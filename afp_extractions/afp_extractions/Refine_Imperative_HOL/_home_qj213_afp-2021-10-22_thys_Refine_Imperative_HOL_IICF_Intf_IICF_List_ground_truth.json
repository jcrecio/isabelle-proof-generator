{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/IICF/Intf/IICF_List.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma param_index[param]: \n  \"\\<lbrakk>single_valued A; single_valued (A\\<inverse>)\\<rbrakk> \\<Longrightarrow> (index,index) \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow> A \\<rightarrow> nat_rel\"", "lemma swap_nth[simp]: \"\\<lbrakk>i < length l; j<length l; k<length l\\<rbrakk> \\<Longrightarrow>\n  swap l i j!k = (\n    if k=i then l!j\n    else if k=j then l!i\n    else l!k\n  )\"", "lemma swap_set[simp]: \"\\<lbrakk> i < length l; j<length l \\<rbrakk> \\<Longrightarrow> set (swap l i j) = set l\"", "lemma swap_multiset[simp]: \"\\<lbrakk> i < length l; j<length l \\<rbrakk> \\<Longrightarrow> mset (swap l i j) = mset l\"", "lemma swap_length[simp]: \"length (swap l i j) = length l\"", "lemma swap_same[simp]: \"swap l i i = l\"", "lemma distinct_swap[simp]: \n  \"\\<lbrakk>i<length l; j<length l\\<rbrakk> \\<Longrightarrow> distinct (swap l i j) = distinct l\"", "lemma map_swap: \"\\<lbrakk>i<length l; j<length l\\<rbrakk> \n  \\<Longrightarrow> map f (swap l i j) = swap (map f l) i j\"", "lemma swap_param[param]: \"\\<lbrakk> i<length l; j<length l; (l',l)\\<in>\\<langle>A\\<rangle>list_rel; (i',i)\\<in>nat_rel; (j',j)\\<in>nat_rel\\<rbrakk>\n  \\<Longrightarrow> (swap l' i' j', swap l i j)\\<in>\\<langle>A\\<rangle>list_rel\"", "lemma swap_param_fref: \"(uncurry2 swap,uncurry2 swap) \\<in> \n  [\\<lambda>((l,i),j). i<length l \\<and> j<length l]\\<^sub>f (\\<langle>A\\<rangle>list_rel \\<times>\\<^sub>r nat_rel) \\<times>\\<^sub>r nat_rel \\<rightarrow> \\<langle>A\\<rangle>list_rel\"", "lemma param_list_null[param]: \"(List.null,List.null) \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow> bool_rel\"", "lemma [def_pat_rules]:\n  \"[] \\<equiv> op_list_empty\"\n  \"(=) $l$[] \\<equiv> op_list_is_empty$l\"\n  \"(=) $[]$l \\<equiv> op_list_is_empty$l\"\n  \"replicate$n$v \\<equiv> op_list_replicate$n$v\"\n  \"Cons$x$xs \\<equiv> op_list_prepend$x$xs\"\n  \"(@) $xs$(Cons$x$[]) \\<equiv> op_list_append$xs$x\"\n  \"(@) $xs$ys \\<equiv> op_list_concat$xs$ys\"\n  \"op_list_concat$xs$(Cons$x$[]) \\<equiv> op_list_append$xs$x\"\n  \"length$xs \\<equiv> op_list_length$xs\"\n  \"nth$l$i \\<equiv> op_list_get$l$i\"\n  \"list_update$l$i$x \\<equiv> op_list_set$l$i$x\"\n  \"hd$l \\<equiv> op_list_hd$l\"\n  \"hd$l \\<equiv> op_list_hd$l\"\n  \"tl$l \\<equiv> op_list_tl$l\"\n  \"tl$l \\<equiv> op_list_tl$l\"\n  \"last$l \\<equiv> op_list_last$l\"\n  \"butlast$l \\<equiv> op_list_butlast$l\"\n  \"(\\<in>) $x$(set$l) \\<equiv> op_list_contains$x$l\"\n  \"swap$l$i$j \\<equiv> op_list_swap$l$i$j\"\n  \"rotate1$l \\<equiv> op_list_rotate1$l\"\n  \"rev$l \\<equiv> op_list_rev$l\"\n  \"index$l$x \\<equiv> op_list_index$l$x\"", "lemma list_rel_pres_neq_nil[fcomp_prenorm_simps]: \"(x',x)\\<in>\\<langle>A\\<rangle>list_rel \\<Longrightarrow> x'\\<noteq>[] \\<longleftrightarrow> x\\<noteq>[]\"", "lemma list_rel_pres_length[fcomp_prenorm_simps]: \"(x',x)\\<in>\\<langle>A\\<rangle>list_rel \\<Longrightarrow> length x' = length x\"", "lemma fold_custom_empty:\n    \"[] = op_custom_empty\"\n    \"op_list_empty = op_custom_empty\"\n    \"mop_list_empty = RETURN op_custom_empty\"", "lemmas custom_hnr[sepref_fr_rules] = customize_hnr_aux[folded op_custom_empty_def]", "lemma gen_mop_list_swap: \"mop_list_swap l i j = do {\n    xi \\<leftarrow> mop_list_get l i;\n    xj \\<leftarrow> mop_list_get l j;\n    l \\<leftarrow> mop_list_set l i xj;\n    l \\<leftarrow> mop_list_set l j xi;\n    RETURN l\n  }\""], "translations": [["", "lemma param_index[param]: \n  \"\\<lbrakk>single_valued A; single_valued (A\\<inverse>)\\<rbrakk> \\<Longrightarrow> (index,index) \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow> A \\<rightarrow> nat_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued A; single_valued (A\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> (index, index)\n                      \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow>\n                            A \\<rightarrow> nat_rel", "unfolding index_def[abs_def] find_index_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued A; single_valued (A\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>xs a.\n                          rec_list (\\<lambda>_. 0)\n                           (\\<lambda>x xs xsa P.\n                               if P x then 0 else xsa P + 1)\n                           xs (\\<lambda>x. x = a),\n                       \\<lambda>xs a.\n                          rec_list (\\<lambda>_. 0)\n                           (\\<lambda>x xs xsa P.\n                               if P x then 0 else xsa P + 1)\n                           xs (\\<lambda>x. x = a))\n                      \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow>\n                            A \\<rightarrow> nat_rel", "apply (subgoal_tac \"(((=), (=)) \\<in> A \\<rightarrow> A \\<rightarrow> bool_rel)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>single_valued A; single_valued (A\\<inverse>);\n     ((=), (=)) \\<in> A \\<rightarrow> A \\<rightarrow> bool_rel\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>xs a.\n                          rec_list (\\<lambda>_. 0)\n                           (\\<lambda>x xs xsa P.\n                               if P x then 0 else xsa P + 1)\n                           xs (\\<lambda>x. x = a),\n                       \\<lambda>xs a.\n                          rec_list (\\<lambda>_. 0)\n                           (\\<lambda>x xs xsa P.\n                               if P x then 0 else xsa P + 1)\n                           xs (\\<lambda>x. x = a))\n                      \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow>\n                            A \\<rightarrow> nat_rel\n 2. \\<lbrakk>single_valued A; single_valued (A\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> ((=), (=))\n                      \\<in> A \\<rightarrow> A \\<rightarrow> bool_rel", "apply parametricity"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued A; single_valued (A\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> ((=), (=))\n                      \\<in> A \\<rightarrow> A \\<rightarrow> bool_rel", "by (simp add: pres_eq_iff_svb)"], ["", "(* TODO: Move? *)"], ["", "subsection \\<open>Swap two elements of a list, by index\\<close>"], ["", "definition \"swap l i j \\<equiv> l[i := l!j, j:=l!i]\""], ["", "lemma swap_nth[simp]: \"\\<lbrakk>i < length l; j<length l; k<length l\\<rbrakk> \\<Longrightarrow>\n  swap l i j!k = (\n    if k=i then l!j\n    else if k=j then l!i\n    else l!k\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length l; j < length l; k < length l\\<rbrakk>\n    \\<Longrightarrow> swap l i j ! k =\n                      (if k = i then l ! j\n                       else if k = j then l ! i else l ! k)", "unfolding swap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length l; j < length l; k < length l\\<rbrakk>\n    \\<Longrightarrow> l[i := l ! j, j := l ! i] ! k =\n                      (if k = i then l ! j\n                       else if k = j then l ! i else l ! k)", "by auto"], ["", "lemma swap_set[simp]: \"\\<lbrakk> i < length l; j<length l \\<rbrakk> \\<Longrightarrow> set (swap l i j) = set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length l; j < length l\\<rbrakk>\n    \\<Longrightarrow> set (swap l i j) = set l", "unfolding swap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length l; j < length l\\<rbrakk>\n    \\<Longrightarrow> set (l[i := l ! j, j := l ! i]) = set l", "by auto"], ["", "lemma swap_multiset[simp]: \"\\<lbrakk> i < length l; j<length l \\<rbrakk> \\<Longrightarrow> mset (swap l i j) = mset l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length l; j < length l\\<rbrakk>\n    \\<Longrightarrow> mset (swap l i j) = mset l", "unfolding swap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length l; j < length l\\<rbrakk>\n    \\<Longrightarrow> mset (l[i := l ! j, j := l ! i]) = mset l", "by (auto simp: mset_swap)"], ["", "lemma swap_length[simp]: \"length (swap l i j) = length l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (swap l i j) = length l", "unfolding swap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (l[i := l ! j, j := l ! i]) = length l", "by auto"], ["", "lemma swap_same[simp]: \"swap l i i = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap l i i = l", "unfolding swap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. l[i := l ! i, i := l ! i] = l", "by auto"], ["", "lemma distinct_swap[simp]: \n  \"\\<lbrakk>i<length l; j<length l\\<rbrakk> \\<Longrightarrow> distinct (swap l i j) = distinct l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length l; j < length l\\<rbrakk>\n    \\<Longrightarrow> distinct (swap l i j) = distinct l", "unfolding swap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length l; j < length l\\<rbrakk>\n    \\<Longrightarrow> distinct (l[i := l ! j, j := l ! i]) = distinct l", "by auto"], ["", "lemma map_swap: \"\\<lbrakk>i<length l; j<length l\\<rbrakk> \n  \\<Longrightarrow> map f (swap l i j) = swap (map f l) i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length l; j < length l\\<rbrakk>\n    \\<Longrightarrow> map f (swap l i j) = swap (map f l) i j", "unfolding swap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length l; j < length l\\<rbrakk>\n    \\<Longrightarrow> map f (l[i := l ! j, j := l ! i]) = (map f l)\n                      [i := map f l ! j, j := map f l ! i]", "by (auto simp add: map_update)"], ["", "lemma swap_param[param]: \"\\<lbrakk> i<length l; j<length l; (l',l)\\<in>\\<langle>A\\<rangle>list_rel; (i',i)\\<in>nat_rel; (j',j)\\<in>nat_rel\\<rbrakk>\n  \\<Longrightarrow> (swap l' i' j', swap l i j)\\<in>\\<langle>A\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length l; j < length l;\n     (l', l) \\<in> \\<langle>A\\<rangle>list_rel; (i', i) \\<in> nat_rel;\n     (j', j) \\<in> nat_rel\\<rbrakk>\n    \\<Longrightarrow> (swap l' i' j', swap l i j)\n                      \\<in> \\<langle>A\\<rangle>list_rel", "unfolding swap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length l; j < length l;\n     (l', l) \\<in> \\<langle>A\\<rangle>list_rel; (i', i) \\<in> nat_rel;\n     (j', j) \\<in> nat_rel\\<rbrakk>\n    \\<Longrightarrow> (l'[i' := l' ! j', j' := l' ! i'], l\n                       [i := l ! j, j := l ! i])\n                      \\<in> \\<langle>A\\<rangle>list_rel", "by parametricity"], ["", "lemma swap_param_fref: \"(uncurry2 swap,uncurry2 swap) \\<in> \n  [\\<lambda>((l,i),j). i<length l \\<and> j<length l]\\<^sub>f (\\<langle>A\\<rangle>list_rel \\<times>\\<^sub>r nat_rel) \\<times>\\<^sub>r nat_rel \\<rightarrow> \\<langle>A\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 swap, uncurry2 swap)\n    \\<in> [\\<lambda>((l, i), j).\n              i < length l \\<and>\n              j < length\n                   l]\\<^sub>f (\\<langle>A\\<rangle>list_rel \\<times>\\<^sub>r\n                               nat_rel) \\<times>\\<^sub>r\n                              nat_rel \\<rightarrow> \\<langle>A\\<rangle>list_rel", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case y of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (l, i) \\<Rightarrow>\n                     \\<lambda>j. i < length l \\<and> j < length l)\n                   xa;\n        (x, y)\n        \\<in> (\\<langle>A\\<rangle>list_rel \\<times>\\<^sub>r\n               nat_rel) \\<times>\\<^sub>r\n              nat_rel\\<rbrakk>\n       \\<Longrightarrow> (uncurry2 swap x, uncurry2 swap y)\n                         \\<in> \\<langle>A\\<rangle>list_rel", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba aa.\n       \\<lbrakk>(a, aa) \\<in> \\<langle>A\\<rangle>list_rel; b < length aa;\n        ba < length aa\\<rbrakk>\n       \\<Longrightarrow> (swap a b ba, swap aa b ba)\n                         \\<in> \\<langle>A\\<rangle>list_rel", "unfolding swap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba aa.\n       \\<lbrakk>(a, aa) \\<in> \\<langle>A\\<rangle>list_rel; b < length aa;\n        ba < length aa\\<rbrakk>\n       \\<Longrightarrow> (a[b := a ! ba, ba := a ! b], aa\n                          [b := aa ! ba, ba := aa ! b])\n                         \\<in> \\<langle>A\\<rangle>list_rel", "apply parametricity"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b ba aa.\n       \\<lbrakk>(a, aa) \\<in> \\<langle>A\\<rangle>list_rel; b < length aa;\n        ba < length aa\\<rbrakk>\n       \\<Longrightarrow> (b, b) \\<in> nat_rel\n 2. \\<And>a b ba aa.\n       \\<lbrakk>(a, aa) \\<in> \\<langle>A\\<rangle>list_rel; b < length aa;\n        ba < length aa\\<rbrakk>\n       \\<Longrightarrow> (ba, ba) \\<in> nat_rel\n 3. \\<And>a b ba aa.\n       \\<lbrakk>(a, aa) \\<in> \\<langle>A\\<rangle>list_rel; b < length aa;\n        ba < length aa\\<rbrakk>\n       \\<Longrightarrow> (ba, ba) \\<in> nat_rel\n 4. \\<And>a b ba aa.\n       \\<lbrakk>(a, aa) \\<in> \\<langle>A\\<rangle>list_rel; b < length aa;\n        ba < length aa\\<rbrakk>\n       \\<Longrightarrow> (b, b) \\<in> nat_rel", "by simp_all"], ["", "lemma param_list_null[param]: \"(List.null,List.null) \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (List.null, List.null)\n    \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow> bool_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (List.null, List.null)\n    \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow> bool_rel", "have 1: \"List.null = (\\<lambda>[] \\<Rightarrow> True | _ \\<Rightarrow> False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.null =\n    (\\<lambda>x.\n        case x of [] \\<Rightarrow> True | a # list \\<Rightarrow> False)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       List.null x =\n       (case x of [] \\<Rightarrow> True | a # list \\<Rightarrow> False)", "subgoal for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.null l =\n    (case l of [] \\<Rightarrow> True | a # list \\<Rightarrow> False)", "by (cases l) (auto simp: List.null_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  List.null =\n  (\\<lambda>x.\n      case x of [] \\<Rightarrow> True | a # list \\<Rightarrow> False)\n\ngoal (1 subgoal):\n 1. (List.null, List.null)\n    \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow> bool_rel", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (List.null, List.null)\n    \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow> bool_rel", "unfolding 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case_list True (\\<lambda>a list. False),\n     case_list True (\\<lambda>a list. False))\n    \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow> bool_rel", "by parametricity"], ["proof (state)\nthis:\n  (List.null, List.null)\n  \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow> bool_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Operations\\<close>"], ["", "sepref_decl_op list_empty: \"[]\" :: \"\\<langle>A\\<rangle>list_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "context notes [simp] = eq_Nil_null begin"], ["", "sepref_decl_op list_is_empty: \"\\<lambda>l. l=[]\" :: \"\\<langle>A\\<rangle>list_rel \\<rightarrow>\\<^sub>f bool_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "sepref_decl_op list_replicate: replicate :: \"nat_rel \\<rightarrow> A \\<rightarrow> \\<langle>A\\<rangle>list_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition op_list_copy :: \"'a list \\<Rightarrow> 'a list\" where [simp]:  \"op_list_copy l \\<equiv> l\""], ["", "sepref_decl_op (no_def) list_copy: \"op_list_copy\" :: \"\\<langle>A\\<rangle>list_rel \\<rightarrow> \\<langle>A\\<rangle>list_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op list_prepend: \"(#)\" :: \"A \\<rightarrow> \\<langle>A\\<rangle>list_rel \\<rightarrow> \\<langle>A\\<rangle>list_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op list_append: \"\\<lambda>xs x. xs@[x]\" :: \"\\<langle>A\\<rangle>list_rel \\<rightarrow> A \\<rightarrow> \\<langle>A\\<rangle>list_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op list_concat: \"(@)\" :: \"\\<langle>A\\<rangle>list_rel \\<rightarrow> \\<langle>A\\<rangle>list_rel \\<rightarrow> \\<langle>A\\<rangle>list_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op list_length: length :: \"\\<langle>A\\<rangle>list_rel \\<rightarrow> nat_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op list_get: nth :: \"[\\<lambda>(l,i). i<length l]\\<^sub>f \\<langle>A\\<rangle>list_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> A\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op list_set: list_update :: \"[\\<lambda>((l,i),_). i<length l]\\<^sub>f (\\<langle>A\\<rangle>list_rel \\<times>\\<^sub>r nat_rel) \\<times>\\<^sub>r A \\<rightarrow> \\<langle>A\\<rangle>list_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "context notes [simp] = eq_Nil_null begin"], ["", "sepref_decl_op list_hd: hd :: \"[\\<lambda>l. l\\<noteq>[]]\\<^sub>f \\<langle>A\\<rangle>list_rel \\<rightarrow> A\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op list_tl: tl :: \"[\\<lambda>l. l\\<noteq>[]]\\<^sub>f \\<langle>A\\<rangle>list_rel \\<rightarrow> \\<langle>A\\<rangle>list_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op list_last: last :: \"[\\<lambda>l. l\\<noteq>[]]\\<^sub>f \\<langle>A\\<rangle>list_rel \\<rightarrow> A\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op list_butlast: butlast :: \"[\\<lambda>l. l\\<noteq>[]]\\<^sub>f \\<langle>A\\<rangle>list_rel \\<rightarrow> \\<langle>A\\<rangle>list_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "sepref_decl_op list_contains: \"\\<lambda>x l. x\\<in>set l\" :: \"A \\<rightarrow> \\<langle>A\\<rangle>list_rel \\<rightarrow> bool_rel\" \n  where \"single_valued A\" \"single_valued (A\\<inverse>)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op list_swap: swap :: \"[\\<lambda>((l,i),j). i<length l \\<and> j<length l]\\<^sub>f (\\<langle>A\\<rangle>list_rel \\<times>\\<^sub>r nat_rel) \\<times>\\<^sub>r nat_rel \\<rightarrow> \\<langle>A\\<rangle>list_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op list_rotate1: rotate1 :: \"\\<langle>A\\<rangle>list_rel \\<rightarrow> \\<langle>A\\<rangle>list_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op list_rev: rev :: \"\\<langle>A\\<rangle>list_rel \\<rightarrow> \\<langle>A\\<rangle>list_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op list_index: index :: \"\\<langle>A\\<rangle>list_rel \\<rightarrow> A \\<rightarrow> nat_rel\" \n  where \"single_valued A\" \"single_valued (A\\<inverse>)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "subsection \\<open>Patterns\\<close>"], ["", "lemma [def_pat_rules]:\n  \"[] \\<equiv> op_list_empty\"\n  \"(=) $l$[] \\<equiv> op_list_is_empty$l\"\n  \"(=) $[]$l \\<equiv> op_list_is_empty$l\"\n  \"replicate$n$v \\<equiv> op_list_replicate$n$v\"\n  \"Cons$x$xs \\<equiv> op_list_prepend$x$xs\"\n  \"(@) $xs$(Cons$x$[]) \\<equiv> op_list_append$xs$x\"\n  \"(@) $xs$ys \\<equiv> op_list_concat$xs$ys\"\n  \"op_list_concat$xs$(Cons$x$[]) \\<equiv> op_list_append$xs$x\"\n  \"length$xs \\<equiv> op_list_length$xs\"\n  \"nth$l$i \\<equiv> op_list_get$l$i\"\n  \"list_update$l$i$x \\<equiv> op_list_set$l$i$x\"\n  \"hd$l \\<equiv> op_list_hd$l\"\n  \"hd$l \\<equiv> op_list_hd$l\"\n  \"tl$l \\<equiv> op_list_tl$l\"\n  \"tl$l \\<equiv> op_list_tl$l\"\n  \"last$l \\<equiv> op_list_last$l\"\n  \"butlast$l \\<equiv> op_list_butlast$l\"\n  \"(\\<in>) $x$(set$l) \\<equiv> op_list_contains$x$l\"\n  \"swap$l$i$j \\<equiv> op_list_swap$l$i$j\"\n  \"rotate1$l \\<equiv> op_list_rotate1$l\"\n  \"rev$l \\<equiv> op_list_rev$l\"\n  \"index$l$x \\<equiv> op_list_index$l$x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((([] \\<equiv> op_list_empty) &&&\n       (=) $ l $ [] \\<equiv> op_list_is_empty $ l) &&&\n      ((=) $ [] $ l \\<equiv> op_list_is_empty $ l) &&&\n      (replicate $ n $ v \\<equiv> op_list_replicate $ n $ v) &&&\n      (#) $ x $ xs \\<equiv> op_list_prepend $ x $ xs) &&&\n     (((@) $ xs $ ((#) $ x $ []) \\<equiv> op_list_append $ xs $ x) &&&\n      ((@) $ xs $ ys \\<equiv> op_list_concat $ xs $ ys) &&&\n      op_list_concat $ xs $ ((#) $ x $ []) \\<equiv>\n      op_list_append $ xs $ x) &&&\n     (length $ xs \\<equiv> op_list_length $ xs) &&&\n     ((!) $ l $ i \\<equiv> op_list_get $ l $ i) &&&\n     list_update $ l $ i $ x \\<equiv> op_list_set $ l $ i $ x) &&&\n    (((hd $ l \\<equiv> op_list_hd $ l) &&&\n      hd $ l \\<equiv> op_list_hd $ l) &&&\n     (tl $ l \\<equiv> op_list_tl $ l) &&&\n     (tl $ l \\<equiv> op_list_tl $ l) &&&\n     last $ l \\<equiv> op_list_last $ l) &&&\n    ((butlast $ l \\<equiv> op_list_butlast $ l) &&&\n     ((\\<in>) $ x $ (set $ l) \\<equiv> op_list_contains $ x $ l) &&&\n     swap $ l $ i $ j \\<equiv> op_list_swap $ l $ i $ j) &&&\n    (rotate1 $ l \\<equiv> op_list_rotate1 $ l) &&&\n    (rev $ l \\<equiv> op_list_rev $ l) &&&\n    index $ l $ x \\<equiv> op_list_index $ l $ x", "by (auto intro!: eq_reflection)"], ["", "text \\<open>Standard preconditions are preserved by list-relation. These lemmas are used for\n  simplification of preconditions after composition.\\<close>"], ["", "lemma list_rel_pres_neq_nil[fcomp_prenorm_simps]: \"(x',x)\\<in>\\<langle>A\\<rangle>list_rel \\<Longrightarrow> x'\\<noteq>[] \\<longleftrightarrow> x\\<noteq>[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x', x) \\<in> \\<langle>A\\<rangle>list_rel \\<Longrightarrow>\n    (x' \\<noteq> []) = (x \\<noteq> [])", "by auto"], ["", "lemma list_rel_pres_length[fcomp_prenorm_simps]: \"(x',x)\\<in>\\<langle>A\\<rangle>list_rel \\<Longrightarrow> length x' = length x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x', x) \\<in> \\<langle>A\\<rangle>list_rel \\<Longrightarrow>\n    length x' = length x", "by (rule list_rel_imp_same_length)"], ["", "locale list_custom_empty = \n  fixes rel empty and op_custom_empty :: \"'a list\"\n  assumes customize_hnr_aux: \"(uncurry0 empty,uncurry0 (RETURN (op_list_empty::'a list))) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a rel\"\n  assumes op_custom_empty_def: \"op_custom_empty = op_list_empty\"\nbegin"], ["", "sepref_register op_custom_empty :: \"'c list\""], ["", "lemma fold_custom_empty:\n    \"[] = op_custom_empty\"\n    \"op_list_empty = op_custom_empty\"\n    \"mop_list_empty = RETURN op_custom_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] = op_custom_empty &&&\n    op_list_empty = op_custom_empty &&&\n    mop_list_empty = RETURN op_custom_empty", "unfolding op_custom_empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] = op_list_empty &&&\n    op_list_empty = op_list_empty &&& mop_list_empty = RETURN op_list_empty", "by simp_all"], ["", "lemmas custom_hnr[sepref_fr_rules] = customize_hnr_aux[folded op_custom_empty_def]"], ["", "end"], ["", "lemma gen_mop_list_swap: \"mop_list_swap l i j = do {\n    xi \\<leftarrow> mop_list_get l i;\n    xj \\<leftarrow> mop_list_get l j;\n    l \\<leftarrow> mop_list_set l i xj;\n    l \\<leftarrow> mop_list_set l j xi;\n    RETURN l\n  }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mop_list_swap l i j =\n    mop_list_get l i \\<bind>\n    (\\<lambda>xi.\n        mop_list_get l j \\<bind>\n        (\\<lambda>xj.\n            mop_list_set l i xj \\<bind>\n            (\\<lambda>l. mop_list_set l j xi \\<bind> RETURN)))", "unfolding mop_list_swap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. curry2\n     (mop pre_list_swap\n       (uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_list_swap)))\n     l i j =\n    mop_list_get l i \\<bind>\n    (\\<lambda>xi.\n        mop_list_get l j \\<bind>\n        (\\<lambda>xj.\n            mop_list_set l i xj \\<bind>\n            (\\<lambda>l. mop_list_set l j xi \\<bind> RETURN)))", "by (auto simp: pw_eq_iff refine_pw_simps swap_def)"], ["", "end"]]}