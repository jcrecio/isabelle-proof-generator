{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/IICF/Intf/IICF_Map.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma bi_total_map_rel_eq:\n  \"\\<lbrakk>IS_RIGHT_TOTAL K; IS_LEFT_TOTAL K\\<rbrakk> \\<Longrightarrow> \\<langle>K,V\\<rangle>map_rel = K \\<rightarrow> \\<langle>V\\<rangle>option_rel\"", "lemma map_rel_Id[simp]: \"\\<langle>Id,Id\\<rangle>map_rel = Id\"", "lemma map_rel_empty1_simp[simp]: \n  \"(Map.empty,m)\\<in>\\<langle>K,V\\<rangle>map_rel \\<longleftrightarrow> m=Map.empty\"", "lemma map_rel_empty2_simp[simp]: \n  \"(m,Map.empty)\\<in>\\<langle>K,V\\<rangle>map_rel \\<longleftrightarrow> m=Map.empty\"", "lemma map_rel_obtain1:\n  assumes 1: \"(m,n)\\<in>\\<langle>K,V\\<rangle>map_rel\"\n  assumes 2: \"n l = Some w\"\n  obtains k v where \"m k = Some v\" \"(k,l)\\<in>K\" \"(v,w)\\<in>V\"", "lemma map_rel_obtain2:\n  assumes 1: \"(m,n)\\<in>\\<langle>K,V\\<rangle>map_rel\"\n  assumes 2: \"m k = Some v\"\n  obtains l w where \"n l = Some w\" \"(k,l)\\<in>K\" \"(v,w)\\<in>V\"", "lemma param_dom[param]: \"(dom,dom)\\<in>\\<langle>K,V\\<rangle>map_rel \\<rightarrow> \\<langle>K\\<rangle>set_rel\"", "lemma [synth_rules]: \"\\<lbrakk>INTF_OF_REL K TYPE('k); INTF_OF_REL V TYPE('v)\\<rbrakk> \n  \\<Longrightarrow> INTF_OF_REL (\\<langle>K,V\\<rangle>map_rel) TYPE(('k,'v) i_map)\"", "lemma in_dom_alt: \"k\\<in>dom m \\<longleftrightarrow> \\<not>is_None (m k)\"", "lemma pat_map_empty[pat_rules]: \"\\<lambda>\\<^sub>2_. None \\<equiv> op_map_empty\"", "lemma pat_map_is_empty[pat_rules]: \n  \"(=) $m$(\\<lambda>\\<^sub>2_. None) \\<equiv> op_map_is_empty$m\" \n  \"(=) $(\\<lambda>\\<^sub>2_. None)$m \\<equiv> op_map_is_empty$m\" \n  \"(=) $(dom$m)${} \\<equiv> op_map_is_empty$m\"\n  \"(=) ${}$(dom$m) \\<equiv> op_map_is_empty$m\"", "lemma pat_map_update[pat_rules]: \n  \"fun_upd$m$k$(Some$v) \\<equiv> op_map_update$'k$'v$'m\"", "lemma pat_map_lookup[pat_rules]: \"m$k \\<equiv> op_map_lookup$'k$'m\"", "lemma op_map_delete_pat[pat_rules]: \n  \"(|`) $ m $ (uminus $ (insert $ k $ {})) \\<equiv> op_map_delete$'k$'m\"\n  \"fun_upd$m$k$None \\<equiv> op_map_delete$'k$'m\"", "lemma op_map_contains_key[pat_rules]: \n  \"(\\<in>) $ k $ (dom$m) \\<equiv> op_map_contains_key$'k$'m\"\n  \"Not$((=) $(m$k)$None) \\<equiv> op_map_contains_key$'k$'m\"", "lemma fold_custom_empty:\n    \"Map.empty = op_custom_empty\"\n    \"op_map_empty = op_custom_empty\"\n    \"mop_map_empty = RETURN op_custom_empty\""], "translations": [["", "lemma bi_total_map_rel_eq:\n  \"\\<lbrakk>IS_RIGHT_TOTAL K; IS_LEFT_TOTAL K\\<rbrakk> \\<Longrightarrow> \\<langle>K,V\\<rangle>map_rel = K \\<rightarrow> \\<langle>V\\<rangle>option_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IS_RIGHT_TOTAL K; IS_LEFT_TOTAL K\\<rbrakk>\n    \\<Longrightarrow> \\<langle>K, V\\<rangle>map_rel =\n                      K \\<rightarrow> \\<langle>V\\<rangle>option_rel", "unfolding map_rel_def IS_RIGHT_TOTAL_def IS_LEFT_TOTAL_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Range K = UNIV; Domain K = UNIV\\<rbrakk>\n    \\<Longrightarrow> (K \\<rightarrow>\n                       \\<langle>V\\<rangle>option_rel) \\<inter>\n                      {(mi, m).\n                       dom mi \\<subseteq> Domain K \\<and>\n                       dom m \\<subseteq> Range K} =\n                      K \\<rightarrow> \\<langle>V\\<rangle>option_rel", "by (auto dest: fun_relD)"], ["", "lemma map_rel_Id[simp]: \"\\<langle>Id,Id\\<rangle>map_rel = Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Id, Id\\<rangle>map_rel = Id", "unfolding map_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Id \\<rightarrow> \\<langle>Id\\<rangle>option_rel) \\<inter>\n    {(mi, m).\n     dom mi \\<subseteq> Domain Id \\<and> dom m \\<subseteq> Range Id} =\n    Id", "by auto"], ["", "lemma map_rel_empty1_simp[simp]: \n  \"(Map.empty,m)\\<in>\\<langle>K,V\\<rangle>map_rel \\<longleftrightarrow> m=Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Map.empty, m) \\<in> \\<langle>K, V\\<rangle>map_rel) = (m = Map.empty)", "apply (auto simp: map_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Map.empty, m)\n             \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n     dom m \\<subseteq> Range K\\<rbrakk>\n    \\<Longrightarrow> m = Map.empty", "by (meson RangeE domIff option_rel_simp(1) subsetCE tagged_fun_relD_none)"], ["", "lemma map_rel_empty2_simp[simp]: \n  \"(m,Map.empty)\\<in>\\<langle>K,V\\<rangle>map_rel \\<longleftrightarrow> m=Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((m, Map.empty) \\<in> \\<langle>K, V\\<rangle>map_rel) = (m = Map.empty)", "apply (auto simp: map_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(m, Map.empty)\n             \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n     dom m \\<subseteq> Domain K\\<rbrakk>\n    \\<Longrightarrow> m = Map.empty", "by (meson Domain.cases domIff fun_relD2 option_rel_simp(2) subset_eq)"], ["", "lemma map_rel_obtain1:\n  assumes 1: \"(m,n)\\<in>\\<langle>K,V\\<rangle>map_rel\"\n  assumes 2: \"n l = Some w\"\n  obtains k v where \"m k = Some v\" \"(k,l)\\<in>K\" \"(v,w)\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        \\<lbrakk>m k = Some v; (k, l) \\<in> K; (v, w) \\<in> V\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 1"], ["proof (prove)\nusing this:\n  (m, n) \\<in> \\<langle>K, V\\<rangle>map_rel\n\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        \\<lbrakk>m k = Some v; (k, l) \\<in> K; (v, w) \\<in> V\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding map_rel_def"], ["proof (prove)\nusing this:\n  (m, n)\n  \\<in> (K \\<rightarrow> \\<langle>V\\<rangle>option_rel) \\<inter>\n        {(mi, m).\n         dom mi \\<subseteq> Domain K \\<and> dom m \\<subseteq> Range K}\n\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        \\<lbrakk>m k = Some v; (k, l) \\<in> K; (v, w) \\<in> V\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k v.\n                \\<lbrakk>m k = Some v; (k, l) \\<in> K;\n                 (v, w) \\<in> V\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (m, n) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n     dom m \\<subseteq> Domain K; dom n \\<subseteq> Range K\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume R: \"(m, n) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel\""], ["proof (state)\nthis:\n  (m, n) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k v.\n                \\<lbrakk>m k = Some v; (k, l) \\<in> K;\n                 (v, w) \\<in> V\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (m, n) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n     dom m \\<subseteq> Domain K; dom n \\<subseteq> Range K\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume \"dom n \\<subseteq> Range K\""], ["proof (state)\nthis:\n  dom n \\<subseteq> Range K\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k v.\n                \\<lbrakk>m k = Some v; (k, l) \\<in> K;\n                 (v, w) \\<in> V\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (m, n) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n     dom m \\<subseteq> Domain K; dom n \\<subseteq> Range K\\<rbrakk>\n    \\<Longrightarrow> thesis", "with 2"], ["proof (chain)\npicking this:\n  n l = Some w\n  dom n \\<subseteq> Range K", "obtain k where \"(k,l)\\<in>K\""], ["proof (prove)\nusing this:\n  n l = Some w\n  dom n \\<subseteq> Range K\n\ngoal (1 subgoal):\n 1. (\\<And>k. (k, l) \\<in> K \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (k, l) \\<in> K\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k v.\n                \\<lbrakk>m k = Some v; (k, l) \\<in> K;\n                 (v, w) \\<in> V\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (m, n) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n     dom m \\<subseteq> Domain K; dom n \\<subseteq> Range K\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  (k, l) \\<in> K\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k v.\n                \\<lbrakk>m k = Some v; (k, l) \\<in> K;\n                 (v, w) \\<in> V\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (m, n) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n     dom m \\<subseteq> Domain K; dom n \\<subseteq> Range K\\<rbrakk>\n    \\<Longrightarrow> thesis", "from fun_relD[OF R this]"], ["proof (chain)\npicking this:\n  (m k, n l) \\<in> \\<langle>V\\<rangle>option_rel", "have \"(m k, n l) \\<in> \\<langle>V\\<rangle>option_rel\""], ["proof (prove)\nusing this:\n  (m k, n l) \\<in> \\<langle>V\\<rangle>option_rel\n\ngoal (1 subgoal):\n 1. (m k, n l) \\<in> \\<langle>V\\<rangle>option_rel", "."], ["proof (state)\nthis:\n  (m k, n l) \\<in> \\<langle>V\\<rangle>option_rel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k v.\n                \\<lbrakk>m k = Some v; (k, l) \\<in> K;\n                 (v, w) \\<in> V\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (m, n) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n     dom m \\<subseteq> Domain K; dom n \\<subseteq> Range K\\<rbrakk>\n    \\<Longrightarrow> thesis", "with 2"], ["proof (chain)\npicking this:\n  n l = Some w\n  (m k, n l) \\<in> \\<langle>V\\<rangle>option_rel", "obtain v where \"m k = Some v\" \"(v,w)\\<in>V\""], ["proof (prove)\nusing this:\n  n l = Some w\n  (m k, n l) \\<in> \\<langle>V\\<rangle>option_rel\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>m k = Some v; (v, w) \\<in> V\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"m k\"; auto)"], ["proof (state)\nthis:\n  m k = Some v\n  (v, w) \\<in> V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k v.\n                \\<lbrakk>m k = Some v; (k, l) \\<in> K;\n                 (v, w) \\<in> V\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (m, n) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n     dom m \\<subseteq> Domain K; dom n \\<subseteq> Range K\\<rbrakk>\n    \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  (k, l) \\<in> K\n  m k = Some v\n  (v, w) \\<in> V", "show thesis"], ["proof (prove)\nusing this:\n  (k, l) \\<in> K\n  m k = Some v\n  (v, w) \\<in> V\n\ngoal (1 subgoal):\n 1. thesis", "by - (rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_rel_obtain2:\n  assumes 1: \"(m,n)\\<in>\\<langle>K,V\\<rangle>map_rel\"\n  assumes 2: \"m k = Some v\"\n  obtains l w where \"n l = Some w\" \"(k,l)\\<in>K\" \"(v,w)\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l w.\n        \\<lbrakk>n l = Some w; (k, l) \\<in> K; (v, w) \\<in> V\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 1"], ["proof (prove)\nusing this:\n  (m, n) \\<in> \\<langle>K, V\\<rangle>map_rel\n\ngoal (1 subgoal):\n 1. (\\<And>l w.\n        \\<lbrakk>n l = Some w; (k, l) \\<in> K; (v, w) \\<in> V\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding map_rel_def"], ["proof (prove)\nusing this:\n  (m, n)\n  \\<in> (K \\<rightarrow> \\<langle>V\\<rangle>option_rel) \\<inter>\n        {(mi, m).\n         dom mi \\<subseteq> Domain K \\<and> dom m \\<subseteq> Range K}\n\ngoal (1 subgoal):\n 1. (\\<And>l w.\n        \\<lbrakk>n l = Some w; (k, l) \\<in> K; (v, w) \\<in> V\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>l w.\n                \\<lbrakk>n l = Some w; (k, l) \\<in> K;\n                 (v, w) \\<in> V\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (m, n) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n     dom m \\<subseteq> Domain K; dom n \\<subseteq> Range K\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume R: \"(m, n) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel\""], ["proof (state)\nthis:\n  (m, n) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>l w.\n                \\<lbrakk>n l = Some w; (k, l) \\<in> K;\n                 (v, w) \\<in> V\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (m, n) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n     dom m \\<subseteq> Domain K; dom n \\<subseteq> Range K\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume \"dom m \\<subseteq> Domain K\""], ["proof (state)\nthis:\n  dom m \\<subseteq> Domain K\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>l w.\n                \\<lbrakk>n l = Some w; (k, l) \\<in> K;\n                 (v, w) \\<in> V\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (m, n) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n     dom m \\<subseteq> Domain K; dom n \\<subseteq> Range K\\<rbrakk>\n    \\<Longrightarrow> thesis", "with 2"], ["proof (chain)\npicking this:\n  m k = Some v\n  dom m \\<subseteq> Domain K", "obtain l where \"(k,l)\\<in>K\""], ["proof (prove)\nusing this:\n  m k = Some v\n  dom m \\<subseteq> Domain K\n\ngoal (1 subgoal):\n 1. (\\<And>l. (k, l) \\<in> K \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (k, l) \\<in> K\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>l w.\n                \\<lbrakk>n l = Some w; (k, l) \\<in> K;\n                 (v, w) \\<in> V\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (m, n) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n     dom m \\<subseteq> Domain K; dom n \\<subseteq> Range K\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  (k, l) \\<in> K\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>l w.\n                \\<lbrakk>n l = Some w; (k, l) \\<in> K;\n                 (v, w) \\<in> V\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (m, n) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n     dom m \\<subseteq> Domain K; dom n \\<subseteq> Range K\\<rbrakk>\n    \\<Longrightarrow> thesis", "from fun_relD[OF R this]"], ["proof (chain)\npicking this:\n  (m k, n l) \\<in> \\<langle>V\\<rangle>option_rel", "have \"(m k, n l) \\<in> \\<langle>V\\<rangle>option_rel\""], ["proof (prove)\nusing this:\n  (m k, n l) \\<in> \\<langle>V\\<rangle>option_rel\n\ngoal (1 subgoal):\n 1. (m k, n l) \\<in> \\<langle>V\\<rangle>option_rel", "."], ["proof (state)\nthis:\n  (m k, n l) \\<in> \\<langle>V\\<rangle>option_rel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>l w.\n                \\<lbrakk>n l = Some w; (k, l) \\<in> K;\n                 (v, w) \\<in> V\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (m, n) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n     dom m \\<subseteq> Domain K; dom n \\<subseteq> Range K\\<rbrakk>\n    \\<Longrightarrow> thesis", "with 2"], ["proof (chain)\npicking this:\n  m k = Some v\n  (m k, n l) \\<in> \\<langle>V\\<rangle>option_rel", "obtain w where \"n l = Some w\" \"(v,w)\\<in>V\""], ["proof (prove)\nusing this:\n  m k = Some v\n  (m k, n l) \\<in> \\<langle>V\\<rangle>option_rel\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>n l = Some w; (v, w) \\<in> V\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"n l\"; auto)"], ["proof (state)\nthis:\n  n l = Some w\n  (v, w) \\<in> V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>l w.\n                \\<lbrakk>n l = Some w; (k, l) \\<in> K;\n                 (v, w) \\<in> V\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (m, n) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n     dom m \\<subseteq> Domain K; dom n \\<subseteq> Range K\\<rbrakk>\n    \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  (k, l) \\<in> K\n  n l = Some w\n  (v, w) \\<in> V", "show thesis"], ["proof (prove)\nusing this:\n  (k, l) \\<in> K\n  n l = Some w\n  (v, w) \\<in> V\n\ngoal (1 subgoal):\n 1. thesis", "by - (rule that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma param_dom[param]: \"(dom,dom)\\<in>\\<langle>K,V\\<rangle>map_rel \\<rightarrow> \\<langle>K\\<rangle>set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dom, dom)\n    \\<in> \\<langle>K, V\\<rangle>map_rel \\<rightarrow>\n          \\<langle>K\\<rangle>set_rel", "apply (clarsimp simp: set_rel_def; safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' x y.\n       \\<lbrakk>(a, a') \\<in> \\<langle>K, V\\<rangle>map_rel;\n        a x = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<in>dom a'. (x, y) \\<in> K\n 2. \\<And>a a' y ya.\n       \\<lbrakk>(a, a') \\<in> \\<langle>K, V\\<rangle>map_rel;\n        a' y = Some ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>dom a. (x, y) \\<in> K", "apply (erule (1) map_rel_obtain2; auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' y ya.\n       \\<lbrakk>(a, a') \\<in> \\<langle>K, V\\<rangle>map_rel;\n        a' y = Some ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>dom a. (x, y) \\<in> K", "apply (erule (1) map_rel_obtain1; auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Interface Type\\<close>"], ["", "sepref_decl_intf ('k,'v) i_map is \"'k \\<rightharpoonup> 'v\""], ["", "lemma [synth_rules]: \"\\<lbrakk>INTF_OF_REL K TYPE('k); INTF_OF_REL V TYPE('v)\\<rbrakk> \n  \\<Longrightarrow> INTF_OF_REL (\\<langle>K,V\\<rangle>map_rel) TYPE(('k,'v) i_map)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>INTF_OF_REL K TYPE('k); INTF_OF_REL V TYPE('v)\\<rbrakk>\n    \\<Longrightarrow> INTF_OF_REL (\\<langle>K, V\\<rangle>map_rel)\n                       TYPE(('k, 'v) i_map)", "by simp"], ["", "subsection \\<open>Operations\\<close>"], ["", "sepref_decl_op map_empty: \"Map.empty\" :: \"\\<langle>K,V\\<rangle>map_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op map_is_empty: \"(=) Map.empty\" :: \"\\<langle>K,V\\<rangle>map_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((RETURN \\<circ>\\<circ> (=)) Map.empty,\n     (RETURN \\<circ>\\<circ> (=)) Map.empty)\n    \\<in> \\<langle>K,\n    V\\<rangle>map_rel \\<rightarrow>\\<^sub>f \\<langle>bool_rel\\<rangle>nres_rel", "apply (rule fref_ncI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((RETURN \\<circ>\\<circ> (=)) Map.empty,\n     (RETURN \\<circ>\\<circ> (=)) Map.empty)\n    \\<in> \\<langle>K, V\\<rangle>map_rel \\<rightarrow>\n          \\<langle>bool_rel\\<rangle>nres_rel", "apply parametricity"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) Map.empty, (=) Map.empty)\n    \\<in> \\<langle>K, V\\<rangle>map_rel \\<rightarrow> bool_rel", "apply (rule fun_relI; auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_decl_op map_update: \"\\<lambda>k v m. m(k\\<mapsto>v)\" :: \"K \\<rightarrow> V \\<rightarrow> \\<langle>K,V\\<rangle>map_rel \\<rightarrow> \\<langle>K,V\\<rangle>map_rel\"\n    where \"single_valued K\" \"single_valued (K\\<inverse>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued K; single_valued (K\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> (uncurry2\n                        (\\<lambda>x1 x2.\n                            RETURN \\<circ>\n                            (\\<lambda>m. m(x1 \\<mapsto> x2))),\n                       uncurry2\n                        (\\<lambda>x1 x2.\n                            RETURN \\<circ>\n                            (\\<lambda>m. m(x1 \\<mapsto> x2))))\n                      \\<in> (K \\<times>\\<^sub>r V) \\<times>\\<^sub>r\n                            \\<langle>K,\n                            V\\<rangle>map_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>K,\n                      V\\<rangle>map_rel\\<rangle>nres_rel", "apply (rule fref_ncI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued K; single_valued (K\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> (uncurry2\n                        (\\<lambda>x1 x2.\n                            RETURN \\<circ>\n                            (\\<lambda>m. m(x1 \\<mapsto> x2))),\n                       uncurry2\n                        (\\<lambda>x1 x2.\n                            RETURN \\<circ>\n                            (\\<lambda>m. m(x1 \\<mapsto> x2))))\n                      \\<in> (K \\<times>\\<^sub>r V) \\<times>\\<^sub>r\n                            \\<langle>K, V\\<rangle>map_rel \\<rightarrow>\n                            \\<langle>\\<langle>K,\n                            V\\<rangle>map_rel\\<rangle>nres_rel", "apply parametricity"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>single_valued K; single_valued (K\\<inverse>);\n        (a, a') \\<in> K; (aa, a'a) \\<in> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>m. m(a \\<mapsto> aa),\n                          \\<lambda>m. m(a' \\<mapsto> a'a))\n                         \\<in> \\<langle>K, V\\<rangle>map_rel \\<rightarrow>\n                               \\<langle>K, V\\<rangle>map_rel", "unfolding map_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>single_valued K; single_valued (K\\<inverse>);\n        (a, a') \\<in> K; (aa, a'a) \\<in> V\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>m. m(a \\<mapsto> aa),\n                          \\<lambda>m. m(a' \\<mapsto> a'a))\n                         \\<in> (K \\<rightarrow>\n                                \\<langle>V\\<rangle>option_rel) \\<inter>\n                               {(mi, m).\n                                dom mi \\<subseteq> Domain K \\<and>\n                                dom m \\<subseteq> Range K} \\<rightarrow>\n                               (K \\<rightarrow>\n                                \\<langle>V\\<rangle>option_rel) \\<inter>\n                               {(mi, m).\n                                dom mi \\<subseteq> Domain K \\<and>\n                                dom m \\<subseteq> Range K}", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>single_valued K; single_valued (K\\<inverse>);\n        (a, a') \\<in> K; (aa, a'a) \\<in> V;\n        (ab, a'b)\n        \\<in> (K \\<rightarrow> \\<langle>V\\<rangle>option_rel) \\<inter>\n              {(mi, m).\n               dom mi \\<subseteq> Domain K \\<and>\n               dom m \\<subseteq> Range K}\\<rbrakk>\n       \\<Longrightarrow> (ab(a \\<mapsto> aa), a'b(a' \\<mapsto> a'a))\n                         \\<in> (K \\<rightarrow>\n                                \\<langle>V\\<rangle>option_rel) \\<inter>\n                               {(mi, m).\n                                dom mi \\<subseteq> Domain K \\<and>\n                                dom m \\<subseteq> Range K}", "apply (elim IntE; rule IntI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>single_valued K; single_valued (K\\<inverse>);\n        (a, a') \\<in> K; (aa, a'a) \\<in> V;\n        (ab, a'b) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n        (ab, a'b)\n        \\<in> {(mi, m).\n               dom mi \\<subseteq> Domain K \\<and>\n               dom m \\<subseteq> Range K}\\<rbrakk>\n       \\<Longrightarrow> (ab(a \\<mapsto> aa), a'b(a' \\<mapsto> a'a))\n                         \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel\n 2. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>single_valued K; single_valued (K\\<inverse>);\n        (a, a') \\<in> K; (aa, a'a) \\<in> V;\n        (ab, a'b) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n        (ab, a'b)\n        \\<in> {(mi, m).\n               dom mi \\<subseteq> Domain K \\<and>\n               dom m \\<subseteq> Range K}\\<rbrakk>\n       \\<Longrightarrow> (ab(a \\<mapsto> aa), a'b(a' \\<mapsto> a'a))\n                         \\<in> {(mi, m).\n                                dom mi \\<subseteq> Domain K \\<and>\n                                dom m \\<subseteq> Range K}", "apply (intro fun_relI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' aa a'a ab a'b ac a'c.\n       \\<lbrakk>single_valued K; single_valued (K\\<inverse>);\n        (a, a') \\<in> K; (aa, a'a) \\<in> V;\n        (ab, a'b) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n        (ab, a'b)\n        \\<in> {(mi, m).\n               dom mi \\<subseteq> Domain K \\<and>\n               dom m \\<subseteq> Range K};\n        (ac, a'c) \\<in> K\\<rbrakk>\n       \\<Longrightarrow> ((ab(a \\<mapsto> aa)) ac,\n                          (a'b(a' \\<mapsto> a'a)) a'c)\n                         \\<in> \\<langle>V\\<rangle>option_rel\n 2. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>single_valued K; single_valued (K\\<inverse>);\n        (a, a') \\<in> K; (aa, a'a) \\<in> V;\n        (ab, a'b) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n        (ab, a'b)\n        \\<in> {(mi, m).\n               dom mi \\<subseteq> Domain K \\<and>\n               dom m \\<subseteq> Range K}\\<rbrakk>\n       \\<Longrightarrow> (ab(a \\<mapsto> aa), a'b(a' \\<mapsto> a'a))\n                         \\<in> {(mi, m).\n                                dom mi \\<subseteq> Domain K \\<and>\n                                dom m \\<subseteq> Range K}", "apply parametricity"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' aa a'a ab a'b ac a'c.\n       \\<lbrakk>single_valued K; single_valued (K\\<inverse>);\n        (a, a') \\<in> K; (aa, a'a) \\<in> V;\n        (ab, a'b) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n        (ab, a'b)\n        \\<in> {(mi, m).\n               dom mi \\<subseteq> Domain K \\<and>\n               dom m \\<subseteq> Range K};\n        (ac, a'c) \\<in> K\\<rbrakk>\n       \\<Longrightarrow> ((=), (=))\n                         \\<in> K \\<rightarrow> K \\<rightarrow> bool_rel\n 2. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>single_valued K; single_valued (K\\<inverse>);\n        (a, a') \\<in> K; (aa, a'a) \\<in> V;\n        (ab, a'b) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n        (ab, a'b)\n        \\<in> {(mi, m).\n               dom mi \\<subseteq> Domain K \\<and>\n               dom m \\<subseteq> Range K}\\<rbrakk>\n       \\<Longrightarrow> (ab(a \\<mapsto> aa), a'b(a' \\<mapsto> a'a))\n                         \\<in> {(mi, m).\n                                dom mi \\<subseteq> Domain K \\<and>\n                                dom m \\<subseteq> Range K}", "apply (simp add: pres_eq_iff_svb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>single_valued K; single_valued (K\\<inverse>);\n        (a, a') \\<in> K; (aa, a'a) \\<in> V;\n        (ab, a'b) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n        (ab, a'b)\n        \\<in> {(mi, m).\n               dom mi \\<subseteq> Domain K \\<and>\n               dom m \\<subseteq> Range K}\\<rbrakk>\n       \\<Longrightarrow> (ab(a \\<mapsto> aa), a'b(a' \\<mapsto> a'a))\n                         \\<in> {(mi, m).\n                                dom mi \\<subseteq> Domain K \\<and>\n                                dom m \\<subseteq> Range K}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_decl_op map_delete: \"\\<lambda>k m. fun_upd m k None\" :: \"K \\<rightarrow> \\<langle>K,V\\<rangle>map_rel \\<rightarrow> \\<langle>K,V\\<rangle>map_rel\"\n    where \"single_valued K\" \"single_valued (K\\<inverse>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued K; single_valued (K\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> (uncurry\n                        (\\<lambda>x1.\n                            RETURN \\<circ> (\\<lambda>m. m(x1 := None))),\n                       uncurry\n                        (\\<lambda>x1.\n                            RETURN \\<circ> (\\<lambda>m. m(x1 := None))))\n                      \\<in> K \\<times>\\<^sub>r \\<langle>K,\n                            V\\<rangle>map_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>K,\n                      V\\<rangle>map_rel\\<rangle>nres_rel", "apply (rule fref_ncI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued K; single_valued (K\\<inverse>)\\<rbrakk>\n    \\<Longrightarrow> (uncurry\n                        (\\<lambda>x1.\n                            RETURN \\<circ> (\\<lambda>m. m(x1 := None))),\n                       uncurry\n                        (\\<lambda>x1.\n                            RETURN \\<circ> (\\<lambda>m. m(x1 := None))))\n                      \\<in> K \\<times>\\<^sub>r \\<langle>K,\n                            V\\<rangle>map_rel \\<rightarrow>\n                            \\<langle>\\<langle>K,\n                            V\\<rangle>map_rel\\<rangle>nres_rel", "apply parametricity"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>single_valued K; single_valued (K\\<inverse>);\n        (a, a') \\<in> K\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>m. m(a := None),\n                          \\<lambda>m. m(a' := None))\n                         \\<in> \\<langle>K, V\\<rangle>map_rel \\<rightarrow>\n                               \\<langle>K, V\\<rangle>map_rel", "unfolding map_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>single_valued K; single_valued (K\\<inverse>);\n        (a, a') \\<in> K\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>m. m(a := None),\n                          \\<lambda>m. m(a' := None))\n                         \\<in> (K \\<rightarrow>\n                                \\<langle>V\\<rangle>option_rel) \\<inter>\n                               {(mi, m).\n                                dom mi \\<subseteq> Domain K \\<and>\n                                dom m \\<subseteq> Range K} \\<rightarrow>\n                               (K \\<rightarrow>\n                                \\<langle>V\\<rangle>option_rel) \\<inter>\n                               {(mi, m).\n                                dom mi \\<subseteq> Domain K \\<and>\n                                dom m \\<subseteq> Range K}", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>single_valued K; single_valued (K\\<inverse>);\n        (a, a') \\<in> K;\n        (aa, a'a)\n        \\<in> (K \\<rightarrow> \\<langle>V\\<rangle>option_rel) \\<inter>\n              {(mi, m).\n               dom mi \\<subseteq> Domain K \\<and>\n               dom m \\<subseteq> Range K}\\<rbrakk>\n       \\<Longrightarrow> (aa(a := None), a'a(a' := None))\n                         \\<in> (K \\<rightarrow>\n                                \\<langle>V\\<rangle>option_rel) \\<inter>\n                               {(mi, m).\n                                dom mi \\<subseteq> Domain K \\<and>\n                                dom m \\<subseteq> Range K}", "apply (elim IntE; rule IntI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>single_valued K; single_valued (K\\<inverse>);\n        (a, a') \\<in> K;\n        (aa, a'a) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n        (aa, a'a)\n        \\<in> {(mi, m).\n               dom mi \\<subseteq> Domain K \\<and>\n               dom m \\<subseteq> Range K}\\<rbrakk>\n       \\<Longrightarrow> (aa(a := None), a'a(a' := None))\n                         \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>single_valued K; single_valued (K\\<inverse>);\n        (a, a') \\<in> K;\n        (aa, a'a) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n        (aa, a'a)\n        \\<in> {(mi, m).\n               dom mi \\<subseteq> Domain K \\<and>\n               dom m \\<subseteq> Range K}\\<rbrakk>\n       \\<Longrightarrow> (aa(a := None), a'a(a' := None))\n                         \\<in> {(mi, m).\n                                dom mi \\<subseteq> Domain K \\<and>\n                                dom m \\<subseteq> Range K}", "apply (intro fun_relI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>single_valued K; single_valued (K\\<inverse>);\n        (a, a') \\<in> K;\n        (aa, a'a) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n        (aa, a'a)\n        \\<in> {(mi, m).\n               dom mi \\<subseteq> Domain K \\<and>\n               dom m \\<subseteq> Range K};\n        (ab, a'b) \\<in> K\\<rbrakk>\n       \\<Longrightarrow> ((aa(a := None)) ab, (a'a(a' := None)) a'b)\n                         \\<in> \\<langle>V\\<rangle>option_rel\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>single_valued K; single_valued (K\\<inverse>);\n        (a, a') \\<in> K;\n        (aa, a'a) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n        (aa, a'a)\n        \\<in> {(mi, m).\n               dom mi \\<subseteq> Domain K \\<and>\n               dom m \\<subseteq> Range K}\\<rbrakk>\n       \\<Longrightarrow> (aa(a := None), a'a(a' := None))\n                         \\<in> {(mi, m).\n                                dom mi \\<subseteq> Domain K \\<and>\n                                dom m \\<subseteq> Range K}", "apply parametricity"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>single_valued K; single_valued (K\\<inverse>);\n        (a, a') \\<in> K;\n        (aa, a'a) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n        (aa, a'a)\n        \\<in> {(mi, m).\n               dom mi \\<subseteq> Domain K \\<and>\n               dom m \\<subseteq> Range K};\n        (ab, a'b) \\<in> K\\<rbrakk>\n       \\<Longrightarrow> ((=), (=))\n                         \\<in> K \\<rightarrow> K \\<rightarrow> bool_rel\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>single_valued K; single_valued (K\\<inverse>);\n        (a, a') \\<in> K;\n        (aa, a'a) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n        (aa, a'a)\n        \\<in> {(mi, m).\n               dom mi \\<subseteq> Domain K \\<and>\n               dom m \\<subseteq> Range K}\\<rbrakk>\n       \\<Longrightarrow> (aa(a := None), a'a(a' := None))\n                         \\<in> {(mi, m).\n                                dom mi \\<subseteq> Domain K \\<and>\n                                dom m \\<subseteq> Range K}", "apply (simp add: pres_eq_iff_svb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>single_valued K; single_valued (K\\<inverse>);\n        (a, a') \\<in> K;\n        (aa, a'a) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n        (aa, a'a)\n        \\<in> {(mi, m).\n               dom mi \\<subseteq> Domain K \\<and>\n               dom m \\<subseteq> Range K}\\<rbrakk>\n       \\<Longrightarrow> (aa(a := None), a'a(a' := None))\n                         \\<in> {(mi, m).\n                                dom mi \\<subseteq> Domain K \\<and>\n                                dom m \\<subseteq> Range K}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_decl_op map_lookup: \"\\<lambda>k (m::'k\\<rightharpoonup>'v). m k\" :: \"K \\<rightarrow> \\<langle>K,V\\<rangle>map_rel \\<rightarrow> \\<langle>V\\<rangle>option_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (\\<lambda>x1. RETURN \\<circ> (\\<lambda>m. m x1)),\n     uncurry (\\<lambda>x1. RETURN \\<circ> (\\<lambda>m. m x1)))\n    \\<in> K \\<times>\\<^sub>r \\<langle>K,\n          V\\<rangle>map_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>V\\<rangle>option_rel\\<rangle>nres_rel", "apply (rule fref_ncI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (\\<lambda>x1. RETURN \\<circ> (\\<lambda>m. m x1)),\n     uncurry (\\<lambda>x1. RETURN \\<circ> (\\<lambda>m. m x1)))\n    \\<in> K \\<times>\\<^sub>r \\<langle>K, V\\<rangle>map_rel \\<rightarrow>\n          \\<langle>\\<langle>V\\<rangle>option_rel\\<rangle>nres_rel", "apply parametricity"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> K \\<Longrightarrow>\n       (\\<lambda>m. m a, \\<lambda>m. m a')\n       \\<in> \\<langle>K, V\\<rangle>map_rel \\<rightarrow>\n             \\<langle>V\\<rangle>option_rel", "unfolding map_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> K \\<Longrightarrow>\n       (\\<lambda>m. m a, \\<lambda>m. m a')\n       \\<in> (K \\<rightarrow> \\<langle>V\\<rangle>option_rel) \\<inter>\n             {(mi, m).\n              dom mi \\<subseteq> Domain K \\<and>\n              dom m \\<subseteq> Range K} \\<rightarrow>\n             \\<langle>V\\<rangle>option_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> K;\n        (aa, a'a)\n        \\<in> (K \\<rightarrow> \\<langle>V\\<rangle>option_rel) \\<inter>\n              {(mi, m).\n               dom mi \\<subseteq> Domain K \\<and>\n               dom m \\<subseteq> Range K}\\<rbrakk>\n       \\<Longrightarrow> (aa a, a'a a') \\<in> \\<langle>V\\<rangle>option_rel", "apply (elim IntE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> K;\n        (aa, a'a) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n        (aa, a'a)\n        \\<in> {(mi, m).\n               dom mi \\<subseteq> Domain K \\<and>\n               dom m \\<subseteq> Range K}\\<rbrakk>\n       \\<Longrightarrow> (aa a, a'a a') \\<in> \\<langle>V\\<rangle>option_rel", "apply parametricity"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma in_dom_alt: \"k\\<in>dom m \\<longleftrightarrow> \\<not>is_None (m k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k \\<in> dom m) = (\\<not> is_None (m k))", "by (auto split: option.split)"], ["", "sepref_decl_op map_contains_key: \"\\<lambda>k m. k\\<in>dom m\" :: \"K \\<rightarrow> \\<langle>K,V\\<rangle>map_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (\\<lambda>x1. RETURN \\<circ> (\\<lambda>m. x1 \\<in> dom m)),\n     uncurry (\\<lambda>x1. RETURN \\<circ> (\\<lambda>m. x1 \\<in> dom m)))\n    \\<in> K \\<times>\\<^sub>r \\<langle>K,\n          V\\<rangle>map_rel \\<rightarrow>\\<^sub>f \\<langle>bool_rel\\<rangle>nres_rel", "unfolding in_dom_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry\n      (\\<lambda>x1. RETURN \\<circ> (\\<lambda>m. \\<not> is_None (m x1))),\n     uncurry\n      (\\<lambda>x1. RETURN \\<circ> (\\<lambda>m. \\<not> is_None (m x1))))\n    \\<in> K \\<times>\\<^sub>r \\<langle>K,\n          V\\<rangle>map_rel \\<rightarrow>\\<^sub>f \\<langle>bool_rel\\<rangle>nres_rel", "apply (rule fref_ncI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry\n      (\\<lambda>x1. RETURN \\<circ> (\\<lambda>m. \\<not> is_None (m x1))),\n     uncurry\n      (\\<lambda>x1. RETURN \\<circ> (\\<lambda>m. \\<not> is_None (m x1))))\n    \\<in> K \\<times>\\<^sub>r \\<langle>K, V\\<rangle>map_rel \\<rightarrow>\n          \\<langle>bool_rel\\<rangle>nres_rel", "apply parametricity"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> K;\n        (aa, a'a) \\<in> \\<langle>K, V\\<rangle>map_rel\\<rbrakk>\n       \\<Longrightarrow> (aa a, a'a a')\n                         \\<in> \\<langle>?R25 a a' aa a'a\\<rangle>option_rel", "unfolding map_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> K;\n        (aa, a'a)\n        \\<in> (K \\<rightarrow> \\<langle>V\\<rangle>option_rel) \\<inter>\n              {(mi, m).\n               dom mi \\<subseteq> Domain K \\<and>\n               dom m \\<subseteq> Range K}\\<rbrakk>\n       \\<Longrightarrow> (aa a, a'a a')\n                         \\<in> \\<langle>?R25 a a' aa a'a\\<rangle>option_rel", "apply (elim IntE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> K;\n        (aa, a'a) \\<in> K \\<rightarrow> \\<langle>V\\<rangle>option_rel;\n        (aa, a'a)\n        \\<in> {(mi, m).\n               dom mi \\<subseteq> Domain K \\<and>\n               dom m \\<subseteq> Range K}\\<rbrakk>\n       \\<Longrightarrow> (aa a, a'a a')\n                         \\<in> \\<langle>?R25 a a' aa a'a\\<rangle>option_rel", "apply parametricity"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Patterns\\<close>"], ["", "lemma pat_map_empty[pat_rules]: \"\\<lambda>\\<^sub>2_. None \\<equiv> op_map_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>x. (#None#) \\<equiv> op_map_empty", "by simp"], ["", "lemma pat_map_is_empty[pat_rules]: \n  \"(=) $m$(\\<lambda>\\<^sub>2_. None) \\<equiv> op_map_is_empty$m\" \n  \"(=) $(\\<lambda>\\<^sub>2_. None)$m \\<equiv> op_map_is_empty$m\" \n  \"(=) $(dom$m)${} \\<equiv> op_map_is_empty$m\"\n  \"(=) ${}$(dom$m) \\<equiv> op_map_is_empty$m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((=) $ m $ (\\<lambda>x. (#None#)) \\<equiv> op_map_is_empty $ m) &&&\n     (=) $ (\\<lambda>x. (#None#)) $ m \\<equiv> op_map_is_empty $ m) &&&\n    ((=) $ (dom $ m) $ {} \\<equiv> op_map_is_empty $ m) &&&\n    (=) $ {} $ (dom $ m) \\<equiv> op_map_is_empty $ m", "unfolding atomize_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) $ m $ (\\<lambda>x. (#None#)) = op_map_is_empty $ m &&&\n     (=) $ (\\<lambda>x. (#None#)) $ m = op_map_is_empty $ m) &&&\n    (=) $ (dom $ m) $ {} = op_map_is_empty $ m &&&\n    (=) $ {} $ (dom $ m) = op_map_is_empty $ m", "by (auto dest: sym)"], ["", "lemma pat_map_update[pat_rules]: \n  \"fun_upd$m$k$(Some$v) \\<equiv> op_map_update$'k$'v$'m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_upd $ m $ k $ (Some $ v) \\<equiv> op_map_update $' k $' v $' m", "by simp"], ["", "lemma pat_map_lookup[pat_rules]: \"m$k \\<equiv> op_map_lookup$'k$'m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m $ k \\<equiv> op_map_lookup $' k $' m", "by simp"], ["", "lemma op_map_delete_pat[pat_rules]: \n  \"(|`) $ m $ (uminus $ (insert $ k $ {})) \\<equiv> op_map_delete$'k$'m\"\n  \"fun_upd$m$k$None \\<equiv> op_map_delete$'k$'m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((|`) $ m $ (uminus $ (insert $ k $ {})) \\<equiv>\n     op_map_delete $' k $' m) &&&\n    fun_upd $ m $ k $ None \\<equiv> op_map_delete $' k $' m", "by (simp_all add: map_upd_eq_restrict)"], ["", "lemma op_map_contains_key[pat_rules]: \n  \"(\\<in>) $ k $ (dom$m) \\<equiv> op_map_contains_key$'k$'m\"\n  \"Not$((=) $(m$k)$None) \\<equiv> op_map_contains_key$'k$'m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<in>) $ k $ (dom $ m) \\<equiv> op_map_contains_key $' k $' m) &&&\n    Not $ ((=) $ (m $ k) $ None) \\<equiv> op_map_contains_key $' k $' m", "by (auto intro!: eq_reflection)"], ["", "subsection \\<open>Parametricity\\<close>"], ["", "locale map_custom_empty = \n  fixes op_custom_empty :: \"'k\\<rightharpoonup>'v\"\n  assumes op_custom_empty_def: \"op_custom_empty = op_map_empty\"\nbegin"], ["", "sepref_register op_custom_empty :: \"('kx,'vx) i_map\""], ["", "lemma fold_custom_empty:\n    \"Map.empty = op_custom_empty\"\n    \"op_map_empty = op_custom_empty\"\n    \"mop_map_empty = RETURN op_custom_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Map.empty = op_custom_empty &&&\n    op_map_empty = op_custom_empty &&&\n    mop_map_empty = RETURN op_custom_empty", "unfolding op_custom_empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Map.empty = op_map_empty &&&\n    op_map_empty = op_map_empty &&& mop_map_empty = RETURN op_map_empty", "by simp_all"], ["", "end"], ["", "end"]]}