{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/Examples/Sepref_NDFS.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma id_red_witness[id_rules]:\n  \"red_init_witness ::\\<^sub>i TYPE('v \\<Rightarrow> 'v \\<Rightarrow> 'v i_red_witness option)\"\n  \"prep_wit_red ::\\<^sub>i TYPE('v \\<Rightarrow> 'v i_red_witness option \\<Rightarrow> 'v i_red_witness option)\"", "lemma red_witness_rel_def: \"\\<langle>R\\<rangle>red_witness_rel \\<equiv> \\<langle>\\<langle>R\\<rangle>list_rel,R\\<rangle>prod_rel\"", "lemma red_witness_rel_sv[constraint_rules]:\n  \"single_valued R \\<Longrightarrow> single_valued (\\<langle>R\\<rangle>red_witness_rel)\"", "lemma [sepref_fr_rules]: \"hn_refine\n  (hn_val R u u' * hn_val R v v')\n  (return (red_init_witness u' v'))\n  (hn_val R u u' * hn_val R v v')\n  (option_assn (pure (\\<langle>R\\<rangle>red_witness_rel)))\n  (RETURN$(red_init_witness$u$v))\"", "lemma [sepref_fr_rules]: \"hn_refine\n  (hn_val R u u' * hn_ctxt (option_assn (pure (\\<langle>R\\<rangle>red_witness_rel))) w w')\n  (return (prep_wit_red u' w'))\n  (hn_val R u u' * hn_ctxt (option_assn (pure (\\<langle>R\\<rangle>red_witness_rel))) w w')\n  (option_assn (pure (\\<langle>R\\<rangle>red_witness_rel)))\n  (RETURN$(prep_wit_red$u$w))\"", "lemma id_init_wit_blue[id_rules]: \n  \"init_wit_blue ::\\<^sub>i TYPE('a \\<Rightarrow> 'a i_red_witness option \\<Rightarrow> 'a blue_witness)\"", "lemma hn_blue_wit[sepref_import_param]: \n  \"(NO_CYC,NO_CYC)\\<in>blue_wit_rel\" \n  \"(prep_wit_blue,prep_wit_blue)\\<in>nat_rel\\<rightarrow>blue_wit_rel\\<rightarrow>blue_wit_rel\"\n  \"((=),(=))\\<in>blue_wit_rel\\<rightarrow>blue_wit_rel\\<rightarrow>bool_rel\"", "lemma hn_init_wit_blue[sepref_fr_rules]: \"hn_refine\n  (hn_val nat_rel v v' * hn_ctxt (option_assn (pure (\\<langle>nat_rel\\<rangle>red_witness_rel))) w w')\n  (return (init_wit_blue v' w'))\n  (hn_val nat_rel v v' * hn_ctxt (option_assn (pure (\\<langle>nat_rel\\<rangle>red_witness_rel))) w w')\n  (pure blue_wit_rel)\n  (RETURN$(init_wit_blue$v$w))\"", "lemma hn_extract_res[sepref_import_param]: \n  \"(extract_res, extract_res) \\<in> blue_wit_rel \\<rightarrow> Id\"", "lemma blue_dfs_correct': \"(uncurry2 blue_dfs, uncurry2 blue_dfs_spec) \\<in> [\\<lambda>((E,A),v0). finite (E\\<^sup>*``{v0})]\\<^sub>f ((Id\\<times>\\<^sub>rId)\\<times>\\<^sub>rId) \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\"", "lemmas blue_dfs_impl_correct' = blue_dfs_impl.refine[FCOMP blue_dfs_correct']", "theorem blue_dfs_impl_correct:\n  fixes E\n  assumes \"finite (E\\<^sup>*``{v0})\"\n  shows \"<ias.assn id_assn A A_impl * adjg_assn id_assn E succ_impl>\n      blue_dfs_impl succ_impl A_impl v0 \n    <\\<lambda>r. ias.assn id_assn A A_impl * adjg_assn id_assn E succ_impl\n      * \\<up>(\n        case r of None \\<Rightarrow> \\<not>has_acc_cycle E A v0\n      | Some (v,pc,pv) \\<Rightarrow> is_acc_cycle E A v0 v pv pc\n    )>\\<^sub>t\"", "lemma testsuite_blue_dfs_modify:\n  \"({}::nat set, {}::nat set, {}::nat set, s) \n  = (op_ias_empty_sz N, op_ias_empty_sz N, op_ias_empty_sz N, s)\"", "lemmas blue_dfs_impl_sz_correct' = blue_dfs_impl_sz.refine[FCOMP blue_dfs_correct']", "theorem blue_dfs_impl_sz_correct:\n  fixes E\n  assumes \"finite (E\\<^sup>*``{v0})\"\n  shows \"<ias.assn id_assn A A_impl * adjg_assn id_assn E succ_impl>\n      blue_dfs_impl_sz N succ_impl A_impl v0 \n    <\\<lambda>r. ias.assn id_assn A A_impl * adjg_assn id_assn E succ_impl\n      * \\<up>(\n        case r of None \\<Rightarrow> \\<not>has_acc_cycle E A v0\n      | Some (v,pc,pv) \\<Rightarrow> is_acc_cycle E A v0 v pv pc\n    )>\\<^sub>t\""], "translations": [["", "lemma id_red_witness[id_rules]:\n  \"red_init_witness ::\\<^sub>i TYPE('v \\<Rightarrow> 'v \\<Rightarrow> 'v i_red_witness option)\"\n  \"prep_wit_red ::\\<^sub>i TYPE('v \\<Rightarrow> 'v i_red_witness option \\<Rightarrow> 'v i_red_witness option)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. red_init_witness ::\\<^sub>i\n    TYPE('v \\<Rightarrow> 'v \\<Rightarrow> 'v i_red_witness option) &&&\n    prep_wit_red ::\\<^sub>i\n    TYPE('v \\<Rightarrow> 'v i_red_witness option\n                          \\<Rightarrow> 'v i_red_witness option)", "by simp_all"], ["", "definition \n  red_witness_rel_def_internal: \"red_witness_rel R \\<equiv> \\<langle>\\<langle>R\\<rangle>list_rel,R\\<rangle>prod_rel\""], ["", "lemma red_witness_rel_def: \"\\<langle>R\\<rangle>red_witness_rel \\<equiv> \\<langle>\\<langle>R\\<rangle>list_rel,R\\<rangle>prod_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>R\\<rangle>red_witness_rel \\<equiv>\n    \\<langle>R\\<rangle>list_rel \\<times>\\<^sub>r R", "unfolding red_witness_rel_def_internal[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>R\\<rangle>(\\<lambda>R.\n                           \\<langle>R\\<rangle>list_rel \\<times>\\<^sub>r\n                           R) \\<equiv>\n    \\<langle>R\\<rangle>list_rel \\<times>\\<^sub>r R", "by (simp add: relAPP_def)"], ["", "lemma red_witness_rel_sv[constraint_rules]:\n  \"single_valued R \\<Longrightarrow> single_valued (\\<langle>R\\<rangle>red_witness_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued R \\<Longrightarrow>\n    single_valued (\\<langle>R\\<rangle>red_witness_rel)", "unfolding red_witness_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued R \\<Longrightarrow>\n    single_valued (\\<langle>R\\<rangle>list_rel \\<times>\\<^sub>r R)", "by tagged_solver"], ["", "lemma [sepref_fr_rules]: \"hn_refine\n  (hn_val R u u' * hn_val R v v')\n  (return (red_init_witness u' v'))\n  (hn_val R u u' * hn_val R v v')\n  (option_assn (pure (\\<langle>R\\<rangle>red_witness_rel)))\n  (RETURN$(red_init_witness$u$v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_val R u u' * hn_val R v v')\n     (return (red_init_witness u' v')) (hn_val R u u' * hn_val R v v')\n     (option_assn (pure (\\<langle>R\\<rangle>red_witness_rel)))\n     (RETURN $ (red_init_witness $ u $ v))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_val R u u' * hn_val R v v')\n     (return (red_init_witness u' v')) (hn_val R u u' * hn_val R v v')\n     (option_assn (pure (\\<langle>R\\<rangle>red_witness_rel)))\n     (RETURN (red_init_witness u v))", "unfolding red_init_witness_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_val R u u' * hn_val R v v') (return (Some ([u'], v')))\n     (hn_val R u u' * hn_val R v v')\n     (option_assn (pure (\\<langle>R\\<rangle>red_witness_rel)))\n     (RETURN (Some ([u], v)))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (RETURN (Some ([u], v))) \\<Longrightarrow>\n    <hn_val R u u' *\n     hn_val R v\n      v'> return\n           (Some\n             ([u'],\n              v')) <\\<lambda>r.\n                       hn_val R u u' * hn_val R v v' *\n                       (\\<exists>\\<^sub>Ax.\n                           option_assn\n                            (pure (\\<langle>R\\<rangle>red_witness_rel)) x\n                            r *\n                           \\<up>\n                            (RETURN x\n                             \\<le> RETURN (Some ([u], v))))>\\<^sub>t", "apply (sep_auto simp: hn_ctxt_def pure_def red_witness_rel_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [sepref_fr_rules]: \"hn_refine\n  (hn_val R u u' * hn_ctxt (option_assn (pure (\\<langle>R\\<rangle>red_witness_rel))) w w')\n  (return (prep_wit_red u' w'))\n  (hn_val R u u' * hn_ctxt (option_assn (pure (\\<langle>R\\<rangle>red_witness_rel))) w w')\n  (option_assn (pure (\\<langle>R\\<rangle>red_witness_rel)))\n  (RETURN$(prep_wit_red$u$w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine\n     (hn_val R u u' *\n      hn_ctxt (option_assn (pure (\\<langle>R\\<rangle>red_witness_rel))) w\n       w')\n     (return (prep_wit_red u' w'))\n     (hn_val R u u' *\n      hn_ctxt (option_assn (pure (\\<langle>R\\<rangle>red_witness_rel))) w\n       w')\n     (option_assn (pure (\\<langle>R\\<rangle>red_witness_rel)))\n     (RETURN $ (prep_wit_red $ u $ w))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (RETURN $ (prep_wit_red $ u $ w)) \\<Longrightarrow>\n    <hn_val R u u' *\n     hn_ctxt (option_assn (pure (\\<langle>R\\<rangle>red_witness_rel))) w\n      w'> return\n           (prep_wit_red u'\n             w') <\\<lambda>r.\n                     hn_val R u u' *\n                     hn_ctxt\n                      (option_assn\n                        (pure (\\<langle>R\\<rangle>red_witness_rel)))\n                      w w' *\n                     (\\<exists>\\<^sub>Ax.\n                         option_assn\n                          (pure (\\<langle>R\\<rangle>red_witness_rel)) x r *\n                         \\<up>\n                          (RETURN x\n                           \\<le> RETURN $ (prep_wit_red $ u $ w)))>\\<^sub>t", "apply (cases w)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>nofail (RETURN $ (prep_wit_red $ u $ w)); w = None\\<rbrakk>\n    \\<Longrightarrow> <hn_val R u u' *\n                       hn_ctxt\n                        (option_assn\n                          (pure (\\<langle>R\\<rangle>red_witness_rel)))\n                        w w'> return\n                               (prep_wit_red u'\n                                 w') <\\<lambda>r.\n   hn_val R u u' *\n   hn_ctxt (option_assn (pure (\\<langle>R\\<rangle>red_witness_rel))) w w' *\n   (\\<exists>\\<^sub>Ax.\n       option_assn (pure (\\<langle>R\\<rangle>red_witness_rel)) x r *\n       \\<up> (RETURN x \\<le> RETURN $ (prep_wit_red $ u $ w)))>\\<^sub>t\n 2. \\<And>a.\n       \\<lbrakk>nofail (RETURN $ (prep_wit_red $ u $ w));\n        w = Some a\\<rbrakk>\n       \\<Longrightarrow> <hn_val R u u' *\n                          hn_ctxt\n                           (option_assn\n                             (pure (\\<langle>R\\<rangle>red_witness_rel)))\n                           w w'> return\n                                  (prep_wit_red u'\n                                    w') <\\<lambda>r.\n      hn_val R u u' *\n      hn_ctxt (option_assn (pure (\\<langle>R\\<rangle>red_witness_rel))) w\n       w' *\n      (\\<exists>\\<^sub>Ax.\n          option_assn (pure (\\<langle>R\\<rangle>red_witness_rel)) x r *\n          \\<up> (RETURN x \\<le> RETURN $ (prep_wit_red $ u $ w)))>\\<^sub>t", "apply (sep_auto simp: hn_ctxt_def pure_def red_witness_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>nofail (RETURN $ (prep_wit_red $ u $ w));\n        w = Some a\\<rbrakk>\n       \\<Longrightarrow> <hn_val R u u' *\n                          hn_ctxt\n                           (option_assn\n                             (pure (\\<langle>R\\<rangle>red_witness_rel)))\n                           w w'> return\n                                  (prep_wit_red u'\n                                    w') <\\<lambda>r.\n      hn_val R u u' *\n      hn_ctxt (option_assn (pure (\\<langle>R\\<rangle>red_witness_rel))) w\n       w' *\n      (\\<exists>\\<^sub>Ax.\n          option_assn (pure (\\<langle>R\\<rangle>red_witness_rel)) x r *\n          \\<up> (RETURN x \\<le> RETURN $ (prep_wit_red $ u $ w)))>\\<^sub>t", "apply (cases w')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>nofail (RETURN $ (prep_wit_red $ u $ w)); w = Some a;\n        w' = None\\<rbrakk>\n       \\<Longrightarrow> <hn_val R u u' *\n                          hn_ctxt\n                           (option_assn\n                             (pure (\\<langle>R\\<rangle>red_witness_rel)))\n                           w w'> return\n                                  (prep_wit_red u'\n                                    w') <\\<lambda>r.\n      hn_val R u u' *\n      hn_ctxt (option_assn (pure (\\<langle>R\\<rangle>red_witness_rel))) w\n       w' *\n      (\\<exists>\\<^sub>Ax.\n          option_assn (pure (\\<langle>R\\<rangle>red_witness_rel)) x r *\n          \\<up> (RETURN x \\<le> RETURN $ (prep_wit_red $ u $ w)))>\\<^sub>t\n 2. \\<And>a aa.\n       \\<lbrakk>nofail (RETURN $ (prep_wit_red $ u $ w)); w = Some a;\n        w' = Some aa\\<rbrakk>\n       \\<Longrightarrow> <hn_val R u u' *\n                          hn_ctxt\n                           (option_assn\n                             (pure (\\<langle>R\\<rangle>red_witness_rel)))\n                           w w'> return\n                                  (prep_wit_red u'\n                                    w') <\\<lambda>r.\n      hn_val R u u' *\n      hn_ctxt (option_assn (pure (\\<langle>R\\<rangle>red_witness_rel))) w\n       w' *\n      (\\<exists>\\<^sub>Ax.\n          option_assn (pure (\\<langle>R\\<rangle>red_witness_rel)) x r *\n          \\<up> (RETURN x \\<le> RETURN $ (prep_wit_red $ u $ w)))>\\<^sub>t", "apply (sep_auto simp: hn_ctxt_def pure_def red_witness_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>nofail (RETURN $ (prep_wit_red $ u $ w)); w = Some a;\n        w' = Some aa\\<rbrakk>\n       \\<Longrightarrow> <hn_val R u u' *\n                          hn_ctxt\n                           (option_assn\n                             (pure (\\<langle>R\\<rangle>red_witness_rel)))\n                           w w'> return\n                                  (prep_wit_red u'\n                                    w') <\\<lambda>r.\n      hn_val R u u' *\n      hn_ctxt (option_assn (pure (\\<langle>R\\<rangle>red_witness_rel))) w\n       w' *\n      (\\<exists>\\<^sub>Ax.\n          option_assn (pure (\\<langle>R\\<rangle>red_witness_rel)) x r *\n          \\<up> (RETURN x \\<le> RETURN $ (prep_wit_red $ u $ w)))>\\<^sub>t", "apply (sep_auto simp: hn_ctxt_def pure_def red_witness_rel_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "term red_dfs"], ["", "sepref_definition red_dfs_impl is \n  \"(uncurry2 (uncurry red_dfs))\" \n  :: \"(adjg_assn nat_assn)\\<^sup>k *\\<^sub>a (ias.assn nat_assn)\\<^sup>k *\\<^sub>a (ias.assn nat_assn)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a UNSPEC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry ?f4), uncurry2 (uncurry red_dfs))\n    \\<in> (adjg_assn nat_assn)\\<^sup>k *\\<^sub>a\n          (ias.assn nat_assn)\\<^sup>k *\\<^sub>a\n          (ias.assn nat_assn)\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a ?S'1", "unfolding red_dfs_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry ?f4),\n     uncurry2\n      (uncurry\n        (\\<lambda>E onstack V u.\n            REC\\<^sub>T\n             (\\<lambda>D (V, u).\n                 let V = insert u V\n                 in FOREACH\\<^sub>C (E `` {u}) (\\<lambda>brk. brk = None)\n                     (\\<lambda>t _.\n                         if t \\<in> onstack\n                         then RETURN (red_init_witness u t)\n                         else RETURN None)\n                     None \\<bind>\n                    (\\<lambda>brk.\n                        case brk of\n                        None \\<Rightarrow>\n                          FOREACH\\<^sub>C (E `` {u})\n                           (\\<lambda>(V, brk). brk = None)\n                           (\\<lambda>t (V, uu_).\n                               if t \\<notin> V\n                               then D (V, t) \\<bind>\n                                    (\\<lambda>(V, brk).\n  RETURN (V, prep_wit_red u brk))\n                               else RETURN (V, None))\n                           (V, None)\n                        | Some a \\<Rightarrow> RETURN (V, brk)))\n             (V, u))))\n    \\<in> (adjg_assn nat_assn)\\<^sup>k *\\<^sub>a\n          (ias.assn nat_assn)\\<^sup>k *\\<^sub>a\n          (ias.assn nat_assn)\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a ?S'1", "using [[goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry ?f4),\n     uncurry2\n      (uncurry\n        (\\<lambda>E onstack V u.\n            REC\\<^sub>T\n             (\\<lambda>D (V, u).\n                 let V = insert u V\n                 in FOREACH\\<^sub>C (E `` {u}) (\\<lambda>brk. brk = None)\n                     (\\<lambda>t _.\n                         if t \\<in> onstack\n                         then RETURN (red_init_witness u t)\n                         else RETURN None)\n                     None \\<bind>\n                    (\\<lambda>brk.\n                        case brk of\n                        None \\<Rightarrow>\n                          FOREACH\\<^sub>C (E `` {u})\n                           (\\<lambda>(V, brk). brk = None)\n                           (\\<lambda>t (V, uu_).\n                               if t \\<notin> V\n                               then D (V, t) \\<bind>\n                                    (\\<lambda>(V, brk).\n  RETURN (V, prep_wit_red u brk))\n                               else RETURN (V, None))\n                           (V, None)\n                        | Some a \\<Rightarrow> RETURN (V, brk)))\n             (V, u))))\n    \\<in> (adjg_assn nat_assn)\\<^sup>k *\\<^sub>a\n          (ias.assn nat_assn)\\<^sup>k *\\<^sub>a\n          (ias.assn nat_assn)\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a ?S'1", "by sepref"], ["", "export_code red_dfs_impl checking SML_imp"], ["", "declare red_dfs_impl.refine[sepref_fr_rules]"], ["", "sepref_register red_dfs :: \"'a i_graph \\<Rightarrow> 'a set \\<Rightarrow> 'a set \\<Rightarrow> 'a \n    \\<Rightarrow> ('a set * 'a i_red_witness option) nres\""], ["", "(*lemma id_red_dfs[id_rules]: \n  \"red_dfs ::\\<^sub>i TYPE(\n    'a i_graph \\<Rightarrow> 'a set \\<Rightarrow> 'a set \\<Rightarrow> 'a \n    \\<Rightarrow> ('a set * 'a i_red_witness option) nres)\"\n  by simp\n\nlemma skel_red_dfs[sepref_la_skel]: \"SKEL (red_dfs$E$os$V$s) = la_op (E,os,V,s)\"\n  by simp\n*)"], ["", "lemma id_init_wit_blue[id_rules]: \n  \"init_wit_blue ::\\<^sub>i TYPE('a \\<Rightarrow> 'a i_red_witness option \\<Rightarrow> 'a blue_witness)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init_wit_blue ::\\<^sub>i\n    TYPE('a \\<Rightarrow> 'a i_red_witness option\n                          \\<Rightarrow> 'a blue_witness)", "by simp"], ["", "lemma hn_blue_wit[sepref_import_param]: \n  \"(NO_CYC,NO_CYC)\\<in>blue_wit_rel\" \n  \"(prep_wit_blue,prep_wit_blue)\\<in>nat_rel\\<rightarrow>blue_wit_rel\\<rightarrow>blue_wit_rel\"\n  \"((=),(=))\\<in>blue_wit_rel\\<rightarrow>blue_wit_rel\\<rightarrow>bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (NO_CYC, NO_CYC) \\<in> blue_wit_rel &&&\n    (prep_wit_blue, prep_wit_blue)\n    \\<in> nat_rel \\<rightarrow> blue_wit_rel \\<rightarrow> blue_wit_rel &&&\n    ((=), (=))\n    \\<in> blue_wit_rel \\<rightarrow> blue_wit_rel \\<rightarrow> bool_rel", "by simp_all"], ["", "lemma hn_init_wit_blue[sepref_fr_rules]: \"hn_refine\n  (hn_val nat_rel v v' * hn_ctxt (option_assn (pure (\\<langle>nat_rel\\<rangle>red_witness_rel))) w w')\n  (return (init_wit_blue v' w'))\n  (hn_val nat_rel v v' * hn_ctxt (option_assn (pure (\\<langle>nat_rel\\<rangle>red_witness_rel))) w w')\n  (pure blue_wit_rel)\n  (RETURN$(init_wit_blue$v$w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine\n     (hn_val nat_rel v v' *\n      hn_ctxt\n       (option_assn (pure (\\<langle>nat_rel\\<rangle>red_witness_rel))) w w')\n     (return (init_wit_blue v' w'))\n     (hn_val nat_rel v v' *\n      hn_ctxt\n       (option_assn (pure (\\<langle>nat_rel\\<rangle>red_witness_rel))) w w')\n     id_assn (RETURN $ (init_wit_blue $ v $ w))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (RETURN $ (init_wit_blue $ v $ w)) \\<Longrightarrow>\n    <hn_val nat_rel v v' *\n     hn_ctxt (option_assn (pure (\\<langle>nat_rel\\<rangle>red_witness_rel)))\n      w w'> return\n             (init_wit_blue v'\n               w') <\\<lambda>r.\n                       hn_val nat_rel v v' *\n                       hn_ctxt\n                        (option_assn\n                          (pure (\\<langle>nat_rel\\<rangle>red_witness_rel)))\n                        w w' *\n                       (\\<exists>\\<^sub>Ax.\n                           id_assn x r *\n                           \\<up>\n                            (RETURN x\n                             \\<le> RETURN $\n                                   (init_wit_blue $ v $ w)))>\\<^sub>t", "apply (sep_auto simp: hn_ctxt_def pure_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>v' = v;\n        (a, b) \\<Turnstile>\n        option_assn\n         (\\<lambda>a c.\n             \\<up> ((c, a) \\<in> \\<langle>nat_rel\\<rangle>red_witness_rel))\n         w w'\\<rbrakk>\n       \\<Longrightarrow> init_wit_blue v w' = init_wit_blue v w", "apply (case_tac w, sep_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa.\n       \\<lbrakk>v' = v;\n        (a, b) \\<Turnstile>\n        option_assn\n         (\\<lambda>a c.\n             \\<up> ((c, a) \\<in> \\<langle>nat_rel\\<rangle>red_witness_rel))\n         w w';\n        w = Some aa\\<rbrakk>\n       \\<Longrightarrow> init_wit_blue v w' = init_wit_blue v w", "apply (case_tac w', sep_auto, sep_auto simp: red_witness_rel_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hn_extract_res[sepref_import_param]: \n  \"(extract_res, extract_res) \\<in> blue_wit_rel \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (extract_res, extract_res) \\<in> blue_wit_rel \\<rightarrow> Id", "by simp"], ["", "thm red_dfs_impl.refine"], ["", "sepref_definition blue_dfs_impl is \"uncurry2 blue_dfs\" :: \"((adjg_assn nat_assn)\\<^sup>k*\\<^sub>a(ias.assn nat_assn)\\<^sup>k*\\<^sub>anat_assn\\<^sup>k\\<rightarrow>\\<^sub>aid_assn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 blue_dfs)\n    \\<in> (adjg_assn nat_assn)\\<^sup>k *\\<^sub>a\n          (ias.assn nat_assn)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "unfolding blue_dfs_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>E A s.\n          REC\\<^sub>T\n           (\\<lambda>D (blues, reds, onstack, s).\n               let blues = insert s blues; onstack = insert s onstack\n               in FOREACH\\<^sub>C (E `` {s})\n                   (\\<lambda>(uu_, uu_, uu_, cyc). cyc = NO_CYC)\n                   (\\<lambda>t (blues, reds, onstack, cyc).\n                       if t \\<notin> blues\n                       then D (blues, reds, onstack, t) \\<bind>\n                            (\\<lambda>(blues, reds, onstack, cyc).\n                                RETURN\n                                 (blues, reds, onstack,\n                                  prep_wit_blue s cyc))\n                       else RETURN (blues, reds, onstack, cyc))\n                   (blues, reds, onstack, NO_CYC) \\<bind>\n                  (\\<lambda>(blues, reds, onstack, cyc).\n                      (if cyc = NO_CYC \\<and> s \\<in> A\n                       then red_dfs E onstack reds s \\<bind>\n                            (\\<lambda>(reds, rcyc).\n                                RETURN (reds, init_wit_blue s rcyc))\n                       else RETURN (reds, cyc)) \\<bind>\n                      (\\<lambda>(reds, cyc).\n                          let onstack = onstack - {s}\n                          in RETURN (blues, reds, onstack, cyc))))\n           ({}, {}, {}, s) \\<bind>\n          (\\<lambda>(uu_, uu_, uu_, cyc). RETURN (extract_res cyc))))\n    \\<in> (adjg_assn nat_assn)\\<^sup>k *\\<^sub>a\n          (ias.assn nat_assn)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "apply (rewrite in \"RECT _ \\<hole>\" ias.fold_custom_empty)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>E A s.\n          REC\\<^sub>T\n           (\\<lambda>D (blues, reds, onstack, s).\n               let blues = insert s blues; onstack = insert s onstack\n               in FOREACH\\<^sub>C (E `` {s})\n                   (\\<lambda>(uu_, uu_, uu_, cyc). cyc = NO_CYC)\n                   (\\<lambda>t (blues, reds, onstack, cyc).\n                       if t \\<notin> blues\n                       then D (blues, reds, onstack, t) \\<bind>\n                            (\\<lambda>(blues, reds, onstack, cyc).\n                                RETURN\n                                 (blues, reds, onstack,\n                                  prep_wit_blue s cyc))\n                       else RETURN (blues, reds, onstack, cyc))\n                   (blues, reds, onstack, NO_CYC) \\<bind>\n                  (\\<lambda>(blues, reds, onstack, cyc).\n                      (if cyc = NO_CYC \\<and> s \\<in> A\n                       then red_dfs E onstack reds s \\<bind>\n                            (\\<lambda>(reds, rcyc).\n                                RETURN (reds, init_wit_blue s rcyc))\n                       else RETURN (reds, cyc)) \\<bind>\n                      (\\<lambda>(reds, cyc).\n                          let onstack = onstack - {s}\n                          in RETURN (blues, reds, onstack, cyc))))\n           (op_ias_empty, op_ias_empty, op_ias_empty, s) \\<bind>\n          (\\<lambda>(uu_, uu_, uu_, cyc). RETURN (extract_res cyc))))\n    \\<in> (adjg_assn nat_assn)\\<^sup>k *\\<^sub>a\n          (ias.assn nat_assn)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "using [[goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>E A s.\n          REC\\<^sub>T\n           (\\<lambda>D (blues, reds, onstack, s).\n               let blues = insert s blues; onstack = insert s onstack\n               in FOREACH\\<^sub>C (E `` {s})\n                   (\\<lambda>(uu_, uu_, uu_, cyc). cyc = NO_CYC)\n                   (\\<lambda>t (blues, reds, onstack, cyc).\n                       if t \\<notin> blues\n                       then D (blues, reds, onstack, t) \\<bind>\n                            (\\<lambda>(blues, reds, onstack, cyc).\n                                RETURN\n                                 (blues, reds, onstack,\n                                  prep_wit_blue s cyc))\n                       else RETURN (blues, reds, onstack, cyc))\n                   (blues, reds, onstack, NO_CYC) \\<bind>\n                  (\\<lambda>(blues, reds, onstack, cyc).\n                      (if cyc = NO_CYC \\<and> s \\<in> A\n                       then red_dfs E onstack reds s \\<bind>\n                            (\\<lambda>(reds, rcyc).\n                                RETURN (reds, init_wit_blue s rcyc))\n                       else RETURN (reds, cyc)) \\<bind>\n                      (\\<lambda>(reds, cyc).\n                          let onstack = onstack - {s}\n                          in RETURN (blues, reds, onstack, cyc))))\n           (op_ias_empty, op_ias_empty, op_ias_empty, s) \\<bind>\n          (\\<lambda>(uu_, uu_, uu_, cyc). RETURN (extract_res cyc))))\n    \\<in> (adjg_assn nat_assn)\\<^sup>k *\\<^sub>a\n          (ias.assn nat_assn)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "by sepref"], ["", "(* Takes long *)"], ["", "export_code blue_dfs_impl checking SML_imp"], ["", "definition \"blue_dfs_spec E A v0 \\<equiv> SPEC (\\<lambda>r. case r of None \\<Rightarrow> \\<not> has_acc_cycle E A v0\n             | Some (v, pc, pv) \\<Rightarrow> is_acc_cycle E A v0 v pv pc)\""], ["", "lemma blue_dfs_correct': \"(uncurry2 blue_dfs, uncurry2 blue_dfs_spec) \\<in> [\\<lambda>((E,A),v0). finite (E\\<^sup>*``{v0})]\\<^sub>f ((Id\\<times>\\<^sub>rId)\\<times>\\<^sub>rId) \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 blue_dfs, uncurry2 blue_dfs_spec)\n    \\<in> [\\<lambda>((E, A), v0).\n              finite\n               (E\\<^sup>* ``\n                {v0})]\\<^sub>f (Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r\n                               Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "apply (intro frefI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case y of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (E, A) \\<Rightarrow>\n                     \\<lambda>v0. finite (E\\<^sup>* `` {v0}))\n                   xa;\n        (x, y) \\<in> (Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r Id\\<rbrakk>\n       \\<Longrightarrow> uncurry2 blue_dfs x\n                         \\<le> \\<Down> Id (uncurry2 blue_dfs_spec y)", "unfolding blue_dfs_spec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case y of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (E, A) \\<Rightarrow>\n                     \\<lambda>v0. finite (E\\<^sup>* `` {v0}))\n                   xa;\n        (x, y) \\<in> (Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r Id\\<rbrakk>\n       \\<Longrightarrow> uncurry2 blue_dfs x\n                         \\<le> \\<Down> Id\n                                (uncurry2\n                                  (\\<lambda>E A v0.\nSPEC\n (\\<lambda>r.\n     case r of None \\<Rightarrow> \\<not> has_acc_cycle E A v0\n     | Some (v, pc, pv) \\<Rightarrow> is_acc_cycle E A v0 v pv pc))\n                                  y)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa bb bc.\n       finite (aa\\<^sup>* `` {bc}) \\<Longrightarrow>\n       blue_dfs aa bb bc\n       \\<le> SPEC\n              (case_option (\\<not> has_acc_cycle aa bb bc)\n                (\\<lambda>(v, pc, pv). is_acc_cycle aa bb bc v pv pc))", "apply (refine_vcg blue_dfs_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas blue_dfs_impl_correct' = blue_dfs_impl.refine[FCOMP blue_dfs_correct']"], ["", "theorem blue_dfs_impl_correct:\n  fixes E\n  assumes \"finite (E\\<^sup>*``{v0})\"\n  shows \"<ias.assn id_assn A A_impl * adjg_assn id_assn E succ_impl>\n      blue_dfs_impl succ_impl A_impl v0 \n    <\\<lambda>r. ias.assn id_assn A A_impl * adjg_assn id_assn E succ_impl\n      * \\<up>(\n        case r of None \\<Rightarrow> \\<not>has_acc_cycle E A v0\n      | Some (v,pc,pv) \\<Rightarrow> is_acc_cycle E A v0 v pv pc\n    )>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <ias.assn nat_assn A A_impl *\n     adjg_assn nat_assn E\n      succ_impl> blue_dfs_impl succ_impl A_impl\n                  v0 <\\<lambda>r.\n                         ias.assn nat_assn A A_impl *\n                         adjg_assn nat_assn E succ_impl *\n                         \\<up>\n                          (case r of\n                           None \\<Rightarrow> \\<not> has_acc_cycle E A v0\n                           | Some (v, pc, pv) \\<Rightarrow>\n                               is_acc_cycle E A v0 v pv pc)>\\<^sub>t", "using blue_dfs_impl_correct'[THEN hfrefD, THEN hn_refineD, of \"((E,A),v0)\" \"((succ_impl,A_impl),v0)\", simplified]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (E\\<^sup>* `` {v0});\n   nofail (blue_dfs_spec E A v0)\\<rbrakk>\n  \\<Longrightarrow> <adjg_assn nat_assn E succ_impl *\n                     ias.assn nat_assn A A_impl *\n                     nat_assn v0 v0>\n                    blue_dfs_impl succ_impl A_impl v0\n                    <\\<lambda>r.\n                        \\<exists>\\<^sub>Ax.\n                           adjg_assn nat_assn E succ_impl *\n                           ias.assn nat_assn A A_impl *\n                           nat_assn v0 v0 *\n                           id_assn x r *\n                           true *\n                           \\<up> (RETURN x \\<le> blue_dfs_spec E A v0)>\n\ngoal (1 subgoal):\n 1. <ias.assn nat_assn A A_impl *\n     adjg_assn nat_assn E\n      succ_impl> blue_dfs_impl succ_impl A_impl\n                  v0 <\\<lambda>r.\n                         ias.assn nat_assn A A_impl *\n                         adjg_assn nat_assn E succ_impl *\n                         \\<up>\n                          (case r of\n                           None \\<Rightarrow> \\<not> has_acc_cycle E A v0\n                           | Some (v, pc, pv) \\<Rightarrow>\n                               is_acc_cycle E A v0 v pv pc)>\\<^sub>t", "apply (rule cons_rule[rotated -1])"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite (E\\<^sup>* `` {v0})\n 2. nofail (blue_dfs_spec E A v0)\n 3. ias.assn nat_assn A A_impl *\n    adjg_assn nat_assn E succ_impl \\<Longrightarrow>\\<^sub>A\n    adjg_assn nat_assn E succ_impl * ias.assn nat_assn A A_impl *\n    nat_assn v0 v0\n 4. \\<And>x.\n       \\<exists>\\<^sub>Axa.\n          adjg_assn nat_assn E succ_impl * ias.assn nat_assn A A_impl *\n          nat_assn v0 v0 *\n          id_assn xa x *\n          true *\n          \\<up>\n           (RETURN xa \\<le> blue_dfs_spec E A v0) \\<Longrightarrow>\\<^sub>A\n       ias.assn nat_assn A A_impl * adjg_assn nat_assn E succ_impl *\n       \\<up>\n        (case x of None \\<Rightarrow> \\<not> has_acc_cycle E A v0\n         | Some (v, pc, pv) \\<Rightarrow> is_acc_cycle E A v0 v pv pc) *\n       true", "using assms"], ["proof (prove)\nusing this:\n  finite (E\\<^sup>* `` {v0})\n\ngoal (4 subgoals):\n 1. finite (E\\<^sup>* `` {v0})\n 2. nofail (blue_dfs_spec E A v0)\n 3. ias.assn nat_assn A A_impl *\n    adjg_assn nat_assn E succ_impl \\<Longrightarrow>\\<^sub>A\n    adjg_assn nat_assn E succ_impl * ias.assn nat_assn A A_impl *\n    nat_assn v0 v0\n 4. \\<And>x.\n       \\<exists>\\<^sub>Axa.\n          adjg_assn nat_assn E succ_impl * ias.assn nat_assn A A_impl *\n          nat_assn v0 v0 *\n          id_assn xa x *\n          true *\n          \\<up>\n           (RETURN xa \\<le> blue_dfs_spec E A v0) \\<Longrightarrow>\\<^sub>A\n       ias.assn nat_assn A A_impl * adjg_assn nat_assn E succ_impl *\n       \\<up>\n        (case x of None \\<Rightarrow> \\<not> has_acc_cycle E A v0\n         | Some (v, pc, pv) \\<Rightarrow> is_acc_cycle E A v0 v pv pc) *\n       true", "by (sep_auto simp: blue_dfs_spec_def pure_def)+"], ["", "text \\<open> We tweak the initialization vector of the outer DFS,\n  to allow pre-initialization of the size of the array-lists.\n  When set to the number of nodes, array-lists will never be resized \n  during the run, which saves some time. \\<close>"], ["", "context \n  fixes N :: nat\nbegin"], ["", "lemma testsuite_blue_dfs_modify:\n  \"({}::nat set, {}::nat set, {}::nat set, s) \n  = (op_ias_empty_sz N, op_ias_empty_sz N, op_ias_empty_sz N, s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({}, {}, {}, s) =\n    (op_ias_empty_sz N, op_ias_empty_sz N, op_ias_empty_sz N, s)", "by simp"], ["", "sepref_definition blue_dfs_impl_sz is \"uncurry2 blue_dfs\" :: \"((adjg_assn nat_assn)\\<^sup>k*\\<^sub>a(ias.assn nat_assn)\\<^sup>k*\\<^sub>anat_assn\\<^sup>k\\<rightarrow>\\<^sub>aid_assn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 blue_dfs)\n    \\<in> (adjg_assn nat_assn)\\<^sup>k *\\<^sub>a\n          (ias.assn nat_assn)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "unfolding blue_dfs_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>E A s.\n          REC\\<^sub>T\n           (\\<lambda>D (blues, reds, onstack, s).\n               let blues = insert s blues; onstack = insert s onstack\n               in FOREACH\\<^sub>C (E `` {s})\n                   (\\<lambda>(uu_, uu_, uu_, cyc). cyc = NO_CYC)\n                   (\\<lambda>t (blues, reds, onstack, cyc).\n                       if t \\<notin> blues\n                       then D (blues, reds, onstack, t) \\<bind>\n                            (\\<lambda>(blues, reds, onstack, cyc).\n                                RETURN\n                                 (blues, reds, onstack,\n                                  prep_wit_blue s cyc))\n                       else RETURN (blues, reds, onstack, cyc))\n                   (blues, reds, onstack, NO_CYC) \\<bind>\n                  (\\<lambda>(blues, reds, onstack, cyc).\n                      (if cyc = NO_CYC \\<and> s \\<in> A\n                       then red_dfs E onstack reds s \\<bind>\n                            (\\<lambda>(reds, rcyc).\n                                RETURN (reds, init_wit_blue s rcyc))\n                       else RETURN (reds, cyc)) \\<bind>\n                      (\\<lambda>(reds, cyc).\n                          let onstack = onstack - {s}\n                          in RETURN (blues, reds, onstack, cyc))))\n           ({}, {}, {}, s) \\<bind>\n          (\\<lambda>(uu_, uu_, uu_, cyc). RETURN (extract_res cyc))))\n    \\<in> (adjg_assn nat_assn)\\<^sup>k *\\<^sub>a\n          (ias.assn nat_assn)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "apply (rewrite in \"RECT _ \\<hole>\" testsuite_blue_dfs_modify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>E A s.\n          REC\\<^sub>T\n           (\\<lambda>D (blues, reds, onstack, s).\n               let blues = insert s blues; onstack = insert s onstack\n               in FOREACH\\<^sub>C (E `` {s})\n                   (\\<lambda>(uu_, uu_, uu_, cyc). cyc = NO_CYC)\n                   (\\<lambda>t (blues, reds, onstack, cyc).\n                       if t \\<notin> blues\n                       then D (blues, reds, onstack, t) \\<bind>\n                            (\\<lambda>(blues, reds, onstack, cyc).\n                                RETURN\n                                 (blues, reds, onstack,\n                                  prep_wit_blue s cyc))\n                       else RETURN (blues, reds, onstack, cyc))\n                   (blues, reds, onstack, NO_CYC) \\<bind>\n                  (\\<lambda>(blues, reds, onstack, cyc).\n                      (if cyc = NO_CYC \\<and> s \\<in> A\n                       then red_dfs E onstack reds s \\<bind>\n                            (\\<lambda>(reds, rcyc).\n                                RETURN (reds, init_wit_blue s rcyc))\n                       else RETURN (reds, cyc)) \\<bind>\n                      (\\<lambda>(reds, cyc).\n                          let onstack = onstack - {s}\n                          in RETURN (blues, reds, onstack, cyc))))\n           (op_ias_empty_sz N, op_ias_empty_sz N, op_ias_empty_sz N,\n            s) \\<bind>\n          (\\<lambda>(uu_, uu_, uu_, cyc). RETURN (extract_res cyc))))\n    \\<in> (adjg_assn nat_assn)\\<^sup>k *\\<^sub>a\n          (ias.assn nat_assn)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "using [[goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>E A s.\n          REC\\<^sub>T\n           (\\<lambda>D (blues, reds, onstack, s).\n               let blues = insert s blues; onstack = insert s onstack\n               in FOREACH\\<^sub>C (E `` {s})\n                   (\\<lambda>(uu_, uu_, uu_, cyc). cyc = NO_CYC)\n                   (\\<lambda>t (blues, reds, onstack, cyc).\n                       if t \\<notin> blues\n                       then D (blues, reds, onstack, t) \\<bind>\n                            (\\<lambda>(blues, reds, onstack, cyc).\n                                RETURN\n                                 (blues, reds, onstack,\n                                  prep_wit_blue s cyc))\n                       else RETURN (blues, reds, onstack, cyc))\n                   (blues, reds, onstack, NO_CYC) \\<bind>\n                  (\\<lambda>(blues, reds, onstack, cyc).\n                      (if cyc = NO_CYC \\<and> s \\<in> A\n                       then red_dfs E onstack reds s \\<bind>\n                            (\\<lambda>(reds, rcyc).\n                                RETURN (reds, init_wit_blue s rcyc))\n                       else RETURN (reds, cyc)) \\<bind>\n                      (\\<lambda>(reds, cyc).\n                          let onstack = onstack - {s}\n                          in RETURN (blues, reds, onstack, cyc))))\n           (op_ias_empty_sz N, op_ias_empty_sz N, op_ias_empty_sz N,\n            s) \\<bind>\n          (\\<lambda>(uu_, uu_, uu_, cyc). RETURN (extract_res cyc))))\n    \\<in> (adjg_assn nat_assn)\\<^sup>k *\\<^sub>a\n          (ias.assn nat_assn)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "by sepref"], ["", "(* Takes long *)"], ["", "export_code blue_dfs_impl_sz checking SML_imp"], ["", "end"], ["", "lemmas blue_dfs_impl_sz_correct' = blue_dfs_impl_sz.refine[FCOMP blue_dfs_correct']"], ["", "term blue_dfs_impl_sz"], ["", "theorem blue_dfs_impl_sz_correct:\n  fixes E\n  assumes \"finite (E\\<^sup>*``{v0})\"\n  shows \"<ias.assn id_assn A A_impl * adjg_assn id_assn E succ_impl>\n      blue_dfs_impl_sz N succ_impl A_impl v0 \n    <\\<lambda>r. ias.assn id_assn A A_impl * adjg_assn id_assn E succ_impl\n      * \\<up>(\n        case r of None \\<Rightarrow> \\<not>has_acc_cycle E A v0\n      | Some (v,pc,pv) \\<Rightarrow> is_acc_cycle E A v0 v pv pc\n    )>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <ias.assn nat_assn A A_impl *\n     adjg_assn nat_assn E\n      succ_impl> blue_dfs_impl_sz N succ_impl A_impl\n                  v0 <\\<lambda>r.\n                         ias.assn nat_assn A A_impl *\n                         adjg_assn nat_assn E succ_impl *\n                         \\<up>\n                          (case r of\n                           None \\<Rightarrow> \\<not> has_acc_cycle E A v0\n                           | Some (v, pc, pv) \\<Rightarrow>\n                               is_acc_cycle E A v0 v pv pc)>\\<^sub>t", "using blue_dfs_impl_sz_correct'[THEN hfrefD, THEN hn_refineD, of \"((E,A),v0)\" \"((succ_impl,A_impl),v0)\", simplified]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (E\\<^sup>* `` {v0});\n   nofail (blue_dfs_spec E A v0)\\<rbrakk>\n  \\<Longrightarrow> <adjg_assn nat_assn E succ_impl *\n                     ias.assn nat_assn A A_impl *\n                     nat_assn v0 v0>\n                    blue_dfs_impl_sz ?N2 succ_impl A_impl v0\n                    <\\<lambda>r.\n                        \\<exists>\\<^sub>Ax.\n                           adjg_assn nat_assn E succ_impl *\n                           ias.assn nat_assn A A_impl *\n                           nat_assn v0 v0 *\n                           id_assn x r *\n                           true *\n                           \\<up> (RETURN x \\<le> blue_dfs_spec E A v0)>\n\ngoal (1 subgoal):\n 1. <ias.assn nat_assn A A_impl *\n     adjg_assn nat_assn E\n      succ_impl> blue_dfs_impl_sz N succ_impl A_impl\n                  v0 <\\<lambda>r.\n                         ias.assn nat_assn A A_impl *\n                         adjg_assn nat_assn E succ_impl *\n                         \\<up>\n                          (case r of\n                           None \\<Rightarrow> \\<not> has_acc_cycle E A v0\n                           | Some (v, pc, pv) \\<Rightarrow>\n                               is_acc_cycle E A v0 v pv pc)>\\<^sub>t", "apply (rule cons_rule[rotated -1])"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite (E\\<^sup>* `` {v0})\n 2. nofail (blue_dfs_spec E A v0)\n 3. ias.assn nat_assn A A_impl *\n    adjg_assn nat_assn E succ_impl \\<Longrightarrow>\\<^sub>A\n    adjg_assn nat_assn E succ_impl * ias.assn nat_assn A A_impl *\n    nat_assn v0 v0\n 4. \\<And>x.\n       \\<exists>\\<^sub>Axa.\n          adjg_assn nat_assn E succ_impl * ias.assn nat_assn A A_impl *\n          nat_assn v0 v0 *\n          id_assn xa x *\n          true *\n          \\<up>\n           (RETURN xa \\<le> blue_dfs_spec E A v0) \\<Longrightarrow>\\<^sub>A\n       ias.assn nat_assn A A_impl * adjg_assn nat_assn E succ_impl *\n       \\<up>\n        (case x of None \\<Rightarrow> \\<not> has_acc_cycle E A v0\n         | Some (v, pc, pv) \\<Rightarrow> is_acc_cycle E A v0 v pv pc) *\n       true", "using assms"], ["proof (prove)\nusing this:\n  finite (E\\<^sup>* `` {v0})\n\ngoal (4 subgoals):\n 1. finite (E\\<^sup>* `` {v0})\n 2. nofail (blue_dfs_spec E A v0)\n 3. ias.assn nat_assn A A_impl *\n    adjg_assn nat_assn E succ_impl \\<Longrightarrow>\\<^sub>A\n    adjg_assn nat_assn E succ_impl * ias.assn nat_assn A A_impl *\n    nat_assn v0 v0\n 4. \\<And>x.\n       \\<exists>\\<^sub>Axa.\n          adjg_assn nat_assn E succ_impl * ias.assn nat_assn A A_impl *\n          nat_assn v0 v0 *\n          id_assn xa x *\n          true *\n          \\<up>\n           (RETURN xa \\<le> blue_dfs_spec E A v0) \\<Longrightarrow>\\<^sub>A\n       ias.assn nat_assn A A_impl * adjg_assn nat_assn E succ_impl *\n       \\<up>\n        (case x of None \\<Rightarrow> \\<not> has_acc_cycle E A v0\n         | Some (v, pc, pv) \\<Rightarrow> is_acc_cycle E A v0 v pv pc) *\n       true", "by (sep_auto simp: blue_dfs_spec_def pure_def)+"], ["", "end"]]}