{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/Sepref_Intf_Util.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma intf_of_relI: \"INTF_OF_REL (R::(_\\<times>'a) set) TYPE('a)\"", "lemma [synth_rules]:\n    \"INTF_OF_REL unit_rel TYPE(unit)\"\n    \"INTF_OF_REL nat_rel TYPE(nat)\"\n    \"INTF_OF_REL int_rel TYPE(int)\"\n    \"INTF_OF_REL bool_rel TYPE(bool)\"\n\n    \"INTF_OF_REL R TYPE('a) \\<Longrightarrow> INTF_OF_REL (\\<langle>R\\<rangle>option_rel) TYPE('a option)\"\n    \"INTF_OF_REL R TYPE('a) \\<Longrightarrow> INTF_OF_REL (\\<langle>R\\<rangle>list_rel) TYPE('a list)\"\n    \"INTF_OF_REL R TYPE('a) \\<Longrightarrow> INTF_OF_REL (\\<langle>R\\<rangle>nres_rel) TYPE('a nres)\"\n    \"\\<lbrakk>INTF_OF_REL R TYPE('a); INTF_OF_REL S TYPE('b)\\<rbrakk> \\<Longrightarrow> INTF_OF_REL (R\\<times>\\<^sub>rS) TYPE('a\\<times>'b)\"\n    \"\\<lbrakk>INTF_OF_REL R TYPE('a); INTF_OF_REL S TYPE('b)\\<rbrakk> \\<Longrightarrow> INTF_OF_REL (\\<langle>R,S\\<rangle>sum_rel) TYPE('a+'b)\"\n    \"\\<lbrakk>INTF_OF_REL R TYPE('a); INTF_OF_REL S TYPE('b)\\<rbrakk> \\<Longrightarrow> INTF_OF_REL (R\\<rightarrow>S) TYPE('a\\<Rightarrow>'b)\"", "lemma synth_intf_of_relI: \"INTF_OF_REL R I \\<Longrightarrow> SYNTH_TERM R I\"", "lemma param_op_mop_iff:\n    assumes \"(Q,P)\\<in>R\\<rightarrow>bool_rel\"\n    shows \n    \"(f, g) \\<in> [P]\\<^sub>f R \\<rightarrow> \\<langle>S\\<rangle>nres_rel\n    \\<longleftrightarrow> \n    (mop Q f, mop P g) \\<in> R \\<rightarrow>\\<^sub>f \\<langle>S\\<rangle>nres_rel\n    \"", "lemma param_mopI:\n    assumes \"(f,g) \\<in> [P]\\<^sub>f R \\<rightarrow> \\<langle>S\\<rangle>nres_rel\"  \n    assumes \"(Q,P) \\<in> R \\<rightarrow> bool_rel\"\n    shows \"(mop Q f, mop P g) \\<in> R \\<rightarrow>\\<^sub>f \\<langle>S\\<rangle>nres_rel\"", "lemma mop_spec_rl: \"P x \\<Longrightarrow> mop P f x \\<le> f x\"", "lemma mop_spec_rl_from_def:  \n    assumes \"f \\<equiv> mop P g\"\n    assumes \"P x\"\n    assumes \"g x \\<le> z\"\n    shows \"f x \\<le> z\"", "lemma mop_leof_rl_from_def:  \n    assumes \"f \\<equiv> mop P g\"\n    assumes \"P x \\<Longrightarrow> g x \\<le>\\<^sub>n z\"\n    shows \"f x \\<le>\\<^sub>n z\"", "lemma assert_true_bind_conv: \"ASSERT True \\<then> m = m\"", "lemmas mop_alt_unfolds = curry_def curry0_def mop_def uncurry_apply uncurry0_apply o_apply assert_true_bind_conv", "lemma add_is_pure_constraint: \"\\<lbrakk>PROP P; CONSTRAINT is_pure A\\<rbrakk> \\<Longrightarrow> PROP P\"", "lemma sepref_relpropI: \"P R = CONSTRAINT P R\"", "lemmas [constraint_simps] = the_pure_pure", "lemma IS_PURE_pureI: \n  \"P R \\<Longrightarrow> IS_PURE P (pure R)\"", "lemma [fcomp_norm_simps]: \"CONSTRAINT (IS_PURE \\<Phi>) P \\<Longrightarrow> pure (the_pure P) = P\"", "lemma [fcomp_norm_simps]: \"CONSTRAINT (IS_PURE P) A \\<Longrightarrow> P (the_pure A)\"", "lemma handle_purity1: \n  \"CONSTRAINT (IS_PURE \\<Phi>) A \\<Longrightarrow> CONSTRAINT \\<Phi> (the_pure A)\"", "lemma handle_purity2:\n  \"CONSTRAINT (IS_PURE \\<Phi>) A \\<Longrightarrow> CONSTRAINT is_pure A\"", "lemma and_pre_beta: \"PP \\<longrightarrow> P x \\<and> Q x \\<Longrightarrow> PP \\<longrightarrow> and_pre P Q x\"", "lemma imp_pre_beta: \"PP \\<longrightarrow> P x \\<longrightarrow> Q x \\<Longrightarrow> PP \\<longrightarrow> imp_pre P Q x\"", "lemma IMP_PRED: \"IMP_PRE P1 P2 \\<Longrightarrow> P1 x \\<Longrightarrow> P2 x\"", "lemma IMP_PRE_refl: \"IMP_PRE P P\"", "lemma IMP_PRE_CUSTOMD: \"IMP_PRE_CUSTOM P1 P2 \\<Longrightarrow> IMP_PRE P1 P2\"", "lemma IMP_PRE_CUSTOMI: \"\\<lbrakk>\\<And>x. P1 x \\<Longrightarrow> P2 x\\<rbrakk> \\<Longrightarrow> IMP_PRE_CUSTOM P1 P2\"", "lemma imp_and_triv_pre: \"IMP_PRE P (and_pre (\\<lambda>_. True) P)\"", "lemma to_IMP_LISTI:\n    \"P \\<Longrightarrow> IMP_LIST [] P\"", "lemma to_IMP_LIST: \"(P \\<Longrightarrow> IMP_LIST Ps Q) \\<equiv> Trueprop (IMP_LIST (P#Ps) Q)\"", "lemma from_IMP_LIST:\n    \"Trueprop (IMP_LIST As B) \\<equiv> (ALL_LIST As \\<Longrightarrow> B)\"\n    \"(ALL_LIST [] \\<Longrightarrow> B) \\<equiv> Trueprop B\"\n    \"(ALL_LIST (A#As) \\<Longrightarrow> B) \\<equiv> (A \\<Longrightarrow> ALL_LIST As \\<Longrightarrow> B)\"", "lemma IMP_LIST_trivial: \"IMP_LIST A B \\<Longrightarrow> IMP_LIST A B\"", "lemma hfcomp_tcomp_pre:\n    assumes B: \"(g,h) \\<in> [Q]\\<^sub>f T \\<rightarrow> \\<langle>U\\<rangle>nres_rel\"\n    assumes A: \"(f,g) \\<in> [P]\\<^sub>a RR' \\<rightarrow> S\"\n    shows \"(f,h) \\<in> [tcomp_pre Q T P]\\<^sub>a hrp_comp RR' T \\<rightarrow> hr_comp S U\"", "lemma transform_pre_param:\n    assumes A: \"IMP_LIST Cns ((f, h) \\<in> [tcomp_pre Q T P]\\<^sub>a hrp_comp RR' T \\<rightarrow> hr_comp S U)\"\n    assumes P: \"IMP_LIST Cns ((P,P') \\<in> T \\<rightarrow> bool_rel)\"\n    assumes C: \"IMP_PRE PP' (and_pre P' Q)\"\n    shows \"IMP_LIST Cns ((f,h) \\<in> [PP']\\<^sub>a hrp_comp RR' T \\<rightarrow> hr_comp S U)\"", "lemma hfref_mop_conv: \"((g,mop P f) \\<in> [Q]\\<^sub>a R \\<rightarrow> S) \\<longleftrightarrow> (g,f) \\<in> [\\<lambda>x. P x \\<and> Q x]\\<^sub>a R \\<rightarrow> S\"", "lemma hfref_op_to_mop:\n    assumes R: \"(impl,f) \\<in> [Q]\\<^sub>a R \\<rightarrow> S\"\n    assumes DEF: \"mf \\<equiv> mop P f\"\n    assumes C: \"IMP_PRE PP' (imp_pre P Q)\"\n    shows \"(impl,mf) \\<in> [PP']\\<^sub>a R \\<rightarrow> S\"", "lemma hfref_mop_to_op:\n    assumes R: \"(impl,mf) \\<in> [Q]\\<^sub>a R \\<rightarrow> S\"\n    assumes DEF: \"mf \\<equiv> mop P f\"\n    assumes C: \"IMP_PRE PP' (and_pre Q P)\"\n    shows \"(impl,f) \\<in> [PP']\\<^sub>a R \\<rightarrow> S\"", "lemma IMP_PRE_eqI:\n    assumes \"\\<And>x. P x \\<longrightarrow> Q x\"\n    assumes \"CNV P P'\"\n    shows \"IMP_PRE P' Q\"", "lemma simp_and1:\n    assumes \"Q \\<Longrightarrow> CNV P P'\"\n    assumes \"PP \\<longrightarrow> P' \\<and> Q\"\n    shows \"PP \\<longrightarrow> P \\<and> Q\"", "lemma simp_and2:\n    assumes \"P \\<Longrightarrow> CNV Q Q'\"\n    assumes \"PP \\<longrightarrow> P \\<and> Q'\"\n    shows \"PP \\<longrightarrow> P \\<and> Q\"", "lemma triv_and1: \"Q \\<longrightarrow> True \\<and> Q\"", "lemma simp_imp:\n    assumes \"P \\<Longrightarrow> CNV Q Q'\"\n    assumes \"PP \\<longrightarrow> Q'\"\n    shows \"PP \\<longrightarrow> (P \\<longrightarrow> Q)\"", "lemma CNV_split:\n    assumes \"CNV A A'\"\n    assumes \"CNV B B'\"\n    shows \"CNV (A \\<and> B) (A' \\<and> B')\"", "lemma CNV_prove:\n    assumes \"P\"  \n    shows \"CNV P True\"", "lemma simp_pre_final_simp:   \n    assumes \"CNV P P'\"\n    shows \"P' \\<longrightarrow> P\"", "lemma auto_weaken_pre_uncurry_step':\n    assumes \"PROTECT f a \\<equiv> f'\"\n    shows \"PROTECT (uncurry f) (a,b) \\<equiv> f' b\"", "lemma add_PR_CONST_to_def: \"x\\<equiv>y \\<Longrightarrow> PR_CONST x \\<equiv> y\"", "lemma vcg_of_RETURN_np:  \n    assumes \"f \\<equiv> RETURN r\"\n    shows \"SPEC (\\<lambda>x. x=r) \\<le> m \\<Longrightarrow> f \\<le> m\"\n      and \"SPEC (\\<lambda>x. x=r) \\<le>\\<^sub>n m \\<Longrightarrow> f \\<le>\\<^sub>n m\"", "lemma vcg_of_RETURN:\n    assumes \"f \\<equiv> do { ASSERT \\<Phi>; RETURN r }\"\n    shows \"\\<lbrakk>\\<Phi>; SPEC (\\<lambda>x. x=r) \\<le> m\\<rbrakk> \\<Longrightarrow> f \\<le> m\"\n      and \"\\<lbrakk>\\<Phi> \\<Longrightarrow> SPEC (\\<lambda>x. x=r) \\<le>\\<^sub>n m\\<rbrakk> \\<Longrightarrow> f \\<le>\\<^sub>n m\"", "lemma vcg_of_SPEC:  \n    assumes \"f \\<equiv> do { ASSERT pre; SPEC post }\"\n    shows \"\\<lbrakk>pre; SPEC post \\<le> m\\<rbrakk> \\<Longrightarrow> f \\<le> m\"\n      and \"\\<lbrakk>pre \\<Longrightarrow> SPEC post \\<le>\\<^sub>n m\\<rbrakk> \\<Longrightarrow> f \\<le>\\<^sub>n m\"", "lemma vcg_of_SPEC_np:  \n    assumes \"f \\<equiv> SPEC post\"\n    shows \"SPEC post \\<le> m \\<Longrightarrow> f \\<le> m\"\n      and \"SPEC post \\<le>\\<^sub>n m \\<Longrightarrow> f \\<le>\\<^sub>n m\"", "lemma mk_mop_rl1:\n    assumes \"\\<And>x. mf x \\<equiv> ASSERT (P x) \\<then> RETURN (f x)\"\n    shows \"(RETURN o f, mf) \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\"", "lemma mk_mop_rl2:\n    assumes \"\\<And>x y. mf x y \\<equiv> ASSERT (P x y) \\<then> RETURN (f x y)\"\n    shows \"(RETURN oo f, mf) \\<in> Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\"", "lemma mk_mop_rl3:\n    assumes \"\\<And>x y z. mf x y z \\<equiv> ASSERT (P x y z) \\<then> RETURN (f x y z)\"\n    shows \"(RETURN ooo f, mf) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\"", "lemma mk_mop_rl0_np:\n    assumes \"mf \\<equiv> RETURN f\"\n    shows \"(RETURN f, mf) \\<in> \\<langle>Id\\<rangle>nres_rel\"", "lemma mk_mop_rl1_np:\n    assumes \"\\<And>x. mf x \\<equiv> RETURN (f x)\"\n    shows \"(RETURN o f, mf) \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\"", "lemma mk_mop_rl2_np:\n    assumes \"\\<And>x y. mf x y \\<equiv> RETURN (f x y)\"\n    shows \"(RETURN oo f, mf) \\<in> Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\"", "lemma mk_mop_rl3_np:\n    assumes \"\\<And>x y z. mf x y z \\<equiv> RETURN (f x y z)\"\n    shows \"(RETURN ooo f, mf) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\"", "lemma mk_op_rl0_np:\n    assumes \"mf \\<equiv> RETURN f\"\n    shows \"(uncurry0 mf, uncurry0 (RETURN f)) \\<in> unit_rel \\<rightarrow>\\<^sub>f \\<langle>Id\\<rangle>nres_rel\"", "lemma mk_op_rl1:\n    assumes \"\\<And>x. mf x \\<equiv> ASSERT (P x) \\<then> RETURN (f x)\"\n    shows \"(mf, RETURN o f) \\<in> [P]\\<^sub>f Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\"", "lemma mk_op_rl1_np:\n    assumes \"\\<And>x. mf x \\<equiv> RETURN (f x)\"\n    shows \"(mf, (RETURN o f)) \\<in> Id \\<rightarrow>\\<^sub>f \\<langle>Id\\<rangle>nres_rel\"", "lemma mk_op_rl2:\n    assumes \"\\<And>x y. mf x y \\<equiv> ASSERT (P x y) \\<then> RETURN (f x y)\"\n    shows \"(uncurry mf, uncurry (RETURN oo f)) \\<in> [uncurry P]\\<^sub>f Id\\<times>\\<^sub>rId \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\"", "lemma mk_op_rl2_np:\n    assumes \"\\<And>x y. mf x y \\<equiv> RETURN (f x y)\"\n    shows \"(uncurry mf, uncurry (RETURN oo f)) \\<in> Id\\<times>\\<^sub>rId \\<rightarrow>\\<^sub>f \\<langle>Id\\<rangle>nres_rel\"", "lemma mk_op_rl3:\n    assumes \"\\<And>x y z. mf x y z \\<equiv> ASSERT (P x y z) \\<then> RETURN (f x y z)\"\n    shows \"(uncurry2 mf, uncurry2 (RETURN ooo f)) \\<in> [uncurry2 P]\\<^sub>f (Id\\<times>\\<^sub>rId)\\<times>\\<^sub>rId \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\"", "lemma mk_op_rl3_np:\n    assumes \"\\<And>x y z. mf x y z \\<equiv> RETURN (f x y z)\"\n    shows \"(uncurry2 mf, uncurry2 (RETURN ooo f)) \\<in> (Id\\<times>\\<^sub>rId)\\<times>\\<^sub>rId \\<rightarrow>\\<^sub>f \\<langle>Id\\<rangle>nres_rel\""], "translations": [["", "lemma intf_of_relI: \"INTF_OF_REL (R::(_\\<times>'a) set) TYPE('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. INTF_OF_REL R TYPE('a)", "by simp"], ["", "declare intf_of_relI[synth_rules] \\<comment> \\<open>Declare as fallback rule\\<close>"], ["", "lemma [synth_rules]:\n    \"INTF_OF_REL unit_rel TYPE(unit)\"\n    \"INTF_OF_REL nat_rel TYPE(nat)\"\n    \"INTF_OF_REL int_rel TYPE(int)\"\n    \"INTF_OF_REL bool_rel TYPE(bool)\"\n\n    \"INTF_OF_REL R TYPE('a) \\<Longrightarrow> INTF_OF_REL (\\<langle>R\\<rangle>option_rel) TYPE('a option)\"\n    \"INTF_OF_REL R TYPE('a) \\<Longrightarrow> INTF_OF_REL (\\<langle>R\\<rangle>list_rel) TYPE('a list)\"\n    \"INTF_OF_REL R TYPE('a) \\<Longrightarrow> INTF_OF_REL (\\<langle>R\\<rangle>nres_rel) TYPE('a nres)\"\n    \"\\<lbrakk>INTF_OF_REL R TYPE('a); INTF_OF_REL S TYPE('b)\\<rbrakk> \\<Longrightarrow> INTF_OF_REL (R\\<times>\\<^sub>rS) TYPE('a\\<times>'b)\"\n    \"\\<lbrakk>INTF_OF_REL R TYPE('a); INTF_OF_REL S TYPE('b)\\<rbrakk> \\<Longrightarrow> INTF_OF_REL (\\<langle>R,S\\<rangle>sum_rel) TYPE('a+'b)\"\n    \"\\<lbrakk>INTF_OF_REL R TYPE('a); INTF_OF_REL S TYPE('b)\\<rbrakk> \\<Longrightarrow> INTF_OF_REL (R\\<rightarrow>S) TYPE('a\\<Rightarrow>'b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((INTF_OF_REL unit_rel TYPE(unit) &&& INTF_OF_REL nat_rel TYPE(nat)) &&&\n     INTF_OF_REL int_rel TYPE(int) &&&\n     INTF_OF_REL bool_rel TYPE(bool) &&&\n     (INTF_OF_REL R TYPE('a) \\<Longrightarrow>\n      INTF_OF_REL (\\<langle>R\\<rangle>option_rel) TYPE('a option))) &&&\n    ((INTF_OF_REL R TYPE('a) \\<Longrightarrow>\n      INTF_OF_REL (\\<langle>R\\<rangle>list_rel) TYPE('a list)) &&&\n     (INTF_OF_REL R TYPE('a) \\<Longrightarrow>\n      INTF_OF_REL (\\<langle>R\\<rangle>nres_rel) TYPE('a nres))) &&&\n    (\\<lbrakk>INTF_OF_REL R TYPE('a); INTF_OF_REL S TYPE('b)\\<rbrakk>\n     \\<Longrightarrow> INTF_OF_REL (R \\<times>\\<^sub>r S)\n                        TYPE('a \\<times> 'b)) &&&\n    (\\<lbrakk>INTF_OF_REL R TYPE('a); INTF_OF_REL S TYPE('b)\\<rbrakk>\n     \\<Longrightarrow> INTF_OF_REL (\\<langle>R, S\\<rangle>sum_rel)\n                        TYPE('a + 'b)) &&&\n    (\\<lbrakk>INTF_OF_REL R TYPE('a); INTF_OF_REL S TYPE('b)\\<rbrakk>\n     \\<Longrightarrow> INTF_OF_REL (R \\<rightarrow> S)\n                        TYPE('a \\<Rightarrow> 'b))", "by simp_all"], ["", "lemma synth_intf_of_relI: \"INTF_OF_REL R I \\<Longrightarrow> SYNTH_TERM R I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. INTF_OF_REL R I \\<Longrightarrow> SYNTH_TERM R I", "by simp"], ["", "subsection \\<open>Operations with Precondition\\<close>"], ["", "definition mop :: \"('a\\<Rightarrow>bool) \\<Rightarrow> ('a\\<Rightarrow>'b nres) \\<Rightarrow> 'a \\<Rightarrow> 'b nres\"\n    \\<comment> \\<open>Package operation with precondition\\<close>\n    where [simp]: \"mop P f \\<equiv> \\<lambda>x. ASSERT (P x) \\<then> f x\""], ["", "lemma param_op_mop_iff:\n    assumes \"(Q,P)\\<in>R\\<rightarrow>bool_rel\"\n    shows \n    \"(f, g) \\<in> [P]\\<^sub>f R \\<rightarrow> \\<langle>S\\<rangle>nres_rel\n    \\<longleftrightarrow> \n    (mop Q f, mop P g) \\<in> R \\<rightarrow>\\<^sub>f \\<langle>S\\<rangle>nres_rel\n    \""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((f, g) \\<in> [P]\\<^sub>f R \\<rightarrow> \\<langle>S\\<rangle>nres_rel) =\n    ((mop Q f, mop P g)\n     \\<in> R \\<rightarrow>\\<^sub>f \\<langle>S\\<rangle>nres_rel)", "using assms"], ["proof (prove)\nusing this:\n  (Q, P) \\<in> R \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. ((f, g) \\<in> [P]\\<^sub>f R \\<rightarrow> \\<langle>S\\<rangle>nres_rel) =\n    ((mop Q f, mop P g)\n     \\<in> R \\<rightarrow>\\<^sub>f \\<langle>S\\<rangle>nres_rel)", "by (auto \n      simp: mop_def fref_def pw_nres_rel_iff refine_pw_simps\n      dest: fun_relD)"], ["", "lemma param_mopI:\n    assumes \"(f,g) \\<in> [P]\\<^sub>f R \\<rightarrow> \\<langle>S\\<rangle>nres_rel\"  \n    assumes \"(Q,P) \\<in> R \\<rightarrow> bool_rel\"\n    shows \"(mop Q f, mop P g) \\<in> R \\<rightarrow>\\<^sub>f \\<langle>S\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mop Q f, mop P g)\n    \\<in> R \\<rightarrow>\\<^sub>f \\<langle>S\\<rangle>nres_rel", "using assms"], ["proof (prove)\nusing this:\n  (f, g) \\<in> [P]\\<^sub>f R \\<rightarrow> \\<langle>S\\<rangle>nres_rel\n  (Q, P) \\<in> R \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. (mop Q f, mop P g)\n    \\<in> R \\<rightarrow>\\<^sub>f \\<langle>S\\<rangle>nres_rel", "by (simp add: param_op_mop_iff)"], ["", "lemma mop_spec_rl: \"P x \\<Longrightarrow> mop P f x \\<le> f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x \\<Longrightarrow> mop P f x \\<le> f x", "by simp"], ["", "lemma mop_spec_rl_from_def:  \n    assumes \"f \\<equiv> mop P g\"\n    assumes \"P x\"\n    assumes \"g x \\<le> z\"\n    shows \"f x \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<le> z", "using assms mop_spec_rl"], ["proof (prove)\nusing this:\n  f \\<equiv> mop P g\n  P x\n  g x \\<le> z\n  ?P ?x \\<Longrightarrow> mop ?P ?f ?x \\<le> ?f ?x\n\ngoal (1 subgoal):\n 1. f x \\<le> z", "by simp"], ["", "lemma mop_leof_rl_from_def:  \n    assumes \"f \\<equiv> mop P g\"\n    assumes \"P x \\<Longrightarrow> g x \\<le>\\<^sub>n z\"\n    shows \"f x \\<le>\\<^sub>n z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<le>\\<^sub>n z", "using assms"], ["proof (prove)\nusing this:\n  f \\<equiv> mop P g\n  P x \\<Longrightarrow> g x \\<le>\\<^sub>n z\n\ngoal (1 subgoal):\n 1. f x \\<le>\\<^sub>n z", "by (simp add: pw_leof_iff refine_pw_simps)"], ["", "lemma assert_true_bind_conv: \"ASSERT True \\<then> m = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT True \\<bind> (\\<lambda>_. m) = m", "by simp"], ["", "lemmas mop_alt_unfolds = curry_def curry0_def mop_def uncurry_apply uncurry0_apply o_apply assert_true_bind_conv"], ["", "subsection \\<open>Constraints\\<close>"], ["", "lemma add_is_pure_constraint: \"\\<lbrakk>PROP P; CONSTRAINT is_pure A\\<rbrakk> \\<Longrightarrow> PROP P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PROP P; CONSTRAINT is_pure A\\<rbrakk> \\<Longrightarrow> PROP P", "."], ["", "lemma sepref_relpropI: \"P R = CONSTRAINT P R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P R = CONSTRAINT P R", "by simp"], ["", "subsubsection \\<open>Purity\\<close>"], ["", "lemmas [constraint_simps] = the_pure_pure"], ["", "definition [constraint_abbrevs]: \"IS_PURE P R \\<equiv> is_pure R \\<and> P (the_pure R)\""], ["", "lemma IS_PURE_pureI: \n  \"P R \\<Longrightarrow> IS_PURE P (pure R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P R \\<Longrightarrow> IS_PURE P (pure R)", "by (auto simp: IS_PURE_def)"], ["", "lemma [fcomp_norm_simps]: \"CONSTRAINT (IS_PURE \\<Phi>) P \\<Longrightarrow> pure (the_pure P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT (IS_PURE \\<Phi>) P \\<Longrightarrow> pure (the_pure P) = P", "by (simp add: IS_PURE_def)"], ["", "lemma [fcomp_norm_simps]: \"CONSTRAINT (IS_PURE P) A \\<Longrightarrow> P (the_pure A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT (IS_PURE P) A \\<Longrightarrow> P (the_pure A)", "by (auto simp: IS_PURE_def)"], ["", "lemma handle_purity1: \n  \"CONSTRAINT (IS_PURE \\<Phi>) A \\<Longrightarrow> CONSTRAINT \\<Phi> (the_pure A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT (IS_PURE \\<Phi>) A \\<Longrightarrow>\n    CONSTRAINT \\<Phi> (the_pure A)", "by (auto simp: IS_PURE_def)"], ["", "lemma handle_purity2:\n  \"CONSTRAINT (IS_PURE \\<Phi>) A \\<Longrightarrow> CONSTRAINT is_pure A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT (IS_PURE \\<Phi>) A \\<Longrightarrow> CONSTRAINT is_pure A", "by (auto simp: IS_PURE_def)"], ["", "subsection \\<open>Composition\\<close>"], ["", "(* TODO/FIXME: Overlaps with FCOMP! *)"], ["", "subsubsection \\<open>Preconditions\\<close>"], ["", "definition [simp]: \"tcomp_pre Q T P \\<equiv> \\<lambda>a. Q a \\<and> (\\<forall>a'. (a', a) \\<in> T \\<longrightarrow> P a')\""], ["", "definition \"and_pre P1 P2 \\<equiv> \\<lambda>x. P1 x \\<and> P2 x\""], ["", "definition \"imp_pre P1 P2 \\<equiv> \\<lambda>x. P1 x \\<longrightarrow> P2 x\""], ["", "lemma and_pre_beta: \"PP \\<longrightarrow> P x \\<and> Q x \\<Longrightarrow> PP \\<longrightarrow> and_pre P Q x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PP \\<longrightarrow> P x \\<and> Q x \\<Longrightarrow>\n    PP \\<longrightarrow> and_pre P Q x", "by (auto simp: and_pre_def)"], ["", "lemma imp_pre_beta: \"PP \\<longrightarrow> P x \\<longrightarrow> Q x \\<Longrightarrow> PP \\<longrightarrow> imp_pre P Q x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PP \\<longrightarrow> P x \\<longrightarrow> Q x \\<Longrightarrow>\n    PP \\<longrightarrow> imp_pre P Q x", "by (auto simp: imp_pre_def)"], ["", "definition \"IMP_PRE P1 P2 \\<equiv> \\<forall>x. P1 x \\<longrightarrow> P2 x\""], ["", "lemma IMP_PRED: \"IMP_PRE P1 P2 \\<Longrightarrow> P1 x \\<Longrightarrow> P2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IMP_PRE P1 P2; P1 x\\<rbrakk> \\<Longrightarrow> P2 x", "unfolding IMP_PRE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x. P1 x \\<longrightarrow> P2 x; P1 x\\<rbrakk>\n    \\<Longrightarrow> P2 x", "by auto"], ["", "lemma IMP_PRE_refl: \"IMP_PRE P P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IMP_PRE P P", "unfolding IMP_PRE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. P x \\<longrightarrow> P x", "by auto"], ["", "definition \"IMP_PRE_CUSTOM \\<equiv> IMP_PRE\""], ["", "lemma IMP_PRE_CUSTOMD: \"IMP_PRE_CUSTOM P1 P2 \\<Longrightarrow> IMP_PRE P1 P2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IMP_PRE_CUSTOM P1 P2 \\<Longrightarrow> IMP_PRE P1 P2", "by (simp add: IMP_PRE_CUSTOM_def)"], ["", "lemma IMP_PRE_CUSTOMI: \"\\<lbrakk>\\<And>x. P1 x \\<Longrightarrow> P2 x\\<rbrakk> \\<Longrightarrow> IMP_PRE_CUSTOM P1 P2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. P1 x \\<Longrightarrow> P2 x) \\<Longrightarrow>\n    IMP_PRE_CUSTOM P1 P2", "by (simp add: IMP_PRE_CUSTOM_def IMP_PRE_def)"], ["", "lemma imp_and_triv_pre: \"IMP_PRE P (and_pre (\\<lambda>_. True) P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IMP_PRE P (and_pre (\\<lambda>_. True) P)", "unfolding IMP_PRE_def and_pre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. P x \\<longrightarrow> True \\<and> P x", "by auto"], ["", "subsubsection \\<open>Premises\\<close>"], ["", "definition \"ALL_LIST A \\<equiv> (\\<forall>x\\<in>set A. x)\""], ["", "definition \"IMP_LIST A B \\<equiv> ALL_LIST A \\<longrightarrow> B\""], ["", "lemma to_IMP_LISTI:\n    \"P \\<Longrightarrow> IMP_LIST [] P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow> IMP_LIST [] P", "by (auto simp: IMP_LIST_def)"], ["", "lemma to_IMP_LIST: \"(P \\<Longrightarrow> IMP_LIST Ps Q) \\<equiv> Trueprop (IMP_LIST (P#Ps) Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<Longrightarrow> IMP_LIST Ps Q) \\<equiv> IMP_LIST (P # Ps) Q", "by (auto simp: IMP_LIST_def ALL_LIST_def intro!: equal_intr_rule)"], ["", "lemma from_IMP_LIST:\n    \"Trueprop (IMP_LIST As B) \\<equiv> (ALL_LIST As \\<Longrightarrow> B)\"\n    \"(ALL_LIST [] \\<Longrightarrow> B) \\<equiv> Trueprop B\"\n    \"(ALL_LIST (A#As) \\<Longrightarrow> B) \\<equiv> (A \\<Longrightarrow> ALL_LIST As \\<Longrightarrow> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (IMP_LIST As B \\<equiv> (ALL_LIST As \\<Longrightarrow> B)) &&&\n    ((ALL_LIST [] \\<Longrightarrow> B) \\<equiv> B) &&&\n    (ALL_LIST (A # As) \\<Longrightarrow> B) \\<equiv>\n    (\\<lbrakk>A; ALL_LIST As\\<rbrakk> \\<Longrightarrow> B)", "by (auto simp: IMP_LIST_def ALL_LIST_def intro!: equal_intr_rule)"], ["", "lemma IMP_LIST_trivial: \"IMP_LIST A B \\<Longrightarrow> IMP_LIST A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IMP_LIST A B \\<Longrightarrow> IMP_LIST A B", "."], ["", "subsubsection \\<open>Composition Rules\\<close>"], ["", "lemma hfcomp_tcomp_pre:\n    assumes B: \"(g,h) \\<in> [Q]\\<^sub>f T \\<rightarrow> \\<langle>U\\<rangle>nres_rel\"\n    assumes A: \"(f,g) \\<in> [P]\\<^sub>a RR' \\<rightarrow> S\"\n    shows \"(f,h) \\<in> [tcomp_pre Q T P]\\<^sub>a hrp_comp RR' T \\<rightarrow> hr_comp S U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, h)\n    \\<in> [tcomp_pre Q T P]\\<^sub>a hrp_comp RR' T \\<rightarrow> hr_comp S U", "using hfcomp[OF A B]"], ["proof (prove)\nusing this:\n  (f, h)\n  \\<in> [\\<lambda>a.\n            Q a \\<and>\n            (\\<forall>a'.\n                (a', a) \\<in> T \\<longrightarrow>\n                P a')]\\<^sub>a hrp_comp RR' T \\<rightarrow> hr_comp S U\n\ngoal (1 subgoal):\n 1. (f, h)\n    \\<in> [tcomp_pre Q T P]\\<^sub>a hrp_comp RR' T \\<rightarrow> hr_comp S U", "by simp"], ["", "lemma transform_pre_param:\n    assumes A: \"IMP_LIST Cns ((f, h) \\<in> [tcomp_pre Q T P]\\<^sub>a hrp_comp RR' T \\<rightarrow> hr_comp S U)\"\n    assumes P: \"IMP_LIST Cns ((P,P') \\<in> T \\<rightarrow> bool_rel)\"\n    assumes C: \"IMP_PRE PP' (and_pre P' Q)\"\n    shows \"IMP_LIST Cns ((f,h) \\<in> [PP']\\<^sub>a hrp_comp RR' T \\<rightarrow> hr_comp S U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IMP_LIST Cns\n     ((f, h) \\<in> [PP']\\<^sub>a hrp_comp RR' T \\<rightarrow> hr_comp S U)", "unfolding from_IMP_LIST"], ["proof (prove)\ngoal (1 subgoal):\n 1. ALL_LIST Cns \\<Longrightarrow>\n    (f, h) \\<in> [PP']\\<^sub>a hrp_comp RR' T \\<rightarrow> hr_comp S U", "apply (rule hfref_cons)"], ["proof (prove)\ngoal (5 subgoals):\n 1. ALL_LIST Cns \\<Longrightarrow>\n    (f, h) \\<in> [?P]\\<^sub>a ?R \\<rightarrow> ?S\n 2. \\<And>x. \\<lbrakk>ALL_LIST Cns; PP' x\\<rbrakk> \\<Longrightarrow> ?P x\n 3. \\<And>x y.\n       ALL_LIST Cns \\<Longrightarrow>\n       fst (hrp_comp RR' T) x y \\<Longrightarrow>\\<^sub>t fst ?R x y\n 4. \\<And>x y.\n       ALL_LIST Cns \\<Longrightarrow>\n       snd ?R x y \\<Longrightarrow>\\<^sub>t snd (hrp_comp RR' T) x y\n 5. \\<And>x y.\n       ALL_LIST Cns \\<Longrightarrow>\n       ?S x y \\<Longrightarrow>\\<^sub>t hr_comp S U x y", "apply (rule A[unfolded from_IMP_LIST])"], ["proof (prove)\ngoal (5 subgoals):\n 1. ALL_LIST Cns \\<Longrightarrow> ALL_LIST Cns\n 2. \\<And>x.\n       \\<lbrakk>ALL_LIST Cns; PP' x\\<rbrakk>\n       \\<Longrightarrow> tcomp_pre Q T P x\n 3. \\<And>x y.\n       ALL_LIST Cns \\<Longrightarrow>\n       fst (hrp_comp RR' T) x y \\<Longrightarrow>\\<^sub>t\n       fst (hrp_comp RR' T) x y\n 4. \\<And>x y.\n       ALL_LIST Cns \\<Longrightarrow>\n       snd (hrp_comp RR' T) x y \\<Longrightarrow>\\<^sub>t\n       snd (hrp_comp RR' T) x y\n 5. \\<And>x y.\n       ALL_LIST Cns \\<Longrightarrow>\n       hr_comp S U x y \\<Longrightarrow>\\<^sub>t hr_comp S U x y", "apply assumption"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>ALL_LIST Cns; PP' x\\<rbrakk>\n       \\<Longrightarrow> tcomp_pre Q T P x\n 2. \\<And>x y.\n       ALL_LIST Cns \\<Longrightarrow>\n       fst (hrp_comp RR' T) x y \\<Longrightarrow>\\<^sub>t\n       fst (hrp_comp RR' T) x y\n 3. \\<And>x y.\n       ALL_LIST Cns \\<Longrightarrow>\n       snd (hrp_comp RR' T) x y \\<Longrightarrow>\\<^sub>t\n       snd (hrp_comp RR' T) x y\n 4. \\<And>x y.\n       ALL_LIST Cns \\<Longrightarrow>\n       hr_comp S U x y \\<Longrightarrow>\\<^sub>t hr_comp S U x y", "apply (drule IMP_PRED[OF C])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>ALL_LIST Cns; and_pre P' Q x\\<rbrakk>\n       \\<Longrightarrow> tcomp_pre Q T P x\n 2. \\<And>x y.\n       ALL_LIST Cns \\<Longrightarrow>\n       fst (hrp_comp RR' T) x y \\<Longrightarrow>\\<^sub>t\n       fst (hrp_comp RR' T) x y\n 3. \\<And>x y.\n       ALL_LIST Cns \\<Longrightarrow>\n       snd (hrp_comp RR' T) x y \\<Longrightarrow>\\<^sub>t\n       snd (hrp_comp RR' T) x y\n 4. \\<And>x y.\n       ALL_LIST Cns \\<Longrightarrow>\n       hr_comp S U x y \\<Longrightarrow>\\<^sub>t hr_comp S U x y", "using P[unfolded from_IMP_LIST]"], ["proof (prove)\nusing this:\n  ALL_LIST Cns \\<Longrightarrow> (P, P') \\<in> T \\<rightarrow> bool_rel\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>ALL_LIST Cns; and_pre P' Q x\\<rbrakk>\n       \\<Longrightarrow> tcomp_pre Q T P x\n 2. \\<And>x y.\n       ALL_LIST Cns \\<Longrightarrow>\n       fst (hrp_comp RR' T) x y \\<Longrightarrow>\\<^sub>t\n       fst (hrp_comp RR' T) x y\n 3. \\<And>x y.\n       ALL_LIST Cns \\<Longrightarrow>\n       snd (hrp_comp RR' T) x y \\<Longrightarrow>\\<^sub>t\n       snd (hrp_comp RR' T) x y\n 4. \\<And>x y.\n       ALL_LIST Cns \\<Longrightarrow>\n       hr_comp S U x y \\<Longrightarrow>\\<^sub>t hr_comp S U x y", "unfolding and_pre_def"], ["proof (prove)\nusing this:\n  ALL_LIST Cns \\<Longrightarrow> (P, P') \\<in> T \\<rightarrow> bool_rel\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>ALL_LIST Cns; P' x \\<and> Q x\\<rbrakk>\n       \\<Longrightarrow> tcomp_pre Q T P x\n 2. \\<And>x y.\n       ALL_LIST Cns \\<Longrightarrow>\n       fst (hrp_comp RR' T) x y \\<Longrightarrow>\\<^sub>t\n       fst (hrp_comp RR' T) x y\n 3. \\<And>x y.\n       ALL_LIST Cns \\<Longrightarrow>\n       snd (hrp_comp RR' T) x y \\<Longrightarrow>\\<^sub>t\n       snd (hrp_comp RR' T) x y\n 4. \\<And>x y.\n       ALL_LIST Cns \\<Longrightarrow>\n       hr_comp S U x y \\<Longrightarrow>\\<^sub>t hr_comp S U x y", "apply (auto dest: fun_relD) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       ALL_LIST Cns \\<Longrightarrow>\n       fst (hrp_comp RR' T) x y \\<Longrightarrow>\\<^sub>t\n       fst (hrp_comp RR' T) x y\n 2. \\<And>x y.\n       ALL_LIST Cns \\<Longrightarrow>\n       snd (hrp_comp RR' T) x y \\<Longrightarrow>\\<^sub>t\n       snd (hrp_comp RR' T) x y\n 3. \\<And>x y.\n       ALL_LIST Cns \\<Longrightarrow>\n       hr_comp S U x y \\<Longrightarrow>\\<^sub>t hr_comp S U x y", "by simp_all"], ["", "lemma hfref_mop_conv: \"((g,mop P f) \\<in> [Q]\\<^sub>a R \\<rightarrow> S) \\<longleftrightarrow> (g,f) \\<in> [\\<lambda>x. P x \\<and> Q x]\\<^sub>a R \\<rightarrow> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((g, mop P f) \\<in> [Q]\\<^sub>a R \\<rightarrow> S) =\n    ((g, f) \\<in> [\\<lambda>x. P x \\<and> Q x]\\<^sub>a R \\<rightarrow> S)", "apply (simp add: hfref_to_ASSERT_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((g, \\<lambda>x.\n            ASSERT (Q x) \\<bind>\n            (\\<lambda>_. ASSERT (P x) \\<bind> (\\<lambda>_. f x)))\n     \\<in> R \\<rightarrow>\\<^sub>a S) =\n    ((g, \\<lambda>x. ASSERT (P x \\<and> Q x) \\<bind> (\\<lambda>_. f x))\n     \\<in> R \\<rightarrow>\\<^sub>a S)", "apply (fo_rule arg_cong fun_cong)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        ASSERT (Q x) \\<bind>\n        (\\<lambda>_. ASSERT (P x) \\<bind> (\\<lambda>_. f x))) =\n    (\\<lambda>x. ASSERT (P x \\<and> Q x) \\<bind> (\\<lambda>_. f x))", "by (auto intro!: ext simp: pw_eq_iff refine_pw_simps)"], ["", "lemma hfref_op_to_mop:\n    assumes R: \"(impl,f) \\<in> [Q]\\<^sub>a R \\<rightarrow> S\"\n    assumes DEF: \"mf \\<equiv> mop P f\"\n    assumes C: \"IMP_PRE PP' (imp_pre P Q)\"\n    shows \"(impl,mf) \\<in> [PP']\\<^sub>a R \\<rightarrow> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (impl, mf) \\<in> [PP']\\<^sub>a R \\<rightarrow> S", "unfolding DEF hfref_mop_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (impl, f) \\<in> [\\<lambda>x. P x \\<and> PP' x]\\<^sub>a R \\<rightarrow> S", "apply (rule hfref_cons[OF R])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. P x \\<and> PP' x \\<Longrightarrow> Q x\n 2. \\<And>x y. fst R x y \\<Longrightarrow>\\<^sub>t fst R x y\n 3. \\<And>x y. snd R x y \\<Longrightarrow>\\<^sub>t snd R x y\n 4. \\<And>x y. S x y \\<Longrightarrow>\\<^sub>t S x y", "using C"], ["proof (prove)\nusing this:\n  IMP_PRE PP' (imp_pre P Q)\n\ngoal (4 subgoals):\n 1. \\<And>x. P x \\<and> PP' x \\<Longrightarrow> Q x\n 2. \\<And>x y. fst R x y \\<Longrightarrow>\\<^sub>t fst R x y\n 3. \\<And>x y. snd R x y \\<Longrightarrow>\\<^sub>t snd R x y\n 4. \\<And>x y. S x y \\<Longrightarrow>\\<^sub>t S x y", "by (auto simp: IMP_PRE_def imp_pre_def)"], ["", "lemma hfref_mop_to_op:\n    assumes R: \"(impl,mf) \\<in> [Q]\\<^sub>a R \\<rightarrow> S\"\n    assumes DEF: \"mf \\<equiv> mop P f\"\n    assumes C: \"IMP_PRE PP' (and_pre Q P)\"\n    shows \"(impl,f) \\<in> [PP']\\<^sub>a R \\<rightarrow> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (impl, f) \\<in> [PP']\\<^sub>a R \\<rightarrow> S", "using R"], ["proof (prove)\nusing this:\n  (impl, mf) \\<in> [Q]\\<^sub>a R \\<rightarrow> S\n\ngoal (1 subgoal):\n 1. (impl, f) \\<in> [PP']\\<^sub>a R \\<rightarrow> S", "unfolding DEF hfref_mop_conv"], ["proof (prove)\nusing this:\n  (impl, f) \\<in> [\\<lambda>x. P x \\<and> Q x]\\<^sub>a R \\<rightarrow> S\n\ngoal (1 subgoal):\n 1. (impl, f) \\<in> [PP']\\<^sub>a R \\<rightarrow> S", "apply (rule hfref_cons)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. PP' x \\<Longrightarrow> P x \\<and> Q x\n 2. \\<And>x y. fst R x y \\<Longrightarrow>\\<^sub>t fst R x y\n 3. \\<And>x y. snd R x y \\<Longrightarrow>\\<^sub>t snd R x y\n 4. \\<And>x y. S x y \\<Longrightarrow>\\<^sub>t S x y", "using C"], ["proof (prove)\nusing this:\n  IMP_PRE PP' (and_pre Q P)\n\ngoal (4 subgoals):\n 1. \\<And>x. PP' x \\<Longrightarrow> P x \\<and> Q x\n 2. \\<And>x y. fst R x y \\<Longrightarrow>\\<^sub>t fst R x y\n 3. \\<And>x y. snd R x y \\<Longrightarrow>\\<^sub>t snd R x y\n 4. \\<And>x y. S x y \\<Longrightarrow>\\<^sub>t S x y", "apply (auto simp: and_pre_def IMP_PRE_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Precondition Simplification\\<close>"], ["", "lemma IMP_PRE_eqI:\n    assumes \"\\<And>x. P x \\<longrightarrow> Q x\"\n    assumes \"CNV P P'\"\n    shows \"IMP_PRE P' Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IMP_PRE P' Q", "using assms"], ["proof (prove)\nusing this:\n  P ?x \\<longrightarrow> Q ?x\n  CNV P P'\n\ngoal (1 subgoal):\n 1. IMP_PRE P' Q", "by (auto simp: IMP_PRE_def)"], ["", "lemma simp_and1:\n    assumes \"Q \\<Longrightarrow> CNV P P'\"\n    assumes \"PP \\<longrightarrow> P' \\<and> Q\"\n    shows \"PP \\<longrightarrow> P \\<and> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PP \\<longrightarrow> P \\<and> Q", "using assms"], ["proof (prove)\nusing this:\n  Q \\<Longrightarrow> CNV P P'\n  PP \\<longrightarrow> P' \\<and> Q\n\ngoal (1 subgoal):\n 1. PP \\<longrightarrow> P \\<and> Q", "by auto"], ["", "lemma simp_and2:\n    assumes \"P \\<Longrightarrow> CNV Q Q'\"\n    assumes \"PP \\<longrightarrow> P \\<and> Q'\"\n    shows \"PP \\<longrightarrow> P \\<and> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PP \\<longrightarrow> P \\<and> Q", "using assms"], ["proof (prove)\nusing this:\n  P \\<Longrightarrow> CNV Q Q'\n  PP \\<longrightarrow> P \\<and> Q'\n\ngoal (1 subgoal):\n 1. PP \\<longrightarrow> P \\<and> Q", "by auto"], ["", "lemma triv_and1: \"Q \\<longrightarrow> True \\<and> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<longrightarrow> True \\<and> Q", "by blast"], ["", "lemma simp_imp:\n    assumes \"P \\<Longrightarrow> CNV Q Q'\"\n    assumes \"PP \\<longrightarrow> Q'\"\n    shows \"PP \\<longrightarrow> (P \\<longrightarrow> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PP \\<longrightarrow> P \\<longrightarrow> Q", "using assms"], ["proof (prove)\nusing this:\n  P \\<Longrightarrow> CNV Q Q'\n  PP \\<longrightarrow> Q'\n\ngoal (1 subgoal):\n 1. PP \\<longrightarrow> P \\<longrightarrow> Q", "by auto"], ["", "lemma CNV_split:\n    assumes \"CNV A A'\"\n    assumes \"CNV B B'\"\n    shows \"CNV (A \\<and> B) (A' \\<and> B')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV (A \\<and> B) (A' \\<and> B')", "using assms"], ["proof (prove)\nusing this:\n  CNV A A'\n  CNV B B'\n\ngoal (1 subgoal):\n 1. CNV (A \\<and> B) (A' \\<and> B')", "by auto"], ["", "lemma CNV_prove:\n    assumes \"P\"  \n    shows \"CNV P True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV P True", "using assms"], ["proof (prove)\nusing this:\n  P\n\ngoal (1 subgoal):\n 1. CNV P True", "by auto"], ["", "lemma simp_pre_final_simp:   \n    assumes \"CNV P P'\"\n    shows \"P' \\<longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P' \\<longrightarrow> P", "using assms"], ["proof (prove)\nusing this:\n  CNV P P'\n\ngoal (1 subgoal):\n 1. P' \\<longrightarrow> P", "by auto"], ["", "lemma auto_weaken_pre_uncurry_step':\n    assumes \"PROTECT f a \\<equiv> f'\"\n    shows \"PROTECT (uncurry f) (a,b) \\<equiv> f' b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PROTECT (uncurry f) (a, b) \\<equiv> f' b", "using assms"], ["proof (prove)\nusing this:\n  PROTECT f a \\<equiv> f'\n\ngoal (1 subgoal):\n 1. PROTECT (uncurry f) (a, b) \\<equiv> f' b", "by (auto simp: curry_def dest!: meta_eq_to_obj_eq intro!: eq_reflection)"], ["", "subsection \\<open>Protected Constants\\<close>"], ["", "lemma add_PR_CONST_to_def: \"x\\<equiv>y \\<Longrightarrow> PR_CONST x \\<equiv> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<equiv> y \\<Longrightarrow> PR_CONST x \\<equiv> y", "by simp"], ["", "subsection \\<open>Rule Collections\\<close>"], ["", "named_theorems_rev sepref_mop_def_thms \\<open>Sepref: mop - definition theorems\\<close>"], ["", "named_theorems_rev sepref_fref_thms \\<open>Sepref: fref-theorems\\<close>"], ["", "named_theorems sepref_relprops_transform \\<open>Sepref: Simp-rules to transform relator properties\\<close>"], ["", "named_theorems sepref_relprops \\<open>Sepref: Simp-rules to add CONSTRAINT-tags to relator properties\\<close>"], ["", "named_theorems sepref_relprops_simps \\<open>Sepref: Simp-rules to simplify relator properties\\<close>"], ["", "subsubsection \\<open>Default Setup\\<close>"], ["", "subsection \\<open>ML-Level Declarations\\<close>"], ["", "ML \\<open>\n    signature SEPREF_INTF_UTIL = sig\n      (* Miscellaneous*)\n      val list_filtered_subterms: (term -> 'a option) -> term -> 'a list\n\n\n      (* Interface types for relations *)\n      val get_intf_of_rel: Proof.context -> term -> typ\n\n      (* Constraints *)\n      (* Convert relations to pure assertions *)\n      val to_assns_rl: bool -> Proof.context -> thm -> thm\n      (* Recognize, summarize and simplify CONSTRAINT - premises *)\n      val cleanup_constraints: Proof.context -> thm -> thm\n\n      (* Preconditions *)\n      (* Simplify precondition. Goal must be in IMP_PRE or IMP_PRE_CUSTOM form. *)\n      val simp_precond_tac: Proof.context -> tactic'\n\n\n      (* Configuration options *)\n      val cfg_def: bool Config.T       (* decl_op: Define constant *)\n      val cfg_ismop: bool Config.T     (* decl_op: Specified term is mop *)\n      val cfg_mop: bool Config.T       (* decl_op, decl_impl: Derive mop *) \n      val cfg_rawgoals: bool Config.T  (* decl_op, decl_impl: Do not pre-process/solve goals *)\n\n\n      (* TODO: Make do_cmd usable from ML-level! *)\n\n    end\n\n    structure Sepref_Intf_Util: SEPREF_INTF_UTIL = struct\n  \n      val cfg_debug = \n        Attrib.setup_config_bool @{binding sepref_debug_intf_util} (K false)\n      \n      val dbg_trace = Sepref_Debugging.dbg_trace_msg cfg_debug  \n      val dbg_msg_tac = Sepref_Debugging.dbg_msg_tac cfg_debug  \n\n\n      fun list_filtered_subterms f t = let\n        fun r t = case f t of \n          SOME a => [a]\n        | NONE => (\n            case t of \n              t1$t2 => r t1 @ r t2\n            | Abs (_,_,t) => r t\n            | _ => []\n          )\n      in\n        r t\n      end\n  \n      fun get_intf_of_rel ctxt R = \n        Term_Synth.synth_term @{thms synth_intf_of_relI} ctxt R\n          |> fastype_of \n          |> Refine_Util.dest_itselfT\n  \n      local\n        fun add_is_pure_constraint ctxt v thm = let\n          val v = Thm.cterm_of ctxt v\n          val rl = Drule.infer_instantiate' ctxt [NONE, SOME v] @{thm add_is_pure_constraint}\n        in\n          thm RS rl\n        end\n      in  \n        fun to_assns_rl add_pure_constr ctxt thm = let\n          val orig_ctxt = ctxt\n      \n          val (thm,ctxt) = yield_singleton (apfst snd oo Variable.importT) thm ctxt\n      \n          val (R,S) = case Thm.concl_of thm of @{mpat \"Trueprop (_\\<in>fref _ ?R ?S)\"} => (R,S)\n            | _ => raise THM(\"to_assns_rl: expected fref-thm\",~1,[thm])\n      \n          fun mk_cn_subst (fname,(iname,C,A)) = \n            let\n              val T' = A --> C --> @{typ assn}\n              val v' = Free (fname,T')\n              val ct' = @{mk_term \"the_pure ?v'\"} |> Thm.cterm_of ctxt\n            in\n              (v',(iname,ct'))\n            end\n      \n          fun relation_flt (name,Type (@{type_name set},[Type (@{type_name prod},[C,A])])) = SOME (name,C,A)\n            | relation_flt _ = NONE  \n      \n            \n          val vars = []\n            |> Term.add_vars R \n            |> Term.add_vars S\n            |> map_filter (relation_flt) \n          val (names,ctxt) = Variable.variant_fixes (map (#1 #> fst) vars) ctxt\n          \n          val cn_substs = map mk_cn_subst (names ~~ vars)\n      \n      \n          val thm = Drule.infer_instantiate ctxt (map snd cn_substs) thm\n      \n          val thm = thm |> add_pure_constr ? fold (fn (v,_) => fn thm => add_is_pure_constraint ctxt v thm) cn_substs\n      \n          val thm = singleton (Variable.export ctxt orig_ctxt) thm\n        in\n          thm\n        end\n      \n        fun cleanup_constraints ctxt thm = let\n          val orig_ctxt = ctxt\n      \n          val (thm, ctxt) = yield_singleton (apfst snd oo Variable.import true) thm ctxt\n      \n          val xform_thms = Named_Theorems.get ctxt @{named_theorems sepref_relprops_transform}\n          val rprops_thms = Named_Theorems.get ctxt @{named_theorems sepref_relprops}\n          val simp_thms = Named_Theorems.get ctxt @{named_theorems sepref_relprops_simps}\n      \n          fun simp thms = Conv.fconv_rule (\n                  Simplifier.asm_full_rewrite \n                    (put_simpset HOL_basic_ss ctxt addsimps thms))\n      \n          (* Check for pure (the_pure R) - patterns *)\n      \n          local\n            val (_,R,S) = case Thm.concl_of thm of\n              @{mpat \"Trueprop (_\\<in>hfref ?P ?R ?S)\"} => (P,R,S)\n            | @{mpat \"Trueprop (_\\<in>fref ?P ?R ?S)\"} => (P,R,S)\n            | _ => raise THM(\"cleanup_constraints: Expected hfref or fref-theorem\",~1,[thm])  \n      \n      \n            fun flt_pat @{mpat \"pure (the_pure ?A)\"} = SOME A | flt_pat _ = NONE\n      \n            val purify_terms = \n              (list_filtered_subterms flt_pat R @ list_filtered_subterms flt_pat S)\n              |> distinct op aconv\n       \n            val thm = fold (add_is_pure_constraint ctxt) purify_terms thm\n          in\n            val thm = thm\n          end\n      \n          val thm = thm\n            |> Local_Defs.unfold0 ctxt xform_thms\n            |> Local_Defs.unfold0 ctxt rprops_thms\n      \n          val insts = map (fn \n              @{mpat \"Trueprop (CONSTRAINT _ (the_pure _))\"} => @{thm handle_purity1}\n            | _ => asm_rl  \n            ) (Thm.prems_of thm)  \n      \n          val thm = (thm OF insts)\n            |> Conv.fconv_rule Thm.eta_conversion\n            |> simp @{thms handle_purity2}\n            |> simp simp_thms\n      \n          val thm = singleton (Variable.export ctxt orig_ctxt) thm  \n      \n        in\n          thm\n        end\n      end  \n  \n      fun simp_precond_tac ctxt = let\n        fun simp_only thms = asm_full_simp_tac (put_simpset HOL_basic_ss ctxt addsimps thms)\n        val rtac = resolve_tac ctxt\n    \n        val cnv_ss = ctxt delsimps @{thms CNV_def}\n    \n        (*val uncurry_tac = SELECT_GOAL (ALLGOALS (DETERM o SOLVED' (\n          REPEAT' (rtac @{thms auto_weaken_pre_uncurry_step'}) \n          THEN' rtac @{thms auto_weaken_pre_uncurry_finish}\n        )))*)\n    \n        val prove_cnv_tac = SOLVED' (rtac @{thms CNV_prove} THEN' SELECT_GOAL (auto_tac ctxt))\n    \n        val do_cnv_tac = \n          (cp_clarsimp_tac cnv_ss) THEN_ALL_NEW\n          (TRY o REPEAT_ALL_NEW (match_tac ctxt @{thms CNV_split}))\n          THEN_ALL_NEW (prove_cnv_tac ORELSE' rtac @{thms CNV_I})\n    \n        val final_simp_tac = \n          rtac @{thms simp_pre_final_simp} \n          THEN' cp_clarsimp_tac cnv_ss\n          THEN' dbg_msg_tac (Sepref_Debugging.msg_subgoal \"final_simp_tac: Before CNV_I\") ctxt\n          THEN' rtac @{thms CNV_I}\n          THEN' dbg_msg_tac (Sepref_Debugging.msg_text \"Final-Simp done\") ctxt\n    \n        (*val curry_tac = let open Conv in\n          CONVERSION (Refine_Util.HOL_concl_conv (fn ctxt => arg1_conv (\n            top_conv ( fn _ => try_conv (rewr_conv @{thm uncurry_def})) ctxt)) ctxt)\n          THEN' REPEAT' (EqSubst.eqsubst_tac ctxt [1] @{thms case_prod_eta})\n          THEN' rtac @{thms CNV_I}\n          end*)\n\n        val simp_tupled_pre_tac = \n          SELECT_GOAL (Local_Defs.unfold0_tac ctxt @{thms prod_casesK uncurry0_hfref_post})\n          THEN' REPEAT' (EqSubst.eqsubst_tac ctxt [1] @{thms case_prod_eta})\n          THEN' rtac @{thms CNV_I}\n\n        val unfold_and_tac = rtac @{thms and_pre_beta} THEN_ALL_NEW simp_only @{thms split}\n    \n        val simp_and1_tac =  \n          rtac @{thms simp_and1} THEN' do_cnv_tac\n    \n        val simp_and2_tac =  \n          rtac @{thms simp_and2} THEN' do_cnv_tac\n    \n        val and_plan_tac =   \n          simp_and1_tac \n          THEN' dbg_msg_tac (Sepref_Debugging.msg_subgoal \"State after and1\") ctxt\n          THEN' (\n            rtac @{thms triv_and1}\n            ORELSE' \n            dbg_msg_tac (Sepref_Debugging.msg_subgoal \"Invoking and2 on\") ctxt\n            THEN' simp_and2_tac \n            THEN' dbg_msg_tac (Sepref_Debugging.msg_subgoal \"State before final_simp_tac\") ctxt\n            THEN' final_simp_tac\n          )\n    \n        val unfold_imp_tac = rtac @{thms imp_pre_beta} THEN_ALL_NEW simp_only @{thms split}\n        val simp_imp1_tac =  \n          rtac @{thms simp_imp} THEN' do_cnv_tac\n    \n        val imp_plan_tac = simp_imp1_tac THEN' final_simp_tac \n    \n        val imp_pre_tac = APPLY_LIST [\n            simp_only @{thms split_tupled_all}\n            THEN' Refine_Util.instantiate_tuples_subgoal_tac ctxt\n            THEN' CASES' [\n              (unfold_and_tac, ALLGOALS and_plan_tac),\n              (unfold_imp_tac, ALLGOALS imp_plan_tac)\n            ]\n          ,\n            simp_tupled_pre_tac\n          ]  \n    \n        val imp_pre_custom_tac = \n          SELECT_GOAL (Local_Defs.unfold0_tac ctxt @{thms and_pre_def}) THEN'\n          TRY o SOLVED' (SELECT_GOAL (auto_tac ctxt))\n    \n      in\n        CASES' [\n          (rtac @{thms IMP_PRE_eqI}, imp_pre_tac 1),\n          (rtac @{thms IMP_PRE_CUSTOMI}, ALLGOALS imp_pre_custom_tac)\n        ]\n      end\n\n\n\n\n      local\n        fun inf_bn_aux name = \n          case String.tokens (fn c => c = #\".\") name of\n            [] => NONE\n          | [a] => SOME (Binding.name a)\n          | (_::a::_) => SOME (Binding.name a)\n      in\n        fun infer_basename (Const (\"_type_constraint_\",_)$t) = infer_basename t\n          | infer_basename (Const (name,_)) = inf_bn_aux name\n          | infer_basename (Free (name,_)) = inf_bn_aux name\n          | infer_basename _ = NONE\n      end    \n  \n      val cfg_mop = Attrib.setup_config_bool @{binding sepref_register_mop} (K true)\n      val cfg_ismop = Attrib.setup_config_bool @{binding sepref_register_ismop} (K false)\n      val cfg_rawgoals = Attrib.setup_config_bool @{binding sepref_register_rawgoals} (K false)\n      val cfg_transfer = Attrib.setup_config_bool @{binding sepref_decl_impl_transfer} (K true)\n      val cfg_def = Attrib.setup_config_bool @{binding sepref_register_def} (K true)\n      val cfg_register = Attrib.setup_config_bool @{binding sepref_decl_impl_register} (K true)\n  \n      local \n        open Refine_Util\n        val flags = \n             parse_bool_config' \"mop\" cfg_mop\n          || parse_bool_config' \"ismop\" cfg_ismop\n          || parse_bool_config' \"rawgoals\" cfg_rawgoals\n          || parse_bool_config' \"def\" cfg_def\n        val parse_flags = parse_paren_list' flags  \n\n        val parse_name = Scan.option (Parse.binding --| @{keyword \":\"})\n        val parse_relconds = Scan.optional (@{keyword \"where\"} |-- Parse.and_list1 (Scan.repeat1 Parse.prop) >> flat) []\n      in\n\n        val do_parser = parse_flags -- parse_name -- Parse.term --| @{keyword \"::\"} -- Parse.term -- parse_relconds\n      end  \n  \n  \n      fun do_cmd ((((flags,name),opt_raw), relt_raw),relconds_raw) lthy = let\n        local\n          val ctxt = Refine_Util.apply_configs flags lthy\n        in\n          val flag_ismop = Config.get ctxt cfg_ismop\n          val flag_mop = Config.get ctxt cfg_mop andalso not flag_ismop\n          val flag_rawgoals = Config.get ctxt cfg_rawgoals\n          val flag_def = Config.get ctxt cfg_def\n        end\n  \n        open Sepref_Basic Sepref_Rules\n\n        val relt = Syntax.parse_term lthy relt_raw\n        val relconds = map (Syntax.parse_prop lthy) relconds_raw \n\n        val _ = dbg_trace lthy \"Parse relation and relation conditions together\"\n        val relt = Const (@{const_name \"Pure.term\"}, dummyT) $ relt\n        local\n          val l = Syntax.check_props lthy (relt::relconds)\n        in\n          val (relt, relconds) = (hd l, tl l) \n        end\n        val relt = Logic.dest_term relt\n\n        val opt_pre = Syntax.parse_term lthy opt_raw\n  \n\n        val _ = dbg_trace lthy \"Infer basename\"\n        val name = case name of \n          SOME name => name\n        | NONE => (\n            case infer_basename opt_pre of \n              NONE => (error \"Could not infer basename: You have to specify a basename\"; Binding.empty)\n            | SOME name => name\n          )\n          \n  \n        fun qname s n = Binding.qualify true (Binding.name_of n) (Binding.name s)\n        fun def name t_pre attribs lthy = let\n          val t = Syntax.check_term lthy t_pre\n            (*|> Thm.cterm_of lthy\n            |> Drule.mk_term\n            |> Local_Defs.unfold0 lthy @{thms PR_CONST_def}\n            |> Drule.dest_term\n            |> Thm.term_of*)\n  \n          val lthy = (snd o Local_Theory.begin_nested) lthy \n          val ((dt,(_,thm)),lthy) = Local_Theory.define \n            ((name,Mixfix.NoSyn),((Thm.def_binding name,@{attributes [code]}@attribs),t)) lthy;\n          val (lthy, lthy_old) = `Local_Theory.end_nested lthy\n          val phi = Proof_Context.export_morphism lthy_old lthy\n          val thm = Morphism.thm phi thm\n          val dt = Morphism.term phi dt\n  \n        in\n          ((dt,thm),lthy)\n        end\n  \n        val _ = dbg_trace lthy \"Analyze Relation\"\n        val (pre,args,res) = analyze_rel relt\n        val specified_pre = is_some pre\n        val pre = the_default (mk_triv_precond args) pre\n  \n        val def_thms = @{thms PR_CONST_def}\n  \n        val _ = dbg_trace lthy \"Define op\"\n        val op_name = Binding.prefix_name (if flag_ismop then \"mop_\" else \"op_\") name\n        val (def_thms,opc,lthy) = \n          if flag_def then let\n              val ((opc,op_def_thm),lthy) = def op_name opt_pre @{attributes [simp]} lthy\n              val opc = Refine_Util.dummify_tvars opc\n              val def_thms = op_def_thm::def_thms\n            in\n              (def_thms,opc,lthy)\n            end\n          else let\n              val _ = dbg_trace lthy \"Refine type of opt_pre to get opc\"\n              val opc = Syntax.check_term lthy opt_pre\n              val new_ctxt = Variable.declare_term opc lthy\n              val opc = singleton (Variable.export_terms new_ctxt lthy) opc\n                |> Refine_Util.dummify_tvars\n            in \n              (def_thms,opc,lthy)\n            end\n  \n            \n        (* PR_CONST Heuristics *)    \n        fun pr_const_heuristics basename c_pre lthy = let\n          val _ = dbg_trace lthy (\"PR_CONST heuristics \" ^ @{make_string} c_pre)\n\n          val c = Syntax.check_term lthy c_pre\n        in\n          case c of\n            @{mpat \"PR_CONST _\"} => ((c_pre,false),lthy)\n          | Const _ => ((c_pre,false),lthy)\n          | _ => let\n              val (f,args) = strip_comb c\n  \n              val lthy = case f of Const _ => let\n                  val ctxt = Variable.declare_term c lthy\n                  val lhs = Autoref_Tagging.list_APP (f,args)\n                  val rhs = @{mk_term \"UNPROTECT ?c\"}\n                  val goal = Logic.mk_equals (lhs,rhs) |> Thm.cterm_of ctxt\n                  val tac = \n                    Local_Defs.unfold0_tac ctxt @{thms APP_def UNPROTECT_def}\n                    THEN ALLGOALS (simp_tac (put_simpset HOL_basic_ss ctxt))\n                  val thm = Goal.prove_internal ctxt [] goal (K tac)\n                    |> singleton (Variable.export ctxt lthy)\n  \n                  val (_,lthy) = Local_Theory.note \n                    ((Binding.suffix_name \"_def_pat\" basename,@{attributes [def_pat_rules]}),[thm]) lthy\n  \n                  val _ = Thm.pretty_thm lthy thm |> Pretty.string_of |> writeln\n                in\n                  lthy\n                end\n              | _ => (\n                Pretty.block [\n                  Pretty.str \"Complex operation pattern. Added PR_CONST but no pattern rules:\",\n                  Pretty.brk 1,Syntax.pretty_term lthy c]\n                |> Pretty.string_of |> warning  \n                ; lthy)\n  \n              val c_pre = Const(@{const_name PR_CONST},dummyT)$c_pre\n            in\n              ((c_pre,true),lthy)\n            end\n        end  \n\n        val ((opc,_),lthy) = pr_const_heuristics op_name opc lthy\n\n        (* Register *)\n        val arg_intfs = map (get_intf_of_rel lthy) args\n        val res_intf = get_intf_of_rel lthy res\n  \n\n        fun register basename c lthy = let\n          val _ = dbg_trace lthy \"Register\"\n          open Sepref_Basic\n          val c = Syntax.check_term lthy c\n  \n          val ri = case (is_nresT (body_type (fastype_of c)), is_nresT res_intf) of\n            (true,false) => mk_nresT res_intf\n          | (false,true) => dest_nresT res_intf\n          | _ => res_intf\n  \n          val iT = arg_intfs ---> ri\n  \n          val ((_,itype_thm),lthy) = Sepref_Combinator_Setup.sepref_register_single (Binding.name_of basename) c iT lthy\n          val _ = Thy_Output.pretty_thm lthy itype_thm |> Pretty.string_of |> writeln\n  \n        in\n          lthy\n        end\n  \n        val lthy = register op_name opc lthy\n  \n        val _ = dbg_trace lthy \"Define pre\"\n        val pre_name = Binding.prefix_name \"pre_\" name\n        val ((prec,pre_def_thm),lthy) = def pre_name pre @{attributes [simp]} lthy\n        val prec = Refine_Util.dummify_tvars prec\n        val def_thms = pre_def_thm::def_thms\n  \n        (* Re-integrate pre-constant into type-context of relation. TODO: This is probably not clean/robust *)\n        val pre = constrain_type_pre (fastype_of pre) prec |> Syntax.check_term lthy\n\n  \n        val _ = dbg_trace lthy \"Convert both, relation and operation to uncurried form, and add nres\"\n        val _ = dbg_trace lthy \"Convert relation (arguments have already been separated by analyze-rel)\"\n        val res = case res of @{mpat \"\\<langle>_\\<rangle>nres_rel\"} => res | _ => @{mk_term \"\\<langle>?res\\<rangle>nres_rel\"}\n        val relt = mk_rel (SOME pre,args,res)\n  \n        val _ = dbg_trace lthy \"Convert operation\"\n        val opcT = fastype_of (Syntax.check_term lthy opc)\n        val op_is_nres = Sepref_Basic.is_nresT (body_type opcT)\n        val (opcu, op_ar) = let\n          val arity = binder_types #> length\n          (* Arity of operation is number of arguments before result (which may be a fun-type! )*)\n          val res_ar = arity (Relators.rel_absT res |> not op_is_nres ? dest_nresT)\n\n          val op_ar = arity opcT - res_ar\n          \n          val _ = op_ar = length args orelse \n            raise TERM(\"Operation/relation arity mismatch: \" ^ string_of_int op_ar ^ \" vs \" ^ string_of_int (length args),[opc,relt])\n  \n          (* Add RETURN o...o if necessary*)\n          val opc = \n            if op_is_nres then opc\n            else mk_compN_pre op_ar (Const(@{const_name Refine_Basic.RETURN},dummyT)) opc\n  \n          (* Add uncurry if necessary *)  \n          val opc = mk_uncurryN_pre op_ar opc\n        in \n          (opc, op_ar)\n        end\n  \n        (* Build mop-variant *)\n        val declare_mop = (specified_pre orelse not op_is_nres) andalso flag_mop\n  \n        val (mop_data,lthy) = if declare_mop then let\n            val _ = dbg_trace lthy \"mop definition\"\n            val mop_rhs = Const(@{const_name mop},dummyT) $ prec $ opcu\n              |> mk_curryN_pre op_ar\n            val mop_name = Binding.prefix_name \"mop_\" name\n            val ((mopc,mop_def_thm),lthy) = def mop_name mop_rhs [] lthy\n            val mopc = Refine_Util.dummify_tvars mopc\n  \n            val ((mopc,added_pr_const),lthy) = pr_const_heuristics mop_name mopc lthy\n\n            val mop_def_thm' = if added_pr_const then \n                mop_def_thm RS @{thm add_PR_CONST_to_def}\n              else mop_def_thm\n\n            val (_,lthy) = Local_Theory.note ((Binding.empty, @{attributes [sepref_mop_def_thms]}),[mop_def_thm']) lthy\n\n            val _ = dbg_trace lthy \"mop alternative definition\"\n            val alt_unfolds = @{thms mop_alt_unfolds}\n              |> not specified_pre ? curry op :: pre_def_thm\n\n            val mop_alt_thm = Local_Defs.unfold0 lthy alt_unfolds mop_def_thm\n              |> Refine_Util.shift_lambda_leftN op_ar\n            val (_,lthy) = Local_Theory.note ((Binding.suffix_name \"_alt\" mop_name,@{attributes [simp]}),[mop_alt_thm]) lthy\n  \n            val _ = dbg_trace lthy \"mop: register\"\n            val lthy = register mop_name mopc lthy\n  \n            val _ = dbg_trace lthy \"mop: vcg theorem\"\n            local\n              val Ts = map Relators.rel_absT args\n              val ctxt = Variable.declare_thm mop_def_thm lthy\n              val ctxt = fold Variable.declare_typ Ts ctxt\n              val (x,ctxt) = Refine_Util.fix_left_tuple_from_Ts \"x\" Ts ctxt\n              \n              val mop_def_thm = mop_def_thm\n                |> Local_Defs.unfold0 ctxt @{thms curry_shl}\n              \n              fun prep_thm thm = (thm OF [mop_def_thm])\n                |> Drule.infer_instantiate' ctxt [SOME (Thm.cterm_of ctxt x)]\n                |> Local_Defs.unfold0 ctxt @{thms uncurry_apply uncurry0_apply o_apply}\n                |> Local_Defs.unfold0 ctxt (def_thms @\n                    @{thms Product_Type.split HOL.True_implies_equals})\n                |> singleton (Variable.export ctxt lthy)\n\n              val thms = map prep_thm @{thms mop_spec_rl_from_def mop_leof_rl_from_def}  \n\n            in\n              val (_,lthy) = Local_Theory.note ((qname \"vcg\" mop_name,@{attributes [refine_vcg]}),thms) lthy\n            end\n  \n          in \n            (SOME (mop_name,mopc,mop_def_thm),lthy)\n          end\n        else (NONE,lthy)\n  \n  \n        val _ = dbg_trace lthy \"Build Parametricity Theorem\"\n        val param_t = mk_pair_in_pre opcu opcu relt \n          |> Syntax.check_term lthy \n          |> HOLogic.mk_Trueprop\n          |> curry Logic.list_implies relconds\n        \n        val _ = dbg_trace lthy \"Build Parametricity Theorem for Precondition\"\n        val param_pre_t = \n          let\n            val pre_relt = Relators.mk_fun_rel (Relators.list_prodrel_left args) @{term bool_rel}\n  \n            val param_pre_t = mk_pair_in_pre prec prec pre_relt \n              |> Syntax.check_term lthy\n              |> HOLogic.mk_Trueprop\n              |> curry Logic.list_implies relconds\n          in\n            param_pre_t\n          end\n        \n        \n        val _ = dbg_trace lthy \"Build goals\"\n        val goals = [[ (param_t, []), (param_pre_t, []) ]]\n  \n        fun after_qed [[p_thm, pp_thm]] _ (*ctxt*) = \n          let\n            val _ = dbg_trace lthy \"after_qed\"\n            val p_thm' = p_thm |> not specified_pre ? Local_Defs.unfold0 lthy [pre_def_thm]\n\n            val (_,lthy) = Local_Theory.note ((qname \"fref\" op_name,@{attributes [sepref_fref_thms]}), [p_thm']) lthy\n            val (_,lthy) = Local_Theory.note ((qname \"param\" pre_name,@{attributes [param]}), [pp_thm]) lthy\n\n            val p'_unfolds = pre_def_thm :: @{thms True_implies_equals}\n            val (_,lthy) = Local_Theory.note ((qname \"fref'\" op_name,[]), [Local_Defs.unfold0 lthy p'_unfolds p_thm]) lthy\n\n  \n            val lthy = case mop_data of NONE => lthy | \n              SOME (mop_name,mopc,mop_def_thm) => let\n                val _ = dbg_trace lthy \"Build and prove mop-stuff\"\n                (* mop - parametricity theorem: (uncurry\\<^sup>n mopc,uncurry\\<^sup>n mopc) \\<in> args \\<rightarrow>\\<^sub>f res *)\n                val mopcu = mk_uncurryN_pre op_ar mopc\n                val param_mop_t = mk_pair_in_pre mopcu mopcu (mk_rel (NONE,args,res))\n                  |> Syntax.check_term lthy\n                  |> HOLogic.mk_Trueprop\n                  |> curry Logic.list_implies relconds\n  \n                val ctxt = Proof_Context.augment param_mop_t lthy \n                \n                val tac = let\n                  val p_thm = Local_Defs.unfold0 ctxt @{thms PR_CONST_def} p_thm\n                in\n                  Local_Defs.unfold0_tac ctxt (mop_def_thm :: @{thms PR_CONST_def uncurry_curry_id uncurry_curry0_id})\n                  THEN FIRSTGOAL (\n                    dbg_msg_tac (Sepref_Debugging.msg_subgoal \"Mop-param thm goal after unfolding\") ctxt THEN'\n                    resolve_tac ctxt @{thms param_mopI}\n                      THEN' SOLVED' (resolve_tac ctxt [p_thm] THEN_ALL_NEW assume_tac ctxt)\n                      THEN' SOLVED' (resolve_tac ctxt [pp_thm] THEN_ALL_NEW assume_tac ctxt)\n                  )\n                end\n  \n                val pm_thm = Goal.prove_internal lthy [] (Thm.cterm_of ctxt param_mop_t) (K tac)\n                  |> singleton (Variable.export ctxt lthy)\n  \n                val (_,lthy) = Local_Theory.note ((qname \"fref\" mop_name,@{attributes [sepref_fref_thms]}), [pm_thm]) lthy\n                val (_,lthy) = Local_Theory.note ((qname \"fref'\" mop_name,[]), [Local_Defs.unfold0 lthy p'_unfolds pm_thm]) lthy\n  \n  \n              in\n                lthy\n              end\n  \n  \n          in\n            lthy\n          end\n          | after_qed thmss _ = raise THM (\"After-qed: Wrong thmss structure\",~1,flat thmss)    \n          \n        fun std_tac ctxt = let\n          val ptac = REPEAT_ALL_NEW_FWD (Parametricity.net_tac (Parametricity.get_dflt ctxt) ctxt)\n  \n          (* Massage simpset a bit *)\n          val ctxt = ctxt\n            |> Context_Position.set_visible false\n            |> Context.proof_map (Thm.attribute_declaration Clasimp.iff_del @{thm pair_in_Id_conv})\n\n        in\n          if flag_rawgoals then\n            all_tac\n          else\n            Local_Defs.unfold0_tac ctxt def_thms THEN ALLGOALS (\n              TRY o SOLVED' (\n                TRY o resolve_tac ctxt @{thms frefI}\n                THEN' TRY o REPEAT_ALL_NEW (ematch_tac ctxt @{thms prod_relE})\n                THEN' simp_tac (put_simpset HOL_basic_ss ctxt addsimps @{thms split uncurry_apply uncurry0_apply})\n                THEN' (\n                  SOLVED' (ptac THEN_ALL_NEW asm_full_simp_tac ctxt)\n                  ORELSE' SOLVED' (cp_clarsimp_tac ctxt THEN_ALL_NEW_FWD ptac THEN_ALL_NEW SELECT_GOAL (auto_tac ctxt))\n                )\n              )\n            )\n  \n        end  \n  \n        val rf_std = Proof.refine (Method.Basic (fn ctxt => SIMPLE_METHOD (std_tac ctxt)))\n          #> Seq.the_result \"do_cmd: Standard proof tactic returned empty result sequence\"\n\n      in\n        Proof.theorem NONE after_qed goals lthy\n        |> rf_std\n      end\n\n      val _ = Outer_Syntax.local_theory_to_proof @{command_keyword \"sepref_decl_op\"}\n        \"\" (do_parser >> do_cmd)\n  \n\n\n\n      local\n      \n        fun unfold_PR_CONST_tac ctxt = SELECT_GOAL (Local_Defs.unfold0_tac ctxt @{thms PR_CONST_def})\n\n        fun transfer_precond_rl ctxt t R = let\n          (*val tfrees = Term.add_tfreesT (fastype_of t) [] \n          val t' = map_types (map_type_tfree (fn x => if member op= tfrees x then dummyT else TFree x)) t\n          *) (* TODO: Brute force approach, that may generalize too much! *)\n          val t' = map_types (K dummyT) t\n        \n          val goal = Sepref_Basic.mk_pair_in_pre t t' R \n            |> Syntax.check_term ctxt\n            |> Thm.cterm_of ctxt\n                                    \n          val thm = Drule.infer_instantiate' ctxt [NONE,SOME goal] @{thm IMP_LIST_trivial}\n\n        in\n          thm\n        end\n      \n      \n        (* Generate a hnr-thm for mop given one for op *)\n        fun generate_mop_thm ctxt op_thm = let\n          val orig_ctxt = ctxt\n      \n          val (op_thm, ctxt) = yield_singleton (apfst snd oo Variable.import true) op_thm ctxt\n      \n          (* Convert mop_def_thms to form uncurry^n f \\<equiv> mop P g *)\n          val mop_def_thms = Named_Theorems_Rev.get ctxt @{named_theorems_rev sepref_mop_def_thms}\n            |> map (Local_Defs.unfold0 ctxt @{thms curry_shl})\n      \n          fun fail_hnr_tac _ _ = raise THM(\"Invalid hnr-theorem\",~1,[op_thm]) \n          fun fail_mop_def_tac i st = let\n            val g = nth (Thm.prems_of st) (i-1)\n          in\n            raise TERM(\"Found no matching mop-definition\",[g])\n          end\n      \n          (* Tactic to solve preconditions of hfref_op_to_mop *)\n          val tac = APPLY_LIST [\n            resolve_tac ctxt [op_thm] ORELSE' fail_hnr_tac,\n            ((*unfold_PR_CONST_tac ctxt THEN'*) resolve_tac ctxt mop_def_thms) ORELSE' fail_mop_def_tac,\n            simp_precond_tac ctxt ORELSE' Sepref_Debugging.error_tac' \"precond simplification failed\" ctxt\n          ] 1\n      \n          (* Do synthesis *)\n          val st = @{thm hfref_op_to_mop}\n          val st = Goal.protect (Thm.nprems_of st) st\n          val mop_thm = tac st |> Seq.hd |> Goal.conclude\n      \n          val mop_thm = singleton (Variable.export ctxt orig_ctxt) mop_thm\n            |> Sepref_Rules.norm_fcomp_rule orig_ctxt\n        in mop_thm end  \n      \n        (* Generate a hnr-thm for op given one for mop *)\n        fun generate_op_thm ctxt mop_thm = let (* TODO: Almost-clone of generate_mop_thm *)\n          val orig_ctxt = ctxt\n      \n          val (mop_thm, ctxt) = yield_singleton (apfst snd oo Variable.import true) mop_thm ctxt\n      \n          (* Convert mop_def_thms to form uncurry^n f \\<equiv> mop P g *)\n          val mop_def_thms = Named_Theorems_Rev.get ctxt @{named_theorems_rev sepref_mop_def_thms}\n            |> map (Local_Defs.unfold0 ctxt @{thms curry_shl})\n      \n          fun fail_hnr_tac _ _ = raise THM(\"Invalid hnr-theorem\",~1,[mop_thm]) \n          fun fail_mop_def_tac i st = let\n            val g = nth (Thm.prems_of st) (i-1)\n          in\n            raise TERM(\"Found no matching mop-definition\",[g])\n          end\n      \n          (* Tactic to solve preconditions of hfref_mop_to_op *)\n          val tac = APPLY_LIST [\n            resolve_tac ctxt [mop_thm] ORELSE' fail_hnr_tac,\n            ((*unfold_PR_CONST_tac ctxt THEN'*) resolve_tac ctxt mop_def_thms) ORELSE' fail_mop_def_tac,\n            simp_precond_tac ctxt ORELSE' Sepref_Debugging.error_tac' \"precond simplification failed\" ctxt\n          ] 1\n      \n          (* Do synthesis *)\n          val st = @{thm hfref_mop_to_op}\n          val st = Goal.protect (Thm.nprems_of st) st\n          val op_thm = tac st |> Seq.hd |> Goal.conclude\n      \n          val op_thm = singleton (Variable.export ctxt orig_ctxt) op_thm\n            |> Sepref_Rules.norm_fcomp_rule orig_ctxt\n        in op_thm end  \n\n\n      \n        fun chk_result ctxt thm = let\n          val (_,R,S) = case Thm.concl_of thm of\n            @{mpat \"Trueprop (_\\<in>hfref ?P ?R ?S)\"} => (P,R,S)\n          | _ => raise THM(\"chk_result: Expected hfref-theorem\",~1,[thm])  \n      \n          fun err t = let\n            val ts = Syntax.pretty_term ctxt t |> Pretty.string_of\n          in\n            raise THM (\"chk_result: Invalid pattern left in assertions: \" ^ ts,~1,[thm])\n          end  \n          fun check_invalid (t as @{mpat \"hr_comp _ _\"}) = err t \n            | check_invalid (t as @{mpat \"hrp_comp _ _\"}) = err t\n            | check_invalid (t as @{mpat \"pure (the_pure _)\"}) = err t\n            | check_invalid (t as @{mpat \"_ O _\"}) = err t\n            | check_invalid _ = false\n            \n      \n          val _ = exists_subterm check_invalid R \n          val _ = exists_subterm check_invalid S\n        in\n          ()\n        end\n\n        fun to_IMP_LIST ctxt thm =    \n          (thm RS @{thm to_IMP_LISTI}) |> Local_Defs.unfold0 ctxt @{thms to_IMP_LIST}\n  \n        fun from_IMP_LIST ctxt thm = thm |> Local_Defs.unfold0 ctxt @{thms from_IMP_LIST}  \n\n      in\n    \n        local\n          open Refine_Util\n          val flags = \n               parse_bool_config' \"mop\" cfg_mop\n            || parse_bool_config' \"ismop\" cfg_ismop\n            || parse_bool_config' \"transfer\" cfg_transfer\n            || parse_bool_config' \"rawgoals\" cfg_rawgoals\n            || parse_bool_config' \"register\" cfg_register\n          val parse_flags = parse_paren_list' flags  \n      \n          val parse_precond = Scan.option (@{keyword \"[\"} |-- Parse.term --| @{keyword \"]\"})\n      \n          val parse_fref_thm = Scan.option (@{keyword \"uses\"} |-- Parse.thm)\n      \n        in\n          val di_parser = parse_flags -- Scan.optional (Parse.binding --| @{keyword \":\"}) Binding.empty -- parse_precond -- Parse.thm -- parse_fref_thm\n        end  \n      \n        fun di_cmd ((((flags,name), precond_raw), i_thm_raw), p_thm_raw) lthy = let\n          val i_thm = singleton (Attrib.eval_thms lthy) i_thm_raw\n          val p_thm = map_option (singleton (Attrib.eval_thms lthy)) p_thm_raw\n      \n          local\n            val ctxt = Refine_Util.apply_configs flags lthy\n          in\n            val flag_mop = Config.get ctxt cfg_mop\n            val flag_ismop = Config.get ctxt cfg_ismop\n            val flag_rawgoals = Config.get ctxt cfg_rawgoals\n            val flag_transfer = Config.get ctxt cfg_transfer\n            val flag_register = Config.get ctxt cfg_register\n          end\n      \n          val fr_attribs = if flag_register then @{attributes [sepref_fr_rules]} else []\n\n\n          val ctxt = lthy\n      \n          (* Compose with fref-theorem *)\n          val _ = dbg_trace lthy \"Compose with fref\"\n\n          local\n            val hf_tcomp_pre = @{thm hfcomp_tcomp_pre} OF [asm_rl,i_thm]\n            fun compose p_thm = let\n              val p_thm = p_thm |> to_assns_rl false lthy \n            in\n              hf_tcomp_pre OF [p_thm]\n            end\n      \n          in  \n            val thm = case p_thm of\n              SOME p_thm => compose p_thm\n            | NONE => let\n                val p_thms = Named_Theorems_Rev.get ctxt @{named_theorems_rev sepref_fref_thms}\n        \n                fun err () = let\n                  val prem_s = nth (Thm.prems_of hf_tcomp_pre) 0 |> Syntax.pretty_term ctxt |> Pretty.string_of\n                in\n                  error (\"Found no fref-theorem matching \" ^ prem_s)\n                end\n        \n              in\n                case get_first (try compose) p_thms of\n                  NONE => err ()\n                | SOME thm => thm  \n        \n              end\n          end  \n      \n          val (thm,ctxt) = yield_singleton (apfst snd oo Variable.import true) thm ctxt\n\n          val _ = dbg_trace lthy \"Transfer Precond\"\n          val thm = to_IMP_LIST ctxt thm\n          val thm = thm RS @{thm transform_pre_param}\n      \n          local\n            val (pre,R,pp_name,pp_type) = case Thm.prems_of thm of\n              [@{mpat \"Trueprop (IMP_LIST _ ((?pre,_)\\<in>?R))\"}, @{mpat \"Trueprop (IMP_PRE (mpaq_STRUCT (mpaq_Var ?pp_name ?pp_type)) _)\"}] => (pre,R,pp_name,pp_type)\n            | _ => raise THM(\"di_cmd: Cannot recognize first prems of transform_pre_param: \", ~1,[thm])\n      \n          in\n            val thm = if flag_transfer then thm OF [transfer_precond_rl ctxt pre R] else thm\n      \n            val thm = case precond_raw of \n              NONE => thm\n            | SOME precond_raw => let\n                val precond = Syntax.parse_term ctxt precond_raw\n                  |> Sepref_Basic.constrain_type_pre pp_type\n                  |> Syntax.check_term ctxt\n                  |> Thm.cterm_of ctxt\n      \n                val thm = Drule.infer_instantiate ctxt [(pp_name,precond)] thm\n                val thm = thm OF [asm_rl,@{thm IMP_PRE_CUSTOMD}]\n              in\n                thm\n              end\n      \n          end\n\n          val _ = dbg_trace lthy \"Build goals\"\n          val goals = [map (fn x => (x,[])) (Thm.prems_of thm)]\n\n          fun after_qed thmss _ = let\n            val _ = dbg_trace lthy \"After QED\"\n            val prems_thms = hd thmss\n      \n            val thm = thm OF prems_thms\n\n            val thm = from_IMP_LIST ctxt thm\n\n            (* Two rounds of cleanup-constraints, norm_fcomp *)\n            val _ = dbg_trace lthy \"Cleanup\"\n            val thm = thm\n              |> cleanup_constraints ctxt\n              |> Sepref_Rules.norm_fcomp_rule ctxt\n              |> cleanup_constraints ctxt\n              |> Sepref_Rules.norm_fcomp_rule ctxt\n      \n            val thm = thm  \n              |> singleton (Variable.export ctxt lthy)\n              |> zero_var_indexes\n      \n            val _ = dbg_trace lthy \"Check Result\"\n            val _ = chk_result lthy thm  \n      \n      \n            fun qname suffix = if Binding.is_empty name then name else Binding.suffix_name suffix name \n      \n            val thm_name = if flag_ismop then qname \"_hnr_mop\" else qname \"_hnr\"\n            val (_,lthy) = Local_Theory.note ((thm_name,fr_attribs),[thm]) lthy\n\n            val _ = Thm.pretty_thm lthy thm |> Pretty.string_of |> writeln\n\n            (* Create mop theorem from op-theorem *)\n            val cr_mop_thm = flag_mop andalso not flag_ismop\n            val lthy = \n              if cr_mop_thm then \n                let \n                  val _ = dbg_trace lthy \"Create mop-thm\"\n                  val mop_thm = thm\n                    |> generate_mop_thm lthy\n                    |> zero_var_indexes\n\n                  val (_,lthy) = Local_Theory.note ((qname \"_hnr_mop\",fr_attribs),[mop_thm]) lthy\n                  val _ = Thm.pretty_thm lthy mop_thm |> Pretty.string_of |> writeln\n                in lthy end \n              else lthy\n\n            (* Create op theorem from mop-theorem *)\n            val cr_op_thm = flag_ismop\n            val lthy = \n              if cr_op_thm then \n                let \n                  val _ = dbg_trace lthy \"Create op-thm\"\n                  val op_thm = thm\n                    |> generate_op_thm lthy\n                    |> zero_var_indexes\n\n                  val (_,lthy) = Local_Theory.note ((qname \"_hnr\",fr_attribs),[op_thm]) lthy\n                  val _ = Thm.pretty_thm lthy op_thm |> Pretty.string_of |> writeln\n                in lthy end \n              else lthy\n\n      \n          in \n            lthy \n          end\n      \n          fun std_tac ctxt = let \n            val ptac = REPEAT_ALL_NEW_FWD ( \n              Parametricity.net_tac (Parametricity.get_dflt ctxt) ctxt ORELSE' assume_tac ctxt\n              )\n          in\n            if flag_rawgoals orelse not flag_transfer then\n              all_tac\n            else\n              APPLY_LIST [\n                SELECT_GOAL (Local_Defs.unfold0_tac ctxt @{thms from_IMP_LIST}) THEN' TRY o SOLVED' ptac,\n                simp_precond_tac ctxt\n              ] 1\n            \n          end\n      \n          val rf_std = Proof.refine (Method.Basic (fn ctxt => SIMPLE_METHOD (std_tac ctxt)))\n            #> Seq.the_result \"di_cmd: Standard proof tactic returned empty result sequence\"\n\n        in\n          Proof.theorem NONE after_qed goals ctxt\n          |> rf_std\n      \n        end\n      \n        val _ = Outer_Syntax.local_theory_to_proof @{command_keyword \"sepref_decl_impl\"}\n          \"\" (di_parser >> di_cmd)\n      end\n\n    end  \n  \\<close>"], ["", "subsection \\<open>Obsolete Manual Specification Helpers\\<close>"], ["", "(* Generate VCG-rules for operations *)"], ["", "lemma vcg_of_RETURN_np:  \n    assumes \"f \\<equiv> RETURN r\"\n    shows \"SPEC (\\<lambda>x. x=r) \\<le> m \\<Longrightarrow> f \\<le> m\"\n      and \"SPEC (\\<lambda>x. x=r) \\<le>\\<^sub>n m \\<Longrightarrow> f \\<le>\\<^sub>n m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SPEC (\\<lambda>x. x = r) \\<le> m \\<Longrightarrow> f \\<le> m) &&&\n    (SPEC (\\<lambda>x. x = r) \\<le>\\<^sub>n m \\<Longrightarrow>\n     f \\<le>\\<^sub>n m)", "using assms"], ["proof (prove)\nusing this:\n  f \\<equiv> RETURN r\n\ngoal (1 subgoal):\n 1. (SPEC (\\<lambda>x. x = r) \\<le> m \\<Longrightarrow> f \\<le> m) &&&\n    (SPEC (\\<lambda>x. x = r) \\<le>\\<^sub>n m \\<Longrightarrow>\n     f \\<le>\\<^sub>n m)", "by (auto simp: pw_le_iff pw_leof_iff)"], ["", "lemma vcg_of_RETURN:\n    assumes \"f \\<equiv> do { ASSERT \\<Phi>; RETURN r }\"\n    shows \"\\<lbrakk>\\<Phi>; SPEC (\\<lambda>x. x=r) \\<le> m\\<rbrakk> \\<Longrightarrow> f \\<le> m\"\n      and \"\\<lbrakk>\\<Phi> \\<Longrightarrow> SPEC (\\<lambda>x. x=r) \\<le>\\<^sub>n m\\<rbrakk> \\<Longrightarrow> f \\<le>\\<^sub>n m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<Phi>; SPEC (\\<lambda>x. x = r) \\<le> m\\<rbrakk>\n     \\<Longrightarrow> f \\<le> m) &&&\n    ((\\<Phi> \\<Longrightarrow>\n      SPEC (\\<lambda>x. x = r) \\<le>\\<^sub>n m) \\<Longrightarrow>\n     f \\<le>\\<^sub>n m)", "using assms"], ["proof (prove)\nusing this:\n  f \\<equiv> ASSERT \\<Phi> \\<bind> (\\<lambda>_. RETURN r)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<Phi>; SPEC (\\<lambda>x. x = r) \\<le> m\\<rbrakk>\n     \\<Longrightarrow> f \\<le> m) &&&\n    ((\\<Phi> \\<Longrightarrow>\n      SPEC (\\<lambda>x. x = r) \\<le>\\<^sub>n m) \\<Longrightarrow>\n     f \\<le>\\<^sub>n m)", "by (auto simp: pw_le_iff pw_leof_iff refine_pw_simps)"], ["", "lemma vcg_of_SPEC:  \n    assumes \"f \\<equiv> do { ASSERT pre; SPEC post }\"\n    shows \"\\<lbrakk>pre; SPEC post \\<le> m\\<rbrakk> \\<Longrightarrow> f \\<le> m\"\n      and \"\\<lbrakk>pre \\<Longrightarrow> SPEC post \\<le>\\<^sub>n m\\<rbrakk> \\<Longrightarrow> f \\<le>\\<^sub>n m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>pre; SPEC post \\<le> m\\<rbrakk>\n     \\<Longrightarrow> f \\<le> m) &&&\n    ((pre \\<Longrightarrow> SPEC post \\<le>\\<^sub>n m) \\<Longrightarrow>\n     f \\<le>\\<^sub>n m)", "using assms"], ["proof (prove)\nusing this:\n  f \\<equiv> ASSERT pre \\<bind> (\\<lambda>_. SPEC post)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>pre; SPEC post \\<le> m\\<rbrakk>\n     \\<Longrightarrow> f \\<le> m) &&&\n    ((pre \\<Longrightarrow> SPEC post \\<le>\\<^sub>n m) \\<Longrightarrow>\n     f \\<le>\\<^sub>n m)", "by (auto simp: pw_le_iff pw_leof_iff refine_pw_simps)"], ["", "lemma vcg_of_SPEC_np:  \n    assumes \"f \\<equiv> SPEC post\"\n    shows \"SPEC post \\<le> m \\<Longrightarrow> f \\<le> m\"\n      and \"SPEC post \\<le>\\<^sub>n m \\<Longrightarrow> f \\<le>\\<^sub>n m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SPEC post \\<le> m \\<Longrightarrow> f \\<le> m) &&&\n    (SPEC post \\<le>\\<^sub>n m \\<Longrightarrow> f \\<le>\\<^sub>n m)", "using assms"], ["proof (prove)\nusing this:\n  f \\<equiv> SPEC post\n\ngoal (1 subgoal):\n 1. (SPEC post \\<le> m \\<Longrightarrow> f \\<le> m) &&&\n    (SPEC post \\<le>\\<^sub>n m \\<Longrightarrow> f \\<le>\\<^sub>n m)", "by auto"], ["", "(* Generate parametricity rules to generalize \n    plain operations to monadic ones. Use with FCOMP.\n  *)"], ["", "lemma mk_mop_rl1:\n    assumes \"\\<And>x. mf x \\<equiv> ASSERT (P x) \\<then> RETURN (f x)\"\n    shows \"(RETURN o f, mf) \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ> f, mf)\n    \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "unfolding assms[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ> f,\n     \\<lambda>x. ASSERT (P x) \\<bind> (\\<lambda>_. RETURN (f x)))\n    \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "by (auto intro!: nres_relI simp: pw_le_iff refine_pw_simps)"], ["", "lemma mk_mop_rl2:\n    assumes \"\\<And>x y. mf x y \\<equiv> ASSERT (P x y) \\<then> RETURN (f x y)\"\n    shows \"(RETURN oo f, mf) \\<in> Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ>\\<circ> f, mf)\n    \\<in> Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "unfolding assms[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ>\\<circ> f,\n     \\<lambda>x y. ASSERT (P x y) \\<bind> (\\<lambda>_. RETURN (f x y)))\n    \\<in> Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "by (auto intro!: nres_relI simp: pw_le_iff refine_pw_simps)"], ["", "lemma mk_mop_rl3:\n    assumes \"\\<And>x y z. mf x y z \\<equiv> ASSERT (P x y z) \\<then> RETURN (f x y z)\"\n    shows \"(RETURN ooo f, mf) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ>\\<circ>\\<circ> f, mf)\n    \\<in> Id \\<rightarrow>\n          Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "unfolding assms[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ>\\<circ>\\<circ> f,\n     \\<lambda>x y z.\n        ASSERT (P x y z) \\<bind> (\\<lambda>_. RETURN (f x y z)))\n    \\<in> Id \\<rightarrow>\n          Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "by (auto intro!: nres_relI simp: pw_le_iff refine_pw_simps)"], ["", "lemma mk_mop_rl0_np:\n    assumes \"mf \\<equiv> RETURN f\"\n    shows \"(RETURN f, mf) \\<in> \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN f, mf) \\<in> \\<langle>Id\\<rangle>nres_rel", "unfolding assms[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN f, RETURN f) \\<in> \\<langle>Id\\<rangle>nres_rel", "by (auto intro!: nres_relI simp: pw_le_iff refine_pw_simps)"], ["", "lemma mk_mop_rl1_np:\n    assumes \"\\<And>x. mf x \\<equiv> RETURN (f x)\"\n    shows \"(RETURN o f, mf) \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ> f, mf)\n    \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "unfolding assms[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ> f, \\<lambda>x. RETURN (f x))\n    \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "by (auto intro!: nres_relI simp: pw_le_iff refine_pw_simps)"], ["", "lemma mk_mop_rl2_np:\n    assumes \"\\<And>x y. mf x y \\<equiv> RETURN (f x y)\"\n    shows \"(RETURN oo f, mf) \\<in> Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ>\\<circ> f, mf)\n    \\<in> Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "unfolding assms[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ>\\<circ> f, \\<lambda>x y. RETURN (f x y))\n    \\<in> Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "by (auto intro!: nres_relI simp: pw_le_iff refine_pw_simps)"], ["", "lemma mk_mop_rl3_np:\n    assumes \"\\<And>x y z. mf x y z \\<equiv> RETURN (f x y z)\"\n    shows \"(RETURN ooo f, mf) \\<in> Id \\<rightarrow> Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ>\\<circ>\\<circ> f, mf)\n    \\<in> Id \\<rightarrow>\n          Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "unfolding assms[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ>\\<circ>\\<circ> f, \\<lambda>x y z. RETURN (f x y z))\n    \\<in> Id \\<rightarrow>\n          Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "by (auto intro!: nres_relI simp: pw_le_iff refine_pw_simps)"], ["", "lemma mk_op_rl0_np:\n    assumes \"mf \\<equiv> RETURN f\"\n    shows \"(uncurry0 mf, uncurry0 (RETURN f)) \\<in> unit_rel \\<rightarrow>\\<^sub>f \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 mf, uncurry0 (RETURN f))\n    \\<in> unit_rel \\<rightarrow>\\<^sub>f \\<langle>Id\\<rangle>nres_rel", "apply (intro frefI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> unit_rel\\<rbrakk>\n       \\<Longrightarrow> uncurry0 mf x\n                         \\<le> \\<Down> Id (uncurry0 (RETURN f) y)", "apply (auto simp: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mk_op_rl1:\n    assumes \"\\<And>x. mf x \\<equiv> ASSERT (P x) \\<then> RETURN (f x)\"\n    shows \"(mf, RETURN o f) \\<in> [P]\\<^sub>f Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mf, RETURN \\<circ> f)\n    \\<in> [P]\\<^sub>f Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "apply (intro frefI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>P y; (x, y) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> mf x \\<le> \\<Down> Id ((RETURN \\<circ> f) y)", "apply (auto simp: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mk_op_rl1_np:\n    assumes \"\\<And>x. mf x \\<equiv> RETURN (f x)\"\n    shows \"(mf, (RETURN o f)) \\<in> Id \\<rightarrow>\\<^sub>f \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mf, RETURN \\<circ> f)\n    \\<in> Id \\<rightarrow>\\<^sub>f \\<langle>Id\\<rangle>nres_rel", "apply (intro frefI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> mf x \\<le> \\<Down> Id ((RETURN \\<circ> f) y)", "apply (auto simp: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mk_op_rl2:\n    assumes \"\\<And>x y. mf x y \\<equiv> ASSERT (P x y) \\<then> RETURN (f x y)\"\n    shows \"(uncurry mf, uncurry (RETURN oo f)) \\<in> [uncurry P]\\<^sub>f Id\\<times>\\<^sub>rId \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry mf, uncurry (RETURN \\<circ>\\<circ> f))\n    \\<in> [uncurry\n            P]\\<^sub>f Id \\<times>\\<^sub>r\n                       Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "apply (intro frefI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>uncurry P y; (x, y) \\<in> Id \\<times>\\<^sub>r Id\\<rbrakk>\n       \\<Longrightarrow> uncurry mf x\n                         \\<le> \\<Down> Id\n                                (uncurry (RETURN \\<circ>\\<circ> f) y)", "apply (auto simp: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mk_op_rl2_np:\n    assumes \"\\<And>x y. mf x y \\<equiv> RETURN (f x y)\"\n    shows \"(uncurry mf, uncurry (RETURN oo f)) \\<in> Id\\<times>\\<^sub>rId \\<rightarrow>\\<^sub>f \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry mf, uncurry (RETURN \\<circ>\\<circ> f))\n    \\<in> Id \\<times>\\<^sub>r\n          Id \\<rightarrow>\\<^sub>f \\<langle>Id\\<rangle>nres_rel", "apply (intro frefI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True; (x, y) \\<in> Id \\<times>\\<^sub>r Id\\<rbrakk>\n       \\<Longrightarrow> uncurry mf x\n                         \\<le> \\<Down> Id\n                                (uncurry (RETURN \\<circ>\\<circ> f) y)", "apply (auto simp: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mk_op_rl3:\n    assumes \"\\<And>x y z. mf x y z \\<equiv> ASSERT (P x y z) \\<then> RETURN (f x y z)\"\n    shows \"(uncurry2 mf, uncurry2 (RETURN ooo f)) \\<in> [uncurry2 P]\\<^sub>f (Id\\<times>\\<^sub>rId)\\<times>\\<^sub>rId \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 mf, uncurry2 (RETURN \\<circ>\\<circ>\\<circ> f))\n    \\<in> [uncurry2\n            P]\\<^sub>f (Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r\n                       Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "apply (intro frefI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>uncurry2 P y;\n        (x, y) \\<in> (Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r Id\\<rbrakk>\n       \\<Longrightarrow> uncurry2 mf x\n                         \\<le> \\<Down> Id\n                                (uncurry2 (RETURN \\<circ>\\<circ>\\<circ> f)\n                                  y)", "apply (auto simp: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mk_op_rl3_np:\n    assumes \"\\<And>x y z. mf x y z \\<equiv> RETURN (f x y z)\"\n    shows \"(uncurry2 mf, uncurry2 (RETURN ooo f)) \\<in> (Id\\<times>\\<^sub>rId)\\<times>\\<^sub>rId \\<rightarrow>\\<^sub>f \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 mf, uncurry2 (RETURN \\<circ>\\<circ>\\<circ> f))\n    \\<in> (Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r\n          Id \\<rightarrow>\\<^sub>f \\<langle>Id\\<rangle>nres_rel", "apply (intro frefI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True;\n        (x, y) \\<in> (Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r Id\\<rbrakk>\n       \\<Longrightarrow> uncurry2 mf x\n                         \\<le> \\<Down> Id\n                                (uncurry2 (RETURN \\<circ>\\<circ>\\<circ> f)\n                                  y)", "apply (auto simp: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}