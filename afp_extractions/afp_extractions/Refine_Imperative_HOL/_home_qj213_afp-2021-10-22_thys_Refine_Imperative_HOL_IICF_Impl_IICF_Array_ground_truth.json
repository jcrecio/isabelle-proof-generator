{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/IICF/Impl/IICF_Array.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma is_array_precise[safe_constraint_rules]: \"precise is_array\"", "lemmas [safe_constraint_rules] = CN_FALSEI[of is_pure \"array_assn A\" for A]", "lemma array_empty_hnr_aux: \"(uncurry0 heap_array_empty,uncurry0 (RETURN op_list_empty)) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_array\"", "lemma array_replicate_hnr_aux: \n    \"(uncurry Array.new, uncurry (RETURN oo op_list_replicate)) \n      \\<in> nat_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_array\"", "lemma array_fold_custom_replicate:\n    \"replicate = op_array_replicate\"\n    \"op_list_replicate = op_array_replicate\"\n    \"mop_list_replicate = RETURN oo op_array_replicate\"", "lemmas array_replicate_custom_hnr[sepref_fr_rules] = array_replicate_hnr[unfolded array_fold_custom_replicate]", "lemma array_of_list_hnr_aux: \"(Array.of_list,RETURN o op_list_copy) \\<in> (list_assn id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a is_array\"", "lemma array_fold_custom_of_list:\n    \"l = op_array_of_list l\"\n    \"op_list_copy = op_array_of_list\"\n    \"mop_list_copy = RETURN o op_array_of_list\"", "lemmas array_of_list_custom_hnr[sepref_fr_rules] = array_of_list_hnr[folded op_array_of_list_def]", "lemma array_copy_hnr_aux: \"(array_copy, RETURN o op_list_copy) \\<in> is_array\\<^sup>k \\<rightarrow>\\<^sub>a is_array\"", "lemma array_get_hnr_aux: \"(uncurry Array.nth,uncurry (RETURN oo op_list_get)) \\<in> [\\<lambda>(l,i). i<length l]\\<^sub>a is_array\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> id_assn\"", "lemma array_set_hnr_aux: \"(uncurry2 heap_array_set,uncurry2 (RETURN ooo op_list_set)) \\<in> [\\<lambda>((l,i),_). i<length l]\\<^sub>a is_array\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k \\<rightarrow> is_array\"", "lemma array_length_hnr_aux: \"(Array.len,RETURN o op_list_length) \\<in> is_array\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], "translations": [["", "lemma is_array_precise[safe_constraint_rules]: \"precise is_array\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precise is_array", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       is_array a p * F \\<and>\\<^sub>A is_array a' p * F' \\<Longrightarrow>\n       a = a'", "unfolding is_array_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       p \\<mapsto>\\<^sub>a a * F \\<and>\\<^sub>A\n       p \\<mapsto>\\<^sub>a a' * F' \\<Longrightarrow>\n       a = a'", "apply prec_extract_eqs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       \\<lbrakk>h \\<Turnstile>\n                p \\<mapsto>\\<^sub>a a * F \\<and>\\<^sub>A\n                p \\<mapsto>\\<^sub>a a' * F';\n        a = a'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "by simp"], ["", "definition array_assn where \"array_assn A \\<equiv> hr_comp is_array (\\<langle>the_pure A\\<rangle>list_rel)\""], ["", "lemmas [safe_constraint_rules] = CN_FALSEI[of is_pure \"array_assn A\" for A]"], ["", "definition [simp,code_unfold]: \"heap_array_empty \\<equiv> Array.of_list []\""], ["", "definition [simp,code_unfold]: \"heap_array_set p i v \\<equiv> Array.upd i v p\""], ["", "context \n  notes [fcomp_norm_unfold] = array_assn_def[symmetric]\n  notes [intro!] = hfrefI hn_refineI[THEN hn_refine_preI]\n  notes [simp] = pure_def hn_ctxt_def is_array_def invalid_assn_def\nbegin"], ["", "lemma array_empty_hnr_aux: \"(uncurry0 heap_array_empty,uncurry0 (RETURN op_list_empty)) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_array\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 heap_array_empty, uncurry0 (RETURN op_list_empty))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_array", "by sep_auto"], ["", "sepref_decl_impl (no_register) array_empty: array_empty_hnr_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma array_replicate_hnr_aux: \n    \"(uncurry Array.new, uncurry (RETURN oo op_list_replicate)) \n      \\<in> nat_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_array\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry Array.new, uncurry (RETURN \\<circ>\\<circ> op_list_replicate))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_array", "by (sep_auto)"], ["", "sepref_decl_impl (no_register) array_replicate: array_replicate_hnr_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition [simp]: \"op_array_replicate \\<equiv> op_list_replicate\""], ["", "sepref_register op_array_replicate"], ["", "lemma array_fold_custom_replicate:\n    \"replicate = op_array_replicate\"\n    \"op_list_replicate = op_array_replicate\"\n    \"mop_list_replicate = RETURN oo op_array_replicate\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate = op_array_replicate &&&\n    op_list_replicate = op_array_replicate &&&\n    mop_list_replicate = RETURN \\<circ>\\<circ> op_array_replicate", "by (auto simp: op_array_replicate_def intro!: ext)"], ["", "lemmas array_replicate_custom_hnr[sepref_fr_rules] = array_replicate_hnr[unfolded array_fold_custom_replicate]"], ["", "lemma array_of_list_hnr_aux: \"(Array.of_list,RETURN o op_list_copy) \\<in> (list_assn id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a is_array\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Array.of_list, RETURN \\<circ> op_list_copy)\n    \\<in> (list_assn id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a is_array", "unfolding list_assn_pure_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Array.of_list, RETURN \\<circ> op_list_copy)\n    \\<in> (pure\n            (\\<langle>Id\\<rangle>list_rel))\\<^sup>k \\<rightarrow>\\<^sub>a is_array", "by (sep_auto)"], ["", "sepref_decl_impl (no_register) array_of_list: array_of_list_hnr_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition [simp]: \"op_array_of_list \\<equiv> op_list_copy\""], ["", "sepref_register op_array_of_list"], ["", "lemma array_fold_custom_of_list:\n    \"l = op_array_of_list l\"\n    \"op_list_copy = op_array_of_list\"\n    \"mop_list_copy = RETURN o op_array_of_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = op_array_of_list l &&&\n    op_list_copy = op_array_of_list &&&\n    mop_list_copy = RETURN \\<circ> op_array_of_list", "by (auto intro!: ext)"], ["", "lemmas array_of_list_custom_hnr[sepref_fr_rules] = array_of_list_hnr[folded op_array_of_list_def]"], ["", "lemma array_copy_hnr_aux: \"(array_copy, RETURN o op_list_copy) \\<in> is_array\\<^sup>k \\<rightarrow>\\<^sub>a is_array\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (array_copy, RETURN \\<circ> op_list_copy)\n    \\<in> is_array\\<^sup>k \\<rightarrow>\\<^sub>a is_array", "by sep_auto"], ["", "sepref_decl_impl array_copy: array_copy_hnr_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma array_get_hnr_aux: \"(uncurry Array.nth,uncurry (RETURN oo op_list_get)) \\<in> [\\<lambda>(l,i). i<length l]\\<^sub>a is_array\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow> id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry Array.nth, uncurry (RETURN \\<circ>\\<circ> op_list_get))\n    \\<in> [\\<lambda>(l, i).\n              i < length\n                   l]\\<^sub>a is_array\\<^sup>k *\\<^sub>a\n                              nat_assn\\<^sup>k \\<rightarrow> id_assn", "by sep_auto"], ["", "sepref_decl_impl array_get: array_get_hnr_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma array_set_hnr_aux: \"(uncurry2 heap_array_set,uncurry2 (RETURN ooo op_list_set)) \\<in> [\\<lambda>((l,i),_). i<length l]\\<^sub>a is_array\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k \\<rightarrow> is_array\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 heap_array_set,\n     uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_list_set))\n    \\<in> [\\<lambda>((l, i), uu_).\n              i < length\n                   l]\\<^sub>a is_array\\<^sup>d *\\<^sub>a\n                              nat_assn\\<^sup>k *\\<^sub>a\n                              id_assn\\<^sup>k \\<rightarrow> is_array", "by sep_auto"], ["", "sepref_decl_impl array_set: array_set_hnr_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma array_length_hnr_aux: \"(Array.len,RETURN o op_list_length) \\<in> is_array\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Array.len, RETURN \\<circ> op_list_length)\n    \\<in> is_array\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sep_auto"], ["", "sepref_decl_impl array_length: array_length_hnr_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "definition [simp]: \"op_array_empty \\<equiv> op_list_empty\""], ["", "interpretation array: list_custom_empty \"array_assn A\" heap_array_empty op_array_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_custom_empty (array_assn A) heap_array_empty op_array_empty", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. (uncurry0 heap_array_empty, uncurry0 (RETURN op_list_empty))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a array_assn A\n 2. op_array_empty = op_list_empty", "apply (rule array_empty_hnr[simplified pre_list_empty_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. op_array_empty = op_list_empty", "by (auto)"], ["", "end"]]}