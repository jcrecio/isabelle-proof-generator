{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/Sepref_Rules.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma intf_of_assnI: \"intf_of_assn R TYPE('a)\"", "lemma intf_of_assn_fallback: \"intf_of_assn (R :: 'a \\<Rightarrow> _ \\<Rightarrow> assn) TYPE('a)\"", "lemma rel2p_fref[rel2p]: \"rel2p (fref P R S) \n    = (\\<lambda>f g. (\\<forall>x y. P y \\<longrightarrow> rel2p R x y \\<longrightarrow> rel2p S (f x) (g y)))\"", "lemma fref_cons:  \n    assumes \"(f,g) \\<in> [P]\\<^sub>f R \\<rightarrow> S\"\n    assumes \"\\<And>c a. (c,a)\\<in>R' \\<Longrightarrow> Q a \\<Longrightarrow> P a\"\n    assumes \"R' \\<subseteq> R\"\n    assumes \"S \\<subseteq> S'\"\n    shows \"(f,g) \\<in> [Q]\\<^sub>f R' \\<rightarrow> S'\"", "lemmas fref_cons' = fref_cons[OF _ _ order_refl order_refl]", "lemma frefI[intro?]: \n    assumes \"\\<And>x y. \\<lbrakk>P y; (x,y)\\<in>R\\<rbrakk> \\<Longrightarrow> (f x, g y)\\<in>S\"\n    shows \"(f,g)\\<in>fref P R S\"", "lemma fref_ncI: \"(f,g)\\<in>R\\<rightarrow>S \\<Longrightarrow> (f,g)\\<in>R\\<rightarrow>\\<^sub>fS\"", "lemma frefD: \n    assumes \"(f,g)\\<in>fref P R S\"\n    shows \"\\<lbrakk>P y; (x,y)\\<in>R\\<rbrakk> \\<Longrightarrow> (f x, g y)\\<in>S\"", "lemma fref_ncD: \"(f,g)\\<in>R\\<rightarrow>\\<^sub>fS \\<Longrightarrow> (f,g)\\<in>R\\<rightarrow>S\"", "lemma fref_compI: \n    \"fref P R1 R2 O fref Q S1 S2 \\<subseteq>\n      fref (\\<lambda>x. Q x \\<and> (\\<forall>y. (y,x)\\<in>S1 \\<longrightarrow> P y)) (R1 O S1) (R2 O S2)\"", "lemma fref_compI':\n    \"\\<lbrakk> (f,g)\\<in>fref P R1 R2; (g,h)\\<in>fref Q S1 S2 \\<rbrakk> \n      \\<Longrightarrow> (f,h) \\<in> fref (\\<lambda>x. Q x \\<and> (\\<forall>y. (y,x)\\<in>S1 \\<longrightarrow> P y)) (R1 O S1) (R2 O S2)\"", "lemma fref_unit_conv:\n    \"(\\<lambda>_. c, \\<lambda>_. a) \\<in> fref P unit_rel S \\<longleftrightarrow> (P () \\<longrightarrow> (c,a)\\<in>S)\"", "lemma fref_uncurry_conv:\n    \"(uncurry c, uncurry a) \\<in> fref P (R1\\<times>\\<^sub>rR2) S \n    \\<longleftrightarrow> (\\<forall>x1 y1 x2 y2. P (y1,y2) \\<longrightarrow> (x1,y1)\\<in>R1 \\<longrightarrow> (x2,y2)\\<in>R2 \\<longrightarrow> (c x1 x2, a y1 y2) \\<in> S)\"", "lemma fref_mono: \"\\<lbrakk> \\<And>x. P' x \\<Longrightarrow> P x; R' \\<subseteq> R; S \\<subseteq> S' \\<rbrakk> \n    \\<Longrightarrow> fref P R S \\<subseteq> fref P' R' S'\"", "lemma fref_composeI:\n    assumes FR1: \"(f,g)\\<in>fref P R1 R2\"\n    assumes FR2: \"(g,h)\\<in>fref Q S1 S2\"\n    assumes C1: \"\\<And>x. P' x \\<Longrightarrow> Q x\"\n    assumes C2: \"\\<And>x y. \\<lbrakk>P' x; (y,x)\\<in>S1\\<rbrakk> \\<Longrightarrow> P y\"\n    assumes R1: \"R' \\<subseteq> R1 O S1\"\n    assumes R2: \"R2 O S2 \\<subseteq> S'\"\n    assumes FH: \"f'=f\" \"h'=h\"\n    shows \"(f',h') \\<in> fref P' R' S'\"", "lemma fref_triv: \"A\\<subseteq>Id \\<Longrightarrow> (f,f)\\<in>[P]\\<^sub>f A \\<rightarrow> Id\"", "lemma hfrefI[intro?]: \n    assumes \"\\<And>c a. P a \\<Longrightarrow> hn_refine (fst RS a c) (f c) (snd RS a c) T (g a)\"\n    shows \"(f,g)\\<in>hfref P RS T\"", "lemma hfrefD: \n    assumes \"(f,g)\\<in>hfref P RS T\"\n    shows \"\\<And>c a. P a \\<Longrightarrow> hn_refine (fst RS a c) (f c) (snd RS a c) T (g a)\"", "lemma hfref_to_ASSERT_conv: \n    \"NO_MATCH (\\<lambda>_. True) P \\<Longrightarrow> (a,b)\\<in>[P]\\<^sub>a R \\<rightarrow> S \\<longleftrightarrow> (a,\\<lambda>x. ASSERT (P x) \\<then> b x) \\<in> R \\<rightarrow>\\<^sub>a S\"", "lemma keep_drop_sels[simp]:  \n    \"fst (R\\<^sup>k) = R\"\n    \"snd (R\\<^sup>k) = R\"\n    \"fst (R\\<^sup>d) = R\"\n    \"snd (R\\<^sup>d) = invalid_assn R\"", "lemma hf_pres_fst[simp]: \"fst (hf_pres R k) = R\"", "lemma hfprod_fst_snd[simp]:\n    \"fst (A *\\<^sub>a B) = prod_assn (fst A) (fst B)\" \n    \"snd (A *\\<^sub>a B) = prod_assn (snd A) (snd B)\"", "lemma fref_to_pure_hfref':\n    assumes \"(f,g) \\<in> [P]\\<^sub>f R\\<rightarrow>\\<langle>S\\<rangle>nres_rel\"\n    assumes \"\\<And>x. x\\<in>Domain R \\<inter> R\\<inverse>``Collect P \\<Longrightarrow> f x = RETURN (f' x)\"\n    shows \"(return o f', g) \\<in> [P]\\<^sub>a (pure R)\\<^sup>k\\<rightarrow>pure S\"", "lemma hf2hnr:\n    assumes \"(f,g) \\<in> [P]\\<^sub>a R \\<rightarrow> S\"\n    shows \"\\<forall>x xi. P x \\<longrightarrow> hn_refine (emp * hn_ctxt (fst R) x xi) (f$xi) (emp * hn_ctxt (snd R) x xi) S (g$x)\"", "lemma to_hnr_prod_fst_snd:\n    \"fst (A *\\<^sub>a B) = to_hnr_prod (fst A) (fst B)\" \n    \"snd (A *\\<^sub>a B) = to_hnr_prod (snd A) (snd B)\"", "lemma hnr_uncurry_unfold: \"\n    (\\<forall>x xi. P x \\<longrightarrow> \n      hn_refine \n        (\\<Gamma> * hn_ctxt (to_hnr_prod A B) x xi) \n        (fi xi) \n        (\\<Gamma>' * hn_ctxt (to_hnr_prod A' B') x xi) \n        R \n        (f x))\n\\<longleftrightarrow> (\\<forall>b bi a ai. P (a,b) \\<longrightarrow>\n      hn_refine \n        (\\<Gamma> * hn_ctxt B b bi * hn_ctxt A a ai) \n        (fi (ai,bi)) \n        (\\<Gamma>' * hn_ctxt B' b bi * hn_ctxt A' a ai)\n        R\n        (f (a,b))\n    )\"", "lemma hnr_intro_dummy:\n    \"\\<forall>x xi. P x \\<longrightarrow> hn_refine (\\<Gamma> x xi) (c xi) (\\<Gamma>' x xi) R (a x) \\<Longrightarrow> \\<forall>x xi. P x \\<longrightarrow> hn_refine (emp*\\<Gamma> x xi) (c xi) (emp*\\<Gamma>' x xi) R (a x)\"", "lemma hn_ctxt_ctxt_fix_conv: \"hn_ctxt (hn_ctxt R) = hn_ctxt R\"", "lemma uncurry_APP: \"uncurry f$(a,b) = f$a$b\"", "lemma norm_RETURN_o: \n    \"\\<And>f. (RETURN o f)$x = (RETURN$(f$x))\"\n    \"\\<And>f. (RETURN oo f)$x$y = (RETURN$(f$x$y))\"\n    \"\\<And>f. (RETURN ooo f)$x$y$z = (RETURN$(f$x$y$z))\"\n    \"\\<And>f. (\\<lambda>x. RETURN ooo f x)$x$y$z$a = (RETURN$(f$x$y$z$a))\"\n    \"\\<And>f. (\\<lambda>x y. RETURN ooo f x y)$x$y$z$a$b = (RETURN$(f$x$y$z$a$b))\"", "lemma norm_return_o: \n    \"\\<And>f. (return o f)$x = (return$(f$x))\"\n    \"\\<And>f. (return oo f)$x$y = (return$(f$x$y))\"\n    \"\\<And>f. (return ooo f)$x$y$z = (return$(f$x$y$z))\"\n    \"\\<And>f. (\\<lambda>x. return ooo f x)$x$y$z$a = (return$(f$x$y$z$a))\"\n    \"\\<And>f. (\\<lambda>x y. return ooo f x y)$x$y$z$a$b = (return$(f$x$y$z$a$b))\"", "lemma hn_val_unit_conv_emp[simp]: \"hn_val unit_rel x y = emp\"", "lemma pure_unit_rel_eq_empty: \"unit_assn x y = emp\"", "lemma uc_hfprod_sel:\n    \"fst (A *\\<^sub>a B) a c = (case (a,c) of ((a1,a2),(c1,c2)) \\<Rightarrow> fst A a1 c1 * fst B a2 c2)\" \n    \"snd (A *\\<^sub>a B) a c = (case (a,c) of ((a1,a2),(c1,c2)) \\<Rightarrow> snd A a1 c1 * snd B a2 c2)\"", "lemma fref_param1: \"R\\<rightarrow>S = fref (\\<lambda>_. True) R S\"", "lemma fref_nest: \"fref P1 R1 (fref P2 R2 S) \n    \\<equiv> CURRY (fref (\\<lambda>(a,b). P1 a \\<and> P2 b) (R1\\<times>\\<^sub>rR2) S)\"", "lemma in_CURRY_conv: \"(f,g) \\<in> CURRY R \\<longleftrightarrow> (uncurry f, uncurry g) \\<in> R\"", "lemma uncurry0_APP[simp]: \"uncurry0 c $ x = c\"", "lemma fref_param0I: \"(c,a)\\<in>R \\<Longrightarrow> (uncurry0 c, uncurry0 a) \\<in> fref (\\<lambda>_. True) unit_rel R\"", "lemma hr_compI: \"(b,a)\\<in>R2 \\<Longrightarrow> R1 b c \\<Longrightarrow>\\<^sub>A hr_comp R1 R2 a c\"", "lemma hr_comp_Id1[simp]: \"hr_comp (pure Id) R = pure R\"", "lemma hr_comp_Id2[simp]: \"hr_comp R Id = R\"", "lemma hr_comp_emp[simp]: \"hr_comp (\\<lambda>a c. emp) R a c = \\<up>(\\<exists>b. (b,a)\\<in>R)\"", "lemma hr_comp_prod_conv[simp]:\n    \"hr_comp (prod_assn Ra Rb) (Ra' \\<times>\\<^sub>r Rb') \n    = prod_assn (hr_comp Ra Ra') (hr_comp Rb Rb')\"", "lemma hr_comp_pure: \"hr_comp (pure R) S = pure (R O S)\"", "lemma hr_comp_is_pure[safe_constraint_rules]: \"is_pure A \\<Longrightarrow> is_pure (hr_comp A B)\"", "lemma hr_comp_the_pure: \"is_pure A \\<Longrightarrow> the_pure (hr_comp A B) = the_pure A O B\"", "lemma rdomp_hrcomp_conv: \"rdomp (hr_comp A R) x \\<longleftrightarrow> (\\<exists>y. rdomp A y \\<and> (y,x)\\<in>R)\"", "lemma hn_rel_compI: \n    \"\\<lbrakk>nofail a; (b,a)\\<in>\\<langle>R2\\<rangle>nres_rel\\<rbrakk> \\<Longrightarrow> hn_rel R1 b c \\<Longrightarrow>\\<^sub>A hn_rel (hr_comp R1 R2) a c\"", "lemma hr_comp_precise[constraint_rules]:\n    assumes [safe_constraint_rules]: \"precise R\"\n    assumes SV: \"single_valued S\"\n    shows \"precise (hr_comp R S)\"", "lemma hr_comp_assoc: \"hr_comp (hr_comp R S) T = hr_comp R (S O T)\"", "lemma hnr_comp:\n    assumes R: \"\\<And>b1 c1. P b1 \\<Longrightarrow> hn_refine (R1 b1 c1 * \\<Gamma>) (c c1) (R1p b1 c1 * \\<Gamma>') R (b b1)\"\n    assumes S: \"\\<And>a1 b1. \\<lbrakk>Q a1; (b1,a1)\\<in>R1'\\<rbrakk> \\<Longrightarrow> (b b1,a a1)\\<in>\\<langle>R'\\<rangle>nres_rel\"\n    assumes PQ: \"\\<And>a1 b1. \\<lbrakk>Q a1; (b1,a1)\\<in>R1'\\<rbrakk> \\<Longrightarrow> P b1\"\n    assumes Q: \"Q a1\"\n    shows \"hn_refine \n      (hr_comp R1 R1' a1 c1 * \\<Gamma>) \n      (c c1)\n      (hr_comp R1p R1' a1 c1 * \\<Gamma>') \n      (hr_comp R R') \n      (a a1)\"", "lemma hnr_comp1_aux:\n    assumes R: \"\\<And>b1 c1. P b1 \\<Longrightarrow> hn_refine (hn_ctxt R1 b1 c1) (c c1) (hn_ctxt R1p b1 c1) R (b$b1)\"\n    assumes S: \"\\<And>a1 b1. \\<lbrakk>Q a1; (b1,a1)\\<in>R1'\\<rbrakk> \\<Longrightarrow> (b$b1,a$a1)\\<in>\\<langle>R'\\<rangle>nres_rel\"\n    assumes PQ: \"\\<And>a1 b1. \\<lbrakk>Q a1; (b1,a1)\\<in>R1'\\<rbrakk> \\<Longrightarrow> P b1\"\n    assumes Q: \"Q a1\"\n    shows \"hn_refine \n      (hr_comp R1 R1' a1 c1) \n      (c c1)\n      (hr_comp R1p R1' a1 c1) \n      (hr_comp R R') \n      (a a1)\"", "lemma hfcomp:\n    assumes A: \"(f,g) \\<in> [P]\\<^sub>a RR' \\<rightarrow> S\"\n    assumes B: \"(g,h) \\<in> [Q]\\<^sub>f T \\<rightarrow> \\<langle>U\\<rangle>nres_rel\"\n    shows \"(f,h) \\<in> [\\<lambda>a. Q a \\<and> (\\<forall>a'. (a',a)\\<in>T \\<longrightarrow> P a')]\\<^sub>a \n      hrp_comp RR' T \\<rightarrow> hr_comp S U\"", "lemma hfref_weaken_pre_nofail: \n    assumes \"(f,g) \\<in> [P]\\<^sub>a R \\<rightarrow> S\"  \n    shows \"(f,g) \\<in> [\\<lambda>x. nofail (g x) \\<longrightarrow> P x]\\<^sub>a R \\<rightarrow> S\"", "lemma hfref_cons:\n    assumes \"(f,g) \\<in> [P]\\<^sub>a R \\<rightarrow> S\"\n    assumes \"\\<And>x. P' x \\<Longrightarrow> P x\"\n    assumes \"\\<And>x y. fst R' x y \\<Longrightarrow>\\<^sub>t fst R x y\"\n    assumes \"\\<And>x y. snd R x y \\<Longrightarrow>\\<^sub>t snd R' x y\"\n    assumes \"\\<And>x y. S x y \\<Longrightarrow>\\<^sub>t S' x y\"\n    shows \"(f,g) \\<in> [P']\\<^sub>a R' \\<rightarrow> S'\"", "lemma prod_hrp_comp: \n    \"hrp_comp (A *\\<^sub>a B) (C \\<times>\\<^sub>r D) = hrp_comp A C *\\<^sub>a hrp_comp B D\"", "lemma hrp_comp_keep: \"hrp_comp (A\\<^sup>k) B = (hr_comp A B)\\<^sup>k\"", "lemma hr_comp_invalid: \"hr_comp (invalid_assn R1) R2 = invalid_assn (hr_comp R1 R2)\"", "lemma hrp_comp_dest: \"hrp_comp (A\\<^sup>d) B = (hr_comp A B)\\<^sup>d\"", "lemma hfref_imp: \"hrp_imp RR RR' \\<Longrightarrow> [P]\\<^sub>a RR \\<rightarrow> S \\<subseteq> [P]\\<^sub>a RR' \\<rightarrow> S\"", "lemma hrp_imp_refl: \"hrp_imp RR RR\"", "lemma hrp_imp_reflI: \"RR = RR' \\<Longrightarrow> hrp_imp RR RR'\"", "lemma hrp_comp_cong: \"hrp_imp A A' \\<Longrightarrow> B=B' \\<Longrightarrow> hrp_imp (hrp_comp A B) (hrp_comp A' B')\"", "lemma hrp_prod_cong: \"hrp_imp A A' \\<Longrightarrow> hrp_imp B B' \\<Longrightarrow> hrp_imp (A*\\<^sub>aB) (A'*\\<^sub>aB')\"", "lemma hrp_imp_trans: \"hrp_imp A B \\<Longrightarrow> hrp_imp B C \\<Longrightarrow> hrp_imp A C\"", "lemma fcomp_norm_dflt_init: \"x\\<in>[P]\\<^sub>a R \\<rightarrow> T \\<Longrightarrow> hrp_imp R S \\<Longrightarrow> x\\<in>[P]\\<^sub>a S \\<rightarrow> T\"", "lemma comp_PRE_cong[cong]: \n    assumes \"R\\<equiv>R'\"\n    assumes \"\\<And>x. P x \\<equiv> P' x\"\n    assumes \"\\<And>x. S x \\<equiv> S' x\"\n    assumes \"\\<And>x y. \\<lbrakk>P x; (y,x)\\<in>R; y\\<in>Domain R; S' x \\<rbrakk> \\<Longrightarrow> Q x y \\<equiv> Q' x y\"\n    shows \"comp_PRE R P Q S \\<equiv> comp_PRE R' P' Q' S'\"", "lemma fref_compI_PRE:\n    \"\\<lbrakk> (f,g)\\<in>fref P R1 R2; (g,h)\\<in>fref Q S1 S2 \\<rbrakk> \n      \\<Longrightarrow> (f,h) \\<in> fref (comp_PRE S1 Q (\\<lambda>_. P) (\\<lambda>_. True)) (R1 O S1) (R2 O S2)\"", "lemma PRE_D1: \"(Q x \\<and> P x) \\<longrightarrow> comp_PRE S1 Q (\\<lambda>x _. P x) S x\"", "lemma PRE_D2: \"(Q x \\<and> (\\<forall>y. (y,x)\\<in>S1 \\<longrightarrow> S x \\<longrightarrow> P x y)) \\<longrightarrow> comp_PRE S1 Q P S x\"", "lemma fref_weaken_pre: \n    assumes \"\\<And>x. P x \\<longrightarrow> P' x\"  \n    assumes \"(f,h) \\<in> fref P' R S\"\n    shows \"(f,h) \\<in> fref P R S\"", "lemma fref_PRE_D1:\n    assumes \"(f,h) \\<in> fref (comp_PRE S1 Q (\\<lambda>x _. P x) X) R S\"  \n    shows \"(f,h) \\<in> fref (\\<lambda>x. Q x \\<and> P x) R S\"", "lemma fref_PRE_D2:\n    assumes \"(f,h) \\<in> fref (comp_PRE S1 Q P X) R S\"  \n    shows \"(f,h) \\<in> fref (\\<lambda>x. Q x \\<and> (\\<forall>y. (y,x)\\<in>S1 \\<longrightarrow> X x \\<longrightarrow> P x y)) R S\"", "lemmas fref_PRE_D = fref_PRE_D1 fref_PRE_D2", "lemma hfref_weaken_pre: \n    assumes \"\\<And>x. P x \\<longrightarrow> P' x\"  \n    assumes \"(f,h) \\<in> hfref P' R S\"\n    shows \"(f,h) \\<in> hfref P R S\"", "lemma hfref_weaken_pre': \n    assumes \"\\<And>x. \\<lbrakk>P x; rdomp (fst R) x\\<rbrakk> \\<Longrightarrow> P' x\"  \n    assumes \"(f,h) \\<in> hfref P' R S\"\n    shows \"(f,h) \\<in> hfref P R S\"", "lemma hfref_weaken_pre_nofail': \n    assumes \"(f,g) \\<in> [P]\\<^sub>a R \\<rightarrow> S\"  \n    assumes \"\\<And>x. \\<lbrakk>nofail (g x); Q x\\<rbrakk> \\<Longrightarrow> P x\"\n    shows \"(f,g) \\<in> [Q]\\<^sub>a R \\<rightarrow> S\"", "lemma hfref_compI_PRE_aux:\n    assumes A: \"(f,g) \\<in> [P]\\<^sub>a RR' \\<rightarrow> S\"\n    assumes B: \"(g,h) \\<in> [Q]\\<^sub>f T \\<rightarrow> \\<langle>U\\<rangle>nres_rel\"\n    shows \"(f,h) \\<in> [comp_PRE T Q (\\<lambda>_. P) (\\<lambda>_. True)]\\<^sub>a \n      hrp_comp RR' T \\<rightarrow> hr_comp S U\"", "lemma hfref_compI_PRE:\n    assumes A: \"(f,g) \\<in> [P]\\<^sub>a RR' \\<rightarrow> S\"\n    assumes B: \"(g,h) \\<in> [Q]\\<^sub>f T \\<rightarrow> \\<langle>U\\<rangle>nres_rel\"\n    shows \"(f,h) \\<in> [comp_PRE T Q (\\<lambda>x y. P y) (\\<lambda>x. nofail (h x))]\\<^sub>a \n      hrp_comp RR' T \\<rightarrow> hr_comp S U\"", "lemma hfref_PRE_D1:\n    assumes \"(f,h) \\<in> hfref (comp_PRE S1 Q (\\<lambda>x _. P x) X) R S\"  \n    shows \"(f,h) \\<in> hfref (\\<lambda>x. Q x \\<and> P x) R S\"", "lemma hfref_PRE_D2:\n    assumes \"(f,h) \\<in> hfref (comp_PRE S1 Q P X) R S\"  \n    shows \"(f,h) \\<in> hfref (\\<lambda>x. Q x \\<and> (\\<forall>y. (y,x)\\<in>S1 \\<longrightarrow> X x \\<longrightarrow> P x y)) R S\"", "lemma hfref_PRE_D3:\n    assumes \"(f,h) \\<in> hfref (comp_PRE S1 Q P X) R S\"  \n    shows \"(f,h) \\<in> hfref (comp_PRE S1 Q P X) R S\"", "lemmas hfref_PRE_D = hfref_PRE_D1 hfref_PRE_D3", "lemmas [safe_constraint_rules] = pure_pure", "lemma uncurry0_add_app_tag: \"uncurry0 (RETURN c) = uncurry0 (RETURN$c)\"", "lemmas [to_hnr_post] = norm_RETURN_o norm_return_o\n    uncurry0_add_app_tag uncurry0_apply uncurry0_APP hn_val_unit_conv_emp\n    mult_1[of \"x::assn\" for x] mult_1_right[of \"x::assn\" for x]", "lemma prod_casesK[to_hfref_post]: \"case_prod (\\<lambda>_ _. k) = (\\<lambda>_. k)\"", "lemma uncurry0_hfref_post[to_hfref_post]: \"hfref (uncurry0 True) R S = hfref (\\<lambda>_. True) R S\"", "lemmas [fcomp_norm_unfold] = prod_rel_comp nres_rel_comp Id_O_R R_O_Id", "lemmas [fcomp_norm_unfold] = hr_comp_Id1 hr_comp_Id2", "lemmas [fcomp_norm_unfold] = hr_comp_prod_conv", "lemmas [fcomp_norm_unfold] = prod_hrp_comp hrp_comp_keep hrp_comp_dest hr_comp_pure", "lemma [fcomp_norm_simps]: \"CONSTRAINT is_pure P \\<Longrightarrow> pure (the_pure P) = P\"", "lemmas [fcomp_norm_simps] = True_implies_equals", "lemmas [fcomp_norm_init] = fcomp_norm_dflt_init", "lemmas [fcomp_norm_trans] = hrp_imp_trans", "lemmas [fcomp_norm_cong] = hrp_comp_cong hrp_prod_cong", "lemmas [fcomp_norm_refl] = refl hrp_imp_refl", "lemma ensure_fref_nresI: \"(f,g)\\<in>[P]\\<^sub>f R\\<rightarrow>S \\<Longrightarrow> (RETURN o f, RETURN o g)\\<in>[P]\\<^sub>f R\\<rightarrow>\\<langle>S\\<rangle>nres_rel\"", "lemma ensure_fref_nres_unfold:\n    \"\\<And>f. RETURN o (uncurry0 f) = uncurry0 (RETURN f)\" \n    \"\\<And>f. RETURN o (uncurry f) = uncurry (RETURN oo f)\"\n    \"\\<And>f. (RETURN ooo uncurry) f = uncurry (RETURN ooo f)\"", "lemma auto_weaken_pre_init_hf: \n    assumes \"\\<And>x. PROTECT P x \\<longrightarrow> P' x\"  \n    assumes \"(f,h) \\<in> hfref P' R S\"\n    shows \"(f,h) \\<in> hfref P R S\"", "lemma auto_weaken_pre_init_f: \n    assumes \"\\<And>x. PROTECT P x \\<longrightarrow> P' x\"  \n    assumes \"(f,h) \\<in> fref P' R S\"\n    shows \"(f,h) \\<in> fref P R S\"", "lemmas auto_weaken_pre_init = auto_weaken_pre_init_hf auto_weaken_pre_init_f", "lemma auto_weaken_pre_uncurry_step:\n    assumes \"PROTECT f a \\<equiv> f'\"\n    shows \"PROTECT (\\<lambda>(x,y). f x y) (a,b) \\<equiv> f' b\"", "lemma auto_weaken_pre_uncurry_finish:  \n    \"PROTECT f x \\<equiv> f x\"", "lemma auto_weaken_pre_uncurry_start:\n    assumes \"P \\<equiv> P'\"\n    assumes \"P'\\<longrightarrow>Q\"\n    shows \"P\\<longrightarrow>Q\"", "lemma auto_weaken_pre_comp_PRE_I:\n    assumes \"S x \\<Longrightarrow> P x\"\n    assumes \"\\<And>y. \\<lbrakk>(y,x)\\<in>R; P x; S x\\<rbrakk> \\<Longrightarrow> Q x y\"\n    shows \"comp_PRE R P Q S x\"", "lemma auto_weaken_pre_to_imp_nf:\n    \"(A\\<longrightarrow>B\\<longrightarrow>C) = (A\\<and>B \\<longrightarrow> C)\"\n    \"((A\\<and>B)\\<and>C) = (A\\<and>B\\<and>C)\"", "lemma auto_weaken_pre_add_dummy_imp:\n    \"P \\<Longrightarrow> True \\<longrightarrow> P\"", "lemma hfsynth_ID_R_D:\n    fixes I :: \"'a itself\"\n    assumes \"hfsynth_ID_R R a\"\n    assumes \"intf_of_assn R I\"\n    shows \"a ::\\<^sub>i I\"", "lemma hfsynth_hnr_from_hfI:\n    assumes \"\\<forall>x xi. P x \\<and> hfsynth_ID_R (fst R) x \\<longrightarrow> hn_refine (emp * hn_ctxt (fst R) x xi) (f$xi) (emp * hn_ctxt (snd R) x xi) S (g$x)\"\n    shows \"(f,g) \\<in> [P]\\<^sub>a R \\<rightarrow> S\"", "lemma hfsynth_ID_R_uncurry_unfold: \n    \"hfsynth_ID_R (to_hnr_prod R S) (a,b) \\<equiv> hfsynth_ID_R R a \\<and> hfsynth_ID_R S b\" \n    \"hfsynth_ID_R (fst (hf_pres R k)) \\<equiv> hfsynth_ID_R R\""], "translations": [["", "lemma intf_of_assnI: \"intf_of_assn R TYPE('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intf_of_assn R TYPE('a)", "by simp"], ["", "named_theorems_rev intf_of_assn \\<open>Links between refinement assertions and interface types\\<close>"], ["", "lemma intf_of_assn_fallback: \"intf_of_assn (R :: 'a \\<Rightarrow> _ \\<Rightarrow> assn) TYPE('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intf_of_assn R TYPE('a)", "by simp"], ["", "subsection \\<open>Function Refinement with Precondition\\<close>"], ["", "definition fref :: \"('c \\<Rightarrow> bool) \\<Rightarrow> ('a \\<times> 'c) set \\<Rightarrow> ('b \\<times> 'd) set\n           \\<Rightarrow> (('a \\<Rightarrow> 'b) \\<times> ('c \\<Rightarrow> 'd)) set\"\n    (\"[_]\\<^sub>f _ \\<rightarrow> _\" [0,60,60] 60)         \n  where \"[P]\\<^sub>f R \\<rightarrow> S \\<equiv> {(f,g). \\<forall>x y. P y \\<and> (x,y)\\<in>R \\<longrightarrow> (f x, g y)\\<in>S}\""], ["", "abbreviation freft (\"_ \\<rightarrow>\\<^sub>f _\" [60,60] 60) where \"R \\<rightarrow>\\<^sub>f S \\<equiv> ([\\<lambda>_. True]\\<^sub>f R \\<rightarrow> S)\""], ["", "lemma rel2p_fref[rel2p]: \"rel2p (fref P R S) \n    = (\\<lambda>f g. (\\<forall>x y. P y \\<longrightarrow> rel2p R x y \\<longrightarrow> rel2p S (f x) (g y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel2p ([P]\\<^sub>f R \\<rightarrow> S) =\n    (\\<lambda>f g.\n        \\<forall>x y.\n           P y \\<longrightarrow>\n           rel2p R x y \\<longrightarrow> rel2p S (f x) (g y))", "by (auto simp: fref_def rel2p_def[abs_def])"], ["", "lemma fref_cons:  \n    assumes \"(f,g) \\<in> [P]\\<^sub>f R \\<rightarrow> S\"\n    assumes \"\\<And>c a. (c,a)\\<in>R' \\<Longrightarrow> Q a \\<Longrightarrow> P a\"\n    assumes \"R' \\<subseteq> R\"\n    assumes \"S \\<subseteq> S'\"\n    shows \"(f,g) \\<in> [Q]\\<^sub>f R' \\<rightarrow> S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g) \\<in> [Q]\\<^sub>f R' \\<rightarrow> S'", "using assms"], ["proof (prove)\nusing this:\n  (f, g) \\<in> [P]\\<^sub>f R \\<rightarrow> S\n  \\<lbrakk>(?c, ?a) \\<in> R'; Q ?a\\<rbrakk> \\<Longrightarrow> P ?a\n  R' \\<subseteq> R\n  S \\<subseteq> S'\n\ngoal (1 subgoal):\n 1. (f, g) \\<in> [Q]\\<^sub>f R' \\<rightarrow> S'", "unfolding fref_def"], ["proof (prove)\nusing this:\n  (f, g)\n  \\<in> {(f, g).\n         \\<forall>x y.\n            P y \\<and> (x, y) \\<in> R \\<longrightarrow> (f x, g y) \\<in> S}\n  \\<lbrakk>(?c, ?a) \\<in> R'; Q ?a\\<rbrakk> \\<Longrightarrow> P ?a\n  R' \\<subseteq> R\n  S \\<subseteq> S'\n\ngoal (1 subgoal):\n 1. (f, g)\n    \\<in> {(f, g).\n           \\<forall>x y.\n              Q y \\<and> (x, y) \\<in> R' \\<longrightarrow>\n              (f x, g y) \\<in> S'}", "by fastforce"], ["", "lemmas fref_cons' = fref_cons[OF _ _ order_refl order_refl]"], ["", "lemma frefI[intro?]: \n    assumes \"\\<And>x y. \\<lbrakk>P y; (x,y)\\<in>R\\<rbrakk> \\<Longrightarrow> (f x, g y)\\<in>S\"\n    shows \"(f,g)\\<in>fref P R S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g) \\<in> [P]\\<^sub>f R \\<rightarrow> S", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>P ?y; (?x, ?y) \\<in> R\\<rbrakk>\n  \\<Longrightarrow> (f ?x, g ?y) \\<in> S\n\ngoal (1 subgoal):\n 1. (f, g) \\<in> [P]\\<^sub>f R \\<rightarrow> S", "unfolding fref_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>P ?y; (?x, ?y) \\<in> R\\<rbrakk>\n  \\<Longrightarrow> (f ?x, g ?y) \\<in> S\n\ngoal (1 subgoal):\n 1. (f, g)\n    \\<in> {(f, g).\n           \\<forall>x y.\n              P y \\<and> (x, y) \\<in> R \\<longrightarrow>\n              (f x, g y) \\<in> S}", "by auto"], ["", "lemma fref_ncI: \"(f,g)\\<in>R\\<rightarrow>S \\<Longrightarrow> (f,g)\\<in>R\\<rightarrow>\\<^sub>fS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g) \\<in> R \\<rightarrow> S \\<Longrightarrow>\n    (f, g) \\<in> R \\<rightarrow>\\<^sub>f S", "apply (rule frefI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>(f, g) \\<in> R \\<rightarrow> S; True;\n        (x, y) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (f x, g y) \\<in> S", "apply parametricity"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma frefD: \n    assumes \"(f,g)\\<in>fref P R S\"\n    shows \"\\<lbrakk>P y; (x,y)\\<in>R\\<rbrakk> \\<Longrightarrow> (f x, g y)\\<in>S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P y; (x, y) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> (f x, g y) \\<in> S", "using assms"], ["proof (prove)\nusing this:\n  (f, g) \\<in> [P]\\<^sub>f R \\<rightarrow> S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P y; (x, y) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> (f x, g y) \\<in> S", "unfolding fref_def"], ["proof (prove)\nusing this:\n  (f, g)\n  \\<in> {(f, g).\n         \\<forall>x y.\n            P y \\<and> (x, y) \\<in> R \\<longrightarrow> (f x, g y) \\<in> S}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>P y; (x, y) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> (f x, g y) \\<in> S", "by auto"], ["", "lemma fref_ncD: \"(f,g)\\<in>R\\<rightarrow>\\<^sub>fS \\<Longrightarrow> (f,g)\\<in>R\\<rightarrow>S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g) \\<in> R \\<rightarrow>\\<^sub>f S \\<Longrightarrow>\n    (f, g) \\<in> R \\<rightarrow> S", "apply (rule fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>(f, g) \\<in> R \\<rightarrow>\\<^sub>f S;\n        (a, a') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (f a, g a') \\<in> S", "apply (drule frefD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a a'. (a, a') \\<in> R \\<Longrightarrow> True\n 2. \\<And>a a'.\n       (a, a') \\<in> R \\<Longrightarrow> (?x2 a a', ?y2 a a') \\<in> R\n 3. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> R;\n        (f (?x2 a a'), g (?y2 a a')) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> (f a, g a') \\<in> S", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a'.\n       (a, a') \\<in> R \\<Longrightarrow> (?x2 a a', ?y2 a a') \\<in> R\n 2. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> R;\n        (f (?x2 a a'), g (?y2 a a')) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> (f a, g a') \\<in> S", "apply assumption+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fref_compI: \n    \"fref P R1 R2 O fref Q S1 S2 \\<subseteq>\n      fref (\\<lambda>x. Q x \\<and> (\\<forall>y. (y,x)\\<in>S1 \\<longrightarrow> P y)) (R1 O S1) (R2 O S2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([P]\\<^sub>f R1 \\<rightarrow> R2) O ([Q]\\<^sub>f S1 \\<rightarrow> S2)\n    \\<subseteq> [\\<lambda>x.\n                    Q x \\<and>\n                    (\\<forall>y.\n                        (y, x) \\<in> S1 \\<longrightarrow>\n                        P y)]\\<^sub>f R1 O S1 \\<rightarrow> R2 O S2", "unfolding fref_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(f, g).\n     \\<forall>x y.\n        P y \\<and> (x, y) \\<in> R1 \\<longrightarrow> (f x, g y) \\<in> R2} O\n    {(f, g).\n     \\<forall>x y.\n        Q y \\<and> (x, y) \\<in> S1 \\<longrightarrow> (f x, g y) \\<in> S2}\n    \\<subseteq> {(f, g).\n                 \\<forall>x y.\n                    (Q y \\<and>\n                     (\\<forall>ya.\n                         (ya, y) \\<in> S1 \\<longrightarrow> P ya)) \\<and>\n                    (x, y) \\<in> R1 O S1 \\<longrightarrow>\n                    (f x, g y) \\<in> R2 O S2}", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z xb yb za.\n       \\<lbrakk>\\<forall>xa ya.\n                   P ya \\<and> (xa, ya) \\<in> R1 \\<longrightarrow>\n                   (x xa, y ya) \\<in> R2;\n        \\<forall>x ya.\n           Q ya \\<and> (x, ya) \\<in> S1 \\<longrightarrow>\n           (y x, z ya) \\<in> S2;\n        Q za; \\<forall>y. (y, za) \\<in> S1 \\<longrightarrow> P y;\n        (xb, yb) \\<in> R1; (yb, za) \\<in> S1\\<rbrakk>\n       \\<Longrightarrow> (x xb, z za) \\<in> R2 O S2", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fref_compI':\n    \"\\<lbrakk> (f,g)\\<in>fref P R1 R2; (g,h)\\<in>fref Q S1 S2 \\<rbrakk> \n      \\<Longrightarrow> (f,h) \\<in> fref (\\<lambda>x. Q x \\<and> (\\<forall>y. (y,x)\\<in>S1 \\<longrightarrow> P y)) (R1 O S1) (R2 O S2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(f, g) \\<in> [P]\\<^sub>f R1 \\<rightarrow> R2;\n     (g, h) \\<in> [Q]\\<^sub>f S1 \\<rightarrow> S2\\<rbrakk>\n    \\<Longrightarrow> (f, h)\n                      \\<in> [\\<lambda>x.\n                                Q x \\<and>\n                                (\\<forall>y.\n                                    (y, x) \\<in> S1 \\<longrightarrow>\n                                    P y)]\\<^sub>f R1 O\n            S1 \\<rightarrow> R2 O S2", "using fref_compI[of P R1 R2 Q S1 S2]"], ["proof (prove)\nusing this:\n  ([P]\\<^sub>f R1 \\<rightarrow> R2) O ([Q]\\<^sub>f S1 \\<rightarrow> S2)\n  \\<subseteq> [\\<lambda>x.\n                  Q x \\<and>\n                  (\\<forall>y.\n                      (y, x) \\<in> S1 \\<longrightarrow>\n                      P y)]\\<^sub>f R1 O S1 \\<rightarrow> R2 O S2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(f, g) \\<in> [P]\\<^sub>f R1 \\<rightarrow> R2;\n     (g, h) \\<in> [Q]\\<^sub>f S1 \\<rightarrow> S2\\<rbrakk>\n    \\<Longrightarrow> (f, h)\n                      \\<in> [\\<lambda>x.\n                                Q x \\<and>\n                                (\\<forall>y.\n                                    (y, x) \\<in> S1 \\<longrightarrow>\n                                    P y)]\\<^sub>f R1 O\n            S1 \\<rightarrow> R2 O S2", "by auto"], ["", "lemma fref_unit_conv:\n    \"(\\<lambda>_. c, \\<lambda>_. a) \\<in> fref P unit_rel S \\<longleftrightarrow> (P () \\<longrightarrow> (c,a)\\<in>S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>_. c, \\<lambda>_. a)\n     \\<in> [P]\\<^sub>f unit_rel \\<rightarrow> S) =\n    (P () \\<longrightarrow> (c, a) \\<in> S)", "by (auto simp: fref_def)"], ["", "lemma fref_uncurry_conv:\n    \"(uncurry c, uncurry a) \\<in> fref P (R1\\<times>\\<^sub>rR2) S \n    \\<longleftrightarrow> (\\<forall>x1 y1 x2 y2. P (y1,y2) \\<longrightarrow> (x1,y1)\\<in>R1 \\<longrightarrow> (x2,y2)\\<in>R2 \\<longrightarrow> (c x1 x2, a y1 y2) \\<in> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((uncurry c, uncurry a)\n     \\<in> [P]\\<^sub>f R1 \\<times>\\<^sub>r R2 \\<rightarrow> S) =\n    (\\<forall>x1 y1 x2 y2.\n        P (y1, y2) \\<longrightarrow>\n        (x1, y1) \\<in> R1 \\<longrightarrow>\n        (x2, y2) \\<in> R2 \\<longrightarrow> (c x1 x2, a y1 y2) \\<in> S)", "by (auto simp: fref_def)"], ["", "lemma fref_mono: \"\\<lbrakk> \\<And>x. P' x \\<Longrightarrow> P x; R' \\<subseteq> R; S \\<subseteq> S' \\<rbrakk> \n    \\<Longrightarrow> fref P R S \\<subseteq> fref P' R' S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. P' x \\<Longrightarrow> P x; R' \\<subseteq> R;\n     S \\<subseteq> S'\\<rbrakk>\n    \\<Longrightarrow> [P]\\<^sub>f R \\<rightarrow> S\n                      \\<subseteq> [P']\\<^sub>f R' \\<rightarrow> S'", "unfolding fref_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. P' x \\<Longrightarrow> P x; R' \\<subseteq> R;\n     S \\<subseteq> S'\\<rbrakk>\n    \\<Longrightarrow> {(f, g).\n                       \\<forall>x y.\n                          P y \\<and> (x, y) \\<in> R \\<longrightarrow>\n                          (f x, g y) \\<in> S}\n                      \\<subseteq> {(f, g).\n                                   \\<forall>x y.\nP' y \\<and> (x, y) \\<in> R' \\<longrightarrow> (f x, g y) \\<in> S'}", "by auto blast"], ["", "lemma fref_composeI:\n    assumes FR1: \"(f,g)\\<in>fref P R1 R2\"\n    assumes FR2: \"(g,h)\\<in>fref Q S1 S2\"\n    assumes C1: \"\\<And>x. P' x \\<Longrightarrow> Q x\"\n    assumes C2: \"\\<And>x y. \\<lbrakk>P' x; (y,x)\\<in>S1\\<rbrakk> \\<Longrightarrow> P y\"\n    assumes R1: \"R' \\<subseteq> R1 O S1\"\n    assumes R2: \"R2 O S2 \\<subseteq> S'\"\n    assumes FH: \"f'=f\" \"h'=h\"\n    shows \"(f',h') \\<in> fref P' R' S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f', h') \\<in> [P']\\<^sub>f R' \\<rightarrow> S'", "unfolding FH"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, h) \\<in> [P']\\<^sub>f R' \\<rightarrow> S'", "apply (rule subsetD[OF fref_mono fref_compI'[OF FR1 FR2]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       P' x \\<Longrightarrow>\n       Q x \\<and> (\\<forall>y. (y, x) \\<in> S1 \\<longrightarrow> P y)\n 2. R' \\<subseteq> R1 O S1\n 3. R2 O S2 \\<subseteq> S'", "using C1 C2"], ["proof (prove)\nusing this:\n  P' ?x \\<Longrightarrow> Q ?x\n  \\<lbrakk>P' ?x; (?y, ?x) \\<in> S1\\<rbrakk> \\<Longrightarrow> P ?y\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       P' x \\<Longrightarrow>\n       Q x \\<and> (\\<forall>y. (y, x) \\<in> S1 \\<longrightarrow> P y)\n 2. R' \\<subseteq> R1 O S1\n 3. R2 O S2 \\<subseteq> S'", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. R' \\<subseteq> R1 O S1\n 2. R2 O S2 \\<subseteq> S'", "using R1"], ["proof (prove)\nusing this:\n  R' \\<subseteq> R1 O S1\n\ngoal (2 subgoals):\n 1. R' \\<subseteq> R1 O S1\n 2. R2 O S2 \\<subseteq> S'", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. R2 O S2 \\<subseteq> S'", "using R2"], ["proof (prove)\nusing this:\n  R2 O S2 \\<subseteq> S'\n\ngoal (1 subgoal):\n 1. R2 O S2 \\<subseteq> S'", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fref_triv: \"A\\<subseteq>Id \\<Longrightarrow> (f,f)\\<in>[P]\\<^sub>f A \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> Id \\<Longrightarrow>\n    (f, f) \\<in> [P]\\<^sub>f A \\<rightarrow> Id", "by (auto simp: fref_def)"], ["", "subsection \\<open>Heap-Function Refinement\\<close>"], ["", "text \\<open>\n    The following relates a heap-function with a pure function.\n    It contains a precondition, a refinement assertion for the arguments\n    before and after execution, and a refinement relation for the result.\n    \\<close>"], ["", "(* TODO: We only use this with keep/destroy information, so we could model\n    the parameter relations as such (('a\\<Rightarrow>'ai \\<Rightarrow> assn) \\<times> bool) *)"], ["", "definition hfref \n    :: \"\n      ('a \\<Rightarrow> bool) \n   \\<Rightarrow> (('a \\<Rightarrow> 'ai \\<Rightarrow> assn) \\<times> ('a \\<Rightarrow> 'ai \\<Rightarrow> assn)) \n   \\<Rightarrow> ('b \\<Rightarrow> 'bi \\<Rightarrow> assn) \n   \\<Rightarrow> (('ai \\<Rightarrow> 'bi Heap) \\<times> ('a\\<Rightarrow>'b nres)) set\"\n   (\"[_]\\<^sub>a _ \\<rightarrow> _\" [0,60,60] 60)\n   where\n    \"[P]\\<^sub>a RS \\<rightarrow> T \\<equiv> { (f,g) . \\<forall>c a.  P a \\<longrightarrow> hn_refine (fst RS a c) (f c) (snd RS a c) T (g a)}\""], ["", "abbreviation hfreft (\"_ \\<rightarrow>\\<^sub>a _\" [60,60] 60) where \"RS \\<rightarrow>\\<^sub>a T \\<equiv> ([\\<lambda>_. True]\\<^sub>a RS \\<rightarrow> T)\""], ["", "lemma hfrefI[intro?]: \n    assumes \"\\<And>c a. P a \\<Longrightarrow> hn_refine (fst RS a c) (f c) (snd RS a c) T (g a)\"\n    shows \"(f,g)\\<in>hfref P RS T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g) \\<in> [P]\\<^sub>a RS \\<rightarrow> T", "using assms"], ["proof (prove)\nusing this:\n  P ?a \\<Longrightarrow>\n  hn_refine (fst RS ?a ?c) (f ?c) (snd RS ?a ?c) T (g ?a)\n\ngoal (1 subgoal):\n 1. (f, g) \\<in> [P]\\<^sub>a RS \\<rightarrow> T", "unfolding hfref_def"], ["proof (prove)\nusing this:\n  P ?a \\<Longrightarrow>\n  hn_refine (fst RS ?a ?c) (f ?c) (snd RS ?a ?c) T (g ?a)\n\ngoal (1 subgoal):\n 1. (f, g)\n    \\<in> {(f, g).\n           \\<forall>c a.\n              P a \\<longrightarrow>\n              hn_refine (fst RS a c) (f c) (snd RS a c) T (g a)}", "by blast"], ["", "lemma hfrefD: \n    assumes \"(f,g)\\<in>hfref P RS T\"\n    shows \"\\<And>c a. P a \\<Longrightarrow> hn_refine (fst RS a c) (f c) (snd RS a c) T (g a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       P a \\<Longrightarrow>\n       hn_refine (fst RS a c) (f c) (snd RS a c) T (g a)", "using assms"], ["proof (prove)\nusing this:\n  (f, g) \\<in> [P]\\<^sub>a RS \\<rightarrow> T\n\ngoal (1 subgoal):\n 1. \\<And>c a.\n       P a \\<Longrightarrow>\n       hn_refine (fst RS a c) (f c) (snd RS a c) T (g a)", "unfolding hfref_def"], ["proof (prove)\nusing this:\n  (f, g)\n  \\<in> {(f, g).\n         \\<forall>c a.\n            P a \\<longrightarrow>\n            hn_refine (fst RS a c) (f c) (snd RS a c) T (g a)}\n\ngoal (1 subgoal):\n 1. \\<And>c a.\n       P a \\<Longrightarrow>\n       hn_refine (fst RS a c) (f c) (snd RS a c) T (g a)", "by blast"], ["", "lemma hfref_to_ASSERT_conv: \n    \"NO_MATCH (\\<lambda>_. True) P \\<Longrightarrow> (a,b)\\<in>[P]\\<^sub>a R \\<rightarrow> S \\<longleftrightarrow> (a,\\<lambda>x. ASSERT (P x) \\<then> b x) \\<in> R \\<rightarrow>\\<^sub>a S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NO_MATCH (\\<lambda>_. True) P \\<Longrightarrow>\n    ((a, b) \\<in> [P]\\<^sub>a R \\<rightarrow> S) =\n    ((a, \\<lambda>x. ASSERT (P x) \\<bind> (\\<lambda>_. b x))\n     \\<in> R \\<rightarrow>\\<^sub>a S)", "unfolding hfref_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. NO_MATCH (\\<lambda>_. True) P \\<Longrightarrow>\n    ((a, b)\n     \\<in> {(f, g).\n            \\<forall>c a.\n               P a \\<longrightarrow>\n               hn_refine (fst R a c) (f c) (snd R a c) S (g a)}) =\n    ((a, \\<lambda>x. ASSERT (P x) \\<bind> (\\<lambda>_. b x))\n     \\<in> {(f, g).\n            \\<forall>c a.\n               True \\<longrightarrow>\n               hn_refine (fst R a c) (f c) (snd R a c) S (g a)})", "apply (clarsimp; safe; clarsimp?)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c aa.\n       \\<forall>c aa.\n          P aa \\<longrightarrow>\n          hn_refine (fst R aa c) (a c) (snd R aa c) S\n           (b aa) \\<Longrightarrow>\n       hn_refine (fst R aa c) (a c) (snd R aa c) S\n        (ASSERT (P aa) \\<bind> (\\<lambda>_. b aa))\n 2. \\<And>c aa.\n       \\<lbrakk>\\<forall>c aa.\n                   hn_refine (fst R aa c) (a c) (snd R aa c) S\n                    (ASSERT (P aa) \\<bind> (\\<lambda>_. b aa));\n        P aa\\<rbrakk>\n       \\<Longrightarrow> hn_refine (fst R aa c) (a c) (snd R aa c) S (b aa)", "apply (rule hn_refine_nofailI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c aa.\n       \\<lbrakk>\\<forall>c aa.\n                   P aa \\<longrightarrow>\n                   hn_refine (fst R aa c) (a c) (snd R aa c) S (b aa);\n        nofail (ASSERT (P aa) \\<bind> (\\<lambda>_. b aa))\\<rbrakk>\n       \\<Longrightarrow> hn_refine (fst R aa c) (a c) (snd R aa c) S\n                          (ASSERT (P aa) \\<bind> (\\<lambda>_. b aa))\n 2. \\<And>c aa.\n       \\<lbrakk>\\<forall>c aa.\n                   hn_refine (fst R aa c) (a c) (snd R aa c) S\n                    (ASSERT (P aa) \\<bind> (\\<lambda>_. b aa));\n        P aa\\<rbrakk>\n       \\<Longrightarrow> hn_refine (fst R aa c) (a c) (snd R aa c) S (b aa)", "apply (simp add: refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c aa.\n       \\<lbrakk>\\<forall>c aa.\n                   hn_refine (fst R aa c) (a c) (snd R aa c) S\n                    (ASSERT (P aa) \\<bind> (\\<lambda>_. b aa));\n        P aa\\<rbrakk>\n       \\<Longrightarrow> hn_refine (fst R aa c) (a c) (snd R aa c) S (b aa)", "subgoal for xc xa"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c aa.\n                hn_refine (fst R aa c) (a c) (snd R aa c) S\n                 (ASSERT (P aa) \\<bind> (\\<lambda>_. b aa));\n     P xa\\<rbrakk>\n    \\<Longrightarrow> hn_refine (fst R xa xc) (a xc) (snd R xa xc) S (b xa)", "apply (drule spec[of _ xc])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P xa;\n     \\<forall>aa.\n        hn_refine (fst R aa xc) (a xc) (snd R aa xc) S\n         (ASSERT (P aa) \\<bind> (\\<lambda>_. b aa))\\<rbrakk>\n    \\<Longrightarrow> hn_refine (fst R xa xc) (a xc) (snd R xa xc) S (b xa)", "apply (drule spec[of _ xa])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P xa;\n     hn_refine (fst R xa xc) (a xc) (snd R xa xc) S\n      (ASSERT (P xa) \\<bind> (\\<lambda>_. b xa))\\<rbrakk>\n    \\<Longrightarrow> hn_refine (fst R xa xc) (a xc) (snd R xa xc) S (b xa)", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n    A pair of argument refinement assertions can be created by the \n    input assertion and the information whether the parameter is kept or destroyed\n    by the function.\n    \\<close>"], ["", "primrec hf_pres \n    :: \"('a \\<Rightarrow> 'b \\<Rightarrow> assn) \\<Rightarrow> bool \\<Rightarrow> ('a \\<Rightarrow> 'b \\<Rightarrow> assn)\\<times>('a \\<Rightarrow> 'b \\<Rightarrow> assn)\"\n    where \n      \"hf_pres R True = (R,R)\" | \"hf_pres R False = (R,invalid_assn R)\""], ["", "abbreviation hfkeep \n    :: \"('a \\<Rightarrow> 'b \\<Rightarrow> assn) \\<Rightarrow> ('a \\<Rightarrow> 'b \\<Rightarrow> assn)\\<times>('a \\<Rightarrow> 'b \\<Rightarrow> assn)\" \n    (\"(_\\<^sup>k)\" [1000] 999)\n    where \"R\\<^sup>k \\<equiv> hf_pres R True\""], ["", "abbreviation hfdrop \n    :: \"('a \\<Rightarrow> 'b \\<Rightarrow> assn) \\<Rightarrow> ('a \\<Rightarrow> 'b \\<Rightarrow> assn)\\<times>('a \\<Rightarrow> 'b \\<Rightarrow> assn)\" \n    (\"(_\\<^sup>d)\" [1000] 999)\n    where \"R\\<^sup>d \\<equiv> hf_pres R False\""], ["", "abbreviation \"hn_kede R kd \\<equiv> hn_ctxt (snd (hf_pres R kd))\""], ["", "abbreviation \"hn_keep R \\<equiv> hn_kede R True\""], ["", "abbreviation \"hn_dest R \\<equiv> hn_kede R False\""], ["", "lemma keep_drop_sels[simp]:  \n    \"fst (R\\<^sup>k) = R\"\n    \"snd (R\\<^sup>k) = R\"\n    \"fst (R\\<^sup>d) = R\"\n    \"snd (R\\<^sup>d) = invalid_assn R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst (R\\<^sup>k) = R &&& snd (R\\<^sup>k) = R) &&&\n    fst (R\\<^sup>d) = R &&& snd (R\\<^sup>d) = invalid_assn R", "by auto"], ["", "lemma hf_pres_fst[simp]: \"fst (hf_pres R k) = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (hf_pres R k) = R", "by (cases k) auto"], ["", "text \\<open>\n    The following operator combines multiple argument assertion-pairs to\n    argument assertion-pairs for the product. It is required to state\n    argument assertion-pairs for uncurried functions.\n    \\<close>"], ["", "definition hfprod :: \"\n    (('a \\<Rightarrow> 'b \\<Rightarrow> assn)\\<times>('a \\<Rightarrow> 'b \\<Rightarrow> assn)) \n    \\<Rightarrow> (('c \\<Rightarrow> 'd \\<Rightarrow> assn)\\<times>('c \\<Rightarrow> 'd \\<Rightarrow> assn))\n    \\<Rightarrow> ((('a\\<times>'c) \\<Rightarrow> ('b \\<times> 'd) \\<Rightarrow> assn) \\<times> (('a\\<times>'c) \\<Rightarrow> ('b \\<times> 'd) \\<Rightarrow> assn))\"\n    (infixl \"*\\<^sub>a\" 65)\n    where \"RR *\\<^sub>a SS \\<equiv> (prod_assn (fst RR) (fst SS), prod_assn (snd RR) (snd SS))\""], ["", "lemma hfprod_fst_snd[simp]:\n    \"fst (A *\\<^sub>a B) = prod_assn (fst A) (fst B)\" \n    \"snd (A *\\<^sub>a B) = prod_assn (snd A) (snd B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (A *\\<^sub>a B) = fst A \\<times>\\<^sub>a fst B &&&\n    snd (A *\\<^sub>a B) = snd A \\<times>\\<^sub>a snd B", "unfolding hfprod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fst A \\<times>\\<^sub>a fst B, snd A \\<times>\\<^sub>a snd B) =\n    fst A \\<times>\\<^sub>a fst B &&&\n    snd (fst A \\<times>\\<^sub>a fst B, snd A \\<times>\\<^sub>a snd B) =\n    snd A \\<times>\\<^sub>a snd B", "by auto"], ["", "subsubsection \\<open>Conversion from fref to hfref\\<close>"], ["", "(* TODO: Variant of import-param! Automate this! *)"], ["", "lemma fref_to_pure_hfref':\n    assumes \"(f,g) \\<in> [P]\\<^sub>f R\\<rightarrow>\\<langle>S\\<rangle>nres_rel\"\n    assumes \"\\<And>x. x\\<in>Domain R \\<inter> R\\<inverse>``Collect P \\<Longrightarrow> f x = RETURN (f' x)\"\n    shows \"(return o f', g) \\<in> [P]\\<^sub>a (pure R)\\<^sup>k\\<rightarrow>pure S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return \\<circ> f', g)\n    \\<in> [P]\\<^sub>a (pure R)\\<^sup>k \\<rightarrow> pure S", "apply (rule hfrefI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       P a \\<Longrightarrow>\n       hn_refine (fst ((pure R)\\<^sup>k) a c) ((return \\<circ> f') c)\n        (snd ((pure R)\\<^sup>k) a c) (pure S) (g a)", "apply (rule hn_refineI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       \\<lbrakk>P a; nofail (g a)\\<rbrakk>\n       \\<Longrightarrow> <fst ((pure R)\\<^sup>k) a\n                           c> (return \\<circ> f')\n                               c <\\<lambda>r.\n                                     snd ((pure R)\\<^sup>k) a c *\n                                     (\\<exists>\\<^sub>Ax.\n   pure S x r * \\<up> (RETURN x \\<le> g a))>\\<^sub>t", "using assms"], ["proof (prove)\nusing this:\n  (f, g) \\<in> [P]\\<^sub>f R \\<rightarrow> \\<langle>S\\<rangle>nres_rel\n  ?x \\<in> Domain R \\<inter> R\\<inverse> `` Collect P \\<Longrightarrow>\n  f ?x = RETURN (f' ?x)\n\ngoal (1 subgoal):\n 1. \\<And>c a.\n       \\<lbrakk>P a; nofail (g a)\\<rbrakk>\n       \\<Longrightarrow> <fst ((pure R)\\<^sup>k) a\n                           c> (return \\<circ> f')\n                               c <\\<lambda>r.\n                                     snd ((pure R)\\<^sup>k) a c *\n                                     (\\<exists>\\<^sub>Ax.\n   pure S x r * \\<up> (RETURN x \\<le> g a))>\\<^sub>t", "apply ((sep_auto simp: fref_def pure_def pw_le_iff pw_nres_rel_iff\n      refine_pw_simps eintros del: exI))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a aa b.\n       \\<lbrakk>P a; nofail (g a);\n        \\<forall>x y.\n           P y \\<and> (x, y) \\<in> R \\<longrightarrow>\n           nofail (g y) \\<longrightarrow>\n           nofail (f x) \\<and>\n           (\\<forall>xa.\n               inres (f x) xa \\<longrightarrow>\n               (\\<exists>s'. (xa, s') \\<in> S \\<and> inres (g y) s'));\n        \\<And>x.\n           x \\<in> Domain R \\<and>\n           x \\<in> R\\<inverse> `` Collect P \\<Longrightarrow>\n           f x = RETURN (f' x);\n        (c, a) \\<in> R; (aa, b) \\<Turnstile> emp\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x. (f' c, x) \\<in> S \\<and> inres (g a) x", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Conversion from hfref to hnr\\<close>"], ["", "text \\<open>This section contains the lemmas. The ML code is further down. \\<close>"], ["", "lemma hf2hnr:\n    assumes \"(f,g) \\<in> [P]\\<^sub>a R \\<rightarrow> S\"\n    shows \"\\<forall>x xi. P x \\<longrightarrow> hn_refine (emp * hn_ctxt (fst R) x xi) (f$xi) (emp * hn_ctxt (snd R) x xi) S (g$x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xi.\n       P x \\<longrightarrow>\n       hn_refine (emp * hn_ctxt (fst R) x xi) (f $ xi)\n        (emp * hn_ctxt (snd R) x xi) S (g $ x)", "using assms"], ["proof (prove)\nusing this:\n  (f, g) \\<in> [P]\\<^sub>a R \\<rightarrow> S\n\ngoal (1 subgoal):\n 1. \\<forall>x xi.\n       P x \\<longrightarrow>\n       hn_refine (emp * hn_ctxt (fst R) x xi) (f $ xi)\n        (emp * hn_ctxt (snd R) x xi) S (g $ x)", "unfolding hfref_def"], ["proof (prove)\nusing this:\n  (f, g)\n  \\<in> {(f, g).\n         \\<forall>c a.\n            P a \\<longrightarrow>\n            hn_refine (fst R a c) (f c) (snd R a c) S (g a)}\n\ngoal (1 subgoal):\n 1. \\<forall>x xi.\n       P x \\<longrightarrow>\n       hn_refine (emp * hn_ctxt (fst R) x xi) (f $ xi)\n        (emp * hn_ctxt (snd R) x xi) S (g $ x)", "by (auto simp: hn_ctxt_def)"], ["", "(*lemma hf2hnr_new:\n    assumes \"(f,g) \\<in> [P]\\<^sub>a R \\<rightarrow> S\"\n    shows \"\\<forall>x xi. (\\<forall>h. h\\<Turnstile>fst R x xi \\<longrightarrow> P x) \\<longrightarrow> hn_refine (emp * hn_ctxt (fst R) x xi) (f xi) (emp * hn_ctxt (snd R) x xi) S (g$x)\"\n    using assms\n    unfolding hfref_def \n    by (auto simp: hn_ctxt_def intro: hn_refine_preI)\n  *)\n\n\n  (* Products that stem from currying are tagged by a special refinement relation *)"], ["", "definition [simp]: \"to_hnr_prod \\<equiv> prod_assn\""], ["", "lemma to_hnr_prod_fst_snd:\n    \"fst (A *\\<^sub>a B) = to_hnr_prod (fst A) (fst B)\" \n    \"snd (A *\\<^sub>a B) = to_hnr_prod (snd A) (snd B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (A *\\<^sub>a B) = to_hnr_prod (fst A) (fst B) &&&\n    snd (A *\\<^sub>a B) = to_hnr_prod (snd A) (snd B)", "unfolding hfprod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fst A \\<times>\\<^sub>a fst B, snd A \\<times>\\<^sub>a snd B) =\n    to_hnr_prod (fst A) (fst B) &&&\n    snd (fst A \\<times>\\<^sub>a fst B, snd A \\<times>\\<^sub>a snd B) =\n    to_hnr_prod (snd A) (snd B)", "by auto"], ["", "(* Warning: This lemma is carefully set up to be applicable as an unfold rule,\n    for more than one level of uncurrying*)"], ["", "lemma hnr_uncurry_unfold: \"\n    (\\<forall>x xi. P x \\<longrightarrow> \n      hn_refine \n        (\\<Gamma> * hn_ctxt (to_hnr_prod A B) x xi) \n        (fi xi) \n        (\\<Gamma>' * hn_ctxt (to_hnr_prod A' B') x xi) \n        R \n        (f x))\n\\<longleftrightarrow> (\\<forall>b bi a ai. P (a,b) \\<longrightarrow>\n      hn_refine \n        (\\<Gamma> * hn_ctxt B b bi * hn_ctxt A a ai) \n        (fi (ai,bi)) \n        (\\<Gamma>' * hn_ctxt B' b bi * hn_ctxt A' a ai)\n        R\n        (f (a,b))\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x xi.\n        P x \\<longrightarrow>\n        hn_refine (\\<Gamma> * hn_ctxt (to_hnr_prod A B) x xi) (fi xi)\n         (\\<Gamma>' * hn_ctxt (to_hnr_prod A' B') x xi) R (f x)) =\n    (\\<forall>b bi a ai.\n        P (a, b) \\<longrightarrow>\n        hn_refine (\\<Gamma> * hn_ctxt B b bi * hn_ctxt A a ai) (fi (ai, bi))\n         (\\<Gamma>' * hn_ctxt B' b bi * hn_ctxt A' a ai) R (f (a, b)))", "by (auto simp: hn_ctxt_def prod_assn_def star_aci)"], ["", "lemma hnr_intro_dummy:\n    \"\\<forall>x xi. P x \\<longrightarrow> hn_refine (\\<Gamma> x xi) (c xi) (\\<Gamma>' x xi) R (a x) \\<Longrightarrow> \\<forall>x xi. P x \\<longrightarrow> hn_refine (emp*\\<Gamma> x xi) (c xi) (emp*\\<Gamma>' x xi) R (a x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xi.\n       P x \\<longrightarrow>\n       hn_refine (\\<Gamma> x xi) (c xi) (\\<Gamma>' x xi) R\n        (a x) \\<Longrightarrow>\n    \\<forall>x xi.\n       P x \\<longrightarrow>\n       hn_refine (emp * \\<Gamma> x xi) (c xi) (emp * \\<Gamma>' x xi) R (a x)", "by simp"], ["", "lemma hn_ctxt_ctxt_fix_conv: \"hn_ctxt (hn_ctxt R) = hn_ctxt R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt (hn_ctxt R) = hn_ctxt R", "by (simp add: hn_ctxt_def[abs_def])"], ["", "lemma uncurry_APP: \"uncurry f$(a,b) = f$a$b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uncurry f $ (a, b) = f $ a $ b", "by auto"], ["", "(* TODO: Replace by more general rule. *)"], ["", "lemma norm_RETURN_o: \n    \"\\<And>f. (RETURN o f)$x = (RETURN$(f$x))\"\n    \"\\<And>f. (RETURN oo f)$x$y = (RETURN$(f$x$y))\"\n    \"\\<And>f. (RETURN ooo f)$x$y$z = (RETURN$(f$x$y$z))\"\n    \"\\<And>f. (\\<lambda>x. RETURN ooo f x)$x$y$z$a = (RETURN$(f$x$y$z$a))\"\n    \"\\<And>f. (\\<lambda>x y. RETURN ooo f x y)$x$y$z$a$b = (RETURN$(f$x$y$z$a$b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>f. (RETURN \\<circ> f) $ x = RETURN $ (f $ x)) &&&\n     (\\<And>f.\n         (RETURN \\<circ>\\<circ> f) $ x $ y = RETURN $ (f $ x $ y))) &&&\n    (\\<And>f.\n        (RETURN \\<circ>\\<circ>\\<circ> f) $ x $ y $ z =\n        RETURN $ (f $ x $ y $ z)) &&&\n    (\\<And>f.\n        (\\<lambda>x. RETURN \\<circ>\\<circ>\\<circ> f x) $ x $ y $ z $ a =\n        RETURN $ (f $ x $ y $ z $ a)) &&&\n    (\\<And>f.\n        (\\<lambda>x y. RETURN \\<circ>\\<circ>\\<circ> f x y) $ x $ y $ z $ a $\n        b =\n        RETURN $ (f $ x $ y $ z $ a $ b))", "by auto"], ["", "lemma norm_return_o: \n    \"\\<And>f. (return o f)$x = (return$(f$x))\"\n    \"\\<And>f. (return oo f)$x$y = (return$(f$x$y))\"\n    \"\\<And>f. (return ooo f)$x$y$z = (return$(f$x$y$z))\"\n    \"\\<And>f. (\\<lambda>x. return ooo f x)$x$y$z$a = (return$(f$x$y$z$a))\"\n    \"\\<And>f. (\\<lambda>x y. return ooo f x y)$x$y$z$a$b = (return$(f$x$y$z$a$b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>f. (return \\<circ> f) $ x = return $ (f $ x)) &&&\n     (\\<And>f.\n         (return \\<circ>\\<circ> f) $ x $ y = return $ (f $ x $ y))) &&&\n    (\\<And>f.\n        (return \\<circ>\\<circ>\\<circ> f) $ x $ y $ z =\n        return $ (f $ x $ y $ z)) &&&\n    (\\<And>f.\n        (\\<lambda>x. return \\<circ>\\<circ>\\<circ> f x) $ x $ y $ z $ a =\n        return $ (f $ x $ y $ z $ a)) &&&\n    (\\<And>f.\n        (\\<lambda>x y. return \\<circ>\\<circ>\\<circ> f x y) $ x $ y $ z $ a $\n        b =\n        return $ (f $ x $ y $ z $ a $ b))", "by auto"], ["", "lemma hn_val_unit_conv_emp[simp]: \"hn_val unit_rel x y = emp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_val unit_rel x y = emp", "by (auto simp: hn_ctxt_def pure_def)"], ["", "subsubsection \\<open>Conversion from hnr to hfref\\<close>"], ["", "text \\<open>This section contains the lemmas. The ML code is further down. \\<close>"], ["", "abbreviation \"id_assn \\<equiv> pure Id\""], ["", "abbreviation \"unit_assn \\<equiv> id_assn :: unit \\<Rightarrow> _\""], ["", "lemma pure_unit_rel_eq_empty: \"unit_assn x y = emp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_assn x y = emp", "by (auto simp: pure_def)"], ["", "lemma uc_hfprod_sel:\n    \"fst (A *\\<^sub>a B) a c = (case (a,c) of ((a1,a2),(c1,c2)) \\<Rightarrow> fst A a1 c1 * fst B a2 c2)\" \n    \"snd (A *\\<^sub>a B) a c = (case (a,c) of ((a1,a2),(c1,c2)) \\<Rightarrow> snd A a1 c1 * snd B a2 c2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (A *\\<^sub>a B) a c =\n    (case (a, c) of\n     ((a1, a2), c1, c2) \\<Rightarrow> fst A a1 c1 * fst B a2 c2) &&&\n    snd (A *\\<^sub>a B) a c =\n    (case (a, c) of\n     ((a1, a2), c1, c2) \\<Rightarrow> snd A a1 c1 * snd B a2 c2)", "unfolding hfprod_def prod_assn_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (\\<lambda>a c.\n            case (a, c) of\n            ((a1, a2), c1, c2) \\<Rightarrow> fst A a1 c1 * fst B a2 c2,\n         \\<lambda>a c.\n            case (a, c) of\n            ((a1, a2), c1, c2) \\<Rightarrow> snd A a1 c1 * snd B a2 c2)\n     a c =\n    (case (a, c) of\n     ((a1, a2), c1, c2) \\<Rightarrow> fst A a1 c1 * fst B a2 c2) &&&\n    snd (\\<lambda>a c.\n            case (a, c) of\n            ((a1, a2), c1, c2) \\<Rightarrow> fst A a1 c1 * fst B a2 c2,\n         \\<lambda>a c.\n            case (a, c) of\n            ((a1, a2), c1, c2) \\<Rightarrow> snd A a1 c1 * snd B a2 c2)\n     a c =\n    (case (a, c) of\n     ((a1, a2), c1, c2) \\<Rightarrow> snd A a1 c1 * snd B a2 c2)", "by auto"], ["", "subsubsection \\<open>Conversion from relation to fref\\<close>"], ["", "text \\<open>This section contains the lemmas. The ML code is further down. \\<close>"], ["", "definition \"CURRY R \\<equiv> { (f,g). (uncurry f, uncurry g) \\<in> R }\""], ["", "lemma fref_param1: \"R\\<rightarrow>S = fref (\\<lambda>_. True) R S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<rightarrow> S = R \\<rightarrow>\\<^sub>f S", "by (auto simp: fref_def fun_relD)"], ["", "lemma fref_nest: \"fref P1 R1 (fref P2 R2 S) \n    \\<equiv> CURRY (fref (\\<lambda>(a,b). P1 a \\<and> P2 b) (R1\\<times>\\<^sub>rR2) S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [P1]\\<^sub>f R1 \\<rightarrow> [P2]\\<^sub>f R2 \\<rightarrow> S \\<equiv>\n    CURRY\n     ([\\<lambda>(a, b).\n          P1 a \\<and> P2 b]\\<^sub>f R1 \\<times>\\<^sub>r R2 \\<rightarrow> S)", "apply (rule eq_reflection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [P1]\\<^sub>f R1 \\<rightarrow> [P2]\\<^sub>f R2 \\<rightarrow> S =\n    CURRY\n     ([\\<lambda>(a, b).\n          P1 a \\<and> P2 b]\\<^sub>f R1 \\<times>\\<^sub>r R2 \\<rightarrow> S)", "by (auto simp: fref_def CURRY_def)"], ["", "lemma in_CURRY_conv: \"(f,g) \\<in> CURRY R \\<longleftrightarrow> (uncurry f, uncurry g) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((f, g) \\<in> CURRY R) = ((uncurry f, uncurry g) \\<in> R)", "unfolding CURRY_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((f, g) \\<in> {(f, g). (uncurry f, uncurry g) \\<in> R}) =\n    ((uncurry f, uncurry g) \\<in> R)", "by auto"], ["", "lemma uncurry0_APP[simp]: \"uncurry0 c $ x = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uncurry0 c $ x = c", "by auto"], ["", "lemma fref_param0I: \"(c,a)\\<in>R \\<Longrightarrow> (uncurry0 c, uncurry0 a) \\<in> fref (\\<lambda>_. True) unit_rel R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c, a) \\<in> R \\<Longrightarrow>\n    (uncurry0 c, uncurry0 a) \\<in> unit_rel \\<rightarrow>\\<^sub>f R", "by (auto simp: fref_def)"], ["", "subsubsection \\<open>Composition\\<close>"], ["", "definition hr_comp :: \"('b \\<Rightarrow> 'c \\<Rightarrow> assn) \\<Rightarrow> ('b \\<times> 'a) set \\<Rightarrow> 'a \\<Rightarrow> 'c \\<Rightarrow> assn\"\n    \\<comment> \\<open>Compose refinement assertion with refinement relation\\<close>\n    where \"hr_comp R1 R2 a c \\<equiv> \\<exists>\\<^sub>Ab. R1 b c * \\<up>((b,a)\\<in>R2)\""], ["", "definition hrp_comp \n    :: \"('d \\<Rightarrow> 'b \\<Rightarrow> assn) \\<times> ('d \\<Rightarrow> 'c \\<Rightarrow> assn)\n        \\<Rightarrow> ('d \\<times> 'a) set \\<Rightarrow> ('a \\<Rightarrow> 'b \\<Rightarrow> assn) \\<times> ('a \\<Rightarrow> 'c \\<Rightarrow> assn)\"\n    \\<comment> \\<open>Compose argument assertion-pair with refinement relation\\<close>    \n    where \"hrp_comp RR' S \\<equiv> (hr_comp (fst RR') S, hr_comp (snd RR') S) \""], ["", "lemma hr_compI: \"(b,a)\\<in>R2 \\<Longrightarrow> R1 b c \\<Longrightarrow>\\<^sub>A hr_comp R1 R2 a c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b, a) \\<in> R2 \\<Longrightarrow>\n    R1 b c \\<Longrightarrow>\\<^sub>A hr_comp R1 R2 a c", "unfolding hr_comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (b, a) \\<in> R2 \\<Longrightarrow>\n    R1 b c \\<Longrightarrow>\\<^sub>A\n    \\<exists>\\<^sub>Ab. R1 b c * \\<up> ((b, a) \\<in> R2)", "by sep_auto"], ["", "lemma hr_comp_Id1[simp]: \"hr_comp (pure Id) R = pure R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hr_comp id_assn R = pure R", "unfolding hr_comp_def[abs_def] pure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a c.\n        \\<exists>\\<^sub>Ab.\n           \\<up> ((c, b) \\<in> Id) * \\<up> ((b, a) \\<in> R)) =\n    (\\<lambda>a c. \\<up> ((c, a) \\<in> R))", "apply (intro ext ent_iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a c.\n       \\<exists>\\<^sub>Ab.\n          \\<up> ((c, b) \\<in> Id) *\n          \\<up> ((b, a) \\<in> R) \\<Longrightarrow>\\<^sub>A\n       \\<up> ((c, a) \\<in> R)\n 2. \\<And>a c.\n       \\<up> ((c, a) \\<in> R) \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Ab. \\<up> ((c, b) \\<in> Id) * \\<up> ((b, a) \\<in> R)", "by sep_auto+"], ["", "lemma hr_comp_Id2[simp]: \"hr_comp R Id = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hr_comp R Id = R", "unfolding hr_comp_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a c. \\<exists>\\<^sub>Ab. R b c * \\<up> ((b, a) \\<in> Id)) = R", "apply (intro ext ent_iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a c.\n       \\<exists>\\<^sub>Ab.\n          R b c * \\<up> ((b, a) \\<in> Id) \\<Longrightarrow>\\<^sub>A\n       R a c\n 2. \\<And>a c.\n       R a c \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Ab. R b c * \\<up> ((b, a) \\<in> Id)", "by sep_auto+"], ["", "(*lemma hr_comp_invalid[simp]: \"hr_comp (\\<lambda>a c. true) R a c = true * \\<up>(\\<exists>b. (b,a)\\<in>R)\"\n    unfolding hr_comp_def[abs_def]\n    apply (intro ext ent_iffI)\n    apply sep_auto+\n    done*)"], ["", "lemma hr_comp_emp[simp]: \"hr_comp (\\<lambda>a c. emp) R a c = \\<up>(\\<exists>b. (b,a)\\<in>R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hr_comp (\\<lambda>a c. emp) R a c = \\<up> (\\<exists>b. (b, a) \\<in> R)", "unfolding hr_comp_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>Ab. emp * \\<up> ((b, a) \\<in> R)) =\n    \\<up> (\\<exists>b. (b, a) \\<in> R)", "apply (intro ext ent_iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>\\<^sub>Ab.\n       emp * \\<up> ((b, a) \\<in> R) \\<Longrightarrow>\\<^sub>A\n    \\<up> (\\<exists>b. (b, a) \\<in> R)\n 2. \\<up> (\\<exists>b. (b, a) \\<in> R) \\<Longrightarrow>\\<^sub>A\n    \\<exists>\\<^sub>Ab. emp * \\<up> ((b, a) \\<in> R)", "apply sep_auto+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hr_comp_prod_conv[simp]:\n    \"hr_comp (prod_assn Ra Rb) (Ra' \\<times>\\<^sub>r Rb') \n    = prod_assn (hr_comp Ra Ra') (hr_comp Rb Rb')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hr_comp (Ra \\<times>\\<^sub>a Rb) (Ra' \\<times>\\<^sub>r Rb') =\n    hr_comp Ra Ra' \\<times>\\<^sub>a hr_comp Rb Rb'", "unfolding hr_comp_def[abs_def] prod_assn_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a c.\n        \\<exists>\\<^sub>Ab.\n           (case (b, c) of\n            ((a1, a2), c1, c2) \\<Rightarrow> Ra a1 c1 * Rb a2 c2) *\n           \\<up> ((b, a) \\<in> Ra' \\<times>\\<^sub>r Rb')) =\n    (\\<lambda>a c.\n        case (a, c) of\n        ((a1, a2), c1, c2) \\<Rightarrow>\n          (\\<exists>\\<^sub>Ab. Ra b c1 * \\<up> ((b, a1) \\<in> Ra')) *\n          (\\<exists>\\<^sub>Ab. Rb b c2 * \\<up> ((b, a2) \\<in> Rb')))", "apply (intro ext ent_iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a c.\n       \\<exists>\\<^sub>Ab.\n          (case (b, c) of\n           ((a1, a2), c1, c2) \\<Rightarrow> Ra a1 c1 * Rb a2 c2) *\n          \\<up>\n           ((b, a) \\<in> Ra' \\<times>\\<^sub>r Rb') \\<Longrightarrow>\\<^sub>A\n       (case (a, c) of\n        ((a1, a2), c1, c2) \\<Rightarrow>\n          (\\<exists>\\<^sub>Ab. Ra b c1 * \\<up> ((b, a1) \\<in> Ra')) *\n          (\\<exists>\\<^sub>Ab. Rb b c2 * \\<up> ((b, a2) \\<in> Rb')))\n 2. \\<And>a c.\n       (case (a, c) of\n        ((a1, a2), c1, c2) \\<Rightarrow>\n          (\\<exists>\\<^sub>Ab. Ra b c1 * \\<up> ((b, a1) \\<in> Ra')) *\n          (\\<exists>\\<^sub>Ab.\n              Rb b c2 *\n              \\<up> ((b, a2) \\<in> Rb'))) \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Ab.\n          (case (b, c) of\n           ((a1, a2), c1, c2) \\<Rightarrow> Ra a1 c1 * Rb a2 c2) *\n          \\<up> ((b, a) \\<in> Ra' \\<times>\\<^sub>r Rb')", "apply solve_entails"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a c b.\n       (b, a) \\<in> Ra' \\<times>\\<^sub>r Rb' \\<Longrightarrow>\n       (case b of\n        (a1, a2) \\<Rightarrow>\n          case c of\n          (c1, c2) \\<Rightarrow>\n            Ra a1 c1 * Rb a2 c2) \\<Longrightarrow>\\<^sub>A\n       (case a of\n        (a1, a2) \\<Rightarrow>\n          case c of\n          (c1, c2) \\<Rightarrow>\n            \\<exists>\\<^sub>Ab ba.\n               Ra ba c1 * \\<up> ((ba, a1) \\<in> Ra') * Rb b c2 *\n               \\<up> ((b, a2) \\<in> Rb'))\n 2. \\<And>a c.\n       (case (a, c) of\n        ((a1, a2), c1, c2) \\<Rightarrow>\n          (\\<exists>\\<^sub>Ab. Ra b c1 * \\<up> ((b, a1) \\<in> Ra')) *\n          (\\<exists>\\<^sub>Ab.\n              Rb b c2 *\n              \\<up> ((b, a2) \\<in> Rb'))) \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Ab.\n          (case (b, c) of\n           ((a1, a2), c1, c2) \\<Rightarrow> Ra a1 c1 * Rb a2 c2) *\n          \\<up> ((b, a) \\<in> Ra' \\<times>\\<^sub>r Rb')", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>(ab, a) \\<in> Ra'; (bb, b) \\<in> Rb'\\<rbrakk>\n       \\<Longrightarrow> Ra ab aa * Rb bb ba \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Abb bc.\n                            Ra bc aa * Rb bb ba *\n                            \\<up>\n                             ((bc, a) \\<in> Ra' \\<and> (bb, b) \\<in> Rb')\n 2. \\<And>a c.\n       (case (a, c) of\n        ((a1, a2), c1, c2) \\<Rightarrow>\n          (\\<exists>\\<^sub>Ab. Ra b c1 * \\<up> ((b, a1) \\<in> Ra')) *\n          (\\<exists>\\<^sub>Ab.\n              Rb b c2 *\n              \\<up> ((b, a2) \\<in> Rb'))) \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Ab.\n          (case (b, c) of\n           ((a1, a2), c1, c2) \\<Rightarrow> Ra a1 c1 * Rb a2 c2) *\n          \\<up> ((b, a) \\<in> Ra' \\<times>\\<^sub>r Rb')", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a c.\n       (case (a, c) of\n        ((a1, a2), c1, c2) \\<Rightarrow>\n          (\\<exists>\\<^sub>Ab. Ra b c1 * \\<up> ((b, a1) \\<in> Ra')) *\n          (\\<exists>\\<^sub>Ab.\n              Rb b c2 *\n              \\<up> ((b, a2) \\<in> Rb'))) \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Ab.\n          (case (b, c) of\n           ((a1, a2), c1, c2) \\<Rightarrow> Ra a1 c1 * Rb a2 c2) *\n          \\<up> ((b, a) \\<in> Ra' \\<times>\\<^sub>r Rb')", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<exists>\\<^sub>Abaa baaa.\n          Ra baaa aa * Rb baa ba *\n          \\<up>\n           ((baaa, a) \\<in> Ra' \\<and>\n            (baa, b) \\<in> Rb') \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Abaa.\n          (case baa of (a1, a2) \\<Rightarrow> Ra a1 aa * Rb a2 ba) *\n          \\<up> ((baa, a, b) \\<in> Ra' \\<times>\\<^sub>r Rb')", "apply (intro ent_ex_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba bb bc.\n       Ra bc aa * Rb bb ba *\n       \\<up>\n        ((bc, a) \\<in> Ra' \\<and>\n         (bb, b) \\<in> Rb') \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Abaa.\n          (case baa of (a1, a2) \\<Rightarrow> Ra a1 aa * Rb a2 ba) *\n          \\<up> ((baa, a, b) \\<in> Ra' \\<times>\\<^sub>r Rb')", "apply (rule ent_ex_postI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba bb bc.\n       Ra bc aa * Rb bb ba *\n       \\<up>\n        ((bc, a) \\<in> Ra' \\<and>\n         (bb, b) \\<in> Rb') \\<Longrightarrow>\\<^sub>A\n       (case ?b23 a b aa ba bb bc of\n        (a1, a2) \\<Rightarrow> Ra a1 aa * Rb a2 ba) *\n       \\<up> ((?b23 a b aa ba bb bc, a, b) \\<in> Ra' \\<times>\\<^sub>r Rb')", "apply (sep_auto split: prod.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hr_comp_pure: \"hr_comp (pure R) S = pure (R O S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hr_comp (pure R) S = pure (R O S)", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa. hr_comp (pure R) S x xa = pure (R O S) x xa", "apply (rule ent_iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       hr_comp (pure R) S x xa \\<Longrightarrow>\\<^sub>A pure (R O S) x xa\n 2. \\<And>x xa.\n       pure (R O S) x xa \\<Longrightarrow>\\<^sub>A hr_comp (pure R) S x xa", "unfolding hr_comp_def[abs_def]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<exists>\\<^sub>Ab.\n          pure R b xa * \\<up> ((b, x) \\<in> S) \\<Longrightarrow>\\<^sub>A\n       pure (R O S) x xa\n 2. \\<And>x xa.\n       pure (R O S) x xa \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Ab. pure R b xa * \\<up> ((b, x) \\<in> S)", "apply (sep_auto simp: pure_def)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hr_comp_is_pure[safe_constraint_rules]: \"is_pure A \\<Longrightarrow> is_pure (hr_comp A B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure A \\<Longrightarrow> is_pure (hr_comp A B)", "by (auto simp: hr_comp_pure is_pure_conv)"], ["", "lemma hr_comp_the_pure: \"is_pure A \\<Longrightarrow> the_pure (hr_comp A B) = the_pure A O B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_pure A \\<Longrightarrow> the_pure (hr_comp A B) = the_pure A O B", "unfolding is_pure_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>R'. A = pure R' \\<Longrightarrow>\n    the_pure (hr_comp A B) = the_pure A O B", "by (clarsimp simp: hr_comp_pure)"], ["", "lemma rdomp_hrcomp_conv: \"rdomp (hr_comp A R) x \\<longleftrightarrow> (\\<exists>y. rdomp A y \\<and> (y,x)\\<in>R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdomp (hr_comp A R) x = (\\<exists>y. rdomp A y \\<and> (y, x) \\<in> R)", "by (auto simp: rdomp_def hr_comp_def)"], ["", "lemma hn_rel_compI: \n    \"\\<lbrakk>nofail a; (b,a)\\<in>\\<langle>R2\\<rangle>nres_rel\\<rbrakk> \\<Longrightarrow> hn_rel R1 b c \\<Longrightarrow>\\<^sub>A hn_rel (hr_comp R1 R2) a c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail a; (b, a) \\<in> \\<langle>R2\\<rangle>nres_rel\\<rbrakk>\n    \\<Longrightarrow> hn_rel R1 b c \\<Longrightarrow>\\<^sub>A\n                      hn_rel (hr_comp R1 R2) a c", "unfolding hr_comp_def hn_rel_def nres_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail a; (b, a) \\<in> {(c, a). c \\<le> \\<Down> R2 a}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<^sub>Ax.\n                         R1 x c *\n                         \\<up> (RETURN x \\<le> b) \\<Longrightarrow>\\<^sub>A\n                      \\<exists>\\<^sub>Ax.\n                         (\\<exists>\\<^sub>Ab.\n                             R1 b c * \\<up> ((b, x) \\<in> R2)) *\n                         \\<up> (RETURN x \\<le> a)", "apply (clarsimp intro!: ent_ex_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>nofail a; b \\<le> \\<Down> R2 a; RETURN x \\<le> b\\<rbrakk>\n       \\<Longrightarrow> R1 x c \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Ax b.\n                            R1 b c *\n                            \\<up> ((b, x) \\<in> R2 \\<and> RETURN x \\<le> a)", "apply (drule (1) order_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>nofail a; b \\<le> \\<Down> R2 a;\n        RETURN x \\<le> \\<Down> R2 a\\<rbrakk>\n       \\<Longrightarrow> R1 x c \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Ax b.\n                            R1 b c *\n                            \\<up> ((b, x) \\<in> R2 \\<and> RETURN x \\<le> a)", "apply (simp add: ret_le_down_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>nofail a; b \\<le> \\<Down> R2 a;\n        \\<exists>aa. (x, aa) \\<in> R2 \\<and> RETURN aa \\<le> a\\<rbrakk>\n       \\<Longrightarrow> R1 x c \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Ax b.\n                            R1 b c *\n                            \\<up> ((b, x) \\<in> R2 \\<and> RETURN x \\<le> a)", "by sep_auto"], ["", "lemma hr_comp_precise[constraint_rules]:\n    assumes [safe_constraint_rules]: \"precise R\"\n    assumes SV: \"single_valued S\"\n    shows \"precise (hr_comp R S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. precise (hr_comp R S)", "apply (rule preciseI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       hr_comp R S a p * F \\<and>\\<^sub>A\n       hr_comp R S a' p * F' \\<Longrightarrow>\n       a = a'", "unfolding hr_comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' h p F F'.\n       h \\<Turnstile>\n       (\\<exists>\\<^sub>Ab. R b p * \\<up> ((b, a) \\<in> S)) *\n       F \\<and>\\<^sub>A\n       (\\<exists>\\<^sub>Ab. R b p * \\<up> ((b, a') \\<in> S)) *\n       F' \\<Longrightarrow>\n       a = a'", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa b p F F' ba bb.\n       \\<lbrakk>(aa, b) \\<Turnstile> R bb p * F \\<and>\\<^sub>A R ba p * F';\n        (bb, a) \\<in> S; (ba, a') \\<in> S\\<rbrakk>\n       \\<Longrightarrow> a = a'", "by (metis SV assms(1) preciseD single_valuedD)"], ["", "lemma hr_comp_assoc: \"hr_comp (hr_comp R S) T = hr_comp R (S O T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hr_comp (hr_comp R S) T = hr_comp R (S O T)", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa. hr_comp (hr_comp R S) T x xa = hr_comp R (S O T) x xa", "unfolding hr_comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (\\<exists>\\<^sub>Ab.\n           (\\<exists>\\<^sub>Aba. R ba xa * \\<up> ((ba, b) \\<in> S)) *\n           \\<up> ((b, x) \\<in> T)) =\n       (\\<exists>\\<^sub>Ab. R b xa * \\<up> ((b, x) \\<in> S O T))", "apply (rule ent_iffI; clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<exists>\\<^sub>Ab ba.\n          R ba xa *\n          \\<up>\n           ((ba, b) \\<in> S \\<and> (b, x) \\<in> T) \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Ab. R b xa * \\<up> ((b, x) \\<in> S O T)\n 2. \\<And>x xa.\n       \\<exists>\\<^sub>Ab.\n          R b xa * \\<up> ((b, x) \\<in> S O T) \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Ab ba.\n          R ba xa * \\<up> ((ba, b) \\<in> S \\<and> (b, x) \\<in> T)", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<exists>\\<^sub>Ab.\n          R b xa * \\<up> ((b, x) \\<in> S O T) \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Ab ba.\n          R ba xa * \\<up> ((ba, b) \\<in> S \\<and> (b, x) \\<in> T)", "apply (rule ent_ex_preI; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb y z.\n       \\<lbrakk>(xb, y) \\<in> S; (y, z) \\<in> T\\<rbrakk>\n       \\<Longrightarrow> R xb xa \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Ab ba.\n                            R ba xa *\n                            \\<up> ((ba, b) \\<in> S \\<and> (b, z) \\<in> T)", "(* TODO: \n      sep_auto/solve_entails is too eager splitting the subgoal here! *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb y z.\n       \\<lbrakk>(xb, y) \\<in> S; (y, z) \\<in> T\\<rbrakk>\n       \\<Longrightarrow> R xb xa \\<Longrightarrow>\\<^sub>A\n                         \\<exists>\\<^sub>Ab ba.\n                            R ba xa *\n                            \\<up> ((ba, b) \\<in> S \\<and> (b, z) \\<in> T)", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hnr_comp:\n    assumes R: \"\\<And>b1 c1. P b1 \\<Longrightarrow> hn_refine (R1 b1 c1 * \\<Gamma>) (c c1) (R1p b1 c1 * \\<Gamma>') R (b b1)\"\n    assumes S: \"\\<And>a1 b1. \\<lbrakk>Q a1; (b1,a1)\\<in>R1'\\<rbrakk> \\<Longrightarrow> (b b1,a a1)\\<in>\\<langle>R'\\<rangle>nres_rel\"\n    assumes PQ: \"\\<And>a1 b1. \\<lbrakk>Q a1; (b1,a1)\\<in>R1'\\<rbrakk> \\<Longrightarrow> P b1\"\n    assumes Q: \"Q a1\"\n    shows \"hn_refine \n      (hr_comp R1 R1' a1 c1 * \\<Gamma>) \n      (c c1)\n      (hr_comp R1p R1' a1 c1 * \\<Gamma>') \n      (hr_comp R R') \n      (a a1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hr_comp R1 R1' a1 c1 * \\<Gamma>) (c c1)\n     (hr_comp R1p R1' a1 c1 * \\<Gamma>') (hr_comp R R') (a a1)", "unfolding hn_refine_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (a a1) \\<longrightarrow>\n    <hr_comp R1 R1' a1 c1 *\n     \\<Gamma>> c c1 <\\<lambda>r.\n                        hn_rel (hr_comp R R') (a a1) r *\n                        (hr_comp R1p R1' a1 c1 * \\<Gamma>')>\\<^sub>t", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. nofail (a a1) \\<Longrightarrow>\n    <hr_comp R1 R1' a1 c1 *\n     \\<Gamma>> c c1 <\\<lambda>r.\n                        hn_rel (hr_comp R R') (a a1) r *\n                        (hr_comp R1p R1' a1 c1 * \\<Gamma>')>\\<^sub>t", "assume NF: \"nofail (a a1)\""], ["proof (state)\nthis:\n  nofail (a a1)\n\ngoal (1 subgoal):\n 1. nofail (a a1) \\<Longrightarrow>\n    <hr_comp R1 R1' a1 c1 *\n     \\<Gamma>> c c1 <\\<lambda>r.\n                        hn_rel (hr_comp R R') (a a1) r *\n                        (hr_comp R1p R1' a1 c1 * \\<Gamma>')>\\<^sub>t", "show \"\n      <hr_comp R1 R1' a1 c1 * \\<Gamma>> \n        c c1 \n      <\\<lambda>r. hn_rel (hr_comp R R') (a a1) r * (hr_comp R1p R1' a1 c1 * \\<Gamma>')>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <hr_comp R1 R1' a1 c1 *\n     \\<Gamma>> c c1 <\\<lambda>r.\n                        hn_rel (hr_comp R R') (a a1) r *\n                        (hr_comp R1p R1' a1 c1 * \\<Gamma>')>\\<^sub>t", "apply (subst hr_comp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. <(\\<exists>\\<^sub>Ab. R1 b c1 * \\<up> ((b, a1) \\<in> R1')) *\n     \\<Gamma>> c c1 <\\<lambda>r.\n                        hn_rel (hr_comp R R') (a a1) r *\n                        (hr_comp R1p R1' a1 c1 * \\<Gamma>')>\\<^sub>t", "apply (clarsimp intro!: norm_pre_ex_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       (b, a1) \\<in> R1' \\<Longrightarrow>\n       <R1 b c1 *\n        \\<Gamma>> c c1 <\\<lambda>r.\n                           hn_rel (hr_comp R R') (a a1) r *\n                           (hr_comp R1p R1' a1 c1 * \\<Gamma>')>\\<^sub>t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       (b, a1) \\<in> R1' \\<Longrightarrow>\n       <R1 b c1 *\n        \\<Gamma>> c c1 <\\<lambda>r.\n                           hn_rel (hr_comp R R') (a a1) r *\n                           (hr_comp R1p R1' a1 c1 * \\<Gamma>')>\\<^sub>t", "fix b1"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       (b, a1) \\<in> R1' \\<Longrightarrow>\n       <R1 b c1 *\n        \\<Gamma>> c c1 <\\<lambda>r.\n                           hn_rel (hr_comp R R') (a a1) r *\n                           (hr_comp R1p R1' a1 c1 * \\<Gamma>')>\\<^sub>t", "assume R1: \"(b1, a1) \\<in> R1'\""], ["proof (state)\nthis:\n  (b1, a1) \\<in> R1'\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       (b, a1) \\<in> R1' \\<Longrightarrow>\n       <R1 b c1 *\n        \\<Gamma>> c c1 <\\<lambda>r.\n                           hn_rel (hr_comp R R') (a a1) r *\n                           (hr_comp R1p R1' a1 c1 * \\<Gamma>')>\\<^sub>t", "from S R1 Q"], ["proof (chain)\npicking this:\n  \\<lbrakk>Q ?a1.0; (?b1.0, ?a1.0) \\<in> R1'\\<rbrakk>\n  \\<Longrightarrow> (b ?b1.0, a ?a1.0) \\<in> \\<langle>R'\\<rangle>nres_rel\n  (b1, a1) \\<in> R1'\n  Q a1", "have R': \"(b b1, a a1) \\<in> \\<langle>R'\\<rangle>nres_rel\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Q ?a1.0; (?b1.0, ?a1.0) \\<in> R1'\\<rbrakk>\n  \\<Longrightarrow> (b ?b1.0, a ?a1.0) \\<in> \\<langle>R'\\<rangle>nres_rel\n  (b1, a1) \\<in> R1'\n  Q a1\n\ngoal (1 subgoal):\n 1. (b b1, a a1) \\<in> \\<langle>R'\\<rangle>nres_rel", "by blast"], ["proof (state)\nthis:\n  (b b1, a a1) \\<in> \\<langle>R'\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       (b, a1) \\<in> R1' \\<Longrightarrow>\n       <R1 b c1 *\n        \\<Gamma>> c c1 <\\<lambda>r.\n                           hn_rel (hr_comp R R') (a a1) r *\n                           (hr_comp R1p R1' a1 c1 * \\<Gamma>')>\\<^sub>t", "with NF"], ["proof (chain)\npicking this:\n  nofail (a a1)\n  (b b1, a a1) \\<in> \\<langle>R'\\<rangle>nres_rel", "have NFB: \"nofail (b b1)\""], ["proof (prove)\nusing this:\n  nofail (a a1)\n  (b b1, a a1) \\<in> \\<langle>R'\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. nofail (b b1)", "by (simp add: nres_rel_def pw_le_iff refine_pw_simps)"], ["proof (state)\nthis:\n  nofail (b b1)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       (b, a1) \\<in> R1' \\<Longrightarrow>\n       <R1 b c1 *\n        \\<Gamma>> c c1 <\\<lambda>r.\n                           hn_rel (hr_comp R R') (a a1) r *\n                           (hr_comp R1p R1' a1 c1 * \\<Gamma>')>\\<^sub>t", "from PQ R1 Q"], ["proof (chain)\npicking this:\n  \\<lbrakk>Q ?a1.0; (?b1.0, ?a1.0) \\<in> R1'\\<rbrakk>\n  \\<Longrightarrow> P ?b1.0\n  (b1, a1) \\<in> R1'\n  Q a1", "have P: \"P b1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Q ?a1.0; (?b1.0, ?a1.0) \\<in> R1'\\<rbrakk>\n  \\<Longrightarrow> P ?b1.0\n  (b1, a1) \\<in> R1'\n  Q a1\n\ngoal (1 subgoal):\n 1. P b1", "by blast"], ["proof (state)\nthis:\n  P b1\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       (b, a1) \\<in> R1' \\<Longrightarrow>\n       <R1 b c1 *\n        \\<Gamma>> c c1 <\\<lambda>r.\n                           hn_rel (hr_comp R R') (a a1) r *\n                           (hr_comp R1p R1' a1 c1 * \\<Gamma>')>\\<^sub>t", "with NFB R"], ["proof (chain)\npicking this:\n  nofail (b b1)\n  P ?b1.0 \\<Longrightarrow>\n  hn_refine (R1 ?b1.0 ?c1.0 * \\<Gamma>) (c ?c1.0)\n   (R1p ?b1.0 ?c1.0 * \\<Gamma>') R (b ?b1.0)\n  P b1", "have \"<R1 b1 c1 * \\<Gamma>> c c1 <\\<lambda>r. hn_rel R (b b1) r * (R1p b1 c1 * \\<Gamma>')>\\<^sub>t\""], ["proof (prove)\nusing this:\n  nofail (b b1)\n  P ?b1.0 \\<Longrightarrow>\n  hn_refine (R1 ?b1.0 ?c1.0 * \\<Gamma>) (c ?c1.0)\n   (R1p ?b1.0 ?c1.0 * \\<Gamma>') R (b ?b1.0)\n  P b1\n\ngoal (1 subgoal):\n 1. <R1 b1 c1 *\n     \\<Gamma>> c c1 <\\<lambda>r.\n                        hn_rel R (b b1) r * (R1p b1 c1 * \\<Gamma>')>\\<^sub>t", "unfolding hn_refine_alt"], ["proof (prove)\nusing this:\n  nofail (b b1)\n  P ?b1.0 \\<Longrightarrow>\n  nofail (b ?b1.0) \\<longrightarrow>\n  <R1 ?b1.0 ?c1.0 *\n   \\<Gamma>> c ?c1.0 <\\<lambda>r.\n                         hn_rel R (b ?b1.0) r *\n                         (R1p ?b1.0 ?c1.0 * \\<Gamma>')>\\<^sub>t\n  P b1\n\ngoal (1 subgoal):\n 1. <R1 b1 c1 *\n     \\<Gamma>> c c1 <\\<lambda>r.\n                        hn_rel R (b b1) r * (R1p b1 c1 * \\<Gamma>')>\\<^sub>t", "by auto"], ["proof (state)\nthis:\n  <R1 b1 c1 *\n   \\<Gamma>> c c1 <\\<lambda>r.\n                      hn_rel R (b b1) r * (R1p b1 c1 * \\<Gamma>')>\\<^sub>t\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       (b, a1) \\<in> R1' \\<Longrightarrow>\n       <R1 b c1 *\n        \\<Gamma>> c c1 <\\<lambda>r.\n                           hn_rel (hr_comp R R') (a a1) r *\n                           (hr_comp R1p R1' a1 c1 * \\<Gamma>')>\\<^sub>t", "thus \"<R1 b1 c1 * \\<Gamma>> \n        c c1 \n        <\\<lambda>r. hn_rel (hr_comp R R') (a a1) r * (hr_comp R1p R1' a1 c1 * \\<Gamma>')>\\<^sub>t\""], ["proof (prove)\nusing this:\n  <R1 b1 c1 *\n   \\<Gamma>> c c1 <\\<lambda>r.\n                      hn_rel R (b b1) r * (R1p b1 c1 * \\<Gamma>')>\\<^sub>t\n\ngoal (1 subgoal):\n 1. <R1 b1 c1 *\n     \\<Gamma>> c c1 <\\<lambda>r.\n                        hn_rel (hr_comp R R') (a a1) r *\n                        (hr_comp R1p R1' a1 c1 * \\<Gamma>')>\\<^sub>t", "apply (rule cons_post_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       hn_rel R (b b1) x * (R1p b1 c1 * \\<Gamma>') *\n       true \\<Longrightarrow>\\<^sub>A\n       hn_rel (hr_comp R R') (a a1) x *\n       (hr_comp R1p R1' a1 c1 * \\<Gamma>') *\n       true", "apply (solve_entails)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       hn_rel R (b b1) x * R1p b1 c1 * \\<Gamma>' *\n       true \\<Longrightarrow>\\<^sub>A\n       hn_rel (hr_comp R R') (a a1) x * hr_comp R1p R1' a1 c1 * \\<Gamma>' *\n       true", "by (intro ent_star_mono hn_rel_compI[OF NF R'] hr_compI[OF R1] ent_refl)"], ["proof (state)\nthis:\n  <R1 b1 c1 *\n   \\<Gamma>> c c1 <\\<lambda>r.\n                      hn_rel (hr_comp R R') (a a1) r *\n                      (hr_comp R1p R1' a1 c1 * \\<Gamma>')>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  <hr_comp R1 R1' a1 c1 *\n   \\<Gamma>> c c1 <\\<lambda>r.\n                      hn_rel (hr_comp R R') (a a1) r *\n                      (hr_comp R1p R1' a1 c1 * \\<Gamma>')>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hnr_comp1_aux:\n    assumes R: \"\\<And>b1 c1. P b1 \\<Longrightarrow> hn_refine (hn_ctxt R1 b1 c1) (c c1) (hn_ctxt R1p b1 c1) R (b$b1)\"\n    assumes S: \"\\<And>a1 b1. \\<lbrakk>Q a1; (b1,a1)\\<in>R1'\\<rbrakk> \\<Longrightarrow> (b$b1,a$a1)\\<in>\\<langle>R'\\<rangle>nres_rel\"\n    assumes PQ: \"\\<And>a1 b1. \\<lbrakk>Q a1; (b1,a1)\\<in>R1'\\<rbrakk> \\<Longrightarrow> P b1\"\n    assumes Q: \"Q a1\"\n    shows \"hn_refine \n      (hr_comp R1 R1' a1 c1) \n      (c c1)\n      (hr_comp R1p R1' a1 c1) \n      (hr_comp R R') \n      (a a1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hr_comp R1 R1' a1 c1) (c c1) (hr_comp R1p R1' a1 c1)\n     (hr_comp R R') (a a1)", "using assms hnr_comp[where \\<Gamma>=emp and \\<Gamma>'=emp and a=a and b=b and c=c and P=P and Q=Q]"], ["proof (prove)\nusing this:\n  P ?b1.0 \\<Longrightarrow>\n  hn_refine (hn_ctxt R1 ?b1.0 ?c1.0) (c ?c1.0) (hn_ctxt R1p ?b1.0 ?c1.0) R\n   (b $ ?b1.0)\n  \\<lbrakk>Q ?a1.0; (?b1.0, ?a1.0) \\<in> R1'\\<rbrakk>\n  \\<Longrightarrow> (b $ ?b1.0, a $ ?a1.0)\n                    \\<in> \\<langle>R'\\<rangle>nres_rel\n  \\<lbrakk>Q ?a1.0; (?b1.0, ?a1.0) \\<in> R1'\\<rbrakk>\n  \\<Longrightarrow> P ?b1.0\n  Q a1\n  \\<lbrakk>\\<And>b1 c1.\n              P b1 \\<Longrightarrow>\n              hn_refine (?R1.0 b1 c1 * emp) (c c1) (?R1p b1 c1 * emp) ?R\n               (b b1);\n   \\<And>a1 b1.\n      \\<lbrakk>Q a1; (b1, a1) \\<in> ?R1'\\<rbrakk>\n      \\<Longrightarrow> (b b1, a a1) \\<in> \\<langle>?R'\\<rangle>nres_rel;\n   \\<And>a1 b1.\n      \\<lbrakk>Q a1; (b1, a1) \\<in> ?R1'\\<rbrakk> \\<Longrightarrow> P b1;\n   Q ?a1.0\\<rbrakk>\n  \\<Longrightarrow> hn_refine (hr_comp ?R1.0 ?R1' ?a1.0 ?c1.0 * emp)\n                     (c ?c1.0) (hr_comp ?R1p ?R1' ?a1.0 ?c1.0 * emp)\n                     (hr_comp ?R ?R') (a ?a1.0)\n\ngoal (1 subgoal):\n 1. hn_refine (hr_comp R1 R1' a1 c1) (c c1) (hr_comp R1p R1' a1 c1)\n     (hr_comp R R') (a a1)", "unfolding hn_ctxt_def"], ["proof (prove)\nusing this:\n  P ?b1.0 \\<Longrightarrow>\n  hn_refine (R1 ?b1.0 ?c1.0) (c ?c1.0) (R1p ?b1.0 ?c1.0) R (b $ ?b1.0)\n  \\<lbrakk>Q ?a1.0; (?b1.0, ?a1.0) \\<in> R1'\\<rbrakk>\n  \\<Longrightarrow> (b $ ?b1.0, a $ ?a1.0)\n                    \\<in> \\<langle>R'\\<rangle>nres_rel\n  \\<lbrakk>Q ?a1.0; (?b1.0, ?a1.0) \\<in> R1'\\<rbrakk>\n  \\<Longrightarrow> P ?b1.0\n  Q a1\n  \\<lbrakk>\\<And>b1 c1.\n              P b1 \\<Longrightarrow>\n              hn_refine (?R1.0 b1 c1 * emp) (c c1) (?R1p b1 c1 * emp) ?R\n               (b b1);\n   \\<And>a1 b1.\n      \\<lbrakk>Q a1; (b1, a1) \\<in> ?R1'\\<rbrakk>\n      \\<Longrightarrow> (b b1, a a1) \\<in> \\<langle>?R'\\<rangle>nres_rel;\n   \\<And>a1 b1.\n      \\<lbrakk>Q a1; (b1, a1) \\<in> ?R1'\\<rbrakk> \\<Longrightarrow> P b1;\n   Q ?a1.0\\<rbrakk>\n  \\<Longrightarrow> hn_refine (hr_comp ?R1.0 ?R1' ?a1.0 ?c1.0 * emp)\n                     (c ?c1.0) (hr_comp ?R1p ?R1' ?a1.0 ?c1.0 * emp)\n                     (hr_comp ?R ?R') (a ?a1.0)\n\ngoal (1 subgoal):\n 1. hn_refine (hr_comp R1 R1' a1 c1) (c c1) (hr_comp R1p R1' a1 c1)\n     (hr_comp R R') (a a1)", "by auto"], ["", "lemma hfcomp:\n    assumes A: \"(f,g) \\<in> [P]\\<^sub>a RR' \\<rightarrow> S\"\n    assumes B: \"(g,h) \\<in> [Q]\\<^sub>f T \\<rightarrow> \\<langle>U\\<rangle>nres_rel\"\n    shows \"(f,h) \\<in> [\\<lambda>a. Q a \\<and> (\\<forall>a'. (a',a)\\<in>T \\<longrightarrow> P a')]\\<^sub>a \n      hrp_comp RR' T \\<rightarrow> hr_comp S U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, h)\n    \\<in> [\\<lambda>a.\n              Q a \\<and>\n              (\\<forall>a'.\n                  (a', a) \\<in> T \\<longrightarrow>\n                  P a')]\\<^sub>a hrp_comp RR' T \\<rightarrow> hr_comp S U", "using assms"], ["proof (prove)\nusing this:\n  (f, g) \\<in> [P]\\<^sub>a RR' \\<rightarrow> S\n  (g, h) \\<in> [Q]\\<^sub>f T \\<rightarrow> \\<langle>U\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (f, h)\n    \\<in> [\\<lambda>a.\n              Q a \\<and>\n              (\\<forall>a'.\n                  (a', a) \\<in> T \\<longrightarrow>\n                  P a')]\\<^sub>a hrp_comp RR' T \\<rightarrow> hr_comp S U", "unfolding fref_def hfref_def hrp_comp_def"], ["proof (prove)\nusing this:\n  (f, g)\n  \\<in> {(f, g).\n         \\<forall>c a.\n            P a \\<longrightarrow>\n            hn_refine (fst RR' a c) (f c) (snd RR' a c) S (g a)}\n  (g, h)\n  \\<in> {(f, g).\n         \\<forall>x y.\n            Q y \\<and> (x, y) \\<in> T \\<longrightarrow>\n            (f x, g y) \\<in> \\<langle>U\\<rangle>nres_rel}\n\ngoal (1 subgoal):\n 1. (f, h)\n    \\<in> {(f, g).\n           \\<forall>c a.\n              Q a \\<and>\n              (\\<forall>a'.\n                  (a', a) \\<in> T \\<longrightarrow> P a') \\<longrightarrow>\n              hn_refine (fst (hr_comp (fst RR') T, hr_comp (snd RR') T) a c)\n               (f c) (snd (hr_comp (fst RR') T, hr_comp (snd RR') T) a c)\n               (hr_comp S U) (g a)}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       \\<lbrakk>\\<forall>c a.\n                   P a \\<longrightarrow>\n                   hn_refine (fst RR' a c) (f c) (snd RR' a c) S (g a);\n        \\<forall>x y.\n           Q y \\<and> (x, y) \\<in> T \\<longrightarrow>\n           (g x, h y) \\<in> \\<langle>U\\<rangle>nres_rel;\n        Q a; \\<forall>a'. (a', a) \\<in> T \\<longrightarrow> P a'\\<rbrakk>\n       \\<Longrightarrow> hn_refine (hr_comp (fst RR') T a c) (f c)\n                          (hr_comp (snd RR') T a c) (hr_comp S U) (h a)", "apply (rule hnr_comp1_aux[of \n        P \"fst RR'\" f \"snd RR'\" S g \"\\<lambda>a. Q a \\<and> (\\<forall>a'. (a',a)\\<in>T \\<longrightarrow> P a')\" T h U])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>c a b1 c1.\n       \\<lbrakk>\\<forall>c a.\n                   P a \\<longrightarrow>\n                   hn_refine (fst RR' a c) (f c) (snd RR' a c) S (g a);\n        \\<forall>x y.\n           Q y \\<and> (x, y) \\<in> T \\<longrightarrow>\n           (g x, h y) \\<in> \\<langle>U\\<rangle>nres_rel;\n        Q a; \\<forall>a'. (a', a) \\<in> T \\<longrightarrow> P a';\n        P b1\\<rbrakk>\n       \\<Longrightarrow> hn_refine (hn_ctxt (fst RR') b1 c1) (f c1)\n                          (hn_ctxt (snd RR') b1 c1) S (g $ b1)\n 2. \\<And>c a a1 b1.\n       \\<lbrakk>\\<forall>c a.\n                   P a \\<longrightarrow>\n                   hn_refine (fst RR' a c) (f c) (snd RR' a c) S (g a);\n        \\<forall>x y.\n           Q y \\<and> (x, y) \\<in> T \\<longrightarrow>\n           (g x, h y) \\<in> \\<langle>U\\<rangle>nres_rel;\n        Q a; \\<forall>a'. (a', a) \\<in> T \\<longrightarrow> P a';\n        Q a1 \\<and> (\\<forall>a'. (a', a1) \\<in> T \\<longrightarrow> P a');\n        (b1, a1) \\<in> T\\<rbrakk>\n       \\<Longrightarrow> (g $ b1, h $ a1) \\<in> \\<langle>U\\<rangle>nres_rel\n 3. \\<And>c a a1 b1.\n       \\<lbrakk>\\<forall>c a.\n                   P a \\<longrightarrow>\n                   hn_refine (fst RR' a c) (f c) (snd RR' a c) S (g a);\n        \\<forall>x y.\n           Q y \\<and> (x, y) \\<in> T \\<longrightarrow>\n           (g x, h y) \\<in> \\<langle>U\\<rangle>nres_rel;\n        Q a; \\<forall>a'. (a', a) \\<in> T \\<longrightarrow> P a';\n        Q a1 \\<and> (\\<forall>a'. (a', a1) \\<in> T \\<longrightarrow> P a');\n        (b1, a1) \\<in> T\\<rbrakk>\n       \\<Longrightarrow> P b1\n 4. \\<And>c a.\n       \\<lbrakk>\\<forall>c a.\n                   P a \\<longrightarrow>\n                   hn_refine (fst RR' a c) (f c) (snd RR' a c) S (g a);\n        \\<forall>x y.\n           Q y \\<and> (x, y) \\<in> T \\<longrightarrow>\n           (g x, h y) \\<in> \\<langle>U\\<rangle>nres_rel;\n        Q a; \\<forall>a'. (a', a) \\<in> T \\<longrightarrow> P a'\\<rbrakk>\n       \\<Longrightarrow> Q a \\<and>\n                         (\\<forall>a'.\n                             (a', a) \\<in> T \\<longrightarrow> P a')", "apply (auto simp: hn_ctxt_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hfref_weaken_pre_nofail: \n    assumes \"(f,g) \\<in> [P]\\<^sub>a R \\<rightarrow> S\"  \n    shows \"(f,g) \\<in> [\\<lambda>x. nofail (g x) \\<longrightarrow> P x]\\<^sub>a R \\<rightarrow> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g)\n    \\<in> [\\<lambda>x.\n              nofail (g x) \\<longrightarrow> P x]\\<^sub>a R \\<rightarrow> S", "using assms"], ["proof (prove)\nusing this:\n  (f, g) \\<in> [P]\\<^sub>a R \\<rightarrow> S\n\ngoal (1 subgoal):\n 1. (f, g)\n    \\<in> [\\<lambda>x.\n              nofail (g x) \\<longrightarrow> P x]\\<^sub>a R \\<rightarrow> S", "unfolding hfref_def hn_refine_def"], ["proof (prove)\nusing this:\n  (f, g)\n  \\<in> {(f, g).\n         \\<forall>c a.\n            P a \\<longrightarrow>\n            nofail (g a) \\<longrightarrow>\n            <fst R a\n              c> f c <\\<lambda>r.\n                         snd R a c *\n                         (\\<exists>\\<^sub>Ax.\n                             S x r * \\<up> (RETURN x \\<le> g a))>\\<^sub>t}\n\ngoal (1 subgoal):\n 1. (f, g)\n    \\<in> {(f, ga).\n           \\<forall>c a.\n              (nofail (g a) \\<longrightarrow> P a) \\<longrightarrow>\n              nofail (ga a) \\<longrightarrow>\n              <fst R a\n                c> f c <\\<lambda>r.\n                           snd R a c *\n                           (\\<exists>\\<^sub>Ax.\n                               S x r *\n                               \\<up> (RETURN x \\<le> ga a))>\\<^sub>t}", "by auto"], ["", "lemma hfref_cons:\n    assumes \"(f,g) \\<in> [P]\\<^sub>a R \\<rightarrow> S\"\n    assumes \"\\<And>x. P' x \\<Longrightarrow> P x\"\n    assumes \"\\<And>x y. fst R' x y \\<Longrightarrow>\\<^sub>t fst R x y\"\n    assumes \"\\<And>x y. snd R x y \\<Longrightarrow>\\<^sub>t snd R' x y\"\n    assumes \"\\<And>x y. S x y \\<Longrightarrow>\\<^sub>t S' x y\"\n    shows \"(f,g) \\<in> [P']\\<^sub>a R' \\<rightarrow> S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g) \\<in> [P']\\<^sub>a R' \\<rightarrow> S'", "unfolding hfref_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g)\n    \\<in> {(f, g).\n           \\<forall>c a.\n              P' a \\<longrightarrow>\n              hn_refine (fst R' a c) (f c) (snd R' a c) S' (g a)}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       P' a \\<Longrightarrow>\n       hn_refine (fst R' a c) (f c) (snd R' a c) S' (g a)", "apply (rule hn_refine_cons)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>c a.\n       P' a \\<Longrightarrow> fst R' a c \\<Longrightarrow>\\<^sub>t ?P'3 c a\n 2. \\<And>c a.\n       P' a \\<Longrightarrow>\n       hn_refine (?P'3 c a) (f c) (?Q3 c a) (?R3 c a) (g a)\n 3. \\<And>c a.\n       P' a \\<Longrightarrow> ?Q3 c a \\<Longrightarrow>\\<^sub>t snd R' a c\n 4. \\<And>c a x y.\n       P' a \\<Longrightarrow> ?R3 c a x y \\<Longrightarrow>\\<^sub>t S' x y", "apply (rule assms(3))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c a.\n       P' a \\<Longrightarrow>\n       hn_refine (fst R a c) (f c) (?Q3 c a) (?R3 c a) (g a)\n 2. \\<And>c a.\n       P' a \\<Longrightarrow> ?Q3 c a \\<Longrightarrow>\\<^sub>t snd R' a c\n 3. \\<And>c a x y.\n       P' a \\<Longrightarrow> ?R3 c a x y \\<Longrightarrow>\\<^sub>t S' x y", "defer"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c a.\n       P' a \\<Longrightarrow> ?Q3 c a \\<Longrightarrow>\\<^sub>t snd R' a c\n 2. \\<And>c a x y.\n       P' a \\<Longrightarrow> ?R3 c a x y \\<Longrightarrow>\\<^sub>t S' x y\n 3. \\<And>c a.\n       P' a \\<Longrightarrow>\n       hn_refine (fst R a c) (f c) (?Q3 c a) (?R3 c a) (g a)", "apply (rule entt_trans[OF assms(4)]; sep_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c a x y.\n       P' a \\<Longrightarrow> ?R3 c a x y \\<Longrightarrow>\\<^sub>t S' x y\n 2. \\<And>c a.\n       P' a \\<Longrightarrow>\n       hn_refine (fst R a c) (f c) (snd R a c) (?R3 c a) (g a)", "apply (rule assms(5))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       P' a \\<Longrightarrow>\n       hn_refine (fst R a c) (f c) (snd R a c) S (g a)", "apply (frule assms(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       \\<lbrakk>P' a; P a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (fst R a c) (f c) (snd R a c) S (g a)", "using assms(1)"], ["proof (prove)\nusing this:\n  (f, g) \\<in> [P]\\<^sub>a R \\<rightarrow> S\n\ngoal (1 subgoal):\n 1. \\<And>c a.\n       \\<lbrakk>P' a; P a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (fst R a c) (f c) (snd R a c) S (g a)", "unfolding hfref_def"], ["proof (prove)\nusing this:\n  (f, g)\n  \\<in> {(f, g).\n         \\<forall>c a.\n            P a \\<longrightarrow>\n            hn_refine (fst R a c) (f c) (snd R a c) S (g a)}\n\ngoal (1 subgoal):\n 1. \\<And>c a.\n       \\<lbrakk>P' a; P a\\<rbrakk>\n       \\<Longrightarrow> hn_refine (fst R a c) (f c) (snd R a c) S (g a)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Composition Automation\\<close>"], ["", "text \\<open>This section contains the lemmas. The ML code is further down. \\<close>"], ["", "lemma prod_hrp_comp: \n    \"hrp_comp (A *\\<^sub>a B) (C \\<times>\\<^sub>r D) = hrp_comp A C *\\<^sub>a hrp_comp B D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hrp_comp (A *\\<^sub>a B) (C \\<times>\\<^sub>r D) =\n    hrp_comp A C *\\<^sub>a hrp_comp B D", "unfolding hrp_comp_def hfprod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (hr_comp\n      (fst (fst A \\<times>\\<^sub>a fst B, snd A \\<times>\\<^sub>a snd B))\n      (C \\<times>\\<^sub>r D),\n     hr_comp\n      (snd (fst A \\<times>\\<^sub>a fst B, snd A \\<times>\\<^sub>a snd B))\n      (C \\<times>\\<^sub>r D)) =\n    (fst (hr_comp (fst A) C, hr_comp (snd A) C) \\<times>\\<^sub>a\n     fst (hr_comp (fst B) D, hr_comp (snd B) D),\n     snd (hr_comp (fst A) C, hr_comp (snd A) C) \\<times>\\<^sub>a\n     snd (hr_comp (fst B) D, hr_comp (snd B) D))", "by simp"], ["", "lemma hrp_comp_keep: \"hrp_comp (A\\<^sup>k) B = (hr_comp A B)\\<^sup>k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hrp_comp (A\\<^sup>k) B = (hr_comp A B)\\<^sup>k", "by (auto simp: hrp_comp_def)"], ["", "lemma hr_comp_invalid: \"hr_comp (invalid_assn R1) R2 = invalid_assn (hr_comp R1 R2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hr_comp (invalid_assn R1) R2 = invalid_assn (hr_comp R1 R2)", "apply (intro ent_iffI entailsI ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa h.\n       h \\<Turnstile> hr_comp (invalid_assn R1) R2 x xa \\<Longrightarrow>\n       h \\<Turnstile> invalid_assn (hr_comp R1 R2) x xa\n 2. \\<And>x xa h.\n       h \\<Turnstile> invalid_assn (hr_comp R1 R2) x xa \\<Longrightarrow>\n       h \\<Turnstile> hr_comp (invalid_assn R1) R2 x xa", "unfolding invalid_assn_def hr_comp_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa h.\n       h \\<Turnstile>\n       (\\<exists>\\<^sub>Ab.\n           \\<up> (\\<exists>h. h \\<Turnstile> R1 b xa) * true *\n           \\<up> ((b, x) \\<in> R2)) \\<Longrightarrow>\n       h \\<Turnstile>\n       \\<up>\n        (\\<exists>h.\n            h \\<Turnstile>\n            (\\<exists>\\<^sub>Ab. R1 b xa * \\<up> ((b, x) \\<in> R2))) *\n       true\n 2. \\<And>x xa h.\n       h \\<Turnstile>\n       \\<up>\n        (\\<exists>h.\n            h \\<Turnstile>\n            (\\<exists>\\<^sub>Ab. R1 b xa * \\<up> ((b, x) \\<in> R2))) *\n       true \\<Longrightarrow>\n       h \\<Turnstile>\n       (\\<exists>\\<^sub>Ab.\n           \\<up> (\\<exists>h. h \\<Turnstile> R1 b xa) * true *\n           \\<up> ((b, x) \\<in> R2))", "by auto"], ["", "lemma hrp_comp_dest: \"hrp_comp (A\\<^sup>d) B = (hr_comp A B)\\<^sup>d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hrp_comp (A\\<^sup>d) B = (hr_comp A B)\\<^sup>d", "by (auto simp: hrp_comp_def hr_comp_invalid)"], ["", "definition \"hrp_imp RR RR' \\<equiv> \n    \\<forall>a b. (fst RR' a b \\<Longrightarrow>\\<^sub>t fst RR a b) \\<and> (snd RR a b \\<Longrightarrow>\\<^sub>t snd RR' a b)\""], ["", "lemma hfref_imp: \"hrp_imp RR RR' \\<Longrightarrow> [P]\\<^sub>a RR \\<rightarrow> S \\<subseteq> [P]\\<^sub>a RR' \\<rightarrow> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hrp_imp RR RR' \\<Longrightarrow>\n    [P]\\<^sub>a RR \\<rightarrow> S\n    \\<subseteq> [P]\\<^sub>a RR' \\<rightarrow> S", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>hrp_imp RR RR';\n        (a, b) \\<in> [P]\\<^sub>a RR \\<rightarrow> S\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> [P]\\<^sub>a RR' \\<rightarrow> S", "apply (erule hfref_cons)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b x. \\<lbrakk>hrp_imp RR RR'; P x\\<rbrakk> \\<Longrightarrow> P x\n 2. \\<And>a b x y.\n       hrp_imp RR RR' \\<Longrightarrow>\n       fst RR' x y \\<Longrightarrow>\\<^sub>t fst RR x y\n 3. \\<And>a b x y.\n       hrp_imp RR RR' \\<Longrightarrow>\n       snd RR x y \\<Longrightarrow>\\<^sub>t snd RR' x y\n 4. \\<And>a b x y.\n       hrp_imp RR RR' \\<Longrightarrow>\n       S x y \\<Longrightarrow>\\<^sub>t S x y", "apply (simp_all add: hrp_imp_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hrp_imp_refl: \"hrp_imp RR RR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hrp_imp RR RR", "unfolding hrp_imp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       (fst RR a b \\<Longrightarrow>\\<^sub>t fst RR a b) \\<and>\n       (snd RR a b \\<Longrightarrow>\\<^sub>t snd RR a b)", "by auto"], ["", "lemma hrp_imp_reflI: \"RR = RR' \\<Longrightarrow> hrp_imp RR RR'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RR = RR' \\<Longrightarrow> hrp_imp RR RR'", "unfolding hrp_imp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RR = RR' \\<Longrightarrow>\n    \\<forall>a b.\n       (fst RR' a b \\<Longrightarrow>\\<^sub>t fst RR a b) \\<and>\n       (snd RR a b \\<Longrightarrow>\\<^sub>t snd RR' a b)", "by auto"], ["", "lemma hrp_comp_cong: \"hrp_imp A A' \\<Longrightarrow> B=B' \\<Longrightarrow> hrp_imp (hrp_comp A B) (hrp_comp A' B')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hrp_imp A A'; B = B'\\<rbrakk>\n    \\<Longrightarrow> hrp_imp (hrp_comp A B) (hrp_comp A' B')", "by (sep_auto simp: hrp_imp_def hrp_comp_def hr_comp_def entailst_def)"], ["", "lemma hrp_prod_cong: \"hrp_imp A A' \\<Longrightarrow> hrp_imp B B' \\<Longrightarrow> hrp_imp (A*\\<^sub>aB) (A'*\\<^sub>aB')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hrp_imp A A'; hrp_imp B B'\\<rbrakk>\n    \\<Longrightarrow> hrp_imp (A *\\<^sub>a B) (A' *\\<^sub>a B')", "by (sep_auto simp: hrp_imp_def prod_assn_def intro: entt_star_mono)"], ["", "lemma hrp_imp_trans: \"hrp_imp A B \\<Longrightarrow> hrp_imp B C \\<Longrightarrow> hrp_imp A C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hrp_imp A B; hrp_imp B C\\<rbrakk> \\<Longrightarrow> hrp_imp A C", "unfolding hrp_imp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a b.\n                (fst B a b \\<Longrightarrow>\\<^sub>t fst A a b) \\<and>\n                (snd A a b \\<Longrightarrow>\\<^sub>t snd B a b);\n     \\<forall>a b.\n        (fst C a b \\<Longrightarrow>\\<^sub>t fst B a b) \\<and>\n        (snd B a b \\<Longrightarrow>\\<^sub>t snd C a b)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a b.\n                         (fst C a b \\<Longrightarrow>\\<^sub>t\n                          fst A a b) \\<and>\n                         (snd A a b \\<Longrightarrow>\\<^sub>t snd C a b)", "by (fastforce intro: entt_trans)"], ["", "lemma fcomp_norm_dflt_init: \"x\\<in>[P]\\<^sub>a R \\<rightarrow> T \\<Longrightarrow> hrp_imp R S \\<Longrightarrow> x\\<in>[P]\\<^sub>a S \\<rightarrow> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> [P]\\<^sub>a R \\<rightarrow> T; hrp_imp R S\\<rbrakk>\n    \\<Longrightarrow> x \\<in> [P]\\<^sub>a S \\<rightarrow> T", "apply (erule rev_subsetD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hrp_imp R S \\<Longrightarrow>\n    [P]\\<^sub>a R \\<rightarrow> T \\<subseteq> [P]\\<^sub>a S \\<rightarrow> T", "by (rule hfref_imp)"], ["", "definition \"comp_PRE R P Q S \\<equiv> \\<lambda>x. S x \\<longrightarrow> (P x \\<and> (\\<forall>y. (y,x)\\<in>R \\<longrightarrow> Q x y))\""], ["", "lemma comp_PRE_cong[cong]: \n    assumes \"R\\<equiv>R'\"\n    assumes \"\\<And>x. P x \\<equiv> P' x\"\n    assumes \"\\<And>x. S x \\<equiv> S' x\"\n    assumes \"\\<And>x y. \\<lbrakk>P x; (y,x)\\<in>R; y\\<in>Domain R; S' x \\<rbrakk> \\<Longrightarrow> Q x y \\<equiv> Q' x y\"\n    shows \"comp_PRE R P Q S \\<equiv> comp_PRE R' P' Q' S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_PRE R P Q S \\<equiv> comp_PRE R' P' Q' S'", "using assms"], ["proof (prove)\nusing this:\n  R \\<equiv> R'\n  P ?x \\<equiv> P' ?x\n  S ?x \\<equiv> S' ?x\n  \\<lbrakk>P ?x; (?y, ?x) \\<in> R; ?y \\<in> Domain R; S' ?x\\<rbrakk>\n  \\<Longrightarrow> Q ?x ?y \\<equiv> Q' ?x ?y\n\ngoal (1 subgoal):\n 1. comp_PRE R P Q S \\<equiv> comp_PRE R' P' Q' S'", "by (fastforce simp: comp_PRE_def intro!: eq_reflection ext)"], ["", "lemma fref_compI_PRE:\n    \"\\<lbrakk> (f,g)\\<in>fref P R1 R2; (g,h)\\<in>fref Q S1 S2 \\<rbrakk> \n      \\<Longrightarrow> (f,h) \\<in> fref (comp_PRE S1 Q (\\<lambda>_. P) (\\<lambda>_. True)) (R1 O S1) (R2 O S2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(f, g) \\<in> [P]\\<^sub>f R1 \\<rightarrow> R2;\n     (g, h) \\<in> [Q]\\<^sub>f S1 \\<rightarrow> S2\\<rbrakk>\n    \\<Longrightarrow> (f, h)\n                      \\<in> [comp_PRE S1 Q (\\<lambda>_. P)\n                              (\\<lambda>_.\n                                  True)]\\<^sub>f R1 O\n           S1 \\<rightarrow> R2 O S2", "using fref_compI[of P R1 R2 Q S1 S2]"], ["proof (prove)\nusing this:\n  ([P]\\<^sub>f R1 \\<rightarrow> R2) O ([Q]\\<^sub>f S1 \\<rightarrow> S2)\n  \\<subseteq> [\\<lambda>x.\n                  Q x \\<and>\n                  (\\<forall>y.\n                      (y, x) \\<in> S1 \\<longrightarrow>\n                      P y)]\\<^sub>f R1 O S1 \\<rightarrow> R2 O S2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(f, g) \\<in> [P]\\<^sub>f R1 \\<rightarrow> R2;\n     (g, h) \\<in> [Q]\\<^sub>f S1 \\<rightarrow> S2\\<rbrakk>\n    \\<Longrightarrow> (f, h)\n                      \\<in> [comp_PRE S1 Q (\\<lambda>_. P)\n                              (\\<lambda>_.\n                                  True)]\\<^sub>f R1 O\n           S1 \\<rightarrow> R2 O S2", "unfolding comp_PRE_def"], ["proof (prove)\nusing this:\n  ([P]\\<^sub>f R1 \\<rightarrow> R2) O ([Q]\\<^sub>f S1 \\<rightarrow> S2)\n  \\<subseteq> [\\<lambda>x.\n                  Q x \\<and>\n                  (\\<forall>y.\n                      (y, x) \\<in> S1 \\<longrightarrow>\n                      P y)]\\<^sub>f R1 O S1 \\<rightarrow> R2 O S2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(f, g) \\<in> [P]\\<^sub>f R1 \\<rightarrow> R2;\n     (g, h) \\<in> [Q]\\<^sub>f S1 \\<rightarrow> S2\\<rbrakk>\n    \\<Longrightarrow> (f, h)\n                      \\<in> [\\<lambda>x.\n                                True \\<longrightarrow>\n                                Q x \\<and>\n                                (\\<forall>y.\n                                    (y, x) \\<in> S1 \\<longrightarrow>\n                                    P y)]\\<^sub>f R1 O\n            S1 \\<rightarrow> R2 O S2", "by auto"], ["", "lemma PRE_D1: \"(Q x \\<and> P x) \\<longrightarrow> comp_PRE S1 Q (\\<lambda>x _. P x) S x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q x \\<and> P x \\<longrightarrow> comp_PRE S1 Q (\\<lambda>x _. P x) S x", "by (auto simp: comp_PRE_def)"], ["", "lemma PRE_D2: \"(Q x \\<and> (\\<forall>y. (y,x)\\<in>S1 \\<longrightarrow> S x \\<longrightarrow> P x y)) \\<longrightarrow> comp_PRE S1 Q P S x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q x \\<and>\n    (\\<forall>y.\n        (y, x) \\<in> S1 \\<longrightarrow>\n        S x \\<longrightarrow> P x y) \\<longrightarrow>\n    comp_PRE S1 Q P S x", "by (auto simp: comp_PRE_def)"], ["", "lemma fref_weaken_pre: \n    assumes \"\\<And>x. P x \\<longrightarrow> P' x\"  \n    assumes \"(f,h) \\<in> fref P' R S\"\n    shows \"(f,h) \\<in> fref P R S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, h) \\<in> [P]\\<^sub>f R \\<rightarrow> S", "apply (rule rev_subsetD[OF assms(2) fref_mono])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. P x \\<Longrightarrow> P' x\n 2. R \\<subseteq> R\n 3. S \\<subseteq> S", "using assms(1)"], ["proof (prove)\nusing this:\n  P ?x \\<longrightarrow> P' ?x\n\ngoal (3 subgoals):\n 1. \\<And>x. P x \\<Longrightarrow> P' x\n 2. R \\<subseteq> R\n 3. S \\<subseteq> S", "by auto"], ["", "lemma fref_PRE_D1:\n    assumes \"(f,h) \\<in> fref (comp_PRE S1 Q (\\<lambda>x _. P x) X) R S\"  \n    shows \"(f,h) \\<in> fref (\\<lambda>x. Q x \\<and> P x) R S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, h) \\<in> [\\<lambda>x. Q x \\<and> P x]\\<^sub>f R \\<rightarrow> S", "by (rule fref_weaken_pre[OF PRE_D1 assms])"], ["", "lemma fref_PRE_D2:\n    assumes \"(f,h) \\<in> fref (comp_PRE S1 Q P X) R S\"  \n    shows \"(f,h) \\<in> fref (\\<lambda>x. Q x \\<and> (\\<forall>y. (y,x)\\<in>S1 \\<longrightarrow> X x \\<longrightarrow> P x y)) R S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, h)\n    \\<in> [\\<lambda>x.\n              Q x \\<and>\n              (\\<forall>y.\n                  (y, x) \\<in> S1 \\<longrightarrow>\n                  X x \\<longrightarrow> P x y)]\\<^sub>f R \\<rightarrow> S", "by (rule fref_weaken_pre[OF PRE_D2 assms])"], ["", "lemmas fref_PRE_D = fref_PRE_D1 fref_PRE_D2"], ["", "lemma hfref_weaken_pre: \n    assumes \"\\<And>x. P x \\<longrightarrow> P' x\"  \n    assumes \"(f,h) \\<in> hfref P' R S\"\n    shows \"(f,h) \\<in> hfref P R S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, h) \\<in> [P]\\<^sub>a R \\<rightarrow> S", "using assms"], ["proof (prove)\nusing this:\n  P ?x \\<longrightarrow> P' ?x\n  (f, h) \\<in> [P']\\<^sub>a R \\<rightarrow> S\n\ngoal (1 subgoal):\n 1. (f, h) \\<in> [P]\\<^sub>a R \\<rightarrow> S", "by (auto simp: hfref_def)"], ["", "lemma hfref_weaken_pre': \n    assumes \"\\<And>x. \\<lbrakk>P x; rdomp (fst R) x\\<rbrakk> \\<Longrightarrow> P' x\"  \n    assumes \"(f,h) \\<in> hfref P' R S\"\n    shows \"(f,h) \\<in> hfref P R S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, h) \\<in> [P]\\<^sub>a R \\<rightarrow> S", "apply (rule hfrefI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       P a \\<Longrightarrow> hn_refine (fst R a c) (f c) (snd R a c) S (h a)", "apply (rule hn_refine_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a ha.\n       \\<lbrakk>P a; ha \\<Turnstile> fst R a c\\<rbrakk>\n       \\<Longrightarrow> hn_refine (fst R a c) (f c) (snd R a c) S (h a)", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>P ?x; rdomp (fst R) ?x\\<rbrakk> \\<Longrightarrow> P' ?x\n  (f, h) \\<in> [P']\\<^sub>a R \\<rightarrow> S\n\ngoal (1 subgoal):\n 1. \\<And>c a ha.\n       \\<lbrakk>P a; ha \\<Turnstile> fst R a c\\<rbrakk>\n       \\<Longrightarrow> hn_refine (fst R a c) (f c) (snd R a c) S (h a)", "by (auto simp: hfref_def rdomp_def)"], ["", "lemma hfref_weaken_pre_nofail': \n    assumes \"(f,g) \\<in> [P]\\<^sub>a R \\<rightarrow> S\"  \n    assumes \"\\<And>x. \\<lbrakk>nofail (g x); Q x\\<rbrakk> \\<Longrightarrow> P x\"\n    shows \"(f,g) \\<in> [Q]\\<^sub>a R \\<rightarrow> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g) \\<in> [Q]\\<^sub>a R \\<rightarrow> S", "apply (rule hfref_weaken_pre[OF _ assms(1)[THEN hfref_weaken_pre_nofail]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. Q x \\<longrightarrow> nofail (g x) \\<longrightarrow> P x", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>nofail (g ?x); Q ?x\\<rbrakk> \\<Longrightarrow> P ?x\n\ngoal (1 subgoal):\n 1. \\<And>x. Q x \\<longrightarrow> nofail (g x) \\<longrightarrow> P x", "by blast"], ["", "lemma hfref_compI_PRE_aux:\n    assumes A: \"(f,g) \\<in> [P]\\<^sub>a RR' \\<rightarrow> S\"\n    assumes B: \"(g,h) \\<in> [Q]\\<^sub>f T \\<rightarrow> \\<langle>U\\<rangle>nres_rel\"\n    shows \"(f,h) \\<in> [comp_PRE T Q (\\<lambda>_. P) (\\<lambda>_. True)]\\<^sub>a \n      hrp_comp RR' T \\<rightarrow> hr_comp S U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, h)\n    \\<in> [comp_PRE T Q (\\<lambda>_. P)\n            (\\<lambda>_.\n                True)]\\<^sub>a hrp_comp RR' T \\<rightarrow> hr_comp S U", "apply (rule hfref_weaken_pre[OF _ hfcomp[OF A B]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       comp_PRE T Q (\\<lambda>_. P) (\\<lambda>_. True) x \\<longrightarrow>\n       Q x \\<and> (\\<forall>a'. (a', x) \\<in> T \\<longrightarrow> P a')", "by (auto simp: comp_PRE_def)"], ["", "lemma hfref_compI_PRE:\n    assumes A: \"(f,g) \\<in> [P]\\<^sub>a RR' \\<rightarrow> S\"\n    assumes B: \"(g,h) \\<in> [Q]\\<^sub>f T \\<rightarrow> \\<langle>U\\<rangle>nres_rel\"\n    shows \"(f,h) \\<in> [comp_PRE T Q (\\<lambda>x y. P y) (\\<lambda>x. nofail (h x))]\\<^sub>a \n      hrp_comp RR' T \\<rightarrow> hr_comp S U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, h)\n    \\<in> [comp_PRE T Q (\\<lambda>x. P)\n            (\\<lambda>x.\n                nofail\n                 (h x))]\\<^sub>a hrp_comp RR' T \\<rightarrow> hr_comp S U", "using hfref_compI_PRE_aux[OF A B, THEN hfref_weaken_pre_nofail]"], ["proof (prove)\nusing this:\n  (f, h)\n  \\<in> [\\<lambda>x.\n            nofail (h x) \\<longrightarrow>\n            comp_PRE T Q (\\<lambda>_. P) (\\<lambda>_. True)\n             x]\\<^sub>a hrp_comp RR' T \\<rightarrow> hr_comp S U\n\ngoal (1 subgoal):\n 1. (f, h)\n    \\<in> [comp_PRE T Q (\\<lambda>x. P)\n            (\\<lambda>x.\n                nofail\n                 (h x))]\\<^sub>a hrp_comp RR' T \\<rightarrow> hr_comp S U", "apply (rule hfref_weaken_pre[rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       comp_PRE T Q (\\<lambda>x. P) (\\<lambda>x. nofail (h x))\n        x \\<longrightarrow>\n       nofail (h x) \\<longrightarrow>\n       comp_PRE T Q (\\<lambda>_. P) (\\<lambda>_. True) x", "apply (auto simp: comp_PRE_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hfref_PRE_D1:\n    assumes \"(f,h) \\<in> hfref (comp_PRE S1 Q (\\<lambda>x _. P x) X) R S\"  \n    shows \"(f,h) \\<in> hfref (\\<lambda>x. Q x \\<and> P x) R S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, h) \\<in> [\\<lambda>x. Q x \\<and> P x]\\<^sub>a R \\<rightarrow> S", "by (rule hfref_weaken_pre[OF PRE_D1 assms])"], ["", "lemma hfref_PRE_D2:\n    assumes \"(f,h) \\<in> hfref (comp_PRE S1 Q P X) R S\"  \n    shows \"(f,h) \\<in> hfref (\\<lambda>x. Q x \\<and> (\\<forall>y. (y,x)\\<in>S1 \\<longrightarrow> X x \\<longrightarrow> P x y)) R S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, h)\n    \\<in> [\\<lambda>x.\n              Q x \\<and>\n              (\\<forall>y.\n                  (y, x) \\<in> S1 \\<longrightarrow>\n                  X x \\<longrightarrow> P x y)]\\<^sub>a R \\<rightarrow> S", "by (rule hfref_weaken_pre[OF PRE_D2 assms])"], ["", "lemma hfref_PRE_D3:\n    assumes \"(f,h) \\<in> hfref (comp_PRE S1 Q P X) R S\"  \n    shows \"(f,h) \\<in> hfref (comp_PRE S1 Q P X) R S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, h) \\<in> [comp_PRE S1 Q P X]\\<^sub>a R \\<rightarrow> S", "using assms"], ["proof (prove)\nusing this:\n  (f, h) \\<in> [comp_PRE S1 Q P X]\\<^sub>a R \\<rightarrow> S\n\ngoal (1 subgoal):\n 1. (f, h) \\<in> [comp_PRE S1 Q P X]\\<^sub>a R \\<rightarrow> S", "."], ["", "lemmas hfref_PRE_D = hfref_PRE_D1 hfref_PRE_D3"], ["", "subsection \\<open>Automation\\<close>"], ["", "text \\<open>Purity configuration for constraint solver\\<close>"], ["", "lemmas [safe_constraint_rules] = pure_pure"], ["", "text \\<open>Configuration for hfref to hnr conversion\\<close>"], ["", "named_theorems to_hnr_post \\<open>to_hnr converter: Postprocessing unfold rules\\<close>"], ["", "lemma uncurry0_add_app_tag: \"uncurry0 (RETURN c) = uncurry0 (RETURN$c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uncurry0 (RETURN c) = uncurry0 (RETURN $ c)", "by simp"], ["", "lemmas [to_hnr_post] = norm_RETURN_o norm_return_o\n    uncurry0_add_app_tag uncurry0_apply uncurry0_APP hn_val_unit_conv_emp\n    mult_1[of \"x::assn\" for x] mult_1_right[of \"x::assn\" for x]"], ["", "named_theorems to_hfref_post \\<open>to_hfref converter: Postprocessing unfold rules\\<close>"], ["", "lemma prod_casesK[to_hfref_post]: \"case_prod (\\<lambda>_ _. k) = (\\<lambda>_. k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(uu_, uu_). k) = (\\<lambda>_. k)", "by auto"], ["", "lemma uncurry0_hfref_post[to_hfref_post]: \"hfref (uncurry0 True) R S = hfref (\\<lambda>_. True) R S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [uncurry0 True]\\<^sub>a R \\<rightarrow> S = R \\<rightarrow>\\<^sub>a S", "apply (fo_rule arg_cong fun_cong)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. uncurry0 True = (\\<lambda>_. True)", "by auto"], ["", "(* Currently not used, we keep it in here anyway. *)"], ["", "text \\<open>Configuration for relation normalization after composition\\<close>"], ["", "named_theorems fcomp_norm_unfold \\<open>fcomp-normalizer: Unfold theorems\\<close>"], ["", "named_theorems fcomp_norm_simps \\<open>fcomp-normalizer: Simplification theorems\\<close>"], ["", "named_theorems fcomp_norm_init \"fcomp-normalizer: Initialization rules\""], ["", "named_theorems fcomp_norm_trans \"fcomp-normalizer: Transitivity rules\""], ["", "named_theorems fcomp_norm_cong \"fcomp-normalizer: Congruence rules\""], ["", "named_theorems fcomp_norm_norm \"fcomp-normalizer: Normalization rules\""], ["", "named_theorems fcomp_norm_refl \"fcomp-normalizer: Reflexivity rules\""], ["", "text \\<open>Default Setup\\<close>"], ["", "lemmas [fcomp_norm_unfold] = prod_rel_comp nres_rel_comp Id_O_R R_O_Id"], ["", "lemmas [fcomp_norm_unfold] = hr_comp_Id1 hr_comp_Id2"], ["", "lemmas [fcomp_norm_unfold] = hr_comp_prod_conv"], ["", "lemmas [fcomp_norm_unfold] = prod_hrp_comp hrp_comp_keep hrp_comp_dest hr_comp_pure"], ["", "(*lemmas [fcomp_norm_unfold] = prod_casesK uncurry0_hfref_post*)"], ["", "lemma [fcomp_norm_simps]: \"CONSTRAINT is_pure P \\<Longrightarrow> pure (the_pure P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT is_pure P \\<Longrightarrow> pure (the_pure P) = P", "by simp"], ["", "lemmas [fcomp_norm_simps] = True_implies_equals"], ["", "lemmas [fcomp_norm_init] = fcomp_norm_dflt_init"], ["", "lemmas [fcomp_norm_trans] = hrp_imp_trans"], ["", "lemmas [fcomp_norm_cong] = hrp_comp_cong hrp_prod_cong"], ["", "(*lemmas [fcomp_norm_norm] = hrp_comp_dest*)"], ["", "lemmas [fcomp_norm_refl] = refl hrp_imp_refl"], ["", "lemma ensure_fref_nresI: \"(f,g)\\<in>[P]\\<^sub>f R\\<rightarrow>S \\<Longrightarrow> (RETURN o f, RETURN o g)\\<in>[P]\\<^sub>f R\\<rightarrow>\\<langle>S\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g) \\<in> [P]\\<^sub>f R \\<rightarrow> S \\<Longrightarrow>\n    (RETURN \\<circ> f, RETURN \\<circ> g)\n    \\<in> [P]\\<^sub>f R \\<rightarrow> \\<langle>S\\<rangle>nres_rel", "by (auto intro: nres_relI simp: fref_def)"], ["", "lemma ensure_fref_nres_unfold:\n    \"\\<And>f. RETURN o (uncurry0 f) = uncurry0 (RETURN f)\" \n    \"\\<And>f. RETURN o (uncurry f) = uncurry (RETURN oo f)\"\n    \"\\<And>f. (RETURN ooo uncurry) f = uncurry (RETURN ooo f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f. (RETURN \\<circ>\\<circ> uncurry0) f = uncurry0 (RETURN f)) &&&\n    (\\<And>f.\n        (RETURN \\<circ>\\<circ> uncurry) f =\n        uncurry (RETURN \\<circ>\\<circ> f)) &&&\n    (\\<And>f.\n        (RETURN \\<circ>\\<circ>\\<circ> uncurry) f =\n        uncurry (RETURN \\<circ>\\<circ>\\<circ> f))", "by auto"], ["", "text \\<open>Composed precondition normalizer\\<close>"], ["", "named_theorems fcomp_prenorm_simps \\<open>fcomp precondition-normalizer: Simplification theorems\\<close>"], ["", "text \\<open>Support for preconditions of the form \\<open>_\\<in>Domain R\\<close>, \n    where \\<open>R\\<close> is the relation of the next more abstract level.\\<close>"], ["", "declare DomainI[fcomp_prenorm_simps]"], ["", "lemma auto_weaken_pre_init_hf: \n    assumes \"\\<And>x. PROTECT P x \\<longrightarrow> P' x\"  \n    assumes \"(f,h) \\<in> hfref P' R S\"\n    shows \"(f,h) \\<in> hfref P R S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, h) \\<in> [P]\\<^sub>a R \\<rightarrow> S", "using assms"], ["proof (prove)\nusing this:\n  PROTECT P ?x \\<longrightarrow> P' ?x\n  (f, h) \\<in> [P']\\<^sub>a R \\<rightarrow> S\n\ngoal (1 subgoal):\n 1. (f, h) \\<in> [P]\\<^sub>a R \\<rightarrow> S", "by (auto simp: hfref_def)"], ["", "lemma auto_weaken_pre_init_f: \n    assumes \"\\<And>x. PROTECT P x \\<longrightarrow> P' x\"  \n    assumes \"(f,h) \\<in> fref P' R S\"\n    shows \"(f,h) \\<in> fref P R S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, h) \\<in> [P]\\<^sub>f R \\<rightarrow> S", "using assms"], ["proof (prove)\nusing this:\n  PROTECT P ?x \\<longrightarrow> P' ?x\n  (f, h) \\<in> [P']\\<^sub>f R \\<rightarrow> S\n\ngoal (1 subgoal):\n 1. (f, h) \\<in> [P]\\<^sub>f R \\<rightarrow> S", "by (auto simp: fref_def)"], ["", "lemmas auto_weaken_pre_init = auto_weaken_pre_init_hf auto_weaken_pre_init_f"], ["", "lemma auto_weaken_pre_uncurry_step:\n    assumes \"PROTECT f a \\<equiv> f'\"\n    shows \"PROTECT (\\<lambda>(x,y). f x y) (a,b) \\<equiv> f' b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PROTECT (\\<lambda>(x, y). f x y) (a, b) \\<equiv> f' b", "using assms"], ["proof (prove)\nusing this:\n  PROTECT f a \\<equiv> f'\n\ngoal (1 subgoal):\n 1. PROTECT (\\<lambda>(x, y). f x y) (a, b) \\<equiv> f' b", "by (auto simp: curry_def dest!: meta_eq_to_obj_eq intro!: eq_reflection)"], ["", "lemma auto_weaken_pre_uncurry_finish:  \n    \"PROTECT f x \\<equiv> f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PROTECT f x \\<equiv> f x", "by (auto)"], ["", "lemma auto_weaken_pre_uncurry_start:\n    assumes \"P \\<equiv> P'\"\n    assumes \"P'\\<longrightarrow>Q\"\n    shows \"P\\<longrightarrow>Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<longrightarrow> Q", "using assms"], ["proof (prove)\nusing this:\n  P \\<equiv> P'\n  P' \\<longrightarrow> Q\n\ngoal (1 subgoal):\n 1. P \\<longrightarrow> Q", "by (auto)"], ["", "lemma auto_weaken_pre_comp_PRE_I:\n    assumes \"S x \\<Longrightarrow> P x\"\n    assumes \"\\<And>y. \\<lbrakk>(y,x)\\<in>R; P x; S x\\<rbrakk> \\<Longrightarrow> Q x y\"\n    shows \"comp_PRE R P Q S x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_PRE R P Q S x", "using assms"], ["proof (prove)\nusing this:\n  S x \\<Longrightarrow> P x\n  \\<lbrakk>(?y, x) \\<in> R; P x; S x\\<rbrakk> \\<Longrightarrow> Q x ?y\n\ngoal (1 subgoal):\n 1. comp_PRE R P Q S x", "by (auto simp: comp_PRE_def)"], ["", "lemma auto_weaken_pre_to_imp_nf:\n    \"(A\\<longrightarrow>B\\<longrightarrow>C) = (A\\<and>B \\<longrightarrow> C)\"\n    \"((A\\<and>B)\\<and>C) = (A\\<and>B\\<and>C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<longrightarrow> B \\<longrightarrow> C) =\n    (A \\<and> B \\<longrightarrow> C) &&&\n    ((A \\<and> B) \\<and> C) = (A \\<and> B \\<and> C)", "by auto"], ["", "lemma auto_weaken_pre_add_dummy_imp:\n    \"P \\<Longrightarrow> True \\<longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<Longrightarrow> True \\<longrightarrow> P", "by simp"], ["", "text \\<open>Synthesis for hfref statements\\<close>"], ["", "definition hfsynth_ID_R :: \"('a \\<Rightarrow> _ \\<Rightarrow> assn) \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n    [simp]: \"hfsynth_ID_R _ _ \\<equiv> True\""], ["", "lemma hfsynth_ID_R_D:\n    fixes I :: \"'a itself\"\n    assumes \"hfsynth_ID_R R a\"\n    assumes \"intf_of_assn R I\"\n    shows \"a ::\\<^sub>i I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a ::\\<^sub>i I", "by simp"], ["", "lemma hfsynth_hnr_from_hfI:\n    assumes \"\\<forall>x xi. P x \\<and> hfsynth_ID_R (fst R) x \\<longrightarrow> hn_refine (emp * hn_ctxt (fst R) x xi) (f$xi) (emp * hn_ctxt (snd R) x xi) S (g$x)\"\n    shows \"(f,g) \\<in> [P]\\<^sub>a R \\<rightarrow> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, g) \\<in> [P]\\<^sub>a R \\<rightarrow> S", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>x xi.\n     P x \\<and> hfsynth_ID_R (fst R) x \\<longrightarrow>\n     hn_refine (emp * hn_ctxt (fst R) x xi) (f $ xi)\n      (emp * hn_ctxt (snd R) x xi) S (g $ x)\n\ngoal (1 subgoal):\n 1. (f, g) \\<in> [P]\\<^sub>a R \\<rightarrow> S", "unfolding hfref_def"], ["proof (prove)\nusing this:\n  \\<forall>x xi.\n     P x \\<and> hfsynth_ID_R (fst R) x \\<longrightarrow>\n     hn_refine (emp * hn_ctxt (fst R) x xi) (f $ xi)\n      (emp * hn_ctxt (snd R) x xi) S (g $ x)\n\ngoal (1 subgoal):\n 1. (f, g)\n    \\<in> {(f, g).\n           \\<forall>c a.\n              P a \\<longrightarrow>\n              hn_refine (fst R a c) (f c) (snd R a c) S (g a)}", "by (auto simp: hn_ctxt_def)"], ["", "lemma hfsynth_ID_R_uncurry_unfold: \n    \"hfsynth_ID_R (to_hnr_prod R S) (a,b) \\<equiv> hfsynth_ID_R R a \\<and> hfsynth_ID_R S b\" \n    \"hfsynth_ID_R (fst (hf_pres R k)) \\<equiv> hfsynth_ID_R R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hfsynth_ID_R (to_hnr_prod R S) (a, b) \\<equiv>\n     hfsynth_ID_R R a \\<and> hfsynth_ID_R S b) &&&\n    hfsynth_ID_R (fst (hf_pres R k)) \\<equiv> hfsynth_ID_R R", "by (auto intro!: eq_reflection)"], ["", "ML \\<open>\n\n    signature SEPREF_RULES = sig\n      (* Analysis of relations, both fref and fun_rel *)\n      (* \"R1\\<rightarrow>...\\<rightarrow>Rn\\<rightarrow>_\" / \"[_]\\<^sub>f ((R1\\<times>\\<^sub>rR2)...\\<times>\\<^sub>rRn)\"  \\<mapsto>  \"[R1,...,Rn]\" *)\n      val binder_rels: term -> term list \n      (* \"_\\<rightarrow>...\\<rightarrow>_\\<rightarrow>S\" / \"[_]\\<^sub>f _ \\<rightarrow> S\"  \\<mapsto>  \"S\" *)\n      val body_rel: term -> term \n      (* Map \\<rightarrow>/fref to (precond,args,res). NONE if no/trivial precond. *)\n      val analyze_rel: term -> term option * term list * term \n      (* Make trivial (\"\\<lambda>_. True\") precond *)\n      val mk_triv_precond: term list -> term \n      (* Make \"[P]\\<^sub>f ((R1\\<times>\\<^sub>rR2)...\\<times>\\<^sub>rRn) \\<rightarrow> S\". Insert trivial precond if NONE. *)\n      val mk_rel: term option * term list * term -> term \n      (* Map relation to (args,res) *)\n      val strip_rel: term -> term list * term \n\n      (* Make hfprod (op *\\<^sub>a) *)\n      val mk_hfprod : term * term -> term\n      val mk_hfprods : term list -> term\n\n      (* Determine interface type of refinement assertion, using default fallback\n        if necessary. Use named_thms intf_of_assn for configuration. *)\n      val intf_of_assn : Proof.context -> term -> typ\n\n      (*\n        Convert a parametricity theorem in higher-order form to\n        uncurried fref-form. For functions without arguments, \n        a unit-argument is added.\n\n        TODO/FIXME: Currently this only works for higher-order theorems,\n          i.e., theorems of the form (f,g)\\<in>R1\\<rightarrow>\\<dots>\\<rightarrow>Rn. \n          \n          First-order theorems are silently treated as refinement theorems\n          for functions with zero arguments, i.e., a unit-argument is added.\n      *)\n      val to_fref : Proof.context -> thm -> thm\n\n      (* Convert a parametricity or fref theorem to first order form *)\n      val to_foparam : Proof.context -> thm -> thm\n\n      (* Convert schematic hfref goal to hnr-goal *)\n      val prepare_hfref_synth_tac : Proof.context -> tactic'\n\n      (* Convert theorem in hfref-form to hnr-form *)\n      val to_hnr : Proof.context -> thm -> thm\n\n      (* Convert theorem in hnr-form to hfref-form *)\n      val to_hfref: Proof.context -> thm -> thm\n\n      (* Convert theorem to given form, if not yet in this form *)\n      val ensure_fref : Proof.context -> thm -> thm\n      val ensure_fref_nres : Proof.context -> thm -> thm\n      val ensure_hfref : Proof.context -> thm -> thm\n      val ensure_hnr : Proof.context -> thm -> thm\n\n\n      type hnr_analysis = {\n        thm: thm,                     (* Original theorem, may be normalized *)\n        precond: term,                (* Precondition, abstracted over abs-arguments *)\n        prems : term list,            (* Premises not depending on arguments *)\n        ahead: term * bool,           (* Abstract function, has leading RETURN *)\n        chead: term * bool,           (* Concrete function, has leading return *)\n        argrels: (term * bool) list,  (* Argument relations, preserved (keep-flag) *)\n        result_rel: term              (* Result relation *)\n      }\n  \n      val analyze_hnr: Proof.context -> thm -> hnr_analysis\n      val pretty_hnr_analysis: Proof.context -> hnr_analysis -> Pretty.T\n      val mk_hfref_thm: Proof.context -> hnr_analysis -> thm\n  \n  \n\n      (* Simplify precondition of fref/hfref-theorem *)\n      val simplify_precond: Proof.context -> thm -> thm\n\n      (* Normalize hfref-theorem after composition *)\n      val norm_fcomp_rule: Proof.context -> thm -> thm\n\n      (* Replace \"pure ?A\" by \"?A'\" and is_pure constraint, then normalize *)\n      val add_pure_constraints_rule: Proof.context -> thm -> thm\n\n      (* Compose fref/hfref and fref theorem, to produce hfref theorem.\n        The input theorems may also be in ho-param or hnr form, and\n        are converted accordingly.\n      *)\n      val gen_compose : Proof.context -> thm -> thm -> thm\n\n      (* FCOMP-attribute *)\n      val fcomp_attrib: attribute context_parser\n    end\n\n    structure Sepref_Rules: SEPREF_RULES = struct\n\n      local open Refine_Util Relators in\n        fun binder_rels @{mpat \"?F \\<rightarrow> ?G\"} = F::binder_rels G\n          | binder_rels @{mpat \"fref _ ?F _\"} = strip_prodrel_left F\n          | binder_rels _ = []\n    \n        local \n          fun br_aux @{mpat \"_ \\<rightarrow> ?G\"} = br_aux G\n            | br_aux R = R\n        in    \n          fun body_rel @{mpat \"fref _ _ ?G\"} = G\n            | body_rel R = br_aux R\n        end\n    \n        fun strip_rel R = (binder_rels R, body_rel R)   \n    \n        fun analyze_rel @{mpat \"fref (\\<lambda>_. True) ?R ?S\"} = (NONE,strip_prodrel_left R,S)\n          | analyze_rel @{mpat \"fref ?P ?R ?S\"} = (SOME P,strip_prodrel_left R,S)\n          | analyze_rel R = let\n              val (args,res) = strip_rel R\n            in\n              (NONE,args,res)\n            end\n    \n        fun mk_triv_precond Rs = absdummy (map rel_absT Rs |> list_prodT_left) @{term True}\n    \n        fun mk_rel (P,Rs,S) = let \n          val R = list_prodrel_left Rs \n    \n          val P = case P of \n              SOME P => P \n            | NONE => mk_triv_precond Rs\n    \n        in \n          @{mk_term \"fref ?P ?R ?S\"} \n        end\n      end\n\n\n      fun mk_hfprod (a, b) = @{mk_term \"?a*\\<^sub>a?b\"}\n  \n      local \n        fun mk_hfprods_rev [] = @{mk_term \"unit_assn\\<^sup>k\"}\n          | mk_hfprods_rev [Rk] = Rk\n          | mk_hfprods_rev (Rkn::Rks) = mk_hfprod (mk_hfprods_rev Rks, Rkn)\n      in\n        val mk_hfprods = mk_hfprods_rev o rev\n      end\n\n\n      fun intf_of_assn ctxt t = let\n        val orig_ctxt = ctxt\n        val (t,ctxt) = yield_singleton (Variable.import_terms false) t ctxt\n\n        val v = TVar ((\"T\",0),Proof_Context.default_sort ctxt (\"T\",0)) |> Logic.mk_type\n        val goal = @{mk_term \"Trueprop (intf_of_assn ?t ?v)\"}\n\n        val i_of_assn_rls = \n          Named_Theorems_Rev.get ctxt @{named_theorems_rev intf_of_assn}\n          @ @{thms intf_of_assn_fallback}\n\n        fun tac ctxt = REPEAT_ALL_NEW (resolve_tac ctxt i_of_assn_rls)\n\n        val thm = Goal.prove ctxt [] [] goal (fn {context,...} => ALLGOALS (tac context))\n        val intf = case Thm.concl_of thm of\n            @{mpat \"Trueprop (intf_of_assn _ (?v AS\\<^sub>p TYPE (_)))\"} => v \n          | _ => raise THM(\"Intf_of_assn: Proved a different theorem?\",~1,[thm])\n\n        val intf = singleton (Variable.export_terms ctxt orig_ctxt) intf\n          |> Logic.dest_type\n\n      in\n        intf\n      end\n\n      datatype rthm_type = \n        RT_HOPARAM    (* (_,_) \\<in> _ \\<rightarrow> \\<dots> \\<rightarrow> _ *)\n      | RT_FREF       (* (_,_) \\<in> [_]\\<^sub>f _ \\<rightarrow> _ *)\n      | RT_HNR        (* hn_refine _ _ _ _ _ *)\n      | RT_HFREF      (* (_,_) \\<in> [_]\\<^sub>a _ \\<rightarrow> _ *)\n      | RT_OTHER\n\n      fun rthm_type thm =\n        case Thm.concl_of thm |> HOLogic.dest_Trueprop of\n          @{mpat \"(_,_) \\<in> fref _ _ _\"} => RT_FREF\n        | @{mpat \"(_,_) \\<in> hfref _ _ _\"} => RT_HFREF\n        | @{mpat \"hn_refine _ _ _ _ _\"} => RT_HNR\n        | @{mpat \"(_,_) \\<in> _\"} => RT_HOPARAM (* TODO: Distinction between ho-param and fo-param *)\n        | _ => RT_OTHER\n\n\n      fun to_fref ctxt thm = let\n        open Conv\n      in  \n        case Thm.concl_of thm |> HOLogic.dest_Trueprop of\n          @{mpat \"(_,_)\\<in>_\\<rightarrow>_\"} =>\n            Local_Defs.unfold0 ctxt @{thms fref_param1} thm\n            |> fconv_rule (repeat_conv (Refine_Util.ftop_conv (K (rewr_conv @{thm fref_nest})) ctxt))\n            |> Local_Defs.unfold0 ctxt @{thms in_CURRY_conv}\n        | @{mpat \"(_,_)\\<in>_\"} => thm RS @{thm fref_param0I}   \n        | _ => raise THM (\"to_fref: Expected theorem of form (_,_)\\<in>_\",~1,[thm])\n      end\n\n      fun to_foparam ctxt thm = let\n        val unf_thms = @{thms \n          split_tupled_all prod_rel_simp uncurry_apply cnv_conj_to_meta Product_Type.split}\n      in\n        case Thm.concl_of thm of\n          @{mpat \"Trueprop ((_,_) \\<in> fref _ _ _)\"} =>\n            (@{thm frefD} OF [thm])\n            |> forall_intr_vars\n            |> Local_Defs.unfold0 ctxt unf_thms\n            |> Variable.gen_all ctxt\n        | @{mpat \"Trueprop ((_,_) \\<in> _)\"} =>\n            Parametricity.fo_rule thm\n        | _ => raise THM(\"Expected parametricity or fref theorem\",~1,[thm])\n      end\n\n      fun to_hnr ctxt thm =\n        (thm RS @{thm hf2hnr})\n        |> Local_Defs.unfold0 ctxt @{thms to_hnr_prod_fst_snd keep_drop_sels} (* Resolve fst and snd over *\\<^sub>a and R\\<^sup>k, R\\<^sup>d *)\n        |> Local_Defs.unfold0 ctxt @{thms hnr_uncurry_unfold} (* Resolve products for uncurried parameters *)\n        |> Local_Defs.unfold0 ctxt @{thms uncurry_apply uncurry_APP assn_one_left split} (* Remove the uncurry modifiers, the emp-dummy, and unfold product cases *)\n        |> Local_Defs.unfold0 ctxt @{thms hn_ctxt_ctxt_fix_conv} (* Remove duplicate hn_ctxt tagging *)\n        |> Local_Defs.unfold0 ctxt @{thms all_to_meta imp_to_meta HOL.True_implies_equals HOL.implies_True_equals Pure.triv_forall_equality cnv_conj_to_meta} (* Convert to meta-level, remove vacuous condition *)\n        |> Local_Defs.unfold0 ctxt (Named_Theorems.get ctxt @{named_theorems to_hnr_post}) (* Post-Processing *)\n        |> Goal.norm_result ctxt\n        |> Conv.fconv_rule Thm.eta_conversion\n\n      (* Convert schematic hfref-goal to hn_refine goal *)  \n      fun prepare_hfref_synth_tac ctxt = let\n        val i_of_assn_rls = \n          Named_Theorems_Rev.get ctxt @{named_theorems_rev intf_of_assn}\n          @ @{thms intf_of_assn_fallback}\n\n        val to_hnr_post_rls = \n          Named_Theorems.get ctxt @{named_theorems to_hnr_post}\n\n        val i_of_assn_tac = (\n          REPEAT' (\n            DETERM o dresolve_tac ctxt @{thms hfsynth_ID_R_D}\n            THEN' DETERM o SOLVED' (REPEAT_ALL_NEW (resolve_tac ctxt i_of_assn_rls))\n          )\n        )\n      in\n        (* Note: To re-use the to_hnr infrastructure, we first work with\n          $-tags on the abstract function, which are finally removed.\n        *)\n        resolve_tac ctxt @{thms hfsynth_hnr_from_hfI} THEN_ELSE' (\n          SELECT_GOAL (\n            unfold_tac ctxt @{thms to_hnr_prod_fst_snd keep_drop_sels hf_pres_fst} (* Distribute fst,snd over product and hf_pres *)\n            THEN unfold_tac ctxt @{thms hnr_uncurry_unfold hfsynth_ID_R_uncurry_unfold} (* Curry parameters *)\n            THEN unfold_tac ctxt @{thms uncurry_apply uncurry_APP assn_one_left split} (* Curry parameters (II) and remove emp assertion *)\n            (*THEN unfold_tac ctxt @{thms hn_ctxt_ctxt_fix_conv} (* Remove duplicate hn_ctxt (Should not be necessary) *)*)\n            THEN unfold_tac ctxt @{thms all_to_meta imp_to_meta HOL.True_implies_equals HOL.implies_True_equals Pure.triv_forall_equality cnv_conj_to_meta} (* Convert precondition to meta-level *)\n            THEN ALLGOALS i_of_assn_tac (* Generate _::\\<^sub>i_ premises*)\n            THEN unfold_tac ctxt to_hnr_post_rls (* Postprocessing *)\n            THEN unfold_tac ctxt @{thms APP_def} (* Get rid of $ - tags *)\n          )\n        ,\n          K all_tac\n        )\n      end\n\n\n      (************************************)  \n      (* Analyze hnr *)\n      structure Termtab2 = Table(\n        type key = term * term \n        val ord = prod_ord Term_Ord.fast_term_ord Term_Ord.fast_term_ord);\n  \n      type hnr_analysis = {\n        thm: thm,                     \n        precond: term,                \n        prems : term list,\n        ahead: term * bool,           \n        chead: term * bool,           \n        argrels: (term * bool) list,  \n        result_rel: term              \n      }\n  \n    \n      fun analyze_hnr (ctxt:Proof.context) thm = let\n    \n        (* Debug information: Stores string*term pairs, which are pretty-printed on error *)\n        val dbg = Unsynchronized.ref []\n        fun add_dbg msg ts = (\n          dbg := (msg,ts) :: !dbg;\n          ()\n        )\n        fun pretty_dbg (msg,ts) = Pretty.block [\n          Pretty.str msg,\n          Pretty.str \":\",\n          Pretty.brk 1,\n          Pretty.list \"[\" \"]\" (map (Syntax.pretty_term ctxt) ts)\n        ]\n        fun pretty_dbgs l = map pretty_dbg l |> Pretty.fbreaks |> Pretty.block\n    \n        fun trace_dbg msg = Pretty.block [Pretty.str msg, Pretty.fbrk, pretty_dbgs (rev (!dbg))] |> Pretty.string_of |> tracing\n    \n        fun fail msg = (trace_dbg msg; raise THM(msg,~1,[thm])) \n        fun assert cond msg = cond orelse fail msg;\n    \n    \n        (* Heads may have a leading return/RETURN.\n          The following code strips off the leading return, unless it has the form\n          \"return x\" for an argument x\n        *)\n        fun check_strip_leading args t f = (* Handle the case RETURN x, where x is an argument *)\n          if Termtab.defined args f then (t,false) else (f,true)\n    \n        fun strip_leading_RETURN args (t as @{mpat \"RETURN$(?f)\"}) = check_strip_leading args t f\n          | strip_leading_RETURN args (t as @{mpat \"RETURN ?f\"}) = check_strip_leading args t f\n          | strip_leading_RETURN _ t = (t,false)\n    \n        fun strip_leading_return args (t as @{mpat \"return$(?f)\"}) = check_strip_leading args t f\n            | strip_leading_return args (t as @{mpat \"return ?f\"}) = check_strip_leading args t f\n            | strip_leading_return _ t = (t,false)\n    \n    \n        (* The following code strips the arguments of the concrete or abstract\n          function. It knows how to handle APP-tags ($), and stops at PR_CONST-tags.\n    \n          Moreover, it only strips actual arguments that occur in the \n          precondition-section of the hn_refine-statement. This ensures\n          that non-arguments, like maxsize, are treated correctly.\n        *)    \n        fun strip_fun _ (t as @{mpat \"PR_CONST _\"}) = (t,[])\n          | strip_fun s (t as @{mpat \"?f$?x\"}) = check_arg s t f x\n          | strip_fun s (t as @{mpat \"?f ?x\"}) = check_arg s t f x\n          | strip_fun _ f = (f,[])\n        and check_arg s t f x = \n            if Termtab.defined s x then\n              strip_fun s f |> apsnd (curry op :: x)\n            else (t,[])  \n    \n        (* Arguments in the pre/postcondition are wrapped into hn_ctxt tags. \n          This function strips them off. *)    \n        fun dest_hn_ctxt @{mpat \"hn_ctxt ?R ?a ?c\"} = ((a,c),R)\n          | dest_hn_ctxt _ = fail \"Invalid hn_ctxt parameter in pre or postcondition\"\n    \n    \n        fun dest_hn_refine @{mpat \"(hn_refine ?G ?c ?G' ?R ?a)\"} = (G,c,G',R,a) \n          | dest_hn_refine _ = fail \"Conclusion is not a hn_refine statement\"\n    \n        (*\n          Strip separation conjunctions. Special case for \"emp\", which is ignored. \n        *)  \n        fun is_emp @{mpat emp} = true | is_emp _ = false\n  \n        val strip_star' = Sepref_Basic.strip_star #> filter (not o is_emp)\n  \n        (* Compare Termtab2s for equality of keys *)  \n        fun pairs_eq pairs1 pairs2 = \n                  Termtab2.forall (Termtab2.defined pairs1 o fst) pairs2\n          andalso Termtab2.forall (Termtab2.defined pairs2 o fst) pairs1\n    \n    \n        fun atomize_prem @{mpat \"Trueprop ?p\"} = p\n          | atomize_prem _ = fail \"Non-atomic premises\"\n    \n        (* Make HOL conjunction list *)  \n        fun mk_conjs [] = @{const True}\n          | mk_conjs [p] = p\n          | mk_conjs (p::ps) = HOLogic.mk_binop @{const_name \"HOL.conj\"} (p,mk_conjs ps)\n    \n    \n        (***********************)      \n        (* Start actual analysis *)\n    \n        val _ = add_dbg \"thm\" [Thm.prop_of thm]\n        val prems = Thm.prems_of thm\n        val concl = Thm.concl_of thm |> HOLogic.dest_Trueprop\n        val (G,c,G',R,a) = dest_hn_refine concl\n    \n        val pre_pairs = G \n          |> strip_star'\n          |> tap (add_dbg \"precondition\")\n          |> map dest_hn_ctxt\n          |> Termtab2.make\n    \n        val post_pairs = G' \n          |> strip_star'\n          |> tap (add_dbg \"postcondition\")\n          |> map dest_hn_ctxt\n          |> Termtab2.make\n    \n        val _ = assert (pairs_eq pre_pairs post_pairs) \n          \"Parameters in precondition do not match postcondition\"\n    \n        val aa_set = pre_pairs |> Termtab2.keys |> map fst |> Termtab.make_set\n        val ca_set = pre_pairs |> Termtab2.keys |> map snd |> Termtab.make_set\n    \n        val (a,leading_RETURN) = strip_leading_RETURN aa_set a\n        val (c,leading_return) = strip_leading_return ca_set c\n    \n        val _ = add_dbg \"stripped abstract term\" [a]\n        val _ = add_dbg \"stripped concrete term\" [c]\n    \n        val (ahead,aargs) = strip_fun aa_set a;\n        val (chead,cargs) = strip_fun ca_set c;\n    \n        val _ = add_dbg \"abstract head\" [ahead]\n        val _ = add_dbg \"abstract args\" aargs\n        val _ = add_dbg \"concrete head\" [chead]\n        val _ = add_dbg \"concrete args\" cargs\n    \n    \n        val _ = assert (length cargs = length aargs) \"Different number of abstract and concrete arguments\";\n    \n        val _ = assert (not (has_duplicates op aconv aargs)) \"Duplicate abstract arguments\"\n        val _ = assert (not (has_duplicates op aconv cargs)) \"Duplicate concrete arguments\"\n    \n        val argpairs = aargs ~~ cargs\n        val ap_set = Termtab2.make_set argpairs\n        val _ = assert (pairs_eq pre_pairs ap_set) \"Arguments from pre/postcondition do not match operation's arguments\"\n    \n        val pre_rels = map (the o (Termtab2.lookup pre_pairs)) argpairs\n        val post_rels = map (the o (Termtab2.lookup post_pairs)) argpairs\n    \n        val _ = add_dbg \"pre-rels\" pre_rels\n        val _ = add_dbg \"post-rels\" post_rels\n\n        fun adjust_hf_pres @{mpat \"snd (?R\\<^sup>k)\"} = R\n          | adjust_hf_pres t = t\n          \n        val post_rels = map adjust_hf_pres post_rels\n    \n        fun is_invalid R @{mpat \"invalid_assn ?R'\"} = R aconv R'\n          | is_invalid _ @{mpat \"snd (_\\<^sup>d)\"} = true\n          | is_invalid _ _ = false\n    \n        fun is_keep (R,R') =\n          if R aconv R' then true\n          else if is_invalid R R' then false\n          else fail \"Mismatch between pre and post relation for argument\"\n    \n        val keep = map is_keep (pre_rels ~~ post_rels)\n    \n        val argrels = pre_rels ~~ keep\n\n        val aa_set = Termtab.make_set aargs\n        val ca_set = Termtab.make_set cargs\n\n        fun is_precond t =\n          (exists_subterm (Termtab.defined ca_set) t andalso fail \"Premise contains concrete argument\")\n          orelse exists_subterm (Termtab.defined aa_set) t\n\n        val (preconds, prems) = split is_precond prems  \n    \n        val precond = \n          map atomize_prem preconds \n          |> mk_conjs\n          |> fold lambda aargs\n    \n        val _ = add_dbg \"precond\" [precond]\n        val _ = add_dbg \"prems\" prems\n    \n      in\n        {\n          thm = thm,\n          precond = precond,\n          prems = prems,\n          ahead = (ahead,leading_RETURN),\n          chead = (chead,leading_return),\n          argrels = argrels,\n          result_rel = R\n        }\n      end  \n    \n      fun pretty_hnr_analysis \n        ctxt \n        ({thm,precond,ahead,chead,argrels,result_rel,...}) \n        : Pretty.T =\n      let  \n        val _ = thm (* Suppress unused warning for thm *)\n\n        fun pretty_argrel (R,k) = Pretty.block [\n          Syntax.pretty_term ctxt R,\n          if k then Pretty.str \"\\<^sup>k\" else Pretty.str \"\\<^sup>d\"\n        ]\n    \n        val pretty_chead = case chead of \n          (t,false) => Syntax.pretty_term ctxt t \n        | (t,true) => Pretty.block [Pretty.str \"return \", Syntax.pretty_term ctxt t]\n\n        val pretty_ahead = case ahead of \n          (t,false) => Syntax.pretty_term ctxt t \n        | (t,true) => Pretty.block [Pretty.str \"RETURN \", Syntax.pretty_term ctxt t]\n\n      in\n        Pretty.fbreaks [\n          (*Display.pretty_thm ctxt thm,*)\n          Pretty.block [ \n            Pretty.enclose \"[\" \"]\" [pretty_chead, pretty_ahead],\n            Pretty.enclose \"[\" \"]\" [Syntax.pretty_term ctxt precond],\n            Pretty.brk 1,\n            Pretty.block (Pretty.separate \" \\<rightarrow>\" (map pretty_argrel argrels @ [Syntax.pretty_term ctxt result_rel]))\n          ]\n        ] |> Pretty.block\n    \n      end\n    \n    \n      fun mk_hfref_thm \n        ctxt \n        ({thm,precond,prems,ahead,chead,argrels,result_rel}) = \n      let\n    \n        fun mk_keep (R,true) = @{mk_term \"?R\\<^sup>k\"}\n          | mk_keep (R,false) = @{mk_term \"?R\\<^sup>d\"}\n    \n        (* TODO: Move, this is of general use! *)  \n        fun mk_uncurry f = @{mk_term \"uncurry ?f\"}  \n      \n        (* Uncurry function for the given number of arguments. \n          For zero arguments, add a unit-parameter.\n        *)\n        fun rpt_uncurry n t =\n          if n=0 then @{mk_term \"uncurry0 ?t\"}\n          else if n=1 then t \n          else funpow (n-1) mk_uncurry t\n      \n        (* Rewrite uncurried lambda's to \\<lambda>(_,_). _ form. Use top-down rewriting\n          to correctly handle nesting to the left. \n    \n          TODO: Combine with abstraction and  uncurry-procedure,\n            and mark the deviation about uncurry as redundant \n            intermediate step to be eliminated.\n        *)  \n        fun rew_uncurry_lambda t = let\n          val rr = map (Logic.dest_equals o Thm.prop_of) @{thms uncurry_def uncurry0_def}\n          val thy = Proof_Context.theory_of ctxt\n        in \n          Pattern.rewrite_term_top thy rr [] t \n        end  \n    \n        (* Shortcuts for simplification tactics *)\n        fun gsimp_only ctxt sec = let\n          val ss = put_simpset HOL_basic_ss ctxt |> sec\n        in asm_full_simp_tac ss end\n    \n        fun simp_only ctxt thms = gsimp_only ctxt (fn ctxt => ctxt addsimps thms)\n    \n    \n        (********************************)\n        (* Build theorem statement *)\n        (* \\<lbrakk>prems\\<rbrakk> \\<Longrightarrow> (chead,ahead) \\<in> [precond] rels \\<rightarrow> R *)\n    \n        (* Uncurry precondition *)\n        val num_args = length argrels\n        val precond = precond\n          |> rpt_uncurry num_args\n          |> rew_uncurry_lambda (* Convert to nicer \\<lambda>((...,_),_) - form*)\n\n        (* Re-attach leading RETURN/return *)\n        fun mk_RETURN (t,r) = if r then \n            let\n              val T = funpow num_args range_type (fastype_of (fst ahead))\n              val tRETURN = Const (@{const_name RETURN}, T --> Type(@{type_name nres},[T]))\n            in\n              Refine_Util.mk_compN num_args tRETURN t\n            end  \n          else t\n    \n        fun mk_return (t,r) = if r then \n            let\n              val T = funpow num_args range_type (fastype_of (fst chead))\n              val tRETURN = Const (@{const_name return}, T --> Type(@{type_name Heap},[T]))\n            in\n              Refine_Util.mk_compN num_args tRETURN t\n            end  \n          else t\n          \n        (* Hrmpf!: Gone for good from 2015\\<rightarrow>2016. Inserting ctxt-based substitute here. *)  \n        fun certify_inst ctxt (instT, inst) =\n         (map (apsnd (Thm.ctyp_of ctxt)) instT,\n          map (apsnd (Thm.cterm_of ctxt)) inst);\n\n        (*  \n        fun mk_RETURN (t,r) = if r then @{mk_term \"RETURN o ?t\"} else t\n        fun mk_return (t,r) = if r then @{mk_term \"return o ?t\"} else t\n        *)\n    \n        (* Uncurry abstract and concrete function, append leading return *)\n        val ahead = ahead |> mk_RETURN |> rpt_uncurry num_args  \n        val chead = chead |> mk_return |> rpt_uncurry num_args \n    \n        (* Add keep-flags and summarize argument relations to product *)\n        val argrel = map mk_keep argrels |> rev (* TODO: Why this rev? *) |> mk_hfprods\n    \n        (* Produce final result statement *)\n        val result = @{mk_term \"Trueprop ((?chead,?ahead) \\<in> [?precond]\\<^sub>a ?argrel \\<rightarrow> ?result_rel)\"}\n        val result = Logic.list_implies (prems,result)\n    \n        (********************************)\n        (* Prove theorem *)\n    \n        (* Create context and import result statement and original theorem *)\n        val orig_ctxt = ctxt\n        (*val thy = Proof_Context.theory_of ctxt*)\n        val (insts, ctxt) = Variable.import_inst true [result] ctxt\n        val insts' = certify_inst ctxt insts\n        val result = Term_Subst.instantiate insts result\n        val thm = Thm.instantiate insts' thm\n    \n        (* Unfold APP tags. This is required as some APP-tags have also been unfolded by analysis *)\n        val thm = Local_Defs.unfold0 ctxt @{thms APP_def} thm\n    \n        (* Tactic to prove the theorem. \n          A first step uses hfrefI to get a hnr-goal.\n          This is then normalized in several consecutive steps, which \n            get rid of uncurrying. Finally, the original theorem is used for resolution,\n            where the pre- and postcondition, and result relation are connected with \n            a consequence rule, to handle unfolded hn_ctxt-tags, re-ordered relations,\n            and introduced unit-parameters (TODO: \n              Mark artificially introduced unit-parameter specially, it may get confused \n              with intentional unit-parameter, e.g., functional empty_set ()!)\n    \n          *)\n        fun tac ctxt = \n                resolve_tac ctxt @{thms hfrefI}\n          THEN' gsimp_only ctxt (fn c => c \n            addsimps @{thms uncurry_def hn_ctxt_def uncurry0_def\n                            keep_drop_sels uc_hfprod_sel o_apply\n                            APP_def}\n            |> Splitter.add_split @{thm prod.split}\n          ) \n    \n          THEN' TRY o (\n            REPEAT_ALL_NEW (match_tac ctxt @{thms allI impI})\n            THEN' simp_only ctxt @{thms Product_Type.split prod.inject})\n    \n          THEN' TRY o REPEAT_ALL_NEW (ematch_tac ctxt @{thms conjE})\n          THEN' TRY o hyp_subst_tac ctxt\n          THEN' simp_only ctxt @{thms triv_forall_equality}\n          THEN' (\n            resolve_tac ctxt @{thms hn_refine_cons[rotated]} \n            THEN' (resolve_tac ctxt [thm] THEN_ALL_NEW assume_tac ctxt))\n          THEN_ALL_NEW simp_only ctxt \n            @{thms hn_ctxt_def entt_refl pure_unit_rel_eq_empty\n              mult_ac mult_1 mult_1_right keep_drop_sels}  \n    \n        (* Prove theorem *)  \n        val result = Thm.cterm_of ctxt result\n        val rthm = Goal.prove_internal ctxt [] result (fn _ => ALLGOALS (tac ctxt))\n    \n        (* Export statement to original context *)\n        val rthm = singleton (Variable.export ctxt orig_ctxt) rthm\n    \n        (* Post-processing *)\n        val rthm = Local_Defs.unfold0 ctxt (Named_Theorems.get ctxt @{named_theorems to_hfref_post}) rthm\n\n      in\n        rthm\n      end\n  \n      fun to_hfref ctxt = analyze_hnr ctxt #> mk_hfref_thm ctxt\n\n\n\n\n      (***********************************)\n      (* Composition *)\n\n      local\n        fun norm_set_of ctxt = {\n          trans_rules = Named_Theorems.get ctxt @{named_theorems fcomp_norm_trans},\n          cong_rules = Named_Theorems.get ctxt @{named_theorems fcomp_norm_cong},\n          norm_rules = Named_Theorems.get ctxt @{named_theorems fcomp_norm_norm},\n          refl_rules = Named_Theorems.get ctxt @{named_theorems fcomp_norm_refl}\n        }\n    \n        fun init_rules_of ctxt = Named_Theorems.get ctxt @{named_theorems fcomp_norm_init}\n        fun unfold_rules_of ctxt = Named_Theorems.get ctxt @{named_theorems fcomp_norm_unfold}\n        fun simp_rules_of ctxt = Named_Theorems.get ctxt @{named_theorems fcomp_norm_simps}\n\n      in  \n        fun norm_fcomp_rule ctxt = let\n          open PO_Normalizer Refine_Util\n          val norm1 = gen_norm_rule (init_rules_of ctxt) (norm_set_of ctxt) ctxt\n          val norm2 = Local_Defs.unfold0 ctxt (unfold_rules_of ctxt)\n          val norm3 = Conv.fconv_rule (\n            Simplifier.asm_full_rewrite \n              (put_simpset HOL_basic_ss ctxt addsimps simp_rules_of ctxt))\n    \n          val norm = changed_rule (try_rule norm1 o try_rule norm2 o try_rule norm3)\n        in\n          repeat_rule norm\n        end\n      end  \n\n      fun add_pure_constraints_rule ctxt thm = let\n        val orig_ctxt = ctxt\n    \n        val t = Thm.prop_of thm\n    \n        fun \n          cnv (@{mpat (typs) \"pure (mpaq_STRUCT (mpaq_Var ?x _) :: (?'v_c\\<times>?'v_a) set)\"}) = \n          let\n            val T = a --> c --> @{typ assn}\n            val t = Var (x,T)\n            val t = @{mk_term \"(the_pure ?t)\"}\n          in\n            [(x,T,t)]\n          end\n        | cnv (t$u) = union op= (cnv t) (cnv u)\n        | cnv (Abs (_,_,t)) = cnv t  \n        | cnv _ = []\n    \n        val pvars = cnv t\n    \n        val _ = (pvars |> map #1 |> has_duplicates op=) \n          andalso raise TERM (\"Duplicate indexname with different type\",[t]) (* This should not happen *)\n    \n        val substs = map (fn (x,_,t) => (x,t)) pvars\n    \n        val t' = subst_Vars substs t  \n    \n        fun mk_asm (x,T,_) = let\n          val t = Var (x,T)\n          val t = @{mk_term \"Trueprop (CONSTRAINT is_pure ?t)\"}\n        in\n          t\n        end\n    \n        val assms = map mk_asm pvars\n    \n        fun add_prems prems t = let\n          val prems' = Logic.strip_imp_prems t\n          val concl = Logic.strip_imp_concl t\n        in\n          Logic.list_implies (prems@prems', concl)\n        end\n    \n        val t' = add_prems assms t'\n    \n        val (t',ctxt) = yield_singleton (Variable.import_terms true) t' ctxt\n    \n        val thm' = Goal.prove_internal ctxt [] (Thm.cterm_of ctxt t') (fn _ => \n          ALLGOALS (resolve_tac ctxt [thm] THEN_ALL_NEW assume_tac ctxt))\n    \n        val thm' = norm_fcomp_rule ctxt thm'\n\n        val thm' = singleton (Variable.export ctxt orig_ctxt) thm'\n      in\n        thm'\n      end  \n\n\n      val cfg_simp_precond = \n        Attrib.setup_config_bool @{binding fcomp_simp_precond} (K true)\n\n      local\n        fun mk_simp_thm ctxt t = let\n          val st = t\n            |> HOLogic.mk_Trueprop\n            |> Thm.cterm_of ctxt\n            |> Goal.init\n      \n          val ctxt = Context_Position.set_visible false ctxt  \n          val ctxt = ctxt addsimps (\n              refine_pw_simps.get ctxt \n            @ Named_Theorems.get ctxt @{named_theorems fcomp_prenorm_simps}\n            @ @{thms split_tupled_all cnv_conj_to_meta}  \n            )\n          \n          val trace_incomplete_transfer_tac =\n            COND (Thm.prems_of #> exists (strip_all_body #> Logic.strip_imp_concl #> Term.is_open))\n              (print_tac ctxt \"Failed transfer from intermediate level:\") all_tac\n    \n          val tac = \n            ALLGOALS (resolve_tac ctxt @{thms auto_weaken_pre_comp_PRE_I} )\n            THEN ALLGOALS (Simplifier.asm_full_simp_tac ctxt)\n            THEN trace_incomplete_transfer_tac\n            THEN ALLGOALS (TRY o filter_prems_tac ctxt (K false))\n            THEN Local_Defs.unfold0_tac ctxt [Drule.triv_forall_equality]\n      \n          val st' = tac st |> Seq.take 1 |> Seq.list_of\n          val thm = case st' of [st'] => Goal.conclude st' | _ => raise THM(\"Simp_Precond: Simp-Tactic failed\",~1,[st])\n    \n          (* Check generated premises for leftover intermediate stuff *)\n          val _ = exists (Logic.is_all) (Thm.prems_of thm) \n            andalso raise THM(\"Simp_Precond: Transfer from intermediate level failed\",~1,[thm])\n    \n          val thm = \n             thm\n          (*|> map (Simplifier.asm_full_simplify ctxt)*)\n          |> Conv.fconv_rule (Object_Logic.atomize ctxt)\n          |> Local_Defs.unfold0 ctxt @{thms auto_weaken_pre_to_imp_nf}\n    \n          val thm = case Thm.concl_of thm of\n            @{mpat \"Trueprop (_ \\<longrightarrow> _)\"} => thm\n          | @{mpat \"Trueprop _\"} => thm RS @{thm auto_weaken_pre_add_dummy_imp}  \n          | _ => raise THM(\"Simp_Precond: Generated odd theorem, expected form 'P\\<longrightarrow>Q'\",~1,[thm])\n    \n    \n        in\n          thm\n        end\n      in  \n        fun simplify_precond ctxt thm = let\n          val orig_ctxt = ctxt\n          val thm = Refine_Util.OF_fst @{thms auto_weaken_pre_init} [asm_rl,thm]\n          val thm = \n            Local_Defs.unfold0 ctxt @{thms split_tupled_all} thm\n            OF @{thms auto_weaken_pre_uncurry_start}\n      \n          fun rec_uncurry thm =\n            case try (fn () => thm OF @{thms auto_weaken_pre_uncurry_step}) () of\n              NONE => thm OF @{thms auto_weaken_pre_uncurry_finish}\n            | SOME thm => rec_uncurry thm  \n      \n          val thm = rec_uncurry thm  \n            |> Conv.fconv_rule Thm.eta_conversion\n      \n          val t = case Thm.prems_of thm of\n            t::_ => t | _ => raise THM(\"Simp-Precond: Expected at least one premise\",~1,[thm])\n      \n          val (t,ctxt) = yield_singleton (Variable.import_terms false) t ctxt\n          val ((_,t),ctxt) = Variable.focus NONE t ctxt\n          val t = case t of\n            @{mpat \"Trueprop (_ \\<longrightarrow> ?t)\"} => t | _ => raise TERM(\"Simp_Precond: Expected implication\",[t])\n      \n          val simpthm = mk_simp_thm ctxt t  \n            |> singleton (Variable.export ctxt orig_ctxt)\n            \n          val thm = thm OF [simpthm]  \n          val thm = Local_Defs.unfold0 ctxt @{thms prod_casesK} thm\n        in\n          thm\n        end\n\n        fun simplify_precond_if_cfg ctxt =\n          if Config.get ctxt cfg_simp_precond then\n            simplify_precond ctxt\n          else I\n\n      end  \n\n      (* fref O fref *)\n      fun compose_ff ctxt A B = \n          (@{thm fref_compI_PRE} OF [A,B])\n        |> norm_fcomp_rule ctxt\n        |> simplify_precond_if_cfg ctxt\n        |> Conv.fconv_rule Thm.eta_conversion\n\n      (* hfref O fref *)\n      fun compose_hf ctxt A B =\n          (@{thm hfref_compI_PRE} OF [A,B])\n        |> norm_fcomp_rule ctxt\n        |> simplify_precond_if_cfg ctxt\n        |> Conv.fconv_rule Thm.eta_conversion\n        |> add_pure_constraints_rule ctxt\n        |> Conv.fconv_rule Thm.eta_conversion\n\n      fun ensure_fref ctxt thm = case rthm_type thm of\n        RT_HOPARAM => to_fref ctxt thm\n      | RT_FREF => thm\n      | _ => raise THM(\"Expected parametricity or fref theorem\",~1,[thm])\n\n      fun ensure_fref_nres ctxt thm = let\n        val thm = ensure_fref ctxt thm\n      in\n        case Thm.concl_of thm of\n          @{mpat (typs) \"Trueprop (_\\<in>fref _ _ (_::(_ nres\\<times>_)set))\"} => thm\n        | @{mpat \"Trueprop ((_,_)\\<in>fref _ _ _)\"} => \n            (thm RS @{thm ensure_fref_nresI}) |> Local_Defs.unfold0 ctxt @{thms ensure_fref_nres_unfold}\n        | _ => raise THM(\"Expected fref-theorem\",~1,[thm])\n      end\n\n      fun ensure_hfref ctxt thm = case rthm_type thm of\n        RT_HNR => to_hfref ctxt thm\n      | RT_HFREF => thm\n      | _ => raise THM(\"Expected hnr or hfref theorem\",~1,[thm])\n\n      fun ensure_hnr ctxt thm = case rthm_type thm of\n        RT_HNR => thm\n      | RT_HFREF => to_hnr ctxt thm\n      | _ => raise THM(\"Expected hnr or hfref theorem\",~1,[thm])\n\n      fun gen_compose ctxt A B = let\n        val rtA = rthm_type A\n      in\n        if rtA = RT_HOPARAM orelse rtA = RT_FREF then\n          compose_ff ctxt (ensure_fref ctxt A) (ensure_fref ctxt B)\n        else  \n          compose_hf ctxt (ensure_hfref ctxt A) ((ensure_fref_nres ctxt B))\n        \n      end\n\n      val parse_fcomp_flags = Refine_Util.parse_paren_lists \n        (Refine_Util.parse_bool_config \"prenorm\" cfg_simp_precond)\n\n      val fcomp_attrib = parse_fcomp_flags |-- Attrib.thm >> (fn B => Thm.rule_attribute [] (fn context => fn A => \n      let\n        val ctxt = Context.proof_of context\n      in  \n        gen_compose ctxt A B\n      end))\n\n    end\n  \\<close>"], ["", "attribute_setup to_fref = \\<open>\n    Scan.succeed (Thm.rule_attribute [] (Sepref_Rules.to_fref o Context.proof_of))\n\\<close> \"Convert parametricity theorem to uncurried fref-form\""], ["", "attribute_setup to_foparam = \\<open>\n      Scan.succeed (Thm.rule_attribute [] (Sepref_Rules.to_foparam o Context.proof_of))\n\\<close> \\<open>Convert param or fref rule to first order rule\\<close>"], ["", "(* Overloading existing param_fo - attribute from Parametricity.thy *)"], ["", "attribute_setup param_fo = \\<open>\n      Scan.succeed (Thm.rule_attribute [] (Sepref_Rules.to_foparam o Context.proof_of))\n\\<close> \\<open>Convert param or fref rule to first order rule\\<close>"], ["", "attribute_setup to_hnr = \\<open>\n    Scan.succeed (Thm.rule_attribute [] (Sepref_Rules.to_hnr o Context.proof_of))\n\\<close> \"Convert hfref-rule to hnr-rule\""], ["", "attribute_setup to_hfref = \\<open>Scan.succeed (\n      Thm.rule_attribute [] (Context.proof_of #> Sepref_Rules.to_hfref)\n    )\\<close> \\<open>Convert hnr to hfref theorem\\<close>"], ["", "attribute_setup ensure_fref_nres = \\<open>Scan.succeed (\n      Thm.rule_attribute [] (Context.proof_of #> Sepref_Rules.ensure_fref_nres)\n    )\\<close>"], ["", "attribute_setup sepref_dbg_norm_fcomp_rule = \\<open>Scan.succeed (\n      Thm.rule_attribute [] (Context.proof_of #> Sepref_Rules.norm_fcomp_rule)\n    )\\<close>"], ["", "attribute_setup sepref_simplify_precond = \\<open>Scan.succeed (\n      Thm.rule_attribute [] (Context.proof_of #> Sepref_Rules.simplify_precond)\n    )\\<close> \\<open>Simplify precondition of fref/hfref-theorem\\<close>"], ["", "attribute_setup FCOMP = Sepref_Rules.fcomp_attrib \"Composition of refinement rules\""], ["", "end"]]}