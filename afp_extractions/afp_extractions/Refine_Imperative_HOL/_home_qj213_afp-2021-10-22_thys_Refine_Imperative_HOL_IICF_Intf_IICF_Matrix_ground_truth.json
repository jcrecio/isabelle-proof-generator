{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/IICF/Intf/IICF_Matrix.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma mtx_rel_id[simp]: \"\\<langle>Id\\<rangle>mtx_rel = Id\"", "lemma [synth_rules]: \"INTF_OF_REL A TYPE('a) \\<Longrightarrow> INTF_OF_REL (\\<langle>A\\<rangle>mtx_rel) TYPE('a i_mtx)\"", "lemma mtx_init_adhoc_frame_match_rule[sepref_frame_match_rules]:\n    \"hn_val (nat_rel\\<times>\\<^sub>rnat_rel \\<rightarrow> A) x y \\<Longrightarrow>\\<^sub>t hn_val (nat_rel\\<times>\\<^sub>rnat_rel \\<rightarrow> the_pure (pure A)) x y\"", "lemma pat_amtx_get: \"c$e\\<equiv>op_mtx_get$'c$'e\"", "lemma pat_amtx_set: \"fun_upd$c$e$v\\<equiv>op_mtx_set$'c$'e$'v\"", "lemmas amtx_pats[pat_rules] = pat_amtx_get pat_amtx_set", "lemma pointwise_upd_fold: \"distinct ps \\<Longrightarrow> \n      q (fold f ps s) p = (if p\\<in>set ps then q (f p s) p else q s p)\"", "lemma pointwise_fun_fold: \n    fixes f :: \"'a \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'b)\"\n    fixes s :: \"'a \\<Rightarrow> 'b\"\n    assumes indep1: \"\\<And>x x' s. x \\<noteq> x' \\<Longrightarrow> f x s x' = s x'\"\n    assumes indep2:  \"\\<And>x x' s. x \\<noteq> x' \\<Longrightarrow> f x (f x' s) x = f x s x\"\n    assumes [simp]: \"distinct xs\"\n    shows \"fold f xs s x = (if x \\<in> set xs then f x s x else s x)\"", "lemma list_prod_divmod_eq: \"List.product [0..<M] [0..<N] = map (\\<lambda>i. (i div N, i mod N)) [0..<N*M]\"", "lemma nfoldli_prod_divmod_conv: \n    \"nfoldli (List.product [0..<N] [0..<M]) ctd (\\<lambda>(i,j). f i j) = nfoldli [0..<N*M] ctd (\\<lambda>i. f (i div M) (i mod M))\"", "lemma nfoldli_prod_divmod_conv': \n    \"nfoldli [0..<M] ctd (\\<lambda>i. nfoldli [0..<N] ctd (f i)) = nfoldli [0..<N*M] ctd (\\<lambda>i. f (i div N) (i mod N))\"", "lemma foldli_prod_divmod_conv': \n    \"foldli [0..<M] ctd (\\<lambda>i. foldli [0..<N] ctd (f i)) = foldli [0..<N*M] ctd (\\<lambda>i. f (i div N) (i mod N))\"\n    (is \"?lhs=?rhs\")", "lemma fold_prod_divmod_conv': \"fold (\\<lambda>i. fold (f i) [0..<N]) [0..<M] = fold (\\<lambda>i. f (i div N) (i mod N)) [0..<N*M]\"", "lemma mtx_nonzero_cases[consumes 0, case_names nonzero zero]:\n    obtains \"(i,j)\\<in>mtx_nonzero m\" | \"m (i,j) = 0\"", "lemma [def_pat_rules]: \"mtx_pointwise_unop$f \\<equiv> UNPROTECT (mtx_pointwise_unop f)\"", "lemma opr_fold_impl_eq:\n      assumes \"mtx_nonzero m \\<subseteq> {0..<N}\\<times>{0..<M}\"\n      shows \"mtx_pointwise_unop f m = opr_fold_impl m\"", "lemma opr_fold_impl_refine: \"(opr_fold_impl, mtx_pointwise_unop f) \\<in> [\\<lambda>m. mtx_nonzero m \\<subseteq> {0..<N}\\<times>{0..<M}]\\<^sub>f Id \\<rightarrow> Id\"", "lemma this_loc: \"mtx_pointwise_unop_gen_impl N M f assn A get_impl set_impl fi\"", "lemma op_hnr[sepref_fr_rules]: \"(mtx_pointwise_unnop_fold_impl1 N M get_impl set_impl fi, RETURN \\<circ> PR_CONST (mtx_pointwise_unop f)) \\<in> assn\\<^sup>d \\<rightarrow>\\<^sub>a assn\"", "lemma [def_pat_rules]: \"mtx_pointwise_binop$f \\<equiv> UNPROTECT (mtx_pointwise_binop f)\"", "lemma opr_fold_impl_eq:\n      assumes \"mtx_nonzero m \\<subseteq> {0..<N}\\<times>{0..<M}\"\n      assumes \"mtx_nonzero n \\<subseteq> {0..<N}\\<times>{0..<M}\"\n      shows \"mtx_pointwise_binop f m n = opr_fold_impl m n\"", "lemma opr_fold_impl_refine: \"(uncurry opr_fold_impl, uncurry (mtx_pointwise_binop f)) \\<in> [\\<lambda>(m,n). mtx_nonzero m \\<subseteq> {0..<N}\\<times>{0..<M} \\<and> mtx_nonzero n \\<subseteq> {0..<N}\\<times>{0..<M}]\\<^sub>f Id\\<times>\\<^sub>rId \\<rightarrow> Id\"", "lemma this_loc: \"mtx_pointwise_binop_gen_impl N M f assn A get_impl set_impl fi\"", "lemma op_hnr[sepref_fr_rules]: \"(uncurry (mtx_pointwise_binop_fold_impl1 N M get_impl set_impl fi), uncurry (RETURN oo PR_CONST (mtx_pointwise_binop f))) \\<in> assn\\<^sup>d *\\<^sub>a assn\\<^sup>k \\<rightarrow>\\<^sub>a assn\"", "lemma [def_pat_rules]: \"mtx_pointwise_cmpop$f$g \\<equiv> UNPROTECT (mtx_pointwise_cmpop f g)\"", "lemma mtx_nonzeroD:\n    \"\\<lbrakk>\\<not>i<N; mtx_nonzero m \\<subseteq> {0..<N}\\<times>{0..<M}\\<rbrakk> \\<Longrightarrow> m(i,j) = 0\"\n    \"\\<lbrakk>\\<not>j<M; mtx_nonzero m \\<subseteq> {0..<N}\\<times>{0..<M}\\<rbrakk> \\<Longrightarrow> m(i,j) = 0\"", "lemma opr_fold_impl_eq:\n      assumes \"mtx_nonzero m \\<subseteq> {0..<N}\\<times>{0..<M}\"\n      assumes \"mtx_nonzero n \\<subseteq> {0..<N}\\<times>{0..<M}\"\n      shows \"opr_fold_impl m n \\<le> RETURN (mtx_pointwise_cmpop f g m n)\"", "lemma opr_fold_impl_refine: \n      \"(uncurry opr_fold_impl, uncurry (RETURN oo mtx_pointwise_cmpop f g)) \\<in> [\\<lambda>(m,n). mtx_nonzero m \\<subseteq> {0..<N}\\<times>{0..<M} \\<and> mtx_nonzero n \\<subseteq> {0..<N}\\<times>{0..<M}]\\<^sub>f Id\\<times>\\<^sub>rId \\<rightarrow> \\<langle>bool_rel\\<rangle>nres_rel\"", "lemma this_loc: \"mtx_pointwise_cmpop_gen_impl N M f g assn A get_impl fi gi\"", "lemma op_hnr[sepref_fr_rules]: \"(uncurry (mtx_pointwise_cmpop_fold_impl1 N M get_impl fi gi), uncurry (RETURN oo PR_CONST (mtx_pointwise_cmpop f g))) \\<in> assn\\<^sup>d *\\<^sub>a assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], "translations": [["", "lemma mtx_rel_id[simp]: \"\\<langle>Id\\<rangle>mtx_rel = Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Id\\<rangle>mtx_rel = Id", "unfolding mtx_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> Id = Id", "by auto"], ["", "type_synonym 'a mtx = \"nat\\<times>nat \\<Rightarrow> 'a\""], ["", "sepref_decl_intf 'a i_mtx is \"nat\\<times>nat \\<Rightarrow> 'a\""], ["", "lemma [synth_rules]: \"INTF_OF_REL A TYPE('a) \\<Longrightarrow> INTF_OF_REL (\\<langle>A\\<rangle>mtx_rel) TYPE('a i_mtx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. INTF_OF_REL A TYPE('a) \\<Longrightarrow>\n    INTF_OF_REL (\\<langle>A\\<rangle>mtx_rel) TYPE('a i_mtx)", "by simp"], ["", "subsection \\<open>Operations\\<close>"], ["", "definition op_mtx_new :: \"'a mtx \\<Rightarrow> 'a mtx\" where [simp]: \"op_mtx_new c \\<equiv> c\""], ["", "sepref_decl_op (no_def) mtx_new: \"op_mtx_new\" :: \"(nat_rel\\<times>\\<^sub>rnat_rel \\<rightarrow> A) \\<rightarrow> \\<langle>A\\<rangle>mtx_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ> op_mtx_new, RETURN \\<circ> op_mtx_new)\n    \\<in> nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n          A \\<rightarrow>\\<^sub>f \\<langle>\\<langle>A\\<rangle>mtx_rel\\<rangle>nres_rel", "apply (rule fref_ncI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ> op_mtx_new, RETURN \\<circ> op_mtx_new)\n    \\<in> (nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> A) \\<rightarrow>\n          \\<langle>\\<langle>A\\<rangle>mtx_rel\\<rangle>nres_rel", "unfolding op_mtx_new_def[abs_def] mtx_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ> (\\<lambda>c. c), RETURN \\<circ> (\\<lambda>c. c))\n    \\<in> (nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> A) \\<rightarrow>\n          \\<langle>nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n                   A\\<rangle>nres_rel", "by parametricity"], ["", "(* TODO: Ad-hoc rule *)"], ["", "lemma mtx_init_adhoc_frame_match_rule[sepref_frame_match_rules]:\n    \"hn_val (nat_rel\\<times>\\<^sub>rnat_rel \\<rightarrow> A) x y \\<Longrightarrow>\\<^sub>t hn_val (nat_rel\\<times>\\<^sub>rnat_rel \\<rightarrow> the_pure (pure A)) x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_val (nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> A) x\n     y \\<Longrightarrow>\\<^sub>t\n    hn_val\n     (nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> the_pure (pure A)) x y", "by simp"], ["", "definition op_mtx_copy :: \"'a mtx \\<Rightarrow> 'a mtx\" where [simp]: \"op_mtx_copy c \\<equiv> c\""], ["", "sepref_decl_op (no_def) mtx_copy: \"op_mtx_copy\" :: \"\\<langle>A\\<rangle>mtx_rel \\<rightarrow> \\<langle>A\\<rangle>mtx_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op mtx_get: \"\\<lambda>(c::'a mtx) ij. c ij\" :: \"\\<langle>A\\<rangle>mtx_rel \\<rightarrow> (nat_rel\\<times>\\<^sub>rnat_rel) \\<rightarrow> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ((\\<circ>) RETURN), uncurry ((\\<circ>) RETURN))\n    \\<in> \\<langle>A\\<rangle>mtx_rel \\<times>\\<^sub>r\n          nat_rel \\<times>\\<^sub>r\n          nat_rel \\<rightarrow>\\<^sub>f \\<langle>A\\<rangle>nres_rel", "apply (rule fref_ncI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ((\\<circ>) RETURN), uncurry ((\\<circ>) RETURN))\n    \\<in> \\<langle>A\\<rangle>mtx_rel \\<times>\\<^sub>r\n          nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n          \\<langle>A\\<rangle>nres_rel", "unfolding mtx_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ((\\<circ>) RETURN), uncurry ((\\<circ>) RETURN))\n    \\<in> (nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n           A) \\<times>\\<^sub>r\n          nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n          \\<langle>A\\<rangle>nres_rel", "by parametricity"], ["", "sepref_decl_op mtx_set: \"fun_upd::'a mtx \\<Rightarrow> _\" :: \"\\<langle>A\\<rangle>mtx_rel \\<rightarrow> (nat_rel\\<times>\\<^sub>rnat_rel) \\<rightarrow> A \\<rightarrow> \\<langle>A\\<rangle>mtx_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (RETURN \\<circ>\\<circ>\\<circ> fun_upd),\n     uncurry2 (RETURN \\<circ>\\<circ>\\<circ> fun_upd))\n    \\<in> (\\<langle>A\\<rangle>mtx_rel \\<times>\\<^sub>r\n           nat_rel \\<times>\\<^sub>r nat_rel) \\<times>\\<^sub>r\n          A \\<rightarrow>\\<^sub>f \\<langle>\\<langle>A\\<rangle>mtx_rel\\<rangle>nres_rel", "apply (rule fref_ncI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (RETURN \\<circ>\\<circ>\\<circ> fun_upd),\n     uncurry2 (RETURN \\<circ>\\<circ>\\<circ> fun_upd))\n    \\<in> (\\<langle>A\\<rangle>mtx_rel \\<times>\\<^sub>r\n           nat_rel \\<times>\\<^sub>r nat_rel) \\<times>\\<^sub>r\n          A \\<rightarrow>\n          \\<langle>\\<langle>A\\<rangle>mtx_rel\\<rangle>nres_rel", "unfolding mtx_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (RETURN \\<circ>\\<circ>\\<circ> fun_upd),\n     uncurry2 (RETURN \\<circ>\\<circ>\\<circ> fun_upd))\n    \\<in> ((nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n            A) \\<times>\\<^sub>r\n           nat_rel \\<times>\\<^sub>r nat_rel) \\<times>\\<^sub>r\n          A \\<rightarrow>\n          \\<langle>nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n                   A\\<rangle>nres_rel", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. (uncurry2 (RETURN \\<circ>\\<circ>\\<circ> fun_upd),\n     uncurry2 (RETURN \\<circ>\\<circ>\\<circ> fun_upd))\n    \\<in> ((nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n            A) \\<times>\\<^sub>r\n           nat_rel \\<times>\\<^sub>r nat_rel) \\<times>\\<^sub>r\n          A \\<rightarrow>\n          \\<langle>nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n                   A\\<rangle>nres_rel", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. (uncurry2 (RETURN \\<circ>\\<circ>\\<circ> fun_upd),\n     uncurry2 (RETURN \\<circ>\\<circ>\\<circ> fun_upd))\n    \\<in> ((nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n            A) \\<times>\\<^sub>r\n           nat_rel \\<times>\\<^sub>r nat_rel) \\<times>\\<^sub>r\n          A \\<rightarrow>\n          \\<langle>nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n                   A\\<rangle>nres_rel", "have [param]: \"((=), (=)) \\<in> nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=), (=))\n    \\<in> nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n          nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> bool_rel", "by simp"], ["proof (state)\nthis:\n  ((=), (=))\n  \\<in> nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n        nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. (uncurry2 (RETURN \\<circ>\\<circ>\\<circ> fun_upd),\n     uncurry2 (RETURN \\<circ>\\<circ>\\<circ> fun_upd))\n    \\<in> ((nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n            A) \\<times>\\<^sub>r\n           nat_rel \\<times>\\<^sub>r nat_rel) \\<times>\\<^sub>r\n          A \\<rightarrow>\n          \\<langle>nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n                   A\\<rangle>nres_rel", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (RETURN \\<circ>\\<circ>\\<circ> fun_upd),\n     uncurry2 (RETURN \\<circ>\\<circ>\\<circ> fun_upd))\n    \\<in> ((nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n            A) \\<times>\\<^sub>r\n           nat_rel \\<times>\\<^sub>r nat_rel) \\<times>\\<^sub>r\n          A \\<rightarrow>\n          \\<langle>nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n                   A\\<rangle>nres_rel", "by parametricity"], ["proof (state)\nthis:\n  (uncurry2 (RETURN \\<circ>\\<circ>\\<circ> fun_upd),\n   uncurry2 (RETURN \\<circ>\\<circ>\\<circ> fun_upd))\n  \\<in> ((nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> A) \\<times>\\<^sub>r\n         nat_rel \\<times>\\<^sub>r nat_rel) \\<times>\\<^sub>r\n        A \\<rightarrow>\n        \\<langle>nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow>\n                 A\\<rangle>nres_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "definition mtx_nonzero :: \"_ mtx \\<Rightarrow> (nat\\<times>nat) set\" where \"mtx_nonzero m \\<equiv> {(i,j). m (i,j)\\<noteq>0}\""], ["", "sepref_decl_op mtx_nonzero: \"mtx_nonzero\" :: \"\\<langle>A\\<rangle>mtx_rel \\<rightarrow> \\<langle>nat_rel\\<times>\\<^sub>rnat_rel\\<rangle>set_rel\"\n    where \"IS_ID (A::(_\\<times>(_::zero)) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IS_ID A \\<Longrightarrow>\n    (RETURN \\<circ> mtx_nonzero, RETURN \\<circ> mtx_nonzero)\n    \\<in> \\<langle>A\\<rangle>mtx_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n nat_rel\\<rangle>set_rel\\<rangle>nres_rel", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. IS_ID A \\<Longrightarrow>\n    (RETURN \\<circ> mtx_nonzero, RETURN \\<circ> mtx_nonzero)\n    \\<in> \\<langle>A\\<rangle>mtx_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n nat_rel\\<rangle>set_rel\\<rangle>nres_rel", "case 1"], ["proof (state)\nthis:\n  IS_ID A\n\ngoal (1 subgoal):\n 1. IS_ID A \\<Longrightarrow>\n    (RETURN \\<circ> mtx_nonzero, RETURN \\<circ> mtx_nonzero)\n    \\<in> \\<langle>A\\<rangle>mtx_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n nat_rel\\<rangle>set_rel\\<rangle>nres_rel", "assume \"IS_ID A\""], ["proof (state)\nthis:\n  IS_ID A\n\ngoal (1 subgoal):\n 1. IS_ID A \\<Longrightarrow>\n    (RETURN \\<circ> mtx_nonzero, RETURN \\<circ> mtx_nonzero)\n    \\<in> \\<langle>A\\<rangle>mtx_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n nat_rel\\<rangle>set_rel\\<rangle>nres_rel", "hence U: \"A=Id\""], ["proof (prove)\nusing this:\n  IS_ID A\n\ngoal (1 subgoal):\n 1. A = Id", "by (simp only: IS_ID_def)"], ["proof (state)\nthis:\n  A = Id\n\ngoal (1 subgoal):\n 1. IS_ID A \\<Longrightarrow>\n    (RETURN \\<circ> mtx_nonzero, RETURN \\<circ> mtx_nonzero)\n    \\<in> \\<langle>A\\<rangle>mtx_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n nat_rel\\<rangle>set_rel\\<rangle>nres_rel", "have [param]: \"((=),(=))\\<in>A\\<rightarrow>A\\<rightarrow>bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=), (=)) \\<in> A \\<rightarrow> A \\<rightarrow> bool_rel", "using U"], ["proof (prove)\nusing this:\n  A = Id\n\ngoal (1 subgoal):\n 1. ((=), (=)) \\<in> A \\<rightarrow> A \\<rightarrow> bool_rel", "by simp"], ["proof (state)\nthis:\n  ((=), (=)) \\<in> A \\<rightarrow> A \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. IS_ID A \\<Longrightarrow>\n    (RETURN \\<circ> mtx_nonzero, RETURN \\<circ> mtx_nonzero)\n    \\<in> \\<langle>A\\<rangle>mtx_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n nat_rel\\<rangle>set_rel\\<rangle>nres_rel", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ> mtx_nonzero, RETURN \\<circ> mtx_nonzero)\n    \\<in> \\<langle>A\\<rangle>mtx_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n nat_rel\\<rangle>set_rel\\<rangle>nres_rel", "apply (rule fref_ncI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ> mtx_nonzero, RETURN \\<circ> mtx_nonzero)\n    \\<in> \\<langle>A\\<rangle>mtx_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                            nat_rel\\<rangle>set_rel\\<rangle>nres_rel", "unfolding mtx_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN \\<circ> mtx_nonzero, RETURN \\<circ> mtx_nonzero)\n    \\<in> (nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> A) \\<rightarrow>\n          \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                            nat_rel\\<rangle>set_rel\\<rangle>nres_rel", "apply parametricity"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mtx_nonzero, mtx_nonzero)\n    \\<in> (nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> A) \\<rightarrow>\n          \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>set_rel", "unfolding U"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mtx_nonzero, mtx_nonzero)\n    \\<in> (nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> Id) \\<rightarrow>\n          \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>set_rel", "by simp_all"], ["proof (state)\nthis:\n  (RETURN \\<circ> mtx_nonzero, RETURN \\<circ> mtx_nonzero)\n  \\<in> \\<langle>A\\<rangle>mtx_rel \\<rightarrow>\\<^sub>f \\<langle>\\<langle>nat_rel \\<times>\\<^sub>r\n                                     nat_rel\\<rangle>set_rel\\<rangle>nres_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Patterns\\<close>"], ["", "lemma pat_amtx_get: \"c$e\\<equiv>op_mtx_get$'c$'e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c $ e \\<equiv> op_mtx_get $' c $' e", "by simp"], ["", "lemma pat_amtx_set: \"fun_upd$c$e$v\\<equiv>op_mtx_set$'c$'e$'v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_upd $ c $ e $ v \\<equiv> op_mtx_set $' c $' e $' v", "by simp"], ["", "lemmas amtx_pats[pat_rules] = pat_amtx_get pat_amtx_set"], ["", "subsection \\<open>Pointwise Operations\\<close>"], ["", "subsubsection \\<open>Auxiliary Definitions and Lemmas\\<close>"], ["", "locale pointwise_op =\n    fixes f :: \"'p \\<Rightarrow> 's \\<Rightarrow> 's\"\n    fixes q :: \"'s \\<Rightarrow> 'p \\<Rightarrow> 'a\"\n    assumes upd_indep1[simp, intro]: \"p\\<noteq>p' \\<Longrightarrow> q (f p s) p' = q s p'\"\n    assumes upd_indep2[simp, intro]: \"p\\<noteq>p' \\<Longrightarrow> q (f p (f p' s)) p = q (f p s) p\"\n  begin"], ["", "lemma pointwise_upd_fold: \"distinct ps \\<Longrightarrow> \n      q (fold f ps s) p = (if p\\<in>set ps then q (f p s) p else q s p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct ps \\<Longrightarrow>\n    q (fold f ps s) p = (if p \\<in> set ps then q (f p s) p else q s p)", "by (induction ps arbitrary: s) auto"], ["", "end"], ["", "lemma pointwise_fun_fold: \n    fixes f :: \"'a \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'b)\"\n    fixes s :: \"'a \\<Rightarrow> 'b\"\n    assumes indep1: \"\\<And>x x' s. x \\<noteq> x' \\<Longrightarrow> f x s x' = s x'\"\n    assumes indep2:  \"\\<And>x x' s. x \\<noteq> x' \\<Longrightarrow> f x (f x' s) x = f x s x\"\n    assumes [simp]: \"distinct xs\"\n    shows \"fold f xs s x = (if x \\<in> set xs then f x s x else s x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold f xs s x = (if x \\<in> set xs then f x s x else s x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fold f xs s x = (if x \\<in> set xs then f x s x else s x)", "interpret pointwise_op f \"\\<lambda>s. s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pointwise_op f (\\<lambda>s. s)", "by unfold_locales fact+"], ["proof (state)\ngoal (1 subgoal):\n 1. fold f xs s x = (if x \\<in> set xs then f x s x else s x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold f xs s x = (if x \\<in> set xs then f x s x else s x)", "using pointwise_upd_fold[of xs s x]"], ["proof (prove)\nusing this:\n  distinct xs \\<Longrightarrow>\n  fold f xs s x = (if x \\<in> set xs then f x s x else s x)\n\ngoal (1 subgoal):\n 1. fold f xs s x = (if x \\<in> set xs then f x s x else s x)", "by auto"], ["proof (state)\nthis:\n  fold f xs s x = (if x \\<in> set xs then f x s x else s x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_prod_divmod_eq: \"List.product [0..<M] [0..<N] = map (\\<lambda>i. (i div N, i mod N)) [0..<N*M]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.product [0..<M] [0..<N] =\n    map (\\<lambda>i. (i div N, i mod N)) [0..<N * M]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. List.product [0..<M] [0..<N] =\n    map (\\<lambda>i. (i div N, i mod N)) [0..<N * M]", "have [simp]: \"i < m*n \\<Longrightarrow> (i::nat) div n < m\" for i m n"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < m * n \\<Longrightarrow> i div n < m", "by (metis mult.commute div_eq_0_iff div_mult2_eq gr_implies_not_zero mult_not_zero)"], ["proof (state)\nthis:\n  ?i < ?m * ?n \\<Longrightarrow> ?i div ?n < ?m\n\ngoal (1 subgoal):\n 1. List.product [0..<M] [0..<N] =\n    map (\\<lambda>i. (i div N, i mod N)) [0..<N * M]", "have [simp]: \"i<N*M \\<Longrightarrow> N>0 \\<and> M>0\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < N * M \\<Longrightarrow> 0 < N \\<and> 0 < M", "by (cases N; cases M; auto)"], ["proof (state)\nthis:\n  ?i < N * M \\<Longrightarrow> 0 < N \\<and> 0 < M\n\ngoal (1 subgoal):\n 1. List.product [0..<M] [0..<N] =\n    map (\\<lambda>i. (i div N, i mod N)) [0..<N * M]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.product [0..<M] [0..<N] =\n    map (\\<lambda>i. (i div N, i mod N)) [0..<N * M]", "by (rule nth_equalityI) (auto simp add: product_nth algebra_simps)"], ["proof (state)\nthis:\n  List.product [0..<M] [0..<N] =\n  map (\\<lambda>i. (i div N, i mod N)) [0..<N * M]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nfoldli_prod_divmod_conv: \n    \"nfoldli (List.product [0..<N] [0..<M]) ctd (\\<lambda>(i,j). f i j) = nfoldli [0..<N*M] ctd (\\<lambda>i. f (i div M) (i mod M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli (List.product [0..<N] [0..<M]) ctd (\\<lambda>(i, j). f i j) =\n    nfoldli [0..<N * M] ctd (\\<lambda>i. f (i div M) (i mod M))", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       nfoldli (List.product [0..<N] [0..<M]) ctd (\\<lambda>(i, j). f i j)\n        x =\n       nfoldli [0..<N * M] ctd (\\<lambda>i. f (i div M) (i mod M)) x", "apply (subst list_prod_divmod_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       nfoldli (map (\\<lambda>i. (i div M, i mod M)) [0..<M * N]) ctd\n        (\\<lambda>(x, y). f x y) x =\n       nfoldli [0..<N * M] ctd (\\<lambda>i. f (i div M) (i mod M)) x", "apply (simp add: nfoldli_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       nfoldli [0..<M * N] ctd\n        ((\\<lambda>(x, y). f x y) \\<circ> (\\<lambda>i. (i div M, i mod M)))\n        x =\n       nfoldli [0..<N * M] ctd (\\<lambda>i. f (i div M) (i mod M)) x", "apply (fo_rule cong)+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x. nfoldli = nfoldli\n 2. \\<And>x. [0..<M * N] = [0..<N * M]\n 3. \\<And>x. ctd = ctd\n 4. \\<And>x.\n       (\\<lambda>(x, y). f x y) \\<circ> (\\<lambda>i. (i div M, i mod M)) =\n       (\\<lambda>i. f (i div M) (i mod M))\n 5. \\<And>x. x = x", "apply (auto simp: algebra_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma nfoldli_prod_divmod_conv': \n    \"nfoldli [0..<M] ctd (\\<lambda>i. nfoldli [0..<N] ctd (f i)) = nfoldli [0..<N*M] ctd (\\<lambda>i. f (i div N) (i mod N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli [0..<M] ctd (\\<lambda>i. nfoldli [0..<N] ctd (f i)) =\n    nfoldli [0..<N * M] ctd (\\<lambda>i. f (i div N) (i mod N))", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       nfoldli [0..<M] ctd (\\<lambda>i. nfoldli [0..<N] ctd (f i)) x =\n       nfoldli [0..<N * M] ctd (\\<lambda>i. f (i div N) (i mod N)) x", "apply (subst nfoldli_nfoldli_prod_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       nfoldli (List.product [0..<M] [0..<N]) ctd (\\<lambda>(x, y). f x y)\n        x =\n       nfoldli [0..<N * M] ctd (\\<lambda>i. f (i div N) (i mod N)) x", "by (simp add: nfoldli_prod_divmod_conv algebra_simps)"], ["", "lemma foldli_prod_divmod_conv': \n    \"foldli [0..<M] ctd (\\<lambda>i. foldli [0..<N] ctd (f i)) = foldli [0..<N*M] ctd (\\<lambda>i. f (i div N) (i mod N))\"\n    (is \"?lhs=?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli [0..<M] ctd (\\<lambda>i. foldli [0..<N] ctd (f i)) =\n    foldli [0..<N * M] ctd (\\<lambda>i. f (i div N) (i mod N))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. foldli [0..<M] ctd (\\<lambda>i. foldli [0..<N] ctd (f i)) =\n    foldli [0..<N * M] ctd (\\<lambda>i. f (i div N) (i mod N))", "have \"RETURN (?lhs s) = RETURN (?rhs s)\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (foldli [0..<M] ctd (\\<lambda>i. foldli [0..<N] ctd (f i)) s) =\n    RETURN (foldli [0..<N * M] ctd (\\<lambda>i. f (i div N) (i mod N)) s)", "apply (subst foldli_eq_nfoldli)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli [0..<M] ctd\n     (\\<lambda>x. nfoldli [0..<N] ctd (\\<lambda>xa s. RETURN (f x xa s)))\n     s =\n    nfoldli [0..<N * M] ctd (\\<lambda>x s. RETURN (f (x div N) (x mod N) s))\n     s", "apply (subst nfoldli_prod_divmod_conv')"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli [0..<N * M] ctd (\\<lambda>i s. RETURN (f (i div N) (i mod N) s))\n     s =\n    nfoldli [0..<N * M] ctd (\\<lambda>x s. RETURN (f (x div N) (x mod N) s))\n     s", ".."], ["proof (state)\nthis:\n  RETURN (foldli [0..<M] ctd (\\<lambda>i. foldli [0..<N] ctd (f i)) ?s) =\n  RETURN (foldli [0..<N * M] ctd (\\<lambda>i. f (i div N) (i mod N)) ?s)\n\ngoal (1 subgoal):\n 1. foldli [0..<M] ctd (\\<lambda>i. foldli [0..<N] ctd (f i)) =\n    foldli [0..<N * M] ctd (\\<lambda>i. f (i div N) (i mod N))", "thus ?thesis"], ["proof (prove)\nusing this:\n  RETURN (foldli [0..<M] ctd (\\<lambda>i. foldli [0..<N] ctd (f i)) ?s) =\n  RETURN (foldli [0..<N * M] ctd (\\<lambda>i. f (i div N) (i mod N)) ?s)\n\ngoal (1 subgoal):\n 1. foldli [0..<M] ctd (\\<lambda>i. foldli [0..<N] ctd (f i)) =\n    foldli [0..<N * M] ctd (\\<lambda>i. f (i div N) (i mod N))", "by auto"], ["proof (state)\nthis:\n  foldli [0..<M] ctd (\\<lambda>i. foldli [0..<N] ctd (f i)) =\n  foldli [0..<N * M] ctd (\\<lambda>i. f (i div N) (i mod N))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fold_prod_divmod_conv': \"fold (\\<lambda>i. fold (f i) [0..<N]) [0..<M] = fold (\\<lambda>i. f (i div N) (i mod N)) [0..<N*M]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>i. fold (f i) [0..<N]) [0..<M] =\n    fold (\\<lambda>i. f (i div N) (i mod N)) [0..<N * M]", "using foldli_prod_divmod_conv'[of M \"\\<lambda>_. True\" N f, THEN fun_cong]"], ["proof (prove)\nusing this:\n  foldli [0..<M] (\\<lambda>_. True)\n   (\\<lambda>i. foldli [0..<N] (\\<lambda>_. True) (f i)) ?x =\n  foldli [0..<N * M] (\\<lambda>_. True) (\\<lambda>i. f (i div N) (i mod N))\n   ?x\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>i. fold (f i) [0..<N]) [0..<M] =\n    fold (\\<lambda>i. f (i div N) (i mod N)) [0..<N * M]", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>x.\n           foldli [0..<M] (\\<lambda>_. True)\n            (\\<lambda>i. foldli [0..<N] (\\<lambda>_. True) (f i)) x =\n           foldli [0..<N * M] (\\<lambda>_. True)\n            (\\<lambda>i. f (i div N) (i mod N)) x) \\<Longrightarrow>\n       fold (\\<lambda>i. fold (f i) [0..<N]) [0..<M] x =\n       fold (\\<lambda>i. f (i div N) (i mod N)) [0..<N * M] x", "apply (simp add: foldli_foldl foldl_conv_fold)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mtx_nonzero_cases[consumes 0, case_names nonzero zero]:\n    obtains \"(i,j)\\<in>mtx_nonzero m\" | \"m (i,j) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(i, j) \\<in> mtx_nonzero m \\<Longrightarrow> thesis;\n     m (i, j) = (0::'a) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (auto simp: mtx_nonzero_def)"], ["", "subsubsection \\<open>Unary Pointwise\\<close>"], ["", "definition mtx_pointwise_unop :: \"(nat\\<times>nat \\<Rightarrow> 'a \\<Rightarrow> 'a) \\<Rightarrow> 'a mtx \\<Rightarrow> 'a mtx\" where\n    \"mtx_pointwise_unop f m \\<equiv> \\<lambda>(i,j). f (i,j) (m(i,j))\""], ["", "context fixes f :: \"nat\\<times>nat \\<Rightarrow> 'a \\<Rightarrow> 'a\" begin"], ["", "sepref_register \"PR_CONST (mtx_pointwise_unop f)\" :: \"'a i_mtx \\<Rightarrow> 'a i_mtx\""], ["", "lemma [def_pat_rules]: \"mtx_pointwise_unop$f \\<equiv> UNPROTECT (mtx_pointwise_unop f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx_pointwise_unop $ f \\<equiv> UNPROTECT (mtx_pointwise_unop f)", "by simp"], ["", "end"], ["", "locale mtx_pointwise_unop_loc =\n    fixes N :: nat and M :: nat\n    fixes f :: \"(nat\\<times>nat) \\<Rightarrow> 'a::{zero} \\<Rightarrow> 'a\"\n    assumes pres_zero[simp]: \"\\<lbrakk> i\\<ge>N \\<or> j\\<ge>M \\<rbrakk> \\<Longrightarrow> f (i,j) 0 = 0\"\n  begin"], ["", "definition \"opr_fold_impl \\<equiv> fold (\\<lambda>i. fold (\\<lambda>j m. m( (i,j) := f (i,j) (m(i,j)) )) [0..<M]) [0..<N]\""], ["", "lemma opr_fold_impl_eq:\n      assumes \"mtx_nonzero m \\<subseteq> {0..<N}\\<times>{0..<M}\"\n      shows \"mtx_pointwise_unop f m = opr_fold_impl m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx_pointwise_unop f m = opr_fold_impl m", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. mtx_pointwise_unop f m x = opr_fold_impl m x", "unfolding opr_fold_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mtx_pointwise_unop f m x =\n       fold\n        (\\<lambda>i.\n            fold (\\<lambda>j m. m((i, j) := f (i, j) (m (i, j)))) [0..<M])\n        [0..<N] m x", "apply (simp add: fold_fold_prod_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mtx_pointwise_unop f m x =\n       fold (\\<lambda>(i, j) m. m((i, j) := f (i, j) (m (i, j))))\n        (List.product [0..<N] [0..<M]) m x", "apply (subst pointwise_fun_fold)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xa x' s.\n       xa \\<noteq> x' \\<Longrightarrow>\n       (case xa of\n        (i, j) \\<Rightarrow> \\<lambda>m. m((i, j) := f (i, j) (m (i, j))))\n        s x' =\n       s x'\n 2. \\<And>x xa x' s.\n       xa \\<noteq> x' \\<Longrightarrow>\n       (case xa of\n        (i, j) \\<Rightarrow> \\<lambda>m. m((i, j) := f (i, j) (m (i, j))))\n        ((case x' of\n          (i, j) \\<Rightarrow> \\<lambda>m. m((i, j) := f (i, j) (m (i, j))))\n          s)\n        xa =\n       (case xa of\n        (i, j) \\<Rightarrow> \\<lambda>m. m((i, j) := f (i, j) (m (i, j))))\n        s xa\n 3. \\<And>x. distinct (List.product [0..<N] [0..<M])\n 4. \\<And>x.\n       mtx_pointwise_unop f m x =\n       (if x \\<in> set (List.product [0..<N] [0..<M])\n        then (case x of\n              (i, j) \\<Rightarrow>\n                \\<lambda>m. m((i, j) := f (i, j) (m (i, j))))\n              m x\n        else m x)", "apply (auto simp: mtx_pointwise_unop_def distinct_product) [3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mtx_pointwise_unop f m x =\n       (if x \\<in> set (List.product [0..<N] [0..<M])\n        then (case x of\n              (i, j) \\<Rightarrow>\n                \\<lambda>m. m((i, j) := f (i, j) (m (i, j))))\n              m x\n        else m x)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a < N \\<and> b < M \\<longrightarrow>\n        mtx_pointwise_unop f m (a, b) = f (a, b) (m (a, b))) \\<and>\n       ((a < N \\<longrightarrow> \\<not> b < M) \\<longrightarrow>\n        mtx_pointwise_unop f m (a, b) = m (a, b))", "subgoal for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a < N \\<and> b < M \\<longrightarrow>\n     mtx_pointwise_unop f m (a, b) = f (a, b) (m (a, b))) \\<and>\n    ((a < N \\<longrightarrow> \\<not> b < M) \\<longrightarrow>\n     mtx_pointwise_unop f m (a, b) = m (a, b))", "apply (cases a b m rule: mtx_nonzero_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (a, b) \\<in> mtx_nonzero m \\<Longrightarrow>\n    (a < N \\<and> b < M \\<longrightarrow>\n     mtx_pointwise_unop f m (a, b) = f (a, b) (m (a, b))) \\<and>\n    ((a < N \\<longrightarrow> \\<not> b < M) \\<longrightarrow>\n     mtx_pointwise_unop f m (a, b) = m (a, b))\n 2. m (a, b) = (0::'a) \\<Longrightarrow>\n    (a < N \\<and> b < M \\<longrightarrow>\n     mtx_pointwise_unop f m (a, b) = f (a, b) (m (a, b))) \\<and>\n    ((a < N \\<longrightarrow> \\<not> b < M) \\<longrightarrow>\n     mtx_pointwise_unop f m (a, b) = m (a, b))", "using assms"], ["proof (prove)\nusing this:\n  mtx_nonzero m \\<subseteq> {0..<N} \\<times> {0..<M}\n\ngoal (2 subgoals):\n 1. (a, b) \\<in> mtx_nonzero m \\<Longrightarrow>\n    (a < N \\<and> b < M \\<longrightarrow>\n     mtx_pointwise_unop f m (a, b) = f (a, b) (m (a, b))) \\<and>\n    ((a < N \\<longrightarrow> \\<not> b < M) \\<longrightarrow>\n     mtx_pointwise_unop f m (a, b) = m (a, b))\n 2. m (a, b) = (0::'a) \\<Longrightarrow>\n    (a < N \\<and> b < M \\<longrightarrow>\n     mtx_pointwise_unop f m (a, b) = f (a, b) (m (a, b))) \\<and>\n    ((a < N \\<longrightarrow> \\<not> b < M) \\<longrightarrow>\n     mtx_pointwise_unop f m (a, b) = m (a, b))", "apply (auto simp: mtx_pointwise_unop_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma opr_fold_impl_refine: \"(opr_fold_impl, mtx_pointwise_unop f) \\<in> [\\<lambda>m. mtx_nonzero m \\<subseteq> {0..<N}\\<times>{0..<M}]\\<^sub>f Id \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (opr_fold_impl, mtx_pointwise_unop f)\n    \\<in> [\\<lambda>m.\n              mtx_nonzero m\n              \\<subseteq> {0..<N} \\<times>\n                          {0..<M}]\\<^sub>f Id \\<rightarrow> Id", "apply (rule frefI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>mtx_nonzero y \\<subseteq> {0..<N} \\<times> {0..<M};\n        (x, y) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (opr_fold_impl x, mtx_pointwise_unop f y) \\<in> Id", "using opr_fold_impl_eq"], ["proof (prove)\nusing this:\n  mtx_nonzero ?m \\<subseteq> {0..<N} \\<times> {0..<M} \\<Longrightarrow>\n  mtx_pointwise_unop f ?m = opr_fold_impl ?m\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>mtx_nonzero y \\<subseteq> {0..<N} \\<times> {0..<M};\n        (x, y) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (opr_fold_impl x, mtx_pointwise_unop f y) \\<in> Id", "by auto"], ["", "end"], ["", "locale mtx_pointwise_unop_gen_impl = mtx_pointwise_unop_loc +\n    fixes assn :: \"'a mtx \\<Rightarrow> 'i \\<Rightarrow> assn\"\n    fixes A :: \"'a \\<Rightarrow> 'ai \\<Rightarrow> assn\"\n    fixes get_impl :: \"'i \\<Rightarrow> nat\\<times>nat \\<Rightarrow> 'ai Heap\"\n    fixes set_impl :: \"'i \\<Rightarrow> nat\\<times>nat \\<Rightarrow> 'ai \\<Rightarrow> 'i Heap\"\n    fixes fi :: \"nat\\<times>nat \\<Rightarrow> 'ai \\<Rightarrow> 'ai Heap\"\n    assumes assn_range: \"rdomp assn m \\<Longrightarrow> mtx_nonzero m \\<subseteq> {0..<N}\\<times>{0..<M}\"\n    assumes get_impl_hnr: \n      \"(uncurry get_impl,uncurry (RETURN oo op_mtx_get)) \\<in> assn\\<^sup>k *\\<^sub>a (prod_assn (nbn_assn N) (nbn_assn M))\\<^sup>k \\<rightarrow>\\<^sub>a A\"\n    assumes set_impl_hnr: \n      \"(uncurry2 set_impl,uncurry2 (RETURN ooo op_mtx_set)) \\<in> assn\\<^sup>d *\\<^sub>a (prod_assn (nbn_assn N) (nbn_assn M))\\<^sup>k *\\<^sub>a A\\<^sup>k \\<rightarrow>\\<^sub>a assn\"\n    assumes fi_hnr:\n      \"(uncurry fi,uncurry (RETURN oo f)) \\<in> (prod_assn nat_assn nat_assn)\\<^sup>k *\\<^sub>a A\\<^sup>k \\<rightarrow>\\<^sub>a A\"  \n  begin"], ["", "lemma this_loc: \"mtx_pointwise_unop_gen_impl N M f assn A get_impl set_impl fi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx_pointwise_unop_gen_impl N M f assn A get_impl set_impl fi", "by unfold_locales"], ["", "context \n      notes [[sepref_register_adhoc f N M]]\n      notes [intf_of_assn] = intf_of_assnI[where R=assn and 'a=\"'a i_mtx\"]\n      notes [sepref_import_param] = IdI[of N] IdI[of M]\n      notes [sepref_fr_rules] = get_impl_hnr set_impl_hnr fi_hnr\n    begin"], ["", "sepref_thm opr_fold_impl1 is \"RETURN o opr_fold_impl\" :: \"assn\\<^sup>d \\<rightarrow>\\<^sub>a assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     (RETURN \\<circ>\\<circ>\\<circ> mtx_pointwise_unop_loc.opr_fold_impl N) M\n      f)\n    \\<in> assn\\<^sup>d \\<rightarrow>\\<^sub>a assn", "unfolding opr_fold_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     (RETURN \\<circ>\\<circ>\\<circ> fold)\n      (\\<lambda>i.\n          fold (\\<lambda>j m. m((i, j) := f (i, j) (m (i, j)))) [0..<M])\n      [0..<N])\n    \\<in> assn\\<^sup>d \\<rightarrow>\\<^sub>a assn", "supply [[goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     (RETURN \\<circ>\\<circ>\\<circ> fold)\n      (\\<lambda>i.\n          fold (\\<lambda>j m. m((i, j) := f (i, j) (m (i, j)))) [0..<M])\n      [0..<N])\n    \\<in> assn\\<^sup>d \\<rightarrow>\\<^sub>a assn", "by sepref"], ["", "end"], ["", "concrete_definition (in -) mtx_pointwise_unnop_fold_impl1 uses mtx_pointwise_unop_gen_impl.opr_fold_impl1.refine_raw"], ["", "prepare_code_thms (in -) mtx_pointwise_unnop_fold_impl1_def"], ["", "lemma op_hnr[sepref_fr_rules]: \"(mtx_pointwise_unnop_fold_impl1 N M get_impl set_impl fi, RETURN \\<circ> PR_CONST (mtx_pointwise_unop f)) \\<in> assn\\<^sup>d \\<rightarrow>\\<^sub>a assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mtx_pointwise_unnop_fold_impl1 N M get_impl set_impl fi,\n     (RETURN \\<circ>\\<circ> PR_CONST) (mtx_pointwise_unop f))\n    \\<in> assn\\<^sup>d \\<rightarrow>\\<^sub>a assn", "unfolding PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mtx_pointwise_unnop_fold_impl1 N M get_impl set_impl fi,\n     (RETURN \\<circ>\\<circ> mtx_pointwise_unop) f)\n    \\<in> assn\\<^sup>d \\<rightarrow>\\<^sub>a assn", "apply (rule hfref_weaken_pre'[OF _ mtx_pointwise_unnop_fold_impl1.refine[OF this_loc,FCOMP opr_fold_impl_refine]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>True; rdomp (fst (assn\\<^sup>d)) x\\<rbrakk>\n       \\<Longrightarrow> mtx_nonzero x \\<subseteq> {0..<N} \\<times> {0..<M}", "by (simp add: assn_range)"], ["", "end"], ["", "subsubsection \\<open>Binary Pointwise\\<close>"], ["", "definition mtx_pointwise_binop :: \"('a \\<Rightarrow> 'a \\<Rightarrow> 'a) \\<Rightarrow> 'a mtx \\<Rightarrow> 'a mtx \\<Rightarrow> 'a mtx\" where\n    \"mtx_pointwise_binop f m n \\<equiv> \\<lambda>(i,j). f (m(i,j)) (n(i,j))\""], ["", "context fixes f :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a\" begin"], ["", "sepref_register \"PR_CONST (mtx_pointwise_binop f)\" :: \"'a i_mtx \\<Rightarrow> 'a i_mtx \\<Rightarrow> 'a i_mtx\""], ["", "lemma [def_pat_rules]: \"mtx_pointwise_binop$f \\<equiv> UNPROTECT (mtx_pointwise_binop f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx_pointwise_binop $ f \\<equiv> UNPROTECT (mtx_pointwise_binop f)", "by simp"], ["", "end"], ["", "locale mtx_pointwise_binop_loc =\n    fixes N :: nat and M :: nat\n    fixes f :: \"'a::{zero} \\<Rightarrow> 'a \\<Rightarrow> 'a\"\n    assumes pres_zero[simp]: \"f 0 0 = 0\"\n  begin"], ["", "definition \"opr_fold_impl m n \\<equiv> fold (\\<lambda>i. fold (\\<lambda>j m. m( (i,j) := f (m(i,j)) (n(i,j)) )) [0..<M]) [0..<N] m\""], ["", "lemma opr_fold_impl_eq:\n      assumes \"mtx_nonzero m \\<subseteq> {0..<N}\\<times>{0..<M}\"\n      assumes \"mtx_nonzero n \\<subseteq> {0..<N}\\<times>{0..<M}\"\n      shows \"mtx_pointwise_binop f m n = opr_fold_impl m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx_pointwise_binop f m n = opr_fold_impl m n", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. mtx_pointwise_binop f m n x = opr_fold_impl m n x", "unfolding opr_fold_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mtx_pointwise_binop f m n x =\n       fold\n        (\\<lambda>i.\n            fold (\\<lambda>j m. m((i, j) := f (m (i, j)) (n (i, j))))\n             [0..<M])\n        [0..<N] m x", "apply (simp add: fold_fold_prod_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mtx_pointwise_binop f m n x =\n       fold (\\<lambda>(i, j) m. m((i, j) := f (m (i, j)) (n (i, j))))\n        (List.product [0..<N] [0..<M]) m x", "apply (subst pointwise_fun_fold)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xa x' s.\n       xa \\<noteq> x' \\<Longrightarrow>\n       (case xa of\n        (i, j) \\<Rightarrow>\n          \\<lambda>m. m((i, j) := f (m (i, j)) (n (i, j))))\n        s x' =\n       s x'\n 2. \\<And>x xa x' s.\n       xa \\<noteq> x' \\<Longrightarrow>\n       (case xa of\n        (i, j) \\<Rightarrow>\n          \\<lambda>m. m((i, j) := f (m (i, j)) (n (i, j))))\n        ((case x' of\n          (i, j) \\<Rightarrow>\n            \\<lambda>m. m((i, j) := f (m (i, j)) (n (i, j))))\n          s)\n        xa =\n       (case xa of\n        (i, j) \\<Rightarrow>\n          \\<lambda>m. m((i, j) := f (m (i, j)) (n (i, j))))\n        s xa\n 3. \\<And>x. distinct (List.product [0..<N] [0..<M])\n 4. \\<And>x.\n       mtx_pointwise_binop f m n x =\n       (if x \\<in> set (List.product [0..<N] [0..<M])\n        then (case x of\n              (i, j) \\<Rightarrow>\n                \\<lambda>m. m((i, j) := f (m (i, j)) (n (i, j))))\n              m x\n        else m x)", "apply (auto simp: mtx_pointwise_binop_def distinct_product) [3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mtx_pointwise_binop f m n x =\n       (if x \\<in> set (List.product [0..<N] [0..<M])\n        then (case x of\n              (i, j) \\<Rightarrow>\n                \\<lambda>m. m((i, j) := f (m (i, j)) (n (i, j))))\n              m x\n        else m x)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a < N \\<and> b < M \\<longrightarrow>\n        mtx_pointwise_binop f m n (a, b) = f (m (a, b)) (n (a, b))) \\<and>\n       ((a < N \\<longrightarrow> \\<not> b < M) \\<longrightarrow>\n        mtx_pointwise_binop f m n (a, b) = m (a, b))", "subgoal for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a < N \\<and> b < M \\<longrightarrow>\n     mtx_pointwise_binop f m n (a, b) = f (m (a, b)) (n (a, b))) \\<and>\n    ((a < N \\<longrightarrow> \\<not> b < M) \\<longrightarrow>\n     mtx_pointwise_binop f m n (a, b) = m (a, b))", "apply (cases a b m rule: mtx_nonzero_cases; cases a b n rule: mtx_nonzero_cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>(a, b) \\<in> mtx_nonzero m; (a, b) \\<in> mtx_nonzero n\\<rbrakk>\n    \\<Longrightarrow> (a < N \\<and> b < M \\<longrightarrow>\n                       mtx_pointwise_binop f m n (a, b) =\n                       f (m (a, b)) (n (a, b))) \\<and>\n                      ((a < N \\<longrightarrow>\n                        \\<not> b < M) \\<longrightarrow>\n                       mtx_pointwise_binop f m n (a, b) = m (a, b))\n 2. \\<lbrakk>(a, b) \\<in> mtx_nonzero m; n (a, b) = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> (a < N \\<and> b < M \\<longrightarrow>\n                       mtx_pointwise_binop f m n (a, b) =\n                       f (m (a, b)) (n (a, b))) \\<and>\n                      ((a < N \\<longrightarrow>\n                        \\<not> b < M) \\<longrightarrow>\n                       mtx_pointwise_binop f m n (a, b) = m (a, b))\n 3. \\<lbrakk>m (a, b) = (0::'a); (a, b) \\<in> mtx_nonzero n\\<rbrakk>\n    \\<Longrightarrow> (a < N \\<and> b < M \\<longrightarrow>\n                       mtx_pointwise_binop f m n (a, b) =\n                       f (m (a, b)) (n (a, b))) \\<and>\n                      ((a < N \\<longrightarrow>\n                        \\<not> b < M) \\<longrightarrow>\n                       mtx_pointwise_binop f m n (a, b) = m (a, b))\n 4. \\<lbrakk>m (a, b) = (0::'a); n (a, b) = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> (a < N \\<and> b < M \\<longrightarrow>\n                       mtx_pointwise_binop f m n (a, b) =\n                       f (m (a, b)) (n (a, b))) \\<and>\n                      ((a < N \\<longrightarrow>\n                        \\<not> b < M) \\<longrightarrow>\n                       mtx_pointwise_binop f m n (a, b) = m (a, b))", "using assms"], ["proof (prove)\nusing this:\n  mtx_nonzero m \\<subseteq> {0..<N} \\<times> {0..<M}\n  mtx_nonzero n \\<subseteq> {0..<N} \\<times> {0..<M}\n\ngoal (4 subgoals):\n 1. \\<lbrakk>(a, b) \\<in> mtx_nonzero m; (a, b) \\<in> mtx_nonzero n\\<rbrakk>\n    \\<Longrightarrow> (a < N \\<and> b < M \\<longrightarrow>\n                       mtx_pointwise_binop f m n (a, b) =\n                       f (m (a, b)) (n (a, b))) \\<and>\n                      ((a < N \\<longrightarrow>\n                        \\<not> b < M) \\<longrightarrow>\n                       mtx_pointwise_binop f m n (a, b) = m (a, b))\n 2. \\<lbrakk>(a, b) \\<in> mtx_nonzero m; n (a, b) = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> (a < N \\<and> b < M \\<longrightarrow>\n                       mtx_pointwise_binop f m n (a, b) =\n                       f (m (a, b)) (n (a, b))) \\<and>\n                      ((a < N \\<longrightarrow>\n                        \\<not> b < M) \\<longrightarrow>\n                       mtx_pointwise_binop f m n (a, b) = m (a, b))\n 3. \\<lbrakk>m (a, b) = (0::'a); (a, b) \\<in> mtx_nonzero n\\<rbrakk>\n    \\<Longrightarrow> (a < N \\<and> b < M \\<longrightarrow>\n                       mtx_pointwise_binop f m n (a, b) =\n                       f (m (a, b)) (n (a, b))) \\<and>\n                      ((a < N \\<longrightarrow>\n                        \\<not> b < M) \\<longrightarrow>\n                       mtx_pointwise_binop f m n (a, b) = m (a, b))\n 4. \\<lbrakk>m (a, b) = (0::'a); n (a, b) = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> (a < N \\<and> b < M \\<longrightarrow>\n                       mtx_pointwise_binop f m n (a, b) =\n                       f (m (a, b)) (n (a, b))) \\<and>\n                      ((a < N \\<longrightarrow>\n                        \\<not> b < M) \\<longrightarrow>\n                       mtx_pointwise_binop f m n (a, b) = m (a, b))", "apply (auto simp: mtx_pointwise_binop_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma opr_fold_impl_refine: \"(uncurry opr_fold_impl, uncurry (mtx_pointwise_binop f)) \\<in> [\\<lambda>(m,n). mtx_nonzero m \\<subseteq> {0..<N}\\<times>{0..<M} \\<and> mtx_nonzero n \\<subseteq> {0..<N}\\<times>{0..<M}]\\<^sub>f Id\\<times>\\<^sub>rId \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry opr_fold_impl, uncurry (mtx_pointwise_binop f))\n    \\<in> [\\<lambda>(m, n).\n              mtx_nonzero m \\<subseteq> {0..<N} \\<times> {0..<M} \\<and>\n              mtx_nonzero n\n              \\<subseteq> {0..<N} \\<times>\n                          {0..<M}]\\<^sub>f Id \\<times>\\<^sub>r\n     Id \\<rightarrow> Id", "apply (rule frefI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case y of\n                (m, n) \\<Rightarrow>\n                  mtx_nonzero m \\<subseteq> {0..<N} \\<times> {0..<M} \\<and>\n                  mtx_nonzero n \\<subseteq> {0..<N} \\<times> {0..<M};\n        (x, y) \\<in> Id \\<times>\\<^sub>r Id\\<rbrakk>\n       \\<Longrightarrow> (uncurry opr_fold_impl x,\n                          uncurry (mtx_pointwise_binop f) y)\n                         \\<in> Id", "using opr_fold_impl_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>mtx_nonzero ?m \\<subseteq> {0..<N} \\<times> {0..<M};\n   mtx_nonzero ?n \\<subseteq> {0..<N} \\<times> {0..<M}\\<rbrakk>\n  \\<Longrightarrow> mtx_pointwise_binop f ?m ?n = opr_fold_impl ?m ?n\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case y of\n                (m, n) \\<Rightarrow>\n                  mtx_nonzero m \\<subseteq> {0..<N} \\<times> {0..<M} \\<and>\n                  mtx_nonzero n \\<subseteq> {0..<N} \\<times> {0..<M};\n        (x, y) \\<in> Id \\<times>\\<^sub>r Id\\<rbrakk>\n       \\<Longrightarrow> (uncurry opr_fold_impl x,\n                          uncurry (mtx_pointwise_binop f) y)\n                         \\<in> Id", "by auto"], ["", "end"], ["", "locale mtx_pointwise_binop_gen_impl = mtx_pointwise_binop_loc +\n    fixes assn :: \"'a mtx \\<Rightarrow> 'i \\<Rightarrow> assn\"\n    fixes A :: \"'a \\<Rightarrow> 'ai \\<Rightarrow> assn\"\n    fixes get_impl :: \"'i \\<Rightarrow> nat\\<times>nat \\<Rightarrow> 'ai Heap\"\n    fixes set_impl :: \"'i \\<Rightarrow> nat\\<times>nat \\<Rightarrow> 'ai \\<Rightarrow> 'i Heap\"\n    fixes fi :: \"'ai \\<Rightarrow> 'ai \\<Rightarrow> 'ai Heap\"\n    assumes assn_range: \"rdomp assn m \\<Longrightarrow> mtx_nonzero m \\<subseteq> {0..<N}\\<times>{0..<M}\"\n    assumes get_impl_hnr: \n      \"(uncurry get_impl,uncurry (RETURN oo op_mtx_get)) \\<in> assn\\<^sup>k *\\<^sub>a (prod_assn (nbn_assn N) (nbn_assn M))\\<^sup>k \\<rightarrow>\\<^sub>a A\"\n    assumes set_impl_hnr: \n      \"(uncurry2 set_impl,uncurry2 (RETURN ooo op_mtx_set)) \\<in> assn\\<^sup>d *\\<^sub>a (prod_assn (nbn_assn N) (nbn_assn M))\\<^sup>k *\\<^sub>a A\\<^sup>k \\<rightarrow>\\<^sub>a assn\"\n    assumes fi_hnr:\n      \"(uncurry fi,uncurry (RETURN oo f)) \\<in> A\\<^sup>k *\\<^sub>a A\\<^sup>k \\<rightarrow>\\<^sub>a A\"  \n  begin"], ["", "lemma this_loc: \"mtx_pointwise_binop_gen_impl N M f assn A get_impl set_impl fi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx_pointwise_binop_gen_impl N M f assn A get_impl set_impl fi", "by unfold_locales"], ["", "context \n      notes [[sepref_register_adhoc f N M]]\n      notes [intf_of_assn] = intf_of_assnI[where R=assn and 'a=\"'a i_mtx\"]\n      notes [sepref_import_param] = IdI[of N] IdI[of M]\n      notes [sepref_fr_rules] = get_impl_hnr set_impl_hnr fi_hnr\n    begin"], ["", "sepref_thm opr_fold_impl1 is \"uncurry (RETURN oo opr_fold_impl)\" :: \"assn\\<^sup>d*\\<^sub>aassn\\<^sup>k \\<rightarrow>\\<^sub>a assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      ((RETURN \\<circ>\\<circ>\\<circ>\n        mtx_pointwise_binop_loc.opr_fold_impl N M)\n        f))\n    \\<in> assn\\<^sup>d *\\<^sub>a assn\\<^sup>k \\<rightarrow>\\<^sub>a assn", "unfolding opr_fold_impl_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>x.\n          RETURN \\<circ>\n          (\\<lambda>n.\n              fold\n               (\\<lambda>i.\n                   fold (\\<lambda>j m. m((i, j) := f (m (i, j)) (n (i, j))))\n                    [0..<M])\n               [0..<N] x)))\n    \\<in> assn\\<^sup>d *\\<^sub>a assn\\<^sup>k \\<rightarrow>\\<^sub>a assn", "by sepref"], ["", "end"], ["", "concrete_definition (in -) mtx_pointwise_binop_fold_impl1 \n      uses mtx_pointwise_binop_gen_impl.opr_fold_impl1.refine_raw is \"(uncurry ?f,_)\\<in>_\""], ["", "prepare_code_thms (in -) mtx_pointwise_binop_fold_impl1_def"], ["", "lemma op_hnr[sepref_fr_rules]: \"(uncurry (mtx_pointwise_binop_fold_impl1 N M get_impl set_impl fi), uncurry (RETURN oo PR_CONST (mtx_pointwise_binop f))) \\<in> assn\\<^sup>d *\\<^sub>a assn\\<^sup>k \\<rightarrow>\\<^sub>a assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (mtx_pointwise_binop_fold_impl1 N M get_impl set_impl fi),\n     uncurry\n      ((RETURN \\<circ>\\<circ>\\<circ> PR_CONST) (mtx_pointwise_binop f)))\n    \\<in> assn\\<^sup>d *\\<^sub>a assn\\<^sup>k \\<rightarrow>\\<^sub>a assn", "unfolding PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (mtx_pointwise_binop_fold_impl1 N M get_impl set_impl fi),\n     uncurry ((RETURN \\<circ>\\<circ>\\<circ> mtx_pointwise_binop) f))\n    \\<in> assn\\<^sup>d *\\<^sub>a assn\\<^sup>k \\<rightarrow>\\<^sub>a assn", "apply (rule hfref_weaken_pre'[OF _ mtx_pointwise_binop_fold_impl1.refine[OF this_loc,FCOMP opr_fold_impl_refine]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>True;\n        rdomp (fst (assn\\<^sup>d *\\<^sub>a assn\\<^sup>k)) x\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (a, b) \\<Rightarrow>\n                           mtx_nonzero a\n                           \\<subseteq> {0..<N} \\<times> {0..<M} \\<and>\n                           mtx_nonzero b\n                           \\<subseteq> {0..<N} \\<times> {0..<M}", "apply (auto dest: assn_range)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsubsection \\<open>Compare Pointwise\\<close>"], ["", "definition mtx_pointwise_cmpop :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a mtx \\<Rightarrow> 'a mtx \\<Rightarrow> bool\" where\n    \"mtx_pointwise_cmpop f g m n \\<equiv> (\\<forall>i j. f (m(i,j)) (n(i,j))) \\<and> (\\<exists>i j. g (m(i,j)) (n(i,j)))\""], ["", "context fixes f g :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" begin"], ["", "sepref_register \"PR_CONST (mtx_pointwise_cmpop f g)\" :: \"'a i_mtx \\<Rightarrow> 'a i_mtx \\<Rightarrow> bool\""], ["", "lemma [def_pat_rules]: \"mtx_pointwise_cmpop$f$g \\<equiv> UNPROTECT (mtx_pointwise_cmpop f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx_pointwise_cmpop $ f $ g \\<equiv> UNPROTECT (mtx_pointwise_cmpop f g)", "by simp"], ["", "end"], ["", "(* TODO: Move *)"], ["", "lemma mtx_nonzeroD:\n    \"\\<lbrakk>\\<not>i<N; mtx_nonzero m \\<subseteq> {0..<N}\\<times>{0..<M}\\<rbrakk> \\<Longrightarrow> m(i,j) = 0\"\n    \"\\<lbrakk>\\<not>j<M; mtx_nonzero m \\<subseteq> {0..<N}\\<times>{0..<M}\\<rbrakk> \\<Longrightarrow> m(i,j) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<not> i < N;\n      mtx_nonzero m \\<subseteq> {0..<N} \\<times> {0..<M}\\<rbrakk>\n     \\<Longrightarrow> m (i, j) = (0::'a)) &&&\n    (\\<lbrakk>\\<not> j < M;\n      mtx_nonzero m \\<subseteq> {0..<N} \\<times> {0..<M}\\<rbrakk>\n     \\<Longrightarrow> m (i, j) = (0::'a))", "by (auto simp: mtx_nonzero_def)"], ["", "locale mtx_pointwise_cmpop_loc =\n    fixes N :: nat and M :: nat\n    fixes f g :: \"'a::{zero} \\<Rightarrow> 'a \\<Rightarrow> bool\"\n    assumes pres_zero[simp]: \"f 0 0 = True\" \"g 0 0 = False\"\n  begin"], ["", "definition \"opr_fold_impl m n \\<equiv> do {\n      s \\<leftarrow> nfoldli (List.product [0..<N] [0..<M]) (\\<lambda>s. s\\<noteq>2) (\\<lambda>(i,j) s. do {\n        if f (m(i,j)) (n(i,j)) then\n          if s=0 then\n            if g (m(i,j)) (n(i,j)) then RETURN 1 else RETURN s\n          else\n            RETURN s\n\n        else RETURN 2\n      }) (0::nat);\n      RETURN (s=1)\n    }\""], ["", "lemma opr_fold_impl_eq:\n      assumes \"mtx_nonzero m \\<subseteq> {0..<N}\\<times>{0..<M}\"\n      assumes \"mtx_nonzero n \\<subseteq> {0..<N}\\<times>{0..<M}\"\n      shows \"opr_fold_impl m n \\<le> RETURN (mtx_pointwise_cmpop f g m n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opr_fold_impl m n \\<le> RETURN (mtx_pointwise_cmpop f g m n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. opr_fold_impl m n \\<le> RETURN (mtx_pointwise_cmpop f g m n)", "have \"(\\<forall>i<N. \\<forall>j<M. f (m (i, j)) (n (i, j))) \\<Longrightarrow> f (m (i, j)) (n (i, j))\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<N. \\<forall>j<M. f (m (i, j)) (n (i, j)) \\<Longrightarrow>\n    f (m (i, j)) (n (i, j))", "apply (cases \"i<N\"; cases \"j<M\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>i<N. \\<forall>j<M. f (m (i, j)) (n (i, j)); i < N;\n     j < M\\<rbrakk>\n    \\<Longrightarrow> f (m (i, j)) (n (i, j))\n 2. \\<lbrakk>\\<forall>i<N. \\<forall>j<M. f (m (i, j)) (n (i, j)); i < N;\n     \\<not> j < M\\<rbrakk>\n    \\<Longrightarrow> f (m (i, j)) (n (i, j))\n 3. \\<lbrakk>\\<forall>i<N. \\<forall>j<M. f (m (i, j)) (n (i, j));\n     \\<not> i < N; j < M\\<rbrakk>\n    \\<Longrightarrow> f (m (i, j)) (n (i, j))\n 4. \\<lbrakk>\\<forall>i<N. \\<forall>j<M. f (m (i, j)) (n (i, j));\n     \\<not> i < N; \\<not> j < M\\<rbrakk>\n    \\<Longrightarrow> f (m (i, j)) (n (i, j))", "using assms"], ["proof (prove)\nusing this:\n  mtx_nonzero m \\<subseteq> {0..<N} \\<times> {0..<M}\n  mtx_nonzero n \\<subseteq> {0..<N} \\<times> {0..<M}\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>i<N. \\<forall>j<M. f (m (i, j)) (n (i, j)); i < N;\n     j < M\\<rbrakk>\n    \\<Longrightarrow> f (m (i, j)) (n (i, j))\n 2. \\<lbrakk>\\<forall>i<N. \\<forall>j<M. f (m (i, j)) (n (i, j)); i < N;\n     \\<not> j < M\\<rbrakk>\n    \\<Longrightarrow> f (m (i, j)) (n (i, j))\n 3. \\<lbrakk>\\<forall>i<N. \\<forall>j<M. f (m (i, j)) (n (i, j));\n     \\<not> i < N; j < M\\<rbrakk>\n    \\<Longrightarrow> f (m (i, j)) (n (i, j))\n 4. \\<lbrakk>\\<forall>i<N. \\<forall>j<M. f (m (i, j)) (n (i, j));\n     \\<not> i < N; \\<not> j < M\\<rbrakk>\n    \\<Longrightarrow> f (m (i, j)) (n (i, j))", "by (auto simp: mtx_nonzeroD)"], ["proof (state)\nthis:\n  \\<forall>i<N. \\<forall>j<M. f (m (i, j)) (n (i, j)) \\<Longrightarrow>\n  f (m (?i, ?j)) (n (?i, ?j))\n\ngoal (1 subgoal):\n 1. opr_fold_impl m n \\<le> RETURN (mtx_pointwise_cmpop f g m n)", "moreover"], ["proof (state)\nthis:\n  \\<forall>i<N. \\<forall>j<M. f (m (i, j)) (n (i, j)) \\<Longrightarrow>\n  f (m (?i, ?j)) (n (?i, ?j))\n\ngoal (1 subgoal):\n 1. opr_fold_impl m n \\<le> RETURN (mtx_pointwise_cmpop f g m n)", "have \"g (m (i, j)) (n (i, j)) \\<Longrightarrow> (\\<exists>i<N. \\<exists>j<M. g (m (i, j)) (n (i, j)))\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. g (m (i, j)) (n (i, j)) \\<Longrightarrow>\n    \\<exists>i<N. \\<exists>j<M. g (m (i, j)) (n (i, j))", "apply (cases \"i<N\"; cases \"j<M\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>g (m (i, j)) (n (i, j)); i < N; j < M\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<N. \\<exists>j<M. g (m (i, j)) (n (i, j))\n 2. \\<lbrakk>g (m (i, j)) (n (i, j)); i < N; \\<not> j < M\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<N. \\<exists>j<M. g (m (i, j)) (n (i, j))\n 3. \\<lbrakk>g (m (i, j)) (n (i, j)); \\<not> i < N; j < M\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<N. \\<exists>j<M. g (m (i, j)) (n (i, j))\n 4. \\<lbrakk>g (m (i, j)) (n (i, j)); \\<not> i < N; \\<not> j < M\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<N. \\<exists>j<M. g (m (i, j)) (n (i, j))", "using assms"], ["proof (prove)\nusing this:\n  mtx_nonzero m \\<subseteq> {0..<N} \\<times> {0..<M}\n  mtx_nonzero n \\<subseteq> {0..<N} \\<times> {0..<M}\n\ngoal (4 subgoals):\n 1. \\<lbrakk>g (m (i, j)) (n (i, j)); i < N; j < M\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<N. \\<exists>j<M. g (m (i, j)) (n (i, j))\n 2. \\<lbrakk>g (m (i, j)) (n (i, j)); i < N; \\<not> j < M\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<N. \\<exists>j<M. g (m (i, j)) (n (i, j))\n 3. \\<lbrakk>g (m (i, j)) (n (i, j)); \\<not> i < N; j < M\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<N. \\<exists>j<M. g (m (i, j)) (n (i, j))\n 4. \\<lbrakk>g (m (i, j)) (n (i, j)); \\<not> i < N; \\<not> j < M\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<N. \\<exists>j<M. g (m (i, j)) (n (i, j))", "by (auto simp: mtx_nonzeroD)"], ["proof (state)\nthis:\n  g (m (?i, ?j)) (n (?i, ?j)) \\<Longrightarrow>\n  \\<exists>i<N. \\<exists>j<M. g (m (i, j)) (n (i, j))\n\ngoal (1 subgoal):\n 1. opr_fold_impl m n \\<le> RETURN (mtx_pointwise_cmpop f g m n)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>i<N. \\<forall>j<M. f (m (i, j)) (n (i, j)) \\<Longrightarrow>\n  f (m (?i, ?j)) (n (?i, ?j))\n  g (m (?i, ?j)) (n (?i, ?j)) \\<Longrightarrow>\n  \\<exists>i<N. \\<exists>j<M. g (m (i, j)) (n (i, j))", "have EQ: \"mtx_pointwise_cmpop f g m n \n        \\<longleftrightarrow> (\\<forall>i<N. \\<forall>j<M. f (m(i,j)) (n(i,j))) \\<and> (\\<exists>i<N. \\<exists>j<M. g (m(i,j)) (n(i,j)))\""], ["proof (prove)\nusing this:\n  \\<forall>i<N. \\<forall>j<M. f (m (i, j)) (n (i, j)) \\<Longrightarrow>\n  f (m (?i, ?j)) (n (?i, ?j))\n  g (m (?i, ?j)) (n (?i, ?j)) \\<Longrightarrow>\n  \\<exists>i<N. \\<exists>j<M. g (m (i, j)) (n (i, j))\n\ngoal (1 subgoal):\n 1. mtx_pointwise_cmpop f g m n =\n    ((\\<forall>i<N. \\<forall>j<M. f (m (i, j)) (n (i, j))) \\<and>\n     (\\<exists>i<N. \\<exists>j<M. g (m (i, j)) (n (i, j))))", "unfolding mtx_pointwise_cmpop_def"], ["proof (prove)\nusing this:\n  \\<forall>i<N. \\<forall>j<M. f (m (i, j)) (n (i, j)) \\<Longrightarrow>\n  f (m (?i, ?j)) (n (?i, ?j))\n  g (m (?i, ?j)) (n (?i, ?j)) \\<Longrightarrow>\n  \\<exists>i<N. \\<exists>j<M. g (m (i, j)) (n (i, j))\n\ngoal (1 subgoal):\n 1. ((\\<forall>i j. f (m (i, j)) (n (i, j))) \\<and>\n     (\\<exists>i j. g (m (i, j)) (n (i, j)))) =\n    ((\\<forall>i<N. \\<forall>j<M. f (m (i, j)) (n (i, j))) \\<and>\n     (\\<exists>i<N. \\<exists>j<M. g (m (i, j)) (n (i, j))))", "by meson"], ["proof (state)\nthis:\n  mtx_pointwise_cmpop f g m n =\n  ((\\<forall>i<N. \\<forall>j<M. f (m (i, j)) (n (i, j))) \\<and>\n   (\\<exists>i<N. \\<exists>j<M. g (m (i, j)) (n (i, j))))\n\ngoal (1 subgoal):\n 1. opr_fold_impl m n \\<le> RETURN (mtx_pointwise_cmpop f g m n)", "have aux: \"List.product [0..<N] [0..<M] = l1 @ (i, j) # l2 \\<Longrightarrow> i<N \\<and> j<M\" for l1 i j l2"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.product [0..<N] [0..<M] = l1 @ (i, j) # l2 \\<Longrightarrow>\n    i < N \\<and> j < M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. List.product [0..<N] [0..<M] = l1 @ (i, j) # l2 \\<Longrightarrow>\n    i < N \\<and> j < M", "assume \"List.product [0..<N] [0..<M] = l1 @ (i, j) # l2\""], ["proof (state)\nthis:\n  List.product [0..<N] [0..<M] = l1 @ (i, j) # l2\n\ngoal (1 subgoal):\n 1. List.product [0..<N] [0..<M] = l1 @ (i, j) # l2 \\<Longrightarrow>\n    i < N \\<and> j < M", "hence \"(i,j)\\<in>set (List.product [0..<N] [0..<M])\""], ["proof (prove)\nusing this:\n  List.product [0..<N] [0..<M] = l1 @ (i, j) # l2\n\ngoal (1 subgoal):\n 1. (i, j) \\<in> set (List.product [0..<N] [0..<M])", "by simp"], ["proof (state)\nthis:\n  (i, j) \\<in> set (List.product [0..<N] [0..<M])\n\ngoal (1 subgoal):\n 1. List.product [0..<N] [0..<M] = l1 @ (i, j) # l2 \\<Longrightarrow>\n    i < N \\<and> j < M", "thus ?thesis"], ["proof (prove)\nusing this:\n  (i, j) \\<in> set (List.product [0..<N] [0..<M])\n\ngoal (1 subgoal):\n 1. i < N \\<and> j < M", "by simp"], ["proof (state)\nthis:\n  i < N \\<and> j < M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  List.product [0..<N] [0..<M] = ?l1.0 @ (?i, ?j) # ?l2.0 \\<Longrightarrow>\n  ?i < N \\<and> ?j < M\n\ngoal (1 subgoal):\n 1. opr_fold_impl m n \\<le> RETURN (mtx_pointwise_cmpop f g m n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. opr_fold_impl m n \\<le> RETURN (mtx_pointwise_cmpop f g m n)", "unfolding opr_fold_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli (List.product [0..<N] [0..<M]) (\\<lambda>s. s \\<noteq> 2)\n     (\\<lambda>(i, j) s.\n         if f (m (i, j)) (n (i, j))\n         then if s = 0\n              then if g (m (i, j)) (n (i, j)) then RETURN 1 else RETURN s\n              else RETURN s\n         else RETURN 2)\n     0 \\<bind>\n    (\\<lambda>s. RETURN (s = 1))\n    \\<le> RETURN (mtx_pointwise_cmpop f g m n)", "apply (refine_vcg\n          nfoldli_rule[where I=\"\\<lambda>l1 _ s. \n              if s=2 then \\<exists>i<N. \\<exists>j<M. \\<not>f (m(i,j)) (n(i,j)) \n              else (\n                (s=0 \\<or> s=1) \\<and>\n                (\\<forall>(i,j)\\<in>set l1. f (m(i,j)) (n(i,j))) \\<and>\n                (s=1 \\<longleftrightarrow> (\\<exists>(i,j)\\<in>set l1. g (m(i,j)) (n(i,j))))\n              )\"]\n          )"], ["proof (prove)\ngoal (7 subgoals):\n 1. if 0 = 2 then \\<exists>i<N. \\<exists>j<M. \\<not> f (m (i, j)) (n (i, j))\n    else (0 = 0 \\<or> 0 = 1) \\<and>\n         (\\<forall>(i, j)\\<in>set []. f (m (i, j)) (n (i, j))) \\<and>\n         (0 = 1) = (\\<exists>(i, j)\\<in>set []. g (m (i, j)) (n (i, j)))\n 2. \\<And>x l1 l2 \\<sigma> x1 x2.\n       \\<lbrakk>List.product [0..<N] [0..<M] = l1 @ x # l2;\n        if \\<sigma> = 2\n        then \\<exists>i<N. \\<exists>j<M. \\<not> f (m (i, j)) (n (i, j))\n        else (\\<sigma> = 0 \\<or> \\<sigma> = 1) \\<and>\n             (\\<forall>(i, j)\\<in>set l1. f (m (i, j)) (n (i, j))) \\<and>\n             (\\<sigma> = 1) =\n             (\\<exists>(i, j)\\<in>set l1. g (m (i, j)) (n (i, j)));\n        \\<sigma> \\<noteq> 2; x = (x1, x2); f (m (x1, x2)) (n (x1, x2));\n        \\<sigma> = 0; g (m (x1, x2)) (n (x1, x2))\\<rbrakk>\n       \\<Longrightarrow> if 1 = 2\n                         then \\<exists>i<N.\n                                 \\<exists>j<M.\n                                    \\<not> f (m (i, j)) (n (i, j))\n                         else (1 = 0 \\<or> 1 = 1) \\<and>\n                              (\\<forall>(i, j)\\<in>set (l1 @ [x]).\n                                  f (m (i, j)) (n (i, j))) \\<and>\n                              (1 = 1) =\n                              (\\<exists>(i, j)\\<in>set (l1 @ [x]).\n                                  g (m (i, j)) (n (i, j)))\n 3. \\<And>x l1 l2 \\<sigma> x1 x2.\n       \\<lbrakk>List.product [0..<N] [0..<M] = l1 @ x # l2;\n        if \\<sigma> = 2\n        then \\<exists>i<N. \\<exists>j<M. \\<not> f (m (i, j)) (n (i, j))\n        else (\\<sigma> = 0 \\<or> \\<sigma> = 1) \\<and>\n             (\\<forall>(i, j)\\<in>set l1. f (m (i, j)) (n (i, j))) \\<and>\n             (\\<sigma> = 1) =\n             (\\<exists>(i, j)\\<in>set l1. g (m (i, j)) (n (i, j)));\n        \\<sigma> \\<noteq> 2; x = (x1, x2); f (m (x1, x2)) (n (x1, x2));\n        \\<sigma> = 0; \\<not> g (m (x1, x2)) (n (x1, x2))\\<rbrakk>\n       \\<Longrightarrow> if \\<sigma> = 2\n                         then \\<exists>i<N.\n                                 \\<exists>j<M.\n                                    \\<not> f (m (i, j)) (n (i, j))\n                         else (\\<sigma> = 0 \\<or> \\<sigma> = 1) \\<and>\n                              (\\<forall>(i, j)\\<in>set (l1 @ [x]).\n                                  f (m (i, j)) (n (i, j))) \\<and>\n                              (\\<sigma> = 1) =\n                              (\\<exists>(i, j)\\<in>set (l1 @ [x]).\n                                  g (m (i, j)) (n (i, j)))\n 4. \\<And>x l1 l2 \\<sigma> x1 x2.\n       \\<lbrakk>List.product [0..<N] [0..<M] = l1 @ x # l2;\n        if \\<sigma> = 2\n        then \\<exists>i<N. \\<exists>j<M. \\<not> f (m (i, j)) (n (i, j))\n        else (\\<sigma> = 0 \\<or> \\<sigma> = 1) \\<and>\n             (\\<forall>(i, j)\\<in>set l1. f (m (i, j)) (n (i, j))) \\<and>\n             (\\<sigma> = 1) =\n             (\\<exists>(i, j)\\<in>set l1. g (m (i, j)) (n (i, j)));\n        \\<sigma> \\<noteq> 2; x = (x1, x2); f (m (x1, x2)) (n (x1, x2));\n        \\<sigma> \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> if \\<sigma> = 2\n                         then \\<exists>i<N.\n                                 \\<exists>j<M.\n                                    \\<not> f (m (i, j)) (n (i, j))\n                         else (\\<sigma> = 0 \\<or> \\<sigma> = 1) \\<and>\n                              (\\<forall>(i, j)\\<in>set (l1 @ [x]).\n                                  f (m (i, j)) (n (i, j))) \\<and>\n                              (\\<sigma> = 1) =\n                              (\\<exists>(i, j)\\<in>set (l1 @ [x]).\n                                  g (m (i, j)) (n (i, j)))\n 5. \\<And>x l1 l2 \\<sigma> x1 x2.\n       \\<lbrakk>List.product [0..<N] [0..<M] = l1 @ x # l2;\n        if \\<sigma> = 2\n        then \\<exists>i<N. \\<exists>j<M. \\<not> f (m (i, j)) (n (i, j))\n        else (\\<sigma> = 0 \\<or> \\<sigma> = 1) \\<and>\n             (\\<forall>(i, j)\\<in>set l1. f (m (i, j)) (n (i, j))) \\<and>\n             (\\<sigma> = 1) =\n             (\\<exists>(i, j)\\<in>set l1. g (m (i, j)) (n (i, j)));\n        \\<sigma> \\<noteq> 2; x = (x1, x2);\n        \\<not> f (m (x1, x2)) (n (x1, x2))\\<rbrakk>\n       \\<Longrightarrow> if 2 = 2\n                         then \\<exists>i<N.\n                                 \\<exists>j<M.\n                                    \\<not> f (m (i, j)) (n (i, j))\n                         else (2 = 0 \\<or> 2 = 1) \\<and>\n                              (\\<forall>(i, j)\\<in>set (l1 @ [x]).\n                                  f (m (i, j)) (n (i, j))) \\<and>\n                              (2 = 1) =\n                              (\\<exists>(i, j)\\<in>set (l1 @ [x]).\n                                  g (m (i, j)) (n (i, j)))\n 6. \\<And>l1 l2 \\<sigma>.\n       \\<lbrakk>List.product [0..<N] [0..<M] = l1 @ l2;\n        if \\<sigma> = 2\n        then \\<exists>i<N. \\<exists>j<M. \\<not> f (m (i, j)) (n (i, j))\n        else (\\<sigma> = 0 \\<or> \\<sigma> = 1) \\<and>\n             (\\<forall>(i, j)\\<in>set l1. f (m (i, j)) (n (i, j))) \\<and>\n             (\\<sigma> = 1) =\n             (\\<exists>(i, j)\\<in>set l1. g (m (i, j)) (n (i, j)));\n        \\<not> \\<sigma> \\<noteq> 2\\<rbrakk>\n       \\<Longrightarrow> mtx_pointwise_cmpop f g m n = (\\<sigma> = 1)\n 7. \\<And>\\<sigma>.\n       \\<lbrakk>if \\<sigma> = 2\n                then \\<exists>i<N.\n                        \\<exists>j<M. \\<not> f (m (i, j)) (n (i, j))\n                else (\\<sigma> = 0 \\<or> \\<sigma> = 1) \\<and>\n                     (\\<forall>(i, j)\n                               \\<in>set (List.product [0..<N] [0..<M]).\n                         f (m (i, j)) (n (i, j))) \\<and>\n                     (\\<sigma> = 1) =\n                     (\\<exists>(i, j)\n                               \\<in>set (List.product [0..<N] [0..<M]).\n                         g (m (i, j)) (n (i, j)));\n        \\<sigma> \\<noteq> 2\\<rbrakk>\n       \\<Longrightarrow> mtx_pointwise_cmpop f g m n = (\\<sigma> = 1)", "apply (vc_solve dest: aux solve: asm_rl simp: EQ) [6]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>if \\<sigma> = 2\n                then \\<exists>i<N.\n                        \\<exists>j<M. \\<not> f (m (i, j)) (n (i, j))\n                else (\\<sigma> = 0 \\<or> \\<sigma> = 1) \\<and>\n                     (\\<forall>(i, j)\n                               \\<in>set (List.product [0..<N] [0..<M]).\n                         f (m (i, j)) (n (i, j))) \\<and>\n                     (\\<sigma> = 1) =\n                     (\\<exists>(i, j)\n                               \\<in>set (List.product [0..<N] [0..<M]).\n                         g (m (i, j)) (n (i, j)));\n        \\<sigma> \\<noteq> 2\\<rbrakk>\n       \\<Longrightarrow> mtx_pointwise_cmpop f g m n = (\\<sigma> = 1)", "apply (fastforce simp: EQ)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  opr_fold_impl m n \\<le> RETURN (mtx_pointwise_cmpop f g m n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma opr_fold_impl_refine: \n      \"(uncurry opr_fold_impl, uncurry (RETURN oo mtx_pointwise_cmpop f g)) \\<in> [\\<lambda>(m,n). mtx_nonzero m \\<subseteq> {0..<N}\\<times>{0..<M} \\<and> mtx_nonzero n \\<subseteq> {0..<N}\\<times>{0..<M}]\\<^sub>f Id\\<times>\\<^sub>rId \\<rightarrow> \\<langle>bool_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry opr_fold_impl,\n     uncurry ((RETURN \\<circ>\\<circ>\\<circ> mtx_pointwise_cmpop f) g))\n    \\<in> [\\<lambda>(m, n).\n              mtx_nonzero m \\<subseteq> {0..<N} \\<times> {0..<M} \\<and>\n              mtx_nonzero n\n              \\<subseteq> {0..<N} \\<times>\n                          {0..<M}]\\<^sub>f Id \\<times>\\<^sub>r\n     Id \\<rightarrow> \\<langle>bool_rel\\<rangle>nres_rel", "apply (rule frefI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case y of\n                (m, n) \\<Rightarrow>\n                  mtx_nonzero m \\<subseteq> {0..<N} \\<times> {0..<M} \\<and>\n                  mtx_nonzero n \\<subseteq> {0..<N} \\<times> {0..<M};\n        (x, y) \\<in> Id \\<times>\\<^sub>r Id\\<rbrakk>\n       \\<Longrightarrow> (uncurry opr_fold_impl x,\n                          uncurry\n                           ((RETURN \\<circ>\\<circ>\\<circ>\n                             mtx_pointwise_cmpop f)\n                             g)\n                           y)\n                         \\<in> \\<langle>bool_rel\\<rangle>nres_rel", "using opr_fold_impl_eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>mtx_nonzero ?m \\<subseteq> {0..<N} \\<times> {0..<M};\n   mtx_nonzero ?n \\<subseteq> {0..<N} \\<times> {0..<M}\\<rbrakk>\n  \\<Longrightarrow> opr_fold_impl ?m ?n\n                    \\<le> RETURN (mtx_pointwise_cmpop f g ?m ?n)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case y of\n                (m, n) \\<Rightarrow>\n                  mtx_nonzero m \\<subseteq> {0..<N} \\<times> {0..<M} \\<and>\n                  mtx_nonzero n \\<subseteq> {0..<N} \\<times> {0..<M};\n        (x, y) \\<in> Id \\<times>\\<^sub>r Id\\<rbrakk>\n       \\<Longrightarrow> (uncurry opr_fold_impl x,\n                          uncurry\n                           ((RETURN \\<circ>\\<circ>\\<circ>\n                             mtx_pointwise_cmpop f)\n                             g)\n                           y)\n                         \\<in> \\<langle>bool_rel\\<rangle>nres_rel", "by (auto intro: nres_relI)"], ["", "end"], ["", "locale mtx_pointwise_cmpop_gen_impl = mtx_pointwise_cmpop_loc +\n    fixes assn :: \"'a mtx \\<Rightarrow> 'i \\<Rightarrow> assn\"\n    fixes A :: \"'a \\<Rightarrow> 'ai \\<Rightarrow> assn\"\n    fixes get_impl :: \"'i \\<Rightarrow> nat\\<times>nat \\<Rightarrow> 'ai Heap\"\n    fixes fi :: \"'ai \\<Rightarrow> 'ai \\<Rightarrow> bool Heap\"\n    fixes gi :: \"'ai \\<Rightarrow> 'ai \\<Rightarrow> bool Heap\"\n    assumes assn_range: \"rdomp assn m \\<Longrightarrow> mtx_nonzero m \\<subseteq> {0..<N}\\<times>{0..<M}\"\n    assumes get_impl_hnr: \n      \"(uncurry get_impl,uncurry (RETURN oo op_mtx_get)) \\<in> assn\\<^sup>k *\\<^sub>a (prod_assn (nbn_assn N) (nbn_assn M))\\<^sup>k \\<rightarrow>\\<^sub>a A\"\n    assumes fi_hnr:\n      \"(uncurry fi,uncurry (RETURN oo f)) \\<in> A\\<^sup>k *\\<^sub>a A\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\"  \n    assumes gi_hnr:\n      \"(uncurry gi,uncurry (RETURN oo g)) \\<in> A\\<^sup>k *\\<^sub>a A\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\"  \n  begin"], ["", "lemma this_loc: \"mtx_pointwise_cmpop_gen_impl N M f g assn A get_impl fi gi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx_pointwise_cmpop_gen_impl N M f g assn A get_impl fi gi", "by unfold_locales"], ["", "context \n      notes [[sepref_register_adhoc f g N M]]\n      notes [intf_of_assn] = intf_of_assnI[where R=assn and 'a=\"'a i_mtx\"]\n      notes [sepref_import_param] = IdI[of N] IdI[of M]\n      notes [sepref_fr_rules] = get_impl_hnr fi_hnr gi_hnr\n    begin"], ["", "sepref_thm opr_fold_impl1 is \"uncurry opr_fold_impl\" :: \"assn\\<^sup>d*\\<^sub>aassn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry opr_fold_impl)\n    \\<in> assn\\<^sup>d *\\<^sub>a\n          assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "unfolding opr_fold_impl_def[abs_def] nfoldli_nfoldli_prod_conv[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>m n.\n          nfoldli [0..<N] (\\<lambda>s. s \\<noteq> 2)\n           (\\<lambda>i.\n               nfoldli [0..<M] (\\<lambda>s. s \\<noteq> 2)\n                (\\<lambda>j s.\n                    if f (m (i, j)) (n (i, j))\n                    then if s = 0\n                         then if g (m (i, j)) (n (i, j)) then RETURN 1\n                              else RETURN s\n                         else RETURN s\n                    else RETURN 2))\n           0 \\<bind>\n          (\\<lambda>s. RETURN (s = 1))))\n    \\<in> assn\\<^sup>d *\\<^sub>a\n          assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by sepref"], ["", "end"], ["", "concrete_definition (in -) mtx_pointwise_cmpop_fold_impl1 \n      uses mtx_pointwise_cmpop_gen_impl.opr_fold_impl1.refine_raw is \"(uncurry ?f,_)\\<in>_\""], ["", "prepare_code_thms (in -) mtx_pointwise_cmpop_fold_impl1_def"], ["", "lemma op_hnr[sepref_fr_rules]: \"(uncurry (mtx_pointwise_cmpop_fold_impl1 N M get_impl fi gi), uncurry (RETURN oo PR_CONST (mtx_pointwise_cmpop f g))) \\<in> assn\\<^sup>d *\\<^sub>a assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (mtx_pointwise_cmpop_fold_impl1 N M get_impl fi gi),\n     uncurry\n      ((RETURN \\<circ>\\<circ>\\<circ> PR_CONST) (mtx_pointwise_cmpop f g)))\n    \\<in> assn\\<^sup>d *\\<^sub>a\n          assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "unfolding PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (mtx_pointwise_cmpop_fold_impl1 N M get_impl fi gi),\n     uncurry ((RETURN \\<circ>\\<circ>\\<circ> mtx_pointwise_cmpop f) g))\n    \\<in> assn\\<^sup>d *\\<^sub>a\n          assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply (rule hfref_weaken_pre'[OF _ mtx_pointwise_cmpop_fold_impl1.refine[OF this_loc,FCOMP opr_fold_impl_refine]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>True;\n        rdomp (fst (assn\\<^sup>d *\\<^sub>a assn\\<^sup>k)) x\\<rbrakk>\n       \\<Longrightarrow> case x of\n                         (a, b) \\<Rightarrow>\n                           mtx_nonzero a\n                           \\<subseteq> {0..<N} \\<times> {0..<M} \\<and>\n                           mtx_nonzero b\n                           \\<subseteq> {0..<N} \\<times> {0..<M}", "apply (auto dest: assn_range)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}