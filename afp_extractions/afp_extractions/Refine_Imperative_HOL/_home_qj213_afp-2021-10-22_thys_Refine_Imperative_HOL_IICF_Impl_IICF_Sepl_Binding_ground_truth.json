{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/IICF/Impl/IICF_Sepl_Binding.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma is_hashmap_finite[simp]: \"h \\<Turnstile> is_hashmap m mi \\<Longrightarrow> finite (dom m)\"", "lemma is_hashset_finite[simp]: \"h \\<Turnstile> is_hashset s si \\<Longrightarrow> finite s\"", "lemma first_memb_rl_aux:\n    assumes \"lmax \\<le> length l\" \"i\\<le>lmax\" \n    shows \n      \"< a \\<mapsto>\\<^sub>a l > \n        first_memb lmax a i \n      <\\<lambda>k. a\\<mapsto>\\<^sub>a l * \\<up>(k\\<le>lmax \\<and> (\\<forall>j. i\\<le>j \\<and> j<k \\<longrightarrow> \\<not>l!j) \\<and> i\\<le>k \\<and> (k=lmax \\<or> l!k)) >\"", "lemma first_memb_rl[sep_heap_rules]:\n    assumes \"lmax \\<le> length l\" \"i\\<le>lmax\" \n    shows \"< a \\<mapsto>\\<^sub>a l > \n      first_memb lmax a i \n    <\\<lambda>k. a\\<mapsto>\\<^sub>a l * \\<up>(ias_of_list l \\<inter> {i..<k} = {} \\<and> i\\<le>k \\<and> (k<lmax \\<and> k\\<in>ias_of_list l \\<or> k=lmax) ) >\"", "lemma ias_of_list_bound: \"ias_of_list l \\<subseteq> {0..<length l}\"", "lemma ias_of_list_finite[simp, intro!]: \"finite (ias_of_list l)\"", "lemma is_ias_finite[simp]: \"h \\<Turnstile> is_ias S x \\<Longrightarrow> finite S\"", "lemma to_list_ga_rec_rule:\n    assumes \"imp_set_iterate is_set is_it it_init it_has_next it_next\"\n    assumes \"imp_list_prepend is_list l_prepend\"\n    assumes FIN: \"finite it\"\n    assumes DIS: \"distinct l\" \"set l \\<inter> it = {}\"\n    shows \"\n    < is_it s si it iti * is_list l li > \n      to_list_ga_rec it_has_next it_next l_prepend iti li\n    < \\<lambda>r. \\<exists>\\<^sub>Al'. is_set s si \n      * is_list l' r\n      * \\<up>(distinct l' \\<and> set l' = set l \\<union> it) >\\<^sub>t\"", "lemma to_list_ga_rule:\n    assumes IT: \"imp_set_iterate is_set is_it it_init it_has_next it_next\"\n    assumes EM: \"imp_list_empty is_list l_empty\"\n    assumes PREP: \"imp_list_prepend is_list l_prepend\"\n    assumes FIN: \"finite s\"\n    shows \"\n    <is_set s si>\n    to_list_ga it_init it_has_next it_next\n      l_empty l_prepend si\n    <\\<lambda>r. \\<exists>\\<^sub>Al. is_set s si * is_list l r * true * \\<up>(distinct l \\<and> set l = s)>\"", "lemmas [fcomp_norm_unfold] = assn_def[symmetric]", "lemmas [safe_constraint_rules] = CN_FALSEI[of is_pure \"assn K V\" for K V]", "lemma empty_hnr_aux: \"(uncurry0 empty,uncurry0 (RETURN op_map_empty)) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_map\"", "lemma is_empty_hnr_aux: \"(is_empty,RETURN o op_map_is_empty) \\<in> is_map\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\"", "lemma update_hnr_aux: \"(uncurry2 update,uncurry2 (RETURN ooo op_map_update)) \\<in> id_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k *\\<^sub>a is_map\\<^sup>d \\<rightarrow>\\<^sub>a is_map\"", "lemma delete_hnr_aux: \"(uncurry delete,uncurry (RETURN oo op_map_delete)) \\<in> id_assn\\<^sup>k *\\<^sub>a is_map\\<^sup>d \\<rightarrow>\\<^sub>a is_map\"", "lemma lookup_hnr_aux: \"(uncurry lookup,uncurry (RETURN oo op_map_lookup)) \\<in> id_assn\\<^sup>k *\\<^sub>a is_map\\<^sup>k \\<rightarrow>\\<^sub>a id_assn\"", "lemma contains_key_hnr_aux: \"(uncurry contains_key,uncurry (RETURN oo op_map_contains_key)) \\<in> id_assn\\<^sup>k *\\<^sub>a is_map\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\"", "lemmas [safe_constraint_rules] = CN_FALSEI[of is_pure \"assn\"]", "lemmas [fcomp_norm_unfold] = assn_def[symmetric]", "lemma APA: \"\\<lbrakk>PROP Q; CONSTRAINT is_pure A\\<rbrakk> \\<Longrightarrow> PROP Q\"", "lemma APAlu: \"\\<lbrakk>PROP Q; CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) A\\<rbrakk> \\<Longrightarrow> PROP Q\"", "lemma APAru: \"\\<lbrakk>PROP Q; CONSTRAINT (IS_PURE IS_RIGHT_UNIQUE) A\\<rbrakk> \\<Longrightarrow> PROP Q\"", "lemma APAbu: \"\\<lbrakk>PROP Q; CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) A; CONSTRAINT (IS_PURE IS_RIGHT_UNIQUE) A\\<rbrakk> \\<Longrightarrow> PROP Q\"", "lemma hnr_empty_aux: \"(uncurry0 empty,uncurry0 (RETURN op_set_empty))\\<in>unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_set\"", "lemmas hnr_op_empty = hnr_empty_aux[FCOMP op_set_empty.fref[where A=\"the_pure A\"]]", "lemmas hnr_mop_empty = hnr_op_empty[FCOMP mk_mop_rl0_np[OF mop_set_empty_alt]]", "lemma hnr_is_empty_aux: \"(is_empty, RETURN o op_set_is_empty)\\<in>is_set\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\"", "lemmas hnr_op_is_empty[sepref_fr_rules] = hnr_is_empty_aux[THEN APA,FCOMP op_set_is_empty.fref[where A=\"the_pure A\"]]", "lemmas hnr_mop_is_empty[sepref_fr_rules] = hnr_op_is_empty[FCOMP mk_mop_rl1_np[OF mop_set_is_empty_alt]]", "lemma hnr_member_aux: \"(uncurry memb, uncurry (RETURN oo op_set_member))\\<in>id_assn\\<^sup>k *\\<^sub>a is_set\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\"", "lemmas hnr_op_member[sepref_fr_rules] = hnr_member_aux[THEN APAbu,FCOMP op_set_member.fref[where A=\"the_pure A\"]]", "lemmas hnr_mop_member[sepref_fr_rules] = hnr_op_member[FCOMP mk_mop_rl2_np[OF mop_set_member_alt]]", "lemma hnr_insert_aux: \"(uncurry ins, uncurry (RETURN oo op_set_insert))\\<in>id_assn\\<^sup>k *\\<^sub>a is_set\\<^sup>d \\<rightarrow>\\<^sub>a is_set\"", "lemmas hnr_op_insert[sepref_fr_rules] = hnr_insert_aux[THEN APAru,FCOMP op_set_insert.fref[where A=\"the_pure A\"]]", "lemmas hnr_mop_insert[sepref_fr_rules] = hnr_op_insert[FCOMP mk_mop_rl2_np[OF mop_set_insert_alt]]", "lemma hnr_delete_aux: \"(uncurry delete, uncurry (RETURN oo op_set_delete))\\<in>id_assn\\<^sup>k *\\<^sub>a is_set\\<^sup>d \\<rightarrow>\\<^sub>a is_set\"", "lemmas hnr_op_delete[sepref_fr_rules] = hnr_delete_aux[THEN APAbu,FCOMP op_set_delete.fref[where A=\"the_pure A\"]]", "lemmas hnr_mop_delete[sepref_fr_rules] = hnr_op_delete[FCOMP mk_mop_rl2_np[OF mop_set_delete_alt]]", "lemma sorted_wrt'_eq: \"sorted_wrt' = sorted_wrt\"", "lemma param_sorted_wrt[param]: \"(sorted_wrt, sorted_wrt) \\<in> (A \\<rightarrow> A \\<rightarrow> bool_rel) \\<rightarrow> \\<langle>A\\<rangle>list_rel \\<rightarrow> bool_rel\"", "lemma obtain_list_from_setrel:\n    assumes SV: \"single_valued A\"\n    assumes \"(set l,s) \\<in> \\<langle>A\\<rangle>set_rel\"\n    obtains m where \"s=set m\" \"(l,m)\\<in>\\<langle>A\\<rangle>list_rel\"", "lemma param_it_to_sorted_list[param]: \"\\<lbrakk>IS_LEFT_UNIQUE A; IS_RIGHT_UNIQUE A\\<rbrakk> \\<Longrightarrow> (it_to_sorted_list, it_to_sorted_list) \\<in> (A \\<rightarrow> A \\<rightarrow> bool_rel) \\<rightarrow> \\<langle>A\\<rangle>set_rel \\<rightarrow> \\<langle>\\<langle>A\\<rangle>list_rel\\<rangle>nres_rel\"", "lemma is_imp_set_iterate: \"imp_set_iterate is_set is_it it_init it_has_next it_next\"", "lemma is_imp_list_empty: \"imp_list_empty (list_assn id_assn) (return [])\"", "lemma is_imp_list_prepend: \"imp_list_prepend (list_assn id_assn) (return oo List.Cons)\"", "lemmas tl_rl = to_list_ga_rule[OF is_imp_set_iterate is_imp_list_empty is_imp_list_prepend, folded to_list_def]", "lemma to_list_sorted1: \"(to_list,PR_CONST (it_to_sorted_list (\\<lambda>_ _. True))) \\<in> is_set\\<^sup>k \\<rightarrow>\\<^sub>a list_assn id_assn\"", "lemma to_list_sorted2: \"\\<lbrakk>\n        CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) A; \n        CONSTRAINT (IS_PURE IS_RIGHT_UNIQUE) A\\<rbrakk> \\<Longrightarrow> \n        (PR_CONST (it_to_sorted_list (\\<lambda>_ _. True)), PR_CONST (it_to_sorted_list (\\<lambda>_ _. True))) \\<in> \\<langle>the_pure A\\<rangle>set_rel \\<rightarrow> \\<langle>\\<langle>the_pure A\\<rangle>list_rel\\<rangle>nres_rel\"", "lemmas to_list_hnr = to_list_sorted1[FCOMP to_list_sorted2, folded assn_def]", "lemmas to_list_is_to_sorted_list = IS_TO_SORTED_LISTI[OF to_list_hnr]", "lemma to_list_gen[sepref_gen_algo_rules]: \"\\<lbrakk>CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) A; CONSTRAINT (IS_PURE IS_RIGHT_UNIQUE) A\\<rbrakk> \n        \\<Longrightarrow> GEN_ALGO to_list (IS_TO_SORTED_LIST (\\<lambda>_ _. True) (bind_set.assn is_set A) A)\"", "lemmas [safe_constraint_rules] = CN_FALSEI[of is_pure \"assn\"]", "lemma hnr_aux: \"(uncurry0 empty,uncurry0 (RETURN op_list_empty))\\<in>(pure unit_rel)\\<^sup>k \\<rightarrow>\\<^sub>a is_list\"", "lemmas hnr \n      = hnr_aux[FCOMP op_list_empty.fref[of \"the_pure A\"], folded assn_def]", "lemmas hnr_mop = hnr[FCOMP mk_mop_rl0_np[OF mop_list_empty_alt]]", "lemma hnr_aux: \"(is_empty,RETURN o op_list_is_empty)\\<in>(is_list)\\<^sup>k \\<rightarrow>\\<^sub>a pure bool_rel\"", "lemmas hnr[sepref_fr_rules] \n      = hnr_aux[FCOMP op_list_is_empty.fref, of \"the_pure A\", folded assn_def]", "lemmas hnr_mop[sepref_fr_rules] = hnr[FCOMP mk_mop_rl1_np[OF mop_list_is_empty_alt]]", "lemma hnr_aux: \"(uncurry (swap_args2 append),uncurry (RETURN oo op_list_append))\n      \\<in>(is_list)\\<^sup>d *\\<^sub>a (pure Id)\\<^sup>k \\<rightarrow>\\<^sub>a is_list\"", "lemmas hnr[sepref_fr_rules] \n      = hnr_aux[FCOMP op_list_append.fref,of A, folded assn_def]", "lemmas hnr_mop[sepref_fr_rules] = hnr[FCOMP mk_mop_rl2_np[OF mop_list_append_alt]]", "lemma hnr_aux: \"(uncurry prepend,uncurry (RETURN oo op_list_prepend))\n      \\<in>(pure Id)\\<^sup>k *\\<^sub>a (is_list)\\<^sup>d \\<rightarrow>\\<^sub>a is_list\"", "lemmas hnr[sepref_fr_rules] \n      = hnr_aux[FCOMP op_list_prepend.fref,of A, folded assn_def]", "lemmas hnr_mop[sepref_fr_rules] = hnr[FCOMP mk_mop_rl2_np[OF mop_list_prepend_alt]]", "lemma hnr_aux: \"(head,RETURN o op_list_hd)\n      \\<in>[\\<lambda>l. l\\<noteq>[]]\\<^sub>a (is_list)\\<^sup>d \\<rightarrow> pure Id\"", "lemmas hnr[sepref_fr_rules] = hnr_aux[FCOMP op_list_hd.fref,of A, folded assn_def]", "lemmas hnr_mop[sepref_fr_rules] = hnr[FCOMP mk_mop_rl1[OF mop_list_hd_alt]]", "lemma hnr_aux: \"(tail,RETURN o op_list_tl)\n      \\<in>[\\<lambda>l. l\\<noteq>[]]\\<^sub>a (is_list)\\<^sup>d \\<rightarrow> is_list\"", "lemmas hnr[sepref_fr_rules] = hnr_aux[FCOMP op_list_tl.fref,of \"the_pure A\", folded assn_def]", "lemmas hnr_mop[sepref_fr_rules] = hnr[FCOMP mk_mop_rl1[OF mop_list_tl_alt]]", "lemma hnr_aux: \"(rotate,RETURN o op_list_rotate1)\n      \\<in>(is_list)\\<^sup>d \\<rightarrow>\\<^sub>a is_list\"", "lemmas hnr[sepref_fr_rules] = hnr_aux[FCOMP op_list_rotate1.fref,of \"the_pure A\", folded assn_def]", "lemmas hnr_mop[sepref_fr_rules] = hnr[FCOMP mk_mop_rl1_np[OF mop_list_rotate1_alt]]", "lemma hnr_aux: \"(reverse,RETURN o op_list_rev)\n      \\<in>(is_list)\\<^sup>d \\<rightarrow>\\<^sub>a is_list\"", "lemmas hnr[sepref_fr_rules] = hnr_aux[FCOMP op_list_rev.fref,of \"the_pure A\", folded assn_def]", "lemmas hnr_mop[sepref_fr_rules] = hnr[FCOMP mk_mop_rl1_np[OF mop_list_rev_alt]]", "lemmas [sepref_fr_rules] = iam.empty_hnr[folded op_iam_empty_def]", "lemma [def_pat_rules]: \"op_iam_empty_sz$N \\<equiv> UNPROTECT (op_iam_empty_sz N)\"", "lemma [sepref_fr_rules]: \"(uncurry0 iam_new, uncurry0 (RETURN (PR_CONST (op_iam_empty_sz N)))) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a iam.assn K V\"", "lemmas [sepref_fr_rules] = ias.hnr_op_empty[folded op_ias_empty_def]", "lemma [def_pat_rules]: \"op_ias_empty_sz$N \\<equiv> UNPROTECT (op_ias_empty_sz N)\"", "lemma [sepref_fr_rules]: \n    \"(uncurry0 (ias_new_sz N), uncurry0 (RETURN (PR_CONST (op_ias_empty_sz N)))) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a ias.assn A\"", "lemmas [sepref_fr_rules] = hm.empty_hnr[folded op_hm_empty_def]", "lemmas [sepref_fr_rules] = hs.hnr_op_empty[folded op_hs_empty_def]"], "translations": [["", "lemma is_hashmap_finite[simp]: \"h \\<Turnstile> is_hashmap m mi \\<Longrightarrow> finite (dom m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<Turnstile> is_hashmap m mi \\<Longrightarrow> finite (dom m)", "unfolding is_hashmap_def is_hashmap'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<Turnstile>\n    (\\<exists>\\<^sub>Al.\n        is_hashtable l mi * \\<up> (map_of (concat l) = m)) \\<Longrightarrow>\n    finite (dom m)", "by auto"], ["", "lemma is_hashset_finite[simp]: \"h \\<Turnstile> is_hashset s si \\<Longrightarrow> finite s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<Turnstile> is_hashset s si \\<Longrightarrow> finite s", "unfolding is_hashset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<Turnstile> is_hashmap (map_of_set s) si \\<Longrightarrow> finite s", "by (auto dest: is_hashmap_finite)"], ["", "(* TODO: Move to array-map/ array-set *)"], ["", "definition \"ias_is_it s a si \\<equiv> \\<lambda>(a',i).\n    \\<exists>\\<^sub>Al. a\\<mapsto>\\<^sub>al * \\<up>(a'=a \\<and> s=ias_of_list l \\<and> (i=length l \\<and> si={} \\<or> i<length l \\<and> i\\<in>s \\<and> si=s \\<inter> {x. x\\<ge>i} ))\n  \""], ["", "context begin"], ["", "private"], ["", "function first_memb where \n    \"first_memb lmax a i = do {\n      if i<lmax then do {\n        x \\<leftarrow> Array.nth a i;\n        if x then return i else first_memb lmax a (Suc i)\n      } else \n        return i\n    }\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>lmax a i.\n           x = (lmax, a, i) \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>lmax a i lmaxa aa ia.\n       (lmax, a, i) = (lmaxa, aa, ia) \\<Longrightarrow>\n       (if i < lmax\n        then Array.nth a i \\<bind>\n             (\\<lambda>x.\n                 if x then return i else first_memb_sumC (lmax, a, Suc i))\n        else return i) =\n       (if ia < lmaxa\n        then Array.nth aa ia \\<bind>\n             (\\<lambda>x.\n                 if x then return ia\n                 else first_memb_sumC (lmaxa, aa, Suc ia))\n        else return ia)", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All first_memb_dom", "by (relation \"measure (\\<lambda>(l,_,i). l-i)\") auto"], ["", "declare first_memb.simps[simp del]"], ["", "private"], ["", "lemma first_memb_rl_aux:\n    assumes \"lmax \\<le> length l\" \"i\\<le>lmax\" \n    shows \n      \"< a \\<mapsto>\\<^sub>a l > \n        first_memb lmax a i \n      <\\<lambda>k. a\\<mapsto>\\<^sub>a l * \\<up>(k\\<le>lmax \\<and> (\\<forall>j. i\\<le>j \\<and> j<k \\<longrightarrow> \\<not>l!j) \\<and> i\\<le>k \\<and> (k=lmax \\<or> l!k)) >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a l> first_memb lmax a i\n    <\\<lambda>k.\n        a \\<mapsto>\\<^sub>a l *\n        \\<up>\n         (k \\<le> lmax \\<and>\n          (\\<forall>j.\n              i \\<le> j \\<and> j < k \\<longrightarrow> \\<not> l ! j) \\<and>\n          i \\<le> k \\<and> (k = lmax \\<or> l ! k))>", "using assms"], ["proof (prove)\nusing this:\n  lmax \\<le> length l\n  i \\<le> lmax\n\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a l> first_memb lmax a i\n    <\\<lambda>k.\n        a \\<mapsto>\\<^sub>a l *\n        \\<up>\n         (k \\<le> lmax \\<and>\n          (\\<forall>j.\n              i \\<le> j \\<and> j < k \\<longrightarrow> \\<not> l ! j) \\<and>\n          i \\<le> k \\<and> (k = lmax \\<or> l ! k))>", "proof (induction lmax a i rule: first_memb.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>lmax a i.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>i < lmax; \\<not> x; lmax \\<le> length l;\n                    Suc i \\<le> lmax\\<rbrakk>\n                   \\<Longrightarrow> <a \\<mapsto>\\<^sub>a l>\n                                     first_memb lmax a (Suc i)\n                                     <\\<lambda>k.\n   a \\<mapsto>\\<^sub>a l *\n   \\<up>\n    (k \\<le> lmax \\<and>\n     (\\<forall>j.\n         Suc i \\<le> j \\<and> j < k \\<longrightarrow> \\<not> l ! j) \\<and>\n     Suc i \\<le> k \\<and> (k = lmax \\<or> l ! k))>;\n        lmax \\<le> length l; i \\<le> lmax\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a l> first_memb lmax a i\n                         <\\<lambda>k.\n                             a \\<mapsto>\\<^sub>a l *\n                             \\<up>\n                              (k \\<le> lmax \\<and>\n                               (\\<forall>j.\n                                   i \\<le> j \\<and> j < k \\<longrightarrow>\n                                   \\<not> l ! j) \\<and>\n                               i \\<le> k \\<and> (k = lmax \\<or> l ! k))>", "case (1 lmax a i)"], ["proof (state)\nthis:\n  \\<lbrakk>i < lmax; \\<not> ?x; lmax \\<le> length l;\n   Suc i \\<le> lmax\\<rbrakk>\n  \\<Longrightarrow> <a \\<mapsto>\\<^sub>a l> first_memb lmax a (Suc i)\n                    <\\<lambda>k.\n                        a \\<mapsto>\\<^sub>a l *\n                        \\<up>\n                         (k \\<le> lmax \\<and>\n                          (\\<forall>j.\n                              Suc i \\<le> j \\<and> j < k \\<longrightarrow>\n                              \\<not> l ! j) \\<and>\n                          Suc i \\<le> k \\<and> (k = lmax \\<or> l ! k))>\n  lmax \\<le> length l\n  i \\<le> lmax\n\ngoal (1 subgoal):\n 1. \\<And>lmax a i.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>i < lmax; \\<not> x; lmax \\<le> length l;\n                    Suc i \\<le> lmax\\<rbrakk>\n                   \\<Longrightarrow> <a \\<mapsto>\\<^sub>a l>\n                                     first_memb lmax a (Suc i)\n                                     <\\<lambda>k.\n   a \\<mapsto>\\<^sub>a l *\n   \\<up>\n    (k \\<le> lmax \\<and>\n     (\\<forall>j.\n         Suc i \\<le> j \\<and> j < k \\<longrightarrow> \\<not> l ! j) \\<and>\n     Suc i \\<le> k \\<and> (k = lmax \\<or> l ! k))>;\n        lmax \\<le> length l; i \\<le> lmax\\<rbrakk>\n       \\<Longrightarrow> <a \\<mapsto>\\<^sub>a l> first_memb lmax a i\n                         <\\<lambda>k.\n                             a \\<mapsto>\\<^sub>a l *\n                             \\<up>\n                              (k \\<le> lmax \\<and>\n                               (\\<forall>j.\n                                   i \\<le> j \\<and> j < k \\<longrightarrow>\n                                   \\<not> l ! j) \\<and>\n                               i \\<le> k \\<and> (k = lmax \\<or> l ! k))>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a l> first_memb lmax a i\n    <\\<lambda>k.\n        a \\<mapsto>\\<^sub>a l *\n        \\<up>\n         (k \\<le> lmax \\<and>\n          (\\<forall>j.\n              i \\<le> j \\<and> j < k \\<longrightarrow> \\<not> l ! j) \\<and>\n          i \\<le> k \\<and> (k = lmax \\<or> l ! k))>", "apply (subst first_memb.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a l>\n    if i < lmax\n    then Array.nth a i \\<bind>\n         (\\<lambda>x. if x then return i else first_memb lmax a (Suc i))\n    else return i\n    <\\<lambda>k.\n        a \\<mapsto>\\<^sub>a l *\n        \\<up>\n         (k \\<le> lmax \\<and>\n          (\\<forall>j.\n              i \\<le> j \\<and> j < k \\<longrightarrow> \\<not> l ! j) \\<and>\n          i \\<le> k \\<and> (k = lmax \\<or> l ! k))>", "using \"1.prems\""], ["proof (prove)\nusing this:\n  lmax \\<le> length l\n  i \\<le> lmax\n\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a l>\n    if i < lmax\n    then Array.nth a i \\<bind>\n         (\\<lambda>x. if x then return i else first_memb lmax a (Suc i))\n    else return i\n    <\\<lambda>k.\n        a \\<mapsto>\\<^sub>a l *\n        \\<up>\n         (k \\<le> lmax \\<and>\n          (\\<forall>j.\n              i \\<le> j \\<and> j < k \\<longrightarrow> \\<not> l ! j) \\<and>\n          i \\<le> k \\<and> (k = lmax \\<or> l ! k))>", "apply (sep_auto heap: \"1.IH\"; ((sep_auto;fail) | metis eq_iff not_less_eq_eq))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <a \\<mapsto>\\<^sub>a l> first_memb lmax a i\n  <\\<lambda>k.\n      a \\<mapsto>\\<^sub>a l *\n      \\<up>\n       (k \\<le> lmax \\<and>\n        (\\<forall>j.\n            i \\<le> j \\<and> j < k \\<longrightarrow> \\<not> l ! j) \\<and>\n        i \\<le> k \\<and> (k = lmax \\<or> l ! k))>\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma first_memb_rl[sep_heap_rules]:\n    assumes \"lmax \\<le> length l\" \"i\\<le>lmax\" \n    shows \"< a \\<mapsto>\\<^sub>a l > \n      first_memb lmax a i \n    <\\<lambda>k. a\\<mapsto>\\<^sub>a l * \\<up>(ias_of_list l \\<inter> {i..<k} = {} \\<and> i\\<le>k \\<and> (k<lmax \\<and> k\\<in>ias_of_list l \\<or> k=lmax) ) >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a l> first_memb lmax a i\n    <\\<lambda>k.\n        a \\<mapsto>\\<^sub>a l *\n        \\<up>\n         (ias_of_list l \\<inter> {i..<k} = {} \\<and>\n          i \\<le> k \\<and>\n          (k < lmax \\<and> k \\<in> ias_of_list l \\<or> k = lmax))>", "using assms"], ["proof (prove)\nusing this:\n  lmax \\<le> length l\n  i \\<le> lmax\n\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a l> first_memb lmax a i\n    <\\<lambda>k.\n        a \\<mapsto>\\<^sub>a l *\n        \\<up>\n         (ias_of_list l \\<inter> {i..<k} = {} \\<and>\n          i \\<le> k \\<and>\n          (k < lmax \\<and> k \\<in> ias_of_list l \\<or> k = lmax))>", "by (sep_auto simp: ias_of_list_def heap: first_memb_rl_aux)"], ["", "definition \"ias_it_init a = do {\n    l \\<leftarrow> Array.len a;\n    i \\<leftarrow> first_memb l a 0;\n    return (a,i)\n  }\""], ["", "definition \"ias_it_has_next \\<equiv> \\<lambda>(a,i). do {\n    l \\<leftarrow> Array.len a;\n    return (i<l)\n  }\""], ["", "definition \"ias_it_next \\<equiv> \\<lambda>(a,i). do {\n    l \\<leftarrow> Array.len a;\n    i' \\<leftarrow> first_memb l a (Suc i);\n    return (i,(a,i'))\n  }\""], ["", "(* TODO: Move *)"], ["", "lemma ias_of_list_bound: \"ias_of_list l \\<subseteq> {0..<length l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ias_of_list l \\<subseteq> {0..<length l}", "by (auto simp: ias_of_list_def)"], ["", "end"], ["", "interpretation ias: imp_set_iterate is_ias ias_is_it ias_it_init ias_it_has_next ias_it_next"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_iterate is_ias ias_is_it ias_it_init ias_it_has_next ias_it_next", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s p. <is_ias s p> ias_it_init p <ias_is_it s p s>\\<^sub>t\n 2. \\<And>s' s p it.\n       s' \\<noteq> {} \\<Longrightarrow>\n       <ias_is_it s p s' it> ias_it_next it\n       <\\<lambda>(a, it').\n           ias_is_it s p (s' - {a}) it' * \\<up> (a \\<in> s')>\n 3. \\<And>s p s' it.\n       <ias_is_it s p s' it> ias_it_has_next it\n       <\\<lambda>r. ias_is_it s p s' it * \\<up> (r = (s' \\<noteq> {}))>\n 4. \\<And>s p s' it.\n       ias_is_it s p s' it \\<Longrightarrow>\\<^sub>A is_ias s p * true", "unfolding is_ias_def ias_is_it_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s p.\n       <\\<exists>\\<^sub>Al.\n           p \\<mapsto>\\<^sub>a l *\n           \\<up>\n            (s =\n             ias_of_list\n              l)> ias_it_init\n                   p <\\<lambda>r.\n                         case r of\n                         (a', i) \\<Rightarrow>\n                           \\<exists>\\<^sub>Al.\n                              p \\<mapsto>\\<^sub>a l *\n                              \\<up>\n                               (a' = p \\<and>\n                                s = ias_of_list l \\<and>\n                                (i = length l \\<and> s = {} \\<or>\n                                 i < length l \\<and>\n                                 i \\<in> s \\<and>\n                                 s = s \\<inter> {x. i \\<le> x}))>\\<^sub>t\n 2. \\<And>s' s p it.\n       s' \\<noteq> {} \\<Longrightarrow>\n       <case it of\n        (a', i) \\<Rightarrow>\n          \\<exists>\\<^sub>Al.\n             p \\<mapsto>\\<^sub>a l *\n             \\<up>\n              (a' = p \\<and>\n               s = ias_of_list l \\<and>\n               (i = length l \\<and> s' = {} \\<or>\n                i < length l \\<and>\n                i \\<in> s \\<and> s' = s \\<inter> {x. i \\<le> x}))>\n       ias_it_next it\n       <\\<lambda>(a, it').\n           (case it' of\n            (a', i) \\<Rightarrow>\n              \\<exists>\\<^sub>Al.\n                 p \\<mapsto>\\<^sub>a l *\n                 \\<up>\n                  (a' = p \\<and>\n                   s = ias_of_list l \\<and>\n                   (i = length l \\<and> s' - {a} = {} \\<or>\n                    i < length l \\<and>\n                    i \\<in> s \\<and>\n                    s' - {a} = s \\<inter> {x. i \\<le> x}))) *\n           \\<up> (a \\<in> s')>\n 3. \\<And>s p s' it.\n       <case it of\n        (a', i) \\<Rightarrow>\n          \\<exists>\\<^sub>Al.\n             p \\<mapsto>\\<^sub>a l *\n             \\<up>\n              (a' = p \\<and>\n               s = ias_of_list l \\<and>\n               (i = length l \\<and> s' = {} \\<or>\n                i < length l \\<and>\n                i \\<in> s \\<and> s' = s \\<inter> {x. i \\<le> x}))>\n       ias_it_has_next it\n       <\\<lambda>r.\n           (case it of\n            (a', i) \\<Rightarrow>\n              \\<exists>\\<^sub>Al.\n                 p \\<mapsto>\\<^sub>a l *\n                 \\<up>\n                  (a' = p \\<and>\n                   s = ias_of_list l \\<and>\n                   (i = length l \\<and> s' = {} \\<or>\n                    i < length l \\<and>\n                    i \\<in> s \\<and> s' = s \\<inter> {x. i \\<le> x}))) *\n           \\<up> (r = (s' \\<noteq> {}))>\n 4. \\<And>s p s' it.\n       (case it of\n        (a', i) \\<Rightarrow>\n          \\<exists>\\<^sub>Al.\n             p \\<mapsto>\\<^sub>a l *\n             \\<up>\n              (a' = p \\<and>\n               s = ias_of_list l \\<and>\n               (i = length l \\<and> s' = {} \\<or>\n                i < length l \\<and>\n                i \\<in> s \\<and>\n                s' = s \\<inter> {x. i \\<le> x}))) \\<Longrightarrow>\\<^sub>A\n       (\\<exists>\\<^sub>Al.\n           p \\<mapsto>\\<^sub>a l * \\<up> (s = ias_of_list l)) *\n       true", "unfolding ias_it_init_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s p.\n       <\\<exists>\\<^sub>Al.\n           p \\<mapsto>\\<^sub>a l *\n           \\<up>\n            (s =\n             ias_of_list\n              l)> Array.len p \\<bind>\n                  (\\<lambda>l.\n                      ??.IICF_Sepl_Binding.first_memb l p 0 \\<bind>\n                      (\\<lambda>i.\n                          return\n                           (p, i))) <\\<lambda>r.\n  case r of\n  (a', i) \\<Rightarrow>\n    \\<exists>\\<^sub>Al.\n       p \\<mapsto>\\<^sub>a l *\n       \\<up>\n        (a' = p \\<and>\n         s = ias_of_list l \\<and>\n         (i = length l \\<and> s = {} \\<or>\n          i < length l \\<and>\n          i \\<in> s \\<and> s = s \\<inter> {x. i \\<le> x}))>\\<^sub>t\n 2. \\<And>s' s p it.\n       s' \\<noteq> {} \\<Longrightarrow>\n       <case it of\n        (a', i) \\<Rightarrow>\n          \\<exists>\\<^sub>Al.\n             p \\<mapsto>\\<^sub>a l *\n             \\<up>\n              (a' = p \\<and>\n               s = ias_of_list l \\<and>\n               (i = length l \\<and> s' = {} \\<or>\n                i < length l \\<and>\n                i \\<in> s \\<and> s' = s \\<inter> {x. i \\<le> x}))>\n       ias_it_next it\n       <\\<lambda>(a, it').\n           (case it' of\n            (a', i) \\<Rightarrow>\n              \\<exists>\\<^sub>Al.\n                 p \\<mapsto>\\<^sub>a l *\n                 \\<up>\n                  (a' = p \\<and>\n                   s = ias_of_list l \\<and>\n                   (i = length l \\<and> s' - {a} = {} \\<or>\n                    i < length l \\<and>\n                    i \\<in> s \\<and>\n                    s' - {a} = s \\<inter> {x. i \\<le> x}))) *\n           \\<up> (a \\<in> s')>\n 3. \\<And>s p s' it.\n       <case it of\n        (a', i) \\<Rightarrow>\n          \\<exists>\\<^sub>Al.\n             p \\<mapsto>\\<^sub>a l *\n             \\<up>\n              (a' = p \\<and>\n               s = ias_of_list l \\<and>\n               (i = length l \\<and> s' = {} \\<or>\n                i < length l \\<and>\n                i \\<in> s \\<and> s' = s \\<inter> {x. i \\<le> x}))>\n       ias_it_has_next it\n       <\\<lambda>r.\n           (case it of\n            (a', i) \\<Rightarrow>\n              \\<exists>\\<^sub>Al.\n                 p \\<mapsto>\\<^sub>a l *\n                 \\<up>\n                  (a' = p \\<and>\n                   s = ias_of_list l \\<and>\n                   (i = length l \\<and> s' = {} \\<or>\n                    i < length l \\<and>\n                    i \\<in> s \\<and> s' = s \\<inter> {x. i \\<le> x}))) *\n           \\<up> (r = (s' \\<noteq> {}))>\n 4. \\<And>s p s' it.\n       (case it of\n        (a', i) \\<Rightarrow>\n          \\<exists>\\<^sub>Al.\n             p \\<mapsto>\\<^sub>a l *\n             \\<up>\n              (a' = p \\<and>\n               s = ias_of_list l \\<and>\n               (i = length l \\<and> s' = {} \\<or>\n                i < length l \\<and>\n                i \\<in> s \\<and>\n                s' = s \\<inter> {x. i \\<le> x}))) \\<Longrightarrow>\\<^sub>A\n       (\\<exists>\\<^sub>Al.\n           p \\<mapsto>\\<^sub>a l * \\<up> (s = ias_of_list l)) *\n       true", "using ias_of_list_bound"], ["proof (prove)\nusing this:\n  ias_of_list ?l \\<subseteq> {0..<length ?l}\n\ngoal (4 subgoals):\n 1. \\<And>s p.\n       <\\<exists>\\<^sub>Al.\n           p \\<mapsto>\\<^sub>a l *\n           \\<up>\n            (s =\n             ias_of_list\n              l)> Array.len p \\<bind>\n                  (\\<lambda>l.\n                      ??.IICF_Sepl_Binding.first_memb l p 0 \\<bind>\n                      (\\<lambda>i.\n                          return\n                           (p, i))) <\\<lambda>r.\n  case r of\n  (a', i) \\<Rightarrow>\n    \\<exists>\\<^sub>Al.\n       p \\<mapsto>\\<^sub>a l *\n       \\<up>\n        (a' = p \\<and>\n         s = ias_of_list l \\<and>\n         (i = length l \\<and> s = {} \\<or>\n          i < length l \\<and>\n          i \\<in> s \\<and> s = s \\<inter> {x. i \\<le> x}))>\\<^sub>t\n 2. \\<And>s' s p it.\n       s' \\<noteq> {} \\<Longrightarrow>\n       <case it of\n        (a', i) \\<Rightarrow>\n          \\<exists>\\<^sub>Al.\n             p \\<mapsto>\\<^sub>a l *\n             \\<up>\n              (a' = p \\<and>\n               s = ias_of_list l \\<and>\n               (i = length l \\<and> s' = {} \\<or>\n                i < length l \\<and>\n                i \\<in> s \\<and> s' = s \\<inter> {x. i \\<le> x}))>\n       ias_it_next it\n       <\\<lambda>(a, it').\n           (case it' of\n            (a', i) \\<Rightarrow>\n              \\<exists>\\<^sub>Al.\n                 p \\<mapsto>\\<^sub>a l *\n                 \\<up>\n                  (a' = p \\<and>\n                   s = ias_of_list l \\<and>\n                   (i = length l \\<and> s' - {a} = {} \\<or>\n                    i < length l \\<and>\n                    i \\<in> s \\<and>\n                    s' - {a} = s \\<inter> {x. i \\<le> x}))) *\n           \\<up> (a \\<in> s')>\n 3. \\<And>s p s' it.\n       <case it of\n        (a', i) \\<Rightarrow>\n          \\<exists>\\<^sub>Al.\n             p \\<mapsto>\\<^sub>a l *\n             \\<up>\n              (a' = p \\<and>\n               s = ias_of_list l \\<and>\n               (i = length l \\<and> s' = {} \\<or>\n                i < length l \\<and>\n                i \\<in> s \\<and> s' = s \\<inter> {x. i \\<le> x}))>\n       ias_it_has_next it\n       <\\<lambda>r.\n           (case it of\n            (a', i) \\<Rightarrow>\n              \\<exists>\\<^sub>Al.\n                 p \\<mapsto>\\<^sub>a l *\n                 \\<up>\n                  (a' = p \\<and>\n                   s = ias_of_list l \\<and>\n                   (i = length l \\<and> s' = {} \\<or>\n                    i < length l \\<and>\n                    i \\<in> s \\<and> s' = s \\<inter> {x. i \\<le> x}))) *\n           \\<up> (r = (s' \\<noteq> {}))>\n 4. \\<And>s p s' it.\n       (case it of\n        (a', i) \\<Rightarrow>\n          \\<exists>\\<^sub>Al.\n             p \\<mapsto>\\<^sub>a l *\n             \\<up>\n              (a' = p \\<and>\n               s = ias_of_list l \\<and>\n               (i = length l \\<and> s' = {} \\<or>\n                i < length l \\<and>\n                i \\<in> s \\<and>\n                s' = s \\<inter> {x. i \\<le> x}))) \\<Longrightarrow>\\<^sub>A\n       (\\<exists>\\<^sub>Al.\n           p \\<mapsto>\\<^sub>a l * \\<up> (s = ias_of_list l)) *\n       true", "apply (sep_auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s' s p it.\n       s' \\<noteq> {} \\<Longrightarrow>\n       <case it of\n        (a', i) \\<Rightarrow>\n          \\<exists>\\<^sub>Al.\n             p \\<mapsto>\\<^sub>a l *\n             \\<up>\n              (a' = p \\<and>\n               s = ias_of_list l \\<and>\n               (i = length l \\<and> s' = {} \\<or>\n                i < length l \\<and>\n                i \\<in> s \\<and> s' = s \\<inter> {x. i \\<le> x}))>\n       ias_it_next it\n       <\\<lambda>(a, it').\n           (case it' of\n            (a', i) \\<Rightarrow>\n              \\<exists>\\<^sub>Al.\n                 p \\<mapsto>\\<^sub>a l *\n                 \\<up>\n                  (a' = p \\<and>\n                   s = ias_of_list l \\<and>\n                   (i = length l \\<and> s' - {a} = {} \\<or>\n                    i < length l \\<and>\n                    i \\<in> s \\<and>\n                    s' - {a} = s \\<inter> {x. i \\<le> x}))) *\n           \\<up> (a \\<in> s')>\n 2. \\<And>s p s' it.\n       <case it of\n        (a', i) \\<Rightarrow>\n          \\<exists>\\<^sub>Al.\n             p \\<mapsto>\\<^sub>a l *\n             \\<up>\n              (a' = p \\<and>\n               s = ias_of_list l \\<and>\n               (i = length l \\<and> s' = {} \\<or>\n                i < length l \\<and>\n                i \\<in> s \\<and> s' = s \\<inter> {x. i \\<le> x}))>\n       ias_it_has_next it\n       <\\<lambda>r.\n           (case it of\n            (a', i) \\<Rightarrow>\n              \\<exists>\\<^sub>Al.\n                 p \\<mapsto>\\<^sub>a l *\n                 \\<up>\n                  (a' = p \\<and>\n                   s = ias_of_list l \\<and>\n                   (i = length l \\<and> s' = {} \\<or>\n                    i < length l \\<and>\n                    i \\<in> s \\<and> s' = s \\<inter> {x. i \\<le> x}))) *\n           \\<up> (r = (s' \\<noteq> {}))>\n 3. \\<And>s p s' it.\n       (case it of\n        (a', i) \\<Rightarrow>\n          \\<exists>\\<^sub>Al.\n             p \\<mapsto>\\<^sub>a l *\n             \\<up>\n              (a' = p \\<and>\n               s = ias_of_list l \\<and>\n               (i = length l \\<and> s' = {} \\<or>\n                i < length l \\<and>\n                i \\<in> s \\<and>\n                s' = s \\<inter> {x. i \\<le> x}))) \\<Longrightarrow>\\<^sub>A\n       (\\<exists>\\<^sub>Al.\n           p \\<mapsto>\\<^sub>a l * \\<up> (s = ias_of_list l)) *\n       true", "unfolding ias_it_next_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s' s p it.\n       s' \\<noteq> {} \\<Longrightarrow>\n       <case it of\n        (a', i) \\<Rightarrow>\n          \\<exists>\\<^sub>Al.\n             p \\<mapsto>\\<^sub>a l *\n             \\<up>\n              (a' = p \\<and>\n               s = ias_of_list l \\<and>\n               (i = length l \\<and> s' = {} \\<or>\n                i < length l \\<and>\n                i \\<in> s \\<and> s' = s \\<inter> {x. i \\<le> x}))>\n       case it of\n       (a, i) \\<Rightarrow>\n         Array.len a \\<bind>\n         (\\<lambda>l.\n             ??.IICF_Sepl_Binding.first_memb l a (Suc i) \\<bind>\n             (\\<lambda>i'. return (i, a, i')))\n       <\\<lambda>(a, it').\n           (case it' of\n            (a', i) \\<Rightarrow>\n              \\<exists>\\<^sub>Al.\n                 p \\<mapsto>\\<^sub>a l *\n                 \\<up>\n                  (a' = p \\<and>\n                   s = ias_of_list l \\<and>\n                   (i = length l \\<and> s' - {a} = {} \\<or>\n                    i < length l \\<and>\n                    i \\<in> s \\<and>\n                    s' - {a} = s \\<inter> {x. i \\<le> x}))) *\n           \\<up> (a \\<in> s')>\n 2. \\<And>s p s' it.\n       <case it of\n        (a', i) \\<Rightarrow>\n          \\<exists>\\<^sub>Al.\n             p \\<mapsto>\\<^sub>a l *\n             \\<up>\n              (a' = p \\<and>\n               s = ias_of_list l \\<and>\n               (i = length l \\<and> s' = {} \\<or>\n                i < length l \\<and>\n                i \\<in> s \\<and> s' = s \\<inter> {x. i \\<le> x}))>\n       ias_it_has_next it\n       <\\<lambda>r.\n           (case it of\n            (a', i) \\<Rightarrow>\n              \\<exists>\\<^sub>Al.\n                 p \\<mapsto>\\<^sub>a l *\n                 \\<up>\n                  (a' = p \\<and>\n                   s = ias_of_list l \\<and>\n                   (i = length l \\<and> s' = {} \\<or>\n                    i < length l \\<and>\n                    i \\<in> s \\<and> s' = s \\<inter> {x. i \\<le> x}))) *\n           \\<up> (r = (s' \\<noteq> {}))>\n 3. \\<And>s p s' it.\n       (case it of\n        (a', i) \\<Rightarrow>\n          \\<exists>\\<^sub>Al.\n             p \\<mapsto>\\<^sub>a l *\n             \\<up>\n              (a' = p \\<and>\n               s = ias_of_list l \\<and>\n               (i = length l \\<and> s' = {} \\<or>\n                i < length l \\<and>\n                i \\<in> s \\<and>\n                s' = s \\<inter> {x. i \\<le> x}))) \\<Longrightarrow>\\<^sub>A\n       (\\<exists>\\<^sub>Al.\n           p \\<mapsto>\\<^sub>a l * \\<up> (s = ias_of_list l)) *\n       true", "using ias_of_list_bound"], ["proof (prove)\nusing this:\n  ias_of_list ?l \\<subseteq> {0..<length ?l}\n\ngoal (3 subgoals):\n 1. \\<And>s' s p it.\n       s' \\<noteq> {} \\<Longrightarrow>\n       <case it of\n        (a', i) \\<Rightarrow>\n          \\<exists>\\<^sub>Al.\n             p \\<mapsto>\\<^sub>a l *\n             \\<up>\n              (a' = p \\<and>\n               s = ias_of_list l \\<and>\n               (i = length l \\<and> s' = {} \\<or>\n                i < length l \\<and>\n                i \\<in> s \\<and> s' = s \\<inter> {x. i \\<le> x}))>\n       case it of\n       (a, i) \\<Rightarrow>\n         Array.len a \\<bind>\n         (\\<lambda>l.\n             ??.IICF_Sepl_Binding.first_memb l a (Suc i) \\<bind>\n             (\\<lambda>i'. return (i, a, i')))\n       <\\<lambda>(a, it').\n           (case it' of\n            (a', i) \\<Rightarrow>\n              \\<exists>\\<^sub>Al.\n                 p \\<mapsto>\\<^sub>a l *\n                 \\<up>\n                  (a' = p \\<and>\n                   s = ias_of_list l \\<and>\n                   (i = length l \\<and> s' - {a} = {} \\<or>\n                    i < length l \\<and>\n                    i \\<in> s \\<and>\n                    s' - {a} = s \\<inter> {x. i \\<le> x}))) *\n           \\<up> (a \\<in> s')>\n 2. \\<And>s p s' it.\n       <case it of\n        (a', i) \\<Rightarrow>\n          \\<exists>\\<^sub>Al.\n             p \\<mapsto>\\<^sub>a l *\n             \\<up>\n              (a' = p \\<and>\n               s = ias_of_list l \\<and>\n               (i = length l \\<and> s' = {} \\<or>\n                i < length l \\<and>\n                i \\<in> s \\<and> s' = s \\<inter> {x. i \\<le> x}))>\n       ias_it_has_next it\n       <\\<lambda>r.\n           (case it of\n            (a', i) \\<Rightarrow>\n              \\<exists>\\<^sub>Al.\n                 p \\<mapsto>\\<^sub>a l *\n                 \\<up>\n                  (a' = p \\<and>\n                   s = ias_of_list l \\<and>\n                   (i = length l \\<and> s' = {} \\<or>\n                    i < length l \\<and>\n                    i \\<in> s \\<and> s' = s \\<inter> {x. i \\<le> x}))) *\n           \\<up> (r = (s' \\<noteq> {}))>\n 3. \\<And>s p s' it.\n       (case it of\n        (a', i) \\<Rightarrow>\n          \\<exists>\\<^sub>Al.\n             p \\<mapsto>\\<^sub>a l *\n             \\<up>\n              (a' = p \\<and>\n               s = ias_of_list l \\<and>\n               (i = length l \\<and> s' = {} \\<or>\n                i < length l \\<and>\n                i \\<in> s \\<and>\n                s' = s \\<inter> {x. i \\<le> x}))) \\<Longrightarrow>\\<^sub>A\n       (\\<exists>\\<^sub>Al.\n           p \\<mapsto>\\<^sub>a l * \\<up> (s = ias_of_list l)) *\n       true", "apply (sep_auto; fastforce)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s p s' it.\n       <case it of\n        (a', i) \\<Rightarrow>\n          \\<exists>\\<^sub>Al.\n             p \\<mapsto>\\<^sub>a l *\n             \\<up>\n              (a' = p \\<and>\n               s = ias_of_list l \\<and>\n               (i = length l \\<and> s' = {} \\<or>\n                i < length l \\<and>\n                i \\<in> s \\<and> s' = s \\<inter> {x. i \\<le> x}))>\n       ias_it_has_next it\n       <\\<lambda>r.\n           (case it of\n            (a', i) \\<Rightarrow>\n              \\<exists>\\<^sub>Al.\n                 p \\<mapsto>\\<^sub>a l *\n                 \\<up>\n                  (a' = p \\<and>\n                   s = ias_of_list l \\<and>\n                   (i = length l \\<and> s' = {} \\<or>\n                    i < length l \\<and>\n                    i \\<in> s \\<and> s' = s \\<inter> {x. i \\<le> x}))) *\n           \\<up> (r = (s' \\<noteq> {}))>\n 2. \\<And>s p s' it.\n       (case it of\n        (a', i) \\<Rightarrow>\n          \\<exists>\\<^sub>Al.\n             p \\<mapsto>\\<^sub>a l *\n             \\<up>\n              (a' = p \\<and>\n               s = ias_of_list l \\<and>\n               (i = length l \\<and> s' = {} \\<or>\n                i < length l \\<and>\n                i \\<in> s \\<and>\n                s' = s \\<inter> {x. i \\<le> x}))) \\<Longrightarrow>\\<^sub>A\n       (\\<exists>\\<^sub>Al.\n           p \\<mapsto>\\<^sub>a l * \\<up> (s = ias_of_list l)) *\n       true", "(* Takes long *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s p s' it.\n       <case it of\n        (a', i) \\<Rightarrow>\n          \\<exists>\\<^sub>Al.\n             p \\<mapsto>\\<^sub>a l *\n             \\<up>\n              (a' = p \\<and>\n               s = ias_of_list l \\<and>\n               (i = length l \\<and> s' = {} \\<or>\n                i < length l \\<and>\n                i \\<in> s \\<and> s' = s \\<inter> {x. i \\<le> x}))>\n       ias_it_has_next it\n       <\\<lambda>r.\n           (case it of\n            (a', i) \\<Rightarrow>\n              \\<exists>\\<^sub>Al.\n                 p \\<mapsto>\\<^sub>a l *\n                 \\<up>\n                  (a' = p \\<and>\n                   s = ias_of_list l \\<and>\n                   (i = length l \\<and> s' = {} \\<or>\n                    i < length l \\<and>\n                    i \\<in> s \\<and> s' = s \\<inter> {x. i \\<le> x}))) *\n           \\<up> (r = (s' \\<noteq> {}))>\n 2. \\<And>s p s' it.\n       (case it of\n        (a', i) \\<Rightarrow>\n          \\<exists>\\<^sub>Al.\n             p \\<mapsto>\\<^sub>a l *\n             \\<up>\n              (a' = p \\<and>\n               s = ias_of_list l \\<and>\n               (i = length l \\<and> s' = {} \\<or>\n                i < length l \\<and>\n                i \\<in> s \\<and>\n                s' = s \\<inter> {x. i \\<le> x}))) \\<Longrightarrow>\\<^sub>A\n       (\\<exists>\\<^sub>Al.\n           p \\<mapsto>\\<^sub>a l * \\<up> (s = ias_of_list l)) *\n       true", "unfolding ias_it_has_next_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s p s' it.\n       <case it of\n        (a', i) \\<Rightarrow>\n          \\<exists>\\<^sub>Al.\n             p \\<mapsto>\\<^sub>a l *\n             \\<up>\n              (a' = p \\<and>\n               s = ias_of_list l \\<and>\n               (i = length l \\<and> s' = {} \\<or>\n                i < length l \\<and>\n                i \\<in> s \\<and> s' = s \\<inter> {x. i \\<le> x}))>\n       case it of\n       (a, i) \\<Rightarrow> Array.len a \\<bind> (\\<lambda>l. return (i < l))\n       <\\<lambda>r.\n           (case it of\n            (a', i) \\<Rightarrow>\n              \\<exists>\\<^sub>Al.\n                 p \\<mapsto>\\<^sub>a l *\n                 \\<up>\n                  (a' = p \\<and>\n                   s = ias_of_list l \\<and>\n                   (i = length l \\<and> s' = {} \\<or>\n                    i < length l \\<and>\n                    i \\<in> s \\<and> s' = s \\<inter> {x. i \\<le> x}))) *\n           \\<up> (r = (s' \\<noteq> {}))>\n 2. \\<And>s p s' it.\n       (case it of\n        (a', i) \\<Rightarrow>\n          \\<exists>\\<^sub>Al.\n             p \\<mapsto>\\<^sub>a l *\n             \\<up>\n              (a' = p \\<and>\n               s = ias_of_list l \\<and>\n               (i = length l \\<and> s' = {} \\<or>\n                i < length l \\<and>\n                i \\<in> s \\<and>\n                s' = s \\<inter> {x. i \\<le> x}))) \\<Longrightarrow>\\<^sub>A\n       (\\<exists>\\<^sub>Al.\n           p \\<mapsto>\\<^sub>a l * \\<up> (s = ias_of_list l)) *\n       true", "apply sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s p s' it.\n       (case it of\n        (a', i) \\<Rightarrow>\n          \\<exists>\\<^sub>Al.\n             p \\<mapsto>\\<^sub>a l *\n             \\<up>\n              (a' = p \\<and>\n               s = ias_of_list l \\<and>\n               (i = length l \\<and> s' = {} \\<or>\n                i < length l \\<and>\n                i \\<in> s \\<and>\n                s' = s \\<inter> {x. i \\<le> x}))) \\<Longrightarrow>\\<^sub>A\n       (\\<exists>\\<^sub>Al.\n           p \\<mapsto>\\<^sub>a l * \\<up> (s = ias_of_list l)) *\n       true", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ias_of_list_finite[simp, intro!]: \"finite (ias_of_list l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (ias_of_list l)", "using finite_subset[OF ias_of_list_bound]"], ["proof (prove)\nusing this:\n  finite {0..<length ?l1} \\<Longrightarrow> finite (ias_of_list ?l1)\n\ngoal (1 subgoal):\n 1. finite (ias_of_list l)", "by auto"], ["", "lemma is_ias_finite[simp]: \"h \\<Turnstile> is_ias S x \\<Longrightarrow> finite S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<Turnstile> is_ias S x \\<Longrightarrow> finite S", "unfolding is_ias_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<Turnstile>\n    (\\<exists>\\<^sub>Al.\n        x \\<mapsto>\\<^sub>a l * \\<up> (S = ias_of_list l)) \\<Longrightarrow>\n    finite S", "by auto"], ["", "(* TODO: Move, replace original rules by this stronger var! *)"], ["", "lemma to_list_ga_rec_rule:\n    assumes \"imp_set_iterate is_set is_it it_init it_has_next it_next\"\n    assumes \"imp_list_prepend is_list l_prepend\"\n    assumes FIN: \"finite it\"\n    assumes DIS: \"distinct l\" \"set l \\<inter> it = {}\"\n    shows \"\n    < is_it s si it iti * is_list l li > \n      to_list_ga_rec it_has_next it_next l_prepend iti li\n    < \\<lambda>r. \\<exists>\\<^sub>Al'. is_set s si \n      * is_list l' r\n      * \\<up>(distinct l' \\<and> set l' = set l \\<union> it) >\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_it s si it iti *\n     is_list l\n      li> to_list_ga_rec it_has_next it_next l_prepend iti\n           li <\\<lambda>r.\n                  \\<exists>\\<^sub>Al'.\n                     is_set s si * is_list l' r *\n                     \\<up>\n                      (distinct l' \\<and>\n                       set l' = set l \\<union> it)>\\<^sub>t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <is_it s si it iti *\n     is_list l\n      li> to_list_ga_rec it_has_next it_next l_prepend iti\n           li <\\<lambda>r.\n                  \\<exists>\\<^sub>Al'.\n                     is_set s si * is_list l' r *\n                     \\<up>\n                      (distinct l' \\<and>\n                       set l' = set l \\<union> it)>\\<^sub>t", "interpret imp_set_iterate is_set is_it it_init it_has_next it_next\n      + imp_list_prepend is_list l_prepend"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_iterate is_set is_it it_init it_has_next it_next &&&\n    imp_list_prepend is_list l_prepend", "by fact+"], ["proof (state)\ngoal (1 subgoal):\n 1. <is_it s si it iti *\n     is_list l\n      li> to_list_ga_rec it_has_next it_next l_prepend iti\n           li <\\<lambda>r.\n                  \\<exists>\\<^sub>Al'.\n                     is_set s si * is_list l' r *\n                     \\<up>\n                      (distinct l' \\<and>\n                       set l' = set l \\<union> it)>\\<^sub>t", "from FIN DIS"], ["proof (chain)\npicking this:\n  finite it\n  distinct l\n  set l \\<inter> it = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite it\n  distinct l\n  set l \\<inter> it = {}\n\ngoal (1 subgoal):\n 1. <is_it s si it iti *\n     is_list l\n      li> to_list_ga_rec it_has_next it_next l_prepend iti\n           li <\\<lambda>r.\n                  \\<exists>\\<^sub>Al'.\n                     is_set s si * is_list l' r *\n                     \\<up>\n                      (distinct l' \\<and>\n                       set l' = set l \\<union> it)>\\<^sub>t", "proof (induction arbitrary: l li iti rule: finite_psubset_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A l li iti.\n       \\<lbrakk>finite A;\n        \\<And>B l li iti.\n           \\<lbrakk>B \\<subset> A; distinct l;\n            set l \\<inter> B = {}\\<rbrakk>\n           \\<Longrightarrow> <is_it s si B iti *\n                              is_list l\n                               li> to_list_ga_rec it_has_next it_next\n                                    l_prepend iti\n                                    li <\\<lambda>r.\n     \\<exists>\\<^sub>Al'.\n        is_set s si * is_list l' r *\n        \\<up> (distinct l' \\<and> set l' = set l \\<union> B)>\\<^sub>t;\n        distinct l; set l \\<inter> A = {}\\<rbrakk>\n       \\<Longrightarrow> <is_it s si A iti *\n                          is_list l\n                           li> to_list_ga_rec it_has_next it_next l_prepend\n                                iti\n                                li <\\<lambda>r.\n \\<exists>\\<^sub>Al'.\n    is_set s si * is_list l' r *\n    \\<up> (distinct l' \\<and> set l' = set l \\<union> A)>\\<^sub>t", "case (psubset it)"], ["proof (state)\nthis:\n  finite it\n  \\<lbrakk>?B \\<subset> it; distinct ?l; set ?l \\<inter> ?B = {}\\<rbrakk>\n  \\<Longrightarrow> <is_it s si ?B ?iti *\n                     is_list ?l\n                      ?li> to_list_ga_rec it_has_next it_next l_prepend ?iti\n                            ?li <\\<lambda>r.\n                                    \\<exists>\\<^sub>Al'.\n is_set s si * is_list l' r *\n \\<up> (distinct l' \\<and> set l' = set ?l \\<union> ?B)>\\<^sub>t\n  distinct l\n  set l \\<inter> it = {}\n\ngoal (1 subgoal):\n 1. \\<And>A l li iti.\n       \\<lbrakk>finite A;\n        \\<And>B l li iti.\n           \\<lbrakk>B \\<subset> A; distinct l;\n            set l \\<inter> B = {}\\<rbrakk>\n           \\<Longrightarrow> <is_it s si B iti *\n                              is_list l\n                               li> to_list_ga_rec it_has_next it_next\n                                    l_prepend iti\n                                    li <\\<lambda>r.\n     \\<exists>\\<^sub>Al'.\n        is_set s si * is_list l' r *\n        \\<up> (distinct l' \\<and> set l' = set l \\<union> B)>\\<^sub>t;\n        distinct l; set l \\<inter> A = {}\\<rbrakk>\n       \\<Longrightarrow> <is_it s si A iti *\n                          is_list l\n                           li> to_list_ga_rec it_has_next it_next l_prepend\n                                iti\n                                li <\\<lambda>r.\n \\<exists>\\<^sub>Al'.\n    is_set s si * is_list l' r *\n    \\<up> (distinct l' \\<and> set l' = set l \\<union> A)>\\<^sub>t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_it s si it iti *\n     is_list l\n      li> to_list_ga_rec it_has_next it_next l_prepend iti\n           li <\\<lambda>r.\n                  \\<exists>\\<^sub>Al'.\n                     is_set s si * is_list l' r *\n                     \\<up>\n                      (distinct l' \\<and>\n                       set l' = set l \\<union> it)>\\<^sub>t", "apply (subst to_list_ga_rec.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_it s si it iti *\n     is_list l\n      li> it_has_next iti \\<bind>\n          (\\<lambda>b.\n              if b\n              then it_next iti \\<bind>\n                   (\\<lambda>(x, it).\n                       l_prepend x li \\<bind>\n                       to_list_ga_rec it_has_next it_next l_prepend it)\n              else return\n                    li) <\\<lambda>r.\n                            \\<exists>\\<^sub>Al'.\n                               is_set s si * is_list l' r *\n                               \\<up>\n                                (distinct l' \\<and>\n                                 set l' = set l \\<union> it)>\\<^sub>t", "using psubset.prems"], ["proof (prove)\nusing this:\n  distinct l\n  set l \\<inter> it = {}\n\ngoal (1 subgoal):\n 1. <is_it s si it iti *\n     is_list l\n      li> it_has_next iti \\<bind>\n          (\\<lambda>b.\n              if b\n              then it_next iti \\<bind>\n                   (\\<lambda>(x, it).\n                       l_prepend x li \\<bind>\n                       to_list_ga_rec it_has_next it_next l_prepend it)\n              else return\n                    li) <\\<lambda>r.\n                            \\<exists>\\<^sub>Al'.\n                               is_set s si * is_list l' r *\n                               \\<up>\n                                (distinct l' \\<and>\n                                 set l' = set l \\<union> it)>\\<^sub>t", "apply (sep_auto heap: psubset.IH)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>distinct l; \\<not> x; it = {}\\<rbrakk>\n       \\<Longrightarrow> is_it s si {} iti *\n                         is_list l li \\<Longrightarrow>\\<^sub>A\n                         is_set s si * is_list l li * true", "apply (rule ent_frame_fwd[OF quit_iteration])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>distinct l; \\<not> x; it = {}\\<rbrakk>\n       \\<Longrightarrow> is_it s si {} iti *\n                         is_list l li \\<Longrightarrow>\\<^sub>A\n                         is_it (?s246 x) (?p246 x) (?s'246 x) (?it246 x) *\n                         ?F245 x\n 2. \\<And>x.\n       \\<lbrakk>distinct l; \\<not> x; it = {}\\<rbrakk>\n       \\<Longrightarrow> is_set (?s246 x) (?p246 x) * true *\n                         ?F245 x \\<Longrightarrow>\\<^sub>A\n                         is_set s si * is_list l li * true", "apply frame_inference"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>distinct l; \\<not> x; it = {}\\<rbrakk>\n       \\<Longrightarrow> is_set s si * true *\n                         is_list l li \\<Longrightarrow>\\<^sub>A\n                         is_set s si * is_list l li * true", "apply solve_entails"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <is_it s si it iti *\n   is_list l\n    li> to_list_ga_rec it_has_next it_next l_prepend iti\n         li <\\<lambda>r.\n                \\<exists>\\<^sub>Al'.\n                   is_set s si * is_list l' r *\n                   \\<up>\n                    (distinct l' \\<and> set l' = set l \\<union> it)>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  <is_it s si it iti *\n   is_list l\n    li> to_list_ga_rec it_has_next it_next l_prepend iti\n         li <\\<lambda>r.\n                \\<exists>\\<^sub>Al'.\n                   is_set s si * is_list l' r *\n                   \\<up>\n                    (distinct l' \\<and> set l' = set l \\<union> it)>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma to_list_ga_rule:\n    assumes IT: \"imp_set_iterate is_set is_it it_init it_has_next it_next\"\n    assumes EM: \"imp_list_empty is_list l_empty\"\n    assumes PREP: \"imp_list_prepend is_list l_prepend\"\n    assumes FIN: \"finite s\"\n    shows \"\n    <is_set s si>\n    to_list_ga it_init it_has_next it_next\n      l_empty l_prepend si\n    <\\<lambda>r. \\<exists>\\<^sub>Al. is_set s si * is_list l r * true * \\<up>(distinct l \\<and> set l = s)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_set s si>\n    to_list_ga it_init it_has_next it_next l_empty l_prepend si\n    <\\<lambda>r.\n        \\<exists>\\<^sub>Al.\n           is_set s si * is_list l r * true *\n           \\<up> (distinct l \\<and> set l = s)>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <is_set s si>\n    to_list_ga it_init it_has_next it_next l_empty l_prepend si\n    <\\<lambda>r.\n        \\<exists>\\<^sub>Al.\n           is_set s si * is_list l r * true *\n           \\<up> (distinct l \\<and> set l = s)>", "interpret imp_list_empty is_list l_empty +\n      imp_set_iterate is_set is_it it_init it_has_next it_next"], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_empty is_list l_empty &&&\n    imp_set_iterate is_set is_it it_init it_has_next it_next", "by fact+"], ["proof (state)\ngoal (1 subgoal):\n 1. <is_set s si>\n    to_list_ga it_init it_has_next it_next l_empty l_prepend si\n    <\\<lambda>r.\n        \\<exists>\\<^sub>Al.\n           is_set s si * is_list l r * true *\n           \\<up> (distinct l \\<and> set l = s)>", "note [sep_heap_rules] = to_list_ga_rec_rule[OF IT PREP]"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?it; distinct ?l; set ?l \\<inter> ?it = {}\\<rbrakk>\n  \\<Longrightarrow> <is_it ?s ?si ?it ?iti *\n                     is_list ?l\n                      ?li> to_list_ga_rec it_has_next it_next l_prepend ?iti\n                            ?li <\\<lambda>r.\n                                    \\<exists>\\<^sub>Al'.\n is_set ?s ?si * is_list l' r *\n \\<up> (distinct l' \\<and> set l' = set ?l \\<union> ?it)>\\<^sub>t\n\ngoal (1 subgoal):\n 1. <is_set s si>\n    to_list_ga it_init it_has_next it_next l_empty l_prepend si\n    <\\<lambda>r.\n        \\<exists>\\<^sub>Al.\n           is_set s si * is_list l r * true *\n           \\<up> (distinct l \\<and> set l = s)>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_set s si>\n    to_list_ga it_init it_has_next it_next l_empty l_prepend si\n    <\\<lambda>r.\n        \\<exists>\\<^sub>Al.\n           is_set s si * is_list l r * true *\n           \\<up> (distinct l \\<and> set l = s)>", "unfolding to_list_ga_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_set s si>\n    it_init si \\<bind>\n    (\\<lambda>it.\n        l_empty \\<bind>\n        (\\<lambda>l.\n            to_list_ga_rec it_has_next it_next l_prepend it l \\<bind>\n            return))\n    <\\<lambda>r.\n        \\<exists>\\<^sub>Al.\n           is_set s si * is_list l r * true *\n           \\<up> (distinct l \\<and> set l = s)>", "by (sep_auto simp: FIN)"], ["proof (state)\nthis:\n  <is_set s si> to_list_ga it_init it_has_next it_next l_empty l_prepend si\n  <\\<lambda>r.\n      \\<exists>\\<^sub>Al.\n         is_set s si * is_list l r * true *\n         \\<up> (distinct l \\<and> set l = s)>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Binding Locales\\<close>"], ["", "method solve_sepl_binding = (\n    unfold_locales;\n    (unfold option_assn_pure_conv)?;\n    sep_auto \n      intro!: hfrefI hn_refineI[THEN hn_refine_preI]\n      simp: invalid_assn_def hn_ctxt_def pure_def\n  )"], ["", "subsubsection \\<open>Map\\<close>"], ["", "locale bind_map = imp_map is_map for is_map :: \"('ki \\<rightharpoonup> 'vi) \\<Rightarrow> 'm \\<Rightarrow> assn\"\n  begin"], ["", "definition \"assn K V \\<equiv> hr_comp is_map (\\<langle>the_pure K,the_pure V\\<rangle>map_rel)\""], ["", "lemmas [fcomp_norm_unfold] = assn_def[symmetric]"], ["", "lemmas [safe_constraint_rules] = CN_FALSEI[of is_pure \"assn K V\" for K V]"], ["", "end"], ["", "locale bind_map_empty = imp_map_empty + bind_map\n  begin"], ["", "lemma empty_hnr_aux: \"(uncurry0 empty,uncurry0 (RETURN op_map_empty)) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 empty, uncurry0 (RETURN op_map_empty))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_map", "by solve_sepl_binding"], ["", "sepref_decl_impl (no_register) empty: empty_hnr_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "locale bind_map_is_empty = imp_map_is_empty + bind_map\n  begin"], ["", "lemma is_empty_hnr_aux: \"(is_empty,RETURN o op_map_is_empty) \\<in> is_map\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_empty, RETURN \\<circ> op_map_is_empty)\n    \\<in> is_map\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by solve_sepl_binding"], ["", "sepref_decl_impl is_empty: is_empty_hnr_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "locale bind_map_update = imp_map_update + bind_map\n  begin"], ["", "lemma update_hnr_aux: \"(uncurry2 update,uncurry2 (RETURN ooo op_map_update)) \\<in> id_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k *\\<^sub>a is_map\\<^sup>d \\<rightarrow>\\<^sub>a is_map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 update, uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_map_update))\n    \\<in> id_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k *\\<^sub>a\n          is_map\\<^sup>d \\<rightarrow>\\<^sub>a is_map", "by solve_sepl_binding"], ["", "sepref_decl_impl update: update_hnr_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "locale bind_map_delete = imp_map_delete + bind_map\n  begin"], ["", "lemma delete_hnr_aux: \"(uncurry delete,uncurry (RETURN oo op_map_delete)) \\<in> id_assn\\<^sup>k *\\<^sub>a is_map\\<^sup>d \\<rightarrow>\\<^sub>a is_map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry delete, uncurry (RETURN \\<circ>\\<circ> op_map_delete))\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          is_map\\<^sup>d \\<rightarrow>\\<^sub>a is_map", "by solve_sepl_binding"], ["", "sepref_decl_impl delete: delete_hnr_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "locale bind_map_lookup = imp_map_lookup + bind_map\n  begin"], ["", "lemma lookup_hnr_aux: \"(uncurry lookup,uncurry (RETURN oo op_map_lookup)) \\<in> id_assn\\<^sup>k *\\<^sub>a is_map\\<^sup>k \\<rightarrow>\\<^sub>a id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry lookup, uncurry (RETURN \\<circ>\\<circ> op_map_lookup))\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          is_map\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "by solve_sepl_binding"], ["", "sepref_decl_impl lookup: lookup_hnr_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "locale bind_map_contains_key = imp_map_contains_key + bind_map\n  begin"], ["", "lemma contains_key_hnr_aux: \"(uncurry contains_key,uncurry (RETURN oo op_map_contains_key)) \\<in> id_assn\\<^sup>k *\\<^sub>a is_map\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry contains_key,\n     uncurry (RETURN \\<circ>\\<circ> op_map_contains_key))\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          is_map\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by solve_sepl_binding"], ["", "sepref_decl_impl contains_key: contains_key_hnr_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "subsubsection \\<open>Set\\<close>"], ["", "locale bind_set = imp_set is_set for is_set :: \"('ai set) \\<Rightarrow> 'm \\<Rightarrow> assn\" +\n    fixes A :: \"'a \\<Rightarrow> 'ai \\<Rightarrow> assn\"\n  begin"], ["", "definition \"assn \\<equiv> hr_comp is_set (\\<langle>the_pure A\\<rangle>set_rel)\""], ["", "lemmas [safe_constraint_rules] = CN_FALSEI[of is_pure \"assn\"]"], ["", "end"], ["", "locale bind_set_setup = bind_set \n  begin"], ["", "(* TODO: Use sepref_decl_impl (see map) *)"], ["", "lemmas [fcomp_norm_unfold] = assn_def[symmetric]"], ["", "lemma APA: \"\\<lbrakk>PROP Q; CONSTRAINT is_pure A\\<rbrakk> \\<Longrightarrow> PROP Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PROP Q; CONSTRAINT is_pure A\\<rbrakk> \\<Longrightarrow> PROP Q", "."], ["", "lemma APAlu: \"\\<lbrakk>PROP Q; CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) A\\<rbrakk> \\<Longrightarrow> PROP Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PROP Q; CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) A\\<rbrakk>\n    \\<Longrightarrow> PROP Q", "."], ["", "lemma APAru: \"\\<lbrakk>PROP Q; CONSTRAINT (IS_PURE IS_RIGHT_UNIQUE) A\\<rbrakk> \\<Longrightarrow> PROP Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PROP Q; CONSTRAINT (IS_PURE single_valued) A\\<rbrakk>\n    \\<Longrightarrow> PROP Q", "."], ["", "lemma APAbu: \"\\<lbrakk>PROP Q; CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) A; CONSTRAINT (IS_PURE IS_RIGHT_UNIQUE) A\\<rbrakk> \\<Longrightarrow> PROP Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PROP Q; CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) A;\n     CONSTRAINT (IS_PURE single_valued) A\\<rbrakk>\n    \\<Longrightarrow> PROP Q", "."], ["", "end"], ["", "locale bind_set_empty = imp_set_empty + bind_set\n  begin"], ["", "lemma hnr_empty_aux: \"(uncurry0 empty,uncurry0 (RETURN op_set_empty))\\<in>unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 empty, uncurry0 (RETURN op_set_empty))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_set", "by solve_sepl_binding"], ["", "interpretation bind_set_setup"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_set_setup is_set", "by standard"], ["", "lemmas hnr_op_empty = hnr_empty_aux[FCOMP op_set_empty.fref[where A=\"the_pure A\"]]"], ["", "lemmas hnr_mop_empty = hnr_op_empty[FCOMP mk_mop_rl0_np[OF mop_set_empty_alt]]"], ["", "end"], ["", "locale bind_set_is_empty = imp_set_is_empty + bind_set\n  begin"], ["", "lemma hnr_is_empty_aux: \"(is_empty, RETURN o op_set_is_empty)\\<in>is_set\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_empty, RETURN \\<circ> op_set_is_empty)\n    \\<in> is_set\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by solve_sepl_binding"], ["", "interpretation bind_set_setup"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_set_setup is_set", "by standard"], ["", "lemmas hnr_op_is_empty[sepref_fr_rules] = hnr_is_empty_aux[THEN APA,FCOMP op_set_is_empty.fref[where A=\"the_pure A\"]]"], ["", "lemmas hnr_mop_is_empty[sepref_fr_rules] = hnr_op_is_empty[FCOMP mk_mop_rl1_np[OF mop_set_is_empty_alt]]"], ["", "end"], ["", "locale bind_set_member = imp_set_memb + bind_set\n  begin"], ["", "lemma hnr_member_aux: \"(uncurry memb, uncurry (RETURN oo op_set_member))\\<in>id_assn\\<^sup>k *\\<^sub>a is_set\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry memb, uncurry (RETURN \\<circ>\\<circ> op_set_member))\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          is_set\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by solve_sepl_binding"], ["", "interpretation bind_set_setup"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_set_setup is_set", "by standard"], ["", "lemmas hnr_op_member[sepref_fr_rules] = hnr_member_aux[THEN APAbu,FCOMP op_set_member.fref[where A=\"the_pure A\"]]"], ["", "lemmas hnr_mop_member[sepref_fr_rules] = hnr_op_member[FCOMP mk_mop_rl2_np[OF mop_set_member_alt]]"], ["", "end"], ["", "locale bind_set_insert = imp_set_ins + bind_set\n  begin"], ["", "lemma hnr_insert_aux: \"(uncurry ins, uncurry (RETURN oo op_set_insert))\\<in>id_assn\\<^sup>k *\\<^sub>a is_set\\<^sup>d \\<rightarrow>\\<^sub>a is_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ins, uncurry (RETURN \\<circ>\\<circ> op_set_insert))\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          is_set\\<^sup>d \\<rightarrow>\\<^sub>a is_set", "by solve_sepl_binding"], ["", "interpretation bind_set_setup"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_set_setup is_set", "by standard"], ["", "lemmas hnr_op_insert[sepref_fr_rules] = hnr_insert_aux[THEN APAru,FCOMP op_set_insert.fref[where A=\"the_pure A\"]]"], ["", "lemmas hnr_mop_insert[sepref_fr_rules] = hnr_op_insert[FCOMP mk_mop_rl2_np[OF mop_set_insert_alt]]"], ["", "end"], ["", "locale bind_set_delete = imp_set_delete + bind_set\n  begin"], ["", "lemma hnr_delete_aux: \"(uncurry delete, uncurry (RETURN oo op_set_delete))\\<in>id_assn\\<^sup>k *\\<^sub>a is_set\\<^sup>d \\<rightarrow>\\<^sub>a is_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry delete, uncurry (RETURN \\<circ>\\<circ> op_set_delete))\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          is_set\\<^sup>d \\<rightarrow>\\<^sub>a is_set", "by solve_sepl_binding"], ["", "interpretation bind_set_setup"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_set_setup is_set", "by standard"], ["", "lemmas hnr_op_delete[sepref_fr_rules] = hnr_delete_aux[THEN APAbu,FCOMP op_set_delete.fref[where A=\"the_pure A\"]]"], ["", "lemmas hnr_mop_delete[sepref_fr_rules] = hnr_op_delete[FCOMP mk_mop_rl2_np[OF mop_set_delete_alt]]"], ["", "end"], ["", "primrec sorted_wrt' where\n    \"sorted_wrt' R [] \\<longleftrightarrow> True\"\n  | \"sorted_wrt' R (x#xs) \\<longleftrightarrow> list_all (R x) xs \\<and> sorted_wrt' R xs\""], ["", "lemma sorted_wrt'_eq: \"sorted_wrt' = sorted_wrt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt' = sorted_wrt", "proof (intro ext iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa. sorted_wrt' x xa \\<Longrightarrow> sorted_wrt x xa\n 2. \\<And>x xa. sorted_wrt x xa \\<Longrightarrow> sorted_wrt' x xa", "fix R :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" and xs :: \"'a list\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa. sorted_wrt' x xa \\<Longrightarrow> sorted_wrt x xa\n 2. \\<And>x xa. sorted_wrt x xa \\<Longrightarrow> sorted_wrt' x xa", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa. sorted_wrt' x xa \\<Longrightarrow> sorted_wrt x xa\n 2. \\<And>x xa. sorted_wrt x xa \\<Longrightarrow> sorted_wrt' x xa", "assume \"sorted_wrt R xs\""], ["proof (state)\nthis:\n  sorted_wrt R xs\n\ngoal (2 subgoals):\n 1. \\<And>x xa. sorted_wrt' x xa \\<Longrightarrow> sorted_wrt x xa\n 2. \\<And>x xa. sorted_wrt x xa \\<Longrightarrow> sorted_wrt' x xa", "thus \"sorted_wrt' R xs\""], ["proof (prove)\nusing this:\n  sorted_wrt R xs\n\ngoal (1 subgoal):\n 1. sorted_wrt' R xs", "by (induction xs)(auto simp: list_all_iff sorted_sorted_wrt[symmetric])"], ["proof (state)\nthis:\n  sorted_wrt' R xs\n\ngoal (1 subgoal):\n 1. \\<And>x xa. sorted_wrt' x xa \\<Longrightarrow> sorted_wrt x xa", "}"], ["proof (state)\nthis:\n  sorted_wrt R xs \\<Longrightarrow> sorted_wrt' R xs\n\ngoal (1 subgoal):\n 1. \\<And>x xa. sorted_wrt' x xa \\<Longrightarrow> sorted_wrt x xa", "{"], ["proof (state)\nthis:\n  sorted_wrt R xs \\<Longrightarrow> sorted_wrt' R xs\n\ngoal (1 subgoal):\n 1. \\<And>x xa. sorted_wrt' x xa \\<Longrightarrow> sorted_wrt x xa", "assume \"sorted_wrt' R xs\""], ["proof (state)\nthis:\n  sorted_wrt' R xs\n\ngoal (1 subgoal):\n 1. \\<And>x xa. sorted_wrt' x xa \\<Longrightarrow> sorted_wrt x xa", "thus \"sorted_wrt R xs\""], ["proof (prove)\nusing this:\n  sorted_wrt' R xs\n\ngoal (1 subgoal):\n 1. sorted_wrt R xs", "by (induction xs) (auto simp: list_all_iff)"], ["proof (state)\nthis:\n  sorted_wrt R xs\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  sorted_wrt' R xs \\<Longrightarrow> sorted_wrt R xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma param_sorted_wrt[param]: \"(sorted_wrt, sorted_wrt) \\<in> (A \\<rightarrow> A \\<rightarrow> bool_rel) \\<rightarrow> \\<langle>A\\<rangle>list_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sorted_wrt, sorted_wrt)\n    \\<in> (A \\<rightarrow> A \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>A\\<rangle>list_rel \\<rightarrow> bool_rel", "unfolding sorted_wrt'_eq[symmetric] sorted_wrt'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>uu uua.\n        rec_list (\\<lambda>R. True)\n         (\\<lambda>x xs xsa R. list_all (R x) xs \\<and> xsa R) uua uu,\n     \\<lambda>uu uua.\n        rec_list (\\<lambda>R. True)\n         (\\<lambda>x xs xsa R. list_all (R x) xs \\<and> xsa R) uua uu)\n    \\<in> (A \\<rightarrow> A \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>A\\<rangle>list_rel \\<rightarrow> bool_rel", "by parametricity"], ["", "lemma obtain_list_from_setrel:\n    assumes SV: \"single_valued A\"\n    assumes \"(set l,s) \\<in> \\<langle>A\\<rangle>set_rel\"\n    obtains m where \"s=set m\" \"(l,m)\\<in>\\<langle>A\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>s = set m;\n         (l, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  (set l, s) \\<in> \\<langle>A\\<rangle>set_rel\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>s = set m;\n         (l, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induction l arbitrary: s thesis)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s thesis.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>s = set m;\n                    ([], m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        (set [], s) \\<in> \\<langle>A\\<rangle>set_rel\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a l s thesis.\n       \\<lbrakk>\\<And>s thesis.\n                   \\<lbrakk>\\<And>m.\n                               \\<lbrakk>s = set m;\n                                (l, m)\n                                \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    (set l, s) \\<in> \\<langle>A\\<rangle>set_rel\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>m.\n           \\<lbrakk>s = set m;\n            (a # l, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        (set (a # l), s) \\<in> \\<langle>A\\<rangle>set_rel\\<rbrakk>\n       \\<Longrightarrow> thesis", "case Nil"], ["proof (state)\nthis:\n  \\<lbrakk>s = set ?m; ([], ?m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n  \\<Longrightarrow> thesis\n  (set [], s) \\<in> \\<langle>A\\<rangle>set_rel\n\ngoal (2 subgoals):\n 1. \\<And>s thesis.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>s = set m;\n                    ([], m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        (set [], s) \\<in> \\<langle>A\\<rangle>set_rel\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a l s thesis.\n       \\<lbrakk>\\<And>s thesis.\n                   \\<lbrakk>\\<And>m.\n                               \\<lbrakk>s = set m;\n                                (l, m)\n                                \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    (set l, s) \\<in> \\<langle>A\\<rangle>set_rel\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>m.\n           \\<lbrakk>s = set m;\n            (a # l, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        (set (a # l), s) \\<in> \\<langle>A\\<rangle>set_rel\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "apply (rule Nil(1)[where m=\"[]\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. s = set []\n 2. ([], []) \\<in> \\<langle>A\\<rangle>list_rel", "using Nil(2)"], ["proof (prove)\nusing this:\n  (set [], s) \\<in> \\<langle>A\\<rangle>set_rel\n\ngoal (2 subgoals):\n 1. s = set []\n 2. ([], []) \\<in> \\<langle>A\\<rangle>list_rel", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>a l s thesis.\n       \\<lbrakk>\\<And>s thesis.\n                   \\<lbrakk>\\<And>m.\n                               \\<lbrakk>s = set m;\n                                (l, m)\n                                \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    (set l, s) \\<in> \\<langle>A\\<rangle>set_rel\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>m.\n           \\<lbrakk>s = set m;\n            (a # l, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        (set (a # l), s) \\<in> \\<langle>A\\<rangle>set_rel\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l s thesis.\n       \\<lbrakk>\\<And>s thesis.\n                   \\<lbrakk>\\<And>m.\n                               \\<lbrakk>s = set m;\n                                (l, m)\n                                \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    (set l, s) \\<in> \\<langle>A\\<rangle>set_rel\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>m.\n           \\<lbrakk>s = set m;\n            (a # l, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        (set (a # l), s) \\<in> \\<langle>A\\<rangle>set_rel\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Cons x l)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>m.\n              \\<lbrakk>?s = set m;\n               (l, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   (set l, ?s) \\<in> \\<langle>A\\<rangle>set_rel\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>s = set ?m;\n   (x # l, ?m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n  \\<Longrightarrow> thesis\n  (set (x # l), s) \\<in> \\<langle>A\\<rangle>set_rel\n\ngoal (1 subgoal):\n 1. \\<And>a l s thesis.\n       \\<lbrakk>\\<And>s thesis.\n                   \\<lbrakk>\\<And>m.\n                               \\<lbrakk>s = set m;\n                                (l, m)\n                                \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    (set l, s) \\<in> \\<langle>A\\<rangle>set_rel\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>m.\n           \\<lbrakk>s = set m;\n            (a # l, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        (set (a # l), s) \\<in> \\<langle>A\\<rangle>set_rel\\<rbrakk>\n       \\<Longrightarrow> thesis", "obtain s' y where \"s=insert y s'\" \"(x,y)\\<in>A\" \"(set l,s')\\<in>\\<langle>A\\<rangle>set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y s'.\n        \\<lbrakk>s = insert y s'; (x, y) \\<in> A;\n         (set l, s') \\<in> \\<langle>A\\<rangle>set_rel\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>y s'.\n        \\<lbrakk>s = insert y s'; (x, y) \\<in> A;\n         (set l, s') \\<in> \\<langle>A\\<rangle>set_rel\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from Cons.prems(2)"], ["proof (chain)\npicking this:\n  (set (x # l), s) \\<in> \\<langle>A\\<rangle>set_rel", "obtain y where X0: \"y\\<in>s\" \"(x,y)\\<in>A\""], ["proof (prove)\nusing this:\n  (set (x # l), s) \\<in> \\<langle>A\\<rangle>set_rel\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> s; (x, y) \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_rel_def"], ["proof (prove)\nusing this:\n  (set (x # l), s)\n  \\<in> {(Aa, B).\n         (\\<forall>x\\<in>Aa. \\<exists>y\\<in>B. (x, y) \\<in> A) \\<and>\n         (\\<forall>y\\<in>B. \\<exists>x\\<in>Aa. (x, y) \\<in> A)}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> s; (x, y) \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> s\n  (x, y) \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<And>y s'.\n        \\<lbrakk>s = insert y s'; (x, y) \\<in> A;\n         (set l, s') \\<in> \\<langle>A\\<rangle>set_rel\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from Cons.prems(2)"], ["proof (chain)\npicking this:\n  (set (x # l), s) \\<in> \\<langle>A\\<rangle>set_rel", "have \n        X1: \"\\<forall>a\\<in>set l. \\<exists>b\\<in>s. (a,b)\\<in>A\" and\n        X2: \"\\<forall>b\\<in>s. \\<exists>a\\<in>insert x (set l). (a,b)\\<in>A\""], ["proof (prove)\nusing this:\n  (set (x # l), s) \\<in> \\<langle>A\\<rangle>set_rel\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set l. \\<exists>b\\<in>s. (a, b) \\<in> A &&&\n    \\<forall>b\\<in>s. \\<exists>a\\<in>insert x (set l). (a, b) \\<in> A", "unfolding set_rel_def"], ["proof (prove)\nusing this:\n  (set (x # l), s)\n  \\<in> {(Aa, B).\n         (\\<forall>x\\<in>Aa. \\<exists>y\\<in>B. (x, y) \\<in> A) \\<and>\n         (\\<forall>y\\<in>B. \\<exists>x\\<in>Aa. (x, y) \\<in> A)}\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set l. \\<exists>b\\<in>s. (a, b) \\<in> A &&&\n    \\<forall>b\\<in>s. \\<exists>a\\<in>insert x (set l). (a, b) \\<in> A", "by auto"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set l. \\<exists>b\\<in>s. (a, b) \\<in> A\n  \\<forall>b\\<in>s. \\<exists>a\\<in>insert x (set l). (a, b) \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<And>y s'.\n        \\<lbrakk>s = insert y s'; (x, y) \\<in> A;\n         (set l, s') \\<in> \\<langle>A\\<rangle>set_rel\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"\\<exists>a\\<in>set l. (a,y)\\<in>A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a\\<in>set l. (a, y) \\<in> A \\<Longrightarrow> thesis\n 2. \\<not> (\\<exists>a\\<in>set l. (a, y) \\<in> A) \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  \\<exists>a\\<in>set l. (a, y) \\<in> A\n\ngoal (2 subgoals):\n 1. \\<exists>a\\<in>set l. (a, y) \\<in> A \\<Longrightarrow> thesis\n 2. \\<not> (\\<exists>a\\<in>set l. (a, y) \\<in> A) \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "apply (rule that[of y s])"], ["proof (prove)\ngoal (3 subgoals):\n 1. s = insert y s\n 2. (x, y) \\<in> A\n 3. (set l, s) \\<in> \\<langle>A\\<rangle>set_rel", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. s = insert y s", "using X0"], ["proof (prove)\nusing this:\n  y \\<in> s\n  (x, y) \\<in> A\n\ngoal (1 subgoal):\n 1. s = insert y s", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. (x, y) \\<in> A\n 2. (set l, s) \\<in> \\<langle>A\\<rangle>set_rel", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> A", "by fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. (set l, s) \\<in> \\<langle>A\\<rangle>set_rel", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (set l, s) \\<in> \\<langle>A\\<rangle>set_rel", "apply (rule set_relI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set l \\<Longrightarrow> \\<exists>y\\<in>s. (x, y) \\<in> A\n 2. \\<And>y.\n       y \\<in> s \\<Longrightarrow> \\<exists>x\\<in>set l. (x, y) \\<in> A", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> set l \\<Longrightarrow> \\<exists>y\\<in>s. (x_, y) \\<in> A", "using X1"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set l. \\<exists>b\\<in>s. (a, b) \\<in> A\n\ngoal (1 subgoal):\n 1. x_ \\<in> set l \\<Longrightarrow> \\<exists>y\\<in>s. (x_, y) \\<in> A", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> s \\<Longrightarrow> \\<exists>x\\<in>set l. (x, y) \\<in> A", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. y_ \\<in> s \\<Longrightarrow> \\<exists>x\\<in>set l. (x, y_) \\<in> A", "by (metis IS_RIGHT_UNIQUED SV True X0(2) X2 insert_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>set l. (a, y) \\<in> A) \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>set l. (a, y) \\<in> A) \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>a\\<in>set l. (a, y) \\<in> A)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>a\\<in>set l. (a, y) \\<in> A) \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "apply (rule that[of y \"s-{y}\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. s = insert y (s - {y})\n 2. (x, y) \\<in> A\n 3. (set l, s - {y}) \\<in> \\<langle>A\\<rangle>set_rel", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. s = insert y (s - {y})", "using X0"], ["proof (prove)\nusing this:\n  y \\<in> s\n  (x, y) \\<in> A\n\ngoal (1 subgoal):\n 1. s = insert y (s - {y})", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. (x, y) \\<in> A\n 2. (set l, s - {y}) \\<in> \\<langle>A\\<rangle>set_rel", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> A", "by fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. (set l, s - {y}) \\<in> \\<langle>A\\<rangle>set_rel", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (set l, s - {y}) \\<in> \\<langle>A\\<rangle>set_rel", "apply (rule set_relI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set l \\<Longrightarrow>\n       \\<exists>y\\<in>s - {y}. (x, y) \\<in> A\n 2. \\<And>ya.\n       ya \\<in> s - {y} \\<Longrightarrow>\n       \\<exists>x\\<in>set l. (x, ya) \\<in> A", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> set l \\<Longrightarrow> \\<exists>y\\<in>s - {y}. (x_, y) \\<in> A", "using False X1"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>a\\<in>set l. (a, y) \\<in> A)\n  \\<forall>a\\<in>set l. \\<exists>b\\<in>s. (a, b) \\<in> A\n\ngoal (1 subgoal):\n 1. x_ \\<in> set l \\<Longrightarrow> \\<exists>y\\<in>s - {y}. (x_, y) \\<in> A", "by fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ya.\n       ya \\<in> s - {y} \\<Longrightarrow>\n       \\<exists>x\\<in>set l. (x, ya) \\<in> A", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ya_ \\<in> s - {y} \\<Longrightarrow>\n    \\<exists>x\\<in>set l. (x, ya_) \\<in> A", "using IS_RIGHT_UNIQUED SV X0(2) X2"], ["proof (prove)\nusing this:\n  \\<lbrakk>single_valued ?r; (?x, ?y) \\<in> ?r; (?x, ?z) \\<in> ?r\\<rbrakk>\n  \\<Longrightarrow> ?y = ?z\n  single_valued A\n  (x, y) \\<in> A\n  \\<forall>b\\<in>s. \\<exists>a\\<in>insert x (set l). (a, b) \\<in> A\n\ngoal (1 subgoal):\n 1. ya_ \\<in> s - {y} \\<Longrightarrow>\n    \\<exists>x\\<in>set l. (x, ya_) \\<in> A", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s = insert y s'\n  (x, y) \\<in> A\n  (set l, s') \\<in> \\<langle>A\\<rangle>set_rel\n\ngoal (1 subgoal):\n 1. \\<And>a l s thesis.\n       \\<lbrakk>\\<And>s thesis.\n                   \\<lbrakk>\\<And>m.\n                               \\<lbrakk>s = set m;\n                                (l, m)\n                                \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    (set l, s) \\<in> \\<langle>A\\<rangle>set_rel\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>m.\n           \\<lbrakk>s = set m;\n            (a # l, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        (set (a # l), s) \\<in> \\<langle>A\\<rangle>set_rel\\<rbrakk>\n       \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  s = insert y s'\n  (x, y) \\<in> A\n  (set l, s') \\<in> \\<langle>A\\<rangle>set_rel\n\ngoal (1 subgoal):\n 1. \\<And>a l s thesis.\n       \\<lbrakk>\\<And>s thesis.\n                   \\<lbrakk>\\<And>m.\n                               \\<lbrakk>s = set m;\n                                (l, m)\n                                \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    (set l, s) \\<in> \\<langle>A\\<rangle>set_rel\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>m.\n           \\<lbrakk>s = set m;\n            (a # l, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        (set (a # l), s) \\<in> \\<langle>A\\<rangle>set_rel\\<rbrakk>\n       \\<Longrightarrow> thesis", "from Cons.IH[OF _ \\<open>(set l,s')\\<in>\\<langle>A\\<rangle>set_rel\\<close>]"], ["proof (chain)\npicking this:\n  (\\<And>m.\n      \\<lbrakk>s' = set m; (l, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain m where \"s'=set m\" \"(l,m)\\<in>\\<langle>A\\<rangle>list_rel\""], ["proof (prove)\nusing this:\n  (\\<And>m.\n      \\<lbrakk>s' = set m; (l, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>s' = set m;\n         (l, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  s' = set m\n  (l, m) \\<in> \\<langle>A\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. \\<And>a l s thesis.\n       \\<lbrakk>\\<And>s thesis.\n                   \\<lbrakk>\\<And>m.\n                               \\<lbrakk>s = set m;\n                                (l, m)\n                                \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    (set l, s) \\<in> \\<langle>A\\<rangle>set_rel\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>m.\n           \\<lbrakk>s = set m;\n            (a # l, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        (set (a # l), s) \\<in> \\<langle>A\\<rangle>set_rel\\<rbrakk>\n       \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  s = insert y s'\n  (x, y) \\<in> A\n  (set l, s') \\<in> \\<langle>A\\<rangle>set_rel\n  s' = set m\n  (l, m) \\<in> \\<langle>A\\<rangle>list_rel", "show thesis"], ["proof (prove)\nusing this:\n  s = insert y s'\n  (x, y) \\<in> A\n  (set l, s') \\<in> \\<langle>A\\<rangle>set_rel\n  s' = set m\n  (l, m) \\<in> \\<langle>A\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s = insert y s'; (x, y) \\<in> A;\n     (set l, s') \\<in> \\<langle>A\\<rangle>set_rel; s' = set m;\n     (l, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (rule Cons.prems(1)[of \"y#m\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>s = insert y s'; (x, y) \\<in> A;\n     (set l, s') \\<in> \\<langle>A\\<rangle>set_rel; s' = set m;\n     (l, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> s = set (y # m)\n 2. \\<lbrakk>s = insert y s'; (x, y) \\<in> A;\n     (set l, s') \\<in> \\<langle>A\\<rangle>set_rel; s' = set m;\n     (l, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n    \\<Longrightarrow> (x # l, y # m) \\<in> \\<langle>A\\<rangle>list_rel", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma param_it_to_sorted_list[param]: \"\\<lbrakk>IS_LEFT_UNIQUE A; IS_RIGHT_UNIQUE A\\<rbrakk> \\<Longrightarrow> (it_to_sorted_list, it_to_sorted_list) \\<in> (A \\<rightarrow> A \\<rightarrow> bool_rel) \\<rightarrow> \\<langle>A\\<rangle>set_rel \\<rightarrow> \\<langle>\\<langle>A\\<rangle>list_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IS_LEFT_UNIQUE A; single_valued A\\<rbrakk>\n    \\<Longrightarrow> (it_to_sorted_list, it_to_sorted_list)\n                      \\<in> (A \\<rightarrow>\n                             A \\<rightarrow> bool_rel) \\<rightarrow>\n                            \\<langle>A\\<rangle>set_rel \\<rightarrow>\n                            \\<langle>\\<langle>A\\<rangle>list_rel\\<rangle>nres_rel", "unfolding it_to_sorted_list_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IS_LEFT_UNIQUE A; single_valued A\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>R s.\n                          SPEC\n                           (\\<lambda>l.\n                               distinct l \\<and>\n                               s = set l \\<and> sorted_wrt R l),\n                       \\<lambda>R s.\n                          SPEC\n                           (\\<lambda>l.\n                               distinct l \\<and>\n                               s = set l \\<and> sorted_wrt R l))\n                      \\<in> (A \\<rightarrow>\n                             A \\<rightarrow> bool_rel) \\<rightarrow>\n                            \\<langle>A\\<rangle>set_rel \\<rightarrow>\n                            \\<langle>\\<langle>A\\<rangle>list_rel\\<rangle>nres_rel", "apply (auto simp: it_to_sorted_list_def pw_nres_rel_iff refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' a'a x.\n       \\<lbrakk>IS_LEFT_UNIQUE A; single_valued A;\n        (a, a') \\<in> A \\<rightarrow> A \\<rightarrow> bool_rel;\n        (set x, a'a) \\<in> \\<langle>A\\<rangle>set_rel; distinct x;\n        sorted_wrt a x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            (x, s') \\<in> \\<langle>A\\<rangle>list_rel \\<and>\n                            distinct s' \\<and>\n                            a'a = set s' \\<and> sorted_wrt a' s'", "apply (rule obtain_list_from_setrel; assumption?; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' x m.\n       \\<lbrakk>IS_LEFT_UNIQUE A; single_valued A;\n        (a, a') \\<in> A \\<rightarrow> A \\<rightarrow> bool_rel;\n        (set x, set m) \\<in> \\<langle>A\\<rangle>set_rel; distinct x;\n        sorted_wrt a x; (x, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            (x, s') \\<in> \\<langle>A\\<rangle>list_rel \\<and>\n                            distinct s' \\<and>\n                            set m = set s' \\<and> sorted_wrt a' s'", "apply (intro exI conjI; assumption?)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a a' x m.\n       \\<lbrakk>IS_LEFT_UNIQUE A; single_valued A;\n        (a, a') \\<in> A \\<rightarrow> A \\<rightarrow> bool_rel;\n        (set x, set m) \\<in> \\<langle>A\\<rangle>set_rel; distinct x;\n        sorted_wrt a x; (x, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> distinct m\n 2. \\<And>a a' x m.\n       \\<lbrakk>IS_LEFT_UNIQUE A; single_valued A;\n        (a, a') \\<in> A \\<rightarrow> A \\<rightarrow> bool_rel;\n        (set x, set m) \\<in> \\<langle>A\\<rangle>set_rel; distinct x;\n        sorted_wrt a x; (x, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> set m = set m\n 3. \\<And>a a' x m.\n       \\<lbrakk>IS_LEFT_UNIQUE A; single_valued A;\n        (a, a') \\<in> A \\<rightarrow> A \\<rightarrow> bool_rel;\n        (set x, set m) \\<in> \\<langle>A\\<rangle>set_rel; distinct x;\n        sorted_wrt a x; (x, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt a' m", "using param_distinct[param_fo]"], ["proof (prove)\nusing this:\n  \\<lbrakk>IS_LEFT_UNIQUE ?A1; single_valued ?A1;\n   (?x, ?x') \\<in> \\<langle>?A1\\<rangle>list_rel\\<rbrakk>\n  \\<Longrightarrow> (distinct ?x, distinct ?x') \\<in> bool_rel\n\ngoal (3 subgoals):\n 1. \\<And>a a' x m.\n       \\<lbrakk>IS_LEFT_UNIQUE A; single_valued A;\n        (a, a') \\<in> A \\<rightarrow> A \\<rightarrow> bool_rel;\n        (set x, set m) \\<in> \\<langle>A\\<rangle>set_rel; distinct x;\n        sorted_wrt a x; (x, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> distinct m\n 2. \\<And>a a' x m.\n       \\<lbrakk>IS_LEFT_UNIQUE A; single_valued A;\n        (a, a') \\<in> A \\<rightarrow> A \\<rightarrow> bool_rel;\n        (set x, set m) \\<in> \\<langle>A\\<rangle>set_rel; distinct x;\n        sorted_wrt a x; (x, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> set m = set m\n 3. \\<And>a a' x m.\n       \\<lbrakk>IS_LEFT_UNIQUE A; single_valued A;\n        (a, a') \\<in> A \\<rightarrow> A \\<rightarrow> bool_rel;\n        (set x, set m) \\<in> \\<langle>A\\<rangle>set_rel; distinct x;\n        sorted_wrt a x; (x, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt a' m", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' x m.\n       \\<lbrakk>IS_LEFT_UNIQUE A; single_valued A;\n        (a, a') \\<in> A \\<rightarrow> A \\<rightarrow> bool_rel;\n        (set x, set m) \\<in> \\<langle>A\\<rangle>set_rel; distinct x;\n        sorted_wrt a x; (x, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> set m = set m\n 2. \\<And>a a' x m.\n       \\<lbrakk>IS_LEFT_UNIQUE A; single_valued A;\n        (a, a') \\<in> A \\<rightarrow> A \\<rightarrow> bool_rel;\n        (set x, set m) \\<in> \\<langle>A\\<rangle>set_rel; distinct x;\n        sorted_wrt a x; (x, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt a' m", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' x m.\n       \\<lbrakk>IS_LEFT_UNIQUE A; single_valued A;\n        (a, a') \\<in> A \\<rightarrow> A \\<rightarrow> bool_rel;\n        (set x, set m) \\<in> \\<langle>A\\<rangle>set_rel; distinct x;\n        sorted_wrt a x; (x, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt a' m", "using param_sorted_wrt[param_fo]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x1, ?x'1) \\<in> ?A2 \\<rightarrow> ?A2 \\<rightarrow> bool_rel;\n   (?x, ?x') \\<in> \\<langle>?A2\\<rangle>list_rel\\<rbrakk>\n  \\<Longrightarrow> (sorted_wrt ?x1 ?x, sorted_wrt ?x'1 ?x') \\<in> bool_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a' x m.\n       \\<lbrakk>IS_LEFT_UNIQUE A; single_valued A;\n        (a, a') \\<in> A \\<rightarrow> A \\<rightarrow> bool_rel;\n        (set x, set m) \\<in> \\<langle>A\\<rangle>set_rel; distinct x;\n        sorted_wrt a x; (x, m) \\<in> \\<langle>A\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt a' m", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "locale bind_set_iterate = imp_set_iterate + bind_set +\n    assumes is_set_finite: \"h \\<Turnstile> is_set S x \\<Longrightarrow> finite S\"\n  begin"], ["", "context begin"], ["", "private"], ["", "lemma is_imp_set_iterate: \"imp_set_iterate is_set is_it it_init it_has_next it_next\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_set_iterate is_set is_it it_init it_has_next it_next", "by unfold_locales"], ["", "private"], ["", "lemma is_imp_list_empty: \"imp_list_empty (list_assn id_assn) (return [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_empty (list_assn id_assn) (return [])", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. precise (list_assn id_assn)\n 2. <emp> return [] <list_assn id_assn []>\\<^sub>t", "apply solve_constraint"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> return [] <list_assn id_assn []>\\<^sub>t", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "private"], ["", "lemma is_imp_list_prepend: \"imp_list_prepend (list_assn id_assn) (return oo List.Cons)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp_list_prepend (list_assn id_assn) (return \\<circ>\\<circ> (#))", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. precise (list_assn id_assn)\n 2. \\<And>l p a.\n       <list_assn id_assn l\n         p> (return \\<circ>\\<circ> (#)) a\n             p <list_assn id_assn (a # l)>\\<^sub>t", "apply solve_constraint"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l p a.\n       <list_assn id_assn l\n         p> (return \\<circ>\\<circ> (#)) a\n             p <list_assn id_assn (a # l)>\\<^sub>t", "apply (sep_auto simp: pure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"to_list \\<equiv> to_list_ga it_init it_has_next it_next (return []) (return oo List.Cons)\""], ["", "private"], ["", "lemmas tl_rl = to_list_ga_rule[OF is_imp_set_iterate is_imp_list_empty is_imp_list_prepend, folded to_list_def]"], ["", "private"], ["", "lemma to_list_sorted1: \"(to_list,PR_CONST (it_to_sorted_list (\\<lambda>_ _. True))) \\<in> is_set\\<^sup>k \\<rightarrow>\\<^sub>a list_assn id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (to_list, PR_CONST (it_to_sorted_list (\\<lambda>_ _. True)))\n    \\<in> is_set\\<^sup>k \\<rightarrow>\\<^sub>a list_assn id_assn", "unfolding PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (to_list, it_to_sorted_list (\\<lambda>_ _. True))\n    \\<in> is_set\\<^sup>k \\<rightarrow>\\<^sub>a list_assn id_assn", "apply (intro hfrefI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       True \\<Longrightarrow>\n       hn_refine (fst (is_set\\<^sup>k) a c) (to_list c)\n        (snd (is_set\\<^sup>k) a c) (list_assn id_assn)\n        (it_to_sorted_list (\\<lambda>_ _. True) a)", "apply (rule hn_refine_preI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a h.\n       \\<lbrakk>True; h \\<Turnstile> fst (is_set\\<^sup>k) a c\\<rbrakk>\n       \\<Longrightarrow> hn_refine (fst (is_set\\<^sup>k) a c) (to_list c)\n                          (snd (is_set\\<^sup>k) a c) (list_assn id_assn)\n                          (it_to_sorted_list (\\<lambda>_ _. True) a)", "apply (rule hn_refineI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a h.\n       \\<lbrakk>True; h \\<Turnstile> fst (is_set\\<^sup>k) a c;\n        nofail (it_to_sorted_list (\\<lambda>_ _. True) a)\\<rbrakk>\n       \\<Longrightarrow> <fst (is_set\\<^sup>k) a\n                           c> to_list\n                               c <\\<lambda>r.\n                                     snd (is_set\\<^sup>k) a c *\n                                     (\\<exists>\\<^sub>Ax.\n   list_assn id_assn x r *\n   \\<up> (RETURN x \\<le> it_to_sorted_list (\\<lambda>_ _. True) a))>\\<^sub>t", "unfolding it_to_sorted_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a h.\n       \\<lbrakk>True; h \\<Turnstile> fst (is_set\\<^sup>k) a c;\n        nofail\n         (SPEC\n           (\\<lambda>l.\n               distinct l \\<and>\n               a = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l))\\<rbrakk>\n       \\<Longrightarrow> <fst (is_set\\<^sup>k) a\n                           c> to_list\n                               c <\\<lambda>r.\n                                     snd (is_set\\<^sup>k) a c *\n                                     (\\<exists>\\<^sub>Ax.\n   list_assn id_assn x r *\n   \\<up>\n    (RETURN x\n     \\<le> SPEC\n            (\\<lambda>l.\n                distinct l \\<and>\n                a = set l \\<and>\n                sorted_wrt (\\<lambda>_ _. True) l)))>\\<^sub>t", "apply (sep_auto intro: hfrefI hn_refineI intro: is_set_finite heap: tl_rl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "private"], ["", "lemma to_list_sorted2: \"\\<lbrakk>\n        CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) A; \n        CONSTRAINT (IS_PURE IS_RIGHT_UNIQUE) A\\<rbrakk> \\<Longrightarrow> \n        (PR_CONST (it_to_sorted_list (\\<lambda>_ _. True)), PR_CONST (it_to_sorted_list (\\<lambda>_ _. True))) \\<in> \\<langle>the_pure A\\<rangle>set_rel \\<rightarrow> \\<langle>\\<langle>the_pure A\\<rangle>list_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) A;\n     CONSTRAINT (IS_PURE single_valued) A\\<rbrakk>\n    \\<Longrightarrow> (PR_CONST (it_to_sorted_list (\\<lambda>_ _. True)),\n                       PR_CONST (it_to_sorted_list (\\<lambda>_ _. True)))\n                      \\<in> \\<langle>the_pure\nA\\<rangle>set_rel \\<rightarrow>\n                            \\<langle>\\<langle>the_pure\n         A\\<rangle>list_rel\\<rangle>nres_rel", "unfolding PR_CONST_def CONSTRAINT_def IS_PURE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_pure A \\<and> IS_LEFT_UNIQUE (the_pure A);\n     is_pure A \\<and> single_valued (the_pure A)\\<rbrakk>\n    \\<Longrightarrow> (it_to_sorted_list (\\<lambda>_ _. True),\n                       it_to_sorted_list (\\<lambda>_ _. True))\n                      \\<in> \\<langle>the_pure\nA\\<rangle>set_rel \\<rightarrow>\n                            \\<langle>\\<langle>the_pure\n         A\\<rangle>list_rel\\<rangle>nres_rel", "by clarify parametricity"], ["", "lemmas to_list_hnr = to_list_sorted1[FCOMP to_list_sorted2, folded assn_def]"], ["", "lemmas to_list_is_to_sorted_list = IS_TO_SORTED_LISTI[OF to_list_hnr]"], ["", "lemma to_list_gen[sepref_gen_algo_rules]: \"\\<lbrakk>CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) A; CONSTRAINT (IS_PURE IS_RIGHT_UNIQUE) A\\<rbrakk> \n        \\<Longrightarrow> GEN_ALGO to_list (IS_TO_SORTED_LIST (\\<lambda>_ _. True) (bind_set.assn is_set A) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) A;\n     CONSTRAINT (IS_PURE single_valued) A\\<rbrakk>\n    \\<Longrightarrow> GEN_ALGO to_list\n                       (IS_TO_SORTED_LIST (\\<lambda>_ _. True) assn A)", "by (simp add: GEN_ALGO_def to_list_is_to_sorted_list)"], ["", "end"], ["", "end"], ["", "subsubsection \\<open>List\\<close>"], ["", "locale bind_list = imp_list is_list for is_list :: \"('ai list) \\<Rightarrow> 'm \\<Rightarrow> assn\" +\n    fixes A :: \"'a \\<Rightarrow> 'ai \\<Rightarrow> assn\"\n  begin"], ["", "(*abbreviation \"Ap \\<equiv> the_pure A\"*)"], ["", "definition \"assn \\<equiv> hr_comp is_list (\\<langle>the_pure A\\<rangle>list_rel)\""], ["", "lemmas [safe_constraint_rules] = CN_FALSEI[of is_pure \"assn\"]"], ["", "end"], ["", "locale bind_list_empty = imp_list_empty + bind_list\n  begin"], ["", "lemma hnr_aux: \"(uncurry0 empty,uncurry0 (RETURN op_list_empty))\\<in>(pure unit_rel)\\<^sup>k \\<rightarrow>\\<^sub>a is_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 empty, uncurry0 (RETURN op_list_empty))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_list", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       True \\<Longrightarrow>\n       hn_refine (fst (unit_assn\\<^sup>k) a c) (uncurry0 empty c)\n        (snd (unit_assn\\<^sup>k) a c) is_list\n        (uncurry0 (RETURN op_list_empty) a)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       \\<lbrakk>True; nofail (uncurry0 (RETURN op_list_empty) a)\\<rbrakk>\n       \\<Longrightarrow> <fst (unit_assn\\<^sup>k) a\n                           c> uncurry0 empty\n                               c <\\<lambda>r.\n                                     snd (unit_assn\\<^sup>k) a c *\n                                     (\\<exists>\\<^sub>Ax.\n   is_list x r *\n   \\<up> (RETURN x \\<le> uncurry0 (RETURN op_list_empty) a))>\\<^sub>t", "apply (sep_auto simp: pure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas hnr \n      = hnr_aux[FCOMP op_list_empty.fref[of \"the_pure A\"], folded assn_def]"], ["", "lemmas hnr_mop = hnr[FCOMP mk_mop_rl0_np[OF mop_list_empty_alt]]"], ["", "end"], ["", "locale bind_list_is_empty = imp_list_is_empty + bind_list\n  begin"], ["", "lemma hnr_aux: \"(is_empty,RETURN o op_list_is_empty)\\<in>(is_list)\\<^sup>k \\<rightarrow>\\<^sub>a pure bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_empty, RETURN \\<circ> op_list_is_empty)\n    \\<in> is_list\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       True \\<Longrightarrow>\n       hn_refine (fst (is_list\\<^sup>k) a c) (is_empty c)\n        (snd (is_list\\<^sup>k) a c) bool_assn\n        ((RETURN \\<circ> op_list_is_empty) a)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a.\n       \\<lbrakk>True; nofail ((RETURN \\<circ> op_list_is_empty) a)\\<rbrakk>\n       \\<Longrightarrow> <fst (is_list\\<^sup>k) a\n                           c> is_empty\n                               c <\\<lambda>r.\n                                     snd (is_list\\<^sup>k) a c *\n                                     (\\<exists>\\<^sub>Ax.\n   bool_assn x r *\n   \\<up> (RETURN x \\<le> (RETURN \\<circ> op_list_is_empty) a))>\\<^sub>t", "apply (sep_auto simp: pure_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas hnr[sepref_fr_rules] \n      = hnr_aux[FCOMP op_list_is_empty.fref, of \"the_pure A\", folded assn_def]"], ["", "lemmas hnr_mop[sepref_fr_rules] = hnr[FCOMP mk_mop_rl1_np[OF mop_list_is_empty_alt]]"], ["", "end"], ["", "locale bind_list_append = imp_list_append + bind_list\n  begin"], ["", "lemma hnr_aux: \"(uncurry (swap_args2 append),uncurry (RETURN oo op_list_append))\n      \\<in>(is_list)\\<^sup>d *\\<^sub>a (pure Id)\\<^sup>k \\<rightarrow>\\<^sub>a is_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (swap_args2 append),\n     uncurry (RETURN \\<circ>\\<circ> op_list_append))\n    \\<in> is_list\\<^sup>d *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_list", "by solve_sepl_binding"], ["", "lemmas hnr[sepref_fr_rules] \n      = hnr_aux[FCOMP op_list_append.fref,of A, folded assn_def]"], ["", "lemmas hnr_mop[sepref_fr_rules] = hnr[FCOMP mk_mop_rl2_np[OF mop_list_append_alt]]"], ["", "end"], ["", "locale bind_list_prepend = imp_list_prepend + bind_list\n  begin"], ["", "lemma hnr_aux: \"(uncurry prepend,uncurry (RETURN oo op_list_prepend))\n      \\<in>(pure Id)\\<^sup>k *\\<^sub>a (is_list)\\<^sup>d \\<rightarrow>\\<^sub>a is_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry prepend, uncurry (RETURN \\<circ>\\<circ> op_list_prepend))\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          is_list\\<^sup>d \\<rightarrow>\\<^sub>a is_list", "by solve_sepl_binding"], ["", "lemmas hnr[sepref_fr_rules] \n      = hnr_aux[FCOMP op_list_prepend.fref,of A, folded assn_def]"], ["", "lemmas hnr_mop[sepref_fr_rules] = hnr[FCOMP mk_mop_rl2_np[OF mop_list_prepend_alt]]"], ["", "end"], ["", "locale bind_list_hd = imp_list_head + bind_list\n  begin"], ["", "lemma hnr_aux: \"(head,RETURN o op_list_hd)\n      \\<in>[\\<lambda>l. l\\<noteq>[]]\\<^sub>a (is_list)\\<^sup>d \\<rightarrow> pure Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (head, RETURN \\<circ> op_list_hd)\n    \\<in> [\\<lambda>l.\n              l \\<noteq> []]\\<^sub>a is_list\\<^sup>d \\<rightarrow> id_assn", "by solve_sepl_binding"], ["", "lemmas hnr[sepref_fr_rules] = hnr_aux[FCOMP op_list_hd.fref,of A, folded assn_def]"], ["", "lemmas hnr_mop[sepref_fr_rules] = hnr[FCOMP mk_mop_rl1[OF mop_list_hd_alt]]"], ["", "end"], ["", "locale bind_list_tl = imp_list_tail + bind_list\n  begin"], ["", "lemma hnr_aux: \"(tail,RETURN o op_list_tl)\n      \\<in>[\\<lambda>l. l\\<noteq>[]]\\<^sub>a (is_list)\\<^sup>d \\<rightarrow> is_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tail, RETURN \\<circ> op_list_tl)\n    \\<in> [\\<lambda>l.\n              l \\<noteq> []]\\<^sub>a is_list\\<^sup>d \\<rightarrow> is_list", "by solve_sepl_binding"], ["", "lemmas hnr[sepref_fr_rules] = hnr_aux[FCOMP op_list_tl.fref,of \"the_pure A\", folded assn_def]"], ["", "lemmas hnr_mop[sepref_fr_rules] = hnr[FCOMP mk_mop_rl1[OF mop_list_tl_alt]]"], ["", "end"], ["", "locale bind_list_rotate1 = imp_list_rotate + bind_list\n  begin"], ["", "lemma hnr_aux: \"(rotate,RETURN o op_list_rotate1)\n      \\<in>(is_list)\\<^sup>d \\<rightarrow>\\<^sub>a is_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rotate, RETURN \\<circ> op_list_rotate1)\n    \\<in> is_list\\<^sup>d \\<rightarrow>\\<^sub>a is_list", "by solve_sepl_binding"], ["", "lemmas hnr[sepref_fr_rules] = hnr_aux[FCOMP op_list_rotate1.fref,of \"the_pure A\", folded assn_def]"], ["", "lemmas hnr_mop[sepref_fr_rules] = hnr[FCOMP mk_mop_rl1_np[OF mop_list_rotate1_alt]]"], ["", "end"], ["", "locale bind_list_rev = imp_list_reverse + bind_list\n  begin"], ["", "lemma hnr_aux: \"(reverse,RETURN o op_list_rev)\n      \\<in>(is_list)\\<^sup>d \\<rightarrow>\\<^sub>a is_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (reverse, RETURN \\<circ> op_list_rev)\n    \\<in> is_list\\<^sup>d \\<rightarrow>\\<^sub>a is_list", "by solve_sepl_binding"], ["", "lemmas hnr[sepref_fr_rules] = hnr_aux[FCOMP op_list_rev.fref,of \"the_pure A\", folded assn_def]"], ["", "lemmas hnr_mop[sepref_fr_rules] = hnr[FCOMP mk_mop_rl1_np[OF mop_list_rev_alt]]"], ["", "end"], ["", "subsection \\<open>Array Map (iam)\\<close>"], ["", "definition \"op_iam_empty \\<equiv> IICF_Map.op_map_empty\""], ["", "interpretation iam: bind_map_empty is_iam iam_new"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_map_empty is_iam iam_new", "by unfold_locales"], ["", "interpretation iam: map_custom_empty op_iam_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_custom_empty op_iam_empty", "by unfold_locales (simp add: op_iam_empty_def)"], ["", "lemmas [sepref_fr_rules] = iam.empty_hnr[folded op_iam_empty_def]"], ["", "definition [simp]: \"op_iam_empty_sz (N::nat) \\<equiv> IICF_Map.op_map_empty\""], ["", "lemma [def_pat_rules]: \"op_iam_empty_sz$N \\<equiv> UNPROTECT (op_iam_empty_sz N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_iam_empty_sz $ N \\<equiv> UNPROTECT (op_iam_empty_sz N)", "by simp"], ["", "interpretation iam_sz: map_custom_empty \"PR_CONST (op_iam_empty_sz N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_custom_empty (PR_CONST (op_iam_empty_sz N))", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. PR_CONST (op_iam_empty_sz N) = op_map_empty", "apply (simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [sepref_fr_rules]: \"(uncurry0 iam_new, uncurry0 (RETURN (PR_CONST (op_iam_empty_sz N)))) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a iam.assn K V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 iam_new, uncurry0 (RETURN (PR_CONST (op_iam_empty_sz N))))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a iam.assn K V", "using iam.empty_hnr[of K V]"], ["proof (prove)\nusing this:\n  (uncurry0 iam_new, uncurry0 (RETURN op_map_empty))\n  \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a iam.assn K V\n\ngoal (1 subgoal):\n 1. (uncurry0 iam_new, uncurry0 (RETURN (PR_CONST (op_iam_empty_sz N))))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a iam.assn K V", "by simp"], ["", "interpretation iam: bind_map_update is_iam Array_Map_Impl.iam_update"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_map_update is_iam iam_update", "by unfold_locales"], ["", "interpretation iam: bind_map_delete is_iam Array_Map_Impl.iam_delete"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_map_delete is_iam iam_delete", "by unfold_locales"], ["", "interpretation iam: bind_map_lookup is_iam Array_Map_Impl.iam_lookup"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_map_lookup is_iam iam_lookup", "by unfold_locales"], ["", "setup Locale_Code.open_block"], ["", "interpretation iam: gen_contains_key_by_lookup is_iam Array_Map_Impl.iam_lookup"], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_contains_key_by_lookup is_iam iam_lookup", "by unfold_locales"], ["", "setup Locale_Code.close_block"], ["", "interpretation iam: bind_map_contains_key is_iam iam.contains_key"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_map_contains_key is_iam iam.contains_key", "by unfold_locales"], ["", "subsection \\<open>Array Set (ias)\\<close>"], ["", "definition [simp]: \"op_ias_empty \\<equiv> op_set_empty\""], ["", "interpretation ias: bind_set_empty is_ias ias_new for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_set_empty is_ias ias_new", "by unfold_locales"], ["", "interpretation ias: set_custom_empty ias_new op_ias_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_custom_empty op_ias_empty", "by unfold_locales simp"], ["", "lemmas [sepref_fr_rules] = ias.hnr_op_empty[folded op_ias_empty_def]"], ["", "definition [simp]: \"op_ias_empty_sz (N::nat) \\<equiv> op_set_empty\""], ["", "lemma [def_pat_rules]: \"op_ias_empty_sz$N \\<equiv> UNPROTECT (op_ias_empty_sz N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_ias_empty_sz $ N \\<equiv> UNPROTECT (op_ias_empty_sz N)", "by simp"], ["", "interpretation ias_sz: bind_set_empty is_ias \"ias_new_sz N\" for N A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_set_empty is_ias (ias_new_sz N)", "by unfold_locales"], ["", "interpretation ias_sz: set_custom_empty \"ias_new_sz N\" \"PR_CONST (op_ias_empty_sz N)\" for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_custom_empty (PR_CONST (op_ias_empty_sz N))", "by unfold_locales simp"], ["", "lemma [sepref_fr_rules]: \n    \"(uncurry0 (ias_new_sz N), uncurry0 (RETURN (PR_CONST (op_ias_empty_sz N)))) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a ias.assn A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 (ias_new_sz N),\n     uncurry0 (RETURN (PR_CONST (op_ias_empty_sz N))))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a ias.assn A", "using ias_sz.hnr_op_empty[of N A]"], ["proof (prove)\nusing this:\n  (uncurry0 (ias_new_sz N), uncurry0 (RETURN op_set_empty))\n  \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a ias.assn A\n\ngoal (1 subgoal):\n 1. (uncurry0 (ias_new_sz N),\n     uncurry0 (RETURN (PR_CONST (op_ias_empty_sz N))))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a ias.assn A", "by simp"], ["", "interpretation ias: bind_set_member is_ias Array_Set_Impl.ias_memb for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_set_member is_ias ias_memb", "by unfold_locales"], ["", "interpretation ias: bind_set_insert is_ias Array_Set_Impl.ias_ins for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_set_insert is_ias ias_ins", "by unfold_locales"], ["", "interpretation ias: bind_set_delete is_ias Array_Set_Impl.ias_delete for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_set_delete is_ias ias_delete", "by unfold_locales"], ["", "setup Locale_Code.open_block"], ["", "interpretation ias: bind_set_iterate is_ias ias_is_it ias_it_init ias_it_has_next ias_it_next for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_set_iterate is_ias ias_is_it ias_it_init ias_it_has_next\n     ias_it_next", "by unfold_locales auto"], ["", "setup Locale_Code.close_block"], ["", "subsection \\<open>Hash Map (hm)\\<close>"], ["", "interpretation hm: bind_map_empty is_hashmap hm_new"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_map_empty is_hashmap hm_new", "by unfold_locales"], ["", "definition \"op_hm_empty \\<equiv> IICF_Map.op_map_empty\""], ["", "interpretation hm: map_custom_empty op_hm_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_custom_empty op_hm_empty", "by unfold_locales (simp add: op_hm_empty_def)"], ["", "lemmas [sepref_fr_rules] = hm.empty_hnr[folded op_hm_empty_def]"], ["", "interpretation hm: bind_map_is_empty is_hashmap Hash_Map.hm_isEmpty"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_map_is_empty is_hashmap hm_isEmpty", "by unfold_locales"], ["", "interpretation hm: bind_map_update is_hashmap Hash_Map.hm_update"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_map_update is_hashmap hm_update", "by unfold_locales"], ["", "interpretation hm: bind_map_delete is_hashmap Hash_Map.hm_delete"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_map_delete is_hashmap hm_delete", "by unfold_locales"], ["", "interpretation hm: bind_map_lookup is_hashmap Hash_Map.hm_lookup"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_map_lookup is_hashmap hm_lookup", "by unfold_locales"], ["", "setup Locale_Code.open_block"], ["", "interpretation hm: gen_contains_key_by_lookup is_hashmap Hash_Map.hm_lookup"], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_contains_key_by_lookup is_hashmap hm_lookup", "by unfold_locales"], ["", "setup Locale_Code.close_block"], ["", "interpretation hm: bind_map_contains_key is_hashmap hm.contains_key"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_map_contains_key is_hashmap hm.contains_key", "by unfold_locales"], ["", "subsection \\<open>Hash Set (hs)\\<close>"], ["", "interpretation hs: bind_set_empty is_hashset hs_new for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_set_empty is_hashset hs_new", "by unfold_locales"], ["", "definition \"op_hs_empty \\<equiv> IICF_Set.op_set_empty\""], ["", "interpretation hs: set_custom_empty hs_new op_hs_empty for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_custom_empty op_hs_empty", "by unfold_locales (simp add: op_hs_empty_def)"], ["", "lemmas [sepref_fr_rules] = hs.hnr_op_empty[folded op_hs_empty_def]"], ["", "interpretation hs: bind_set_is_empty is_hashset Hash_Set_Impl.hs_isEmpty for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_set_is_empty is_hashset hs_isEmpty", "by unfold_locales"], ["", "interpretation hs: bind_set_member is_hashset Hash_Set_Impl.hs_memb for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_set_member is_hashset hs_memb", "by unfold_locales"], ["", "interpretation hs: bind_set_insert is_hashset Hash_Set_Impl.hs_ins for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_set_insert is_hashset hs_ins", "by unfold_locales"], ["", "interpretation hs: bind_set_delete is_hashset Hash_Set_Impl.hs_delete for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_set_delete is_hashset hs_delete", "by unfold_locales"], ["", "setup Locale_Code.open_block"], ["", "interpretation hs: bind_set_iterate is_hashset hs_is_it hs_it_init hs_it_has_next hs_it_next for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_set_iterate is_hashset hs_is_it hs_it_init hs_it_has_next\n     hs_it_next", "by unfold_locales simp"], ["", "setup Locale_Code.close_block"], ["", "subsection \\<open>Open Singly Linked List (osll)\\<close>"], ["", "interpretation osll: bind_list os_list for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_list os_list", "by unfold_locales"], ["", "interpretation osll_empty: bind_list_empty os_list os_empty for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_list_empty os_list os_empty", "by unfold_locales"], ["", "definition \"osll_empty \\<equiv> op_list_empty\""], ["", "interpretation osll: list_custom_empty \"osll.assn A\" os_empty osll_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_custom_empty (osll.assn A) os_empty osll_empty", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. (uncurry0 os_empty, uncurry0 (RETURN op_list_empty))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a osll.assn A\n 2. osll_empty = op_list_empty", "apply (rule osll_empty.hnr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. osll_empty = op_list_empty", "by (simp add: osll_empty_def)"], ["", "interpretation osll_is_empty: bind_list_is_empty os_list os_is_empty for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_list_is_empty os_list os_is_empty", "by unfold_locales"], ["", "interpretation osll_prepend: bind_list_prepend os_list os_prepend for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_list_prepend os_list os_prepend", "by unfold_locales"], ["", "interpretation osll_hd: bind_list_hd os_list os_head for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_list_hd os_list os_head", "by unfold_locales"], ["", "interpretation osll_tl: bind_list_tl os_list os_tl for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_list_tl os_list os_tl", "by unfold_locales"], ["", "interpretation osll_rev: bind_list_rev os_list os_reverse for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_list_rev os_list os_reverse", "by unfold_locales"], ["", "subsection \\<open>Circular Singly Linked List (csll)\\<close>"], ["", "(* TODO: In-place reversal of circular list! *)"], ["", "interpretation csll: bind_list cs_list for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_list cs_list", "by unfold_locales"], ["", "interpretation csll_empty: bind_list_empty cs_list cs_empty for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_list_empty cs_list cs_empty", "by unfold_locales"], ["", "definition \"csll_empty \\<equiv> op_list_empty\""], ["", "interpretation csll: list_custom_empty \"csll.assn A\" cs_empty csll_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_custom_empty (csll.assn A) cs_empty csll_empty", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. (uncurry0 cs_empty, uncurry0 (RETURN op_list_empty))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a csll.assn A\n 2. csll_empty = op_list_empty", "apply (rule csll_empty.hnr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. csll_empty = op_list_empty", "by (simp add: csll_empty_def)"], ["", "interpretation csll_is_empty: bind_list_is_empty cs_list cs_is_empty for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_list_is_empty cs_list cs_is_empty", "by unfold_locales"], ["", "interpretation csll_prepend: bind_list_prepend cs_list cs_prepend for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_list_prepend cs_list cs_prepend", "by unfold_locales"], ["", "interpretation csll_append: bind_list_append cs_list cs_append for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_list_append cs_list cs_append", "by unfold_locales"], ["", "interpretation csll_hd: bind_list_hd cs_list cs_head for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_list_hd cs_list cs_head", "by unfold_locales"], ["", "interpretation csll_tl: bind_list_tl cs_list cs_tail for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_list_tl cs_list cs_tail", "by unfold_locales"], ["", "interpretation csll_rotate1: bind_list_rotate1 cs_list cs_rotate for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_list_rotate1 cs_list cs_rotate", "by unfold_locales"], ["", "schematic_goal \"hn_refine (emp) (?c::?'c Heap) ?\\<Gamma>' ?R (do {\n    x \\<leftarrow> mop_list_empty;\n    RETURN (1 \\<in> dom [1::nat \\<mapsto> True, 2\\<mapsto>False], {1,2::nat}, 1#(2::nat)#x)\n  })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine emp ?c ?\\<Gamma>' ?R\n     (mop_list_empty \\<bind>\n      (\\<lambda>x.\n          RETURN\n           (1 \\<in> dom [1 \\<mapsto> True, 2 \\<mapsto> False], {1, 2},\n            1 # 2 # x)))", "apply (subst iam_sz.fold_custom_empty[where N=10])"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine emp ?c ?\\<Gamma>' ?R\n     (mop_list_empty \\<bind>\n      (\\<lambda>x.\n          RETURN\n           (1 \\<in> dom (PR_CONST (op_iam_empty_sz 10)(1 \\<mapsto> True, 2 \n                         \\<mapsto> False)),\n            {1, 2}, 1 # 2 # x)))", "apply (subst hs.fold_custom_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine emp ?c ?\\<Gamma>' ?R\n     (mop_list_empty \\<bind>\n      (\\<lambda>x.\n          RETURN\n           (1 \\<in> dom (PR_CONST (op_iam_empty_sz 10)(1 \\<mapsto> True, 2 \n                         \\<mapsto> False)),\n            insert 1 (insert 2 op_hs_empty), 1 # 2 # x)))", "apply (subst osll.fold_custom_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine emp ?c ?\\<Gamma>' ?R\n     (RETURN osll_empty \\<bind>\n      (\\<lambda>x.\n          RETURN\n           (1 \\<in> dom (PR_CONST (op_iam_empty_sz 10)(1 \\<mapsto> True, 2 \n                         \\<mapsto> False)),\n            insert 1 (insert 2 op_hs_empty), 1 # 2 # x)))", "by sepref"], ["", "end"]]}