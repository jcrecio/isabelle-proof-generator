{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/IICF/Impl/Heaps/IICF_Impl_Heap.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma [sepref_import_param]: \"(prio,prio) \\<in> Id \\<rightarrow> Id\"", "lemma [sepref_import_param]: \n      \"((\\<le>), (\\<le>)::'b \\<Rightarrow> _) \\<in> Id \\<rightarrow> Id \\<rightarrow> bool_rel\"\n      \"((<), (<)::'b \\<Rightarrow> _) \\<in> Id \\<rightarrow> Id \\<rightarrow> bool_rel\"", "lemma [def_pat_rules]: \n      \"heapstruct.prio_of_op$prio \\<equiv> PR_CONST prio_of_op\"\n      \"heapstruct.sink_op$prio \\<equiv> PR_CONST sink_op\"\n      \"heapstruct.swim_op$prio \\<equiv> PR_CONST swim_op\"\n      \"heapstruct.repair_op$prio \\<equiv> PR_CONST repair_op\"", "lemmas [sepref_fr_rules] = update_impl.refine", "lemmas [sepref_fr_rules] = val_of_impl.refine", "lemmas [sepref_fr_rules] = exch_impl.refine", "lemmas [sepref_fr_rules] = valid_impl.refine", "lemmas [sepref_fr_rules] = prio_of_impl.refine", "lemmas [sepref_fr_rules] = swim_impl.refine", "lemmas [sepref_fr_rules] = sink_impl.refine", "lemmas [fcomp_norm_unfold] = heap_rel_def[symmetric]"], "translations": [["", "lemma [sepref_import_param]: \"(prio,prio) \\<in> Id \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (prio, prio) \\<in> Id \\<rightarrow> Id", "by simp"], ["", "lemma [sepref_import_param]: \n      \"((\\<le>), (\\<le>)::'b \\<Rightarrow> _) \\<in> Id \\<rightarrow> Id \\<rightarrow> bool_rel\"\n      \"((<), (<)::'b \\<Rightarrow> _) \\<in> Id \\<rightarrow> Id \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<le>), (\\<le>)) \\<in> Id \\<rightarrow> Id \\<rightarrow> bool_rel &&&\n    ((<), (<)) \\<in> Id \\<rightarrow> Id \\<rightarrow> bool_rel", "by simp_all"], ["", "sepref_register \n      update_op\n      val_of_op\n      \"PR_CONST prio_of_op\"\n      exch_op\n      valid\n      \"length::'a list \\<Rightarrow> _\"\n      append_op\n      butlast_op\n      \n      \"PR_CONST sink_op\"\n      \"PR_CONST swim_op\"\n      \"PR_CONST repair_op\""], ["", "lemma [def_pat_rules]: \n      \"heapstruct.prio_of_op$prio \\<equiv> PR_CONST prio_of_op\"\n      \"heapstruct.sink_op$prio \\<equiv> PR_CONST sink_op\"\n      \"heapstruct.swim_op$prio \\<equiv> PR_CONST swim_op\"\n      \"heapstruct.repair_op$prio \\<equiv> PR_CONST repair_op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((heapstruct.prio_of_op $ prio \\<equiv> PR_CONST prio_of_op) &&&\n     heapstruct.sink_op $ prio \\<equiv> PR_CONST sink_op) &&&\n    (heapstruct.swim_op $ prio \\<equiv> PR_CONST swim_op) &&&\n    heapstruct.repair_op $ prio \\<equiv> PR_CONST repair_op", "by simp_all"], ["", "end"], ["", "context\n    fixes prio :: \"'a::{heap,default} \\<Rightarrow> 'b::linorder\"\n  begin"], ["", "interpretation heapstruct_impl prio"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "subsection \\<open>Synthesis of operations\\<close>"], ["", "text \\<open>Note that we have to repeat some boilerplate per operation.\n    It is future work to add more automation here.\\<close>"], ["", "sepref_definition update_impl is \"uncurry2 update_op\" :: \"rel\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k \\<rightarrow>\\<^sub>a rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 update_op)\n    \\<in> (arl_assn id_assn)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn id_assn", "unfolding update_op_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>h i v.\n          ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_set h (i - 1) v)))\n    \\<in> (arl_assn id_assn)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          id_assn\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn id_assn", "by sepref"], ["", "lemmas [sepref_fr_rules] = update_impl.refine"], ["", "sepref_definition val_of_impl is \"uncurry val_of_op\" :: \"rel\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry val_of_op)\n    \\<in> (arl_assn id_assn)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "unfolding val_of_op_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>l i.\n          ASSERT (0 < i) \\<bind> (\\<lambda>_. mop_list_get l (i - 1))))\n    \\<in> (arl_assn id_assn)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "by sepref"], ["", "lemmas [sepref_fr_rules] = val_of_impl.refine"], ["", "sepref_definition exch_impl is \"uncurry2 exch_op\" :: \"rel\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 exch_op)\n    \\<in> (arl_assn id_assn)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn id_assn", "unfolding exch_op_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>l i j.\n          ASSERT (0 < i \\<and> 0 < j) \\<bind>\n          (\\<lambda>_. mop_list_swap l (i - 1) (j - 1) \\<bind> RETURN)))\n    \\<in> (arl_assn id_assn)\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn id_assn", "by sepref"], ["", "lemmas [sepref_fr_rules] = exch_impl.refine"], ["", "sepref_definition valid_impl is \"uncurry (RETURN oo valid)\" :: \"rel\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (RETURN \\<circ>\\<circ> valid))\n    \\<in> (arl_assn id_assn)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "unfolding valid_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>x.\n          RETURN \\<circ> (\\<lambda>i. 0 < i \\<and> i \\<le> length x)))\n    \\<in> (arl_assn id_assn)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by sepref"], ["", "lemmas [sepref_fr_rules] = valid_impl.refine"], ["", "sepref_definition prio_of_impl is \"uncurry (PR_CONST prio_of_op)\" :: \"rel\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (PR_CONST prio_of_op))\n    \\<in> (arl_assn id_assn)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "unfolding prio_of_op_def[abs_def] PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>l i. val_of_op l i \\<bind> (\\<lambda>v. RETURN (prio v))))\n    \\<in> (arl_assn id_assn)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "by sepref"], ["", "lemmas [sepref_fr_rules] = prio_of_impl.refine"], ["", "sepref_definition swim_impl is \"uncurry (PR_CONST swim_op)\" :: \"rel\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (PR_CONST swim_op))\n    \\<in> (arl_assn id_assn)\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn id_assn", "unfolding swim_op_def[abs_def] parent_def PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>h i.\n          REC\\<^sub>T\n           (\\<lambda>swim (h, i).\n               ASSERT (valid h i \\<and> swim_invar h i) \\<bind>\n               (\\<lambda>_.\n                   if valid h (i div 2)\n                   then prio_of_op h (i div 2) \\<bind>\n                        (\\<lambda>ppi.\n                            prio_of_op h i \\<bind>\n                            (\\<lambda>pi.\n                                if \\<not> ppi \\<le> pi\n                                then exch_op h i (i div 2) \\<bind>\n                                     (\\<lambda>h. swim (h, i div 2))\n                                else RETURN h))\n                   else RETURN h))\n           (h, i)))\n    \\<in> (arl_assn id_assn)\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn id_assn", "by sepref"], ["", "lemmas [sepref_fr_rules] = swim_impl.refine"], ["", "sepref_definition sink_impl is \"uncurry (PR_CONST sink_op)\" :: \"rel\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (PR_CONST sink_op))\n    \\<in> (arl_assn id_assn)\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn id_assn", "unfolding sink_op_opt_def[abs_def] sink_op_opt_eq[symmetric,abs_def]  PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>h k.\n          REC\\<^sub>T\n           (\\<lambda>D (h, k).\n               ASSERT (0 < k \\<and> k \\<le> length h) \\<bind>\n               (\\<lambda>_.\n                   let len = length h\n                   in if 2 * k \\<le> len\n                      then let j = 2 * k\n                           in prio_of_op h j \\<bind>\n                              (\\<lambda>pj.\n                                  (if j < len\n                                   then prio_of_op h (Suc j) \\<bind>\n  (\\<lambda>psj. if psj < pj then RETURN (j + 1) else RETURN j)\n                                   else RETURN j) \\<bind>\n                                  (\\<lambda>j.\nprio_of_op h j \\<bind>\n(\\<lambda>pj.\n    prio_of_op h k \\<bind>\n    (\\<lambda>pk.\n        if pj < pk then exch_op h k j \\<bind> (\\<lambda>h. D (h, j))\n        else RETURN h))))\n                      else RETURN h))\n           (h, k)))\n    \\<in> (arl_assn id_assn)\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn id_assn", "by sepref"], ["", "lemmas [sepref_fr_rules] = sink_impl.refine"], ["", "lemmas [fcomp_norm_unfold] = heap_rel_def[symmetric]"], ["", "sepref_definition empty_impl is \"uncurry0 empty_op\" :: \"unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 empty_op)\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn id_assn", "unfolding empty_op_def arl.fold_custom_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 (RETURN op_arl_empty))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn id_assn", "by sepref"], ["", "sepref_decl_impl (no_register) heap_empty: empty_impl.refine[FCOMP empty_op_refine]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_definition is_empty_impl is \"is_empty_op\" :: \"rel\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, is_empty_op)\n    \\<in> (arl_assn id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "unfolding is_empty_op_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>h.\n        ASSERT (heap_invar h) \\<bind>\n        (\\<lambda>_. let l = length h in RETURN (l = 0)))\n    \\<in> (arl_assn id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by sepref"], ["", "sepref_decl_impl heap_is_empty: is_empty_impl.refine[FCOMP is_empty_op_refine]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_definition insert_impl is \"uncurry insert_op\" :: \"id_assn\\<^sup>k *\\<^sub>a rel\\<^sup>d \\<rightarrow>\\<^sub>a rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry insert_op)\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          (arl_assn id_assn)\\<^sup>d \\<rightarrow>\\<^sub>a arl_assn id_assn", "unfolding insert_op_def[abs_def] append_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>v h.\n          ASSERT (heap_invar h) \\<bind>\n          (\\<lambda>_.\n              mop_list_append h v \\<bind>\n              (\\<lambda>h.\n                  let l = length h in swim_op h l \\<bind> RETURN))))\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          (arl_assn id_assn)\\<^sup>d \\<rightarrow>\\<^sub>a arl_assn id_assn", "by sepref"], ["", "sepref_decl_impl heap_insert: insert_impl.refine[FCOMP insert_op_refine]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_definition pop_min_impl is \"pop_min_op\" :: \"rel\\<^sup>d \\<rightarrow>\\<^sub>a prod_assn id_assn rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, pop_min_op)\n    \\<in> (arl_assn\n            id_assn)\\<^sup>d \\<rightarrow>\\<^sub>a id_assn \\<times>\\<^sub>a\n             arl_assn id_assn", "unfolding pop_min_op_def[abs_def] butlast_op_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>h.\n        ASSERT (heap_invar h) \\<bind>\n        (\\<lambda>_.\n            ASSERT (valid h 1) \\<bind>\n            (\\<lambda>_.\n                val_of_op h 1 \\<bind>\n                (\\<lambda>m.\n                    let l = length h\n                    in exch_op h 1 l \\<bind>\n                       (\\<lambda>h.\n                           mop_list_butlast h \\<bind>\n                           (\\<lambda>h.\n                               if l \\<noteq> 1\n                               then sink_op h 1 \\<bind>\n                                    (\\<lambda>h. RETURN (m, h))\n                               else RETURN (m, h)))))))\n    \\<in> (arl_assn\n            id_assn)\\<^sup>d \\<rightarrow>\\<^sub>a id_assn \\<times>\\<^sub>a\n             arl_assn id_assn", "by sepref"], ["", "sepref_decl_impl (no_mop) heap_pop_min: pop_min_impl.refine[FCOMP pop_min_op_refine]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_definition peek_min_impl is \"peek_min_op\" :: \"rel\\<^sup>k \\<rightarrow>\\<^sub>a id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, peek_min_op)\n    \\<in> (arl_assn id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "unfolding peek_min_op_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>h.\n        ASSERT (heap_invar h) \\<bind>\n        (\\<lambda>_.\n            ASSERT (valid h 1) \\<bind> (\\<lambda>_. val_of_op h 1)))\n    \\<in> (arl_assn id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "by sepref"], ["", "sepref_decl_impl (no_mop) heap_peek_min: peek_min_impl.refine[FCOMP peek_min_op_refine]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "definition [simp]: \"heap_custom_empty \\<equiv> op_mset_empty\""], ["", "interpretation heap: mset_custom_empty \n  \"heap_rel prio A\" empty_impl heap_custom_empty for prio A"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_custom_empty (heap_rel prio A) empty_impl heap_custom_empty", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. (uncurry0 empty_impl, uncurry0 (RETURN op_mset_empty))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a heap_rel prio A\n 2. heap_custom_empty = op_mset_empty", "apply (rule heap_empty_hnr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap_custom_empty = op_mset_empty", "by simp"], ["", "subsection \\<open>Regression Test\\<close>"], ["", "export_code empty_impl is_empty_impl insert_impl pop_min_impl peek_min_impl checking SML"], ["", "definition \"sort_by_prio prio l \\<equiv> do {\n  q \\<leftarrow> nfoldli l (\\<lambda>_. True) (\\<lambda>x q. mop_mset_insert x q) heap_custom_empty;\n  (l,q) \\<leftarrow> WHILET (\\<lambda>(l,q). \\<not>op_mset_is_empty q) (\\<lambda>(l,q). do {\n    (x,q) \\<leftarrow> mop_prio_pop_min prio q;\n    RETURN (l@[x],q)\n  }) (op_arl_empty,q);\n  RETURN l\n}\""], ["", "context fixes prio:: \"'a::{default,heap} \\<Rightarrow> 'b::linorder\" begin"], ["", "sepref_definition sort_impl is \n  \"sort_by_prio prio\" :: \"(list_assn (id_assn::'a::{default,heap} \\<Rightarrow> _))\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, sort_by_prio prio)\n    \\<in> (list_assn id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn id_assn", "unfolding sort_by_prio_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        nfoldli l (\\<lambda>_. True) mop_mset_insert\n         heap_custom_empty \\<bind>\n        (\\<lambda>q.\n            WHILE\\<^sub>T (\\<lambda>(l, q). \\<not> op_mset_is_empty q)\n             (\\<lambda>(l, q).\n                 mop_prio_pop_min prio q \\<bind>\n                 (\\<lambda>(x, q). RETURN (l @ [x], q)))\n             (op_arl_empty, q) \\<bind>\n            (\\<lambda>(l, q). RETURN l)))\n    \\<in> (list_assn id_assn)\\<^sup>k \\<rightarrow>\\<^sub>a arl_assn id_assn", "by sepref"], ["", "end"], ["", "definition \"sort_impl_nat \\<equiv> sort_impl (id::nat\\<Rightarrow>nat) \""], ["", "export_code sort_impl checking SML"], ["", "ML \\<open>\n  @{code sort_impl_nat} (map @{code nat_of_integer} [4,1,7,2,3,9,8,62]) ()\n\\<close>"], ["", "hide_const sort_impl sort_impl_nat"], ["", "hide_fact sort_impl_def sort_impl_nat_def sort_impl.refine"], ["", "end"]]}