{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/Examples/Snippets/Sepref_Snip_Combinator.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma F_unf: \"hn_ctxt F_assn x y = F\"", "lemma f_rl': \"hn_refine (hn_ctxt A x xi * hn_ctxt (F_assn) dx dxi) (fi xi) (hn_ctxt A' x xi * hn_ctxt (F_assn) dx dxi) B (f$x)\"", "lemmas mmap_impl' = mmap_impl[unfolded F_unf]", "lemma mmap_arity[sepref_monadify_arity]: \"mmap \\<equiv> \\<lambda>\\<^sub>2f l. SP mmap$(\\<lambda>\\<^sub>2x. f$x)$l\"", "lemma mmap_mcomb[sepref_monadify_comb]: \"mmap$f$x \\<equiv> (\\<bind>)$(EVAL$x)$(\\<lambda>\\<^sub>2x. SP mmap$f$x)\"", "lemma mmap_comb_rl[sepref_comb_rules]:\n    assumes \"P \\<Longrightarrow>\\<^sub>t hn_ctxt (list_assn A) l li * F\"\n        \\<comment> \\<open>Initial frame\\<close>\n      and \"\\<And>x xi. hn_refine (hn_ctxt A x xi * F) (fi xi) (Q x xi) B (f x)\"\n        \\<comment> \\<open>Refinement of map-function\\<close>\n      and \"\\<And>x xi. Q x xi \\<Longrightarrow>\\<^sub>t hn_ctxt A' x xi * F\"\n        \\<comment> \\<open>Recover refinement for list-element and original frame from what map-function produced\\<close>\n    shows \"hn_refine P (mmap_impl fi li) (hn_ctxt (list_assn A') l li * F) (list_assn B) (mmap$(\\<lambda>\\<^sub>2x. f x)$l)\""], "translations": [["", "lemma F_unf: \"hn_ctxt F_assn x y = F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_ctxt local.F_assn x y = F", "by (auto simp: F_assn_def hn_ctxt_def)"], ["", "text \\<open>We build a combinator rule to refine \\<open>f\\<close>. We need a combinator rule here,\n      because \\<open>f\\<close> does not only depend on its formal arguments, but also on the frame \n      (represented as dummy argument). \\<close>"], ["", "lemma f_rl': \"hn_refine (hn_ctxt A x xi * hn_ctxt (F_assn) dx dxi) (fi xi) (hn_ctxt A' x xi * hn_ctxt (F_assn) dx dxi) B (f$x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt A x xi * hn_ctxt local.F_assn dx dxi) (fi xi)\n     (hn_ctxt A' x xi * hn_ctxt local.F_assn dx dxi) B (f $ x)", "unfolding F_unf"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt A x xi * F) (fi xi) (hn_ctxt A' x xi * F) B (f $ x)", "by (rule f_rl)"], ["", "text \\<open>Then we use the Sepref tool to synthesize an implementation of \\<open>mmap\\<close>.\\<close>"], ["", "schematic_goal mmap_impl:\n      notes [sepref_comb_rules] = hn_refine_frame[OF f_rl']\n      shows \"hn_refine (hn_ctxt (list_assn A) l li * hn_ctxt (F_assn) dx dxi) (?c::?'c Heap) ?\\<Gamma>' ?R mmap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt (list_assn A) l li * hn_ctxt local.F_assn dx dxi) ?c\n     ?\\<Gamma>' ?R local.mmap", "unfolding mmap_def \"HOL_list.fold_custom_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine (hn_ctxt (list_assn A) l li * hn_ctxt local.F_assn dx dxi) ?c\n     ?\\<Gamma>' ?R\n     (REC\\<^sub>T\n       (\\<lambda>mmap xa.\n           case xa of [] \\<Rightarrow> RETURN op_HOL_list_empty\n           | x # xs \\<Rightarrow>\n               f x \\<bind>\n               (\\<lambda>x. mmap xs \\<bind> (\\<lambda>xs. RETURN (x # xs))))\n       l)", "apply sepref_dbg_keep"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>We unfold the wrapped frame\\<close>"], ["", "lemmas mmap_impl' = mmap_impl[unfolded F_unf]"], ["", "end"], ["", "subsection \\<open>Setup for Sepref\\<close>"], ["", "text \\<open>Outside the context, we extract the synthesized implementation as a new constant, and set up\n    code theorems for the fixed-point combinators.\\<close>"], ["", "concrete_definition mmap_impl uses mmap_impl'"], ["", "prepare_code_thms mmap_impl_def"], ["", "text \\<open>Moreover, we have to manually declare arity and monadify theorems.\n    The arity theorem ensures that we always have a constant number of operators, and \n    the monadify theorem determines an execution order: The list-argument is evaluated first.\n    \\<close>"], ["", "lemma mmap_arity[sepref_monadify_arity]: \"mmap \\<equiv> \\<lambda>\\<^sub>2f l. SP mmap$(\\<lambda>\\<^sub>2x. f$x)$l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mmap \\<equiv>\n    \\<lambda>x.\n       (#\\<lambda>xa. (#SP mmap $ (\\<lambda>xa. (#x $ xa#)) $ xa#)#)", "by simp"], ["", "lemma mmap_mcomb[sepref_monadify_comb]: \"mmap$f$x \\<equiv> (\\<bind>)$(EVAL$x)$(\\<lambda>\\<^sub>2x. SP mmap$f$x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mmap $ f $ x \\<equiv>\n    (\\<bind>) $ (EVAL $ x) $ (\\<lambda>x. (#SP mmap $ f $ x#))", "by simp"], ["", "text \\<open>We can massage the refinement theorem @{thm mmap_impl.refine} a bit, to get a valid \n    combinator rule\\<close>"], ["", "print_statement hn_refine_cons_pre[OF _ mmap_impl.refine, sepref_prep_comb_rule, no_vars]"], ["", "lemma mmap_comb_rl[sepref_comb_rules]:\n    assumes \"P \\<Longrightarrow>\\<^sub>t hn_ctxt (list_assn A) l li * F\"\n        \\<comment> \\<open>Initial frame\\<close>\n      and \"\\<And>x xi. hn_refine (hn_ctxt A x xi * F) (fi xi) (Q x xi) B (f x)\"\n        \\<comment> \\<open>Refinement of map-function\\<close>\n      and \"\\<And>x xi. Q x xi \\<Longrightarrow>\\<^sub>t hn_ctxt A' x xi * F\"\n        \\<comment> \\<open>Recover refinement for list-element and original frame from what map-function produced\\<close>\n    shows \"hn_refine P (mmap_impl fi li) (hn_ctxt (list_assn A') l li * F) (list_assn B) (mmap$(\\<lambda>\\<^sub>2x. f x)$l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine P (mmap_impl fi li) (hn_ctxt (list_assn A') l li * F)\n     (list_assn B) (mmap $ (\\<lambda>x. (#f x#)) $ l)", "unfolding APP_def PROTECT2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hn_refine P (mmap_impl fi li) (hn_ctxt (list_assn A') l li * F)\n     (list_assn B) (mmap f l)", "using hn_refine_cons_pre[OF _ mmap_impl.refine, sepref_prep_comb_rule, of P A l li F fi Q B f A']"], ["proof (prove)\nusing this:\n  \\<lbrakk>P \\<Longrightarrow>\\<^sub>t hn_ctxt (list_assn A) l li * F;\n   \\<And>x xi. hn_refine (hn_ctxt A x xi * F) (fi xi) (Q x xi) B (f $ x);\n   \\<And>x xi. Q x xi \\<Longrightarrow>\\<^sub>t hn_ctxt A' x xi * F\\<rbrakk>\n  \\<Longrightarrow> hn_refine P (mmap_impl fi li)\n                     (hn_ctxt (list_assn A') l li * F) (list_assn B)\n                     (mmap f l)\n\ngoal (1 subgoal):\n 1. hn_refine P (mmap_impl fi li) (hn_ctxt (list_assn A') l li * F)\n     (list_assn B) (mmap f l)", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>P \\<Longrightarrow>\\<^sub>t hn_ctxt (list_assn A) l li * F;\n   \\<And>x xi. hn_refine (hn_ctxt A x xi * F) (fi xi) (Q x xi) B (f $ x);\n   \\<And>x xi. Q x xi \\<Longrightarrow>\\<^sub>t hn_ctxt A' x xi * F\\<rbrakk>\n  \\<Longrightarrow> hn_refine P (mmap_impl fi li)\n                     (hn_ctxt (list_assn A') l li * F) (list_assn B)\n                     (mmap f l)\n  P \\<Longrightarrow>\\<^sub>t hn_ctxt (list_assn A) l li * F\n  hn_refine (hn_ctxt A ?x ?xi * F) (fi ?xi) (Q ?x ?xi) B (f ?x)\n  Q ?x ?xi \\<Longrightarrow>\\<^sub>t hn_ctxt A' ?x ?xi * F\n\ngoal (1 subgoal):\n 1. hn_refine P (mmap_impl fi li) (hn_ctxt (list_assn A') l li * F)\n     (list_assn B) (mmap f l)", "by simp"], ["", "subsection \\<open>Example\\<close>"], ["", "text \\<open>Finally, we can test our combinator. Note how the \n    map-function accesses the array on the heap, which is not among its arguments. \n    This is only possible as we passed around a frame. \\<close>"], ["", "sepref_thm test_mmap \n    is \"\\<lambda>l. do { let a = op_array_of_list [True,True,False]; mmap (\\<lambda>x. do { mop_list_get a (x mod 3) }) l }\"\n    :: \"(list_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a list_assn bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        let a = op_array_of_list [True, True, False]\n        in mmap (\\<lambda>x. mop_list_get a (x mod 3)) l)\n    \\<in> (list_assn\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a list_assn bool_assn", "unfolding HOL_list.fold_custom_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>l.\n        let a = op_array_of_list (True # True # False # op_HOL_list_empty)\n        in mmap (\\<lambda>x. mop_list_get a (x mod 3)) l)\n    \\<in> (list_assn\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a list_assn bool_assn", "by sepref"], ["", "subsection \\<open>Limitations\\<close>"], ["", "text \\<open>\n    Currently, the major limitation is that combinator rules are fixed to specific data types.\n    In our example, we did an implementation for HOL lists. We cannot come up with an alternative implementation, \n    for, e.g., array-lists, but have to use a different abstract combinator.\n\n    One workaround is to use some generic operations, as is done for foreach-loops, which require\n    a generic to-list operation. However, in this case, we produce unwanted intermediate lists, and\n    would have to add complicated a-posteriori deforestation optimizations.\n    \\<close>"], ["", "end"]]}