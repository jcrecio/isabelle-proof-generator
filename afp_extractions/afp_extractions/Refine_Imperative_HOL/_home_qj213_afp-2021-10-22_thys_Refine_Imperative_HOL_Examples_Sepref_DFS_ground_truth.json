{"file_name": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL/Examples/Sepref_DFS.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Refine_Imperative_HOL", "problem_names": ["lemma dfs_correct:\n    assumes fr: \"finite reachable\"\n    shows \"dfs \\<le> dfs_spec\"", "lemma dfs_correct': \"(uncurry2 dfs, uncurry2 dfs_spec) \n  \\<in> [\\<lambda>((E,s),t). finite (reachable E s)]\\<^sub>f ((Id\\<times>\\<^sub>rId)\\<times>\\<^sub>rId) \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\"", "lemmas dfs_impl_correct' = dfs_impl.refine[FCOMP dfs_correct']"], "translations": [["", "lemma dfs_correct:\n    assumes fr: \"finite reachable\"\n    shows \"dfs \\<le> dfs_spec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "have F: \"\\<And>v. v\\<in>reachable \\<Longrightarrow> finite (E``{v})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> local.reachable \\<Longrightarrow> finite (E `` {v})", "using fr"], ["proof (prove)\nusing this:\n  finite local.reachable\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> local.reachable \\<Longrightarrow> finite (E `` {v})", "apply (auto simp: reachable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(v0, v) \\<in> E\\<^sup>*;\n        finite {v. (v0, v) \\<in> E\\<^sup>*}\\<rbrakk>\n       \\<Longrightarrow> finite (E `` {v})", "by (metis (mono_tags) Image_singleton Image_singleton_iff\n        finite_subset rtrancl.rtrancl_into_rtrancl subsetI)"], ["proof (state)\nthis:\n  ?v \\<in> local.reachable \\<Longrightarrow> finite (E `` {?v})\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "define rpre where \"rpre = (\\<lambda>S (V,v). \n        v\\<in>reachable \n      \\<and> V\\<subseteq>reachable\n      \\<and> S\\<subseteq>V\n      \\<and> (V \\<inter> Collect tgt = {})\n      \\<and> E``(V-S) \\<subseteq> V)\""], ["proof (state)\nthis:\n  rpre =\n  (\\<lambda>S (V, v).\n      v \\<in> local.reachable \\<and>\n      V \\<subseteq> local.reachable \\<and>\n      S \\<subseteq> V \\<and>\n      V \\<inter> Collect tgt = {} \\<and> E `` (V - S) \\<subseteq> V)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "define rpost where \"rpost = (\\<lambda>S (V,v) (V',r). \n          (r\\<longleftrightarrow>V'\\<inter>Collect tgt \\<noteq> {}) \n        \\<and> V\\<subseteq>V' \n        \\<and> v\\<in>V'\n        \\<and> V'\\<subseteq>reachable\n        \\<and> (\\<not>r \\<longrightarrow> (E``(V'-S) \\<subseteq> V')))\n      \""], ["proof (state)\nthis:\n  rpost =\n  (\\<lambda>S (V, v) (V', r).\n      r = (V' \\<inter> Collect tgt \\<noteq> {}) \\<and>\n      V \\<subseteq> V' \\<and>\n      v \\<in> V' \\<and>\n      V' \\<subseteq> local.reachable \\<and>\n      (\\<not> r \\<longrightarrow> E `` (V' - S) \\<subseteq> V'))\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "define fe_inv where \"fe_inv = (\\<lambda>S V v it (V',r).\n        (r\\<longleftrightarrow>V'\\<inter>Collect tgt \\<noteq> {})\n      \\<and> insert v V\\<subseteq>V'\n      \\<and> E``{v} - it \\<subseteq> V'\n      \\<and> V'\\<subseteq>reachable\n      \\<and> S\\<subseteq>insert v V\n      \\<and> (\\<not>r \\<longrightarrow> E``(V'-S) \\<subseteq> V' \\<union> it \\<and> E``(V'-insert v S) \\<subseteq> V'))\""], ["proof (state)\nthis:\n  fe_inv =\n  (\\<lambda>S V v it (V', r).\n      r = (V' \\<inter> Collect tgt \\<noteq> {}) \\<and>\n      insert v V \\<subseteq> V' \\<and>\n      E `` {v} - it \\<subseteq> V' \\<and>\n      V' \\<subseteq> local.reachable \\<and>\n      S \\<subseteq> insert v V \\<and>\n      (\\<not> r \\<longrightarrow>\n       E `` (V' - S) \\<subseteq> V' \\<union> it \\<and>\n       E `` (V' - insert v S) \\<subseteq> V'))\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "have vc_pre_initial: \"rpre {} ({}, v0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rpre {} ({}, v0)", "by (auto simp: rpre_def reachable_def)"], ["proof (state)\nthis:\n  rpre {} ({}, v0)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "{"], ["proof (state)\nthis:\n  rpre {} ({}, v0)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "(* Case: Node already visited *)"], ["proof (state)\nthis:\n  rpre {} ({}, v0)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "fix S V v"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "assume \"rpre S (V,v)\"\n        and \"v\\<in>V\""], ["proof (state)\nthis:\n  rpre S (V, v)\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "hence \"rpost S (V,v) (V,False)\""], ["proof (prove)\nusing this:\n  rpre S (V, v)\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. rpost S (V, v) (V, False)", "unfolding rpre_def rpost_def"], ["proof (prove)\nusing this:\n  case (V, v) of\n  (V, v) \\<Rightarrow>\n    v \\<in> local.reachable \\<and>\n    V \\<subseteq> local.reachable \\<and>\n    S \\<subseteq> V \\<and>\n    V \\<inter> Collect tgt = {} \\<and> E `` (V - S) \\<subseteq> V\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. (case (V, v) of\n     (V, v) \\<Rightarrow>\n       \\<lambda>(V', r).\n          r = (V' \\<inter> Collect tgt \\<noteq> {}) \\<and>\n          V \\<subseteq> V' \\<and>\n          v \\<in> V' \\<and>\n          V' \\<subseteq> local.reachable \\<and>\n          (\\<not> r \\<longrightarrow> E `` (V' - S) \\<subseteq> V'))\n     (V, False)", "by auto"], ["proof (state)\nthis:\n  rpost S (V, v) (V, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "}"], ["proof (state)\nthis:\n  \\<lbrakk>rpre ?S2 (?V2, ?v2); ?v2 \\<in> ?V2\\<rbrakk>\n  \\<Longrightarrow> rpost ?S2 (?V2, ?v2) (?V2, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "note vc_node_visited = this"], ["proof (state)\nthis:\n  \\<lbrakk>rpre ?S2 (?V2, ?v2); ?v2 \\<in> ?V2\\<rbrakk>\n  \\<Longrightarrow> rpost ?S2 (?V2, ?v2) (?V2, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "{"], ["proof (state)\nthis:\n  \\<lbrakk>rpre ?S2 (?V2, ?v2); ?v2 \\<in> ?V2\\<rbrakk>\n  \\<Longrightarrow> rpost ?S2 (?V2, ?v2) (?V2, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "(* Case: Found node *)"], ["proof (state)\nthis:\n  \\<lbrakk>rpre ?S2 (?V2, ?v2); ?v2 \\<in> ?V2\\<rbrakk>\n  \\<Longrightarrow> rpost ?S2 (?V2, ?v2) (?V2, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "fix S V v"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "assume \"tgt v\"\n      and \"rpre S (V,v)\""], ["proof (state)\nthis:\n  tgt v\n  rpre S (V, v)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "hence \"rpost S (V,v) (insert v V, True)\""], ["proof (prove)\nusing this:\n  tgt v\n  rpre S (V, v)\n\ngoal (1 subgoal):\n 1. rpost S (V, v) (insert v V, True)", "unfolding rpre_def rpost_def"], ["proof (prove)\nusing this:\n  tgt v\n  case (V, v) of\n  (V, v) \\<Rightarrow>\n    v \\<in> local.reachable \\<and>\n    V \\<subseteq> local.reachable \\<and>\n    S \\<subseteq> V \\<and>\n    V \\<inter> Collect tgt = {} \\<and> E `` (V - S) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. (case (V, v) of\n     (V, v) \\<Rightarrow>\n       \\<lambda>(V', r).\n          r = (V' \\<inter> Collect tgt \\<noteq> {}) \\<and>\n          V \\<subseteq> V' \\<and>\n          v \\<in> V' \\<and>\n          V' \\<subseteq> local.reachable \\<and>\n          (\\<not> r \\<longrightarrow> E `` (V' - S) \\<subseteq> V'))\n     (insert v V, True)", "by auto"], ["proof (state)\nthis:\n  rpost S (V, v) (insert v V, True)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "}"], ["proof (state)\nthis:\n  \\<lbrakk>tgt ?v2; rpre ?S2 (?V2, ?v2)\\<rbrakk>\n  \\<Longrightarrow> rpost ?S2 (?V2, ?v2) (insert ?v2 ?V2, True)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "note vc_node_found = this"], ["proof (state)\nthis:\n  \\<lbrakk>tgt ?v2; rpre ?S2 (?V2, ?v2)\\<rbrakk>\n  \\<Longrightarrow> rpost ?S2 (?V2, ?v2) (insert ?v2 ?V2, True)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "{"], ["proof (state)\nthis:\n  \\<lbrakk>tgt ?v2; rpre ?S2 (?V2, ?v2)\\<rbrakk>\n  \\<Longrightarrow> rpost ?S2 (?V2, ?v2) (insert ?v2 ?V2, True)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "fix S V v"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "assume \"rpre S (V, v)\""], ["proof (state)\nthis:\n  rpre S (V, v)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "hence \"finite (E``{v})\""], ["proof (prove)\nusing this:\n  rpre S (V, v)\n\ngoal (1 subgoal):\n 1. finite (E `` {v})", "unfolding rpre_def"], ["proof (prove)\nusing this:\n  case (V, v) of\n  (V, v) \\<Rightarrow>\n    v \\<in> local.reachable \\<and>\n    V \\<subseteq> local.reachable \\<and>\n    S \\<subseteq> V \\<and>\n    V \\<inter> Collect tgt = {} \\<and> E `` (V - S) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. finite (E `` {v})", "using F"], ["proof (prove)\nusing this:\n  case (V, v) of\n  (V, v) \\<Rightarrow>\n    v \\<in> local.reachable \\<and>\n    V \\<subseteq> local.reachable \\<and>\n    S \\<subseteq> V \\<and>\n    V \\<inter> Collect tgt = {} \\<and> E `` (V - S) \\<subseteq> V\n  ?v \\<in> local.reachable \\<Longrightarrow> finite (E `` {?v})\n\ngoal (1 subgoal):\n 1. finite (E `` {v})", "by (auto)"], ["proof (state)\nthis:\n  finite (E `` {v})\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "}"], ["proof (state)\nthis:\n  rpre ?S2 (?V2, ?v2) \\<Longrightarrow> finite (E `` {?v2})\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "note vc_foreach_finite = this"], ["proof (state)\nthis:\n  rpre ?S2 (?V2, ?v2) \\<Longrightarrow> finite (E `` {?v2})\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "{"], ["proof (state)\nthis:\n  rpre ?S2 (?V2, ?v2) \\<Longrightarrow> finite (E `` {?v2})\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "(* fe_inv initial *)"], ["proof (state)\nthis:\n  rpre ?S2 (?V2, ?v2) \\<Longrightarrow> finite (E `` {?v2})\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "fix S V v"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "assume A: \"v \\<notin> V\" \"\\<not>tgt v\"\n        and PRE: \"rpre S (V, v)\""], ["proof (state)\nthis:\n  v \\<notin> V\n  \\<not> tgt v\n  rpre S (V, v)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "hence \"fe_inv S V v (E``{v}) (insert v V, False)\""], ["proof (prove)\nusing this:\n  v \\<notin> V\n  \\<not> tgt v\n  rpre S (V, v)\n\ngoal (1 subgoal):\n 1. fe_inv S V v (E `` {v}) (insert v V, False)", "unfolding fe_inv_def rpre_def"], ["proof (prove)\nusing this:\n  v \\<notin> V\n  \\<not> tgt v\n  case (V, v) of\n  (V, v) \\<Rightarrow>\n    v \\<in> local.reachable \\<and>\n    V \\<subseteq> local.reachable \\<and>\n    S \\<subseteq> V \\<and>\n    V \\<inter> Collect tgt = {} \\<and> E `` (V - S) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. case (insert v V, False) of\n    (V', r) \\<Rightarrow>\n      r = (V' \\<inter> Collect tgt \\<noteq> {}) \\<and>\n      insert v V \\<subseteq> V' \\<and>\n      E `` {v} - E `` {v} \\<subseteq> V' \\<and>\n      V' \\<subseteq> local.reachable \\<and>\n      S \\<subseteq> insert v V \\<and>\n      (\\<not> r \\<longrightarrow>\n       E `` (V' - S) \\<subseteq> V' \\<union> E `` {v} \\<and>\n       E `` (V' - insert v S) \\<subseteq> V')", "by (auto)"], ["proof (state)\nthis:\n  fe_inv S V v (E `` {v}) (insert v V, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?v2 \\<notin> ?V2; \\<not> tgt ?v2; rpre ?S2 (?V2, ?v2)\\<rbrakk>\n  \\<Longrightarrow> fe_inv ?S2 ?V2 ?v2 (E `` {?v2}) (insert ?v2 ?V2, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "note vc_enter_foreach = this"], ["proof (state)\nthis:\n  \\<lbrakk>?v2 \\<notin> ?V2; \\<not> tgt ?v2; rpre ?S2 (?V2, ?v2)\\<rbrakk>\n  \\<Longrightarrow> fe_inv ?S2 ?V2 ?v2 (E `` {?v2}) (insert ?v2 ?V2, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?v2 \\<notin> ?V2; \\<not> tgt ?v2; rpre ?S2 (?V2, ?v2)\\<rbrakk>\n  \\<Longrightarrow> fe_inv ?S2 ?V2 ?v2 (E `` {?v2}) (insert ?v2 ?V2, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "(* fe_inv ensures rpre *)"], ["proof (state)\nthis:\n  \\<lbrakk>?v2 \\<notin> ?V2; \\<not> tgt ?v2; rpre ?S2 (?V2, ?v2)\\<rbrakk>\n  \\<Longrightarrow> fe_inv ?S2 ?V2 ?v2 (E `` {?v2}) (insert ?v2 ?V2, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "fix S V v v' it V'"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "assume A: \"v \\<notin> V\" \"\\<not>tgt v\" \"v' \\<in> it\" \"it \\<subseteq> E``{v}\"\n        and FEI: \"fe_inv S V v it (V', False)\"\n        and PRE: \"rpre S (V, v)\""], ["proof (state)\nthis:\n  v \\<notin> V\n  \\<not> tgt v\n  v' \\<in> it\n  it \\<subseteq> E `` {v}\n  fe_inv S V v it (V', False)\n  rpre S (V, v)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "from A"], ["proof (chain)\npicking this:\n  v \\<notin> V\n  \\<not> tgt v\n  v' \\<in> it\n  it \\<subseteq> E `` {v}", "have \"v' \\<in> E``{v}\""], ["proof (prove)\nusing this:\n  v \\<notin> V\n  \\<not> tgt v\n  v' \\<in> it\n  it \\<subseteq> E `` {v}\n\ngoal (1 subgoal):\n 1. v' \\<in> E `` {v}", "by auto"], ["proof (state)\nthis:\n  v' \\<in> E `` {v}\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "moreover"], ["proof (state)\nthis:\n  v' \\<in> E `` {v}\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "from PRE"], ["proof (chain)\npicking this:\n  rpre S (V, v)", "have \"v \\<in> reachable\""], ["proof (prove)\nusing this:\n  rpre S (V, v)\n\ngoal (1 subgoal):\n 1. v \\<in> local.reachable", "by (auto simp: rpre_def)"], ["proof (state)\nthis:\n  v \\<in> local.reachable\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "hence \"E``{v} \\<subseteq> reachable\""], ["proof (prove)\nusing this:\n  v \\<in> local.reachable\n\ngoal (1 subgoal):\n 1. E `` {v} \\<subseteq> local.reachable", "by (auto simp: reachable_def)"], ["proof (state)\nthis:\n  E `` {v} \\<subseteq> local.reachable\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "ultimately"], ["proof (chain)\npicking this:\n  v' \\<in> E `` {v}\n  E `` {v} \\<subseteq> local.reachable", "have [simp]: \"v'\\<in>reachable\""], ["proof (prove)\nusing this:\n  v' \\<in> E `` {v}\n  E `` {v} \\<subseteq> local.reachable\n\ngoal (1 subgoal):\n 1. v' \\<in> local.reachable", "by blast"], ["proof (state)\nthis:\n  v' \\<in> local.reachable\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "have \"rpre (insert v S) (V', v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rpre (insert v S) (V', v')", "unfolding rpre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (V', v') of\n    (V, va) \\<Rightarrow>\n      va \\<in> local.reachable \\<and>\n      V \\<subseteq> local.reachable \\<and>\n      insert v S \\<subseteq> V \\<and>\n      V \\<inter> Collect tgt = {} \\<and> E `` (V - insert v S) \\<subseteq> V", "using FEI PRE"], ["proof (prove)\nusing this:\n  fe_inv S V v it (V', False)\n  rpre S (V, v)\n\ngoal (1 subgoal):\n 1. case (V', v') of\n    (V, va) \\<Rightarrow>\n      va \\<in> local.reachable \\<and>\n      V \\<subseteq> local.reachable \\<and>\n      insert v S \\<subseteq> V \\<and>\n      V \\<inter> Collect tgt = {} \\<and> E `` (V - insert v S) \\<subseteq> V", "by (auto simp: fe_inv_def rpre_def) []"], ["proof (state)\nthis:\n  rpre (insert v S) (V', v')\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?v2 \\<notin> ?V2; \\<not> tgt ?v2; ?v'2 \\<in> ?it2;\n   ?it2 \\<subseteq> E `` {?v2}; fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, False);\n   rpre ?S2 (?V2, ?v2)\\<rbrakk>\n  \\<Longrightarrow> rpre (insert ?v2 ?S2) (?V'2, ?v'2)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "note vc_rec_pre = this"], ["proof (state)\nthis:\n  \\<lbrakk>?v2 \\<notin> ?V2; \\<not> tgt ?v2; ?v'2 \\<in> ?it2;\n   ?it2 \\<subseteq> E `` {?v2}; fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, False);\n   rpre ?S2 (?V2, ?v2)\\<rbrakk>\n  \\<Longrightarrow> rpre (insert ?v2 ?S2) (?V'2, ?v'2)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?v2 \\<notin> ?V2; \\<not> tgt ?v2; ?v'2 \\<in> ?it2;\n   ?it2 \\<subseteq> E `` {?v2}; fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, False);\n   rpre ?S2 (?V2, ?v2)\\<rbrakk>\n  \\<Longrightarrow> rpre (insert ?v2 ?S2) (?V'2, ?v'2)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "(* rpost implies fe_inv *)"], ["proof (state)\nthis:\n  \\<lbrakk>?v2 \\<notin> ?V2; \\<not> tgt ?v2; ?v'2 \\<in> ?it2;\n   ?it2 \\<subseteq> E `` {?v2}; fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, False);\n   rpre ?S2 (?V2, ?v2)\\<rbrakk>\n  \\<Longrightarrow> rpre (insert ?v2 ?S2) (?V'2, ?v'2)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "fix S V V' v v' it Vr''"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "assume \"fe_inv S V v it (V', False)\"\n        and \"rpost (insert v S) (V', v') Vr''\""], ["proof (state)\nthis:\n  fe_inv S V v it (V', False)\n  rpost (insert v S) (V', v') Vr''\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "hence \"fe_inv S V v (it - {v'}) Vr''\""], ["proof (prove)\nusing this:\n  fe_inv S V v it (V', False)\n  rpost (insert v S) (V', v') Vr''\n\ngoal (1 subgoal):\n 1. fe_inv S V v (it - {v'}) Vr''", "unfolding rpre_def rpost_def fe_inv_def"], ["proof (prove)\nusing this:\n  case (V', False) of\n  (V', r) \\<Rightarrow>\n    r = (V' \\<inter> Collect tgt \\<noteq> {}) \\<and>\n    insert v V \\<subseteq> V' \\<and>\n    E `` {v} - it \\<subseteq> V' \\<and>\n    V' \\<subseteq> local.reachable \\<and>\n    S \\<subseteq> insert v V \\<and>\n    (\\<not> r \\<longrightarrow>\n     E `` (V' - S) \\<subseteq> V' \\<union> it \\<and>\n     E `` (V' - insert v S) \\<subseteq> V')\n  (case (V', v') of\n   (V, va) \\<Rightarrow>\n     \\<lambda>(V', r).\n        r = (V' \\<inter> Collect tgt \\<noteq> {}) \\<and>\n        V \\<subseteq> V' \\<and>\n        va \\<in> V' \\<and>\n        V' \\<subseteq> local.reachable \\<and>\n        (\\<not> r \\<longrightarrow> E `` (V' - insert v S) \\<subseteq> V'))\n   Vr''\n\ngoal (1 subgoal):\n 1. case Vr'' of\n    (V', r) \\<Rightarrow>\n      r = (V' \\<inter> Collect tgt \\<noteq> {}) \\<and>\n      insert v V \\<subseteq> V' \\<and>\n      E `` {v} - (it - {v'}) \\<subseteq> V' \\<and>\n      V' \\<subseteq> local.reachable \\<and>\n      S \\<subseteq> insert v V \\<and>\n      (\\<not> r \\<longrightarrow>\n       E `` (V' - S) \\<subseteq> V' \\<union> (it - {v'}) \\<and>\n       E `` (V' - insert v S) \\<subseteq> V')", "by clarsimp blast"], ["proof (state)\nthis:\n  fe_inv S V v (it - {v'}) Vr''\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "}"], ["proof (state)\nthis:\n  \\<lbrakk>fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, False);\n   rpost (insert ?v2 ?S2) (?V'2, ?v'2) ?Vr''2\\<rbrakk>\n  \\<Longrightarrow> fe_inv ?S2 ?V2 ?v2 (?it2 - {?v'2}) ?Vr''2\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "note vc_iterate_foreach = this"], ["proof (state)\nthis:\n  \\<lbrakk>fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, False);\n   rpost (insert ?v2 ?S2) (?V'2, ?v'2) ?Vr''2\\<rbrakk>\n  \\<Longrightarrow> fe_inv ?S2 ?V2 ?v2 (?it2 - {?v'2}) ?Vr''2\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "{"], ["proof (state)\nthis:\n  \\<lbrakk>fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, False);\n   rpost (insert ?v2 ?S2) (?V'2, ?v'2) ?Vr''2\\<rbrakk>\n  \\<Longrightarrow> fe_inv ?S2 ?V2 ?v2 (?it2 - {?v'2}) ?Vr''2\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "(* fe_inv (completed) implies rpost *)"], ["proof (state)\nthis:\n  \\<lbrakk>fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, False);\n   rpost (insert ?v2 ?S2) (?V'2, ?v'2) ?Vr''2\\<rbrakk>\n  \\<Longrightarrow> fe_inv ?S2 ?V2 ?v2 (?it2 - {?v'2}) ?Vr''2\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "fix S V v V'"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "assume PRE: \"rpre S (V, v)\""], ["proof (state)\nthis:\n  rpre S (V, v)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "assume A: \"v \\<notin> V\" \"\\<not>tgt v\""], ["proof (state)\nthis:\n  v \\<notin> V\n  \\<not> tgt v\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "assume FEI: \"fe_inv S V v {} (V', False)\""], ["proof (state)\nthis:\n  fe_inv S V v {} (V', False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "have \"rpost S (V, v) (V', False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rpost S (V, v) (V', False)", "unfolding rpost_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (V, v) of\n     (V, v) \\<Rightarrow>\n       \\<lambda>(V', r).\n          r = (V' \\<inter> Collect tgt \\<noteq> {}) \\<and>\n          V \\<subseteq> V' \\<and>\n          v \\<in> V' \\<and>\n          V' \\<subseteq> local.reachable \\<and>\n          (\\<not> r \\<longrightarrow> E `` (V' - S) \\<subseteq> V'))\n     (V', False)", "using FEI"], ["proof (prove)\nusing this:\n  fe_inv S V v {} (V', False)\n\ngoal (1 subgoal):\n 1. (case (V, v) of\n     (V, v) \\<Rightarrow>\n       \\<lambda>(V', r).\n          r = (V' \\<inter> Collect tgt \\<noteq> {}) \\<and>\n          V \\<subseteq> V' \\<and>\n          v \\<in> V' \\<and>\n          V' \\<subseteq> local.reachable \\<and>\n          (\\<not> r \\<longrightarrow> E `` (V' - S) \\<subseteq> V'))\n     (V', False)", "by (auto simp: fe_inv_def) []"], ["proof (state)\nthis:\n  rpost S (V, v) (V', False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "}"], ["proof (state)\nthis:\n  \\<lbrakk>rpre ?S2 (?V2, ?v2); ?v2 \\<notin> ?V2; \\<not> tgt ?v2;\n   fe_inv ?S2 ?V2 ?v2 {} (?V'2, False)\\<rbrakk>\n  \\<Longrightarrow> rpost ?S2 (?V2, ?v2) (?V'2, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "note vc_foreach_completed_imp_post = this"], ["proof (state)\nthis:\n  \\<lbrakk>rpre ?S2 (?V2, ?v2); ?v2 \\<notin> ?V2; \\<not> tgt ?v2;\n   fe_inv ?S2 ?V2 ?v2 {} (?V'2, False)\\<rbrakk>\n  \\<Longrightarrow> rpost ?S2 (?V2, ?v2) (?V'2, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "{"], ["proof (state)\nthis:\n  \\<lbrakk>rpre ?S2 (?V2, ?v2); ?v2 \\<notin> ?V2; \\<not> tgt ?v2;\n   fe_inv ?S2 ?V2 ?v2 {} (?V'2, False)\\<rbrakk>\n  \\<Longrightarrow> rpost ?S2 (?V2, ?v2) (?V'2, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "(* fe_inv (interrupted) implies rpost *)"], ["proof (state)\nthis:\n  \\<lbrakk>rpre ?S2 (?V2, ?v2); ?v2 \\<notin> ?V2; \\<not> tgt ?v2;\n   fe_inv ?S2 ?V2 ?v2 {} (?V'2, False)\\<rbrakk>\n  \\<Longrightarrow> rpost ?S2 (?V2, ?v2) (?V'2, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "fix S V v V' it"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "assume PRE: \"rpre S (V, v)\" \n        and A: \"v \\<notin> V\" \"\\<not>tgt v\" \"it \\<subseteq> E``{v}\"\n        and FEI: \"fe_inv S V v it (V', True)\""], ["proof (state)\nthis:\n  rpre S (V, v)\n  v \\<notin> V\n  \\<not> tgt v\n  it \\<subseteq> E `` {v}\n  fe_inv S V v it (V', True)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "hence \"rpost S (V, v) (V', True)\""], ["proof (prove)\nusing this:\n  rpre S (V, v)\n  v \\<notin> V\n  \\<not> tgt v\n  it \\<subseteq> E `` {v}\n  fe_inv S V v it (V', True)\n\ngoal (1 subgoal):\n 1. rpost S (V, v) (V', True)", "by (auto simp add: rpre_def rpost_def fe_inv_def) []"], ["proof (state)\nthis:\n  rpost S (V, v) (V', True)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "}"], ["proof (state)\nthis:\n  \\<lbrakk>rpre ?S2 (?V2, ?v2); ?v2 \\<notin> ?V2; \\<not> tgt ?v2;\n   ?it2 \\<subseteq> E `` {?v2};\n   fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, True)\\<rbrakk>\n  \\<Longrightarrow> rpost ?S2 (?V2, ?v2) (?V'2, True)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "note vc_foreach_interrupted_imp_post = this"], ["proof (state)\nthis:\n  \\<lbrakk>rpre ?S2 (?V2, ?v2); ?v2 \\<notin> ?V2; \\<not> tgt ?v2;\n   ?it2 \\<subseteq> E `` {?v2};\n   fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, True)\\<rbrakk>\n  \\<Longrightarrow> rpost ?S2 (?V2, ?v2) (?V'2, True)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "{"], ["proof (state)\nthis:\n  \\<lbrakk>rpre ?S2 (?V2, ?v2); ?v2 \\<notin> ?V2; \\<not> tgt ?v2;\n   ?it2 \\<subseteq> E `` {?v2};\n   fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, True)\\<rbrakk>\n  \\<Longrightarrow> rpost ?S2 (?V2, ?v2) (?V'2, True)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "fix V r"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "assume \"rpost {} ({}, v0) (V, r)\""], ["proof (state)\nthis:\n  rpost {} ({}, v0) (V, r)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "hence \"(r \\<longleftrightarrow> reachable \\<inter> Collect tgt \\<noteq> {}) \\<and> (\\<not>r\\<longrightarrow>V=reachable)\""], ["proof (prove)\nusing this:\n  rpost {} ({}, v0) (V, r)\n\ngoal (1 subgoal):\n 1. r = (local.reachable \\<inter> Collect tgt \\<noteq> {}) \\<and>\n    (\\<not> r \\<longrightarrow> V = local.reachable)", "by (auto \n          simp: rpost_def reachable_def \n          dest: Image_closed_trancl \n          intro: rev_ImageI)"], ["proof (state)\nthis:\n  r = (local.reachable \\<inter> Collect tgt \\<noteq> {}) \\<and>\n  (\\<not> r \\<longrightarrow> V = local.reachable)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "}"], ["proof (state)\nthis:\n  rpost {} ({}, v0) (?V2, ?r2) \\<Longrightarrow>\n  ?r2 = (local.reachable \\<inter> Collect tgt \\<noteq> {}) \\<and>\n  (\\<not> ?r2 \\<longrightarrow> ?V2 = local.reachable)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "note vc_rpost_imp_spec = this"], ["proof (state)\nthis:\n  rpost {} ({}, v0) (?V2, ?r2) \\<Longrightarrow>\n  ?r2 = (local.reachable \\<inter> Collect tgt \\<noteq> {}) \\<and>\n  (\\<not> ?r2 \\<longrightarrow> ?V2 = local.reachable)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dfs \\<le> local.dfs_spec", "unfolding dfs_def dfs_spec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>dfs (V, v).\n         if v \\<in> V then RETURN (V, False)\n         else let V = insert v V\n              in if tgt v then RETURN (V, True)\n                 else FOREACH\\<^sub>C (E `` {v})\n                       (\\<lambda>(uu_, b). \\<not> b)\n                       (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False))\n     ({}, v0) \\<bind>\n    (\\<lambda>(V, r). RETURN (V, r))\n    \\<le> SPEC\n           (\\<lambda>(V, r).\n               r = (local.reachable \\<inter> Collect tgt \\<noteq> {}) \\<and>\n               (\\<not> r \\<longrightarrow> V = local.reachable))", "apply (refine_rcg refine_vcg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>dfs (V, v).\n         if v \\<in> V then RETURN (V, False)\n         else let V = insert v V\n              in if tgt v then RETURN (V, True)\n                 else FOREACH\\<^sub>C (E `` {v})\n                       (\\<lambda>(uu_, b). \\<not> b)\n                       (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False))\n     ({}, v0)\n    \\<le> SPEC\n           (\\<lambda>x.\n               (case x of (V, r) \\<Rightarrow> RETURN (V, r))\n               \\<le> SPEC\n                      (\\<lambda>(V, r).\n                          r =\n                          (local.reachable \\<inter> Collect tgt \\<noteq>\n                           {}) \\<and>\n                          (\\<not> r \\<longrightarrow> V = local.reachable)))", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. REC\\<^sub>T\n     (\\<lambda>dfs (V, v).\n         if v \\<in> V then RETURN (V, False)\n         else let V = insert v V\n              in if tgt v then RETURN (V, True)\n                 else FOREACH\\<^sub>C (E `` {v})\n                       (\\<lambda>(uu_, b). \\<not> b)\n                       (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False))\n     ({}, v0)\n    \\<le> ?y1\n 2. ?y1\n    \\<le> SPEC\n           (\\<lambda>x.\n               (case x of (V, r) \\<Rightarrow> RETURN (V, r))\n               \\<le> SPEC\n                      (\\<lambda>(V, r).\n                          r =\n                          (local.reachable \\<inter> Collect tgt \\<noteq>\n                           {}) \\<and>\n                          (\\<not> r \\<longrightarrow> V = local.reachable)))", "apply(rule RECT_rule_arb[where \n          pre=rpre \n          and M=\"\\<lambda>a x. SPEC (rpost a x)\"\n          and V=\"finite_psupset reachable <*lex*> {}\"\n          ])"], ["proof (prove)\ngoal (5 subgoals):\n 1. trimono\n     (\\<lambda>dfs (V, v).\n         if v \\<in> V then RETURN (V, False)\n         else let V = insert v V\n              in if tgt v then RETURN (V, True)\n                 else FOREACH\\<^sub>C (E `` {v})\n                       (\\<lambda>(uu_, b). \\<not> b)\n                       (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False))\n 2. wf (finite_psupset local.reachable <*lex*> {})\n 3. rpre ?arb4 ({}, v0)\n 4. \\<And>f arb x.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', x)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb x;\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (V, v) \\<Rightarrow>\n                            if v \\<in> V then RETURN (V, False)\n                            else let V = insert v V\n                                 in if tgt v then RETURN (V, True)\n                                    else FOREACH\\<^sub>C (E `` {v})\n    (\\<lambda>(uu_, b). \\<not> b) (\\<lambda>v' (V, uu_). f (V, v'))\n    (V, False))\n                         \\<le> SPEC (rpost arb x)\n 5. SPEC (rpost ?arb4 ({}, v0))\n    \\<le> SPEC\n           (\\<lambda>x.\n               (case x of (V, r) \\<Rightarrow> RETURN (V, r))\n               \\<le> SPEC\n                      (\\<lambda>(V, r).\n                          r =\n                          (local.reachable \\<inter> Collect tgt \\<noteq>\n                           {}) \\<and>\n                          (\\<not> r \\<longrightarrow> V = local.reachable)))", "apply refine_mono"], ["proof (prove)\ngoal (4 subgoals):\n 1. wf (finite_psupset local.reachable <*lex*> {})\n 2. rpre ?arb4 ({}, v0)\n 3. \\<And>f arb x.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', x)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb x;\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (V, v) \\<Rightarrow>\n                            if v \\<in> V then RETURN (V, False)\n                            else let V = insert v V\n                                 in if tgt v then RETURN (V, True)\n                                    else FOREACH\\<^sub>C (E `` {v})\n    (\\<lambda>(uu_, b). \\<not> b) (\\<lambda>v' (V, uu_). f (V, v'))\n    (V, False))\n                         \\<le> SPEC (rpost arb x)\n 4. SPEC (rpost ?arb4 ({}, v0))\n    \\<le> SPEC\n           (\\<lambda>x.\n               (case x of (V, r) \\<Rightarrow> RETURN (V, r))\n               \\<le> SPEC\n                      (\\<lambda>(V, r).\n                          r =\n                          (local.reachable \\<inter> Collect tgt \\<noteq>\n                           {}) \\<and>\n                          (\\<not> r \\<longrightarrow> V = local.reachable)))", "apply (blast intro: fr)"], ["proof (prove)\ngoal (3 subgoals):\n 1. rpre ?arb4 ({}, v0)\n 2. \\<And>f arb x.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', x)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb x;\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (V, v) \\<Rightarrow>\n                            if v \\<in> V then RETURN (V, False)\n                            else let V = insert v V\n                                 in if tgt v then RETURN (V, True)\n                                    else FOREACH\\<^sub>C (E `` {v})\n    (\\<lambda>(uu_, b). \\<not> b) (\\<lambda>v' (V, uu_). f (V, v'))\n    (V, False))\n                         \\<le> SPEC (rpost arb x)\n 3. SPEC (rpost ?arb4 ({}, v0))\n    \\<le> SPEC\n           (\\<lambda>x.\n               (case x of (V, r) \\<Rightarrow> RETURN (V, r))\n               \\<le> SPEC\n                      (\\<lambda>(V, r).\n                          r =\n                          (local.reachable \\<inter> Collect tgt \\<noteq>\n                           {}) \\<and>\n                          (\\<not> r \\<longrightarrow> V = local.reachable)))", "apply (rule vc_pre_initial)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f arb x.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', x)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb x;\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          (V, v) \\<Rightarrow>\n                            if v \\<in> V then RETURN (V, False)\n                            else let V = insert v V\n                                 in if tgt v then RETURN (V, True)\n                                    else FOREACH\\<^sub>C (E `` {v})\n    (\\<lambda>(uu_, b). \\<not> b) (\\<lambda>v' (V, uu_). f (V, v'))\n    (V, False))\n                         \\<le> SPEC (rpost arb x)\n 2. SPEC (rpost {} ({}, v0))\n    \\<le> SPEC\n           (\\<lambda>x.\n               (case x of (V, r) \\<Rightarrow> RETURN (V, r))\n               \\<le> SPEC\n                      (\\<lambda>(V, r).\n                          r =\n                          (local.reachable \\<inter> Collect tgt \\<noteq>\n                           {}) \\<and>\n                          (\\<not> r \\<longrightarrow> V = local.reachable)))", "apply (refine_rcg refine_vcg \n        FOREACHc_rule'[where I=\"fe_inv S v s\" for S v s]\n        )"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>f arb x a b.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', x)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb x;\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<in> a\\<rbrakk>\n       \\<Longrightarrow> rpost arb x (a, False)\n 2. \\<And>f arb x a b.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', x)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb x;\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; tgt b\\<rbrakk>\n       \\<Longrightarrow> rpost arb x (insert b a, True)\n 3. \\<And>f arb x a b.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', x)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb x;\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b\\<rbrakk>\n       \\<Longrightarrow> finite (E `` {b})\n 4. \\<And>f arb x a b.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', x)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb x;\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b\\<rbrakk>\n       \\<Longrightarrow> fe_inv (?S131 f arb x a b) (?v131 f arb x a b)\n                          (?s131 f arb x a b) (E `` {b}) (insert b a, False)\n 5. \\<And>f arb x a b xa it \\<sigma> aa ba.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', x)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb x;\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; xa \\<in> it;\n        it \\<subseteq> E `` {b};\n        fe_inv (?S131 f arb x a b) (?v131 f arb x a b) (?s131 f arb x a b)\n         it \\<sigma>;\n        case \\<sigma> of (uu_, b) \\<Rightarrow> \\<not> b;\n        \\<sigma> = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> f (aa, xa)\n                         \\<le> SPEC\n                                (fe_inv (?S131 f arb x a b)\n                                  (?v131 f arb x a b) (?s131 f arb x a b)\n                                  (it - {xa}))\n 6. \\<And>f arb x a b \\<sigma>.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', x)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb x;\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b;\n        fe_inv (?S131 f arb x a b) (?v131 f arb x a b) (?s131 f arb x a b)\n         {} \\<sigma>;\n        case \\<sigma> of (uu_, b) \\<Rightarrow> \\<not> b\\<rbrakk>\n       \\<Longrightarrow> rpost arb x \\<sigma>\n 7. \\<And>f arb x a b it \\<sigma>.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', x)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb x;\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; it \\<subseteq> E `` {b};\n        fe_inv (?S131 f arb x a b) (?v131 f arb x a b) (?s131 f arb x a b)\n         it \\<sigma>;\n        \\<not> (case \\<sigma> of (uu_, b) \\<Rightarrow> \\<not> b)\\<rbrakk>\n       \\<Longrightarrow> rpost arb x \\<sigma>\n 8. SPEC (rpost {} ({}, v0))\n    \\<le> SPEC\n           (\\<lambda>x.\n               (case x of (V, r) \\<Rightarrow> RETURN (V, r))\n               \\<le> SPEC\n                      (\\<lambda>(V, r).\n                          r =\n                          (local.reachable \\<inter> Collect tgt \\<noteq>\n                           {}) \\<and>\n                          (\\<not> r \\<longrightarrow> V = local.reachable)))", "apply (simp_all add: vc_node_visited vc_node_found)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>f arb x a b.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b\\<rbrakk>\n       \\<Longrightarrow> finite (E `` {b})\n 2. \\<And>f arb x a b.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b\\<rbrakk>\n       \\<Longrightarrow> fe_inv (?S131 f arb (a, b) a b)\n                          (?v131 f arb (a, b) a b) (?s131 f arb (a, b) a b)\n                          (E `` {b}) (insert b a, False)\n 3. \\<And>f arb x a b xa it \\<sigma> aa ba.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; xa \\<in> it;\n        it \\<subseteq> E `` {b};\n        fe_inv (?S131 f arb (a, b) a b) (?v131 f arb (a, b) a b)\n         (?s131 f arb (a, b) a b) it (aa, False);\n        \\<not> ba; \\<sigma> = (aa, False)\\<rbrakk>\n       \\<Longrightarrow> f (aa, xa)\n                         \\<le> SPEC\n                                (fe_inv (?S131 f arb (a, b) a b)\n                                  (?v131 f arb (a, b) a b)\n                                  (?s131 f arb (a, b) a b) (it - {xa}))\n 4. \\<And>f arb x a b \\<sigma>.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b;\n        fe_inv (?S131 f arb (a, b) a b) (?v131 f arb (a, b) a b)\n         (?s131 f arb (a, b) a b) {} \\<sigma>;\n        case \\<sigma> of (uu_, b) \\<Rightarrow> \\<not> b\\<rbrakk>\n       \\<Longrightarrow> rpost arb (a, b) \\<sigma>\n 5. \\<And>f arb x a b it \\<sigma>.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; it \\<subseteq> E `` {b};\n        fe_inv (?S131 f arb (a, b) a b) (?v131 f arb (a, b) a b)\n         (?s131 f arb (a, b) a b) it \\<sigma>;\n        \\<not> (case \\<sigma> of (uu_, b) \\<Rightarrow> \\<not> b)\\<rbrakk>\n       \\<Longrightarrow> rpost arb (a, b) \\<sigma>\n 6. Collect (rpost {} ({}, v0))\n    \\<subseteq> {(V, r).\n                 r =\n                 (local.reachable \\<inter> Collect tgt \\<noteq> {}) \\<and>\n                 (\\<not> r \\<longrightarrow> V = local.reachable)}", "apply (simp add: vc_foreach_finite)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>f arb x a b.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b\\<rbrakk>\n       \\<Longrightarrow> fe_inv (?S131 f arb (a, b) a b)\n                          (?v131 f arb (a, b) a b) (?s131 f arb (a, b) a b)\n                          (E `` {b}) (insert b a, False)\n 2. \\<And>f arb x a b xa it \\<sigma> aa ba.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; xa \\<in> it;\n        it \\<subseteq> E `` {b};\n        fe_inv (?S131 f arb (a, b) a b) (?v131 f arb (a, b) a b)\n         (?s131 f arb (a, b) a b) it (aa, False);\n        \\<not> ba; \\<sigma> = (aa, False)\\<rbrakk>\n       \\<Longrightarrow> f (aa, xa)\n                         \\<le> SPEC\n                                (fe_inv (?S131 f arb (a, b) a b)\n                                  (?v131 f arb (a, b) a b)\n                                  (?s131 f arb (a, b) a b) (it - {xa}))\n 3. \\<And>f arb x a b \\<sigma>.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b;\n        fe_inv (?S131 f arb (a, b) a b) (?v131 f arb (a, b) a b)\n         (?s131 f arb (a, b) a b) {} \\<sigma>;\n        case \\<sigma> of (uu_, b) \\<Rightarrow> \\<not> b\\<rbrakk>\n       \\<Longrightarrow> rpost arb (a, b) \\<sigma>\n 4. \\<And>f arb x a b it \\<sigma>.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; it \\<subseteq> E `` {b};\n        fe_inv (?S131 f arb (a, b) a b) (?v131 f arb (a, b) a b)\n         (?s131 f arb (a, b) a b) it \\<sigma>;\n        \\<not> (case \\<sigma> of (uu_, b) \\<Rightarrow> \\<not> b)\\<rbrakk>\n       \\<Longrightarrow> rpost arb (a, b) \\<sigma>\n 5. Collect (rpost {} ({}, v0))\n    \\<subseteq> {(V, r).\n                 r =\n                 (local.reachable \\<inter> Collect tgt \\<noteq> {}) \\<and>\n                 (\\<not> r \\<longrightarrow> V = local.reachable)}", "apply (auto intro: vc_enter_foreach) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f arb x a b xa it \\<sigma> aa ba.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; xa \\<in> it;\n        it \\<subseteq> E `` {b}; fe_inv arb a b it (aa, False); \\<not> ba;\n        \\<sigma> = (aa, False)\\<rbrakk>\n       \\<Longrightarrow> f (aa, xa) \\<le> SPEC (fe_inv arb a b (it - {xa}))\n 2. \\<And>f arb x a b \\<sigma>.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; fe_inv arb a b {} \\<sigma>;\n        case \\<sigma> of (uu_, b) \\<Rightarrow> \\<not> b\\<rbrakk>\n       \\<Longrightarrow> rpost arb (a, b) \\<sigma>\n 3. \\<And>f arb x a b it \\<sigma>.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; it \\<subseteq> E `` {b};\n        fe_inv arb a b it \\<sigma>;\n        \\<not> (case \\<sigma> of (uu_, b) \\<Rightarrow> \\<not> b)\\<rbrakk>\n       \\<Longrightarrow> rpost arb (a, b) \\<sigma>\n 4. Collect (rpost {} ({}, v0))\n    \\<subseteq> {(V, r).\n                 r =\n                 (local.reachable \\<inter> Collect tgt \\<noteq> {}) \\<and>\n                 (\\<not> r \\<longrightarrow> V = local.reachable)}", "apply (rule order_trans)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>f arb x a b xa it \\<sigma> aa ba.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; xa \\<in> it;\n        it \\<subseteq> E `` {b}; fe_inv arb a b it (aa, False); \\<not> ba;\n        \\<sigma> = (aa, False)\\<rbrakk>\n       \\<Longrightarrow> f (aa, xa)\n                         \\<le> ?y147 f arb x a b xa it \\<sigma> aa ba\n 2. \\<And>f arb x a b xa it \\<sigma> aa ba.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; xa \\<in> it;\n        it \\<subseteq> E `` {b}; fe_inv arb a b it (aa, False); \\<not> ba;\n        \\<sigma> = (aa, False)\\<rbrakk>\n       \\<Longrightarrow> ?y147 f arb x a b xa it \\<sigma> aa ba\n                         \\<le> SPEC (fe_inv arb a b (it - {xa}))\n 3. \\<And>f arb x a b \\<sigma>.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; fe_inv arb a b {} \\<sigma>;\n        case \\<sigma> of (uu_, b) \\<Rightarrow> \\<not> b\\<rbrakk>\n       \\<Longrightarrow> rpost arb (a, b) \\<sigma>\n 4. \\<And>f arb x a b it \\<sigma>.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; it \\<subseteq> E `` {b};\n        fe_inv arb a b it \\<sigma>;\n        \\<not> (case \\<sigma> of (uu_, b) \\<Rightarrow> \\<not> b)\\<rbrakk>\n       \\<Longrightarrow> rpost arb (a, b) \\<sigma>\n 5. Collect (rpost {} ({}, v0))\n    \\<subseteq> {(V, r).\n                 r =\n                 (local.reachable \\<inter> Collect tgt \\<noteq> {}) \\<and>\n                 (\\<not> r \\<longrightarrow> V = local.reachable)}", "apply (rprems)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>f arb x a b xa it \\<sigma> aa ba.\n       \\<lbrakk>rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; xa \\<in> it;\n        it \\<subseteq> E `` {b}; fe_inv arb a b it (aa, False); \\<not> ba;\n        \\<sigma> = (aa, False)\\<rbrakk>\n       \\<Longrightarrow> rpre (?arb'305 f arb x a b xa it \\<sigma> aa ba)\n                          (aa, xa)\n 2. \\<And>f arb x a b xa it \\<sigma> aa ba.\n       \\<lbrakk>rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; xa \\<in> it;\n        it \\<subseteq> E `` {b}; fe_inv arb a b it (aa, False); \\<not> ba;\n        \\<sigma> = (aa, False)\\<rbrakk>\n       \\<Longrightarrow> ((aa, xa), a, b)\n                         \\<in> finite_psupset local.reachable <*lex*> {}\n 3. \\<And>f arb x a b xa it \\<sigma> aa ba.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; xa \\<in> it;\n        it \\<subseteq> E `` {b}; fe_inv arb a b it (aa, False); \\<not> ba;\n        \\<sigma> = (aa, False)\\<rbrakk>\n       \\<Longrightarrow> SPEC\n                          (rpost (?arb'305 f arb x a b xa it \\<sigma> aa ba)\n                            (aa, xa))\n                         \\<le> SPEC (fe_inv arb a b (it - {xa}))\n 4. \\<And>f arb x a b \\<sigma>.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; fe_inv arb a b {} \\<sigma>;\n        case \\<sigma> of (uu_, b) \\<Rightarrow> \\<not> b\\<rbrakk>\n       \\<Longrightarrow> rpost arb (a, b) \\<sigma>\n 5. \\<And>f arb x a b it \\<sigma>.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; it \\<subseteq> E `` {b};\n        fe_inv arb a b it \\<sigma>;\n        \\<not> (case \\<sigma> of (uu_, b) \\<Rightarrow> \\<not> b)\\<rbrakk>\n       \\<Longrightarrow> rpost arb (a, b) \\<sigma>\n 6. Collect (rpost {} ({}, v0))\n    \\<subseteq> {(V, r).\n                 r =\n                 (local.reachable \\<inter> Collect tgt \\<noteq> {}) \\<and>\n                 (\\<not> r \\<longrightarrow> V = local.reachable)}", "apply (erule (5) vc_rec_pre)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>f arb x a b xa it \\<sigma> aa ba.\n       \\<lbrakk>rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; xa \\<in> it;\n        it \\<subseteq> E `` {b}; fe_inv arb a b it (aa, False); \\<not> ba;\n        \\<sigma> = (aa, False)\\<rbrakk>\n       \\<Longrightarrow> ((aa, xa), a, b)\n                         \\<in> finite_psupset local.reachable <*lex*> {}\n 2. \\<And>f arb x a b xa it \\<sigma> aa ba.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; xa \\<in> it;\n        it \\<subseteq> E `` {b}; fe_inv arb a b it (aa, False); \\<not> ba;\n        \\<sigma> = (aa, False)\\<rbrakk>\n       \\<Longrightarrow> SPEC (rpost (insert b arb) (aa, xa))\n                         \\<le> SPEC (fe_inv arb a b (it - {xa}))\n 3. \\<And>f arb x a b \\<sigma>.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; fe_inv arb a b {} \\<sigma>;\n        case \\<sigma> of (uu_, b) \\<Rightarrow> \\<not> b\\<rbrakk>\n       \\<Longrightarrow> rpost arb (a, b) \\<sigma>\n 4. \\<And>f arb x a b it \\<sigma>.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; it \\<subseteq> E `` {b};\n        fe_inv arb a b it \\<sigma>;\n        \\<not> (case \\<sigma> of (uu_, b) \\<Rightarrow> \\<not> b)\\<rbrakk>\n       \\<Longrightarrow> rpost arb (a, b) \\<sigma>\n 5. Collect (rpost {} ({}, v0))\n    \\<subseteq> {(V, r).\n                 r =\n                 (local.reachable \\<inter> Collect tgt \\<noteq> {}) \\<and>\n                 (\\<not> r \\<longrightarrow> V = local.reachable)}", "apply (auto simp add: fe_inv_def finite_psupset_def) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f arb x a b xa it \\<sigma> aa ba.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; xa \\<in> it;\n        it \\<subseteq> E `` {b}; fe_inv arb a b it (aa, False); \\<not> ba;\n        \\<sigma> = (aa, False)\\<rbrakk>\n       \\<Longrightarrow> SPEC (rpost (insert b arb) (aa, xa))\n                         \\<le> SPEC (fe_inv arb a b (it - {xa}))\n 2. \\<And>f arb x a b \\<sigma>.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; fe_inv arb a b {} \\<sigma>;\n        case \\<sigma> of (uu_, b) \\<Rightarrow> \\<not> b\\<rbrakk>\n       \\<Longrightarrow> rpost arb (a, b) \\<sigma>\n 3. \\<And>f arb x a b it \\<sigma>.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; it \\<subseteq> E `` {b};\n        fe_inv arb a b it \\<sigma>;\n        \\<not> (case \\<sigma> of (uu_, b) \\<Rightarrow> \\<not> b)\\<rbrakk>\n       \\<Longrightarrow> rpost arb (a, b) \\<sigma>\n 4. Collect (rpost {} ({}, v0))\n    \\<subseteq> {(V, r).\n                 r =\n                 (local.reachable \\<inter> Collect tgt \\<noteq> {}) \\<and>\n                 (\\<not> r \\<longrightarrow> V = local.reachable)}", "apply (refine_rcg refine_vcg)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f arb x a b xa it \\<sigma> aa ba xb.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; xa \\<in> it;\n        it \\<subseteq> E `` {b}; fe_inv arb a b it (aa, False); \\<not> ba;\n        \\<sigma> = (aa, False); rpost (insert b arb) (aa, xa) xb\\<rbrakk>\n       \\<Longrightarrow> fe_inv arb a b (it - {xa}) xb\n 2. \\<And>f arb x a b \\<sigma>.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; fe_inv arb a b {} \\<sigma>;\n        case \\<sigma> of (uu_, b) \\<Rightarrow> \\<not> b\\<rbrakk>\n       \\<Longrightarrow> rpost arb (a, b) \\<sigma>\n 3. \\<And>f arb x a b it \\<sigma>.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; it \\<subseteq> E `` {b};\n        fe_inv arb a b it \\<sigma>;\n        \\<not> (case \\<sigma> of (uu_, b) \\<Rightarrow> \\<not> b)\\<rbrakk>\n       \\<Longrightarrow> rpost arb (a, b) \\<sigma>\n 4. Collect (rpost {} ({}, v0))\n    \\<subseteq> {(V, r).\n                 r =\n                 (local.reachable \\<inter> Collect tgt \\<noteq> {}) \\<and>\n                 (\\<not> r \\<longrightarrow> V = local.reachable)}", "apply (simp add: vc_iterate_foreach)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f arb x a b \\<sigma>.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; fe_inv arb a b {} \\<sigma>;\n        case \\<sigma> of (uu_, b) \\<Rightarrow> \\<not> b\\<rbrakk>\n       \\<Longrightarrow> rpost arb (a, b) \\<sigma>\n 2. \\<And>f arb x a b it \\<sigma>.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; it \\<subseteq> E `` {b};\n        fe_inv arb a b it \\<sigma>;\n        \\<not> (case \\<sigma> of (uu_, b) \\<Rightarrow> \\<not> b)\\<rbrakk>\n       \\<Longrightarrow> rpost arb (a, b) \\<sigma>\n 3. Collect (rpost {} ({}, v0))\n    \\<subseteq> {(V, r).\n                 r =\n                 (local.reachable \\<inter> Collect tgt \\<noteq> {}) \\<and>\n                 (\\<not> r \\<longrightarrow> V = local.reachable)}", "apply (auto simp add: vc_foreach_completed_imp_post) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f arb x a b it \\<sigma>.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', a, b)\n                    \\<in> finite_psupset local.reachable <*lex*> {}\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb (a, b);\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v \\<in> V then RETURN (V, False)\n             else let V = insert v V\n                  in if tgt v then RETURN (V, True)\n                     else FOREACH\\<^sub>C (E `` {v})\n                           (\\<lambda>(uu_, b). \\<not> b)\n                           (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False)) =\n        f;\n        x = (a, b); b \\<notin> a; \\<not> tgt b; it \\<subseteq> E `` {b};\n        fe_inv arb a b it \\<sigma>;\n        \\<not> (case \\<sigma> of (uu_, b) \\<Rightarrow> \\<not> b)\\<rbrakk>\n       \\<Longrightarrow> rpost arb (a, b) \\<sigma>\n 2. Collect (rpost {} ({}, v0))\n    \\<subseteq> {(V, r).\n                 r =\n                 (local.reachable \\<inter> Collect tgt \\<noteq> {}) \\<and>\n                 (\\<not> r \\<longrightarrow> V = local.reachable)}", "apply (auto simp add: vc_foreach_interrupted_imp_post) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect (rpost {} ({}, v0))\n    \\<subseteq> {(V, r).\n                 r =\n                 (local.reachable \\<inter> Collect tgt \\<noteq> {}) \\<and>\n                 (\\<not> r \\<longrightarrow> V = local.reachable)}", "apply (auto dest: vc_rpost_imp_spec) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  local.dfs \\<le> local.dfs_spec\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma dfs_correct': \"(uncurry2 dfs, uncurry2 dfs_spec) \n  \\<in> [\\<lambda>((E,s),t). finite (reachable E s)]\\<^sub>f ((Id\\<times>\\<^sub>rId)\\<times>\\<^sub>rId) \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 dfs, uncurry2 dfs_spec)\n    \\<in> [\\<lambda>((E, s), t).\n              finite\n               (reachable E\n                 s)]\\<^sub>f (Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r\n                             Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel", "apply (intro frefI nres_relI; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa bb bc.\n       finite (reachable aa bb) \\<Longrightarrow>\n       dfs aa bb bc \\<le> dfs_spec aa bb bc", "by (rule dfs_correct)"], ["", "subsection \\<open>Refinement to Imperative/HOL\\<close>"], ["", "text \\<open>We set up a schematic proof goal,\n  and use the sepref-tool to synthesize the implementation.\n\\<close>"], ["", "sepref_definition dfs_impl is \n  \"uncurry2 dfs\" :: \"(adjg_assn nat_assn)\\<^sup>k*\\<^sub>anat_assn\\<^sup>k*\\<^sub>a(pure (nat_rel \\<rightarrow> bool_rel))\\<^sup>k \\<rightarrow>\\<^sub>a prod_assn (ias.assn nat_assn) bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 dfs)\n    \\<in> (adjg_assn nat_assn)\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          (pure\n            (nat_rel \\<rightarrow>\n             bool_rel))\\<^sup>k \\<rightarrow>\\<^sub>a ias.assn\n                 nat_assn \\<times>\\<^sub>a\n                bool_assn", "unfolding dfs_def[abs_def] \\<comment> \\<open>Unfold definition of DFS\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>E v0 tgt.\n          REC\\<^sub>T\n           (\\<lambda>dfs (V, v).\n               if v \\<in> V then RETURN (V, False)\n               else let V = insert v V\n                    in if tgt v then RETURN (V, True)\n                       else FOREACH\\<^sub>C (E `` {v})\n                             (\\<lambda>(uu_, b). \\<not> b)\n                             (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False))\n           ({}, v0) \\<bind>\n          (\\<lambda>(V, r). RETURN (V, r))))\n    \\<in> (adjg_assn nat_assn)\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          (pure\n            (nat_rel \\<rightarrow>\n             bool_rel))\\<^sup>k \\<rightarrow>\\<^sub>a ias.assn\n                 nat_assn \\<times>\\<^sub>a\n                bool_assn", "using [[goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>E v0 tgt.\n          REC\\<^sub>T\n           (\\<lambda>dfs (V, v).\n               if v \\<in> V then RETURN (V, False)\n               else let V = insert v V\n                    in if tgt v then RETURN (V, True)\n                       else FOREACH\\<^sub>C (E `` {v})\n                             (\\<lambda>(uu_, b). \\<not> b)\n                             (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False))\n           ({}, v0) \\<bind>\n          (\\<lambda>(V, r). RETURN (V, r))))\n    \\<in> (adjg_assn nat_assn)\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          (pure\n            (nat_rel \\<rightarrow>\n             bool_rel))\\<^sup>k \\<rightarrow>\\<^sub>a ias.assn\n                 nat_assn \\<times>\\<^sub>a\n                bool_assn", "apply (rewrite in \"RECT _ (\\<hole>,_)\" ias.fold_custom_empty) \\<comment> \\<open>Select impls\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>E v0 tgt.\n          REC\\<^sub>T\n           (\\<lambda>dfs (V, v).\n               if v \\<in> V then RETURN (V, False)\n               else let V = insert v V\n                    in if tgt v then RETURN (V, True)\n                       else FOREACH\\<^sub>C (E `` {v})\n                             (\\<lambda>(uu_, b). \\<not> b)\n                             (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False))\n           (op_ias_empty, v0) \\<bind>\n          (\\<lambda>(V, r). RETURN (V, r))))\n    \\<in> (adjg_assn nat_assn)\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          (pure\n            (nat_rel \\<rightarrow>\n             bool_rel))\\<^sup>k \\<rightarrow>\\<^sub>a ias.assn\n                 nat_assn \\<times>\\<^sub>a\n                bool_assn", "apply (rewrite in \"if \\<hole> then RETURN (_,True) else _\" fold_pho_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>E v0 tgt.\n          REC\\<^sub>T\n           (\\<lambda>dfs (V, v).\n               if v \\<in> V then RETURN (V, False)\n               else let V = insert v V\n                    in if pho_apply tgt v then RETURN (V, True)\n                       else FOREACH\\<^sub>C (E `` {v})\n                             (\\<lambda>(uu_, b). \\<not> b)\n                             (\\<lambda>v' (V, uu_). dfs (V, v')) (V, False))\n           (op_ias_empty, v0) \\<bind>\n          (\\<lambda>(V, r). RETURN (V, r))))\n    \\<in> (adjg_assn nat_assn)\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          (pure\n            (nat_rel \\<rightarrow>\n             bool_rel))\\<^sup>k \\<rightarrow>\\<^sub>a ias.assn\n                 nat_assn \\<times>\\<^sub>a\n                bool_assn", "apply sepref \\<comment> \\<open>Invoke sepref-tool\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "export_code dfs_impl checking SML_imp\n  \\<comment> \\<open>Generate SML code with Imperative/HOL\\<close>"], ["", "export_code dfs_impl in Haskell module_name DFS"], ["", "text \\<open>Finally, correctness is shown by combining the \n  generated refinement theorem with the abstract correctness theorem.\\<close>"], ["", "lemmas dfs_impl_correct' = dfs_impl.refine[FCOMP dfs_correct']"], ["", "corollary dfs_impl_correct:\n  \"finite (reachable E s) \\<Longrightarrow> \n  <adjg_assn nat_assn E Ei> \n    dfs_impl Ei s tgt\n  < \\<lambda>(Vi,r). \\<exists>\\<^sub>AV. adjg_assn nat_assn E Ei * ias.assn nat_assn V Vi * \\<up>((r \\<longleftrightarrow> reachable E s \\<inter> Collect tgt \\<noteq> {}) \\<and> (\\<not>r \\<longrightarrow> V=reachable E s) ) >\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (reachable E s) \\<Longrightarrow>\n    <adjg_assn nat_assn E\n      Ei> dfs_impl Ei s\n           tgt <\\<lambda>r.\n                   case r of\n                   (Vi, r) \\<Rightarrow>\n                     \\<exists>\\<^sub>AV.\n                        adjg_assn nat_assn E Ei * ias.assn nat_assn V Vi *\n                        \\<up>\n                         (r =\n                          (reachable E s \\<inter> Collect tgt \\<noteq>\n                           {}) \\<and>\n                          (\\<not> r \\<longrightarrow>\n                           V = reachable E s))>\\<^sub>t", "using dfs_impl_correct'[THEN hfrefD, THEN hn_refineD, of \"((E,s),tgt)\" \"((Ei,s),tgt)\", simplified]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (reachable E s); nofail (dfs_spec E s tgt)\\<rbrakk>\n  \\<Longrightarrow> <adjg_assn nat_assn E Ei * nat_assn s s *\n                     id_assn tgt tgt>\n                    dfs_impl Ei s tgt\n                    <\\<lambda>r.\n                        \\<exists>\\<^sub>Ax.\n                           adjg_assn nat_assn E Ei * nat_assn s s *\n                           id_assn tgt tgt *\n                           (ias.assn nat_assn \\<times>\\<^sub>a bool_assn) x\n                            r *\n                           true *\n                           \\<up> (RETURN x \\<le> dfs_spec E s tgt)>\n\ngoal (1 subgoal):\n 1. finite (reachable E s) \\<Longrightarrow>\n    <adjg_assn nat_assn E\n      Ei> dfs_impl Ei s\n           tgt <\\<lambda>r.\n                   case r of\n                   (Vi, r) \\<Rightarrow>\n                     \\<exists>\\<^sub>AV.\n                        adjg_assn nat_assn E Ei * ias.assn nat_assn V Vi *\n                        \\<up>\n                         (r =\n                          (reachable E s \\<inter> Collect tgt \\<noteq>\n                           {}) \\<and>\n                          (\\<not> r \\<longrightarrow>\n                           V = reachable E s))>\\<^sub>t", "apply (rule cons_rule[rotated -1])"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite (reachable E s) \\<Longrightarrow> finite (reachable E s)\n 2. finite (reachable E s) \\<Longrightarrow> nofail (dfs_spec E s tgt)\n 3. finite (reachable E s) \\<Longrightarrow>\n    adjg_assn nat_assn E Ei \\<Longrightarrow>\\<^sub>A\n    adjg_assn nat_assn E Ei * nat_assn s s * id_assn tgt tgt\n 4. \\<And>x.\n       finite (reachable E s) \\<Longrightarrow>\n       \\<exists>\\<^sub>Axa.\n          adjg_assn nat_assn E Ei * nat_assn s s * id_assn tgt tgt *\n          (ias.assn nat_assn \\<times>\\<^sub>a bool_assn) xa x *\n          true *\n          \\<up> (RETURN xa \\<le> dfs_spec E s tgt) \\<Longrightarrow>\\<^sub>A\n       (case x of\n        (Vi, r) \\<Rightarrow>\n          \\<exists>\\<^sub>AV.\n             adjg_assn nat_assn E Ei * ias.assn nat_assn V Vi *\n             \\<up>\n              (r = (reachable E s \\<inter> Collect tgt \\<noteq> {}) \\<and>\n               (\\<not> r \\<longrightarrow> V = reachable E s))) *\n       true", "apply (sep_auto intro!: ent_ex_preI simp: dfs_spec_def pure_def)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}