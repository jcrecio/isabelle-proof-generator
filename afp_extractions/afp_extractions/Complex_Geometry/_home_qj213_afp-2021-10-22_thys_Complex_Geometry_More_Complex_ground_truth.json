{"file_name": "/home/qj213/afp-2021-10-22/thys/Complex_Geometry/More_Complex.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Complex_Geometry", "problem_names": ["lemma rcis_cnj: \n  shows \"cnj a = rcis (cmod a) (- arg a)\"", "lemmas complex_cnj = complex_cnj_diff complex_cnj_mult complex_cnj_add complex_cnj_divide complex_cnj_minus", "lemma cor_neg_one [simp]:\n  shows \"cor (-1) = -1\"", "lemma neg_cor_neg_one [simp]:\n  shows \"- cor (-1) = 1\"", "lemma cmod_cis [simp]:\n  assumes \"a \\<noteq> 0\"\n  shows \"cor (cmod a) * cis (arg a) = a\"", "lemma cis_cmod [simp]:\n  assumes \"a \\<noteq> 0\"\n  shows \"cis (arg a) * cor (cmod a) = a\"", "lemma cor_add:\n  shows \"cor (a + b) = cor a + cor b\"", "lemma cor_mult:\n  shows \"cor (a * b) = cor a * cor b\"", "lemma cor_squared:\n  shows \"(cor x)\\<^sup>2 = cor (x\\<^sup>2)\"", "lemma cor_sqrt_mult_cor_sqrt [simp]:\n  shows \"cor (sqrt A) * cor (sqrt A) = cor \\<bar>A\\<bar>\"", "lemma cor_eq_0: \"cor x + \\<i> * cor y = 0 \\<longleftrightarrow> x = 0 \\<and> y = 0\"", "lemma one_plus_square_neq_zero [simp]:\n  shows \"1 + (cor x)\\<^sup>2 \\<noteq> 0\"", "lemma complex_real_two [simp]:\n  shows \"Complex 2 0 = 2\"", "lemma complex_double [simp]:\n  shows \"(Complex a b) * 2 = Complex (2*a) (2*b)\"", "lemma complex_half [simp]: \n  shows \"(Complex a b) / 2 = Complex (a/2) (b/2)\"", "lemma Complex_scale1:\n  shows \"Complex (a * b) (a * c) = cor a * Complex b c\"", "lemma Complex_scale2: \n  shows \"Complex (a * c) (b * c) = Complex a b * cor c\"", "lemma Complex_scale3: \n  shows \"Complex (a / b) (a / c) = cor a * Complex (1 / b) (1 / c)\"", "lemma Complex_scale4:\n  shows \"c \\<noteq> 0 \\<Longrightarrow> Complex (a / c) (b / c) = Complex a b / cor c\"", "lemma Complex_Re_express_cnj:\n  shows \"Complex (Re z) 0 = (z + cnj z) / 2\"", "lemma Complex_Im_express_cnj:\n  shows \"Complex 0 (Im z) = (z - cnj z)/2\"", "lemma complex_mult_cnj_cmod:\n  shows \"z * cnj z = cor ((cmod z)\\<^sup>2)\"", "lemma cmod_square: \n  shows \"(cmod z)\\<^sup>2 = Re (z * cnj z)\"", "lemma cor_cmod_power_4 [simp]:\n  shows \"cor (cmod z) ^ 4 = (z * cnj z)\\<^sup>2\"", "lemma cnjE:\n  assumes \"x \\<noteq> 0\"\n  shows \"cnj x = cor ((cmod x)\\<^sup>2) / x\"", "lemma cmod_mult [simp]:\n  shows \"cmod (a * b) = cmod a * cmod b\"", "lemma cmod_divide [simp]:\n  shows \"cmod (a / b) = cmod a / cmod b\"", "lemma cmod_cor_divide [simp]:\n  shows \"cmod (z / cor k) = cmod z / \\<bar>k\\<bar>\"", "lemma cmod_mult_minus_left_distrib [simp]:\n  shows \"cmod (z*z1 - z*z2) = cmod z * cmod(z1 - z2)\"", "lemma cmod_eqI:\n  assumes \"z1 * cnj z1 = z2 * cnj z2\"\n  shows \"cmod z1 = cmod z2\"", "lemma cmod_eqE:\n  assumes \"cmod z1 = cmod z2\"\n  shows \"z1 * cnj z1 = z2 * cnj z2\"", "lemma cmod_eq_one [simp]:\n  shows \"cmod a = 1 \\<longleftrightarrow> a*cnj a = 1\"", "lemma real_imag_0:\n  assumes \"is_real a\" \"is_imag a\" \n  shows \"a = 0\"", "lemma complex_eq_if_Re_eq:\n  assumes \"is_real z1\" and \"is_real z2\"\n  shows \"z1 = z2 \\<longleftrightarrow> Re z1 = Re z2\"", "lemma mult_reals [simp]:\n  assumes \"is_real a\" and \"is_real b\"\n  shows \"is_real (a * b)\"", "lemma div_reals [simp]:\n  assumes \"is_real a\" and \"is_real b\"\n  shows \"is_real (a / b)\"", "lemma complex_of_real_Re [simp]:\n  assumes \"is_real k\"\n  shows \"cor (Re k) = k\"", "lemma cor_cmod_real:\n  assumes \"is_real a\"\n  shows \"cor (cmod a) = a \\<or> cor (cmod a) = -a\"", "lemma eq_cnj_iff_real:\n  shows \"cnj z = z \\<longleftrightarrow> is_real z\"", "lemma eq_minus_cnj_iff_imag:\n  shows \"cnj z = -z \\<longleftrightarrow> is_imag z\"", "lemma Re_divide_real:\n  assumes \"is_real b\" and \"b \\<noteq> 0\"\n  shows \"Re (a / b) = (Re a) / (Re b)\"", "lemma Re_mult_real:\n  assumes \"is_real a\"\n  shows \"Re (a * b) = (Re a) * (Re b)\"", "lemma Im_mult_real:\n  assumes \"is_real a\"\n  shows \"Im (a * b) = (Re a) * (Im b)\"", "lemma Im_divide_real:\n  assumes \"is_real b\" and \"b \\<noteq> 0\"\n  shows \"Im (a / b) = (Im a) / (Re b)\"", "lemma Re_half [simp]:\n  shows \"Re (x / 2) = Re x / 2\"", "lemma Re_double [simp]:\n  shows \"Re (2 * x) = 2 * Re x\"", "lemma Im_half [simp]:\n  shows \"Im (z / 2) = Im z / 2\"", "lemma Im_double [simp]:\n  shows \"Im (2 * z) = 2 * Im z\"", "lemma Re_sgn:\n  assumes \"is_real R\"\n  shows \"Re (sgn R) = sgn (Re R)\"", "lemma is_real_div:\n  assumes \"b \\<noteq> 0\"\n  shows \"is_real (a / b) \\<longleftrightarrow> a*cnj b = b*cnj a\"", "lemma is_real_mult_real:\n  assumes \"is_real a\" and \"a \\<noteq> 0\"\n  shows \"is_real b \\<longleftrightarrow> is_real (a * b)\"", "lemma Im_express_cnj:\n  shows \"Im z = (z - cnj z) / (2 * \\<i>)\"", "lemma Re_express_cnj: \n  shows \"Re z = (z + cnj z) / 2\"", "lemma rot90_ii: \n  shows \"rot90 z = z * \\<i>\"", "lemma cnj_mix_minus:\n  shows \"cnj z1*z2 - z1*cnj z2 = \\<i> * cnj_mix (rot90 z1) z2\"", "lemma cnj_mix_minus':\n  shows \"cnj z1*z2 - z1*cnj z2 = rot90 (cnj_mix (rot90 z1) z2)\"", "lemma cnj_mix_real [simp]:\n  shows \"is_real (cnj_mix z1 z2)\"", "lemma scalprod_real [simp]:\n  shows \"is_real (scalprod z1 z2)\"", "lemma cis_minus_pi2 [simp]:\n  shows \"cis (-pi/2) = -\\<i>\"", "lemma cis_pi2_minus_x [simp]:\n  shows \"cis (pi/2 - x) = \\<i> * cis(-x)\"", "lemma cis_pm_pi [simp]: \n  shows \"cis (x - pi) = - cis x\" and  \"cis (x + pi) = - cis x\"", "lemma cis_times_cis_opposite [simp]: \n  shows \"cis \\<phi> * cis (- \\<phi>) = 1\"", "lemma cis_eq:\n  assumes \"cis a = cis b\"\n  shows \"\\<exists> k::int. a - b = 2 * k * pi\"", "lemma cis_inj:\n  assumes \"-pi < \\<alpha>\" and \"\\<alpha> \\<le> pi\" and \"-pi < \\<alpha>'\" and \"\\<alpha>' \\<le> pi\"\n  assumes \"cis \\<alpha> = cis \\<alpha>'\"\n  shows \"\\<alpha> = \\<alpha>'\"", "lemma cis_diff_cis_opposite [simp]: \n  shows \"cis \\<phi> - cis (- \\<phi>) = 2 * \\<i> * sin \\<phi>\"", "lemma cis_opposite_diff_cis [simp]:\n  shows \"cis (-\\<phi>) - cis (\\<phi>) = - 2 * \\<i> * sin \\<phi>\"", "lemma cis_add_cis_opposite [simp]: \n  shows \"cis \\<phi> + cis (-\\<phi>) = 2 * cos \\<phi>\"", "lemma cis_one [simp]:\n  assumes \"sin \\<phi> = 0\" and \"cos \\<phi> = 1\"\n  shows \"cis \\<phi> = 1\"", "lemma cis_minus_one [simp]:\n  assumes \"sin \\<phi> = 0\" and \"cos \\<phi> = -1\"\n  shows \"cis \\<phi> = -1\"", "lemma is_real_arg1:\n  assumes \"arg z = 0 \\<or> arg z = pi\"\n  shows \"is_real z\"", "lemma is_real_arg2:\n  assumes \"is_real z\"\n  shows \"arg z = 0 \\<or> arg z = pi\"", "lemma arg_complex_of_real_positive [simp]:\n  assumes \"k > 0\"\n  shows \"arg (cor k) = 0\"", "lemma arg_complex_of_real_negative [simp]:\n  assumes \"k < 0\"\n  shows \"arg (cor k) = pi\"", "lemma arg_0_iff:\n  shows \"z \\<noteq> 0 \\<and> arg z = 0 \\<longleftrightarrow> is_real z \\<and> Re z > 0\"", "lemma arg_pi_iff:\n  shows \"arg z = pi \\<longleftrightarrow> is_real z \\<and> Re z < 0\"", "lemma is_imag_arg1:\n  assumes \"arg z = pi/2 \\<or> arg z = -pi/2\"\n  shows \"is_imag z\"", "lemma is_imag_arg2:\n  assumes \"is_imag z\" and \"z \\<noteq> 0\"\n  shows \"arg z = pi/2 \\<or> arg z = -pi/2\"", "lemma arg_complex_of_real_times_i_positive [simp]:\n  assumes \"k > 0\"\n  shows \"arg (cor k * \\<i>) = pi / 2\"", "lemma arg_complex_of_real_times_i_negative [simp]:\n  assumes \"k < 0\"\n  shows \"arg (cor k * \\<i>) = - pi / 2\"", "lemma arg_pi2_iff:\n  shows \"z \\<noteq> 0 \\<and> arg z = pi / 2 \\<longleftrightarrow> is_imag z \\<and> Im z > 0\"", "lemma arg_minus_pi2_iff:\n  shows \"z \\<noteq> 0 \\<and> arg z = - pi / 2 \\<longleftrightarrow> is_imag z \\<and> Im z < 0\"", "lemma arg_ii [simp]:\n  shows \"arg \\<i> = pi/2\"", "lemma arg_minus_ii [simp]: \n  shows \"arg (-\\<i>) = -pi/2\"", "lemma canon_ang_arg:\n  shows \"\\<downharpoonright>arg z\\<downharpoonleft> = arg z\"", "lemma arg_cis:\n  shows \"arg (cis \\<phi>) = \\<downharpoonright>\\<phi>\\<downharpoonleft>\"", "lemma cos_arg:\n  assumes \"z \\<noteq> 0\"\n  shows \"cos (arg z) = Re z / cmod z\"", "lemma sin_arg:\n  assumes \"z \\<noteq> 0\"\n  shows \"sin (arg z) = Im z / cmod z\"", "lemma cis_arg_mult:\n  assumes \"z1 * z2 \\<noteq> 0\"\n  shows \"cis (arg (z1 * z2)) = cis (arg z1 + arg z2)\"", "lemma arg_mult_2kpi:\n  assumes \"z1 * z2 \\<noteq> 0\"\n  shows \"\\<exists> k::int. arg (z1 * z2) = arg z1 + arg z2 + 2*k*pi\"", "lemma arg_mult:\n  assumes \"z1 * z2 \\<noteq> 0\"\n  shows \"arg(z1 * z2) = \\<downharpoonright>arg z1 + arg z2\\<downharpoonleft>\"", "lemma arg_mult_real_positive [simp]:\n  assumes \"k > 0\"\n  shows \"arg (cor k * z) = arg z\"", "lemma arg_mult_real_negative [simp]:\n  assumes \"k < 0\"\n  shows \"arg (cor k * z) = arg (-z)\"", "lemma arg_div_real_positive [simp]:\n  assumes \"k > 0\"\n  shows \"arg (z / cor k) = arg z\"", "lemma arg_div_real_negative [simp]:\n  assumes \"k < 0\"\n  shows \"arg (z / cor k) = arg (-z)\"", "lemma arg_mult_eq:\n  assumes \"z * z1 \\<noteq> 0\" and \"z * z2 \\<noteq> 0\"\n  assumes \"arg (z * z1) = arg (z * z2)\"\n  shows \"arg z1 = arg z2\"", "lemma arg_cnj_pi:\n  assumes \"arg z = pi\"\n  shows \"arg (cnj z) = pi\"", "lemma arg_cnj_not_pi:\n  assumes \"arg z \\<noteq> pi\"\n  shows \"arg (cnj z) = -arg z\"", "lemma arg_inv_not_pi:\n  assumes \"z \\<noteq> 0\" and \"arg z \\<noteq> pi\"\n  shows \"arg (1 / z) = - arg z\"", "lemma arg_inv_pi:\n  assumes \"z \\<noteq> 0\" and \"arg z = pi\"\n  shows \"arg (1 / z) = pi\"", "lemma arg_inv_2kpi:\n  assumes \"z \\<noteq> 0\"\n  shows \"\\<exists> k::int. arg (1 / z) = - arg z + 2*k*pi\"", "lemma arg_inv:\n  assumes \"z \\<noteq> 0\"\n  shows \"arg (1 / z) = \\<downharpoonright>- arg z\\<downharpoonleft>\"", "lemma arg_div_2kpi:\n  assumes \"z1 \\<noteq> 0\" and \"z2 \\<noteq> 0\"\n  shows \"\\<exists> k::int. arg (z1 / z2) = arg z1 - arg z2 + 2*k*pi\"", "lemma arg_div:\n  assumes \"z1 \\<noteq> 0\" and \"z2 \\<noteq> 0\"\n  shows \"arg(z1 / z2) = \\<downharpoonright>arg z1 - arg z2\\<downharpoonleft>\"", "lemma arg_uminus:\n  assumes \"z \\<noteq> 0\"\n  shows \"arg (-z) = \\<downharpoonright>arg z + pi\\<downharpoonleft>\"", "lemma arg_uminus_opposite_sign:\n  assumes \"z \\<noteq> 0\"\n  shows \"arg z > 0 \\<longleftrightarrow> \\<not> arg (-z) > 0\"", "lemma arg_Im_sgn:\n  assumes \"\\<not> is_real z\"\n  shows \"sgn (arg z) = sgn (Im z)\"", "lemma square_ccsqrt [simp]:\n  shows \"(ccsqrt x)\\<^sup>2 = x\"", "lemma ex_complex_sqrt:\n  shows \"\\<exists> s::complex. s*s = z\"", "lemma ccsqrt:\n  assumes \"s * s = z\"\n  shows \"s = ccsqrt z \\<or> s = -ccsqrt z\"", "lemma null_ccsqrt [simp]:\n  shows \"ccsqrt x = 0 \\<longleftrightarrow> x = 0\"", "lemma ccsqrt_mult:\n  shows \"ccsqrt (a * b) = ccsqrt a * ccsqrt b \\<or>\n         ccsqrt (a * b) = - ccsqrt a * ccsqrt b\"", "lemma csqrt_real:\n  assumes \"is_real x\"\n  shows \"(Re x \\<ge> 0 \\<and> ccsqrt x = cor (sqrt (Re x))) \\<or>\n         (Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- (Re x))))\"", "lemma is_real_rot_to_x_axis:\n  assumes \"z \\<noteq> 0\"\n  shows \"is_real (cis (-arg z) * z)\"", "lemma positive_rot_to_x_axis:\n  assumes \"z \\<noteq> 0\"\n  shows \"Re (cis (-arg z) * z) > 0\"", "lemma cmod_1_plus_mult_le:\n  shows \"cmod (1 + z*w) \\<le> sqrt((1 + (cmod z)\\<^sup>2) * (1 + (cmod w)\\<^sup>2))\"", "lemma cmod_diff_ge: \n  shows \"cmod (b - c) \\<ge> sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\"", "lemma cmod_diff_le:\n  shows \"cmod (b - c) \\<le> sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2)\"", "lemma ex_complex_to_complex [simp]:\n  fixes z1 z2 :: complex\n  assumes \"z1 \\<noteq> 0\" and \"z2 \\<noteq> 0\"\n  shows \"\\<exists>k. k \\<noteq> 0 \\<and> z2 = k * z1\"", "lemma ex_complex_to_one [simp]:\n  fixes z::complex\n  assumes \"z \\<noteq> 0\"\n  shows \"\\<exists>k. k \\<noteq> 0 \\<and> k * z = 1\"", "lemma ex_complex_to_complex2 [simp]:\n  fixes z::complex\n  shows \"\\<exists>k. k \\<noteq> 0 \\<and> k * z = z\"", "lemma complex_sqrt_1:\n  fixes z::complex\n  assumes \"z \\<noteq> 0\"\n  shows \"z = 1 / z \\<longleftrightarrow> z = 1 \\<or> z = -1\""], "translations": [["", "lemma rcis_cnj: \n  shows \"cnj a = rcis (cmod a) (- arg a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj a = rcis (cmod a) (- arg a)", "by (subst rcis_cmod_arg[of a, symmetric]) (simp add: rcis_def)"], ["", "lemmas complex_cnj = complex_cnj_diff complex_cnj_mult complex_cnj_add complex_cnj_divide complex_cnj_minus"], ["", "text \\<open>Some properties for @{term complex_of_real}. Also, since it is often used in our\nformalization we abbreviate it to @{term cor}.\\<close>"], ["", "abbreviation cor :: \"real \\<Rightarrow> complex\" where\n  \"cor \\<equiv> complex_of_real\""], ["", "lemma cor_neg_one [simp]:\n  shows \"cor (-1) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cor (- 1) = - 1", "by simp"], ["", "lemma neg_cor_neg_one [simp]:\n  shows \"- cor (-1) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - cor (- 1) = 1", "by simp"], ["", "lemma cmod_cis [simp]:\n  assumes \"a \\<noteq> 0\"\n  shows \"cor (cmod a) * cis (arg a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cor (cmod a) * cis (arg a) = a", "using assms"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cor (cmod a) * cis (arg a) = a", "by (metis rcis_cmod_arg rcis_def)"], ["", "lemma cis_cmod [simp]:\n  assumes \"a \\<noteq> 0\"\n  shows \"cis (arg a) * cor (cmod a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (arg a) * cor (cmod a) = a", "using assms cmod_cis[of a]"], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  a \\<noteq> 0 \\<Longrightarrow> cor (cmod a) * cis (arg a) = a\n\ngoal (1 subgoal):\n 1. cis (arg a) * cor (cmod a) = a", "by (simp add: field_simps)"], ["", "lemma cor_add:\n  shows \"cor (a + b) = cor a + cor b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cor (a + b) = cor a + cor b", "by (rule of_real_add)"], ["", "lemma cor_mult:\n  shows \"cor (a * b) = cor a * cor b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cor (a * b) = cor a * cor b", "by (rule of_real_mult)"], ["", "lemma cor_squared:\n  shows \"(cor x)\\<^sup>2 = cor (x\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cor x)\\<^sup>2 = cor (x\\<^sup>2)", "by (simp add: power2_eq_square)"], ["", "lemma cor_sqrt_mult_cor_sqrt [simp]:\n  shows \"cor (sqrt A) * cor (sqrt A) = cor \\<bar>A\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cor (sqrt A) * cor (sqrt A) = cor \\<bar>A\\<bar>", "by (metis cor_mult real_sqrt_abs2 real_sqrt_mult)"], ["", "lemma cor_eq_0: \"cor x + \\<i> * cor y = 0 \\<longleftrightarrow> x = 0 \\<and> y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cor x + \\<i> * cor y = 0) = (x = 0 \\<and> y = 0)", "by (metis Complex_eq Im_complex_of_real Im_i_times Re_complex_of_real add_cancel_left_left of_real_eq_0_iff plus_complex.sel(2) zero_complex.code)"], ["", "lemma one_plus_square_neq_zero [simp]:\n  shows \"1 + (cor x)\\<^sup>2 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + (cor x)\\<^sup>2 \\<noteq> 0", "by (metis (hide_lams, no_types) of_real_1 of_real_add of_real_eq_0_iff of_real_power power_one sum_power2_eq_zero_iff zero_neq_one)"], ["", "text \\<open>Additional lemmas about @{term Complex} constructor. Following newer versions of Isabelle,\nthese should be deprecated.\\<close>"], ["", "lemma complex_real_two [simp]:\n  shows \"Complex 2 0 = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex 2 0 = 2", "by (simp add: Complex_eq)"], ["", "lemma complex_double [simp]:\n  shows \"(Complex a b) * 2 = Complex (2*a) (2*b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex a b * 2 = Complex (2 * a) (2 * b)", "by (simp add: Complex_eq)"], ["", "lemma complex_half [simp]: \n  shows \"(Complex a b) / 2 = Complex (a/2) (b/2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex a b / 2 = Complex (a / 2) (b / 2)", "by (subst complex_eq_iff) auto"], ["", "lemma Complex_scale1:\n  shows \"Complex (a * b) (a * c) = cor a * Complex b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex (a * b) (a * c) = cor a * Complex b c", "unfolding complex_of_real_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex (a * b) (a * c) = Complex a 0 * Complex b c", "unfolding Complex_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. cor (a * b) + \\<i> * cor (a * c) =\n    (cor a + \\<i> * cor 0) * (cor b + \\<i> * cor c)", "by (auto simp add: field_simps)"], ["", "lemma Complex_scale2: \n  shows \"Complex (a * c) (b * c) = Complex a b * cor c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex (a * c) (b * c) = Complex a b * cor c", "unfolding complex_of_real_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex (a * c) (b * c) = Complex a b * Complex c 0", "unfolding Complex_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. cor (a * c) + \\<i> * cor (b * c) =\n    (cor a + \\<i> * cor b) * (cor c + \\<i> * cor 0)", "by (auto simp add: field_simps)"], ["", "lemma Complex_scale3: \n  shows \"Complex (a / b) (a / c) = cor a * Complex (1 / b) (1 / c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex (a / b) (a / c) = cor a * Complex (1 / b) (1 / c)", "unfolding complex_of_real_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex (a / b) (a / c) = Complex a 0 * Complex (1 / b) (1 / c)", "unfolding Complex_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. cor (a / b) + \\<i> * cor (a / c) =\n    (cor a + \\<i> * cor 0) * (cor (1 / b) + \\<i> * cor (1 / c))", "by (auto simp add: field_simps)"], ["", "lemma Complex_scale4:\n  shows \"c \\<noteq> 0 \\<Longrightarrow> Complex (a / c) (b / c) = Complex a b / cor c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    Complex (a / c) (b / c) = Complex a b / cor c", "unfolding complex_of_real_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    Complex (a / c) (b / c) = Complex a b / Complex c 0", "unfolding Complex_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> 0 \\<Longrightarrow>\n    cor (a / c) + \\<i> * cor (b / c) =\n    (cor a + \\<i> * cor b) / (cor c + \\<i> * cor 0)", "by (auto simp add: field_simps power2_eq_square)"], ["", "lemma Complex_Re_express_cnj:\n  shows \"Complex (Re z) 0 = (z + cnj z) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex (Re z) 0 = (z + cnj z) / 2", "by (cases z) (simp add: Complex_eq)"], ["", "lemma Complex_Im_express_cnj:\n  shows \"Complex 0 (Im z) = (z - cnj z)/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complex 0 (Im z) = (z - cnj z) / 2", "by (cases z) (simp add: Complex_eq)"], ["", "text \\<open>Additional properties of @{term cmod}.\\<close>"], ["", "lemma complex_mult_cnj_cmod:\n  shows \"z * cnj z = cor ((cmod z)\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * cnj z = cor ((cmod z)\\<^sup>2)", "using complex_norm_square"], ["proof (prove)\nusing this:\n  cor ((cmod ?z)\\<^sup>2) = ?z * cnj ?z\n\ngoal (1 subgoal):\n 1. z * cnj z = cor ((cmod z)\\<^sup>2)", "by auto"], ["", "lemma cmod_square: \n  shows \"(cmod z)\\<^sup>2 = Re (z * cnj z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod z)\\<^sup>2 = Re (z * cnj z)", "using complex_mult_cnj_cmod[of z]"], ["proof (prove)\nusing this:\n  z * cnj z = cor ((cmod z)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (cmod z)\\<^sup>2 = Re (z * cnj z)", "by (simp add: power2_eq_square)"], ["", "lemma cor_cmod_power_4 [simp]:\n  shows \"cor (cmod z) ^ 4 = (z * cnj z)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cor (cmod z) ^ 4 = (z * cnj z)\\<^sup>2", "by (metis complex_norm_square cor_squared numeral_times_numeral power2_eq_square semiring_norm(11) semiring_norm(13) semiring_normalization_rules(36))"], ["", "lemma cnjE:\n  assumes \"x \\<noteq> 0\"\n  shows \"cnj x = cor ((cmod x)\\<^sup>2) / x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj x = cor ((cmod x)\\<^sup>2) / x", "using complex_mult_cnj_cmod[of x] assms"], ["proof (prove)\nusing this:\n  x * cnj x = cor ((cmod x)\\<^sup>2)\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cnj x = cor ((cmod x)\\<^sup>2) / x", "by (auto simp add: field_simps)"], ["", "lemma cmod_mult [simp]:\n  shows \"cmod (a * b) = cmod a * cmod b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (a * b) = cmod a * cmod b", "by (rule norm_mult)"], ["", "lemma cmod_divide [simp]:\n  shows \"cmod (a / b) = cmod a / cmod b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (a / b) = cmod a / cmod b", "by (rule norm_divide)"], ["", "lemma cmod_cor_divide [simp]:\n  shows \"cmod (z / cor k) = cmod z / \\<bar>k\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (z / cor k) = cmod z / \\<bar>k\\<bar>", "by auto"], ["", "lemma cmod_mult_minus_left_distrib [simp]:\n  shows \"cmod (z*z1 - z*z2) = cmod z * cmod(z1 - z2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (z * z1 - z * z2) = cmod z * cmod (z1 - z2)", "by (metis bounded_bilinear.diff_right bounded_bilinear_mult cmod_mult)"], ["", "lemma cmod_eqI:\n  assumes \"z1 * cnj z1 = z2 * cnj z2\"\n  shows \"cmod z1 = cmod z2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod z1 = cmod z2", "using assms"], ["proof (prove)\nusing this:\n  z1 * cnj z1 = z2 * cnj z2\n\ngoal (1 subgoal):\n 1. cmod z1 = cmod z2", "by (subst complex_mod_sqrt_Re_mult_cnj)+ auto"], ["", "lemma cmod_eqE:\n  assumes \"cmod z1 = cmod z2\"\n  shows \"z1 * cnj z1 = z2 * cnj z2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z1 * cnj z1 = z2 * cnj z2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. z1 * cnj z1 = z2 * cnj z2", "from assms"], ["proof (chain)\npicking this:\n  cmod z1 = cmod z2", "have \"cor ((cmod z1)\\<^sup>2) = cor ((cmod z2)\\<^sup>2)\""], ["proof (prove)\nusing this:\n  cmod z1 = cmod z2\n\ngoal (1 subgoal):\n 1. cor ((cmod z1)\\<^sup>2) = cor ((cmod z2)\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  cor ((cmod z1)\\<^sup>2) = cor ((cmod z2)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. z1 * cnj z1 = z2 * cnj z2", "thus ?thesis"], ["proof (prove)\nusing this:\n  cor ((cmod z1)\\<^sup>2) = cor ((cmod z2)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. z1 * cnj z1 = z2 * cnj z2", "using complex_mult_cnj_cmod"], ["proof (prove)\nusing this:\n  cor ((cmod z1)\\<^sup>2) = cor ((cmod z2)\\<^sup>2)\n  ?z * cnj ?z = cor ((cmod ?z)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. z1 * cnj z1 = z2 * cnj z2", "by auto"], ["proof (state)\nthis:\n  z1 * cnj z1 = z2 * cnj z2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cmod_eq_one [simp]:\n  shows \"cmod a = 1 \\<longleftrightarrow> a*cnj a = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod a = 1) = (a * cnj a = 1)", "by (metis cmod_eqE cmod_eqI complex_cnj_one monoid_mult_class.mult.left_neutral norm_one)"], ["", "text \\<open>We introduce @{term is_real} (the imaginary part of complex number is zero) and @{term is_imag}\n(real part of complex number is zero) operators and prove some of their properties.\\<close>"], ["", "abbreviation is_real where\n  \"is_real z \\<equiv> Im z = 0\""], ["", "abbreviation is_imag where\n  \"is_imag z \\<equiv> Re z = 0\""], ["", "lemma real_imag_0:\n  assumes \"is_real a\" \"is_imag a\" \n  shows \"a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = 0", "using assms"], ["proof (prove)\nusing this:\n  is_real a\n  is_imag a\n\ngoal (1 subgoal):\n 1. a = 0", "by (simp add: complex.expand)"], ["", "lemma complex_eq_if_Re_eq:\n  assumes \"is_real z1\" and \"is_real z2\"\n  shows \"z1 = z2 \\<longleftrightarrow> Re z1 = Re z2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z1 = z2) = (Re z1 = Re z2)", "using assms"], ["proof (prove)\nusing this:\n  is_real z1\n  is_real z2\n\ngoal (1 subgoal):\n 1. (z1 = z2) = (Re z1 = Re z2)", "by (cases z1, cases z2) auto"], ["", "lemma mult_reals [simp]:\n  assumes \"is_real a\" and \"is_real b\"\n  shows \"is_real (a * b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real (a * b)", "using assms"], ["proof (prove)\nusing this:\n  is_real a\n  is_real b\n\ngoal (1 subgoal):\n 1. is_real (a * b)", "by auto"], ["", "lemma div_reals [simp]:\n  assumes \"is_real a\" and \"is_real b\"\n  shows \"is_real (a / b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real (a / b)", "using assms"], ["proof (prove)\nusing this:\n  is_real a\n  is_real b\n\ngoal (1 subgoal):\n 1. is_real (a / b)", "by (simp add: complex_is_Real_iff)"], ["", "lemma complex_of_real_Re [simp]:\n  assumes \"is_real k\"\n  shows \"cor (Re k) = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cor (Re k) = k", "using assms"], ["proof (prove)\nusing this:\n  is_real k\n\ngoal (1 subgoal):\n 1. cor (Re k) = k", "by (cases k) (auto simp add: complex_of_real_def)"], ["", "lemma cor_cmod_real:\n  assumes \"is_real a\"\n  shows \"cor (cmod a) = a \\<or> cor (cmod a) = -a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cor (cmod a) = a \\<or> cor (cmod a) = - a", "using assms"], ["proof (prove)\nusing this:\n  is_real a\n\ngoal (1 subgoal):\n 1. cor (cmod a) = a \\<or> cor (cmod a) = - a", "unfolding cmod_def"], ["proof (prove)\nusing this:\n  is_real a\n\ngoal (1 subgoal):\n 1. cor (sqrt ((Re a)\\<^sup>2 + (Im a)\\<^sup>2)) = a \\<or>\n    cor (sqrt ((Re a)\\<^sup>2 + (Im a)\\<^sup>2)) = - a", "by (cases \"Re a > 0\") auto"], ["", "lemma eq_cnj_iff_real:\n  shows \"cnj z = z \\<longleftrightarrow> is_real z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cnj z = z) = is_real z", "by (cases z) (simp add: Complex_eq)"], ["", "lemma eq_minus_cnj_iff_imag:\n  shows \"cnj z = -z \\<longleftrightarrow> is_imag z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cnj z = - z) = is_imag z", "by (cases z) (simp add: Complex_eq)"], ["", "lemma Re_divide_real:\n  assumes \"is_real b\" and \"b \\<noteq> 0\"\n  shows \"Re (a / b) = (Re a) / (Re b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (a / b) = Re a / Re b", "using assms"], ["proof (prove)\nusing this:\n  is_real b\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Re (a / b) = Re a / Re b", "by (simp add: complex_is_Real_iff)"], ["", "lemma Re_mult_real:\n  assumes \"is_real a\"\n  shows \"Re (a * b) = (Re a) * (Re b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (a * b) = Re a * Re b", "using assms"], ["proof (prove)\nusing this:\n  is_real a\n\ngoal (1 subgoal):\n 1. Re (a * b) = Re a * Re b", "by simp"], ["", "lemma Im_mult_real:\n  assumes \"is_real a\"\n  shows \"Im (a * b) = (Re a) * (Im b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (a * b) = Re a * Im b", "using assms"], ["proof (prove)\nusing this:\n  is_real a\n\ngoal (1 subgoal):\n 1. Im (a * b) = Re a * Im b", "by simp"], ["", "lemma Im_divide_real:\n  assumes \"is_real b\" and \"b \\<noteq> 0\"\n  shows \"Im (a / b) = (Im a) / (Re b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (a / b) = Im a / Re b", "using assms"], ["proof (prove)\nusing this:\n  is_real b\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Im (a / b) = Im a / Re b", "by (simp add: complex_is_Real_iff)"], ["", "lemma Re_half [simp]:\n  shows \"Re (x / 2) = Re x / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (x / 2) = Re x / 2", "by (rule Re_divide_numeral)"], ["", "lemma Re_double [simp]:\n  shows \"Re (2 * x) = 2 * Re x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (2 * x) = 2 * Re x", "using Re_mult_real[of \"2\" x]"], ["proof (prove)\nusing this:\n  is_real 2 \\<Longrightarrow> Re (2 * x) = Re 2 * Re x\n\ngoal (1 subgoal):\n 1. Re (2 * x) = 2 * Re x", "by simp"], ["", "lemma Im_half [simp]:\n  shows \"Im (z / 2) = Im z / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (z / 2) = Im z / 2", "by (subst Im_divide_real, auto)"], ["", "lemma Im_double [simp]:\n  shows \"Im (2 * z) = 2 * Im z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Im (2 * z) = 2 * Im z", "using Im_mult_real[of \"2\" z]"], ["proof (prove)\nusing this:\n  is_real 2 \\<Longrightarrow> Im (2 * z) = Re 2 * Im z\n\ngoal (1 subgoal):\n 1. Im (2 * z) = 2 * Im z", "by simp"], ["", "lemma Re_sgn:\n  assumes \"is_real R\"\n  shows \"Re (sgn R) = sgn (Re R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (sgn R) = sgn (Re R)", "using assms"], ["proof (prove)\nusing this:\n  is_real R\n\ngoal (1 subgoal):\n 1. Re (sgn R) = sgn (Re R)", "by (metis Re_sgn complex_of_real_Re norm_of_real real_sgn_eq)"], ["", "lemma is_real_div:\n  assumes \"b \\<noteq> 0\"\n  shows \"is_real (a / b) \\<longleftrightarrow> a*cnj b = b*cnj a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real (a / b) = (a * cnj b = b * cnj a)", "using assms"], ["proof (prove)\nusing this:\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_real (a / b) = (a * cnj b = b * cnj a)", "by (metis complex_cnj_divide complex_cnj_zero_iff eq_cnj_iff_real frac_eq_eq mult.commute)"], ["", "lemma is_real_mult_real:\n  assumes \"is_real a\" and \"a \\<noteq> 0\"\n  shows \"is_real b \\<longleftrightarrow> is_real (a * b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real b = is_real (a * b)", "using assms"], ["proof (prove)\nusing this:\n  is_real a\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_real b = is_real (a * b)", "by (cases a, auto simp add: Complex_eq)"], ["", "lemma Im_express_cnj:\n  shows \"Im z = (z - cnj z) / (2 * \\<i>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cor (Im z) = (z - cnj z) / (2 * \\<i>)", "by (simp add: complex_diff_cnj field_simps)"], ["", "lemma Re_express_cnj: \n  shows \"Re z = (z + cnj z) / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cor (Re z) = (z + cnj z) / 2", "by (simp add: complex_add_cnj)"], ["", "text \\<open>Rotation of complex number for 90 degrees in the positive direction.\\<close>"], ["", "abbreviation rot90 where\n  \"rot90 z \\<equiv> Complex (-Im z) (Re z)\""], ["", "lemma rot90_ii: \n  shows \"rot90 z = z * \\<i>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rot90 z = z * \\<i>", "by (metis Complex_mult_i complex_surj)"], ["", "text \\<open>With @{term cnj_mix} we introduce scalar product between complex vectors. This operation shows\nto be useful to succinctly express some conditions.\\<close>"], ["", "abbreviation cnj_mix where\n  \"cnj_mix z1 z2 \\<equiv> cnj z1 * z2 + z1 * cnj z2\""], ["", "abbreviation scalprod where\n  \"scalprod z1 z2 \\<equiv> cnj_mix z1 z2 / 2\""], ["", "lemma cnj_mix_minus:\n  shows \"cnj z1*z2 - z1*cnj z2 = \\<i> * cnj_mix (rot90 z1) z2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj z1 * z2 - z1 * cnj z2 = \\<i> * cnj_mix (rot90 z1) z2", "by (cases z1, cases z2) (simp add: Complex_eq field_simps)"], ["", "lemma cnj_mix_minus':\n  shows \"cnj z1*z2 - z1*cnj z2 = rot90 (cnj_mix (rot90 z1) z2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj z1 * z2 - z1 * cnj z2 = rot90 (cnj_mix (rot90 z1) z2)", "by (cases z1, cases z2) (simp add: Complex_eq field_simps)"], ["", "lemma cnj_mix_real [simp]:\n  shows \"is_real (cnj_mix z1 z2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real (cnj_mix z1 z2)", "by (cases z1, cases z2) simp"], ["", "lemma scalprod_real [simp]:\n  shows \"is_real (scalprod z1 z2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real (scalprod z1 z2)", "using cnj_mix_real"], ["proof (prove)\nusing this:\n  is_real (cnj_mix ?z1.0 ?z2.0)\n\ngoal (1 subgoal):\n 1. is_real (scalprod z1 z2)", "by simp"], ["", "text \\<open>Additional properties of @{term cis} function.\\<close>"], ["", "lemma cis_minus_pi2 [simp]:\n  shows \"cis (-pi/2) = -\\<i>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (- pi / 2) = - \\<i>", "by (simp add: cis_inverse[symmetric])"], ["", "lemma cis_pi2_minus_x [simp]:\n  shows \"cis (pi/2 - x) = \\<i> * cis(-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (pi / 2 - x) = \\<i> * cis (- x)", "using cis_divide[of \"pi/2\" x, symmetric]"], ["proof (prove)\nusing this:\n  cis (pi / 2 - x) = cis (pi / 2) / cis x\n\ngoal (1 subgoal):\n 1. cis (pi / 2 - x) = \\<i> * cis (- x)", "using cis_divide[of 0 x, symmetric]"], ["proof (prove)\nusing this:\n  cis (pi / 2 - x) = cis (pi / 2) / cis x\n  cis (0 - x) = cis 0 / cis x\n\ngoal (1 subgoal):\n 1. cis (pi / 2 - x) = \\<i> * cis (- x)", "by simp"], ["", "lemma cis_pm_pi [simp]: \n  shows \"cis (x - pi) = - cis x\" and  \"cis (x + pi) = - cis x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (x - pi) = - cis x &&& cis (x + pi) = - cis x", "by (simp add: cis.ctr complex_minus)+"], ["", "lemma cis_times_cis_opposite [simp]: \n  shows \"cis \\<phi> * cis (- \\<phi>) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis \\<phi> * cis (- \\<phi>) = 1", "by (simp add: cis_mult)"], ["", "text \\<open>@{term cis} repeats only after $2k\\pi$\\<close>"], ["", "lemma cis_eq:\n  assumes \"cis a = cis b\"\n  shows \"\\<exists> k::int. a - b = 2 * k * pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. a - b = 2 * real_of_int x * pi", "using assms sin_cos_eq[of a b]"], ["proof (prove)\nusing this:\n  cis a = cis b\n  \\<lbrakk>cos a = cos b; sin a = sin b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. a - b = 2 * real_of_int x * pi\n\ngoal (1 subgoal):\n 1. \\<exists>x. a - b = 2 * real_of_int x * pi", "using cis.sel[of a] cis.sel[of b]"], ["proof (prove)\nusing this:\n  cis a = cis b\n  \\<lbrakk>cos a = cos b; sin a = sin b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. a - b = 2 * real_of_int x * pi\n  Re (cis a) = cos a\n  Im (cis a) = sin a\n  Re (cis b) = cos b\n  Im (cis b) = sin b\n\ngoal (1 subgoal):\n 1. \\<exists>x. a - b = 2 * real_of_int x * pi", "by (cases \"cis a\", cases \"cis b\") auto"], ["", "text \\<open>@{term cis} is injective on $(-\\pi, \\pi]$.\\<close>"], ["", "lemma cis_inj:\n  assumes \"-pi < \\<alpha>\" and \"\\<alpha> \\<le> pi\" and \"-pi < \\<alpha>'\" and \"\\<alpha>' \\<le> pi\"\n  assumes \"cis \\<alpha> = cis \\<alpha>'\"\n  shows \"\\<alpha> = \\<alpha>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> = \\<alpha>'", "using assms"], ["proof (prove)\nusing this:\n  - pi < \\<alpha>\n  \\<alpha> \\<le> pi\n  - pi < \\<alpha>'\n  \\<alpha>' \\<le> pi\n  cis \\<alpha> = cis \\<alpha>'\n\ngoal (1 subgoal):\n 1. \\<alpha> = \\<alpha>'", "by (metis arg_unique sgn_cis)"], ["", "text \\<open>@{term cis} of an angle combined with @{term cis} of the opposite angle\\<close>"], ["", "lemma cis_diff_cis_opposite [simp]: \n  shows \"cis \\<phi> - cis (- \\<phi>) = 2 * \\<i> * sin \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis \\<phi> - cis (- \\<phi>) = 2 * \\<i> * cor (sin \\<phi>)", "using Im_express_cnj[of \"cis \\<phi>\"]"], ["proof (prove)\nusing this:\n  cor (Im (cis \\<phi>)) = (cis \\<phi> - cnj (cis \\<phi>)) / (2 * \\<i>)\n\ngoal (1 subgoal):\n 1. cis \\<phi> - cis (- \\<phi>) = 2 * \\<i> * cor (sin \\<phi>)", "by simp"], ["", "lemma cis_opposite_diff_cis [simp]:\n  shows \"cis (-\\<phi>) - cis (\\<phi>) = - 2 * \\<i> * sin \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (- \\<phi>) - cis \\<phi> = - 2 * \\<i> * cor (sin \\<phi>)", "using cis_diff_cis_opposite[of \"-\\<phi>\"]"], ["proof (prove)\nusing this:\n  cis (- \\<phi>) - cis (- (- \\<phi>)) = 2 * \\<i> * cor (sin (- \\<phi>))\n\ngoal (1 subgoal):\n 1. cis (- \\<phi>) - cis \\<phi> = - 2 * \\<i> * cor (sin \\<phi>)", "by simp"], ["", "lemma cis_add_cis_opposite [simp]: \n  shows \"cis \\<phi> + cis (-\\<phi>) = 2 * cos \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis \\<phi> + cis (- \\<phi>) = cor (2 * cos \\<phi>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. cis \\<phi> + cis (- \\<phi>) = cor (2 * cos \\<phi>)", "have \"2 * cos \\<phi> = (cis \\<phi> + cnj (cis \\<phi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cor (2 * cos \\<phi>) = cis \\<phi> + cnj (cis \\<phi>)", "using Re_express_cnj[of \"cis \\<phi>\"]"], ["proof (prove)\nusing this:\n  cor (Re (cis \\<phi>)) = (cis \\<phi> + cnj (cis \\<phi>)) / 2\n\ngoal (1 subgoal):\n 1. cor (2 * cos \\<phi>) = cis \\<phi> + cnj (cis \\<phi>)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  cor (2 * cos \\<phi>) = cis \\<phi> + cnj (cis \\<phi>)\n\ngoal (1 subgoal):\n 1. cis \\<phi> + cis (- \\<phi>) = cor (2 * cos \\<phi>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  cor (2 * cos \\<phi>) = cis \\<phi> + cnj (cis \\<phi>)\n\ngoal (1 subgoal):\n 1. cis \\<phi> + cis (- \\<phi>) = cor (2 * cos \\<phi>)", "by simp"], ["proof (state)\nthis:\n  cis \\<phi> + cis (- \\<phi>) = cor (2 * cos \\<phi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>@{term cis} equal to 1 or -1\\<close>"], ["", "lemma cis_one [simp]:\n  assumes \"sin \\<phi> = 0\" and \"cos \\<phi> = 1\"\n  shows \"cis \\<phi> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis \\<phi> = 1", "using assms"], ["proof (prove)\nusing this:\n  sin \\<phi> = 0\n  cos \\<phi> = 1\n\ngoal (1 subgoal):\n 1. cis \\<phi> = 1", "by (auto simp add: cis.ctr one_complex.code)"], ["", "lemma cis_minus_one [simp]:\n  assumes \"sin \\<phi> = 0\" and \"cos \\<phi> = -1\"\n  shows \"cis \\<phi> = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis \\<phi> = - 1", "using assms"], ["proof (prove)\nusing this:\n  sin \\<phi> = 0\n  cos \\<phi> = - 1\n\ngoal (1 subgoal):\n 1. cis \\<phi> = - 1", "by (auto simp add: cis.ctr Complex_eq_neg_1)"], ["", "(* -------------------------------------------------------------------------- *)"], ["", "subsubsection \\<open>Additional properties of complex number argument\\<close>"], ["", "(* -------------------------------------------------------------------------- *)"], ["", "text \\<open>@{term arg} of real numbers\\<close>"], ["", "lemma is_real_arg1:\n  assumes \"arg z = 0 \\<or> arg z = pi\"\n  shows \"is_real z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real z", "using assms"], ["proof (prove)\nusing this:\n  arg z = 0 \\<or> arg z = pi\n\ngoal (1 subgoal):\n 1. is_real z", "using rcis_cmod_arg[of z] Im_rcis[of \"cmod z\" \"arg z\"]"], ["proof (prove)\nusing this:\n  arg z = 0 \\<or> arg z = pi\n  rcis (cmod z) (arg z) = z\n  Im (rcis (cmod z) (arg z)) = cmod z * sin (arg z)\n\ngoal (1 subgoal):\n 1. is_real z", "by auto"], ["", "lemma is_real_arg2:\n  assumes \"is_real z\"\n  shows \"arg z = 0 \\<or> arg z = pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg z = 0 \\<or> arg z = pi", "proof (cases \"z = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow> arg z = 0 \\<or> arg z = pi\n 2. z \\<noteq> 0 \\<Longrightarrow> arg z = 0 \\<or> arg z = pi", "case True"], ["proof (state)\nthis:\n  z = 0\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow> arg z = 0 \\<or> arg z = pi\n 2. z \\<noteq> 0 \\<Longrightarrow> arg z = 0 \\<or> arg z = pi", "thus ?thesis"], ["proof (prove)\nusing this:\n  z = 0\n\ngoal (1 subgoal):\n 1. arg z = 0 \\<or> arg z = pi", "by (auto simp add: arg_zero)"], ["proof (state)\nthis:\n  arg z = 0 \\<or> arg z = pi\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> arg z = 0 \\<or> arg z = pi", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> arg z = 0 \\<or> arg z = pi", "case False"], ["proof (state)\nthis:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> arg z = 0 \\<or> arg z = pi", "hence \"sin (arg z) = 0\""], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sin (arg z) = 0", "using assms rcis_cmod_arg[of z] Im_rcis[of \"cmod z\" \"arg z\"]"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n  is_real z\n  rcis (cmod z) (arg z) = z\n  Im (rcis (cmod z) (arg z)) = cmod z * sin (arg z)\n\ngoal (1 subgoal):\n 1. sin (arg z) = 0", "by auto"], ["proof (state)\nthis:\n  sin (arg z) = 0\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> arg z = 0 \\<or> arg z = pi", "thus ?thesis"], ["proof (prove)\nusing this:\n  sin (arg z) = 0\n\ngoal (1 subgoal):\n 1. arg z = 0 \\<or> arg z = pi", "using arg_bounded[of z]"], ["proof (prove)\nusing this:\n  sin (arg z) = 0\n  - pi < arg z \\<and> arg z \\<le> pi\n\ngoal (1 subgoal):\n 1. arg z = 0 \\<or> arg z = pi", "using sin_0_iff_canon"], ["proof (prove)\nusing this:\n  sin (arg z) = 0\n  - pi < arg z \\<and> arg z \\<le> pi\n  \\<lbrakk>sin ?\\<phi> = 0; - pi < ?\\<phi>; ?\\<phi> \\<le> pi\\<rbrakk>\n  \\<Longrightarrow> ?\\<phi> = 0 \\<or> ?\\<phi> = pi\n\ngoal (1 subgoal):\n 1. arg z = 0 \\<or> arg z = pi", "by simp"], ["proof (state)\nthis:\n  arg z = 0 \\<or> arg z = pi\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arg_complex_of_real_positive [simp]:\n  assumes \"k > 0\"\n  shows \"arg (cor k) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg (cor k) = 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. arg (cor k) = 0", "have \"cos (arg (Complex k 0)) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < cos (arg (Complex k 0))", "using assms"], ["proof (prove)\nusing this:\n  0 < k\n\ngoal (1 subgoal):\n 1. 0 < cos (arg (Complex k 0))", "using rcis_cmod_arg[of \"Complex k 0\"] Re_rcis[of \"cmod (Complex k 0)\" \"arg (Complex k 0)\"]"], ["proof (prove)\nusing this:\n  0 < k\n  rcis (cmod (Complex k 0)) (arg (Complex k 0)) = Complex k 0\n  Re (rcis (cmod (Complex k 0)) (arg (Complex k 0))) =\n  cmod (Complex k 0) * cos (arg (Complex k 0))\n\ngoal (1 subgoal):\n 1. 0 < cos (arg (Complex k 0))", "by (smt complex.sel(1) mult_nonneg_nonpos norm_ge_zero)"], ["proof (state)\nthis:\n  0 < cos (arg (Complex k 0))\n\ngoal (1 subgoal):\n 1. arg (cor k) = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < cos (arg (Complex k 0))\n\ngoal (1 subgoal):\n 1. arg (cor k) = 0", "using assms is_real_arg2[of \"cor k\"]"], ["proof (prove)\nusing this:\n  0 < cos (arg (Complex k 0))\n  0 < k\n  is_real (cor k) \\<Longrightarrow> arg (cor k) = 0 \\<or> arg (cor k) = pi\n\ngoal (1 subgoal):\n 1. arg (cor k) = 0", "unfolding complex_of_real_def"], ["proof (prove)\nusing this:\n  0 < cos (arg (Complex k 0))\n  0 < k\n  is_real (Complex k 0) \\<Longrightarrow>\n  arg (Complex k 0) = 0 \\<or> arg (Complex k 0) = pi\n\ngoal (1 subgoal):\n 1. arg (Complex k 0) = 0", "by auto"], ["proof (state)\nthis:\n  arg (cor k) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arg_complex_of_real_negative [simp]:\n  assumes \"k < 0\"\n  shows \"arg (cor k) = pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg (cor k) = pi", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. arg (cor k) = pi", "have \"cos (arg (Complex k 0)) < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (arg (Complex k 0)) < 0", "using \\<open>k < 0\\<close> rcis_cmod_arg[of \"Complex k 0\"] Re_rcis[of \"cmod (Complex k 0)\" \"arg (Complex k 0)\"]"], ["proof (prove)\nusing this:\n  k < 0\n  rcis (cmod (Complex k 0)) (arg (Complex k 0)) = Complex k 0\n  Re (rcis (cmod (Complex k 0)) (arg (Complex k 0))) =\n  cmod (Complex k 0) * cos (arg (Complex k 0))\n\ngoal (1 subgoal):\n 1. cos (arg (Complex k 0)) < 0", "by (smt complex.sel(1) mult_nonneg_nonneg norm_ge_zero)"], ["proof (state)\nthis:\n  cos (arg (Complex k 0)) < 0\n\ngoal (1 subgoal):\n 1. arg (cor k) = pi", "thus ?thesis"], ["proof (prove)\nusing this:\n  cos (arg (Complex k 0)) < 0\n\ngoal (1 subgoal):\n 1. arg (cor k) = pi", "using assms is_real_arg2[of \"cor k\"]"], ["proof (prove)\nusing this:\n  cos (arg (Complex k 0)) < 0\n  k < 0\n  is_real (cor k) \\<Longrightarrow> arg (cor k) = 0 \\<or> arg (cor k) = pi\n\ngoal (1 subgoal):\n 1. arg (cor k) = pi", "unfolding complex_of_real_def"], ["proof (prove)\nusing this:\n  cos (arg (Complex k 0)) < 0\n  k < 0\n  is_real (Complex k 0) \\<Longrightarrow>\n  arg (Complex k 0) = 0 \\<or> arg (Complex k 0) = pi\n\ngoal (1 subgoal):\n 1. arg (Complex k 0) = pi", "by auto"], ["proof (state)\nthis:\n  arg (cor k) = pi\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arg_0_iff:\n  shows \"z \\<noteq> 0 \\<and> arg z = 0 \\<longleftrightarrow> is_real z \\<and> Re z > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<noteq> 0 \\<and> arg z = 0) = (is_real z \\<and> 0 < Re z)", "by (smt arg_complex_of_real_negative arg_complex_of_real_positive arg_zero complex_of_real_Re is_real_arg1 pi_gt_zero zero_complex.simps)"], ["", "lemma arg_pi_iff:\n  shows \"arg z = pi \\<longleftrightarrow> is_real z \\<and> Re z < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (arg z = pi) = (is_real z \\<and> Re z < 0)", "by (smt arg_complex_of_real_negative arg_complex_of_real_positive arg_zero complex_of_real_Re is_real_arg1 pi_gt_zero zero_complex.simps)"], ["", "text \\<open>@{term arg} of imaginary numbers\\<close>"], ["", "lemma is_imag_arg1:\n  assumes \"arg z = pi/2 \\<or> arg z = -pi/2\"\n  shows \"is_imag z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_imag z", "using assms"], ["proof (prove)\nusing this:\n  arg z = pi / 2 \\<or> arg z = - pi / 2\n\ngoal (1 subgoal):\n 1. is_imag z", "using rcis_cmod_arg[of z] Re_rcis[of \"cmod z\" \"arg z\"]"], ["proof (prove)\nusing this:\n  arg z = pi / 2 \\<or> arg z = - pi / 2\n  rcis (cmod z) (arg z) = z\n  Re (rcis (cmod z) (arg z)) = cmod z * cos (arg z)\n\ngoal (1 subgoal):\n 1. is_imag z", "by (metis cos_minus cos_pi_half minus_divide_left mult_eq_0_iff)"], ["", "lemma is_imag_arg2:\n  assumes \"is_imag z\" and \"z \\<noteq> 0\"\n  shows \"arg z = pi/2 \\<or> arg z = -pi/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg z = pi / 2 \\<or> arg z = - pi / 2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. arg z = pi / 2 \\<or> arg z = - pi / 2", "have \"cos (arg z) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (arg z) = 0", "using assms"], ["proof (prove)\nusing this:\n  is_imag z\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cos (arg z) = 0", "by (metis Re_rcis no_zero_divisors norm_eq_zero rcis_cmod_arg)"], ["proof (state)\nthis:\n  cos (arg z) = 0\n\ngoal (1 subgoal):\n 1. arg z = pi / 2 \\<or> arg z = - pi / 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  cos (arg z) = 0\n\ngoal (1 subgoal):\n 1. arg z = pi / 2 \\<or> arg z = - pi / 2", "using arg_bounded[of z]"], ["proof (prove)\nusing this:\n  cos (arg z) = 0\n  - pi < arg z \\<and> arg z \\<le> pi\n\ngoal (1 subgoal):\n 1. arg z = pi / 2 \\<or> arg z = - pi / 2", "using cos_0_iff_canon[of \"arg z\"]"], ["proof (prove)\nusing this:\n  cos (arg z) = 0\n  - pi < arg z \\<and> arg z \\<le> pi\n  \\<lbrakk>cos (arg z) = 0; - pi < arg z; arg z \\<le> pi\\<rbrakk>\n  \\<Longrightarrow> arg z = pi / 2 \\<or> arg z = - pi / 2\n\ngoal (1 subgoal):\n 1. arg z = pi / 2 \\<or> arg z = - pi / 2", "by simp"], ["proof (state)\nthis:\n  arg z = pi / 2 \\<or> arg z = - pi / 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arg_complex_of_real_times_i_positive [simp]:\n  assumes \"k > 0\"\n  shows \"arg (cor k * \\<i>) = pi / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg (cor k * \\<i>) = pi / 2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. arg (cor k * \\<i>) = pi / 2", "have \"sin (arg (Complex 0 k)) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < sin (arg (Complex 0 k))", "using \\<open>k > 0\\<close> rcis_cmod_arg[of \"Complex 0 k\"] Im_rcis[of \"cmod (Complex 0 k)\" \"arg (Complex 0 k)\"]"], ["proof (prove)\nusing this:\n  0 < k\n  rcis (cmod (Complex 0 k)) (arg (Complex 0 k)) = Complex 0 k\n  Im (rcis (cmod (Complex 0 k)) (arg (Complex 0 k))) =\n  cmod (Complex 0 k) * sin (arg (Complex 0 k))\n\ngoal (1 subgoal):\n 1. 0 < sin (arg (Complex 0 k))", "by (smt complex.sel(2) mult_nonneg_nonpos norm_ge_zero)"], ["proof (state)\nthis:\n  0 < sin (arg (Complex 0 k))\n\ngoal (1 subgoal):\n 1. arg (cor k * \\<i>) = pi / 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < sin (arg (Complex 0 k))\n\ngoal (1 subgoal):\n 1. arg (cor k * \\<i>) = pi / 2", "using assms is_imag_arg2[of \"cor k * \\<i>\"]"], ["proof (prove)\nusing this:\n  0 < sin (arg (Complex 0 k))\n  0 < k\n  \\<lbrakk>is_imag (cor k * \\<i>); cor k * \\<i> \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> arg (cor k * \\<i>) = pi / 2 \\<or>\n                    arg (cor k * \\<i>) = - pi / 2\n\ngoal (1 subgoal):\n 1. arg (cor k * \\<i>) = pi / 2", "using arg_zero complex_of_real_i"], ["proof (prove)\nusing this:\n  0 < sin (arg (Complex 0 k))\n  0 < k\n  \\<lbrakk>is_imag (cor k * \\<i>); cor k * \\<i> \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> arg (cor k * \\<i>) = pi / 2 \\<or>\n                    arg (cor k * \\<i>) = - pi / 2\n  arg 0 = 0\n  cor ?r * \\<i> = Complex 0 ?r\n\ngoal (1 subgoal):\n 1. arg (cor k * \\<i>) = pi / 2", "by force"], ["proof (state)\nthis:\n  arg (cor k * \\<i>) = pi / 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arg_complex_of_real_times_i_negative [simp]:\n  assumes \"k < 0\"\n  shows \"arg (cor k * \\<i>) = - pi / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg (cor k * \\<i>) = - pi / 2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. arg (cor k * \\<i>) = - pi / 2", "have \"sin (arg (Complex 0 k)) < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sin (arg (Complex 0 k)) < 0", "using \\<open>k < 0\\<close> rcis_cmod_arg[of \"Complex 0 k\"] Im_rcis[of \"cmod (Complex 0 k)\" \"arg (Complex 0 k)\"]"], ["proof (prove)\nusing this:\n  k < 0\n  rcis (cmod (Complex 0 k)) (arg (Complex 0 k)) = Complex 0 k\n  Im (rcis (cmod (Complex 0 k)) (arg (Complex 0 k))) =\n  cmod (Complex 0 k) * sin (arg (Complex 0 k))\n\ngoal (1 subgoal):\n 1. sin (arg (Complex 0 k)) < 0", "by (smt complex.sel(2) mult_nonneg_nonneg norm_ge_zero)"], ["proof (state)\nthis:\n  sin (arg (Complex 0 k)) < 0\n\ngoal (1 subgoal):\n 1. arg (cor k * \\<i>) = - pi / 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  sin (arg (Complex 0 k)) < 0\n\ngoal (1 subgoal):\n 1. arg (cor k * \\<i>) = - pi / 2", "using assms is_imag_arg2[of \"cor k * \\<i>\"]"], ["proof (prove)\nusing this:\n  sin (arg (Complex 0 k)) < 0\n  k < 0\n  \\<lbrakk>is_imag (cor k * \\<i>); cor k * \\<i> \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> arg (cor k * \\<i>) = pi / 2 \\<or>\n                    arg (cor k * \\<i>) = - pi / 2\n\ngoal (1 subgoal):\n 1. arg (cor k * \\<i>) = - pi / 2", "using arg_zero complex_of_real_i[of k]"], ["proof (prove)\nusing this:\n  sin (arg (Complex 0 k)) < 0\n  k < 0\n  \\<lbrakk>is_imag (cor k * \\<i>); cor k * \\<i> \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> arg (cor k * \\<i>) = pi / 2 \\<or>\n                    arg (cor k * \\<i>) = - pi / 2\n  arg 0 = 0\n  cor k * \\<i> = Complex 0 k\n\ngoal (1 subgoal):\n 1. arg (cor k * \\<i>) = - pi / 2", "by (smt complex.sel(1) sin_pi_half sin_zero)"], ["proof (state)\nthis:\n  arg (cor k * \\<i>) = - pi / 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arg_pi2_iff:\n  shows \"z \\<noteq> 0 \\<and> arg z = pi / 2 \\<longleftrightarrow> is_imag z \\<and> Im z > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<noteq> 0 \\<and> arg z = pi / 2) = (is_imag z \\<and> 0 < Im z)", "by (smt Im_rcis Re_i_times Re_rcis arcsin_minus_1 cos_pi_half divide_minus_left mult.commute mult_cancel_right1 rcis_cmod_arg is_imag_arg2 sin_arcsin sin_pi_half zero_less_mult_pos zero_less_norm_iff)"], ["", "lemma arg_minus_pi2_iff:\n  shows \"z \\<noteq> 0 \\<and> arg z = - pi / 2 \\<longleftrightarrow> is_imag z \\<and> Im z < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<noteq> 0 \\<and> arg z = - pi / 2) = (is_imag z \\<and> Im z < 0)", "by (smt arg_pi2_iff complex.expand divide_cancel_right pi_neq_zero is_imag_arg1 is_imag_arg2 zero_complex.simps(1) zero_complex.simps(2))"], ["", "lemma arg_ii [simp]:\n  shows \"arg \\<i> = pi/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg \\<i> = pi / 2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. arg \\<i> = pi / 2", "have \"\\<i> = cis (arg \\<i>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i> = cis (arg \\<i>)", "using rcis_cmod_arg[of \\<i>]"], ["proof (prove)\nusing this:\n  rcis (cmod \\<i>) (arg \\<i>) = \\<i>\n\ngoal (1 subgoal):\n 1. \\<i> = cis (arg \\<i>)", "by (simp add: rcis_def)"], ["proof (state)\nthis:\n  \\<i> = cis (arg \\<i>)\n\ngoal (1 subgoal):\n 1. arg \\<i> = pi / 2", "hence \"cos (arg \\<i>) = 0\" \"sin (arg \\<i>) = 1\""], ["proof (prove)\nusing this:\n  \\<i> = cis (arg \\<i>)\n\ngoal (1 subgoal):\n 1. cos (arg \\<i>) = 0 &&& sin (arg \\<i>) = 1", "by (metis cis.simps(1) imaginary_unit.simps(1), metis cis.simps(2) imaginary_unit.simps(2))"], ["proof (state)\nthis:\n  cos (arg \\<i>) = 0\n  sin (arg \\<i>) = 1\n\ngoal (1 subgoal):\n 1. arg \\<i> = pi / 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  cos (arg \\<i>) = 0\n  sin (arg \\<i>) = 1\n\ngoal (1 subgoal):\n 1. arg \\<i> = pi / 2", "using cos_0_iff_canon[of \"arg \\<i>\"] arg_bounded[of \\<i>]"], ["proof (prove)\nusing this:\n  cos (arg \\<i>) = 0\n  sin (arg \\<i>) = 1\n  \\<lbrakk>cos (arg \\<i>) = 0; - pi < arg \\<i>; arg \\<i> \\<le> pi\\<rbrakk>\n  \\<Longrightarrow> arg \\<i> = pi / 2 \\<or> arg \\<i> = - pi / 2\n  - pi < arg \\<i> \\<and> arg \\<i> \\<le> pi\n\ngoal (1 subgoal):\n 1. arg \\<i> = pi / 2", "by auto"], ["proof (state)\nthis:\n  arg \\<i> = pi / 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arg_minus_ii [simp]: \n  shows \"arg (-\\<i>) = -pi/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg (- \\<i>) = - pi / 2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. arg (- \\<i>) = - pi / 2", "have \"-\\<i> = cis (arg (- \\<i>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - \\<i> = cis (arg (- \\<i>))", "using rcis_cmod_arg[of \"-\\<i>\"]"], ["proof (prove)\nusing this:\n  rcis (cmod (- \\<i>)) (arg (- \\<i>)) = - \\<i>\n\ngoal (1 subgoal):\n 1. - \\<i> = cis (arg (- \\<i>))", "by (simp add: rcis_def)"], ["proof (state)\nthis:\n  - \\<i> = cis (arg (- \\<i>))\n\ngoal (1 subgoal):\n 1. arg (- \\<i>) = - pi / 2", "hence \"cos (arg (-\\<i>)) = 0\" \"sin (arg (-\\<i>)) = -1\""], ["proof (prove)\nusing this:\n  - \\<i> = cis (arg (- \\<i>))\n\ngoal (1 subgoal):\n 1. cos (arg (- \\<i>)) = 0 &&& sin (arg (- \\<i>)) = - 1", "using cis.simps[of \"arg (-\\<i>)\"]"], ["proof (prove)\nusing this:\n  - \\<i> = cis (arg (- \\<i>))\n  Re (cis (arg (- \\<i>))) = cos (arg (- \\<i>))\n  Im (cis (arg (- \\<i>))) = sin (arg (- \\<i>))\n\ngoal (1 subgoal):\n 1. cos (arg (- \\<i>)) = 0 &&& sin (arg (- \\<i>)) = - 1", "by auto"], ["proof (state)\nthis:\n  cos (arg (- \\<i>)) = 0\n  sin (arg (- \\<i>)) = - 1\n\ngoal (1 subgoal):\n 1. arg (- \\<i>) = - pi / 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  cos (arg (- \\<i>)) = 0\n  sin (arg (- \\<i>)) = - 1\n\ngoal (1 subgoal):\n 1. arg (- \\<i>) = - pi / 2", "using cos_0_iff_canon[of \"arg (-\\<i>)\"] arg_bounded[of \"-\\<i>\"]"], ["proof (prove)\nusing this:\n  cos (arg (- \\<i>)) = 0\n  sin (arg (- \\<i>)) = - 1\n  \\<lbrakk>cos (arg (- \\<i>)) = 0; - pi < arg (- \\<i>);\n   arg (- \\<i>) \\<le> pi\\<rbrakk>\n  \\<Longrightarrow> arg (- \\<i>) = pi / 2 \\<or> arg (- \\<i>) = - pi / 2\n  - pi < arg (- \\<i>) \\<and> arg (- \\<i>) \\<le> pi\n\ngoal (1 subgoal):\n 1. arg (- \\<i>) = - pi / 2", "by fastforce"], ["proof (state)\nthis:\n  arg (- \\<i>) = - pi / 2\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Argument is a canonical angle\\<close>"], ["", "lemma canon_ang_arg:\n  shows \"\\<downharpoonright>arg z\\<downharpoonleft> = arg z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<downharpoonright>arg z\\<downharpoonleft> = arg z", "using canon_ang_id[of \"arg z\"] arg_bounded"], ["proof (prove)\nusing this:\n  - pi < arg z \\<and> arg z \\<le> pi \\<Longrightarrow>\n  \\<downharpoonright>arg z\\<downharpoonleft> = arg z\n  - pi < arg ?z \\<and> arg ?z \\<le> pi\n\ngoal (1 subgoal):\n 1. \\<downharpoonright>arg z\\<downharpoonleft> = arg z", "by simp"], ["", "lemma arg_cis:\n  shows \"arg (cis \\<phi>) = \\<downharpoonright>\\<phi>\\<downharpoonleft>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg (cis \\<phi>) = \\<downharpoonright>\\<phi>\\<downharpoonleft>", "proof (rule canon_ang_eqI[symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x. arg (cis \\<phi>) - \\<phi> = 2 * real_of_int x * pi\n 2. - pi < arg (cis \\<phi>) \\<and> arg (cis \\<phi>) \\<le> pi", "show \"- pi < arg (cis \\<phi>) \\<and> arg (cis \\<phi>) \\<le> pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - pi < arg (cis \\<phi>) \\<and> arg (cis \\<phi>) \\<le> pi", "using arg_bounded"], ["proof (prove)\nusing this:\n  - pi < arg ?z \\<and> arg ?z \\<le> pi\n\ngoal (1 subgoal):\n 1. - pi < arg (cis \\<phi>) \\<and> arg (cis \\<phi>) \\<le> pi", "by simp"], ["proof (state)\nthis:\n  - pi < arg (cis \\<phi>) \\<and> arg (cis \\<phi>) \\<le> pi\n\ngoal (1 subgoal):\n 1. \\<exists>x. arg (cis \\<phi>) - \\<phi> = 2 * real_of_int x * pi", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. arg (cis \\<phi>) - \\<phi> = 2 * real_of_int x * pi", "show \"\\<exists> k::int. arg (cis \\<phi>) - \\<phi> = 2*k*pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. arg (cis \\<phi>) - \\<phi> = 2 * real_of_int x * pi", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. arg (cis \\<phi>) - \\<phi> = 2 * real_of_int x * pi", "have \"cis (arg (cis \\<phi>)) = cis \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (arg (cis \\<phi>)) = cis \\<phi>", "using cis_arg[of \"cis \\<phi>\"]"], ["proof (prove)\nusing this:\n  cis \\<phi> \\<noteq> 0 \\<Longrightarrow>\n  cis (arg (cis \\<phi>)) = sgn (cis \\<phi>)\n\ngoal (1 subgoal):\n 1. cis (arg (cis \\<phi>)) = cis \\<phi>", "by auto"], ["proof (state)\nthis:\n  cis (arg (cis \\<phi>)) = cis \\<phi>\n\ngoal (1 subgoal):\n 1. \\<exists>x. arg (cis \\<phi>) - \\<phi> = 2 * real_of_int x * pi", "thus ?thesis"], ["proof (prove)\nusing this:\n  cis (arg (cis \\<phi>)) = cis \\<phi>\n\ngoal (1 subgoal):\n 1. \\<exists>x. arg (cis \\<phi>) - \\<phi> = 2 * real_of_int x * pi", "using cis_eq"], ["proof (prove)\nusing this:\n  cis (arg (cis \\<phi>)) = cis \\<phi>\n  cis ?a = cis ?b \\<Longrightarrow>\n  \\<exists>x. ?a - ?b = 2 * real_of_int x * pi\n\ngoal (1 subgoal):\n 1. \\<exists>x. arg (cis \\<phi>) - \\<phi> = 2 * real_of_int x * pi", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. arg (cis \\<phi>) - \\<phi> = 2 * real_of_int x * pi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x. arg (cis \\<phi>) - \\<phi> = 2 * real_of_int x * pi\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Cosine and sine of @{term arg}\\<close>"], ["", "lemma cos_arg:\n  assumes \"z \\<noteq> 0\"\n  shows \"cos (arg z) = Re z / cmod z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (arg z) = Re z / cmod z", "by (metis Complex.Re_sgn cis.simps(1) assms cis_arg)"], ["", "lemma sin_arg:\n  assumes \"z \\<noteq> 0\"\n  shows \"sin (arg z) = Im z / cmod z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sin (arg z) = Im z / cmod z", "by (metis Complex.Im_sgn cis.simps(2) assms cis_arg)"], ["", "text \\<open>Argument of product\\<close>"], ["", "lemma cis_arg_mult:\n  assumes \"z1 * z2 \\<noteq> 0\"\n  shows \"cis (arg (z1 * z2)) = cis (arg z1 + arg z2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (arg (z1 * z2)) = cis (arg z1 + arg z2)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. cis (arg (z1 * z2)) = cis (arg z1 + arg z2)", "have \"z1 * z2 = cor (cmod z1) * cor (cmod z2) * cis (arg z1) * cis (arg z2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z1 * z2 = cor (cmod z1) * cor (cmod z2) * cis (arg z1) * cis (arg z2)", "using rcis_cmod_arg[of z1, symmetric]  rcis_cmod_arg[of z2, symmetric]"], ["proof (prove)\nusing this:\n  z1 = rcis (cmod z1) (arg z1)\n  z2 = rcis (cmod z2) (arg z2)\n\ngoal (1 subgoal):\n 1. z1 * z2 = cor (cmod z1) * cor (cmod z2) * cis (arg z1) * cis (arg z2)", "unfolding rcis_def"], ["proof (prove)\nusing this:\n  z1 = cor (cmod z1) * cis (arg z1)\n  z2 = cor (cmod z2) * cis (arg z2)\n\ngoal (1 subgoal):\n 1. z1 * z2 = cor (cmod z1) * cor (cmod z2) * cis (arg z1) * cis (arg z2)", "by algebra"], ["proof (state)\nthis:\n  z1 * z2 = cor (cmod z1) * cor (cmod z2) * cis (arg z1) * cis (arg z2)\n\ngoal (1 subgoal):\n 1. cis (arg (z1 * z2)) = cis (arg z1 + arg z2)", "hence \"z1 * z2 = cor (cmod (z1 * z2)) * cis (arg z1 + arg z2)\""], ["proof (prove)\nusing this:\n  z1 * z2 = cor (cmod z1) * cor (cmod z2) * cis (arg z1) * cis (arg z2)\n\ngoal (1 subgoal):\n 1. z1 * z2 = cor (cmod (z1 * z2)) * cis (arg z1 + arg z2)", "using cis_mult[of \"arg z1\" \"arg z2\"]"], ["proof (prove)\nusing this:\n  z1 * z2 = cor (cmod z1) * cor (cmod z2) * cis (arg z1) * cis (arg z2)\n  cis (arg z1) * cis (arg z2) = cis (arg z1 + arg z2)\n\ngoal (1 subgoal):\n 1. z1 * z2 = cor (cmod (z1 * z2)) * cis (arg z1 + arg z2)", "by auto"], ["proof (state)\nthis:\n  z1 * z2 = cor (cmod (z1 * z2)) * cis (arg z1 + arg z2)\n\ngoal (1 subgoal):\n 1. cis (arg (z1 * z2)) = cis (arg z1 + arg z2)", "hence \"cor (cmod (z1 * z2)) * cis (arg z1 + arg z2) =  cor (cmod (z1 * z2)) * cis (arg (z1 * z2))\""], ["proof (prove)\nusing this:\n  z1 * z2 = cor (cmod (z1 * z2)) * cis (arg z1 + arg z2)\n\ngoal (1 subgoal):\n 1. cor (cmod (z1 * z2)) * cis (arg z1 + arg z2) =\n    cor (cmod (z1 * z2)) * cis (arg (z1 * z2))", "using assms"], ["proof (prove)\nusing this:\n  z1 * z2 = cor (cmod (z1 * z2)) * cis (arg z1 + arg z2)\n  z1 * z2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cor (cmod (z1 * z2)) * cis (arg z1 + arg z2) =\n    cor (cmod (z1 * z2)) * cis (arg (z1 * z2))", "using rcis_cmod_arg[of \"z1*z2\"]"], ["proof (prove)\nusing this:\n  z1 * z2 = cor (cmod (z1 * z2)) * cis (arg z1 + arg z2)\n  z1 * z2 \\<noteq> 0\n  rcis (cmod (z1 * z2)) (arg (z1 * z2)) = z1 * z2\n\ngoal (1 subgoal):\n 1. cor (cmod (z1 * z2)) * cis (arg z1 + arg z2) =\n    cor (cmod (z1 * z2)) * cis (arg (z1 * z2))", "unfolding rcis_def"], ["proof (prove)\nusing this:\n  z1 * z2 = cor (cmod (z1 * z2)) * cis (arg z1 + arg z2)\n  z1 * z2 \\<noteq> 0\n  cor (cmod (z1 * z2)) * cis (arg (z1 * z2)) = z1 * z2\n\ngoal (1 subgoal):\n 1. cor (cmod (z1 * z2)) * cis (arg z1 + arg z2) =\n    cor (cmod (z1 * z2)) * cis (arg (z1 * z2))", "by auto"], ["proof (state)\nthis:\n  cor (cmod (z1 * z2)) * cis (arg z1 + arg z2) =\n  cor (cmod (z1 * z2)) * cis (arg (z1 * z2))\n\ngoal (1 subgoal):\n 1. cis (arg (z1 * z2)) = cis (arg z1 + arg z2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  cor (cmod (z1 * z2)) * cis (arg z1 + arg z2) =\n  cor (cmod (z1 * z2)) * cis (arg (z1 * z2))\n\ngoal (1 subgoal):\n 1. cis (arg (z1 * z2)) = cis (arg z1 + arg z2)", "using mult_cancel_left[of \"cor (cmod (z1 * z2))\" \"cis (arg z1 + arg z2)\" \"cis (arg (z1 * z2))\"]"], ["proof (prove)\nusing this:\n  cor (cmod (z1 * z2)) * cis (arg z1 + arg z2) =\n  cor (cmod (z1 * z2)) * cis (arg (z1 * z2))\n  (cor (cmod (z1 * z2)) * cis (arg z1 + arg z2) =\n   cor (cmod (z1 * z2)) * cis (arg (z1 * z2))) =\n  (cor (cmod (z1 * z2)) = 0 \\<or>\n   cis (arg z1 + arg z2) = cis (arg (z1 * z2)))\n\ngoal (1 subgoal):\n 1. cis (arg (z1 * z2)) = cis (arg z1 + arg z2)", "using assms"], ["proof (prove)\nusing this:\n  cor (cmod (z1 * z2)) * cis (arg z1 + arg z2) =\n  cor (cmod (z1 * z2)) * cis (arg (z1 * z2))\n  (cor (cmod (z1 * z2)) * cis (arg z1 + arg z2) =\n   cor (cmod (z1 * z2)) * cis (arg (z1 * z2))) =\n  (cor (cmod (z1 * z2)) = 0 \\<or>\n   cis (arg z1 + arg z2) = cis (arg (z1 * z2)))\n  z1 * z2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cis (arg (z1 * z2)) = cis (arg z1 + arg z2)", "by auto"], ["proof (state)\nthis:\n  cis (arg (z1 * z2)) = cis (arg z1 + arg z2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arg_mult_2kpi:\n  assumes \"z1 * z2 \\<noteq> 0\"\n  shows \"\\<exists> k::int. arg (z1 * z2) = arg z1 + arg z2 + 2*k*pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. arg (z1 * z2) = arg z1 + arg z2 + 2 * real_of_int x * pi", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. arg (z1 * z2) = arg z1 + arg z2 + 2 * real_of_int x * pi", "have \"cis (arg (z1*z2)) = cis (arg z1 + arg z2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (arg (z1 * z2)) = cis (arg z1 + arg z2)", "by (rule cis_arg_mult[OF assms])"], ["proof (state)\nthis:\n  cis (arg (z1 * z2)) = cis (arg z1 + arg z2)\n\ngoal (1 subgoal):\n 1. \\<exists>x. arg (z1 * z2) = arg z1 + arg z2 + 2 * real_of_int x * pi", "thus ?thesis"], ["proof (prove)\nusing this:\n  cis (arg (z1 * z2)) = cis (arg z1 + arg z2)\n\ngoal (1 subgoal):\n 1. \\<exists>x. arg (z1 * z2) = arg z1 + arg z2 + 2 * real_of_int x * pi", "using cis_eq[of \"arg (z1*z2)\" \"arg z1 + arg z2\"]"], ["proof (prove)\nusing this:\n  cis (arg (z1 * z2)) = cis (arg z1 + arg z2)\n  cis (arg (z1 * z2)) = cis (arg z1 + arg z2) \\<Longrightarrow>\n  \\<exists>x. arg (z1 * z2) - (arg z1 + arg z2) = 2 * real_of_int x * pi\n\ngoal (1 subgoal):\n 1. \\<exists>x. arg (z1 * z2) = arg z1 + arg z2 + 2 * real_of_int x * pi", "by (auto simp add: field_simps)"], ["proof (state)\nthis:\n  \\<exists>x. arg (z1 * z2) = arg z1 + arg z2 + 2 * real_of_int x * pi\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arg_mult:\n  assumes \"z1 * z2 \\<noteq> 0\"\n  shows \"arg(z1 * z2) = \\<downharpoonright>arg z1 + arg z2\\<downharpoonleft>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg (z1 * z2) = \\<downharpoonright>arg z1 + arg z2\\<downharpoonleft>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. arg (z1 * z2) = \\<downharpoonright>arg z1 + arg z2\\<downharpoonleft>", "obtain k::int where \"arg(z1 * z2) = arg z1 + arg z2 + 2*k*pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        arg (z1 * z2) =\n        arg z1 + arg z2 + real_of_int (2 * k) * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using arg_mult_2kpi[of z1 z2]"], ["proof (prove)\nusing this:\n  z1 * z2 \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>x. arg (z1 * z2) = arg z1 + arg z2 + 2 * real_of_int x * pi\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        arg (z1 * z2) =\n        arg z1 + arg z2 + real_of_int (2 * k) * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  z1 * z2 \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>x. arg (z1 * z2) = arg z1 + arg z2 + 2 * real_of_int x * pi\n  z1 * z2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        arg (z1 * z2) =\n        arg z1 + arg z2 + real_of_int (2 * k) * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  arg (z1 * z2) = arg z1 + arg z2 + real_of_int (2 * k) * pi\n\ngoal (1 subgoal):\n 1. arg (z1 * z2) = \\<downharpoonright>arg z1 + arg z2\\<downharpoonleft>", "hence \"\\<downharpoonright>arg(z1 * z2)\\<downharpoonleft> = \\<downharpoonright>arg z1 + arg z2\\<downharpoonleft>\""], ["proof (prove)\nusing this:\n  arg (z1 * z2) = arg z1 + arg z2 + real_of_int (2 * k) * pi\n\ngoal (1 subgoal):\n 1. \\<downharpoonright>arg (z1 * z2)\\<downharpoonleft> =\n    \\<downharpoonright>arg z1 + arg z2\\<downharpoonleft>", "using canon_ang_eq"], ["proof (prove)\nusing this:\n  arg (z1 * z2) = arg z1 + arg z2 + real_of_int (2 * k) * pi\n  \\<exists>x.\n     ?\\<alpha>\\<^sub>1 - ?\\<alpha>\\<^sub>2 =\n     2 * real_of_int x * pi \\<Longrightarrow>\n  \\<downharpoonright>?\\<alpha>\\<^sub>1\\<downharpoonleft> =\n  \\<downharpoonright>?\\<alpha>\\<^sub>2\\<downharpoonleft>\n\ngoal (1 subgoal):\n 1. \\<downharpoonright>arg (z1 * z2)\\<downharpoonleft> =\n    \\<downharpoonright>arg z1 + arg z2\\<downharpoonleft>", "by(simp add:field_simps)"], ["proof (state)\nthis:\n  \\<downharpoonright>arg (z1 * z2)\\<downharpoonleft> =\n  \\<downharpoonright>arg z1 + arg z2\\<downharpoonleft>\n\ngoal (1 subgoal):\n 1. arg (z1 * z2) = \\<downharpoonright>arg z1 + arg z2\\<downharpoonleft>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<downharpoonright>arg (z1 * z2)\\<downharpoonleft> =\n  \\<downharpoonright>arg z1 + arg z2\\<downharpoonleft>\n\ngoal (1 subgoal):\n 1. arg (z1 * z2) = \\<downharpoonright>arg z1 + arg z2\\<downharpoonleft>", "using canon_ang_arg[of \"z1*z2\"]"], ["proof (prove)\nusing this:\n  \\<downharpoonright>arg (z1 * z2)\\<downharpoonleft> =\n  \\<downharpoonright>arg z1 + arg z2\\<downharpoonleft>\n  \\<downharpoonright>arg (z1 * z2)\\<downharpoonleft> = arg (z1 * z2)\n\ngoal (1 subgoal):\n 1. arg (z1 * z2) = \\<downharpoonright>arg z1 + arg z2\\<downharpoonleft>", "by auto"], ["proof (state)\nthis:\n  arg (z1 * z2) = \\<downharpoonright>arg z1 + arg z2\\<downharpoonleft>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arg_mult_real_positive [simp]:\n  assumes \"k > 0\"\n  shows \"arg (cor k * z) = arg z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg (cor k * z) = arg z", "proof (cases \"z = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow> arg (cor k * z) = arg z\n 2. z \\<noteq> 0 \\<Longrightarrow> arg (cor k * z) = arg z", "case True"], ["proof (state)\nthis:\n  z = 0\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow> arg (cor k * z) = arg z\n 2. z \\<noteq> 0 \\<Longrightarrow> arg (cor k * z) = arg z", "thus ?thesis"], ["proof (prove)\nusing this:\n  z = 0\n\ngoal (1 subgoal):\n 1. arg (cor k * z) = arg z", "by (auto simp add: arg_zero)"], ["proof (state)\nthis:\n  arg (cor k * z) = arg z\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> arg (cor k * z) = arg z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> arg (cor k * z) = arg z", "case False"], ["proof (state)\nthis:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> arg (cor k * z) = arg z", "thus ?thesis"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arg (cor k * z) = arg z", "using assms"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n  0 < k\n\ngoal (1 subgoal):\n 1. arg (cor k * z) = arg z", "using arg_mult[of \"cor k\" z]"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n  0 < k\n  cor k * z \\<noteq> 0 \\<Longrightarrow>\n  arg (cor k * z) = \\<downharpoonright>arg (cor k) + arg z\\<downharpoonleft>\n\ngoal (1 subgoal):\n 1. arg (cor k * z) = arg z", "by (auto simp add: canon_ang_arg)"], ["proof (state)\nthis:\n  arg (cor k * z) = arg z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arg_mult_real_negative [simp]:\n  assumes \"k < 0\"\n  shows \"arg (cor k * z) = arg (-z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg (cor k * z) = arg (- z)", "proof (cases \"z = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow> arg (cor k * z) = arg (- z)\n 2. z \\<noteq> 0 \\<Longrightarrow> arg (cor k * z) = arg (- z)", "case True"], ["proof (state)\nthis:\n  z = 0\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow> arg (cor k * z) = arg (- z)\n 2. z \\<noteq> 0 \\<Longrightarrow> arg (cor k * z) = arg (- z)", "thus ?thesis"], ["proof (prove)\nusing this:\n  z = 0\n\ngoal (1 subgoal):\n 1. arg (cor k * z) = arg (- z)", "by (auto simp add: arg_zero)"], ["proof (state)\nthis:\n  arg (cor k * z) = arg (- z)\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> arg (cor k * z) = arg (- z)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> arg (cor k * z) = arg (- z)", "case False"], ["proof (state)\nthis:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> arg (cor k * z) = arg (- z)", "thus ?thesis"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arg (cor k * z) = arg (- z)", "using assms"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n  k < 0\n\ngoal (1 subgoal):\n 1. arg (cor k * z) = arg (- z)", "using arg_mult[of \"cor k\" z]"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n  k < 0\n  cor k * z \\<noteq> 0 \\<Longrightarrow>\n  arg (cor k * z) = \\<downharpoonright>arg (cor k) + arg z\\<downharpoonleft>\n\ngoal (1 subgoal):\n 1. arg (cor k * z) = arg (- z)", "using arg_mult[of \"-1\" z]"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n  k < 0\n  cor k * z \\<noteq> 0 \\<Longrightarrow>\n  arg (cor k * z) = \\<downharpoonright>arg (cor k) + arg z\\<downharpoonleft>\n  - 1 * z \\<noteq> 0 \\<Longrightarrow>\n  arg (- 1 * z) = \\<downharpoonright>arg (- 1) + arg z\\<downharpoonleft>\n\ngoal (1 subgoal):\n 1. arg (cor k * z) = arg (- z)", "using arg_complex_of_real_negative[of k] arg_complex_of_real_negative[of \"-1\"]"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n  k < 0\n  cor k * z \\<noteq> 0 \\<Longrightarrow>\n  arg (cor k * z) = \\<downharpoonright>arg (cor k) + arg z\\<downharpoonleft>\n  - 1 * z \\<noteq> 0 \\<Longrightarrow>\n  arg (- 1 * z) = \\<downharpoonright>arg (- 1) + arg z\\<downharpoonleft>\n  k < 0 \\<Longrightarrow> arg (cor k) = pi\n  - 1 < 0 \\<Longrightarrow> arg (cor (- 1)) = pi\n\ngoal (1 subgoal):\n 1. arg (cor k * z) = arg (- z)", "by auto"], ["proof (state)\nthis:\n  arg (cor k * z) = arg (- z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arg_div_real_positive [simp]:\n  assumes \"k > 0\"\n  shows \"arg (z / cor k) = arg z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg (z / cor k) = arg z", "proof(cases \"z = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow> arg (z / cor k) = arg z\n 2. z \\<noteq> 0 \\<Longrightarrow> arg (z / cor k) = arg z", "case True"], ["proof (state)\nthis:\n  z = 0\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow> arg (z / cor k) = arg z\n 2. z \\<noteq> 0 \\<Longrightarrow> arg (z / cor k) = arg z", "thus ?thesis"], ["proof (prove)\nusing this:\n  z = 0\n\ngoal (1 subgoal):\n 1. arg (z / cor k) = arg z", "by auto"], ["proof (state)\nthis:\n  arg (z / cor k) = arg z\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> arg (z / cor k) = arg z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> arg (z / cor k) = arg z", "case False"], ["proof (state)\nthis:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> arg (z / cor k) = arg z", "thus ?thesis"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arg (z / cor k) = arg z", "using assms"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n  0 < k\n\ngoal (1 subgoal):\n 1. arg (z / cor k) = arg z", "using arg_mult_real_positive[of \"1/k\" z]"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n  0 < k\n  0 < 1 / k \\<Longrightarrow> arg (cor (1 / k) * z) = arg z\n\ngoal (1 subgoal):\n 1. arg (z / cor k) = arg z", "by auto"], ["proof (state)\nthis:\n  arg (z / cor k) = arg z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arg_div_real_negative [simp]:\n  assumes \"k < 0\"\n  shows \"arg (z / cor k) = arg (-z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg (z / cor k) = arg (- z)", "proof(cases \"z = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow> arg (z / cor k) = arg (- z)\n 2. z \\<noteq> 0 \\<Longrightarrow> arg (z / cor k) = arg (- z)", "case True"], ["proof (state)\nthis:\n  z = 0\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow> arg (z / cor k) = arg (- z)\n 2. z \\<noteq> 0 \\<Longrightarrow> arg (z / cor k) = arg (- z)", "thus ?thesis"], ["proof (prove)\nusing this:\n  z = 0\n\ngoal (1 subgoal):\n 1. arg (z / cor k) = arg (- z)", "by auto"], ["proof (state)\nthis:\n  arg (z / cor k) = arg (- z)\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> arg (z / cor k) = arg (- z)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> arg (z / cor k) = arg (- z)", "case False"], ["proof (state)\nthis:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> arg (z / cor k) = arg (- z)", "thus ?thesis"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arg (z / cor k) = arg (- z)", "using assms"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n  k < 0\n\ngoal (1 subgoal):\n 1. arg (z / cor k) = arg (- z)", "using arg_mult_real_negative[of \"1/k\" z]"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n  k < 0\n  1 / k < 0 \\<Longrightarrow> arg (cor (1 / k) * z) = arg (- z)\n\ngoal (1 subgoal):\n 1. arg (z / cor k) = arg (- z)", "by auto"], ["proof (state)\nthis:\n  arg (z / cor k) = arg (- z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arg_mult_eq:\n  assumes \"z * z1 \\<noteq> 0\" and \"z * z2 \\<noteq> 0\"\n  assumes \"arg (z * z1) = arg (z * z2)\"\n  shows \"arg z1 = arg z2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg z1 = arg z2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. arg z1 = arg z2", "from assms"], ["proof (chain)\npicking this:\n  z * z1 \\<noteq> 0\n  z * z2 \\<noteq> 0\n  arg (z * z1) = arg (z * z2)", "have \"\\<downharpoonright>arg z + arg z1\\<downharpoonleft> = \\<downharpoonright>arg z + arg z2\\<downharpoonleft>\""], ["proof (prove)\nusing this:\n  z * z1 \\<noteq> 0\n  z * z2 \\<noteq> 0\n  arg (z * z1) = arg (z * z2)\n\ngoal (1 subgoal):\n 1. \\<downharpoonright>arg z + arg z1\\<downharpoonleft> =\n    \\<downharpoonright>arg z + arg z2\\<downharpoonleft>", "by (simp add: arg_mult)"], ["proof (state)\nthis:\n  \\<downharpoonright>arg z + arg z1\\<downharpoonleft> =\n  \\<downharpoonright>arg z + arg z2\\<downharpoonleft>\n\ngoal (1 subgoal):\n 1. arg z1 = arg z2", "then"], ["proof (chain)\npicking this:\n  \\<downharpoonright>arg z + arg z1\\<downharpoonleft> =\n  \\<downharpoonright>arg z + arg z2\\<downharpoonleft>", "obtain x::int where *: \"arg z1 - arg z2 = 2 * x * pi\""], ["proof (prove)\nusing this:\n  \\<downharpoonright>arg z + arg z1\\<downharpoonleft> =\n  \\<downharpoonright>arg z + arg z2\\<downharpoonleft>\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        arg z1 - arg z2 = real_of_int (2 * x) * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using canon_ang_eqE[of \"arg z + arg z1\" \"arg z + arg z2\"]"], ["proof (prove)\nusing this:\n  \\<downharpoonright>arg z + arg z1\\<downharpoonleft> =\n  \\<downharpoonright>arg z + arg z2\\<downharpoonleft>\n  \\<downharpoonright>arg z + arg z1\\<downharpoonleft> =\n  \\<downharpoonright>arg z + arg z2\\<downharpoonleft> \\<Longrightarrow>\n  \\<exists>x. arg z + arg z1 - (arg z + arg z2) = 2 * real_of_int x * pi\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        arg z1 - arg z2 = real_of_int (2 * x) * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  arg z1 - arg z2 = real_of_int (2 * x) * pi\n\ngoal (1 subgoal):\n 1. arg z1 = arg z2", "moreover"], ["proof (state)\nthis:\n  arg z1 - arg z2 = real_of_int (2 * x) * pi\n\ngoal (1 subgoal):\n 1. arg z1 = arg z2", "have \"arg z1 - arg z2 < 2*pi\" \"arg z1 - arg z2 > -2*pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg z1 - arg z2 < 2 * pi &&& - 2 * pi < arg z1 - arg z2", "using arg_bounded[of z1] arg_bounded[of z2]"], ["proof (prove)\nusing this:\n  - pi < arg z1 \\<and> arg z1 \\<le> pi\n  - pi < arg z2 \\<and> arg z2 \\<le> pi\n\ngoal (1 subgoal):\n 1. arg z1 - arg z2 < 2 * pi &&& - 2 * pi < arg z1 - arg z2", "by auto"], ["proof (state)\nthis:\n  arg z1 - arg z2 < 2 * pi\n  - 2 * pi < arg z1 - arg z2\n\ngoal (1 subgoal):\n 1. arg z1 = arg z2", "ultimately"], ["proof (chain)\npicking this:\n  arg z1 - arg z2 = real_of_int (2 * x) * pi\n  arg z1 - arg z2 < 2 * pi\n  - 2 * pi < arg z1 - arg z2", "have \"-1 < x\" \"x < 1\""], ["proof (prove)\nusing this:\n  arg z1 - arg z2 = real_of_int (2 * x) * pi\n  arg z1 - arg z2 < 2 * pi\n  - 2 * pi < arg z1 - arg z2\n\ngoal (1 subgoal):\n 1. - 1 < x &&& x < 1", "using divide_strict_right_mono[of \"-pi\" \"pi * x\" pi]"], ["proof (prove)\nusing this:\n  arg z1 - arg z2 = real_of_int (2 * x) * pi\n  arg z1 - arg z2 < 2 * pi\n  - 2 * pi < arg z1 - arg z2\n  \\<lbrakk>- pi < pi * real_of_int x; 0 < pi\\<rbrakk>\n  \\<Longrightarrow> - pi / pi < pi * real_of_int x / pi\n\ngoal (1 subgoal):\n 1. - 1 < x &&& x < 1", "by auto"], ["proof (state)\nthis:\n  - 1 < x\n  x < 1\n\ngoal (1 subgoal):\n 1. arg z1 = arg z2", "hence \"x = 0\""], ["proof (prove)\nusing this:\n  - 1 < x\n  x < 1\n\ngoal (1 subgoal):\n 1. x = 0", "by auto"], ["proof (state)\nthis:\n  x = 0\n\ngoal (1 subgoal):\n 1. arg z1 = arg z2", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = 0\n\ngoal (1 subgoal):\n 1. arg z1 = arg z2", "using *"], ["proof (prove)\nusing this:\n  x = 0\n  arg z1 - arg z2 = real_of_int (2 * x) * pi\n\ngoal (1 subgoal):\n 1. arg z1 = arg z2", "by simp"], ["proof (state)\nthis:\n  arg z1 = arg z2\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Argument of conjugate\\<close>"], ["", "lemma arg_cnj_pi:\n  assumes \"arg z = pi\"\n  shows \"arg (cnj z) = pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg (cnj z) = pi", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. arg (cnj z) = pi", "have \"cos (arg (cnj z)) = cos (arg z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (arg (cnj z)) = cos (arg z)", "using rcis_cmod_arg[of z, symmetric] Re_rcis[of \"cmod z\" \"arg z\"]"], ["proof (prove)\nusing this:\n  z = rcis (cmod z) (arg z)\n  Re (rcis (cmod z) (arg z)) = cmod z * cos (arg z)\n\ngoal (1 subgoal):\n 1. cos (arg (cnj z)) = cos (arg z)", "using rcis_cmod_arg[of \"cnj z\", symmetric] Re_rcis[of \"cmod (cnj z)\" \"arg (cnj z)\"]"], ["proof (prove)\nusing this:\n  z = rcis (cmod z) (arg z)\n  Re (rcis (cmod z) (arg z)) = cmod z * cos (arg z)\n  cnj z = rcis (cmod (cnj z)) (arg (cnj z))\n  Re (rcis (cmod (cnj z)) (arg (cnj z))) = cmod (cnj z) * cos (arg (cnj z))\n\ngoal (1 subgoal):\n 1. cos (arg (cnj z)) = cos (arg z)", "by auto"], ["proof (state)\nthis:\n  cos (arg (cnj z)) = cos (arg z)\n\ngoal (1 subgoal):\n 1. arg (cnj z) = pi", "hence \"arg (cnj z) = arg z \\<or> arg(cnj z) = -arg z\""], ["proof (prove)\nusing this:\n  cos (arg (cnj z)) = cos (arg z)\n\ngoal (1 subgoal):\n 1. arg (cnj z) = arg z \\<or> arg (cnj z) = - arg z", "using arg_bounded[of z] arg_bounded[of \"cnj z\"]"], ["proof (prove)\nusing this:\n  cos (arg (cnj z)) = cos (arg z)\n  - pi < arg z \\<and> arg z \\<le> pi\n  - pi < arg (cnj z) \\<and> arg (cnj z) \\<le> pi\n\ngoal (1 subgoal):\n 1. arg (cnj z) = arg z \\<or> arg (cnj z) = - arg z", "by (metis arccos_cos arccos_cos2 less_eq_real_def linorder_le_cases minus_minus)"], ["proof (state)\nthis:\n  arg (cnj z) = arg z \\<or> arg (cnj z) = - arg z\n\ngoal (1 subgoal):\n 1. arg (cnj z) = pi", "thus ?thesis"], ["proof (prove)\nusing this:\n  arg (cnj z) = arg z \\<or> arg (cnj z) = - arg z\n\ngoal (1 subgoal):\n 1. arg (cnj z) = pi", "using assms"], ["proof (prove)\nusing this:\n  arg (cnj z) = arg z \\<or> arg (cnj z) = - arg z\n  arg z = pi\n\ngoal (1 subgoal):\n 1. arg (cnj z) = pi", "using arg_bounded[of \"cnj z\"]"], ["proof (prove)\nusing this:\n  arg (cnj z) = arg z \\<or> arg (cnj z) = - arg z\n  arg z = pi\n  - pi < arg (cnj z) \\<and> arg (cnj z) \\<le> pi\n\ngoal (1 subgoal):\n 1. arg (cnj z) = pi", "by auto"], ["proof (state)\nthis:\n  arg (cnj z) = pi\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arg_cnj_not_pi:\n  assumes \"arg z \\<noteq> pi\"\n  shows \"arg (cnj z) = -arg z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg (cnj z) = - arg z", "proof(cases \"arg z = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. arg z = 0 \\<Longrightarrow> arg (cnj z) = - arg z\n 2. arg z \\<noteq> 0 \\<Longrightarrow> arg (cnj z) = - arg z", "case True"], ["proof (state)\nthis:\n  arg z = 0\n\ngoal (2 subgoals):\n 1. arg z = 0 \\<Longrightarrow> arg (cnj z) = - arg z\n 2. arg z \\<noteq> 0 \\<Longrightarrow> arg (cnj z) = - arg z", "thus ?thesis"], ["proof (prove)\nusing this:\n  arg z = 0\n\ngoal (1 subgoal):\n 1. arg (cnj z) = - arg z", "using eq_cnj_iff_real[of z] is_real_arg1[of z]"], ["proof (prove)\nusing this:\n  arg z = 0\n  (cnj z = z) = is_real z\n  arg z = 0 \\<or> arg z = pi \\<Longrightarrow> is_real z\n\ngoal (1 subgoal):\n 1. arg (cnj z) = - arg z", "by force"], ["proof (state)\nthis:\n  arg (cnj z) = - arg z\n\ngoal (1 subgoal):\n 1. arg z \\<noteq> 0 \\<Longrightarrow> arg (cnj z) = - arg z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. arg z \\<noteq> 0 \\<Longrightarrow> arg (cnj z) = - arg z", "case False"], ["proof (state)\nthis:\n  arg z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arg z \\<noteq> 0 \\<Longrightarrow> arg (cnj z) = - arg z", "have \"cos (arg (cnj z)) = cos (arg z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (arg (cnj z)) = cos (arg z)", "using rcis_cmod_arg[of z] Re_rcis[of \"cmod z\" \"arg z\"]"], ["proof (prove)\nusing this:\n  rcis (cmod z) (arg z) = z\n  Re (rcis (cmod z) (arg z)) = cmod z * cos (arg z)\n\ngoal (1 subgoal):\n 1. cos (arg (cnj z)) = cos (arg z)", "using rcis_cmod_arg[of \"cnj z\"] Re_rcis[of \"cmod (cnj z)\" \"arg (cnj z)\"]"], ["proof (prove)\nusing this:\n  rcis (cmod z) (arg z) = z\n  Re (rcis (cmod z) (arg z)) = cmod z * cos (arg z)\n  rcis (cmod (cnj z)) (arg (cnj z)) = cnj z\n  Re (rcis (cmod (cnj z)) (arg (cnj z))) = cmod (cnj z) * cos (arg (cnj z))\n\ngoal (1 subgoal):\n 1. cos (arg (cnj z)) = cos (arg z)", "by auto"], ["proof (state)\nthis:\n  cos (arg (cnj z)) = cos (arg z)\n\ngoal (1 subgoal):\n 1. arg z \\<noteq> 0 \\<Longrightarrow> arg (cnj z) = - arg z", "hence \"arg (cnj z) = arg z \\<or> arg(cnj z) = -arg z\""], ["proof (prove)\nusing this:\n  cos (arg (cnj z)) = cos (arg z)\n\ngoal (1 subgoal):\n 1. arg (cnj z) = arg z \\<or> arg (cnj z) = - arg z", "using arg_bounded[of z] arg_bounded[of \"cnj z\"]"], ["proof (prove)\nusing this:\n  cos (arg (cnj z)) = cos (arg z)\n  - pi < arg z \\<and> arg z \\<le> pi\n  - pi < arg (cnj z) \\<and> arg (cnj z) \\<le> pi\n\ngoal (1 subgoal):\n 1. arg (cnj z) = arg z \\<or> arg (cnj z) = - arg z", "by (metis arccos_cos arccos_cos2 less_eq_real_def linorder_le_cases minus_minus)"], ["proof (state)\nthis:\n  arg (cnj z) = arg z \\<or> arg (cnj z) = - arg z\n\ngoal (1 subgoal):\n 1. arg z \\<noteq> 0 \\<Longrightarrow> arg (cnj z) = - arg z", "moreover"], ["proof (state)\nthis:\n  arg (cnj z) = arg z \\<or> arg (cnj z) = - arg z\n\ngoal (1 subgoal):\n 1. arg z \\<noteq> 0 \\<Longrightarrow> arg (cnj z) = - arg z", "have \"sin (arg (cnj z)) = -sin (arg z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sin (arg (cnj z)) = - sin (arg z)", "using rcis_cmod_arg[of z] Im_rcis[of \"cmod z\" \"arg z\"]"], ["proof (prove)\nusing this:\n  rcis (cmod z) (arg z) = z\n  Im (rcis (cmod z) (arg z)) = cmod z * sin (arg z)\n\ngoal (1 subgoal):\n 1. sin (arg (cnj z)) = - sin (arg z)", "using rcis_cmod_arg[of \"cnj z\"] Im_rcis[of \"cmod (cnj z)\" \"arg (cnj z)\"]"], ["proof (prove)\nusing this:\n  rcis (cmod z) (arg z) = z\n  Im (rcis (cmod z) (arg z)) = cmod z * sin (arg z)\n  rcis (cmod (cnj z)) (arg (cnj z)) = cnj z\n  Im (rcis (cmod (cnj z)) (arg (cnj z))) = cmod (cnj z) * sin (arg (cnj z))\n\ngoal (1 subgoal):\n 1. sin (arg (cnj z)) = - sin (arg z)", "using calculation eq_cnj_iff_real is_real_arg2"], ["proof (prove)\nusing this:\n  rcis (cmod z) (arg z) = z\n  Im (rcis (cmod z) (arg z)) = cmod z * sin (arg z)\n  rcis (cmod (cnj z)) (arg (cnj z)) = cnj z\n  Im (rcis (cmod (cnj z)) (arg (cnj z))) = cmod (cnj z) * sin (arg (cnj z))\n  arg (cnj z) = arg z \\<or> arg (cnj z) = - arg z\n  (cnj ?z = ?z) = is_real ?z\n  is_real ?z \\<Longrightarrow> arg ?z = 0 \\<or> arg ?z = pi\n\ngoal (1 subgoal):\n 1. sin (arg (cnj z)) = - sin (arg z)", "by force"], ["proof (state)\nthis:\n  sin (arg (cnj z)) = - sin (arg z)\n\ngoal (1 subgoal):\n 1. arg z \\<noteq> 0 \\<Longrightarrow> arg (cnj z) = - arg z", "hence \"arg (cnj z) \\<noteq> arg z\""], ["proof (prove)\nusing this:\n  sin (arg (cnj z)) = - sin (arg z)\n\ngoal (1 subgoal):\n 1. arg (cnj z) \\<noteq> arg z", "using sin_0_iff_canon[of \"arg (cnj z)\"] arg_bounded False assms"], ["proof (prove)\nusing this:\n  sin (arg (cnj z)) = - sin (arg z)\n  \\<lbrakk>sin (arg (cnj z)) = 0; - pi < arg (cnj z);\n   arg (cnj z) \\<le> pi\\<rbrakk>\n  \\<Longrightarrow> arg (cnj z) = 0 \\<or> arg (cnj z) = pi\n  - pi < arg ?z \\<and> arg ?z \\<le> pi\n  arg z \\<noteq> 0\n  arg z \\<noteq> pi\n\ngoal (1 subgoal):\n 1. arg (cnj z) \\<noteq> arg z", "by auto"], ["proof (state)\nthis:\n  arg (cnj z) \\<noteq> arg z\n\ngoal (1 subgoal):\n 1. arg z \\<noteq> 0 \\<Longrightarrow> arg (cnj z) = - arg z", "ultimately"], ["proof (chain)\npicking this:\n  arg (cnj z) = arg z \\<or> arg (cnj z) = - arg z\n  arg (cnj z) \\<noteq> arg z", "show ?thesis"], ["proof (prove)\nusing this:\n  arg (cnj z) = arg z \\<or> arg (cnj z) = - arg z\n  arg (cnj z) \\<noteq> arg z\n\ngoal (1 subgoal):\n 1. arg (cnj z) = - arg z", "by auto"], ["proof (state)\nthis:\n  arg (cnj z) = - arg z\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Argument of reciprocal\\<close>"], ["", "lemma arg_inv_not_pi:\n  assumes \"z \\<noteq> 0\" and \"arg z \\<noteq> pi\"\n  shows \"arg (1 / z) = - arg z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg (1 / z) = - arg z", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. arg (1 / z) = - arg z", "have \"1/z = cnj z / cor ((cmod z)\\<^sup>2 )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / z = cnj z / cor ((cmod z)\\<^sup>2)", "using \\<open>z \\<noteq> 0\\<close> complex_mult_cnj_cmod[of z]"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n  z * cnj z = cor ((cmod z)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. 1 / z = cnj z / cor ((cmod z)\\<^sup>2)", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  1 / z = cnj z / cor ((cmod z)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. arg (1 / z) = - arg z", "thus ?thesis"], ["proof (prove)\nusing this:\n  1 / z = cnj z / cor ((cmod z)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. arg (1 / z) = - arg z", "using arg_div_real_positive[of \"(cmod z)\\<^sup>2\" \"cnj z\"] \\<open>z \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  1 / z = cnj z / cor ((cmod z)\\<^sup>2)\n  0 < (cmod z)\\<^sup>2 \\<Longrightarrow>\n  arg (cnj z / cor ((cmod z)\\<^sup>2)) = arg (cnj z)\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arg (1 / z) = - arg z", "using arg_cnj_not_pi[of z] \\<open>arg z \\<noteq> pi\\<close>"], ["proof (prove)\nusing this:\n  1 / z = cnj z / cor ((cmod z)\\<^sup>2)\n  0 < (cmod z)\\<^sup>2 \\<Longrightarrow>\n  arg (cnj z / cor ((cmod z)\\<^sup>2)) = arg (cnj z)\n  z \\<noteq> 0\n  arg z \\<noteq> pi \\<Longrightarrow> arg (cnj z) = - arg z\n  arg z \\<noteq> pi\n\ngoal (1 subgoal):\n 1. arg (1 / z) = - arg z", "by auto"], ["proof (state)\nthis:\n  arg (1 / z) = - arg z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arg_inv_pi:\n  assumes \"z \\<noteq> 0\" and \"arg z = pi\"\n  shows \"arg (1 / z) = pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg (1 / z) = pi", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. arg (1 / z) = pi", "have \"1/z = cnj z / cor ((cmod z)\\<^sup>2 )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / z = cnj z / cor ((cmod z)\\<^sup>2)", "using \\<open>z \\<noteq> 0\\<close> complex_mult_cnj_cmod[of z]"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n  z * cnj z = cor ((cmod z)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. 1 / z = cnj z / cor ((cmod z)\\<^sup>2)", "by (auto simp add:field_simps)"], ["proof (state)\nthis:\n  1 / z = cnj z / cor ((cmod z)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. arg (1 / z) = pi", "thus ?thesis"], ["proof (prove)\nusing this:\n  1 / z = cnj z / cor ((cmod z)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. arg (1 / z) = pi", "using arg_div_real_positive[of \"(cmod z)\\<^sup>2\" \"cnj z\"] \\<open>z \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  1 / z = cnj z / cor ((cmod z)\\<^sup>2)\n  0 < (cmod z)\\<^sup>2 \\<Longrightarrow>\n  arg (cnj z / cor ((cmod z)\\<^sup>2)) = arg (cnj z)\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arg (1 / z) = pi", "using arg_cnj_pi[of z] \\<open>arg z = pi\\<close>"], ["proof (prove)\nusing this:\n  1 / z = cnj z / cor ((cmod z)\\<^sup>2)\n  0 < (cmod z)\\<^sup>2 \\<Longrightarrow>\n  arg (cnj z / cor ((cmod z)\\<^sup>2)) = arg (cnj z)\n  z \\<noteq> 0\n  arg z = pi \\<Longrightarrow> arg (cnj z) = pi\n  arg z = pi\n\ngoal (1 subgoal):\n 1. arg (1 / z) = pi", "by auto"], ["proof (state)\nthis:\n  arg (1 / z) = pi\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arg_inv_2kpi:\n  assumes \"z \\<noteq> 0\"\n  shows \"\\<exists> k::int. arg (1 / z) = - arg z + 2*k*pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. arg (1 / z) = - arg z + 2 * real_of_int x * pi", "using arg_inv_pi[OF assms]"], ["proof (prove)\nusing this:\n  arg z = pi \\<Longrightarrow> arg (1 / z) = pi\n\ngoal (1 subgoal):\n 1. \\<exists>x. arg (1 / z) = - arg z + 2 * real_of_int x * pi", "using arg_inv_not_pi[OF assms]"], ["proof (prove)\nusing this:\n  arg z = pi \\<Longrightarrow> arg (1 / z) = pi\n  arg z \\<noteq> pi \\<Longrightarrow> arg (1 / z) = - arg z\n\ngoal (1 subgoal):\n 1. \\<exists>x. arg (1 / z) = - arg z + 2 * real_of_int x * pi", "by (cases \"arg z = pi\") (rule_tac x=\"1\" in exI, simp, rule_tac x=\"0\" in exI, simp)"], ["", "lemma arg_inv:\n  assumes \"z \\<noteq> 0\"\n  shows \"arg (1 / z) = \\<downharpoonright>- arg z\\<downharpoonleft>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg (1 / z) = \\<downharpoonright>- arg z\\<downharpoonleft>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. arg (1 / z) = \\<downharpoonright>- arg z\\<downharpoonleft>", "obtain k::int where \"arg(1 / z) = - arg z + 2*k*pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        arg (1 / z) = - arg z + real_of_int (2 * k) * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using arg_inv_2kpi[of z]"], ["proof (prove)\nusing this:\n  z \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>x. arg (1 / z) = - arg z + 2 * real_of_int x * pi\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        arg (1 / z) = - arg z + real_of_int (2 * k) * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  z \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>x. arg (1 / z) = - arg z + 2 * real_of_int x * pi\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        arg (1 / z) = - arg z + real_of_int (2 * k) * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  arg (1 / z) = - arg z + real_of_int (2 * k) * pi\n\ngoal (1 subgoal):\n 1. arg (1 / z) = \\<downharpoonright>- arg z\\<downharpoonleft>", "hence \"\\<downharpoonright>arg(1 / z)\\<downharpoonleft> = \\<downharpoonright>- arg z\\<downharpoonleft>\""], ["proof (prove)\nusing this:\n  arg (1 / z) = - arg z + real_of_int (2 * k) * pi\n\ngoal (1 subgoal):\n 1. \\<downharpoonright>arg (1 / z)\\<downharpoonleft> =\n    \\<downharpoonright>- arg z\\<downharpoonleft>", "using canon_ang_eq"], ["proof (prove)\nusing this:\n  arg (1 / z) = - arg z + real_of_int (2 * k) * pi\n  \\<exists>x.\n     ?\\<alpha>\\<^sub>1 - ?\\<alpha>\\<^sub>2 =\n     2 * real_of_int x * pi \\<Longrightarrow>\n  \\<downharpoonright>?\\<alpha>\\<^sub>1\\<downharpoonleft> =\n  \\<downharpoonright>?\\<alpha>\\<^sub>2\\<downharpoonleft>\n\ngoal (1 subgoal):\n 1. \\<downharpoonright>arg (1 / z)\\<downharpoonleft> =\n    \\<downharpoonright>- arg z\\<downharpoonleft>", "by(simp add:field_simps)"], ["proof (state)\nthis:\n  \\<downharpoonright>arg (1 / z)\\<downharpoonleft> =\n  \\<downharpoonright>- arg z\\<downharpoonleft>\n\ngoal (1 subgoal):\n 1. arg (1 / z) = \\<downharpoonright>- arg z\\<downharpoonleft>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<downharpoonright>arg (1 / z)\\<downharpoonleft> =\n  \\<downharpoonright>- arg z\\<downharpoonleft>\n\ngoal (1 subgoal):\n 1. arg (1 / z) = \\<downharpoonright>- arg z\\<downharpoonleft>", "using canon_ang_arg[of \"1 / z\"]"], ["proof (prove)\nusing this:\n  \\<downharpoonright>arg (1 / z)\\<downharpoonleft> =\n  \\<downharpoonright>- arg z\\<downharpoonleft>\n  \\<downharpoonright>arg (1 / z)\\<downharpoonleft> = arg (1 / z)\n\ngoal (1 subgoal):\n 1. arg (1 / z) = \\<downharpoonright>- arg z\\<downharpoonleft>", "by auto"], ["proof (state)\nthis:\n  arg (1 / z) = \\<downharpoonright>- arg z\\<downharpoonleft>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Argument of quotient\\<close>"], ["", "lemma arg_div_2kpi:\n  assumes \"z1 \\<noteq> 0\" and \"z2 \\<noteq> 0\"\n  shows \"\\<exists> k::int. arg (z1 / z2) = arg z1 - arg z2 + 2*k*pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. arg (z1 / z2) = arg z1 - arg z2 + 2 * real_of_int x * pi", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. arg (z1 / z2) = arg z1 - arg z2 + 2 * real_of_int x * pi", "obtain x1 where \"arg (z1 * (1 / z2)) = arg z1 + arg (1 / z2) + 2 * real_of_int x1 * pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1.\n        arg (z1 * (1 / z2)) =\n        arg z1 + arg (1 / z2) + 2 * real_of_int x1 * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms arg_mult_2kpi[of z1 \"1/z2\"]"], ["proof (prove)\nusing this:\n  z1 \\<noteq> 0\n  z2 \\<noteq> 0\n  z1 * (1 / z2) \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>x.\n     arg (z1 * (1 / z2)) = arg z1 + arg (1 / z2) + 2 * real_of_int x * pi\n\ngoal (1 subgoal):\n 1. (\\<And>x1.\n        arg (z1 * (1 / z2)) =\n        arg z1 + arg (1 / z2) + 2 * real_of_int x1 * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  arg (z1 * (1 / z2)) = arg z1 + arg (1 / z2) + 2 * real_of_int x1 * pi\n\ngoal (1 subgoal):\n 1. \\<exists>x. arg (z1 / z2) = arg z1 - arg z2 + 2 * real_of_int x * pi", "moreover"], ["proof (state)\nthis:\n  arg (z1 * (1 / z2)) = arg z1 + arg (1 / z2) + 2 * real_of_int x1 * pi\n\ngoal (1 subgoal):\n 1. \\<exists>x. arg (z1 / z2) = arg z1 - arg z2 + 2 * real_of_int x * pi", "obtain x2 where \"arg (1 / z2) = - arg z2 + 2 * real_of_int x2 * pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x2.\n        arg (1 / z2) = - arg z2 + 2 * real_of_int x2 * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms arg_inv_2kpi[of z2]"], ["proof (prove)\nusing this:\n  z1 \\<noteq> 0\n  z2 \\<noteq> 0\n  z2 \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>x. arg (1 / z2) = - arg z2 + 2 * real_of_int x * pi\n\ngoal (1 subgoal):\n 1. (\\<And>x2.\n        arg (1 / z2) = - arg z2 + 2 * real_of_int x2 * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  arg (1 / z2) = - arg z2 + 2 * real_of_int x2 * pi\n\ngoal (1 subgoal):\n 1. \\<exists>x. arg (z1 / z2) = arg z1 - arg z2 + 2 * real_of_int x * pi", "ultimately"], ["proof (chain)\npicking this:\n  arg (z1 * (1 / z2)) = arg z1 + arg (1 / z2) + 2 * real_of_int x1 * pi\n  arg (1 / z2) = - arg z2 + 2 * real_of_int x2 * pi", "show ?thesis"], ["proof (prove)\nusing this:\n  arg (z1 * (1 / z2)) = arg z1 + arg (1 / z2) + 2 * real_of_int x1 * pi\n  arg (1 / z2) = - arg z2 + 2 * real_of_int x2 * pi\n\ngoal (1 subgoal):\n 1. \\<exists>x. arg (z1 / z2) = arg z1 - arg z2 + 2 * real_of_int x * pi", "by (rule_tac x=\"x1 + x2\" in exI, simp add: field_simps)"], ["proof (state)\nthis:\n  \\<exists>x. arg (z1 / z2) = arg z1 - arg z2 + 2 * real_of_int x * pi\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arg_div:\n  assumes \"z1 \\<noteq> 0\" and \"z2 \\<noteq> 0\"\n  shows \"arg(z1 / z2) = \\<downharpoonright>arg z1 - arg z2\\<downharpoonleft>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg (z1 / z2) = \\<downharpoonright>arg z1 - arg z2\\<downharpoonleft>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. arg (z1 / z2) = \\<downharpoonright>arg z1 - arg z2\\<downharpoonleft>", "obtain k::int where \"arg(z1 / z2) = arg z1 - arg z2 + 2*k*pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        arg (z1 / z2) =\n        arg z1 - arg z2 + real_of_int (2 * k) * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using arg_div_2kpi[of z1 z2]"], ["proof (prove)\nusing this:\n  \\<lbrakk>z1 \\<noteq> 0; z2 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x.\n                       arg (z1 / z2) =\n                       arg z1 - arg z2 + 2 * real_of_int x * pi\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        arg (z1 / z2) =\n        arg z1 - arg z2 + real_of_int (2 * k) * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>z1 \\<noteq> 0; z2 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x.\n                       arg (z1 / z2) =\n                       arg z1 - arg z2 + 2 * real_of_int x * pi\n  z1 \\<noteq> 0\n  z2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        arg (z1 / z2) =\n        arg z1 - arg z2 + real_of_int (2 * k) * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  arg (z1 / z2) = arg z1 - arg z2 + real_of_int (2 * k) * pi\n\ngoal (1 subgoal):\n 1. arg (z1 / z2) = \\<downharpoonright>arg z1 - arg z2\\<downharpoonleft>", "hence \"canon_ang(arg(z1 / z2)) = canon_ang(arg z1 - arg z2)\""], ["proof (prove)\nusing this:\n  arg (z1 / z2) = arg z1 - arg z2 + real_of_int (2 * k) * pi\n\ngoal (1 subgoal):\n 1. \\<downharpoonright>arg (z1 / z2)\\<downharpoonleft> =\n    \\<downharpoonright>arg z1 - arg z2\\<downharpoonleft>", "using canon_ang_eq"], ["proof (prove)\nusing this:\n  arg (z1 / z2) = arg z1 - arg z2 + real_of_int (2 * k) * pi\n  \\<exists>x.\n     ?\\<alpha>\\<^sub>1 - ?\\<alpha>\\<^sub>2 =\n     2 * real_of_int x * pi \\<Longrightarrow>\n  \\<downharpoonright>?\\<alpha>\\<^sub>1\\<downharpoonleft> =\n  \\<downharpoonright>?\\<alpha>\\<^sub>2\\<downharpoonleft>\n\ngoal (1 subgoal):\n 1. \\<downharpoonright>arg (z1 / z2)\\<downharpoonleft> =\n    \\<downharpoonright>arg z1 - arg z2\\<downharpoonleft>", "by(simp add:field_simps)"], ["proof (state)\nthis:\n  \\<downharpoonright>arg (z1 / z2)\\<downharpoonleft> =\n  \\<downharpoonright>arg z1 - arg z2\\<downharpoonleft>\n\ngoal (1 subgoal):\n 1. arg (z1 / z2) = \\<downharpoonright>arg z1 - arg z2\\<downharpoonleft>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<downharpoonright>arg (z1 / z2)\\<downharpoonleft> =\n  \\<downharpoonright>arg z1 - arg z2\\<downharpoonleft>\n\ngoal (1 subgoal):\n 1. arg (z1 / z2) = \\<downharpoonright>arg z1 - arg z2\\<downharpoonleft>", "using canon_ang_arg[of \"z1/z2\"]"], ["proof (prove)\nusing this:\n  \\<downharpoonright>arg (z1 / z2)\\<downharpoonleft> =\n  \\<downharpoonright>arg z1 - arg z2\\<downharpoonleft>\n  \\<downharpoonright>arg (z1 / z2)\\<downharpoonleft> = arg (z1 / z2)\n\ngoal (1 subgoal):\n 1. arg (z1 / z2) = \\<downharpoonright>arg z1 - arg z2\\<downharpoonleft>", "by auto"], ["proof (state)\nthis:\n  arg (z1 / z2) = \\<downharpoonright>arg z1 - arg z2\\<downharpoonleft>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Argument of opposite\\<close>"], ["", "lemma arg_uminus:\n  assumes \"z \\<noteq> 0\"\n  shows \"arg (-z) = \\<downharpoonright>arg z + pi\\<downharpoonleft>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg (- z) = \\<downharpoonright>arg z + pi\\<downharpoonleft>", "using assms"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arg (- z) = \\<downharpoonright>arg z + pi\\<downharpoonleft>", "using arg_mult[of \"-1\" z]"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n  - 1 * z \\<noteq> 0 \\<Longrightarrow>\n  arg (- 1 * z) = \\<downharpoonright>arg (- 1) + arg z\\<downharpoonleft>\n\ngoal (1 subgoal):\n 1. arg (- z) = \\<downharpoonright>arg z + pi\\<downharpoonleft>", "using arg_complex_of_real_negative[of \"-1\"]"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n  - 1 * z \\<noteq> 0 \\<Longrightarrow>\n  arg (- 1 * z) = \\<downharpoonright>arg (- 1) + arg z\\<downharpoonleft>\n  - 1 < 0 \\<Longrightarrow> arg (cor (- 1)) = pi\n\ngoal (1 subgoal):\n 1. arg (- z) = \\<downharpoonright>arg z + pi\\<downharpoonleft>", "by (auto simp add: field_simps)"], ["", "lemma arg_uminus_opposite_sign:\n  assumes \"z \\<noteq> 0\"\n  shows \"arg z > 0 \\<longleftrightarrow> \\<not> arg (-z) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < arg z) = (\\<not> 0 < arg (- z))", "proof (cases \"arg z = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. arg z = 0 \\<Longrightarrow> (0 < arg z) = (\\<not> 0 < arg (- z))\n 2. arg z \\<noteq> 0 \\<Longrightarrow> (0 < arg z) = (\\<not> 0 < arg (- z))", "case True"], ["proof (state)\nthis:\n  arg z = 0\n\ngoal (2 subgoals):\n 1. arg z = 0 \\<Longrightarrow> (0 < arg z) = (\\<not> 0 < arg (- z))\n 2. arg z \\<noteq> 0 \\<Longrightarrow> (0 < arg z) = (\\<not> 0 < arg (- z))", "thus ?thesis"], ["proof (prove)\nusing this:\n  arg z = 0\n\ngoal (1 subgoal):\n 1. (0 < arg z) = (\\<not> 0 < arg (- z))", "using assms"], ["proof (prove)\nusing this:\n  arg z = 0\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (0 < arg z) = (\\<not> 0 < arg (- z))", "by (simp add: arg_uminus)"], ["proof (state)\nthis:\n  (0 < arg z) = (\\<not> 0 < arg (- z))\n\ngoal (1 subgoal):\n 1. arg z \\<noteq> 0 \\<Longrightarrow> (0 < arg z) = (\\<not> 0 < arg (- z))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. arg z \\<noteq> 0 \\<Longrightarrow> (0 < arg z) = (\\<not> 0 < arg (- z))", "case False"], ["proof (state)\nthis:\n  arg z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arg z \\<noteq> 0 \\<Longrightarrow> (0 < arg z) = (\\<not> 0 < arg (- z))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < arg z) = (\\<not> 0 < arg (- z))", "proof (cases \"arg z > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < arg z \\<Longrightarrow> (0 < arg z) = (\\<not> 0 < arg (- z))\n 2. \\<not> 0 < arg z \\<Longrightarrow> (0 < arg z) = (\\<not> 0 < arg (- z))", "case True"], ["proof (state)\nthis:\n  0 < arg z\n\ngoal (2 subgoals):\n 1. 0 < arg z \\<Longrightarrow> (0 < arg z) = (\\<not> 0 < arg (- z))\n 2. \\<not> 0 < arg z \\<Longrightarrow> (0 < arg z) = (\\<not> 0 < arg (- z))", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < arg z\n\ngoal (1 subgoal):\n 1. (0 < arg z) = (\\<not> 0 < arg (- z))", "using assms"], ["proof (prove)\nusing this:\n  0 < arg z\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (0 < arg z) = (\\<not> 0 < arg (- z))", "using arg_bounded[of z]"], ["proof (prove)\nusing this:\n  0 < arg z\n  z \\<noteq> 0\n  - pi < arg z \\<and> arg z \\<le> pi\n\ngoal (1 subgoal):\n 1. (0 < arg z) = (\\<not> 0 < arg (- z))", "using canon_ang_plus_pi1[of \"arg z\"]"], ["proof (prove)\nusing this:\n  0 < arg z\n  z \\<noteq> 0\n  - pi < arg z \\<and> arg z \\<le> pi\n  \\<lbrakk>0 < arg z; arg z \\<le> 2 * pi\\<rbrakk>\n  \\<Longrightarrow> \\<downharpoonright>arg z + pi\\<downharpoonleft> =\n                    arg z - pi\n\ngoal (1 subgoal):\n 1. (0 < arg z) = (\\<not> 0 < arg (- z))", "by (simp add: arg_uminus)"], ["proof (state)\nthis:\n  (0 < arg z) = (\\<not> 0 < arg (- z))\n\ngoal (1 subgoal):\n 1. \\<not> 0 < arg z \\<Longrightarrow> (0 < arg z) = (\\<not> 0 < arg (- z))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < arg z \\<Longrightarrow> (0 < arg z) = (\\<not> 0 < arg (- z))", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < arg z\n\ngoal (1 subgoal):\n 1. \\<not> 0 < arg z \\<Longrightarrow> (0 < arg z) = (\\<not> 0 < arg (- z))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> 0 < arg z\n\ngoal (1 subgoal):\n 1. (0 < arg z) = (\\<not> 0 < arg (- z))", "using \\<open>arg z \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> 0 < arg z\n  arg z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (0 < arg z) = (\\<not> 0 < arg (- z))", "using assms"], ["proof (prove)\nusing this:\n  \\<not> 0 < arg z\n  arg z \\<noteq> 0\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (0 < arg z) = (\\<not> 0 < arg (- z))", "using arg_bounded[of z]"], ["proof (prove)\nusing this:\n  \\<not> 0 < arg z\n  arg z \\<noteq> 0\n  z \\<noteq> 0\n  - pi < arg z \\<and> arg z \\<le> pi\n\ngoal (1 subgoal):\n 1. (0 < arg z) = (\\<not> 0 < arg (- z))", "using canon_ang_plus_pi2[of \"arg z\"]"], ["proof (prove)\nusing this:\n  \\<not> 0 < arg z\n  arg z \\<noteq> 0\n  z \\<noteq> 0\n  - pi < arg z \\<and> arg z \\<le> pi\n  \\<lbrakk>- 2 * pi < arg z; arg z \\<le> 0\\<rbrakk>\n  \\<Longrightarrow> \\<downharpoonright>arg z + pi\\<downharpoonleft> =\n                    arg z + pi\n\ngoal (1 subgoal):\n 1. (0 < arg z) = (\\<not> 0 < arg (- z))", "by (simp add: arg_uminus)"], ["proof (state)\nthis:\n  (0 < arg z) = (\\<not> 0 < arg (- z))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (0 < arg z) = (\\<not> 0 < arg (- z))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Sign of argument is the same as the sign of the Imaginary part\\<close>"], ["", "lemma arg_Im_sgn:\n  assumes \"\\<not> is_real z\"\n  shows \"sgn (arg z) = sgn (Im z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn (arg z) = sgn (Im z)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. sgn (arg z) = sgn (Im z)", "have \"z \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  Im z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sgn (arg z) = sgn (Im z)", "then"], ["proof (chain)\npicking this:\n  z \\<noteq> 0", "obtain r \\<phi> where polar: \"z = cor r * cis \\<phi>\" \"\\<phi> = arg z\" \"r > 0\""], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>r \\<phi>.\n        \\<lbrakk>z = cor r * cis \\<phi>; \\<phi> = arg z; 0 < r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (smt cmod_cis mult_eq_0_iff norm_ge_zero of_real_0)"], ["proof (state)\nthis:\n  z = cor r * cis \\<phi>\n  \\<phi> = arg z\n  0 < r\n\ngoal (1 subgoal):\n 1. sgn (arg z) = sgn (Im z)", "hence \"Im z = r * sin \\<phi>\""], ["proof (prove)\nusing this:\n  z = cor r * cis \\<phi>\n  \\<phi> = arg z\n  0 < r\n\ngoal (1 subgoal):\n 1. Im z = r * sin \\<phi>", "by (metis Im_mult_real Re_complex_of_real cis.simps(2) Im_complex_of_real)"], ["proof (state)\nthis:\n  Im z = r * sin \\<phi>\n\ngoal (1 subgoal):\n 1. sgn (arg z) = sgn (Im z)", "hence  \"Im z > 0 \\<longleftrightarrow> sin \\<phi> > 0\" \"Im z < 0 \\<longleftrightarrow> sin \\<phi> < 0\""], ["proof (prove)\nusing this:\n  Im z = r * sin \\<phi>\n\ngoal (1 subgoal):\n 1. (0 < Im z) = (0 < sin \\<phi>) &&& (Im z < 0) = (sin \\<phi> < 0)", "using \\<open>r > 0\\<close>"], ["proof (prove)\nusing this:\n  Im z = r * sin \\<phi>\n  0 < r\n\ngoal (1 subgoal):\n 1. (0 < Im z) = (0 < sin \\<phi>) &&& (Im z < 0) = (sin \\<phi> < 0)", "using mult_pos_pos mult_nonneg_nonneg zero_less_mult_pos mult_less_cancel_left"], ["proof (prove)\nusing this:\n  Im z = r * sin \\<phi>\n  0 < r\n  \\<lbrakk>(0::?'a) < ?a; (0::?'a) < ?b\\<rbrakk>\n  \\<Longrightarrow> (0::?'a) < ?a * ?b\n  \\<lbrakk>(0::?'a) \\<le> ?a; (0::?'a) \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> (0::?'a) \\<le> ?a * ?b\n  \\<lbrakk>(0::?'a) < ?a * ?b; (0::?'a) < ?a\\<rbrakk>\n  \\<Longrightarrow> (0::?'a) < ?b\n  (?c * ?a < ?c * ?b) =\n  (((0::?'a) \\<le> ?c \\<longrightarrow> ?a < ?b) \\<and>\n   (?c \\<le> (0::?'a) \\<longrightarrow> ?b < ?a))\n\ngoal (1 subgoal):\n 1. (0 < Im z) = (0 < sin \\<phi>) &&& (Im z < 0) = (sin \\<phi> < 0)", "by smt+"], ["proof (state)\nthis:\n  (0 < Im z) = (0 < sin \\<phi>)\n  (Im z < 0) = (sin \\<phi> < 0)\n\ngoal (1 subgoal):\n 1. sgn (arg z) = sgn (Im z)", "moreover"], ["proof (state)\nthis:\n  (0 < Im z) = (0 < sin \\<phi>)\n  (Im z < 0) = (sin \\<phi> < 0)\n\ngoal (1 subgoal):\n 1. sgn (arg z) = sgn (Im z)", "have \"\\<phi> \\<noteq> pi\" \"\\<phi> \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> \\<noteq> pi &&& \\<phi> \\<noteq> 0", "using \\<open>\\<not> is_real z\\<close> polar cis_pi"], ["proof (prove)\nusing this:\n  Im z \\<noteq> 0\n  z = cor r * cis \\<phi>\n  \\<phi> = arg z\n  0 < r\n  cis pi = - 1\n\ngoal (1 subgoal):\n 1. \\<phi> \\<noteq> pi &&& \\<phi> \\<noteq> 0", "by force+"], ["proof (state)\nthis:\n  \\<phi> \\<noteq> pi\n  \\<phi> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sgn (arg z) = sgn (Im z)", "hence \"sin \\<phi> > 0 \\<longleftrightarrow> \\<phi> > 0\" \"\\<phi> < 0 \\<longleftrightarrow> sin \\<phi> < 0\""], ["proof (prove)\nusing this:\n  \\<phi> \\<noteq> pi\n  \\<phi> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (0 < sin \\<phi>) = (0 < \\<phi>) &&& (\\<phi> < 0) = (sin \\<phi> < 0)", "using \\<open>\\<phi> = arg z\\<close> \\<open>\\<phi> \\<noteq> 0\\<close> \\<open>\\<phi> \\<noteq> pi\\<close>"], ["proof (prove)\nusing this:\n  \\<phi> \\<noteq> pi\n  \\<phi> \\<noteq> 0\n  \\<phi> = arg z\n  \\<phi> \\<noteq> 0\n  \\<phi> \\<noteq> pi\n\ngoal (1 subgoal):\n 1. (0 < sin \\<phi>) = (0 < \\<phi>) &&& (\\<phi> < 0) = (sin \\<phi> < 0)", "using arg_bounded[of z]"], ["proof (prove)\nusing this:\n  \\<phi> \\<noteq> pi\n  \\<phi> \\<noteq> 0\n  \\<phi> = arg z\n  \\<phi> \\<noteq> 0\n  \\<phi> \\<noteq> pi\n  - pi < arg z \\<and> arg z \\<le> pi\n\ngoal (1 subgoal):\n 1. (0 < sin \\<phi>) = (0 < \\<phi>) &&& (\\<phi> < 0) = (sin \\<phi> < 0)", "by (smt sin_gt_zero sin_le_zero sin_pi_minus sin_0_iff_canon sin_ge_zero)+"], ["proof (state)\nthis:\n  (0 < sin \\<phi>) = (0 < \\<phi>)\n  (\\<phi> < 0) = (sin \\<phi> < 0)\n\ngoal (1 subgoal):\n 1. sgn (arg z) = sgn (Im z)", "ultimately"], ["proof (chain)\npicking this:\n  (0 < Im z) = (0 < sin \\<phi>)\n  (Im z < 0) = (sin \\<phi> < 0)\n  (0 < sin \\<phi>) = (0 < \\<phi>)\n  (\\<phi> < 0) = (sin \\<phi> < 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (0 < Im z) = (0 < sin \\<phi>)\n  (Im z < 0) = (sin \\<phi> < 0)\n  (0 < sin \\<phi>) = (0 < \\<phi>)\n  (\\<phi> < 0) = (sin \\<phi> < 0)\n\ngoal (1 subgoal):\n 1. sgn (arg z) = sgn (Im z)", "using \\<open>\\<phi> = arg z\\<close>"], ["proof (prove)\nusing this:\n  (0 < Im z) = (0 < sin \\<phi>)\n  (Im z < 0) = (sin \\<phi> < 0)\n  (0 < sin \\<phi>) = (0 < \\<phi>)\n  (\\<phi> < 0) = (sin \\<phi> < 0)\n  \\<phi> = arg z\n\ngoal (1 subgoal):\n 1. sgn (arg z) = sgn (Im z)", "by auto"], ["proof (state)\nthis:\n  sgn (arg z) = sgn (Im z)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Complex square root\\<close>"], ["", "definition\n  \"ccsqrt z = rcis (sqrt (cmod z)) (arg z / 2)\""], ["", "lemma square_ccsqrt [simp]:\n  shows \"(ccsqrt x)\\<^sup>2 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ccsqrt x)\\<^sup>2 = x", "unfolding ccsqrt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rcis (sqrt (cmod x)) (arg x / 2))\\<^sup>2 = x", "by (subst DeMoivre2) (simp add: rcis_cmod_arg)"], ["", "lemma ex_complex_sqrt:\n  shows \"\\<exists> s::complex. s*s = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s. s * s = z", "unfolding power2_eq_square[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s. s\\<^sup>2 = z", "by (rule_tac x=\"csqrt z\" in exI) simp"], ["", "lemma ccsqrt:\n  assumes \"s * s = z\"\n  shows \"s = ccsqrt z \\<or> s = -ccsqrt z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = ccsqrt z \\<or> s = - ccsqrt z", "proof (cases \"s = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s = 0 \\<Longrightarrow> s = ccsqrt z \\<or> s = - ccsqrt z\n 2. s \\<noteq> 0 \\<Longrightarrow> s = ccsqrt z \\<or> s = - ccsqrt z", "case True"], ["proof (state)\nthis:\n  s = 0\n\ngoal (2 subgoals):\n 1. s = 0 \\<Longrightarrow> s = ccsqrt z \\<or> s = - ccsqrt z\n 2. s \\<noteq> 0 \\<Longrightarrow> s = ccsqrt z \\<or> s = - ccsqrt z", "thus ?thesis"], ["proof (prove)\nusing this:\n  s = 0\n\ngoal (1 subgoal):\n 1. s = ccsqrt z \\<or> s = - ccsqrt z", "using assms"], ["proof (prove)\nusing this:\n  s = 0\n  s * s = z\n\ngoal (1 subgoal):\n 1. s = ccsqrt z \\<or> s = - ccsqrt z", "unfolding ccsqrt_def"], ["proof (prove)\nusing this:\n  s = 0\n  s * s = z\n\ngoal (1 subgoal):\n 1. s = rcis (sqrt (cmod z)) (arg z / 2) \\<or>\n    s = - rcis (sqrt (cmod z)) (arg z / 2)", "by simp"], ["proof (state)\nthis:\n  s = ccsqrt z \\<or> s = - ccsqrt z\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow> s = ccsqrt z \\<or> s = - ccsqrt z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow> s = ccsqrt z \\<or> s = - ccsqrt z", "case False"], ["proof (state)\nthis:\n  s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow> s = ccsqrt z \\<or> s = - ccsqrt z", "then"], ["proof (chain)\npicking this:\n  s \\<noteq> 0", "obtain k::int where \"cmod s * cmod s = cmod z\" \"2 * arg s - arg z = 2*k*pi\""], ["proof (prove)\nusing this:\n  s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>cmod s * cmod s = cmod z;\n         2 * arg s - arg z = real_of_int (2 * k) * pi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  s \\<noteq> 0\n  s * s = z\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>cmod s * cmod s = cmod z;\n         2 * arg s - arg z = real_of_int (2 * k) * pi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rcis_cmod_arg[of z] rcis_cmod_arg[of s]"], ["proof (prove)\nusing this:\n  s \\<noteq> 0\n  s * s = z\n  rcis (cmod z) (arg z) = z\n  rcis (cmod s) (arg s) = s\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>cmod s * cmod s = cmod z;\n         2 * arg s - arg z = real_of_int (2 * k) * pi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using arg_mult[of s s]"], ["proof (prove)\nusing this:\n  s \\<noteq> 0\n  s * s = z\n  rcis (cmod z) (arg z) = z\n  rcis (cmod s) (arg s) = s\n  s * s \\<noteq> 0 \\<Longrightarrow>\n  arg (s * s) = \\<downharpoonright>arg s + arg s\\<downharpoonleft>\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>cmod s * cmod s = cmod z;\n         2 * arg s - arg z = real_of_int (2 * k) * pi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using canon_ang(3)[of \"2*arg s\"]"], ["proof (prove)\nusing this:\n  s \\<noteq> 0\n  s * s = z\n  rcis (cmod z) (arg z) = z\n  rcis (cmod s) (arg s) = s\n  s * s \\<noteq> 0 \\<Longrightarrow>\n  arg (s * s) = \\<downharpoonright>arg s + arg s\\<downharpoonleft>\n  \\<exists>x.\n     2 * arg s - \\<downharpoonright>2 * arg s\\<downharpoonleft> =\n     2 * real_of_int x * pi\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>cmod s * cmod s = cmod z;\n         2 * arg s - arg z = real_of_int (2 * k) * pi\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: norm_mult arg_mult)"], ["proof (state)\nthis:\n  cmod s * cmod s = cmod z\n  2 * arg s - arg z = real_of_int (2 * k) * pi\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow> s = ccsqrt z \\<or> s = - ccsqrt z", "have *: \"sqrt (cmod z) = cmod s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (cmod z) = cmod s", "using \\<open>cmod s * cmod s = cmod z\\<close>"], ["proof (prove)\nusing this:\n  cmod s * cmod s = cmod z\n\ngoal (1 subgoal):\n 1. sqrt (cmod z) = cmod s", "by (smt norm_not_less_zero real_sqrt_abs2)"], ["proof (state)\nthis:\n  sqrt (cmod z) = cmod s\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow> s = ccsqrt z \\<or> s = - ccsqrt z", "have **: \"arg z / 2 = arg s - k*pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg z / 2 = arg s - real_of_int k * pi", "using \\<open>2 * arg s - arg z = 2*k*pi\\<close>"], ["proof (prove)\nusing this:\n  2 * arg s - arg z = real_of_int (2 * k) * pi\n\ngoal (1 subgoal):\n 1. arg z / 2 = arg s - real_of_int k * pi", "by simp"], ["proof (state)\nthis:\n  arg z / 2 = arg s - real_of_int k * pi\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow> s = ccsqrt z \\<or> s = - ccsqrt z", "have \"cis (arg s - k*pi) = cis (arg s) \\<or> cis (arg s - k*pi) = -cis (arg s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (arg s - real_of_int k * pi) = cis (arg s) \\<or>\n    cis (arg s - real_of_int k * pi) = - cis (arg s)", "proof (cases \"even k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. even k \\<Longrightarrow>\n    cis (arg s - real_of_int k * pi) = cis (arg s) \\<or>\n    cis (arg s - real_of_int k * pi) = - cis (arg s)\n 2. odd k \\<Longrightarrow>\n    cis (arg s - real_of_int k * pi) = cis (arg s) \\<or>\n    cis (arg s - real_of_int k * pi) = - cis (arg s)", "case True"], ["proof (state)\nthis:\n  even k\n\ngoal (2 subgoals):\n 1. even k \\<Longrightarrow>\n    cis (arg s - real_of_int k * pi) = cis (arg s) \\<or>\n    cis (arg s - real_of_int k * pi) = - cis (arg s)\n 2. odd k \\<Longrightarrow>\n    cis (arg s - real_of_int k * pi) = cis (arg s) \\<or>\n    cis (arg s - real_of_int k * pi) = - cis (arg s)", "hence \"cis (arg s - k*pi) = cis (arg s)\""], ["proof (prove)\nusing this:\n  even k\n\ngoal (1 subgoal):\n 1. cis (arg s - real_of_int k * pi) = cis (arg s)", "by (simp add: cis_def complex.corec cos_diff sin_diff)"], ["proof (state)\nthis:\n  cis (arg s - real_of_int k * pi) = cis (arg s)\n\ngoal (2 subgoals):\n 1. even k \\<Longrightarrow>\n    cis (arg s - real_of_int k * pi) = cis (arg s) \\<or>\n    cis (arg s - real_of_int k * pi) = - cis (arg s)\n 2. odd k \\<Longrightarrow>\n    cis (arg s - real_of_int k * pi) = cis (arg s) \\<or>\n    cis (arg s - real_of_int k * pi) = - cis (arg s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  cis (arg s - real_of_int k * pi) = cis (arg s)\n\ngoal (1 subgoal):\n 1. cis (arg s - real_of_int k * pi) = cis (arg s) \\<or>\n    cis (arg s - real_of_int k * pi) = - cis (arg s)", "by simp"], ["proof (state)\nthis:\n  cis (arg s - real_of_int k * pi) = cis (arg s) \\<or>\n  cis (arg s - real_of_int k * pi) = - cis (arg s)\n\ngoal (1 subgoal):\n 1. odd k \\<Longrightarrow>\n    cis (arg s - real_of_int k * pi) = cis (arg s) \\<or>\n    cis (arg s - real_of_int k * pi) = - cis (arg s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. odd k \\<Longrightarrow>\n    cis (arg s - real_of_int k * pi) = cis (arg s) \\<or>\n    cis (arg s - real_of_int k * pi) = - cis (arg s)", "case False"], ["proof (state)\nthis:\n  odd k\n\ngoal (1 subgoal):\n 1. odd k \\<Longrightarrow>\n    cis (arg s - real_of_int k * pi) = cis (arg s) \\<or>\n    cis (arg s - real_of_int k * pi) = - cis (arg s)", "hence \"cis (arg s - k*pi) = -cis (arg s)\""], ["proof (prove)\nusing this:\n  odd k\n\ngoal (1 subgoal):\n 1. cis (arg s - real_of_int k * pi) = - cis (arg s)", "by (simp add: cis_def complex.corec Complex_eq cos_diff sin_diff)"], ["proof (state)\nthis:\n  cis (arg s - real_of_int k * pi) = - cis (arg s)\n\ngoal (1 subgoal):\n 1. odd k \\<Longrightarrow>\n    cis (arg s - real_of_int k * pi) = cis (arg s) \\<or>\n    cis (arg s - real_of_int k * pi) = - cis (arg s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  cis (arg s - real_of_int k * pi) = - cis (arg s)\n\ngoal (1 subgoal):\n 1. cis (arg s - real_of_int k * pi) = cis (arg s) \\<or>\n    cis (arg s - real_of_int k * pi) = - cis (arg s)", "by simp"], ["proof (state)\nthis:\n  cis (arg s - real_of_int k * pi) = cis (arg s) \\<or>\n  cis (arg s - real_of_int k * pi) = - cis (arg s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cis (arg s - real_of_int k * pi) = cis (arg s) \\<or>\n  cis (arg s - real_of_int k * pi) = - cis (arg s)\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0 \\<Longrightarrow> s = ccsqrt z \\<or> s = - ccsqrt z", "thus ?thesis"], ["proof (prove)\nusing this:\n  cis (arg s - real_of_int k * pi) = cis (arg s) \\<or>\n  cis (arg s - real_of_int k * pi) = - cis (arg s)\n\ngoal (1 subgoal):\n 1. s = ccsqrt z \\<or> s = - ccsqrt z", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. cis (arg s - real_of_int k * pi) = cis (arg s) \\<Longrightarrow>\n    s = ccsqrt z \\<or> s = - ccsqrt z\n 2. cis (arg s - real_of_int k * pi) = - cis (arg s) \\<Longrightarrow>\n    s = ccsqrt z \\<or> s = - ccsqrt z", "assume ***: \"cis (arg s - k * pi) = cis (arg s)\""], ["proof (state)\nthis:\n  cis (arg s - real_of_int k * pi) = cis (arg s)\n\ngoal (2 subgoals):\n 1. cis (arg s - real_of_int k * pi) = cis (arg s) \\<Longrightarrow>\n    s = ccsqrt z \\<or> s = - ccsqrt z\n 2. cis (arg s - real_of_int k * pi) = - cis (arg s) \\<Longrightarrow>\n    s = ccsqrt z \\<or> s = - ccsqrt z", "hence \"s = ccsqrt z\""], ["proof (prove)\nusing this:\n  cis (arg s - real_of_int k * pi) = cis (arg s)\n\ngoal (1 subgoal):\n 1. s = ccsqrt z", "using rcis_cmod_arg[of s]"], ["proof (prove)\nusing this:\n  cis (arg s - real_of_int k * pi) = cis (arg s)\n  rcis (cmod s) (arg s) = s\n\ngoal (1 subgoal):\n 1. s = ccsqrt z", "unfolding ccsqrt_def rcis_def"], ["proof (prove)\nusing this:\n  cis (arg s - real_of_int k * pi) = cis (arg s)\n  cor (cmod s) * cis (arg s) = s\n\ngoal (1 subgoal):\n 1. s = cor (sqrt (cmod z)) * cis (arg z / 2)", "by (subst *, subst **, subst ***, simp)"], ["proof (state)\nthis:\n  s = ccsqrt z\n\ngoal (2 subgoals):\n 1. cis (arg s - real_of_int k * pi) = cis (arg s) \\<Longrightarrow>\n    s = ccsqrt z \\<or> s = - ccsqrt z\n 2. cis (arg s - real_of_int k * pi) = - cis (arg s) \\<Longrightarrow>\n    s = ccsqrt z \\<or> s = - ccsqrt z", "thus ?thesis"], ["proof (prove)\nusing this:\n  s = ccsqrt z\n\ngoal (1 subgoal):\n 1. s = ccsqrt z \\<or> s = - ccsqrt z", "by simp"], ["proof (state)\nthis:\n  s = ccsqrt z \\<or> s = - ccsqrt z\n\ngoal (1 subgoal):\n 1. cis (arg s - real_of_int k * pi) = - cis (arg s) \\<Longrightarrow>\n    s = ccsqrt z \\<or> s = - ccsqrt z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cis (arg s - real_of_int k * pi) = - cis (arg s) \\<Longrightarrow>\n    s = ccsqrt z \\<or> s = - ccsqrt z", "assume ***: \"cis (arg s - k * pi) = -cis (arg s)\""], ["proof (state)\nthis:\n  cis (arg s - real_of_int k * pi) = - cis (arg s)\n\ngoal (1 subgoal):\n 1. cis (arg s - real_of_int k * pi) = - cis (arg s) \\<Longrightarrow>\n    s = ccsqrt z \\<or> s = - ccsqrt z", "hence \"s = - ccsqrt z\""], ["proof (prove)\nusing this:\n  cis (arg s - real_of_int k * pi) = - cis (arg s)\n\ngoal (1 subgoal):\n 1. s = - ccsqrt z", "using rcis_cmod_arg[of s]"], ["proof (prove)\nusing this:\n  cis (arg s - real_of_int k * pi) = - cis (arg s)\n  rcis (cmod s) (arg s) = s\n\ngoal (1 subgoal):\n 1. s = - ccsqrt z", "unfolding ccsqrt_def rcis_def"], ["proof (prove)\nusing this:\n  cis (arg s - real_of_int k * pi) = - cis (arg s)\n  cor (cmod s) * cis (arg s) = s\n\ngoal (1 subgoal):\n 1. s = - (cor (sqrt (cmod z)) * cis (arg z / 2))", "by (subst *, subst **, subst ***, simp)"], ["proof (state)\nthis:\n  s = - ccsqrt z\n\ngoal (1 subgoal):\n 1. cis (arg s - real_of_int k * pi) = - cis (arg s) \\<Longrightarrow>\n    s = ccsqrt z \\<or> s = - ccsqrt z", "thus ?thesis"], ["proof (prove)\nusing this:\n  s = - ccsqrt z\n\ngoal (1 subgoal):\n 1. s = ccsqrt z \\<or> s = - ccsqrt z", "by simp"], ["proof (state)\nthis:\n  s = ccsqrt z \\<or> s = - ccsqrt z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s = ccsqrt z \\<or> s = - ccsqrt z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma null_ccsqrt [simp]:\n  shows \"ccsqrt x = 0 \\<longleftrightarrow> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ccsqrt x = 0) = (x = 0)", "unfolding ccsqrt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rcis (sqrt (cmod x)) (arg x / 2) = 0) = (x = 0)", "by auto"], ["", "lemma ccsqrt_mult:\n  shows \"ccsqrt (a * b) = ccsqrt a * ccsqrt b \\<or>\n         ccsqrt (a * b) = - ccsqrt a * ccsqrt b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccsqrt (a * b) = ccsqrt a * ccsqrt b \\<or>\n    ccsqrt (a * b) = - ccsqrt a * ccsqrt b", "proof (cases \"a = 0 \\<or> b = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = 0 \\<or> b = 0 \\<Longrightarrow>\n    ccsqrt (a * b) = ccsqrt a * ccsqrt b \\<or>\n    ccsqrt (a * b) = - ccsqrt a * ccsqrt b\n 2. \\<not> (a = 0 \\<or> b = 0) \\<Longrightarrow>\n    ccsqrt (a * b) = ccsqrt a * ccsqrt b \\<or>\n    ccsqrt (a * b) = - ccsqrt a * ccsqrt b", "case True"], ["proof (state)\nthis:\n  a = 0 \\<or> b = 0\n\ngoal (2 subgoals):\n 1. a = 0 \\<or> b = 0 \\<Longrightarrow>\n    ccsqrt (a * b) = ccsqrt a * ccsqrt b \\<or>\n    ccsqrt (a * b) = - ccsqrt a * ccsqrt b\n 2. \\<not> (a = 0 \\<or> b = 0) \\<Longrightarrow>\n    ccsqrt (a * b) = ccsqrt a * ccsqrt b \\<or>\n    ccsqrt (a * b) = - ccsqrt a * ccsqrt b", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = 0 \\<or> b = 0\n\ngoal (1 subgoal):\n 1. ccsqrt (a * b) = ccsqrt a * ccsqrt b \\<or>\n    ccsqrt (a * b) = - ccsqrt a * ccsqrt b", "by auto"], ["proof (state)\nthis:\n  ccsqrt (a * b) = ccsqrt a * ccsqrt b \\<or>\n  ccsqrt (a * b) = - ccsqrt a * ccsqrt b\n\ngoal (1 subgoal):\n 1. \\<not> (a = 0 \\<or> b = 0) \\<Longrightarrow>\n    ccsqrt (a * b) = ccsqrt a * ccsqrt b \\<or>\n    ccsqrt (a * b) = - ccsqrt a * ccsqrt b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (a = 0 \\<or> b = 0) \\<Longrightarrow>\n    ccsqrt (a * b) = ccsqrt a * ccsqrt b \\<or>\n    ccsqrt (a * b) = - ccsqrt a * ccsqrt b", "case False"], ["proof (state)\nthis:\n  \\<not> (a = 0 \\<or> b = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (a = 0 \\<or> b = 0) \\<Longrightarrow>\n    ccsqrt (a * b) = ccsqrt a * ccsqrt b \\<or>\n    ccsqrt (a * b) = - ccsqrt a * ccsqrt b", "obtain k::int where \"arg a + arg b - \\<downharpoonright>arg a + arg b\\<downharpoonleft> = 2 * real_of_int k * pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        arg a + arg b - \\<downharpoonright>arg a + arg b\\<downharpoonleft> =\n        2 * real_of_int k * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using canon_ang(3)[of \"arg a + arg b\"]"], ["proof (prove)\nusing this:\n  \\<exists>x.\n     arg a + arg b - \\<downharpoonright>arg a + arg b\\<downharpoonleft> =\n     2 * real_of_int x * pi\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        arg a + arg b - \\<downharpoonright>arg a + arg b\\<downharpoonleft> =\n        2 * real_of_int k * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  arg a + arg b - \\<downharpoonright>arg a + arg b\\<downharpoonleft> =\n  2 * real_of_int k * pi\n\ngoal (1 subgoal):\n 1. \\<not> (a = 0 \\<or> b = 0) \\<Longrightarrow>\n    ccsqrt (a * b) = ccsqrt a * ccsqrt b \\<or>\n    ccsqrt (a * b) = - ccsqrt a * ccsqrt b", "hence *: \"\\<downharpoonright>arg a + arg b\\<downharpoonleft> = arg a + arg b - 2 * (real_of_int k) * pi\""], ["proof (prove)\nusing this:\n  arg a + arg b - \\<downharpoonright>arg a + arg b\\<downharpoonleft> =\n  2 * real_of_int k * pi\n\ngoal (1 subgoal):\n 1. \\<downharpoonright>arg a + arg b\\<downharpoonleft> =\n    arg a + arg b - 2 * real_of_int k * pi", "by (auto simp add: field_simps)"], ["proof (state)\nthis:\n  \\<downharpoonright>arg a + arg b\\<downharpoonleft> =\n  arg a + arg b - 2 * real_of_int k * pi\n\ngoal (1 subgoal):\n 1. \\<not> (a = 0 \\<or> b = 0) \\<Longrightarrow>\n    ccsqrt (a * b) = ccsqrt a * ccsqrt b \\<or>\n    ccsqrt (a * b) = - ccsqrt a * ccsqrt b", "have \"cis (\\<downharpoonright>arg a + arg b\\<downharpoonleft> / 2) = cis (arg a / 2 + arg b / 2) \\<or> cis (\\<downharpoonright>arg a + arg b\\<downharpoonleft> / 2) = - cis (arg a / 2 + arg b / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (\\<downharpoonright>arg a + arg b\\<downharpoonleft> / 2) =\n    cis (arg a / 2 + arg b / 2) \\<or>\n    cis (\\<downharpoonright>arg a + arg b\\<downharpoonleft> / 2) =\n    - cis (arg a / 2 + arg b / 2)", "using cos_even_kpi[of k] cos_odd_kpi[of k]"], ["proof (prove)\nusing this:\n  even k \\<Longrightarrow> cos (real_of_int k * pi) = 1\n  odd k \\<Longrightarrow> cos (real_of_int k * pi) = - 1\n\ngoal (1 subgoal):\n 1. cis (\\<downharpoonright>arg a + arg b\\<downharpoonleft> / 2) =\n    cis (arg a / 2 + arg b / 2) \\<or>\n    cis (\\<downharpoonright>arg a + arg b\\<downharpoonleft> / 2) =\n    - cis (arg a / 2 + arg b / 2)", "by ((subst *)+, (subst diff_divide_distrib)+, (subst add_divide_distrib)+)\n       (cases \"even k\", auto simp add: cis_def complex.corec Complex_eq cos_diff sin_diff)"], ["proof (state)\nthis:\n  cis (\\<downharpoonright>arg a + arg b\\<downharpoonleft> / 2) =\n  cis (arg a / 2 + arg b / 2) \\<or>\n  cis (\\<downharpoonright>arg a + arg b\\<downharpoonleft> / 2) =\n  - cis (arg a / 2 + arg b / 2)\n\ngoal (1 subgoal):\n 1. \\<not> (a = 0 \\<or> b = 0) \\<Longrightarrow>\n    ccsqrt (a * b) = ccsqrt a * ccsqrt b \\<or>\n    ccsqrt (a * b) = - ccsqrt a * ccsqrt b", "thus ?thesis"], ["proof (prove)\nusing this:\n  cis (\\<downharpoonright>arg a + arg b\\<downharpoonleft> / 2) =\n  cis (arg a / 2 + arg b / 2) \\<or>\n  cis (\\<downharpoonright>arg a + arg b\\<downharpoonleft> / 2) =\n  - cis (arg a / 2 + arg b / 2)\n\ngoal (1 subgoal):\n 1. ccsqrt (a * b) = ccsqrt a * ccsqrt b \\<or>\n    ccsqrt (a * b) = - ccsqrt a * ccsqrt b", "using False"], ["proof (prove)\nusing this:\n  cis (\\<downharpoonright>arg a + arg b\\<downharpoonleft> / 2) =\n  cis (arg a / 2 + arg b / 2) \\<or>\n  cis (\\<downharpoonright>arg a + arg b\\<downharpoonleft> / 2) =\n  - cis (arg a / 2 + arg b / 2)\n  \\<not> (a = 0 \\<or> b = 0)\n\ngoal (1 subgoal):\n 1. ccsqrt (a * b) = ccsqrt a * ccsqrt b \\<or>\n    ccsqrt (a * b) = - ccsqrt a * ccsqrt b", "unfolding ccsqrt_def"], ["proof (prove)\nusing this:\n  cis (\\<downharpoonright>arg a + arg b\\<downharpoonleft> / 2) =\n  cis (arg a / 2 + arg b / 2) \\<or>\n  cis (\\<downharpoonright>arg a + arg b\\<downharpoonleft> / 2) =\n  - cis (arg a / 2 + arg b / 2)\n  \\<not> (a = 0 \\<or> b = 0)\n\ngoal (1 subgoal):\n 1. rcis (sqrt (cmod (a * b))) (arg (a * b) / 2) =\n    rcis (sqrt (cmod a)) (arg a / 2) *\n    rcis (sqrt (cmod b)) (arg b / 2) \\<or>\n    rcis (sqrt (cmod (a * b))) (arg (a * b) / 2) =\n    - rcis (sqrt (cmod a)) (arg a / 2) * rcis (sqrt (cmod b)) (arg b / 2)", "by (simp add: rcis_mult real_sqrt_mult arg_mult)\n       (auto simp add: rcis_def)"], ["proof (state)\nthis:\n  ccsqrt (a * b) = ccsqrt a * ccsqrt b \\<or>\n  ccsqrt (a * b) = - ccsqrt a * ccsqrt b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma csqrt_real:\n  assumes \"is_real x\"\n  shows \"(Re x \\<ge> 0 \\<and> ccsqrt x = cor (sqrt (Re x))) \\<or>\n         (Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- (Re x))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))", "case True"], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))", "by auto"], ["proof (state)\nthis:\n  0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n  Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))", "case False"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))", "proof (cases \"Re x > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < Re x \\<Longrightarrow>\n    0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))\n 2. \\<not> 0 < Re x \\<Longrightarrow>\n    0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))", "case True"], ["proof (state)\nthis:\n  0 < Re x\n\ngoal (2 subgoals):\n 1. 0 < Re x \\<Longrightarrow>\n    0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))\n 2. \\<not> 0 < Re x \\<Longrightarrow>\n    0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))", "hence \"arg x = 0\""], ["proof (prove)\nusing this:\n  0 < Re x\n\ngoal (1 subgoal):\n 1. arg x = 0", "using \\<open>is_real x\\<close>"], ["proof (prove)\nusing this:\n  0 < Re x\n  is_real x\n\ngoal (1 subgoal):\n 1. arg x = 0", "by (metis arg_complex_of_real_positive complex_of_real_Re)"], ["proof (state)\nthis:\n  arg x = 0\n\ngoal (2 subgoals):\n 1. 0 < Re x \\<Longrightarrow>\n    0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))\n 2. \\<not> 0 < Re x \\<Longrightarrow>\n    0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))", "thus ?thesis"], ["proof (prove)\nusing this:\n  arg x = 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))", "using \\<open>Re x > 0\\<close> \\<open>is_real x\\<close>"], ["proof (prove)\nusing this:\n  arg x = 0\n  0 < Re x\n  is_real x\n\ngoal (1 subgoal):\n 1. 0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))", "unfolding ccsqrt_def"], ["proof (prove)\nusing this:\n  arg x = 0\n  0 < Re x\n  is_real x\n\ngoal (1 subgoal):\n 1. 0 \\<le> Re x \\<and>\n    rcis (sqrt (cmod x)) (arg x / 2) = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and>\n    rcis (sqrt (cmod x)) (arg x / 2) = \\<i> * cor (sqrt (- Re x))", "by (simp add: cmod_eq_Re)"], ["proof (state)\nthis:\n  0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n  Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))\n\ngoal (1 subgoal):\n 1. \\<not> 0 < Re x \\<Longrightarrow>\n    0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < Re x \\<Longrightarrow>\n    0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < Re x\n\ngoal (1 subgoal):\n 1. \\<not> 0 < Re x \\<Longrightarrow>\n    0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))", "hence \"Re x < 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 < Re x\n\ngoal (1 subgoal):\n 1. Re x < 0", "using \\<open>x \\<noteq> 0\\<close> \\<open>is_real x\\<close>"], ["proof (prove)\nusing this:\n  \\<not> 0 < Re x\n  x \\<noteq> 0\n  is_real x\n\ngoal (1 subgoal):\n 1. Re x < 0", "using complex_eq_if_Re_eq"], ["proof (prove)\nusing this:\n  \\<not> 0 < Re x\n  x \\<noteq> 0\n  is_real x\n  \\<lbrakk>is_real ?z1.0; is_real ?z2.0\\<rbrakk>\n  \\<Longrightarrow> (?z1.0 = ?z2.0) = (Re ?z1.0 = Re ?z2.0)\n\ngoal (1 subgoal):\n 1. Re x < 0", "by auto"], ["proof (state)\nthis:\n  Re x < 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < Re x \\<Longrightarrow>\n    0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))", "hence \"arg x = pi\""], ["proof (prove)\nusing this:\n  Re x < 0\n\ngoal (1 subgoal):\n 1. arg x = pi", "using \\<open>is_real x\\<close>"], ["proof (prove)\nusing this:\n  Re x < 0\n  is_real x\n\ngoal (1 subgoal):\n 1. arg x = pi", "by (metis arg_complex_of_real_negative complex_of_real_Re)"], ["proof (state)\nthis:\n  arg x = pi\n\ngoal (1 subgoal):\n 1. \\<not> 0 < Re x \\<Longrightarrow>\n    0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))", "thus ?thesis"], ["proof (prove)\nusing this:\n  arg x = pi\n\ngoal (1 subgoal):\n 1. 0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))", "using \\<open>Re x < 0\\<close> \\<open>is_real x\\<close>"], ["proof (prove)\nusing this:\n  arg x = pi\n  Re x < 0\n  is_real x\n\ngoal (1 subgoal):\n 1. 0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))", "unfolding ccsqrt_def rcis_def"], ["proof (prove)\nusing this:\n  arg x = pi\n  Re x < 0\n  is_real x\n\ngoal (1 subgoal):\n 1. 0 \\<le> Re x \\<and>\n    cor (sqrt (cmod x)) * cis (arg x / 2) = cor (sqrt (Re x)) \\<or>\n    Re x < 0 \\<and>\n    cor (sqrt (cmod x)) * cis (arg x / 2) = \\<i> * cor (sqrt (- Re x))", "by (simp add: cis_def complex.corec Complex_eq cmod_eq_Re)"], ["proof (state)\nthis:\n  0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n  Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> Re x \\<and> ccsqrt x = cor (sqrt (Re x)) \\<or>\n  Re x < 0 \\<and> ccsqrt x = \\<i> * cor (sqrt (- Re x))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Rotation of complex vector to x-axis.\\<close>"], ["", "lemma is_real_rot_to_x_axis:\n  assumes \"z \\<noteq> 0\"\n  shows \"is_real (cis (-arg z) * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real (cis (- arg z) * z)", "proof (cases \"arg z = pi\")"], ["proof (state)\ngoal (2 subgoals):\n 1. arg z = pi \\<Longrightarrow> is_real (cis (- arg z) * z)\n 2. arg z \\<noteq> pi \\<Longrightarrow> is_real (cis (- arg z) * z)", "case True"], ["proof (state)\nthis:\n  arg z = pi\n\ngoal (2 subgoals):\n 1. arg z = pi \\<Longrightarrow> is_real (cis (- arg z) * z)\n 2. arg z \\<noteq> pi \\<Longrightarrow> is_real (cis (- arg z) * z)", "thus ?thesis"], ["proof (prove)\nusing this:\n  arg z = pi\n\ngoal (1 subgoal):\n 1. is_real (cis (- arg z) * z)", "using is_real_arg1[of z]"], ["proof (prove)\nusing this:\n  arg z = pi\n  arg z = 0 \\<or> arg z = pi \\<Longrightarrow> is_real z\n\ngoal (1 subgoal):\n 1. is_real (cis (- arg z) * z)", "by auto"], ["proof (state)\nthis:\n  is_real (cis (- arg z) * z)\n\ngoal (1 subgoal):\n 1. arg z \\<noteq> pi \\<Longrightarrow> is_real (cis (- arg z) * z)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. arg z \\<noteq> pi \\<Longrightarrow> is_real (cis (- arg z) * z)", "case False"], ["proof (state)\nthis:\n  arg z \\<noteq> pi\n\ngoal (1 subgoal):\n 1. arg z \\<noteq> pi \\<Longrightarrow> is_real (cis (- arg z) * z)", "hence \"\\<downharpoonright>- arg z\\<downharpoonleft> = - arg z\""], ["proof (prove)\nusing this:\n  arg z \\<noteq> pi\n\ngoal (1 subgoal):\n 1. \\<downharpoonright>- arg z\\<downharpoonleft> = - arg z", "using canon_ang_eqI[of \"- arg z\" \"-arg z\"]"], ["proof (prove)\nusing this:\n  arg z \\<noteq> pi\n  \\<lbrakk>\\<exists>x. - arg z - - arg z = 2 * real_of_int x * pi;\n   - pi < - arg z \\<and> - arg z \\<le> pi\\<rbrakk>\n  \\<Longrightarrow> \\<downharpoonright>- arg z\\<downharpoonleft> = - arg z\n\ngoal (1 subgoal):\n 1. \\<downharpoonright>- arg z\\<downharpoonleft> = - arg z", "using arg_bounded[of z]"], ["proof (prove)\nusing this:\n  arg z \\<noteq> pi\n  \\<lbrakk>\\<exists>x. - arg z - - arg z = 2 * real_of_int x * pi;\n   - pi < - arg z \\<and> - arg z \\<le> pi\\<rbrakk>\n  \\<Longrightarrow> \\<downharpoonright>- arg z\\<downharpoonleft> = - arg z\n  - pi < arg z \\<and> arg z \\<le> pi\n\ngoal (1 subgoal):\n 1. \\<downharpoonright>- arg z\\<downharpoonleft> = - arg z", "by (auto simp add: field_simps)"], ["proof (state)\nthis:\n  \\<downharpoonright>- arg z\\<downharpoonleft> = - arg z\n\ngoal (1 subgoal):\n 1. arg z \\<noteq> pi \\<Longrightarrow> is_real (cis (- arg z) * z)", "hence \"arg (cis (- (arg z)) * z) = 0\""], ["proof (prove)\nusing this:\n  \\<downharpoonright>- arg z\\<downharpoonleft> = - arg z\n\ngoal (1 subgoal):\n 1. arg (cis (- arg z) * z) = 0", "using arg_mult[of \"cis (- (arg z))\" z] \\<open>z \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  \\<downharpoonright>- arg z\\<downharpoonleft> = - arg z\n  cis (- arg z) * z \\<noteq> 0 \\<Longrightarrow>\n  arg (cis (- arg z) * z) =\n  \\<downharpoonright>arg (cis (- arg z)) + arg z\\<downharpoonleft>\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arg (cis (- arg z) * z) = 0", "using arg_cis[of \"- arg z\"]"], ["proof (prove)\nusing this:\n  \\<downharpoonright>- arg z\\<downharpoonleft> = - arg z\n  cis (- arg z) * z \\<noteq> 0 \\<Longrightarrow>\n  arg (cis (- arg z) * z) =\n  \\<downharpoonright>arg (cis (- arg z)) + arg z\\<downharpoonleft>\n  z \\<noteq> 0\n  arg (cis (- arg z)) = \\<downharpoonright>- arg z\\<downharpoonleft>\n\ngoal (1 subgoal):\n 1. arg (cis (- arg z) * z) = 0", "by simp"], ["proof (state)\nthis:\n  arg (cis (- arg z) * z) = 0\n\ngoal (1 subgoal):\n 1. arg z \\<noteq> pi \\<Longrightarrow> is_real (cis (- arg z) * z)", "thus ?thesis"], ["proof (prove)\nusing this:\n  arg (cis (- arg z) * z) = 0\n\ngoal (1 subgoal):\n 1. is_real (cis (- arg z) * z)", "using is_real_arg1[of \"cis (- arg z) * z\"]"], ["proof (prove)\nusing this:\n  arg (cis (- arg z) * z) = 0\n  arg (cis (- arg z) * z) = 0 \\<or>\n  arg (cis (- arg z) * z) = pi \\<Longrightarrow>\n  is_real (cis (- arg z) * z)\n\ngoal (1 subgoal):\n 1. is_real (cis (- arg z) * z)", "by auto"], ["proof (state)\nthis:\n  is_real (cis (- arg z) * z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma positive_rot_to_x_axis:\n  assumes \"z \\<noteq> 0\"\n  shows \"Re (cis (-arg z) * z) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Re (cis (- arg z) * z)", "using assms"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < Re (cis (- arg z) * z)", "by (smt Re_complex_of_real cis_rcis_eq mult_cancel_right1 rcis_cmod_arg rcis_mult rcis_zero_arg zero_less_norm_iff)"], ["", "text \\<open>Inequalities involving @{term cmod}.\\<close>"], ["", "lemma cmod_1_plus_mult_le:\n  shows \"cmod (1 + z*w) \\<le> sqrt((1 + (cmod z)\\<^sup>2) * (1 + (cmod w)\\<^sup>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (1 + z * w)\n    \\<le> sqrt ((1 + (cmod z)\\<^sup>2) * (1 + (cmod w)\\<^sup>2))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod (1 + z * w)\n    \\<le> sqrt ((1 + (cmod z)\\<^sup>2) * (1 + (cmod w)\\<^sup>2))", "have \"Re ((1+z*w)*(1+cnj z*cnj w)) \\<le> Re (1+z*cnj z)* Re (1+w*cnj w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re ((1 + z * w) * (1 + cnj z * cnj w))\n    \\<le> Re (1 + z * cnj z) * Re (1 + w * cnj w)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Re ((1 + z * w) * (1 + cnj z * cnj w))\n    \\<le> Re (1 + z * cnj z) * Re (1 + w * cnj w)", "have \"Re ((w - cnj z)*cnj(w - cnj z)) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> Re ((w - cnj z) * cnj (w - cnj z))", "by (subst complex_mult_cnj_cmod) (simp add: power2_eq_square)"], ["proof (state)\nthis:\n  0 \\<le> Re ((w - cnj z) * cnj (w - cnj z))\n\ngoal (1 subgoal):\n 1. Re ((1 + z * w) * (1 + cnj z * cnj w))\n    \\<le> Re (1 + z * cnj z) * Re (1 + w * cnj w)", "hence \"Re (z*w + cnj z * cnj w) \\<le> Re (w*cnj w) + Re(z*cnj z)\""], ["proof (prove)\nusing this:\n  0 \\<le> Re ((w - cnj z) * cnj (w - cnj z))\n\ngoal (1 subgoal):\n 1. Re (z * w + cnj z * cnj w) \\<le> Re (w * cnj w) + Re (z * cnj z)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  Re (z * w + cnj z * cnj w) \\<le> Re (w * cnj w) + Re (z * cnj z)\n\ngoal (1 subgoal):\n 1. Re ((1 + z * w) * (1 + cnj z * cnj w))\n    \\<le> Re (1 + z * cnj z) * Re (1 + w * cnj w)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Re (z * w + cnj z * cnj w) \\<le> Re (w * cnj w) + Re (z * cnj z)\n\ngoal (1 subgoal):\n 1. Re ((1 + z * w) * (1 + cnj z * cnj w))\n    \\<le> Re (1 + z * cnj z) * Re (1 + w * cnj w)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  Re ((1 + z * w) * (1 + cnj z * cnj w))\n  \\<le> Re (1 + z * cnj z) * Re (1 + w * cnj w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re ((1 + z * w) * (1 + cnj z * cnj w))\n  \\<le> Re (1 + z * cnj z) * Re (1 + w * cnj w)\n\ngoal (1 subgoal):\n 1. cmod (1 + z * w)\n    \\<le> sqrt ((1 + (cmod z)\\<^sup>2) * (1 + (cmod w)\\<^sup>2))", "hence \"(cmod (1 + z * w))\\<^sup>2 \\<le> (1 + (cmod z)\\<^sup>2) * (1 + (cmod w)\\<^sup>2)\""], ["proof (prove)\nusing this:\n  Re ((1 + z * w) * (1 + cnj z * cnj w))\n  \\<le> Re (1 + z * cnj z) * Re (1 + w * cnj w)\n\ngoal (1 subgoal):\n 1. (cmod (1 + z * w))\\<^sup>2\n    \\<le> (1 + (cmod z)\\<^sup>2) * (1 + (cmod w)\\<^sup>2)", "by (subst cmod_square)+ simp"], ["proof (state)\nthis:\n  (cmod (1 + z * w))\\<^sup>2\n  \\<le> (1 + (cmod z)\\<^sup>2) * (1 + (cmod w)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. cmod (1 + z * w)\n    \\<le> sqrt ((1 + (cmod z)\\<^sup>2) * (1 + (cmod w)\\<^sup>2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (cmod (1 + z * w))\\<^sup>2\n  \\<le> (1 + (cmod z)\\<^sup>2) * (1 + (cmod w)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. cmod (1 + z * w)\n    \\<le> sqrt ((1 + (cmod z)\\<^sup>2) * (1 + (cmod w)\\<^sup>2))", "by (metis abs_norm_cancel real_sqrt_abs real_sqrt_le_iff)"], ["proof (state)\nthis:\n  cmod (1 + z * w)\n  \\<le> sqrt ((1 + (cmod z)\\<^sup>2) * (1 + (cmod w)\\<^sup>2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cmod_diff_ge: \n  shows \"cmod (b - c) \\<ge> sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n    \\<le> cmod (b - c)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n    \\<le> cmod (b - c)", "have \"(cmod (b - c))\\<^sup>2 + (1/2*Im(b*cnj c - c*cnj b))\\<^sup>2 \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (cmod (b - c))\\<^sup>2 +\n            (1 / 2 * Im (b * cnj c - c * cnj b))\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  0 \\<le> (cmod (b - c))\\<^sup>2 +\n          (1 / 2 * Im (b * cnj c - c * cnj b))\\<^sup>2\n\ngoal (1 subgoal):\n 1. sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n    \\<le> cmod (b - c)", "hence \"(cmod (b - c))\\<^sup>2 \\<ge> - (1/2*Im(b*cnj c - c*cnj b))\\<^sup>2\""], ["proof (prove)\nusing this:\n  0 \\<le> (cmod (b - c))\\<^sup>2 +\n          (1 / 2 * Im (b * cnj c - c * cnj b))\\<^sup>2\n\ngoal (1 subgoal):\n 1. - (1 / 2 * Im (b * cnj c - c * cnj b))\\<^sup>2\n    \\<le> (cmod (b - c))\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  - (1 / 2 * Im (b * cnj c - c * cnj b))\\<^sup>2\n  \\<le> (cmod (b - c))\\<^sup>2\n\ngoal (1 subgoal):\n 1. sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n    \\<le> cmod (b - c)", "hence \"(cmod (b - c))\\<^sup>2 \\<ge> (1/2*Re(b*cnj c + c*cnj b))\\<^sup>2 - Re(b*cnj b*c*cnj c) \""], ["proof (prove)\nusing this:\n  - (1 / 2 * Im (b * cnj c - c * cnj b))\\<^sup>2\n  \\<le> (cmod (b - c))\\<^sup>2\n\ngoal (1 subgoal):\n 1. (1 / 2 * Re (b * cnj c + c * cnj b))\\<^sup>2 -\n    Re (b * cnj b * c * cnj c)\n    \\<le> (cmod (b - c))\\<^sup>2", "by (auto simp add: power2_eq_square field_simps)"], ["proof (state)\nthis:\n  (1 / 2 * Re (b * cnj c + c * cnj b))\\<^sup>2 - Re (b * cnj b * c * cnj c)\n  \\<le> (cmod (b - c))\\<^sup>2\n\ngoal (1 subgoal):\n 1. sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n    \\<le> cmod (b - c)", "hence \"Re ((b - c)*(cnj b - cnj c)) \\<ge> (1/2*Re(b*cnj c + c*cnj b))\\<^sup>2 - Re(b*cnj b*c*cnj c)\""], ["proof (prove)\nusing this:\n  (1 / 2 * Re (b * cnj c + c * cnj b))\\<^sup>2 - Re (b * cnj b * c * cnj c)\n  \\<le> (cmod (b - c))\\<^sup>2\n\ngoal (1 subgoal):\n 1. (1 / 2 * Re (b * cnj c + c * cnj b))\\<^sup>2 -\n    Re (b * cnj b * c * cnj c)\n    \\<le> Re ((b - c) * (cnj b - cnj c))", "by (subst (asm) cmod_square) simp"], ["proof (state)\nthis:\n  (1 / 2 * Re (b * cnj c + c * cnj b))\\<^sup>2 - Re (b * cnj b * c * cnj c)\n  \\<le> Re ((b - c) * (cnj b - cnj c))\n\ngoal (1 subgoal):\n 1. sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n    \\<le> cmod (b - c)", "moreover"], ["proof (state)\nthis:\n  (1 / 2 * Re (b * cnj c + c * cnj b))\\<^sup>2 - Re (b * cnj b * c * cnj c)\n  \\<le> Re ((b - c) * (cnj b - cnj c))\n\ngoal (1 subgoal):\n 1. sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n    \\<le> cmod (b - c)", "have \"(1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2) = 1 + Re(b*cnj b) + Re(c*cnj c) + Re(b*cnj b*c*cnj c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2) =\n    1 + Re (b * cnj b) + Re (c * cnj c) + Re (b * cnj b * c * cnj c)", "by (subst cmod_square)+ (simp add: field_simps power2_eq_square)"], ["proof (state)\nthis:\n  (1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2) =\n  1 + Re (b * cnj b) + Re (c * cnj c) + Re (b * cnj b * c * cnj c)\n\ngoal (1 subgoal):\n 1. sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n    \\<le> cmod (b - c)", "moreover"], ["proof (state)\nthis:\n  (1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2) =\n  1 + Re (b * cnj b) + Re (c * cnj c) + Re (b * cnj b * c * cnj c)\n\ngoal (1 subgoal):\n 1. sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n    \\<le> cmod (b - c)", "have \"(1 + Re (scalprod b c))\\<^sup>2 = 1 + 2*Re(scalprod b c) + ((Re (scalprod b c))\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 + Re (scalprod b c))\\<^sup>2 =\n    1 + 2 * Re (scalprod b c) + (Re (scalprod b c))\\<^sup>2", "by (subst power2_sum) simp"], ["proof (state)\nthis:\n  (1 + Re (scalprod b c))\\<^sup>2 =\n  1 + 2 * Re (scalprod b c) + (Re (scalprod b c))\\<^sup>2\n\ngoal (1 subgoal):\n 1. sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n    \\<le> cmod (b - c)", "hence \"(1 + Re (scalprod b c))\\<^sup>2 = 1 + Re(b*cnj c + c*cnj b) + (1/2 * Re (b*cnj c + c*cnj b))\\<^sup>2\""], ["proof (prove)\nusing this:\n  (1 + Re (scalprod b c))\\<^sup>2 =\n  1 + 2 * Re (scalprod b c) + (Re (scalprod b c))\\<^sup>2\n\ngoal (1 subgoal):\n 1. (1 + Re (scalprod b c))\\<^sup>2 =\n    1 + Re (b * cnj c + c * cnj b) +\n    (1 / 2 * Re (b * cnj c + c * cnj b))\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  (1 + Re (scalprod b c))\\<^sup>2 =\n  1 + Re (b * cnj c + c * cnj b) +\n  (1 / 2 * Re (b * cnj c + c * cnj b))\\<^sup>2\n\ngoal (1 subgoal):\n 1. sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n    \\<le> cmod (b - c)", "ultimately"], ["proof (chain)\npicking this:\n  (1 / 2 * Re (b * cnj c + c * cnj b))\\<^sup>2 - Re (b * cnj b * c * cnj c)\n  \\<le> Re ((b - c) * (cnj b - cnj c))\n  (1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2) =\n  1 + Re (b * cnj b) + Re (c * cnj c) + Re (b * cnj b * c * cnj c)\n  (1 + Re (scalprod b c))\\<^sup>2 =\n  1 + Re (b * cnj c + c * cnj b) +\n  (1 / 2 * Re (b * cnj c + c * cnj b))\\<^sup>2", "have \"(1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2) \\<ge> (1 + Re (scalprod b c))\\<^sup>2\""], ["proof (prove)\nusing this:\n  (1 / 2 * Re (b * cnj c + c * cnj b))\\<^sup>2 - Re (b * cnj b * c * cnj c)\n  \\<le> Re ((b - c) * (cnj b - cnj c))\n  (1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2) =\n  1 + Re (b * cnj b) + Re (c * cnj c) + Re (b * cnj b * c * cnj c)\n  (1 + Re (scalprod b c))\\<^sup>2 =\n  1 + Re (b * cnj c + c * cnj b) +\n  (1 / 2 * Re (b * cnj c + c * cnj b))\\<^sup>2\n\ngoal (1 subgoal):\n 1. (1 + Re (scalprod b c))\\<^sup>2\n    \\<le> (1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (1 + Re (scalprod b c))\\<^sup>2\n  \\<le> (1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n    \\<le> cmod (b - c)", "moreover"], ["proof (state)\nthis:\n  (1 + Re (scalprod b c))\\<^sup>2\n  \\<le> (1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n    \\<le> cmod (b - c)", "have \"sqrt((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2)) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))", "by (metis one_power2 real_sqrt_sum_squares_mult_ge_zero)"], ["proof (state)\nthis:\n  0 \\<le> sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n    \\<le> cmod (b - c)", "ultimately"], ["proof (chain)\npicking this:\n  (1 + Re (scalprod b c))\\<^sup>2\n  \\<le> (1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2)\n  0 \\<le> sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))", "have \"sqrt((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2)) \\<ge> 1 + Re (scalprod b c)\""], ["proof (prove)\nusing this:\n  (1 + Re (scalprod b c))\\<^sup>2\n  \\<le> (1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2)\n  0 \\<le> sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. 1 + Re (scalprod b c)\n    \\<le> sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))", "by (metis power2_le_imp_le real_sqrt_ge_0_iff real_sqrt_pow2_iff)"], ["proof (state)\nthis:\n  1 + Re (scalprod b c)\n  \\<le> sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n    \\<le> cmod (b - c)", "hence \"Re ((b - c) * (cnj b - cnj c)) \\<ge> 1 + Re (c*cnj c) + 1 + Re (b*cnj b) - 2*sqrt((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))\""], ["proof (prove)\nusing this:\n  1 + Re (scalprod b c)\n  \\<le> sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. 1 + Re (c * cnj c) + 1 + Re (b * cnj b) -\n    2 * sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))\n    \\<le> Re ((b - c) * (cnj b - cnj c))", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  1 + Re (c * cnj c) + 1 + Re (b * cnj b) -\n  2 * sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))\n  \\<le> Re ((b - c) * (cnj b - cnj c))\n\ngoal (1 subgoal):\n 1. sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n    \\<le> cmod (b - c)", "hence *: \"(cmod (b - c))\\<^sup>2 \\<ge> (sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2))\\<^sup>2\""], ["proof (prove)\nusing this:\n  1 + Re (c * cnj c) + 1 + Re (b * cnj b) -\n  2 * sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))\n  \\<le> Re ((b - c) * (cnj b - cnj c))\n\ngoal (1 subgoal):\n 1. (sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2))\\<^sup>2\n    \\<le> (cmod (b - c))\\<^sup>2", "apply (subst cmod_square)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 + Re (c * cnj c) + 1 + Re (b * cnj b) -\n             2 * sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))\n             \\<le> Re ((b - c) * (cnj b - cnj c));\n     1 + Re (c * cnj c) + 1 + Re (b * cnj b) -\n     2 * sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))\n     \\<le> Re ((b - c) * (cnj b - cnj c));\n     1 + Re (c * cnj c) + 1 + Re (b * cnj b) -\n     2 * sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))\n     \\<le> Re ((b - c) * (cnj b - cnj c))\\<rbrakk>\n    \\<Longrightarrow> (sqrt (1 + Re (b * cnj b)) -\n                       sqrt (1 + Re (c * cnj c)))\\<^sup>2\n                      \\<le> Re ((b - c) * cnj (b - c))", "apply (subst (asm) cmod_square)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 + Re (c * cnj c) + 1 + Re (b * cnj b) -\n             2 * sqrt ((1 + Re (b * cnj b)) * (1 + Re (c * cnj c)))\n             \\<le> Re ((b - c) * (cnj b - cnj c));\n     1 + Re (c * cnj c) + 1 + Re (b * cnj b) -\n     2 * sqrt ((1 + Re (b * cnj b)) * (1 + Re (c * cnj c)))\n     \\<le> Re ((b - c) * (cnj b - cnj c));\n     1 + Re (c * cnj c) + 1 + Re (b * cnj b) -\n     2 * sqrt ((1 + Re (b * cnj b)) * (1 + Re (c * cnj c)))\n     \\<le> Re ((b - c) * (cnj b - cnj c))\\<rbrakk>\n    \\<Longrightarrow> (sqrt (1 + Re (b * cnj b)) -\n                       sqrt (1 + Re (c * cnj c)))\\<^sup>2\n                      \\<le> Re ((b - c) * cnj (b - c))", "apply (subst power2_diff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 + Re (c * cnj c) + 1 + Re (b * cnj b) -\n             2 * sqrt ((1 + Re (b * cnj b)) * (1 + Re (c * cnj c)))\n             \\<le> Re ((b - c) * (cnj b - cnj c));\n     1 + Re (c * cnj c) + 1 + Re (b * cnj b) -\n     2 * sqrt ((1 + Re (b * cnj b)) * (1 + Re (c * cnj c)))\n     \\<le> Re ((b - c) * (cnj b - cnj c));\n     1 + Re (c * cnj c) + 1 + Re (b * cnj b) -\n     2 * sqrt ((1 + Re (b * cnj b)) * (1 + Re (c * cnj c)))\n     \\<le> Re ((b - c) * (cnj b - cnj c))\\<rbrakk>\n    \\<Longrightarrow> (sqrt (1 + Re (b * cnj b)))\\<^sup>2 +\n                      (sqrt (1 + Re (c * cnj c)))\\<^sup>2 -\n                      2 * sqrt (1 + Re (b * cnj b)) *\n                      sqrt (1 + Re (c * cnj c))\n                      \\<le> Re ((b - c) * cnj (b - c))", "apply (subst real_sqrt_pow2, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 + Re (c * cnj c) + 1 + Re (b * cnj b) -\n             2 * sqrt ((1 + Re (b * cnj b)) * (1 + Re (c * cnj c)))\n             \\<le> Re ((b - c) * (cnj b - cnj c));\n     1 + Re (c * cnj c) + 1 + Re (b * cnj b) -\n     2 * sqrt ((1 + Re (b * cnj b)) * (1 + Re (c * cnj c)))\n     \\<le> Re ((b - c) * (cnj b - cnj c));\n     1 + Re (c * cnj c) + 1 + Re (b * cnj b) -\n     2 * sqrt ((1 + Re (b * cnj b)) * (1 + Re (c * cnj c)))\n     \\<le> Re ((b - c) * (cnj b - cnj c))\\<rbrakk>\n    \\<Longrightarrow> 1 + Re (b * cnj b) +\n                      (sqrt (1 + Re (c * cnj c)))\\<^sup>2 -\n                      2 * sqrt (1 + Re (b * cnj b)) *\n                      sqrt (1 + Re (c * cnj c))\n                      \\<le> Re ((b - c) * cnj (b - c))", "apply (subst real_sqrt_pow2, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 + Re (c * cnj c) + 1 + Re (b * cnj b) -\n             2 * sqrt ((1 + Re (b * cnj b)) * (1 + Re (c * cnj c)))\n             \\<le> Re ((b - c) * (cnj b - cnj c));\n     1 + Re (c * cnj c) + 1 + Re (b * cnj b) -\n     2 * sqrt ((1 + Re (b * cnj b)) * (1 + Re (c * cnj c)))\n     \\<le> Re ((b - c) * (cnj b - cnj c));\n     1 + Re (c * cnj c) + 1 + Re (b * cnj b) -\n     2 * sqrt ((1 + Re (b * cnj b)) * (1 + Re (c * cnj c)))\n     \\<le> Re ((b - c) * (cnj b - cnj c))\\<rbrakk>\n    \\<Longrightarrow> 1 + Re (b * cnj b) + (1 + Re (c * cnj c)) -\n                      2 * sqrt (1 + Re (b * cnj b)) *\n                      sqrt (1 + Re (c * cnj c))\n                      \\<le> Re ((b - c) * cnj (b - c))", "apply (simp add: real_sqrt_mult)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2))\\<^sup>2\n  \\<le> (cmod (b - c))\\<^sup>2\n\ngoal (1 subgoal):\n 1. sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n    \\<le> cmod (b - c)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2))\\<^sup>2\n  \\<le> (cmod (b - c))\\<^sup>2\n\ngoal (1 subgoal):\n 1. sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n    \\<le> cmod (b - c)", "proof (cases \"sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2) > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(sqrt (1 + (cmod b)\\<^sup>2) -\n              sqrt (1 + (cmod c)\\<^sup>2))\\<^sup>2\n             \\<le> (cmod (b - c))\\<^sup>2;\n     0 < sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> sqrt (1 + (cmod b)\\<^sup>2) -\n                      sqrt (1 + (cmod c)\\<^sup>2)\n                      \\<le> cmod (b - c)\n 2. \\<lbrakk>(sqrt (1 + (cmod b)\\<^sup>2) -\n              sqrt (1 + (cmod c)\\<^sup>2))\\<^sup>2\n             \\<le> (cmod (b - c))\\<^sup>2;\n     \\<not> 0 < sqrt (1 + (cmod b)\\<^sup>2) -\n                sqrt (1 + (cmod c)\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> sqrt (1 + (cmod b)\\<^sup>2) -\n                      sqrt (1 + (cmod c)\\<^sup>2)\n                      \\<le> cmod (b - c)", "case True"], ["proof (state)\nthis:\n  0 < sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(sqrt (1 + (cmod b)\\<^sup>2) -\n              sqrt (1 + (cmod c)\\<^sup>2))\\<^sup>2\n             \\<le> (cmod (b - c))\\<^sup>2;\n     0 < sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> sqrt (1 + (cmod b)\\<^sup>2) -\n                      sqrt (1 + (cmod c)\\<^sup>2)\n                      \\<le> cmod (b - c)\n 2. \\<lbrakk>(sqrt (1 + (cmod b)\\<^sup>2) -\n              sqrt (1 + (cmod c)\\<^sup>2))\\<^sup>2\n             \\<le> (cmod (b - c))\\<^sup>2;\n     \\<not> 0 < sqrt (1 + (cmod b)\\<^sup>2) -\n                sqrt (1 + (cmod c)\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> sqrt (1 + (cmod b)\\<^sup>2) -\n                      sqrt (1 + (cmod c)\\<^sup>2)\n                      \\<le> cmod (b - c)", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n    \\<le> cmod (b - c)", "using power2_le_imp_le[OF *]"], ["proof (prove)\nusing this:\n  0 < sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n  0 \\<le> cmod (b - c) \\<Longrightarrow>\n  sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n  \\<le> cmod (b - c)\n\ngoal (1 subgoal):\n 1. sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n    \\<le> cmod (b - c)", "by simp"], ["proof (state)\nthis:\n  sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n  \\<le> cmod (b - c)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(sqrt (1 + (cmod b)\\<^sup>2) -\n              sqrt (1 + (cmod c)\\<^sup>2))\\<^sup>2\n             \\<le> (cmod (b - c))\\<^sup>2;\n     \\<not> 0 < sqrt (1 + (cmod b)\\<^sup>2) -\n                sqrt (1 + (cmod c)\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> sqrt (1 + (cmod b)\\<^sup>2) -\n                      sqrt (1 + (cmod c)\\<^sup>2)\n                      \\<le> cmod (b - c)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(sqrt (1 + (cmod b)\\<^sup>2) -\n              sqrt (1 + (cmod c)\\<^sup>2))\\<^sup>2\n             \\<le> (cmod (b - c))\\<^sup>2;\n     \\<not> 0 < sqrt (1 + (cmod b)\\<^sup>2) -\n                sqrt (1 + (cmod c)\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> sqrt (1 + (cmod b)\\<^sup>2) -\n                      sqrt (1 + (cmod c)\\<^sup>2)\n                      \\<le> cmod (b - c)", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(sqrt (1 + (cmod b)\\<^sup>2) -\n              sqrt (1 + (cmod c)\\<^sup>2))\\<^sup>2\n             \\<le> (cmod (b - c))\\<^sup>2;\n     \\<not> 0 < sqrt (1 + (cmod b)\\<^sup>2) -\n                sqrt (1 + (cmod c)\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> sqrt (1 + (cmod b)\\<^sup>2) -\n                      sqrt (1 + (cmod c)\\<^sup>2)\n                      \\<le> cmod (b - c)", "hence \"0 \\<ge> sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\""], ["proof (prove)\nusing this:\n  \\<not> 0 < sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2) \\<le> 0", "by (metis less_eq_real_def linorder_neqE_linordered_idom)"], ["proof (state)\nthis:\n  sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2) \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(sqrt (1 + (cmod b)\\<^sup>2) -\n              sqrt (1 + (cmod c)\\<^sup>2))\\<^sup>2\n             \\<le> (cmod (b - c))\\<^sup>2;\n     \\<not> 0 < sqrt (1 + (cmod b)\\<^sup>2) -\n                sqrt (1 + (cmod c)\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> sqrt (1 + (cmod b)\\<^sup>2) -\n                      sqrt (1 + (cmod c)\\<^sup>2)\n                      \\<le> cmod (b - c)", "moreover"], ["proof (state)\nthis:\n  sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2) \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(sqrt (1 + (cmod b)\\<^sup>2) -\n              sqrt (1 + (cmod c)\\<^sup>2))\\<^sup>2\n             \\<le> (cmod (b - c))\\<^sup>2;\n     \\<not> 0 < sqrt (1 + (cmod b)\\<^sup>2) -\n                sqrt (1 + (cmod c)\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> sqrt (1 + (cmod b)\\<^sup>2) -\n                      sqrt (1 + (cmod c)\\<^sup>2)\n                      \\<le> cmod (b - c)", "have \"cmod (b - c) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> cmod (b - c)", "by simp"], ["proof (state)\nthis:\n  0 \\<le> cmod (b - c)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(sqrt (1 + (cmod b)\\<^sup>2) -\n              sqrt (1 + (cmod c)\\<^sup>2))\\<^sup>2\n             \\<le> (cmod (b - c))\\<^sup>2;\n     \\<not> 0 < sqrt (1 + (cmod b)\\<^sup>2) -\n                sqrt (1 + (cmod c)\\<^sup>2)\\<rbrakk>\n    \\<Longrightarrow> sqrt (1 + (cmod b)\\<^sup>2) -\n                      sqrt (1 + (cmod c)\\<^sup>2)\n                      \\<le> cmod (b - c)", "ultimately"], ["proof (chain)\npicking this:\n  sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2) \\<le> 0\n  0 \\<le> cmod (b - c)", "show ?thesis"], ["proof (prove)\nusing this:\n  sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2) \\<le> 0\n  0 \\<le> cmod (b - c)\n\ngoal (1 subgoal):\n 1. sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n    \\<le> cmod (b - c)", "by (metis add_increasing monoid_add_class.add.right_neutral)"], ["proof (state)\nthis:\n  sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n  \\<le> cmod (b - c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sqrt (1 + (cmod b)\\<^sup>2) - sqrt (1 + (cmod c)\\<^sup>2)\n  \\<le> cmod (b - c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cmod_diff_le:\n  shows \"cmod (b - c) \\<le> sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (b - c)\n    \\<le> sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod (b - c)\n    \\<le> sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2)", "have \"(cmod (b + c))\\<^sup>2 + (1/2*Im(b*cnj c - c*cnj b))\\<^sup>2 \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (cmod (b + c))\\<^sup>2 +\n            (1 / 2 * Im (b * cnj c - c * cnj b))\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  0 \\<le> (cmod (b + c))\\<^sup>2 +\n          (1 / 2 * Im (b * cnj c - c * cnj b))\\<^sup>2\n\ngoal (1 subgoal):\n 1. cmod (b - c)\n    \\<le> sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2)", "hence \"(cmod (b + c))\\<^sup>2 \\<ge> - (1/2*Im(b*cnj c - c*cnj b))\\<^sup>2\""], ["proof (prove)\nusing this:\n  0 \\<le> (cmod (b + c))\\<^sup>2 +\n          (1 / 2 * Im (b * cnj c - c * cnj b))\\<^sup>2\n\ngoal (1 subgoal):\n 1. - (1 / 2 * Im (b * cnj c - c * cnj b))\\<^sup>2\n    \\<le> (cmod (b + c))\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  - (1 / 2 * Im (b * cnj c - c * cnj b))\\<^sup>2\n  \\<le> (cmod (b + c))\\<^sup>2\n\ngoal (1 subgoal):\n 1. cmod (b - c)\n    \\<le> sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2)", "hence \"(cmod (b + c))\\<^sup>2 \\<ge> (1/2*Re(b*cnj c + c*cnj b))\\<^sup>2 - Re(b*cnj b*c*cnj c) \""], ["proof (prove)\nusing this:\n  - (1 / 2 * Im (b * cnj c - c * cnj b))\\<^sup>2\n  \\<le> (cmod (b + c))\\<^sup>2\n\ngoal (1 subgoal):\n 1. (1 / 2 * Re (b * cnj c + c * cnj b))\\<^sup>2 -\n    Re (b * cnj b * c * cnj c)\n    \\<le> (cmod (b + c))\\<^sup>2", "by (auto simp add: power2_eq_square field_simps)"], ["proof (state)\nthis:\n  (1 / 2 * Re (b * cnj c + c * cnj b))\\<^sup>2 - Re (b * cnj b * c * cnj c)\n  \\<le> (cmod (b + c))\\<^sup>2\n\ngoal (1 subgoal):\n 1. cmod (b - c)\n    \\<le> sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2)", "hence \"Re ((b + c)*(cnj b + cnj c)) \\<ge> (1/2*Re(b*cnj c + c*cnj b))\\<^sup>2 - Re(b*cnj b*c*cnj c)\""], ["proof (prove)\nusing this:\n  (1 / 2 * Re (b * cnj c + c * cnj b))\\<^sup>2 - Re (b * cnj b * c * cnj c)\n  \\<le> (cmod (b + c))\\<^sup>2\n\ngoal (1 subgoal):\n 1. (1 / 2 * Re (b * cnj c + c * cnj b))\\<^sup>2 -\n    Re (b * cnj b * c * cnj c)\n    \\<le> Re ((b + c) * (cnj b + cnj c))", "by (subst (asm) cmod_square) simp"], ["proof (state)\nthis:\n  (1 / 2 * Re (b * cnj c + c * cnj b))\\<^sup>2 - Re (b * cnj b * c * cnj c)\n  \\<le> Re ((b + c) * (cnj b + cnj c))\n\ngoal (1 subgoal):\n 1. cmod (b - c)\n    \\<le> sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2)", "moreover"], ["proof (state)\nthis:\n  (1 / 2 * Re (b * cnj c + c * cnj b))\\<^sup>2 - Re (b * cnj b * c * cnj c)\n  \\<le> Re ((b + c) * (cnj b + cnj c))\n\ngoal (1 subgoal):\n 1. cmod (b - c)\n    \\<le> sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2)", "have \"(1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2) = 1 + Re(b*cnj b) + Re(c*cnj c) + Re(b*cnj b*c*cnj c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2) =\n    1 + Re (b * cnj b) + Re (c * cnj c) + Re (b * cnj b * c * cnj c)", "by (subst cmod_square)+ (simp add: field_simps power2_eq_square)"], ["proof (state)\nthis:\n  (1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2) =\n  1 + Re (b * cnj b) + Re (c * cnj c) + Re (b * cnj b * c * cnj c)\n\ngoal (1 subgoal):\n 1. cmod (b - c)\n    \\<le> sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2)", "moreover"], ["proof (state)\nthis:\n  (1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2) =\n  1 + Re (b * cnj b) + Re (c * cnj c) + Re (b * cnj b * c * cnj c)\n\ngoal (1 subgoal):\n 1. cmod (b - c)\n    \\<le> sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2)", "have ++: \"2*Re(scalprod b c) = Re(b*cnj c + c*cnj b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Re (scalprod b c) = Re (b * cnj c + c * cnj b)", "by simp"], ["proof (state)\nthis:\n  2 * Re (scalprod b c) = Re (b * cnj c + c * cnj b)\n\ngoal (1 subgoal):\n 1. cmod (b - c)\n    \\<le> sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2)", "have \"(1 - Re (scalprod b c))\\<^sup>2 = 1 - 2*Re(scalprod b c) + ((Re (scalprod b c))\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - Re (scalprod b c))\\<^sup>2 =\n    1 - 2 * Re (scalprod b c) + (Re (scalprod b c))\\<^sup>2", "by (subst power2_diff) simp"], ["proof (state)\nthis:\n  (1 - Re (scalprod b c))\\<^sup>2 =\n  1 - 2 * Re (scalprod b c) + (Re (scalprod b c))\\<^sup>2\n\ngoal (1 subgoal):\n 1. cmod (b - c)\n    \\<le> sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2)", "hence \"(1 - Re (scalprod b c))\\<^sup>2 = 1 - Re(b*cnj c + c*cnj b) + (1/2 * Re (b*cnj c + c*cnj b))\\<^sup>2\""], ["proof (prove)\nusing this:\n  (1 - Re (scalprod b c))\\<^sup>2 =\n  1 - 2 * Re (scalprod b c) + (Re (scalprod b c))\\<^sup>2\n\ngoal (1 subgoal):\n 1. (1 - Re (scalprod b c))\\<^sup>2 =\n    1 - Re (b * cnj c + c * cnj b) +\n    (1 / 2 * Re (b * cnj c + c * cnj b))\\<^sup>2", "by (subst ++[symmetric]) simp"], ["proof (state)\nthis:\n  (1 - Re (scalprod b c))\\<^sup>2 =\n  1 - Re (b * cnj c + c * cnj b) +\n  (1 / 2 * Re (b * cnj c + c * cnj b))\\<^sup>2\n\ngoal (1 subgoal):\n 1. cmod (b - c)\n    \\<le> sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2)", "ultimately"], ["proof (chain)\npicking this:\n  (1 / 2 * Re (b * cnj c + c * cnj b))\\<^sup>2 - Re (b * cnj b * c * cnj c)\n  \\<le> Re ((b + c) * (cnj b + cnj c))\n  (1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2) =\n  1 + Re (b * cnj b) + Re (c * cnj c) + Re (b * cnj b * c * cnj c)\n  (1 - Re (scalprod b c))\\<^sup>2 =\n  1 - Re (b * cnj c + c * cnj b) +\n  (1 / 2 * Re (b * cnj c + c * cnj b))\\<^sup>2", "have \"(1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2) \\<ge> (1 - Re (scalprod b c))\\<^sup>2\""], ["proof (prove)\nusing this:\n  (1 / 2 * Re (b * cnj c + c * cnj b))\\<^sup>2 - Re (b * cnj b * c * cnj c)\n  \\<le> Re ((b + c) * (cnj b + cnj c))\n  (1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2) =\n  1 + Re (b * cnj b) + Re (c * cnj c) + Re (b * cnj b * c * cnj c)\n  (1 - Re (scalprod b c))\\<^sup>2 =\n  1 - Re (b * cnj c + c * cnj b) +\n  (1 / 2 * Re (b * cnj c + c * cnj b))\\<^sup>2\n\ngoal (1 subgoal):\n 1. (1 - Re (scalprod b c))\\<^sup>2\n    \\<le> (1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (1 - Re (scalprod b c))\\<^sup>2\n  \\<le> (1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. cmod (b - c)\n    \\<le> sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2)", "moreover"], ["proof (state)\nthis:\n  (1 - Re (scalprod b c))\\<^sup>2\n  \\<le> (1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. cmod (b - c)\n    \\<le> sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2)", "have \"sqrt((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2)) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))", "by (metis one_power2 real_sqrt_sum_squares_mult_ge_zero)"], ["proof (state)\nthis:\n  0 \\<le> sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. cmod (b - c)\n    \\<le> sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2)", "ultimately"], ["proof (chain)\npicking this:\n  (1 - Re (scalprod b c))\\<^sup>2\n  \\<le> (1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2)\n  0 \\<le> sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))", "have \"sqrt((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2)) \\<ge> 1 - Re (scalprod b c)\""], ["proof (prove)\nusing this:\n  (1 - Re (scalprod b c))\\<^sup>2\n  \\<le> (1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2)\n  0 \\<le> sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. 1 - Re (scalprod b c)\n    \\<le> sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))", "by (metis power2_le_imp_le real_sqrt_ge_0_iff real_sqrt_pow2_iff)"], ["proof (state)\nthis:\n  1 - Re (scalprod b c)\n  \\<le> sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. cmod (b - c)\n    \\<le> sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2)", "hence \"Re ((b - c) * (cnj b - cnj c)) \\<le> 1 + Re (c*cnj c) + 1 + Re (b*cnj b) + 2*sqrt((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))\""], ["proof (prove)\nusing this:\n  1 - Re (scalprod b c)\n  \\<le> sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. Re ((b - c) * (cnj b - cnj c))\n    \\<le> 1 + Re (c * cnj c) + 1 + Re (b * cnj b) +\n          2 * sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  Re ((b - c) * (cnj b - cnj c))\n  \\<le> 1 + Re (c * cnj c) + 1 + Re (b * cnj b) +\n        2 * sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. cmod (b - c)\n    \\<le> sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2)", "hence *: \"(cmod (b - c))\\<^sup>2 \\<le> (sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2))\\<^sup>2\""], ["proof (prove)\nusing this:\n  Re ((b - c) * (cnj b - cnj c))\n  \\<le> 1 + Re (c * cnj c) + 1 + Re (b * cnj b) +\n        2 * sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. (cmod (b - c))\\<^sup>2\n    \\<le> (sqrt (1 + (cmod b)\\<^sup>2) +\n           sqrt (1 + (cmod c)\\<^sup>2))\\<^sup>2", "apply (subst cmod_square)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Re ((b - c) * (cnj b - cnj c))\n             \\<le> 1 + Re (c * cnj c) + 1 + Re (b * cnj b) +\n                   2 *\n                   sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2));\n     Re ((b - c) * (cnj b - cnj c))\n     \\<le> 1 + Re (c * cnj c) + 1 + Re (b * cnj b) +\n           2 * sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2));\n     Re ((b - c) * (cnj b - cnj c))\n     \\<le> 1 + Re (c * cnj c) + 1 + Re (b * cnj b) +\n           2 *\n           sqrt ((1 + (cmod b)\\<^sup>2) * (1 + (cmod c)\\<^sup>2))\\<rbrakk>\n    \\<Longrightarrow> Re ((b - c) * cnj (b - c))\n                      \\<le> (sqrt (1 + Re (b * cnj b)) +\n                             sqrt (1 + Re (c * cnj c)))\\<^sup>2", "apply (subst (asm) cmod_square)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Re ((b - c) * (cnj b - cnj c))\n             \\<le> 1 + Re (c * cnj c) + 1 + Re (b * cnj b) +\n                   2 * sqrt ((1 + Re (b * cnj b)) * (1 + Re (c * cnj c)));\n     Re ((b - c) * (cnj b - cnj c))\n     \\<le> 1 + Re (c * cnj c) + 1 + Re (b * cnj b) +\n           2 * sqrt ((1 + Re (b * cnj b)) * (1 + Re (c * cnj c)));\n     Re ((b - c) * (cnj b - cnj c))\n     \\<le> 1 + Re (c * cnj c) + 1 + Re (b * cnj b) +\n           2 * sqrt ((1 + Re (b * cnj b)) * (1 + Re (c * cnj c)))\\<rbrakk>\n    \\<Longrightarrow> Re ((b - c) * cnj (b - c))\n                      \\<le> (sqrt (1 + Re (b * cnj b)) +\n                             sqrt (1 + Re (c * cnj c)))\\<^sup>2", "apply (subst power2_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Re ((b - c) * (cnj b - cnj c))\n             \\<le> 1 + Re (c * cnj c) + 1 + Re (b * cnj b) +\n                   2 * sqrt ((1 + Re (b * cnj b)) * (1 + Re (c * cnj c)));\n     Re ((b - c) * (cnj b - cnj c))\n     \\<le> 1 + Re (c * cnj c) + 1 + Re (b * cnj b) +\n           2 * sqrt ((1 + Re (b * cnj b)) * (1 + Re (c * cnj c)));\n     Re ((b - c) * (cnj b - cnj c))\n     \\<le> 1 + Re (c * cnj c) + 1 + Re (b * cnj b) +\n           2 * sqrt ((1 + Re (b * cnj b)) * (1 + Re (c * cnj c)))\\<rbrakk>\n    \\<Longrightarrow> Re ((b - c) * cnj (b - c))\n                      \\<le> (sqrt (1 + Re (b * cnj b)))\\<^sup>2 +\n                            (sqrt (1 + Re (c * cnj c)))\\<^sup>2 +\n                            2 * sqrt (1 + Re (b * cnj b)) *\n                            sqrt (1 + Re (c * cnj c))", "apply (subst real_sqrt_pow2, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Re ((b - c) * (cnj b - cnj c))\n             \\<le> 1 + Re (c * cnj c) + 1 + Re (b * cnj b) +\n                   2 * sqrt ((1 + Re (b * cnj b)) * (1 + Re (c * cnj c)));\n     Re ((b - c) * (cnj b - cnj c))\n     \\<le> 1 + Re (c * cnj c) + 1 + Re (b * cnj b) +\n           2 * sqrt ((1 + Re (b * cnj b)) * (1 + Re (c * cnj c)));\n     Re ((b - c) * (cnj b - cnj c))\n     \\<le> 1 + Re (c * cnj c) + 1 + Re (b * cnj b) +\n           2 * sqrt ((1 + Re (b * cnj b)) * (1 + Re (c * cnj c)))\\<rbrakk>\n    \\<Longrightarrow> Re ((b - c) * cnj (b - c))\n                      \\<le> 1 + Re (b * cnj b) +\n                            (sqrt (1 + Re (c * cnj c)))\\<^sup>2 +\n                            2 * sqrt (1 + Re (b * cnj b)) *\n                            sqrt (1 + Re (c * cnj c))", "apply (subst real_sqrt_pow2, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Re ((b - c) * (cnj b - cnj c))\n             \\<le> 1 + Re (c * cnj c) + 1 + Re (b * cnj b) +\n                   2 * sqrt ((1 + Re (b * cnj b)) * (1 + Re (c * cnj c)));\n     Re ((b - c) * (cnj b - cnj c))\n     \\<le> 1 + Re (c * cnj c) + 1 + Re (b * cnj b) +\n           2 * sqrt ((1 + Re (b * cnj b)) * (1 + Re (c * cnj c)));\n     Re ((b - c) * (cnj b - cnj c))\n     \\<le> 1 + Re (c * cnj c) + 1 + Re (b * cnj b) +\n           2 * sqrt ((1 + Re (b * cnj b)) * (1 + Re (c * cnj c)))\\<rbrakk>\n    \\<Longrightarrow> Re ((b - c) * cnj (b - c))\n                      \\<le> 1 + Re (b * cnj b) + (1 + Re (c * cnj c)) +\n                            2 * sqrt (1 + Re (b * cnj b)) *\n                            sqrt (1 + Re (c * cnj c))", "apply (simp add: real_sqrt_mult)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (cmod (b - c))\\<^sup>2\n  \\<le> (sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2))\\<^sup>2\n\ngoal (1 subgoal):\n 1. cmod (b - c)\n    \\<le> sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (cmod (b - c))\\<^sup>2\n  \\<le> (sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2))\\<^sup>2\n\ngoal (1 subgoal):\n 1. cmod (b - c)\n    \\<le> sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2)", "using power2_le_imp_le[OF *]"], ["proof (prove)\nusing this:\n  (cmod (b - c))\\<^sup>2\n  \\<le> (sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2))\\<^sup>2\n  0 \\<le> sqrt (1 + (cmod b)\\<^sup>2) +\n          sqrt (1 + (cmod c)\\<^sup>2) \\<Longrightarrow>\n  cmod (b - c)\n  \\<le> sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. cmod (b - c)\n    \\<le> sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  cmod (b - c)\n  \\<le> sqrt (1 + (cmod b)\\<^sup>2) + sqrt (1 + (cmod c)\\<^sup>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Definition of Euclidean distance between two complex numbers.\\<close>"], ["", "definition cdist where\n  [simp]: \"cdist z1 z2 \\<equiv> cmod (z2 - z1)\""], ["", "text \\<open>Misc. properties of complex numbers.\\<close>"], ["", "lemma ex_complex_to_complex [simp]:\n  fixes z1 z2 :: complex\n  assumes \"z1 \\<noteq> 0\" and \"z2 \\<noteq> 0\"\n  shows \"\\<exists>k. k \\<noteq> 0 \\<and> z2 = k * z1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> z2 = k * z1", "using assms"], ["proof (prove)\nusing this:\n  z1 \\<noteq> 0\n  z2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> z2 = k * z1", "by (rule_tac x=\"z2/z1\" in exI) simp"], ["", "lemma ex_complex_to_one [simp]:\n  fixes z::complex\n  assumes \"z \\<noteq> 0\"\n  shows \"\\<exists>k. k \\<noteq> 0 \\<and> k * z = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> k * z = 1", "using assms"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> k * z = 1", "by (rule_tac x=\"1/z\" in exI) simp"], ["", "lemma ex_complex_to_complex2 [simp]:\n  fixes z::complex\n  shows \"\\<exists>k. k \\<noteq> 0 \\<and> k * z = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> k * z = z", "by (rule_tac x=\"1\" in exI) simp"], ["", "lemma complex_sqrt_1:\n  fixes z::complex\n  assumes \"z \\<noteq> 0\"\n  shows \"z = 1 / z \\<longleftrightarrow> z = 1 \\<or> z = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z = 1 / z) = (z = 1 \\<or> z = - 1)", "using assms"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (z = 1 / z) = (z = 1 \\<or> z = - 1)", "using nonzero_eq_divide_eq square_eq_iff"], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n  ?c \\<noteq> (0::?'a) \\<Longrightarrow> (?a = ?b / ?c) = (?a * ?c = ?b)\n  (?a * ?a = ?b * ?b) = (?a = ?b \\<or> ?a = - ?b)\n\ngoal (1 subgoal):\n 1. (z = 1 / z) = (z = 1 \\<or> z = - 1)", "by fastforce"], ["", "end"]]}