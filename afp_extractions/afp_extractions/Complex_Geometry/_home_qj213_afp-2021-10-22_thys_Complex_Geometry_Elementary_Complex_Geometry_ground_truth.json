{"file_name": "/home/qj213/afp-2021-10-22/thys/Complex_Geometry/Elementary_Complex_Geometry.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Complex_Geometry", "problem_names": ["lemma collinear_ex_real:\n  shows \"collinear z1 z2 z3 \\<longleftrightarrow>\n         (\\<exists> k::real. z1 = z2 \\<or> z3 - z1 = complex_of_real k * (z2 - z1))\"", "lemma collinear_det:\n  assumes \"\\<not> collinear z1 z2 z3\"\n  shows \"det2 (z3 - z1) (cnj (z3 - z1)) (z1 - z2) (cnj (z1 - z2)) \\<noteq> 0\"", "lemma collinear_sym1:\n  shows \"collinear z1 z2 z3 \\<longleftrightarrow> collinear z1 z3 z2\"", "lemma collinear_sym2':\n  assumes \"collinear z1 z2 z3\"\n  shows \"collinear z2 z1 z3\"", "lemma collinear_sym2:\n  shows \"collinear z1 z2 z3 \\<longleftrightarrow> collinear z2 z1 z3\"", "lemma collinear_trans1:\n  assumes \"collinear z0 z2 z1\" and \"collinear z0 z3 z1\" and \"z0 \\<noteq> z1\"\n  shows \"collinear z0 z2 z3\"", "lemma line_points_collinear:\n  assumes \"z1 \\<in> line z z'\" and \"z2 \\<in> line z z'\" and \"z3 \\<in> line z z'\" and \"z \\<noteq> z'\"\n  shows \"collinear z1 z2 z3\"", "lemma line_param:\n  shows \"z1 + cor k * (z2 - z1) \\<in> line z1 z2\"", "lemma line_equation:\n  assumes \"z1 \\<noteq> z2\" and \"\\<mu> = rot90 (z2 - z1)\"\n  shows \"line z1 z2 = {z. cnj \\<mu>*z + \\<mu>*cnj z - (cnj \\<mu> * z1 + \\<mu> * cnj z1)  = 0}\"", "lemma circle_equation:\n  assumes \"r \\<ge> 0\"\n  shows \"circle \\<mu> r = {z. z*cnj z - z*cnj \\<mu> - cnj z*\\<mu> + \\<mu>*cnj \\<mu> - cor (r*r) = 0}\"", "lemma circline_circle:\n  assumes \"A \\<noteq> 0\" and \"A * D \\<le> (cmod BC)\\<^sup>2\"\n  \"cl = circline A BC D\" and\n  \"\\<mu> = -BC/cor A\" and \n  \"r2 = ((cmod BC)\\<^sup>2 - A*D) / A\\<^sup>2\" and \"r = sqrt r2\"\n  shows \"cl = circle \\<mu> r\"", "lemma circline_ex_circle:\n  assumes \"A \\<noteq> 0\" and \"A * D \\<le> (cmod BC)\\<^sup>2\" and \"cl = circline A BC D\"\n  shows \"\\<exists> \\<mu> r. cl = circle \\<mu> r\"", "lemma circle_circline:\n  assumes \"cl = circle \\<mu> r\" and \"r \\<ge> 0\"\n  shows \"cl = circline 1 (-\\<mu>) ((cmod \\<mu>)\\<^sup>2 - r\\<^sup>2)\"", "lemma circle_ex_circline:\n  assumes \"cl = circle \\<mu> r\" and \"r \\<ge> 0\"\n  shows \"\\<exists> A BC D. A \\<noteq> 0 \\<and> A*D \\<le> (cmod BC)\\<^sup>2 \\<and> cl = circline A BC D\"", "lemma circline_line:\n  assumes\n    \"A = 0\" and \"BC \\<noteq> 0\" and\n    \"cl = circline A BC D\" and\n    \"z1 = - cor D * BC / (2 * BC * cnj BC)\" and\n    \"z2 = z1 + \\<i> * sgn (if arg BC > 0 then -BC else BC)\"\n  shows\n    \"cl = line z1 z2\"", "lemma circline_ex_line:\n  assumes \"A = 0\" and \"BC \\<noteq> 0\" and \"cl = circline A BC D\"\n  shows \"\\<exists> z1 z2. z1 \\<noteq> z2 \\<and> cl = line z1 z2\"", "lemma line_ex_circline:\n  assumes \"cl = line z1 z2\" and \"z1 \\<noteq> z2\"\n  shows \"\\<exists> BC D. BC \\<noteq> 0 \\<and> cl = circline 0 BC D\"", "lemma circline_line':\n  assumes \"z1 \\<noteq> z2\"\n  shows \"circline 0 (\\<i> * (z2 - z1)) (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) = line z1 z2\"", "lemma circ_tang_vec_ortho:\n  shows \"scalprod (E - \\<mu>) (circ_tang_vec \\<mu> E p) = 0\"", "lemma circ_tang_vec_opposite_orient:\n  shows \"circ_tang_vec \\<mu> E p = - circ_tang_vec \\<mu> E (\\<not> p)\"", "lemma ang_circ_simp:\n  assumes \"E \\<noteq> \\<mu>1\" and \"E \\<noteq> \\<mu>2\"\n  shows \"ang_circ E \\<mu>1 \\<mu>2 p1 p2 =\n         \\<downharpoonright>arg (E - \\<mu>2) - arg (E - \\<mu>1) + sgn_bool p1 * pi / 2 - sgn_bool p2 * pi / 2\\<downharpoonleft>\"", "lemma cos_ang_circ_simp:\n  assumes \"E \\<noteq> \\<mu>1\" and \"E \\<noteq> \\<mu>2\"\n  shows \"cos (ang_circ E \\<mu>1 \\<mu>2 p1 p2) =\n         sgn_bool (p1 = p2) * cos (arg (E - \\<mu>2) - arg (E - \\<mu>1))\"", "lemma ang_circ_c_simp:\n  assumes \"E \\<noteq> \\<mu>1\" and \"E \\<noteq> \\<mu>2\"\n  shows \"ang_circ_c E \\<mu>1 \\<mu>2 p1 p2 = \n        \\<bar>\\<downharpoonright>arg (E - \\<mu>2) - arg (E - \\<mu>1) + sgn_bool p1 * pi / 2 - sgn_bool p2 * pi / 2\\<downharpoonleft>\\<bar>\"", "lemma ang_circ_a_simp:\n  assumes \"E \\<noteq> \\<mu>1\" and \"E \\<noteq> \\<mu>2\"\n  shows \"ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = \n         acute_ang (abs (canon_ang (arg(E - \\<mu>2) - arg(E - \\<mu>1) + (sgn_bool p1) * pi/2 - (sgn_bool p2) * pi/2)))\"", "lemma ang_circ_a_pTrue:\n  assumes \"E \\<noteq> \\<mu>1\" and \"E \\<noteq> \\<mu>2\"\n  shows \"ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True\"", "lemma ang_circ_a_simp1:\n  assumes \"E \\<noteq> \\<mu>1\" and \"E \\<noteq> \\<mu>2\"\n  shows \"ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = \\<angle>a (E - \\<mu>1) (E - \\<mu>2)\"", "lemma ang_circ_a'_simp:\n  assumes \"E \\<noteq> \\<mu>1\" and \"E \\<noteq> \\<mu>2\"\n  shows \"ang_circ_a' E \\<mu>1 \\<mu>2 = \\<angle>a (E - \\<mu>1) (E - \\<mu>2)\""], "translations": [["", "lemma collinear_ex_real:\n  shows \"collinear z1 z2 z3 \\<longleftrightarrow>\n         (\\<exists> k::real. z1 = z2 \\<or> z3 - z1 = complex_of_real k * (z2 - z1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collinear z1 z2 z3 =\n    (\\<exists>k. z1 = z2 \\<or> z3 - z1 = cor k * (z2 - z1))", "unfolding collinear_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (z1 = z2 \\<or> is_real ((z3 - z1) / (z2 - z1))) =\n    (\\<exists>k. z1 = z2 \\<or> z3 - z1 = cor k * (z2 - z1))", "by (metis Im_complex_of_real add_diff_cancel_right' complex_eq diff_zero legacy_Complex_simps(15) nonzero_mult_div_cancel_right right_minus_eq times_divide_eq_left zero_complex.code)"], ["", "text \\<open>Collinearity characterization using determinants\\<close>"], ["", "lemma collinear_det:\n  assumes \"\\<not> collinear z1 z2 z3\"\n  shows \"det2 (z3 - z1) (cnj (z3 - z1)) (z1 - z2) (cnj (z1 - z2)) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det2 (z3 - z1) (cnj (z3 - z1)) (z1 - z2) (cnj (z1 - z2)) \\<noteq> 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. det2 (z3 - z1) (cnj (z3 - z1)) (z1 - z2) (cnj (z1 - z2)) \\<noteq> 0", "from assms"], ["proof (chain)\npicking this:\n  \\<not> collinear z1 z2 z3", "have \"((z3 - z1) / (z2 - z1)) - cnj ((z3 - z1) / (z2 - z1)) \\<noteq> 0\" \"z2 \\<noteq> z1\""], ["proof (prove)\nusing this:\n  \\<not> collinear z1 z2 z3\n\ngoal (1 subgoal):\n 1. (z3 - z1) / (z2 - z1) - cnj ((z3 - z1) / (z2 - z1)) \\<noteq> 0 &&&\n    z2 \\<noteq> z1", "unfolding collinear_def"], ["proof (prove)\nusing this:\n  \\<not> (z1 = z2 \\<or> is_real ((z3 - z1) / (z2 - z1)))\n\ngoal (1 subgoal):\n 1. (z3 - z1) / (z2 - z1) - cnj ((z3 - z1) / (z2 - z1)) \\<noteq> 0 &&&\n    z2 \\<noteq> z1", "using Complex_Im_express_cnj[of \"(z3 - z1) / (z2 - z1)\"]"], ["proof (prove)\nusing this:\n  \\<not> (z1 = z2 \\<or> is_real ((z3 - z1) / (z2 - z1)))\n  Complex 0 (Im ((z3 - z1) / (z2 - z1))) =\n  ((z3 - z1) / (z2 - z1) - cnj ((z3 - z1) / (z2 - z1))) / 2\n\ngoal (1 subgoal):\n 1. (z3 - z1) / (z2 - z1) - cnj ((z3 - z1) / (z2 - z1)) \\<noteq> 0 &&&\n    z2 \\<noteq> z1", "by (auto simp add: Complex_eq)"], ["proof (state)\nthis:\n  (z3 - z1) / (z2 - z1) - cnj ((z3 - z1) / (z2 - z1)) \\<noteq> 0\n  z2 \\<noteq> z1\n\ngoal (1 subgoal):\n 1. det2 (z3 - z1) (cnj (z3 - z1)) (z1 - z2) (cnj (z1 - z2)) \\<noteq> 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  (z3 - z1) / (z2 - z1) - cnj ((z3 - z1) / (z2 - z1)) \\<noteq> 0\n  z2 \\<noteq> z1\n\ngoal (1 subgoal):\n 1. det2 (z3 - z1) (cnj (z3 - z1)) (z1 - z2) (cnj (z1 - z2)) \\<noteq> 0", "by (auto simp add: field_simps)"], ["proof (state)\nthis:\n  det2 (z3 - z1) (cnj (z3 - z1)) (z1 - z2) (cnj (z1 - z2)) \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Properties of three collinear points\\<close>"], ["", "lemma collinear_sym1:\n  shows \"collinear z1 z2 z3 \\<longleftrightarrow> collinear z1 z3 z2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collinear z1 z2 z3 = collinear z1 z3 z2", "unfolding collinear_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (z1 = z2 \\<or> is_real ((z3 - z1) / (z2 - z1))) =\n    (z1 = z3 \\<or> is_real ((z2 - z1) / (z3 - z1)))", "using div_reals[of \"1\" \"(z3 - z1)/(z2 - z1)\"]  div_reals[of \"1\" \"(z2 - z1)/(z3 - z1)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_real 1; is_real ((z3 - z1) / (z2 - z1))\\<rbrakk>\n  \\<Longrightarrow> is_real (1 / ((z3 - z1) / (z2 - z1)))\n  \\<lbrakk>is_real 1; is_real ((z2 - z1) / (z3 - z1))\\<rbrakk>\n  \\<Longrightarrow> is_real (1 / ((z2 - z1) / (z3 - z1)))\n\ngoal (1 subgoal):\n 1. (z1 = z2 \\<or> is_real ((z3 - z1) / (z2 - z1))) =\n    (z1 = z3 \\<or> is_real ((z2 - z1) / (z3 - z1)))", "by auto"], ["", "lemma collinear_sym2':\n  assumes \"collinear z1 z2 z3\"\n  shows \"collinear z2 z1 z3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collinear z2 z1 z3", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. collinear z2 z1 z3", "obtain k where \"z1 = z2 \\<or> z3 - z1 = complex_of_real k * (z2 - z1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        z1 = z2 \\<or> z3 - z1 = cor k * (z2 - z1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  collinear z1 z2 z3\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        z1 = z2 \\<or> z3 - z1 = cor k * (z2 - z1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding collinear_ex_real"], ["proof (prove)\nusing this:\n  \\<exists>k. z1 = z2 \\<or> z3 - z1 = cor k * (z2 - z1)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        z1 = z2 \\<or> z3 - z1 = cor k * (z2 - z1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z1 = z2 \\<or> z3 - z1 = cor k * (z2 - z1)\n\ngoal (1 subgoal):\n 1. collinear z2 z1 z3", "thus ?thesis"], ["proof (prove)\nusing this:\n  z1 = z2 \\<or> z3 - z1 = cor k * (z2 - z1)\n\ngoal (1 subgoal):\n 1. collinear z2 z1 z3", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. z1 = z2 \\<Longrightarrow> collinear z2 z1 z3\n 2. z3 - z1 = cor k * (z2 - z1) \\<Longrightarrow> collinear z2 z1 z3", "assume \"z3 - z1 = complex_of_real k * (z2 - z1)\""], ["proof (state)\nthis:\n  z3 - z1 = cor k * (z2 - z1)\n\ngoal (2 subgoals):\n 1. z1 = z2 \\<Longrightarrow> collinear z2 z1 z3\n 2. z3 - z1 = cor k * (z2 - z1) \\<Longrightarrow> collinear z2 z1 z3", "thus ?thesis"], ["proof (prove)\nusing this:\n  z3 - z1 = cor k * (z2 - z1)\n\ngoal (1 subgoal):\n 1. collinear z2 z1 z3", "unfolding collinear_ex_real"], ["proof (prove)\nusing this:\n  z3 - z1 = cor k * (z2 - z1)\n\ngoal (1 subgoal):\n 1. \\<exists>k. z2 = z1 \\<or> z3 - z2 = cor k * (z1 - z2)", "by (rule_tac x=\"1-k\" in exI) (auto simp add: field_simps)"], ["proof (state)\nthis:\n  collinear z2 z1 z3\n\ngoal (1 subgoal):\n 1. z1 = z2 \\<Longrightarrow> collinear z2 z1 z3", "qed (simp add: collinear_def)"], ["proof (state)\nthis:\n  collinear z2 z1 z3\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma collinear_sym2:\n  shows \"collinear z1 z2 z3 \\<longleftrightarrow> collinear z2 z1 z3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collinear z1 z2 z3 = collinear z2 z1 z3", "using collinear_sym2'[of z1 z2 z3] collinear_sym2'[of z2 z1 z3]"], ["proof (prove)\nusing this:\n  collinear z1 z2 z3 \\<Longrightarrow> collinear z2 z1 z3\n  collinear z2 z1 z3 \\<Longrightarrow> collinear z1 z2 z3\n\ngoal (1 subgoal):\n 1. collinear z1 z2 z3 = collinear z2 z1 z3", "by auto"], ["", "text \\<open>Properties of four collinear points\\<close>"], ["", "lemma collinear_trans1:\n  assumes \"collinear z0 z2 z1\" and \"collinear z0 z3 z1\" and \"z0 \\<noteq> z1\"\n  shows \"collinear z0 z2 z3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collinear z0 z2 z3", "using assms"], ["proof (prove)\nusing this:\n  collinear z0 z2 z1\n  collinear z0 z3 z1\n  z0 \\<noteq> z1\n\ngoal (1 subgoal):\n 1. collinear z0 z2 z3", "unfolding collinear_ex_real"], ["proof (prove)\nusing this:\n  \\<exists>k. z0 = z2 \\<or> z1 - z0 = cor k * (z2 - z0)\n  \\<exists>k. z0 = z3 \\<or> z1 - z0 = cor k * (z3 - z0)\n  z0 \\<noteq> z1\n\ngoal (1 subgoal):\n 1. \\<exists>k. z0 = z2 \\<or> z3 - z0 = cor k * (z2 - z0)", "by (cases \"z0 = z2\", auto) (rule_tac x=\"k/ka\" in exI, case_tac \"ka = 0\", auto simp add: field_simps)"], ["", "(* ----------------------------------------------------------------- *)"], ["", "subsection \\<open>Euclidean line\\<close>"], ["", "(* ----------------------------------------------------------------- *)"], ["", "text \\<open>Line is defined by using collinearity\\<close>"], ["", "definition line :: \"complex \\<Rightarrow> complex \\<Rightarrow> complex set\" where\n  \"line z1 z2 = {z. collinear z1 z2 z}\""], ["", "lemma line_points_collinear:\n  assumes \"z1 \\<in> line z z'\" and \"z2 \\<in> line z z'\" and \"z3 \\<in> line z z'\" and \"z \\<noteq> z'\"\n  shows \"collinear z1 z2 z3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collinear z1 z2 z3", "using assms"], ["proof (prove)\nusing this:\n  z1 \\<in> line z z'\n  z2 \\<in> line z z'\n  z3 \\<in> line z z'\n  z \\<noteq> z'\n\ngoal (1 subgoal):\n 1. collinear z1 z2 z3", "unfolding line_def"], ["proof (prove)\nusing this:\n  z1 \\<in> Collect (collinear z z')\n  z2 \\<in> Collect (collinear z z')\n  z3 \\<in> Collect (collinear z z')\n  z \\<noteq> z'\n\ngoal (1 subgoal):\n 1. collinear z1 z2 z3", "by (smt collinear_sym1 collinear_sym2' collinear_trans1 mem_Collect_eq)"], ["", "text \\<open>Parametric equation of a line\\<close>"], ["", "lemma line_param:\n  shows \"z1 + cor k * (z2 - z1) \\<in> line z1 z2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z1 + cor k * (z2 - z1) \\<in> line z1 z2", "unfolding line_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. z1 + cor k * (z2 - z1) \\<in> Collect (collinear z1 z2)", "by (auto simp add: collinear_def)"], ["", "text \\<open>Equation of the line containing two different given points\\<close>"], ["", "lemma line_equation:\n  assumes \"z1 \\<noteq> z2\" and \"\\<mu> = rot90 (z2 - z1)\"\n  shows \"line z1 z2 = {z. cnj \\<mu>*z + \\<mu>*cnj z - (cnj \\<mu> * z1 + \\<mu> * cnj z1)  = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line z1 z2 = {z. cnj_mix \\<mu> z - cnj_mix \\<mu> z1 = 0}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. line z1 z2 = {z. cnj_mix \\<mu> z - cnj_mix \\<mu> z1 = 0}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. line z1 z2 = {z. cnj_mix \\<mu> z - cnj_mix \\<mu> z1 = 0}", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. line z1 z2 = {z. cnj_mix \\<mu> z - cnj_mix \\<mu> z1 = 0}", "have \"z \\<in> line z1 z2 \\<longleftrightarrow> Im ((z - z1)/(z2 - z1)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<in> line z1 z2) = is_real ((z - z1) / (z2 - z1))", "using assms"], ["proof (prove)\nusing this:\n  z1 \\<noteq> z2\n  \\<mu> = rot90 (z2 - z1)\n\ngoal (1 subgoal):\n 1. (z \\<in> line z1 z2) = is_real ((z - z1) / (z2 - z1))", "by (simp add: line_def collinear_def)"], ["proof (state)\nthis:\n  (z \\<in> line z1 z2) = is_real ((z - z1) / (z2 - z1))\n\ngoal (1 subgoal):\n 1. line z1 z2 = {z. cnj_mix \\<mu> z - cnj_mix \\<mu> z1 = 0}", "also"], ["proof (state)\nthis:\n  (z \\<in> line z1 z2) = is_real ((z - z1) / (z2 - z1))\n\ngoal (1 subgoal):\n 1. line z1 z2 = {z. cnj_mix \\<mu> z - cnj_mix \\<mu> z1 = 0}", "have \"... \\<longleftrightarrow> (z - z1)/(z2 - z1) = cnj ((z - z1)/(z2 - z1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real ((z - z1) / (z2 - z1)) =\n    ((z - z1) / (z2 - z1) = cnj ((z - z1) / (z2 - z1)))", "using complex_diff_cnj[of \"(z - z1)/(z2 - z1)\"]"], ["proof (prove)\nusing this:\n  (z - z1) / (z2 - z1) - cnj ((z - z1) / (z2 - z1)) =\n  cor (2 * Im ((z - z1) / (z2 - z1))) * \\<i>\n\ngoal (1 subgoal):\n 1. is_real ((z - z1) / (z2 - z1)) =\n    ((z - z1) / (z2 - z1) = cnj ((z - z1) / (z2 - z1)))", "by auto"], ["proof (state)\nthis:\n  is_real ((z - z1) / (z2 - z1)) =\n  ((z - z1) / (z2 - z1) = cnj ((z - z1) / (z2 - z1)))\n\ngoal (1 subgoal):\n 1. line z1 z2 = {z. cnj_mix \\<mu> z - cnj_mix \\<mu> z1 = 0}", "also"], ["proof (state)\nthis:\n  is_real ((z - z1) / (z2 - z1)) =\n  ((z - z1) / (z2 - z1) = cnj ((z - z1) / (z2 - z1)))\n\ngoal (1 subgoal):\n 1. line z1 z2 = {z. cnj_mix \\<mu> z - cnj_mix \\<mu> z1 = 0}", "have \"... \\<longleftrightarrow> (z - z1)*(cnj z2 - cnj z1) = (cnj z - cnj z1)*(z2 - z1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((z - z1) / (z2 - z1) = cnj ((z - z1) / (z2 - z1))) =\n    ((z - z1) * (cnj z2 - cnj z1) = (cnj z - cnj z1) * (z2 - z1))", "using assms(1)"], ["proof (prove)\nusing this:\n  z1 \\<noteq> z2\n\ngoal (1 subgoal):\n 1. ((z - z1) / (z2 - z1) = cnj ((z - z1) / (z2 - z1))) =\n    ((z - z1) * (cnj z2 - cnj z1) = (cnj z - cnj z1) * (z2 - z1))", "using \\<open>(z \\<in> line z1 z2) = is_real ((z - z1) / (z2 - z1))\\<close> calculation is_real_div"], ["proof (prove)\nusing this:\n  z1 \\<noteq> z2\n  (z \\<in> line z1 z2) = is_real ((z - z1) / (z2 - z1))\n  (z \\<in> line z1 z2) = ((z - z1) / (z2 - z1) = cnj ((z - z1) / (z2 - z1)))\n  ?b \\<noteq> 0 \\<Longrightarrow>\n  is_real (?a / ?b) = (?a * cnj ?b = ?b * cnj ?a)\n\ngoal (1 subgoal):\n 1. ((z - z1) / (z2 - z1) = cnj ((z - z1) / (z2 - z1))) =\n    ((z - z1) * (cnj z2 - cnj z1) = (cnj z - cnj z1) * (z2 - z1))", "by auto"], ["proof (state)\nthis:\n  ((z - z1) / (z2 - z1) = cnj ((z - z1) / (z2 - z1))) =\n  ((z - z1) * (cnj z2 - cnj z1) = (cnj z - cnj z1) * (z2 - z1))\n\ngoal (1 subgoal):\n 1. line z1 z2 = {z. cnj_mix \\<mu> z - cnj_mix \\<mu> z1 = 0}", "also"], ["proof (state)\nthis:\n  ((z - z1) / (z2 - z1) = cnj ((z - z1) / (z2 - z1))) =\n  ((z - z1) * (cnj z2 - cnj z1) = (cnj z - cnj z1) * (z2 - z1))\n\ngoal (1 subgoal):\n 1. line z1 z2 = {z. cnj_mix \\<mu> z - cnj_mix \\<mu> z1 = 0}", "have \"... \\<longleftrightarrow> cnj(z2 - z1)*z - (z2 - z1)*cnj z - (cnj(z2 - z1)*z1 - (z2 - z1)*cnj z1) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((z - z1) * (cnj z2 - cnj z1) = (cnj z - cnj z1) * (z2 - z1)) =\n    (cnj (z2 - z1) * z - (z2 - z1) * cnj z -\n     (cnj (z2 - z1) * z1 - (z2 - z1) * cnj z1) =\n     0)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  ((z - z1) * (cnj z2 - cnj z1) = (cnj z - cnj z1) * (z2 - z1)) =\n  (cnj (z2 - z1) * z - (z2 - z1) * cnj z -\n   (cnj (z2 - z1) * z1 - (z2 - z1) * cnj z1) =\n   0)\n\ngoal (1 subgoal):\n 1. line z1 z2 = {z. cnj_mix \\<mu> z - cnj_mix \\<mu> z1 = 0}", "also"], ["proof (state)\nthis:\n  ((z - z1) * (cnj z2 - cnj z1) = (cnj z - cnj z1) * (z2 - z1)) =\n  (cnj (z2 - z1) * z - (z2 - z1) * cnj z -\n   (cnj (z2 - z1) * z1 - (z2 - z1) * cnj z1) =\n   0)\n\ngoal (1 subgoal):\n 1. line z1 z2 = {z. cnj_mix \\<mu> z - cnj_mix \\<mu> z1 = 0}", "have \"... \\<longleftrightarrow> cnj \\<mu> * z + \\<mu> * cnj z  - (cnj \\<mu> * z1 + \\<mu> * cnj z1) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cnj (z2 - z1) * z - (z2 - z1) * cnj z -\n     (cnj (z2 - z1) * z1 - (z2 - z1) * cnj z1) =\n     0) =\n    (cnj_mix \\<mu> z - cnj_mix \\<mu> z1 = 0)", "apply (subst assms)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cnj (z2 - z1) * z - (z2 - z1) * cnj z -\n     (cnj (z2 - z1) * z1 - (z2 - z1) * cnj z1) =\n     0) =\n    (cnj_mix (rot90 (z2 - z1)) z - cnj_mix (rot90 (z2 - z1)) z1 = 0)", "apply (subst cnj_mix_minus)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<i> * cnj_mix (rot90 (z2 - z1)) z -\n     \\<i> * cnj_mix (rot90 (z2 - z1)) z1 =\n     0) =\n    (cnj_mix (rot90 (z2 - z1)) z - cnj_mix (rot90 (z2 - z1)) z1 = 0)", "by simp"], ["proof (state)\nthis:\n  (cnj (z2 - z1) * z - (z2 - z1) * cnj z -\n   (cnj (z2 - z1) * z1 - (z2 - z1) * cnj z1) =\n   0) =\n  (cnj_mix \\<mu> z - cnj_mix \\<mu> z1 = 0)\n\ngoal (1 subgoal):\n 1. line z1 z2 = {z. cnj_mix \\<mu> z - cnj_mix \\<mu> z1 = 0}", "finally"], ["proof (chain)\npicking this:\n  (z \\<in> line z1 z2) = (cnj_mix \\<mu> z - cnj_mix \\<mu> z1 = 0)", "have \"z \\<in> line z1 z2 \\<longleftrightarrow> cnj \\<mu> * z + \\<mu> * cnj z  - (cnj \\<mu> * z1 + \\<mu> * cnj z1) = 0\""], ["proof (prove)\nusing this:\n  (z \\<in> line z1 z2) = (cnj_mix \\<mu> z - cnj_mix \\<mu> z1 = 0)\n\ngoal (1 subgoal):\n 1. (z \\<in> line z1 z2) = (cnj_mix \\<mu> z - cnj_mix \\<mu> z1 = 0)", "."], ["proof (state)\nthis:\n  (z \\<in> line z1 z2) = (cnj_mix \\<mu> z - cnj_mix \\<mu> z1 = 0)\n\ngoal (1 subgoal):\n 1. line z1 z2 = {z. cnj_mix \\<mu> z - cnj_mix \\<mu> z1 = 0}", "}"], ["proof (state)\nthis:\n  (?z2 \\<in> line z1 z2) = (cnj_mix \\<mu> ?z2 - cnj_mix \\<mu> z1 = 0)\n\ngoal (1 subgoal):\n 1. line z1 z2 = {z. cnj_mix \\<mu> z - cnj_mix \\<mu> z1 = 0}", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?z2 \\<in> line z1 z2) = (cnj_mix \\<mu> ?z2 - cnj_mix \\<mu> z1 = 0)\n\ngoal (1 subgoal):\n 1. line z1 z2 = {z. cnj_mix \\<mu> z - cnj_mix \\<mu> z1 = 0}", "by auto"], ["proof (state)\nthis:\n  line z1 z2 = {z. cnj_mix \\<mu> z - cnj_mix \\<mu> z1 = 0}\n\ngoal:\nNo subgoals!", "qed"], ["", "(* -------------------------------------------------------------------------- *)"], ["", "subsection \\<open>Euclidean circle\\<close>"], ["", "(* -------------------------------------------------------------------------- *)"], ["", "text \\<open>Definition of the circle with given center and radius. It consists of all\npoints on the distance $r$ from the center $\\mu$.\\<close>"], ["", "definition circle :: \"complex \\<Rightarrow> real \\<Rightarrow> complex set\" where\n  \"circle \\<mu> r = {z. cmod (z - \\<mu>) = r}\""], ["", "text \\<open>Equation of the circle centered at $\\mu$ with the radius $r$.\\<close>"], ["", "lemma circle_equation:\n  assumes \"r \\<ge> 0\"\n  shows \"circle \\<mu> r = {z. z*cnj z - z*cnj \\<mu> - cnj z*\\<mu> + \\<mu>*cnj \\<mu> - cor (r*r) = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. circle \\<mu> r =\n    {z. z * cnj z - z * cnj \\<mu> - cnj z * \\<mu> + \\<mu> * cnj \\<mu> -\n        cor (r * r) =\n        0}", "proof (safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> circle \\<mu> r \\<Longrightarrow>\n       x * cnj x - x * cnj \\<mu> - cnj x * \\<mu> + \\<mu> * cnj \\<mu> -\n       cor (r * r) =\n       0\n 2. \\<And>x.\n       x * cnj x - x * cnj \\<mu> - cnj x * \\<mu> + \\<mu> * cnj \\<mu> -\n       cor (r * r) =\n       0 \\<Longrightarrow>\n       x \\<in> circle \\<mu> r", "fix z"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> circle \\<mu> r \\<Longrightarrow>\n       x * cnj x - x * cnj \\<mu> - cnj x * \\<mu> + \\<mu> * cnj \\<mu> -\n       cor (r * r) =\n       0\n 2. \\<And>x.\n       x * cnj x - x * cnj \\<mu> - cnj x * \\<mu> + \\<mu> * cnj \\<mu> -\n       cor (r * r) =\n       0 \\<Longrightarrow>\n       x \\<in> circle \\<mu> r", "assume \"z \\<in> circle \\<mu> r\""], ["proof (state)\nthis:\n  z \\<in> circle \\<mu> r\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> circle \\<mu> r \\<Longrightarrow>\n       x * cnj x - x * cnj \\<mu> - cnj x * \\<mu> + \\<mu> * cnj \\<mu> -\n       cor (r * r) =\n       0\n 2. \\<And>x.\n       x * cnj x - x * cnj \\<mu> - cnj x * \\<mu> + \\<mu> * cnj \\<mu> -\n       cor (r * r) =\n       0 \\<Longrightarrow>\n       x \\<in> circle \\<mu> r", "hence \"(z - \\<mu>)*cnj (z - \\<mu>) = complex_of_real (r*r)\""], ["proof (prove)\nusing this:\n  z \\<in> circle \\<mu> r\n\ngoal (1 subgoal):\n 1. (z - \\<mu>) * cnj (z - \\<mu>) = cor (r * r)", "unfolding circle_def"], ["proof (prove)\nusing this:\n  z \\<in> {z. cmod (z - \\<mu>) = r}\n\ngoal (1 subgoal):\n 1. (z - \\<mu>) * cnj (z - \\<mu>) = cor (r * r)", "using complex_mult_cnj_cmod[of \"z - \\<mu>\"]"], ["proof (prove)\nusing this:\n  z \\<in> {z. cmod (z - \\<mu>) = r}\n  (z - \\<mu>) * cnj (z - \\<mu>) = cor ((cmod (z - \\<mu>))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (z - \\<mu>) * cnj (z - \\<mu>) = cor (r * r)", "by (auto simp add: power2_eq_square)"], ["proof (state)\nthis:\n  (z - \\<mu>) * cnj (z - \\<mu>) = cor (r * r)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> circle \\<mu> r \\<Longrightarrow>\n       x * cnj x - x * cnj \\<mu> - cnj x * \\<mu> + \\<mu> * cnj \\<mu> -\n       cor (r * r) =\n       0\n 2. \\<And>x.\n       x * cnj x - x * cnj \\<mu> - cnj x * \\<mu> + \\<mu> * cnj \\<mu> -\n       cor (r * r) =\n       0 \\<Longrightarrow>\n       x \\<in> circle \\<mu> r", "thus \"z * cnj z - z * cnj \\<mu> - cnj z * \\<mu> + \\<mu> * cnj \\<mu> - cor (r * r) = 0\""], ["proof (prove)\nusing this:\n  (z - \\<mu>) * cnj (z - \\<mu>) = cor (r * r)\n\ngoal (1 subgoal):\n 1. z * cnj z - z * cnj \\<mu> - cnj z * \\<mu> + \\<mu> * cnj \\<mu> -\n    cor (r * r) =\n    0", "by (auto simp add: field_simps)"], ["proof (state)\nthis:\n  z * cnj z - z * cnj \\<mu> - cnj z * \\<mu> + \\<mu> * cnj \\<mu> -\n  cor (r * r) =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x * cnj x - x * cnj \\<mu> - cnj x * \\<mu> + \\<mu> * cnj \\<mu> -\n       cor (r * r) =\n       0 \\<Longrightarrow>\n       x \\<in> circle \\<mu> r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x * cnj x - x * cnj \\<mu> - cnj x * \\<mu> + \\<mu> * cnj \\<mu> -\n       cor (r * r) =\n       0 \\<Longrightarrow>\n       x \\<in> circle \\<mu> r", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x * cnj x - x * cnj \\<mu> - cnj x * \\<mu> + \\<mu> * cnj \\<mu> -\n       cor (r * r) =\n       0 \\<Longrightarrow>\n       x \\<in> circle \\<mu> r", "assume \"z * cnj z - z * cnj \\<mu> - cnj z * \\<mu> + \\<mu> * cnj \\<mu> - cor (r * r) = 0\""], ["proof (state)\nthis:\n  z * cnj z - z * cnj \\<mu> - cnj z * \\<mu> + \\<mu> * cnj \\<mu> -\n  cor (r * r) =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x * cnj x - x * cnj \\<mu> - cnj x * \\<mu> + \\<mu> * cnj \\<mu> -\n       cor (r * r) =\n       0 \\<Longrightarrow>\n       x \\<in> circle \\<mu> r", "hence \"(z - \\<mu>)*cnj (z - \\<mu>) = cor (r*r)\""], ["proof (prove)\nusing this:\n  z * cnj z - z * cnj \\<mu> - cnj z * \\<mu> + \\<mu> * cnj \\<mu> -\n  cor (r * r) =\n  0\n\ngoal (1 subgoal):\n 1. (z - \\<mu>) * cnj (z - \\<mu>) = cor (r * r)", "by (auto simp add: field_simps)"], ["proof (state)\nthis:\n  (z - \\<mu>) * cnj (z - \\<mu>) = cor (r * r)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x * cnj x - x * cnj \\<mu> - cnj x * \\<mu> + \\<mu> * cnj \\<mu> -\n       cor (r * r) =\n       0 \\<Longrightarrow>\n       x \\<in> circle \\<mu> r", "thus \"z \\<in> circle \\<mu> r\""], ["proof (prove)\nusing this:\n  (z - \\<mu>) * cnj (z - \\<mu>) = cor (r * r)\n\ngoal (1 subgoal):\n 1. z \\<in> circle \\<mu> r", "using assms"], ["proof (prove)\nusing this:\n  (z - \\<mu>) * cnj (z - \\<mu>) = cor (r * r)\n  0 \\<le> r\n\ngoal (1 subgoal):\n 1. z \\<in> circle \\<mu> r", "using complex_mult_cnj_cmod[of \"z - \\<mu>\"]"], ["proof (prove)\nusing this:\n  (z - \\<mu>) * cnj (z - \\<mu>) = cor (r * r)\n  0 \\<le> r\n  (z - \\<mu>) * cnj (z - \\<mu>) = cor ((cmod (z - \\<mu>))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. z \\<in> circle \\<mu> r", "using power2_eq_imp_eq[of \"cmod (z - \\<mu>)\" r]"], ["proof (prove)\nusing this:\n  (z - \\<mu>) * cnj (z - \\<mu>) = cor (r * r)\n  0 \\<le> r\n  (z - \\<mu>) * cnj (z - \\<mu>) = cor ((cmod (z - \\<mu>))\\<^sup>2)\n  \\<lbrakk>(cmod (z - \\<mu>))\\<^sup>2 = r\\<^sup>2; 0 \\<le> cmod (z - \\<mu>);\n   0 \\<le> r\\<rbrakk>\n  \\<Longrightarrow> cmod (z - \\<mu>) = r\n\ngoal (1 subgoal):\n 1. z \\<in> circle \\<mu> r", "unfolding circle_def power2_eq_square[symmetric] complex_of_real_def"], ["proof (prove)\nusing this:\n  (z - \\<mu>) * cnj (z - \\<mu>) = Complex (r\\<^sup>2) 0\n  0 \\<le> r\n  (z - \\<mu>) * cnj (z - \\<mu>) = Complex ((cmod (z - \\<mu>))\\<^sup>2) 0\n  \\<lbrakk>(cmod (z - \\<mu>))\\<^sup>2 = r\\<^sup>2; 0 \\<le> cmod (z - \\<mu>);\n   0 \\<le> r\\<rbrakk>\n  \\<Longrightarrow> cmod (z - \\<mu>) = r\n\ngoal (1 subgoal):\n 1. z \\<in> {z. cmod (z - \\<mu>) = r}", "by auto"], ["proof (state)\nthis:\n  z \\<in> circle \\<mu> r\n\ngoal:\nNo subgoals!", "qed"], ["", "(* -------------------------------------------------------------------------- *)"], ["", "subsection \\<open>Circline\\<close>"], ["", "(* -------------------------------------------------------------------------- *)"], ["", "text \\<open>A very important property of the extended complex plane is that it is possible to treat circles\nand lines in a uniform way. The basic object is \\emph{generalized circle}, or \\emph{circline} for\nshort. We introduce circline equation given in $\\mathbb{C}$, and it will later be generalized to an\nequation in the extended complex plane $\\overline{\\mathbb{C}}$ given in matrix form using a\nHermitean matrix and a quadratic form over homogenous coordinates.\\<close>"], ["", "definition circline where\n  \"circline A BC D = {z. cor A*z*cnj z + cnj BC*z + BC*cnj z + cor D = 0}\""], ["", "text \\<open>Connection between circline and Euclidean circle\\<close>"], ["", "text \\<open>Every circline with positive determinant and $A \\neq 0$ represents an Euclidean circle\\<close>"], ["", "lemma circline_circle:\n  assumes \"A \\<noteq> 0\" and \"A * D \\<le> (cmod BC)\\<^sup>2\"\n  \"cl = circline A BC D\" and\n  \"\\<mu> = -BC/cor A\" and \n  \"r2 = ((cmod BC)\\<^sup>2 - A*D) / A\\<^sup>2\" and \"r = sqrt r2\"\n  shows \"cl = circle \\<mu> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl = circle \\<mu> r", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. cl = circle \\<mu> r", "have *: \"cl = {z. z * cnj z + cnj (BC / cor A) * z + (BC / cor A) * cnj z + cor (D / A) = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl =\n    {z. z * cnj z + cnj (BC / cor A) * z + BC / cor A * cnj z +\n        cor (D / A) =\n        0}", "using \\<open>cl = circline A BC D\\<close> \\<open>A \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  cl = circline A BC D\n  A \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cl =\n    {z. z * cnj z + cnj (BC / cor A) * z + BC / cor A * cnj z +\n        cor (D / A) =\n        0}", "by (auto simp add: circline_def field_simps)"], ["proof (state)\nthis:\n  cl =\n  {z. z * cnj z + cnj (BC / cor A) * z + BC / cor A * cnj z + cor (D / A) =\n      0}\n\ngoal (1 subgoal):\n 1. cl = circle \\<mu> r", "have \"r2 \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> r2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> r2", "have \"(cmod BC)\\<^sup>2 - A * D \\<ge>  0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (cmod BC)\\<^sup>2 - A * D", "using \\<open>A * D \\<le> (cmod BC)\\<^sup>2\\<close>"], ["proof (prove)\nusing this:\n  A * D \\<le> (cmod BC)\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 \\<le> (cmod BC)\\<^sup>2 - A * D", "by auto"], ["proof (state)\nthis:\n  0 \\<le> (cmod BC)\\<^sup>2 - A * D\n\ngoal (1 subgoal):\n 1. 0 \\<le> r2", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> (cmod BC)\\<^sup>2 - A * D\n\ngoal (1 subgoal):\n 1. 0 \\<le> r2", "using \\<open>A \\<noteq> 0\\<close> \\<open>r2 = ((cmod BC)\\<^sup>2 - A*D) / A\\<^sup>2\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> (cmod BC)\\<^sup>2 - A * D\n  A \\<noteq> 0\n  r2 = ((cmod BC)\\<^sup>2 - A * D) / A\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 \\<le> r2", "by (metis zero_le_divide_iff zero_le_power2)"], ["proof (state)\nthis:\n  0 \\<le> r2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> r2\n\ngoal (1 subgoal):\n 1. cl = circle \\<mu> r", "hence **: \"r * r = r2\" \"r \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> r2\n\ngoal (1 subgoal):\n 1. r * r = r2 &&& 0 \\<le> r", "using \\<open>r = sqrt r2\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> r2\n  r = sqrt r2\n\ngoal (1 subgoal):\n 1. r * r = r2 &&& 0 \\<le> r", "by (auto simp add: real_sqrt_mult[symmetric])"], ["proof (state)\nthis:\n  r * r = r2\n  0 \\<le> r\n\ngoal (1 subgoal):\n 1. cl = circle \\<mu> r", "have ***: \"- \\<mu> * - cnj \\<mu> - cor r2 = cor (D / A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - \\<mu> * - cnj \\<mu> - cor r2 = cor (D / A)", "using \\<open>\\<mu> = - BC / complex_of_real A\\<close> \\<open>r2 = ((cmod BC)\\<^sup>2 - A * D) / A\\<^sup>2\\<close>"], ["proof (prove)\nusing this:\n  \\<mu> = - BC / cor A\n  r2 = ((cmod BC)\\<^sup>2 - A * D) / A\\<^sup>2\n\ngoal (1 subgoal):\n 1. - \\<mu> * - cnj \\<mu> - cor r2 = cor (D / A)", "by (auto simp add: power2_eq_square complex_mult_cnj_cmod field_simps)\n       (simp add: add_divide_eq_iff assms(1))"], ["proof (state)\nthis:\n  - \\<mu> * - cnj \\<mu> - cor r2 = cor (D / A)\n\ngoal (1 subgoal):\n 1. cl = circle \\<mu> r", "thus ?thesis"], ["proof (prove)\nusing this:\n  - \\<mu> * - cnj \\<mu> - cor r2 = cor (D / A)\n\ngoal (1 subgoal):\n 1. cl = circle \\<mu> r", "using \\<open>r2 = ((cmod BC)\\<^sup>2 - A*D) / A\\<^sup>2\\<close> \\<open>\\<mu> = - BC / cor A\\<close>"], ["proof (prove)\nusing this:\n  - \\<mu> * - cnj \\<mu> - cor r2 = cor (D / A)\n  r2 = ((cmod BC)\\<^sup>2 - A * D) / A\\<^sup>2\n  \\<mu> = - BC / cor A\n\ngoal (1 subgoal):\n 1. cl = circle \\<mu> r", "by (subst *, subst circle_equation[of r \\<mu>, OF \\<open>r \\<ge> 0\\<close>], subst **) (auto simp add: field_simps power2_eq_square)"], ["proof (state)\nthis:\n  cl = circle \\<mu> r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma circline_ex_circle:\n  assumes \"A \\<noteq> 0\" and \"A * D \\<le> (cmod BC)\\<^sup>2\" and \"cl = circline A BC D\"\n  shows \"\\<exists> \\<mu> r. cl = circle \\<mu> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<mu> r. cl = circle \\<mu> r", "using circline_circle[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<mu> = - BC / cor A;\n   ?r2.0 = ((cmod BC)\\<^sup>2 - A * D) / A\\<^sup>2; ?r = sqrt ?r2.0\\<rbrakk>\n  \\<Longrightarrow> cl = circle ?\\<mu> ?r\n\ngoal (1 subgoal):\n 1. \\<exists>\\<mu> r. cl = circle \\<mu> r", "by auto"], ["", "text \\<open>Every Euclidean circle can be represented by a circline\\<close>"], ["", "lemma circle_circline:\n  assumes \"cl = circle \\<mu> r\" and \"r \\<ge> 0\"\n  shows \"cl = circline 1 (-\\<mu>) ((cmod \\<mu>)\\<^sup>2 - r\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl = circline 1 (- \\<mu>) ((cmod \\<mu>)\\<^sup>2 - r\\<^sup>2)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. cl = circline 1 (- \\<mu>) ((cmod \\<mu>)\\<^sup>2 - r\\<^sup>2)", "have \"complex_of_real ((cmod \\<mu>)\\<^sup>2 - r\\<^sup>2) = \\<mu> * cnj \\<mu> - complex_of_real (r\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cor ((cmod \\<mu>)\\<^sup>2 - r\\<^sup>2) =\n    \\<mu> * cnj \\<mu> - cor (r\\<^sup>2)", "by (auto simp add: complex_mult_cnj_cmod)"], ["proof (state)\nthis:\n  cor ((cmod \\<mu>)\\<^sup>2 - r\\<^sup>2) =\n  \\<mu> * cnj \\<mu> - cor (r\\<^sup>2)\n\ngoal (1 subgoal):\n 1. cl = circline 1 (- \\<mu>) ((cmod \\<mu>)\\<^sup>2 - r\\<^sup>2)", "thus \"cl = circline 1 (- \\<mu>) ((cmod \\<mu>)\\<^sup>2 - r\\<^sup>2)\""], ["proof (prove)\nusing this:\n  cor ((cmod \\<mu>)\\<^sup>2 - r\\<^sup>2) =\n  \\<mu> * cnj \\<mu> - cor (r\\<^sup>2)\n\ngoal (1 subgoal):\n 1. cl = circline 1 (- \\<mu>) ((cmod \\<mu>)\\<^sup>2 - r\\<^sup>2)", "using assms"], ["proof (prove)\nusing this:\n  cor ((cmod \\<mu>)\\<^sup>2 - r\\<^sup>2) =\n  \\<mu> * cnj \\<mu> - cor (r\\<^sup>2)\n  cl = circle \\<mu> r\n  0 \\<le> r\n\ngoal (1 subgoal):\n 1. cl = circline 1 (- \\<mu>) ((cmod \\<mu>)\\<^sup>2 - r\\<^sup>2)", "using circle_equation[of r \\<mu>]"], ["proof (prove)\nusing this:\n  cor ((cmod \\<mu>)\\<^sup>2 - r\\<^sup>2) =\n  \\<mu> * cnj \\<mu> - cor (r\\<^sup>2)\n  cl = circle \\<mu> r\n  0 \\<le> r\n  0 \\<le> r \\<Longrightarrow>\n  circle \\<mu> r =\n  {z. z * cnj z - z * cnj \\<mu> - cnj z * \\<mu> + \\<mu> * cnj \\<mu> -\n      cor (r * r) =\n      0}\n\ngoal (1 subgoal):\n 1. cl = circline 1 (- \\<mu>) ((cmod \\<mu>)\\<^sup>2 - r\\<^sup>2)", "unfolding circline_def power2_eq_square"], ["proof (prove)\nusing this:\n  cor (cmod \\<mu> * cmod \\<mu> - r * r) = \\<mu> * cnj \\<mu> - cor (r * r)\n  cl = circle \\<mu> r\n  0 \\<le> r\n  0 \\<le> r \\<Longrightarrow>\n  circle \\<mu> r =\n  {z. z * cnj z - z * cnj \\<mu> - cnj z * \\<mu> + \\<mu> * cnj \\<mu> -\n      cor (r * r) =\n      0}\n\ngoal (1 subgoal):\n 1. cl =\n    {z. cor 1 * z * cnj z + cnj (- \\<mu>) * z + - \\<mu> * cnj z +\n        cor (cmod \\<mu> * cmod \\<mu> - r * r) =\n        0}", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  cl = circline 1 (- \\<mu>) ((cmod \\<mu>)\\<^sup>2 - r\\<^sup>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma circle_ex_circline:\n  assumes \"cl = circle \\<mu> r\" and \"r \\<ge> 0\"\n  shows \"\\<exists> A BC D. A \\<noteq> 0 \\<and> A*D \\<le> (cmod BC)\\<^sup>2 \\<and> cl = circline A BC D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A BC D.\n       A \\<noteq> 0 \\<and>\n       A * D \\<le> (cmod BC)\\<^sup>2 \\<and> cl = circline A BC D", "using circle_circline[OF assms]"], ["proof (prove)\nusing this:\n  cl = circline 1 (- \\<mu>) ((cmod \\<mu>)\\<^sup>2 - r\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<exists>A BC D.\n       A \\<noteq> 0 \\<and>\n       A * D \\<le> (cmod BC)\\<^sup>2 \\<and> cl = circline A BC D", "using \\<open>r \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  cl = circline 1 (- \\<mu>) ((cmod \\<mu>)\\<^sup>2 - r\\<^sup>2)\n  0 \\<le> r\n\ngoal (1 subgoal):\n 1. \\<exists>A BC D.\n       A \\<noteq> 0 \\<and>\n       A * D \\<le> (cmod BC)\\<^sup>2 \\<and> cl = circline A BC D", "by (rule_tac x=1 in exI, rule_tac x=\"-\\<mu>\" in exI, rule_tac x=\"Re (\\<mu> * cnj \\<mu>) - (r * r)\" in exI) (simp add: complex_mult_cnj_cmod power2_eq_square)"], ["", "text \\<open>Connection between circline and Euclidean line\\<close>"], ["", "text \\<open>Every circline with a positive determinant and $A = 0$ represents an Euclidean line\\<close>"], ["", "lemma circline_line:\n  assumes\n    \"A = 0\" and \"BC \\<noteq> 0\" and\n    \"cl = circline A BC D\" and\n    \"z1 = - cor D * BC / (2 * BC * cnj BC)\" and\n    \"z2 = z1 + \\<i> * sgn (if arg BC > 0 then -BC else BC)\"\n  shows\n    \"cl = line z1 z2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl = line z1 z2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. cl = line z1 z2", "have \"cl = {z. cnj BC*z + BC*cnj z + complex_of_real D = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl = {z. cnj_mix BC z + cor D = 0}", "using assms"], ["proof (prove)\nusing this:\n  A = 0\n  BC \\<noteq> 0\n  cl = circline A BC D\n  z1 = - cor D * BC / (2 * BC * cnj BC)\n  z2 = z1 + \\<i> * sgn (if 0 < arg BC then - BC else BC)\n\ngoal (1 subgoal):\n 1. cl = {z. cnj_mix BC z + cor D = 0}", "by (simp add: circline_def)"], ["proof (state)\nthis:\n  cl = {z. cnj_mix BC z + cor D = 0}\n\ngoal (1 subgoal):\n 1. cl = line z1 z2", "have \"{z. cnj BC*z + BC*cnj z + complex_of_real D = 0} =\n          {z. cnj BC*z + BC*cnj z - (cnj BC*z1 + BC*cnj z1) = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {z. cnj_mix BC z + cor D = 0} = {z. cnj_mix BC z - cnj_mix BC z1 = 0}", "using  \\<open>BC \\<noteq> 0\\<close> assms"], ["proof (prove)\nusing this:\n  BC \\<noteq> 0\n  A = 0\n  BC \\<noteq> 0\n  cl = circline A BC D\n  z1 = - cor D * BC / (2 * BC * cnj BC)\n  z2 = z1 + \\<i> * sgn (if 0 < arg BC then - BC else BC)\n\ngoal (1 subgoal):\n 1. {z. cnj_mix BC z + cor D = 0} = {z. cnj_mix BC z - cnj_mix BC z1 = 0}", "by simp"], ["proof (state)\nthis:\n  {z. cnj_mix BC z + cor D = 0} = {z. cnj_mix BC z - cnj_mix BC z1 = 0}\n\ngoal (1 subgoal):\n 1. cl = line z1 z2", "moreover"], ["proof (state)\nthis:\n  {z. cnj_mix BC z + cor D = 0} = {z. cnj_mix BC z - cnj_mix BC z1 = 0}\n\ngoal (1 subgoal):\n 1. cl = line z1 z2", "have \"z1 \\<noteq> z2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z1 \\<noteq> z2", "using \\<open>BC \\<noteq> 0\\<close> assms"], ["proof (prove)\nusing this:\n  BC \\<noteq> 0\n  A = 0\n  BC \\<noteq> 0\n  cl = circline A BC D\n  z1 = - cor D * BC / (2 * BC * cnj BC)\n  z2 = z1 + \\<i> * sgn (if 0 < arg BC then - BC else BC)\n\ngoal (1 subgoal):\n 1. z1 \\<noteq> z2", "by (auto simp add: sgn_eq)"], ["proof (state)\nthis:\n  z1 \\<noteq> z2\n\ngoal (1 subgoal):\n 1. cl = line z1 z2", "moreover"], ["proof (state)\nthis:\n  z1 \\<noteq> z2\n\ngoal (1 subgoal):\n 1. cl = line z1 z2", "have \"\\<exists> k. k \\<noteq> 0 \\<and> BC = cor k*rot90 (z2 - z1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> BC = cor k * rot90 (z2 - z1)", "proof (cases \"arg BC > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < arg BC \\<Longrightarrow>\n    \\<exists>k. k \\<noteq> 0 \\<and> BC = cor k * rot90 (z2 - z1)\n 2. \\<not> 0 < arg BC \\<Longrightarrow>\n    \\<exists>k. k \\<noteq> 0 \\<and> BC = cor k * rot90 (z2 - z1)", "case True"], ["proof (state)\nthis:\n  0 < arg BC\n\ngoal (2 subgoals):\n 1. 0 < arg BC \\<Longrightarrow>\n    \\<exists>k. k \\<noteq> 0 \\<and> BC = cor k * rot90 (z2 - z1)\n 2. \\<not> 0 < arg BC \\<Longrightarrow>\n    \\<exists>k. k \\<noteq> 0 \\<and> BC = cor k * rot90 (z2 - z1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < arg BC\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> BC = cor k * rot90 (z2 - z1)", "using assms"], ["proof (prove)\nusing this:\n  0 < arg BC\n  A = 0\n  BC \\<noteq> 0\n  cl = circline A BC D\n  z1 = - cor D * BC / (2 * BC * cnj BC)\n  z2 = z1 + \\<i> * sgn (if 0 < arg BC then - BC else BC)\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> BC = cor k * rot90 (z2 - z1)", "by (rule_tac x=\"(cmod BC)\" in exI, auto simp add: Complex_scale4)"], ["proof (state)\nthis:\n  \\<exists>k. k \\<noteq> 0 \\<and> BC = cor k * rot90 (z2 - z1)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < arg BC \\<Longrightarrow>\n    \\<exists>k. k \\<noteq> 0 \\<and> BC = cor k * rot90 (z2 - z1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < arg BC \\<Longrightarrow>\n    \\<exists>k. k \\<noteq> 0 \\<and> BC = cor k * rot90 (z2 - z1)", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < arg BC\n\ngoal (1 subgoal):\n 1. \\<not> 0 < arg BC \\<Longrightarrow>\n    \\<exists>k. k \\<noteq> 0 \\<and> BC = cor k * rot90 (z2 - z1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> 0 < arg BC\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> BC = cor k * rot90 (z2 - z1)", "using assms"], ["proof (prove)\nusing this:\n  \\<not> 0 < arg BC\n  A = 0\n  BC \\<noteq> 0\n  cl = circline A BC D\n  z1 = - cor D * BC / (2 * BC * cnj BC)\n  z2 = z1 + \\<i> * sgn (if 0 < arg BC then - BC else BC)\n\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0 \\<and> BC = cor k * rot90 (z2 - z1)", "by (rule_tac x=\"-(cmod BC)\" in exI, simp)\n           (smt Complex.Re_sgn Im_sgn cis_arg complex_minus complex_surj mult_minus_right rcis_cmod_arg rcis_def)"], ["proof (state)\nthis:\n  \\<exists>k. k \\<noteq> 0 \\<and> BC = cor k * rot90 (z2 - z1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k. k \\<noteq> 0 \\<and> BC = cor k * rot90 (z2 - z1)\n\ngoal (1 subgoal):\n 1. cl = line z1 z2", "then"], ["proof (chain)\npicking this:\n  \\<exists>k. k \\<noteq> 0 \\<and> BC = cor k * rot90 (z2 - z1)", "obtain k where \"cor k \\<noteq> 0\" \"BC = cor k*rot90 (z2 - z1)\""], ["proof (prove)\nusing this:\n  \\<exists>k. k \\<noteq> 0 \\<and> BC = cor k * rot90 (z2 - z1)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>cor k \\<noteq> 0; BC = cor k * rot90 (z2 - z1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  cor k \\<noteq> 0\n  BC = cor k * rot90 (z2 - z1)\n\ngoal (1 subgoal):\n 1. cl = line z1 z2", "moreover"], ["proof (state)\nthis:\n  cor k \\<noteq> 0\n  BC = cor k * rot90 (z2 - z1)\n\ngoal (1 subgoal):\n 1. cl = line z1 z2", "have *: \"\\<And> z. cnj_mix (BC / cor k) z - cnj_mix (BC / cor k) z1 = (1/cor k) * (cnj_mix BC z - cnj_mix BC z1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       cnj_mix (BC / cor k) z - cnj_mix (BC / cor k) z1 =\n       1 / cor k * (cnj_mix BC z - cnj_mix BC z1)", "using \\<open>cor k \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  cor k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       cnj_mix (BC / cor k) z - cnj_mix (BC / cor k) z1 =\n       1 / cor k * (cnj_mix BC z - cnj_mix BC z1)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  cnj_mix (BC / cor k) ?z - cnj_mix (BC / cor k) z1 =\n  1 / cor k * (cnj_mix BC ?z - cnj_mix BC z1)\n\ngoal (1 subgoal):\n 1. cl = line z1 z2", "hence \"{z. cnj_mix BC z - cnj_mix BC z1 = 0} = {z. cnj_mix (BC / cor k) z - cnj_mix (BC / cor k) z1 = 0}\""], ["proof (prove)\nusing this:\n  cnj_mix (BC / cor k) ?z - cnj_mix (BC / cor k) z1 =\n  1 / cor k * (cnj_mix BC ?z - cnj_mix BC z1)\n\ngoal (1 subgoal):\n 1. {z. cnj_mix BC z - cnj_mix BC z1 = 0} =\n    {z. cnj_mix (BC / cor k) z - cnj_mix (BC / cor k) z1 = 0}", "using \\<open>cor k \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  cnj_mix (BC / cor k) ?z - cnj_mix (BC / cor k) z1 =\n  1 / cor k * (cnj_mix BC ?z - cnj_mix BC z1)\n  cor k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {z. cnj_mix BC z - cnj_mix BC z1 = 0} =\n    {z. cnj_mix (BC / cor k) z - cnj_mix (BC / cor k) z1 = 0}", "by auto"], ["proof (state)\nthis:\n  {z. cnj_mix BC z - cnj_mix BC z1 = 0} =\n  {z. cnj_mix (BC / cor k) z - cnj_mix (BC / cor k) z1 = 0}\n\ngoal (1 subgoal):\n 1. cl = line z1 z2", "ultimately"], ["proof (chain)\npicking this:\n  {z. cnj_mix BC z + cor D = 0} = {z. cnj_mix BC z - cnj_mix BC z1 = 0}\n  z1 \\<noteq> z2\n  cor k \\<noteq> 0\n  BC = cor k * rot90 (z2 - z1)\n  {z. cnj_mix BC z - cnj_mix BC z1 = 0} =\n  {z. cnj_mix (BC / cor k) z - cnj_mix (BC / cor k) z1 = 0}", "have \"cl = line z1 z2\""], ["proof (prove)\nusing this:\n  {z. cnj_mix BC z + cor D = 0} = {z. cnj_mix BC z - cnj_mix BC z1 = 0}\n  z1 \\<noteq> z2\n  cor k \\<noteq> 0\n  BC = cor k * rot90 (z2 - z1)\n  {z. cnj_mix BC z - cnj_mix BC z1 = 0} =\n  {z. cnj_mix (BC / cor k) z - cnj_mix (BC / cor k) z1 = 0}\n\ngoal (1 subgoal):\n 1. cl = line z1 z2", "using line_equation[of z1 z2 \"BC/cor k\"] \\<open>cl = {z. cnj BC*z + BC*cnj z + complex_of_real D = 0}\\<close>"], ["proof (prove)\nusing this:\n  {z. cnj_mix BC z + cor D = 0} = {z. cnj_mix BC z - cnj_mix BC z1 = 0}\n  z1 \\<noteq> z2\n  cor k \\<noteq> 0\n  BC = cor k * rot90 (z2 - z1)\n  {z. cnj_mix BC z - cnj_mix BC z1 = 0} =\n  {z. cnj_mix (BC / cor k) z - cnj_mix (BC / cor k) z1 = 0}\n  \\<lbrakk>z1 \\<noteq> z2; BC / cor k = rot90 (z2 - z1)\\<rbrakk>\n  \\<Longrightarrow> line z1 z2 =\n                    {z. cnj_mix (BC / cor k) z - cnj_mix (BC / cor k) z1 =\n                        0}\n  cl = {z. cnj_mix BC z + cor D = 0}\n\ngoal (1 subgoal):\n 1. cl = line z1 z2", "by auto"], ["proof (state)\nthis:\n  cl = line z1 z2\n\ngoal (1 subgoal):\n 1. cl = line z1 z2", "thus ?thesis"], ["proof (prove)\nusing this:\n  cl = line z1 z2\n\ngoal (1 subgoal):\n 1. cl = line z1 z2", "using \\<open>z1 \\<noteq> z2\\<close>"], ["proof (prove)\nusing this:\n  cl = line z1 z2\n  z1 \\<noteq> z2\n\ngoal (1 subgoal):\n 1. cl = line z1 z2", "by blast"], ["proof (state)\nthis:\n  cl = line z1 z2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma circline_ex_line:\n  assumes \"A = 0\" and \"BC \\<noteq> 0\" and \"cl = circline A BC D\"\n  shows \"\\<exists> z1 z2. z1 \\<noteq> z2 \\<and> cl = line z1 z2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z1 z2. z1 \\<noteq> z2 \\<and> cl = line z1 z2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>z1 z2. z1 \\<noteq> z2 \\<and> cl = line z1 z2", "let ?z1 = \"- cor D * BC / (2 * BC * cnj BC)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>z1 z2. z1 \\<noteq> z2 \\<and> cl = line z1 z2", "let ?z2 = \"?z1 + \\<i> * sgn (if 0 < arg BC then - BC else BC)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>z1 z2. z1 \\<noteq> z2 \\<and> cl = line z1 z2", "have \"?z1 \\<noteq> ?z2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - cor D * BC / (2 * BC * cnj BC) \\<noteq>\n    - cor D * BC / (2 * BC * cnj BC) +\n    \\<i> * sgn (if 0 < arg BC then - BC else BC)", "using \\<open>BC \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  BC \\<noteq> 0\n\ngoal (1 subgoal):\n 1. - cor D * BC / (2 * BC * cnj BC) \\<noteq>\n    - cor D * BC / (2 * BC * cnj BC) +\n    \\<i> * sgn (if 0 < arg BC then - BC else BC)", "by (simp add: sgn_eq)"], ["proof (state)\nthis:\n  - cor D * BC / (2 * BC * cnj BC) \\<noteq>\n  - cor D * BC / (2 * BC * cnj BC) +\n  \\<i> * sgn (if 0 < arg BC then - BC else BC)\n\ngoal (1 subgoal):\n 1. \\<exists>z1 z2. z1 \\<noteq> z2 \\<and> cl = line z1 z2", "thus ?thesis"], ["proof (prove)\nusing this:\n  - cor D * BC / (2 * BC * cnj BC) \\<noteq>\n  - cor D * BC / (2 * BC * cnj BC) +\n  \\<i> * sgn (if 0 < arg BC then - BC else BC)\n\ngoal (1 subgoal):\n 1. \\<exists>z1 z2. z1 \\<noteq> z2 \\<and> cl = line z1 z2", "using circline_line[OF assms, of ?z1 ?z2] \\<open>BC \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  - cor D * BC / (2 * BC * cnj BC) \\<noteq>\n  - cor D * BC / (2 * BC * cnj BC) +\n  \\<i> * sgn (if 0 < arg BC then - BC else BC)\n  \\<lbrakk>- cor D * BC / (2 * BC * cnj BC) =\n           - cor D * BC / (2 * BC * cnj BC);\n   - cor D * BC / (2 * BC * cnj BC) +\n   \\<i> * sgn (if 0 < arg BC then - BC else BC) =\n   - cor D * BC / (2 * BC * cnj BC) +\n   \\<i> * sgn (if 0 < arg BC then - BC else BC)\\<rbrakk>\n  \\<Longrightarrow> cl =\n                    line (- cor D * BC / (2 * BC * cnj BC))\n                     (- cor D * BC / (2 * BC * cnj BC) +\n                      \\<i> * sgn (if 0 < arg BC then - BC else BC))\n  BC \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>z1 z2. z1 \\<noteq> z2 \\<and> cl = line z1 z2", "by (rule_tac x=\"?z1\" in exI, rule_tac x=\"?z2\" in exI, simp)"], ["proof (state)\nthis:\n  \\<exists>z1 z2. z1 \\<noteq> z2 \\<and> cl = line z1 z2\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Every Euclidean line can be represented by a circline\\<close>"], ["", "lemma line_ex_circline:\n  assumes \"cl = line z1 z2\" and \"z1 \\<noteq> z2\"\n  shows \"\\<exists> BC D. BC \\<noteq> 0 \\<and> cl = circline 0 BC D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>BC D. BC \\<noteq> 0 \\<and> cl = circline 0 BC D", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>BC D. BC \\<noteq> 0 \\<and> cl = circline 0 BC D", "let ?BC = \"rot90 (z2 - z1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>BC D. BC \\<noteq> 0 \\<and> cl = circline 0 BC D", "let ?D = \"Re (- 2 * scalprod z1 ?BC)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>BC D. BC \\<noteq> 0 \\<and> cl = circline 0 BC D", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>BC D. BC \\<noteq> 0 \\<and> cl = circline 0 BC D", "proof (rule_tac x=\"?BC\" in exI, rule_tac x=\"?D\" in exI, rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. rot90 (z2 - z1) \\<noteq> 0\n 2. cl =\n    circline 0 (rot90 (z2 - z1)) (Re (- 2 * scalprod z1 (rot90 (z2 - z1))))", "show \"?BC \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rot90 (z2 - z1) \\<noteq> 0", "using \\<open>z1 \\<noteq> z2\\<close> rot90_ii[of \"z2 - z1\"]"], ["proof (prove)\nusing this:\n  z1 \\<noteq> z2\n  rot90 (z2 - z1) = (z2 - z1) * \\<i>\n\ngoal (1 subgoal):\n 1. rot90 (z2 - z1) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  rot90 (z2 - z1) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cl =\n    circline 0 (rot90 (z2 - z1)) (Re (- 2 * scalprod z1 (rot90 (z2 - z1))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cl =\n    circline 0 (rot90 (z2 - z1)) (Re (- 2 * scalprod z1 (rot90 (z2 - z1))))", "have *: \"complex_of_real (Re (- 2 * scalprod z1 (rot90 (z2 - z1)))) = - (cnj_mix z1 (rot90 (z2 - z1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cor (Re (- 2 * scalprod z1 (rot90 (z2 - z1)))) =\n    - cnj_mix z1 (rot90 (z2 - z1))", "using rot90_ii[of \"z2 - z1\"]"], ["proof (prove)\nusing this:\n  rot90 (z2 - z1) = (z2 - z1) * \\<i>\n\ngoal (1 subgoal):\n 1. cor (Re (- 2 * scalprod z1 (rot90 (z2 - z1)))) =\n    - cnj_mix z1 (rot90 (z2 - z1))", "by (cases z1, cases z2, simp add: Complex_eq field_simps)"], ["proof (state)\nthis:\n  cor (Re (- 2 * scalprod z1 (rot90 (z2 - z1)))) =\n  - cnj_mix z1 (rot90 (z2 - z1))\n\ngoal (1 subgoal):\n 1. cl =\n    circline 0 (rot90 (z2 - z1)) (Re (- 2 * scalprod z1 (rot90 (z2 - z1))))", "show \"cl = circline 0 ?BC ?D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl =\n    circline 0 (rot90 (z2 - z1)) (Re (- 2 * scalprod z1 (rot90 (z2 - z1))))", "apply (subst assms, subst line_equation[of z1 z2 ?BC])"], ["proof (prove)\ngoal (3 subgoals):\n 1. z1 \\<noteq> z2\n 2. rot90 (z2 - z1) = rot90 (z2 - z1)\n 3. {z. cnj_mix (rot90 (z2 - z1)) z - cnj_mix (rot90 (z2 - z1)) z1 = 0} =\n    circline 0 (rot90 (z2 - z1)) (Re (- 2 * scalprod z1 (rot90 (z2 - z1))))", "unfolding circline_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. z1 \\<noteq> z2\n 2. rot90 (z2 - z1) = rot90 (z2 - z1)\n 3. {z. cnj_mix (rot90 (z2 - z1)) z - cnj_mix (rot90 (z2 - z1)) z1 = 0} =\n    {z. cor 0 * z * cnj z + cnj (rot90 (z2 - z1)) * z +\n        rot90 (z2 - z1) * cnj z +\n        cor (Re (- 2 * scalprod z1 (rot90 (z2 - z1)))) =\n        0}", "by (fact, simp, subst *, simp add: field_simps)"], ["proof (state)\nthis:\n  cl =\n  circline 0 (rot90 (z2 - z1)) (Re (- 2 * scalprod z1 (rot90 (z2 - z1))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>BC D. BC \\<noteq> 0 \\<and> cl = circline 0 BC D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma circline_line':\n  assumes \"z1 \\<noteq> z2\"\n  shows \"circline 0 (\\<i> * (z2 - z1)) (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) = line z1 z2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. circline 0 (\\<i> * (z2 - z1)) (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n    line z1 z2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. circline 0 (\\<i> * (z2 - z1)) (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n    line z1 z2", "let ?B = \"\\<i> * (z2 - z1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. circline 0 (\\<i> * (z2 - z1)) (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n    line z1 z2", "let ?D = \"Re (- cnj_mix ?B z1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. circline 0 (\\<i> * (z2 - z1)) (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n    line z1 z2", "have \"circline 0 ?B ?D = {z. cnj ?B*z + ?B*cnj z + complex_of_real ?D = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. circline 0 (\\<i> * (z2 - z1)) (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n    {z. cnj_mix (\\<i> * (z2 - z1)) z +\n        cor (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n        0}", "using assms"], ["proof (prove)\nusing this:\n  z1 \\<noteq> z2\n\ngoal (1 subgoal):\n 1. circline 0 (\\<i> * (z2 - z1)) (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n    {z. cnj_mix (\\<i> * (z2 - z1)) z +\n        cor (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n        0}", "by (simp add: circline_def)"], ["proof (state)\nthis:\n  circline 0 (\\<i> * (z2 - z1)) (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n  {z. cnj_mix (\\<i> * (z2 - z1)) z +\n      cor (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n      0}\n\ngoal (1 subgoal):\n 1. circline 0 (\\<i> * (z2 - z1)) (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n    line z1 z2", "moreover"], ["proof (state)\nthis:\n  circline 0 (\\<i> * (z2 - z1)) (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n  {z. cnj_mix (\\<i> * (z2 - z1)) z +\n      cor (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n      0}\n\ngoal (1 subgoal):\n 1. circline 0 (\\<i> * (z2 - z1)) (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n    line z1 z2", "have \"is_real (- cnj_mix (\\<i> * (z2 - z1)) z1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real (- cnj_mix (\\<i> * (z2 - z1)) z1)", "using cnj_mix_real[of ?B z1]"], ["proof (prove)\nusing this:\n  is_real (cnj_mix (\\<i> * (z2 - z1)) z1)\n\ngoal (1 subgoal):\n 1. is_real (- cnj_mix (\\<i> * (z2 - z1)) z1)", "by auto"], ["proof (state)\nthis:\n  is_real (- cnj_mix (\\<i> * (z2 - z1)) z1)\n\ngoal (1 subgoal):\n 1. circline 0 (\\<i> * (z2 - z1)) (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n    line z1 z2", "hence \"{z. cnj ?B*z + ?B*cnj z + complex_of_real ?D = 0} =\n         {z. cnj ?B*z + ?B*cnj z - (cnj ?B*z1 + ?B*cnj z1) = 0}\""], ["proof (prove)\nusing this:\n  is_real (- cnj_mix (\\<i> * (z2 - z1)) z1)\n\ngoal (1 subgoal):\n 1. {z. cnj_mix (\\<i> * (z2 - z1)) z +\n        cor (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n        0} =\n    {z. cnj_mix (\\<i> * (z2 - z1)) z - cnj_mix (\\<i> * (z2 - z1)) z1 = 0}", "apply (subst complex_of_real_Re, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real (- cnj_mix (\\<i> * (z2 - z1)) z1) \\<Longrightarrow>\n    {z. cnj_mix (\\<i> * (z2 - z1)) z + - cnj_mix (\\<i> * (z2 - z1)) z1 =\n        0} =\n    {z. cnj_mix (\\<i> * (z2 - z1)) z - cnj_mix (\\<i> * (z2 - z1)) z1 = 0}", "unfolding diff_conv_add_uminus"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_real (- cnj_mix (\\<i> * (z2 + - z1)) z1) \\<Longrightarrow>\n    {z. cnj_mix (\\<i> * (z2 + - z1)) z + - cnj_mix (\\<i> * (z2 + - z1)) z1 =\n        0} =\n    {z. cnj_mix (\\<i> * (z2 + - z1)) z + - cnj_mix (\\<i> * (z2 + - z1)) z1 =\n        0}", "by simp"], ["proof (state)\nthis:\n  {z. cnj_mix (\\<i> * (z2 - z1)) z +\n      cor (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n      0} =\n  {z. cnj_mix (\\<i> * (z2 - z1)) z - cnj_mix (\\<i> * (z2 - z1)) z1 = 0}\n\ngoal (1 subgoal):\n 1. circline 0 (\\<i> * (z2 - z1)) (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n    line z1 z2", "moreover"], ["proof (state)\nthis:\n  {z. cnj_mix (\\<i> * (z2 - z1)) z +\n      cor (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n      0} =\n  {z. cnj_mix (\\<i> * (z2 - z1)) z - cnj_mix (\\<i> * (z2 - z1)) z1 = 0}\n\ngoal (1 subgoal):\n 1. circline 0 (\\<i> * (z2 - z1)) (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n    line z1 z2", "have \"line z1 z2 = {z. cnj_mix (\\<i> * (z2 - z1)) z - cnj_mix (\\<i> * (z2 - z1)) z1 = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line z1 z2 =\n    {z. cnj_mix (\\<i> * (z2 - z1)) z - cnj_mix (\\<i> * (z2 - z1)) z1 = 0}", "using line_equation[of z1 z2 ?B] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>z1 \\<noteq> z2; \\<i> * (z2 - z1) = rot90 (z2 - z1)\\<rbrakk>\n  \\<Longrightarrow> line z1 z2 =\n                    {z. cnj_mix (\\<i> * (z2 - z1)) z -\n                        cnj_mix (\\<i> * (z2 - z1)) z1 =\n                        0}\n  z1 \\<noteq> z2\n\ngoal (1 subgoal):\n 1. line z1 z2 =\n    {z. cnj_mix (\\<i> * (z2 - z1)) z - cnj_mix (\\<i> * (z2 - z1)) z1 = 0}", "unfolding rot90_ii"], ["proof (prove)\nusing this:\n  \\<lbrakk>z1 \\<noteq> z2; \\<i> * (z2 - z1) = (z2 - z1) * \\<i>\\<rbrakk>\n  \\<Longrightarrow> line z1 z2 =\n                    {z. cnj_mix (\\<i> * (z2 - z1)) z -\n                        cnj_mix (\\<i> * (z2 - z1)) z1 =\n                        0}\n  z1 \\<noteq> z2\n\ngoal (1 subgoal):\n 1. line z1 z2 =\n    {z. cnj_mix (\\<i> * (z2 - z1)) z - cnj_mix (\\<i> * (z2 - z1)) z1 = 0}", "by simp"], ["proof (state)\nthis:\n  line z1 z2 =\n  {z. cnj_mix (\\<i> * (z2 - z1)) z - cnj_mix (\\<i> * (z2 - z1)) z1 = 0}\n\ngoal (1 subgoal):\n 1. circline 0 (\\<i> * (z2 - z1)) (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n    line z1 z2", "ultimately"], ["proof (chain)\npicking this:\n  circline 0 (\\<i> * (z2 - z1)) (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n  {z. cnj_mix (\\<i> * (z2 - z1)) z +\n      cor (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n      0}\n  {z. cnj_mix (\\<i> * (z2 - z1)) z +\n      cor (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n      0} =\n  {z. cnj_mix (\\<i> * (z2 - z1)) z - cnj_mix (\\<i> * (z2 - z1)) z1 = 0}\n  line z1 z2 =\n  {z. cnj_mix (\\<i> * (z2 - z1)) z - cnj_mix (\\<i> * (z2 - z1)) z1 = 0}", "show ?thesis"], ["proof (prove)\nusing this:\n  circline 0 (\\<i> * (z2 - z1)) (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n  {z. cnj_mix (\\<i> * (z2 - z1)) z +\n      cor (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n      0}\n  {z. cnj_mix (\\<i> * (z2 - z1)) z +\n      cor (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n      0} =\n  {z. cnj_mix (\\<i> * (z2 - z1)) z - cnj_mix (\\<i> * (z2 - z1)) z1 = 0}\n  line z1 z2 =\n  {z. cnj_mix (\\<i> * (z2 - z1)) z - cnj_mix (\\<i> * (z2 - z1)) z1 = 0}\n\ngoal (1 subgoal):\n 1. circline 0 (\\<i> * (z2 - z1)) (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n    line z1 z2", "by simp"], ["proof (state)\nthis:\n  circline 0 (\\<i> * (z2 - z1)) (Re (- cnj_mix (\\<i> * (z2 - z1)) z1)) =\n  line z1 z2\n\ngoal:\nNo subgoals!", "qed"], ["", "(* ---------------------------------------------------------------------------- *)"], ["", "subsection \\<open>Angle between two circles\\<close>"], ["", "(* ---------------------------------------------------------------------------- *)"], ["", "text \\<open>Given a center $\\mu$ of an Euclidean circle and a point $E$ on it, we define the tangent vector\nin $E$ as the radius vector $\\overrightarrow{\\mu E}$, rotated by $\\pi/2$, clockwise or\ncounterclockwise, depending on the circle orientation. The Boolean @{term p} encodes the orientation\nof the circle, and the function @{term \"sgn_bool p\"} returns $1$ when @{term p} is true, and\n$-1$ when @{term p} is false.\\<close>"], ["", "abbreviation sgn_bool where\n  \"sgn_bool p \\<equiv> if p then 1 else -1\""], ["", "definition circ_tang_vec :: \"complex \\<Rightarrow> complex \\<Rightarrow> bool \\<Rightarrow> complex\" where\n  \"circ_tang_vec \\<mu> E p = sgn_bool p * \\<i> * (E - \\<mu>)\""], ["", "text \\<open>Tangent vector is orthogonal to the radius.\\<close>"], ["", "lemma circ_tang_vec_ortho:\n  shows \"scalprod (E - \\<mu>) (circ_tang_vec \\<mu> E p) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scalprod (E - \\<mu>) (circ_tang_vec \\<mu> E p) = 0", "unfolding circ_tang_vec_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. scalprod (E - \\<mu>) (sgn_bool p * \\<i> * (E - \\<mu>)) = 0", "by auto"], ["", "text \\<open>Changing the circle orientation gives the opposite tangent vector.\\<close>"], ["", "lemma circ_tang_vec_opposite_orient:\n  shows \"circ_tang_vec \\<mu> E p = - circ_tang_vec \\<mu> E (\\<not> p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. circ_tang_vec \\<mu> E p = - circ_tang_vec \\<mu> E (\\<not> p)", "unfolding circ_tang_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sgn_bool p * \\<i> * (E - \\<mu>) =\n    - (sgn_bool (\\<not> p) * \\<i> * (E - \\<mu>))", "by auto"], ["", "text \\<open>Angle between two oriented circles at their common point $E$ is defined as the angle between\ntangent vectors at $E$. Again we define three different angle measures.\\<close>"], ["", "text \\<open>The oriented angle between two circles at the point $E$. The first circle is\ncentered at $\\mu_1$ and its orientation is given by the Boolean $p_1$, \nwhile the second circle is centered at $\\mu_2$ and its orientation is given by \nthe Boolea $p_2$.\\<close>"], ["", "definition ang_circ where \n  \"ang_circ E \\<mu>1 \\<mu>2 p1 p2 = \\<angle> (circ_tang_vec \\<mu>1 E p1) (circ_tang_vec \\<mu>2 E p2)\""], ["", "text \\<open>The unoriented angle between the two circles\\<close>"], ["", "definition ang_circ_c where\n  \"ang_circ_c E \\<mu>1 \\<mu>2 p1 p2 = \\<angle>c (circ_tang_vec \\<mu>1 E p1) (circ_tang_vec \\<mu>2 E p2)\""], ["", "text \\<open>The acute angle between the two circles\\<close>"], ["", "definition ang_circ_a where\n  \"ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = \\<angle>a (circ_tang_vec \\<mu>1 E p1) (circ_tang_vec \\<mu>2 E p2)\""], ["", "text \\<open>Explicit expression for oriented angle between two circles\\<close>"], ["", "lemma ang_circ_simp:\n  assumes \"E \\<noteq> \\<mu>1\" and \"E \\<noteq> \\<mu>2\"\n  shows \"ang_circ E \\<mu>1 \\<mu>2 p1 p2 =\n         \\<downharpoonright>arg (E - \\<mu>2) - arg (E - \\<mu>1) + sgn_bool p1 * pi / 2 - sgn_bool p2 * pi / 2\\<downharpoonleft>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ang_circ E \\<mu>1 \\<mu>2 p1 p2 =\n    \\<downharpoonright>arg (E - \\<mu>2) - arg (E - \\<mu>1) +\n                       sgn_bool p1 * pi / 2 -\n                       sgn_bool p2 * pi / 2\\<downharpoonleft>", "unfolding ang_circ_def ang_vec_def circ_tang_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<downharpoonright>arg (sgn_bool p2 * \\<i> * (E - \\<mu>2)) -\n                       arg (sgn_bool p1 * \\<i> *\n                            (E - \\<mu>1))\\<downharpoonleft> =\n    \\<downharpoonright>arg (E - \\<mu>2) - arg (E - \\<mu>1) +\n                       sgn_bool p1 * pi / 2 -\n                       sgn_bool p2 * pi / 2\\<downharpoonleft>", "apply (rule canon_ang_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       arg (sgn_bool p2 * \\<i> * (E - \\<mu>2)) -\n       arg (sgn_bool p1 * \\<i> * (E - \\<mu>1)) -\n       (arg (E - \\<mu>2) - arg (E - \\<mu>1) + sgn_bool p1 * pi / 2 -\n        sgn_bool p2 * pi / 2) =\n       2 * real_of_int x * pi", "using assms"], ["proof (prove)\nusing this:\n  E \\<noteq> \\<mu>1\n  E \\<noteq> \\<mu>2\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       arg (sgn_bool p2 * \\<i> * (E - \\<mu>2)) -\n       arg (sgn_bool p1 * \\<i> * (E - \\<mu>1)) -\n       (arg (E - \\<mu>2) - arg (E - \\<mu>1) + sgn_bool p1 * pi / 2 -\n        sgn_bool p2 * pi / 2) =\n       2 * real_of_int x * pi", "using arg_mult_2kpi[of \"sgn_bool p2*\\<i>\" \"E - \\<mu>2\"]"], ["proof (prove)\nusing this:\n  E \\<noteq> \\<mu>1\n  E \\<noteq> \\<mu>2\n  sgn_bool p2 * \\<i> * (E - \\<mu>2) \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>x.\n     arg (sgn_bool p2 * \\<i> * (E - \\<mu>2)) =\n     arg (sgn_bool p2 * \\<i>) + arg (E - \\<mu>2) + 2 * real_of_int x * pi\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       arg (sgn_bool p2 * \\<i> * (E - \\<mu>2)) -\n       arg (sgn_bool p1 * \\<i> * (E - \\<mu>1)) -\n       (arg (E - \\<mu>2) - arg (E - \\<mu>1) + sgn_bool p1 * pi / 2 -\n        sgn_bool p2 * pi / 2) =\n       2 * real_of_int x * pi", "using arg_mult_2kpi[of \"sgn_bool p1*\\<i>\" \"E - \\<mu>1\"]"], ["proof (prove)\nusing this:\n  E \\<noteq> \\<mu>1\n  E \\<noteq> \\<mu>2\n  sgn_bool p2 * \\<i> * (E - \\<mu>2) \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>x.\n     arg (sgn_bool p2 * \\<i> * (E - \\<mu>2)) =\n     arg (sgn_bool p2 * \\<i>) + arg (E - \\<mu>2) + 2 * real_of_int x * pi\n  sgn_bool p1 * \\<i> * (E - \\<mu>1) \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>x.\n     arg (sgn_bool p1 * \\<i> * (E - \\<mu>1)) =\n     arg (sgn_bool p1 * \\<i>) + arg (E - \\<mu>1) + 2 * real_of_int x * pi\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       arg (sgn_bool p2 * \\<i> * (E - \\<mu>2)) -\n       arg (sgn_bool p1 * \\<i> * (E - \\<mu>1)) -\n       (arg (E - \\<mu>2) - arg (E - \\<mu>1) + sgn_bool p1 * pi / 2 -\n        sgn_bool p2 * pi / 2) =\n       2 * real_of_int x * pi", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>E \\<noteq> \\<mu>1; E \\<noteq> \\<mu>2; p1; p2;\n        arg (\\<i> * (E - \\<mu>2)) =\n        pi / 2 + arg (E - \\<mu>2) + 2 * real_of_int x * pi;\n        arg (\\<i> * (E - \\<mu>1)) =\n        pi / 2 + arg (E - \\<mu>1) + 2 * real_of_int xa * pi\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb.\n                            2 * real_of_int x * pi -\n                            2 * real_of_int xa * pi =\n                            2 * real_of_int xb * pi\n 2. \\<And>x xa.\n       \\<lbrakk>E \\<noteq> \\<mu>1; E \\<noteq> \\<mu>2; p1; \\<not> p2;\n        arg (- (\\<i> * (E - \\<mu>2))) =\n        arg (E - \\<mu>2) - pi / 2 + 2 * real_of_int x * pi;\n        arg (\\<i> * (E - \\<mu>1)) =\n        pi / 2 + arg (E - \\<mu>1) + 2 * real_of_int xa * pi\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb.\n                            2 * real_of_int x * pi -\n                            2 * real_of_int xa * pi -\n                            2 * pi =\n                            2 * real_of_int xb * pi\n 3. \\<And>x xa.\n       \\<lbrakk>E \\<noteq> \\<mu>1; E \\<noteq> \\<mu>2; \\<not> p1; p2;\n        arg (\\<i> * (E - \\<mu>2)) =\n        pi / 2 + arg (E - \\<mu>2) + 2 * real_of_int x * pi;\n        arg (- (\\<i> * (E - \\<mu>1))) =\n        arg (E - \\<mu>1) - pi / 2 + 2 * real_of_int xa * pi\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb.\n                            2 * pi +\n                            (2 * real_of_int x * pi -\n                             2 * real_of_int xa * pi) =\n                            2 * real_of_int xb * pi\n 4. \\<And>x xa.\n       \\<lbrakk>E \\<noteq> \\<mu>1; E \\<noteq> \\<mu>2; \\<not> p1; \\<not> p2;\n        arg (- (\\<i> * (E - \\<mu>2))) =\n        arg (E - \\<mu>2) - pi / 2 + 2 * real_of_int x * pi;\n        arg (- (\\<i> * (E - \\<mu>1))) =\n        arg (E - \\<mu>1) - pi / 2 + 2 * real_of_int xa * pi\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb.\n                            2 * real_of_int x * pi -\n                            2 * real_of_int xa * pi =\n                            2 * real_of_int xb * pi", "apply (rule_tac x=\"x-xa\" in exI, auto simp add: field_simps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>E \\<noteq> \\<mu>1; E \\<noteq> \\<mu>2; p1; \\<not> p2;\n        pi + 2 * arg (\\<i> * \\<mu>2 - \\<i> * E) =\n        2 * arg (E - \\<mu>2) + pi * (real_of_int x * 4);\n        2 * arg (\\<i> * E - \\<i> * \\<mu>1) =\n        pi + (2 * arg (E - \\<mu>1) + pi * (real_of_int xa * 4))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb.\n                            pi * (real_of_int x * 2) =\n                            pi * 2 +\n                            (pi * (real_of_int xa * 2) +\n                             pi * (real_of_int xb * 2))\n 2. \\<And>x xa.\n       \\<lbrakk>E \\<noteq> \\<mu>1; E \\<noteq> \\<mu>2; \\<not> p1; p2;\n        2 * arg (\\<i> * E - \\<i> * \\<mu>2) =\n        pi + (2 * arg (E - \\<mu>2) + pi * (real_of_int x * 4));\n        pi + 2 * arg (\\<i> * \\<mu>1 - \\<i> * E) =\n        2 * arg (E - \\<mu>1) + pi * (real_of_int xa * 4)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb.\n                            pi * 2 + pi * (real_of_int x * 2) =\n                            pi * (real_of_int xa * 2) +\n                            pi * (real_of_int xb * 2)\n 3. \\<And>x xa.\n       \\<lbrakk>E \\<noteq> \\<mu>1; E \\<noteq> \\<mu>2; \\<not> p1; \\<not> p2;\n        pi + 2 * arg (\\<i> * \\<mu>2 - \\<i> * E) =\n        2 * arg (E - \\<mu>2) + pi * (real_of_int x * 4);\n        pi + 2 * arg (\\<i> * \\<mu>1 - \\<i> * E) =\n        2 * arg (E - \\<mu>1) + pi * (real_of_int xa * 4)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb.\n                            pi * (real_of_int x * 2) =\n                            pi * (real_of_int xa * 2) +\n                            pi * (real_of_int xb * 2)", "apply (rule_tac x=\"-1+x-xa\" in exI, auto simp add: field_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>E \\<noteq> \\<mu>1; E \\<noteq> \\<mu>2; \\<not> p1; p2;\n        2 * arg (\\<i> * E - \\<i> * \\<mu>2) =\n        pi + (2 * arg (E - \\<mu>2) + pi * (real_of_int x * 4));\n        pi + 2 * arg (\\<i> * \\<mu>1 - \\<i> * E) =\n        2 * arg (E - \\<mu>1) + pi * (real_of_int xa * 4)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb.\n                            pi * 2 + pi * (real_of_int x * 2) =\n                            pi * (real_of_int xa * 2) +\n                            pi * (real_of_int xb * 2)\n 2. \\<And>x xa.\n       \\<lbrakk>E \\<noteq> \\<mu>1; E \\<noteq> \\<mu>2; \\<not> p1; \\<not> p2;\n        pi + 2 * arg (\\<i> * \\<mu>2 - \\<i> * E) =\n        2 * arg (E - \\<mu>2) + pi * (real_of_int x * 4);\n        pi + 2 * arg (\\<i> * \\<mu>1 - \\<i> * E) =\n        2 * arg (E - \\<mu>1) + pi * (real_of_int xa * 4)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb.\n                            pi * (real_of_int x * 2) =\n                            pi * (real_of_int xa * 2) +\n                            pi * (real_of_int xb * 2)", "apply (rule_tac x=\"1+x-xa\" in exI, auto simp add: field_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>E \\<noteq> \\<mu>1; E \\<noteq> \\<mu>2; \\<not> p1; \\<not> p2;\n        pi + 2 * arg (\\<i> * \\<mu>2 - \\<i> * E) =\n        2 * arg (E - \\<mu>2) + pi * (real_of_int x * 4);\n        pi + 2 * arg (\\<i> * \\<mu>1 - \\<i> * E) =\n        2 * arg (E - \\<mu>1) + pi * (real_of_int xa * 4)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xb.\n                            pi * (real_of_int x * 2) =\n                            pi * (real_of_int xa * 2) +\n                            pi * (real_of_int xb * 2)", "apply (rule_tac x=\"x-xa\" in exI, auto simp add: field_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Explicit expression for the cosine of angle between two circles\\<close>"], ["", "lemma cos_ang_circ_simp:\n  assumes \"E \\<noteq> \\<mu>1\" and \"E \\<noteq> \\<mu>2\"\n  shows \"cos (ang_circ E \\<mu>1 \\<mu>2 p1 p2) =\n         sgn_bool (p1 = p2) * cos (arg (E - \\<mu>2) - arg (E - \\<mu>1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (ang_circ E \\<mu>1 \\<mu>2 p1 p2) =\n    sgn_bool (p1 = p2) * cos (arg (E - \\<mu>2) - arg (E - \\<mu>1))", "using assms"], ["proof (prove)\nusing this:\n  E \\<noteq> \\<mu>1\n  E \\<noteq> \\<mu>2\n\ngoal (1 subgoal):\n 1. cos (ang_circ E \\<mu>1 \\<mu>2 p1 p2) =\n    sgn_bool (p1 = p2) * cos (arg (E - \\<mu>2) - arg (E - \\<mu>1))", "using cos_periodic_pi2[of \"arg (E - \\<mu>2) - arg (E - \\<mu>1)\"]"], ["proof (prove)\nusing this:\n  E \\<noteq> \\<mu>1\n  E \\<noteq> \\<mu>2\n  cos (pi + (arg (E - \\<mu>2) - arg (E - \\<mu>1))) =\n  - cos (arg (E - \\<mu>2) - arg (E - \\<mu>1))\n\ngoal (1 subgoal):\n 1. cos (ang_circ E \\<mu>1 \\<mu>2 p1 p2) =\n    sgn_bool (p1 = p2) * cos (arg (E - \\<mu>2) - arg (E - \\<mu>1))", "using cos_minus_pi[of \"arg (E - \\<mu>2) - arg (E - \\<mu>1)\"]"], ["proof (prove)\nusing this:\n  E \\<noteq> \\<mu>1\n  E \\<noteq> \\<mu>2\n  cos (pi + (arg (E - \\<mu>2) - arg (E - \\<mu>1))) =\n  - cos (arg (E - \\<mu>2) - arg (E - \\<mu>1))\n  cos (arg (E - \\<mu>2) - arg (E - \\<mu>1) - pi) =\n  - cos (arg (E - \\<mu>2) - arg (E - \\<mu>1))\n\ngoal (1 subgoal):\n 1. cos (ang_circ E \\<mu>1 \\<mu>2 p1 p2) =\n    sgn_bool (p1 = p2) * cos (arg (E - \\<mu>2) - arg (E - \\<mu>1))", "using ang_circ_simp[OF assms, of p1 p2]"], ["proof (prove)\nusing this:\n  E \\<noteq> \\<mu>1\n  E \\<noteq> \\<mu>2\n  cos (pi + (arg (E - \\<mu>2) - arg (E - \\<mu>1))) =\n  - cos (arg (E - \\<mu>2) - arg (E - \\<mu>1))\n  cos (arg (E - \\<mu>2) - arg (E - \\<mu>1) - pi) =\n  - cos (arg (E - \\<mu>2) - arg (E - \\<mu>1))\n  ang_circ E \\<mu>1 \\<mu>2 p1 p2 =\n  \\<downharpoonright>arg (E - \\<mu>2) - arg (E - \\<mu>1) +\n                     sgn_bool p1 * pi / 2 -\n                     sgn_bool p2 * pi / 2\\<downharpoonleft>\n\ngoal (1 subgoal):\n 1. cos (ang_circ E \\<mu>1 \\<mu>2 p1 p2) =\n    sgn_bool (p1 = p2) * cos (arg (E - \\<mu>2) - arg (E - \\<mu>1))", "by auto"], ["", "text \\<open>Explicit expression for the unoriented angle between two circles\\<close>"], ["", "lemma ang_circ_c_simp:\n  assumes \"E \\<noteq> \\<mu>1\" and \"E \\<noteq> \\<mu>2\"\n  shows \"ang_circ_c E \\<mu>1 \\<mu>2 p1 p2 = \n        \\<bar>\\<downharpoonright>arg (E - \\<mu>2) - arg (E - \\<mu>1) + sgn_bool p1 * pi / 2 - sgn_bool p2 * pi / 2\\<downharpoonleft>\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ang_circ_c E \\<mu>1 \\<mu>2 p1 p2 =\n    \\<bar>\\<downharpoonright>arg (E - \\<mu>2) - arg (E - \\<mu>1) +\n                             sgn_bool p1 * pi / 2 -\n                             sgn_bool p2 * pi / 2\\<downharpoonleft>\\<bar>", "unfolding ang_circ_c_def ang_vec_c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>\\<angle> (circ_tang_vec \\<mu>1 E p1)\n           (circ_tang_vec \\<mu>2 E p2)\\<bar> =\n    \\<bar>\\<downharpoonright>arg (E - \\<mu>2) - arg (E - \\<mu>1) +\n                             sgn_bool p1 * pi / 2 -\n                             sgn_bool p2 * pi / 2\\<downharpoonleft>\\<bar>", "using ang_circ_simp[OF assms]"], ["proof (prove)\nusing this:\n  ang_circ E \\<mu>1 \\<mu>2 ?p1.0 ?p2.0 =\n  \\<downharpoonright>arg (E - \\<mu>2) - arg (E - \\<mu>1) +\n                     sgn_bool ?p1.0 * pi / 2 -\n                     sgn_bool ?p2.0 * pi / 2\\<downharpoonleft>\n\ngoal (1 subgoal):\n 1. \\<bar>\\<angle> (circ_tang_vec \\<mu>1 E p1)\n           (circ_tang_vec \\<mu>2 E p2)\\<bar> =\n    \\<bar>\\<downharpoonright>arg (E - \\<mu>2) - arg (E - \\<mu>1) +\n                             sgn_bool p1 * pi / 2 -\n                             sgn_bool p2 * pi / 2\\<downharpoonleft>\\<bar>", "unfolding ang_circ_def"], ["proof (prove)\nusing this:\n  \\<angle> (circ_tang_vec \\<mu>1 E ?p1.0) (circ_tang_vec \\<mu>2 E ?p2.0) =\n  \\<downharpoonright>arg (E - \\<mu>2) - arg (E - \\<mu>1) +\n                     sgn_bool ?p1.0 * pi / 2 -\n                     sgn_bool ?p2.0 * pi / 2\\<downharpoonleft>\n\ngoal (1 subgoal):\n 1. \\<bar>\\<angle> (circ_tang_vec \\<mu>1 E p1)\n           (circ_tang_vec \\<mu>2 E p2)\\<bar> =\n    \\<bar>\\<downharpoonright>arg (E - \\<mu>2) - arg (E - \\<mu>1) +\n                             sgn_bool p1 * pi / 2 -\n                             sgn_bool p2 * pi / 2\\<downharpoonleft>\\<bar>", "by auto"], ["", "text \\<open>Explicit expression for the acute angle between two circles\\<close>"], ["", "lemma ang_circ_a_simp:\n  assumes \"E \\<noteq> \\<mu>1\" and \"E \\<noteq> \\<mu>2\"\n  shows \"ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = \n         acute_ang (abs (canon_ang (arg(E - \\<mu>2) - arg(E - \\<mu>1) + (sgn_bool p1) * pi/2 - (sgn_bool p2) * pi/2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 =\n    acute_ang\n     \\<bar>\\<downharpoonright>arg (E - \\<mu>2) - arg (E - \\<mu>1) +\n                              sgn_bool p1 * pi / 2 -\n                              sgn_bool p2 * pi / 2\\<downharpoonleft>\\<bar>", "unfolding ang_circ_a_def ang_vec_a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. acute_ang\n     (\\<angle>c (circ_tang_vec \\<mu>1 E p1) (circ_tang_vec \\<mu>2 E p2)) =\n    acute_ang\n     \\<bar>\\<downharpoonright>arg (E - \\<mu>2) - arg (E - \\<mu>1) +\n                              sgn_bool p1 * pi / 2 -\n                              sgn_bool p2 * pi / 2\\<downharpoonleft>\\<bar>", "using ang_circ_c_simp[OF assms]"], ["proof (prove)\nusing this:\n  ang_circ_c E \\<mu>1 \\<mu>2 ?p1.0 ?p2.0 =\n  \\<bar>\\<downharpoonright>arg (E - \\<mu>2) - arg (E - \\<mu>1) +\n                           sgn_bool ?p1.0 * pi / 2 -\n                           sgn_bool ?p2.0 * pi / 2\\<downharpoonleft>\\<bar>\n\ngoal (1 subgoal):\n 1. acute_ang\n     (\\<angle>c (circ_tang_vec \\<mu>1 E p1) (circ_tang_vec \\<mu>2 E p2)) =\n    acute_ang\n     \\<bar>\\<downharpoonright>arg (E - \\<mu>2) - arg (E - \\<mu>1) +\n                              sgn_bool p1 * pi / 2 -\n                              sgn_bool p2 * pi / 2\\<downharpoonleft>\\<bar>", "unfolding ang_circ_c_def"], ["proof (prove)\nusing this:\n  \\<angle>c (circ_tang_vec \\<mu>1 E ?p1.0) (circ_tang_vec \\<mu>2 E ?p2.0) =\n  \\<bar>\\<downharpoonright>arg (E - \\<mu>2) - arg (E - \\<mu>1) +\n                           sgn_bool ?p1.0 * pi / 2 -\n                           sgn_bool ?p2.0 * pi / 2\\<downharpoonleft>\\<bar>\n\ngoal (1 subgoal):\n 1. acute_ang\n     (\\<angle>c (circ_tang_vec \\<mu>1 E p1) (circ_tang_vec \\<mu>2 E p2)) =\n    acute_ang\n     \\<bar>\\<downharpoonright>arg (E - \\<mu>2) - arg (E - \\<mu>1) +\n                              sgn_bool p1 * pi / 2 -\n                              sgn_bool p2 * pi / 2\\<downharpoonleft>\\<bar>", "by auto"], ["", "text \\<open>Acute angle between two circles does not depend on the circle orientation.\\<close>"], ["", "lemma ang_circ_a_pTrue:\n  assumes \"E \\<noteq> \\<mu>1\" and \"E \\<noteq> \\<mu>2\"\n  shows \"ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "proof (cases \"p1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p1 \\<Longrightarrow>\n    ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True\n 2. \\<not> p1 \\<Longrightarrow>\n    ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "case True"], ["proof (state)\nthis:\n  p1\n\ngoal (2 subgoals):\n 1. p1 \\<Longrightarrow>\n    ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True\n 2. \\<not> p1 \\<Longrightarrow>\n    ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "proof (cases \"p2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p2 \\<Longrightarrow>\n    ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True\n 2. \\<not> p2 \\<Longrightarrow>\n    ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "case True"], ["proof (state)\nthis:\n  p2\n\ngoal (2 subgoals):\n 1. p2 \\<Longrightarrow>\n    ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True\n 2. \\<not> p2 \\<Longrightarrow>\n    ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "using \\<open>p1\\<close> \\<open>p2\\<close>"], ["proof (prove)\nusing this:\n  p1\n  p2\n\ngoal (1 subgoal):\n 1. ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "by simp"], ["proof (state)\nthis:\n  ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True\n\ngoal (1 subgoal):\n 1. \\<not> p2 \\<Longrightarrow>\n    ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> p2 \\<Longrightarrow>\n    ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "case False"], ["proof (state)\nthis:\n  \\<not> p2\n\ngoal (1 subgoal):\n 1. \\<not> p2 \\<Longrightarrow>\n    ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "using \\<open>p1\\<close> \\<open>\\<not> p2\\<close>"], ["proof (prove)\nusing this:\n  p1\n  \\<not> p2\n\ngoal (1 subgoal):\n 1. ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "unfolding ang_circ_a_def"], ["proof (prove)\nusing this:\n  p1\n  \\<not> p2\n\ngoal (1 subgoal):\n 1. \\<angle>a (circ_tang_vec \\<mu>1 E p1) (circ_tang_vec \\<mu>2 E p2) =\n    \\<angle>a (circ_tang_vec \\<mu>1 E True) (circ_tang_vec \\<mu>2 E True)", "using circ_tang_vec_opposite_orient[of \\<mu>2 E p2]"], ["proof (prove)\nusing this:\n  p1\n  \\<not> p2\n  circ_tang_vec \\<mu>2 E p2 = - circ_tang_vec \\<mu>2 E (\\<not> p2)\n\ngoal (1 subgoal):\n 1. \\<angle>a (circ_tang_vec \\<mu>1 E p1) (circ_tang_vec \\<mu>2 E p2) =\n    \\<angle>a (circ_tang_vec \\<mu>1 E True) (circ_tang_vec \\<mu>2 E True)", "using ang_vec_a_opposite2"], ["proof (prove)\nusing this:\n  p1\n  \\<not> p2\n  circ_tang_vec \\<mu>2 E p2 = - circ_tang_vec \\<mu>2 E (\\<not> p2)\n  \\<angle>a ?z1.0 ?z2.0 = \\<angle>a ?z1.0 (- ?z2.0)\n\ngoal (1 subgoal):\n 1. \\<angle>a (circ_tang_vec \\<mu>1 E p1) (circ_tang_vec \\<mu>2 E p2) =\n    \\<angle>a (circ_tang_vec \\<mu>1 E True) (circ_tang_vec \\<mu>2 E True)", "by simp"], ["proof (state)\nthis:\n  ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True\n\ngoal (1 subgoal):\n 1. \\<not> p1 \\<Longrightarrow>\n    ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> p1 \\<Longrightarrow>\n    ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "case False"], ["proof (state)\nthis:\n  \\<not> p1\n\ngoal (1 subgoal):\n 1. \\<not> p1 \\<Longrightarrow>\n    ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "proof (cases \"p2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p2 \\<Longrightarrow>\n    ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True\n 2. \\<not> p2 \\<Longrightarrow>\n    ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "case True"], ["proof (state)\nthis:\n  p2\n\ngoal (2 subgoals):\n 1. p2 \\<Longrightarrow>\n    ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True\n 2. \\<not> p2 \\<Longrightarrow>\n    ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "using \\<open>\\<not> p1\\<close> \\<open>p2\\<close>"], ["proof (prove)\nusing this:\n  \\<not> p1\n  p2\n\ngoal (1 subgoal):\n 1. ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "unfolding ang_circ_a_def"], ["proof (prove)\nusing this:\n  \\<not> p1\n  p2\n\ngoal (1 subgoal):\n 1. \\<angle>a (circ_tang_vec \\<mu>1 E p1) (circ_tang_vec \\<mu>2 E p2) =\n    \\<angle>a (circ_tang_vec \\<mu>1 E True) (circ_tang_vec \\<mu>2 E True)", "using circ_tang_vec_opposite_orient[of \\<mu>1 E p1]"], ["proof (prove)\nusing this:\n  \\<not> p1\n  p2\n  circ_tang_vec \\<mu>1 E p1 = - circ_tang_vec \\<mu>1 E (\\<not> p1)\n\ngoal (1 subgoal):\n 1. \\<angle>a (circ_tang_vec \\<mu>1 E p1) (circ_tang_vec \\<mu>2 E p2) =\n    \\<angle>a (circ_tang_vec \\<mu>1 E True) (circ_tang_vec \\<mu>2 E True)", "using ang_vec_a_opposite1"], ["proof (prove)\nusing this:\n  \\<not> p1\n  p2\n  circ_tang_vec \\<mu>1 E p1 = - circ_tang_vec \\<mu>1 E (\\<not> p1)\n  \\<angle>a ?z1.0 ?z2.0 = \\<angle>a (- ?z1.0) ?z2.0\n\ngoal (1 subgoal):\n 1. \\<angle>a (circ_tang_vec \\<mu>1 E p1) (circ_tang_vec \\<mu>2 E p2) =\n    \\<angle>a (circ_tang_vec \\<mu>1 E True) (circ_tang_vec \\<mu>2 E True)", "by simp"], ["proof (state)\nthis:\n  ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True\n\ngoal (1 subgoal):\n 1. \\<not> p2 \\<Longrightarrow>\n    ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> p2 \\<Longrightarrow>\n    ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "case False"], ["proof (state)\nthis:\n  \\<not> p2\n\ngoal (1 subgoal):\n 1. \\<not> p2 \\<Longrightarrow>\n    ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "using \\<open>\\<not> p1\\<close> \\<open>\\<not> p2\\<close>"], ["proof (prove)\nusing this:\n  \\<not> p1\n  \\<not> p2\n\ngoal (1 subgoal):\n 1. ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True", "unfolding ang_circ_a_def"], ["proof (prove)\nusing this:\n  \\<not> p1\n  \\<not> p2\n\ngoal (1 subgoal):\n 1. \\<angle>a (circ_tang_vec \\<mu>1 E p1) (circ_tang_vec \\<mu>2 E p2) =\n    \\<angle>a (circ_tang_vec \\<mu>1 E True) (circ_tang_vec \\<mu>2 E True)", "using circ_tang_vec_opposite_orient[of \\<mu>1 E p1] circ_tang_vec_opposite_orient[of \\<mu>2 E p2]"], ["proof (prove)\nusing this:\n  \\<not> p1\n  \\<not> p2\n  circ_tang_vec \\<mu>1 E p1 = - circ_tang_vec \\<mu>1 E (\\<not> p1)\n  circ_tang_vec \\<mu>2 E p2 = - circ_tang_vec \\<mu>2 E (\\<not> p2)\n\ngoal (1 subgoal):\n 1. \\<angle>a (circ_tang_vec \\<mu>1 E p1) (circ_tang_vec \\<mu>2 E p2) =\n    \\<angle>a (circ_tang_vec \\<mu>1 E True) (circ_tang_vec \\<mu>2 E True)", "using ang_vec_a_opposite1  ang_vec_a_opposite2"], ["proof (prove)\nusing this:\n  \\<not> p1\n  \\<not> p2\n  circ_tang_vec \\<mu>1 E p1 = - circ_tang_vec \\<mu>1 E (\\<not> p1)\n  circ_tang_vec \\<mu>2 E p2 = - circ_tang_vec \\<mu>2 E (\\<not> p2)\n  \\<angle>a ?z1.0 ?z2.0 = \\<angle>a (- ?z1.0) ?z2.0\n  \\<angle>a ?z1.0 ?z2.0 = \\<angle>a ?z1.0 (- ?z2.0)\n\ngoal (1 subgoal):\n 1. \\<angle>a (circ_tang_vec \\<mu>1 E p1) (circ_tang_vec \\<mu>2 E p2) =\n    \\<angle>a (circ_tang_vec \\<mu>1 E True) (circ_tang_vec \\<mu>2 E True)", "by simp"], ["proof (state)\nthis:\n  ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = ang_circ_a E \\<mu>1 \\<mu>2 True True\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Definition of the acute angle between the two unoriented circles \\<close>"], ["", "abbreviation ang_circ_a' where\n  \"ang_circ_a' E \\<mu>1 \\<mu>2 \\<equiv> ang_circ_a E \\<mu>1 \\<mu>2 True True\""], ["", "text \\<open>A very simple expression for the acute angle between the two circles\\<close>"], ["", "lemma ang_circ_a_simp1:\n  assumes \"E \\<noteq> \\<mu>1\" and \"E \\<noteq> \\<mu>2\"\n  shows \"ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = \\<angle>a (E - \\<mu>1) (E - \\<mu>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 = \\<angle>a (E - \\<mu>1) (E - \\<mu>2)", "unfolding ang_vec_a_def ang_vec_c_def ang_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ang_circ_a E \\<mu>1 \\<mu>2 p1 p2 =\n    acute_ang\n     \\<bar>\\<downharpoonright>arg (E - \\<mu>2) -\n                              arg (E - \\<mu>1)\\<downharpoonleft>\\<bar>", "by (subst ang_circ_a_pTrue[OF assms, of p1 p2], subst ang_circ_a_simp[OF assms, of True True]) (metis add_diff_cancel)"], ["", "lemma ang_circ_a'_simp:\n  assumes \"E \\<noteq> \\<mu>1\" and \"E \\<noteq> \\<mu>2\"\n  shows \"ang_circ_a' E \\<mu>1 \\<mu>2 = \\<angle>a (E - \\<mu>1) (E - \\<mu>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ang_circ_a' E \\<mu>1 \\<mu>2 = \\<angle>a (E - \\<mu>1) (E - \\<mu>2)", "by (rule ang_circ_a_simp1[OF assms])"], ["", "end"]]}