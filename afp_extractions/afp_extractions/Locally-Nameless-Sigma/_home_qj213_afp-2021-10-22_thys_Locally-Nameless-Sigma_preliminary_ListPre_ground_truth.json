{"file_name": "/home/qj213/afp-2021-10-22/thys/Locally-Nameless-Sigma/preliminary/ListPre.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Locally-Nameless-Sigma", "problem_names": ["lemma drop_lem[rule_format]: \n  fixes n :: nat and l :: \"'a list\" and g :: \"'a list\"\n  assumes \"drop n l = drop n g\" and \"length l = length g\" and \"n < length g\"\n  shows \"l!n = g!n\"", "lemma mem_append_lem': \"x \\<in> set (l @ [y]) \\<Longrightarrow> x \\<in> set l \\<or> x = y\"", "lemma nth_last: \"length l = n \\<Longrightarrow> (l @ [x])!n = x\"", "lemma take_n:\n  fixes n :: nat and l :: \"'a list\" and g :: \"'a list\"\n  assumes \"take n l = take n g\" and \"Suc n \\<le> length g\" and \"length l = length g\"\n  shows \"take (Suc n) (l[n := g!n]) = take (Suc n) g\"", "lemma drop_n_lem:\n  fixes n :: nat and l :: \"'a list\"\n  assumes \"Suc n \\<le> length l\"\n  shows \"drop (Suc n) (l[n := x]) = drop (Suc n) l\"", "lemma drop_n: \n  fixes n :: nat and l :: \"'a list\" and g :: \"'a list\"\n  assumes \"drop n l = drop n g\" and \"Suc n \\<le> length g\" and \"length l = length g\"\n  shows \"drop (Suc n) (l[n := g!n]) = drop (Suc n) g\"", "lemma nth_fst[rule_format]: \"length l = n + 1 \\<longrightarrow> (l @ [x])!0 = l!0\"", "lemma nth_zero_app: \n  fixes l :: \"'a list\" and x :: 'a and y :: 'a\n  assumes \"l \\<noteq> []\" and \"l!0 = x\"\n  shows\"(l @ [y])!0 = x\"", "lemma rev_induct2[consumes 1]:\n  fixes xs :: \"'a list\" and ys :: \"'a list\" and P :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> bool\"\n  assumes \n  \"length xs = length ys\" and \"P [] []\" and\n  \"\\<And>x xs y ys. \\<lbrakk> length xs = length ys; P xs ys \\<rbrakk> \\<Longrightarrow> P (xs @ [x]) (ys @ [y])\"\n  shows \"P xs ys\"", "lemma list_induct3: (* Similar to induction for 2: see ML \"thm \\\"list_induct2\\\"\"; *)\n  \"\\<And>ys zs. \\<lbrakk> length xs = length ys; length zs = length xs; P [] [] [];\n              \\<And>x xs y ys z zs. \\<lbrakk> length xs = length ys; \n                                    length zs = length xs; P xs ys zs \\<rbrakk>\n                                 \\<Longrightarrow> P (x # xs)(y # ys)(z # zs) \n  \\<rbrakk> \\<Longrightarrow> P xs ys zs\"", "lemma insert_eq[simp]: \"\\<forall>i\\<le>length l. (list_insert l i a)!i = a\"", "lemma insert_gt[simp]: \"\\<forall>i\\<le>length l. \\<forall>j<i. (list_insert  l i a)!j = l!j\"", "lemma insert_lt[simp]: \"\\<forall>j\\<le>length l. \\<forall>i\\<le>j. (list_insert l i a)!Suc j = l!j\"", "lemma insert_first[simp]: \"list_insert l 0 b = b#l\"", "lemma insert_prepend[simp]: \n  \"i = Suc j \\<Longrightarrow> list_insert (a#l) i b = a # list_insert l j b\"", "lemma insert_lt2[simp]: \"\\<forall>j. \\<forall>i\\<le>j. (list_insert  l i a)!Suc j = l!j\"", "lemma insert_commute[simp]: \n  \"\\<forall>i\\<le>length l. (list_insert (list_insert l i b) 0 a) =\n                 (list_insert (list_insert l 0 a ) (Suc i) b)\"", "lemma insert_length': \"\\<And>i x. length (list_insert l i x) = length (x#l)\"", "lemma insert_length[simp]: \"length (list_insert l i b) = length (list_insert l j c)\"", "lemma insert_select[simp]: \"the ((f(l \\<mapsto> t)) l) = t\"", "lemma dom_insert[simp]: \"l \\<in> dom f \\<Longrightarrow> dom (f(l \\<mapsto> t)) = dom f\"", "lemma insert_select2[simp]: \"l1 \\<noteq> l2 \\<Longrightarrow> ((f(l1 \\<mapsto> t)) l2) = (f l2)\"", "lemma the_insert_select[simp]: \n  \"\\<lbrakk> l2 \\<in> dom f; l1 \\<noteq> l2 \\<rbrakk> \\<Longrightarrow>  the ((f(l1 \\<mapsto> t)) l2) =  the (f l2)\"", "lemma insert_dom_eq: \"dom f = dom f' \\<Longrightarrow> dom (f(l \\<mapsto> x)) = dom (f'(l \\<mapsto> x'))\"", "lemma insert_dom_less_eq: \n  \"\\<lbrakk> x \\<notin> dom f; x \\<notin> dom f'; dom (f(x \\<mapsto> y)) = dom (f'(x \\<mapsto> y')) \\<rbrakk> \n  \\<Longrightarrow> dom f = dom f'\"", "lemma one_more_dom[rule_format]: \n  \"\\<forall>l\\<in>dom f . \\<exists>f'. f = f'(l \\<mapsto> the(f l)) \\<and> l \\<notin> dom f'\""], "translations": [["", "lemma drop_lem[rule_format]: \n  fixes n :: nat and l :: \"'a list\" and g :: \"'a list\"\n  assumes \"drop n l = drop n g\" and \"length l = length g\" and \"n < length g\"\n  shows \"l!n = g!n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l ! n = g ! n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. l ! n = g ! n", "from assms(2-3)"], ["proof (chain)\npicking this:\n  length l = length g\n  n < length g", "have \"n < length l\""], ["proof (prove)\nusing this:\n  length l = length g\n  n < length g\n\ngoal (1 subgoal):\n 1. n < length l", "by simp"], ["proof (state)\nthis:\n  n < length l\n\ngoal (1 subgoal):\n 1. l ! n = g ! n", "from Cons_nth_drop_Suc[OF this] Cons_nth_drop_Suc[OF assms(3)] assms(1)"], ["proof (chain)\npicking this:\n  l ! n # drop (Suc n) l = drop n l\n  g ! n # drop (Suc n) g = drop n g\n  drop n l = drop n g", "have \"l!n # drop (Suc n) l = g!n # drop (Suc n) g\""], ["proof (prove)\nusing this:\n  l ! n # drop (Suc n) l = drop n l\n  g ! n # drop (Suc n) g = drop n g\n  drop n l = drop n g\n\ngoal (1 subgoal):\n 1. l ! n # drop (Suc n) l = g ! n # drop (Suc n) g", "by simp"], ["proof (state)\nthis:\n  l ! n # drop (Suc n) l = g ! n # drop (Suc n) g\n\ngoal (1 subgoal):\n 1. l ! n = g ! n", "thus ?thesis"], ["proof (prove)\nusing this:\n  l ! n # drop (Suc n) l = g ! n # drop (Suc n) g\n\ngoal (1 subgoal):\n 1. l ! n = g ! n", "by simp"], ["proof (state)\nthis:\n  l ! n = g ! n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mem_append_lem': \"x \\<in> set (l @ [y]) \\<Longrightarrow> x \\<in> set l \\<or> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (l @ [y]) \\<Longrightarrow> x \\<in> set l \\<or> x = y", "by auto"], ["", "lemma nth_last: \"length l = n \\<Longrightarrow> (l @ [x])!n = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length l = n \\<Longrightarrow> (l @ [x]) ! n = x", "by auto"], ["", "lemma take_n:\n  fixes n :: nat and l :: \"'a list\" and g :: \"'a list\"\n  assumes \"take n l = take n g\" and \"Suc n \\<le> length g\" and \"length l = length g\"\n  shows \"take (Suc n) (l[n := g!n]) = take (Suc n) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (Suc n) (l[n := g ! n]) = take (Suc n) g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. take (Suc n) (l[n := g ! n]) = take (Suc n) g", "from assms(2)"], ["proof (chain)\npicking this:\n  Suc n \\<le> length g", "have ng: \"n < length g\""], ["proof (prove)\nusing this:\n  Suc n \\<le> length g\n\ngoal (1 subgoal):\n 1. n < length g", "by simp"], ["proof (state)\nthis:\n  n < length g\n\ngoal (1 subgoal):\n 1. take (Suc n) (l[n := g ! n]) = take (Suc n) g", "with assms(3)"], ["proof (chain)\npicking this:\n  length l = length g\n  n < length g", "have nlupd: \"n < length (l[n := g!n])\""], ["proof (prove)\nusing this:\n  length l = length g\n  n < length g\n\ngoal (1 subgoal):\n 1. n < length (l[n := g ! n])", "by simp"], ["proof (state)\nthis:\n  n < length (l[n := g ! n])\n\ngoal (1 subgoal):\n 1. take (Suc n) (l[n := g ! n]) = take (Suc n) g", "hence nl: \"n < length l\""], ["proof (prove)\nusing this:\n  n < length (l[n := g ! n])\n\ngoal (1 subgoal):\n 1. n < length l", "by simp"], ["proof (state)\nthis:\n  n < length l\n\ngoal (1 subgoal):\n 1. take (Suc n) (l[n := g ! n]) = take (Suc n) g", "from \n    sym[OF assms(1)] id_take_nth_drop[OF ng] take_Suc_conv_app_nth[OF nlupd]\n    nth_list_update_eq[OF nl] take_Suc_conv_app_nth[OF ng]\n    upd_conv_take_nth_drop[OF nl] assms(2-3)"], ["proof (chain)\npicking this:\n  take n g = take n l\n  g = take n g @ g ! n # drop (Suc n) g\n  take (Suc n) (l[n := g ! n]) =\n  take n (l[n := g ! n]) @ [l[n := g ! n] ! n]\n  l[n := ?x] ! n = ?x\n  take (Suc n) g = take n g @ [g ! n]\n  l[n := ?a] = take n l @ ?a # drop (Suc n) l\n  Suc n \\<le> length g\n  length l = length g", "show ?thesis"], ["proof (prove)\nusing this:\n  take n g = take n l\n  g = take n g @ g ! n # drop (Suc n) g\n  take (Suc n) (l[n := g ! n]) =\n  take n (l[n := g ! n]) @ [l[n := g ! n] ! n]\n  l[n := ?x] ! n = ?x\n  take (Suc n) g = take n g @ [g ! n]\n  l[n := ?a] = take n l @ ?a # drop (Suc n) l\n  Suc n \\<le> length g\n  length l = length g\n\ngoal (1 subgoal):\n 1. take (Suc n) (l[n := g ! n]) = take (Suc n) g", "by simp"], ["proof (state)\nthis:\n  take (Suc n) (l[n := g ! n]) = take (Suc n) g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma drop_n_lem:\n  fixes n :: nat and l :: \"'a list\"\n  assumes \"Suc n \\<le> length l\"\n  shows \"drop (Suc n) (l[n := x]) = drop (Suc n) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (Suc n) (l[n := x]) = drop (Suc n) l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. drop (Suc n) (l[n := x]) = drop (Suc n) l", "from assms"], ["proof (chain)\npicking this:\n  Suc n \\<le> length l", "have \"n < length l\""], ["proof (prove)\nusing this:\n  Suc n \\<le> length l\n\ngoal (1 subgoal):\n 1. n < length l", "by simp"], ["proof (state)\nthis:\n  n < length l\n\ngoal (1 subgoal):\n 1. drop (Suc n) (l[n := x]) = drop (Suc n) l", "from \n    upd_conv_take_nth_drop[OF this] drop_Suc[of n \"l[n := x]\"] \n    drop_Suc[of n l] assms"], ["proof (chain)\npicking this:\n  l[n := ?a] = take n l @ ?a # drop (Suc n) l\n  drop (Suc n) (l[n := x]) = drop n (tl (l[n := x]))\n  drop (Suc n) l = drop n (tl l)\n  Suc n \\<le> length l", "show ?thesis"], ["proof (prove)\nusing this:\n  l[n := ?a] = take n l @ ?a # drop (Suc n) l\n  drop (Suc n) (l[n := x]) = drop n (tl (l[n := x]))\n  drop (Suc n) l = drop n (tl l)\n  Suc n \\<le> length l\n\ngoal (1 subgoal):\n 1. drop (Suc n) (l[n := x]) = drop (Suc n) l", "by (simp,(subst drop_tl)+, simp)"], ["proof (state)\nthis:\n  drop (Suc n) (l[n := x]) = drop (Suc n) l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma drop_n: \n  fixes n :: nat and l :: \"'a list\" and g :: \"'a list\"\n  assumes \"drop n l = drop n g\" and \"Suc n \\<le> length g\" and \"length l = length g\"\n  shows \"drop (Suc n) (l[n := g!n]) = drop (Suc n) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (Suc n) (l[n := g ! n]) = drop (Suc n) g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. drop (Suc n) (l[n := g ! n]) = drop (Suc n) g", "from assms(2-3)"], ["proof (chain)\npicking this:\n  Suc n \\<le> length g\n  length l = length g", "have \"Suc n \\<le> length l\""], ["proof (prove)\nusing this:\n  Suc n \\<le> length g\n  length l = length g\n\ngoal (1 subgoal):\n 1. Suc n \\<le> length l", "by simp"], ["proof (state)\nthis:\n  Suc n \\<le> length l\n\ngoal (1 subgoal):\n 1. drop (Suc n) (l[n := g ! n]) = drop (Suc n) g", "from drop_n_lem[OF this] assms(1)"], ["proof (chain)\npicking this:\n  drop (Suc n) (l[n := ?x]) = drop (Suc n) l\n  drop n l = drop n g", "show ?thesis"], ["proof (prove)\nusing this:\n  drop (Suc n) (l[n := ?x]) = drop (Suc n) l\n  drop n l = drop n g\n\ngoal (1 subgoal):\n 1. drop (Suc n) (l[n := g ! n]) = drop (Suc n) g", "by (simp, (subst drop_Suc)+, (subst drop_tl)+, simp)"], ["proof (state)\nthis:\n  drop (Suc n) (l[n := g ! n]) = drop (Suc n) g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nth_fst[rule_format]: \"length l = n + 1 \\<longrightarrow> (l @ [x])!0 = l!0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length l = n + 1 \\<longrightarrow> (l @ [x]) ! 0 = l ! 0", "by (induct l, simp_all)"], ["", "lemma nth_zero_app: \n  fixes l :: \"'a list\" and x :: 'a and y :: 'a\n  assumes \"l \\<noteq> []\" and \"l!0 = x\"\n  shows\"(l @ [y])!0 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l @ [y]) ! 0 = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (l @ [y]) ! 0 = x", "have \"l \\<noteq> [] \\<and> l!0 = x \\<longrightarrow> (l @ [y])!0 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<and> l ! 0 = x \\<longrightarrow> (l @ [y]) ! 0 = x", "by (induct l, simp_all)"], ["proof (state)\nthis:\n  l \\<noteq> [] \\<and> l ! 0 = x \\<longrightarrow> (l @ [y]) ! 0 = x\n\ngoal (1 subgoal):\n 1. (l @ [y]) ! 0 = x", "with assms"], ["proof (chain)\npicking this:\n  l \\<noteq> []\n  l ! 0 = x\n  l \\<noteq> [] \\<and> l ! 0 = x \\<longrightarrow> (l @ [y]) ! 0 = x", "show ?thesis"], ["proof (prove)\nusing this:\n  l \\<noteq> []\n  l ! 0 = x\n  l \\<noteq> [] \\<and> l ! 0 = x \\<longrightarrow> (l @ [y]) ! 0 = x\n\ngoal (1 subgoal):\n 1. (l @ [y]) ! 0 = x", "by simp"], ["proof (state)\nthis:\n  (l @ [y]) ! 0 = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rev_induct2[consumes 1]:\n  fixes xs :: \"'a list\" and ys :: \"'a list\" and P :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> bool\"\n  assumes \n  \"length xs = length ys\" and \"P [] []\" and\n  \"\\<And>x xs y ys. \\<lbrakk> length xs = length ys; P xs ys \\<rbrakk> \\<Longrightarrow> P (xs @ [x]) (ys @ [y])\"\n  shows \"P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs ys", "proof (simplesubst rev_rev_ident[symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. P xs (rev (rev ys))", "from assms(1)"], ["proof (chain)\npicking this:\n  length xs = length ys", "have lrev: \"length (rev xs) = length (rev ys)\""], ["proof (prove)\nusing this:\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. length (rev xs) = length (rev ys)", "by simp"], ["proof (state)\nthis:\n  length (rev xs) = length (rev ys)\n\ngoal (1 subgoal):\n 1. P xs (rev (rev ys))", "from assms"], ["proof (chain)\npicking this:\n  length xs = length ys\n  P [] []\n  \\<lbrakk>length ?xs = length ?ys; P ?xs ?ys\\<rbrakk>\n  \\<Longrightarrow> P (?xs @ [?x]) (?ys @ [?y])", "have \"P (rev (rev xs))(rev (rev ys))\""], ["proof (prove)\nusing this:\n  length xs = length ys\n  P [] []\n  \\<lbrakk>length ?xs = length ?ys; P ?xs ?ys\\<rbrakk>\n  \\<Longrightarrow> P (?xs @ [?x]) (?ys @ [?y])\n\ngoal (1 subgoal):\n 1. P (rev (rev xs)) (rev (rev ys))", "by (induct rule: list_induct2[OF lrev], simp_all)"], ["proof (state)\nthis:\n  P (rev (rev xs)) (rev (rev ys))\n\ngoal (1 subgoal):\n 1. P xs (rev (rev ys))", "thus \"P xs (rev (rev ys))\""], ["proof (prove)\nusing this:\n  P (rev (rev xs)) (rev (rev ys))\n\ngoal (1 subgoal):\n 1. P xs (rev (rev ys))", "by simp"], ["proof (state)\nthis:\n  P xs (rev (rev ys))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_induct3: (* Similar to induction for 2: see ML \"thm \\\"list_induct2\\\"\"; *)\n  \"\\<And>ys zs. \\<lbrakk> length xs = length ys; length zs = length xs; P [] [] [];\n              \\<And>x xs y ys z zs. \\<lbrakk> length xs = length ys; \n                                    length zs = length xs; P xs ys zs \\<rbrakk>\n                                 \\<Longrightarrow> P (x # xs)(y # ys)(z # zs) \n  \\<rbrakk> \\<Longrightarrow> P xs ys zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>length xs = length ys; length zs = length xs; P [] [] [];\n        \\<And>x xs y ys z zs.\n           \\<lbrakk>length xs = length ys; length zs = length xs;\n            P xs ys zs\\<rbrakk>\n           \\<Longrightarrow> P (x # xs) (y # ys) (z # zs)\\<rbrakk>\n       \\<Longrightarrow> P xs ys zs", "proof (induct xs, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys zs.\n       \\<lbrakk>\\<And>ys zs.\n                   \\<lbrakk>length xs = length ys; length zs = length xs;\n                    P [] [] [];\n                    \\<And>x xs y ys z zs.\n                       \\<lbrakk>length xs = length ys;\n                        length zs = length xs; P xs ys zs\\<rbrakk>\n                       \\<Longrightarrow> P (x # xs) (y # ys)\n    (z # zs)\\<rbrakk>\n                   \\<Longrightarrow> P xs ys zs;\n        length (a # xs) = length ys; length zs = length (a # xs);\n        P [] [] [];\n        \\<And>x xs y ys z zs.\n           \\<lbrakk>length xs = length ys; length zs = length xs;\n            P xs ys zs\\<rbrakk>\n           \\<Longrightarrow> P (x # xs) (y # ys) (z # zs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs) ys zs", "case (Cons a xs ys zs)"], ["proof (state)\nthis:\n  \\<lbrakk>length xs = length ?ys; length ?zs = length xs; P [] [] [];\n   \\<And>x xs y ys z zs.\n      \\<lbrakk>length xs = length ys; length zs = length xs;\n       P xs ys zs\\<rbrakk>\n      \\<Longrightarrow> P (x # xs) (y # ys) (z # zs)\\<rbrakk>\n  \\<Longrightarrow> P xs ?ys ?zs\n  length (a # xs) = length ys\n  length zs = length (a # xs)\n  P [] [] []\n  \\<lbrakk>length ?xs = length ?ys; length ?zs = length ?xs;\n   P ?xs ?ys ?zs\\<rbrakk>\n  \\<Longrightarrow> P (?x # ?xs) (?y # ?ys) (?z # ?zs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys zs.\n       \\<lbrakk>\\<And>ys zs.\n                   \\<lbrakk>length xs = length ys; length zs = length xs;\n                    P [] [] [];\n                    \\<And>x xs y ys z zs.\n                       \\<lbrakk>length xs = length ys;\n                        length zs = length xs; P xs ys zs\\<rbrakk>\n                       \\<Longrightarrow> P (x # xs) (y # ys)\n    (z # zs)\\<rbrakk>\n                   \\<Longrightarrow> P xs ys zs;\n        length (a # xs) = length ys; length zs = length (a # xs);\n        P [] [] [];\n        \\<And>x xs y ys z zs.\n           \\<lbrakk>length xs = length ys; length zs = length xs;\n            P xs ys zs\\<rbrakk>\n           \\<Longrightarrow> P (x # xs) (y # ys) (z # zs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs) ys zs", "from \\<open>length (a#xs) = length ys\\<close> \\<open>length zs = length (a#xs)\\<close>"], ["proof (chain)\npicking this:\n  length (a # xs) = length ys\n  length zs = length (a # xs)", "have \"ys \\<noteq> [] \\<and> zs \\<noteq> []\""], ["proof (prove)\nusing this:\n  length (a # xs) = length ys\n  length zs = length (a # xs)\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [] \\<and> zs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  ys \\<noteq> [] \\<and> zs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys zs.\n       \\<lbrakk>\\<And>ys zs.\n                   \\<lbrakk>length xs = length ys; length zs = length xs;\n                    P [] [] [];\n                    \\<And>x xs y ys z zs.\n                       \\<lbrakk>length xs = length ys;\n                        length zs = length xs; P xs ys zs\\<rbrakk>\n                       \\<Longrightarrow> P (x # xs) (y # ys)\n    (z # zs)\\<rbrakk>\n                   \\<Longrightarrow> P xs ys zs;\n        length (a # xs) = length ys; length zs = length (a # xs);\n        P [] [] [];\n        \\<And>x xs y ys z zs.\n           \\<lbrakk>length xs = length ys; length zs = length xs;\n            P xs ys zs\\<rbrakk>\n           \\<Longrightarrow> P (x # xs) (y # ys) (z # zs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs) ys zs", "then"], ["proof (chain)\npicking this:\n  ys \\<noteq> [] \\<and> zs \\<noteq> []", "obtain b ly c lz where \"ys = b#ly\" and \"zs = c#lz\""], ["proof (prove)\nusing this:\n  ys \\<noteq> [] \\<and> zs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>b ly c lz.\n        \\<lbrakk>ys = b # ly; zs = c # lz\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: neq_Nil_conv)"], ["proof (state)\nthis:\n  ys = b # ly\n  zs = c # lz\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys zs.\n       \\<lbrakk>\\<And>ys zs.\n                   \\<lbrakk>length xs = length ys; length zs = length xs;\n                    P [] [] [];\n                    \\<And>x xs y ys z zs.\n                       \\<lbrakk>length xs = length ys;\n                        length zs = length xs; P xs ys zs\\<rbrakk>\n                       \\<Longrightarrow> P (x # xs) (y # ys)\n    (z # zs)\\<rbrakk>\n                   \\<Longrightarrow> P xs ys zs;\n        length (a # xs) = length ys; length zs = length (a # xs);\n        P [] [] [];\n        \\<And>x xs y ys z zs.\n           \\<lbrakk>length xs = length ys; length zs = length xs;\n            P xs ys zs\\<rbrakk>\n           \\<Longrightarrow> P (x # xs) (y # ys) (z # zs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs) ys zs", "with \\<open>length (a#xs) = length ys\\<close> \\<open>length zs = length (a#xs)\\<close>"], ["proof (chain)\npicking this:\n  length (a # xs) = length ys\n  length zs = length (a # xs)\n  ys = b # ly\n  zs = c # lz", "obtain \"length xs = length ly\" and \"length lz = length xs\""], ["proof (prove)\nusing this:\n  length (a # xs) = length ys\n  length zs = length (a # xs)\n  ys = b # ly\n  zs = c # lz\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>length xs = length ly; length lz = length xs\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  length xs = length ly\n  length lz = length xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys zs.\n       \\<lbrakk>\\<And>ys zs.\n                   \\<lbrakk>length xs = length ys; length zs = length xs;\n                    P [] [] [];\n                    \\<And>x xs y ys z zs.\n                       \\<lbrakk>length xs = length ys;\n                        length zs = length xs; P xs ys zs\\<rbrakk>\n                       \\<Longrightarrow> P (x # xs) (y # ys)\n    (z # zs)\\<rbrakk>\n                   \\<Longrightarrow> P xs ys zs;\n        length (a # xs) = length ys; length zs = length (a # xs);\n        P [] [] [];\n        \\<And>x xs y ys z zs.\n           \\<lbrakk>length xs = length ys; length zs = length xs;\n            P xs ys zs\\<rbrakk>\n           \\<Longrightarrow> P (x # xs) (y # ys) (z # zs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs) ys zs", "from \n    Cons(5)[OF this Cons(1)[OF this \\<open>P [] [] []\\<close>]] \n    Cons(5) \\<open>ys = b#ly\\<close> \\<open>zs = c#lz\\<close>"], ["proof (chain)\npicking this:\n  (\\<And>x xs y ys z zs.\n      \\<lbrakk>length xs = length ys; length zs = length xs;\n       P xs ys zs\\<rbrakk>\n      \\<Longrightarrow> P (x # xs) (y # ys) (z # zs)) \\<Longrightarrow>\n  P (?x # xs) (?y # ly) (?z # lz)\n  \\<lbrakk>length ?xs = length ?ys; length ?zs = length ?xs;\n   P ?xs ?ys ?zs\\<rbrakk>\n  \\<Longrightarrow> P (?x # ?xs) (?y # ?ys) (?z # ?zs)\n  ys = b # ly\n  zs = c # lz", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>x xs y ys z zs.\n      \\<lbrakk>length xs = length ys; length zs = length xs;\n       P xs ys zs\\<rbrakk>\n      \\<Longrightarrow> P (x # xs) (y # ys) (z # zs)) \\<Longrightarrow>\n  P (?x # xs) (?y # ly) (?z # lz)\n  \\<lbrakk>length ?xs = length ?ys; length ?zs = length ?xs;\n   P ?xs ?ys ?zs\\<rbrakk>\n  \\<Longrightarrow> P (?x # ?xs) (?y # ?ys) (?z # ?zs)\n  ys = b # ly\n  zs = c # lz\n\ngoal (1 subgoal):\n 1. P (a # xs) ys zs", "by simp"], ["proof (state)\nthis:\n  P (a # xs) ys zs\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec list_insert :: \"'a list \\<Rightarrow> nat \\<Rightarrow> 'a \\<Rightarrow> 'a list\" where\n  \"list_insert (ah#as) i a = \n  (case i of \n        0      \\<Rightarrow> a#ah#as\n       |Suc j  \\<Rightarrow> ah#(list_insert as j a))\" |\n\n  \"list_insert [] i a = [a]\""], ["", "lemma insert_eq[simp]: \"\\<forall>i\\<le>length l. (list_insert l i a)!i = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>length l. list_insert l i a ! i = a", "by (induct l, simp, intro strip, simp split: nat.split)"], ["", "lemma insert_gt[simp]: \"\\<forall>i\\<le>length l. \\<forall>j<i. (list_insert  l i a)!j = l!j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>length l. \\<forall>j<i. list_insert l i a ! j = l ! j", "proof (induct l, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa l.\n       \\<forall>i\\<le>length l.\n          \\<forall>j<i. list_insert l i a ! j = l ! j \\<Longrightarrow>\n       \\<forall>i\\<le>length (aa # l).\n          \\<forall>j<i. list_insert (aa # l) i a ! j = (aa # l) ! j", "case (Cons x l)"], ["proof (state)\nthis:\n  \\<forall>i\\<le>length l. \\<forall>j<i. list_insert l i a ! j = l ! j\n\ngoal (1 subgoal):\n 1. \\<And>aa l.\n       \\<forall>i\\<le>length l.\n          \\<forall>j<i. list_insert l i a ! j = l ! j \\<Longrightarrow>\n       \\<forall>i\\<le>length (aa # l).\n          \\<forall>j<i. list_insert (aa # l) i a ! j = (aa # l) ! j", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>length l. \\<forall>j<i. list_insert l i a ! j = l ! j\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>length (x # l).\n       \\<forall>j<i. list_insert (x # l) i a ! j = (x # l) ! j", "proof (auto split: nat.split)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2 j.\n       \\<lbrakk>\\<forall>i\\<le>length l.\n                   \\<forall>j<i. list_insert l i a ! j = l ! j;\n        x2 \\<le> length l; j < Suc x2\\<rbrakk>\n       \\<Longrightarrow> (x # list_insert l x2 a) ! j = (x # l) ! j", "fix n j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2 j.\n       \\<lbrakk>\\<forall>i\\<le>length l.\n                   \\<forall>j<i. list_insert l i a ! j = l ! j;\n        x2 \\<le> length l; j < Suc x2\\<rbrakk>\n       \\<Longrightarrow> (x # list_insert l x2 a) ! j = (x # l) ! j", "assume \"n \\<le> length l\" and \"j < Suc n\""], ["proof (state)\nthis:\n  n \\<le> length l\n  j < Suc n\n\ngoal (1 subgoal):\n 1. \\<And>x2 j.\n       \\<lbrakk>\\<forall>i\\<le>length l.\n                   \\<forall>j<i. list_insert l i a ! j = l ! j;\n        x2 \\<le> length l; j < Suc x2\\<rbrakk>\n       \\<Longrightarrow> (x # list_insert l x2 a) ! j = (x # l) ! j", "with Cons(1)"], ["proof (chain)\npicking this:\n  \\<forall>i\\<le>length l. \\<forall>j<i. list_insert l i a ! j = l ! j\n  n \\<le> length l\n  j < Suc n", "show \"(x#(list_insert l n a))!j = (x#l)!j\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>length l. \\<forall>j<i. list_insert l i a ! j = l ! j\n  n \\<le> length l\n  j < Suc n\n\ngoal (1 subgoal):\n 1. (x # list_insert l n a) ! j = (x # l) ! j", "by (cases j) simp_all"], ["proof (state)\nthis:\n  (x # list_insert l n a) ! j = (x # l) ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i\\<le>length (x # l).\n     \\<forall>j<i. list_insert (x # l) i a ! j = (x # l) ! j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_lt[simp]: \"\\<forall>j\\<le>length l. \\<forall>i\\<le>j. (list_insert l i a)!Suc j = l!j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<le>length l.\n       \\<forall>i\\<le>j. list_insert l i a ! Suc j = l ! j", "proof (induct l, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa l.\n       \\<forall>j\\<le>length l.\n          \\<forall>i\\<le>j.\n             list_insert l i a ! Suc j = l ! j \\<Longrightarrow>\n       \\<forall>j\\<le>length (aa # l).\n          \\<forall>i\\<le>j. list_insert (aa # l) i a ! Suc j = (aa # l) ! j", "case (Cons x l)"], ["proof (state)\nthis:\n  \\<forall>j\\<le>length l.\n     \\<forall>i\\<le>j. list_insert l i a ! Suc j = l ! j\n\ngoal (1 subgoal):\n 1. \\<And>aa l.\n       \\<forall>j\\<le>length l.\n          \\<forall>i\\<le>j.\n             list_insert l i a ! Suc j = l ! j \\<Longrightarrow>\n       \\<forall>j\\<le>length (aa # l).\n          \\<forall>i\\<le>j. list_insert (aa # l) i a ! Suc j = (aa # l) ! j", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>j\\<le>length l.\n     \\<forall>i\\<le>j. list_insert l i a ! Suc j = l ! j\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<le>length (x # l).\n       \\<forall>i\\<le>j. list_insert (x # l) i a ! Suc j = (x # l) ! j", "proof (auto split: nat.split)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j x2.\n       \\<lbrakk>\\<forall>j\\<le>length l.\n                   \\<forall>i\\<le>j. list_insert l i a ! Suc j = l ! j;\n        j \\<le> Suc (length l); Suc x2 \\<le> j\\<rbrakk>\n       \\<Longrightarrow> list_insert l x2 a ! j = l ! (j - Suc 0)", "fix n j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j x2.\n       \\<lbrakk>\\<forall>j\\<le>length l.\n                   \\<forall>i\\<le>j. list_insert l i a ! Suc j = l ! j;\n        j \\<le> Suc (length l); Suc x2 \\<le> j\\<rbrakk>\n       \\<Longrightarrow> list_insert l x2 a ! j = l ! (j - Suc 0)", "assume \"j \\<le> Suc (length l)\" and \"Suc n \\<le> j\""], ["proof (state)\nthis:\n  j \\<le> Suc (length l)\n  Suc n \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>j x2.\n       \\<lbrakk>\\<forall>j\\<le>length l.\n                   \\<forall>i\\<le>j. list_insert l i a ! Suc j = l ! j;\n        j \\<le> Suc (length l); Suc x2 \\<le> j\\<rbrakk>\n       \\<Longrightarrow> list_insert l x2 a ! j = l ! (j - Suc 0)", "with Cons(1)"], ["proof (chain)\npicking this:\n  \\<forall>j\\<le>length l.\n     \\<forall>i\\<le>j. list_insert l i a ! Suc j = l ! j\n  j \\<le> Suc (length l)\n  Suc n \\<le> j", "show \"(list_insert l n a)!j = l!(j - Suc 0)\""], ["proof (prove)\nusing this:\n  \\<forall>j\\<le>length l.\n     \\<forall>i\\<le>j. list_insert l i a ! Suc j = l ! j\n  j \\<le> Suc (length l)\n  Suc n \\<le> j\n\ngoal (1 subgoal):\n 1. list_insert l n a ! j = l ! (j - Suc 0)", "by (cases j) simp_all"], ["proof (state)\nthis:\n  list_insert l n a ! j = l ! (j - Suc 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>j\\<le>length (x # l).\n     \\<forall>i\\<le>j. list_insert (x # l) i a ! Suc j = (x # l) ! j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_first[simp]: \"list_insert l 0 b = b#l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_insert l 0 b = b # l", "by (induct l, simp_all)"], ["", "lemma insert_prepend[simp]: \n  \"i = Suc j \\<Longrightarrow> list_insert (a#l) i b = a # list_insert l j b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = Suc j \\<Longrightarrow>\n    list_insert (a # l) i b = a # list_insert l j b", "by auto"], ["", "lemma insert_lt2[simp]: \"\\<forall>j. \\<forall>i\\<le>j. (list_insert  l i a)!Suc j = l!j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j i.\n       i \\<le> j \\<longrightarrow> list_insert l i a ! Suc j = l ! j", "proof (induct l, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa l.\n       \\<forall>j i.\n          i \\<le> j \\<longrightarrow>\n          list_insert l i a ! Suc j = l ! j \\<Longrightarrow>\n       \\<forall>j i.\n          i \\<le> j \\<longrightarrow>\n          list_insert (aa # l) i a ! Suc j = (aa # l) ! j", "case (Cons x l)"], ["proof (state)\nthis:\n  \\<forall>j i.\n     i \\<le> j \\<longrightarrow> list_insert l i a ! Suc j = l ! j\n\ngoal (1 subgoal):\n 1. \\<And>aa l.\n       \\<forall>j i.\n          i \\<le> j \\<longrightarrow>\n          list_insert l i a ! Suc j = l ! j \\<Longrightarrow>\n       \\<forall>j i.\n          i \\<le> j \\<longrightarrow>\n          list_insert (aa # l) i a ! Suc j = (aa # l) ! j", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>j i.\n     i \\<le> j \\<longrightarrow> list_insert l i a ! Suc j = l ! j\n\ngoal (1 subgoal):\n 1. \\<forall>j i.\n       i \\<le> j \\<longrightarrow>\n       list_insert (x # l) i a ! Suc j = (x # l) ! j", "proof (auto split: nat.split)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j x2.\n       \\<lbrakk>\\<forall>j i.\n                   i \\<le> j \\<longrightarrow>\n                   list_insert l i a ! Suc j = l ! j;\n        Suc x2 \\<le> j\\<rbrakk>\n       \\<Longrightarrow> list_insert l x2 a ! j = l ! (j - Suc 0)", "fix n j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j x2.\n       \\<lbrakk>\\<forall>j i.\n                   i \\<le> j \\<longrightarrow>\n                   list_insert l i a ! Suc j = l ! j;\n        Suc x2 \\<le> j\\<rbrakk>\n       \\<Longrightarrow> list_insert l x2 a ! j = l ! (j - Suc 0)", "assume \"Suc n \\<le> j\""], ["proof (state)\nthis:\n  Suc n \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>j x2.\n       \\<lbrakk>\\<forall>j i.\n                   i \\<le> j \\<longrightarrow>\n                   list_insert l i a ! Suc j = l ! j;\n        Suc x2 \\<le> j\\<rbrakk>\n       \\<Longrightarrow> list_insert l x2 a ! j = l ! (j - Suc 0)", "with Cons(1)"], ["proof (chain)\npicking this:\n  \\<forall>j i.\n     i \\<le> j \\<longrightarrow> list_insert l i a ! Suc j = l ! j\n  Suc n \\<le> j", "show \"(list_insert l n a)!j = l!(j - Suc 0)\""], ["proof (prove)\nusing this:\n  \\<forall>j i.\n     i \\<le> j \\<longrightarrow> list_insert l i a ! Suc j = l ! j\n  Suc n \\<le> j\n\ngoal (1 subgoal):\n 1. list_insert l n a ! j = l ! (j - Suc 0)", "by (cases j) simp_all"], ["proof (state)\nthis:\n  list_insert l n a ! j = l ! (j - Suc 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>j i.\n     i \\<le> j \\<longrightarrow>\n     list_insert (x # l) i a ! Suc j = (x # l) ! j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_commute[simp]: \n  \"\\<forall>i\\<le>length l. (list_insert (list_insert l i b) 0 a) =\n                 (list_insert (list_insert l 0 a ) (Suc i) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>length l.\n       list_insert (list_insert l i b) 0 a =\n       list_insert (list_insert l 0 a) (Suc i) b", "by (induct l, auto split: nat.split)"], ["", "lemma insert_length': \"\\<And>i x. length (list_insert l i x) = length (x#l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x. length (list_insert l i x) = length (x # l)", "by (induct l, auto split: nat.split)"], ["", "lemma insert_length[simp]: \"length (list_insert l i b) = length (list_insert l j c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (list_insert l i b) = length (list_insert l j c)", "by (simp add: insert_length')"], ["", "lemma insert_select[simp]: \"the ((f(l \\<mapsto> t)) l) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the ((f(l \\<mapsto> t)) l) = t", "by auto"], ["", "lemma dom_insert[simp]: \"l \\<in> dom f \\<Longrightarrow> dom (f(l \\<mapsto> t)) = dom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> dom f \\<Longrightarrow> dom (f(l \\<mapsto> t)) = dom f", "by auto"], ["", "lemma insert_select2[simp]: \"l1 \\<noteq> l2 \\<Longrightarrow> ((f(l1 \\<mapsto> t)) l2) = (f l2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l1 \\<noteq> l2 \\<Longrightarrow> (f(l1 \\<mapsto> t)) l2 = f l2", "by auto"], ["", "lemma the_insert_select[simp]: \n  \"\\<lbrakk> l2 \\<in> dom f; l1 \\<noteq> l2 \\<rbrakk> \\<Longrightarrow>  the ((f(l1 \\<mapsto> t)) l2) =  the (f l2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l2 \\<in> dom f; l1 \\<noteq> l2\\<rbrakk>\n    \\<Longrightarrow> the ((f(l1 \\<mapsto> t)) l2) = the (f l2)", "by auto"], ["", "lemma insert_dom_eq: \"dom f = dom f' \\<Longrightarrow> dom (f(l \\<mapsto> x)) = dom (f'(l \\<mapsto> x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom f = dom f' \\<Longrightarrow>\n    dom (f(l \\<mapsto> x)) = dom (f'(l \\<mapsto> x'))", "by auto"], ["", "lemma insert_dom_less_eq: \n  \"\\<lbrakk> x \\<notin> dom f; x \\<notin> dom f'; dom (f(x \\<mapsto> y)) = dom (f'(x \\<mapsto> y')) \\<rbrakk> \n  \\<Longrightarrow> dom f = dom f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> dom f; x \\<notin> dom f';\n     dom (f(x \\<mapsto> y)) = dom (f'(x \\<mapsto> y'))\\<rbrakk>\n    \\<Longrightarrow> dom f = dom f'", "by auto"], ["", "lemma one_more_dom[rule_format]: \n  \"\\<forall>l\\<in>dom f . \\<exists>f'. f = f'(l \\<mapsto> the(f l)) \\<and> l \\<notin> dom f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l\\<in>dom f.\n       \\<exists>f'. f = f'(l \\<mapsto> the (f l)) \\<and> l \\<notin> dom f'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       l \\<in> dom f \\<Longrightarrow>\n       \\<exists>f'. f = f'(l \\<mapsto> the (f l)) \\<and> l \\<notin> dom f'", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       l \\<in> dom f \\<Longrightarrow>\n       \\<exists>f'. f = f'(l \\<mapsto> the (f l)) \\<and> l \\<notin> dom f'", "assume \"l \\<in> dom f\""], ["proof (state)\nthis:\n  l \\<in> dom f\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       l \\<in> dom f \\<Longrightarrow>\n       \\<exists>f'. f = f'(l \\<mapsto> the (f l)) \\<and> l \\<notin> dom f'", "hence \"\\<And>la. f la = ((\\<lambda>la. if la = l then None else f la)(l \\<mapsto> the (f l))) la\""], ["proof (prove)\nusing this:\n  l \\<in> dom f\n\ngoal (1 subgoal):\n 1. \\<And>la.\n       f la =\n       ((\\<lambda>la. if la = l then None else f la)(l \\<mapsto> the (f l)))\n        la", "by auto"], ["proof (state)\nthis:\n  f ?la =\n  ((\\<lambda>la. if la = l then None else f la)(l \\<mapsto> the (f l))) ?la\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       l \\<in> dom f \\<Longrightarrow>\n       \\<exists>f'. f = f'(l \\<mapsto> the (f l)) \\<and> l \\<notin> dom f'", "hence \"f = (\\<lambda>la. if la = l then None else f la)(l \\<mapsto> the (f l))\""], ["proof (prove)\nusing this:\n  f ?la =\n  ((\\<lambda>la. if la = l then None else f la)(l \\<mapsto> the (f l))) ?la\n\ngoal (1 subgoal):\n 1. f = (\\<lambda>la. if la = l then None else f la)(l \\<mapsto> the (f l))", "by (rule ext)"], ["proof (state)\nthis:\n  f = (\\<lambda>la. if la = l then None else f la)(l \\<mapsto> the (f l))\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       l \\<in> dom f \\<Longrightarrow>\n       \\<exists>f'. f = f'(l \\<mapsto> the (f l)) \\<and> l \\<notin> dom f'", "thus \"\\<exists>f'. f = f'(l \\<mapsto> the(f l) ) \\<and> l \\<notin> dom f'\""], ["proof (prove)\nusing this:\n  f = (\\<lambda>la. if la = l then None else f la)(l \\<mapsto> the (f l))\n\ngoal (1 subgoal):\n 1. \\<exists>f'. f = f'(l \\<mapsto> the (f l)) \\<and> l \\<notin> dom f'", "by auto"], ["proof (state)\nthis:\n  \\<exists>f'. f = f'(l \\<mapsto> the (f l)) \\<and> l \\<notin> dom f'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}