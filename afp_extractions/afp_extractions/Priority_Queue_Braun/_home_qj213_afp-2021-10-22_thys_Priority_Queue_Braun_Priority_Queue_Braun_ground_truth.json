{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun", "problem_names": ["lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\"", "lemma get_min: \"\\<lbrakk> heap t;  t \\<noteq> Leaf \\<rbrakk> \\<Longrightarrow> get_min t = Min_mset (mset_tree t)\"", "lemma size_insert[simp]: \"size(insert x t) = size t + 1\"", "lemma mset_insert: \"mset_tree(insert x t) = {#x#} + mset_tree t\"", "lemma set_insert[simp]: \"set_tree(insert x t) = {x} \\<union> (set_tree t)\"", "lemma braun_insert: \"braun t \\<Longrightarrow> braun(insert x t)\"", "lemma heap_insert: \"heap t \\<Longrightarrow> heap(insert x t)\"", "lemma del_left_mset_plus:\n  \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf\n  \\<Longrightarrow> mset_tree t = {#x#} + mset_tree t'\"", "lemma del_left_mset:\n  \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf\n  \\<Longrightarrow> x \\<in># mset_tree t \\<and> mset_tree t' = mset_tree t - {#x#}\"", "lemma del_left_set:\n  \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> set_tree t = {x} \\<union> set_tree t'\"", "lemma del_left_heap:\n  \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> heap t \\<Longrightarrow> heap t'\"", "lemma del_left_size:\n  \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> size t = size t' + 1\"", "lemma del_left_braun:\n  \"del_left t = (x,t') \\<Longrightarrow> braun t \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> braun t'\"", "lemma size_sift_down:\n  \"braun(Node l a r) \\<Longrightarrow> size(sift_down l a r) = size l + size r + 1\"", "lemma braun_sift_down:\n  \"braun(Node l a r) \\<Longrightarrow> braun(sift_down l a r)\"", "lemma mset_sift_down:\n  \"braun(Node l a r) \\<Longrightarrow> mset_tree(sift_down l a r) = {#a#} + (mset_tree l + mset_tree r)\"", "lemma set_sift_down: \"braun(Node l a r)\n  \\<Longrightarrow> set_tree(sift_down l a r) = {a} \\<union> (set_tree l \\<union> set_tree r)\"", "lemma heap_sift_down:\n  \"braun(Node l a r) \\<Longrightarrow> heap l \\<Longrightarrow> heap r \\<Longrightarrow> heap(sift_down l a r)\"", "lemma braun_del_min: \"braun t \\<Longrightarrow> braun(del_min t)\"", "lemma heap_del_min: \"heap t \\<Longrightarrow> braun t \\<Longrightarrow> heap(del_min t)\"", "lemma size_del_min: assumes \"braun t\" shows \"size(del_min t) = size t - 1\"", "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\""], "translations": [["", "lemma height_size_braun: \"braun t \\<Longrightarrow> 2 ^ (height t) \\<le> 2 * size t + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun t \\<Longrightarrow> 2 ^ height t \\<le> 2 * size t + 1", "proof(induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. braun \\<langle>\\<rangle> \\<Longrightarrow>\n    2 ^ height \\<langle>\\<rangle> \\<le> 2 * size \\<langle>\\<rangle> + 1\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>braun t1 \\<Longrightarrow>\n                2 ^ height t1 \\<le> 2 * size t1 + 1;\n        braun t2 \\<Longrightarrow> 2 ^ height t2 \\<le> 2 * size t2 + 1;\n        braun \\<langle>t1, x2, t2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> 2 ^ height \\<langle>t1, x2, t2\\<rangle>\n                         \\<le> 2 * size \\<langle>t1, x2, t2\\<rangle> + 1", "case (Node t1)"], ["proof (state)\nthis:\n  braun t1 \\<Longrightarrow> 2 ^ height t1 \\<le> 2 * size t1 + 1\n  braun t2_ \\<Longrightarrow> 2 ^ height t2_ \\<le> 2 * size t2_ + 1\n  braun \\<langle>t1, x2_, t2_\\<rangle>\n\ngoal (2 subgoals):\n 1. braun \\<langle>\\<rangle> \\<Longrightarrow>\n    2 ^ height \\<langle>\\<rangle> \\<le> 2 * size \\<langle>\\<rangle> + 1\n 2. \\<And>t1 x2 t2.\n       \\<lbrakk>braun t1 \\<Longrightarrow>\n                2 ^ height t1 \\<le> 2 * size t1 + 1;\n        braun t2 \\<Longrightarrow> 2 ^ height t2 \\<le> 2 * size t2 + 1;\n        braun \\<langle>t1, x2, t2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> 2 ^ height \\<langle>t1, x2, t2\\<rangle>\n                         \\<le> 2 * size \\<langle>t1, x2, t2\\<rangle> + 1", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n    \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "proof (cases \"height t1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. height t1 = 0 \\<Longrightarrow>\n    2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n    \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1\n 2. \\<And>nat.\n       height t1 = Suc nat \\<Longrightarrow>\n       2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n       \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "case 0"], ["proof (state)\nthis:\n  height t1 = 0\n\ngoal (2 subgoals):\n 1. height t1 = 0 \\<Longrightarrow>\n    2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n    \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1\n 2. \\<And>nat.\n       height t1 = Suc nat \\<Longrightarrow>\n       2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n       \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  height t1 = 0\n\ngoal (1 subgoal):\n 1. 2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n    \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "using Node"], ["proof (prove)\nusing this:\n  height t1 = 0\n  braun t1 \\<Longrightarrow> 2 ^ height t1 \\<le> 2 * size t1 + 1\n  braun t2_ \\<Longrightarrow> 2 ^ height t2_ \\<le> 2 * size t2_ + 1\n  braun \\<langle>t1, x2_, t2_\\<rangle>\n\ngoal (1 subgoal):\n 1. 2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n    \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "by simp"], ["proof (state)\nthis:\n  2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n  \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       height t1 = Suc nat \\<Longrightarrow>\n       2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n       \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       height t1 = Suc nat \\<Longrightarrow>\n       2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n       \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "case (Suc n)"], ["proof (state)\nthis:\n  height t1 = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       height t1 = Suc nat \\<Longrightarrow>\n       2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n       \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "hence \"2 ^ n \\<le> size t1\""], ["proof (prove)\nusing this:\n  height t1 = Suc n\n\ngoal (1 subgoal):\n 1. 2 ^ n \\<le> size t1", "using Node"], ["proof (prove)\nusing this:\n  height t1 = Suc n\n  braun t1 \\<Longrightarrow> 2 ^ height t1 \\<le> 2 * size t1 + 1\n  braun t2_ \\<Longrightarrow> 2 ^ height t2_ \\<le> 2 * size t2_ + 1\n  braun \\<langle>t1, x2_, t2_\\<rangle>\n\ngoal (1 subgoal):\n 1. 2 ^ n \\<le> size t1", "by simp"], ["proof (state)\nthis:\n  2 ^ n \\<le> size t1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       height t1 = Suc nat \\<Longrightarrow>\n       2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n       \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  2 ^ n \\<le> size t1\n\ngoal (1 subgoal):\n 1. 2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n    \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "using Suc Node"], ["proof (prove)\nusing this:\n  2 ^ n \\<le> size t1\n  height t1 = Suc n\n  braun t1 \\<Longrightarrow> 2 ^ height t1 \\<le> 2 * size t1 + 1\n  braun t2_ \\<Longrightarrow> 2 ^ height t2_ \\<le> 2 * size t2_ + 1\n  braun \\<langle>t1, x2_, t2_\\<rangle>\n\ngoal (1 subgoal):\n 1. 2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n    \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1", "by(auto simp: max_def)"], ["proof (state)\nthis:\n  2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n  \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 ^ height \\<langle>t1, x2_, t2_\\<rangle>\n  \\<le> 2 * size \\<langle>t1, x2_, t2_\\<rangle> + 1\n\ngoal (1 subgoal):\n 1. braun \\<langle>\\<rangle> \\<Longrightarrow>\n    2 ^ height \\<langle>\\<rangle> \\<le> 2 * size \\<langle>\\<rangle> + 1", "qed simp"], ["", "subsection \"Get Minimum\""], ["", "fun get_min :: \"'a::linorder tree \\<Rightarrow> 'a\" where\n\"get_min (Node l a r) = a\""], ["", "lemma get_min: \"\\<lbrakk> heap t;  t \\<noteq> Leaf \\<rbrakk> \\<Longrightarrow> get_min t = Min_mset (mset_tree t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap t; t \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> get_min t = Min_mset (mset_tree t)", "by (auto simp add: eq_Min_iff neq_Leaf_iff)"], ["", "subsection \\<open>Insertion\\<close>"], ["", "hide_const (open) insert"], ["", "fun insert :: \"'a::linorder \\<Rightarrow> 'a tree \\<Rightarrow> 'a tree\" where\n\"insert a Leaf = Node Leaf a Leaf\" |\n\"insert a (Node l x r) =\n (if a < x then Node (insert x r) a l else Node (insert a r) x l)\""], ["", "lemma size_insert[simp]: \"size(insert x t) = size t + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (insert x t) = size t + 1", "by(induction t arbitrary: x) auto"], ["", "lemma mset_insert: \"mset_tree(insert x t) = {#x#} + mset_tree t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_tree (insert x t) = {#x#} + mset_tree t", "by(induction t arbitrary: x) (auto simp: ac_simps)"], ["", "lemma set_insert[simp]: \"set_tree(insert x t) = {x} \\<union> (set_tree t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_tree (insert x t) = {x} \\<union> set_tree t", "by(simp add: mset_insert flip: set_mset_tree)"], ["", "lemma braun_insert: \"braun t \\<Longrightarrow> braun(insert x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun t \\<Longrightarrow> braun (insert x t)", "by(induction t arbitrary: x) auto"], ["", "lemma heap_insert: \"heap t \\<Longrightarrow> heap(insert x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap t \\<Longrightarrow> heap (insert x t)", "by(induction t arbitrary: x) (auto  simp add: ball_Un)"], ["", "subsection \\<open>Deletion\\<close>"], ["", "text \\<open>Slightly simpler definition of @{text del_left}\nwhich avoids the need to appeal to the Braun invariant.\\<close>"], ["", "fun del_left :: \"'a tree \\<Rightarrow> 'a * 'a tree\" where\n\"del_left (Node Leaf x r) = (x,r)\" |\n\"del_left (Node l x r) = (let (y,l') = del_left l in (y,Node r x l'))\""], ["", "lemma del_left_mset_plus:\n  \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf\n  \\<Longrightarrow> mset_tree t = {#x#} + mset_tree t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>del_left t = (x, t'); t \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> mset_tree t = {#x#} + mset_tree t'", "by (induction t arbitrary: x t' rule: del_left.induct;\n    auto split: prod.splits)"], ["", "lemma del_left_mset:\n  \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf\n  \\<Longrightarrow> x \\<in># mset_tree t \\<and> mset_tree t' = mset_tree t - {#x#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>del_left t = (x, t'); t \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> x \\<in># mset_tree t \\<and>\n                      mset_tree t' = mset_tree t - {#x#}", "by (simp add: del_left_mset_plus)"], ["", "lemma del_left_set:\n  \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> set_tree t = {x} \\<union> set_tree t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>del_left t = (x, t'); t \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> set_tree t = {x} \\<union> set_tree t'", "by(simp add: del_left_mset_plus flip: set_mset_tree)"], ["", "lemma del_left_heap:\n  \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> heap t \\<Longrightarrow> heap t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>del_left t = (x, t'); t \\<noteq> \\<langle>\\<rangle>;\n     heap t\\<rbrakk>\n    \\<Longrightarrow> heap t'", "by (induction t arbitrary: x t' rule: del_left.induct;\n    fastforce split: prod.splits dest: del_left_set[THEN equalityD2])"], ["", "lemma del_left_size:\n  \"del_left t = (x,t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> size t = size t' + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>del_left t = (x, t'); t \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> size t = size t' + 1", "by(induction t arbitrary: x t' rule: del_left.induct;\n    auto split: prod.splits)"], ["", "lemma del_left_braun:\n  \"del_left t = (x,t') \\<Longrightarrow> braun t \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> braun t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>del_left t = (x, t'); braun t;\n     t \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> braun t'", "by(induction t arbitrary: x t' rule: del_left.induct;\n    auto split: prod.splits dest: del_left_size)"], ["", "context includes pattern_aliases\nbegin"], ["", "text \\<open>Slightly simpler definition: \\<open>_\\<close> instead of @{const Leaf} because of Braun invariant.\\<close>"], ["", "function (sequential) sift_down :: \"'a::linorder tree \\<Rightarrow> 'a \\<Rightarrow> 'a tree \\<Rightarrow> 'a tree\" where\n\"sift_down Leaf a _ = Node Leaf a Leaf\" |\n\"sift_down (Node Leaf x _) a Leaf =\n  (if a \\<le> x then Node (Node Leaf x Leaf) a Leaf\n   else Node (Node Leaf a Leaf) x Leaf)\" |\n\"sift_down (Node l1 x1 r1 =: t1) a (Node l2 x2 r2 =: t2) =\n  (if a \\<le> x1 \\<and> a \\<le> x2\n   then Node t1 a t2\n   else if x1 \\<le> x2 then Node (sift_down l1 a r1) x1 t2\n        else Node t1 x2 (sift_down l2 a r2))\""], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>a uu_.\n                   x = (\\<langle>\\<rangle>, a, uu_) \\<Longrightarrow> P;\n        \\<And>xa uv_ a.\n           x =\n           (\\<langle>\\<langle>\\<rangle>, xa, uv_\\<rangle>, a,\n            \\<langle>\\<rangle>) \\<Longrightarrow>\n           P;\n        \\<And>l1 x1 r1 a l2 x2 r2.\n           x =\n           (\\<langle>l1, x1, r1\\<rangle>, a,\n            \\<langle>l2, x2, r2\\<rangle>) \\<Longrightarrow>\n           P;\n        \\<And>vc vd ve va vb b.\n           x =\n           (\\<langle>\\<langle>vc, vd, ve\\<rangle>, va, vb\\<rangle>, b,\n            \\<langle>\\<rangle>) \\<Longrightarrow>\n           P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>a uu_ aa uua_.\n       (\\<langle>\\<rangle>, a, uu_) =\n       (\\<langle>\\<rangle>, aa, uua_) \\<Longrightarrow>\n       \\<langle>\\<langle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle> =\n       \\<langle>\\<langle>\\<rangle>, aa, \\<langle>\\<rangle>\\<rangle>\n 3. \\<And>a uu_ x uv_ aa.\n       (\\<langle>\\<rangle>, a, uu_) =\n       (\\<langle>\\<langle>\\<rangle>, x, uv_\\<rangle>, aa,\n        \\<langle>\\<rangle>) \\<Longrightarrow>\n       \\<langle>\\<langle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle> =\n       (if aa \\<le> x\n        then \\<langle>\\<langle>\\<langle>\\<rangle>, x,\n                       \\<langle>\\<rangle>\\<rangle>,\n              aa, \\<langle>\\<rangle>\\<rangle>\n        else \\<langle>\\<langle>\\<langle>\\<rangle>, aa,\n                       \\<langle>\\<rangle>\\<rangle>,\n              x, \\<langle>\\<rangle>\\<rangle>)\n 4. \\<And>a uu_ l1 x1 r1 aa l2 x2 r2.\n       (\\<langle>\\<rangle>, a, uu_) =\n       (\\<langle>l1, x1, r1\\<rangle>, aa,\n        \\<langle>l2, x2, r2\\<rangle>) \\<Longrightarrow>\n       \\<langle>\\<langle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle> =\n       (let t2 = \\<langle>l2, x2, r2\\<rangle>;\n            t1 = \\<langle>l1, x1, r1\\<rangle>\n        in if aa \\<le> x1 \\<and> aa \\<le> x2\n           then \\<langle>t1, aa, t2\\<rangle>\n           else if x1 \\<le> x2\n                then \\<langle>sift_down_sumC (l1, aa, r1), x1, t2\\<rangle>\n                else \\<langle>t1, x2, sift_down_sumC (l2, aa, r2)\\<rangle>)\n 5. \\<And>a uu_ vc vd ve va vb b.\n       (\\<langle>\\<rangle>, a, uu_) =\n       (\\<langle>\\<langle>vc, vd, ve\\<rangle>, va, vb\\<rangle>, b,\n        \\<langle>\\<rangle>) \\<Longrightarrow>\n       \\<langle>\\<langle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle> =\n       undefined\n 6. \\<And>x uv_ a xa uva_ aa.\n       (\\<langle>\\<langle>\\<rangle>, x, uv_\\<rangle>, a,\n        \\<langle>\\<rangle>) =\n       (\\<langle>\\<langle>\\<rangle>, xa, uva_\\<rangle>, aa,\n        \\<langle>\\<rangle>) \\<Longrightarrow>\n       (if a \\<le> x\n        then \\<langle>\\<langle>\\<langle>\\<rangle>, x,\n                       \\<langle>\\<rangle>\\<rangle>,\n              a, \\<langle>\\<rangle>\\<rangle>\n        else \\<langle>\\<langle>\\<langle>\\<rangle>, a,\n                       \\<langle>\\<rangle>\\<rangle>,\n              x, \\<langle>\\<rangle>\\<rangle>) =\n       (if aa \\<le> xa\n        then \\<langle>\\<langle>\\<langle>\\<rangle>, xa,\n                       \\<langle>\\<rangle>\\<rangle>,\n              aa, \\<langle>\\<rangle>\\<rangle>\n        else \\<langle>\\<langle>\\<langle>\\<rangle>, aa,\n                       \\<langle>\\<rangle>\\<rangle>,\n              xa, \\<langle>\\<rangle>\\<rangle>)\n 7. \\<And>x uv_ a l1 x1 r1 aa l2 x2 r2.\n       (\\<langle>\\<langle>\\<rangle>, x, uv_\\<rangle>, a,\n        \\<langle>\\<rangle>) =\n       (\\<langle>l1, x1, r1\\<rangle>, aa,\n        \\<langle>l2, x2, r2\\<rangle>) \\<Longrightarrow>\n       (if a \\<le> x\n        then \\<langle>\\<langle>\\<langle>\\<rangle>, x,\n                       \\<langle>\\<rangle>\\<rangle>,\n              a, \\<langle>\\<rangle>\\<rangle>\n        else \\<langle>\\<langle>\\<langle>\\<rangle>, a,\n                       \\<langle>\\<rangle>\\<rangle>,\n              x, \\<langle>\\<rangle>\\<rangle>) =\n       (let t2 = \\<langle>l2, x2, r2\\<rangle>;\n            t1 = \\<langle>l1, x1, r1\\<rangle>\n        in if aa \\<le> x1 \\<and> aa \\<le> x2\n           then \\<langle>t1, aa, t2\\<rangle>\n           else if x1 \\<le> x2\n                then \\<langle>sift_down_sumC (l1, aa, r1), x1, t2\\<rangle>\n                else \\<langle>t1, x2, sift_down_sumC (l2, aa, r2)\\<rangle>)\n 8. \\<And>x uv_ a vc vd ve va vb b.\n       (\\<langle>\\<langle>\\<rangle>, x, uv_\\<rangle>, a,\n        \\<langle>\\<rangle>) =\n       (\\<langle>\\<langle>vc, vd, ve\\<rangle>, va, vb\\<rangle>, b,\n        \\<langle>\\<rangle>) \\<Longrightarrow>\n       (if a \\<le> x\n        then \\<langle>\\<langle>\\<langle>\\<rangle>, x,\n                       \\<langle>\\<rangle>\\<rangle>,\n              a, \\<langle>\\<rangle>\\<rangle>\n        else \\<langle>\\<langle>\\<langle>\\<rangle>, a,\n                       \\<langle>\\<rangle>\\<rangle>,\n              x, \\<langle>\\<rangle>\\<rangle>) =\n       undefined\n 9. \\<And>l1 x1 r1 a l2 x2 r2 l1a x1a r1a aa l2a x2a r2a.\n       (\\<langle>l1, x1, r1\\<rangle>, a, \\<langle>l2, x2, r2\\<rangle>) =\n       (\\<langle>l1a, x1a, r1a\\<rangle>, aa,\n        \\<langle>l2a, x2a, r2a\\<rangle>) \\<Longrightarrow>\n       (let t2 = \\<langle>l2, x2, r2\\<rangle>;\n            t1 = \\<langle>l1, x1, r1\\<rangle>\n        in if a \\<le> x1 \\<and> a \\<le> x2 then \\<langle>t1, a, t2\\<rangle>\n           else if x1 \\<le> x2\n                then \\<langle>sift_down_sumC (l1, a, r1), x1, t2\\<rangle>\n                else \\<langle>t1, x2, sift_down_sumC (l2, a, r2)\\<rangle>) =\n       (let t2 = \\<langle>l2a, x2a, r2a\\<rangle>;\n            t1 = \\<langle>l1a, x1a, r1a\\<rangle>\n        in if aa \\<le> x1a \\<and> aa \\<le> x2a\n           then \\<langle>t1, aa, t2\\<rangle>\n           else if x1a \\<le> x2a\n                then \\<langle>sift_down_sumC (l1a, aa, r1a), x1a,\n                      t2\\<rangle>\n                else \\<langle>t1, x2a,\n                      sift_down_sumC (l2a, aa, r2a)\\<rangle>)\n 10. \\<And>l1 x1 r1 a l2 x2 r2 vc vd ve va vb b.\n        (\\<langle>l1, x1, r1\\<rangle>, a, \\<langle>l2, x2, r2\\<rangle>) =\n        (\\<langle>\\<langle>vc, vd, ve\\<rangle>, va, vb\\<rangle>, b,\n         \\<langle>\\<rangle>) \\<Longrightarrow>\n        (let t2 = \\<langle>l2, x2, r2\\<rangle>;\n             t1 = \\<langle>l1, x1, r1\\<rangle>\n         in if a \\<le> x1 \\<and> a \\<le> x2 then \\<langle>t1, a, t2\\<rangle>\n            else if x1 \\<le> x2\n                 then \\<langle>sift_down_sumC (l1, a, r1), x1, t2\\<rangle>\n                 else \\<langle>t1, x2,\n                       sift_down_sumC (l2, a, r2)\\<rangle>) =\n        undefined\nA total of 11 subgoals...", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All sift_down_dom", "by (relation \"measure (%(l,a,r). size l + size r)\") auto"], ["", "end"], ["", "lemma size_sift_down:\n  \"braun(Node l a r) \\<Longrightarrow> size(sift_down l a r) = size l + size r + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>l, a, r\\<rangle> \\<Longrightarrow>\n    size (sift_down l a r) = size l + size r + 1", "by(induction l a r rule: sift_down.induct) (auto simp: Let_def)"], ["", "lemma braun_sift_down:\n  \"braun(Node l a r) \\<Longrightarrow> braun(sift_down l a r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>l, a, r\\<rangle> \\<Longrightarrow>\n    braun (sift_down l a r)", "by(induction l a r rule: sift_down.induct) (auto simp: size_sift_down Let_def)"], ["", "lemma mset_sift_down:\n  \"braun(Node l a r) \\<Longrightarrow> mset_tree(sift_down l a r) = {#a#} + (mset_tree l + mset_tree r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>l, a, r\\<rangle> \\<Longrightarrow>\n    mset_tree (sift_down l a r) = {#a#} + (mset_tree l + mset_tree r)", "by(induction l a r rule: sift_down.induct) (auto simp: ac_simps Let_def)"], ["", "lemma set_sift_down: \"braun(Node l a r)\n  \\<Longrightarrow> set_tree(sift_down l a r) = {a} \\<union> (set_tree l \\<union> set_tree r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>l, a, r\\<rangle> \\<Longrightarrow>\n    set_tree (sift_down l a r) =\n    {a} \\<union> (set_tree l \\<union> set_tree r)", "by(drule arg_cong[where f=set_mset, OF mset_sift_down]) (simp)"], ["", "lemma heap_sift_down:\n  \"braun(Node l a r) \\<Longrightarrow> heap l \\<Longrightarrow> heap r \\<Longrightarrow> heap(sift_down l a r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>braun \\<langle>l, a, r\\<rangle>; heap l; heap r\\<rbrakk>\n    \\<Longrightarrow> heap (sift_down l a r)", "by (induction l a r rule: sift_down.induct) (auto simp: set_sift_down ball_Un Let_def)"], ["", "fun del_min :: \"'a::linorder tree \\<Rightarrow> 'a tree\" where\n\"del_min Leaf = Leaf\" |\n\"del_min (Node Leaf x r) = Leaf\" |\n\"del_min (Node l x r) = (let (y,l') = del_left l in sift_down r y l')\""], ["", "lemma braun_del_min: \"braun t \\<Longrightarrow> braun(del_min t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun t \\<Longrightarrow> braun (del_min t)", "apply(cases t rule: del_min.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>braun t; t = \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> braun (del_min t)\n 2. \\<And>x r.\n       \\<lbrakk>braun t;\n        t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> braun (del_min t)\n 3. \\<And>v va vb x r.\n       \\<lbrakk>braun t;\n        t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> braun (del_min t)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x r.\n       \\<lbrakk>braun t;\n        t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> braun (del_min t)\n 2. \\<And>v va vb x r.\n       \\<lbrakk>braun t;\n        t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> braun (del_min t)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r.\n       \\<lbrakk>braun t;\n        t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> braun (del_min t)", "apply (fastforce split: prod.split intro!: braun_sift_down\n  dest: del_left_size del_left_braun)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma heap_del_min: \"heap t \\<Longrightarrow> braun t \\<Longrightarrow> heap(del_min t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap t; braun t\\<rbrakk> \\<Longrightarrow> heap (del_min t)", "apply(cases t rule: del_min.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>heap t; braun t; t = \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> heap (del_min t)\n 2. \\<And>x r.\n       \\<lbrakk>heap t; braun t;\n        t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap (del_min t)\n 3. \\<And>v va vb x r.\n       \\<lbrakk>heap t; braun t;\n        t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap (del_min t)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x r.\n       \\<lbrakk>heap t; braun t;\n        t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap (del_min t)\n 2. \\<And>v va vb x r.\n       \\<lbrakk>heap t; braun t;\n        t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap (del_min t)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r.\n       \\<lbrakk>heap t; braun t;\n        t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap (del_min t)", "apply (fastforce split: prod.split intro!: heap_sift_down\n  dest: del_left_size del_left_braun del_left_heap)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma size_del_min: assumes \"braun t\" shows \"size(del_min t) = size t - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (del_min t) = size t - 1", "proof(cases t rule: del_min.cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. t = \\<langle>\\<rangle> \\<Longrightarrow> size (del_min t) = size t - 1\n 2. \\<And>x r.\n       t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       size (del_min t) = size t - 1\n 3. \\<And>v va vb x r.\n       t =\n       \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       size (del_min t) = size t - 1", "case [simp]: (3 ll b lr a r)"], ["proof (state)\nthis:\n  t = \\<langle>\\<langle>ll, b, lr\\<rangle>, a, r\\<rangle>\n\ngoal (3 subgoals):\n 1. t = \\<langle>\\<rangle> \\<Longrightarrow> size (del_min t) = size t - 1\n 2. \\<And>x r.\n       t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       size (del_min t) = size t - 1\n 3. \\<And>v va vb x r.\n       t =\n       \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       size (del_min t) = size t - 1", "{"], ["proof (state)\nthis:\n  t = \\<langle>\\<langle>ll, b, lr\\<rangle>, a, r\\<rangle>\n\ngoal (3 subgoals):\n 1. t = \\<langle>\\<rangle> \\<Longrightarrow> size (del_min t) = size t - 1\n 2. \\<And>x r.\n       t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       size (del_min t) = size t - 1\n 3. \\<And>v va vb x r.\n       t =\n       \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       size (del_min t) = size t - 1", "fix y l'"], ["proof (state)\ngoal (3 subgoals):\n 1. t = \\<langle>\\<rangle> \\<Longrightarrow> size (del_min t) = size t - 1\n 2. \\<And>x r.\n       t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       size (del_min t) = size t - 1\n 3. \\<And>v va vb x r.\n       t =\n       \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       size (del_min t) = size t - 1", "assume \"del_left (Node ll b lr) = (y,l')\""], ["proof (state)\nthis:\n  del_left \\<langle>ll, b, lr\\<rangle> = (y, l')\n\ngoal (3 subgoals):\n 1. t = \\<langle>\\<rangle> \\<Longrightarrow> size (del_min t) = size t - 1\n 2. \\<And>x r.\n       t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       size (del_min t) = size t - 1\n 3. \\<And>v va vb x r.\n       t =\n       \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       size (del_min t) = size t - 1", "hence \"size(sift_down r y l') = size t - 1\""], ["proof (prove)\nusing this:\n  del_left \\<langle>ll, b, lr\\<rangle> = (y, l')\n\ngoal (1 subgoal):\n 1. size (sift_down r y l') = size t - 1", "using assms"], ["proof (prove)\nusing this:\n  del_left \\<langle>ll, b, lr\\<rangle> = (y, l')\n  braun t\n\ngoal (1 subgoal):\n 1. size (sift_down r y l') = size t - 1", "by(subst size_sift_down) (auto dest: del_left_size del_left_braun)"], ["proof (state)\nthis:\n  size (sift_down r y l') = size t - 1\n\ngoal (3 subgoals):\n 1. t = \\<langle>\\<rangle> \\<Longrightarrow> size (del_min t) = size t - 1\n 2. \\<And>x r.\n       t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       size (del_min t) = size t - 1\n 3. \\<And>v va vb x r.\n       t =\n       \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       size (del_min t) = size t - 1", "}"], ["proof (state)\nthis:\n  del_left \\<langle>ll, b, lr\\<rangle> = (?y2, ?l'2) \\<Longrightarrow>\n  size (sift_down r ?y2 ?l'2) = size t - 1\n\ngoal (3 subgoals):\n 1. t = \\<langle>\\<rangle> \\<Longrightarrow> size (del_min t) = size t - 1\n 2. \\<And>x r.\n       t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       size (del_min t) = size t - 1\n 3. \\<And>v va vb x r.\n       t =\n       \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       size (del_min t) = size t - 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  del_left \\<langle>ll, b, lr\\<rangle> = (?y2, ?l'2) \\<Longrightarrow>\n  size (sift_down r ?y2 ?l'2) = size t - 1\n\ngoal (1 subgoal):\n 1. size (del_min t) = size t - 1", "by(auto split: prod.split)"], ["proof (state)\nthis:\n  size (del_min t) = size t - 1\n\ngoal (2 subgoals):\n 1. t = \\<langle>\\<rangle> \\<Longrightarrow> size (del_min t) = size t - 1\n 2. \\<And>x r.\n       t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       size (del_min t) = size t - 1", "qed (insert assms, auto)"], ["", "lemma mset_del_min: assumes \"braun t\" \"t \\<noteq> Leaf\"\nshows \"mset_tree(del_min t) = mset_tree t - {#get_min t#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_tree (del_min t) = mset_tree t - {#get_min t#}", "proof(cases t rule: del_min.cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. t = \\<langle>\\<rangle> \\<Longrightarrow>\n    mset_tree (del_min t) = mset_tree t - {#get_min t#}\n 2. \\<And>x r.\n       t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}\n 3. \\<And>v va vb x r.\n       t =\n       \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}", "case 1"], ["proof (state)\nthis:\n  t = \\<langle>\\<rangle>\n\ngoal (3 subgoals):\n 1. t = \\<langle>\\<rangle> \\<Longrightarrow>\n    mset_tree (del_min t) = mset_tree t - {#get_min t#}\n 2. \\<And>x r.\n       t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}\n 3. \\<And>v va vb x r.\n       t =\n       \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}", "with assms"], ["proof (chain)\npicking this:\n  braun t\n  t \\<noteq> \\<langle>\\<rangle>\n  t = \\<langle>\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  braun t\n  t \\<noteq> \\<langle>\\<rangle>\n  t = \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. mset_tree (del_min t) = mset_tree t - {#get_min t#}", "by simp"], ["proof (state)\nthis:\n  mset_tree (del_min t) = mset_tree t - {#get_min t#}\n\ngoal (2 subgoals):\n 1. \\<And>x r.\n       t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}\n 2. \\<And>v va vb x r.\n       t =\n       \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x r.\n       t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}\n 2. \\<And>v va vb x r.\n       t =\n       \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}", "case 2"], ["proof (state)\nthis:\n  t = \\<langle>\\<langle>\\<rangle>, x_, r_\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>x r.\n       t = \\<langle>\\<langle>\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}\n 2. \\<And>v va vb x r.\n       t =\n       \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}", "with assms"], ["proof (chain)\npicking this:\n  braun t\n  t \\<noteq> \\<langle>\\<rangle>\n  t = \\<langle>\\<langle>\\<rangle>, x_, r_\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  braun t\n  t \\<noteq> \\<langle>\\<rangle>\n  t = \\<langle>\\<langle>\\<rangle>, x_, r_\\<rangle>\n\ngoal (1 subgoal):\n 1. mset_tree (del_min t) = mset_tree t - {#get_min t#}", "by (simp)"], ["proof (state)\nthis:\n  mset_tree (del_min t) = mset_tree t - {#get_min t#}\n\ngoal (1 subgoal):\n 1. \\<And>v va vb x r.\n       t =\n       \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r.\n       t =\n       \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}", "case [simp]: (3 ll b lr a r)"], ["proof (state)\nthis:\n  t = \\<langle>\\<langle>ll, b, lr\\<rangle>, a, r\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>v va vb x r.\n       t =\n       \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}", "have \"mset_tree(sift_down r y l') = mset_tree t - {#a#}\"\n    if del: \"del_left (Node ll b lr) = (y,l')\" for y l'"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_tree (sift_down r y l') = mset_tree t - {#a#}", "using assms del_left_mset[OF del] del_left_size[OF del]\n      del_left_braun[OF del] del_left_mset_plus[OF del]"], ["proof (prove)\nusing this:\n  braun t\n  t \\<noteq> \\<langle>\\<rangle>\n  \\<langle>ll, b, lr\\<rangle> \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n  y \\<in># mset_tree \\<langle>ll, b, lr\\<rangle> \\<and>\n  mset_tree l' = mset_tree \\<langle>ll, b, lr\\<rangle> - {#y#}\n  \\<langle>ll, b, lr\\<rangle> \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n  size \\<langle>ll, b, lr\\<rangle> = size l' + 1\n  \\<lbrakk>braun \\<langle>ll, b, lr\\<rangle>;\n   \\<langle>ll, b, lr\\<rangle> \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> braun l'\n  \\<langle>ll, b, lr\\<rangle> \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n  mset_tree \\<langle>ll, b, lr\\<rangle> = {#y#} + mset_tree l'\n\ngoal (1 subgoal):\n 1. mset_tree (sift_down r y l') = mset_tree t - {#a#}", "apply (subst mset_sift_down)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>braun t; t \\<noteq> \\<langle>\\<rangle>;\n     \\<langle>ll, b, lr\\<rangle> \\<noteq>\n     \\<langle>\\<rangle> \\<Longrightarrow>\n     y \\<in># mset_tree \\<langle>ll, b, lr\\<rangle> \\<and>\n     mset_tree l' = mset_tree \\<langle>ll, b, lr\\<rangle> - {#y#};\n     \\<langle>ll, b, lr\\<rangle> \\<noteq>\n     \\<langle>\\<rangle> \\<Longrightarrow>\n     size \\<langle>ll, b, lr\\<rangle> = size l' + 1;\n     \\<lbrakk>braun \\<langle>ll, b, lr\\<rangle>;\n      \\<langle>ll, b, lr\\<rangle> \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n     \\<Longrightarrow> braun l';\n     \\<langle>ll, b, lr\\<rangle> \\<noteq>\n     \\<langle>\\<rangle> \\<Longrightarrow>\n     mset_tree \\<langle>ll, b, lr\\<rangle> = {#y#} + mset_tree l'\\<rbrakk>\n    \\<Longrightarrow> braun \\<langle>r, y, l'\\<rangle>\n 2. \\<lbrakk>braun t; t \\<noteq> \\<langle>\\<rangle>;\n     \\<langle>ll, b, lr\\<rangle> \\<noteq>\n     \\<langle>\\<rangle> \\<Longrightarrow>\n     y \\<in># mset_tree \\<langle>ll, b, lr\\<rangle> \\<and>\n     mset_tree l' = mset_tree \\<langle>ll, b, lr\\<rangle> - {#y#};\n     \\<langle>ll, b, lr\\<rangle> \\<noteq>\n     \\<langle>\\<rangle> \\<Longrightarrow>\n     size \\<langle>ll, b, lr\\<rangle> = size l' + 1;\n     \\<lbrakk>braun \\<langle>ll, b, lr\\<rangle>;\n      \\<langle>ll, b, lr\\<rangle> \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n     \\<Longrightarrow> braun l';\n     \\<langle>ll, b, lr\\<rangle> \\<noteq>\n     \\<langle>\\<rangle> \\<Longrightarrow>\n     mset_tree \\<langle>ll, b, lr\\<rangle> = {#y#} + mset_tree l'\\<rbrakk>\n    \\<Longrightarrow> {#y#} + (mset_tree r + mset_tree l') =\n                      mset_tree t - {#a#}", "apply (auto simp: ac_simps del_left_mset_plus[OF del])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  del_left \\<langle>ll, b, lr\\<rangle> = (?y, ?l') \\<Longrightarrow>\n  mset_tree (sift_down r ?y ?l') = mset_tree t - {#a#}\n\ngoal (1 subgoal):\n 1. \\<And>v va vb x r.\n       t =\n       \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle> \\<Longrightarrow>\n       mset_tree (del_min t) = mset_tree t - {#get_min t#}", "thus ?thesis"], ["proof (prove)\nusing this:\n  del_left \\<langle>ll, b, lr\\<rangle> = (?y, ?l') \\<Longrightarrow>\n  mset_tree (sift_down r ?y ?l') = mset_tree t - {#a#}\n\ngoal (1 subgoal):\n 1. mset_tree (del_min t) = mset_tree t - {#get_min t#}", "by(auto split: prod.split)"], ["proof (state)\nthis:\n  mset_tree (del_min t) = mset_tree t - {#get_min t#}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Last step: prove all axioms of the priority queue specification:\\<close>"], ["", "interpretation braun: Priority_Queue\nwhere empty = Leaf and is_empty = \"\\<lambda>h. h = Leaf\"\nand insert = insert and del_min = del_min\nand get_min = get_min and invar = \"\\<lambda>h. braun h \\<and> heap h\"\nand mset = mset_tree"], ["proof (prove)\ngoal (1 subgoal):\n 1. Priority_Queue \\<langle>\\<rangle> (\\<lambda>h. h = \\<langle>\\<rangle>)\n     insert get_min del_min (\\<lambda>h. braun h \\<and> heap h) mset_tree", "proof(standard, goal_cases)"], ["proof (state)\ngoal (8 subgoals):\n 1. mset_tree \\<langle>\\<rangle> = {#}\n 2. \\<And>q.\n       braun q \\<and> heap q \\<Longrightarrow>\n       (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n 3. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 5. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 6. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 7. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 8. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (8 subgoals):\n 1. mset_tree \\<langle>\\<rangle> = {#}\n 2. \\<And>q.\n       braun q \\<and> heap q \\<Longrightarrow>\n       (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n 3. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 5. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 6. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 7. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 8. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_tree \\<langle>\\<rangle> = {#}", "by simp"], ["proof (state)\nthis:\n  mset_tree \\<langle>\\<rangle> = {#}\n\ngoal (7 subgoals):\n 1. \\<And>q.\n       braun q \\<and> heap q \\<Longrightarrow>\n       (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n 2. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 5. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 6. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 7. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>q.\n       braun q \\<and> heap q \\<Longrightarrow>\n       (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n 2. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 5. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 6. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 7. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "case 2"], ["proof (state)\nthis:\n  braun q_ \\<and> heap q_\n\ngoal (7 subgoals):\n 1. \\<And>q.\n       braun q \\<and> heap q \\<Longrightarrow>\n       (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n 2. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 5. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 6. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 7. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (q_ = \\<langle>\\<rangle>) = (mset_tree q_ = {#})", "by simp"], ["proof (state)\nthis:\n  (q_ = \\<langle>\\<rangle>) = (mset_tree q_ = {#})\n\ngoal (6 subgoals):\n 1. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 4. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 5. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 6. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 4. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 5. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 6. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "case 3"], ["proof (state)\nthis:\n  braun q_ \\<and> heap q_\n\ngoal (6 subgoals):\n 1. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 4. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 5. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 6. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_tree (insert x_ q_) = mset_tree q_ + {#x_#}", "by(simp add: mset_insert)"], ["proof (state)\nthis:\n  mset_tree (insert x_ q_) = mset_tree q_ + {#x_#}\n\ngoal (5 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 3. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 4. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 5. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 3. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 4. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 5. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "case 4"], ["proof (state)\nthis:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (5 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min q) = mset_tree q - {#get_min q#}\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 3. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 4. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 5. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "thus ?case"], ["proof (prove)\nusing this:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. mset_tree (del_min q_) = mset_tree q_ - {#get_min q_#}", "by(simp add: mset_del_min)"], ["proof (state)\nthis:\n  mset_tree (del_min q_) = mset_tree q_ - {#get_min q_#}\n\ngoal (4 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 2. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 3. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 2. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 3. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "case 5"], ["proof (state)\nthis:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (4 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 2. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 3. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "thus ?case"], ["proof (prove)\nusing this:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. get_min q_ = Min_mset (mset_tree q_)", "using get_min mset_tree.simps(1)"], ["proof (prove)\nusing this:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n  \\<lbrakk>heap ?t; ?t \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> get_min ?t = Min_mset (mset_tree ?t)\n  mset_tree \\<langle>\\<rangle> = {#}\n\ngoal (1 subgoal):\n 1. get_min q_ = Min_mset (mset_tree q_)", "by blast"], ["proof (state)\nthis:\n  get_min q_ = Min_mset (mset_tree q_)\n\ngoal (3 subgoals):\n 1. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 2. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 2. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "case 6"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 2. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>", "by(simp)"], ["proof (state)\nthis:\n  braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "case 7"], ["proof (state)\nthis:\n  braun q_ \\<and> heap q_\n\ngoal (2 subgoals):\n 1. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "thus ?case"], ["proof (prove)\nusing this:\n  braun q_ \\<and> heap q_\n\ngoal (1 subgoal):\n 1. braun (insert x_ q_) \\<and> heap (insert x_ q_)", "by(simp add: heap_insert braun_insert)"], ["proof (state)\nthis:\n  braun (insert x_ q_) \\<and> heap (insert x_ q_)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "case 8"], ["proof (state)\nthis:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min q) \\<and> heap (del_min q)", "thus ?case"], ["proof (prove)\nusing this:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. braun (del_min q_) \\<and> heap (del_min q_)", "by(simp add: heap_del_min braun_del_min)"], ["proof (state)\nthis:\n  braun (del_min q_) \\<and> heap (del_min q_)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}