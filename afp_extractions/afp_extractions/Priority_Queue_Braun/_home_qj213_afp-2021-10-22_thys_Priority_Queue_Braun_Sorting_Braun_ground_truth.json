{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Sorting_Braun.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun", "problem_names": ["lemma heap_heap_of_A: \"heap (heap_of_A xs)\"", "lemma braun_heap_of_A: \"braun (heap_of_A xs)\"", "lemma mset_tree_heap_of_A: \"mset_tree (heap_of_A xs) = mset xs\"", "lemma t_insert_height:\n  \"t_insert x t \\<le> height t + 1\"", "lemma height_insert_ge:\n  \"height t \\<le> height (insert x t)\"", "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\"", "lemma size_heap_of_A:\n  \"size (heap_of_A xs) = length xs\"", "lemma t_heap_of_A_log_bound:\n  \"t_heap_of_A xs \\<le> length xs * (nlog2 (length xs + 1) + 1)\"", "lemma heapify_snd:\n  \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\"", "lemma heapify_snd_tup:\n  \"heapify n xs = (t, ys) \\<Longrightarrow> n \\<le> length xs \\<Longrightarrow> ys = drop n xs\"", "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\"", "lemma braun_heapify:\n  \"n \\<le> length xs \\<Longrightarrow> braun (fst (heapify n xs))\"", "lemma heap_heapify:\n  \"n \\<le> length xs \\<Longrightarrow> heap (fst (heapify n xs))\"", "lemma mset_heapify:\n  \"n \\<le> length xs \\<Longrightarrow> mset_tree (fst (heapify n xs)) = mset (take n xs)\"", "lemma t_sift_down_height:\n  \"braun (Node l x r) \\<Longrightarrow> t_sift_down l x r \\<le> height (Node l x r)\"", "lemma sift_down_height:\n  \"braun (Node l x r) \\<Longrightarrow> height (sift_down l x r) \\<le> height (Node l x r)\"", "lemma braun_height_r_le:\n  \"braun (Node l x r) \\<Longrightarrow> height r \\<le> height l\"", "lemma braun_height_l_le:\n  assumes b: \"braun (Node l x r)\"\n  shows \"height l \\<le> Suc (height r)\"", "lemma braun_height_node_eq:\n  assumes b: \"braun (Node l x r)\"\n  shows \"height (Node l x r) = Suc (height l)\"", "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\"", "lemma t_heapify_bound:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs \\<le> 5 * i + 1\"", "lemma size_prod_measure[measure_function]:\n  \"is_measure f \\<Longrightarrow> is_measure g \\<Longrightarrow> is_measure (size_prod f g)\"", "lemma merge_size[termination_simp]:\n  \"size (merge l r) = size l + size r\"", "lemma set_tree_merge[simp]:\n  \"set_tree (merge l r) = set_tree l \\<union> set_tree r\"", "lemma mset_tree_merge[simp]:\n  \"mset_tree (merge l r) = mset_tree l + mset_tree r\"", "lemma merge_heap:\n  \"heap l \\<Longrightarrow> heap r \\<Longrightarrow> heap (merge l r)\"", "lemma set_list_of_A[simp]:\n  \"set (list_of_A t) = set_tree t\"", "lemma mset_list_of_A[simp]:\n  \"mset (list_of_A t) = mset_tree t\"", "lemma sorted_list_of_A:\n  \"heap t \\<Longrightarrow> sorted (list_of_A t)\"", "lemma sortedA: \"sorted (list_of_A (heap_of_A xs))\"", "lemma msetA: \"mset (list_of_A (heap_of_A xs)) = mset xs\"", "lemma merge_height:\n  \"height (merge l r) \\<le>  Suc (max (height l) (height r))\"", "lemma t_merge_height:\n  \"t_merge l r \\<le> max (height l) (height r)\"", "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\"", "lemma t_list_of_A_bound:\n  \"t_list_of_A t \\<le> 2 * height t * size t\"", "lemma t_list_of_A_log_bound:\n  \"braun t \\<Longrightarrow> t_list_of_A t \\<le> 2 * nlog2 (size t + 1) * size t\"", "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")", "lemma list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> list_of_B_dom t\"", "lemmas list_of_B_braun_simps\n    = list_of_B.psimps[OF list_of_B_braun_ptermination]", "lemma mset_list_of_B:\n  \"braun t \\<Longrightarrow> mset (list_of_B t) = mset_tree t\"", "lemma set_list_of_B:\n  \"braun t \\<Longrightarrow> set (list_of_B t) = set_tree t\"", "lemma sorted_list_of_B:\n  \"braun t \\<Longrightarrow> heap t \\<Longrightarrow> sorted (list_of_B t)\"", "lemma sortedB: \"sorted (list_of_B (heap_of_B xs))\"", "lemma msetB: \"mset (list_of_B (heap_of_B xs)) = mset xs\"", "lemma t_del_left_bound:\n  \"t \\<noteq> Leaf \\<Longrightarrow> t_del_left t \\<le> 2 * height t\"", "lemma del_left_height:\n  \"del_left t = (v, t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> height t' \\<le> height t\"", "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\"", "lemma t_list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> t_list_of_B_dom t\"", "lemmas t_list_of_B_braun_simps\n    = t_list_of_B.psimps[OF t_list_of_B_braun_ptermination]", "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\"", "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\"", "lemma t_list_of_B_bound:\n  \"braun t \\<Longrightarrow> t_list_of_B t \\<le> 3 * (height t + 1) * size t\"", "lemma t_list_of_B_log_bound:\n  \"braun t \\<Longrightarrow> t_list_of_B t \\<le> 3 * (nlog2 (size t + 1) + 1) * size t\"", "lemma t_heap_of_B_bound:\n  \"t_heap_of_B xs \\<le> 6 * length xs + 1\"", "lemmas size_heapify = arg_cong[OF mset_heapify, where f=size, simplified]", "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")"], "translations": [["", "lemma heap_heap_of_A: \"heap (heap_of_A xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap (heap_of_A xs)", "by(induction xs)(simp_all add: heap_insert)"], ["", "lemma braun_heap_of_A: \"braun (heap_of_A xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun (heap_of_A xs)", "by(induction xs)(simp_all add: braun_insert)"], ["", "lemma mset_tree_heap_of_A: \"mset_tree (heap_of_A xs) = mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_tree (heap_of_A xs) = mset xs", "by(induction xs)(simp_all add: mset_insert)"], ["", "text \\<open>Running time is n*log n, which we can approximate with height.\\<close>"], ["", "fun t_insert :: \"'a::linorder \\<Rightarrow> 'a tree \\<Rightarrow> nat\" where\n\"t_insert a Leaf = 1\" |\n\"t_insert a (Node l x r) =\n (if a < x then 1 + t_insert x r else 1 + t_insert a r)\""], ["", "fun t_heap_of_A :: \"('a::linorder) list \\<Rightarrow> nat\" where\n\"t_heap_of_A [] = 0\" |\n\"t_heap_of_A (a#as) = t_insert a (heap_of_A as) + t_heap_of_A as\""], ["", "lemma t_insert_height:\n  \"t_insert x t \\<le> height t + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_insert x t \\<le> height t + 1", "apply (induct t arbitrary: x; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t1 x2 t2 x.\n       \\<lbrakk>\\<And>x. t_insert x t1 \\<le> Suc (height t1);\n        \\<And>x. t_insert x t2 \\<le> Suc (height t2)\\<rbrakk>\n       \\<Longrightarrow> (x < x2 \\<longrightarrow>\n                          t_insert x2 t2\n                          \\<le> Suc (max (height t1) (height t2))) \\<and>\n                         (\\<not> x < x2 \\<longrightarrow>\n                          t_insert x t2\n                          \\<le> Suc (max (height t1) (height t2)))", "apply (simp only: max_Suc_Suc[symmetric] le_max_iff_disj, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma height_insert_ge:\n  \"height t \\<le> height (insert x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height t \\<le> height (insert x t)", "apply (induct t arbitrary: x; simp add: le_max_iff_disj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t1 x2 t2 x.\n       \\<lbrakk>\\<And>x. height t1 \\<le> height (insert x t1);\n        \\<And>x. height t2 \\<le> height (insert x t2)\\<rbrakk>\n       \\<Longrightarrow> (x < x2 \\<longrightarrow>\n                          height t1 \\<le> height (insert x2 t2) \\<or>\n                          height t2 \\<le> height t1) \\<and>\n                         (\\<not> x < x2 \\<longrightarrow>\n                          height t1 \\<le> height (insert x t2) \\<or>\n                          height t2 \\<le> height t1)", "apply (metis less_imp_le_nat less_le_trans not_le_imp_less)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma t_heap_of_A_bound:\n  \"t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1)\n 2. \\<And>a xs.\n       t_heap_of_A xs\n       \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow>\n       t_heap_of_A (a # xs)\n       \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "case (Cons x xs)"], ["proof (state)\nthis:\n  t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\n\ngoal (2 subgoals):\n 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1)\n 2. \\<And>a xs.\n       t_heap_of_A xs\n       \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow>\n       t_heap_of_A (a # xs)\n       \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "let ?lhs = \"t_insert x (heap_of_A xs) + t_heap_of_A xs\""], ["proof (state)\ngoal (2 subgoals):\n 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1)\n 2. \\<And>a xs.\n       t_heap_of_A xs\n       \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow>\n       t_heap_of_A (a # xs)\n       \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "have \"?lhs \\<le> ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_insert x (heap_of_A xs) + t_heap_of_A xs\n    \\<le> t_insert x (heap_of_A xs) + t_heap_of_A xs", "by simp"], ["proof (state)\nthis:\n  t_insert x (heap_of_A xs) + t_heap_of_A xs\n  \\<le> t_insert x (heap_of_A xs) + t_heap_of_A xs\n\ngoal (2 subgoals):\n 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1)\n 2. \\<And>a xs.\n       t_heap_of_A xs\n       \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow>\n       t_heap_of_A (a # xs)\n       \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "also"], ["proof (state)\nthis:\n  t_insert x (heap_of_A xs) + t_heap_of_A xs\n  \\<le> t_insert x (heap_of_A xs) + t_heap_of_A xs\n\ngoal (2 subgoals):\n 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1)\n 2. \\<And>a xs.\n       t_heap_of_A xs\n       \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow>\n       t_heap_of_A (a # xs)\n       \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "note Cons"], ["proof (state)\nthis:\n  t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\n\ngoal (2 subgoals):\n 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1)\n 2. \\<And>a xs.\n       t_heap_of_A xs\n       \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow>\n       t_heap_of_A (a # xs)\n       \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "also"], ["proof (state)\nthis:\n  t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\n\ngoal (2 subgoals):\n 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1)\n 2. \\<And>a xs.\n       t_heap_of_A xs\n       \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow>\n       t_heap_of_A (a # xs)\n       \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "note height_insert_ge[of \"heap_of_A xs\" x]"], ["proof (state)\nthis:\n  height (heap_of_A xs) \\<le> height (insert x (heap_of_A xs))\n\ngoal (2 subgoals):\n 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1)\n 2. \\<And>a xs.\n       t_heap_of_A xs\n       \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow>\n       t_heap_of_A (a # xs)\n       \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "also"], ["proof (state)\nthis:\n  height (heap_of_A xs) \\<le> height (insert x (heap_of_A xs))\n\ngoal (2 subgoals):\n 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1)\n 2. \\<And>a xs.\n       t_heap_of_A xs\n       \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow>\n       t_heap_of_A (a # xs)\n       \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "note t_insert_height[of x \"heap_of_A xs\"]"], ["proof (state)\nthis:\n  t_insert x (heap_of_A xs) \\<le> height (heap_of_A xs) + 1\n\ngoal (2 subgoals):\n 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1)\n 2. \\<And>a xs.\n       t_heap_of_A xs\n       \\<le> length xs * (height (heap_of_A xs) + 1) \\<Longrightarrow>\n       t_heap_of_A (a # xs)\n       \\<le> length (a # xs) * (height (heap_of_A (a # xs)) + 1)", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>xa y.\n              xa \\<le> y \\<Longrightarrow>\n              t_insert x (heap_of_A xs) + xa\n              \\<le> t_insert x (heap_of_A xs) + y;\n   \\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      t_insert x (heap_of_A xs) + length xs * (xa + 1)\n      \\<le> t_insert x (heap_of_A xs) + length xs * (y + 1);\n   \\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      xa + length xs * (height (insert x (heap_of_A xs)) + 1)\n      \\<le> y + length xs * (height (insert x (heap_of_A xs)) + 1)\\<rbrakk>\n  \\<Longrightarrow> t_insert x (heap_of_A xs) + t_heap_of_A xs\n                    \\<le> height (heap_of_A xs) + 1 +\n                          length xs * (height (insert x (heap_of_A xs)) + 1)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>xa y.\n              xa \\<le> y \\<Longrightarrow>\n              t_insert x (heap_of_A xs) + xa\n              \\<le> t_insert x (heap_of_A xs) + y;\n   \\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      t_insert x (heap_of_A xs) + length xs * (xa + 1)\n      \\<le> t_insert x (heap_of_A xs) + length xs * (y + 1);\n   \\<And>xa y.\n      xa \\<le> y \\<Longrightarrow>\n      xa + length xs * (height (insert x (heap_of_A xs)) + 1)\n      \\<le> y + length xs * (height (insert x (heap_of_A xs)) + 1)\\<rbrakk>\n  \\<Longrightarrow> t_insert x (heap_of_A xs) + t_heap_of_A xs\n                    \\<le> height (heap_of_A xs) + 1 +\n                          length xs * (height (insert x (heap_of_A xs)) + 1)\n\ngoal (1 subgoal):\n 1. t_heap_of_A (x # xs)\n    \\<le> length (x # xs) * (height (heap_of_A (x # xs)) + 1)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. t_insert x (heap_of_A xs) + t_heap_of_A xs\n    \\<le> Suc (height (heap_of_A xs) +\n               (length xs +\n                length xs *\n                height (insert x (heap_of_A xs)))) \\<Longrightarrow>\n    t_insert x (heap_of_A xs) + t_heap_of_A xs\n    \\<le> Suc (length xs +\n               (height (insert x (heap_of_A xs)) +\n                length xs * height (insert x (heap_of_A xs))))", "apply (erule order_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (height (heap_of_A xs) +\n         (length xs + length xs * height (insert x (heap_of_A xs))))\n    \\<le> Suc (length xs +\n               (height (insert x (heap_of_A xs)) +\n                length xs * height (insert x (heap_of_A xs))))", "apply (simp add: height_insert_ge)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  t_heap_of_A (x # xs)\n  \\<le> length (x # xs) * (height (heap_of_A (x # xs)) + 1)\n\ngoal (1 subgoal):\n 1. t_heap_of_A [] \\<le> length [] * (height (heap_of_A []) + 1)", "qed simp_all"], ["", "lemma size_heap_of_A:\n  \"size (heap_of_A xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (heap_of_A xs) = length xs", "using arg_cong[OF mset_tree_heap_of_A, of size xs]"], ["proof (prove)\nusing this:\n  size (mset_tree (heap_of_A xs)) = size (mset xs)\n\ngoal (1 subgoal):\n 1. size (heap_of_A xs) = length xs", "by simp"], ["", "lemma t_heap_of_A_log_bound:\n  \"t_heap_of_A xs \\<le> length xs * (nlog2 (length xs + 1) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_heap_of_A xs\n    \\<le> length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "using t_heap_of_A_bound[of xs]\n    acomplete_if_braun[OF braun_heap_of_A, of xs]"], ["proof (prove)\nusing this:\n  t_heap_of_A xs \\<le> length xs * (height (heap_of_A xs) + 1)\n  acomplete (heap_of_A xs)\n\ngoal (1 subgoal):\n 1. t_heap_of_A xs\n    \\<le> length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "by (simp add: height_acomplete size1_size size_heap_of_A)"], ["", "text \\<open>Algorithm B mimics heap sort more closely by building heaps bottom up in a balanced way:\\<close>"], ["", "fun heapify :: \"nat \\<Rightarrow> ('a::linorder) list \\<Rightarrow> 'a tree * 'a list\" where\n\"heapify 0 xs = (Leaf, xs)\" |\n\"heapify (Suc n) (x#xs) =\n\t (let (l, ys) = heapify (Suc n div 2) xs;\n\t\t    (r, zs) = heapify (n div 2) ys\n\t  in (sift_down l x r, zs))\""], ["", "text \\<open>The result should be a Braun tree:\\<close>"], ["", "lemma heapify_snd:\n  \"n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow> snd (heapify n xs) = drop n xs", "apply (induct xs arbitrary: n rule: measure_induct[where f=length])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       \\<lbrakk>\\<forall>y.\n                   length y < length x \\<longrightarrow>\n                   (\\<forall>x\\<le>length y. snd (heapify x y) = drop x y);\n        n \\<le> length x\\<rbrakk>\n       \\<Longrightarrow> snd (heapify n x) = drop n x", "apply (case_tac n; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n nat.\n       \\<lbrakk>\\<forall>y.\n                   length y < length x \\<longrightarrow>\n                   (\\<forall>x\\<le>length y. snd (heapify x y) = drop x y);\n        Suc nat \\<le> length x; n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> snd (heapify (Suc nat) x) = drop (Suc nat) x", "apply (clarsimp simp: Suc_le_length_iff case_prod_beta)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat ys.\n       \\<lbrakk>\\<forall>y.\n                   length y < Suc (length ys) \\<longrightarrow>\n                   (\\<forall>x\\<le>length y. snd (heapify x y) = drop x y);\n        nat \\<le> length ys\\<rbrakk>\n       \\<Longrightarrow> drop (nat div 2 + Suc nat div 2) ys = drop nat ys", "apply (rule arg_cong[where f=\"\\<lambda>n. drop n xs\" for xs])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat ys.\n       \\<lbrakk>\\<forall>y.\n                   length y < Suc (length ys) \\<longrightarrow>\n                   (\\<forall>x\\<le>length y. snd (heapify x y) = drop x y);\n        nat \\<le> length ys\\<rbrakk>\n       \\<Longrightarrow> nat div 2 + Suc nat div 2 = nat", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma heapify_snd_tup:\n  \"heapify n xs = (t, ys) \\<Longrightarrow> n \\<le> length xs \\<Longrightarrow> ys = drop n xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heapify n xs = (t, ys); n \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> ys = drop n xs", "by (drule heapify_snd, simp)"], ["", "lemma heapify_correct:\n  \"n \\<le> length xs \\<Longrightarrow> heapify n xs = (t, ys) \\<Longrightarrow>\n    size t = n \\<and> heap t \\<and> braun t \\<and> mset_tree t = mset (take n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> length xs; heapify n xs = (t, ys)\\<rbrakk>\n    \\<Longrightarrow> size t = n \\<and>\n                      heap t \\<and>\n                      braun t \\<and> mset_tree t = mset (take n xs)", "proof (induct n xs arbitrary: t ys rule: heapify.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>n x xs t ys.\n       \\<lbrakk>\\<And>t ys.\n                   \\<lbrakk>Suc n div 2 \\<le> length xs;\n                    heapify (Suc n div 2) xs = (t, ys)\\<rbrakk>\n                   \\<Longrightarrow> size t = Suc n div 2 \\<and>\n                                     heap t \\<and>\n                                     braun t \\<and>\n                                     mset_tree t =\n                                     mset (take (Suc n div 2) xs);\n        \\<And>xa xb y t ys.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk>\n           \\<Longrightarrow> size t = n div 2 \\<and>\n                             heap t \\<and>\n                             braun t \\<and>\n                             mset_tree t = mset (take (n div 2) y);\n        Suc n \\<le> length (x # xs);\n        heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc n \\<and>\n                         heap t \\<and>\n                         braun t \\<and>\n                         mset_tree t = mset (take (Suc n) (x # xs))\n 3. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "case (2 n x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>Suc n div 2 \\<le> length xs;\n   heapify (Suc n div 2) xs = (?t, ?ys)\\<rbrakk>\n  \\<Longrightarrow> size ?t = Suc n div 2 \\<and>\n                    heap ?t \\<and>\n                    braun ?t \\<and>\n                    mset_tree ?t = mset (take (Suc n div 2) xs)\n  \\<lbrakk>?xa = heapify (Suc n div 2) xs; (?xb, ?y) = ?xa;\n   n div 2 \\<le> length ?y; heapify (n div 2) ?y = (?t, ?ys)\\<rbrakk>\n  \\<Longrightarrow> size ?t = n div 2 \\<and>\n                    heap ?t \\<and>\n                    braun ?t \\<and> mset_tree ?t = mset (take (n div 2) ?y)\n  Suc n \\<le> length (x # xs)\n  heapify (Suc n) (x # xs) = (t, ys)\n\ngoal (3 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>n x xs t ys.\n       \\<lbrakk>\\<And>t ys.\n                   \\<lbrakk>Suc n div 2 \\<le> length xs;\n                    heapify (Suc n div 2) xs = (t, ys)\\<rbrakk>\n                   \\<Longrightarrow> size t = Suc n div 2 \\<and>\n                                     heap t \\<and>\n                                     braun t \\<and>\n                                     mset_tree t =\n                                     mset (take (Suc n div 2) xs);\n        \\<And>xa xb y t ys.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk>\n           \\<Longrightarrow> size t = n div 2 \\<and>\n                             heap t \\<and>\n                             braun t \\<and>\n                             mset_tree t = mset (take (n div 2) y);\n        Suc n \\<le> length (x # xs);\n        heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc n \\<and>\n                         heap t \\<and>\n                         braun t \\<and>\n                         mset_tree t = mset (take (Suc n) (x # xs))\n 3. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "note len = \"2.prems\"(1)"], ["proof (state)\nthis:\n  Suc n \\<le> length (x # xs)\n\ngoal (3 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>n x xs t ys.\n       \\<lbrakk>\\<And>t ys.\n                   \\<lbrakk>Suc n div 2 \\<le> length xs;\n                    heapify (Suc n div 2) xs = (t, ys)\\<rbrakk>\n                   \\<Longrightarrow> size t = Suc n div 2 \\<and>\n                                     heap t \\<and>\n                                     braun t \\<and>\n                                     mset_tree t =\n                                     mset (take (Suc n div 2) xs);\n        \\<And>xa xb y t ys.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk>\n           \\<Longrightarrow> size t = n div 2 \\<and>\n                             heap t \\<and>\n                             braun t \\<and>\n                             mset_tree t = mset (take (n div 2) y);\n        Suc n \\<le> length (x # xs);\n        heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc n \\<and>\n                         heap t \\<and>\n                         braun t \\<and>\n                         mset_tree t = mset (take (Suc n) (x # xs))\n 3. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "obtain t1 ys1 where h1: \"heapify (Suc n div 2) xs = (t1, ys1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t1 ys1.\n        heapify (Suc n div 2) xs = (t1, ys1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (simp add: prod_eq_iff)"], ["proof (state)\nthis:\n  heapify (Suc n div 2) xs = (t1, ys1)\n\ngoal (3 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>n x xs t ys.\n       \\<lbrakk>\\<And>t ys.\n                   \\<lbrakk>Suc n div 2 \\<le> length xs;\n                    heapify (Suc n div 2) xs = (t, ys)\\<rbrakk>\n                   \\<Longrightarrow> size t = Suc n div 2 \\<and>\n                                     heap t \\<and>\n                                     braun t \\<and>\n                                     mset_tree t =\n                                     mset (take (Suc n div 2) xs);\n        \\<And>xa xb y t ys.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk>\n           \\<Longrightarrow> size t = n div 2 \\<and>\n                             heap t \\<and>\n                             braun t \\<and>\n                             mset_tree t = mset (take (n div 2) y);\n        Suc n \\<le> length (x # xs);\n        heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc n \\<and>\n                         heap t \\<and>\n                         braun t \\<and>\n                         mset_tree t = mset (take (Suc n) (x # xs))\n 3. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "obtain t2 ys2 where h2: \"heapify (n div 2) ys1 = (t2, ys2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t2 ys2.\n        heapify (n div 2) ys1 = (t2, ys2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (simp add: prod_eq_iff)"], ["proof (state)\nthis:\n  heapify (n div 2) ys1 = (t2, ys2)\n\ngoal (3 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>n x xs t ys.\n       \\<lbrakk>\\<And>t ys.\n                   \\<lbrakk>Suc n div 2 \\<le> length xs;\n                    heapify (Suc n div 2) xs = (t, ys)\\<rbrakk>\n                   \\<Longrightarrow> size t = Suc n div 2 \\<and>\n                                     heap t \\<and>\n                                     braun t \\<and>\n                                     mset_tree t =\n                                     mset (take (Suc n div 2) xs);\n        \\<And>xa xb y t ys.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk>\n           \\<Longrightarrow> size t = n div 2 \\<and>\n                             heap t \\<and>\n                             braun t \\<and>\n                             mset_tree t = mset (take (n div 2) y);\n        Suc n \\<le> length (x # xs);\n        heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc n \\<and>\n                         heap t \\<and>\n                         braun t \\<and>\n                         mset_tree t = mset (take (Suc n) (x # xs))\n 3. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "from len"], ["proof (chain)\npicking this:\n  Suc n \\<le> length (x # xs)", "have le1: \"Suc n div 2 \\<le> length xs\""], ["proof (prove)\nusing this:\n  Suc n \\<le> length (x # xs)\n\ngoal (1 subgoal):\n 1. Suc n div 2 \\<le> length xs", "by simp"], ["proof (state)\nthis:\n  Suc n div 2 \\<le> length xs\n\ngoal (3 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>n x xs t ys.\n       \\<lbrakk>\\<And>t ys.\n                   \\<lbrakk>Suc n div 2 \\<le> length xs;\n                    heapify (Suc n div 2) xs = (t, ys)\\<rbrakk>\n                   \\<Longrightarrow> size t = Suc n div 2 \\<and>\n                                     heap t \\<and>\n                                     braun t \\<and>\n                                     mset_tree t =\n                                     mset (take (Suc n div 2) xs);\n        \\<And>xa xb y t ys.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk>\n           \\<Longrightarrow> size t = n div 2 \\<and>\n                             heap t \\<and>\n                             braun t \\<and>\n                             mset_tree t = mset (take (n div 2) y);\n        Suc n \\<le> length (x # xs);\n        heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc n \\<and>\n                         heap t \\<and>\n                         braun t \\<and>\n                         mset_tree t = mset (take (Suc n) (x # xs))\n 3. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "note ys1 = heapify_snd_tup[OF h1 le1]"], ["proof (state)\nthis:\n  ys1 = drop (Suc n div 2) xs\n\ngoal (3 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>n x xs t ys.\n       \\<lbrakk>\\<And>t ys.\n                   \\<lbrakk>Suc n div 2 \\<le> length xs;\n                    heapify (Suc n div 2) xs = (t, ys)\\<rbrakk>\n                   \\<Longrightarrow> size t = Suc n div 2 \\<and>\n                                     heap t \\<and>\n                                     braun t \\<and>\n                                     mset_tree t =\n                                     mset (take (Suc n div 2) xs);\n        \\<And>xa xb y t ys.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk>\n           \\<Longrightarrow> size t = n div 2 \\<and>\n                             heap t \\<and>\n                             braun t \\<and>\n                             mset_tree t = mset (take (n div 2) y);\n        Suc n \\<le> length (x # xs);\n        heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc n \\<and>\n                         heap t \\<and>\n                         braun t \\<and>\n                         mset_tree t = mset (take (Suc n) (x # xs))\n 3. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "from len"], ["proof (chain)\npicking this:\n  Suc n \\<le> length (x # xs)", "have le2: \"n div 2 \\<le> length ys1\""], ["proof (prove)\nusing this:\n  Suc n \\<le> length (x # xs)\n\ngoal (1 subgoal):\n 1. n div 2 \\<le> length ys1", "by (simp add: ys1)"], ["proof (state)\nthis:\n  n div 2 \\<le> length ys1\n\ngoal (3 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>n x xs t ys.\n       \\<lbrakk>\\<And>t ys.\n                   \\<lbrakk>Suc n div 2 \\<le> length xs;\n                    heapify (Suc n div 2) xs = (t, ys)\\<rbrakk>\n                   \\<Longrightarrow> size t = Suc n div 2 \\<and>\n                                     heap t \\<and>\n                                     braun t \\<and>\n                                     mset_tree t =\n                                     mset (take (Suc n div 2) xs);\n        \\<And>xa xb y t ys.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk>\n           \\<Longrightarrow> size t = n div 2 \\<and>\n                             heap t \\<and>\n                             braun t \\<and>\n                             mset_tree t = mset (take (n div 2) y);\n        Suc n \\<le> length (x # xs);\n        heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc n \\<and>\n                         heap t \\<and>\n                         braun t \\<and>\n                         mset_tree t = mset (take (Suc n) (x # xs))\n 3. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "note app_hyps = \"2.hyps\"(1)[OF le1 h1]\n    \"2.hyps\"(2)[OF refl h1[symmetric], simplified, OF le2 h2]"], ["proof (state)\nthis:\n  size t1 = Suc n div 2 \\<and>\n  heap t1 \\<and> braun t1 \\<and> mset_tree t1 = mset (take (Suc n div 2) xs)\n  size t2 = n div 2 \\<and>\n  heap t2 \\<and> braun t2 \\<and> mset_tree t2 = mset (take (n div 2) ys1)\n\ngoal (3 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>n x xs t ys.\n       \\<lbrakk>\\<And>t ys.\n                   \\<lbrakk>Suc n div 2 \\<le> length xs;\n                    heapify (Suc n div 2) xs = (t, ys)\\<rbrakk>\n                   \\<Longrightarrow> size t = Suc n div 2 \\<and>\n                                     heap t \\<and>\n                                     braun t \\<and>\n                                     mset_tree t =\n                                     mset (take (Suc n div 2) xs);\n        \\<And>xa xb y t ys.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk>\n           \\<Longrightarrow> size t = n div 2 \\<and>\n                             heap t \\<and>\n                             braun t \\<and>\n                             mset_tree t = mset (take (n div 2) y);\n        Suc n \\<le> length (x # xs);\n        heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc n \\<and>\n                         heap t \\<and>\n                         braun t \\<and>\n                         mset_tree t = mset (take (Suc n) (x # xs))\n 3. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "hence braun: \"braun (Node t1 x t2)\""], ["proof (prove)\nusing this:\n  size t1 = Suc n div 2 \\<and>\n  heap t1 \\<and> braun t1 \\<and> mset_tree t1 = mset (take (Suc n div 2) xs)\n  size t2 = n div 2 \\<and>\n  heap t2 \\<and> braun t2 \\<and> mset_tree t2 = mset (take (n div 2) ys1)\n\ngoal (1 subgoal):\n 1. braun \\<langle>t1, x, t2\\<rangle>", "by (simp, linarith)"], ["proof (state)\nthis:\n  braun \\<langle>t1, x, t2\\<rangle>\n\ngoal (3 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>n x xs t ys.\n       \\<lbrakk>\\<And>t ys.\n                   \\<lbrakk>Suc n div 2 \\<le> length xs;\n                    heapify (Suc n div 2) xs = (t, ys)\\<rbrakk>\n                   \\<Longrightarrow> size t = Suc n div 2 \\<and>\n                                     heap t \\<and>\n                                     braun t \\<and>\n                                     mset_tree t =\n                                     mset (take (Suc n div 2) xs);\n        \\<And>xa xb y t ys.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk>\n           \\<Longrightarrow> size t = n div 2 \\<and>\n                             heap t \\<and>\n                             braun t \\<and>\n                             mset_tree t = mset (take (n div 2) y);\n        Suc n \\<le> length (x # xs);\n        heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc n \\<and>\n                         heap t \\<and>\n                         braun t \\<and>\n                         mset_tree t = mset (take (Suc n) (x # xs))\n 3. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "have eq:\n    \"n div 2 + Suc n div 2 = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n div 2 + Suc n div 2 = n", "by simp"], ["proof (state)\nthis:\n  n div 2 + Suc n div 2 = n\n\ngoal (3 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>n x xs t ys.\n       \\<lbrakk>\\<And>t ys.\n                   \\<lbrakk>Suc n div 2 \\<le> length xs;\n                    heapify (Suc n div 2) xs = (t, ys)\\<rbrakk>\n                   \\<Longrightarrow> size t = Suc n div 2 \\<and>\n                                     heap t \\<and>\n                                     braun t \\<and>\n                                     mset_tree t =\n                                     mset (take (Suc n div 2) xs);\n        \\<And>xa xb y t ys.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk>\n           \\<Longrightarrow> size t = n div 2 \\<and>\n                             heap t \\<and>\n                             braun t \\<and>\n                             mset_tree t = mset (take (n div 2) y);\n        Suc n \\<le> length (x # xs);\n        heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc n \\<and>\n                         heap t \\<and>\n                         braun t \\<and>\n                         mset_tree t = mset (take (Suc n) (x # xs))\n 3. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "have msets:\n    \"mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) = mset (take n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) =\n    mset (take n xs)", "apply (subst append_take_drop_id[symmetric, where n=\"Suc n div 2\" and t=\"take n xs\"],\n        subst mset_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) =\n    mset (take (Suc n div 2) (take n xs)) +\n    mset (drop (Suc n div 2) (take n xs))", "apply (simp add: take_drop min_absorb1 le1 eq ys1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) =\n  mset (take n xs)\n\ngoal (3 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>n x xs t ys.\n       \\<lbrakk>\\<And>t ys.\n                   \\<lbrakk>Suc n div 2 \\<le> length xs;\n                    heapify (Suc n div 2) xs = (t, ys)\\<rbrakk>\n                   \\<Longrightarrow> size t = Suc n div 2 \\<and>\n                                     heap t \\<and>\n                                     braun t \\<and>\n                                     mset_tree t =\n                                     mset (take (Suc n div 2) xs);\n        \\<And>xa xb y t ys.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            n div 2 \\<le> length y; heapify (n div 2) y = (t, ys)\\<rbrakk>\n           \\<Longrightarrow> size t = n div 2 \\<and>\n                             heap t \\<and>\n                             braun t \\<and>\n                             mset_tree t = mset (take (n div 2) y);\n        Suc n \\<le> length (x # xs);\n        heapify (Suc n) (x # xs) = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc n \\<and>\n                         heap t \\<and>\n                         braun t \\<and>\n                         mset_tree t = mset (take (Suc n) (x # xs))\n 3. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "from \"2.prems\" app_hyps msets"], ["proof (chain)\npicking this:\n  Suc n \\<le> length (x # xs)\n  heapify (Suc n) (x # xs) = (t, ys)\n  size t1 = Suc n div 2 \\<and>\n  heap t1 \\<and> braun t1 \\<and> mset_tree t1 = mset (take (Suc n div 2) xs)\n  size t2 = n div 2 \\<and>\n  heap t2 \\<and> braun t2 \\<and> mset_tree t2 = mset (take (n div 2) ys1)\n  mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) =\n  mset (take n xs)", "show ?case"], ["proof (prove)\nusing this:\n  Suc n \\<le> length (x # xs)\n  heapify (Suc n) (x # xs) = (t, ys)\n  size t1 = Suc n div 2 \\<and>\n  heap t1 \\<and> braun t1 \\<and> mset_tree t1 = mset (take (Suc n div 2) xs)\n  size t2 = n div 2 \\<and>\n  heap t2 \\<and> braun t2 \\<and> mset_tree t2 = mset (take (n div 2) ys1)\n  mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) =\n  mset (take n xs)\n\ngoal (1 subgoal):\n 1. size t = Suc n \\<and>\n    heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n) (x # xs))", "apply (clarsimp simp: h1 h2 le2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> length xs;\n     mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) =\n     mset (take n xs);\n     ys2 = ys; t = sift_down t1 x t2; size t1 = Suc n div 2;\n     size t2 = n div 2; heap t1; heap t2; braun t1;\n     mset_tree t1 = mset (take (Suc n div 2) xs); braun t2;\n     mset_tree t2 = mset (take (n div 2) ys1)\\<rbrakk>\n    \\<Longrightarrow> size (sift_down t1 x t2) = Suc n \\<and>\n                      heap (sift_down t1 x t2) \\<and>\n                      braun (sift_down t1 x t2) \\<and>\n                      mset_tree (sift_down t1 x t2) =\n                      add_mset x (mset (take n xs))", "apply (clarsimp simp: size_sift_down[OF braun]\n                       braun_sift_down[OF braun]\n                       mset_sift_down[OF braun])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> length xs;\n     mset (take (Suc n div 2) xs) + mset (take (n div 2) ys1) =\n     mset (take n xs);\n     ys2 = ys; t = sift_down t1 x t2; size t1 = Suc n div 2;\n     size t2 = n div 2; heap t1; heap t2; braun t1;\n     mset_tree t1 = mset (take (Suc n div 2) xs); braun t2;\n     mset_tree t2 = mset (take (n div 2) ys1)\\<rbrakk>\n    \\<Longrightarrow> Suc n div 2 + n div 2 = n \\<and>\n                      heap (sift_down t1 x t2)", "apply (simp add: heap_sift_down[OF braun])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  size t = Suc n \\<and>\n  heap t \\<and> braun t \\<and> mset_tree t = mset (take (Suc n) (x # xs))\n\ngoal (2 subgoals):\n 1. \\<And>xs t ys.\n       \\<lbrakk>0 \\<le> length xs; heapify 0 xs = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = 0 \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take 0 xs)\n 2. \\<And>v t ys.\n       \\<lbrakk>Suc v \\<le> length []; heapify (Suc v) [] = (t, ys)\\<rbrakk>\n       \\<Longrightarrow> size t = Suc v \\<and>\n                         heap t \\<and>\n                         braun t \\<and> mset_tree t = mset (take (Suc v) [])", "qed simp_all"], ["", "lemma braun_heapify:\n  \"n \\<le> length xs \\<Longrightarrow> braun (fst (heapify n xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow> braun (fst (heapify n xs))", "by (cases \"heapify n xs\", drule(1) heapify_correct, simp)"], ["", "lemma heap_heapify:\n  \"n \\<le> length xs \\<Longrightarrow> heap (fst (heapify n xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow> heap (fst (heapify n xs))", "by (cases \"heapify n xs\", drule(1) heapify_correct, simp)"], ["", "lemma mset_heapify:\n  \"n \\<le> length xs \\<Longrightarrow> mset_tree (fst (heapify n xs)) = mset (take n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    mset_tree (fst (heapify n xs)) = mset (take n xs)", "by (cases \"heapify n xs\", drule(1) heapify_correct, simp)"], ["", "text \\<open>The running time of heapify is linear.\n  (similar to \\<^url>\\<open>https://en.wikipedia.org/wiki/Binary_heap#Building_a_heap\\<close>)\n\nThis is an interesting result, so we embark on this exercise\nto prove it the hard way.\n\\<close>"], ["", "context includes pattern_aliases\nbegin"], ["", "function (sequential) t_sift_down :: \"'a::linorder tree \\<Rightarrow> 'a \\<Rightarrow> 'a tree \\<Rightarrow> nat\" where\n\"t_sift_down Leaf a Leaf = 1\" |\n\"t_sift_down (Node Leaf x Leaf) a Leaf = 2\" |\n\"t_sift_down (Node l1 x1 r1 =: t1) a (Node l2 x2 r2 =: t2) =\n  (if a \\<le> x1 \\<and> a \\<le> x2\n   then 1\n   else if x1 \\<le> x2 then 1 + t_sift_down l1 a r1\n        else 1 + t_sift_down l2 a r2)\""], ["proof (prove)\ngoal (22 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>a.\n                   x =\n                   (\\<langle>\\<rangle>, a,\n                    \\<langle>\\<rangle>) \\<Longrightarrow>\n                   P;\n        \\<And>xa a.\n           x =\n           (\\<langle>\\<langle>\\<rangle>, xa, \\<langle>\\<rangle>\\<rangle>, a,\n            \\<langle>\\<rangle>) \\<Longrightarrow>\n           P;\n        \\<And>l1 x1 r1 a l2 x2 r2.\n           x =\n           (\\<langle>l1, x1, r1\\<rangle>, a,\n            \\<langle>l2, x2, r2\\<rangle>) \\<Longrightarrow>\n           P;\n        \\<And>vc vd ve va vb b.\n           x =\n           (\\<langle>\\<langle>vc, vd, ve\\<rangle>, va, vb\\<rangle>, b,\n            \\<langle>\\<rangle>) \\<Longrightarrow>\n           P;\n        \\<And>v va vc vd ve b.\n           x =\n           (\\<langle>v, va, \\<langle>vc, vd, ve\\<rangle>\\<rangle>, b,\n            \\<langle>\\<rangle>) \\<Longrightarrow>\n           P;\n        \\<And>b v va vb.\n           x =\n           (\\<langle>\\<rangle>, b,\n            \\<langle>v, va, vb\\<rangle>) \\<Longrightarrow>\n           P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>a aa.\n       (\\<langle>\\<rangle>, a, \\<langle>\\<rangle>) =\n       (\\<langle>\\<rangle>, aa, \\<langle>\\<rangle>) \\<Longrightarrow>\n       1 = 1\n 3. \\<And>a x aa.\n       (\\<langle>\\<rangle>, a, \\<langle>\\<rangle>) =\n       (\\<langle>\\<langle>\\<rangle>, x, \\<langle>\\<rangle>\\<rangle>, aa,\n        \\<langle>\\<rangle>) \\<Longrightarrow>\n       1 = 2\n 4. \\<And>a l1 x1 r1 aa l2 x2 r2.\n       (\\<langle>\\<rangle>, a, \\<langle>\\<rangle>) =\n       (\\<langle>l1, x1, r1\\<rangle>, aa,\n        \\<langle>l2, x2, r2\\<rangle>) \\<Longrightarrow>\n       1 =\n       (let t2 = \\<langle>l2, x2, r2\\<rangle>;\n            t1 = \\<langle>l1, x1, r1\\<rangle>\n        in if aa \\<le> x1 \\<and> aa \\<le> x2 then 1\n           else if x1 \\<le> x2 then 1 + t_sift_down_sumC (l1, aa, r1)\n                else 1 + t_sift_down_sumC (l2, aa, r2))\n 5. \\<And>a vc vd ve va vb b.\n       (\\<langle>\\<rangle>, a, \\<langle>\\<rangle>) =\n       (\\<langle>\\<langle>vc, vd, ve\\<rangle>, va, vb\\<rangle>, b,\n        \\<langle>\\<rangle>) \\<Longrightarrow>\n       1 = undefined\n 6. \\<And>a v va vc vd ve b.\n       (\\<langle>\\<rangle>, a, \\<langle>\\<rangle>) =\n       (\\<langle>v, va, \\<langle>vc, vd, ve\\<rangle>\\<rangle>, b,\n        \\<langle>\\<rangle>) \\<Longrightarrow>\n       1 = undefined\n 7. \\<And>a b v va vb.\n       (\\<langle>\\<rangle>, a, \\<langle>\\<rangle>) =\n       (\\<langle>\\<rangle>, b,\n        \\<langle>v, va, vb\\<rangle>) \\<Longrightarrow>\n       1 = undefined\n 8. \\<And>x a xa aa.\n       (\\<langle>\\<langle>\\<rangle>, x, \\<langle>\\<rangle>\\<rangle>, a,\n        \\<langle>\\<rangle>) =\n       (\\<langle>\\<langle>\\<rangle>, xa, \\<langle>\\<rangle>\\<rangle>, aa,\n        \\<langle>\\<rangle>) \\<Longrightarrow>\n       2 = 2\n 9. \\<And>x a l1 x1 r1 aa l2 x2 r2.\n       (\\<langle>\\<langle>\\<rangle>, x, \\<langle>\\<rangle>\\<rangle>, a,\n        \\<langle>\\<rangle>) =\n       (\\<langle>l1, x1, r1\\<rangle>, aa,\n        \\<langle>l2, x2, r2\\<rangle>) \\<Longrightarrow>\n       2 =\n       (let t2 = \\<langle>l2, x2, r2\\<rangle>;\n            t1 = \\<langle>l1, x1, r1\\<rangle>\n        in if aa \\<le> x1 \\<and> aa \\<le> x2 then 1\n           else if x1 \\<le> x2 then 1 + t_sift_down_sumC (l1, aa, r1)\n                else 1 + t_sift_down_sumC (l2, aa, r2))\n 10. \\<And>x a vc vd ve va vb b.\n        (\\<langle>\\<langle>\\<rangle>, x, \\<langle>\\<rangle>\\<rangle>, a,\n         \\<langle>\\<rangle>) =\n        (\\<langle>\\<langle>vc, vd, ve\\<rangle>, va, vb\\<rangle>, b,\n         \\<langle>\\<rangle>) \\<Longrightarrow>\n        2 = undefined\nA total of 22 subgoals...", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All t_sift_down_dom", "by (relation \"measure (%(l,a,r). size l + size r)\") auto"], ["", "end"], ["", "fun t_heapify :: \"nat \\<Rightarrow> ('a::linorder) list \\<Rightarrow> nat\" where\n\"t_heapify 0 xs = 1\" |\n\"t_heapify (Suc n) (x#xs) =\n\t (let (l, ys) = heapify (Suc n div 2) xs;\n        t1 = t_heapify (Suc n div 2) xs;\n        (r, zs) = heapify (n div 2) ys;\n\t\t    t2 = t_heapify (n div 2) ys\n\t  in 1 + t1 + t2 + t_sift_down l x r)\""], ["", "lemma t_sift_down_height:\n  \"braun (Node l x r) \\<Longrightarrow> t_sift_down l x r \\<le> height (Node l x r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>l, x, r\\<rangle> \\<Longrightarrow>\n    t_sift_down l x r \\<le> height \\<langle>l, x, r\\<rangle>", "by (induct l x r rule: t_sift_down.induct; auto)"], ["", "lemma sift_down_height:\n  \"braun (Node l x r) \\<Longrightarrow> height (sift_down l x r) \\<le> height (Node l x r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>l, x, r\\<rangle> \\<Longrightarrow>\n    height (sift_down l x r) \\<le> height \\<langle>l, x, r\\<rangle>", "by (induct l x r rule: sift_down.induct; auto simp: Let_def)"], ["", "lemma braun_height_r_le:\n  \"braun (Node l x r) \\<Longrightarrow> height r \\<le> height l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>l, x, r\\<rangle> \\<Longrightarrow>\n    height r \\<le> height l", "by (rule acomplete_optimal, auto intro: acomplete_if_braun)"], ["", "lemma braun_height_l_le:\n  assumes b: \"braun (Node l x r)\"\n  shows \"height l \\<le> Suc (height r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height l \\<le> Suc (height r)", "using b acomplete_if_braun[OF b] min_height_le_height[of r]"], ["proof (prove)\nusing this:\n  braun \\<langle>l, x, r\\<rangle>\n  acomplete \\<langle>l, x, r\\<rangle>\n  min_height r \\<le> height r\n\ngoal (1 subgoal):\n 1. height l \\<le> Suc (height r)", "by (simp add: acomplete_def)"], ["", "lemma braun_height_node_eq:\n  assumes b: \"braun (Node l x r)\"\n  shows \"height (Node l x r) = Suc (height l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height \\<langle>l, x, r\\<rangle> = Suc (height l)", "using b braun_height_r_le[OF b]"], ["proof (prove)\nusing this:\n  braun \\<langle>l, x, r\\<rangle>\n  height r \\<le> height l\n\ngoal (1 subgoal):\n 1. height \\<langle>l, x, r\\<rangle> = Suc (height l)", "by (auto simp add: max_def)"], ["", "lemma t_heapify_induct:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> length xs \\<Longrightarrow>\n    t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1", "proof (induct i xs rule: t_heapify.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs.\n       0 \\<le> length xs \\<Longrightarrow>\n       t_heapify 0 xs + height (fst (heapify 0 xs)) \\<le> 5 * 0 + 1\n 2. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 3. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "case (1 vs)"], ["proof (state)\nthis:\n  0 \\<le> length vs\n\ngoal (3 subgoals):\n 1. \\<And>xs.\n       0 \\<le> length xs \\<Longrightarrow>\n       t_heapify 0 xs + height (fst (heapify 0 xs)) \\<le> 5 * 0 + 1\n 2. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 3. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "thus ?case"], ["proof (prove)\nusing this:\n  0 \\<le> length vs\n\ngoal (1 subgoal):\n 1. t_heapify 0 vs + height (fst (heapify 0 vs)) \\<le> 5 * 0 + 1", "by simp"], ["proof (state)\nthis:\n  t_heapify 0 vs + height (fst (heapify 0 vs)) \\<le> 5 * 0 + 1\n\ngoal (2 subgoals):\n 1. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 2. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 2. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "case (2 i x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>?xa = heapify (Suc i div 2) xs; (?xb, ?y) = ?xa;\n   Suc i div 2 \\<le> length xs\\<rbrakk>\n  \\<Longrightarrow> t_heapify (Suc i div 2) xs +\n                    height (fst (heapify (Suc i div 2) xs))\n                    \\<le> 5 * (Suc i div 2) + 1\n  \\<lbrakk>?xa = heapify (Suc i div 2) xs; (?xb, ?y) = ?xa;\n   ?xaa = t_heapify (Suc i div 2) xs; ?xab = heapify (i div 2) ?y;\n   (?xac, ?ya) = ?xab; i div 2 \\<le> length ?y\\<rbrakk>\n  \\<Longrightarrow> t_heapify (i div 2) ?y +\n                    height (fst (heapify (i div 2) ?y))\n                    \\<le> 5 * (i div 2) + 1\n  Suc i \\<le> length (x # xs)\n\ngoal (2 subgoals):\n 1. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 2. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "obtain l ys where h1: \"heapify (Suc i div 2) xs = (l, ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l ys.\n        heapify (Suc i div 2) xs = (l, ys) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (simp add: prod_eq_iff)"], ["proof (state)\nthis:\n  heapify (Suc i div 2) xs = (l, ys)\n\ngoal (2 subgoals):\n 1. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 2. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "note hyps1 = \"2.hyps\"[OF h1[symmetric] refl, simplified]"], ["proof (state)\nthis:\n  Suc i div 2 \\<le> length xs \\<Longrightarrow>\n  t_heapify (Suc i div 2) xs + height (fst (heapify (Suc i div 2) xs))\n  \\<le> Suc (5 * (Suc i div 2))\n  \\<lbrakk>?xaa = t_heapify (Suc i div 2) xs; ?xab = heapify (i div 2) ys;\n   (?xac, ?ya) = ?xab; i div 2 \\<le> length ys\\<rbrakk>\n  \\<Longrightarrow> t_heapify (i div 2) ys +\n                    height (fst (heapify (i div 2) ys))\n                    \\<le> Suc (5 * (i div 2))\n\ngoal (2 subgoals):\n 1. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 2. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "obtain r zs where h2: \"heapify (i div 2) ys = (r, zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r zs.\n        heapify (i div 2) ys = (r, zs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (simp add: prod_eq_iff)"], ["proof (state)\nthis:\n  heapify (i div 2) ys = (r, zs)\n\ngoal (2 subgoals):\n 1. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 2. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "from \"2.prems\" heapify_snd_tup[OF h1]"], ["proof (chain)\npicking this:\n  Suc i \\<le> length (x # xs)\n  Suc i div 2 \\<le> length xs \\<Longrightarrow> ys = drop (Suc i div 2) xs", "have le1: \"Suc i div 2 \\<le> length xs\"\n    and le2: \"i div 2 \\<le> length xs\"\n    and le4: \"i div 2 \\<le> length ys\""], ["proof (prove)\nusing this:\n  Suc i \\<le> length (x # xs)\n  Suc i div 2 \\<le> length xs \\<Longrightarrow> ys = drop (Suc i div 2) xs\n\ngoal (1 subgoal):\n 1. Suc i div 2 \\<le> length xs &&&\n    i div 2 \\<le> length xs &&& i div 2 \\<le> length ys", "by simp_all"], ["proof (state)\nthis:\n  Suc i div 2 \\<le> length xs\n  i div 2 \\<le> length xs\n  i div 2 \\<le> length ys\n\ngoal (2 subgoals):\n 1. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 2. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "note hyps2 = hyps1(1)[OF le1] hyps1(2)[OF refl h2[symmetric] refl le4]"], ["proof (state)\nthis:\n  t_heapify (Suc i div 2) xs + height (fst (heapify (Suc i div 2) xs))\n  \\<le> Suc (5 * (Suc i div 2))\n  t_heapify (i div 2) ys + height (fst (heapify (i div 2) ys))\n  \\<le> Suc (5 * (i div 2))\n\ngoal (2 subgoals):\n 1. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 2. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "note prem = add_le_mono[OF add_le_mono[OF hyps2] order_refl[where x=3]]"], ["proof (state)\nthis:\n  t_heapify (Suc i div 2) xs + height (fst (heapify (Suc i div 2) xs)) +\n  (t_heapify (i div 2) ys + height (fst (heapify (i div 2) ys))) +\n  3\n  \\<le> Suc (5 * (Suc i div 2)) + Suc (5 * (i div 2)) + 3\n\ngoal (2 subgoals):\n 1. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 2. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "from heapify_correct[OF le1 h1] heapify_correct[OF le4 h2]"], ["proof (chain)\npicking this:\n  size l = Suc i div 2 \\<and>\n  heap l \\<and> braun l \\<and> mset_tree l = mset (take (Suc i div 2) xs)\n  size r = i div 2 \\<and>\n  heap r \\<and> braun r \\<and> mset_tree r = mset (take (i div 2) ys)", "have braun: \"braun \\<langle>l, x, r\\<rangle>\""], ["proof (prove)\nusing this:\n  size l = Suc i div 2 \\<and>\n  heap l \\<and> braun l \\<and> mset_tree l = mset (take (Suc i div 2) xs)\n  size r = i div 2 \\<and>\n  heap r \\<and> braun r \\<and> mset_tree r = mset (take (i div 2) ys)\n\ngoal (1 subgoal):\n 1. braun \\<langle>l, x, r\\<rangle>", "by auto"], ["proof (state)\nthis:\n  braun \\<langle>l, x, r\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 2. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "have t_sift_l:\n    \"t_sift_down l x r \\<le> height l + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_sift_down l x r \\<le> height l + 1", "using t_sift_down_height[OF braun] braun_height_r_le[OF braun]"], ["proof (prove)\nusing this:\n  t_sift_down l x r \\<le> height \\<langle>l, x, r\\<rangle>\n  height r \\<le> height l\n\ngoal (1 subgoal):\n 1. t_sift_down l x r \\<le> height l + 1", "by simp"], ["proof (state)\nthis:\n  t_sift_down l x r \\<le> height l + 1\n\ngoal (2 subgoals):\n 1. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 2. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "from t_sift_down_height[OF braun]"], ["proof (chain)\npicking this:\n  t_sift_down l x r \\<le> height \\<langle>l, x, r\\<rangle>", "have height_sift_r:\n    \"height (sift_down l x r) \\<le> height r + 2\""], ["proof (prove)\nusing this:\n  t_sift_down l x r \\<le> height \\<langle>l, x, r\\<rangle>\n\ngoal (1 subgoal):\n 1. height (sift_down l x r) \\<le> height r + 2", "using sift_down_height[OF braun] braun_height_l_le[OF braun]"], ["proof (prove)\nusing this:\n  t_sift_down l x r \\<le> height \\<langle>l, x, r\\<rangle>\n  height (sift_down l x r) \\<le> height \\<langle>l, x, r\\<rangle>\n  height l \\<le> Suc (height r)\n\ngoal (1 subgoal):\n 1. height (sift_down l x r) \\<le> height r + 2", "by simp"], ["proof (state)\nthis:\n  height (sift_down l x r) \\<le> height r + 2\n\ngoal (2 subgoals):\n 1. \\<And>n x xs.\n       \\<lbrakk>\\<And>xa xb y.\n                   \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n                    Suc n div 2 \\<le> length xs\\<rbrakk>\n                   \\<Longrightarrow> t_heapify (Suc n div 2) xs +\n                                     height (fst (heapify (Suc n div 2) xs))\n                                     \\<le> 5 * (Suc n div 2) + 1;\n        \\<And>xa xb y xaa xab xac ya.\n           \\<lbrakk>xa = heapify (Suc n div 2) xs; (xb, y) = xa;\n            xaa = t_heapify (Suc n div 2) xs; xab = heapify (n div 2) y;\n            (xac, ya) = xab; n div 2 \\<le> length y\\<rbrakk>\n           \\<Longrightarrow> t_heapify (n div 2) y +\n                             height (fst (heapify (n div 2) y))\n                             \\<le> 5 * (n div 2) + 1;\n        Suc n \\<le> length (x # xs)\\<rbrakk>\n       \\<Longrightarrow> t_heapify (Suc n) (x # xs) +\n                         height (fst (heapify (Suc n) (x # xs)))\n                         \\<le> 5 * Suc n + 1\n 2. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "from h1 h2 t_sift_l height_sift_r \"2.prems\""], ["proof (chain)\npicking this:\n  heapify (Suc i div 2) xs = (l, ys)\n  heapify (i div 2) ys = (r, zs)\n  t_sift_down l x r \\<le> height l + 1\n  height (sift_down l x r) \\<le> height r + 2\n  Suc i \\<le> length (x # xs)", "show ?case"], ["proof (prove)\nusing this:\n  heapify (Suc i div 2) xs = (l, ys)\n  heapify (i div 2) ys = (r, zs)\n  t_sift_down l x r \\<le> height l + 1\n  height (sift_down l x r) \\<le> height r + 2\n  Suc i \\<le> length (x # xs)\n\ngoal (1 subgoal):\n 1. t_heapify (Suc i) (x # xs) + height (fst (heapify (Suc i) (x # xs)))\n    \\<le> 5 * Suc i + 1", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heapify (Suc i div 2) xs = (l, ys);\n     heapify (i div 2) ys = (r, zs); t_sift_down l x r \\<le> Suc (height l);\n     height (sift_down l x r) \\<le> Suc (Suc (height r));\n     i \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> t_heapify (Suc i div 2) xs +\n                      (t_heapify (i div 2) ys +\n                       (t_sift_down l x r + height (sift_down l x r)))\n                      \\<le> 5 + 5 * i", "apply (rule order_trans, rule order_trans[rotated], rule prem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>heapify (Suc i div 2) xs = (l, ys);\n     heapify (i div 2) ys = (r, zs); t_sift_down l x r \\<le> Suc (height l);\n     height (sift_down l x r) \\<le> Suc (Suc (height r));\n     i \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> t_heapify (Suc i div 2) xs +\n                      (t_heapify (i div 2) ys +\n                       (t_sift_down l x r + height (sift_down l x r)))\n                      \\<le> t_heapify (Suc i div 2) xs +\n                            height (fst (heapify (Suc i div 2) xs)) +\n                            (t_heapify (i div 2) ys +\n                             height (fst (heapify (i div 2) ys))) +\n                            3\n 2. \\<lbrakk>heapify (Suc i div 2) xs = (l, ys);\n     heapify (i div 2) ys = (r, zs); t_sift_down l x r \\<le> Suc (height l);\n     height (sift_down l x r) \\<le> Suc (Suc (height r));\n     i \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> Suc (5 * (Suc i div 2)) + Suc (5 * (i div 2)) + 3\n                      \\<le> 5 + 5 * i", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heapify (Suc i div 2) xs = (l, ys);\n     heapify (i div 2) ys = (r, zs); t_sift_down l x r \\<le> Suc (height l);\n     height (sift_down l x r) \\<le> Suc (Suc (height r));\n     i \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> 5 * (Suc i div 2) + 5 * (i div 2) \\<le> 5 * i", "apply (simp only: mult_le_cancel1 add_mult_distrib2[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heapify (Suc i div 2) xs = (l, ys);\n     heapify (i div 2) ys = (r, zs); t_sift_down l x r \\<le> Suc (height l);\n     height (sift_down l x r) \\<le> Suc (Suc (height r));\n     i \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> 0 < 5 \\<longrightarrow> Suc i div 2 + i div 2 \\<le> i", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  t_heapify (Suc i) (x # xs) + height (fst (heapify (Suc i) (x # xs)))\n  \\<le> 5 * Suc i + 1\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       Suc v \\<le> length [] \\<Longrightarrow>\n       t_heapify (Suc v) [] + height (fst (heapify (Suc v) []))\n       \\<le> 5 * Suc v + 1", "qed simp_all"], ["", "lemma t_heapify_bound:\n  \"i \\<le> length xs \\<Longrightarrow> t_heapify i xs \\<le> 5 * i + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> length xs \\<Longrightarrow> t_heapify i xs \\<le> 5 * i + 1", "using t_heapify_induct[of i xs]"], ["proof (prove)\nusing this:\n  i \\<le> length xs \\<Longrightarrow>\n  t_heapify i xs + height (fst (heapify i xs)) \\<le> 5 * i + 1\n\ngoal (1 subgoal):\n 1. i \\<le> length xs \\<Longrightarrow> t_heapify i xs \\<le> 5 * i + 1", "by simp"], ["", "section \\<open>Phase 2: Heap to List\\<close>"], ["", "text\\<open>Algorithm A extracts (\\<open>list_of_A\\<close>) the list by removing the root and merging the children:\\<close>"], ["", "(* For termination of \\<open>merge\\<close> only: *)"], ["", "lemma size_prod_measure[measure_function]:\n  \"is_measure f \\<Longrightarrow> is_measure g \\<Longrightarrow> is_measure (size_prod f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_measure f; is_measure g\\<rbrakk>\n    \\<Longrightarrow> is_measure (size_prod f g)", "by (rule is_measure_trivial)"], ["", "fun merge :: \"('a::linorder) tree \\<Rightarrow> 'a tree \\<Rightarrow> 'a tree\" where\n\"merge Leaf t2 = t2\" |\n\"merge t1 Leaf = t1\" |\n\"merge (Node l1 a1 r1) (Node l2 a2 r2) =\n   (if a1 \\<le> a2 then Node (merge l1 r1) a1 (Node l2 a2 r2)\n    else Node (Node l1 a1 r1) a2 (merge l2 r2))\""], ["", "(* Merging does not preserve braun: *)"], ["", "value \"merge \\<langle>\\<langle>\\<rangle>, 0::int, \\<langle>\\<rangle>\\<rangle> \\<langle>\\<langle>\\<rangle>, 0, \\<langle>\\<rangle>\\<rangle> = \\<langle>\\<langle>\\<rangle>, 0, \\<langle>\\<langle>\\<rangle>, 0, \\<langle>\\<rangle>\\<rangle>\\<rangle>\""], ["", "lemma merge_size[termination_simp]:\n  \"size (merge l r) = size l + size r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (merge l r) = size l + size r", "by (induct rule: merge.induct; simp)"], ["", "fun list_of_A :: \"('a::linorder) tree \\<Rightarrow> 'a list\" where\n\"list_of_A Leaf = []\" |\n\"list_of_A (Node l a r) = a # list_of_A (merge l r)\""], ["", "value \"list_of_A (heap_of_A shuffle100)\""], ["", "lemma set_tree_merge[simp]:\n  \"set_tree (merge l r) = set_tree l \\<union> set_tree r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_tree (merge l r) = set_tree l \\<union> set_tree r", "by (induct l r rule: merge.induct; simp)"], ["", "lemma mset_tree_merge[simp]:\n  \"mset_tree (merge l r) = mset_tree l + mset_tree r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_tree (merge l r) = mset_tree l + mset_tree r", "by (induct l r rule: merge.induct; simp)"], ["", "lemma merge_heap:\n  \"heap l \\<Longrightarrow> heap r \\<Longrightarrow> heap (merge l r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap l; heap r\\<rbrakk> \\<Longrightarrow> heap (merge l r)", "by (induct l r rule: merge.induct; auto simp: ball_Un)"], ["", "lemma set_list_of_A[simp]:\n  \"set (list_of_A t) = set_tree t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (list_of_A t) = set_tree t", "by (induct t rule: list_of_A.induct; simp)"], ["", "lemma mset_list_of_A[simp]:\n  \"mset (list_of_A t) = mset_tree t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (list_of_A t) = mset_tree t", "by (induct t rule: list_of_A.induct; simp)"], ["", "lemma sorted_list_of_A:\n  \"heap t \\<Longrightarrow> sorted (list_of_A t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap t \\<Longrightarrow> sorted (list_of_A t)", "by (induct t rule: list_of_A.induct; simp add: merge_heap)"], ["", "lemma sortedA: \"sorted (list_of_A (heap_of_A xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (list_of_A (heap_of_A xs))", "by (simp add: heap_heap_of_A sorted_list_of_A)"], ["", "lemma msetA: \"mset (list_of_A (heap_of_A xs)) = mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (list_of_A (heap_of_A xs)) = mset xs", "by (simp add: mset_tree_heap_of_A)"], ["", "text\\<open>Does \\<open>list_of_A\\<close> take time $O(n lg n)$? Although \\<open>merge\\<close> does not preserve \\<open>braun\\<close>,\nit cannot increase the height of the heap.\\<close>"], ["", "lemma merge_height:\n  \"height (merge l r) \\<le>  Suc (max (height l) (height r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height (merge l r) \\<le> Suc (max (height l) (height r))", "by (induct rule: merge.induct, auto)"], ["", "corollary merge_height_display:\n  \"height (merge l r) \\<le> height (Node l x r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height (merge l r) \\<le> height \\<langle>l, x, r\\<rangle>", "using merge_height"], ["proof (prove)\nusing this:\n  height (merge ?l ?r) \\<le> Suc (max (height ?l) (height ?r))\n\ngoal (1 subgoal):\n 1. height (merge l r) \\<le> height \\<langle>l, x, r\\<rangle>", "by simp"], ["", "fun t_merge :: \"('a::linorder) tree \\<Rightarrow> 'a tree \\<Rightarrow> nat\" where\n\"t_merge Leaf t2 = 0\" |\n\"t_merge t1 Leaf = 0\" |\n\"t_merge (Node l1 a1 r1) (Node l2 a2 r2) =\n   (if a1 \\<le> a2 then 1 + t_merge l1 r1\n    else 1 + t_merge l2 r2)\""], ["", "fun t_list_of_A :: \"('a::linorder) tree \\<Rightarrow> nat\" where\n\"t_list_of_A Leaf = 0\" |\n\"t_list_of_A (Node l a r) = 1 + t_merge l r + t_list_of_A (merge l r)\""], ["", "lemma t_merge_height:\n  \"t_merge l r \\<le> max (height l) (height r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_merge l r \\<le> max (height l) (height r)", "by (induct rule: t_merge.induct, auto)"], ["", "lemma t_list_of_A_induct:\n  \"height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height t \\<le> n \\<Longrightarrow> t_list_of_A t \\<le> 2 * n * size t", "apply (induct rule: t_list_of_A.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. height \\<langle>\\<rangle> \\<le> n \\<Longrightarrow>\n    t_list_of_A \\<langle>\\<rangle> \\<le> 2 * n * size \\<langle>\\<rangle>\n 2. \\<And>l a r.\n       \\<lbrakk>height (merge l r) \\<le> n \\<Longrightarrow>\n                t_list_of_A (merge l r) \\<le> 2 * n * size (merge l r);\n        height \\<langle>l, a, r\\<rangle> \\<le> n\\<rbrakk>\n       \\<Longrightarrow> t_list_of_A \\<langle>l, a, r\\<rangle>\n                         \\<le> 2 * n * size \\<langle>l, a, r\\<rangle>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l a r.\n       \\<lbrakk>height (merge l r) \\<le> n \\<Longrightarrow>\n                t_list_of_A (merge l r) \\<le> 2 * n * size (merge l r);\n        height \\<langle>l, a, r\\<rangle> \\<le> n\\<rbrakk>\n       \\<Longrightarrow> t_list_of_A \\<langle>l, a, r\\<rangle>\n                         \\<le> 2 * n * size \\<langle>l, a, r\\<rangle>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<lbrakk>height (merge l r) \\<le> n \\<Longrightarrow>\n                t_list_of_A (merge l r) \\<le> 2 * n * size (merge l r);\n        Suc (max (height l) (height r)) \\<le> n\\<rbrakk>\n       \\<Longrightarrow> Suc (t_merge l r + t_list_of_A (merge l r))\n                         \\<le> 2 * n + 2 * n * (size l + size r)", "apply (drule meta_mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l r.\n       Suc (max (height l) (height r)) \\<le> n \\<Longrightarrow>\n       height (merge l r) \\<le> n\n 2. \\<And>l r.\n       \\<lbrakk>Suc (max (height l) (height r)) \\<le> n;\n        t_list_of_A (merge l r) \\<le> 2 * n * size (merge l r)\\<rbrakk>\n       \\<Longrightarrow> Suc (t_merge l r + t_list_of_A (merge l r))\n                         \\<le> 2 * n + 2 * n * (size l + size r)", "apply (rule order_trans, rule merge_height)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l r.\n       Suc (max (height l) (height r)) \\<le> n \\<Longrightarrow>\n       Suc (max (height l) (height r)) \\<le> n\n 2. \\<And>l r.\n       \\<lbrakk>Suc (max (height l) (height r)) \\<le> n;\n        t_list_of_A (merge l r) \\<le> 2 * n * size (merge l r)\\<rbrakk>\n       \\<Longrightarrow> Suc (t_merge l r + t_list_of_A (merge l r))\n                         \\<le> 2 * n + 2 * n * (size l + size r)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<lbrakk>Suc (max (height l) (height r)) \\<le> n;\n        t_list_of_A (merge l r) \\<le> 2 * n * size (merge l r)\\<rbrakk>\n       \\<Longrightarrow> Suc (t_merge l r + t_list_of_A (merge l r))\n                         \\<le> 2 * n + 2 * n * (size l + size r)", "apply (simp add: merge_size)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<lbrakk>Suc (max (height l) (height r)) \\<le> n;\n        t_list_of_A (merge l r) \\<le> 2 * n * (size l + size r)\\<rbrakk>\n       \\<Longrightarrow> Suc (t_merge l r + t_list_of_A (merge l r))\n                         \\<le> 2 * n + 2 * n * (size l + size r)", "apply (cut_tac l=l and r=r in t_merge_height)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l r.\n       \\<lbrakk>Suc (max (height l) (height r)) \\<le> n;\n        t_list_of_A (merge l r) \\<le> 2 * n * (size l + size r);\n        t_merge l r \\<le> max (height l) (height r)\\<rbrakk>\n       \\<Longrightarrow> Suc (t_merge l r + t_list_of_A (merge l r))\n                         \\<le> 2 * n + 2 * n * (size l + size r)", "apply linarith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma t_list_of_A_bound:\n  \"t_list_of_A t \\<le> 2 * height t * size t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_list_of_A t \\<le> 2 * height t * size t", "by (rule t_list_of_A_induct, simp)"], ["", "lemma t_list_of_A_log_bound:\n  \"braun t \\<Longrightarrow> t_list_of_A t \\<le> 2 * nlog2 (size t + 1) * size t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun t \\<Longrightarrow>\n    t_list_of_A t\n    \\<le> 2 * nat \\<lceil>log 2 (real (size t + 1))\\<rceil> * size t", "using t_list_of_A_bound[of t]"], ["proof (prove)\nusing this:\n  t_list_of_A t \\<le> 2 * height t * size t\n\ngoal (1 subgoal):\n 1. braun t \\<Longrightarrow>\n    t_list_of_A t\n    \\<le> 2 * nat \\<lceil>log 2 (real (size t + 1))\\<rceil> * size t", "by (simp add: height_acomplete acomplete_if_braun size1_size)"], ["", "value \"t_list_of_A (heap_of_A shuffle100)\""], ["", "theorem t_sortA:\n  \"t_heap_of_A xs + t_list_of_A (heap_of_A xs) \\<le> 3 * length xs * (nlog2 (length xs + 1) + 1)\"\n  (is \"?lhs \\<le> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "have \"?lhs \\<le> ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n    \\<le> t_heap_of_A xs + t_list_of_A (heap_of_A xs)", "by simp"], ["proof (state)\nthis:\n  t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n  \\<le> t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n\ngoal (1 subgoal):\n 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "also"], ["proof (state)\nthis:\n  t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n  \\<le> t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n\ngoal (1 subgoal):\n 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "note t_heap_of_A_log_bound[of xs]"], ["proof (state)\nthis:\n  t_heap_of_A xs\n  \\<le> length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)\n\ngoal (1 subgoal):\n 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "also"], ["proof (state)\nthis:\n  t_heap_of_A xs\n  \\<le> length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)\n\ngoal (1 subgoal):\n 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "note t_list_of_A_log_bound[of \"heap_of_A xs\", OF braun_heap_of_A]"], ["proof (state)\nthis:\n  t_list_of_A (heap_of_A xs)\n  \\<le> 2 * nat \\<lceil>log 2 (real (size (heap_of_A xs) + 1))\\<rceil> *\n        size (heap_of_A xs)\n\ngoal (1 subgoal):\n 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + t_list_of_A (heap_of_A xs)\n              \\<le> y + t_list_of_A (heap_of_A xs);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1) + x\n      \\<le> length xs *\n            (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1) +\n            y\\<rbrakk>\n  \\<Longrightarrow> t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n                    \\<le> length xs *\n                          (nat \\<lceil>log 2\n  (real (length xs + 1))\\<rceil> +\n                           1) +\n                          2 *\n                          nat \\<lceil>log 2\n (real (size (heap_of_A xs) + 1))\\<rceil> *\n                          size (heap_of_A xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + t_list_of_A (heap_of_A xs)\n              \\<le> y + t_list_of_A (heap_of_A xs);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      length xs * (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1) + x\n      \\<le> length xs *\n            (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1) +\n            y\\<rbrakk>\n  \\<Longrightarrow> t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n                    \\<le> length xs *\n                          (nat \\<lceil>log 2\n  (real (length xs + 1))\\<rceil> +\n                           1) +\n                          2 *\n                          nat \\<lceil>log 2\n (real (size (heap_of_A xs) + 1))\\<rceil> *\n                          size (heap_of_A xs)\n\ngoal (1 subgoal):\n 1. t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)", "by (simp add: size_heap_of_A)"], ["proof (state)\nthis:\n  t_heap_of_A xs + t_list_of_A (heap_of_A xs)\n  \\<le> 3 * length xs *\n        (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Running time of algorithm B:\\<close>"], ["", "(* Unfortunately this can only be proven to terminate conditionally.\n   To make it unconditional would require a total specification of\n   sift_down, which would be complex and differ substantially from\n   Paulson's presentation.  *)"], ["", "function list_of_B :: \"('a::linorder) tree \\<Rightarrow> 'a list\" where\n\"list_of_B Leaf = []\" |\n\"list_of_B (Node l a r) = a # list_of_B (del_min (Node l a r))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = \\<langle>\\<rangle> \\<Longrightarrow> P;\n        \\<And>l a r.\n           x = \\<langle>l, a, r\\<rangle> \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<langle>\\<rangle> = \\<langle>\\<rangle> \\<Longrightarrow> [] = []\n 3. \\<And>l a r.\n       \\<langle>\\<rangle> = \\<langle>l, a, r\\<rangle> \\<Longrightarrow>\n       [] = a # list_of_B_sumC (del_min \\<langle>l, a, r\\<rangle>)\n 4. \\<And>l a r la aa ra.\n       \\<langle>l, a, r\\<rangle> =\n       \\<langle>la, aa, ra\\<rangle> \\<Longrightarrow>\n       a # list_of_B_sumC (del_min \\<langle>l, a, r\\<rangle>) =\n       aa # list_of_B_sumC (del_min \\<langle>la, aa, ra\\<rangle>)", "by pat_completeness auto"], ["", "lemma list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> list_of_B_dom t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun t \\<Longrightarrow> list_of_B_dom t", "apply (induct t rule: measure_induct[where f=size])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   size y < size x \\<longrightarrow>\n                   braun y \\<longrightarrow> list_of_B_dom y;\n        braun x\\<rbrakk>\n       \\<Longrightarrow> list_of_B_dom x", "apply (rule accpI, erule list_of_B_rel.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y l a r.\n       \\<lbrakk>\\<forall>y.\n                   size y < size x \\<longrightarrow>\n                   braun y \\<longrightarrow> list_of_B_dom y;\n        braun x; y = del_min \\<langle>l, a, r\\<rangle>;\n        x = \\<langle>l, a, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> list_of_B_dom y", "apply (clarsimp simp: size_del_min braun_del_min)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas list_of_B_braun_simps\n    = list_of_B.psimps[OF list_of_B_braun_ptermination]"], ["", "lemma mset_list_of_B:\n  \"braun t \\<Longrightarrow> mset (list_of_B t) = mset_tree t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun t \\<Longrightarrow> mset (list_of_B t) = mset_tree t", "apply (induct t rule: measure_induct[where f=size])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   size y < size x \\<longrightarrow>\n                   braun y \\<longrightarrow>\n                   mset (list_of_B y) = mset_tree y;\n        braun x\\<rbrakk>\n       \\<Longrightarrow> mset (list_of_B x) = mset_tree x", "apply (case_tac x; simp add: list_of_B_braun_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x21 x22 x23.\n       \\<lbrakk>\\<forall>y.\n                   size y < Suc (size x21 + size x23) \\<longrightarrow>\n                   braun y \\<longrightarrow>\n                   mset (list_of_B y) = mset_tree y;\n        (size x21 = size x23 \\<or> size x21 = Suc (size x23)) \\<and>\n        braun x21 \\<and> braun x23;\n        x = \\<langle>x21, x22, x23\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> mset\n                          (list_of_B\n                            (del_min \\<langle>x21, x22, x23\\<rangle>)) =\n                         mset_tree x21 + mset_tree x23", "apply (simp add: size_del_min braun_del_min mset_del_min)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_list_of_B:\n  \"braun t \\<Longrightarrow> set (list_of_B t) = set_tree t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun t \\<Longrightarrow> set (list_of_B t) = set_tree t", "by (simp only: set_mset_mset[symmetric] mset_list_of_B, simp)"], ["", "lemma sorted_list_of_B:\n  \"braun t \\<Longrightarrow> heap t \\<Longrightarrow> sorted (list_of_B t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>braun t; heap t\\<rbrakk> \\<Longrightarrow> sorted (list_of_B t)", "apply (induct t rule: measure_induct[where f=size])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   size y < size x \\<longrightarrow>\n                   braun y \\<longrightarrow>\n                   heap y \\<longrightarrow> sorted (list_of_B y);\n        braun x; heap x\\<rbrakk>\n       \\<Longrightarrow> sorted (list_of_B x)", "apply (case_tac x; simp add: list_of_B_braun_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x21 x22 x23.\n       \\<lbrakk>\\<forall>y.\n                   size y < Suc (size x21 + size x23) \\<longrightarrow>\n                   braun y \\<longrightarrow>\n                   heap y \\<longrightarrow> sorted (list_of_B y);\n        (size x21 = size x23 \\<or> size x21 = Suc (size x23)) \\<and>\n        braun x21 \\<and> braun x23;\n        (\\<forall>x\\<in>set_tree x21 \\<union> set_tree x23.\n            x22 \\<le> x) \\<and>\n        heap x21 \\<and> heap x23;\n        x = \\<langle>x21, x22, x23\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>set\n    (list_of_B (del_min \\<langle>x21, x22, x23\\<rangle>)).\n                             x22 \\<le> x) \\<and>\n                         sorted\n                          (list_of_B\n                            (del_min \\<langle>x21, x22, x23\\<rangle>))", "apply (clarsimp simp: set_list_of_B braun_del_min size_del_min heap_del_min)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23 xa.\n       \\<lbrakk>\\<forall>y.\n                   size y < Suc (size x21 + size x23) \\<longrightarrow>\n                   braun y \\<longrightarrow>\n                   heap y \\<longrightarrow> sorted (list_of_B y);\n        xa \\<in> set_tree (del_min \\<langle>x21, x22, x23\\<rangle>);\n        size x21 = size x23 \\<or> size x21 = Suc (size x23);\n        \\<forall>x\\<in>set_tree x21 \\<union> set_tree x23. x22 \\<le> x;\n        braun x21; braun x23; heap x21; heap x23\\<rbrakk>\n       \\<Longrightarrow> x22 \\<le> xa", "apply (simp add: set_mset_tree[symmetric] mset_del_min del: set_mset_tree)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition\n  \"heap_of_B xs = fst (heapify (length xs) xs)\""], ["", "lemma sortedB: \"sorted (list_of_B (heap_of_B xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (list_of_B (heap_of_B xs))", "by (simp add: heap_of_B_def braun_heapify heap_heapify sorted_list_of_B)"], ["", "lemma msetB: \"mset (list_of_B (heap_of_B xs)) = mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (list_of_B (heap_of_B xs)) = mset xs", "by (simp add: heap_of_B_def braun_heapify mset_heapify mset_list_of_B)"], ["", "fun t_del_left :: \"'a tree \\<Rightarrow> nat\" where\n\"t_del_left (Node Leaf x r) = 1\" |\n\"t_del_left (Node l x r) = (let (y,l') = del_left l in 2 + t_del_left l)\""], ["", "fun t_del_min :: \"'a::linorder tree \\<Rightarrow> nat\" where\n\"t_del_min Leaf = 0\" |\n\"t_del_min (Node Leaf x r) = 0\" |\n\"t_del_min (Node l x r) = (let (y,l') = del_left l in t_del_left l + t_sift_down r y l')\""], ["", "function t_list_of_B :: \"('a::linorder) tree \\<Rightarrow> nat\" where\n\"t_list_of_B Leaf = 0\" |\n\"t_list_of_B (Node l a r) = 1 + t_del_min (Node l a r) + t_list_of_B (del_min (Node l a r))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = \\<langle>\\<rangle> \\<Longrightarrow> P;\n        \\<And>l a r.\n           x = \\<langle>l, a, r\\<rangle> \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<langle>\\<rangle> = \\<langle>\\<rangle> \\<Longrightarrow> 0 = 0\n 3. \\<And>l a r.\n       \\<langle>\\<rangle> = \\<langle>l, a, r\\<rangle> \\<Longrightarrow>\n       0 =\n       1 + t_del_min \\<langle>l, a, r\\<rangle> +\n       t_list_of_B_sumC (del_min \\<langle>l, a, r\\<rangle>)\n 4. \\<And>l a r la aa ra.\n       \\<langle>l, a, r\\<rangle> =\n       \\<langle>la, aa, ra\\<rangle> \\<Longrightarrow>\n       1 + t_del_min \\<langle>l, a, r\\<rangle> +\n       t_list_of_B_sumC (del_min \\<langle>l, a, r\\<rangle>) =\n       1 + t_del_min \\<langle>la, aa, ra\\<rangle> +\n       t_list_of_B_sumC (del_min \\<langle>la, aa, ra\\<rangle>)", "by pat_completeness auto"], ["", "lemma t_del_left_bound:\n  \"t \\<noteq> Leaf \\<Longrightarrow> t_del_left t \\<le> 2 * height t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    t_del_left t \\<le> 2 * height t", "apply (induct rule: t_del_left.induct; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb r.\n       (\\<And>a b xb y.\n           \\<lbrakk>(a, b) = del_left \\<langle>v, va, vb\\<rangle>;\n            (xb, y) = del_left \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n           \\<Longrightarrow> t_del_left \\<langle>v, va, vb\\<rangle>\n                             \\<le> Suc (Suc\n   (2 * max (height v) (height vb)))) \\<Longrightarrow>\n       t_del_left \\<langle>v, va, vb\\<rangle>\n       \\<le> 2 * max (Suc (max (height v) (height vb))) (height r)", "apply (atomize(full); clarsimp simp: prod_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb r.\n       t_del_left \\<langle>v, va, vb\\<rangle>\n       \\<le> Suc (Suc (2 * max (height v) (height vb))) \\<Longrightarrow>\n       t_del_left \\<langle>v, va, vb\\<rangle>\n       \\<le> 2 * max (Suc (max (height v) (height vb))) (height r)", "apply (simp add: nat_mult_max_right le_max_iff_disj)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma del_left_height:\n  \"del_left t = (v, t') \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> height t' \\<le> height t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>del_left t = (v, t'); t \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> height t' \\<le> height t", "apply (induct t arbitrary: v t' rule: del_left.induct; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r vc t'.\n       \\<lbrakk>\\<And>vaa t'.\n                   del_left \\<langle>v, va, vb\\<rangle> =\n                   (vaa, t') \\<Longrightarrow>\n                   height t' \\<le> Suc (max (height v) (height vb));\n        (case del_left \\<langle>v, va, vb\\<rangle> of\n         (y, l') \\<Rightarrow> (y, \\<langle>r, x, l'\\<rangle>)) =\n        (vc, t')\\<rbrakk>\n       \\<Longrightarrow> height t'\n                         \\<le> Suc (max (Suc (max (height v) (height vb)))\n                                     (height r))", "apply (atomize(full), clarsimp split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb r x1 x2.\n       \\<lbrakk>height x2 \\<le> Suc (max (height v) (height vb));\n        del_left \\<langle>v, va, vb\\<rangle> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> height x2\n                         \\<le> max (Suc (max (height v) (height vb)))\n                                (height r)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma t_del_min_bound:\n  \"braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun t \\<Longrightarrow> t_del_min t \\<le> 3 * height t", "apply (cases t rule: t_del_min.cases; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r.\n       \\<lbrakk>(Suc (size v + size vb) = size r \\<or>\n                 size v + size vb = size r) \\<and>\n                (size v = size vb \\<or> size v = Suc (size vb)) \\<and>\n                braun v \\<and> braun vb \\<and> braun r;\n        t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> (case del_left \\<langle>v, va, vb\\<rangle> of\n                          (y, l') \\<Rightarrow>\n                            t_del_left \\<langle>v, va, vb\\<rangle> +\n                            t_sift_down r y l')\n                         \\<le> 3 +\n                               3 *\n                               max (Suc (max (height v) (height vb)))\n                                (height r)", "apply (clarsimp split: prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size v + size vb) = size r \\<or> size v + size vb = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> t_del_left \\<langle>v, va, vb\\<rangle> +\n                         t_sift_down r x1 x2\n                         \\<le> 3 +\n                               3 *\n                               max (Suc (max (height v) (height vb)))\n                                (height r)", "apply (frule del_left_braun, simp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size v + size vb) = size r \\<or> size v + size vb = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2);\n        braun x2\\<rbrakk>\n       \\<Longrightarrow> t_del_left \\<langle>v, va, vb\\<rangle> +\n                         t_sift_down r x1 x2\n                         \\<le> 3 +\n                               3 *\n                               max (Suc (max (height v) (height vb)))\n                                (height r)", "apply (frule del_left_size, simp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size x2) = size r \\<or> size x2 = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2;\n        size v + size vb = size x2\\<rbrakk>\n       \\<Longrightarrow> t_del_left \\<langle>v, va, vb\\<rangle> +\n                         t_sift_down r x1 x2\n                         \\<le> 3 +\n                               3 *\n                               max (Suc (max (height v) (height vb)))\n                                (height r)", "apply (frule del_left_height, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size x2) = size r \\<or> size x2 = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2;\n        size v + size vb = size x2;\n        height x2 \\<le> height \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> t_del_left \\<langle>v, va, vb\\<rangle> +\n                         t_sift_down r x1 x2\n                         \\<le> 3 +\n                               3 *\n                               max (Suc (max (height v) (height vb)))\n                                (height r)", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size x2) = size r \\<or> size x2 = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2;\n        size v + size vb = size x2;\n        height x2 \\<le> height \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> t_del_left \\<langle>v, va, vb\\<rangle> +\n                         t_sift_down r x1 x2\n                         \\<le> ?y30 v va vb x r x1 x2\n 2. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size x2) = size r \\<or> size x2 = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2;\n        size v + size vb = size x2;\n        height x2 \\<le> height \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> ?y30 v va vb x r x1 x2\n                         \\<le> 3 +\n                               3 *\n                               max (Suc (max (height v) (height vb)))\n                                (height r)", "apply ((rule add_le_mono t_del_left_bound t_sift_down_height | simp)+)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size x2) = size r \\<or> size x2 = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2;\n        size v + size vb = size x2;\n        height x2 \\<le> Suc (max (height v) (height vb))\\<rbrakk>\n       \\<Longrightarrow> size r = size x2 \\<or> size r = Suc (size x2)\n 2. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size x2) = size r \\<or> size x2 = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2;\n        size v + size vb = size x2;\n        height x2 \\<le> height \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> 2 * height \\<langle>v, va, vb\\<rangle> +\n                         height \\<langle>r, x1, x2\\<rangle>\n                         \\<le> 3 +\n                               3 *\n                               max (Suc (max (height v) (height vb)))\n                                (height r)", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size x2) = size r \\<or> size x2 = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2;\n        size v + size vb = size x2;\n        height x2 \\<le> height \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> 2 * height \\<langle>v, va, vb\\<rangle> +\n                         height \\<langle>r, x1, x2\\<rangle>\n                         \\<le> 3 +\n                               3 *\n                               max (Suc (max (height v) (height vb)))\n                                (height r)", "apply (simp add: max_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma t_list_of_B_braun_ptermination:\n  \"braun t \\<Longrightarrow> t_list_of_B_dom t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun t \\<Longrightarrow> t_list_of_B_dom t", "apply (induct t rule: measure_induct[where f=size])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   size y < size x \\<longrightarrow>\n                   braun y \\<longrightarrow> t_list_of_B_dom y;\n        braun x\\<rbrakk>\n       \\<Longrightarrow> t_list_of_B_dom x", "apply (rule accpI, erule t_list_of_B_rel.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y l a r.\n       \\<lbrakk>\\<forall>y.\n                   size y < size x \\<longrightarrow>\n                   braun y \\<longrightarrow> t_list_of_B_dom y;\n        braun x; y = del_min \\<langle>l, a, r\\<rangle>;\n        x = \\<langle>l, a, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> t_list_of_B_dom y", "apply (clarsimp simp: size_del_min braun_del_min)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas t_list_of_B_braun_simps\n    = t_list_of_B.psimps[OF t_list_of_B_braun_ptermination]"], ["", "lemma del_min_height:\n  \"braun t \\<Longrightarrow> height (del_min t) \\<le> height t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun t \\<Longrightarrow> height (del_min t) \\<le> height t", "apply (cases t rule: del_min.cases; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r.\n       \\<lbrakk>(Suc (size v + size vb) = size r \\<or>\n                 size v + size vb = size r) \\<and>\n                (size v = size vb \\<or> size v = Suc (size vb)) \\<and>\n                braun v \\<and> braun vb \\<and> braun r;\n        t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> height\n                          (case del_left \\<langle>v, va, vb\\<rangle> of\n                           (x, xa) \\<Rightarrow> sift_down r x xa)\n                         \\<le> Suc (max (Suc (max (height v) (height vb)))\n                                     (height r))", "apply (clarsimp split: prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size v + size vb) = size r \\<or> size v + size vb = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> height (sift_down r x1 x2)\n                         \\<le> Suc (max (Suc (max (height v) (height vb)))\n                                     (height r))", "apply (frule del_left_braun, simp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size v + size vb) = size r \\<or> size v + size vb = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2);\n        braun x2\\<rbrakk>\n       \\<Longrightarrow> height (sift_down r x1 x2)\n                         \\<le> Suc (max (Suc (max (height v) (height vb)))\n                                     (height r))", "apply (frule del_left_size, simp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size x2) = size r \\<or> size x2 = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; del_left \\<langle>v, va, vb\\<rangle> = (x1, x2); braun x2;\n        size v + size vb = size x2\\<rbrakk>\n       \\<Longrightarrow> height (sift_down r x1 x2)\n                         \\<le> Suc (max (Suc (max (height v) (height vb)))\n                                     (height r))", "apply (drule del_left_height)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size x2) = size r \\<or> size x2 = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; braun x2; size v + size vb = size x2\\<rbrakk>\n       \\<Longrightarrow> \\<langle>v, va, vb\\<rangle> \\<noteq>\n                         \\<langle>\\<rangle>\n 2. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size x2) = size r \\<or> size x2 = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; braun x2; size v + size vb = size x2;\n        height x2 \\<le> height \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> height (sift_down r x1 x2)\n                         \\<le> Suc (max (Suc (max (height v) (height vb)))\n                                     (height r))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v va vb x r x1 x2.\n       \\<lbrakk>t = \\<langle>\\<langle>v, va, vb\\<rangle>, x, r\\<rangle>;\n        Suc (size x2) = size r \\<or> size x2 = size r;\n        size v = size vb \\<or> size v = Suc (size vb); braun v; braun vb;\n        braun r; braun x2; size v + size vb = size x2;\n        height x2 \\<le> height \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> height (sift_down r x1 x2)\n                         \\<le> Suc (max (Suc (max (height v) (height vb)))\n                                     (height r))", "apply (rule order_trans, rule sift_down_height, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma t_list_of_B_induct:\n  \"braun t \\<Longrightarrow> height t \\<le> n \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>braun t; height t \\<le> n\\<rbrakk>\n    \\<Longrightarrow> t_list_of_B t \\<le> 3 * (n + 1) * size t", "apply (induct t rule: measure_induct[where f=size])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>y.\n                   size y < size x \\<longrightarrow>\n                   braun y \\<longrightarrow>\n                   height y \\<le> n \\<longrightarrow>\n                   t_list_of_B y \\<le> 3 * (n + 1) * size y;\n        braun x; height x \\<le> n\\<rbrakk>\n       \\<Longrightarrow> t_list_of_B x \\<le> 3 * (n + 1) * size x", "apply (drule_tac x=\"del_min x\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>braun x; height x \\<le> n;\n        size (del_min x) < size x \\<longrightarrow>\n        braun (del_min x) \\<longrightarrow>\n        height (del_min x) \\<le> n \\<longrightarrow>\n        t_list_of_B (del_min x)\n        \\<le> 3 * (n + 1) * size (del_min x)\\<rbrakk>\n       \\<Longrightarrow> t_list_of_B x \\<le> 3 * (n + 1) * size x", "apply (frule del_min_height)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>braun x; height x \\<le> n;\n        size (del_min x) < size x \\<longrightarrow>\n        braun (del_min x) \\<longrightarrow>\n        height (del_min x) \\<le> n \\<longrightarrow>\n        t_list_of_B (del_min x) \\<le> 3 * (n + 1) * size (del_min x);\n        height (del_min x) \\<le> height x\\<rbrakk>\n       \\<Longrightarrow> t_list_of_B x \\<le> 3 * (n + 1) * size x", "apply (case_tac x; simp add: t_list_of_B_braun_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x21 x22 x23.\n       \\<lbrakk>(size x21 = size x23 \\<or> size x21 = Suc (size x23)) \\<and>\n                braun x21 \\<and> braun x23;\n        Suc (max (height x21) (height x23)) \\<le> n;\n        size (del_min \\<langle>x21, x22, x23\\<rangle>)\n        < Suc (size x21 + size x23) \\<longrightarrow>\n        braun (del_min \\<langle>x21, x22, x23\\<rangle>) \\<longrightarrow>\n        t_list_of_B (del_min \\<langle>x21, x22, x23\\<rangle>)\n        \\<le> (3 + 3 * n) * size (del_min \\<langle>x21, x22, x23\\<rangle>);\n        height (del_min \\<langle>x21, x22, x23\\<rangle>)\n        \\<le> Suc (max (height x21) (height x23));\n        x = \\<langle>x21, x22, x23\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> t_del_min \\<langle>x21, x22, x23\\<rangle> +\n                         t_list_of_B\n                          (del_min \\<langle>x21, x22, x23\\<rangle>)\n                         \\<le> Suc (Suc (3 * n +\n   (3 + 3 * n) * (size x21 + size x23)))", "apply (rename_tac l x' r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x l x' r.\n       \\<lbrakk>(size l = size r \\<or> size l = Suc (size r)) \\<and>\n                braun l \\<and> braun r;\n        Suc (max (height l) (height r)) \\<le> n;\n        size (del_min \\<langle>l, x', r\\<rangle>)\n        < Suc (size l + size r) \\<longrightarrow>\n        braun (del_min \\<langle>l, x', r\\<rangle>) \\<longrightarrow>\n        t_list_of_B (del_min \\<langle>l, x', r\\<rangle>)\n        \\<le> (3 + 3 * n) * size (del_min \\<langle>l, x', r\\<rangle>);\n        height (del_min \\<langle>l, x', r\\<rangle>)\n        \\<le> Suc (max (height l) (height r));\n        x = \\<langle>l, x', r\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> t_del_min \\<langle>l, x', r\\<rangle> +\n                         t_list_of_B (del_min \\<langle>l, x', r\\<rangle>)\n                         \\<le> Suc (Suc (3 * n +\n   (3 + 3 * n) * (size l + size r)))", "apply (clarsimp simp: braun_del_min size_del_min)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l x' r.\n       \\<lbrakk>Suc (max (height l) (height r)) \\<le> n;\n        t_list_of_B (del_min \\<langle>l, x', r\\<rangle>)\n        \\<le> (3 + 3 * n) * (size l + size r);\n        height (del_min \\<langle>l, x', r\\<rangle>)\n        \\<le> Suc (max (height l) (height r));\n        size l = size r \\<or> size l = Suc (size r); braun l;\n        braun r\\<rbrakk>\n       \\<Longrightarrow> t_del_min \\<langle>l, x', r\\<rangle> +\n                         t_list_of_B (del_min \\<langle>l, x', r\\<rangle>)\n                         \\<le> Suc (Suc (3 * n +\n   (3 + 3 * n) * (size l + size r)))", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l x' r.\n       \\<lbrakk>Suc (max (height l) (height r)) \\<le> n;\n        t_list_of_B (del_min \\<langle>l, x', r\\<rangle>)\n        \\<le> (3 + 3 * n) * (size l + size r);\n        height (del_min \\<langle>l, x', r\\<rangle>)\n        \\<le> Suc (max (height l) (height r));\n        size l = size r \\<or> size l = Suc (size r); braun l;\n        braun r\\<rbrakk>\n       \\<Longrightarrow> t_del_min \\<langle>l, x', r\\<rangle> +\n                         t_list_of_B (del_min \\<langle>l, x', r\\<rangle>)\n                         \\<le> ?y21 l x' r\n 2. \\<And>l x' r.\n       \\<lbrakk>Suc (max (height l) (height r)) \\<le> n;\n        t_list_of_B (del_min \\<langle>l, x', r\\<rangle>)\n        \\<le> (3 + 3 * n) * (size l + size r);\n        height (del_min \\<langle>l, x', r\\<rangle>)\n        \\<le> Suc (max (height l) (height r));\n        size l = size r \\<or> size l = Suc (size r); braun l;\n        braun r\\<rbrakk>\n       \\<Longrightarrow> ?y21 l x' r\n                         \\<le> Suc (Suc (3 * n +\n   (3 + 3 * n) * (size l + size r)))", "apply ((rule add_le_mono t_del_min_bound | assumption | simp)+)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l x' r.\n       \\<lbrakk>Suc (max (height l) (height r)) \\<le> n;\n        t_list_of_B (del_min \\<langle>l, x', r\\<rangle>)\n        \\<le> (3 + 3 * n) * (size l + size r);\n        height (del_min \\<langle>l, x', r\\<rangle>)\n        \\<le> Suc (max (height l) (height r));\n        size l = size r \\<or> size l = Suc (size r); braun l;\n        braun r\\<rbrakk>\n       \\<Longrightarrow> 3 * height \\<langle>l, x', r\\<rangle> +\n                         (3 + 3 * n) * (size l + size r)\n                         \\<le> Suc (Suc (3 * n +\n   (3 + 3 * n) * (size l + size r)))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma t_list_of_B_bound:\n  \"braun t \\<Longrightarrow> t_list_of_B t \\<le> 3 * (height t + 1) * size t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun t \\<Longrightarrow>\n    t_list_of_B t \\<le> 3 * (height t + 1) * size t", "by (erule t_list_of_B_induct, simp)"], ["", "lemma t_list_of_B_log_bound:\n  \"braun t \\<Longrightarrow> t_list_of_B t \\<le> 3 * (nlog2 (size t + 1) + 1) * size t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun t \\<Longrightarrow>\n    t_list_of_B t\n    \\<le> 3 * (nat \\<lceil>log 2 (real (size t + 1))\\<rceil> + 1) * size t", "apply (frule t_list_of_B_bound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>braun t;\n     t_list_of_B t \\<le> 3 * (height t + 1) * size t\\<rbrakk>\n    \\<Longrightarrow> t_list_of_B t\n                      \\<le> 3 *\n                            (nat \\<lceil>log 2 (real (size t + 1))\\<rceil> +\n                             1) *\n                            size t", "apply (simp add: height_acomplete acomplete_if_braun size1_size)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition\n  \"t_heap_of_B xs = length xs + t_heapify (length xs) xs\""], ["", "lemma t_heap_of_B_bound:\n  \"t_heap_of_B xs \\<le> 6 * length xs + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_heap_of_B xs \\<le> 6 * length xs + 1", "by (simp add: t_heap_of_B_def order_trans[OF t_heapify_bound])"], ["", "lemmas size_heapify = arg_cong[OF mset_heapify, where f=size, simplified]"], ["", "theorem t_sortB:\n  \"t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs * (nlog2 (length xs + 1) + 3) + 1\"\n  (is \"?lhs \\<le> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) +\n          1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) +\n          1", "have \"?lhs \\<le> ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> t_heap_of_B xs + t_list_of_B (heap_of_B xs)", "by simp"], ["proof (state)\nthis:\n  t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n  \\<le> t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n\ngoal (1 subgoal):\n 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) +\n          1", "also"], ["proof (state)\nthis:\n  t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n  \\<le> t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n\ngoal (1 subgoal):\n 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) +\n          1", "note t_heap_of_B_bound[of xs]"], ["proof (state)\nthis:\n  t_heap_of_B xs \\<le> 6 * length xs + 1\n\ngoal (1 subgoal):\n 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) +\n          1", "also"], ["proof (state)\nthis:\n  t_heap_of_B xs \\<le> 6 * length xs + 1\n\ngoal (1 subgoal):\n 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) +\n          1", "note t_list_of_B_log_bound[of \"heap_of_B xs\"]"], ["proof (state)\nthis:\n  braun (heap_of_B xs) \\<Longrightarrow>\n  t_list_of_B (heap_of_B xs)\n  \\<le> 3 *\n        (nat \\<lceil>log 2 (real (size (heap_of_B xs) + 1))\\<rceil> + 1) *\n        size (heap_of_B xs)\n\ngoal (1 subgoal):\n 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) +\n          1", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + t_list_of_B (heap_of_B xs)\n              \\<le> y + t_list_of_B (heap_of_B xs);\n   braun (heap_of_B xs);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      6 * length xs + 1 + x \\<le> 6 * length xs + 1 + y\\<rbrakk>\n  \\<Longrightarrow> t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n                    \\<le> 6 * length xs + 1 +\n                          3 *\n                          (nat \\<lceil>log 2\n  (real (size (heap_of_B xs) + 1))\\<rceil> +\n                           1) *\n                          size (heap_of_B xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + t_list_of_B (heap_of_B xs)\n              \\<le> y + t_list_of_B (heap_of_B xs);\n   braun (heap_of_B xs);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      6 * length xs + 1 + x \\<le> 6 * length xs + 1 + y\\<rbrakk>\n  \\<Longrightarrow> t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n                    \\<le> 6 * length xs + 1 +\n                          3 *\n                          (nat \\<lceil>log 2\n  (real (size (heap_of_B xs) + 1))\\<rceil> +\n                           1) *\n                          size (heap_of_B xs)\n\ngoal (1 subgoal):\n 1. t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n    \\<le> 3 * length xs *\n          (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) +\n          1", "apply (simp add: size_heapify braun_heapify heap_of_B_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. t_heap_of_B xs + t_list_of_B (fst (heapify (length xs) xs))\n    \\<le> Suc (6 * length xs +\n               (3 + 3 * nat \\<lceil>log 2 (1 + real (length xs))\\<rceil>) *\n               length xs) \\<Longrightarrow>\n    t_heap_of_B xs + t_list_of_B (fst (heapify (length xs) xs))\n    \\<le> Suc (3 * length xs *\n               (nat \\<lceil>log 2 (1 + real (length xs))\\<rceil> + 3))", "apply (simp add: field_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  t_heap_of_B xs + t_list_of_B (heap_of_B xs)\n  \\<le> 3 * length xs *\n        (nat \\<lceil>log 2 (real (length xs + 1))\\<rceil> + 3) +\n        1\n\ngoal:\nNo subgoals!", "qed"], ["", "(* One suspects that algorithm A is actually faster, despite being\nalgorithmically slower on the construction of the heap. The operation\nmerge needs to allocate one constructor per level of the heap,\nas opposed to del_min, which needs three, so the extraction is probably\nmuch faster. Not sure how to validate that.\n\nvalue \"t_list_of_B (heap_of\n  [50 :: nat, 7, 77, 15, 42, 82, 87, 68, 69, 29, 43, 24, 84, 12, 35, 30, 95, 45, 14, 47, 54, 66, 96, 71, 98, 4, 22, 0, 92, 86, 34, 33, 57, 91, 20, 13, 64, 73, 70, 8, 85, 40, 16, 18, 81, 99, 63, 41, 56, 72, 79, 48, 78, 52, 25, 49, 65, 90, 26, 76, 3, 59, 74, 58, 46, 38, 61, 94, 75, 11, 88, 31, 53, 17, 44, 89, 39, 93, 62, 5, 1, 21, 6, 55, 83, 28, 37, 60, 19, 67, 23, 97, 51, 10, 27, 32, 2, 36, 9, 80]\n)\"\n *)"], ["", "end"]]}