{"file_name": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun/Priority_Queue_Braun2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Priority_Queue_Braun", "problem_names": ["lemma replace_min_sift_down: \"braun (Node l a r) \\<Longrightarrow> replace_min x (Node l a r) = sift_down l x r\"", "lemma mset_tree_merge:\n  \"braun (Node l x r) \\<Longrightarrow> mset_tree(merge l r) = mset_tree l + mset_tree r\"", "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\"", "lemma del_left_braun_size:\n  \"del_left t = (x,t') \\<Longrightarrow> braun t \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> braun t' \\<and> size t = size t' + 1\"", "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\""], "translations": [["", "lemma replace_min_sift_down: \"braun (Node l a r) \\<Longrightarrow> replace_min x (Node l a r) = sift_down l x r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>l, a, r\\<rangle> \\<Longrightarrow>\n    replace_min x \\<langle>l, a, r\\<rangle> = sift_down l x r", "by(induction l x r rule: sift_down.induct)(auto)"], ["", "text \\<open>This means that @{const del_min2} is merely a slight optimization of @{const del_min}:\ninstead of calling @{const del_left} right away, @{const merge} can take advantage of the case\nwhere the smaller element is at the root of the left heap and can be moved up without complications.\nHowever, on average this is just the case on the first level.\\<close>"], ["", "text \\<open>Function @{const merge}:\\<close>"], ["", "lemma mset_tree_merge:\n  \"braun (Node l x r) \\<Longrightarrow> mset_tree(merge l r) = mset_tree l + mset_tree r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>l, x, r\\<rangle> \\<Longrightarrow>\n    mset_tree (merge l r) = mset_tree l + mset_tree r", "by(induction l r rule: merge.induct)\n  (auto simp: Let_def tree.set_sel(2) mset_sift_down replace_min_sift_down\n        simp del: replace_min.simps dest!: del_left_mset split!: prod.split)"], ["", "lemma heap_merge:\n  \"\\<lbrakk> braun (Node l x r); heap l; heap r \\<rbrakk> \\<Longrightarrow> heap(merge l r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>braun \\<langle>l, x, r\\<rangle>; heap l; heap r\\<rbrakk>\n    \\<Longrightarrow> heap (merge l r)", "proof(induction l r rule: merge.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>braun \\<langle>l, x, \\<langle>\\<rangle>\\<rangle>; heap l;\n        heap \\<langle>\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap (merge l \\<langle>\\<rangle>)\n 2. \\<And>l1 a1 r1 l2 a2 r2.\n       \\<lbrakk>\\<lbrakk>a1 \\<le> a2; braun \\<langle>l1, x, r1\\<rangle>;\n                 heap l1; heap r1\\<rbrakk>\n                \\<Longrightarrow> heap (merge l1 r1);\n        braun\n         \\<langle>\\<langle>l1, a1, r1\\<rangle>, x,\n          \\<langle>l2, a2, r2\\<rangle>\\<rangle>;\n        heap \\<langle>l1, a1, r1\\<rangle>;\n        heap \\<langle>l2, a2, r2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>l1, a1, r1\\<rangle>\n                            \\<langle>l2, a2, r2\\<rangle>)\n 3. \\<And>v va vb.\n       \\<lbrakk>braun\n                 \\<langle>\\<langle>\\<rangle>, x,\n                  \\<langle>v, va, vb\\<rangle>\\<rangle>;\n        heap \\<langle>\\<rangle>; heap \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>\\<rangle>\n                            \\<langle>v, va, vb\\<rangle>)", "case 1"], ["proof (state)\nthis:\n  braun \\<langle>l_, x, \\<langle>\\<rangle>\\<rangle>\n  heap l_\n  heap \\<langle>\\<rangle>\n\ngoal (3 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>braun \\<langle>l, x, \\<langle>\\<rangle>\\<rangle>; heap l;\n        heap \\<langle>\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap (merge l \\<langle>\\<rangle>)\n 2. \\<And>l1 a1 r1 l2 a2 r2.\n       \\<lbrakk>\\<lbrakk>a1 \\<le> a2; braun \\<langle>l1, x, r1\\<rangle>;\n                 heap l1; heap r1\\<rbrakk>\n                \\<Longrightarrow> heap (merge l1 r1);\n        braun\n         \\<langle>\\<langle>l1, a1, r1\\<rangle>, x,\n          \\<langle>l2, a2, r2\\<rangle>\\<rangle>;\n        heap \\<langle>l1, a1, r1\\<rangle>;\n        heap \\<langle>l2, a2, r2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>l1, a1, r1\\<rangle>\n                            \\<langle>l2, a2, r2\\<rangle>)\n 3. \\<And>v va vb.\n       \\<lbrakk>braun\n                 \\<langle>\\<langle>\\<rangle>, x,\n                  \\<langle>v, va, vb\\<rangle>\\<rangle>;\n        heap \\<langle>\\<rangle>; heap \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>\\<rangle>\n                            \\<langle>v, va, vb\\<rangle>)", "thus ?case"], ["proof (prove)\nusing this:\n  braun \\<langle>l_, x, \\<langle>\\<rangle>\\<rangle>\n  heap l_\n  heap \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. heap (merge l_ \\<langle>\\<rangle>)", "by simp"], ["proof (state)\nthis:\n  heap (merge l_ \\<langle>\\<rangle>)\n\ngoal (2 subgoals):\n 1. \\<And>l1 a1 r1 l2 a2 r2.\n       \\<lbrakk>\\<lbrakk>a1 \\<le> a2; braun \\<langle>l1, x, r1\\<rangle>;\n                 heap l1; heap r1\\<rbrakk>\n                \\<Longrightarrow> heap (merge l1 r1);\n        braun\n         \\<langle>\\<langle>l1, a1, r1\\<rangle>, x,\n          \\<langle>l2, a2, r2\\<rangle>\\<rangle>;\n        heap \\<langle>l1, a1, r1\\<rangle>;\n        heap \\<langle>l2, a2, r2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>l1, a1, r1\\<rangle>\n                            \\<langle>l2, a2, r2\\<rangle>)\n 2. \\<And>v va vb.\n       \\<lbrakk>braun\n                 \\<langle>\\<langle>\\<rangle>, x,\n                  \\<langle>v, va, vb\\<rangle>\\<rangle>;\n        heap \\<langle>\\<rangle>; heap \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>\\<rangle>\n                            \\<langle>v, va, vb\\<rangle>)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l1 a1 r1 l2 a2 r2.\n       \\<lbrakk>\\<lbrakk>a1 \\<le> a2; braun \\<langle>l1, x, r1\\<rangle>;\n                 heap l1; heap r1\\<rbrakk>\n                \\<Longrightarrow> heap (merge l1 r1);\n        braun\n         \\<langle>\\<langle>l1, a1, r1\\<rangle>, x,\n          \\<langle>l2, a2, r2\\<rangle>\\<rangle>;\n        heap \\<langle>l1, a1, r1\\<rangle>;\n        heap \\<langle>l2, a2, r2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>l1, a1, r1\\<rangle>\n                            \\<langle>l2, a2, r2\\<rangle>)\n 2. \\<And>v va vb.\n       \\<lbrakk>braun\n                 \\<langle>\\<langle>\\<rangle>, x,\n                  \\<langle>v, va, vb\\<rangle>\\<rangle>;\n        heap \\<langle>\\<rangle>; heap \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>\\<rangle>\n                            \\<langle>v, va, vb\\<rangle>)", "case (2 l1 a1 r1 l2 a2 r2)"], ["proof (state)\nthis:\n  \\<lbrakk>a1 \\<le> a2; braun \\<langle>l1, x, r1\\<rangle>; heap l1;\n   heap r1\\<rbrakk>\n  \\<Longrightarrow> heap (merge l1 r1)\n  braun\n   \\<langle>\\<langle>l1, a1, r1\\<rangle>, x,\n    \\<langle>l2, a2, r2\\<rangle>\\<rangle>\n  heap \\<langle>l1, a1, r1\\<rangle>\n  heap \\<langle>l2, a2, r2\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>l1 a1 r1 l2 a2 r2.\n       \\<lbrakk>\\<lbrakk>a1 \\<le> a2; braun \\<langle>l1, x, r1\\<rangle>;\n                 heap l1; heap r1\\<rbrakk>\n                \\<Longrightarrow> heap (merge l1 r1);\n        braun\n         \\<langle>\\<langle>l1, a1, r1\\<rangle>, x,\n          \\<langle>l2, a2, r2\\<rangle>\\<rangle>;\n        heap \\<langle>l1, a1, r1\\<rangle>;\n        heap \\<langle>l2, a2, r2\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>l1, a1, r1\\<rangle>\n                            \\<langle>l2, a2, r2\\<rangle>)\n 2. \\<And>v va vb.\n       \\<lbrakk>braun\n                 \\<langle>\\<langle>\\<rangle>, x,\n                  \\<langle>v, va, vb\\<rangle>\\<rangle>;\n        heap \\<langle>\\<rangle>; heap \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>\\<rangle>\n                            \\<langle>v, va, vb\\<rangle>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)\n 2. \\<not> ?P \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "assume \"a1 \\<le> a2\""], ["proof (state)\nthis:\n  a1 \\<le> a2\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)\n 2. \\<not> ?P \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a1 \\<le> a2\n\ngoal (1 subgoal):\n 1. heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "using 2"], ["proof (prove)\nusing this:\n  a1 \\<le> a2\n  \\<lbrakk>a1 \\<le> a2; braun \\<langle>l1, x, r1\\<rangle>; heap l1;\n   heap r1\\<rbrakk>\n  \\<Longrightarrow> heap (merge l1 r1)\n  braun\n   \\<langle>\\<langle>l1, a1, r1\\<rangle>, x,\n    \\<langle>l2, a2, r2\\<rangle>\\<rangle>\n  heap \\<langle>l1, a1, r1\\<rangle>\n  heap \\<langle>l2, a2, r2\\<rangle>\n\ngoal (1 subgoal):\n 1. heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "by(auto simp: ball_Un mset_tree_merge simp flip: set_mset_tree)"], ["proof (state)\nthis:\n  heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "assume \"\\<not> a1 \\<le> a2\""], ["proof (state)\nthis:\n  \\<not> a1 \\<le> a2\n\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "let ?l = \"Node l1 a1 r1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "let ?r = \"Node l2 a2 r2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "have \"braun ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>l2, a2, r2\\<rangle>", "using \"2.prems\"(1)"], ["proof (prove)\nusing this:\n  braun\n   \\<langle>\\<langle>l1, a1, r1\\<rangle>, x,\n    \\<langle>l2, a2, r2\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. braun \\<langle>l2, a2, r2\\<rangle>", "by auto"], ["proof (state)\nthis:\n  braun \\<langle>l2, a2, r2\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "obtain x l' where dl: \"del_left ?l = (x, l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x l'.\n        del_left \\<langle>l1, a1, r1\\<rangle> = (x, l') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis surj_pair)"], ["proof (state)\nthis:\n  del_left \\<langle>l1, a1, r1\\<rangle> = (x, l')\n\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "from del_left_heap[OF this _ \"2.prems\"(2)]"], ["proof (chain)\npicking this:\n  \\<langle>l1, a1, r1\\<rangle> \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n  heap l'", "have \"heap l'\""], ["proof (prove)\nusing this:\n  \\<langle>l1, a1, r1\\<rangle> \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n  heap l'\n\ngoal (1 subgoal):\n 1. heap l'", "by auto"], ["proof (state)\nthis:\n  heap l'\n\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "have hr: \"heap(replace_min x ?r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap (replace_min x \\<langle>l2, a2, r2\\<rangle>)", "using \\<open>braun ?r\\<close> \"2.prems\"(3)"], ["proof (prove)\nusing this:\n  braun \\<langle>l2, a2, r2\\<rangle>\n  heap \\<langle>l2, a2, r2\\<rangle>\n\ngoal (1 subgoal):\n 1. heap (replace_min x \\<langle>l2, a2, r2\\<rangle>)", "by(simp add: heap_sift_down neq_Leaf_iff replace_min_sift_down del: replace_min.simps)"], ["proof (state)\nthis:\n  heap (replace_min x \\<langle>l2, a2, r2\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "have 0: \"\\<forall>x \\<in> set_tree ?l. a2 \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_tree \\<langle>l1, a1, r1\\<rangle>. a2 \\<le> x", "using \"2.prems\"(2) \\<open>\\<not> a1 \\<le> a2\\<close>"], ["proof (prove)\nusing this:\n  heap \\<langle>l1, a1, r1\\<rangle>\n  \\<not> a1 \\<le> a2\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_tree \\<langle>l1, a1, r1\\<rangle>. a2 \\<le> x", "by (auto simp: ball_Un)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set_tree \\<langle>l1, a1, r1\\<rangle>. a2 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set_tree \\<langle>l1, a1, r1\\<rangle>. a2 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "have \"set_tree l' \\<subseteq> set_tree ?l\" \"x \\<in> set_tree ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_tree l' \\<subseteq> set_tree \\<langle>l1, a1, r1\\<rangle> &&&\n    x \\<in> set_tree \\<langle>l1, a1, r1\\<rangle>", "using del_left_mset[OF dl]"], ["proof (prove)\nusing this:\n  \\<langle>l1, a1, r1\\<rangle> \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n  x \\<in># mset_tree \\<langle>l1, a1, r1\\<rangle> \\<and>\n  mset_tree l' = mset_tree \\<langle>l1, a1, r1\\<rangle> - {#x#}\n\ngoal (1 subgoal):\n 1. set_tree l' \\<subseteq> set_tree \\<langle>l1, a1, r1\\<rangle> &&&\n    x \\<in> set_tree \\<langle>l1, a1, r1\\<rangle>", "by (auto simp flip: set_mset_tree dest:in_diffD simp: union_iff)"], ["proof (state)\nthis:\n  set_tree l' \\<subseteq> set_tree \\<langle>l1, a1, r1\\<rangle>\n  x \\<in> set_tree \\<langle>l1, a1, r1\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set_tree \\<langle>l1, a1, r1\\<rangle>. a2 \\<le> x\n  set_tree l' \\<subseteq> set_tree \\<langle>l1, a1, r1\\<rangle>\n  x \\<in> set_tree \\<langle>l1, a1, r1\\<rangle>", "have 1: \"\\<forall>x \\<in> set_tree l'. a2 \\<le> x\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set_tree \\<langle>l1, a1, r1\\<rangle>. a2 \\<le> x\n  set_tree l' \\<subseteq> set_tree \\<langle>l1, a1, r1\\<rangle>\n  x \\<in> set_tree \\<langle>l1, a1, r1\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_tree l'. a2 \\<le> x", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set_tree l'. a2 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "have \"\\<forall>x \\<in> set_tree ?r. a2 \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_tree \\<langle>l2, a2, r2\\<rangle>. a2 \\<le> x", "using \\<open>heap ?r\\<close>"], ["proof (prove)\nusing this:\n  heap \\<langle>l2, a2, r2\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set_tree \\<langle>l2, a2, r2\\<rangle>. a2 \\<le> x", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set_tree \\<langle>l2, a2, r2\\<rangle>. a2 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set_tree \\<langle>l2, a2, r2\\<rangle>. a2 \\<le> x\n\ngoal (1 subgoal):\n 1. heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "using \\<open>\\<not> a1 \\<le> a2\\<close> dl \\<open>heap(replace_min x ?r)\\<close> \\<open>heap l'\\<close> \\<open>x \\<in> set_tree ?l\\<close> 0 1 \\<open>braun ?r\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set_tree \\<langle>l2, a2, r2\\<rangle>. a2 \\<le> x\n  \\<not> a1 \\<le> a2\n  del_left \\<langle>l1, a1, r1\\<rangle> = (x, l')\n  heap (replace_min x \\<langle>l2, a2, r2\\<rangle>)\n  heap l'\n  x \\<in> set_tree \\<langle>l1, a1, r1\\<rangle>\n  \\<forall>x\\<in>set_tree \\<langle>l1, a1, r1\\<rangle>. a2 \\<le> x\n  \\<forall>x\\<in>set_tree l'. a2 \\<le> x\n  braun \\<langle>l2, a2, r2\\<rangle>\n\ngoal (1 subgoal):\n 1. heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)", "by(auto simp: mset_sift_down replace_min_sift_down simp flip: set_mset_tree\n              simp del: replace_min.simps)"], ["proof (state)\nthis:\n  heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  heap (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>v va vb.\n       \\<lbrakk>braun\n                 \\<langle>\\<langle>\\<rangle>, x,\n                  \\<langle>v, va, vb\\<rangle>\\<rangle>;\n        heap \\<langle>\\<rangle>; heap \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>\\<rangle>\n                            \\<langle>v, va, vb\\<rangle>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v va vb.\n       \\<lbrakk>braun\n                 \\<langle>\\<langle>\\<rangle>, x,\n                  \\<langle>v, va, vb\\<rangle>\\<rangle>;\n        heap \\<langle>\\<rangle>; heap \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>\\<rangle>\n                            \\<langle>v, va, vb\\<rangle>)", "case 3"], ["proof (state)\nthis:\n  braun\n   \\<langle>\\<langle>\\<rangle>, x, \\<langle>v_, va_, vb_\\<rangle>\\<rangle>\n  heap \\<langle>\\<rangle>\n  heap \\<langle>v_, va_, vb_\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>v va vb.\n       \\<lbrakk>braun\n                 \\<langle>\\<langle>\\<rangle>, x,\n                  \\<langle>v, va, vb\\<rangle>\\<rangle>;\n        heap \\<langle>\\<rangle>; heap \\<langle>v, va, vb\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> heap\n                          (merge \\<langle>\\<rangle>\n                            \\<langle>v, va, vb\\<rangle>)", "thus ?case"], ["proof (prove)\nusing this:\n  braun\n   \\<langle>\\<langle>\\<rangle>, x, \\<langle>v_, va_, vb_\\<rangle>\\<rangle>\n  heap \\<langle>\\<rangle>\n  heap \\<langle>v_, va_, vb_\\<rangle>\n\ngoal (1 subgoal):\n 1. heap (merge \\<langle>\\<rangle> \\<langle>v_, va_, vb_\\<rangle>)", "by simp"], ["proof (state)\nthis:\n  heap (merge \\<langle>\\<rangle> \\<langle>v_, va_, vb_\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma del_left_braun_size:\n  \"del_left t = (x,t') \\<Longrightarrow> braun t \\<Longrightarrow> t \\<noteq> Leaf \\<Longrightarrow> braun t' \\<and> size t = size t' + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>del_left t = (x, t'); braun t;\n     t \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> braun t' \\<and> size t = size t' + 1", "by (simp add: del_left_braun del_left_size)"], ["", "lemma braun_size_merge:\n  \"braun (Node l x r) \\<Longrightarrow> braun(merge l r) \\<and> size(merge l r) = size l + size r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>l, x, r\\<rangle> \\<Longrightarrow>\n    braun (merge l r) \\<and> size (merge l r) = size l + size r", "apply(induction l r rule: merge.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l.\n       braun \\<langle>l, x, \\<langle>\\<rangle>\\<rangle> \\<Longrightarrow>\n       braun (merge l \\<langle>\\<rangle>) \\<and>\n       size (merge l \\<langle>\\<rangle>) = size l + size \\<langle>\\<rangle>\n 2. \\<And>l1 a1 r1 l2 a2 r2.\n       \\<lbrakk>\\<lbrakk>a1 \\<le> a2;\n                 braun \\<langle>l1, x, r1\\<rangle>\\<rbrakk>\n                \\<Longrightarrow> braun (merge l1 r1) \\<and>\n                                  size (merge l1 r1) = size l1 + size r1;\n        braun\n         \\<langle>\\<langle>l1, a1, r1\\<rangle>, x,\n          \\<langle>l2, a2, r2\\<rangle>\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> braun\n                          (merge \\<langle>l1, a1, r1\\<rangle>\n                            \\<langle>l2, a2, r2\\<rangle>) \\<and>\n                         size\n                          (merge \\<langle>l1, a1, r1\\<rangle>\n                            \\<langle>l2, a2, r2\\<rangle>) =\n                         size \\<langle>l1, a1, r1\\<rangle> +\n                         size \\<langle>l2, a2, r2\\<rangle>\n 3. \\<And>v va vb.\n       braun\n        \\<langle>\\<langle>\\<rangle>, x,\n         \\<langle>v, va, vb\\<rangle>\\<rangle> \\<Longrightarrow>\n       braun (merge \\<langle>\\<rangle> \\<langle>v, va, vb\\<rangle>) \\<and>\n       size (merge \\<langle>\\<rangle> \\<langle>v, va, vb\\<rangle>) =\n       size \\<langle>\\<rangle> + size \\<langle>v, va, vb\\<rangle>", "apply(auto simp: size_sift_down braun_sift_down replace_min_sift_down\n           simp del: replace_min.simps\n           dest!: del_left_braun_size split!: prod.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Last step: prove all axioms of the priority queue specification:\\<close>"], ["", "interpretation braun: Priority_Queue\nwhere empty = Leaf and is_empty = \"\\<lambda>h. h = Leaf\"\nand insert = insert and del_min = del_min2\nand get_min = get_min and invar = \"\\<lambda>h. braun h \\<and> heap h\"\nand mset = mset_tree"], ["proof (prove)\ngoal (1 subgoal):\n 1. Priority_Queue \\<langle>\\<rangle> (\\<lambda>h. h = \\<langle>\\<rangle>)\n     insert get_min del_min2 (\\<lambda>h. braun h \\<and> heap h) mset_tree", "proof(standard, goal_cases)"], ["proof (state)\ngoal (8 subgoals):\n 1. mset_tree \\<langle>\\<rangle> = {#}\n 2. \\<And>q.\n       braun q \\<and> heap q \\<Longrightarrow>\n       (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n 3. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min2 q) =\n                         mset_tree q - {#get_min q#}\n 5. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 6. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 7. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 8. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (8 subgoals):\n 1. mset_tree \\<langle>\\<rangle> = {#}\n 2. \\<And>q.\n       braun q \\<and> heap q \\<Longrightarrow>\n       (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n 3. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min2 q) =\n                         mset_tree q - {#get_min q#}\n 5. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 6. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 7. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 8. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_tree \\<langle>\\<rangle> = {#}", "by simp"], ["proof (state)\nthis:\n  mset_tree \\<langle>\\<rangle> = {#}\n\ngoal (7 subgoals):\n 1. \\<And>q.\n       braun q \\<and> heap q \\<Longrightarrow>\n       (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n 2. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min2 q) =\n                         mset_tree q - {#get_min q#}\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 5. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 6. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 7. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>q.\n       braun q \\<and> heap q \\<Longrightarrow>\n       (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n 2. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min2 q) =\n                         mset_tree q - {#get_min q#}\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 5. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 6. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 7. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "case 2"], ["proof (state)\nthis:\n  braun q_ \\<and> heap q_\n\ngoal (7 subgoals):\n 1. \\<And>q.\n       braun q \\<and> heap q \\<Longrightarrow>\n       (q = \\<langle>\\<rangle>) = (mset_tree q = {#})\n 2. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min2 q) =\n                         mset_tree q - {#get_min q#}\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 5. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 6. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 7. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (q_ = \\<langle>\\<rangle>) = (mset_tree q_ = {#})", "by simp"], ["proof (state)\nthis:\n  (q_ = \\<langle>\\<rangle>) = (mset_tree q_ = {#})\n\ngoal (6 subgoals):\n 1. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min2 q) =\n                         mset_tree q - {#get_min q#}\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 4. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 5. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 6. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min2 q) =\n                         mset_tree q - {#get_min q#}\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 4. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 5. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 6. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "case 3"], ["proof (state)\nthis:\n  braun q_ \\<and> heap q_\n\ngoal (6 subgoals):\n 1. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       mset_tree (insert x q) = mset_tree q + {#x#}\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min2 q) =\n                         mset_tree q - {#get_min q#}\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 4. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 5. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 6. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_tree (insert x_ q_) = mset_tree q_ + {#x_#}", "by(simp add: mset_insert)"], ["proof (state)\nthis:\n  mset_tree (insert x_ q_) = mset_tree q_ + {#x_#}\n\ngoal (5 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min2 q) =\n                         mset_tree q - {#get_min q#}\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 3. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 4. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 5. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min2 q) =\n                         mset_tree q - {#get_min q#}\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 3. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 4. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 5. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "case 4"], ["proof (state)\nthis:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (5 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> mset_tree (del_min2 q) =\n                         mset_tree q - {#get_min q#}\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 3. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 4. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 5. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "thus ?case"], ["proof (prove)\nusing this:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. mset_tree (del_min2 q_) = mset_tree q_ - {#get_min q_#}", "by(auto simp: mset_tree_merge neq_Leaf_iff)"], ["proof (state)\nthis:\n  mset_tree (del_min2 q_) = mset_tree q_ - {#get_min q_#}\n\ngoal (4 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 2. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 3. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 2. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 3. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "case 5"], ["proof (state)\nthis:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (4 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> get_min q = Min_mset (mset_tree q)\n 2. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 3. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 4. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "thus ?case"], ["proof (prove)\nusing this:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. get_min q_ = Min_mset (mset_tree q_)", "using get_min mset_tree.simps(1)"], ["proof (prove)\nusing this:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n  \\<lbrakk>heap ?t; ?t \\<noteq> \\<langle>\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> get_min ?t = Min_mset (mset_tree ?t)\n  mset_tree \\<langle>\\<rangle> = {#}\n\ngoal (1 subgoal):\n 1. get_min q_ = Min_mset (mset_tree q_)", "by blast"], ["proof (state)\nthis:\n  get_min q_ = Min_mset (mset_tree q_)\n\ngoal (3 subgoals):\n 1. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 2. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 2. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "case 6"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n 2. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 3. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>", "by(simp)"], ["proof (state)\nthis:\n  braun \\<langle>\\<rangle> \\<and> heap \\<langle>\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "case 7"], ["proof (state)\nthis:\n  braun q_ \\<and> heap q_\n\ngoal (2 subgoals):\n 1. \\<And>q x.\n       braun q \\<and> heap q \\<Longrightarrow>\n       braun (insert x q) \\<and> heap (insert x q)\n 2. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "thus ?case"], ["proof (prove)\nusing this:\n  braun q_ \\<and> heap q_\n\ngoal (1 subgoal):\n 1. braun (insert x_ q_) \\<and> heap (insert x_ q_)", "by(simp add: heap_insert braun_insert)"], ["proof (state)\nthis:\n  braun (insert x_ q_) \\<and> heap (insert x_ q_)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "case 8"], ["proof (state)\nthis:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>braun q \\<and> heap q; mset_tree q \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> braun (del_min2 q) \\<and> heap (del_min2 q)", "thus ?case"], ["proof (prove)\nusing this:\n  braun q_ \\<and> heap q_\n  mset_tree q_ \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. braun (del_min2 q_) \\<and> heap (del_min2 q_)", "by(auto simp: heap_merge braun_size_merge neq_Leaf_iff)"], ["proof (state)\nthis:\n  braun (del_min2 q_) \\<and> heap (del_min2 q_)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}