{"file_name": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography_CM/Construction_Utility.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography_CM", "problem_names": ["lemma ldummy_converter_of_callee: \n  \"ldummy_converter f (converter_of_callee callee state) = \n    converter_of_callee (\\<lambda>s q. case_sum (\\<lambda>ql. Done (Inl (f ql), s)) (\\<lambda>qr. map_gpv (map_prod Inr id) id (callee s qr))  q)  state\"", "lemma rdummy_converter_of_callee: \n  \"rdummy_converter f (converter_of_callee callee state) = \n    converter_of_callee (\\<lambda>s q. case_sum (\\<lambda>ql. map_gpv (map_prod Inl id) id (callee s ql)) (\\<lambda>qr. Done (Inr (f qr), s))  q) state\"", "lemma parallel_oracle_fuse:\n  \"apply_wiring fused_wiring\\<^sub>w (parallel_oracle (fused_resource.fuse core1 rest1) (fused_resource.fuse core2 rest2)) =\n    apply_state_iso parallel_state_iso (fused_resource.fuse (parallel_core core1 core2) (parallel_rest rest1 rest2))\"", "lemma attach_callee_fuse:\n  \"attach_callee ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest) (fused_resource.fuse core rest) =\n   apply_state_iso iso_trisplit (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core) (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\"\n  (is \"?lhs = ?rhs\")", "lemma attach_parallel_fuse':\n  \"(CNV cnv_adv_core s_a_c |\\<^sub>= CNV cnv_adv_rest s_a_r) |\\<^sub>= (CNV cnv_usr_core s_u_c |\\<^sub>= CNV cnv_usr_rest s_u_r) \\<rhd> \n   RES (fused_resource.fuse core rest) (s_r_c, s_r_r) = \n   RES (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core) (attach_rest cnv_adv_rest cnv_usr_rest f_init rest)) (((s_a_c, s_u_c), s_r_c), ((s_a_r, s_u_r), s_r_r))\"", "lemma WT_translate_rest [WT_intro]: \n  assumes \"WT_rest \\<I>_adv \\<I>_usr I_rest rest\"\n  shows \"WT_rest \\<I>_adv \\<I>_usr (pred_prod (\\<lambda>_. True) I_rest) translate_rest\"", "lemma fused_resource_move_translate:\n  \"fused_resource.fuse core translate_rest = apply_state_iso iso_swapar (fused_resource.fuse translate_core rest)\"", "lemma\n  fuse_ishift_core_to_rest:\n  assumes \"cpoke core' = (\\<lambda>s. case_sum (\\<lambda>q. fn s q) (cpoke core s))\"\n      and \"cfunc_adv core = cfunc_adv core'\"\n      and \"cfunc_usr core = cfunc_usr core' \\<oplus>\\<^sub>O (\\<lambda>s i. map_spmf (Pair (h_out i)) (fn s i))\"\n      and \"rfunc_adv rest' = (\\<lambda>s q. map_spmf (apfst (apsnd (map Inr))) (rfunc_adv rest s q))\"\n      and \"rfunc_usr rest' = plus_eoracle (\\<lambda>s i. return_spmf ((h_out i, [i]), s)) (rfunc_usr rest)\"\n    shows \"fused_resource.fuse core rest = apply_wiring (1\\<^sub>w |\\<^sub>w lassocr\\<^sub>w) (fused_resource.fuse core' rest')\" (is \"?L = ?R\")", "lemma move_simulator_interface:\n  defines \"x_ifunc \\<equiv> (\\<lambda>ifunc core (se, sc) q. do {\n      ((out, es), se') \\<leftarrow> ifunc se q;\n      sc' \\<leftarrow> foldl_spmf (cpoke core) (return_spmf sc) es;\n      return_spmf (out, se', sc')   })\"\n  assumes \"cpoke core' = cpoke (translate_core etran core)\"\n      and \"cfunc_adv core' = \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O x_ifunc ifunc core\"\n      and \"cfunc_usr core' = cfunc_usr (translate_core etran core)\"\n      and \"rinit rest = (einit, rinit rest')\"\n      and \"rfunc_adv rest = (\\<lambda>s q. case q of \n        Inl ql \\<Rightarrow> map_spmf (apfst (map_prod Inl id)) ((ifunc\\<dagger>) s ql)\n      | Inr qr \\<Rightarrow> map_spmf (apfst (map_prod Inr id)) ((translate_eoracle etran (\\<dagger>(rfunc_adv rest'))) s qr))\"\n      and \"rfunc_usr rest = translate_eoracle etran (\\<dagger>(rfunc_usr rest'))\"\n  shows \"fused_resource.fuse core rest =  apply_wiring (rassocl\\<^sub>w |\\<^sub>w (id, id))\n       (apply_state_iso (rprodl o (apfst prod.swap), (apfst prod.swap) o lprodr)\n         (fused_resource.fuse core' rest'))\"\n    (is \"?L = ?R\")"], "translations": [["", "lemma ldummy_converter_of_callee: \n  \"ldummy_converter f (converter_of_callee callee state) = \n    converter_of_callee (\\<lambda>s q. case_sum (\\<lambda>ql. Done (Inl (f ql), s)) (\\<lambda>qr. map_gpv (map_prod Inr id) id (callee s qr))  q)  state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ldummy_converter f (CNV callee state) =\n    CNV (\\<lambda>s q.\n            case q of Inl ql \\<Rightarrow> Done (Inl (f ql), s)\n            | Inr qr \\<Rightarrow>\n                map_gpv (map_prod Inr id) id (callee s qr))\n     state", "apply (coinduction arbitrary: callee state)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>callee state.\n       rel_fun (=)\n        (rel_gpv\n          (rel_prod (=)\n            (\\<lambda>converter__ converter'__.\n                \\<exists>callee state.\n                   converter__ =\n                   ldummy_converter f (CNV callee state) \\<and>\n                   converter'__ =\n                   CNV (\\<lambda>s.\n                           case_sum (\\<lambda>ql. Done (Inl (f ql), s))\n                            (\\<lambda>qr.\n                                map_gpv (map_prod Inr id) id (callee s qr)))\n                    state))\n          (=))\n        (run_converter (ldummy_converter f (CNV callee state)))\n        (run_converter\n          (CNV (\\<lambda>s.\n                   case_sum (\\<lambda>ql. Done (Inl (f ql), s))\n                    (\\<lambda>qr.\n                        map_gpv (map_prod Inr id) id (callee s qr)))\n            state))", "apply(clarsimp intro!:rel_funI split!:sum.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>callee state.\n       \\<exists>calleea statea.\n          ldummy_converter f (CNV callee state) =\n          ldummy_converter f (CNV calleea statea) \\<and>\n          CNV (\\<lambda>s.\n                  case_sum (\\<lambda>ql. Done (Inl (f ql), s))\n                   (\\<lambda>qr.\n                       map_gpv (map_prod Inr id) id (callee s qr)))\n           state =\n          CNV (\\<lambda>s.\n                  case_sum (\\<lambda>ql. Done (Inl (f ql), s))\n                   (\\<lambda>qr.\n                       map_gpv (map_prod Inr id) id (calleea s qr)))\n           statea\n 2. \\<And>callee state x2.\n       rel_gpv\n        (rel_prod (=)\n          (\\<lambda>converter__ converter'__.\n              \\<exists>callee state.\n                 converter__ = ldummy_converter f (CNV callee state) \\<and>\n                 converter'__ =\n                 CNV (\\<lambda>s.\n                         case_sum (\\<lambda>ql. Done (Inl (f ql), s))\n                          (\\<lambda>qr.\n                              map_gpv (map_prod Inr id) id (callee s qr)))\n                  state))\n        (=)\n        (map_gpv (map_prod Inr (ldummy_converter f)) id\n          (map_gpv (map_prod id (CNV callee)) id (callee state x2)))\n        (map_gpv\n          (map_prod id\n            (CNV (\\<lambda>s.\n                     case_sum (\\<lambda>ql. Done (Inl (f ql), s))\n                      (\\<lambda>qr.\n                          map_gpv (map_prod Inr id) id (callee s qr)))))\n          id (map_gpv (map_prod Inr id) id (callee state x2)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>callee state.\n       ldummy_converter f (CNV callee_ state_) =\n       ldummy_converter f (CNV callee state) \\<and>\n       CNV (\\<lambda>s.\n               case_sum (\\<lambda>ql. Done (Inl (f ql), s))\n                (\\<lambda>qr. map_gpv (map_prod Inr id) id (callee_ s qr)))\n        state_ =\n       CNV (\\<lambda>s.\n               case_sum (\\<lambda>ql. Done (Inl (f ql), s))\n                (\\<lambda>qr. map_gpv (map_prod Inr id) id (callee s qr)))\n        state", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>callee state x2.\n       rel_gpv\n        (rel_prod (=)\n          (\\<lambda>converter__ converter'__.\n              \\<exists>callee state.\n                 converter__ = ldummy_converter f (CNV callee state) \\<and>\n                 converter'__ =\n                 CNV (\\<lambda>s.\n                         case_sum (\\<lambda>ql. Done (Inl (f ql), s))\n                          (\\<lambda>qr.\n                              map_gpv (map_prod Inr id) id (callee s qr)))\n                  state))\n        (=)\n        (map_gpv (map_prod Inr (ldummy_converter f)) id\n          (map_gpv (map_prod id (CNV callee)) id (callee state x2)))\n        (map_gpv\n          (map_prod id\n            (CNV (\\<lambda>s.\n                     case_sum (\\<lambda>ql. Done (Inl (f ql), s))\n                      (\\<lambda>qr.\n                          map_gpv (map_prod Inr id) id (callee s qr)))))\n          id (map_gpv (map_prod Inr id) id (callee state x2)))", "apply (simp add: gpv.rel_map map_prod_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>callee state x2.\n       rel_gpv\n        (\\<lambda>x y.\n            fst x = fst y \\<and>\n            (\\<exists>calleea state.\n                ldummy_converter f (CNV callee (snd x)) =\n                ldummy_converter f (CNV calleea state) \\<and>\n                CNV (\\<lambda>s.\n                        case_sum (\\<lambda>ql. Done (Inl (f ql), s))\n                         (\\<lambda>qr.\n                             map_gpv (\\<lambda>p. (Inr (fst p), snd p)) id\n                              (callee s qr)))\n                 (snd y) =\n                CNV (\\<lambda>s.\n                        case_sum (\\<lambda>ql. Done (Inl (f ql), s))\n                         (\\<lambda>qr.\n                             map_gpv (\\<lambda>p. (Inr (fst p), snd p)) id\n                              (calleea s qr)))\n                 state))\n        (=) (callee state x2) (callee state x2)", "by (rule gpv.rel_mono_strong0[of \"(=)\" \"(=)\"]) (auto simp add: gpv.rel_eq)"], ["", "lemma rdummy_converter_of_callee: \n  \"rdummy_converter f (converter_of_callee callee state) = \n    converter_of_callee (\\<lambda>s q. case_sum (\\<lambda>ql. map_gpv (map_prod Inl id) id (callee s ql)) (\\<lambda>qr. Done (Inr (f qr), s))  q) state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rdummy_converter f (CNV callee state) =\n    CNV (\\<lambda>s q.\n            case q of\n            Inl ql \\<Rightarrow> map_gpv (map_prod Inl id) id (callee s ql)\n            | Inr qr \\<Rightarrow> Done (Inr (f qr), s))\n     state", "apply (coinduction arbitrary: callee state)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>callee state.\n       rel_fun (=)\n        (rel_gpv\n          (rel_prod (=)\n            (\\<lambda>converter__ converter'__.\n                \\<exists>callee state.\n                   converter__ =\n                   rdummy_converter f (CNV callee state) \\<and>\n                   converter'__ =\n                   CNV (\\<lambda>s.\n                           case_sum\n                            (\\<lambda>ql.\n                                map_gpv (map_prod Inl id) id (callee s ql))\n                            (\\<lambda>qr. Done (Inr (f qr), s)))\n                    state))\n          (=))\n        (run_converter (rdummy_converter f (CNV callee state)))\n        (run_converter\n          (CNV (\\<lambda>s.\n                   case_sum\n                    (\\<lambda>ql.\n                        map_gpv (map_prod Inl id) id (callee s ql))\n                    (\\<lambda>qr. Done (Inr (f qr), s)))\n            state))", "apply(clarsimp intro!:rel_funI split!:sum.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>callee state x1.\n       rel_gpv\n        (rel_prod (=)\n          (\\<lambda>converter__ converter'__.\n              \\<exists>callee state.\n                 converter__ = rdummy_converter f (CNV callee state) \\<and>\n                 converter'__ =\n                 CNV (\\<lambda>s.\n                         case_sum\n                          (\\<lambda>ql.\n                              map_gpv (map_prod Inl id) id (callee s ql))\n                          (\\<lambda>qr. Done (Inr (f qr), s)))\n                  state))\n        (=)\n        (map_gpv (map_prod Inl (rdummy_converter f)) id\n          (map_gpv (map_prod id (CNV callee)) id (callee state x1)))\n        (map_gpv\n          (map_prod id\n            (CNV (\\<lambda>s.\n                     case_sum\n                      (\\<lambda>ql.\n                          map_gpv (map_prod Inl id) id (callee s ql))\n                      (\\<lambda>qr. Done (Inr (f qr), s)))))\n          id (map_gpv (map_prod Inl id) id (callee state x1)))\n 2. \\<And>callee state.\n       \\<exists>calleea statea.\n          rdummy_converter f (CNV callee state) =\n          rdummy_converter f (CNV calleea statea) \\<and>\n          CNV (\\<lambda>s.\n                  case_sum\n                   (\\<lambda>ql. map_gpv (map_prod Inl id) id (callee s ql))\n                   (\\<lambda>qr. Done (Inr (f qr), s)))\n           state =\n          CNV (\\<lambda>s.\n                  case_sum\n                   (\\<lambda>ql.\n                       map_gpv (map_prod Inl id) id (calleea s ql))\n                   (\\<lambda>qr. Done (Inr (f qr), s)))\n           statea", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>callee state.\n       \\<exists>calleea statea.\n          rdummy_converter f (CNV callee state) =\n          rdummy_converter f (CNV calleea statea) \\<and>\n          CNV (\\<lambda>s.\n                  case_sum\n                   (\\<lambda>ql. map_gpv (map_prod Inl id) id (callee s ql))\n                   (\\<lambda>qr. Done (Inr (f qr), s)))\n           state =\n          CNV (\\<lambda>s.\n                  case_sum\n                   (\\<lambda>ql.\n                       map_gpv (map_prod Inl id) id (calleea s ql))\n                   (\\<lambda>qr. Done (Inr (f qr), s)))\n           statea\n 2. \\<And>callee state x1.\n       rel_gpv\n        (rel_prod (=)\n          (\\<lambda>converter__ converter'__.\n              \\<exists>callee state.\n                 converter__ = rdummy_converter f (CNV callee state) \\<and>\n                 converter'__ =\n                 CNV (\\<lambda>s.\n                         case_sum\n                          (\\<lambda>ql.\n                              map_gpv (map_prod Inl id) id (callee s ql))\n                          (\\<lambda>qr. Done (Inr (f qr), s)))\n                  state))\n        (=)\n        (map_gpv (map_prod Inl (rdummy_converter f)) id\n          (map_gpv (map_prod id (CNV callee)) id (callee state x1)))\n        (map_gpv\n          (map_prod id\n            (CNV (\\<lambda>s.\n                     case_sum\n                      (\\<lambda>ql.\n                          map_gpv (map_prod Inl id) id (callee s ql))\n                      (\\<lambda>qr. Done (Inr (f qr), s)))))\n          id (map_gpv (map_prod Inl id) id (callee state x1)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>callee state.\n       rdummy_converter f (CNV callee_ state_) =\n       rdummy_converter f (CNV callee state) \\<and>\n       CNV (\\<lambda>s.\n               case_sum\n                (\\<lambda>ql. map_gpv (map_prod Inl id) id (callee_ s ql))\n                (\\<lambda>qr. Done (Inr (f qr), s)))\n        state_ =\n       CNV (\\<lambda>s.\n               case_sum\n                (\\<lambda>ql. map_gpv (map_prod Inl id) id (callee s ql))\n                (\\<lambda>qr. Done (Inr (f qr), s)))\n        state", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>callee state x1.\n       rel_gpv\n        (rel_prod (=)\n          (\\<lambda>converter__ converter'__.\n              \\<exists>callee state.\n                 converter__ = rdummy_converter f (CNV callee state) \\<and>\n                 converter'__ =\n                 CNV (\\<lambda>s.\n                         case_sum\n                          (\\<lambda>ql.\n                              map_gpv (map_prod Inl id) id (callee s ql))\n                          (\\<lambda>qr. Done (Inr (f qr), s)))\n                  state))\n        (=)\n        (map_gpv (map_prod Inl (rdummy_converter f)) id\n          (map_gpv (map_prod id (CNV callee)) id (callee state x1)))\n        (map_gpv\n          (map_prod id\n            (CNV (\\<lambda>s.\n                     case_sum\n                      (\\<lambda>ql.\n                          map_gpv (map_prod Inl id) id (callee s ql))\n                      (\\<lambda>qr. Done (Inr (f qr), s)))))\n          id (map_gpv (map_prod Inl id) id (callee state x1)))", "apply (simp add: gpv.rel_map map_prod_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>callee state x1.\n       rel_gpv\n        (\\<lambda>x y.\n            fst x = fst y \\<and>\n            (\\<exists>calleea state.\n                rdummy_converter f (CNV callee (snd x)) =\n                rdummy_converter f (CNV calleea state) \\<and>\n                CNV (\\<lambda>s.\n                        case_sum\n                         (\\<lambda>ql.\n                             map_gpv (\\<lambda>p. (Inl (fst p), snd p)) id\n                              (callee s ql))\n                         (\\<lambda>qr. Done (Inr (f qr), s)))\n                 (snd y) =\n                CNV (\\<lambda>s.\n                        case_sum\n                         (\\<lambda>ql.\n                             map_gpv (\\<lambda>p. (Inl (fst p), snd p)) id\n                              (calleea s ql))\n                         (\\<lambda>qr. Done (Inr (f qr), s)))\n                 state))\n        (=) (callee state x1) (callee state x1)", "by (rule gpv.rel_mono_strong0[of \"(=)\" \"(=)\"]) (auto simp add: gpv.rel_eq)\n\n\n\n\\<comment> \\<open>Commonly used wirings\\<close>"], ["", "context\n  fixes\n    cnv1 :: \"('icnv_usr1, 'ocnv_usr1, 'iusr1_res1 + 'iusr1_res2, 'ousr1_res1 + 'ousr1_res2) converter\" and\n    cnv2 :: \"('icnv_usr2, 'ocnv_usr2, 'iusr2_res1 + 'iusr2_res2, 'ousr2_res1 + 'ousr2_res2) converter\" \nbegin\n\n\\<comment> \\<open>c1r22: a converter that has 1 interface and sends queries to two resources,\n   where the first and second resources have 2 and 2 interfaces respectively\\<close>"], ["", "definition \n  wiring_c1r22_c1r22 :: \"('icnv_usr1 + 'icnv_usr2, 'ocnv_usr1 + 'ocnv_usr2, \n    ('iusr1_res1 + 'iusr2_res1) + 'iusr1_res2 + 'iusr2_res2, \n    ('ousr1_res1 + 'ousr2_res1) + 'ousr1_res2 + 'ousr2_res2) converter\"\n  where \n    \"wiring_c1r22_c1r22  \\<equiv> (cnv1 |\\<^sub>= cnv2) \\<odot> parallel_wiring\""], ["", "end\n\n\n\\<comment> \\<open>Special wiring converters used for the parallel composition of Fused resources\\<close>"], ["", "definition \n  fused_wiring :: \"\n    ((('iadv_core1 + 'iadv_core2) + ('iadv_rest1 + 'iadv_rest2)) + \n      (('iusr_core1 + 'iusr_core2) + ('iusr_rest1 + 'iusr_rest2)), \n    (('oadv_core1 + 'oadv_core2) + ('oadv_rest1 + 'oadv_rest2)) +\n      (('ousr_core1 + 'ousr_core2) + ('ousr_rest1 + 'ousr_rest2)),\n    (('iadv_core1 + 'iadv_rest1) + ('iusr_core1 + 'iusr_rest1)) + \n      (('iadv_core2 + 'iadv_rest2) + ('iusr_core2 + 'iusr_rest2)),\n    (('oadv_core1 + 'oadv_rest1) + ('ousr_core1 + 'ousr_rest1)) + \n      (('oadv_core2 + 'oadv_rest2) + ('ousr_core2 + 'ousr_rest2))) converter\"\n  where\n    \"fused_wiring \\<equiv> (parallel_wiring |\\<^sub>= parallel_wiring) \\<odot> parallel_wiring\""], ["", "definition \n  fused_wiring\\<^sub>w \n  where\n    \"fused_wiring\\<^sub>w \\<equiv> (parallel_wiring\\<^sub>w |\\<^sub>w parallel_wiring\\<^sub>w) \\<circ>\\<^sub>w parallel_wiring\\<^sub>w\""], ["", "schematic_goal \n  wiring_fused_wiring[wiring_intro]: \"wiring ?\\<I>1 ?\\<I>2 fused_wiring fused_wiring\\<^sub>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wiring ?\\<I>1 ?\\<I>2 fused_wiring fused_wiring\\<^sub>w", "unfolding fused_wiring_def fused_wiring\\<^sub>w_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wiring ?\\<I>1 ?\\<I>2\n     ((parallel_wiring |\\<^sub>= parallel_wiring) \\<odot> parallel_wiring)\n     (parallel_wiring\\<^sub>w |\\<^sub>w\n      parallel_wiring\\<^sub>w \\<circ>\\<^sub>w\n      parallel_wiring\\<^sub>w)", "by(rule wiring_intro)+"], ["", "schematic_goal WT_fused_wiring [WT_intro]: \"?\\<I>1, ?\\<I>2 \\<turnstile>\\<^sub>C fused_wiring \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ?\\<I>1, ?\\<I>2 \\<turnstile>\\<^sub>C fused_wiring \\<surd>", "unfolding fused_wiring_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ?\\<I>1, ?\\<I>2 \\<turnstile>\\<^sub>C\n    (parallel_wiring |\\<^sub>= parallel_wiring) \\<odot>\n    parallel_wiring \\<surd>", "by(rule WT_intro)+\n\n\n\n\\<comment> \\<open>Commonlu used attachments\\<close>"], ["", "context\n  fixes\n    cnv1 :: \"('icnv_usr1, 'ocnv_usr1, 'iusr1_core1 + 'iusr1_core2, 'ousr1_core1 + 'ousr1_core2) converter\" and\n    cnv2 :: \"('icnv_usr2, 'ocnv_usr2, 'iusr2_core1 + 'iusr2_core2, 'ousr2_core1 + 'ousr2_core2) converter\" and\n    res1 :: \"(('iadv_core1 + 'iadv_rest1) + ('iusr1_core1 + 'iusr2_core1) + 'iusr_rest1,\n      ('oadv_core1 + 'oadv_rest1) + ('ousr1_core1 + 'ousr2_core1) + 'ousr_rest1) resource\" and\n    res2 :: \"(('iadv_core2 + 'iadv_rest2) + ('iusr1_core2 + 'iusr2_core2) + 'iusr_rest2,\n      ('oadv_core2 + 'oadv_rest2) + ('ousr1_core2 + 'ousr2_core2) + 'ousr_rest2) resource\"\nbegin\n\n\\<comment> \\<open>Attachement of two c1f22 ('f' instead of 'r' to indicate Fused Resources) converters \n  to two 2-interface Fused Resources, the results will be a new 2-interface Fused Resource\\<close>"], ["", "definition \n  attach_c1f22_c1f22 :: \"((('iadv_core1 + 'iadv_core2) + 'iadv_rest1 + 'iadv_rest2) + ('icnv_usr1 + 'icnv_usr2) + 'iusr_rest1 + 'iusr_rest2,\n    (('oadv_core1 + 'oadv_core2) + 'oadv_rest1 + 'oadv_rest2) + ('ocnv_usr1 + 'ocnv_usr2) + 'ousr_rest1 + 'ousr_rest2) resource\"\n  where\n    \"attach_c1f22_c1f22 = (((1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>= ((wiring_c1r22_c1r22 cnv1 cnv2) |\\<^sub>= 1\\<^sub>C)) \\<odot> fused_wiring) \\<rhd> (res1 \\<parallel> res2)\""], ["", "end\n\n\n\\<comment> \\<open>Properties of Converters attaching to Fused resources\\<close>"], ["", "context\n  fixes\n    core1 :: \"('s_core1, 'e1, 'iadv_core1, 'iusr_core1, 'oadv_core1, 'ousr_core1) core\" and\n    core2 :: \"('s_core2, 'e2, 'iadv_core2, 'iusr_core2, 'oadv_core2, 'ousr_core2) core\" and\n    rest1 :: \"('s_rest1, 'e1, 'iadv_rest1, 'iusr_rest1, 'oadv_rest1, 'ousr_rest1, 'm1) rest_scheme\" and\n    rest2 :: \"('s_rest2, 'e2, 'iadv_rest2, 'iusr_rest2, 'oadv_rest2, 'ousr_rest2, 'm2) rest_scheme\"\nbegin"], ["", "lemma parallel_oracle_fuse:\n  \"apply_wiring fused_wiring\\<^sub>w (parallel_oracle (fused_resource.fuse core1 rest1) (fused_resource.fuse core2 rest2)) =\n    apply_state_iso parallel_state_iso (fused_resource.fuse (parallel_core core1 core2) (parallel_rest rest1 rest2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_wiring fused_wiring\\<^sub>w\n     (fused_resource.fuse core1 rest1 \\<ddagger>\\<^sub>O\n      fused_resource.fuse core2 rest2) =\n    apply_state_iso parallel_state_iso\n     (fused_resource.fuse (parallel_core core1 core2)\n       (parallel_rest rest1 rest2))", "supply fused_resource.fuse.simps[simp]"], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_wiring fused_wiring\\<^sub>w\n     (fused_resource.fuse core1 rest1 \\<ddagger>\\<^sub>O\n      fused_resource.fuse core2 rest2) =\n    apply_state_iso parallel_state_iso\n     (fused_resource.fuse (parallel_core core1 core2)\n       (parallel_rest rest1 rest2))", "apply(rule ext)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       apply_wiring fused_wiring\\<^sub>w\n        (fused_resource.fuse core1 rest1 \\<ddagger>\\<^sub>O\n         fused_resource.fuse core2 rest2)\n        x xa =\n       apply_state_iso parallel_state_iso\n        (fused_resource.fuse (parallel_core core1 core2)\n          (parallel_rest rest1 rest2))\n        x xa", "apply(clarsimp simp add: fused_wiring\\<^sub>w_def apply_state_iso_def parallel_state_iso_def parallel_wiring\\<^sub>w_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba xa.\n       apply_wiring\n        ((lassocr\\<^sub>w \\<circ>\\<^sub>w\n          ((id, id) |\\<^sub>w swap_lassocr\\<^sub>w \\<circ>\\<^sub>w\n           rassocl\\<^sub>w)) |\\<^sub>w\n         (lassocr\\<^sub>w \\<circ>\\<^sub>w\n          ((id, id) |\\<^sub>w swap_lassocr\\<^sub>w \\<circ>\\<^sub>w\n           rassocl\\<^sub>w)))\n        (apply_wiring lassocr\\<^sub>w\n          (apply_wiring ((id, id) |\\<^sub>w swap_lassocr\\<^sub>w)\n            (apply_wiring rassocl\\<^sub>w\n              (fused_resource.fuse core1 rest1 \\<ddagger>\\<^sub>O\n               fused_resource.fuse core2 rest2))))\n        ((a, b), aa, ba) xa =\n       map_spmf\n        (map_prod id\n          (\\<lambda>((s11, s12), s21, s22). ((s11, s21), s12, s22)))\n        (fused_resource.fuse (parallel_core core1 core2)\n          (parallel_rest rest1 rest2) ((a, aa), b, ba) xa)", "apply(simp add: apply_wiring_def comp_wiring_def parallel2_wiring_def lassocr\\<^sub>w_def swap_lassocr\\<^sub>w_def rassocl\\<^sub>w_def swap\\<^sub>w_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba xa.\n       map_spmf\n        (map_prod\n          (map_sum\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml))\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml)))\n          id)\n        (map_spmf (map_prod lsumr id)\n          (map_spmf\n            (map_prod\n              (map_sum id\n                (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)))\n              id)\n            (map_spmf (map_prod rsuml id)\n              ((fused_resource.fuse core1 rest1 \\<ddagger>\\<^sub>O\n                fused_resource.fuse core2 rest2)\n                ((a, b), aa, ba)\n                (lsumr\n                  (map_sum id\n                    (rsuml \\<circ> map_sum swap_sum id \\<circ> lsumr)\n                    (rsuml\n                      (map_sum\n                        (lsumr \\<circ>\n                         map_sum id\n                          (rsuml \\<circ> map_sum swap_sum id \\<circ>\n                           lsumr) \\<circ>\n                         rsuml)\n                        (lsumr \\<circ>\n                         map_sum id\n                          (rsuml \\<circ> map_sum swap_sum id \\<circ>\n                           lsumr) \\<circ>\n                         rsuml)\n                        xa)))))))) =\n       map_spmf\n        (map_prod id\n          (\\<lambda>((s11, s12), s21, s22). ((s11, s21), s12, s22)))\n        (fused_resource.fuse (parallel_core core1 core2)\n          (parallel_rest rest1 rest2) ((a, aa), b, ba) xa)", "subgoal for s_core1 s_rest1 s_core2 s_rest2 i"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf\n     (map_prod\n       (map_sum\n         (lsumr \\<circ>\n          (map_sum id\n            (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n           rsuml))\n         (lsumr \\<circ>\n          (map_sum id\n            (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n           rsuml)))\n       id)\n     (map_spmf (map_prod lsumr id)\n       (map_spmf\n         (map_prod\n           (map_sum id (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)))\n           id)\n         (map_spmf (map_prod rsuml id)\n           ((fused_resource.fuse core1 rest1 \\<ddagger>\\<^sub>O\n             fused_resource.fuse core2 rest2)\n             ((s_core1, s_rest1), s_core2, s_rest2)\n             (lsumr\n               (map_sum id (rsuml \\<circ> map_sum swap_sum id \\<circ> lsumr)\n                 (rsuml\n                   (map_sum\n                     (lsumr \\<circ>\n                      map_sum id\n                       (rsuml \\<circ> map_sum swap_sum id \\<circ>\n                        lsumr) \\<circ>\n                      rsuml)\n                     (lsumr \\<circ>\n                      map_sum id\n                       (rsuml \\<circ> map_sum swap_sum id \\<circ>\n                        lsumr) \\<circ>\n                      rsuml)\n                     i)))))))) =\n    map_spmf\n     (map_prod id (\\<lambda>((s11, s12), s21, s22). ((s11, s21), s12, s22)))\n     (fused_resource.fuse (parallel_core core1 core2)\n       (parallel_rest rest1 rest2) ((s_core1, s_core2), s_rest1, s_rest2) i)", "apply(cases \"(parallel_rest rest1 rest2, ((s_core1, s_core2), (s_rest1, s_rest2)), i)\" rule: fused_resource.fuse.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>rest state iadv_core.\n       (parallel_rest rest1 rest2, ((s_core1, s_core2), s_rest1, s_rest2),\n        i) =\n       (rest, state, Inl (Inl iadv_core)) \\<Longrightarrow>\n       map_spmf\n        (map_prod\n          (map_sum\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml))\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml)))\n          id)\n        (map_spmf (map_prod lsumr id)\n          (map_spmf\n            (map_prod\n              (map_sum id\n                (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)))\n              id)\n            (map_spmf (map_prod rsuml id)\n              ((fused_resource.fuse core1 rest1 \\<ddagger>\\<^sub>O\n                fused_resource.fuse core2 rest2)\n                ((s_core1, s_rest1), s_core2, s_rest2)\n                (lsumr\n                  (map_sum id\n                    (rsuml \\<circ> map_sum swap_sum id \\<circ> lsumr)\n                    (rsuml\n                      (map_sum\n                        (lsumr \\<circ>\n                         map_sum id\n                          (rsuml \\<circ> map_sum swap_sum id \\<circ>\n                           lsumr) \\<circ>\n                         rsuml)\n                        (lsumr \\<circ>\n                         map_sum id\n                          (rsuml \\<circ> map_sum swap_sum id \\<circ>\n                           lsumr) \\<circ>\n                         rsuml)\n                        i)))))))) =\n       map_spmf\n        (map_prod id\n          (\\<lambda>((s11, s12), s21, s22). ((s11, s21), s12, s22)))\n        (fused_resource.fuse (parallel_core core1 core2)\n          (parallel_rest rest1 rest2) ((s_core1, s_core2), s_rest1, s_rest2)\n          i)\n 2. \\<And>rest state iadv_rest.\n       (parallel_rest rest1 rest2, ((s_core1, s_core2), s_rest1, s_rest2),\n        i) =\n       (rest, state, Inl (Inr iadv_rest)) \\<Longrightarrow>\n       map_spmf\n        (map_prod\n          (map_sum\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml))\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml)))\n          id)\n        (map_spmf (map_prod lsumr id)\n          (map_spmf\n            (map_prod\n              (map_sum id\n                (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)))\n              id)\n            (map_spmf (map_prod rsuml id)\n              ((fused_resource.fuse core1 rest1 \\<ddagger>\\<^sub>O\n                fused_resource.fuse core2 rest2)\n                ((s_core1, s_rest1), s_core2, s_rest2)\n                (lsumr\n                  (map_sum id\n                    (rsuml \\<circ> map_sum swap_sum id \\<circ> lsumr)\n                    (rsuml\n                      (map_sum\n                        (lsumr \\<circ>\n                         map_sum id\n                          (rsuml \\<circ> map_sum swap_sum id \\<circ>\n                           lsumr) \\<circ>\n                         rsuml)\n                        (lsumr \\<circ>\n                         map_sum id\n                          (rsuml \\<circ> map_sum swap_sum id \\<circ>\n                           lsumr) \\<circ>\n                         rsuml)\n                        i)))))))) =\n       map_spmf\n        (map_prod id\n          (\\<lambda>((s11, s12), s21, s22). ((s11, s21), s12, s22)))\n        (fused_resource.fuse (parallel_core core1 core2)\n          (parallel_rest rest1 rest2) ((s_core1, s_core2), s_rest1, s_rest2)\n          i)\n 3. \\<And>rest state iusr_core.\n       (parallel_rest rest1 rest2, ((s_core1, s_core2), s_rest1, s_rest2),\n        i) =\n       (rest, state, Inr (Inl iusr_core)) \\<Longrightarrow>\n       map_spmf\n        (map_prod\n          (map_sum\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml))\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml)))\n          id)\n        (map_spmf (map_prod lsumr id)\n          (map_spmf\n            (map_prod\n              (map_sum id\n                (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)))\n              id)\n            (map_spmf (map_prod rsuml id)\n              ((fused_resource.fuse core1 rest1 \\<ddagger>\\<^sub>O\n                fused_resource.fuse core2 rest2)\n                ((s_core1, s_rest1), s_core2, s_rest2)\n                (lsumr\n                  (map_sum id\n                    (rsuml \\<circ> map_sum swap_sum id \\<circ> lsumr)\n                    (rsuml\n                      (map_sum\n                        (lsumr \\<circ>\n                         map_sum id\n                          (rsuml \\<circ> map_sum swap_sum id \\<circ>\n                           lsumr) \\<circ>\n                         rsuml)\n                        (lsumr \\<circ>\n                         map_sum id\n                          (rsuml \\<circ> map_sum swap_sum id \\<circ>\n                           lsumr) \\<circ>\n                         rsuml)\n                        i)))))))) =\n       map_spmf\n        (map_prod id\n          (\\<lambda>((s11, s12), s21, s22). ((s11, s21), s12, s22)))\n        (fused_resource.fuse (parallel_core core1 core2)\n          (parallel_rest rest1 rest2) ((s_core1, s_core2), s_rest1, s_rest2)\n          i)\n 4. \\<And>rest state iusr_rest.\n       (parallel_rest rest1 rest2, ((s_core1, s_core2), s_rest1, s_rest2),\n        i) =\n       (rest, state, Inr (Inr iusr_rest)) \\<Longrightarrow>\n       map_spmf\n        (map_prod\n          (map_sum\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml))\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml)))\n          id)\n        (map_spmf (map_prod lsumr id)\n          (map_spmf\n            (map_prod\n              (map_sum id\n                (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)))\n              id)\n            (map_spmf (map_prod rsuml id)\n              ((fused_resource.fuse core1 rest1 \\<ddagger>\\<^sub>O\n                fused_resource.fuse core2 rest2)\n                ((s_core1, s_rest1), s_core2, s_rest2)\n                (lsumr\n                  (map_sum id\n                    (rsuml \\<circ> map_sum swap_sum id \\<circ> lsumr)\n                    (rsuml\n                      (map_sum\n                        (lsumr \\<circ>\n                         map_sum id\n                          (rsuml \\<circ> map_sum swap_sum id \\<circ>\n                           lsumr) \\<circ>\n                         rsuml)\n                        (lsumr \\<circ>\n                         map_sum id\n                          (rsuml \\<circ> map_sum swap_sum id \\<circ>\n                           lsumr) \\<circ>\n                         rsuml)\n                        i)))))))) =\n       map_spmf\n        (map_prod id\n          (\\<lambda>((s11, s12), s21, s22). ((s11, s21), s12, s22)))\n        (fused_resource.fuse (parallel_core core1 core2)\n          (parallel_rest rest1 rest2) ((s_core1, s_core2), s_rest1, s_rest2)\n          i)", "apply(auto split!: sum.splits)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>iadv_core.\n       i = Inl (Inl iadv_core) \\<Longrightarrow>\n       map_spmf\n        (map_prod\n          (map_sum\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml))\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml)))\n          id)\n        (map_spmf (map_prod lsumr id)\n          (map_spmf\n            (map_prod\n              (map_sum id\n                (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)))\n              id)\n            (map_spmf (map_prod rsuml id)\n              ((fused_resource.fuse core1 rest1 \\<ddagger>\\<^sub>O\n                fused_resource.fuse core2 rest2)\n                ((s_core1, s_rest1), s_core2, s_rest2)\n                (lsumr\n                  (map_sum id\n                    (rsuml \\<circ> map_sum swap_sum id \\<circ> lsumr)\n                    (rsuml\n                      (Inl (lsumr\n                             (map_sum id\n                               (rsuml \\<circ> map_sum swap_sum id \\<circ>\n                                lsumr)\n                               (rsuml (Inl iadv_core)))))))))))) =\n       map_spmf\n        (map_prod id\n          (\\<lambda>((s11, s12), s21, s22). ((s11, s21), s12, s22)))\n        ((cfunc_adv core1 \\<ddagger>\\<^sub>O cfunc_adv core2)\n          (s_core1, s_core2) iadv_core \\<bind>\n         (\\<lambda>os_cfunc.\n             return_spmf\n              (map_prod (Inl \\<circ> Inl)\n                (prod.swap \\<circ> Pair (s_rest1, s_rest2)) os_cfunc)))\n 2. \\<And>iadv_rest.\n       i = Inl (Inr iadv_rest) \\<Longrightarrow>\n       map_spmf\n        (map_prod\n          (map_sum\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml))\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml)))\n          id)\n        (map_spmf (map_prod lsumr id)\n          (map_spmf\n            (map_prod\n              (map_sum id\n                (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)))\n              id)\n            (map_spmf (map_prod rsuml id)\n              ((fused_resource.fuse core1 rest1 \\<ddagger>\\<^sub>O\n                fused_resource.fuse core2 rest2)\n                ((s_core1, s_rest1), s_core2, s_rest2)\n                (lsumr\n                  (map_sum id\n                    (rsuml \\<circ> map_sum swap_sum id \\<circ> lsumr)\n                    (rsuml\n                      (Inl (lsumr\n                             (Inr (rsuml\n                                    (map_sum swap_sum id\n(lsumr (Inr iadv_rest)))))))))))))) =\n       map_spmf\n        (map_prod id\n          (\\<lambda>((s11, s12), s21, s22). ((s11, s21), s12, s22)))\n        (parallel_eoracle (rfunc_adv rest1) (rfunc_adv rest2)\n          (s_rest1, s_rest2) iadv_rest \\<bind>\n         (\\<lambda>((o_rfunc, e_lst), s_rfunc).\n             foldl_spmf (parallel_handler (cpoke core1) (cpoke core2))\n              (return_spmf (s_core1, s_core2)) e_lst \\<bind>\n             (\\<lambda>s_notify.\n                 return_spmf (Inl (Inr o_rfunc), s_notify, s_rfunc))))\n 3. \\<And>iusr_core.\n       i = Inr (Inl iusr_core) \\<Longrightarrow>\n       map_spmf\n        (map_prod\n          (map_sum\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml))\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml)))\n          id)\n        (map_spmf (map_prod lsumr id)\n          (map_spmf\n            (map_prod\n              (map_sum id\n                (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)))\n              id)\n            (map_spmf (map_prod rsuml id)\n              ((fused_resource.fuse core1 rest1 \\<ddagger>\\<^sub>O\n                fused_resource.fuse core2 rest2)\n                ((s_core1, s_rest1), s_core2, s_rest2)\n                (lsumr\n                  (Inr (rsuml\n                         (map_sum swap_sum id\n                           (lsumr\n                             (Inr (lsumr\n                                    (map_sum id\n(rsuml \\<circ> map_sum swap_sum id \\<circ> lsumr)\n(rsuml (Inl iusr_core)))))))))))))) =\n       map_spmf\n        (map_prod id\n          (\\<lambda>((s11, s12), s21, s22). ((s11, s21), s12, s22)))\n        ((cfunc_usr core1 \\<ddagger>\\<^sub>O cfunc_usr core2)\n          (s_core1, s_core2) iusr_core \\<bind>\n         (\\<lambda>os_cfunc.\n             return_spmf\n              (map_prod (Inr \\<circ> Inl)\n                (prod.swap \\<circ> Pair (s_rest1, s_rest2)) os_cfunc)))\n 4. \\<And>iusr_rest.\n       i = Inr (Inr iusr_rest) \\<Longrightarrow>\n       map_spmf\n        (map_prod\n          (map_sum\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml))\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml)))\n          id)\n        (map_spmf (map_prod lsumr id)\n          (map_spmf\n            (map_prod\n              (map_sum id\n                (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)))\n              id)\n            (map_spmf (map_prod rsuml id)\n              ((fused_resource.fuse core1 rest1 \\<ddagger>\\<^sub>O\n                fused_resource.fuse core2 rest2)\n                ((s_core1, s_rest1), s_core2, s_rest2)\n                (lsumr\n                  (Inr (rsuml\n                         (map_sum swap_sum id\n                           (lsumr\n                             (Inr (lsumr\n                                    (Inr\n(rsuml (map_sum swap_sum id (lsumr (Inr iusr_rest)))))))))))))))) =\n       map_spmf\n        (map_prod id\n          (\\<lambda>((s11, s12), s21, s22). ((s11, s21), s12, s22)))\n        (parallel_eoracle (rfunc_usr rest1) (rfunc_usr rest2)\n          (s_rest1, s_rest2) iusr_rest \\<bind>\n         (\\<lambda>((o_rfunc, e_lst), s_rfunc).\n             foldl_spmf (parallel_handler (cpoke core1) (cpoke core2))\n              (return_spmf (s_core1, s_core2)) e_lst \\<bind>\n             (\\<lambda>s_notify.\n                 return_spmf (Inr (Inr o_rfunc), s_notify, s_rfunc))))", "subgoal for iadv_core"], ["proof (prove)\ngoal (1 subgoal):\n 1. i = Inl (Inl iadv_core) \\<Longrightarrow>\n    map_spmf\n     (map_prod\n       (map_sum\n         (lsumr \\<circ>\n          (map_sum id\n            (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n           rsuml))\n         (lsumr \\<circ>\n          (map_sum id\n            (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n           rsuml)))\n       id)\n     (map_spmf (map_prod lsumr id)\n       (map_spmf\n         (map_prod\n           (map_sum id (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)))\n           id)\n         (map_spmf (map_prod rsuml id)\n           ((fused_resource.fuse core1 rest1 \\<ddagger>\\<^sub>O\n             fused_resource.fuse core2 rest2)\n             ((s_core1, s_rest1), s_core2, s_rest2)\n             (lsumr\n               (map_sum id (rsuml \\<circ> map_sum swap_sum id \\<circ> lsumr)\n                 (rsuml\n                   (Inl (lsumr\n                          (map_sum id\n                            (rsuml \\<circ> map_sum swap_sum id \\<circ>\n                             lsumr)\n                            (rsuml (Inl iadv_core)))))))))))) =\n    map_spmf\n     (map_prod id (\\<lambda>((s11, s12), s21, s22). ((s11, s21), s12, s22)))\n     ((cfunc_adv core1 \\<ddagger>\\<^sub>O cfunc_adv core2)\n       (s_core1, s_core2) iadv_core \\<bind>\n      (\\<lambda>os_cfunc.\n          return_spmf\n           (map_prod (Inl \\<circ> Inl)\n             (prod.swap \\<circ> Pair (s_rest1, s_rest2)) os_cfunc)))", "by (cases iadv_core) (auto simp add: map_spmf_bind_spmf bind_map_spmf intro!: bind_spmf_cong split!: sum.splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>iadv_rest.\n       i = Inl (Inr iadv_rest) \\<Longrightarrow>\n       map_spmf\n        (map_prod\n          (map_sum\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml))\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml)))\n          id)\n        (map_spmf (map_prod lsumr id)\n          (map_spmf\n            (map_prod\n              (map_sum id\n                (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)))\n              id)\n            (map_spmf (map_prod rsuml id)\n              ((fused_resource.fuse core1 rest1 \\<ddagger>\\<^sub>O\n                fused_resource.fuse core2 rest2)\n                ((s_core1, s_rest1), s_core2, s_rest2)\n                (lsumr\n                  (map_sum id\n                    (rsuml \\<circ> map_sum swap_sum id \\<circ> lsumr)\n                    (rsuml\n                      (Inl (lsumr\n                             (Inr (rsuml\n                                    (map_sum swap_sum id\n(lsumr (Inr iadv_rest)))))))))))))) =\n       map_spmf\n        (map_prod id\n          (\\<lambda>((s11, s12), s21, s22). ((s11, s21), s12, s22)))\n        (parallel_eoracle (rfunc_adv rest1) (rfunc_adv rest2)\n          (s_rest1, s_rest2) iadv_rest \\<bind>\n         (\\<lambda>((o_rfunc, e_lst), s_rfunc).\n             foldl_spmf (parallel_handler (cpoke core1) (cpoke core2))\n              (return_spmf (s_core1, s_core2)) e_lst \\<bind>\n             (\\<lambda>s_notify.\n                 return_spmf (Inl (Inr o_rfunc), s_notify, s_rfunc))))\n 2. \\<And>iusr_core.\n       i = Inr (Inl iusr_core) \\<Longrightarrow>\n       map_spmf\n        (map_prod\n          (map_sum\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml))\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml)))\n          id)\n        (map_spmf (map_prod lsumr id)\n          (map_spmf\n            (map_prod\n              (map_sum id\n                (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)))\n              id)\n            (map_spmf (map_prod rsuml id)\n              ((fused_resource.fuse core1 rest1 \\<ddagger>\\<^sub>O\n                fused_resource.fuse core2 rest2)\n                ((s_core1, s_rest1), s_core2, s_rest2)\n                (lsumr\n                  (Inr (rsuml\n                         (map_sum swap_sum id\n                           (lsumr\n                             (Inr (lsumr\n                                    (map_sum id\n(rsuml \\<circ> map_sum swap_sum id \\<circ> lsumr)\n(rsuml (Inl iusr_core)))))))))))))) =\n       map_spmf\n        (map_prod id\n          (\\<lambda>((s11, s12), s21, s22). ((s11, s21), s12, s22)))\n        ((cfunc_usr core1 \\<ddagger>\\<^sub>O cfunc_usr core2)\n          (s_core1, s_core2) iusr_core \\<bind>\n         (\\<lambda>os_cfunc.\n             return_spmf\n              (map_prod (Inr \\<circ> Inl)\n                (prod.swap \\<circ> Pair (s_rest1, s_rest2)) os_cfunc)))\n 3. \\<And>iusr_rest.\n       i = Inr (Inr iusr_rest) \\<Longrightarrow>\n       map_spmf\n        (map_prod\n          (map_sum\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml))\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml)))\n          id)\n        (map_spmf (map_prod lsumr id)\n          (map_spmf\n            (map_prod\n              (map_sum id\n                (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)))\n              id)\n            (map_spmf (map_prod rsuml id)\n              ((fused_resource.fuse core1 rest1 \\<ddagger>\\<^sub>O\n                fused_resource.fuse core2 rest2)\n                ((s_core1, s_rest1), s_core2, s_rest2)\n                (lsumr\n                  (Inr (rsuml\n                         (map_sum swap_sum id\n                           (lsumr\n                             (Inr (lsumr\n                                    (Inr\n(rsuml (map_sum swap_sum id (lsumr (Inr iusr_rest)))))))))))))))) =\n       map_spmf\n        (map_prod id\n          (\\<lambda>((s11, s12), s21, s22). ((s11, s21), s12, s22)))\n        (parallel_eoracle (rfunc_usr rest1) (rfunc_usr rest2)\n          (s_rest1, s_rest2) iusr_rest \\<bind>\n         (\\<lambda>((o_rfunc, e_lst), s_rfunc).\n             foldl_spmf (parallel_handler (cpoke core1) (cpoke core2))\n              (return_spmf (s_core1, s_core2)) e_lst \\<bind>\n             (\\<lambda>s_notify.\n                 return_spmf (Inr (Inr o_rfunc), s_notify, s_rfunc))))", "subgoal for iadv_rest"], ["proof (prove)\ngoal (1 subgoal):\n 1. i = Inl (Inr iadv_rest) \\<Longrightarrow>\n    map_spmf\n     (map_prod\n       (map_sum\n         (lsumr \\<circ>\n          (map_sum id\n            (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n           rsuml))\n         (lsumr \\<circ>\n          (map_sum id\n            (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n           rsuml)))\n       id)\n     (map_spmf (map_prod lsumr id)\n       (map_spmf\n         (map_prod\n           (map_sum id (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)))\n           id)\n         (map_spmf (map_prod rsuml id)\n           ((fused_resource.fuse core1 rest1 \\<ddagger>\\<^sub>O\n             fused_resource.fuse core2 rest2)\n             ((s_core1, s_rest1), s_core2, s_rest2)\n             (lsumr\n               (map_sum id (rsuml \\<circ> map_sum swap_sum id \\<circ> lsumr)\n                 (rsuml\n                   (Inl (lsumr\n                          (Inr (rsuml\n                                 (map_sum swap_sum id\n                                   (lsumr (Inr iadv_rest)))))))))))))) =\n    map_spmf\n     (map_prod id (\\<lambda>((s11, s12), s21, s22). ((s11, s21), s12, s22)))\n     (parallel_eoracle (rfunc_adv rest1) (rfunc_adv rest2)\n       (s_rest1, s_rest2) iadv_rest \\<bind>\n      (\\<lambda>((o_rfunc, e_lst), s_rfunc).\n          foldl_spmf (parallel_handler (cpoke core1) (cpoke core2))\n           (return_spmf (s_core1, s_core2)) e_lst \\<bind>\n          (\\<lambda>s_notify.\n              return_spmf (Inl (Inr o_rfunc), s_notify, s_rfunc))))", "by (cases iadv_rest) (auto simp add: parallel_handler_left parallel_handler_right foldl_spmf_pair_left \n        parallel_eoracle_def foldl_spmf_pair_right split_beta o_def map_spmf_bind_spmf bind_map_spmf)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>iusr_core.\n       i = Inr (Inl iusr_core) \\<Longrightarrow>\n       map_spmf\n        (map_prod\n          (map_sum\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml))\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml)))\n          id)\n        (map_spmf (map_prod lsumr id)\n          (map_spmf\n            (map_prod\n              (map_sum id\n                (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)))\n              id)\n            (map_spmf (map_prod rsuml id)\n              ((fused_resource.fuse core1 rest1 \\<ddagger>\\<^sub>O\n                fused_resource.fuse core2 rest2)\n                ((s_core1, s_rest1), s_core2, s_rest2)\n                (lsumr\n                  (Inr (rsuml\n                         (map_sum swap_sum id\n                           (lsumr\n                             (Inr (lsumr\n                                    (map_sum id\n(rsuml \\<circ> map_sum swap_sum id \\<circ> lsumr)\n(rsuml (Inl iusr_core)))))))))))))) =\n       map_spmf\n        (map_prod id\n          (\\<lambda>((s11, s12), s21, s22). ((s11, s21), s12, s22)))\n        ((cfunc_usr core1 \\<ddagger>\\<^sub>O cfunc_usr core2)\n          (s_core1, s_core2) iusr_core \\<bind>\n         (\\<lambda>os_cfunc.\n             return_spmf\n              (map_prod (Inr \\<circ> Inl)\n                (prod.swap \\<circ> Pair (s_rest1, s_rest2)) os_cfunc)))\n 2. \\<And>iusr_rest.\n       i = Inr (Inr iusr_rest) \\<Longrightarrow>\n       map_spmf\n        (map_prod\n          (map_sum\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml))\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml)))\n          id)\n        (map_spmf (map_prod lsumr id)\n          (map_spmf\n            (map_prod\n              (map_sum id\n                (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)))\n              id)\n            (map_spmf (map_prod rsuml id)\n              ((fused_resource.fuse core1 rest1 \\<ddagger>\\<^sub>O\n                fused_resource.fuse core2 rest2)\n                ((s_core1, s_rest1), s_core2, s_rest2)\n                (lsumr\n                  (Inr (rsuml\n                         (map_sum swap_sum id\n                           (lsumr\n                             (Inr (lsumr\n                                    (Inr\n(rsuml (map_sum swap_sum id (lsumr (Inr iusr_rest)))))))))))))))) =\n       map_spmf\n        (map_prod id\n          (\\<lambda>((s11, s12), s21, s22). ((s11, s21), s12, s22)))\n        (parallel_eoracle (rfunc_usr rest1) (rfunc_usr rest2)\n          (s_rest1, s_rest2) iusr_rest \\<bind>\n         (\\<lambda>((o_rfunc, e_lst), s_rfunc).\n             foldl_spmf (parallel_handler (cpoke core1) (cpoke core2))\n              (return_spmf (s_core1, s_core2)) e_lst \\<bind>\n             (\\<lambda>s_notify.\n                 return_spmf (Inr (Inr o_rfunc), s_notify, s_rfunc))))", "subgoal for iusr_core"], ["proof (prove)\ngoal (1 subgoal):\n 1. i = Inr (Inl iusr_core) \\<Longrightarrow>\n    map_spmf\n     (map_prod\n       (map_sum\n         (lsumr \\<circ>\n          (map_sum id\n            (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n           rsuml))\n         (lsumr \\<circ>\n          (map_sum id\n            (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n           rsuml)))\n       id)\n     (map_spmf (map_prod lsumr id)\n       (map_spmf\n         (map_prod\n           (map_sum id (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)))\n           id)\n         (map_spmf (map_prod rsuml id)\n           ((fused_resource.fuse core1 rest1 \\<ddagger>\\<^sub>O\n             fused_resource.fuse core2 rest2)\n             ((s_core1, s_rest1), s_core2, s_rest2)\n             (lsumr\n               (Inr (rsuml\n                      (map_sum swap_sum id\n                        (lsumr\n                          (Inr (lsumr\n                                 (map_sum id\n                                   (rsuml \\<circ>\n                                    map_sum swap_sum id \\<circ>\n                                    lsumr)\n                                   (rsuml (Inl iusr_core)))))))))))))) =\n    map_spmf\n     (map_prod id (\\<lambda>((s11, s12), s21, s22). ((s11, s21), s12, s22)))\n     ((cfunc_usr core1 \\<ddagger>\\<^sub>O cfunc_usr core2)\n       (s_core1, s_core2) iusr_core \\<bind>\n      (\\<lambda>os_cfunc.\n          return_spmf\n           (map_prod (Inr \\<circ> Inl)\n             (prod.swap \\<circ> Pair (s_rest1, s_rest2)) os_cfunc)))", "by (cases iusr_core) (auto simp add: map_spmf_bind_spmf bind_map_spmf intro!: bind_spmf_cong split!: sum.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>iusr_rest.\n       i = Inr (Inr iusr_rest) \\<Longrightarrow>\n       map_spmf\n        (map_prod\n          (map_sum\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml))\n            (lsumr \\<circ>\n             (map_sum id\n               (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n              rsuml)))\n          id)\n        (map_spmf (map_prod lsumr id)\n          (map_spmf\n            (map_prod\n              (map_sum id\n                (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)))\n              id)\n            (map_spmf (map_prod rsuml id)\n              ((fused_resource.fuse core1 rest1 \\<ddagger>\\<^sub>O\n                fused_resource.fuse core2 rest2)\n                ((s_core1, s_rest1), s_core2, s_rest2)\n                (lsumr\n                  (Inr (rsuml\n                         (map_sum swap_sum id\n                           (lsumr\n                             (Inr (lsumr\n                                    (Inr\n(rsuml (map_sum swap_sum id (lsumr (Inr iusr_rest)))))))))))))))) =\n       map_spmf\n        (map_prod id\n          (\\<lambda>((s11, s12), s21, s22). ((s11, s21), s12, s22)))\n        (parallel_eoracle (rfunc_usr rest1) (rfunc_usr rest2)\n          (s_rest1, s_rest2) iusr_rest \\<bind>\n         (\\<lambda>((o_rfunc, e_lst), s_rfunc).\n             foldl_spmf (parallel_handler (cpoke core1) (cpoke core2))\n              (return_spmf (s_core1, s_core2)) e_lst \\<bind>\n             (\\<lambda>s_notify.\n                 return_spmf (Inr (Inr o_rfunc), s_notify, s_rfunc))))", "subgoal for iusr_rest"], ["proof (prove)\ngoal (1 subgoal):\n 1. i = Inr (Inr iusr_rest) \\<Longrightarrow>\n    map_spmf\n     (map_prod\n       (map_sum\n         (lsumr \\<circ>\n          (map_sum id\n            (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n           rsuml))\n         (lsumr \\<circ>\n          (map_sum id\n            (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ>\n           rsuml)))\n       id)\n     (map_spmf (map_prod lsumr id)\n       (map_spmf\n         (map_prod\n           (map_sum id (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)))\n           id)\n         (map_spmf (map_prod rsuml id)\n           ((fused_resource.fuse core1 rest1 \\<ddagger>\\<^sub>O\n             fused_resource.fuse core2 rest2)\n             ((s_core1, s_rest1), s_core2, s_rest2)\n             (lsumr\n               (Inr (rsuml\n                      (map_sum swap_sum id\n                        (lsumr\n                          (Inr (lsumr\n                                 (Inr (rsuml\n  (map_sum swap_sum id (lsumr (Inr iusr_rest)))))))))))))))) =\n    map_spmf\n     (map_prod id (\\<lambda>((s11, s12), s21, s22). ((s11, s21), s12, s22)))\n     (parallel_eoracle (rfunc_usr rest1) (rfunc_usr rest2)\n       (s_rest1, s_rest2) iusr_rest \\<bind>\n      (\\<lambda>((o_rfunc, e_lst), s_rfunc).\n          foldl_spmf (parallel_handler (cpoke core1) (cpoke core2))\n           (return_spmf (s_core1, s_core2)) e_lst \\<bind>\n          (\\<lambda>s_notify.\n              return_spmf (Inr (Inr o_rfunc), s_notify, s_rfunc))))", "by (cases iusr_rest) (auto simp add: parallel_handler_left parallel_handler_right foldl_spmf_pair_left \n        parallel_eoracle_def foldl_spmf_pair_right split_beta o_def map_spmf_bind_spmf bind_map_spmf)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma attach_callee_fuse:\n  \"attach_callee ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest) (fused_resource.fuse core rest) =\n   apply_state_iso iso_trisplit (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core) (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. attach_callee\n     ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n      cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n     (fused_resource.fuse core rest) =\n    apply_state_iso iso_trisplit\n     (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n       (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))", "proof(intro ext; clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb xa.\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((a, b), aa, ba), ab, bb) xa =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((a, b), aa, ba), ab, bb) xa", "note fused_resource.fuse.simps [simp]"], ["proof (state)\nthis:\n  fused_resource.fuse ?core ?rest ?state (Inl (Inl ?iadv_core)) =\n  (let handle =\n         map_prod (Inl \\<circ> Inl) (prod.swap \\<circ> Pair (snd ?state))\n   in cfunc_adv ?core (fst ?state) ?iadv_core \\<bind>\n      (\\<lambda>os_cfunc. return_spmf (handle os_cfunc)))\n  fused_resource.fuse ?core ?rest ?state (Inl (Inr ?iadv_rest)) =\n  rfunc_adv ?rest (snd ?state) ?iadv_rest \\<bind>\n  (\\<lambda>((o_rfunc, e_lst), s_rfunc).\n      foldl_spmf (cpoke ?core) (return_spmf (fst ?state)) e_lst \\<bind>\n      (\\<lambda>s_notify.\n          return_spmf ((Inl \\<circ> Inr) o_rfunc, s_notify, s_rfunc)))\n  fused_resource.fuse ?core ?rest ?state (Inr (Inl ?iusr_core)) =\n  (let handle =\n         map_prod (Inr \\<circ> Inl) (prod.swap \\<circ> Pair (snd ?state))\n   in cfunc_usr ?core (fst ?state) ?iusr_core \\<bind>\n      (\\<lambda>os_cfunc. return_spmf (handle os_cfunc)))\n  fused_resource.fuse ?core ?rest ?state (Inr (Inr ?iusr_rest)) =\n  rfunc_usr ?rest (snd ?state) ?iusr_rest \\<bind>\n  (\\<lambda>((o_rfunc, e_lst), s_rfunc).\n      foldl_spmf (cpoke ?core) (return_spmf (fst ?state)) e_lst \\<bind>\n      (\\<lambda>s_notify.\n          return_spmf ((Inr \\<circ> Inr) o_rfunc, s_notify, s_rfunc)))\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb xa.\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((a, b), aa, ba), ab, bb) xa =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((a, b), aa, ba), ab, bb) xa", "let ?tri = \"\\<lambda>(((s11, s12), s13), (s21, s22), s23). (((s11, s21), s12, s22), s13, s23)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb xa.\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((a, b), aa, ba), ab, bb) xa =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((a, b), aa, ba), ab, bb) xa", "fix q :: \"('g + 'h) + 'i + 'j\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb xa.\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((a, b), aa, ba), ab, bb) xa =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((a, b), aa, ba), ab, bb) xa", "consider (ACore) qac where \"q = Inl (Inl qac)\"\n    | (ARest) qar where \"q = Inl (Inr qar)\"\n    | (UCore) quc where \"q = Inr (Inl quc)\"\n    | (URest) qur where \"q = Inr (Inr qur)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>qac. q = Inl (Inl qac) \\<Longrightarrow> thesis;\n     \\<And>qar. q = Inl (Inr qar) \\<Longrightarrow> thesis;\n     \\<And>quc. q = Inr (Inl quc) \\<Longrightarrow> thesis;\n     \\<And>qur. q = Inr (Inr qur) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using fuse_callee.cases"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>iadv_core. ?x = Inl (Inl iadv_core) \\<Longrightarrow> ?P;\n   \\<And>iadv_rest. ?x = Inl (Inr iadv_rest) \\<Longrightarrow> ?P;\n   \\<And>iusr_core. ?x = Inr (Inl iusr_core) \\<Longrightarrow> ?P;\n   \\<And>iusr_rest. ?x = Inr (Inr iusr_rest) \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>qac. q = Inl (Inl qac) \\<Longrightarrow> thesis;\n     \\<And>qar. q = Inl (Inr qar) \\<Longrightarrow> thesis;\n     \\<And>quc. q = Inr (Inl quc) \\<Longrightarrow> thesis;\n     \\<And>qur. q = Inr (Inr qur) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>qac. q = Inl (Inl qac) \\<Longrightarrow> ?thesis1;\n   \\<And>qar. q = Inl (Inr qar) \\<Longrightarrow> ?thesis1;\n   \\<And>quc. q = Inr (Inl quc) \\<Longrightarrow> ?thesis1;\n   \\<And>qur. q = Inr (Inr qur) \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba ab bb xa.\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((a, b), aa, ba), ab, bb) xa =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((a, b), aa, ba), ab, bb) xa", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>qac. q = Inl (Inl qac) \\<Longrightarrow> ?thesis1;\n   \\<And>qar. q = Inl (Inr qar) \\<Longrightarrow> ?thesis1;\n   \\<And>quc. q = Inr (Inl quc) \\<Longrightarrow> ?thesis1;\n   \\<And>qur. q = Inr (Inr qur) \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1", "show \"?lhs (((sac, sar), (suc, sur)), (sc, sr)) q = ?rhs (((sac, sar), (suc, sur)), (sc, sr)) q\"\n    for sac sar suc sur sc sr"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>qac. q = Inl (Inl qac) \\<Longrightarrow> ?thesis1;\n   \\<And>qar. q = Inl (Inr qar) \\<Longrightarrow> ?thesis1;\n   \\<And>quc. q = Inr (Inl quc) \\<Longrightarrow> ?thesis1;\n   \\<And>qur. q = Inr (Inr qur) \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. attach_callee\n     ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n      cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n     (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n    apply_state_iso iso_trisplit\n     (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n       (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n     (((sac, sar), suc, sur), sc, sr) q", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>qac.\n       q = Inl (Inl qac) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q\n 2. \\<And>qar.\n       q = Inl (Inr qar) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q\n 3. \\<And>quc.\n       q = Inr (Inl quc) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q\n 4. \\<And>qur.\n       q = Inr (Inr qur) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q", "case ACore"], ["proof (state)\nthis:\n  q = Inl (Inl qac)\n\ngoal (4 subgoals):\n 1. \\<And>qac.\n       q = Inl (Inl qac) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q\n 2. \\<And>qar.\n       q = Inl (Inr qar) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q\n 3. \\<And>quc.\n       q = Inr (Inl quc) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q\n 4. \\<And>qur.\n       q = Inr (Inr qur) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q", "have \"map_spmf rprodl (exec_gpv (fused_resource.fuse core rest)\n       (left_gpv (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id (left_gpv (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sar))) id (cnv_adv_core sac qac)))))\n       (sc, sr)) =\n     (map_spmf (map_prod (Inl \\<circ> Inl) (?tri \\<circ> prod.swap \\<circ> Pair ((sar, sur), sr)))\n       (map_spmf (\\<lambda>((oadv, s_adv'), s_core'). (oadv, (s_adv', suc), s_core'))\n         (exec_gpv (cfunc_adv core) (cnv_adv_core sac qac) sc)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf rprodl\n     (exec_gpv (fused_resource.fuse core rest)\n       (left_gpv\n         (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n           (left_gpv\n             (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sar))) id\n               (cnv_adv_core sac qac)))))\n       (sc, sr)) =\n    map_spmf\n     (map_prod (Inl \\<circ> Inl)\n       ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n            (((s11, s21), s12, s22), s13, s23)) \\<circ>\n        prod.swap \\<circ>\n        Pair ((sar, sur), sr)))\n     (map_spmf\n       (\\<lambda>((oadv, s_adv'), s_core'). (oadv, (s_adv', suc), s_core'))\n       (exec_gpv (cfunc_adv core) (cnv_adv_core sac qac) sc))", "proof(induction arbitrary: sc cnv_adv_core rule: exec_gpv_fixp_parallel_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb.\n            map_spmf rprodl\n             (curry (fst x)\n               (left_gpv\n                 (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n                   (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sar))) id\n                       (xb sac qac)))))\n               (xa, sr)) =\n            map_spmf\n             (map_prod (Inl \\<circ> Inl)\n               ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                    (((s11, s21), s12, s22), s13, s23)) \\<circ>\n                prod.swap \\<circ>\n                Pair ((sar, sur), sr)))\n             (map_spmf\n               (\\<lambda>((oadv, s_adv'), s_core').\n                   (oadv, (s_adv', suc), s_core'))\n               (curry (snd x) (xb sac qac) xa)))\n 2. \\<And>sc cnv_adv_core.\n       map_spmf rprodl (return_pmf None) =\n       map_spmf\n        (map_prod (Inl \\<circ> Inl)\n          ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n               (((s11, s21), s12, s22), s13, s23)) \\<circ>\n           prod.swap \\<circ>\n           Pair ((sar, sur), sr)))\n        (map_spmf\n          (\\<lambda>((oadv, s_adv'), s_core').\n              (oadv, (s_adv', suc), s_core'))\n          (return_pmf None))\n 3. \\<And>f g sc cnv_adv_core.\n       (\\<And>sc cnv_adv_core.\n           map_spmf rprodl\n            (f (left_gpv\n                 (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n                   (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sar))) id\n                       (cnv_adv_core sac qac)))))\n              (sc, sr)) =\n           map_spmf\n            (map_prod (Inl \\<circ> Inl)\n              ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                   (((s11, s21), s12, s22), s13, s23)) \\<circ>\n               prod.swap \\<circ>\n               Pair ((sar, sur), sr)))\n            (map_spmf\n              (\\<lambda>((oadv, s_adv'), s_core').\n                  (oadv, (s_adv', suc), s_core'))\n              (g (cnv_adv_core sac qac) sc))) \\<Longrightarrow>\n       map_spmf rprodl\n        (the_gpv\n          (left_gpv\n            (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n              (left_gpv\n                (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sar))) id\n                  (cnv_adv_core sac qac))))) \\<bind>\n         case_generat (\\<lambda>x. return_spmf (x, sc, sr))\n          (\\<lambda>out c.\n              fused_resource.fuse core rest (sc, sr) out \\<bind>\n              (\\<lambda>(x, y). f (c x) y))) =\n       map_spmf\n        (map_prod (Inl \\<circ> Inl)\n          ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n               (((s11, s21), s12, s22), s13, s23)) \\<circ>\n           prod.swap \\<circ>\n           Pair ((sar, sur), sr)))\n        (map_spmf\n          (\\<lambda>((oadv, s_adv'), s_core').\n              (oadv, (s_adv', suc), s_core'))\n          (the_gpv (cnv_adv_core sac qac) \\<bind>\n           case_generat (\\<lambda>x. return_spmf (x, sc))\n            (\\<lambda>out c.\n                cfunc_adv core sc out \\<bind>\n                (\\<lambda>(x, y). g (c x) y))))", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb.\n            map_spmf rprodl\n             (curry (fst x)\n               (left_gpv\n                 (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n                   (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sar))) id\n                       (xb sac qac)))))\n               (xa, sr)) =\n            map_spmf\n             (map_prod (Inl \\<circ> Inl)\n               ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                    (((s11, s21), s12, s22), s13, s23)) \\<circ>\n                prod.swap \\<circ>\n                Pair ((sar, sur), sr)))\n             (map_spmf\n               (\\<lambda>((oadv, s_adv'), s_core').\n                   (oadv, (s_adv', suc), s_core'))\n               (curry (snd x) (xb sac qac) xa)))\n 2. \\<And>sc cnv_adv_core.\n       map_spmf rprodl (return_pmf None) =\n       map_spmf\n        (map_prod (Inl \\<circ> Inl)\n          ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n               (((s11, s21), s12, s22), s13, s23)) \\<circ>\n           prod.swap \\<circ>\n           Pair ((sar, sur), sr)))\n        (map_spmf\n          (\\<lambda>((oadv, s_adv'), s_core').\n              (oadv, (s_adv', suc), s_core'))\n          (return_pmf None))\n 3. \\<And>f g sc cnv_adv_core.\n       (\\<And>sc cnv_adv_core.\n           map_spmf rprodl\n            (f (left_gpv\n                 (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n                   (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sar))) id\n                       (cnv_adv_core sac qac)))))\n              (sc, sr)) =\n           map_spmf\n            (map_prod (Inl \\<circ> Inl)\n              ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                   (((s11, s21), s12, s22), s13, s23)) \\<circ>\n               prod.swap \\<circ>\n               Pair ((sar, sur), sr)))\n            (map_spmf\n              (\\<lambda>((oadv, s_adv'), s_core').\n                  (oadv, (s_adv', suc), s_core'))\n              (g (cnv_adv_core sac qac) sc))) \\<Longrightarrow>\n       map_spmf rprodl\n        (the_gpv\n          (left_gpv\n            (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n              (left_gpv\n                (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sar))) id\n                  (cnv_adv_core sac qac))))) \\<bind>\n         case_generat (\\<lambda>x. return_spmf (x, sc, sr))\n          (\\<lambda>out c.\n              fused_resource.fuse core rest (sc, sr) out \\<bind>\n              (\\<lambda>(x, y). f (c x) y))) =\n       map_spmf\n        (map_prod (Inl \\<circ> Inl)\n          ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n               (((s11, s21), s12, s22), s13, s23)) \\<circ>\n           prod.swap \\<circ>\n           Pair ((sar, sur), sr)))\n        (map_spmf\n          (\\<lambda>((oadv, s_adv'), s_core').\n              (oadv, (s_adv', suc), s_core'))\n          (the_gpv (cnv_adv_core sac qac) \\<bind>\n           case_generat (\\<lambda>x. return_spmf (x, sc))\n            (\\<lambda>out c.\n                cfunc_adv core sc out \\<bind>\n                (\\<lambda>(x, y). g (c x) y))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xaa.\n            map_spmf rprodl\n             (curry (fst x)\n               (left_gpv\n                 (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n                   (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sar))) id\n                       (xaa sac qac)))))\n               (xa, sr)) =\n            map_spmf\n             (map_prod (Inl \\<circ> Inl)\n               ((\\<lambda>a.\n                    case a of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (a, b) \\<Rightarrow>\n                         (case a of\n                          (s11, s12) \\<Rightarrow>\n                            \\<lambda>s13 a.\n                               case a of\n                               (a, b) \\<Rightarrow>\n                                 (case a of\n                                  (s21, s22) \\<Rightarrow>\n                                    \\<lambda>s23.\n (((s11, s21), s12, s22), s13, s23))\n                                  b)\n                          b)\n                       b) \\<circ>\n                prod.swap \\<circ>\n                Pair ((sar, sur), sr)))\n             (map_spmf\n               (\\<lambda>a.\n                   case a of\n                   (a, b) \\<Rightarrow>\n                     (case a of\n                      (oadv, s_adv') \\<Rightarrow>\n                        \\<lambda>s_core'. (oadv, (s_adv', suc), s_core'))\n                      b)\n               (curry (snd x) (xaa sac qac) xa)))", "by simp"], ["proof (state)\nthis:\n  ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n   (rel_prod spmf.le_fun spmf.le_fun)\n   (\\<lambda>x.\n       \\<forall>xa xaa.\n          map_spmf rprodl\n           (curry (fst x)\n             (left_gpv\n               (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n                 (left_gpv\n                   (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sar))) id\n                     (xaa sac qac)))))\n             (xa, sr)) =\n          map_spmf\n           (map_prod (Inl \\<circ> Inl)\n             ((\\<lambda>a.\n                  case a of\n                  (a, b) \\<Rightarrow>\n                    (case a of\n                     (a, b) \\<Rightarrow>\n                       (case a of\n                        (s11, s12) \\<Rightarrow>\n                          \\<lambda>s13 a.\n                             case a of\n                             (a, b) \\<Rightarrow>\n                               (case a of\n                                (s21, s22) \\<Rightarrow>\n                                  \\<lambda>s23.\n                                     (((s11, s21), s12, s22), s13, s23))\n                                b)\n                        b)\n                     b) \\<circ>\n              prod.swap \\<circ>\n              Pair ((sar, sur), sr)))\n           (map_spmf\n             (\\<lambda>a.\n                 case a of\n                 (a, b) \\<Rightarrow>\n                   (case a of\n                    (oadv, s_adv') \\<Rightarrow>\n                      \\<lambda>s_core'. (oadv, (s_adv', suc), s_core'))\n                    b)\n             (curry (snd x) (xaa sac qac) xa)))\n\ngoal (2 subgoals):\n 1. \\<And>sc cnv_adv_core.\n       map_spmf rprodl (return_pmf None) =\n       map_spmf\n        (map_prod (Inl \\<circ> Inl)\n          ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n               (((s11, s21), s12, s22), s13, s23)) \\<circ>\n           prod.swap \\<circ>\n           Pair ((sar, sur), sr)))\n        (map_spmf\n          (\\<lambda>((oadv, s_adv'), s_core').\n              (oadv, (s_adv', suc), s_core'))\n          (return_pmf None))\n 2. \\<And>f g sc cnv_adv_core.\n       (\\<And>sc cnv_adv_core.\n           map_spmf rprodl\n            (f (left_gpv\n                 (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n                   (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sar))) id\n                       (cnv_adv_core sac qac)))))\n              (sc, sr)) =\n           map_spmf\n            (map_prod (Inl \\<circ> Inl)\n              ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                   (((s11, s21), s12, s22), s13, s23)) \\<circ>\n               prod.swap \\<circ>\n               Pair ((sar, sur), sr)))\n            (map_spmf\n              (\\<lambda>((oadv, s_adv'), s_core').\n                  (oadv, (s_adv', suc), s_core'))\n              (g (cnv_adv_core sac qac) sc))) \\<Longrightarrow>\n       map_spmf rprodl\n        (the_gpv\n          (left_gpv\n            (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n              (left_gpv\n                (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sar))) id\n                  (cnv_adv_core sac qac))))) \\<bind>\n         case_generat (\\<lambda>x. return_spmf (x, sc, sr))\n          (\\<lambda>out c.\n              fused_resource.fuse core rest (sc, sr) out \\<bind>\n              (\\<lambda>(x, y). f (c x) y))) =\n       map_spmf\n        (map_prod (Inl \\<circ> Inl)\n          ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n               (((s11, s21), s12, s22), s13, s23)) \\<circ>\n           prod.swap \\<circ>\n           Pair ((sar, sur), sr)))\n        (map_spmf\n          (\\<lambda>((oadv, s_adv'), s_core').\n              (oadv, (s_adv', suc), s_core'))\n          (the_gpv (cnv_adv_core sac qac) \\<bind>\n           case_generat (\\<lambda>x. return_spmf (x, sc))\n            (\\<lambda>out c.\n                cfunc_adv core sc out \\<bind>\n                (\\<lambda>(x, y). g (c x) y))))", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>sc cnv_adv_core.\n       map_spmf rprodl (return_pmf None) =\n       map_spmf\n        (map_prod (Inl \\<circ> Inl)\n          ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n               (((s11, s21), s12, s22), s13, s23)) \\<circ>\n           prod.swap \\<circ>\n           Pair ((sar, sur), sr)))\n        (map_spmf\n          (\\<lambda>((oadv, s_adv'), s_core').\n              (oadv, (s_adv', suc), s_core'))\n          (return_pmf None))\n 2. \\<And>f g sc cnv_adv_core.\n       (\\<And>sc cnv_adv_core.\n           map_spmf rprodl\n            (f (left_gpv\n                 (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n                   (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sar))) id\n                       (cnv_adv_core sac qac)))))\n              (sc, sr)) =\n           map_spmf\n            (map_prod (Inl \\<circ> Inl)\n              ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                   (((s11, s21), s12, s22), s13, s23)) \\<circ>\n               prod.swap \\<circ>\n               Pair ((sar, sur), sr)))\n            (map_spmf\n              (\\<lambda>((oadv, s_adv'), s_core').\n                  (oadv, (s_adv', suc), s_core'))\n              (g (cnv_adv_core sac qac) sc))) \\<Longrightarrow>\n       map_spmf rprodl\n        (the_gpv\n          (left_gpv\n            (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n              (left_gpv\n                (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sar))) id\n                  (cnv_adv_core sac qac))))) \\<bind>\n         case_generat (\\<lambda>x. return_spmf (x, sc, sr))\n          (\\<lambda>out c.\n              fused_resource.fuse core rest (sc, sr) out \\<bind>\n              (\\<lambda>(x, y). f (c x) y))) =\n       map_spmf\n        (map_prod (Inl \\<circ> Inl)\n          ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n               (((s11, s21), s12, s22), s13, s23)) \\<circ>\n           prod.swap \\<circ>\n           Pair ((sar, sur), sr)))\n        (map_spmf\n          (\\<lambda>((oadv, s_adv'), s_core').\n              (oadv, (s_adv', suc), s_core'))\n          (the_gpv (cnv_adv_core sac qac) \\<bind>\n           case_generat (\\<lambda>x. return_spmf (x, sc))\n            (\\<lambda>out c.\n                cfunc_adv core sc out \\<bind>\n                (\\<lambda>(x, y). g (c x) y))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf rprodl (return_pmf None) =\n    map_spmf\n     (map_prod (Inl \\<circ> Inl)\n       ((\\<lambda>a.\n            case a of\n            (a, b) \\<Rightarrow>\n              (case a of\n               (a, b) \\<Rightarrow>\n                 (case a of\n                  (s11, s12) \\<Rightarrow>\n                    \\<lambda>s13 a.\n                       case a of\n                       (a, b) \\<Rightarrow>\n                         (case a of\n                          (s21, s22) \\<Rightarrow>\n                            \\<lambda>s23.\n                               (((s11, s21), s12, s22), s13, s23))\n                          b)\n                  b)\n               b) \\<circ>\n        prod.swap \\<circ>\n        Pair ((sar, sur), sr)))\n     (map_spmf\n       (\\<lambda>a.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of\n              (oadv, s_adv') \\<Rightarrow>\n                \\<lambda>s_core'. (oadv, (s_adv', suc), s_core'))\n              b)\n       (return_pmf None))", "by simp"], ["proof (state)\nthis:\n  map_spmf rprodl (return_pmf None) =\n  map_spmf\n   (map_prod (Inl \\<circ> Inl)\n     ((\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (a, b) \\<Rightarrow>\n               (case a of\n                (s11, s12) \\<Rightarrow>\n                  \\<lambda>s13 a.\n                     case a of\n                     (a, b) \\<Rightarrow>\n                       (case a of\n                        (s21, s22) \\<Rightarrow>\n                          \\<lambda>s23. (((s11, s21), s12, s22), s13, s23))\n                        b)\n                b)\n             b) \\<circ>\n      prod.swap \\<circ>\n      Pair ((sar, sur), sr)))\n   (map_spmf\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (oadv, s_adv') \\<Rightarrow>\n              \\<lambda>s_core'. (oadv, (s_adv', suc), s_core'))\n            b)\n     (return_pmf None))\n\ngoal (1 subgoal):\n 1. \\<And>f g sc cnv_adv_core.\n       (\\<And>sc cnv_adv_core.\n           map_spmf rprodl\n            (f (left_gpv\n                 (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n                   (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sar))) id\n                       (cnv_adv_core sac qac)))))\n              (sc, sr)) =\n           map_spmf\n            (map_prod (Inl \\<circ> Inl)\n              ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                   (((s11, s21), s12, s22), s13, s23)) \\<circ>\n               prod.swap \\<circ>\n               Pair ((sar, sur), sr)))\n            (map_spmf\n              (\\<lambda>((oadv, s_adv'), s_core').\n                  (oadv, (s_adv', suc), s_core'))\n              (g (cnv_adv_core sac qac) sc))) \\<Longrightarrow>\n       map_spmf rprodl\n        (the_gpv\n          (left_gpv\n            (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n              (left_gpv\n                (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sar))) id\n                  (cnv_adv_core sac qac))))) \\<bind>\n         case_generat (\\<lambda>x. return_spmf (x, sc, sr))\n          (\\<lambda>out c.\n              fused_resource.fuse core rest (sc, sr) out \\<bind>\n              (\\<lambda>(x, y). f (c x) y))) =\n       map_spmf\n        (map_prod (Inl \\<circ> Inl)\n          ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n               (((s11, s21), s12, s22), s13, s23)) \\<circ>\n           prod.swap \\<circ>\n           Pair ((sar, sur), sr)))\n        (map_spmf\n          (\\<lambda>((oadv, s_adv'), s_core').\n              (oadv, (s_adv', suc), s_core'))\n          (the_gpv (cnv_adv_core sac qac) \\<bind>\n           case_generat (\\<lambda>x. return_spmf (x, sc))\n            (\\<lambda>out c.\n                cfunc_adv core sc out \\<bind>\n                (\\<lambda>(x, y). g (c x) y))))", "case (step execl execr)"], ["proof (state)\nthis:\n  map_spmf rprodl\n   (execl\n     (left_gpv\n       (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n         (left_gpv\n           (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sar))) id\n             (?cnv_adv_core1 sac qac)))))\n     (?sc1, sr)) =\n  map_spmf\n   (map_prod (Inl \\<circ> Inl)\n     ((\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (a, b) \\<Rightarrow>\n               (case a of\n                (s11, s12) \\<Rightarrow>\n                  \\<lambda>s13 a.\n                     case a of\n                     (a, b) \\<Rightarrow>\n                       (case a of\n                        (s21, s22) \\<Rightarrow>\n                          \\<lambda>s23. (((s11, s21), s12, s22), s13, s23))\n                        b)\n                b)\n             b) \\<circ>\n      prod.swap \\<circ>\n      Pair ((sar, sur), sr)))\n   (map_spmf\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (oadv, s_adv') \\<Rightarrow>\n              \\<lambda>s_core'. (oadv, (s_adv', suc), s_core'))\n            b)\n     (execr (?cnv_adv_core1 sac qac) ?sc1))\n\ngoal (1 subgoal):\n 1. \\<And>f g sc cnv_adv_core.\n       (\\<And>sc cnv_adv_core.\n           map_spmf rprodl\n            (f (left_gpv\n                 (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n                   (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sar))) id\n                       (cnv_adv_core sac qac)))))\n              (sc, sr)) =\n           map_spmf\n            (map_prod (Inl \\<circ> Inl)\n              ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                   (((s11, s21), s12, s22), s13, s23)) \\<circ>\n               prod.swap \\<circ>\n               Pair ((sar, sur), sr)))\n            (map_spmf\n              (\\<lambda>((oadv, s_adv'), s_core').\n                  (oadv, (s_adv', suc), s_core'))\n              (g (cnv_adv_core sac qac) sc))) \\<Longrightarrow>\n       map_spmf rprodl\n        (the_gpv\n          (left_gpv\n            (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n              (left_gpv\n                (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sar))) id\n                  (cnv_adv_core sac qac))))) \\<bind>\n         case_generat (\\<lambda>x. return_spmf (x, sc, sr))\n          (\\<lambda>out c.\n              fused_resource.fuse core rest (sc, sr) out \\<bind>\n              (\\<lambda>(x, y). f (c x) y))) =\n       map_spmf\n        (map_prod (Inl \\<circ> Inl)\n          ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n               (((s11, s21), s12, s22), s13, s23)) \\<circ>\n           prod.swap \\<circ>\n           Pair ((sar, sur), sr)))\n        (map_spmf\n          (\\<lambda>((oadv, s_adv'), s_core').\n              (oadv, (s_adv', suc), s_core'))\n          (the_gpv (cnv_adv_core sac qac) \\<bind>\n           case_generat (\\<lambda>x. return_spmf (x, sc))\n            (\\<lambda>out c.\n                cfunc_adv core sc out \\<bind>\n                (\\<lambda>(x, y). g (c x) y))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf rprodl\n     (the_gpv\n       (left_gpv\n         (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n           (left_gpv\n             (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sar))) id\n               (cnv_adv_core sac qac))))) \\<bind>\n      (\\<lambda>a.\n          case a of Pure x \\<Rightarrow> return_spmf (x, sc, sr)\n          | IO out c \\<Rightarrow>\n              fused_resource.fuse core rest (sc, sr) out \\<bind>\n              (\\<lambda>a. case a of (x, y) \\<Rightarrow> execl (c x) y))) =\n    map_spmf\n     (map_prod (Inl \\<circ> Inl)\n       ((\\<lambda>a.\n            case a of\n            (a, b) \\<Rightarrow>\n              (case a of\n               (a, b) \\<Rightarrow>\n                 (case a of\n                  (s11, s12) \\<Rightarrow>\n                    \\<lambda>s13 a.\n                       case a of\n                       (a, b) \\<Rightarrow>\n                         (case a of\n                          (s21, s22) \\<Rightarrow>\n                            \\<lambda>s23.\n                               (((s11, s21), s12, s22), s13, s23))\n                          b)\n                  b)\n               b) \\<circ>\n        prod.swap \\<circ>\n        Pair ((sar, sur), sr)))\n     (map_spmf\n       (\\<lambda>a.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of\n              (oadv, s_adv') \\<Rightarrow>\n                \\<lambda>s_core'. (oadv, (s_adv', suc), s_core'))\n              b)\n       (the_gpv (cnv_adv_core sac qac) \\<bind>\n        (\\<lambda>a.\n            case a of Pure x \\<Rightarrow> return_spmf (x, sc)\n            | IO out c \\<Rightarrow>\n                cfunc_adv core sc out \\<bind>\n                (\\<lambda>a.\n                    case a of (x, y) \\<Rightarrow> execr (c x) y))))", "apply(clarsimp simp add: gpv.map_sel map_bind_spmf bind_map_spmf intro!: bind_spmf_cong[OF refl] split!: generat.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21a x22a a b.\n       \\<lbrakk>IO x21a x22a\n                \\<in> set_spmf (the_gpv (cnv_adv_core sac qac));\n        (a, b) \\<in> set_spmf (cfunc_adv core sc x21a)\\<rbrakk>\n       \\<Longrightarrow> map_spmf rprodl\n                          (execl\n                            (left_gpv\n                              (map_gpv\n                                (map_prod Inl\n                                  (\\<lambda>s1'. (s1', suc, sur)))\n                                (\\<lambda>a. a)\n                                (left_gpv\n                                  (map_gpv\n                                    (map_prod Inl\n(\\<lambda>s1'. (s1', sar)))\n                                    (\\<lambda>a. a) (x22a a)))))\n                            (b, sr)) =\n                         map_spmf\n                          (map_prod (\\<lambda>a. Inl (Inl a))\n                            (\\<lambda>a.\n                                (case a of\n                                 (x, xa) \\<Rightarrow>\n                                   (case x of\n                                    (s11, s12) \\<Rightarrow>\n\\<lambda>s13 ((s21, s22), s23). (((s11, s21), s12, s22), s13, s23))\n                                    xa)\n                                 ((sar, sur), sr)))\n                          (map_spmf\n                            (\\<lambda>((oadv, s_adv'), s_core').\n                                (oadv, (s_adv', suc), s_core'))\n                            (execr (x22a a) b))", "apply(subst step.IH[unfolded id_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21a x22a a b.\n       \\<lbrakk>IO x21a x22a\n                \\<in> set_spmf (the_gpv (cnv_adv_core sac qac));\n        (a, b) \\<in> set_spmf (cfunc_adv core sc x21a)\\<rbrakk>\n       \\<Longrightarrow> map_spmf\n                          (map_prod (Inl \\<circ> Inl)\n                            ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                                 (((s11, s21), s12, s22), s13, s23)) \\<circ>\n                             prod.swap \\<circ>\n                             Pair ((sar, sur), sr)))\n                          (map_spmf\n                            (\\<lambda>((oadv, s_adv'), s_core').\n                                (oadv, (s_adv', suc), s_core'))\n                            (execr (x22a a) b)) =\n                         map_spmf\n                          (map_prod (\\<lambda>a. Inl (Inl a))\n                            (\\<lambda>a.\n                                (case a of\n                                 (x, xa) \\<Rightarrow>\n                                   (case x of\n                                    (s11, s12) \\<Rightarrow>\n\\<lambda>s13 ((s21, s22), s23). (((s11, s21), s12, s22), s13, s23))\n                                    xa)\n                                 ((sar, sur), sr)))\n                          (map_spmf\n                            (\\<lambda>((oadv, s_adv'), s_core').\n                                (oadv, (s_adv', suc), s_core'))\n                            (execr (x22a a) b))", "apply(simp add: spmf.map_comp o_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_spmf rprodl\n   (the_gpv\n     (left_gpv\n       (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n         (left_gpv\n           (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sar))) id\n             (cnv_adv_core sac qac))))) \\<bind>\n    (\\<lambda>a.\n        case a of Pure x \\<Rightarrow> return_spmf (x, sc, sr)\n        | IO out c \\<Rightarrow>\n            fused_resource.fuse core rest (sc, sr) out \\<bind>\n            (\\<lambda>a. case a of (x, y) \\<Rightarrow> execl (c x) y))) =\n  map_spmf\n   (map_prod (Inl \\<circ> Inl)\n     ((\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (a, b) \\<Rightarrow>\n               (case a of\n                (s11, s12) \\<Rightarrow>\n                  \\<lambda>s13 a.\n                     case a of\n                     (a, b) \\<Rightarrow>\n                       (case a of\n                        (s21, s22) \\<Rightarrow>\n                          \\<lambda>s23. (((s11, s21), s12, s22), s13, s23))\n                        b)\n                b)\n             b) \\<circ>\n      prod.swap \\<circ>\n      Pair ((sar, sur), sr)))\n   (map_spmf\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (oadv, s_adv') \\<Rightarrow>\n              \\<lambda>s_core'. (oadv, (s_adv', suc), s_core'))\n            b)\n     (the_gpv (cnv_adv_core sac qac) \\<bind>\n      (\\<lambda>a.\n          case a of Pure x \\<Rightarrow> return_spmf (x, sc)\n          | IO out c \\<Rightarrow>\n              cfunc_adv core sc out \\<bind>\n              (\\<lambda>a. case a of (x, y) \\<Rightarrow> execr (c x) y))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_spmf rprodl\n   (exec_gpv (fused_resource.fuse core rest)\n     (left_gpv\n       (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n         (left_gpv\n           (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sar))) id\n             (cnv_adv_core sac qac)))))\n     (sc, sr)) =\n  map_spmf\n   (map_prod (Inl \\<circ> Inl)\n     ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n          (((s11, s21), s12, s22), s13, s23)) \\<circ>\n      prod.swap \\<circ>\n      Pair ((sar, sur), sr)))\n   (map_spmf\n     (\\<lambda>((oadv, s_adv'), s_core'). (oadv, (s_adv', suc), s_core'))\n     (exec_gpv (cfunc_adv core) (cnv_adv_core sac qac) sc))\n\ngoal (4 subgoals):\n 1. \\<And>qac.\n       q = Inl (Inl qac) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q\n 2. \\<And>qar.\n       q = Inl (Inr qar) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q\n 3. \\<And>quc.\n       q = Inr (Inl quc) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q\n 4. \\<And>qur.\n       q = Inr (Inr qur) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q", "then"], ["proof (chain)\npicking this:\n  map_spmf rprodl\n   (exec_gpv (fused_resource.fuse core rest)\n     (left_gpv\n       (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n         (left_gpv\n           (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sar))) id\n             (cnv_adv_core sac qac)))))\n     (sc, sr)) =\n  map_spmf\n   (map_prod (Inl \\<circ> Inl)\n     ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n          (((s11, s21), s12, s22), s13, s23)) \\<circ>\n      prod.swap \\<circ>\n      Pair ((sar, sur), sr)))\n   (map_spmf\n     (\\<lambda>((oadv, s_adv'), s_core'). (oadv, (s_adv', suc), s_core'))\n     (exec_gpv (cfunc_adv core) (cnv_adv_core sac qac) sc))", "show ?thesis"], ["proof (prove)\nusing this:\n  map_spmf rprodl\n   (exec_gpv (fused_resource.fuse core rest)\n     (left_gpv\n       (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n         (left_gpv\n           (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sar))) id\n             (cnv_adv_core sac qac)))))\n     (sc, sr)) =\n  map_spmf\n   (map_prod (Inl \\<circ> Inl)\n     ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n          (((s11, s21), s12, s22), s13, s23)) \\<circ>\n      prod.swap \\<circ>\n      Pair ((sar, sur), sr)))\n   (map_spmf\n     (\\<lambda>((oadv, s_adv'), s_core'). (oadv, (s_adv', suc), s_core'))\n     (exec_gpv (cfunc_adv core) (cnv_adv_core sac qac) sc))\n\ngoal (1 subgoal):\n 1. attach_callee\n     ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n      cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n     (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n    apply_state_iso iso_trisplit\n     (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n       (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n     (((sac, sar), suc, sur), sc, sr) q", "using ACore"], ["proof (prove)\nusing this:\n  map_spmf rprodl\n   (exec_gpv (fused_resource.fuse core rest)\n     (left_gpv\n       (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n         (left_gpv\n           (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sar))) id\n             (cnv_adv_core sac qac)))))\n     (sc, sr)) =\n  map_spmf\n   (map_prod (Inl \\<circ> Inl)\n     ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n          (((s11, s21), s12, s22), s13, s23)) \\<circ>\n      prod.swap \\<circ>\n      Pair ((sar, sur), sr)))\n   (map_spmf\n     (\\<lambda>((oadv, s_adv'), s_core'). (oadv, (s_adv', suc), s_core'))\n     (exec_gpv (cfunc_adv core) (cnv_adv_core sac qac) sc))\n  q = Inl (Inl qac)\n\ngoal (1 subgoal):\n 1. attach_callee\n     ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n      cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n     (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n    apply_state_iso iso_trisplit\n     (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n       (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n     (((sac, sar), suc, sur), sc, sr) q", "by(simp add: apply_state_iso_def iso_trisplit_def map_spmf_conv_bind_spmf[symmetric] spmf.map_comp o_def split_def)"], ["proof (state)\nthis:\n  attach_callee\n   ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n    cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n   (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n  apply_state_iso iso_trisplit\n   (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n     (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n   (((sac, sar), suc, sur), sc, sr) q\n\ngoal (3 subgoals):\n 1. \\<And>qar.\n       q = Inl (Inr qar) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q\n 2. \\<And>quc.\n       q = Inr (Inl quc) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q\n 3. \\<And>qur.\n       q = Inr (Inr qur) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>qar.\n       q = Inl (Inr qar) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q\n 2. \\<And>quc.\n       q = Inr (Inl quc) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q\n 3. \\<And>qur.\n       q = Inr (Inr qur) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q", "case ARest"], ["proof (state)\nthis:\n  q = Inl (Inr qar)\n\ngoal (3 subgoals):\n 1. \\<And>qar.\n       q = Inl (Inr qar) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q\n 2. \\<And>quc.\n       q = Inr (Inl quc) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q\n 3. \\<And>qur.\n       q = Inr (Inr qur) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q", "have \"bind_spmf (foldl_spmf (cpoke core) (return_spmf sc) es) (\\<lambda>sc'.\n      map_spmf rprodl (exec_gpv (fused_resource.fuse core rest)\n        (left_gpv (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id (right_gpv (map_gpv (map_prod Inr (Pair sac)) id (cnv_adv_rest sar qar)))))\n        (sc', sr))) =\n      bind_spmf\n        (exec_gpv (\\<lambda>(s, es) q. map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e)) (rfunc_adv rest s q)) (cnv_adv_rest sar qar) (sr, es))\n        (map_spmf (map_prod id ?tri) \\<circ>\n          ((\\<lambda>((o_rfunc, e_lst), s_rfunc). map_spmf (\\<lambda>s_notify. (Inl (Inr o_rfunc), s_notify, s_rfunc))\n            (map_spmf (Pair (sac, suc)) (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n          (\\<lambda>((oadv, s_adv'), s_rest', es). ((oadv, es), (s_adv', sur), s_rest'))))\"\n      for es"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n    (\\<lambda>sc'.\n        map_spmf rprodl\n         (exec_gpv (fused_resource.fuse core rest)\n           (left_gpv\n             (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n               (right_gpv\n                 (map_gpv (map_prod Inr (Pair sac)) id\n                   (cnv_adv_rest sar qar)))))\n           (sc', sr))) =\n    exec_gpv\n     (\\<lambda>(s, es) q.\n         map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n          (rfunc_adv rest s q))\n     (cnv_adv_rest sar qar) (sr, es) \\<bind>\n    map_spmf\n     (map_prod id\n       (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n           (((s11, s21), s12, s22), s13, s23))) \\<circ>\n    ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n         map_spmf\n          (\\<lambda>s_notify. (Inl (Inr o_rfunc), s_notify, s_rfunc))\n          (map_spmf (Pair (sac, suc))\n            (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n     (\\<lambda>((oadv, s_adv'), s_rest', es).\n         ((oadv, es), (s_adv', sur), s_rest')))", "proof(induction arbitrary: sc sr es cnv_adv_rest rule: exec_gpv_fixp_parallel_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb xc xd.\n            foldl_spmf (cpoke core) (return_spmf xa) xc \\<bind>\n            (\\<lambda>sc'.\n                map_spmf rprodl\n                 (curry (fst x)\n                   (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur)))\n                       id (right_gpv\n                            (map_gpv (map_prod Inr (Pair sac)) id\n                              (xd sar qar)))))\n                   (sc', xb))) =\n            curry (snd x) (xd sar qar) (xb, xc) \\<bind>\n            map_spmf\n             (map_prod id\n               (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                   (((s11, s21), s12, s22), s13, s23))) \\<circ>\n            ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n                 map_spmf\n                  (\\<lambda>s_notify.\n                      (Inl (Inr o_rfunc), s_notify, s_rfunc))\n                  (map_spmf (Pair (sac, suc))\n                    (foldl_spmf (cpoke core) (return_spmf xa)\n                      e_lst))) \\<circ>\n             (\\<lambda>((oadv, s_adv'), s_rest', es).\n                 ((oadv, es), (s_adv', sur), s_rest'))))\n 2. \\<And>sc sr es cnv_adv_rest.\n       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n       (\\<lambda>sc'. map_spmf rprodl (return_pmf None)) =\n       return_pmf None \\<bind>\n       map_spmf\n        (map_prod id\n          (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n              (((s11, s21), s12, s22), s13, s23))) \\<circ>\n       ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n            map_spmf\n             (\\<lambda>s_notify. (Inl (Inr o_rfunc), s_notify, s_rfunc))\n             (map_spmf (Pair (sac, suc))\n               (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n        (\\<lambda>((oadv, s_adv'), s_rest', es).\n            ((oadv, es), (s_adv', sur), s_rest')))\n 3. \\<And>f g sc sr es cnv_adv_rest.\n       (\\<And>sc sr es cnv_adv_rest.\n           foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n           (\\<lambda>sc'.\n               map_spmf rprodl\n                (f (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur)))\n                       id (right_gpv\n                            (map_gpv (map_prod Inr (Pair sac)) id\n                              (cnv_adv_rest sar qar)))))\n                  (sc', sr))) =\n           g (cnv_adv_rest sar qar) (sr, es) \\<bind>\n           map_spmf\n            (map_prod id\n              (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                  (((s11, s21), s12, s22), s13, s23))) \\<circ>\n           ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n                map_spmf\n                 (\\<lambda>s_notify. (Inl (Inr o_rfunc), s_notify, s_rfunc))\n                 (map_spmf (Pair (sac, suc))\n                   (foldl_spmf (cpoke core) (return_spmf sc)\n                     e_lst))) \\<circ>\n            (\\<lambda>((oadv, s_adv'), s_rest', es).\n                ((oadv, es), (s_adv', sur), s_rest')))) \\<Longrightarrow>\n       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n       (\\<lambda>sc'.\n           map_spmf rprodl\n            (the_gpv\n              (left_gpv\n                (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n                  (right_gpv\n                    (map_gpv (map_prod Inr (Pair sac)) id\n                      (cnv_adv_rest sar qar))))) \\<bind>\n             case_generat (\\<lambda>x. return_spmf (x, sc', sr))\n              (\\<lambda>out c.\n                  fused_resource.fuse core rest (sc', sr) out \\<bind>\n                  (\\<lambda>(x, y). f (c x) y)))) =\n       the_gpv (cnv_adv_rest sar qar) \\<bind>\n       case_generat (\\<lambda>x. return_spmf (x, sr, es))\n        (\\<lambda>out c.\n            (case (sr, es) of\n             (s, es) \\<Rightarrow>\n               \\<lambda>q.\n                  map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n                   (rfunc_adv rest s q))\n             out \\<bind>\n            (\\<lambda>(x, y). g (c x) y)) \\<bind>\n       map_spmf\n        (map_prod id\n          (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n              (((s11, s21), s12, s22), s13, s23))) \\<circ>\n       ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n            map_spmf\n             (\\<lambda>s_notify. (Inl (Inr o_rfunc), s_notify, s_rfunc))\n             (map_spmf (Pair (sac, suc))\n               (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n        (\\<lambda>((oadv, s_adv'), s_rest', es).\n            ((oadv, es), (s_adv', sur), s_rest')))", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb xc xd.\n            foldl_spmf (cpoke core) (return_spmf xa) xc \\<bind>\n            (\\<lambda>sc'.\n                map_spmf rprodl\n                 (curry (fst x)\n                   (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur)))\n                       id (right_gpv\n                            (map_gpv (map_prod Inr (Pair sac)) id\n                              (xd sar qar)))))\n                   (sc', xb))) =\n            curry (snd x) (xd sar qar) (xb, xc) \\<bind>\n            map_spmf\n             (map_prod id\n               (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                   (((s11, s21), s12, s22), s13, s23))) \\<circ>\n            ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n                 map_spmf\n                  (\\<lambda>s_notify.\n                      (Inl (Inr o_rfunc), s_notify, s_rfunc))\n                  (map_spmf (Pair (sac, suc))\n                    (foldl_spmf (cpoke core) (return_spmf xa)\n                      e_lst))) \\<circ>\n             (\\<lambda>((oadv, s_adv'), s_rest', es).\n                 ((oadv, es), (s_adv', sur), s_rest'))))\n 2. \\<And>sc sr es cnv_adv_rest.\n       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n       (\\<lambda>sc'. map_spmf rprodl (return_pmf None)) =\n       return_pmf None \\<bind>\n       map_spmf\n        (map_prod id\n          (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n              (((s11, s21), s12, s22), s13, s23))) \\<circ>\n       ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n            map_spmf\n             (\\<lambda>s_notify. (Inl (Inr o_rfunc), s_notify, s_rfunc))\n             (map_spmf (Pair (sac, suc))\n               (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n        (\\<lambda>((oadv, s_adv'), s_rest', es).\n            ((oadv, es), (s_adv', sur), s_rest')))\n 3. \\<And>f g sc sr es cnv_adv_rest.\n       (\\<And>sc sr es cnv_adv_rest.\n           foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n           (\\<lambda>sc'.\n               map_spmf rprodl\n                (f (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur)))\n                       id (right_gpv\n                            (map_gpv (map_prod Inr (Pair sac)) id\n                              (cnv_adv_rest sar qar)))))\n                  (sc', sr))) =\n           g (cnv_adv_rest sar qar) (sr, es) \\<bind>\n           map_spmf\n            (map_prod id\n              (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                  (((s11, s21), s12, s22), s13, s23))) \\<circ>\n           ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n                map_spmf\n                 (\\<lambda>s_notify. (Inl (Inr o_rfunc), s_notify, s_rfunc))\n                 (map_spmf (Pair (sac, suc))\n                   (foldl_spmf (cpoke core) (return_spmf sc)\n                     e_lst))) \\<circ>\n            (\\<lambda>((oadv, s_adv'), s_rest', es).\n                ((oadv, es), (s_adv', sur), s_rest')))) \\<Longrightarrow>\n       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n       (\\<lambda>sc'.\n           map_spmf rprodl\n            (the_gpv\n              (left_gpv\n                (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n                  (right_gpv\n                    (map_gpv (map_prod Inr (Pair sac)) id\n                      (cnv_adv_rest sar qar))))) \\<bind>\n             case_generat (\\<lambda>x. return_spmf (x, sc', sr))\n              (\\<lambda>out c.\n                  fused_resource.fuse core rest (sc', sr) out \\<bind>\n                  (\\<lambda>(x, y). f (c x) y)))) =\n       the_gpv (cnv_adv_rest sar qar) \\<bind>\n       case_generat (\\<lambda>x. return_spmf (x, sr, es))\n        (\\<lambda>out c.\n            (case (sr, es) of\n             (s, es) \\<Rightarrow>\n               \\<lambda>q.\n                  map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n                   (rfunc_adv rest s q))\n             out \\<bind>\n            (\\<lambda>(x, y). g (c x) y)) \\<bind>\n       map_spmf\n        (map_prod id\n          (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n              (((s11, s21), s12, s22), s13, s23))) \\<circ>\n       ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n            map_spmf\n             (\\<lambda>s_notify. (Inl (Inr o_rfunc), s_notify, s_rfunc))\n             (map_spmf (Pair (sac, suc))\n               (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n        (\\<lambda>((oadv, s_adv'), s_rest', es).\n            ((oadv, es), (s_adv', sur), s_rest')))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xaa xaaa xaaaa.\n            foldl_spmf (cpoke core) (return_spmf xa) xaaa \\<bind>\n            (\\<lambda>sc'.\n                map_spmf rprodl\n                 (curry (fst x)\n                   (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur)))\n                       id (right_gpv\n                            (map_gpv (map_prod Inr (Pair sac)) id\n                              (xaaaa sar qar)))))\n                   (sc', xaa))) =\n            curry (snd x) (xaaaa sar qar) (xaa, xaaa) \\<bind>\n            map_spmf\n             (map_prod id\n               (\\<lambda>a.\n                   case a of\n                   (a, b) \\<Rightarrow>\n                     (case a of\n                      (a, b) \\<Rightarrow>\n                        (case a of\n                         (s11, s12) \\<Rightarrow>\n                           \\<lambda>s13 a.\n                              case a of\n                              (a, b) \\<Rightarrow>\n                                (case a of\n                                 (s21, s22) \\<Rightarrow>\n                                   \\<lambda>s23.\n(((s11, s21), s12, s22), s13, s23))\n                                 b)\n                         b)\n                      b)) \\<circ>\n            ((\\<lambda>a.\n                 case a of\n                 (a, b) \\<Rightarrow>\n                   (case a of\n                    (o_rfunc, e_lst) \\<Rightarrow>\n                      \\<lambda>s_rfunc.\n                         map_spmf\n                          (\\<lambda>s_notify.\n                              (Inl (Inr o_rfunc), s_notify, s_rfunc))\n                          (map_spmf (Pair (sac, suc))\n                            (foldl_spmf (cpoke core) (return_spmf xa)\n                              e_lst)))\n                    b) \\<circ>\n             (\\<lambda>a.\n                 case a of\n                 (a, b) \\<Rightarrow>\n                   (case a of\n                    (oadv, s_adv') \\<Rightarrow>\n                      \\<lambda>a.\n                         case a of\n                         (s_rest', es) \\<Rightarrow>\n                           ((oadv, es), (s_adv', sur), s_rest'))\n                    b)))", "by simp"], ["proof (state)\nthis:\n  ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n   (rel_prod spmf.le_fun spmf.le_fun)\n   (\\<lambda>x.\n       \\<forall>xa xaa xaaa xaaaa.\n          foldl_spmf (cpoke core) (return_spmf xa) xaaa \\<bind>\n          (\\<lambda>sc'.\n              map_spmf rprodl\n               (curry (fst x)\n                 (left_gpv\n                   (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur)))\n                     id (right_gpv\n                          (map_gpv (map_prod Inr (Pair sac)) id\n                            (xaaaa sar qar)))))\n                 (sc', xaa))) =\n          curry (snd x) (xaaaa sar qar) (xaa, xaaa) \\<bind>\n          map_spmf\n           (map_prod id\n             (\\<lambda>a.\n                 case a of\n                 (a, b) \\<Rightarrow>\n                   (case a of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (s11, s12) \\<Rightarrow>\n                         \\<lambda>s13 a.\n                            case a of\n                            (a, b) \\<Rightarrow>\n                              (case a of\n                               (s21, s22) \\<Rightarrow>\n                                 \\<lambda>s23.\n                                    (((s11, s21), s12, s22), s13, s23))\n                               b)\n                       b)\n                    b)) \\<circ>\n          ((\\<lambda>a.\n               case a of\n               (a, b) \\<Rightarrow>\n                 (case a of\n                  (o_rfunc, e_lst) \\<Rightarrow>\n                    \\<lambda>s_rfunc.\n                       map_spmf\n                        (\\<lambda>s_notify.\n                            (Inl (Inr o_rfunc), s_notify, s_rfunc))\n                        (map_spmf (Pair (sac, suc))\n                          (foldl_spmf (cpoke core) (return_spmf xa) e_lst)))\n                  b) \\<circ>\n           (\\<lambda>a.\n               case a of\n               (a, b) \\<Rightarrow>\n                 (case a of\n                  (oadv, s_adv') \\<Rightarrow>\n                    \\<lambda>a.\n                       case a of\n                       (s_rest', es) \\<Rightarrow>\n                         ((oadv, es), (s_adv', sur), s_rest'))\n                  b)))\n\ngoal (2 subgoals):\n 1. \\<And>sc sr es cnv_adv_rest.\n       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n       (\\<lambda>sc'. map_spmf rprodl (return_pmf None)) =\n       return_pmf None \\<bind>\n       map_spmf\n        (map_prod id\n          (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n              (((s11, s21), s12, s22), s13, s23))) \\<circ>\n       ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n            map_spmf\n             (\\<lambda>s_notify. (Inl (Inr o_rfunc), s_notify, s_rfunc))\n             (map_spmf (Pair (sac, suc))\n               (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n        (\\<lambda>((oadv, s_adv'), s_rest', es).\n            ((oadv, es), (s_adv', sur), s_rest')))\n 2. \\<And>f g sc sr es cnv_adv_rest.\n       (\\<And>sc sr es cnv_adv_rest.\n           foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n           (\\<lambda>sc'.\n               map_spmf rprodl\n                (f (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur)))\n                       id (right_gpv\n                            (map_gpv (map_prod Inr (Pair sac)) id\n                              (cnv_adv_rest sar qar)))))\n                  (sc', sr))) =\n           g (cnv_adv_rest sar qar) (sr, es) \\<bind>\n           map_spmf\n            (map_prod id\n              (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                  (((s11, s21), s12, s22), s13, s23))) \\<circ>\n           ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n                map_spmf\n                 (\\<lambda>s_notify. (Inl (Inr o_rfunc), s_notify, s_rfunc))\n                 (map_spmf (Pair (sac, suc))\n                   (foldl_spmf (cpoke core) (return_spmf sc)\n                     e_lst))) \\<circ>\n            (\\<lambda>((oadv, s_adv'), s_rest', es).\n                ((oadv, es), (s_adv', sur), s_rest')))) \\<Longrightarrow>\n       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n       (\\<lambda>sc'.\n           map_spmf rprodl\n            (the_gpv\n              (left_gpv\n                (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n                  (right_gpv\n                    (map_gpv (map_prod Inr (Pair sac)) id\n                      (cnv_adv_rest sar qar))))) \\<bind>\n             case_generat (\\<lambda>x. return_spmf (x, sc', sr))\n              (\\<lambda>out c.\n                  fused_resource.fuse core rest (sc', sr) out \\<bind>\n                  (\\<lambda>(x, y). f (c x) y)))) =\n       the_gpv (cnv_adv_rest sar qar) \\<bind>\n       case_generat (\\<lambda>x. return_spmf (x, sr, es))\n        (\\<lambda>out c.\n            (case (sr, es) of\n             (s, es) \\<Rightarrow>\n               \\<lambda>q.\n                  map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n                   (rfunc_adv rest s q))\n             out \\<bind>\n            (\\<lambda>(x, y). g (c x) y)) \\<bind>\n       map_spmf\n        (map_prod id\n          (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n              (((s11, s21), s12, s22), s13, s23))) \\<circ>\n       ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n            map_spmf\n             (\\<lambda>s_notify. (Inl (Inr o_rfunc), s_notify, s_rfunc))\n             (map_spmf (Pair (sac, suc))\n               (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n        (\\<lambda>((oadv, s_adv'), s_rest', es).\n            ((oadv, es), (s_adv', sur), s_rest')))", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>sc sr es cnv_adv_rest.\n       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n       (\\<lambda>sc'. map_spmf rprodl (return_pmf None)) =\n       return_pmf None \\<bind>\n       map_spmf\n        (map_prod id\n          (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n              (((s11, s21), s12, s22), s13, s23))) \\<circ>\n       ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n            map_spmf\n             (\\<lambda>s_notify. (Inl (Inr o_rfunc), s_notify, s_rfunc))\n             (map_spmf (Pair (sac, suc))\n               (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n        (\\<lambda>((oadv, s_adv'), s_rest', es).\n            ((oadv, es), (s_adv', sur), s_rest')))\n 2. \\<And>f g sc sr es cnv_adv_rest.\n       (\\<And>sc sr es cnv_adv_rest.\n           foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n           (\\<lambda>sc'.\n               map_spmf rprodl\n                (f (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur)))\n                       id (right_gpv\n                            (map_gpv (map_prod Inr (Pair sac)) id\n                              (cnv_adv_rest sar qar)))))\n                  (sc', sr))) =\n           g (cnv_adv_rest sar qar) (sr, es) \\<bind>\n           map_spmf\n            (map_prod id\n              (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                  (((s11, s21), s12, s22), s13, s23))) \\<circ>\n           ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n                map_spmf\n                 (\\<lambda>s_notify. (Inl (Inr o_rfunc), s_notify, s_rfunc))\n                 (map_spmf (Pair (sac, suc))\n                   (foldl_spmf (cpoke core) (return_spmf sc)\n                     e_lst))) \\<circ>\n            (\\<lambda>((oadv, s_adv'), s_rest', es).\n                ((oadv, es), (s_adv', sur), s_rest')))) \\<Longrightarrow>\n       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n       (\\<lambda>sc'.\n           map_spmf rprodl\n            (the_gpv\n              (left_gpv\n                (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n                  (right_gpv\n                    (map_gpv (map_prod Inr (Pair sac)) id\n                      (cnv_adv_rest sar qar))))) \\<bind>\n             case_generat (\\<lambda>x. return_spmf (x, sc', sr))\n              (\\<lambda>out c.\n                  fused_resource.fuse core rest (sc', sr) out \\<bind>\n                  (\\<lambda>(x, y). f (c x) y)))) =\n       the_gpv (cnv_adv_rest sar qar) \\<bind>\n       case_generat (\\<lambda>x. return_spmf (x, sr, es))\n        (\\<lambda>out c.\n            (case (sr, es) of\n             (s, es) \\<Rightarrow>\n               \\<lambda>q.\n                  map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n                   (rfunc_adv rest s q))\n             out \\<bind>\n            (\\<lambda>(x, y). g (c x) y)) \\<bind>\n       map_spmf\n        (map_prod id\n          (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n              (((s11, s21), s12, s22), s13, s23))) \\<circ>\n       ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n            map_spmf\n             (\\<lambda>s_notify. (Inl (Inr o_rfunc), s_notify, s_rfunc))\n             (map_spmf (Pair (sac, suc))\n               (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n        (\\<lambda>((oadv, s_adv'), s_rest', es).\n            ((oadv, es), (s_adv', sur), s_rest')))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n    (\\<lambda>sc'. map_spmf rprodl (return_pmf None)) =\n    return_pmf None \\<bind>\n    map_spmf\n     (map_prod id\n       (\\<lambda>a.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of\n              (a, b) \\<Rightarrow>\n                (case a of\n                 (s11, s12) \\<Rightarrow>\n                   \\<lambda>s13 a.\n                      case a of\n                      (a, b) \\<Rightarrow>\n                        (case a of\n                         (s21, s22) \\<Rightarrow>\n                           \\<lambda>s23. (((s11, s21), s12, s22), s13, s23))\n                         b)\n                 b)\n              b)) \\<circ>\n    ((\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (o_rfunc, e_lst) \\<Rightarrow>\n              \\<lambda>s_rfunc.\n                 map_spmf\n                  (\\<lambda>s_notify.\n                      (Inl (Inr o_rfunc), s_notify, s_rfunc))\n                  (map_spmf (Pair (sac, suc))\n                    (foldl_spmf (cpoke core) (return_spmf sc) e_lst)))\n            b) \\<circ>\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (oadv, s_adv') \\<Rightarrow>\n              \\<lambda>a.\n                 case a of\n                 (s_rest', es) \\<Rightarrow>\n                   ((oadv, es), (s_adv', sur), s_rest'))\n            b))", "by simp"], ["proof (state)\nthis:\n  foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n  (\\<lambda>sc'. map_spmf rprodl (return_pmf None)) =\n  return_pmf None \\<bind>\n  map_spmf\n   (map_prod id\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (a, b) \\<Rightarrow>\n              (case a of\n               (s11, s12) \\<Rightarrow>\n                 \\<lambda>s13 a.\n                    case a of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (s21, s22) \\<Rightarrow>\n                         \\<lambda>s23. (((s11, s21), s12, s22), s13, s23))\n                       b)\n               b)\n            b)) \\<circ>\n  ((\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (o_rfunc, e_lst) \\<Rightarrow>\n            \\<lambda>s_rfunc.\n               map_spmf\n                (\\<lambda>s_notify. (Inl (Inr o_rfunc), s_notify, s_rfunc))\n                (map_spmf (Pair (sac, suc))\n                  (foldl_spmf (cpoke core) (return_spmf sc) e_lst)))\n          b) \\<circ>\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (oadv, s_adv') \\<Rightarrow>\n            \\<lambda>a.\n               case a of\n               (s_rest', es) \\<Rightarrow>\n                 ((oadv, es), (s_adv', sur), s_rest'))\n          b))\n\ngoal (1 subgoal):\n 1. \\<And>f g sc sr es cnv_adv_rest.\n       (\\<And>sc sr es cnv_adv_rest.\n           foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n           (\\<lambda>sc'.\n               map_spmf rprodl\n                (f (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur)))\n                       id (right_gpv\n                            (map_gpv (map_prod Inr (Pair sac)) id\n                              (cnv_adv_rest sar qar)))))\n                  (sc', sr))) =\n           g (cnv_adv_rest sar qar) (sr, es) \\<bind>\n           map_spmf\n            (map_prod id\n              (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                  (((s11, s21), s12, s22), s13, s23))) \\<circ>\n           ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n                map_spmf\n                 (\\<lambda>s_notify. (Inl (Inr o_rfunc), s_notify, s_rfunc))\n                 (map_spmf (Pair (sac, suc))\n                   (foldl_spmf (cpoke core) (return_spmf sc)\n                     e_lst))) \\<circ>\n            (\\<lambda>((oadv, s_adv'), s_rest', es).\n                ((oadv, es), (s_adv', sur), s_rest')))) \\<Longrightarrow>\n       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n       (\\<lambda>sc'.\n           map_spmf rprodl\n            (the_gpv\n              (left_gpv\n                (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n                  (right_gpv\n                    (map_gpv (map_prod Inr (Pair sac)) id\n                      (cnv_adv_rest sar qar))))) \\<bind>\n             case_generat (\\<lambda>x. return_spmf (x, sc', sr))\n              (\\<lambda>out c.\n                  fused_resource.fuse core rest (sc', sr) out \\<bind>\n                  (\\<lambda>(x, y). f (c x) y)))) =\n       the_gpv (cnv_adv_rest sar qar) \\<bind>\n       case_generat (\\<lambda>x. return_spmf (x, sr, es))\n        (\\<lambda>out c.\n            (case (sr, es) of\n             (s, es) \\<Rightarrow>\n               \\<lambda>q.\n                  map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n                   (rfunc_adv rest s q))\n             out \\<bind>\n            (\\<lambda>(x, y). g (c x) y)) \\<bind>\n       map_spmf\n        (map_prod id\n          (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n              (((s11, s21), s12, s22), s13, s23))) \\<circ>\n       ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n            map_spmf\n             (\\<lambda>s_notify. (Inl (Inr o_rfunc), s_notify, s_rfunc))\n             (map_spmf (Pair (sac, suc))\n               (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n        (\\<lambda>((oadv, s_adv'), s_rest', es).\n            ((oadv, es), (s_adv', sur), s_rest')))", "case (step execl execr)"], ["proof (state)\nthis:\n  foldl_spmf (cpoke core) (return_spmf ?sc1) ?es1 \\<bind>\n  (\\<lambda>sc'.\n      map_spmf rprodl\n       (execl\n         (left_gpv\n           (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n             (right_gpv\n               (map_gpv (map_prod Inr (Pair sac)) id\n                 (?cnv_adv_rest1 sar qar)))))\n         (sc', ?sr1))) =\n  execr (?cnv_adv_rest1 sar qar) (?sr1, ?es1) \\<bind>\n  map_spmf\n   (map_prod id\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (a, b) \\<Rightarrow>\n              (case a of\n               (s11, s12) \\<Rightarrow>\n                 \\<lambda>s13 a.\n                    case a of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (s21, s22) \\<Rightarrow>\n                         \\<lambda>s23. (((s11, s21), s12, s22), s13, s23))\n                       b)\n               b)\n            b)) \\<circ>\n  ((\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (o_rfunc, e_lst) \\<Rightarrow>\n            \\<lambda>s_rfunc.\n               map_spmf\n                (\\<lambda>s_notify. (Inl (Inr o_rfunc), s_notify, s_rfunc))\n                (map_spmf (Pair (sac, suc))\n                  (foldl_spmf (cpoke core) (return_spmf ?sc1) e_lst)))\n          b) \\<circ>\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (oadv, s_adv') \\<Rightarrow>\n            \\<lambda>a.\n               case a of\n               (s_rest', es) \\<Rightarrow>\n                 ((oadv, es), (s_adv', sur), s_rest'))\n          b))\n\ngoal (1 subgoal):\n 1. \\<And>f g sc sr es cnv_adv_rest.\n       (\\<And>sc sr es cnv_adv_rest.\n           foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n           (\\<lambda>sc'.\n               map_spmf rprodl\n                (f (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur)))\n                       id (right_gpv\n                            (map_gpv (map_prod Inr (Pair sac)) id\n                              (cnv_adv_rest sar qar)))))\n                  (sc', sr))) =\n           g (cnv_adv_rest sar qar) (sr, es) \\<bind>\n           map_spmf\n            (map_prod id\n              (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                  (((s11, s21), s12, s22), s13, s23))) \\<circ>\n           ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n                map_spmf\n                 (\\<lambda>s_notify. (Inl (Inr o_rfunc), s_notify, s_rfunc))\n                 (map_spmf (Pair (sac, suc))\n                   (foldl_spmf (cpoke core) (return_spmf sc)\n                     e_lst))) \\<circ>\n            (\\<lambda>((oadv, s_adv'), s_rest', es).\n                ((oadv, es), (s_adv', sur), s_rest')))) \\<Longrightarrow>\n       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n       (\\<lambda>sc'.\n           map_spmf rprodl\n            (the_gpv\n              (left_gpv\n                (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n                  (right_gpv\n                    (map_gpv (map_prod Inr (Pair sac)) id\n                      (cnv_adv_rest sar qar))))) \\<bind>\n             case_generat (\\<lambda>x. return_spmf (x, sc', sr))\n              (\\<lambda>out c.\n                  fused_resource.fuse core rest (sc', sr) out \\<bind>\n                  (\\<lambda>(x, y). f (c x) y)))) =\n       the_gpv (cnv_adv_rest sar qar) \\<bind>\n       case_generat (\\<lambda>x. return_spmf (x, sr, es))\n        (\\<lambda>out c.\n            (case (sr, es) of\n             (s, es) \\<Rightarrow>\n               \\<lambda>q.\n                  map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n                   (rfunc_adv rest s q))\n             out \\<bind>\n            (\\<lambda>(x, y). g (c x) y)) \\<bind>\n       map_spmf\n        (map_prod id\n          (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n              (((s11, s21), s12, s22), s13, s23))) \\<circ>\n       ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n            map_spmf\n             (\\<lambda>s_notify. (Inl (Inr o_rfunc), s_notify, s_rfunc))\n             (map_spmf (Pair (sac, suc))\n               (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n        (\\<lambda>((oadv, s_adv'), s_rest', es).\n            ((oadv, es), (s_adv', sur), s_rest')))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n    (\\<lambda>sc'.\n        map_spmf rprodl\n         (the_gpv\n           (left_gpv\n             (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n               (right_gpv\n                 (map_gpv (map_prod Inr (Pair sac)) id\n                   (cnv_adv_rest sar qar))))) \\<bind>\n          (\\<lambda>a.\n              case a of Pure x \\<Rightarrow> return_spmf (x, sc', sr)\n              | IO out c \\<Rightarrow>\n                  fused_resource.fuse core rest (sc', sr) out \\<bind>\n                  (\\<lambda>a.\n                      case a of (x, y) \\<Rightarrow> execl (c x) y)))) =\n    the_gpv (cnv_adv_rest sar qar) \\<bind>\n    (\\<lambda>a.\n        case a of Pure x \\<Rightarrow> return_spmf (x, sr, es)\n        | IO out c \\<Rightarrow>\n            (case (sr, es) of\n             (s, es) \\<Rightarrow>\n               \\<lambda>q.\n                  map_spmf\n                   (\\<lambda>a.\n                       case a of\n                       (a, b) \\<Rightarrow>\n                         (case a of\n                          (out, e) \\<Rightarrow>\n                            \\<lambda>s'. (out, s', es @ e))\n                          b)\n                   (rfunc_adv rest s q))\n             out \\<bind>\n            (\\<lambda>a.\n                case a of (x, y) \\<Rightarrow> execr (c x) y)) \\<bind>\n    map_spmf\n     (map_prod id\n       (\\<lambda>a.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of\n              (a, b) \\<Rightarrow>\n                (case a of\n                 (s11, s12) \\<Rightarrow>\n                   \\<lambda>s13 a.\n                      case a of\n                      (a, b) \\<Rightarrow>\n                        (case a of\n                         (s21, s22) \\<Rightarrow>\n                           \\<lambda>s23. (((s11, s21), s12, s22), s13, s23))\n                         b)\n                 b)\n              b)) \\<circ>\n    ((\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (o_rfunc, e_lst) \\<Rightarrow>\n              \\<lambda>s_rfunc.\n                 map_spmf\n                  (\\<lambda>s_notify.\n                      (Inl (Inr o_rfunc), s_notify, s_rfunc))\n                  (map_spmf (Pair (sac, suc))\n                    (foldl_spmf (cpoke core) (return_spmf sc) e_lst)))\n            b) \\<circ>\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (oadv, s_adv') \\<Rightarrow>\n              \\<lambda>a.\n                 case a of\n                 (s_rest', es) \\<Rightarrow>\n                   ((oadv, es), (s_adv', sur), s_rest'))\n            b))", "apply(clarsimp simp add: gpv.map_sel map_bind_spmf bind_map_spmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n    (\\<lambda>sc'.\n        the_gpv (cnv_adv_rest sar qar) \\<bind>\n        map_spmf rprodl \\<circ>\n        (case_generat (\\<lambda>x. return_spmf (x, sc', sr))\n          (\\<lambda>out c.\n              fused_resource.fuse core rest (sc', sr) out \\<bind>\n              (\\<lambda>(x, y). execl (c x) y)) \\<circ>\n         map_generat id Inl left_rpv \\<circ>\n         map_generat (map_prod Inl (\\<lambda>s1'. (s1', suc, sur)))\n          (\\<lambda>a. a)\n          ((\\<circ>)\n            (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur)))\n              (\\<lambda>a. a))) \\<circ>\n         map_generat id Inr right_rpv \\<circ>\n         map_generat (map_prod Inr (Pair sac)) (\\<lambda>a. a)\n          ((\\<circ>)\n            (map_gpv (map_prod Inr (Pair sac)) (\\<lambda>a. a))))) =\n    the_gpv (cnv_adv_rest sar qar) \\<bind>\n    (\\<lambda>y.\n        (case y of Pure x \\<Rightarrow> return_spmf (x, sr, es)\n         | IO out c \\<Rightarrow>\n             map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n              (rfunc_adv rest sr out) \\<bind>\n             (\\<lambda>(x, y). execr (c x) y)) \\<bind>\n        (\\<lambda>a.\n            map_spmf\n             (map_prod (\\<lambda>a. a)\n               (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                   (((s11, s21), s12, s22), s13, s23)))\n             (case case a of\n                   (x, xa) \\<Rightarrow>\n                     (case x of\n                      (oadv, s_adv') \\<Rightarrow>\n                        \\<lambda>(s_rest', es).\n                           ((oadv, es), (s_adv', sur), s_rest'))\n                      xa of\n              (x, xa) \\<Rightarrow>\n                (case x of\n                 (o_rfunc, e_lst) \\<Rightarrow>\n                   \\<lambda>s_rfunc.\n                      map_spmf\n                       (\\<lambda>s_notify.\n                           (Inl (Inr o_rfunc), s_notify, s_rfunc))\n                       (map_spmf (Pair (sac, suc))\n                         (foldl_spmf (cpoke core) (return_spmf sc) e_lst)))\n                 xa)))", "apply(subst bind_commute_spmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. the_gpv (cnv_adv_rest sar qar) \\<bind>\n    (\\<lambda>y.\n        foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n        (\\<lambda>x.\n            (map_spmf rprodl \\<circ>\n             (case_generat (\\<lambda>xa. return_spmf (xa, x, sr))\n               (\\<lambda>out c.\n                   fused_resource.fuse core rest (x, sr) out \\<bind>\n                   (\\<lambda>(x, y). execl (c x) y)) \\<circ>\n              map_generat id Inl left_rpv \\<circ>\n              map_generat (map_prod Inl (\\<lambda>s1'. (s1', suc, sur)))\n               (\\<lambda>a. a)\n               ((\\<circ>)\n                 (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur)))\n                   (\\<lambda>a. a))) \\<circ>\n              map_generat id Inr right_rpv \\<circ>\n              map_generat (map_prod Inr (Pair sac)) (\\<lambda>a. a)\n               ((\\<circ>)\n                 (map_gpv (map_prod Inr (Pair sac)) (\\<lambda>a. a)))))\n             y)) =\n    the_gpv (cnv_adv_rest sar qar) \\<bind>\n    (\\<lambda>y.\n        (case y of Pure x \\<Rightarrow> return_spmf (x, sr, es)\n         | IO out c \\<Rightarrow>\n             map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n              (rfunc_adv rest sr out) \\<bind>\n             (\\<lambda>(x, y). execr (c x) y)) \\<bind>\n        (\\<lambda>a.\n            map_spmf\n             (map_prod (\\<lambda>a. a)\n               (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                   (((s11, s21), s12, s22), s13, s23)))\n             (case case a of\n                   (x, xa) \\<Rightarrow>\n                     (case x of\n                      (oadv, s_adv') \\<Rightarrow>\n                        \\<lambda>(s_rest', es).\n                           ((oadv, es), (s_adv', sur), s_rest'))\n                      xa of\n              (x, xa) \\<Rightarrow>\n                (case x of\n                 (o_rfunc, e_lst) \\<Rightarrow>\n                   \\<lambda>s_rfunc.\n                      map_spmf\n                       (\\<lambda>s_notify.\n                           (Inl (Inr o_rfunc), s_notify, s_rfunc))\n                       (map_spmf (Pair (sac, suc))\n                         (foldl_spmf (cpoke core) (return_spmf sc) e_lst)))\n                 xa)))", "apply(clarsimp simp add: gpv.map_sel map_bind_spmf bind_map_spmf spmf.map_comp o_def map_spmf_conv_bind_spmf[symmetric] intro!: bind_spmf_cong[OF refl] split!: generat.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22\n       \\<in> set_spmf (the_gpv (cnv_adv_rest sar qar)) \\<Longrightarrow>\n       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n       (\\<lambda>x.\n           rfunc_adv rest sr x21 \\<bind>\n           (\\<lambda>xa.\n               (case xa of\n                (xa, xb) \\<Rightarrow>\n                  (case xa of\n                   (o_rfunc, e_lst) \\<Rightarrow>\n                     \\<lambda>s_rfunc.\n                        map_spmf\n                         (\\<lambda>s_notify.\n                             (Inl (Inr o_rfunc), s_notify, s_rfunc))\n                         (foldl_spmf (cpoke core) (return_spmf x) e_lst))\n                   xb) \\<bind>\n               (\\<lambda>x.\n                   map_spmf rprodl\n                    (case x of\n                     (x, xa) \\<Rightarrow>\n                       execl\n                        (left_rpv\n                          (\\<lambda>input'.\n                              map_gpv\n                               (map_prod Inl\n                                 (\\<lambda>s1'. (s1', suc, sur)))\n                               (\\<lambda>a. a)\n                               (right_rpv\n                                 (\\<lambda>input'.\n                                     map_gpv (map_prod Inr (Pair sac))\n(\\<lambda>a. a) (x22 input'))\n                                 input'))\n                          x)\n                        xa)))) =\n       rfunc_adv rest sr x21 \\<bind>\n       (\\<lambda>y.\n           (case case y of\n                 (x, xa) \\<Rightarrow>\n                   (case x of\n                    (out, e) \\<Rightarrow> \\<lambda>s'. (out, s', es @ e))\n                    xa of\n            (x, xa) \\<Rightarrow> execr (x22 x) xa) \\<bind>\n           (\\<lambda>a.\n               map_spmf\n                (map_prod (\\<lambda>a. a)\n                  (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                      (((s11, s21), s12, s22), s13, s23)))\n                (case case a of\n                      (x, xa) \\<Rightarrow>\n                        (case x of\n                         (oadv, s_adv') \\<Rightarrow>\n                           \\<lambda>(s_rest', es).\n                              ((oadv, es), (s_adv', sur), s_rest'))\n                         xa of\n                 (x, xa) \\<Rightarrow>\n                   (case x of\n                    (o_rfunc, e_lst) \\<Rightarrow>\n                      \\<lambda>s_rfunc.\n                         map_spmf\n                          (\\<lambda>x.\n                              (Inl (Inr o_rfunc), ((sac, suc), x), s_rfunc))\n                          (foldl_spmf (cpoke core) (return_spmf sc) e_lst))\n                    xa)))", "apply(subst bind_commute_spmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22\n       \\<in> set_spmf (the_gpv (cnv_adv_rest sar qar)) \\<Longrightarrow>\n       rfunc_adv rest sr x21 \\<bind>\n       (\\<lambda>y.\n           foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n           (\\<lambda>x.\n               (case y of\n                (xa, xb) \\<Rightarrow>\n                  (case xa of\n                   (o_rfunc, e_lst) \\<Rightarrow>\n                     \\<lambda>s_rfunc.\n                        map_spmf\n                         (\\<lambda>s_notify.\n                             (Inl (Inr o_rfunc), s_notify, s_rfunc))\n                         (foldl_spmf (cpoke core) (return_spmf x) e_lst))\n                   xb) \\<bind>\n               (\\<lambda>x.\n                   map_spmf rprodl\n                    (case x of\n                     (x, xa) \\<Rightarrow>\n                       execl\n                        (left_rpv\n                          (\\<lambda>input'.\n                              map_gpv\n                               (map_prod Inl\n                                 (\\<lambda>s1'. (s1', suc, sur)))\n                               (\\<lambda>a. a)\n                               (right_rpv\n                                 (\\<lambda>input'.\n                                     map_gpv (map_prod Inr (Pair sac))\n(\\<lambda>a. a) (x22 input'))\n                                 input'))\n                          x)\n                        xa)))) =\n       rfunc_adv rest sr x21 \\<bind>\n       (\\<lambda>y.\n           (case case y of\n                 (x, xa) \\<Rightarrow>\n                   (case x of\n                    (out, e) \\<Rightarrow> \\<lambda>s'. (out, s', es @ e))\n                    xa of\n            (x, xa) \\<Rightarrow> execr (x22 x) xa) \\<bind>\n           (\\<lambda>a.\n               map_spmf\n                (map_prod (\\<lambda>a. a)\n                  (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                      (((s11, s21), s12, s22), s13, s23)))\n                (case case a of\n                      (x, xa) \\<Rightarrow>\n                        (case x of\n                         (oadv, s_adv') \\<Rightarrow>\n                           \\<lambda>(s_rest', es).\n                              ((oadv, es), (s_adv', sur), s_rest'))\n                         xa of\n                 (x, xa) \\<Rightarrow>\n                   (case x of\n                    (o_rfunc, e_lst) \\<Rightarrow>\n                      \\<lambda>s_rfunc.\n                         map_spmf\n                          (\\<lambda>x.\n                              (Inl (Inr o_rfunc), ((sac, suc), x), s_rfunc))\n                          (foldl_spmf (cpoke core) (return_spmf sc) e_lst))\n                    xa)))", "apply(clarsimp simp add: gpv.map_sel map_bind_spmf bind_map_spmf spmf.map_comp o_def map_spmf_conv_bind_spmf[symmetric] intro!: bind_spmf_cong[OF refl] split!: generat.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 a b ba.\n       \\<lbrakk>IO x21 x22 \\<in> set_spmf (the_gpv (cnv_adv_rest sar qar));\n        ((a, b), ba) \\<in> set_spmf (rfunc_adv rest sr x21)\\<rbrakk>\n       \\<Longrightarrow> foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n                         (\\<lambda>x.\n                             foldl_spmf (cpoke core) (return_spmf x)\n                              b \\<bind>\n                             (\\<lambda>x.\n                                 map_spmf rprodl\n                                  (execl\n                                    (left_gpv\n(map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) (\\<lambda>a. a)\n  (right_gpv (map_gpv (map_prod Inr (Pair sac)) (\\<lambda>a. a) (x22 a)))))\n                                    (x, ba)))) =\n                         execr (x22 a) (ba, es @ b) \\<bind>\n                         (\\<lambda>a.\n                             map_spmf\n                              (map_prod (\\<lambda>a. a)\n                                (\\<lambda>(((s11, s12), s13), (s21, s22),\n                                    s23).\n                                    (((s11, s21), s12, s22), s13, s23)))\n                              (case case a of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (oadv, s_adv') \\<Rightarrow>\n   \\<lambda>(s_rest', es). ((oadv, es), (s_adv', sur), s_rest'))\n xa of\n                               (x, xa) \\<Rightarrow>\n                                 (case x of\n                                  (o_rfunc, e_lst) \\<Rightarrow>\n                                    \\<lambda>s_rfunc.\n map_spmf (\\<lambda>x. (Inl (Inr o_rfunc), ((sac, suc), x), s_rfunc))\n  (foldl_spmf (cpoke core) (return_spmf sc) e_lst))\n                                  xa))", "apply(simp add: bind_spmf_assoc[symmetric] bind_foldl_spmf_return foldl_spmf_append[symmetric] del: bind_spmf_assoc )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 a b ba.\n       \\<lbrakk>IO x21 x22 \\<in> set_spmf (the_gpv (cnv_adv_rest sar qar));\n        ((a, b), ba) \\<in> set_spmf (rfunc_adv rest sr x21)\\<rbrakk>\n       \\<Longrightarrow> foldl_spmf (cpoke core) (return_spmf sc)\n                          (es @ b) \\<bind>\n                         (\\<lambda>x.\n                             map_spmf rprodl\n                              (execl\n                                (left_gpv\n                                  (map_gpv\n                                    (map_prod Inl\n(\\<lambda>s1'. (s1', suc, sur)))\n                                    (\\<lambda>a. a)\n                                    (right_gpv\n(map_gpv (map_prod Inr (Pair sac)) (\\<lambda>a. a) (x22 a)))))\n                                (x, ba))) =\n                         execr (x22 a) (ba, es @ b) \\<bind>\n                         (\\<lambda>a.\n                             map_spmf\n                              (map_prod (\\<lambda>a. a)\n                                (\\<lambda>(((s11, s12), s13), (s21, s22),\n                                    s23).\n                                    (((s11, s21), s12, s22), s13, s23)))\n                              (case case a of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (oadv, s_adv') \\<Rightarrow>\n   \\<lambda>(s_rest', es). ((oadv, es), (s_adv', sur), s_rest'))\n xa of\n                               (x, xa) \\<Rightarrow>\n                                 (case x of\n                                  (o_rfunc, e_lst) \\<Rightarrow>\n                                    \\<lambda>s_rfunc.\n map_spmf (\\<lambda>x. (Inl (Inr o_rfunc), ((sac, suc), x), s_rfunc))\n  (foldl_spmf (cpoke core) (return_spmf sc) e_lst))\n                                  xa))", "apply(subst step.IH[unfolded id_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 a b ba.\n       \\<lbrakk>IO x21 x22 \\<in> set_spmf (the_gpv (cnv_adv_rest sar qar));\n        ((a, b), ba) \\<in> set_spmf (rfunc_adv rest sr x21)\\<rbrakk>\n       \\<Longrightarrow> execr (x22 a) (ba, es @ b) \\<bind>\n                         map_spmf\n                          (map_prod (\\<lambda>a. a)\n                            (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                                (((s11, s21), s12, s22), s13, s23))) \\<circ>\n                         ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n                              map_spmf\n                               (\\<lambda>s_notify.\n                                   (Inl (Inr o_rfunc), s_notify, s_rfunc))\n                               (map_spmf (Pair (sac, suc))\n                                 (foldl_spmf (cpoke core) (return_spmf sc)\n                                   e_lst))) \\<circ>\n                          (\\<lambda>((oadv, s_adv'), s_rest', es).\n                              ((oadv, es), (s_adv', sur), s_rest'))) =\n                         execr (x22 a) (ba, es @ b) \\<bind>\n                         (\\<lambda>a.\n                             map_spmf\n                              (map_prod (\\<lambda>a. a)\n                                (\\<lambda>(((s11, s12), s13), (s21, s22),\n                                    s23).\n                                    (((s11, s21), s12, s22), s13, s23)))\n                              (case case a of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (oadv, s_adv') \\<Rightarrow>\n   \\<lambda>(s_rest', es). ((oadv, es), (s_adv', sur), s_rest'))\n xa of\n                               (x, xa) \\<Rightarrow>\n                                 (case x of\n                                  (o_rfunc, e_lst) \\<Rightarrow>\n                                    \\<lambda>s_rfunc.\n map_spmf (\\<lambda>x. (Inl (Inr o_rfunc), ((sac, suc), x), s_rfunc))\n  (foldl_spmf (cpoke core) (return_spmf sc) e_lst))\n                                  xa))", "apply(simp add: split_def o_def spmf.map_comp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n  (\\<lambda>sc'.\n      map_spmf rprodl\n       (the_gpv\n         (left_gpv\n           (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n             (right_gpv\n               (map_gpv (map_prod Inr (Pair sac)) id\n                 (cnv_adv_rest sar qar))))) \\<bind>\n        (\\<lambda>a.\n            case a of Pure x \\<Rightarrow> return_spmf (x, sc', sr)\n            | IO out c \\<Rightarrow>\n                fused_resource.fuse core rest (sc', sr) out \\<bind>\n                (\\<lambda>a.\n                    case a of (x, y) \\<Rightarrow> execl (c x) y)))) =\n  the_gpv (cnv_adv_rest sar qar) \\<bind>\n  (\\<lambda>a.\n      case a of Pure x \\<Rightarrow> return_spmf (x, sr, es)\n      | IO out c \\<Rightarrow>\n          (case (sr, es) of\n           (s, es) \\<Rightarrow>\n             \\<lambda>q.\n                map_spmf\n                 (\\<lambda>a.\n                     case a of\n                     (a, b) \\<Rightarrow>\n                       (case a of\n                        (out, e) \\<Rightarrow>\n                          \\<lambda>s'. (out, s', es @ e))\n                        b)\n                 (rfunc_adv rest s q))\n           out \\<bind>\n          (\\<lambda>a.\n              case a of (x, y) \\<Rightarrow> execr (c x) y)) \\<bind>\n  map_spmf\n   (map_prod id\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (a, b) \\<Rightarrow>\n              (case a of\n               (s11, s12) \\<Rightarrow>\n                 \\<lambda>s13 a.\n                    case a of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (s21, s22) \\<Rightarrow>\n                         \\<lambda>s23. (((s11, s21), s12, s22), s13, s23))\n                       b)\n               b)\n            b)) \\<circ>\n  ((\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (o_rfunc, e_lst) \\<Rightarrow>\n            \\<lambda>s_rfunc.\n               map_spmf\n                (\\<lambda>s_notify. (Inl (Inr o_rfunc), s_notify, s_rfunc))\n                (map_spmf (Pair (sac, suc))\n                  (foldl_spmf (cpoke core) (return_spmf sc) e_lst)))\n          b) \\<circ>\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (oadv, s_adv') \\<Rightarrow>\n            \\<lambda>a.\n               case a of\n               (s_rest', es) \\<Rightarrow>\n                 ((oadv, es), (s_adv', sur), s_rest'))\n          b))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldl_spmf (cpoke core) (return_spmf sc) ?es2 \\<bind>\n  (\\<lambda>sc'.\n      map_spmf rprodl\n       (exec_gpv (fused_resource.fuse core rest)\n         (left_gpv\n           (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n             (right_gpv\n               (map_gpv (map_prod Inr (Pair sac)) id\n                 (cnv_adv_rest sar qar)))))\n         (sc', sr))) =\n  exec_gpv\n   (\\<lambda>(s, es) q.\n       map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n        (rfunc_adv rest s q))\n   (cnv_adv_rest sar qar) (sr, ?es2) \\<bind>\n  map_spmf\n   (map_prod id\n     (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n         (((s11, s21), s12, s22), s13, s23))) \\<circ>\n  ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n       map_spmf (\\<lambda>s_notify. (Inl (Inr o_rfunc), s_notify, s_rfunc))\n        (map_spmf (Pair (sac, suc))\n          (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n   (\\<lambda>((oadv, s_adv'), s_rest', es).\n       ((oadv, es), (s_adv', sur), s_rest')))\n\ngoal (3 subgoals):\n 1. \\<And>qar.\n       q = Inl (Inr qar) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q\n 2. \\<And>quc.\n       q = Inr (Inl quc) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q\n 3. \\<And>qur.\n       q = Inr (Inr qur) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q", "from this[of \"[]\"]"], ["proof (chain)\npicking this:\n  foldl_spmf (cpoke core) (return_spmf sc) [] \\<bind>\n  (\\<lambda>sc'.\n      map_spmf rprodl\n       (exec_gpv (fused_resource.fuse core rest)\n         (left_gpv\n           (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n             (right_gpv\n               (map_gpv (map_prod Inr (Pair sac)) id\n                 (cnv_adv_rest sar qar)))))\n         (sc', sr))) =\n  exec_gpv\n   (\\<lambda>(s, es) q.\n       map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n        (rfunc_adv rest s q))\n   (cnv_adv_rest sar qar) (sr, []) \\<bind>\n  map_spmf\n   (map_prod id\n     (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n         (((s11, s21), s12, s22), s13, s23))) \\<circ>\n  ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n       map_spmf (\\<lambda>s_notify. (Inl (Inr o_rfunc), s_notify, s_rfunc))\n        (map_spmf (Pair (sac, suc))\n          (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n   (\\<lambda>((oadv, s_adv'), s_rest', es).\n       ((oadv, es), (s_adv', sur), s_rest')))", "show ?thesis"], ["proof (prove)\nusing this:\n  foldl_spmf (cpoke core) (return_spmf sc) [] \\<bind>\n  (\\<lambda>sc'.\n      map_spmf rprodl\n       (exec_gpv (fused_resource.fuse core rest)\n         (left_gpv\n           (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n             (right_gpv\n               (map_gpv (map_prod Inr (Pair sac)) id\n                 (cnv_adv_rest sar qar)))))\n         (sc', sr))) =\n  exec_gpv\n   (\\<lambda>(s, es) q.\n       map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n        (rfunc_adv rest s q))\n   (cnv_adv_rest sar qar) (sr, []) \\<bind>\n  map_spmf\n   (map_prod id\n     (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n         (((s11, s21), s12, s22), s13, s23))) \\<circ>\n  ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n       map_spmf (\\<lambda>s_notify. (Inl (Inr o_rfunc), s_notify, s_rfunc))\n        (map_spmf (Pair (sac, suc))\n          (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n   (\\<lambda>((oadv, s_adv'), s_rest', es).\n       ((oadv, es), (s_adv', sur), s_rest')))\n\ngoal (1 subgoal):\n 1. attach_callee\n     ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n      cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n     (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n    apply_state_iso iso_trisplit\n     (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n       (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n     (((sac, sar), suc, sur), sc, sr) q", "using ARest"], ["proof (prove)\nusing this:\n  foldl_spmf (cpoke core) (return_spmf sc) [] \\<bind>\n  (\\<lambda>sc'.\n      map_spmf rprodl\n       (exec_gpv (fused_resource.fuse core rest)\n         (left_gpv\n           (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', suc, sur))) id\n             (right_gpv\n               (map_gpv (map_prod Inr (Pair sac)) id\n                 (cnv_adv_rest sar qar)))))\n         (sc', sr))) =\n  exec_gpv\n   (\\<lambda>(s, es) q.\n       map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n        (rfunc_adv rest s q))\n   (cnv_adv_rest sar qar) (sr, []) \\<bind>\n  map_spmf\n   (map_prod id\n     (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n         (((s11, s21), s12, s22), s13, s23))) \\<circ>\n  ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n       map_spmf (\\<lambda>s_notify. (Inl (Inr o_rfunc), s_notify, s_rfunc))\n        (map_spmf (Pair (sac, suc))\n          (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n   (\\<lambda>((oadv, s_adv'), s_rest', es).\n       ((oadv, es), (s_adv', sur), s_rest')))\n  q = Inl (Inr qar)\n\ngoal (1 subgoal):\n 1. attach_callee\n     ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n      cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n     (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n    apply_state_iso iso_trisplit\n     (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n       (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n     (((sac, sar), suc, sur), sc, sr) q", "by(simp add: apply_state_iso_def iso_trisplit_def map_bind_spmf bind_map_spmf map_spmf_conv_bind_spmf[symmetric] foldl_spmf_pair_right)"], ["proof (state)\nthis:\n  attach_callee\n   ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n    cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n   (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n  apply_state_iso iso_trisplit\n   (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n     (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n   (((sac, sar), suc, sur), sc, sr) q\n\ngoal (2 subgoals):\n 1. \\<And>quc.\n       q = Inr (Inl quc) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q\n 2. \\<And>qur.\n       q = Inr (Inr qur) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>quc.\n       q = Inr (Inl quc) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q\n 2. \\<And>qur.\n       q = Inr (Inr qur) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q", "case UCore"], ["proof (state)\nthis:\n  q = Inr (Inl quc)\n\ngoal (2 subgoals):\n 1. \\<And>quc.\n       q = Inr (Inl quc) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q\n 2. \\<And>qur.\n       q = Inr (Inr qur) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q", "have \"map_spmf rprodl (exec_gpv (fused_resource.fuse core rest)\n       (right_gpv (map_gpv (map_prod Inr (Pair (sac, sar))) id (left_gpv (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sur))) id (cnv_usr_core suc quc)))))\n       (sc, sr)) =\n     (map_spmf (map_prod (Inr \\<circ> Inl) (?tri \\<circ> prod.swap \\<circ> Pair ((sar, sur), sr)))\n       (map_spmf (\\<lambda>((ousr, s_usr'), s_core'). (ousr, (sac, s_usr'), s_core'))\n         (exec_gpv (cfunc_usr core) (cnv_usr_core suc quc) sc)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf rprodl\n     (exec_gpv (fused_resource.fuse core rest)\n       (right_gpv\n         (map_gpv (map_prod Inr (Pair (sac, sar))) id\n           (left_gpv\n             (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sur))) id\n               (cnv_usr_core suc quc)))))\n       (sc, sr)) =\n    map_spmf\n     (map_prod (Inr \\<circ> Inl)\n       ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n            (((s11, s21), s12, s22), s13, s23)) \\<circ>\n        prod.swap \\<circ>\n        Pair ((sar, sur), sr)))\n     (map_spmf\n       (\\<lambda>((ousr, s_usr'), s_core'). (ousr, (sac, s_usr'), s_core'))\n       (exec_gpv (cfunc_usr core) (cnv_usr_core suc quc) sc))", "proof(induction arbitrary: sc cnv_usr_core rule: exec_gpv_fixp_parallel_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb.\n            map_spmf rprodl\n             (curry (fst x)\n               (right_gpv\n                 (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                   (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sur))) id\n                       (xb suc quc)))))\n               (xa, sr)) =\n            map_spmf\n             (map_prod (Inr \\<circ> Inl)\n               ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                    (((s11, s21), s12, s22), s13, s23)) \\<circ>\n                prod.swap \\<circ>\n                Pair ((sar, sur), sr)))\n             (map_spmf\n               (\\<lambda>((ousr, s_usr'), s_core').\n                   (ousr, (sac, s_usr'), s_core'))\n               (curry (snd x) (xb suc quc) xa)))\n 2. \\<And>sc cnv_usr_core.\n       map_spmf rprodl (return_pmf None) =\n       map_spmf\n        (map_prod (Inr \\<circ> Inl)\n          ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n               (((s11, s21), s12, s22), s13, s23)) \\<circ>\n           prod.swap \\<circ>\n           Pair ((sar, sur), sr)))\n        (map_spmf\n          (\\<lambda>((ousr, s_usr'), s_core').\n              (ousr, (sac, s_usr'), s_core'))\n          (return_pmf None))\n 3. \\<And>f g sc cnv_usr_core.\n       (\\<And>sc cnv_usr_core.\n           map_spmf rprodl\n            (f (right_gpv\n                 (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                   (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sur))) id\n                       (cnv_usr_core suc quc)))))\n              (sc, sr)) =\n           map_spmf\n            (map_prod (Inr \\<circ> Inl)\n              ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                   (((s11, s21), s12, s22), s13, s23)) \\<circ>\n               prod.swap \\<circ>\n               Pair ((sar, sur), sr)))\n            (map_spmf\n              (\\<lambda>((ousr, s_usr'), s_core').\n                  (ousr, (sac, s_usr'), s_core'))\n              (g (cnv_usr_core suc quc) sc))) \\<Longrightarrow>\n       map_spmf rprodl\n        (the_gpv\n          (right_gpv\n            (map_gpv (map_prod Inr (Pair (sac, sar))) id\n              (left_gpv\n                (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sur))) id\n                  (cnv_usr_core suc quc))))) \\<bind>\n         case_generat (\\<lambda>x. return_spmf (x, sc, sr))\n          (\\<lambda>out c.\n              fused_resource.fuse core rest (sc, sr) out \\<bind>\n              (\\<lambda>(x, y). f (c x) y))) =\n       map_spmf\n        (map_prod (Inr \\<circ> Inl)\n          ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n               (((s11, s21), s12, s22), s13, s23)) \\<circ>\n           prod.swap \\<circ>\n           Pair ((sar, sur), sr)))\n        (map_spmf\n          (\\<lambda>((ousr, s_usr'), s_core').\n              (ousr, (sac, s_usr'), s_core'))\n          (the_gpv (cnv_usr_core suc quc) \\<bind>\n           case_generat (\\<lambda>x. return_spmf (x, sc))\n            (\\<lambda>out c.\n                cfunc_usr core sc out \\<bind>\n                (\\<lambda>(x, y). g (c x) y))))", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb.\n            map_spmf rprodl\n             (curry (fst x)\n               (right_gpv\n                 (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                   (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sur))) id\n                       (xb suc quc)))))\n               (xa, sr)) =\n            map_spmf\n             (map_prod (Inr \\<circ> Inl)\n               ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                    (((s11, s21), s12, s22), s13, s23)) \\<circ>\n                prod.swap \\<circ>\n                Pair ((sar, sur), sr)))\n             (map_spmf\n               (\\<lambda>((ousr, s_usr'), s_core').\n                   (ousr, (sac, s_usr'), s_core'))\n               (curry (snd x) (xb suc quc) xa)))\n 2. \\<And>sc cnv_usr_core.\n       map_spmf rprodl (return_pmf None) =\n       map_spmf\n        (map_prod (Inr \\<circ> Inl)\n          ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n               (((s11, s21), s12, s22), s13, s23)) \\<circ>\n           prod.swap \\<circ>\n           Pair ((sar, sur), sr)))\n        (map_spmf\n          (\\<lambda>((ousr, s_usr'), s_core').\n              (ousr, (sac, s_usr'), s_core'))\n          (return_pmf None))\n 3. \\<And>f g sc cnv_usr_core.\n       (\\<And>sc cnv_usr_core.\n           map_spmf rprodl\n            (f (right_gpv\n                 (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                   (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sur))) id\n                       (cnv_usr_core suc quc)))))\n              (sc, sr)) =\n           map_spmf\n            (map_prod (Inr \\<circ> Inl)\n              ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                   (((s11, s21), s12, s22), s13, s23)) \\<circ>\n               prod.swap \\<circ>\n               Pair ((sar, sur), sr)))\n            (map_spmf\n              (\\<lambda>((ousr, s_usr'), s_core').\n                  (ousr, (sac, s_usr'), s_core'))\n              (g (cnv_usr_core suc quc) sc))) \\<Longrightarrow>\n       map_spmf rprodl\n        (the_gpv\n          (right_gpv\n            (map_gpv (map_prod Inr (Pair (sac, sar))) id\n              (left_gpv\n                (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sur))) id\n                  (cnv_usr_core suc quc))))) \\<bind>\n         case_generat (\\<lambda>x. return_spmf (x, sc, sr))\n          (\\<lambda>out c.\n              fused_resource.fuse core rest (sc, sr) out \\<bind>\n              (\\<lambda>(x, y). f (c x) y))) =\n       map_spmf\n        (map_prod (Inr \\<circ> Inl)\n          ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n               (((s11, s21), s12, s22), s13, s23)) \\<circ>\n           prod.swap \\<circ>\n           Pair ((sar, sur), sr)))\n        (map_spmf\n          (\\<lambda>((ousr, s_usr'), s_core').\n              (ousr, (sac, s_usr'), s_core'))\n          (the_gpv (cnv_usr_core suc quc) \\<bind>\n           case_generat (\\<lambda>x. return_spmf (x, sc))\n            (\\<lambda>out c.\n                cfunc_usr core sc out \\<bind>\n                (\\<lambda>(x, y). g (c x) y))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xaa.\n            map_spmf rprodl\n             (curry (fst x)\n               (right_gpv\n                 (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                   (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sur))) id\n                       (xaa suc quc)))))\n               (xa, sr)) =\n            map_spmf\n             (map_prod (Inr \\<circ> Inl)\n               ((\\<lambda>a.\n                    case a of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (a, b) \\<Rightarrow>\n                         (case a of\n                          (s11, s12) \\<Rightarrow>\n                            \\<lambda>s13 a.\n                               case a of\n                               (a, b) \\<Rightarrow>\n                                 (case a of\n                                  (s21, s22) \\<Rightarrow>\n                                    \\<lambda>s23.\n (((s11, s21), s12, s22), s13, s23))\n                                  b)\n                          b)\n                       b) \\<circ>\n                prod.swap \\<circ>\n                Pair ((sar, sur), sr)))\n             (map_spmf\n               (\\<lambda>a.\n                   case a of\n                   (a, b) \\<Rightarrow>\n                     (case a of\n                      (ousr, s_usr') \\<Rightarrow>\n                        \\<lambda>s_core'. (ousr, (sac, s_usr'), s_core'))\n                      b)\n               (curry (snd x) (xaa suc quc) xa)))", "by simp"], ["proof (state)\nthis:\n  ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n   (rel_prod spmf.le_fun spmf.le_fun)\n   (\\<lambda>x.\n       \\<forall>xa xaa.\n          map_spmf rprodl\n           (curry (fst x)\n             (right_gpv\n               (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                 (left_gpv\n                   (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sur))) id\n                     (xaa suc quc)))))\n             (xa, sr)) =\n          map_spmf\n           (map_prod (Inr \\<circ> Inl)\n             ((\\<lambda>a.\n                  case a of\n                  (a, b) \\<Rightarrow>\n                    (case a of\n                     (a, b) \\<Rightarrow>\n                       (case a of\n                        (s11, s12) \\<Rightarrow>\n                          \\<lambda>s13 a.\n                             case a of\n                             (a, b) \\<Rightarrow>\n                               (case a of\n                                (s21, s22) \\<Rightarrow>\n                                  \\<lambda>s23.\n                                     (((s11, s21), s12, s22), s13, s23))\n                                b)\n                        b)\n                     b) \\<circ>\n              prod.swap \\<circ>\n              Pair ((sar, sur), sr)))\n           (map_spmf\n             (\\<lambda>a.\n                 case a of\n                 (a, b) \\<Rightarrow>\n                   (case a of\n                    (ousr, s_usr') \\<Rightarrow>\n                      \\<lambda>s_core'. (ousr, (sac, s_usr'), s_core'))\n                    b)\n             (curry (snd x) (xaa suc quc) xa)))\n\ngoal (2 subgoals):\n 1. \\<And>sc cnv_usr_core.\n       map_spmf rprodl (return_pmf None) =\n       map_spmf\n        (map_prod (Inr \\<circ> Inl)\n          ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n               (((s11, s21), s12, s22), s13, s23)) \\<circ>\n           prod.swap \\<circ>\n           Pair ((sar, sur), sr)))\n        (map_spmf\n          (\\<lambda>((ousr, s_usr'), s_core').\n              (ousr, (sac, s_usr'), s_core'))\n          (return_pmf None))\n 2. \\<And>f g sc cnv_usr_core.\n       (\\<And>sc cnv_usr_core.\n           map_spmf rprodl\n            (f (right_gpv\n                 (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                   (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sur))) id\n                       (cnv_usr_core suc quc)))))\n              (sc, sr)) =\n           map_spmf\n            (map_prod (Inr \\<circ> Inl)\n              ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                   (((s11, s21), s12, s22), s13, s23)) \\<circ>\n               prod.swap \\<circ>\n               Pair ((sar, sur), sr)))\n            (map_spmf\n              (\\<lambda>((ousr, s_usr'), s_core').\n                  (ousr, (sac, s_usr'), s_core'))\n              (g (cnv_usr_core suc quc) sc))) \\<Longrightarrow>\n       map_spmf rprodl\n        (the_gpv\n          (right_gpv\n            (map_gpv (map_prod Inr (Pair (sac, sar))) id\n              (left_gpv\n                (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sur))) id\n                  (cnv_usr_core suc quc))))) \\<bind>\n         case_generat (\\<lambda>x. return_spmf (x, sc, sr))\n          (\\<lambda>out c.\n              fused_resource.fuse core rest (sc, sr) out \\<bind>\n              (\\<lambda>(x, y). f (c x) y))) =\n       map_spmf\n        (map_prod (Inr \\<circ> Inl)\n          ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n               (((s11, s21), s12, s22), s13, s23)) \\<circ>\n           prod.swap \\<circ>\n           Pair ((sar, sur), sr)))\n        (map_spmf\n          (\\<lambda>((ousr, s_usr'), s_core').\n              (ousr, (sac, s_usr'), s_core'))\n          (the_gpv (cnv_usr_core suc quc) \\<bind>\n           case_generat (\\<lambda>x. return_spmf (x, sc))\n            (\\<lambda>out c.\n                cfunc_usr core sc out \\<bind>\n                (\\<lambda>(x, y). g (c x) y))))", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>sc cnv_usr_core.\n       map_spmf rprodl (return_pmf None) =\n       map_spmf\n        (map_prod (Inr \\<circ> Inl)\n          ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n               (((s11, s21), s12, s22), s13, s23)) \\<circ>\n           prod.swap \\<circ>\n           Pair ((sar, sur), sr)))\n        (map_spmf\n          (\\<lambda>((ousr, s_usr'), s_core').\n              (ousr, (sac, s_usr'), s_core'))\n          (return_pmf None))\n 2. \\<And>f g sc cnv_usr_core.\n       (\\<And>sc cnv_usr_core.\n           map_spmf rprodl\n            (f (right_gpv\n                 (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                   (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sur))) id\n                       (cnv_usr_core suc quc)))))\n              (sc, sr)) =\n           map_spmf\n            (map_prod (Inr \\<circ> Inl)\n              ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                   (((s11, s21), s12, s22), s13, s23)) \\<circ>\n               prod.swap \\<circ>\n               Pair ((sar, sur), sr)))\n            (map_spmf\n              (\\<lambda>((ousr, s_usr'), s_core').\n                  (ousr, (sac, s_usr'), s_core'))\n              (g (cnv_usr_core suc quc) sc))) \\<Longrightarrow>\n       map_spmf rprodl\n        (the_gpv\n          (right_gpv\n            (map_gpv (map_prod Inr (Pair (sac, sar))) id\n              (left_gpv\n                (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sur))) id\n                  (cnv_usr_core suc quc))))) \\<bind>\n         case_generat (\\<lambda>x. return_spmf (x, sc, sr))\n          (\\<lambda>out c.\n              fused_resource.fuse core rest (sc, sr) out \\<bind>\n              (\\<lambda>(x, y). f (c x) y))) =\n       map_spmf\n        (map_prod (Inr \\<circ> Inl)\n          ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n               (((s11, s21), s12, s22), s13, s23)) \\<circ>\n           prod.swap \\<circ>\n           Pair ((sar, sur), sr)))\n        (map_spmf\n          (\\<lambda>((ousr, s_usr'), s_core').\n              (ousr, (sac, s_usr'), s_core'))\n          (the_gpv (cnv_usr_core suc quc) \\<bind>\n           case_generat (\\<lambda>x. return_spmf (x, sc))\n            (\\<lambda>out c.\n                cfunc_usr core sc out \\<bind>\n                (\\<lambda>(x, y). g (c x) y))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf rprodl (return_pmf None) =\n    map_spmf\n     (map_prod (Inr \\<circ> Inl)\n       ((\\<lambda>a.\n            case a of\n            (a, b) \\<Rightarrow>\n              (case a of\n               (a, b) \\<Rightarrow>\n                 (case a of\n                  (s11, s12) \\<Rightarrow>\n                    \\<lambda>s13 a.\n                       case a of\n                       (a, b) \\<Rightarrow>\n                         (case a of\n                          (s21, s22) \\<Rightarrow>\n                            \\<lambda>s23.\n                               (((s11, s21), s12, s22), s13, s23))\n                          b)\n                  b)\n               b) \\<circ>\n        prod.swap \\<circ>\n        Pair ((sar, sur), sr)))\n     (map_spmf\n       (\\<lambda>a.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of\n              (ousr, s_usr') \\<Rightarrow>\n                \\<lambda>s_core'. (ousr, (sac, s_usr'), s_core'))\n              b)\n       (return_pmf None))", "by simp"], ["proof (state)\nthis:\n  map_spmf rprodl (return_pmf None) =\n  map_spmf\n   (map_prod (Inr \\<circ> Inl)\n     ((\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (a, b) \\<Rightarrow>\n               (case a of\n                (s11, s12) \\<Rightarrow>\n                  \\<lambda>s13 a.\n                     case a of\n                     (a, b) \\<Rightarrow>\n                       (case a of\n                        (s21, s22) \\<Rightarrow>\n                          \\<lambda>s23. (((s11, s21), s12, s22), s13, s23))\n                        b)\n                b)\n             b) \\<circ>\n      prod.swap \\<circ>\n      Pair ((sar, sur), sr)))\n   (map_spmf\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (ousr, s_usr') \\<Rightarrow>\n              \\<lambda>s_core'. (ousr, (sac, s_usr'), s_core'))\n            b)\n     (return_pmf None))\n\ngoal (1 subgoal):\n 1. \\<And>f g sc cnv_usr_core.\n       (\\<And>sc cnv_usr_core.\n           map_spmf rprodl\n            (f (right_gpv\n                 (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                   (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sur))) id\n                       (cnv_usr_core suc quc)))))\n              (sc, sr)) =\n           map_spmf\n            (map_prod (Inr \\<circ> Inl)\n              ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                   (((s11, s21), s12, s22), s13, s23)) \\<circ>\n               prod.swap \\<circ>\n               Pair ((sar, sur), sr)))\n            (map_spmf\n              (\\<lambda>((ousr, s_usr'), s_core').\n                  (ousr, (sac, s_usr'), s_core'))\n              (g (cnv_usr_core suc quc) sc))) \\<Longrightarrow>\n       map_spmf rprodl\n        (the_gpv\n          (right_gpv\n            (map_gpv (map_prod Inr (Pair (sac, sar))) id\n              (left_gpv\n                (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sur))) id\n                  (cnv_usr_core suc quc))))) \\<bind>\n         case_generat (\\<lambda>x. return_spmf (x, sc, sr))\n          (\\<lambda>out c.\n              fused_resource.fuse core rest (sc, sr) out \\<bind>\n              (\\<lambda>(x, y). f (c x) y))) =\n       map_spmf\n        (map_prod (Inr \\<circ> Inl)\n          ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n               (((s11, s21), s12, s22), s13, s23)) \\<circ>\n           prod.swap \\<circ>\n           Pair ((sar, sur), sr)))\n        (map_spmf\n          (\\<lambda>((ousr, s_usr'), s_core').\n              (ousr, (sac, s_usr'), s_core'))\n          (the_gpv (cnv_usr_core suc quc) \\<bind>\n           case_generat (\\<lambda>x. return_spmf (x, sc))\n            (\\<lambda>out c.\n                cfunc_usr core sc out \\<bind>\n                (\\<lambda>(x, y). g (c x) y))))", "case (step execl execr)"], ["proof (state)\nthis:\n  map_spmf rprodl\n   (execl\n     (right_gpv\n       (map_gpv (map_prod Inr (Pair (sac, sar))) id\n         (left_gpv\n           (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sur))) id\n             (?cnv_usr_core1 suc quc)))))\n     (?sc1, sr)) =\n  map_spmf\n   (map_prod (Inr \\<circ> Inl)\n     ((\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (a, b) \\<Rightarrow>\n               (case a of\n                (s11, s12) \\<Rightarrow>\n                  \\<lambda>s13 a.\n                     case a of\n                     (a, b) \\<Rightarrow>\n                       (case a of\n                        (s21, s22) \\<Rightarrow>\n                          \\<lambda>s23. (((s11, s21), s12, s22), s13, s23))\n                        b)\n                b)\n             b) \\<circ>\n      prod.swap \\<circ>\n      Pair ((sar, sur), sr)))\n   (map_spmf\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (ousr, s_usr') \\<Rightarrow>\n              \\<lambda>s_core'. (ousr, (sac, s_usr'), s_core'))\n            b)\n     (execr (?cnv_usr_core1 suc quc) ?sc1))\n\ngoal (1 subgoal):\n 1. \\<And>f g sc cnv_usr_core.\n       (\\<And>sc cnv_usr_core.\n           map_spmf rprodl\n            (f (right_gpv\n                 (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                   (left_gpv\n                     (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sur))) id\n                       (cnv_usr_core suc quc)))))\n              (sc, sr)) =\n           map_spmf\n            (map_prod (Inr \\<circ> Inl)\n              ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                   (((s11, s21), s12, s22), s13, s23)) \\<circ>\n               prod.swap \\<circ>\n               Pair ((sar, sur), sr)))\n            (map_spmf\n              (\\<lambda>((ousr, s_usr'), s_core').\n                  (ousr, (sac, s_usr'), s_core'))\n              (g (cnv_usr_core suc quc) sc))) \\<Longrightarrow>\n       map_spmf rprodl\n        (the_gpv\n          (right_gpv\n            (map_gpv (map_prod Inr (Pair (sac, sar))) id\n              (left_gpv\n                (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sur))) id\n                  (cnv_usr_core suc quc))))) \\<bind>\n         case_generat (\\<lambda>x. return_spmf (x, sc, sr))\n          (\\<lambda>out c.\n              fused_resource.fuse core rest (sc, sr) out \\<bind>\n              (\\<lambda>(x, y). f (c x) y))) =\n       map_spmf\n        (map_prod (Inr \\<circ> Inl)\n          ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n               (((s11, s21), s12, s22), s13, s23)) \\<circ>\n           prod.swap \\<circ>\n           Pair ((sar, sur), sr)))\n        (map_spmf\n          (\\<lambda>((ousr, s_usr'), s_core').\n              (ousr, (sac, s_usr'), s_core'))\n          (the_gpv (cnv_usr_core suc quc) \\<bind>\n           case_generat (\\<lambda>x. return_spmf (x, sc))\n            (\\<lambda>out c.\n                cfunc_usr core sc out \\<bind>\n                (\\<lambda>(x, y). g (c x) y))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf rprodl\n     (the_gpv\n       (right_gpv\n         (map_gpv (map_prod Inr (Pair (sac, sar))) id\n           (left_gpv\n             (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sur))) id\n               (cnv_usr_core suc quc))))) \\<bind>\n      (\\<lambda>a.\n          case a of Pure x \\<Rightarrow> return_spmf (x, sc, sr)\n          | IO out c \\<Rightarrow>\n              fused_resource.fuse core rest (sc, sr) out \\<bind>\n              (\\<lambda>a. case a of (x, y) \\<Rightarrow> execl (c x) y))) =\n    map_spmf\n     (map_prod (Inr \\<circ> Inl)\n       ((\\<lambda>a.\n            case a of\n            (a, b) \\<Rightarrow>\n              (case a of\n               (a, b) \\<Rightarrow>\n                 (case a of\n                  (s11, s12) \\<Rightarrow>\n                    \\<lambda>s13 a.\n                       case a of\n                       (a, b) \\<Rightarrow>\n                         (case a of\n                          (s21, s22) \\<Rightarrow>\n                            \\<lambda>s23.\n                               (((s11, s21), s12, s22), s13, s23))\n                          b)\n                  b)\n               b) \\<circ>\n        prod.swap \\<circ>\n        Pair ((sar, sur), sr)))\n     (map_spmf\n       (\\<lambda>a.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of\n              (ousr, s_usr') \\<Rightarrow>\n                \\<lambda>s_core'. (ousr, (sac, s_usr'), s_core'))\n              b)\n       (the_gpv (cnv_usr_core suc quc) \\<bind>\n        (\\<lambda>a.\n            case a of Pure x \\<Rightarrow> return_spmf (x, sc)\n            | IO out c \\<Rightarrow>\n                cfunc_usr core sc out \\<bind>\n                (\\<lambda>a.\n                    case a of (x, y) \\<Rightarrow> execr (c x) y))))", "apply(clarsimp simp add: gpv.map_sel map_bind_spmf bind_map_spmf intro!: bind_spmf_cong[OF refl] split!: generat.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21a x22a a b.\n       \\<lbrakk>IO x21a x22a\n                \\<in> set_spmf (the_gpv (cnv_usr_core suc quc));\n        (a, b) \\<in> set_spmf (cfunc_usr core sc x21a)\\<rbrakk>\n       \\<Longrightarrow> map_spmf rprodl\n                          (execl\n                            (right_gpv\n                              (map_gpv (map_prod Inr (Pair (sac, sar)))\n                                (\\<lambda>a. a)\n                                (left_gpv\n                                  (map_gpv\n                                    (map_prod Inl\n(\\<lambda>s1'. (s1', sur)))\n                                    (\\<lambda>a. a) (x22a a)))))\n                            (b, sr)) =\n                         map_spmf\n                          (map_prod (\\<lambda>a. Inr (Inl a))\n                            (\\<lambda>a.\n                                (case a of\n                                 (x, xa) \\<Rightarrow>\n                                   (case x of\n                                    (s11, s12) \\<Rightarrow>\n\\<lambda>s13 ((s21, s22), s23). (((s11, s21), s12, s22), s13, s23))\n                                    xa)\n                                 ((sar, sur), sr)))\n                          (map_spmf\n                            (\\<lambda>((ousr, s_usr'), s_core').\n                                (ousr, (sac, s_usr'), s_core'))\n                            (execr (x22a a) b))", "apply(subst step.IH[unfolded id_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21a x22a a b.\n       \\<lbrakk>IO x21a x22a\n                \\<in> set_spmf (the_gpv (cnv_usr_core suc quc));\n        (a, b) \\<in> set_spmf (cfunc_usr core sc x21a)\\<rbrakk>\n       \\<Longrightarrow> map_spmf\n                          (map_prod (Inr \\<circ> Inl)\n                            ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                                 (((s11, s21), s12, s22), s13, s23)) \\<circ>\n                             prod.swap \\<circ>\n                             Pair ((sar, sur), sr)))\n                          (map_spmf\n                            (\\<lambda>((ousr, s_usr'), s_core').\n                                (ousr, (sac, s_usr'), s_core'))\n                            (execr (x22a a) b)) =\n                         map_spmf\n                          (map_prod (\\<lambda>a. Inr (Inl a))\n                            (\\<lambda>a.\n                                (case a of\n                                 (x, xa) \\<Rightarrow>\n                                   (case x of\n                                    (s11, s12) \\<Rightarrow>\n\\<lambda>s13 ((s21, s22), s23). (((s11, s21), s12, s22), s13, s23))\n                                    xa)\n                                 ((sar, sur), sr)))\n                          (map_spmf\n                            (\\<lambda>((ousr, s_usr'), s_core').\n                                (ousr, (sac, s_usr'), s_core'))\n                            (execr (x22a a) b))", "apply(simp add: spmf.map_comp o_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_spmf rprodl\n   (the_gpv\n     (right_gpv\n       (map_gpv (map_prod Inr (Pair (sac, sar))) id\n         (left_gpv\n           (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sur))) id\n             (cnv_usr_core suc quc))))) \\<bind>\n    (\\<lambda>a.\n        case a of Pure x \\<Rightarrow> return_spmf (x, sc, sr)\n        | IO out c \\<Rightarrow>\n            fused_resource.fuse core rest (sc, sr) out \\<bind>\n            (\\<lambda>a. case a of (x, y) \\<Rightarrow> execl (c x) y))) =\n  map_spmf\n   (map_prod (Inr \\<circ> Inl)\n     ((\\<lambda>a.\n          case a of\n          (a, b) \\<Rightarrow>\n            (case a of\n             (a, b) \\<Rightarrow>\n               (case a of\n                (s11, s12) \\<Rightarrow>\n                  \\<lambda>s13 a.\n                     case a of\n                     (a, b) \\<Rightarrow>\n                       (case a of\n                        (s21, s22) \\<Rightarrow>\n                          \\<lambda>s23. (((s11, s21), s12, s22), s13, s23))\n                        b)\n                b)\n             b) \\<circ>\n      prod.swap \\<circ>\n      Pair ((sar, sur), sr)))\n   (map_spmf\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (ousr, s_usr') \\<Rightarrow>\n              \\<lambda>s_core'. (ousr, (sac, s_usr'), s_core'))\n            b)\n     (the_gpv (cnv_usr_core suc quc) \\<bind>\n      (\\<lambda>a.\n          case a of Pure x \\<Rightarrow> return_spmf (x, sc)\n          | IO out c \\<Rightarrow>\n              cfunc_usr core sc out \\<bind>\n              (\\<lambda>a. case a of (x, y) \\<Rightarrow> execr (c x) y))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_spmf rprodl\n   (exec_gpv (fused_resource.fuse core rest)\n     (right_gpv\n       (map_gpv (map_prod Inr (Pair (sac, sar))) id\n         (left_gpv\n           (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sur))) id\n             (cnv_usr_core suc quc)))))\n     (sc, sr)) =\n  map_spmf\n   (map_prod (Inr \\<circ> Inl)\n     ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n          (((s11, s21), s12, s22), s13, s23)) \\<circ>\n      prod.swap \\<circ>\n      Pair ((sar, sur), sr)))\n   (map_spmf\n     (\\<lambda>((ousr, s_usr'), s_core'). (ousr, (sac, s_usr'), s_core'))\n     (exec_gpv (cfunc_usr core) (cnv_usr_core suc quc) sc))\n\ngoal (2 subgoals):\n 1. \\<And>quc.\n       q = Inr (Inl quc) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q\n 2. \\<And>qur.\n       q = Inr (Inr qur) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q", "then"], ["proof (chain)\npicking this:\n  map_spmf rprodl\n   (exec_gpv (fused_resource.fuse core rest)\n     (right_gpv\n       (map_gpv (map_prod Inr (Pair (sac, sar))) id\n         (left_gpv\n           (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sur))) id\n             (cnv_usr_core suc quc)))))\n     (sc, sr)) =\n  map_spmf\n   (map_prod (Inr \\<circ> Inl)\n     ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n          (((s11, s21), s12, s22), s13, s23)) \\<circ>\n      prod.swap \\<circ>\n      Pair ((sar, sur), sr)))\n   (map_spmf\n     (\\<lambda>((ousr, s_usr'), s_core'). (ousr, (sac, s_usr'), s_core'))\n     (exec_gpv (cfunc_usr core) (cnv_usr_core suc quc) sc))", "show ?thesis"], ["proof (prove)\nusing this:\n  map_spmf rprodl\n   (exec_gpv (fused_resource.fuse core rest)\n     (right_gpv\n       (map_gpv (map_prod Inr (Pair (sac, sar))) id\n         (left_gpv\n           (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sur))) id\n             (cnv_usr_core suc quc)))))\n     (sc, sr)) =\n  map_spmf\n   (map_prod (Inr \\<circ> Inl)\n     ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n          (((s11, s21), s12, s22), s13, s23)) \\<circ>\n      prod.swap \\<circ>\n      Pair ((sar, sur), sr)))\n   (map_spmf\n     (\\<lambda>((ousr, s_usr'), s_core'). (ousr, (sac, s_usr'), s_core'))\n     (exec_gpv (cfunc_usr core) (cnv_usr_core suc quc) sc))\n\ngoal (1 subgoal):\n 1. attach_callee\n     ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n      cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n     (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n    apply_state_iso iso_trisplit\n     (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n       (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n     (((sac, sar), suc, sur), sc, sr) q", "using UCore"], ["proof (prove)\nusing this:\n  map_spmf rprodl\n   (exec_gpv (fused_resource.fuse core rest)\n     (right_gpv\n       (map_gpv (map_prod Inr (Pair (sac, sar))) id\n         (left_gpv\n           (map_gpv (map_prod Inl (\\<lambda>s1'. (s1', sur))) id\n             (cnv_usr_core suc quc)))))\n     (sc, sr)) =\n  map_spmf\n   (map_prod (Inr \\<circ> Inl)\n     ((\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n          (((s11, s21), s12, s22), s13, s23)) \\<circ>\n      prod.swap \\<circ>\n      Pair ((sar, sur), sr)))\n   (map_spmf\n     (\\<lambda>((ousr, s_usr'), s_core'). (ousr, (sac, s_usr'), s_core'))\n     (exec_gpv (cfunc_usr core) (cnv_usr_core suc quc) sc))\n  q = Inr (Inl quc)\n\ngoal (1 subgoal):\n 1. attach_callee\n     ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n      cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n     (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n    apply_state_iso iso_trisplit\n     (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n       (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n     (((sac, sar), suc, sur), sc, sr) q", "by(simp add: apply_state_iso_def iso_trisplit_def map_spmf_conv_bind_spmf[symmetric] spmf.map_comp o_def split_def)"], ["proof (state)\nthis:\n  attach_callee\n   ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n    cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n   (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n  apply_state_iso iso_trisplit\n   (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n     (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n   (((sac, sar), suc, sur), sc, sr) q\n\ngoal (1 subgoal):\n 1. \\<And>qur.\n       q = Inr (Inr qur) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qur.\n       q = Inr (Inr qur) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q", "case URest"], ["proof (state)\nthis:\n  q = Inr (Inr qur)\n\ngoal (1 subgoal):\n 1. \\<And>qur.\n       q = Inr (Inr qur) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q", "have \"bind_spmf (foldl_spmf (cpoke core) (return_spmf sc) es) (\\<lambda>sc'.\n      map_spmf rprodl (exec_gpv (fused_resource.fuse core rest)\n        (right_gpv (map_gpv (map_prod Inr (Pair (sac, sar))) id (right_gpv (map_gpv (map_prod Inr (Pair suc)) id (cnv_usr_rest sur qur)))))\n        (sc', sr))) =\n      bind_spmf\n        (exec_gpv (\\<lambda>(s, es) q. map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e)) (rfunc_usr rest s q)) (cnv_usr_rest sur qur) (sr, es))\n        (map_spmf (map_prod id ?tri) \\<circ>\n           ((\\<lambda>((o_rfunc, e_lst), s_rfunc). map_spmf (\\<lambda>s_notify. (Inr (Inr o_rfunc), s_notify, s_rfunc))\n              (map_spmf (Pair (sac, suc)) (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n           (\\<lambda>((ousr, s_usr'), s_rest', es). ((ousr, es), (sar, s_usr'), s_rest'))))\"\n      for es"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n    (\\<lambda>sc'.\n        map_spmf rprodl\n         (exec_gpv (fused_resource.fuse core rest)\n           (right_gpv\n             (map_gpv (map_prod Inr (Pair (sac, sar))) id\n               (right_gpv\n                 (map_gpv (map_prod Inr (Pair suc)) id\n                   (cnv_usr_rest sur qur)))))\n           (sc', sr))) =\n    exec_gpv\n     (\\<lambda>(s, es) q.\n         map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n          (rfunc_usr rest s q))\n     (cnv_usr_rest sur qur) (sr, es) \\<bind>\n    map_spmf\n     (map_prod id\n       (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n           (((s11, s21), s12, s22), s13, s23))) \\<circ>\n    ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n         map_spmf\n          (\\<lambda>s_notify. (Inr (Inr o_rfunc), s_notify, s_rfunc))\n          (map_spmf (Pair (sac, suc))\n            (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n     (\\<lambda>((ousr, s_usr'), s_rest', es).\n         ((ousr, es), (sar, s_usr'), s_rest')))", "proof(induction arbitrary: sc sr es cnv_usr_rest rule: exec_gpv_fixp_parallel_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb xc xd.\n            foldl_spmf (cpoke core) (return_spmf xa) xc \\<bind>\n            (\\<lambda>sc'.\n                map_spmf rprodl\n                 (curry (fst x)\n                   (right_gpv\n                     (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                       (right_gpv\n                         (map_gpv (map_prod Inr (Pair suc)) id\n                           (xd sur qur)))))\n                   (sc', xb))) =\n            curry (snd x) (xd sur qur) (xb, xc) \\<bind>\n            map_spmf\n             (map_prod id\n               (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                   (((s11, s21), s12, s22), s13, s23))) \\<circ>\n            ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n                 map_spmf\n                  (\\<lambda>s_notify.\n                      (Inr (Inr o_rfunc), s_notify, s_rfunc))\n                  (map_spmf (Pair (sac, suc))\n                    (foldl_spmf (cpoke core) (return_spmf xa)\n                      e_lst))) \\<circ>\n             (\\<lambda>((ousr, s_usr'), s_rest', es).\n                 ((ousr, es), (sar, s_usr'), s_rest'))))\n 2. \\<And>sc sr es cnv_usr_rest.\n       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n       (\\<lambda>sc'. map_spmf rprodl (return_pmf None)) =\n       return_pmf None \\<bind>\n       map_spmf\n        (map_prod id\n          (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n              (((s11, s21), s12, s22), s13, s23))) \\<circ>\n       ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n            map_spmf\n             (\\<lambda>s_notify. (Inr (Inr o_rfunc), s_notify, s_rfunc))\n             (map_spmf (Pair (sac, suc))\n               (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n        (\\<lambda>((ousr, s_usr'), s_rest', es).\n            ((ousr, es), (sar, s_usr'), s_rest')))\n 3. \\<And>f g sc sr es cnv_usr_rest.\n       (\\<And>sc sr es cnv_usr_rest.\n           foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n           (\\<lambda>sc'.\n               map_spmf rprodl\n                (f (right_gpv\n                     (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                       (right_gpv\n                         (map_gpv (map_prod Inr (Pair suc)) id\n                           (cnv_usr_rest sur qur)))))\n                  (sc', sr))) =\n           g (cnv_usr_rest sur qur) (sr, es) \\<bind>\n           map_spmf\n            (map_prod id\n              (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                  (((s11, s21), s12, s22), s13, s23))) \\<circ>\n           ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n                map_spmf\n                 (\\<lambda>s_notify. (Inr (Inr o_rfunc), s_notify, s_rfunc))\n                 (map_spmf (Pair (sac, suc))\n                   (foldl_spmf (cpoke core) (return_spmf sc)\n                     e_lst))) \\<circ>\n            (\\<lambda>((ousr, s_usr'), s_rest', es).\n                ((ousr, es), (sar, s_usr'), s_rest')))) \\<Longrightarrow>\n       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n       (\\<lambda>sc'.\n           map_spmf rprodl\n            (the_gpv\n              (right_gpv\n                (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                  (right_gpv\n                    (map_gpv (map_prod Inr (Pair suc)) id\n                      (cnv_usr_rest sur qur))))) \\<bind>\n             case_generat (\\<lambda>x. return_spmf (x, sc', sr))\n              (\\<lambda>out c.\n                  fused_resource.fuse core rest (sc', sr) out \\<bind>\n                  (\\<lambda>(x, y). f (c x) y)))) =\n       the_gpv (cnv_usr_rest sur qur) \\<bind>\n       case_generat (\\<lambda>x. return_spmf (x, sr, es))\n        (\\<lambda>out c.\n            (case (sr, es) of\n             (s, es) \\<Rightarrow>\n               \\<lambda>q.\n                  map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n                   (rfunc_usr rest s q))\n             out \\<bind>\n            (\\<lambda>(x, y). g (c x) y)) \\<bind>\n       map_spmf\n        (map_prod id\n          (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n              (((s11, s21), s12, s22), s13, s23))) \\<circ>\n       ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n            map_spmf\n             (\\<lambda>s_notify. (Inr (Inr o_rfunc), s_notify, s_rfunc))\n             (map_spmf (Pair (sac, suc))\n               (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n        (\\<lambda>((ousr, s_usr'), s_rest', es).\n            ((ousr, es), (sar, s_usr'), s_rest')))", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xb xc xd.\n            foldl_spmf (cpoke core) (return_spmf xa) xc \\<bind>\n            (\\<lambda>sc'.\n                map_spmf rprodl\n                 (curry (fst x)\n                   (right_gpv\n                     (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                       (right_gpv\n                         (map_gpv (map_prod Inr (Pair suc)) id\n                           (xd sur qur)))))\n                   (sc', xb))) =\n            curry (snd x) (xd sur qur) (xb, xc) \\<bind>\n            map_spmf\n             (map_prod id\n               (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                   (((s11, s21), s12, s22), s13, s23))) \\<circ>\n            ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n                 map_spmf\n                  (\\<lambda>s_notify.\n                      (Inr (Inr o_rfunc), s_notify, s_rfunc))\n                  (map_spmf (Pair (sac, suc))\n                    (foldl_spmf (cpoke core) (return_spmf xa)\n                      e_lst))) \\<circ>\n             (\\<lambda>((ousr, s_usr'), s_rest', es).\n                 ((ousr, es), (sar, s_usr'), s_rest'))))\n 2. \\<And>sc sr es cnv_usr_rest.\n       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n       (\\<lambda>sc'. map_spmf rprodl (return_pmf None)) =\n       return_pmf None \\<bind>\n       map_spmf\n        (map_prod id\n          (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n              (((s11, s21), s12, s22), s13, s23))) \\<circ>\n       ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n            map_spmf\n             (\\<lambda>s_notify. (Inr (Inr o_rfunc), s_notify, s_rfunc))\n             (map_spmf (Pair (sac, suc))\n               (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n        (\\<lambda>((ousr, s_usr'), s_rest', es).\n            ((ousr, es), (sar, s_usr'), s_rest')))\n 3. \\<And>f g sc sr es cnv_usr_rest.\n       (\\<And>sc sr es cnv_usr_rest.\n           foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n           (\\<lambda>sc'.\n               map_spmf rprodl\n                (f (right_gpv\n                     (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                       (right_gpv\n                         (map_gpv (map_prod Inr (Pair suc)) id\n                           (cnv_usr_rest sur qur)))))\n                  (sc', sr))) =\n           g (cnv_usr_rest sur qur) (sr, es) \\<bind>\n           map_spmf\n            (map_prod id\n              (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                  (((s11, s21), s12, s22), s13, s23))) \\<circ>\n           ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n                map_spmf\n                 (\\<lambda>s_notify. (Inr (Inr o_rfunc), s_notify, s_rfunc))\n                 (map_spmf (Pair (sac, suc))\n                   (foldl_spmf (cpoke core) (return_spmf sc)\n                     e_lst))) \\<circ>\n            (\\<lambda>((ousr, s_usr'), s_rest', es).\n                ((ousr, es), (sar, s_usr'), s_rest')))) \\<Longrightarrow>\n       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n       (\\<lambda>sc'.\n           map_spmf rprodl\n            (the_gpv\n              (right_gpv\n                (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                  (right_gpv\n                    (map_gpv (map_prod Inr (Pair suc)) id\n                      (cnv_usr_rest sur qur))))) \\<bind>\n             case_generat (\\<lambda>x. return_spmf (x, sc', sr))\n              (\\<lambda>out c.\n                  fused_resource.fuse core rest (sc', sr) out \\<bind>\n                  (\\<lambda>(x, y). f (c x) y)))) =\n       the_gpv (cnv_usr_rest sur qur) \\<bind>\n       case_generat (\\<lambda>x. return_spmf (x, sr, es))\n        (\\<lambda>out c.\n            (case (sr, es) of\n             (s, es) \\<Rightarrow>\n               \\<lambda>q.\n                  map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n                   (rfunc_usr rest s q))\n             out \\<bind>\n            (\\<lambda>(x, y). g (c x) y)) \\<bind>\n       map_spmf\n        (map_prod id\n          (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n              (((s11, s21), s12, s22), s13, s23))) \\<circ>\n       ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n            map_spmf\n             (\\<lambda>s_notify. (Inr (Inr o_rfunc), s_notify, s_rfunc))\n             (map_spmf (Pair (sac, suc))\n               (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n        (\\<lambda>((ousr, s_usr'), s_rest', es).\n            ((ousr, es), (sar, s_usr'), s_rest')))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n     (rel_prod spmf.le_fun spmf.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa xaa xaaa xaaaa.\n            foldl_spmf (cpoke core) (return_spmf xa) xaaa \\<bind>\n            (\\<lambda>sc'.\n                map_spmf rprodl\n                 (curry (fst x)\n                   (right_gpv\n                     (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                       (right_gpv\n                         (map_gpv (map_prod Inr (Pair suc)) id\n                           (xaaaa sur qur)))))\n                   (sc', xaa))) =\n            curry (snd x) (xaaaa sur qur) (xaa, xaaa) \\<bind>\n            map_spmf\n             (map_prod id\n               (\\<lambda>a.\n                   case a of\n                   (a, b) \\<Rightarrow>\n                     (case a of\n                      (a, b) \\<Rightarrow>\n                        (case a of\n                         (s11, s12) \\<Rightarrow>\n                           \\<lambda>s13 a.\n                              case a of\n                              (a, b) \\<Rightarrow>\n                                (case a of\n                                 (s21, s22) \\<Rightarrow>\n                                   \\<lambda>s23.\n(((s11, s21), s12, s22), s13, s23))\n                                 b)\n                         b)\n                      b)) \\<circ>\n            ((\\<lambda>a.\n                 case a of\n                 (a, b) \\<Rightarrow>\n                   (case a of\n                    (o_rfunc, e_lst) \\<Rightarrow>\n                      \\<lambda>s_rfunc.\n                         map_spmf\n                          (\\<lambda>s_notify.\n                              (Inr (Inr o_rfunc), s_notify, s_rfunc))\n                          (map_spmf (Pair (sac, suc))\n                            (foldl_spmf (cpoke core) (return_spmf xa)\n                              e_lst)))\n                    b) \\<circ>\n             (\\<lambda>a.\n                 case a of\n                 (a, b) \\<Rightarrow>\n                   (case a of\n                    (ousr, s_usr') \\<Rightarrow>\n                      \\<lambda>a.\n                         case a of\n                         (s_rest', es) \\<Rightarrow>\n                           ((ousr, es), (sar, s_usr'), s_rest'))\n                    b)))", "by simp"], ["proof (state)\nthis:\n  ccpo.admissible (prod_lub spmf.lub_fun spmf.lub_fun)\n   (rel_prod spmf.le_fun spmf.le_fun)\n   (\\<lambda>x.\n       \\<forall>xa xaa xaaa xaaaa.\n          foldl_spmf (cpoke core) (return_spmf xa) xaaa \\<bind>\n          (\\<lambda>sc'.\n              map_spmf rprodl\n               (curry (fst x)\n                 (right_gpv\n                   (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                     (right_gpv\n                       (map_gpv (map_prod Inr (Pair suc)) id\n                         (xaaaa sur qur)))))\n                 (sc', xaa))) =\n          curry (snd x) (xaaaa sur qur) (xaa, xaaa) \\<bind>\n          map_spmf\n           (map_prod id\n             (\\<lambda>a.\n                 case a of\n                 (a, b) \\<Rightarrow>\n                   (case a of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (s11, s12) \\<Rightarrow>\n                         \\<lambda>s13 a.\n                            case a of\n                            (a, b) \\<Rightarrow>\n                              (case a of\n                               (s21, s22) \\<Rightarrow>\n                                 \\<lambda>s23.\n                                    (((s11, s21), s12, s22), s13, s23))\n                               b)\n                       b)\n                    b)) \\<circ>\n          ((\\<lambda>a.\n               case a of\n               (a, b) \\<Rightarrow>\n                 (case a of\n                  (o_rfunc, e_lst) \\<Rightarrow>\n                    \\<lambda>s_rfunc.\n                       map_spmf\n                        (\\<lambda>s_notify.\n                            (Inr (Inr o_rfunc), s_notify, s_rfunc))\n                        (map_spmf (Pair (sac, suc))\n                          (foldl_spmf (cpoke core) (return_spmf xa) e_lst)))\n                  b) \\<circ>\n           (\\<lambda>a.\n               case a of\n               (a, b) \\<Rightarrow>\n                 (case a of\n                  (ousr, s_usr') \\<Rightarrow>\n                    \\<lambda>a.\n                       case a of\n                       (s_rest', es) \\<Rightarrow>\n                         ((ousr, es), (sar, s_usr'), s_rest'))\n                  b)))\n\ngoal (2 subgoals):\n 1. \\<And>sc sr es cnv_usr_rest.\n       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n       (\\<lambda>sc'. map_spmf rprodl (return_pmf None)) =\n       return_pmf None \\<bind>\n       map_spmf\n        (map_prod id\n          (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n              (((s11, s21), s12, s22), s13, s23))) \\<circ>\n       ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n            map_spmf\n             (\\<lambda>s_notify. (Inr (Inr o_rfunc), s_notify, s_rfunc))\n             (map_spmf (Pair (sac, suc))\n               (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n        (\\<lambda>((ousr, s_usr'), s_rest', es).\n            ((ousr, es), (sar, s_usr'), s_rest')))\n 2. \\<And>f g sc sr es cnv_usr_rest.\n       (\\<And>sc sr es cnv_usr_rest.\n           foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n           (\\<lambda>sc'.\n               map_spmf rprodl\n                (f (right_gpv\n                     (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                       (right_gpv\n                         (map_gpv (map_prod Inr (Pair suc)) id\n                           (cnv_usr_rest sur qur)))))\n                  (sc', sr))) =\n           g (cnv_usr_rest sur qur) (sr, es) \\<bind>\n           map_spmf\n            (map_prod id\n              (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                  (((s11, s21), s12, s22), s13, s23))) \\<circ>\n           ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n                map_spmf\n                 (\\<lambda>s_notify. (Inr (Inr o_rfunc), s_notify, s_rfunc))\n                 (map_spmf (Pair (sac, suc))\n                   (foldl_spmf (cpoke core) (return_spmf sc)\n                     e_lst))) \\<circ>\n            (\\<lambda>((ousr, s_usr'), s_rest', es).\n                ((ousr, es), (sar, s_usr'), s_rest')))) \\<Longrightarrow>\n       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n       (\\<lambda>sc'.\n           map_spmf rprodl\n            (the_gpv\n              (right_gpv\n                (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                  (right_gpv\n                    (map_gpv (map_prod Inr (Pair suc)) id\n                      (cnv_usr_rest sur qur))))) \\<bind>\n             case_generat (\\<lambda>x. return_spmf (x, sc', sr))\n              (\\<lambda>out c.\n                  fused_resource.fuse core rest (sc', sr) out \\<bind>\n                  (\\<lambda>(x, y). f (c x) y)))) =\n       the_gpv (cnv_usr_rest sur qur) \\<bind>\n       case_generat (\\<lambda>x. return_spmf (x, sr, es))\n        (\\<lambda>out c.\n            (case (sr, es) of\n             (s, es) \\<Rightarrow>\n               \\<lambda>q.\n                  map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n                   (rfunc_usr rest s q))\n             out \\<bind>\n            (\\<lambda>(x, y). g (c x) y)) \\<bind>\n       map_spmf\n        (map_prod id\n          (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n              (((s11, s21), s12, s22), s13, s23))) \\<circ>\n       ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n            map_spmf\n             (\\<lambda>s_notify. (Inr (Inr o_rfunc), s_notify, s_rfunc))\n             (map_spmf (Pair (sac, suc))\n               (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n        (\\<lambda>((ousr, s_usr'), s_rest', es).\n            ((ousr, es), (sar, s_usr'), s_rest')))", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>sc sr es cnv_usr_rest.\n       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n       (\\<lambda>sc'. map_spmf rprodl (return_pmf None)) =\n       return_pmf None \\<bind>\n       map_spmf\n        (map_prod id\n          (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n              (((s11, s21), s12, s22), s13, s23))) \\<circ>\n       ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n            map_spmf\n             (\\<lambda>s_notify. (Inr (Inr o_rfunc), s_notify, s_rfunc))\n             (map_spmf (Pair (sac, suc))\n               (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n        (\\<lambda>((ousr, s_usr'), s_rest', es).\n            ((ousr, es), (sar, s_usr'), s_rest')))\n 2. \\<And>f g sc sr es cnv_usr_rest.\n       (\\<And>sc sr es cnv_usr_rest.\n           foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n           (\\<lambda>sc'.\n               map_spmf rprodl\n                (f (right_gpv\n                     (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                       (right_gpv\n                         (map_gpv (map_prod Inr (Pair suc)) id\n                           (cnv_usr_rest sur qur)))))\n                  (sc', sr))) =\n           g (cnv_usr_rest sur qur) (sr, es) \\<bind>\n           map_spmf\n            (map_prod id\n              (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                  (((s11, s21), s12, s22), s13, s23))) \\<circ>\n           ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n                map_spmf\n                 (\\<lambda>s_notify. (Inr (Inr o_rfunc), s_notify, s_rfunc))\n                 (map_spmf (Pair (sac, suc))\n                   (foldl_spmf (cpoke core) (return_spmf sc)\n                     e_lst))) \\<circ>\n            (\\<lambda>((ousr, s_usr'), s_rest', es).\n                ((ousr, es), (sar, s_usr'), s_rest')))) \\<Longrightarrow>\n       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n       (\\<lambda>sc'.\n           map_spmf rprodl\n            (the_gpv\n              (right_gpv\n                (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                  (right_gpv\n                    (map_gpv (map_prod Inr (Pair suc)) id\n                      (cnv_usr_rest sur qur))))) \\<bind>\n             case_generat (\\<lambda>x. return_spmf (x, sc', sr))\n              (\\<lambda>out c.\n                  fused_resource.fuse core rest (sc', sr) out \\<bind>\n                  (\\<lambda>(x, y). f (c x) y)))) =\n       the_gpv (cnv_usr_rest sur qur) \\<bind>\n       case_generat (\\<lambda>x. return_spmf (x, sr, es))\n        (\\<lambda>out c.\n            (case (sr, es) of\n             (s, es) \\<Rightarrow>\n               \\<lambda>q.\n                  map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n                   (rfunc_usr rest s q))\n             out \\<bind>\n            (\\<lambda>(x, y). g (c x) y)) \\<bind>\n       map_spmf\n        (map_prod id\n          (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n              (((s11, s21), s12, s22), s13, s23))) \\<circ>\n       ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n            map_spmf\n             (\\<lambda>s_notify. (Inr (Inr o_rfunc), s_notify, s_rfunc))\n             (map_spmf (Pair (sac, suc))\n               (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n        (\\<lambda>((ousr, s_usr'), s_rest', es).\n            ((ousr, es), (sar, s_usr'), s_rest')))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n    (\\<lambda>sc'. map_spmf rprodl (return_pmf None)) =\n    return_pmf None \\<bind>\n    map_spmf\n     (map_prod id\n       (\\<lambda>a.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of\n              (a, b) \\<Rightarrow>\n                (case a of\n                 (s11, s12) \\<Rightarrow>\n                   \\<lambda>s13 a.\n                      case a of\n                      (a, b) \\<Rightarrow>\n                        (case a of\n                         (s21, s22) \\<Rightarrow>\n                           \\<lambda>s23. (((s11, s21), s12, s22), s13, s23))\n                         b)\n                 b)\n              b)) \\<circ>\n    ((\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (o_rfunc, e_lst) \\<Rightarrow>\n              \\<lambda>s_rfunc.\n                 map_spmf\n                  (\\<lambda>s_notify.\n                      (Inr (Inr o_rfunc), s_notify, s_rfunc))\n                  (map_spmf (Pair (sac, suc))\n                    (foldl_spmf (cpoke core) (return_spmf sc) e_lst)))\n            b) \\<circ>\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (ousr, s_usr') \\<Rightarrow>\n              \\<lambda>a.\n                 case a of\n                 (s_rest', es) \\<Rightarrow>\n                   ((ousr, es), (sar, s_usr'), s_rest'))\n            b))", "by simp"], ["proof (state)\nthis:\n  foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n  (\\<lambda>sc'. map_spmf rprodl (return_pmf None)) =\n  return_pmf None \\<bind>\n  map_spmf\n   (map_prod id\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (a, b) \\<Rightarrow>\n              (case a of\n               (s11, s12) \\<Rightarrow>\n                 \\<lambda>s13 a.\n                    case a of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (s21, s22) \\<Rightarrow>\n                         \\<lambda>s23. (((s11, s21), s12, s22), s13, s23))\n                       b)\n               b)\n            b)) \\<circ>\n  ((\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (o_rfunc, e_lst) \\<Rightarrow>\n            \\<lambda>s_rfunc.\n               map_spmf\n                (\\<lambda>s_notify. (Inr (Inr o_rfunc), s_notify, s_rfunc))\n                (map_spmf (Pair (sac, suc))\n                  (foldl_spmf (cpoke core) (return_spmf sc) e_lst)))\n          b) \\<circ>\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (ousr, s_usr') \\<Rightarrow>\n            \\<lambda>a.\n               case a of\n               (s_rest', es) \\<Rightarrow>\n                 ((ousr, es), (sar, s_usr'), s_rest'))\n          b))\n\ngoal (1 subgoal):\n 1. \\<And>f g sc sr es cnv_usr_rest.\n       (\\<And>sc sr es cnv_usr_rest.\n           foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n           (\\<lambda>sc'.\n               map_spmf rprodl\n                (f (right_gpv\n                     (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                       (right_gpv\n                         (map_gpv (map_prod Inr (Pair suc)) id\n                           (cnv_usr_rest sur qur)))))\n                  (sc', sr))) =\n           g (cnv_usr_rest sur qur) (sr, es) \\<bind>\n           map_spmf\n            (map_prod id\n              (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                  (((s11, s21), s12, s22), s13, s23))) \\<circ>\n           ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n                map_spmf\n                 (\\<lambda>s_notify. (Inr (Inr o_rfunc), s_notify, s_rfunc))\n                 (map_spmf (Pair (sac, suc))\n                   (foldl_spmf (cpoke core) (return_spmf sc)\n                     e_lst))) \\<circ>\n            (\\<lambda>((ousr, s_usr'), s_rest', es).\n                ((ousr, es), (sar, s_usr'), s_rest')))) \\<Longrightarrow>\n       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n       (\\<lambda>sc'.\n           map_spmf rprodl\n            (the_gpv\n              (right_gpv\n                (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                  (right_gpv\n                    (map_gpv (map_prod Inr (Pair suc)) id\n                      (cnv_usr_rest sur qur))))) \\<bind>\n             case_generat (\\<lambda>x. return_spmf (x, sc', sr))\n              (\\<lambda>out c.\n                  fused_resource.fuse core rest (sc', sr) out \\<bind>\n                  (\\<lambda>(x, y). f (c x) y)))) =\n       the_gpv (cnv_usr_rest sur qur) \\<bind>\n       case_generat (\\<lambda>x. return_spmf (x, sr, es))\n        (\\<lambda>out c.\n            (case (sr, es) of\n             (s, es) \\<Rightarrow>\n               \\<lambda>q.\n                  map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n                   (rfunc_usr rest s q))\n             out \\<bind>\n            (\\<lambda>(x, y). g (c x) y)) \\<bind>\n       map_spmf\n        (map_prod id\n          (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n              (((s11, s21), s12, s22), s13, s23))) \\<circ>\n       ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n            map_spmf\n             (\\<lambda>s_notify. (Inr (Inr o_rfunc), s_notify, s_rfunc))\n             (map_spmf (Pair (sac, suc))\n               (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n        (\\<lambda>((ousr, s_usr'), s_rest', es).\n            ((ousr, es), (sar, s_usr'), s_rest')))", "case (step execl execr)"], ["proof (state)\nthis:\n  foldl_spmf (cpoke core) (return_spmf ?sc1) ?es1 \\<bind>\n  (\\<lambda>sc'.\n      map_spmf rprodl\n       (execl\n         (right_gpv\n           (map_gpv (map_prod Inr (Pair (sac, sar))) id\n             (right_gpv\n               (map_gpv (map_prod Inr (Pair suc)) id\n                 (?cnv_usr_rest1 sur qur)))))\n         (sc', ?sr1))) =\n  execr (?cnv_usr_rest1 sur qur) (?sr1, ?es1) \\<bind>\n  map_spmf\n   (map_prod id\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (a, b) \\<Rightarrow>\n              (case a of\n               (s11, s12) \\<Rightarrow>\n                 \\<lambda>s13 a.\n                    case a of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (s21, s22) \\<Rightarrow>\n                         \\<lambda>s23. (((s11, s21), s12, s22), s13, s23))\n                       b)\n               b)\n            b)) \\<circ>\n  ((\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (o_rfunc, e_lst) \\<Rightarrow>\n            \\<lambda>s_rfunc.\n               map_spmf\n                (\\<lambda>s_notify. (Inr (Inr o_rfunc), s_notify, s_rfunc))\n                (map_spmf (Pair (sac, suc))\n                  (foldl_spmf (cpoke core) (return_spmf ?sc1) e_lst)))\n          b) \\<circ>\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (ousr, s_usr') \\<Rightarrow>\n            \\<lambda>a.\n               case a of\n               (s_rest', es) \\<Rightarrow>\n                 ((ousr, es), (sar, s_usr'), s_rest'))\n          b))\n\ngoal (1 subgoal):\n 1. \\<And>f g sc sr es cnv_usr_rest.\n       (\\<And>sc sr es cnv_usr_rest.\n           foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n           (\\<lambda>sc'.\n               map_spmf rprodl\n                (f (right_gpv\n                     (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                       (right_gpv\n                         (map_gpv (map_prod Inr (Pair suc)) id\n                           (cnv_usr_rest sur qur)))))\n                  (sc', sr))) =\n           g (cnv_usr_rest sur qur) (sr, es) \\<bind>\n           map_spmf\n            (map_prod id\n              (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                  (((s11, s21), s12, s22), s13, s23))) \\<circ>\n           ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n                map_spmf\n                 (\\<lambda>s_notify. (Inr (Inr o_rfunc), s_notify, s_rfunc))\n                 (map_spmf (Pair (sac, suc))\n                   (foldl_spmf (cpoke core) (return_spmf sc)\n                     e_lst))) \\<circ>\n            (\\<lambda>((ousr, s_usr'), s_rest', es).\n                ((ousr, es), (sar, s_usr'), s_rest')))) \\<Longrightarrow>\n       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n       (\\<lambda>sc'.\n           map_spmf rprodl\n            (the_gpv\n              (right_gpv\n                (map_gpv (map_prod Inr (Pair (sac, sar))) id\n                  (right_gpv\n                    (map_gpv (map_prod Inr (Pair suc)) id\n                      (cnv_usr_rest sur qur))))) \\<bind>\n             case_generat (\\<lambda>x. return_spmf (x, sc', sr))\n              (\\<lambda>out c.\n                  fused_resource.fuse core rest (sc', sr) out \\<bind>\n                  (\\<lambda>(x, y). f (c x) y)))) =\n       the_gpv (cnv_usr_rest sur qur) \\<bind>\n       case_generat (\\<lambda>x. return_spmf (x, sr, es))\n        (\\<lambda>out c.\n            (case (sr, es) of\n             (s, es) \\<Rightarrow>\n               \\<lambda>q.\n                  map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n                   (rfunc_usr rest s q))\n             out \\<bind>\n            (\\<lambda>(x, y). g (c x) y)) \\<bind>\n       map_spmf\n        (map_prod id\n          (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n              (((s11, s21), s12, s22), s13, s23))) \\<circ>\n       ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n            map_spmf\n             (\\<lambda>s_notify. (Inr (Inr o_rfunc), s_notify, s_rfunc))\n             (map_spmf (Pair (sac, suc))\n               (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n        (\\<lambda>((ousr, s_usr'), s_rest', es).\n            ((ousr, es), (sar, s_usr'), s_rest')))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n    (\\<lambda>sc'.\n        map_spmf rprodl\n         (the_gpv\n           (right_gpv\n             (map_gpv (map_prod Inr (Pair (sac, sar))) id\n               (right_gpv\n                 (map_gpv (map_prod Inr (Pair suc)) id\n                   (cnv_usr_rest sur qur))))) \\<bind>\n          (\\<lambda>a.\n              case a of Pure x \\<Rightarrow> return_spmf (x, sc', sr)\n              | IO out c \\<Rightarrow>\n                  fused_resource.fuse core rest (sc', sr) out \\<bind>\n                  (\\<lambda>a.\n                      case a of (x, y) \\<Rightarrow> execl (c x) y)))) =\n    the_gpv (cnv_usr_rest sur qur) \\<bind>\n    (\\<lambda>a.\n        case a of Pure x \\<Rightarrow> return_spmf (x, sr, es)\n        | IO out c \\<Rightarrow>\n            (case (sr, es) of\n             (s, es) \\<Rightarrow>\n               \\<lambda>q.\n                  map_spmf\n                   (\\<lambda>a.\n                       case a of\n                       (a, b) \\<Rightarrow>\n                         (case a of\n                          (out, e) \\<Rightarrow>\n                            \\<lambda>s'. (out, s', es @ e))\n                          b)\n                   (rfunc_usr rest s q))\n             out \\<bind>\n            (\\<lambda>a.\n                case a of (x, y) \\<Rightarrow> execr (c x) y)) \\<bind>\n    map_spmf\n     (map_prod id\n       (\\<lambda>a.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of\n              (a, b) \\<Rightarrow>\n                (case a of\n                 (s11, s12) \\<Rightarrow>\n                   \\<lambda>s13 a.\n                      case a of\n                      (a, b) \\<Rightarrow>\n                        (case a of\n                         (s21, s22) \\<Rightarrow>\n                           \\<lambda>s23. (((s11, s21), s12, s22), s13, s23))\n                         b)\n                 b)\n              b)) \\<circ>\n    ((\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (o_rfunc, e_lst) \\<Rightarrow>\n              \\<lambda>s_rfunc.\n                 map_spmf\n                  (\\<lambda>s_notify.\n                      (Inr (Inr o_rfunc), s_notify, s_rfunc))\n                  (map_spmf (Pair (sac, suc))\n                    (foldl_spmf (cpoke core) (return_spmf sc) e_lst)))\n            b) \\<circ>\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (ousr, s_usr') \\<Rightarrow>\n              \\<lambda>a.\n                 case a of\n                 (s_rest', es) \\<Rightarrow>\n                   ((ousr, es), (sar, s_usr'), s_rest'))\n            b))", "apply(clarsimp simp add: gpv.map_sel map_bind_spmf bind_map_spmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n    (\\<lambda>sc'.\n        the_gpv (cnv_usr_rest sur qur) \\<bind>\n        map_spmf rprodl \\<circ>\n        (case_generat (\\<lambda>x. return_spmf (x, sc', sr))\n          (\\<lambda>out c.\n              fused_resource.fuse core rest (sc', sr) out \\<bind>\n              (\\<lambda>(x, y). execl (c x) y)) \\<circ>\n         map_generat id Inr right_rpv \\<circ>\n         map_generat (map_prod Inr (Pair (sac, sar))) (\\<lambda>a. a)\n          ((\\<circ>)\n            (map_gpv (map_prod Inr (Pair (sac, sar)))\n              (\\<lambda>a. a))) \\<circ>\n         map_generat id Inr right_rpv \\<circ>\n         map_generat (map_prod Inr (Pair suc)) (\\<lambda>a. a)\n          ((\\<circ>)\n            (map_gpv (map_prod Inr (Pair suc)) (\\<lambda>a. a))))) =\n    the_gpv (cnv_usr_rest sur qur) \\<bind>\n    (\\<lambda>y.\n        (case y of Pure x \\<Rightarrow> return_spmf (x, sr, es)\n         | IO out c \\<Rightarrow>\n             map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n              (rfunc_usr rest sr out) \\<bind>\n             (\\<lambda>(x, y). execr (c x) y)) \\<bind>\n        (\\<lambda>a.\n            map_spmf\n             (map_prod (\\<lambda>a. a)\n               (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                   (((s11, s21), s12, s22), s13, s23)))\n             (case case a of\n                   (x, xa) \\<Rightarrow>\n                     (case x of\n                      (ousr, s_usr') \\<Rightarrow>\n                        \\<lambda>(s_rest', es).\n                           ((ousr, es), (sar, s_usr'), s_rest'))\n                      xa of\n              (x, xa) \\<Rightarrow>\n                (case x of\n                 (o_rfunc, e_lst) \\<Rightarrow>\n                   \\<lambda>s_rfunc.\n                      map_spmf\n                       (\\<lambda>s_notify.\n                           (Inr (Inr o_rfunc), s_notify, s_rfunc))\n                       (map_spmf (Pair (sac, suc))\n                         (foldl_spmf (cpoke core) (return_spmf sc) e_lst)))\n                 xa)))", "apply(subst bind_commute_spmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. the_gpv (cnv_usr_rest sur qur) \\<bind>\n    (\\<lambda>y.\n        foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n        (\\<lambda>x.\n            (map_spmf rprodl \\<circ>\n             (case_generat (\\<lambda>xa. return_spmf (xa, x, sr))\n               (\\<lambda>out c.\n                   fused_resource.fuse core rest (x, sr) out \\<bind>\n                   (\\<lambda>(x, y). execl (c x) y)) \\<circ>\n              map_generat id Inr right_rpv \\<circ>\n              map_generat (map_prod Inr (Pair (sac, sar))) (\\<lambda>a. a)\n               ((\\<circ>)\n                 (map_gpv (map_prod Inr (Pair (sac, sar)))\n                   (\\<lambda>a. a))) \\<circ>\n              map_generat id Inr right_rpv \\<circ>\n              map_generat (map_prod Inr (Pair suc)) (\\<lambda>a. a)\n               ((\\<circ>)\n                 (map_gpv (map_prod Inr (Pair suc)) (\\<lambda>a. a)))))\n             y)) =\n    the_gpv (cnv_usr_rest sur qur) \\<bind>\n    (\\<lambda>y.\n        (case y of Pure x \\<Rightarrow> return_spmf (x, sr, es)\n         | IO out c \\<Rightarrow>\n             map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n              (rfunc_usr rest sr out) \\<bind>\n             (\\<lambda>(x, y). execr (c x) y)) \\<bind>\n        (\\<lambda>a.\n            map_spmf\n             (map_prod (\\<lambda>a. a)\n               (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                   (((s11, s21), s12, s22), s13, s23)))\n             (case case a of\n                   (x, xa) \\<Rightarrow>\n                     (case x of\n                      (ousr, s_usr') \\<Rightarrow>\n                        \\<lambda>(s_rest', es).\n                           ((ousr, es), (sar, s_usr'), s_rest'))\n                      xa of\n              (x, xa) \\<Rightarrow>\n                (case x of\n                 (o_rfunc, e_lst) \\<Rightarrow>\n                   \\<lambda>s_rfunc.\n                      map_spmf\n                       (\\<lambda>s_notify.\n                           (Inr (Inr o_rfunc), s_notify, s_rfunc))\n                       (map_spmf (Pair (sac, suc))\n                         (foldl_spmf (cpoke core) (return_spmf sc) e_lst)))\n                 xa)))", "apply(clarsimp simp add: gpv.map_sel map_bind_spmf bind_map_spmf spmf.map_comp o_def map_spmf_conv_bind_spmf[symmetric] intro!: bind_spmf_cong[OF refl] split!: generat.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22\n       \\<in> set_spmf (the_gpv (cnv_usr_rest sur qur)) \\<Longrightarrow>\n       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n       (\\<lambda>x.\n           rfunc_usr rest sr x21 \\<bind>\n           (\\<lambda>xa.\n               (case xa of\n                (xa, xb) \\<Rightarrow>\n                  (case xa of\n                   (o_rfunc, e_lst) \\<Rightarrow>\n                     \\<lambda>s_rfunc.\n                        map_spmf\n                         (\\<lambda>s_notify.\n                             (Inr (Inr o_rfunc), s_notify, s_rfunc))\n                         (foldl_spmf (cpoke core) (return_spmf x) e_lst))\n                   xb) \\<bind>\n               (\\<lambda>x.\n                   map_spmf rprodl\n                    (case x of\n                     (x, xa) \\<Rightarrow>\n                       execl\n                        (right_rpv\n                          (\\<lambda>input'.\n                              map_gpv (map_prod Inr (Pair (sac, sar)))\n                               (\\<lambda>a. a)\n                               (right_rpv\n                                 (\\<lambda>input'.\n                                     map_gpv (map_prod Inr (Pair suc))\n(\\<lambda>a. a) (x22 input'))\n                                 input'))\n                          x)\n                        xa)))) =\n       rfunc_usr rest sr x21 \\<bind>\n       (\\<lambda>y.\n           (case case y of\n                 (x, xa) \\<Rightarrow>\n                   (case x of\n                    (out, e) \\<Rightarrow> \\<lambda>s'. (out, s', es @ e))\n                    xa of\n            (x, xa) \\<Rightarrow> execr (x22 x) xa) \\<bind>\n           (\\<lambda>a.\n               map_spmf\n                (map_prod (\\<lambda>a. a)\n                  (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                      (((s11, s21), s12, s22), s13, s23)))\n                (case case a of\n                      (x, xa) \\<Rightarrow>\n                        (case x of\n                         (ousr, s_usr') \\<Rightarrow>\n                           \\<lambda>(s_rest', es).\n                              ((ousr, es), (sar, s_usr'), s_rest'))\n                         xa of\n                 (x, xa) \\<Rightarrow>\n                   (case x of\n                    (o_rfunc, e_lst) \\<Rightarrow>\n                      \\<lambda>s_rfunc.\n                         map_spmf\n                          (\\<lambda>x.\n                              (Inr (Inr o_rfunc), ((sac, suc), x), s_rfunc))\n                          (foldl_spmf (cpoke core) (return_spmf sc) e_lst))\n                    xa)))", "apply(subst bind_commute_spmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22\n       \\<in> set_spmf (the_gpv (cnv_usr_rest sur qur)) \\<Longrightarrow>\n       rfunc_usr rest sr x21 \\<bind>\n       (\\<lambda>y.\n           foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n           (\\<lambda>x.\n               (case y of\n                (xa, xb) \\<Rightarrow>\n                  (case xa of\n                   (o_rfunc, e_lst) \\<Rightarrow>\n                     \\<lambda>s_rfunc.\n                        map_spmf\n                         (\\<lambda>s_notify.\n                             (Inr (Inr o_rfunc), s_notify, s_rfunc))\n                         (foldl_spmf (cpoke core) (return_spmf x) e_lst))\n                   xb) \\<bind>\n               (\\<lambda>x.\n                   map_spmf rprodl\n                    (case x of\n                     (x, xa) \\<Rightarrow>\n                       execl\n                        (right_rpv\n                          (\\<lambda>input'.\n                              map_gpv (map_prod Inr (Pair (sac, sar)))\n                               (\\<lambda>a. a)\n                               (right_rpv\n                                 (\\<lambda>input'.\n                                     map_gpv (map_prod Inr (Pair suc))\n(\\<lambda>a. a) (x22 input'))\n                                 input'))\n                          x)\n                        xa)))) =\n       rfunc_usr rest sr x21 \\<bind>\n       (\\<lambda>y.\n           (case case y of\n                 (x, xa) \\<Rightarrow>\n                   (case x of\n                    (out, e) \\<Rightarrow> \\<lambda>s'. (out, s', es @ e))\n                    xa of\n            (x, xa) \\<Rightarrow> execr (x22 x) xa) \\<bind>\n           (\\<lambda>a.\n               map_spmf\n                (map_prod (\\<lambda>a. a)\n                  (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                      (((s11, s21), s12, s22), s13, s23)))\n                (case case a of\n                      (x, xa) \\<Rightarrow>\n                        (case x of\n                         (ousr, s_usr') \\<Rightarrow>\n                           \\<lambda>(s_rest', es).\n                              ((ousr, es), (sar, s_usr'), s_rest'))\n                         xa of\n                 (x, xa) \\<Rightarrow>\n                   (case x of\n                    (o_rfunc, e_lst) \\<Rightarrow>\n                      \\<lambda>s_rfunc.\n                         map_spmf\n                          (\\<lambda>x.\n                              (Inr (Inr o_rfunc), ((sac, suc), x), s_rfunc))\n                          (foldl_spmf (cpoke core) (return_spmf sc) e_lst))\n                    xa)))", "apply(clarsimp simp add: gpv.map_sel map_bind_spmf bind_map_spmf spmf.map_comp o_def map_spmf_conv_bind_spmf[symmetric] intro!: bind_spmf_cong[OF refl] split!: generat.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 a b ba.\n       \\<lbrakk>IO x21 x22 \\<in> set_spmf (the_gpv (cnv_usr_rest sur qur));\n        ((a, b), ba) \\<in> set_spmf (rfunc_usr rest sr x21)\\<rbrakk>\n       \\<Longrightarrow> foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n                         (\\<lambda>x.\n                             foldl_spmf (cpoke core) (return_spmf x)\n                              b \\<bind>\n                             (\\<lambda>x.\n                                 map_spmf rprodl\n                                  (execl\n                                    (right_gpv\n(map_gpv (map_prod Inr (Pair (sac, sar))) (\\<lambda>a. a)\n  (right_gpv (map_gpv (map_prod Inr (Pair suc)) (\\<lambda>a. a) (x22 a)))))\n                                    (x, ba)))) =\n                         execr (x22 a) (ba, es @ b) \\<bind>\n                         (\\<lambda>a.\n                             map_spmf\n                              (map_prod (\\<lambda>a. a)\n                                (\\<lambda>(((s11, s12), s13), (s21, s22),\n                                    s23).\n                                    (((s11, s21), s12, s22), s13, s23)))\n                              (case case a of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (ousr, s_usr') \\<Rightarrow>\n   \\<lambda>(s_rest', es). ((ousr, es), (sar, s_usr'), s_rest'))\n xa of\n                               (x, xa) \\<Rightarrow>\n                                 (case x of\n                                  (o_rfunc, e_lst) \\<Rightarrow>\n                                    \\<lambda>s_rfunc.\n map_spmf (\\<lambda>x. (Inr (Inr o_rfunc), ((sac, suc), x), s_rfunc))\n  (foldl_spmf (cpoke core) (return_spmf sc) e_lst))\n                                  xa))", "apply(simp add: bind_spmf_assoc[symmetric] bind_foldl_spmf_return foldl_spmf_append[symmetric] del: bind_spmf_assoc )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 a b ba.\n       \\<lbrakk>IO x21 x22 \\<in> set_spmf (the_gpv (cnv_usr_rest sur qur));\n        ((a, b), ba) \\<in> set_spmf (rfunc_usr rest sr x21)\\<rbrakk>\n       \\<Longrightarrow> foldl_spmf (cpoke core) (return_spmf sc)\n                          (es @ b) \\<bind>\n                         (\\<lambda>x.\n                             map_spmf rprodl\n                              (execl\n                                (right_gpv\n                                  (map_gpv (map_prod Inr (Pair (sac, sar)))\n                                    (\\<lambda>a. a)\n                                    (right_gpv\n(map_gpv (map_prod Inr (Pair suc)) (\\<lambda>a. a) (x22 a)))))\n                                (x, ba))) =\n                         execr (x22 a) (ba, es @ b) \\<bind>\n                         (\\<lambda>a.\n                             map_spmf\n                              (map_prod (\\<lambda>a. a)\n                                (\\<lambda>(((s11, s12), s13), (s21, s22),\n                                    s23).\n                                    (((s11, s21), s12, s22), s13, s23)))\n                              (case case a of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (ousr, s_usr') \\<Rightarrow>\n   \\<lambda>(s_rest', es). ((ousr, es), (sar, s_usr'), s_rest'))\n xa of\n                               (x, xa) \\<Rightarrow>\n                                 (case x of\n                                  (o_rfunc, e_lst) \\<Rightarrow>\n                                    \\<lambda>s_rfunc.\n map_spmf (\\<lambda>x. (Inr (Inr o_rfunc), ((sac, suc), x), s_rfunc))\n  (foldl_spmf (cpoke core) (return_spmf sc) e_lst))\n                                  xa))", "apply(subst step.IH[unfolded id_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 a b ba.\n       \\<lbrakk>IO x21 x22 \\<in> set_spmf (the_gpv (cnv_usr_rest sur qur));\n        ((a, b), ba) \\<in> set_spmf (rfunc_usr rest sr x21)\\<rbrakk>\n       \\<Longrightarrow> execr (x22 a) (ba, es @ b) \\<bind>\n                         map_spmf\n                          (map_prod (\\<lambda>a. a)\n                            (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n                                (((s11, s21), s12, s22), s13, s23))) \\<circ>\n                         ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n                              map_spmf\n                               (\\<lambda>s_notify.\n                                   (Inr (Inr o_rfunc), s_notify, s_rfunc))\n                               (map_spmf (Pair (sac, suc))\n                                 (foldl_spmf (cpoke core) (return_spmf sc)\n                                   e_lst))) \\<circ>\n                          (\\<lambda>((ousr, s_usr'), s_rest', es).\n                              ((ousr, es), (sar, s_usr'), s_rest'))) =\n                         execr (x22 a) (ba, es @ b) \\<bind>\n                         (\\<lambda>a.\n                             map_spmf\n                              (map_prod (\\<lambda>a. a)\n                                (\\<lambda>(((s11, s12), s13), (s21, s22),\n                                    s23).\n                                    (((s11, s21), s12, s22), s13, s23)))\n                              (case case a of\n                                    (x, xa) \\<Rightarrow>\n(case x of\n (ousr, s_usr') \\<Rightarrow>\n   \\<lambda>(s_rest', es). ((ousr, es), (sar, s_usr'), s_rest'))\n xa of\n                               (x, xa) \\<Rightarrow>\n                                 (case x of\n                                  (o_rfunc, e_lst) \\<Rightarrow>\n                                    \\<lambda>s_rfunc.\n map_spmf (\\<lambda>x. (Inr (Inr o_rfunc), ((sac, suc), x), s_rfunc))\n  (foldl_spmf (cpoke core) (return_spmf sc) e_lst))\n                                  xa))", "apply(simp add: split_def o_def spmf.map_comp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n  (\\<lambda>sc'.\n      map_spmf rprodl\n       (the_gpv\n         (right_gpv\n           (map_gpv (map_prod Inr (Pair (sac, sar))) id\n             (right_gpv\n               (map_gpv (map_prod Inr (Pair suc)) id\n                 (cnv_usr_rest sur qur))))) \\<bind>\n        (\\<lambda>a.\n            case a of Pure x \\<Rightarrow> return_spmf (x, sc', sr)\n            | IO out c \\<Rightarrow>\n                fused_resource.fuse core rest (sc', sr) out \\<bind>\n                (\\<lambda>a.\n                    case a of (x, y) \\<Rightarrow> execl (c x) y)))) =\n  the_gpv (cnv_usr_rest sur qur) \\<bind>\n  (\\<lambda>a.\n      case a of Pure x \\<Rightarrow> return_spmf (x, sr, es)\n      | IO out c \\<Rightarrow>\n          (case (sr, es) of\n           (s, es) \\<Rightarrow>\n             \\<lambda>q.\n                map_spmf\n                 (\\<lambda>a.\n                     case a of\n                     (a, b) \\<Rightarrow>\n                       (case a of\n                        (out, e) \\<Rightarrow>\n                          \\<lambda>s'. (out, s', es @ e))\n                        b)\n                 (rfunc_usr rest s q))\n           out \\<bind>\n          (\\<lambda>a.\n              case a of (x, y) \\<Rightarrow> execr (c x) y)) \\<bind>\n  map_spmf\n   (map_prod id\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (a, b) \\<Rightarrow>\n              (case a of\n               (s11, s12) \\<Rightarrow>\n                 \\<lambda>s13 a.\n                    case a of\n                    (a, b) \\<Rightarrow>\n                      (case a of\n                       (s21, s22) \\<Rightarrow>\n                         \\<lambda>s23. (((s11, s21), s12, s22), s13, s23))\n                       b)\n               b)\n            b)) \\<circ>\n  ((\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (o_rfunc, e_lst) \\<Rightarrow>\n            \\<lambda>s_rfunc.\n               map_spmf\n                (\\<lambda>s_notify. (Inr (Inr o_rfunc), s_notify, s_rfunc))\n                (map_spmf (Pair (sac, suc))\n                  (foldl_spmf (cpoke core) (return_spmf sc) e_lst)))\n          b) \\<circ>\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (ousr, s_usr') \\<Rightarrow>\n            \\<lambda>a.\n               case a of\n               (s_rest', es) \\<Rightarrow>\n                 ((ousr, es), (sar, s_usr'), s_rest'))\n          b))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldl_spmf (cpoke core) (return_spmf sc) ?es2 \\<bind>\n  (\\<lambda>sc'.\n      map_spmf rprodl\n       (exec_gpv (fused_resource.fuse core rest)\n         (right_gpv\n           (map_gpv (map_prod Inr (Pair (sac, sar))) id\n             (right_gpv\n               (map_gpv (map_prod Inr (Pair suc)) id\n                 (cnv_usr_rest sur qur)))))\n         (sc', sr))) =\n  exec_gpv\n   (\\<lambda>(s, es) q.\n       map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n        (rfunc_usr rest s q))\n   (cnv_usr_rest sur qur) (sr, ?es2) \\<bind>\n  map_spmf\n   (map_prod id\n     (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n         (((s11, s21), s12, s22), s13, s23))) \\<circ>\n  ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n       map_spmf (\\<lambda>s_notify. (Inr (Inr o_rfunc), s_notify, s_rfunc))\n        (map_spmf (Pair (sac, suc))\n          (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n   (\\<lambda>((ousr, s_usr'), s_rest', es).\n       ((ousr, es), (sar, s_usr'), s_rest')))\n\ngoal (1 subgoal):\n 1. \\<And>qur.\n       q = Inr (Inr qur) \\<Longrightarrow>\n       attach_callee\n        ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n        (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n       apply_state_iso iso_trisplit\n        (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n        (((sac, sar), suc, sur), sc, sr) q", "from this[of \"[]\"]"], ["proof (chain)\npicking this:\n  foldl_spmf (cpoke core) (return_spmf sc) [] \\<bind>\n  (\\<lambda>sc'.\n      map_spmf rprodl\n       (exec_gpv (fused_resource.fuse core rest)\n         (right_gpv\n           (map_gpv (map_prod Inr (Pair (sac, sar))) id\n             (right_gpv\n               (map_gpv (map_prod Inr (Pair suc)) id\n                 (cnv_usr_rest sur qur)))))\n         (sc', sr))) =\n  exec_gpv\n   (\\<lambda>(s, es) q.\n       map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n        (rfunc_usr rest s q))\n   (cnv_usr_rest sur qur) (sr, []) \\<bind>\n  map_spmf\n   (map_prod id\n     (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n         (((s11, s21), s12, s22), s13, s23))) \\<circ>\n  ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n       map_spmf (\\<lambda>s_notify. (Inr (Inr o_rfunc), s_notify, s_rfunc))\n        (map_spmf (Pair (sac, suc))\n          (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n   (\\<lambda>((ousr, s_usr'), s_rest', es).\n       ((ousr, es), (sar, s_usr'), s_rest')))", "show ?thesis"], ["proof (prove)\nusing this:\n  foldl_spmf (cpoke core) (return_spmf sc) [] \\<bind>\n  (\\<lambda>sc'.\n      map_spmf rprodl\n       (exec_gpv (fused_resource.fuse core rest)\n         (right_gpv\n           (map_gpv (map_prod Inr (Pair (sac, sar))) id\n             (right_gpv\n               (map_gpv (map_prod Inr (Pair suc)) id\n                 (cnv_usr_rest sur qur)))))\n         (sc', sr))) =\n  exec_gpv\n   (\\<lambda>(s, es) q.\n       map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n        (rfunc_usr rest s q))\n   (cnv_usr_rest sur qur) (sr, []) \\<bind>\n  map_spmf\n   (map_prod id\n     (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n         (((s11, s21), s12, s22), s13, s23))) \\<circ>\n  ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n       map_spmf (\\<lambda>s_notify. (Inr (Inr o_rfunc), s_notify, s_rfunc))\n        (map_spmf (Pair (sac, suc))\n          (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n   (\\<lambda>((ousr, s_usr'), s_rest', es).\n       ((ousr, es), (sar, s_usr'), s_rest')))\n\ngoal (1 subgoal):\n 1. attach_callee\n     ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n      cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n     (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n    apply_state_iso iso_trisplit\n     (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n       (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n     (((sac, sar), suc, sur), sc, sr) q", "using URest"], ["proof (prove)\nusing this:\n  foldl_spmf (cpoke core) (return_spmf sc) [] \\<bind>\n  (\\<lambda>sc'.\n      map_spmf rprodl\n       (exec_gpv (fused_resource.fuse core rest)\n         (right_gpv\n           (map_gpv (map_prod Inr (Pair (sac, sar))) id\n             (right_gpv\n               (map_gpv (map_prod Inr (Pair suc)) id\n                 (cnv_usr_rest sur qur)))))\n         (sc', sr))) =\n  exec_gpv\n   (\\<lambda>(s, es) q.\n       map_spmf (\\<lambda>((out, e), s'). (out, s', es @ e))\n        (rfunc_usr rest s q))\n   (cnv_usr_rest sur qur) (sr, []) \\<bind>\n  map_spmf\n   (map_prod id\n     (\\<lambda>(((s11, s12), s13), (s21, s22), s23).\n         (((s11, s21), s12, s22), s13, s23))) \\<circ>\n  ((\\<lambda>((o_rfunc, e_lst), s_rfunc).\n       map_spmf (\\<lambda>s_notify. (Inr (Inr o_rfunc), s_notify, s_rfunc))\n        (map_spmf (Pair (sac, suc))\n          (foldl_spmf (cpoke core) (return_spmf sc) e_lst))) \\<circ>\n   (\\<lambda>((ousr, s_usr'), s_rest', es).\n       ((ousr, es), (sar, s_usr'), s_rest')))\n  q = Inr (Inr qur)\n\ngoal (1 subgoal):\n 1. attach_callee\n     ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n      cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n     (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n    apply_state_iso iso_trisplit\n     (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n       (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n     (((sac, sar), suc, sur), sc, sr) q", "by(simp add: apply_state_iso_def iso_trisplit_def map_bind_spmf bind_map_spmf map_spmf_conv_bind_spmf[symmetric] foldl_spmf_pair_right)"], ["proof (state)\nthis:\n  attach_callee\n   ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n    cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n   (fused_resource.fuse core rest) (((sac, sar), suc, sur), sc, sr) q =\n  apply_state_iso iso_trisplit\n   (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n     (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n   (((sac, sar), suc, sur), sc, sr) q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  attach_callee\n   ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n    cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n   (fused_resource.fuse core rest)\n   (((?sac1, ?sar1), ?suc1, ?sur1), ?sc1, ?sr1) q =\n  apply_state_iso iso_trisplit\n   (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n     (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n   (((?sac1, ?sar1), ?suc1, ?sur1), ?sc1, ?sr1) q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma attach_parallel_fuse':\n  \"(CNV cnv_adv_core s_a_c |\\<^sub>= CNV cnv_adv_rest s_a_r) |\\<^sub>= (CNV cnv_usr_core s_u_c |\\<^sub>= CNV cnv_usr_rest s_u_r) \\<rhd> \n   RES (fused_resource.fuse core rest) (s_r_c, s_r_r) = \n   RES (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core) (attach_rest cnv_adv_rest cnv_usr_rest f_init rest)) (((s_a_c, s_u_c), s_r_c), ((s_a_r, s_u_r), s_r_r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (CNV cnv_adv_core s_a_c |\\<^sub>= CNV cnv_adv_rest s_a_r) |\\<^sub>=\n    CNV cnv_usr_core s_u_c |\\<^sub>= CNV cnv_usr_rest s_u_r \\<rhd>\n    RES (fused_resource.fuse core rest) (s_r_c, s_r_r) =\n    RES (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n     (((s_a_c, s_u_c), s_r_c), (s_a_r, s_u_r), s_r_r)", "apply(fold conv_callee_parallel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n         cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n     ((s_a_c, s_a_r), s_u_c, s_u_r) \\<rhd>\n    RES (fused_resource.fuse core rest) (s_r_c, s_r_r) =\n    RES (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n     (((s_a_c, s_u_c), s_r_c), (s_a_r, s_u_r), s_r_r)", "apply(unfold attach_CNV_RES)"], ["proof (prove)\ngoal (1 subgoal):\n 1. RES (attach_callee\n          ((cnv_adv_core \\<ddagger>\\<^sub>I cnv_adv_rest) \\<ddagger>\\<^sub>I\n           cnv_usr_core \\<ddagger>\\<^sub>I cnv_usr_rest)\n          (fused_resource.fuse core rest))\n     (((s_a_c, s_a_r), s_u_c, s_u_r), s_r_c, s_r_r) =\n    RES (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n     (((s_a_c, s_u_c), s_r_c), (s_a_r, s_u_r), s_r_r)", "apply(subst attach_callee_fuse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. RES (apply_state_iso iso_trisplit\n          (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n            (attach_rest cnv_adv_rest cnv_usr_rest ?f_init rest)))\n     (((s_a_c, s_a_r), s_u_c, s_u_r), s_r_c, s_r_r) =\n    RES (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n     (((s_a_c, s_u_c), s_r_c), (s_a_r, s_u_r), s_r_r)", "apply(subst resource_of_oracle_state_iso)"], ["proof (prove)\ngoal (2 subgoals):\n 1. state_iso iso_trisplit\n 2. RES (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest ?f_init rest))\n     (snd iso_trisplit (((s_a_c, s_a_r), s_u_c, s_u_r), s_r_c, s_r_r)) =\n    RES (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n     (((s_a_c, s_u_c), s_r_c), (s_a_r, s_u_r), s_r_r)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. RES (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest ?f_init rest))\n     (snd iso_trisplit (((s_a_c, s_a_r), s_u_c, s_u_r), s_r_c, s_r_r)) =\n    RES (fused_resource.fuse (attach_core cnv_adv_core cnv_usr_core core)\n          (attach_rest cnv_adv_rest cnv_usr_rest f_init rest))\n     (((s_a_c, s_u_c), s_r_c), (s_a_r, s_u_r), s_r_r)", "apply(simp add: iso_trisplit_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n\n\\<comment> \\<open>Moving event translators from rest to the core\\<close>"], ["", "context\n  fixes\n    einit :: 's_event and\n    etran :: \"('s_event, 'ievent, 'oevent list) oracle'\" and\n    rest :: \"('s_rest, 'ievent, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest) rest_wstate\" and\n    core :: \"('s_core, 'oevent, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\"\nbegin"], ["", "primcorec\n  translate_rest :: \"('s_event \\<times> 's_rest, 'oevent, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest) rest_wstate\"\n  where\n    \"rinit translate_rest = (einit, rinit rest)\"\n  | \"rfunc_adv translate_rest = translate_eoracle etran (extend_state_oracle (rfunc_adv rest))\"\n  | \"rfunc_usr translate_rest = translate_eoracle etran (extend_state_oracle (rfunc_usr rest))\""], ["", "primcorec\n  translate_core :: \"('s_event \\<times> 's_core, 'ievent, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\"\n  where\n    \"cpoke translate_core = (\\<lambda>(s_event, s_core) event. \n      bind_spmf (etran s_event event) (\\<lambda>(events, s_event'). \n        map_spmf (\\<lambda>s_core'. (s_event', s_core')) (foldl_spmf (cpoke core) (return_spmf s_core) events)))\"\n  | \"cfunc_adv translate_core = extend_state_oracle (cfunc_adv core)\"\n  | \"cfunc_usr translate_core = extend_state_oracle (cfunc_usr core)\""], ["", "lemma WT_translate_rest [WT_intro]: \n  assumes \"WT_rest \\<I>_adv \\<I>_usr I_rest rest\"\n  shows \"WT_rest \\<I>_adv \\<I>_usr (pred_prod (\\<lambda>_. True) I_rest) translate_rest\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WT_rest \\<I>_adv \\<I>_usr (pred_prod (\\<lambda>_. True) I_rest)\n     local.translate_rest", "by(rule WT_rest.intros)(auto simp add: translate_eoracle_def simp add: WT_restD_rinit[OF assms] dest!: WT_restD(1,2)[OF assms])"], ["", "lemma fused_resource_move_translate:\n  \"fused_resource.fuse core translate_rest = apply_state_iso iso_swapar (fused_resource.fuse translate_core rest)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fused_resource.fuse core local.translate_rest =\n    apply_state_iso iso_swapar\n     (fused_resource.fuse local.translate_core rest)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fused_resource.fuse core local.translate_rest =\n    apply_state_iso iso_swapar\n     (fused_resource.fuse local.translate_core rest)", "note [simp] = exec_gpv_bind spmf.map_comp o_def map_bind_spmf bind_map_spmf bind_spmf_const"], ["proof (state)\nthis:\n  exec_gpv ?callee (?c \\<bind> ?f) ?s =\n  exec_gpv ?callee ?c ?s \\<bind>\n  (\\<lambda>xa. case xa of (x, s') \\<Rightarrow> exec_gpv ?callee (?f x) s')\n  map_spmf ?f (map_spmf ?g ?p) = map_spmf (?f \\<circ> ?g) ?p\n  ?f \\<circ> ?g = (\\<lambda>x. ?f (?g x))\n  map_spmf ?f (?p \\<bind> ?g) = ?p \\<bind> map_spmf ?f \\<circ> ?g\n  map_spmf ?f ?p \\<bind> ?g = ?p \\<bind> ?g \\<circ> ?f\n  ?p \\<bind> (\\<lambda>x. ?q) = scale_spmf (weight_spmf ?p) ?q\n\ngoal (1 subgoal):\n 1. fused_resource.fuse core local.translate_rest =\n    apply_state_iso iso_swapar\n     (fused_resource.fuse local.translate_core rest)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fused_resource.fuse core local.translate_rest =\n    apply_state_iso iso_swapar\n     (fused_resource.fuse local.translate_core rest)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       fused_resource.fuse core local.translate_rest x =\n       apply_state_iso iso_swapar\n        (fused_resource.fuse local.translate_core rest) x", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       fused_resource.fuse core local.translate_rest x xa =\n       apply_state_iso iso_swapar\n        (fused_resource.fuse local.translate_core rest) x xa", "subgoal for s query"], ["proof (prove)\ngoal (1 subgoal):\n 1. fused_resource.fuse core local.translate_rest s query =\n    apply_state_iso iso_swapar\n     (fused_resource.fuse local.translate_core rest) s query", "apply (cases s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       s = (a, b, c) \\<Longrightarrow>\n       fused_resource.fuse core local.translate_rest s query =\n       apply_state_iso iso_swapar\n        (fused_resource.fuse local.translate_core rest) s query", "subgoal for s_core s_event s_rest"], ["proof (prove)\ngoal (1 subgoal):\n 1. s = (s_core, s_event, s_rest) \\<Longrightarrow>\n    fused_resource.fuse core local.translate_rest s query =\n    apply_state_iso iso_swapar\n     (fused_resource.fuse local.translate_core rest) s query", "apply (cases query)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>s = (s_core, s_event, s_rest); query = Inl a\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core local.translate_rest s\n                          query =\n                         apply_state_iso iso_swapar\n                          (fused_resource.fuse local.translate_core rest) s\n                          query\n 2. \\<And>b.\n       \\<lbrakk>s = (s_core, s_event, s_rest); query = Inr b\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core local.translate_rest s\n                          query =\n                         apply_state_iso iso_swapar\n                          (fused_resource.fuse local.translate_core rest) s\n                          query", "subgoal for q_adv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s = (s_core, s_event, s_rest); query = Inl q_adv\\<rbrakk>\n    \\<Longrightarrow> fused_resource.fuse core local.translate_rest s\n                       query =\n                      apply_state_iso iso_swapar\n                       (fused_resource.fuse local.translate_core rest) s\n                       query", "apply (cases q_adv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>s = (s_core, s_event, s_rest); query = Inl q_adv;\n        q_adv = Inl a\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core local.translate_rest s\n                          query =\n                         apply_state_iso iso_swapar\n                          (fused_resource.fuse local.translate_core rest) s\n                          query\n 2. \\<And>b.\n       \\<lbrakk>s = (s_core, s_event, s_rest); query = Inl q_adv;\n        q_adv = Inr b\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core local.translate_rest s\n                          query =\n                         apply_state_iso iso_swapar\n                          (fused_resource.fuse local.translate_core rest) s\n                          query", "subgoal for q_acore"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s = (s_core, s_event, s_rest); query = Inl q_adv;\n     q_adv = Inl q_acore\\<rbrakk>\n    \\<Longrightarrow> fused_resource.fuse core local.translate_rest s\n                       query =\n                      apply_state_iso iso_swapar\n                       (fused_resource.fuse local.translate_core rest) s\n                       query", "by (simp add: apply_state_iso_def iso_swapar_def fused_resource.fuse.simps split_def map_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>s = (s_core, s_event, s_rest); query = Inl q_adv;\n        q_adv = Inr b\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core local.translate_rest s\n                          query =\n                         apply_state_iso iso_swapar\n                          (fused_resource.fuse local.translate_core rest) s\n                          query", "subgoal for q_arest"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s = (s_core, s_event, s_rest); query = Inl q_adv;\n     q_adv = Inr q_arest\\<rbrakk>\n    \\<Longrightarrow> fused_resource.fuse core local.translate_rest s\n                       query =\n                      apply_state_iso iso_swapar\n                       (fused_resource.fuse local.translate_core rest) s\n                       query", "apply (simp add: apply_state_iso_def iso_swapar_def fused_resource.fuse.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s = (s_core, s_event, s_rest); query = Inl (Inr q_arest);\n     q_adv = Inr q_arest\\<rbrakk>\n    \\<Longrightarrow> translate_eoracle etran \\<dagger>(rfunc_adv rest)\n                       (s_event, s_rest) q_arest \\<bind>\n                      (\\<lambda>((o_rfunc, e_lst), s_rfunc).\n                          foldl_spmf (cpoke core) (return_spmf s_core)\n                           e_lst \\<bind>\n                          (\\<lambda>s_notify.\n                              return_spmf\n                               (Inl (Inr o_rfunc), s_notify, s_rfunc))) =\n                      rfunc_adv rest s_rest q_arest \\<bind>\n                      (\\<lambda>x.\n                          map_spmf\n                           (map_prod id\n                             (\\<lambda>((sm, s1), s2). (s1, sm, s2)))\n                           (case x of\n                            (x, xa) \\<Rightarrow>\n                              (case x of\n                               (o_rfunc, e_lst) \\<Rightarrow>\n                                 \\<lambda>s_rfunc.\n                                    foldl_spmf\n                                     (\\<lambda>(s_event, s_core) event.\n   etran s_event event \\<bind>\n   (\\<lambda>(events, s_event').\n       map_spmf (Pair s_event')\n        (foldl_spmf (cpoke core) (return_spmf s_core) events)))\n                                     (return_spmf (s_event, s_core))\n                                     e_lst \\<bind>\n                                    (\\<lambda>s_notify.\n  return_spmf (Inl (Inr o_rfunc), s_notify, s_rfunc)))\n                               xa))", "apply (simp add: translate_eoracle_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s = (s_core, s_event, s_rest); query = Inl (Inr q_arest);\n     q_adv = Inr q_arest\\<rbrakk>\n    \\<Longrightarrow> rfunc_adv rest s_rest q_arest \\<bind>\n                      (\\<lambda>y.\n                          foldl_spmf\n                           (\\<lambda>p e.\n                               map_spmf (map_prod ((@) (fst p)) id)\n                                (etran (snd p) e))\n                           (return_spmf ([], s_event)) (snd (fst y)) \\<bind>\n                          (\\<lambda>ya.\n                              foldl_spmf (cpoke core) (return_spmf s_core)\n                               (fst ya) \\<bind>\n                              (\\<lambda>s_notify.\n                                  return_spmf\n                                   (Inl (Inr (fst (fst y))), s_notify,\n                                    snd ya, snd y)))) =\n                      rfunc_adv rest s_rest q_arest \\<bind>\n                      (\\<lambda>x.\n                          foldl_spmf\n                           (\\<lambda>p event.\n                               etran (fst p) event \\<bind>\n                               (\\<lambda>pa.\n                                   map_spmf (Pair (snd pa))\n                                    (foldl_spmf (cpoke core)\n(return_spmf (snd p)) (fst pa))))\n                           (return_spmf (s_event, s_core))\n                           (snd (fst x)) \\<bind>\n                          (\\<lambda>xa.\n                              return_spmf\n                               (Inl (Inr (fst (fst x))), snd xa, fst xa,\n                                snd x)))", "apply(rule bind_spmf_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>s = (s_core, s_event, s_rest); query = Inl (Inr q_arest);\n        q_adv = Inr q_arest;\n        x \\<in> set_spmf (rfunc_adv rest s_rest q_arest)\\<rbrakk>\n       \\<Longrightarrow> foldl_spmf\n                          (\\<lambda>p e.\n                              map_spmf (map_prod ((@) (fst p)) id)\n                               (etran (snd p) e))\n                          (return_spmf ([], s_event)) (snd (fst x)) \\<bind>\n                         (\\<lambda>y.\n                             foldl_spmf (cpoke core) (return_spmf s_core)\n                              (fst y) \\<bind>\n                             (\\<lambda>s_notify.\n                                 return_spmf\n                                  (Inl (Inr (fst (fst x))), s_notify, snd y,\n                                   snd x))) =\n                         foldl_spmf\n                          (\\<lambda>p event.\n                              etran (fst p) event \\<bind>\n                              (\\<lambda>pa.\n                                  map_spmf (Pair (snd pa))\n                                   (foldl_spmf (cpoke core)\n                                     (return_spmf (snd p)) (fst pa))))\n                          (return_spmf (s_event, s_core))\n                          (snd (fst x)) \\<bind>\n                         (\\<lambda>xa.\n                             return_spmf\n                              (Inl (Inr (fst (fst x))), snd xa, fst xa,\n                               snd x))", "apply(subst foldl_spmf_chain[simplified split_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>s = (s_core, s_event, s_rest); query = Inl (Inr q_arest);\n        q_adv = Inr q_arest;\n        x \\<in> set_spmf (rfunc_adv rest s_rest q_arest)\\<rbrakk>\n       \\<Longrightarrow> foldl_spmf\n                          (\\<lambda>p event.\n                              etran (fst p) event \\<bind>\n                              (\\<lambda>pa.\n                                  map_spmf (Pair (snd pa))\n                                   (foldl_spmf (cpoke core)\n                                     (return_spmf (snd p)) (fst pa))))\n                          (return_spmf (s_event, s_core))\n                          (snd (fst x)) \\<bind>\n                         (\\<lambda>p.\n                             return_spmf\n                              (Inl (Inr (fst (fst x))), snd p, fst p,\n                               snd x)) =\n                         foldl_spmf\n                          (\\<lambda>p event.\n                              etran (fst p) event \\<bind>\n                              (\\<lambda>pa.\n                                  map_spmf (Pair (snd pa))\n                                   (foldl_spmf (cpoke core)\n                                     (return_spmf (snd p)) (fst pa))))\n                          (return_spmf (s_event, s_core))\n                          (snd (fst x)) \\<bind>\n                         (\\<lambda>xa.\n                             return_spmf\n                              (Inl (Inr (fst (fst x))), snd xa, fst xa,\n                               snd x))", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>s = (s_core, s_event, s_rest); query = Inr b\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core local.translate_rest s\n                          query =\n                         apply_state_iso iso_swapar\n                          (fused_resource.fuse local.translate_core rest) s\n                          query", "subgoal for q_usr"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s = (s_core, s_event, s_rest); query = Inr q_usr\\<rbrakk>\n    \\<Longrightarrow> fused_resource.fuse core local.translate_rest s\n                       query =\n                      apply_state_iso iso_swapar\n                       (fused_resource.fuse local.translate_core rest) s\n                       query", "apply (cases q_usr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>s = (s_core, s_event, s_rest); query = Inr q_usr;\n        q_usr = Inl a\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core local.translate_rest s\n                          query =\n                         apply_state_iso iso_swapar\n                          (fused_resource.fuse local.translate_core rest) s\n                          query\n 2. \\<And>b.\n       \\<lbrakk>s = (s_core, s_event, s_rest); query = Inr q_usr;\n        q_usr = Inr b\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core local.translate_rest s\n                          query =\n                         apply_state_iso iso_swapar\n                          (fused_resource.fuse local.translate_core rest) s\n                          query", "subgoal for q_ucore"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s = (s_core, s_event, s_rest); query = Inr q_usr;\n     q_usr = Inl q_ucore\\<rbrakk>\n    \\<Longrightarrow> fused_resource.fuse core local.translate_rest s\n                       query =\n                      apply_state_iso iso_swapar\n                       (fused_resource.fuse local.translate_core rest) s\n                       query", "by (simp add: apply_state_iso_def iso_swapar_def fused_resource.fuse.simps split_def map_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>s = (s_core, s_event, s_rest); query = Inr q_usr;\n        q_usr = Inr b\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core local.translate_rest s\n                          query =\n                         apply_state_iso iso_swapar\n                          (fused_resource.fuse local.translate_core rest) s\n                          query", "subgoal for q_urest"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s = (s_core, s_event, s_rest); query = Inr q_usr;\n     q_usr = Inr q_urest\\<rbrakk>\n    \\<Longrightarrow> fused_resource.fuse core local.translate_rest s\n                       query =\n                      apply_state_iso iso_swapar\n                       (fused_resource.fuse local.translate_core rest) s\n                       query", "apply (simp add: apply_state_iso_def iso_swapar_def fused_resource.fuse.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s = (s_core, s_event, s_rest); query = Inr (Inr q_urest);\n     q_usr = Inr q_urest\\<rbrakk>\n    \\<Longrightarrow> translate_eoracle etran \\<dagger>(rfunc_usr rest)\n                       (s_event, s_rest) q_urest \\<bind>\n                      (\\<lambda>((o_rfunc, e_lst), s_rfunc).\n                          foldl_spmf (cpoke core) (return_spmf s_core)\n                           e_lst \\<bind>\n                          (\\<lambda>s_notify.\n                              return_spmf\n                               (Inr (Inr o_rfunc), s_notify, s_rfunc))) =\n                      rfunc_usr rest s_rest q_urest \\<bind>\n                      (\\<lambda>x.\n                          map_spmf\n                           (map_prod id\n                             (\\<lambda>((sm, s1), s2). (s1, sm, s2)))\n                           (case x of\n                            (x, xa) \\<Rightarrow>\n                              (case x of\n                               (o_rfunc, e_lst) \\<Rightarrow>\n                                 \\<lambda>s_rfunc.\n                                    foldl_spmf\n                                     (\\<lambda>(s_event, s_core) event.\n   etran s_event event \\<bind>\n   (\\<lambda>(events, s_event').\n       map_spmf (Pair s_event')\n        (foldl_spmf (cpoke core) (return_spmf s_core) events)))\n                                     (return_spmf (s_event, s_core))\n                                     e_lst \\<bind>\n                                    (\\<lambda>s_notify.\n  return_spmf (Inr (Inr o_rfunc), s_notify, s_rfunc)))\n                               xa))", "apply (simp add: translate_eoracle_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s = (s_core, s_event, s_rest); query = Inr (Inr q_urest);\n     q_usr = Inr q_urest\\<rbrakk>\n    \\<Longrightarrow> rfunc_usr rest s_rest q_urest \\<bind>\n                      (\\<lambda>y.\n                          foldl_spmf\n                           (\\<lambda>p e.\n                               map_spmf (map_prod ((@) (fst p)) id)\n                                (etran (snd p) e))\n                           (return_spmf ([], s_event)) (snd (fst y)) \\<bind>\n                          (\\<lambda>ya.\n                              foldl_spmf (cpoke core) (return_spmf s_core)\n                               (fst ya) \\<bind>\n                              (\\<lambda>s_notify.\n                                  return_spmf\n                                   (Inr (Inr (fst (fst y))), s_notify,\n                                    snd ya, snd y)))) =\n                      rfunc_usr rest s_rest q_urest \\<bind>\n                      (\\<lambda>x.\n                          foldl_spmf\n                           (\\<lambda>p event.\n                               etran (fst p) event \\<bind>\n                               (\\<lambda>pa.\n                                   map_spmf (Pair (snd pa))\n                                    (foldl_spmf (cpoke core)\n(return_spmf (snd p)) (fst pa))))\n                           (return_spmf (s_event, s_core))\n                           (snd (fst x)) \\<bind>\n                          (\\<lambda>xa.\n                              return_spmf\n                               (Inr (Inr (fst (fst x))), snd xa, fst xa,\n                                snd x)))", "apply(rule bind_spmf_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>s = (s_core, s_event, s_rest); query = Inr (Inr q_urest);\n        q_usr = Inr q_urest;\n        x \\<in> set_spmf (rfunc_usr rest s_rest q_urest)\\<rbrakk>\n       \\<Longrightarrow> foldl_spmf\n                          (\\<lambda>p e.\n                              map_spmf (map_prod ((@) (fst p)) id)\n                               (etran (snd p) e))\n                          (return_spmf ([], s_event)) (snd (fst x)) \\<bind>\n                         (\\<lambda>y.\n                             foldl_spmf (cpoke core) (return_spmf s_core)\n                              (fst y) \\<bind>\n                             (\\<lambda>s_notify.\n                                 return_spmf\n                                  (Inr (Inr (fst (fst x))), s_notify, snd y,\n                                   snd x))) =\n                         foldl_spmf\n                          (\\<lambda>p event.\n                              etran (fst p) event \\<bind>\n                              (\\<lambda>pa.\n                                  map_spmf (Pair (snd pa))\n                                   (foldl_spmf (cpoke core)\n                                     (return_spmf (snd p)) (fst pa))))\n                          (return_spmf (s_event, s_core))\n                          (snd (fst x)) \\<bind>\n                         (\\<lambda>xa.\n                             return_spmf\n                              (Inr (Inr (fst (fst x))), snd xa, fst xa,\n                               snd x))", "apply(subst foldl_spmf_chain[simplified split_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>s = (s_core, s_event, s_rest); query = Inr (Inr q_urest);\n        q_usr = Inr q_urest;\n        x \\<in> set_spmf (rfunc_usr rest s_rest q_urest)\\<rbrakk>\n       \\<Longrightarrow> foldl_spmf\n                          (\\<lambda>p event.\n                              etran (fst p) event \\<bind>\n                              (\\<lambda>pa.\n                                  map_spmf (Pair (snd pa))\n                                   (foldl_spmf (cpoke core)\n                                     (return_spmf (snd p)) (fst pa))))\n                          (return_spmf (s_event, s_core))\n                          (snd (fst x)) \\<bind>\n                         (\\<lambda>p.\n                             return_spmf\n                              (Inr (Inr (fst (fst x))), snd p, fst p,\n                               snd x)) =\n                         foldl_spmf\n                          (\\<lambda>p event.\n                              etran (fst p) event \\<bind>\n                              (\\<lambda>pa.\n                                  map_spmf (Pair (snd pa))\n                                   (foldl_spmf (cpoke core)\n                                     (return_spmf (snd p)) (fst pa))))\n                          (return_spmf (s_event, s_core))\n                          (snd (fst x)) \\<bind>\n                         (\\<lambda>xa.\n                             return_spmf\n                              (Inr (Inr (fst (fst x))), snd xa, fst xa,\n                               snd x))", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fused_resource.fuse core local.translate_rest =\n  apply_state_iso iso_swapar (fused_resource.fuse local.translate_core rest)\n\ngoal:\nNo subgoals!", "qed"], ["", "end\n\n\n\\<comment> \\<open>Moving interfaces between rest and core\\<close>"], ["", "lemma\n  fuse_ishift_core_to_rest:\n  assumes \"cpoke core' = (\\<lambda>s. case_sum (\\<lambda>q. fn s q) (cpoke core s))\"\n      and \"cfunc_adv core = cfunc_adv core'\"\n      and \"cfunc_usr core = cfunc_usr core' \\<oplus>\\<^sub>O (\\<lambda>s i. map_spmf (Pair (h_out i)) (fn s i))\"\n      and \"rfunc_adv rest' = (\\<lambda>s q. map_spmf (apfst (apsnd (map Inr))) (rfunc_adv rest s q))\"\n      and \"rfunc_usr rest' = plus_eoracle (\\<lambda>s i. return_spmf ((h_out i, [i]), s)) (rfunc_usr rest)\"\n    shows \"fused_resource.fuse core rest = apply_wiring (1\\<^sub>w |\\<^sub>w lassocr\\<^sub>w) (fused_resource.fuse core' rest')\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. fused_resource.fuse core rest =\n    apply_wiring ((id, id) |\\<^sub>w lassocr\\<^sub>w)\n     (fused_resource.fuse core' rest')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fused_resource.fuse core rest =\n    apply_wiring ((id, id) |\\<^sub>w lassocr\\<^sub>w)\n     (fused_resource.fuse core' rest')", "note [simp] = fused_resource.fuse.simps apply_wiring_def lassocr\\<^sub>w_def parallel2_wiring_def \n    plus_eoracle_def map_spmf_conv_bind_spmf map_prod_def map_fun_def split_def o_def"], ["proof (state)\nthis:\n  fused_resource.fuse ?core ?rest ?state (Inl (Inl ?iadv_core)) =\n  (let handle =\n         map_prod (Inl \\<circ> Inl) (prod.swap \\<circ> Pair (snd ?state))\n   in cfunc_adv ?core (fst ?state) ?iadv_core \\<bind>\n      (\\<lambda>os_cfunc. return_spmf (handle os_cfunc)))\n  fused_resource.fuse ?core ?rest ?state (Inl (Inr ?iadv_rest)) =\n  rfunc_adv ?rest (snd ?state) ?iadv_rest \\<bind>\n  (\\<lambda>((o_rfunc, e_lst), s_rfunc).\n      foldl_spmf (cpoke ?core) (return_spmf (fst ?state)) e_lst \\<bind>\n      (\\<lambda>s_notify.\n          return_spmf ((Inl \\<circ> Inr) o_rfunc, s_notify, s_rfunc)))\n  fused_resource.fuse ?core ?rest ?state (Inr (Inl ?iusr_core)) =\n  (let handle =\n         map_prod (Inr \\<circ> Inl) (prod.swap \\<circ> Pair (snd ?state))\n   in cfunc_usr ?core (fst ?state) ?iusr_core \\<bind>\n      (\\<lambda>os_cfunc. return_spmf (handle os_cfunc)))\n  fused_resource.fuse ?core ?rest ?state (Inr (Inr ?iusr_rest)) =\n  rfunc_usr ?rest (snd ?state) ?iusr_rest \\<bind>\n  (\\<lambda>((o_rfunc, e_lst), s_rfunc).\n      foldl_spmf (cpoke ?core) (return_spmf (fst ?state)) e_lst \\<bind>\n      (\\<lambda>s_notify.\n          return_spmf ((Inr \\<circ> Inr) o_rfunc, s_notify, s_rfunc)))\n  apply_wiring =\n  (\\<lambda>(f, g). map_fun id (map_fun f (map_spmf (map_prod g id))))\n  lassocr\\<^sub>w = (rsuml, lsumr)\n  (|\\<^sub>w) = (\\<lambda>(f, g) (f', g'). (map_sum f f', map_sum g g'))\n  plus_eoracle ?eoracle1.0 ?eoracle2.0 ?state \\<equiv>\n  map_spmf\n   (map_prod (case_sum (map_prod Inl (map Inl)) (map_prod Inr (map Inr)))\n     id) \\<circ>\n  (?eoracle1.0 \\<oplus>\\<^sub>O ?eoracle2.0) ?state\n  map_spmf ?f ?p = ?p \\<bind> (\\<lambda>x. return_spmf (?f x))\n  map_prod ?f ?g = (\\<lambda>(x, y). (?f x, ?g y))\n  map_fun ?f ?g ?h = ?g \\<circ> ?h \\<circ> ?f\n  case_prod = (\\<lambda>c p. c (fst p) (snd p))\n  ?f \\<circ> ?g = (\\<lambda>x. ?f (?g x))\n\ngoal (1 subgoal):\n 1. fused_resource.fuse core rest =\n    apply_wiring ((id, id) |\\<^sub>w lassocr\\<^sub>w)\n     (fused_resource.fuse core' rest')", "have \"?L s q = ?R s q\" for s q"], ["proof (prove)\ngoal (1 subgoal):\n 1. fused_resource.fuse core rest s q =\n    apply_wiring ((id, id) |\\<^sub>w lassocr\\<^sub>w)\n     (fused_resource.fuse core' rest') s q", "apply (cases q; cases s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa b.\n       \\<lbrakk>q = Inl a; s = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core rest s q =\n                         apply_wiring ((id, id) |\\<^sub>w lassocr\\<^sub>w)\n                          (fused_resource.fuse core' rest') s q\n 2. \\<And>b a ba.\n       \\<lbrakk>q = Inr b; s = (a, ba)\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core rest s q =\n                         apply_wiring ((id, id) |\\<^sub>w lassocr\\<^sub>w)\n                          (fused_resource.fuse core' rest') s q", "subgoal for q_adv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q = Inl q_adv; s = (aa_, b_)\\<rbrakk>\n    \\<Longrightarrow> fused_resource.fuse core rest s q =\n                      apply_wiring ((id, id) |\\<^sub>w lassocr\\<^sub>w)\n                       (fused_resource.fuse core' rest') s q", "by (cases q_adv) (simp_all add: assms(1, 2, 4))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b a ba.\n       \\<lbrakk>q = Inr b; s = (a, ba)\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core rest s q =\n                         apply_wiring ((id, id) |\\<^sub>w lassocr\\<^sub>w)\n                          (fused_resource.fuse core' rest') s q", "subgoal for q_usr"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q = Inr q_usr; s = (a_, ba_)\\<rbrakk>\n    \\<Longrightarrow> fused_resource.fuse core rest s q =\n                      apply_wiring ((id, id) |\\<^sub>w lassocr\\<^sub>w)\n                       (fused_resource.fuse core' rest') s q", "apply (cases q_usr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>q = Inr q_usr; s = (a_, ba_); q_usr = Inl aa\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core rest s q =\n                         apply_wiring ((id, id) |\\<^sub>w lassocr\\<^sub>w)\n                          (fused_resource.fuse core' rest') s q\n 2. \\<And>b.\n       \\<lbrakk>q = Inr q_usr; s = (a_, ba_); q_usr = Inr b\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core rest s q =\n                         apply_wiring ((id, id) |\\<^sub>w lassocr\\<^sub>w)\n                          (fused_resource.fuse core' rest') s q", "subgoal for q_usr_core"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q = Inr q_usr; s = (a_, ba_); q_usr = Inl q_usr_core\\<rbrakk>\n    \\<Longrightarrow> fused_resource.fuse core rest s q =\n                      apply_wiring ((id, id) |\\<^sub>w lassocr\\<^sub>w)\n                       (fused_resource.fuse core' rest') s q", "apply (cases q_usr_core)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>q = Inr q_usr; s = (a_, ba_); q_usr = Inl q_usr_core;\n        q_usr_core = Inl aa\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core rest s q =\n                         apply_wiring ((id, id) |\\<^sub>w lassocr\\<^sub>w)\n                          (fused_resource.fuse core' rest') s q\n 2. \\<And>b.\n       \\<lbrakk>q = Inr q_usr; s = (a_, ba_); q_usr = Inl q_usr_core;\n        q_usr_core = Inr b\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core rest s q =\n                         apply_wiring ((id, id) |\\<^sub>w lassocr\\<^sub>w)\n                          (fused_resource.fuse core' rest') s q", "subgoal for q_nrm"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q = Inr q_usr; s = (a_, ba_); q_usr = Inl q_usr_core;\n     q_usr_core = Inl q_nrm\\<rbrakk>\n    \\<Longrightarrow> fused_resource.fuse core rest s q =\n                      apply_wiring ((id, id) |\\<^sub>w lassocr\\<^sub>w)\n                       (fused_resource.fuse core' rest') s q", "by (simp add: assms(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>q = Inr q_usr; s = (a_, ba_); q_usr = Inl q_usr_core;\n        q_usr_core = Inr b\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core rest s q =\n                         apply_wiring ((id, id) |\\<^sub>w lassocr\\<^sub>w)\n                          (fused_resource.fuse core' rest') s q", "by (simp add: assms(1, 3, 5))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>q = Inr q_usr; s = (a_, ba_); q_usr = Inr b\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core rest s q =\n                         apply_wiring ((id, id) |\\<^sub>w lassocr\\<^sub>w)\n                          (fused_resource.fuse core' rest') s q", "by (simp add: assms(1, 5))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fused_resource.fuse core rest ?s ?q =\n  apply_wiring ((id, id) |\\<^sub>w lassocr\\<^sub>w)\n   (fused_resource.fuse core' rest') ?s ?q\n\ngoal (1 subgoal):\n 1. fused_resource.fuse core rest =\n    apply_wiring ((id, id) |\\<^sub>w lassocr\\<^sub>w)\n     (fused_resource.fuse core' rest')", "then"], ["proof (chain)\npicking this:\n  fused_resource.fuse core rest ?s ?q =\n  apply_wiring ((id, id) |\\<^sub>w lassocr\\<^sub>w)\n   (fused_resource.fuse core' rest') ?s ?q", "show ?thesis"], ["proof (prove)\nusing this:\n  fused_resource.fuse core rest ?s ?q =\n  apply_wiring ((id, id) |\\<^sub>w lassocr\\<^sub>w)\n   (fused_resource.fuse core' rest') ?s ?q\n\ngoal (1 subgoal):\n 1. fused_resource.fuse core rest =\n    apply_wiring ((id, id) |\\<^sub>w lassocr\\<^sub>w)\n     (fused_resource.fuse core' rest')", "by blast"], ["proof (state)\nthis:\n  fused_resource.fuse core rest =\n  apply_wiring ((id, id) |\\<^sub>w lassocr\\<^sub>w)\n   (fused_resource.fuse core' rest')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma move_simulator_interface:\n  defines \"x_ifunc \\<equiv> (\\<lambda>ifunc core (se, sc) q. do {\n      ((out, es), se') \\<leftarrow> ifunc se q;\n      sc' \\<leftarrow> foldl_spmf (cpoke core) (return_spmf sc) es;\n      return_spmf (out, se', sc')   })\"\n  assumes \"cpoke core' = cpoke (translate_core etran core)\"\n      and \"cfunc_adv core' = \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O x_ifunc ifunc core\"\n      and \"cfunc_usr core' = cfunc_usr (translate_core etran core)\"\n      and \"rinit rest = (einit, rinit rest')\"\n      and \"rfunc_adv rest = (\\<lambda>s q. case q of \n        Inl ql \\<Rightarrow> map_spmf (apfst (map_prod Inl id)) ((ifunc\\<dagger>) s ql)\n      | Inr qr \\<Rightarrow> map_spmf (apfst (map_prod Inr id)) ((translate_eoracle etran (\\<dagger>(rfunc_adv rest'))) s qr))\"\n      and \"rfunc_usr rest = translate_eoracle etran (\\<dagger>(rfunc_usr rest'))\"\n  shows \"fused_resource.fuse core rest =  apply_wiring (rassocl\\<^sub>w |\\<^sub>w (id, id))\n       (apply_state_iso (rprodl o (apfst prod.swap), (apfst prod.swap) o lprodr)\n         (fused_resource.fuse core' rest'))\"\n    (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. fused_resource.fuse core rest =\n    apply_wiring (rassocl\\<^sub>w |\\<^sub>w (id, id))\n     (apply_state_iso\n       (rprodl \\<circ> apfst prod.swap, apfst prod.swap \\<circ> lprodr)\n       (fused_resource.fuse core' rest'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fused_resource.fuse core rest =\n    apply_wiring (rassocl\\<^sub>w |\\<^sub>w (id, id))\n     (apply_state_iso\n       (rprodl \\<circ> apfst prod.swap, apfst prod.swap \\<circ> lprodr)\n       (fused_resource.fuse core' rest'))", "note [simp] = fused_resource.fuse.simps apply_wiring_def rassocl\\<^sub>w_def parallel2_wiring_def apply_state_iso_def\n    exec_gpv_bind spmf.map_comp map_bind_spmf bind_map_spmf bind_spmf_const o_def split_def"], ["proof (state)\nthis:\n  fused_resource.fuse ?core ?rest ?state (Inl (Inl ?iadv_core)) =\n  (let handle =\n         map_prod (Inl \\<circ> Inl) (prod.swap \\<circ> Pair (snd ?state))\n   in cfunc_adv ?core (fst ?state) ?iadv_core \\<bind>\n      (\\<lambda>os_cfunc. return_spmf (handle os_cfunc)))\n  fused_resource.fuse ?core ?rest ?state (Inl (Inr ?iadv_rest)) =\n  rfunc_adv ?rest (snd ?state) ?iadv_rest \\<bind>\n  (\\<lambda>((o_rfunc, e_lst), s_rfunc).\n      foldl_spmf (cpoke ?core) (return_spmf (fst ?state)) e_lst \\<bind>\n      (\\<lambda>s_notify.\n          return_spmf ((Inl \\<circ> Inr) o_rfunc, s_notify, s_rfunc)))\n  fused_resource.fuse ?core ?rest ?state (Inr (Inl ?iusr_core)) =\n  (let handle =\n         map_prod (Inr \\<circ> Inl) (prod.swap \\<circ> Pair (snd ?state))\n   in cfunc_usr ?core (fst ?state) ?iusr_core \\<bind>\n      (\\<lambda>os_cfunc. return_spmf (handle os_cfunc)))\n  fused_resource.fuse ?core ?rest ?state (Inr (Inr ?iusr_rest)) =\n  rfunc_usr ?rest (snd ?state) ?iusr_rest \\<bind>\n  (\\<lambda>((o_rfunc, e_lst), s_rfunc).\n      foldl_spmf (cpoke ?core) (return_spmf (fst ?state)) e_lst \\<bind>\n      (\\<lambda>s_notify.\n          return_spmf ((Inr \\<circ> Inr) o_rfunc, s_notify, s_rfunc)))\n  apply_wiring =\n  (\\<lambda>(f, g). map_fun id (map_fun f (map_spmf (map_prod g id))))\n  rassocl\\<^sub>w = (lsumr, rsuml)\n  (|\\<^sub>w) = (\\<lambda>(f, g) (f', g'). (map_sum f f', map_sum g g'))\n  apply_state_iso \\<equiv>\n  \\<lambda>(f, g). map_fun g (map_fun id (map_spmf (map_prod id f)))\n  exec_gpv ?callee (?c \\<bind> ?f) ?s =\n  exec_gpv ?callee ?c ?s \\<bind>\n  (\\<lambda>xa. case xa of (x, s') \\<Rightarrow> exec_gpv ?callee (?f x) s')\n  map_spmf ?f (map_spmf ?g ?p) = map_spmf (?f \\<circ> ?g) ?p\n  map_spmf ?f (?p \\<bind> ?g) = ?p \\<bind> map_spmf ?f \\<circ> ?g\n  map_spmf ?f ?p \\<bind> ?g = ?p \\<bind> ?g \\<circ> ?f\n  ?p \\<bind> (\\<lambda>x. ?q) = scale_spmf (weight_spmf ?p) ?q\n  ?f \\<circ> ?g = (\\<lambda>x. ?f (?g x))\n  case_prod = (\\<lambda>c p. c (fst p) (snd p))\n\ngoal (1 subgoal):\n 1. fused_resource.fuse core rest =\n    apply_wiring (rassocl\\<^sub>w |\\<^sub>w (id, id))\n     (apply_state_iso\n       (rprodl \\<circ> apfst prod.swap, apfst prod.swap \\<circ> lprodr)\n       (fused_resource.fuse core' rest'))", "have \"?L (sc, st, sr) q = ?R (sc, st, sr) q\" for sc st sr q"], ["proof (prove)\ngoal (1 subgoal):\n 1. fused_resource.fuse core rest (sc, st, sr) q =\n    apply_wiring (rassocl\\<^sub>w |\\<^sub>w (id, id))\n     (apply_state_iso\n       (rprodl \\<circ> apfst prod.swap, apfst prod.swap \\<circ> lprodr)\n       (fused_resource.fuse core' rest'))\n     (sc, st, sr) q", "apply (simp add: map_fun_def map_prod_def prod.swap_def apfst_def lprodr_def rprodl_def id_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fused_resource.fuse core rest (sc, st, sr) q =\n    map_spmf\n     (\\<lambda>x.\n         (map_sum rsuml (\\<lambda>x. x) (fst x), snd (fst (snd x)),\n          fst (fst (snd x)), snd (snd x)))\n     (fused_resource.fuse core' rest' ((st, sc), sr)\n       (map_sum lsumr (\\<lambda>x. x) q))", "using assms"], ["proof (prove)\nusing this:\n  x_ifunc \\<equiv>\n  \\<lambda>ifunc core (se, sc) q.\n     ifunc se q \\<bind>\n     (\\<lambda>((out, es), se').\n         foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n         (\\<lambda>sc'. return_spmf (out, se', sc')))\n  cpoke core' = cpoke (translate_core etran core)\n  cfunc_adv core' =\n  \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O x_ifunc ifunc core\n  cfunc_usr core' = cfunc_usr (translate_core etran core)\n  rinit rest = (einit, rinit rest')\n  rfunc_adv rest =\n  (\\<lambda>s q.\n      case q of\n      Inl ql \\<Rightarrow>\n        map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n      | Inr qr \\<Rightarrow>\n          map_spmf (apfst (map_prod Inr id))\n           (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr))\n  rfunc_usr rest = translate_eoracle etran \\<dagger>(rfunc_usr rest')\n\ngoal (1 subgoal):\n 1. fused_resource.fuse core rest (sc, st, sr) q =\n    map_spmf\n     (\\<lambda>x.\n         (map_sum rsuml (\\<lambda>x. x) (fst x), snd (fst (snd x)),\n          fst (fst (snd x)), snd (snd x)))\n     (fused_resource.fuse core' rest' ((st, sc), sr)\n       (map_sum lsumr (\\<lambda>x. x) q))", "apply (cases q)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>x_ifunc \\<equiv>\n                \\<lambda>ifunc core (se, sc) q.\n                   ifunc se q \\<bind>\n                   (\\<lambda>((out, es), se').\n                       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n                       (\\<lambda>sc'. return_spmf (out, se', sc')));\n        cpoke core' = cpoke (translate_core etran core);\n        cfunc_adv core' =\n        \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O x_ifunc ifunc core;\n        cfunc_usr core' = cfunc_usr (translate_core etran core);\n        rinit rest = (einit, rinit rest');\n        rfunc_adv rest =\n        (\\<lambda>s q.\n            case q of\n            Inl ql \\<Rightarrow>\n              map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n            | Inr qr \\<Rightarrow>\n                map_spmf (apfst (map_prod Inr id))\n                 (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n        rfunc_usr rest = translate_eoracle etran \\<dagger>(rfunc_usr rest');\n        q = Inl a\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core rest (sc, st, sr) q =\n                         map_spmf\n                          (\\<lambda>x.\n                              (map_sum rsuml (\\<lambda>x. x) (fst x),\n                               snd (fst (snd x)), fst (fst (snd x)),\n                               snd (snd x)))\n                          (fused_resource.fuse core' rest' ((st, sc), sr)\n                            (map_sum lsumr (\\<lambda>x. x) q))\n 2. \\<And>b.\n       \\<lbrakk>x_ifunc \\<equiv>\n                \\<lambda>ifunc core (se, sc) q.\n                   ifunc se q \\<bind>\n                   (\\<lambda>((out, es), se').\n                       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n                       (\\<lambda>sc'. return_spmf (out, se', sc')));\n        cpoke core' = cpoke (translate_core etran core);\n        cfunc_adv core' =\n        \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O x_ifunc ifunc core;\n        cfunc_usr core' = cfunc_usr (translate_core etran core);\n        rinit rest = (einit, rinit rest');\n        rfunc_adv rest =\n        (\\<lambda>s q.\n            case q of\n            Inl ql \\<Rightarrow>\n              map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n            | Inr qr \\<Rightarrow>\n                map_spmf (apfst (map_prod Inr id))\n                 (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n        rfunc_usr rest = translate_eoracle etran \\<dagger>(rfunc_usr rest');\n        q = Inr b\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core rest (sc, st, sr) q =\n                         map_spmf\n                          (\\<lambda>x.\n                              (map_sum rsuml (\\<lambda>x. x) (fst x),\n                               snd (fst (snd x)), fst (fst (snd x)),\n                               snd (snd x)))\n                          (fused_resource.fuse core' rest' ((st, sc), sr)\n                            (map_sum lsumr (\\<lambda>x. x) q))", "subgoal for q_adv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ifunc \\<equiv>\n             \\<lambda>ifunc core (se, sc) q.\n                ifunc se q \\<bind>\n                (\\<lambda>((out, es), se').\n                    foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n                    (\\<lambda>sc'. return_spmf (out, se', sc')));\n     cpoke core' = cpoke (translate_core etran core);\n     cfunc_adv core' =\n     \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O x_ifunc ifunc core;\n     cfunc_usr core' = cfunc_usr (translate_core etran core);\n     rinit rest = (einit, rinit rest');\n     rfunc_adv rest =\n     (\\<lambda>s q.\n         case q of\n         Inl ql \\<Rightarrow>\n           map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n         | Inr qr \\<Rightarrow>\n             map_spmf (apfst (map_prod Inr id))\n              (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n     rfunc_usr rest = translate_eoracle etran \\<dagger>(rfunc_usr rest');\n     q = Inl q_adv\\<rbrakk>\n    \\<Longrightarrow> fused_resource.fuse core rest (sc, st, sr) q =\n                      map_spmf\n                       (\\<lambda>x.\n                           (map_sum rsuml (\\<lambda>x. x) (fst x),\n                            snd (fst (snd x)), fst (fst (snd x)),\n                            snd (snd x)))\n                       (fused_resource.fuse core' rest' ((st, sc), sr)\n                         (map_sum lsumr (\\<lambda>x. x) q))", "apply (cases q_adv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>x_ifunc \\<equiv>\n                \\<lambda>ifunc core (se, sc) q.\n                   ifunc se q \\<bind>\n                   (\\<lambda>((out, es), se').\n                       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n                       (\\<lambda>sc'. return_spmf (out, se', sc')));\n        cpoke core' = cpoke (translate_core etran core);\n        cfunc_adv core' =\n        \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O x_ifunc ifunc core;\n        cfunc_usr core' = cfunc_usr (translate_core etran core);\n        rinit rest = (einit, rinit rest');\n        rfunc_adv rest =\n        (\\<lambda>s q.\n            case q of\n            Inl ql \\<Rightarrow>\n              map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n            | Inr qr \\<Rightarrow>\n                map_spmf (apfst (map_prod Inr id))\n                 (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n        rfunc_usr rest = translate_eoracle etran \\<dagger>(rfunc_usr rest');\n        q = Inl q_adv; q_adv = Inl a\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core rest (sc, st, sr) q =\n                         map_spmf\n                          (\\<lambda>x.\n                              (map_sum rsuml (\\<lambda>x. x) (fst x),\n                               snd (fst (snd x)), fst (fst (snd x)),\n                               snd (snd x)))\n                          (fused_resource.fuse core' rest' ((st, sc), sr)\n                            (map_sum lsumr (\\<lambda>x. x) q))\n 2. \\<And>b.\n       \\<lbrakk>x_ifunc \\<equiv>\n                \\<lambda>ifunc core (se, sc) q.\n                   ifunc se q \\<bind>\n                   (\\<lambda>((out, es), se').\n                       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n                       (\\<lambda>sc'. return_spmf (out, se', sc')));\n        cpoke core' = cpoke (translate_core etran core);\n        cfunc_adv core' =\n        \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O x_ifunc ifunc core;\n        cfunc_usr core' = cfunc_usr (translate_core etran core);\n        rinit rest = (einit, rinit rest');\n        rfunc_adv rest =\n        (\\<lambda>s q.\n            case q of\n            Inl ql \\<Rightarrow>\n              map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n            | Inr qr \\<Rightarrow>\n                map_spmf (apfst (map_prod Inr id))\n                 (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n        rfunc_usr rest = translate_eoracle etran \\<dagger>(rfunc_usr rest');\n        q = Inl q_adv; q_adv = Inr b\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core rest (sc, st, sr) q =\n                         map_spmf\n                          (\\<lambda>x.\n                              (map_sum rsuml (\\<lambda>x. x) (fst x),\n                               snd (fst (snd x)), fst (fst (snd x)),\n                               snd (snd x)))\n                          (fused_resource.fuse core' rest' ((st, sc), sr)\n                            (map_sum lsumr (\\<lambda>x. x) q))", "subgoal for q_adv_core"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ifunc \\<equiv>\n             \\<lambda>ifunc core (se, sc) q.\n                ifunc se q \\<bind>\n                (\\<lambda>((out, es), se').\n                    foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n                    (\\<lambda>sc'. return_spmf (out, se', sc')));\n     cpoke core' = cpoke (translate_core etran core);\n     cfunc_adv core' =\n     \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O x_ifunc ifunc core;\n     cfunc_usr core' = cfunc_usr (translate_core etran core);\n     rinit rest = (einit, rinit rest');\n     rfunc_adv rest =\n     (\\<lambda>s q.\n         case q of\n         Inl ql \\<Rightarrow>\n           map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n         | Inr qr \\<Rightarrow>\n             map_spmf (apfst (map_prod Inr id))\n              (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n     rfunc_usr rest = translate_eoracle etran \\<dagger>(rfunc_usr rest');\n     q = Inl q_adv; q_adv = Inl q_adv_core\\<rbrakk>\n    \\<Longrightarrow> fused_resource.fuse core rest (sc, st, sr) q =\n                      map_spmf\n                       (\\<lambda>x.\n                           (map_sum rsuml (\\<lambda>x. x) (fst x),\n                            snd (fst (snd x)), fst (fst (snd x)),\n                            snd (snd x)))\n                       (fused_resource.fuse core' rest' ((st, sc), sr)\n                         (map_sum lsumr (\\<lambda>x. x) q))", "by (simp add: map_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>x_ifunc \\<equiv>\n                \\<lambda>ifunc core (se, sc) q.\n                   ifunc se q \\<bind>\n                   (\\<lambda>((out, es), se').\n                       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n                       (\\<lambda>sc'. return_spmf (out, se', sc')));\n        cpoke core' = cpoke (translate_core etran core);\n        cfunc_adv core' =\n        \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O x_ifunc ifunc core;\n        cfunc_usr core' = cfunc_usr (translate_core etran core);\n        rinit rest = (einit, rinit rest');\n        rfunc_adv rest =\n        (\\<lambda>s q.\n            case q of\n            Inl ql \\<Rightarrow>\n              map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n            | Inr qr \\<Rightarrow>\n                map_spmf (apfst (map_prod Inr id))\n                 (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n        rfunc_usr rest = translate_eoracle etran \\<dagger>(rfunc_usr rest');\n        q = Inl q_adv; q_adv = Inr b\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core rest (sc, st, sr) q =\n                         map_spmf\n                          (\\<lambda>x.\n                              (map_sum rsuml (\\<lambda>x. x) (fst x),\n                               snd (fst (snd x)), fst (fst (snd x)),\n                               snd (snd x)))\n                          (fused_resource.fuse core' rest' ((st, sc), sr)\n                            (map_sum lsumr (\\<lambda>x. x) q))", "subgoal for q_adv_rest"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ifunc \\<equiv>\n             \\<lambda>ifunc core (se, sc) q.\n                ifunc se q \\<bind>\n                (\\<lambda>((out, es), se').\n                    foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n                    (\\<lambda>sc'. return_spmf (out, se', sc')));\n     cpoke core' = cpoke (translate_core etran core);\n     cfunc_adv core' =\n     \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O x_ifunc ifunc core;\n     cfunc_usr core' = cfunc_usr (translate_core etran core);\n     rinit rest = (einit, rinit rest');\n     rfunc_adv rest =\n     (\\<lambda>s q.\n         case q of\n         Inl ql \\<Rightarrow>\n           map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n         | Inr qr \\<Rightarrow>\n             map_spmf (apfst (map_prod Inr id))\n              (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n     rfunc_usr rest = translate_eoracle etran \\<dagger>(rfunc_usr rest');\n     q = Inl q_adv; q_adv = Inr q_adv_rest\\<rbrakk>\n    \\<Longrightarrow> fused_resource.fuse core rest (sc, st, sr) q =\n                      map_spmf\n                       (\\<lambda>x.\n                           (map_sum rsuml (\\<lambda>x. x) (fst x),\n                            snd (fst (snd x)), fst (fst (snd x)),\n                            snd (snd x)))\n                       (fused_resource.fuse core' rest' ((st, sc), sr)\n                         (map_sum lsumr (\\<lambda>x. x) q))", "apply (cases q_adv_rest)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>x_ifunc \\<equiv>\n                \\<lambda>ifunc core (se, sc) q.\n                   ifunc se q \\<bind>\n                   (\\<lambda>((out, es), se').\n                       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n                       (\\<lambda>sc'. return_spmf (out, se', sc')));\n        cpoke core' = cpoke (translate_core etran core);\n        cfunc_adv core' =\n        \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O x_ifunc ifunc core;\n        cfunc_usr core' = cfunc_usr (translate_core etran core);\n        rinit rest = (einit, rinit rest');\n        rfunc_adv rest =\n        (\\<lambda>s q.\n            case q of\n            Inl ql \\<Rightarrow>\n              map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n            | Inr qr \\<Rightarrow>\n                map_spmf (apfst (map_prod Inr id))\n                 (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n        rfunc_usr rest = translate_eoracle etran \\<dagger>(rfunc_usr rest');\n        q = Inl q_adv; q_adv = Inr q_adv_rest; q_adv_rest = Inl a\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core rest (sc, st, sr) q =\n                         map_spmf\n                          (\\<lambda>x.\n                              (map_sum rsuml (\\<lambda>x. x) (fst x),\n                               snd (fst (snd x)), fst (fst (snd x)),\n                               snd (snd x)))\n                          (fused_resource.fuse core' rest' ((st, sc), sr)\n                            (map_sum lsumr (\\<lambda>x. x) q))\n 2. \\<And>b.\n       \\<lbrakk>x_ifunc \\<equiv>\n                \\<lambda>ifunc core (se, sc) q.\n                   ifunc se q \\<bind>\n                   (\\<lambda>((out, es), se').\n                       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n                       (\\<lambda>sc'. return_spmf (out, se', sc')));\n        cpoke core' = cpoke (translate_core etran core);\n        cfunc_adv core' =\n        \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O x_ifunc ifunc core;\n        cfunc_usr core' = cfunc_usr (translate_core etran core);\n        rinit rest = (einit, rinit rest');\n        rfunc_adv rest =\n        (\\<lambda>s q.\n            case q of\n            Inl ql \\<Rightarrow>\n              map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n            | Inr qr \\<Rightarrow>\n                map_spmf (apfst (map_prod Inr id))\n                 (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n        rfunc_usr rest = translate_eoracle etran \\<dagger>(rfunc_usr rest');\n        q = Inl q_adv; q_adv = Inr q_adv_rest; q_adv_rest = Inr b\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core rest (sc, st, sr) q =\n                         map_spmf\n                          (\\<lambda>x.\n                              (map_sum rsuml (\\<lambda>x. x) (fst x),\n                               snd (fst (snd x)), fst (fst (snd x)),\n                               snd (snd x)))\n                          (fused_resource.fuse core' rest' ((st, sc), sr)\n                            (map_sum lsumr (\\<lambda>x. x) q))", "subgoal for q_adv_rest_ifunc"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ifunc \\<equiv>\n             \\<lambda>ifunc core (se, sc) q.\n                ifunc se q \\<bind>\n                (\\<lambda>((out, es), se').\n                    foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n                    (\\<lambda>sc'. return_spmf (out, se', sc')));\n     cpoke core' = cpoke (translate_core etran core);\n     cfunc_adv core' =\n     \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O x_ifunc ifunc core;\n     cfunc_usr core' = cfunc_usr (translate_core etran core);\n     rinit rest = (einit, rinit rest');\n     rfunc_adv rest =\n     (\\<lambda>s q.\n         case q of\n         Inl ql \\<Rightarrow>\n           map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n         | Inr qr \\<Rightarrow>\n             map_spmf (apfst (map_prod Inr id))\n              (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n     rfunc_usr rest = translate_eoracle etran \\<dagger>(rfunc_usr rest');\n     q = Inl q_adv; q_adv = Inr q_adv_rest;\n     q_adv_rest = Inl q_adv_rest_ifunc\\<rbrakk>\n    \\<Longrightarrow> fused_resource.fuse core rest (sc, st, sr) q =\n                      map_spmf\n                       (\\<lambda>x.\n                           (map_sum rsuml (\\<lambda>x. x) (fst x),\n                            snd (fst (snd x)), fst (fst (snd x)),\n                            snd (snd x)))\n                       (fused_resource.fuse core' rest' ((st, sc), sr)\n                         (map_sum lsumr (\\<lambda>x. x) q))", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>x_ifunc \\<equiv>\n                \\<lambda>ifunc core (se, sc) q.\n                   ifunc se q \\<bind>\n                   (\\<lambda>((out, es), se').\n                       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n                       (\\<lambda>sc'. return_spmf (out, se', sc')));\n        cpoke core' = cpoke (translate_core etran core);\n        cfunc_adv core' =\n        \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O x_ifunc ifunc core;\n        cfunc_usr core' = cfunc_usr (translate_core etran core);\n        rinit rest = (einit, rinit rest');\n        rfunc_adv rest =\n        (\\<lambda>s q.\n            case q of\n            Inl ql \\<Rightarrow>\n              map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n            | Inr qr \\<Rightarrow>\n                map_spmf (apfst (map_prod Inr id))\n                 (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n        rfunc_usr rest = translate_eoracle etran \\<dagger>(rfunc_usr rest');\n        q = Inl q_adv; q_adv = Inr q_adv_rest; q_adv_rest = Inr b\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core rest (sc, st, sr) q =\n                         map_spmf\n                          (\\<lambda>x.\n                              (map_sum rsuml (\\<lambda>x. x) (fst x),\n                               snd (fst (snd x)), fst (fst (snd x)),\n                               snd (snd x)))\n                          (fused_resource.fuse core' rest' ((st, sc), sr)\n                            (map_sum lsumr (\\<lambda>x. x) q))", "subgoal for q_adv_rest_etran"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ifunc \\<equiv>\n             \\<lambda>ifunc core (se, sc) q.\n                ifunc se q \\<bind>\n                (\\<lambda>((out, es), se').\n                    foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n                    (\\<lambda>sc'. return_spmf (out, se', sc')));\n     cpoke core' = cpoke (translate_core etran core);\n     cfunc_adv core' =\n     \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O x_ifunc ifunc core;\n     cfunc_usr core' = cfunc_usr (translate_core etran core);\n     rinit rest = (einit, rinit rest');\n     rfunc_adv rest =\n     (\\<lambda>s q.\n         case q of\n         Inl ql \\<Rightarrow>\n           map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n         | Inr qr \\<Rightarrow>\n             map_spmf (apfst (map_prod Inr id))\n              (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n     rfunc_usr rest = translate_eoracle etran \\<dagger>(rfunc_usr rest');\n     q = Inl q_adv; q_adv = Inr q_adv_rest;\n     q_adv_rest = Inr q_adv_rest_etran\\<rbrakk>\n    \\<Longrightarrow> fused_resource.fuse core rest (sc, st, sr) q =\n                      map_spmf\n                       (\\<lambda>x.\n                           (map_sum rsuml (\\<lambda>x. x) (fst x),\n                            snd (fst (snd x)), fst (fst (snd x)),\n                            snd (snd x)))\n                       (fused_resource.fuse core' rest' ((st, sc), sr)\n                         (map_sum lsumr (\\<lambda>x. x) q))", "apply (simp add: translate_eoracle_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ifunc \\<equiv>\n             \\<lambda>ifunc core p q.\n                ifunc (fst p) q \\<bind>\n                (\\<lambda>pa.\n                    foldl_spmf (cpoke core) (return_spmf (snd p))\n                     (snd (fst pa)) \\<bind>\n                    (\\<lambda>sc'.\n                        return_spmf (fst (fst pa), snd pa, sc')));\n     cpoke core' =\n     (\\<lambda>p event.\n         etran (fst p) event \\<bind>\n         (\\<lambda>pa.\n             map_spmf (Pair (snd pa))\n              (foldl_spmf (cpoke core) (return_spmf (snd p)) (fst pa))));\n     cfunc_adv core' =\n     \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O\n     (\\<lambda>p q.\n         ifunc (fst p) q \\<bind>\n         (\\<lambda>pa.\n             foldl_spmf (cpoke core) (return_spmf (snd p))\n              (snd (fst pa)) \\<bind>\n             (\\<lambda>sc'. return_spmf (fst (fst pa), snd pa, sc'))));\n     cfunc_usr core' = \\<dagger>(cfunc_usr core);\n     rinit rest = (einit, rinit rest');\n     rfunc_adv rest =\n     (\\<lambda>s q.\n         case q of\n         Inl ql \\<Rightarrow>\n           map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n         | Inr qr \\<Rightarrow>\n             map_spmf (apfst (map_prod Inr id))\n              (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n     rfunc_usr rest = translate_eoracle etran \\<dagger>(rfunc_usr rest');\n     q = Inl (Inr (Inr q_adv_rest_etran));\n     q_adv = Inr (Inr q_adv_rest_etran);\n     q_adv_rest = Inr q_adv_rest_etran\\<rbrakk>\n    \\<Longrightarrow> rfunc_adv rest' sr q_adv_rest_etran \\<bind>\n                      (\\<lambda>y.\n                          foldl_spmf\n                           (\\<lambda>p e.\n                               map_spmf (map_prod ((@) (fst p)) id)\n                                (etran (snd p) e))\n                           (return_spmf ([], st)) (snd (fst y)) \\<bind>\n                          (\\<lambda>ya.\n                              foldl_spmf (cpoke core) (return_spmf sc)\n                               (fst ya) \\<bind>\n                              (\\<lambda>s_notify.\n                                  return_spmf\n                                   (Inl (Inr (Inr (fst (fst y)))), s_notify,\n                                    snd ya, snd y)))) =\n                      rfunc_adv rest' sr q_adv_rest_etran \\<bind>\n                      (\\<lambda>x.\n                          foldl_spmf\n                           (\\<lambda>p event.\n                               etran (fst p) event \\<bind>\n                               (\\<lambda>pa.\n                                   map_spmf (Pair (snd pa))\n                                    (foldl_spmf (cpoke core)\n(return_spmf (snd p)) (fst pa))))\n                           (return_spmf (st, sc)) (snd (fst x)) \\<bind>\n                          (\\<lambda>xa.\n                              return_spmf\n                               (Inl (Inr (Inr (fst (fst x)))), snd xa,\n                                fst xa, snd x)))", "apply(rule bind_spmf_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x_ifunc \\<equiv>\n                \\<lambda>ifunc core p q.\n                   ifunc (fst p) q \\<bind>\n                   (\\<lambda>pa.\n                       foldl_spmf (cpoke core) (return_spmf (snd p))\n                        (snd (fst pa)) \\<bind>\n                       (\\<lambda>sc'.\n                           return_spmf (fst (fst pa), snd pa, sc')));\n        cpoke core' =\n        (\\<lambda>p event.\n            etran (fst p) event \\<bind>\n            (\\<lambda>pa.\n                map_spmf (Pair (snd pa))\n                 (foldl_spmf (cpoke core) (return_spmf (snd p)) (fst pa))));\n        cfunc_adv core' =\n        \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O\n        (\\<lambda>p q.\n            ifunc (fst p) q \\<bind>\n            (\\<lambda>pa.\n                foldl_spmf (cpoke core) (return_spmf (snd p))\n                 (snd (fst pa)) \\<bind>\n                (\\<lambda>sc'. return_spmf (fst (fst pa), snd pa, sc'))));\n        cfunc_usr core' = \\<dagger>(cfunc_usr core);\n        rinit rest = (einit, rinit rest');\n        rfunc_adv rest =\n        (\\<lambda>s q.\n            case q of\n            Inl ql \\<Rightarrow>\n              map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n            | Inr qr \\<Rightarrow>\n                map_spmf (apfst (map_prod Inr id))\n                 (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n        rfunc_usr rest = translate_eoracle etran \\<dagger>(rfunc_usr rest');\n        q = Inl (Inr (Inr q_adv_rest_etran));\n        q_adv = Inr (Inr q_adv_rest_etran);\n        q_adv_rest = Inr q_adv_rest_etran;\n        x \\<in> set_spmf (rfunc_adv rest' sr q_adv_rest_etran)\\<rbrakk>\n       \\<Longrightarrow> foldl_spmf\n                          (\\<lambda>p e.\n                              map_spmf (map_prod ((@) (fst p)) id)\n                               (etran (snd p) e))\n                          (return_spmf ([], st)) (snd (fst x)) \\<bind>\n                         (\\<lambda>y.\n                             foldl_spmf (cpoke core) (return_spmf sc)\n                              (fst y) \\<bind>\n                             (\\<lambda>s_notify.\n                                 return_spmf\n                                  (Inl (Inr (Inr (fst (fst x)))), s_notify,\n                                   snd y, snd x))) =\n                         foldl_spmf\n                          (\\<lambda>p event.\n                              etran (fst p) event \\<bind>\n                              (\\<lambda>pa.\n                                  map_spmf (Pair (snd pa))\n                                   (foldl_spmf (cpoke core)\n                                     (return_spmf (snd p)) (fst pa))))\n                          (return_spmf (st, sc)) (snd (fst x)) \\<bind>\n                         (\\<lambda>xa.\n                             return_spmf\n                              (Inl (Inr (Inr (fst (fst x)))), snd xa,\n                               fst xa, snd x))", "apply(subst foldl_spmf_chain[simplified split_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x_ifunc \\<equiv>\n                \\<lambda>ifunc core p q.\n                   ifunc (fst p) q \\<bind>\n                   (\\<lambda>pa.\n                       foldl_spmf (cpoke core) (return_spmf (snd p))\n                        (snd (fst pa)) \\<bind>\n                       (\\<lambda>sc'.\n                           return_spmf (fst (fst pa), snd pa, sc')));\n        cpoke core' =\n        (\\<lambda>p event.\n            etran (fst p) event \\<bind>\n            (\\<lambda>pa.\n                map_spmf (Pair (snd pa))\n                 (foldl_spmf (cpoke core) (return_spmf (snd p)) (fst pa))));\n        cfunc_adv core' =\n        \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O\n        (\\<lambda>p q.\n            ifunc (fst p) q \\<bind>\n            (\\<lambda>pa.\n                foldl_spmf (cpoke core) (return_spmf (snd p))\n                 (snd (fst pa)) \\<bind>\n                (\\<lambda>sc'. return_spmf (fst (fst pa), snd pa, sc'))));\n        cfunc_usr core' = \\<dagger>(cfunc_usr core);\n        rinit rest = (einit, rinit rest');\n        rfunc_adv rest =\n        (\\<lambda>s q.\n            case q of\n            Inl ql \\<Rightarrow>\n              map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n            | Inr qr \\<Rightarrow>\n                map_spmf (apfst (map_prod Inr id))\n                 (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n        rfunc_usr rest = translate_eoracle etran \\<dagger>(rfunc_usr rest');\n        q = Inl (Inr (Inr q_adv_rest_etran));\n        q_adv = Inr (Inr q_adv_rest_etran);\n        q_adv_rest = Inr q_adv_rest_etran;\n        x \\<in> set_spmf (rfunc_adv rest' sr q_adv_rest_etran)\\<rbrakk>\n       \\<Longrightarrow> foldl_spmf\n                          (\\<lambda>p event.\n                              etran (fst p) event \\<bind>\n                              (\\<lambda>pa.\n                                  map_spmf (Pair (snd pa))\n                                   (foldl_spmf (cpoke core)\n                                     (return_spmf (snd p)) (fst pa))))\n                          (return_spmf (st, sc)) (snd (fst x)) \\<bind>\n                         (\\<lambda>p.\n                             return_spmf\n                              (Inl (Inr (Inr (fst (fst x)))), snd p, fst p,\n                               snd x)) =\n                         foldl_spmf\n                          (\\<lambda>p event.\n                              etran (fst p) event \\<bind>\n                              (\\<lambda>pa.\n                                  map_spmf (Pair (snd pa))\n                                   (foldl_spmf (cpoke core)\n                                     (return_spmf (snd p)) (fst pa))))\n                          (return_spmf (st, sc)) (snd (fst x)) \\<bind>\n                         (\\<lambda>xa.\n                             return_spmf\n                              (Inl (Inr (Inr (fst (fst x)))), snd xa,\n                               fst xa, snd x))", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>x_ifunc \\<equiv>\n                \\<lambda>ifunc core (se, sc) q.\n                   ifunc se q \\<bind>\n                   (\\<lambda>((out, es), se').\n                       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n                       (\\<lambda>sc'. return_spmf (out, se', sc')));\n        cpoke core' = cpoke (translate_core etran core);\n        cfunc_adv core' =\n        \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O x_ifunc ifunc core;\n        cfunc_usr core' = cfunc_usr (translate_core etran core);\n        rinit rest = (einit, rinit rest');\n        rfunc_adv rest =\n        (\\<lambda>s q.\n            case q of\n            Inl ql \\<Rightarrow>\n              map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n            | Inr qr \\<Rightarrow>\n                map_spmf (apfst (map_prod Inr id))\n                 (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n        rfunc_usr rest = translate_eoracle etran \\<dagger>(rfunc_usr rest');\n        q = Inr b\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core rest (sc, st, sr) q =\n                         map_spmf\n                          (\\<lambda>x.\n                              (map_sum rsuml (\\<lambda>x. x) (fst x),\n                               snd (fst (snd x)), fst (fst (snd x)),\n                               snd (snd x)))\n                          (fused_resource.fuse core' rest' ((st, sc), sr)\n                            (map_sum lsumr (\\<lambda>x. x) q))", "subgoal for q_usr"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ifunc \\<equiv>\n             \\<lambda>ifunc core (se, sc) q.\n                ifunc se q \\<bind>\n                (\\<lambda>((out, es), se').\n                    foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n                    (\\<lambda>sc'. return_spmf (out, se', sc')));\n     cpoke core' = cpoke (translate_core etran core);\n     cfunc_adv core' =\n     \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O x_ifunc ifunc core;\n     cfunc_usr core' = cfunc_usr (translate_core etran core);\n     rinit rest = (einit, rinit rest');\n     rfunc_adv rest =\n     (\\<lambda>s q.\n         case q of\n         Inl ql \\<Rightarrow>\n           map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n         | Inr qr \\<Rightarrow>\n             map_spmf (apfst (map_prod Inr id))\n              (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n     rfunc_usr rest = translate_eoracle etran \\<dagger>(rfunc_usr rest');\n     q = Inr q_usr\\<rbrakk>\n    \\<Longrightarrow> fused_resource.fuse core rest (sc, st, sr) q =\n                      map_spmf\n                       (\\<lambda>x.\n                           (map_sum rsuml (\\<lambda>x. x) (fst x),\n                            snd (fst (snd x)), fst (fst (snd x)),\n                            snd (snd x)))\n                       (fused_resource.fuse core' rest' ((st, sc), sr)\n                         (map_sum lsumr (\\<lambda>x. x) q))", "apply (cases q_usr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>x_ifunc \\<equiv>\n                \\<lambda>ifunc core (se, sc) q.\n                   ifunc se q \\<bind>\n                   (\\<lambda>((out, es), se').\n                       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n                       (\\<lambda>sc'. return_spmf (out, se', sc')));\n        cpoke core' = cpoke (translate_core etran core);\n        cfunc_adv core' =\n        \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O x_ifunc ifunc core;\n        cfunc_usr core' = cfunc_usr (translate_core etran core);\n        rinit rest = (einit, rinit rest');\n        rfunc_adv rest =\n        (\\<lambda>s q.\n            case q of\n            Inl ql \\<Rightarrow>\n              map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n            | Inr qr \\<Rightarrow>\n                map_spmf (apfst (map_prod Inr id))\n                 (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n        rfunc_usr rest = translate_eoracle etran \\<dagger>(rfunc_usr rest');\n        q = Inr q_usr; q_usr = Inl a\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core rest (sc, st, sr) q =\n                         map_spmf\n                          (\\<lambda>x.\n                              (map_sum rsuml (\\<lambda>x. x) (fst x),\n                               snd (fst (snd x)), fst (fst (snd x)),\n                               snd (snd x)))\n                          (fused_resource.fuse core' rest' ((st, sc), sr)\n                            (map_sum lsumr (\\<lambda>x. x) q))\n 2. \\<And>b.\n       \\<lbrakk>x_ifunc \\<equiv>\n                \\<lambda>ifunc core (se, sc) q.\n                   ifunc se q \\<bind>\n                   (\\<lambda>((out, es), se').\n                       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n                       (\\<lambda>sc'. return_spmf (out, se', sc')));\n        cpoke core' = cpoke (translate_core etran core);\n        cfunc_adv core' =\n        \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O x_ifunc ifunc core;\n        cfunc_usr core' = cfunc_usr (translate_core etran core);\n        rinit rest = (einit, rinit rest');\n        rfunc_adv rest =\n        (\\<lambda>s q.\n            case q of\n            Inl ql \\<Rightarrow>\n              map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n            | Inr qr \\<Rightarrow>\n                map_spmf (apfst (map_prod Inr id))\n                 (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n        rfunc_usr rest = translate_eoracle etran \\<dagger>(rfunc_usr rest');\n        q = Inr q_usr; q_usr = Inr b\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core rest (sc, st, sr) q =\n                         map_spmf\n                          (\\<lambda>x.\n                              (map_sum rsuml (\\<lambda>x. x) (fst x),\n                               snd (fst (snd x)), fst (fst (snd x)),\n                               snd (snd x)))\n                          (fused_resource.fuse core' rest' ((st, sc), sr)\n                            (map_sum lsumr (\\<lambda>x. x) q))", "subgoal for q_usr_core"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ifunc \\<equiv>\n             \\<lambda>ifunc core (se, sc) q.\n                ifunc se q \\<bind>\n                (\\<lambda>((out, es), se').\n                    foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n                    (\\<lambda>sc'. return_spmf (out, se', sc')));\n     cpoke core' = cpoke (translate_core etran core);\n     cfunc_adv core' =\n     \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O x_ifunc ifunc core;\n     cfunc_usr core' = cfunc_usr (translate_core etran core);\n     rinit rest = (einit, rinit rest');\n     rfunc_adv rest =\n     (\\<lambda>s q.\n         case q of\n         Inl ql \\<Rightarrow>\n           map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n         | Inr qr \\<Rightarrow>\n             map_spmf (apfst (map_prod Inr id))\n              (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n     rfunc_usr rest = translate_eoracle etran \\<dagger>(rfunc_usr rest');\n     q = Inr q_usr; q_usr = Inl q_usr_core\\<rbrakk>\n    \\<Longrightarrow> fused_resource.fuse core rest (sc, st, sr) q =\n                      map_spmf\n                       (\\<lambda>x.\n                           (map_sum rsuml (\\<lambda>x. x) (fst x),\n                            snd (fst (snd x)), fst (fst (snd x)),\n                            snd (snd x)))\n                       (fused_resource.fuse core' rest' ((st, sc), sr)\n                         (map_sum lsumr (\\<lambda>x. x) q))", "by (simp add: map_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>x_ifunc \\<equiv>\n                \\<lambda>ifunc core (se, sc) q.\n                   ifunc se q \\<bind>\n                   (\\<lambda>((out, es), se').\n                       foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n                       (\\<lambda>sc'. return_spmf (out, se', sc')));\n        cpoke core' = cpoke (translate_core etran core);\n        cfunc_adv core' =\n        \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O x_ifunc ifunc core;\n        cfunc_usr core' = cfunc_usr (translate_core etran core);\n        rinit rest = (einit, rinit rest');\n        rfunc_adv rest =\n        (\\<lambda>s q.\n            case q of\n            Inl ql \\<Rightarrow>\n              map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n            | Inr qr \\<Rightarrow>\n                map_spmf (apfst (map_prod Inr id))\n                 (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n        rfunc_usr rest = translate_eoracle etran \\<dagger>(rfunc_usr rest');\n        q = Inr q_usr; q_usr = Inr b\\<rbrakk>\n       \\<Longrightarrow> fused_resource.fuse core rest (sc, st, sr) q =\n                         map_spmf\n                          (\\<lambda>x.\n                              (map_sum rsuml (\\<lambda>x. x) (fst x),\n                               snd (fst (snd x)), fst (fst (snd x)),\n                               snd (snd x)))\n                          (fused_resource.fuse core' rest' ((st, sc), sr)\n                            (map_sum lsumr (\\<lambda>x. x) q))", "subgoal for q_usr_rest"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ifunc \\<equiv>\n             \\<lambda>ifunc core (se, sc) q.\n                ifunc se q \\<bind>\n                (\\<lambda>((out, es), se').\n                    foldl_spmf (cpoke core) (return_spmf sc) es \\<bind>\n                    (\\<lambda>sc'. return_spmf (out, se', sc')));\n     cpoke core' = cpoke (translate_core etran core);\n     cfunc_adv core' =\n     \\<dagger>(cfunc_adv core) \\<oplus>\\<^sub>O x_ifunc ifunc core;\n     cfunc_usr core' = cfunc_usr (translate_core etran core);\n     rinit rest = (einit, rinit rest');\n     rfunc_adv rest =\n     (\\<lambda>s q.\n         case q of\n         Inl ql \\<Rightarrow>\n           map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n         | Inr qr \\<Rightarrow>\n             map_spmf (apfst (map_prod Inr id))\n              (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n     rfunc_usr rest = translate_eoracle etran \\<dagger>(rfunc_usr rest');\n     q = Inr q_usr; q_usr = Inr q_usr_rest\\<rbrakk>\n    \\<Longrightarrow> fused_resource.fuse core rest (sc, st, sr) q =\n                      map_spmf\n                       (\\<lambda>x.\n                           (map_sum rsuml (\\<lambda>x. x) (fst x),\n                            snd (fst (snd x)), fst (fst (snd x)),\n                            snd (snd x)))\n                       (fused_resource.fuse core' rest' ((st, sc), sr)\n                         (map_sum lsumr (\\<lambda>x. x) q))", "apply (simp add: translate_eoracle_def extend_state_oracle_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ifunc \\<equiv>\n             \\<lambda>ifunc core p q.\n                ifunc (fst p) q \\<bind>\n                (\\<lambda>pa.\n                    foldl_spmf (cpoke core) (return_spmf (snd p))\n                     (snd (fst pa)) \\<bind>\n                    (\\<lambda>sc'.\n                        return_spmf (fst (fst pa), snd pa, sc')));\n     cpoke core' =\n     (\\<lambda>p event.\n         etran (fst p) event \\<bind>\n         (\\<lambda>pa.\n             map_spmf (Pair (snd pa))\n              (foldl_spmf (cpoke core) (return_spmf (snd p)) (fst pa))));\n     cfunc_adv core' =\n     (\\<lambda>p x.\n         map_spmf (\\<lambda>pa. (fst pa, fst p, snd pa))\n          (cfunc_adv core (snd p) x)) \\<oplus>\\<^sub>O\n     (\\<lambda>p q.\n         ifunc (fst p) q \\<bind>\n         (\\<lambda>pa.\n             foldl_spmf (cpoke core) (return_spmf (snd p))\n              (snd (fst pa)) \\<bind>\n             (\\<lambda>sc'. return_spmf (fst (fst pa), snd pa, sc'))));\n     cfunc_usr core' =\n     (\\<lambda>p x.\n         map_spmf (\\<lambda>pa. (fst pa, fst p, snd pa))\n          (cfunc_usr core (snd p) x));\n     rinit rest = (einit, rinit rest');\n     rfunc_adv rest =\n     (\\<lambda>s q.\n         case q of\n         Inl ql \\<Rightarrow>\n           map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n         | Inr qr \\<Rightarrow>\n             map_spmf (apfst (map_prod Inr id))\n              (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n     rfunc_usr rest =\n     translate_eoracle etran\n      (\\<lambda>p x.\n          map_spmf (\\<lambda>pa. (fst pa, fst p, snd pa))\n           (rfunc_usr rest' (snd p) x));\n     q = Inr (Inr q_usr_rest); q_usr = Inr q_usr_rest\\<rbrakk>\n    \\<Longrightarrow> rfunc_usr rest' sr q_usr_rest \\<bind>\n                      (\\<lambda>y.\n                          foldl_spmf\n                           (\\<lambda>p e.\n                               map_spmf (map_prod ((@) (fst p)) id)\n                                (etran (snd p) e))\n                           (return_spmf ([], st)) (snd (fst y)) \\<bind>\n                          (\\<lambda>ya.\n                              foldl_spmf (cpoke core) (return_spmf sc)\n                               (fst ya) \\<bind>\n                              (\\<lambda>s_notify.\n                                  return_spmf\n                                   (Inr (Inr (fst (fst y))), s_notify,\n                                    snd ya, snd y)))) =\n                      rfunc_usr rest' sr q_usr_rest \\<bind>\n                      (\\<lambda>x.\n                          foldl_spmf\n                           (\\<lambda>p event.\n                               etran (fst p) event \\<bind>\n                               (\\<lambda>pa.\n                                   map_spmf (Pair (snd pa))\n                                    (foldl_spmf (cpoke core)\n(return_spmf (snd p)) (fst pa))))\n                           (return_spmf (st, sc)) (snd (fst x)) \\<bind>\n                          (\\<lambda>xa.\n                              return_spmf\n                               (Inr (Inr (fst (fst x))), snd xa, fst xa,\n                                snd x)))", "apply(rule bind_spmf_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x_ifunc \\<equiv>\n                \\<lambda>ifunc core p q.\n                   ifunc (fst p) q \\<bind>\n                   (\\<lambda>pa.\n                       foldl_spmf (cpoke core) (return_spmf (snd p))\n                        (snd (fst pa)) \\<bind>\n                       (\\<lambda>sc'.\n                           return_spmf (fst (fst pa), snd pa, sc')));\n        cpoke core' =\n        (\\<lambda>p event.\n            etran (fst p) event \\<bind>\n            (\\<lambda>pa.\n                map_spmf (Pair (snd pa))\n                 (foldl_spmf (cpoke core) (return_spmf (snd p)) (fst pa))));\n        cfunc_adv core' =\n        (\\<lambda>p x.\n            map_spmf (\\<lambda>pa. (fst pa, fst p, snd pa))\n             (cfunc_adv core (snd p) x)) \\<oplus>\\<^sub>O\n        (\\<lambda>p q.\n            ifunc (fst p) q \\<bind>\n            (\\<lambda>pa.\n                foldl_spmf (cpoke core) (return_spmf (snd p))\n                 (snd (fst pa)) \\<bind>\n                (\\<lambda>sc'. return_spmf (fst (fst pa), snd pa, sc'))));\n        cfunc_usr core' =\n        (\\<lambda>p x.\n            map_spmf (\\<lambda>pa. (fst pa, fst p, snd pa))\n             (cfunc_usr core (snd p) x));\n        rinit rest = (einit, rinit rest');\n        rfunc_adv rest =\n        (\\<lambda>s q.\n            case q of\n            Inl ql \\<Rightarrow>\n              map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n            | Inr qr \\<Rightarrow>\n                map_spmf (apfst (map_prod Inr id))\n                 (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n        rfunc_usr rest =\n        translate_eoracle etran\n         (\\<lambda>p x.\n             map_spmf (\\<lambda>pa. (fst pa, fst p, snd pa))\n              (rfunc_usr rest' (snd p) x));\n        q = Inr (Inr q_usr_rest); q_usr = Inr q_usr_rest;\n        x \\<in> set_spmf (rfunc_usr rest' sr q_usr_rest)\\<rbrakk>\n       \\<Longrightarrow> foldl_spmf\n                          (\\<lambda>p e.\n                              map_spmf (map_prod ((@) (fst p)) id)\n                               (etran (snd p) e))\n                          (return_spmf ([], st)) (snd (fst x)) \\<bind>\n                         (\\<lambda>y.\n                             foldl_spmf (cpoke core) (return_spmf sc)\n                              (fst y) \\<bind>\n                             (\\<lambda>s_notify.\n                                 return_spmf\n                                  (Inr (Inr (fst (fst x))), s_notify, snd y,\n                                   snd x))) =\n                         foldl_spmf\n                          (\\<lambda>p event.\n                              etran (fst p) event \\<bind>\n                              (\\<lambda>pa.\n                                  map_spmf (Pair (snd pa))\n                                   (foldl_spmf (cpoke core)\n                                     (return_spmf (snd p)) (fst pa))))\n                          (return_spmf (st, sc)) (snd (fst x)) \\<bind>\n                         (\\<lambda>xa.\n                             return_spmf\n                              (Inr (Inr (fst (fst x))), snd xa, fst xa,\n                               snd x))", "apply(subst foldl_spmf_chain[simplified split_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x_ifunc \\<equiv>\n                \\<lambda>ifunc core p q.\n                   ifunc (fst p) q \\<bind>\n                   (\\<lambda>pa.\n                       foldl_spmf (cpoke core) (return_spmf (snd p))\n                        (snd (fst pa)) \\<bind>\n                       (\\<lambda>sc'.\n                           return_spmf (fst (fst pa), snd pa, sc')));\n        cpoke core' =\n        (\\<lambda>p event.\n            etran (fst p) event \\<bind>\n            (\\<lambda>pa.\n                map_spmf (Pair (snd pa))\n                 (foldl_spmf (cpoke core) (return_spmf (snd p)) (fst pa))));\n        cfunc_adv core' =\n        (\\<lambda>p x.\n            map_spmf (\\<lambda>pa. (fst pa, fst p, snd pa))\n             (cfunc_adv core (snd p) x)) \\<oplus>\\<^sub>O\n        (\\<lambda>p q.\n            ifunc (fst p) q \\<bind>\n            (\\<lambda>pa.\n                foldl_spmf (cpoke core) (return_spmf (snd p))\n                 (snd (fst pa)) \\<bind>\n                (\\<lambda>sc'. return_spmf (fst (fst pa), snd pa, sc'))));\n        cfunc_usr core' =\n        (\\<lambda>p x.\n            map_spmf (\\<lambda>pa. (fst pa, fst p, snd pa))\n             (cfunc_usr core (snd p) x));\n        rinit rest = (einit, rinit rest');\n        rfunc_adv rest =\n        (\\<lambda>s q.\n            case q of\n            Inl ql \\<Rightarrow>\n              map_spmf (apfst (map_prod Inl id)) (ifunc\\<dagger> s ql)\n            | Inr qr \\<Rightarrow>\n                map_spmf (apfst (map_prod Inr id))\n                 (translate_eoracle etran \\<dagger>(rfunc_adv rest') s qr));\n        rfunc_usr rest =\n        translate_eoracle etran\n         (\\<lambda>p x.\n             map_spmf (\\<lambda>pa. (fst pa, fst p, snd pa))\n              (rfunc_usr rest' (snd p) x));\n        q = Inr (Inr q_usr_rest); q_usr = Inr q_usr_rest;\n        x \\<in> set_spmf (rfunc_usr rest' sr q_usr_rest)\\<rbrakk>\n       \\<Longrightarrow> foldl_spmf\n                          (\\<lambda>p event.\n                              etran (fst p) event \\<bind>\n                              (\\<lambda>pa.\n                                  map_spmf (Pair (snd pa))\n                                   (foldl_spmf (cpoke core)\n                                     (return_spmf (snd p)) (fst pa))))\n                          (return_spmf (st, sc)) (snd (fst x)) \\<bind>\n                         (\\<lambda>p.\n                             return_spmf\n                              (Inr (Inr (fst (fst x))), snd p, fst p,\n                               snd x)) =\n                         foldl_spmf\n                          (\\<lambda>p event.\n                              etran (fst p) event \\<bind>\n                              (\\<lambda>pa.\n                                  map_spmf (Pair (snd pa))\n                                   (foldl_spmf (cpoke core)\n                                     (return_spmf (snd p)) (fst pa))))\n                          (return_spmf (st, sc)) (snd (fst x)) \\<bind>\n                         (\\<lambda>xa.\n                             return_spmf\n                              (Inr (Inr (fst (fst x))), snd xa, fst xa,\n                               snd x))", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fused_resource.fuse core rest (?sc, ?st, ?sr) ?q =\n  apply_wiring (rassocl\\<^sub>w |\\<^sub>w (id, id))\n   (apply_state_iso\n     (rprodl \\<circ> apfst prod.swap, apfst prod.swap \\<circ> lprodr)\n     (fused_resource.fuse core' rest'))\n   (?sc, ?st, ?sr) ?q\n\ngoal (1 subgoal):\n 1. fused_resource.fuse core rest =\n    apply_wiring (rassocl\\<^sub>w |\\<^sub>w (id, id))\n     (apply_state_iso\n       (rprodl \\<circ> apfst prod.swap, apfst prod.swap \\<circ> lprodr)\n       (fused_resource.fuse core' rest'))", "then"], ["proof (chain)\npicking this:\n  fused_resource.fuse core rest (?sc, ?st, ?sr) ?q =\n  apply_wiring (rassocl\\<^sub>w |\\<^sub>w (id, id))\n   (apply_state_iso\n     (rprodl \\<circ> apfst prod.swap, apfst prod.swap \\<circ> lprodr)\n     (fused_resource.fuse core' rest'))\n   (?sc, ?st, ?sr) ?q", "show ?thesis"], ["proof (prove)\nusing this:\n  fused_resource.fuse core rest (?sc, ?st, ?sr) ?q =\n  apply_wiring (rassocl\\<^sub>w |\\<^sub>w (id, id))\n   (apply_state_iso\n     (rprodl \\<circ> apfst prod.swap, apfst prod.swap \\<circ> lprodr)\n     (fused_resource.fuse core' rest'))\n   (?sc, ?st, ?sr) ?q\n\ngoal (1 subgoal):\n 1. fused_resource.fuse core rest =\n    apply_wiring (rassocl\\<^sub>w |\\<^sub>w (id, id))\n     (apply_state_iso\n       (rprodl \\<circ> apfst prod.swap, apfst prod.swap \\<circ> lprodr)\n       (fused_resource.fuse core' rest'))", "by force"], ["proof (state)\nthis:\n  fused_resource.fuse core rest =\n  apply_wiring (rassocl\\<^sub>w |\\<^sub>w (id, id))\n   (apply_state_iso\n     (rprodl \\<circ> apfst prod.swap, apfst prod.swap \\<circ> lprodr)\n     (fused_resource.fuse core' rest'))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}