{"file_name": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography_CM/Specifications/Key.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography_CM", "problem_names": ["lemma Alice_neq_iff [simp]: \"Alice \\<noteq> x \\<longleftrightarrow> x = Bob\"", "lemma neq_Alice_iff [simp]: \"x \\<noteq> Alice \\<longleftrightarrow> x = Bob\"", "lemma Bob_neq_iff [simp]: \"Bob \\<noteq> x \\<longleftrightarrow> x = Alice\"", "lemma neq_Bob_iff [simp]: \"x \\<noteq> Bob \\<longleftrightarrow> x = Alice\"", "lemma Alice_in_iff_nonempty: \"Alice \\<in> A \\<longleftrightarrow> A \\<noteq> {}\" if \"Bob \\<notin> A\"", "lemma Bob_in_iff_nonempty: \"Bob \\<in> A \\<longleftrightarrow> A \\<noteq> {}\" if \"Alice \\<notin> A\"", "lemma in_set_spmf_poke:\n  \"s' \\<in> set_spmf (poke s x) \\<longleftrightarrow>\n  (\\<exists>s_kernel parties party. s = (s_kernel, parties) \\<and> x = Event_Shell party \\<and> party \\<notin> parties \\<and> s' = (s_kernel, insert party parties)) \\<or>\n  (\\<exists>s_shell key. s = (PState_Store, s_shell) \\<and> x = Event_Kernel \\<and> key \\<in> valid_keys \\<and> finite valid_keys \\<and> s' = (State_Store key, s_shell))\"", "lemma foldl_poke_invar:\n  \"\\<lbrakk> (s_kernel', parties') \\<in> set_spmf (foldl_spmf poke p events); \\<forall>(s_kernel, parties)\\<in>set_spmf p. set_s_kernel s_kernel \\<subseteq> valid_keys \\<rbrakk>\n  \\<Longrightarrow> set_s_kernel s_kernel' \\<subseteq> valid_keys\"", "lemma in_set_iface_usr_func [simp]:\n  \"x \\<in> set_spmf (iface_usr_func party wrap state inp) \\<longleftrightarrow>\n   (\\<exists>key parties. state = (State_Store key, parties) \\<and> party \\<in> parties \\<and> x = (wrap key, State_Store key, parties))\"", "lemma WT_core [WT_intro]: \n  \"WT_core \\<I>_full (\\<I>_uniform UNIV (Out_Alice ` valid_keys) \\<oplus>\\<^sub>\\<I> \\<I>_uniform UNIV (Out_Bob ` valid_keys))\n     (pred_prod (pred_s_kernel (\\<lambda>key. key \\<in> valid_keys)) (\\<lambda>_. True)) core\"", "lemma WT_fuse [WT_intro]: \n  assumes [WT_intro]: \"WT_rest \\<I>_adv_rest \\<I>_usr_rest I_rest rest\"\n  shows \"(\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I> ((\\<I>_uniform UNIV (Out_Alice ` valid_keys) \\<oplus>\\<^sub>\\<I> \\<I>_uniform UNIV (Out_Bob ` valid_keys)) \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest) \\<turnstile>res resource rest \\<surd>\""], "translations": [["", "lemma Alice_neq_iff [simp]: \"Alice \\<noteq> x \\<longleftrightarrow> x = Bob\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Alice \\<noteq> x) = (x = Bob)", "by(cases x) simp_all"], ["", "lemma neq_Alice_iff [simp]: \"x \\<noteq> Alice \\<longleftrightarrow> x = Bob\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<noteq> Alice) = (x = Bob)", "by(cases x) simp_all"], ["", "lemma Bob_neq_iff [simp]: \"Bob \\<noteq> x \\<longleftrightarrow> x = Alice\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Bob \\<noteq> x) = (x = Alice)", "by(cases x) simp_all"], ["", "lemma neq_Bob_iff [simp]: \"x \\<noteq> Bob \\<longleftrightarrow> x = Alice\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<noteq> Bob) = (x = Alice)", "by(cases x) simp_all"], ["", "lemma Alice_in_iff_nonempty: \"Alice \\<in> A \\<longleftrightarrow> A \\<noteq> {}\" if \"Bob \\<notin> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Alice \\<in> A) = (A \\<noteq> {})", "using that"], ["proof (prove)\nusing this:\n  Bob \\<notin> A\n\ngoal (1 subgoal):\n 1. (Alice \\<in> A) = (A \\<noteq> {})", "by(auto)(metis (full_types) party.exhaust)"], ["", "lemma Bob_in_iff_nonempty: \"Bob \\<in> A \\<longleftrightarrow> A \\<noteq> {}\" if \"Alice \\<notin> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Bob \\<in> A) = (A \\<noteq> {})", "using that"], ["proof (prove)\nusing this:\n  Alice \\<notin> A\n\ngoal (1 subgoal):\n 1. (Bob \\<in> A) = (A \\<noteq> {})", "by(auto)(metis (full_types) party.exhaust)"], ["", "subsection \\<open>Defining the event handler\\<close>"], ["", "fun poke :: \"('key state, event) handler\"\n  where\n    \"poke (s_kernel, parties) (Event_Shell party) = \n      (if party \\<in> parties then \n        return_pmf None\n      else \n        return_spmf (s_kernel, insert party parties))\"\n  | \"poke (PState_Store, s_shell) (Event_Kernel) = do {\n      key \\<leftarrow> spmf_of_set valid_keys;\n      return_spmf (State_Store key, s_shell)  } \"\n  | \"poke _ _ = return_pmf None\""], ["", "lemma in_set_spmf_poke:\n  \"s' \\<in> set_spmf (poke s x) \\<longleftrightarrow>\n  (\\<exists>s_kernel parties party. s = (s_kernel, parties) \\<and> x = Event_Shell party \\<and> party \\<notin> parties \\<and> s' = (s_kernel, insert party parties)) \\<or>\n  (\\<exists>s_shell key. s = (PState_Store, s_shell) \\<and> x = Event_Kernel \\<and> key \\<in> valid_keys \\<and> finite valid_keys \\<and> s' = (State_Store key, s_shell))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s' \\<in> set_spmf (poke s x)) =\n    ((\\<exists>s_kernel parties party.\n         s = (s_kernel, parties) \\<and>\n         x = Event_Shell party \\<and>\n         party \\<notin> parties \\<and>\n         s' = (s_kernel, insert party parties)) \\<or>\n     (\\<exists>s_shell key.\n         s = (PState_Store, s_shell) \\<and>\n         x = Event_Kernel \\<and>\n         key \\<in> valid_keys \\<and>\n         finite valid_keys \\<and> s' = (State_Store key, s_shell)))", "by(cases \"(s, x)\" rule: poke.cases)(auto simp add: set_spmf_of_set)"], ["", "lemma foldl_poke_invar:\n  \"\\<lbrakk> (s_kernel', parties') \\<in> set_spmf (foldl_spmf poke p events); \\<forall>(s_kernel, parties)\\<in>set_spmf p. set_s_kernel s_kernel \\<subseteq> valid_keys \\<rbrakk>\n  \\<Longrightarrow> set_s_kernel s_kernel' \\<subseteq> valid_keys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s_kernel', parties')\n             \\<in> set_spmf (foldl_spmf poke p events);\n     \\<forall>(s_kernel, parties)\\<in>set_spmf p.\n        set_s_kernel s_kernel \\<subseteq> valid_keys\\<rbrakk>\n    \\<Longrightarrow> set_s_kernel s_kernel' \\<subseteq> valid_keys", "by(induction events arbitrary: parties' rule: rev_induct)\n    (auto 4 3 simp add: split_def foldl_spmf_append in_set_spmf_poke dest: bspec)"], ["", "subsection \\<open>Defining the adversary interface\\<close>"], ["", "fun iface_adv :: \"('key state, iadv, oadv) oracle'\"\n  where\n   \"iface_adv state _ = return_spmf (Out_Adversary, state)\""], ["", "subsection \\<open>Defining the user interfaces\\<close>"], ["", "context\nbegin"], ["", "private"], ["", "fun iface_usr_func :: \"party \\<Rightarrow> _ \\<Rightarrow> _ \\<Rightarrow> 'inp \\<Rightarrow> ('wrap_key \\<times> 'key state) spmf\"\n  where\n    \"iface_usr_func party wrap (State_Store key, parties) inp = \n      (if party \\<in> parties then\n        return_spmf (wrap key, State_Store key, parties)\n      else\n        return_pmf None)\"\n  | \"iface_usr_func _ _ _ _ = return_pmf None\""], ["", "abbreviation iface_alice :: \"('key state, iusr_alice, 'key ousr_alice) oracle'\"\n  where\n    \"iface_alice \\<equiv> iface_usr_func Alice Out_Alice\""], ["", "abbreviation iface_bob :: \"('key state, iusr_bob, 'key ousr_bob) oracle'\"\n  where\n    \"iface_bob \\<equiv> iface_usr_func Bob Out_Bob\""], ["", "abbreviation iface_usr :: \"('key state, iusr, 'key ousr) oracle'\"\n  where\n    \"iface_usr \\<equiv> plus_oracle iface_alice iface_bob\""], ["", "lemma in_set_iface_usr_func [simp]:\n  \"x \\<in> set_spmf (iface_usr_func party wrap state inp) \\<longleftrightarrow>\n   (\\<exists>key parties. state = (State_Store key, parties) \\<and> party \\<in> parties \\<and> x = (wrap key, State_Store key, parties))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set_spmf (iface_usr_func party wrap state inp)) =\n    (\\<exists>key parties.\n        state = (State_Store key, parties) \\<and>\n        party \\<in> parties \\<and> x = (wrap key, State_Store key, parties))", "by(cases \"(party, wrap, state, inp)\" rule: iface_usr_func.cases) auto"], ["", "end"], ["", "subsection \\<open>Defining the Fuse Resource\\<close>"], ["", "primcorec core :: \"('key state, event, iadv, iusr, oadv,'key ousr) core\" \n  where\n    \"cpoke core = poke\"\n  | \"cfunc_adv core = iface_adv\"\n  | \"cfunc_usr core = iface_usr\""], ["", "sublocale fused_resource core \"(PState_Store, {})\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "subsubsection \\<open>Lemma showing that the resulting resource is well-typed\\<close>"], ["", "lemma WT_core [WT_intro]: \n  \"WT_core \\<I>_full (\\<I>_uniform UNIV (Out_Alice ` valid_keys) \\<oplus>\\<^sub>\\<I> \\<I>_uniform UNIV (Out_Bob ` valid_keys))\n     (pred_prod (pred_s_kernel (\\<lambda>key. key \\<in> valid_keys)) (\\<lambda>_. True)) core\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WT_core \\<I>_full\n     (\\<I>_uniform UNIV (Out_Alice ` valid_keys) \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform UNIV (Out_Bob ` valid_keys))\n     (pred_prod (pred_s_kernel (\\<lambda>key. key \\<in> valid_keys))\n       (\\<lambda>_. True))\n     core", "apply (rule WT_core.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s e s'.\n       \\<lbrakk>s' \\<in> set_spmf (cpoke core s e);\n        pred_prod (pred_s_kernel (\\<lambda>key. key \\<in> valid_keys))\n         (\\<lambda>_. True) s\\<rbrakk>\n       \\<Longrightarrow> pred_prod\n                          (pred_s_kernel\n                            (\\<lambda>key. key \\<in> valid_keys))\n                          (\\<lambda>_. True) s'\n 2. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (cfunc_adv core s x);\n        x \\<in> outs_\\<I> \\<I>_full;\n        pred_prod (pred_s_kernel (\\<lambda>key. key \\<in> valid_keys))\n         (\\<lambda>_. True) s\\<rbrakk>\n       \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_full x \\<and>\n                         pred_prod\n                          (pred_s_kernel\n                            (\\<lambda>key. key \\<in> valid_keys))\n                          (\\<lambda>_. True) s'\n 3. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (cfunc_usr core s x);\n        x \\<in> outs_\\<I>\n                 (\\<I>_uniform UNIV\n                   (Out_Alice ` valid_keys) \\<oplus>\\<^sub>\\<I>\n                  \\<I>_uniform UNIV (Out_Bob ` valid_keys));\n        pred_prod (pred_s_kernel (\\<lambda>key. key \\<in> valid_keys))\n         (\\<lambda>_. True) s\\<rbrakk>\n       \\<Longrightarrow> y \\<in> responses_\\<I>\n                                  (\\<I>_uniform UNIV\n                                    (Out_Alice `\n                                     valid_keys) \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_uniform UNIV (Out_Bob ` valid_keys))\n                                  x \\<and>\n                         pred_prod\n                          (pred_s_kernel\n                            (\\<lambda>key. key \\<in> valid_keys))\n                          (\\<lambda>_. True) s'", "subgoal for s e s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s' \\<in> set_spmf (cpoke core s e);\n     pred_prod (pred_s_kernel (\\<lambda>key. key \\<in> valid_keys))\n      (\\<lambda>_. True) s\\<rbrakk>\n    \\<Longrightarrow> pred_prod\n                       (pred_s_kernel (\\<lambda>key. key \\<in> valid_keys))\n                       (\\<lambda>_. True) s'", "by(cases \"(s, e)\" rule: poke.cases)(auto split: if_split_asm simp add: set_spmf_of_set)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (cfunc_adv core s x);\n        x \\<in> outs_\\<I> \\<I>_full;\n        pred_prod (pred_s_kernel (\\<lambda>key. key \\<in> valid_keys))\n         (\\<lambda>_. True) s\\<rbrakk>\n       \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_full x \\<and>\n                         pred_prod\n                          (pred_s_kernel\n                            (\\<lambda>key. key \\<in> valid_keys))\n                          (\\<lambda>_. True) s'\n 2. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (cfunc_usr core s x);\n        x \\<in> outs_\\<I>\n                 (\\<I>_uniform UNIV\n                   (Out_Alice ` valid_keys) \\<oplus>\\<^sub>\\<I>\n                  \\<I>_uniform UNIV (Out_Bob ` valid_keys));\n        pred_prod (pred_s_kernel (\\<lambda>key. key \\<in> valid_keys))\n         (\\<lambda>_. True) s\\<rbrakk>\n       \\<Longrightarrow> y \\<in> responses_\\<I>\n                                  (\\<I>_uniform UNIV\n                                    (Out_Alice `\n                                     valid_keys) \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_uniform UNIV (Out_Bob ` valid_keys))\n                                  x \\<and>\n                         pred_prod\n                          (pred_s_kernel\n                            (\\<lambda>key. key \\<in> valid_keys))\n                          (\\<lambda>_. True) s'", "by auto"], ["", "lemma WT_fuse [WT_intro]: \n  assumes [WT_intro]: \"WT_rest \\<I>_adv_rest \\<I>_usr_rest I_rest rest\"\n  shows \"(\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I> ((\\<I>_uniform UNIV (Out_Alice ` valid_keys) \\<oplus>\\<^sub>\\<I> \\<I>_uniform UNIV (Out_Bob ` valid_keys)) \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest) \\<turnstile>res resource rest \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n    ((\\<I>_uniform UNIV (Out_Alice ` valid_keys) \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform UNIV (Out_Bob ` valid_keys)) \\<oplus>\\<^sub>\\<I>\n     \\<I>_usr_rest) \n    \\<turnstile>res resource rest \\<surd>", "by(rule WT_intro)+ simp"], ["", "end"], ["", "end"]]}