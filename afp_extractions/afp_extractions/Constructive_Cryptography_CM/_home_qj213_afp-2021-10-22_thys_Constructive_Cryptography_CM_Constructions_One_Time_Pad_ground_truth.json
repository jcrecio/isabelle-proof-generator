{"file_name": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography_CM/Constructions/One_Time_Pad.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography_CM", "problem_names": ["lemma sec_party_of_key_party_simps [simp]:\n  \"sec_party_of_key_party key.Alice = sec.Alice\"\n  \"sec_party_of_key_party key.Bob = sec.Bob\"", "lemma sec_party_of_key_party_eq_simps [simp]:\n  \"sec_party_of_key_party p = sec.Alice \\<longleftrightarrow> p = key.Alice\"\n  \"sec_party_of_key_party p = sec.Bob \\<longleftrightarrow> p = key.Bob\"", "lemma key_case_party_collapse [simp]: \"key.case_party x x p = x\"", "lemma sec_case_party_collapse [simp]: \"sec.case_party x x p = x\"", "lemma Alice_in_sec_party_of_key_party [simp]:\n  \"sec.Alice \\<in> sec_party_of_key_party ` P \\<longleftrightarrow> key.Alice \\<in> P\"", "lemma Bob_in_sec_party_of_key_party [simp]:\n  \"sec.Bob \\<in> sec_party_of_key_party ` P \\<longleftrightarrow> key.Bob \\<in> P\"", "lemma case_sec_party_of_key_party [simp]: \"sec.case_party a b (sec_party_of_key_party x) = key.case_party a b x\"", "lemma attach_ideal: \"ideal_resource = RES (fused_resource.fuse ideal_core' ideal_rest') (ideal_s_core', ideal_s_rest')\"", "lemma WT_callee_real1: \"((\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<oplus>\\<^sub>\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)) \\<oplus>\\<^sub>\\<I> ((\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<oplus>\\<^sub>\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)) \\<turnstile>c \n  (key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest) s \\<surd>\"", "lemma WT_callee_real2: \"(\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<oplus>\\<^sub>\\<I> (((\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<oplus>\\<^sub>\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)) \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<turnstile>c\n  fused_resource.fuse (parallel_core key.core auth.core) (parallel_rest key_rest auth_rest) s \\<surd>\"", "lemma attach_real: \"real_resource = RES (fused_resource.fuse real_core' real_rest') (real_s_core', real_s_rest')\"", "lemma trace_eq_core: \"trace_core_eq ideal_core' real_core' \n  UNIV (UNIV <+> UNIV <+> UNIV <+> (auth.Inp_Fedit ` carrier \\<L>)) ((sec.Inp_Send ` carrier \\<L>) <+> UNIV) \n  (return_spmf ideal_s_core') (return_spmf real_s_core')\"", "lemma invar_ideal_s_core' [simp]: \"invar_ideal' ideal_s_core'\"", "lemma invar_real_s_core' [simp]: \"invar_real' real_s_core'\"", "lemma WT_ideal_core' [WT_intro]: \"WT_core \\<I>_adv_core \\<I>_usr_core invar_ideal' ideal_core'\"", "lemma WT_ideal_rest' [WT_intro]:\n  assumes \"WT_rest \\<I>_adv_restk \\<I>_usr_restk I_key_rest key_rest\"\n    and \"WT_rest \\<I>_adv_resta \\<I>_usr_resta I_auth_rest auth_rest\"\n  shows \"WT_rest (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta) (\\<I>_usr_restk \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta) (\\<lambda>(_, s_rest). pred_prod I_key_rest I_auth_rest s_rest) ideal_rest'\"", "lemma WT_real_core' [WT_intro]: \"WT_core \\<I>_adv_core \\<I>_usr_core invar_real' real_core'\"", "lemma trace_eq_sec: \n    fixes \\<I>_adv_restk \\<I>_adv_resta \\<I>_usr_restk \\<I>_usr_resta \n  defines \"outs_adv \\<equiv> (UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>) <+> outs_\\<I> (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta)\"\n      and \"outs_usr \\<equiv> (sec.Inp_Send ` carrier \\<L> <+> UNIV) <+> outs_\\<I> (\\<I>_usr_restk \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta)\"\n  assumes WT_key [WT_intro]: \"WT_rest \\<I>_adv_restk \\<I>_usr_restk I_key_rest key_rest\" \n      and WT_auth [WT_intro]: \"WT_rest \\<I>_adv_resta \\<I>_usr_resta I_auth_rest auth_rest\"\n    shows \"(outs_adv <+> outs_usr) \\<turnstile>\\<^sub>C fused_resource.fuse ideal_core' ideal_rest' ((ideal_s_core', ideal_s_rest')) \\<approx> \n      fused_resource.fuse real_core' real_rest' ((real_s_core', real_s_rest'))\"", "lemma connect[unfolded \\<I>_adv_core_def \\<I>_usr_core_def]:\n    fixes \\<I>_adv_restk \\<I>_adv_resta \\<I>_usr_restk \\<I>_usr_resta \n  defines \"\\<I> \\<equiv> (\\<I>_adv_core \\<oplus>\\<^sub>\\<I> (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta)) \\<oplus>\\<^sub>\\<I> (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> (\\<I>_usr_restk \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta))\"\n  assumes [WT_intro]: \"WT_rest \\<I>_adv_restk \\<I>_usr_restk I_key_rest key_rest\" \n      and [WT_intro]: \"WT_rest \\<I>_adv_resta \\<I>_usr_resta I_auth_rest auth_rest\"\n      and \"exception_\\<I> \\<I> \\<turnstile>g D \\<surd>\"\n    shows \"connect D (obsf_resource ideal_resource) = connect D (obsf_resource real_resource)\"", "lemma WT_enc_callee [WT_intro]:\n  \"\\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV, \\<I>_uniform UNIV (key.Out_Alice ` carrier \\<L>) \\<oplus>\\<^sub>\\<I>  \\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV \\<turnstile>\\<^sub>C CNV enc_callee () \\<surd>\"", "lemma WT_dec_callee [WT_intro]:\n  \"\\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>), \\<I>_uniform UNIV (key.Out_Bob ` carrier \\<L>) \\<oplus>\\<^sub>\\<I> \\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>) \\<turnstile>\\<^sub>C CNV dec_callee () \\<surd>\"", "lemma pfinite_enc_callee [pfinite_intro]: \n   \"pfinite_converter (\\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV) (\\<I>_uniform UNIV (key.Out_Alice ` carrier \\<L>) \\<oplus>\\<^sub>\\<I> \\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV) (CNV enc_callee ())\"", "lemma pfinite_dec_callee [pfinite_intro]:\n  \"pfinite_converter (\\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>)) (\\<I>_uniform UNIV (key.Out_Bob ` carrier \\<L>) \\<oplus>\\<^sub>\\<I> \\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>)) (CNV dec_callee ())\"", "theorem secure:\n  defines \"\\<I>_real \\<equiv> ((\\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_uniform (sec.Inp_Fedit ` (carrier \\<L>)) UNIV))) \\<oplus>\\<^sub>\\<I> (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta))\" \n      and \"\\<I>_common_core \\<equiv> \\<I>_uniform (sec.Inp_Send ` (carrier \\<L>)) UNIV \\<oplus>\\<^sub>\\<I> \\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>)\"\n      and \"\\<I>_common_rest \\<equiv> \\<I>_usr_restk \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta\"\n      and \"\\<I>_ideal \\<equiv> (\\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_uniform (sec.Inp_Fedit ` (carrier \\<L>)) UNIV)) \\<oplus>\\<^sub>\\<I> (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta)\" \n    shows \"constructive_security_obsf (real_resource TYPE(_) TYPE(_) key_rest auth_rest) (sec.resource (ideal_rest key_rest auth_rest)) (sim |\\<^sub>= 1\\<^sub>C) \\<I>_real \\<I>_ideal (\\<I>_common_core \\<oplus>\\<^sub>\\<I> \\<I>_common_rest) \\<A> 0\"", "theorem secure':\n  defines \"\\<I>_real \\<equiv> \\<lambda>\\<eta>. ((\\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_uniform (sec.Inp_Fedit ` (carrier (\\<L> \\<eta>))) UNIV))) \\<oplus>\\<^sub>\\<I> (\\<I>_adv_restk \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta \\<eta>))\"\n      and \"\\<I>_common \\<equiv> \\<lambda>\\<eta>. ((\\<I>_uniform (sec.Inp_Send ` (carrier (\\<L> \\<eta>))) UNIV \\<oplus>\\<^sub>\\<I> \\<I>_uniform UNIV (sec.Out_Recv ` carrier (\\<L> \\<eta>))) \\<oplus>\\<^sub>\\<I> (\\<I>_usr_restk \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta \\<eta>))\"\n      and \"\\<I>_ideal \\<equiv> \\<lambda>\\<eta>. (\\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_uniform (sec.Inp_Fedit ` (carrier (\\<L> \\<eta>))) UNIV)) \\<oplus>\\<^sub>\\<I> (\\<I>_adv_restk \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta \\<eta>)\" \n    shows \"constructive_security_obsf' (real_resource' key_rest auth_rest) (ideal_resource' key_rest auth_rest) sim' \\<I>_real \\<I>_ideal \\<I>_common \\<A>\""], "translations": [["", "lemma sec_party_of_key_party_simps [simp]:\n  \"sec_party_of_key_party key.Alice = sec.Alice\"\n  \"sec_party_of_key_party key.Bob = sec.Bob\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sec_party_of_key_party key.Alice = sec.Alice &&&\n    sec_party_of_key_party key.Bob = sec.Bob", "by(simp_all add: sec_party_of_key_party_def)"], ["", "lemma sec_party_of_key_party_eq_simps [simp]:\n  \"sec_party_of_key_party p = sec.Alice \\<longleftrightarrow> p = key.Alice\"\n  \"sec_party_of_key_party p = sec.Bob \\<longleftrightarrow> p = key.Bob\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sec_party_of_key_party p = sec.Alice) = (p = key.Alice) &&&\n    (sec_party_of_key_party p = sec.Bob) = (p = key.Bob)", "by(simp_all add: sec_party_of_key_party_def split: key.party.split)"], ["", "lemma key_case_party_collapse [simp]: \"key.case_party x x p = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case p of key.Alice \\<Rightarrow> x | _ \\<Rightarrow> x) = x", "by(simp split: key.party.split)"], ["", "lemma sec_case_party_collapse [simp]: \"sec.case_party x x p = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case p of sec.Alice \\<Rightarrow> x | _ \\<Rightarrow> x) = x", "by(simp split: sec.party.split)"], ["", "lemma Alice_in_sec_party_of_key_party [simp]:\n  \"sec.Alice \\<in> sec_party_of_key_party ` P \\<longleftrightarrow> key.Alice \\<in> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sec.Alice \\<in> sec_party_of_key_party ` P) = (key.Alice \\<in> P)", "by(auto simp add: sec_party_of_key_party_def split: key.party.splits)"], ["", "lemma Bob_in_sec_party_of_key_party [simp]:\n  \"sec.Bob \\<in> sec_party_of_key_party ` P \\<longleftrightarrow> key.Bob \\<in> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sec.Bob \\<in> sec_party_of_key_party ` P) = (key.Bob \\<in> P)", "by(auto simp add: sec_party_of_key_party_def split: key.party.splits)"], ["", "lemma case_sec_party_of_key_party [simp]: \"sec.case_party a b (sec_party_of_key_party x) = key.case_party a b x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case sec_party_of_key_party x of sec.Alice \\<Rightarrow> a\n     | sec.Bob \\<Rightarrow> b) =\n    (case x of key.Alice \\<Rightarrow> a | key.Bob \\<Rightarrow> b)", "by(simp add: sec_party_of_key_party_def split: sec.party.split key.party.split)"], ["", "subsection \\<open>Defining Ideal and Real constructions\\<close>"], ["", "context \n  fixes \n    key_rest :: \"('key_s_rest, key.event, 'key_iadv_rest, 'key_iusr_rest, 'key_oadv_rest, 'key_ousr_rest) rest_wstate\" and\n    auth_rest :: \"('auth_s_rest, auth.event, 'auth_iadv_rest, 'auth_iusr_rest, 'auth_oadv_rest, 'auth_ousr_rest) rest_wstate\"\nbegin"], ["", "definition ideal_rest \n  where\n    \"ideal_rest \\<equiv> translate_rest einit etran (parallel_rest key_rest auth_rest)\""], ["", "definition ideal_resource \n  where\n    \"ideal_resource \\<equiv> (sim |\\<^sub>= 1\\<^sub>C) |\\<^sub>= 1\\<^sub>C |\\<^sub>= 1\\<^sub>C  \\<rhd> (sec.resource ideal_rest)\""], ["", "definition real_resource \n  where\n    \"real_resource \\<equiv> attach_c1f22_c1f22 (CNV enc_callee ()) (CNV dec_callee ()) (key.resource key_rest) (auth.resource auth_rest)\""], ["", "subsection \\<open>Wiring and simplifying the Ideal construction\\<close>"], ["", "definition ideal_s_core' :: \"((_ \\<times> 'msg astate \\<times> _) \\<times> _) \\<times> estate \\<times> 'msg sec.state\"\n  where\n    \"ideal_s_core' \\<equiv> ((((), None, ()), ()), (False, {}), sec.State_Void, {})\""], ["", "definition ideal_s_rest' :: \"_ \\<times> 'key_s_rest \\<times> 'auth_s_rest\"\n  where\n    \"ideal_s_rest' \\<equiv> (((), ()), rinit key_rest, rinit auth_rest)\""], ["", "primcorec ideal_core' :: \"(((unit \\<times> _ \\<times> unit) \\<times> unit) \\<times>  _,  _, key.iadv + _, _, _, _) core\"\n  where\n    \"cpoke ideal_core' = (\\<lambda>(s_advusr, s_event, s_core) event. do {\n        (events, s_event') \\<leftarrow> (etran s_event event);\n        s_core' \\<leftarrow> foldl_spmf sec.poke (return_spmf s_core) events;\n        return_spmf (s_advusr, s_event', s_core')\n    })\"\n  | \"cfunc_adv ideal_core' = (\\<lambda>((s_adv, s_usr), s_core) iadv.\n      let handle_l = (\\<lambda>_. Done (Inl key.Out_Adversary, s_adv)) in\n      let handle_r = (\\<lambda>qr. map_gpv (map_prod Inr id) id ((1\\<^sub>I \\<ddagger>\\<^sub>I look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I) s_adv qr)) in\n      map_spmf \n        (\\<lambda>((oadv, s_adv'), s_core'). (oadv, (s_adv', s_usr), s_core'))\n        (exec_gpv \\<dagger>sec.iface_adv (case_sum handle_l handle_r iadv) s_core))\"\n  | \"cfunc_usr ideal_core' = \\<dagger>\\<dagger>sec.iface_usr\""], ["", "primcorec ideal_rest' :: \"((unit \\<times> unit) \\<times> _, _, _, _, _, _, _) rest_scheme\"\n  where\n    \"rinit ideal_rest' = (((), ()), rinit key_rest, rinit auth_rest)\"\n  | \"rfunc_adv ideal_rest' = \\<dagger>(parallel_eoracle (rfunc_adv key_rest) (rfunc_adv auth_rest))\"\n  | \"rfunc_usr ideal_rest' = \\<dagger>(parallel_eoracle (rfunc_usr key_rest) (rfunc_usr auth_rest))\""], ["", "subsubsection \\<open>The ideal attachment lemma\\<close>"], ["", "lemma attach_ideal: \"ideal_resource = RES (fused_resource.fuse ideal_core' ideal_rest') (ideal_s_core', ideal_s_rest')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal_resource =\n    RES (fused_resource.fuse ideal_core' ideal_rest')\n     (ideal_s_core', ideal_s_rest')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ideal_resource =\n    RES (fused_resource.fuse ideal_core' ideal_rest')\n     (ideal_s_core', ideal_s_rest')", "have fact1: \"ideal_rest' = attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ())) (parallel_rest key_rest auth_rest)\"  (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal_rest' =\n    attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ideal_rest' =\n    attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest)", "have \"rinit ?L = rinit ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rinit ideal_rest' =\n    rinit\n     (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n       (parallel_rest key_rest auth_rest))", "by simp"], ["proof (state)\nthis:\n  rinit ideal_rest' =\n  rinit\n   (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest))\n\ngoal (1 subgoal):\n 1. ideal_rest' =\n    attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest)", "moreover"], ["proof (state)\nthis:\n  rinit ideal_rest' =\n  rinit\n   (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest))\n\ngoal (1 subgoal):\n 1. ideal_rest' =\n    attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest)", "have \"rfunc_adv ?L = rfunc_adv ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rfunc_adv ideal_rest' =\n    rfunc_adv\n     (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n       (parallel_rest key_rest auth_rest))", "unfolding attach_rest_id_oracle_adv parallel_eoracle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rfunc_adv ideal_rest' =\n    (\\<lambda>(s_cnv, s_core) q.\n        map_spmf (\\<lambda>(out, s_core'). (out, s_cnv, s_core'))\n         (rfunc_adv (parallel_rest key_rest auth_rest) s_core q))", "by (simp add: extend_state_oracle_def)"], ["proof (state)\nthis:\n  rfunc_adv ideal_rest' =\n  rfunc_adv\n   (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest))\n\ngoal (1 subgoal):\n 1. ideal_rest' =\n    attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest)", "moreover"], ["proof (state)\nthis:\n  rfunc_adv ideal_rest' =\n  rfunc_adv\n   (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest))\n\ngoal (1 subgoal):\n 1. ideal_rest' =\n    attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest)", "have \"rfunc_usr ?L = rfunc_usr ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rfunc_usr ideal_rest' =\n    rfunc_usr\n     (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n       (parallel_rest key_rest auth_rest))", "unfolding attach_rest_id_oracle_usr parallel_eoracle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rfunc_usr ideal_rest' =\n    (\\<lambda>(s_cnv, s_core) q.\n        map_spmf (\\<lambda>(out, s_core'). (out, s_cnv, s_core'))\n         (rfunc_usr (parallel_rest key_rest auth_rest) s_core q))", "by (simp add: extend_state_oracle_def)"], ["proof (state)\nthis:\n  rfunc_usr ideal_rest' =\n  rfunc_usr\n   (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest))\n\ngoal (1 subgoal):\n 1. ideal_rest' =\n    attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest)", "ultimately"], ["proof (chain)\npicking this:\n  rinit ideal_rest' =\n  rinit\n   (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest))\n  rfunc_adv ideal_rest' =\n  rfunc_adv\n   (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest))\n  rfunc_usr ideal_rest' =\n  rfunc_usr\n   (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest))", "show ?thesis"], ["proof (prove)\nusing this:\n  rinit ideal_rest' =\n  rinit\n   (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest))\n  rfunc_adv ideal_rest' =\n  rfunc_adv\n   (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest))\n  rfunc_usr ideal_rest' =\n  rfunc_usr\n   (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest))\n\ngoal (1 subgoal):\n 1. ideal_rest' =\n    attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest)", "by (coinduction) blast"], ["proof (state)\nthis:\n  ideal_rest' =\n  attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n   (parallel_rest key_rest auth_rest)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ideal_rest' =\n  attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n   (parallel_rest key_rest auth_rest)\n\ngoal (1 subgoal):\n 1. ideal_resource =\n    RES (fused_resource.fuse ideal_core' ideal_rest')\n     (ideal_s_core', ideal_s_rest')", "have fact2: \"ideal_core' =\n    (let handle_l = (\\<lambda>s ql. Generative_Probabilistic_Value.Done (Inl key.Out_Adversary, s)) in\n     let handle_r = (\\<lambda>s qr. map_gpv (map_prod Inr id) id ((1\\<^sub>I \\<ddagger>\\<^sub>I look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I) s qr)) in\n     let tcore = translate_core etran sec.core in\n    attach_core (\\<lambda>s. case_sum (handle_l s) (handle_r s)) 1\\<^sub>I tcore)\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal_core' =\n    (let handle_l =\n           \\<lambda>s ql.\n              Generative_Probabilistic_Value.Done\n               (Inl key.Out_Adversary, s);\n         handle_r =\n           \\<lambda>s qr.\n              map_gpv (map_prod Inr id) id\n               ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                 look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                 s qr)\n     in Let (translate_core etran sec.core)\n         (attach_core (\\<lambda>s. case_sum (handle_l s) (handle_r s))\n           1\\<^sub>I))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ideal_core' =\n    (let handle_l =\n           \\<lambda>s ql.\n              Generative_Probabilistic_Value.Done\n               (Inl key.Out_Adversary, s);\n         handle_r =\n           \\<lambda>s qr.\n              map_gpv (map_prod Inr id) id\n               ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                 look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                 s qr)\n     in Let (translate_core etran sec.core)\n         (attach_core (\\<lambda>s. case_sum (handle_l s) (handle_r s))\n           1\\<^sub>I))", "have \"cpoke ?L = cpoke ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cpoke ideal_core' =\n    cpoke\n     (let handle_l =\n            \\<lambda>s ql.\n               Generative_Probabilistic_Value.Done\n                (Inl key.Out_Adversary, s);\n          handle_r =\n            \\<lambda>s qr.\n               map_gpv (map_prod Inr id) id\n                ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                  look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                  s qr)\n      in Let (translate_core etran sec.core)\n          (attach_core (\\<lambda>s. case_sum (handle_l s) (handle_r s))\n            1\\<^sub>I))", "by (simp add: split_def map_spmf_conv_bind_spmf)"], ["proof (state)\nthis:\n  cpoke ideal_core' =\n  cpoke\n   (let handle_l =\n          \\<lambda>s ql.\n             Generative_Probabilistic_Value.Done (Inl key.Out_Adversary, s);\n        handle_r =\n          \\<lambda>s qr.\n             map_gpv (map_prod Inr id) id\n              ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                s qr)\n    in Let (translate_core etran sec.core)\n        (attach_core (\\<lambda>s. case_sum (handle_l s) (handle_r s))\n          1\\<^sub>I))\n\ngoal (1 subgoal):\n 1. ideal_core' =\n    (let handle_l =\n           \\<lambda>s ql.\n              Generative_Probabilistic_Value.Done\n               (Inl key.Out_Adversary, s);\n         handle_r =\n           \\<lambda>s qr.\n              map_gpv (map_prod Inr id) id\n               ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                 look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                 s qr)\n     in Let (translate_core etran sec.core)\n         (attach_core (\\<lambda>s. case_sum (handle_l s) (handle_r s))\n           1\\<^sub>I))", "moreover"], ["proof (state)\nthis:\n  cpoke ideal_core' =\n  cpoke\n   (let handle_l =\n          \\<lambda>s ql.\n             Generative_Probabilistic_Value.Done (Inl key.Out_Adversary, s);\n        handle_r =\n          \\<lambda>s qr.\n             map_gpv (map_prod Inr id) id\n              ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                s qr)\n    in Let (translate_core etran sec.core)\n        (attach_core (\\<lambda>s. case_sum (handle_l s) (handle_r s))\n          1\\<^sub>I))\n\ngoal (1 subgoal):\n 1. ideal_core' =\n    (let handle_l =\n           \\<lambda>s ql.\n              Generative_Probabilistic_Value.Done\n               (Inl key.Out_Adversary, s);\n         handle_r =\n           \\<lambda>s qr.\n              map_gpv (map_prod Inr id) id\n               ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                 look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                 s qr)\n     in Let (translate_core etran sec.core)\n         (attach_core (\\<lambda>s. case_sum (handle_l s) (handle_r s))\n           1\\<^sub>I))", "have \"cfunc_adv ?L = cfunc_adv ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfunc_adv ideal_core' =\n    cfunc_adv\n     (let handle_l =\n            \\<lambda>s ql.\n               Generative_Probabilistic_Value.Done\n                (Inl key.Out_Adversary, s);\n          handle_r =\n            \\<lambda>s qr.\n               map_gpv (map_prod Inr id) id\n                ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                  look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                  s qr)\n      in Let (translate_core etran sec.core)\n          (attach_core (\\<lambda>s. case_sum (handle_l s) (handle_r s))\n            1\\<^sub>I))", "unfolding attach_core_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cfunc_adv ideal_core' =\n    cfunc_adv\n     (let handle_l =\n            \\<lambda>s ql.\n               Generative_Probabilistic_Value.Done\n                (Inl key.Out_Adversary, s);\n          handle_r =\n            \\<lambda>s qr.\n               map_gpv (map_prod Inr id) id\n                ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                  look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                  s qr);\n          tcore = translate_core etran sec.core\n      in corec_core\n          (\\<lambda>x (s_advusr, s_core) event.\n              map_spmf (Pair s_advusr) (cpoke tcore s_core event))\n          (\\<lambda>x ((s_adv, s_usr), s_core) iadv.\n              map_spmf\n               (\\<lambda>((oadv, s_adv'), s_core').\n                   (oadv, (s_adv', s_usr), s_core'))\n               (exec_gpv (cfunc_adv tcore)\n                 (case iadv of Inl x \\<Rightarrow> handle_l s_adv x\n                  | Inr x \\<Rightarrow> handle_r s_adv x)\n                 s_core))\n          (\\<lambda>x ((s_adv, s_usr), s_core) iusr.\n              map_spmf\n               (\\<lambda>((ousr, s_usr'), s_core').\n                   (ousr, (s_adv, s_usr'), s_core'))\n               (exec_gpv (cfunc_usr tcore) (1\\<^sub>I s_usr iusr) s_core))\n          ())", "by (simp add: split_def)"], ["proof (state)\nthis:\n  cfunc_adv ideal_core' =\n  cfunc_adv\n   (let handle_l =\n          \\<lambda>s ql.\n             Generative_Probabilistic_Value.Done (Inl key.Out_Adversary, s);\n        handle_r =\n          \\<lambda>s qr.\n             map_gpv (map_prod Inr id) id\n              ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                s qr)\n    in Let (translate_core etran sec.core)\n        (attach_core (\\<lambda>s. case_sum (handle_l s) (handle_r s))\n          1\\<^sub>I))\n\ngoal (1 subgoal):\n 1. ideal_core' =\n    (let handle_l =\n           \\<lambda>s ql.\n              Generative_Probabilistic_Value.Done\n               (Inl key.Out_Adversary, s);\n         handle_r =\n           \\<lambda>s qr.\n              map_gpv (map_prod Inr id) id\n               ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                 look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                 s qr)\n     in Let (translate_core etran sec.core)\n         (attach_core (\\<lambda>s. case_sum (handle_l s) (handle_r s))\n           1\\<^sub>I))", "moreover"], ["proof (state)\nthis:\n  cfunc_adv ideal_core' =\n  cfunc_adv\n   (let handle_l =\n          \\<lambda>s ql.\n             Generative_Probabilistic_Value.Done (Inl key.Out_Adversary, s);\n        handle_r =\n          \\<lambda>s qr.\n             map_gpv (map_prod Inr id) id\n              ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                s qr)\n    in Let (translate_core etran sec.core)\n        (attach_core (\\<lambda>s. case_sum (handle_l s) (handle_r s))\n          1\\<^sub>I))\n\ngoal (1 subgoal):\n 1. ideal_core' =\n    (let handle_l =\n           \\<lambda>s ql.\n              Generative_Probabilistic_Value.Done\n               (Inl key.Out_Adversary, s);\n         handle_r =\n           \\<lambda>s qr.\n              map_gpv (map_prod Inr id) id\n               ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                 look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                 s qr)\n     in Let (translate_core etran sec.core)\n         (attach_core (\\<lambda>s. case_sum (handle_l s) (handle_r s))\n           1\\<^sub>I))", "have \"cfunc_usr ?L = cfunc_usr ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfunc_usr ideal_core' =\n    cfunc_usr\n     (let handle_l =\n            \\<lambda>s ql.\n               Generative_Probabilistic_Value.Done\n                (Inl key.Out_Adversary, s);\n          handle_r =\n            \\<lambda>s qr.\n               map_gpv (map_prod Inr id) id\n                ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                  look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                  s qr)\n      in Let (translate_core etran sec.core)\n          (attach_core (\\<lambda>s. case_sum (handle_l s) (handle_r s))\n            1\\<^sub>I))", "unfolding Let_def attach_core_id_oracle_usr"], ["proof (prove)\ngoal (1 subgoal):\n 1. cfunc_usr ideal_core' =\n    (\\<lambda>(s_cnv, s_core) q.\n        map_spmf (\\<lambda>(out, s_core'). (out, s_cnv, s_core'))\n         (cfunc_usr (translate_core etran sec.core) s_core q))", "by (clarsimp simp add: extend_state_oracle_def[symmetric])"], ["proof (state)\nthis:\n  cfunc_usr ideal_core' =\n  cfunc_usr\n   (let handle_l =\n          \\<lambda>s ql.\n             Generative_Probabilistic_Value.Done (Inl key.Out_Adversary, s);\n        handle_r =\n          \\<lambda>s qr.\n             map_gpv (map_prod Inr id) id\n              ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                s qr)\n    in Let (translate_core etran sec.core)\n        (attach_core (\\<lambda>s. case_sum (handle_l s) (handle_r s))\n          1\\<^sub>I))\n\ngoal (1 subgoal):\n 1. ideal_core' =\n    (let handle_l =\n           \\<lambda>s ql.\n              Generative_Probabilistic_Value.Done\n               (Inl key.Out_Adversary, s);\n         handle_r =\n           \\<lambda>s qr.\n              map_gpv (map_prod Inr id) id\n               ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                 look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                 s qr)\n     in Let (translate_core etran sec.core)\n         (attach_core (\\<lambda>s. case_sum (handle_l s) (handle_r s))\n           1\\<^sub>I))", "ultimately"], ["proof (chain)\npicking this:\n  cpoke ideal_core' =\n  cpoke\n   (let handle_l =\n          \\<lambda>s ql.\n             Generative_Probabilistic_Value.Done (Inl key.Out_Adversary, s);\n        handle_r =\n          \\<lambda>s qr.\n             map_gpv (map_prod Inr id) id\n              ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                s qr)\n    in Let (translate_core etran sec.core)\n        (attach_core (\\<lambda>s. case_sum (handle_l s) (handle_r s))\n          1\\<^sub>I))\n  cfunc_adv ideal_core' =\n  cfunc_adv\n   (let handle_l =\n          \\<lambda>s ql.\n             Generative_Probabilistic_Value.Done (Inl key.Out_Adversary, s);\n        handle_r =\n          \\<lambda>s qr.\n             map_gpv (map_prod Inr id) id\n              ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                s qr)\n    in Let (translate_core etran sec.core)\n        (attach_core (\\<lambda>s. case_sum (handle_l s) (handle_r s))\n          1\\<^sub>I))\n  cfunc_usr ideal_core' =\n  cfunc_usr\n   (let handle_l =\n          \\<lambda>s ql.\n             Generative_Probabilistic_Value.Done (Inl key.Out_Adversary, s);\n        handle_r =\n          \\<lambda>s qr.\n             map_gpv (map_prod Inr id) id\n              ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                s qr)\n    in Let (translate_core etran sec.core)\n        (attach_core (\\<lambda>s. case_sum (handle_l s) (handle_r s))\n          1\\<^sub>I))", "show ?thesis"], ["proof (prove)\nusing this:\n  cpoke ideal_core' =\n  cpoke\n   (let handle_l =\n          \\<lambda>s ql.\n             Generative_Probabilistic_Value.Done (Inl key.Out_Adversary, s);\n        handle_r =\n          \\<lambda>s qr.\n             map_gpv (map_prod Inr id) id\n              ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                s qr)\n    in Let (translate_core etran sec.core)\n        (attach_core (\\<lambda>s. case_sum (handle_l s) (handle_r s))\n          1\\<^sub>I))\n  cfunc_adv ideal_core' =\n  cfunc_adv\n   (let handle_l =\n          \\<lambda>s ql.\n             Generative_Probabilistic_Value.Done (Inl key.Out_Adversary, s);\n        handle_r =\n          \\<lambda>s qr.\n             map_gpv (map_prod Inr id) id\n              ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                s qr)\n    in Let (translate_core etran sec.core)\n        (attach_core (\\<lambda>s. case_sum (handle_l s) (handle_r s))\n          1\\<^sub>I))\n  cfunc_usr ideal_core' =\n  cfunc_usr\n   (let handle_l =\n          \\<lambda>s ql.\n             Generative_Probabilistic_Value.Done (Inl key.Out_Adversary, s);\n        handle_r =\n          \\<lambda>s qr.\n             map_gpv (map_prod Inr id) id\n              ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                s qr)\n    in Let (translate_core etran sec.core)\n        (attach_core (\\<lambda>s. case_sum (handle_l s) (handle_r s))\n          1\\<^sub>I))\n\ngoal (1 subgoal):\n 1. ideal_core' =\n    (let handle_l =\n           \\<lambda>s ql.\n              Generative_Probabilistic_Value.Done\n               (Inl key.Out_Adversary, s);\n         handle_r =\n           \\<lambda>s qr.\n              map_gpv (map_prod Inr id) id\n               ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                 look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                 s qr)\n     in Let (translate_core etran sec.core)\n         (attach_core (\\<lambda>s. case_sum (handle_l s) (handle_r s))\n           1\\<^sub>I))", "by (coinduction) blast"], ["proof (state)\nthis:\n  ideal_core' =\n  (let handle_l =\n         \\<lambda>s ql.\n            Generative_Probabilistic_Value.Done (Inl key.Out_Adversary, s);\n       handle_r =\n         \\<lambda>s qr.\n            map_gpv (map_prod Inr id) id\n             ((1\\<^sub>I \\<ddagger>\\<^sub>I\n               look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n               s qr)\n   in Let (translate_core etran sec.core)\n       (attach_core (\\<lambda>s. case_sum (handle_l s) (handle_r s))\n         1\\<^sub>I))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ideal_core' =\n  (let handle_l =\n         \\<lambda>s ql.\n            Generative_Probabilistic_Value.Done (Inl key.Out_Adversary, s);\n       handle_r =\n         \\<lambda>s qr.\n            map_gpv (map_prod Inr id) id\n             ((1\\<^sub>I \\<ddagger>\\<^sub>I\n               look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n               s qr)\n   in Let (translate_core etran sec.core)\n       (attach_core (\\<lambda>s. case_sum (handle_l s) (handle_r s))\n         1\\<^sub>I))\n\ngoal (1 subgoal):\n 1. ideal_resource =\n    RES (fused_resource.fuse ideal_core' ideal_rest')\n     (ideal_s_core', ideal_s_rest')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ideal_resource =\n    RES (fused_resource.fuse ideal_core' ideal_rest')\n     (ideal_s_core', ideal_s_rest')", "unfolding ideal_resource_def sec.resource_def sim_def ideal_rest_def ideal_s_core'_def ideal_s_rest'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((let look_converter = CNV look_callee None\n      in ldummy_converter (\\<lambda>_. key.Out_Adversary)\n          (1\\<^sub>C |\\<^sub>=\n           look_converter |\\<^sub>= 1\\<^sub>C)) |\\<^sub>=\n     1\\<^sub>C) |\\<^sub>=\n    1\\<^sub>C |\\<^sub>= 1\\<^sub>C \\<rhd>\n    RES (sec.fuse\n          (translate_rest (False, {}) etran\n            (parallel_rest key_rest auth_rest)))\n     ((sec.State_Void, {}),\n      rinit\n       (translate_rest (False, {}) etran\n         (parallel_rest key_rest auth_rest))) =\n    RES (fused_resource.fuse ideal_core' ideal_rest')\n     (((((), None, ()), ()), (False, {}), sec.State_Void, {}), ((), ()),\n      rinit key_rest, rinit auth_rest)", "apply(simp add: conv_callee_parallel_id_right[symmetric, where s'=\"()\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ldummy_converter (\\<lambda>_. key.Out_Adversary)\n      (1\\<^sub>C |\\<^sub>=\n       CNV (look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I) (None, ())) |\\<^sub>=\n     1\\<^sub>C) |\\<^sub>=\n    1\\<^sub>C |\\<^sub>= 1\\<^sub>C \\<rhd>\n    RES (sec.fuse\n          (translate_rest (False, {}) etran\n            (parallel_rest key_rest auth_rest)))\n     ((sec.State_Void, {}), (False, {}), rinit key_rest, rinit auth_rest) =\n    RES (fused_resource.fuse ideal_core' ideal_rest')\n     (((((), None, ()), ()), (False, {}), sec.State_Void, {}), ((), ()),\n      rinit key_rest, rinit auth_rest)", "apply(simp add: conv_callee_parallel_id_left[symmetric, where s=\"()\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ldummy_converter (\\<lambda>_. key.Out_Adversary)\n      (CNV (1\\<^sub>I \\<ddagger>\\<^sub>I\n            look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n        ((), None, ())) |\\<^sub>=\n     1\\<^sub>C) |\\<^sub>=\n    1\\<^sub>C |\\<^sub>= 1\\<^sub>C \\<rhd>\n    RES (sec.fuse\n          (translate_rest (False, {}) etran\n            (parallel_rest key_rest auth_rest)))\n     ((sec.State_Void, {}), (False, {}), rinit key_rest, rinit auth_rest) =\n    RES (fused_resource.fuse ideal_core' ideal_rest')\n     (((((), None, ()), ()), (False, {}), sec.State_Void, {}), ((), ()),\n      rinit key_rest, rinit auth_rest)", "apply(simp add: ldummy_converter_of_callee)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (CNV (\\<lambda>s q.\n             case q of\n             Inl ql \\<Rightarrow>\n               Generative_Probabilistic_Value.Done\n                (Inl key.Out_Adversary, s)\n             | Inr qr \\<Rightarrow>\n                 map_gpv (map_prod Inr id) id\n                  ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                    look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                    s qr))\n      ((), None, ()) |\\<^sub>=\n     1\\<^sub>C) |\\<^sub>=\n    1\\<^sub>C |\\<^sub>= 1\\<^sub>C \\<rhd>\n    RES (sec.fuse\n          (translate_rest (False, {}) etran\n            (parallel_rest key_rest auth_rest)))\n     ((sec.State_Void, {}), (False, {}), rinit key_rest, rinit auth_rest) =\n    RES (fused_resource.fuse ideal_core' ideal_rest')\n     (((((), None, ()), ()), (False, {}), sec.State_Void, {}), ((), ()),\n      rinit key_rest, rinit auth_rest)", "apply(subst fused_resource_move_translate[of _ einit etran])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (CNV (\\<lambda>s.\n             case_sum\n              (\\<lambda>ql.\n                  Generative_Probabilistic_Value.Done\n                   (Inl key.Out_Adversary, s))\n              (\\<lambda>qr.\n                  map_gpv (map_prod Inr id) id\n                   ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                     look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                     s qr)))\n      ((), None, ()) |\\<^sub>=\n     1\\<^sub>C) |\\<^sub>=\n    1\\<^sub>C |\\<^sub>= 1\\<^sub>C \\<rhd>\n    RES (apply_state_iso iso_swapar\n          (fused_resource.fuse (translate_core etran sec.core)\n            (parallel_rest key_rest auth_rest)))\n     ((sec.State_Void, {}), (False, {}), rinit key_rest, rinit auth_rest) =\n    RES (fused_resource.fuse ideal_core' ideal_rest')\n     (((((), None, ()), ()), (False, {}), sec.State_Void, {}), ((), ()),\n      rinit key_rest, rinit auth_rest)", "apply(simp add: resource_of_oracle_state_iso)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (CNV (\\<lambda>s.\n             case_sum\n              (\\<lambda>ql.\n                  Generative_Probabilistic_Value.Done\n                   (Inl key.Out_Adversary, s))\n              (\\<lambda>qr.\n                  map_gpv (map_prod Inr id) id\n                   ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                     look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                     s qr)))\n      ((), None, ()) |\\<^sub>=\n     1\\<^sub>C) |\\<^sub>=\n    1\\<^sub>C |\\<^sub>= 1\\<^sub>C \\<rhd>\n    RES (fused_resource.fuse (translate_core etran sec.core)\n          (parallel_rest key_rest auth_rest))\n     (snd iso_swapar\n       ((sec.State_Void, {}), (False, {}), rinit key_rest,\n        rinit auth_rest)) =\n    RES (fused_resource.fuse ideal_core' ideal_rest')\n     (((((), None, ()), ()), (False, {}), sec.State_Void, {}), ((), ()),\n      rinit key_rest, rinit auth_rest)", "apply(simp add: iso_swapar_def split_beta ideal_rest_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (CNV (\\<lambda>s.\n             case_sum\n              (\\<lambda>ql.\n                  Generative_Probabilistic_Value.Done\n                   (Inl key.Out_Adversary, s))\n              (\\<lambda>qr.\n                  map_gpv (map_prod Inr id) id\n                   ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                     look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                     s qr)))\n      ((), None, ()) |\\<^sub>=\n     1\\<^sub>C) |\\<^sub>=\n    1\\<^sub>C |\\<^sub>= 1\\<^sub>C \\<rhd>\n    RES (fused_resource.fuse (translate_core etran sec.core)\n          (parallel_rest key_rest auth_rest))\n     (((False, {}), sec.State_Void, {}), rinit key_rest, rinit auth_rest) =\n    RES (fused_resource.fuse ideal_core' ideal_rest')\n     (((((), None, ()), ()), (False, {}), sec.State_Void, {}), ((), ()),\n      rinit key_rest, rinit auth_rest)", "apply(subst (1 2 3) converter_of_callee_id_oracle[symmetric, of \"()\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (CNV (\\<lambda>s.\n             case_sum\n              (\\<lambda>ql.\n                  Generative_Probabilistic_Value.Done\n                   (Inl key.Out_Adversary, s))\n              (\\<lambda>qr.\n                  map_gpv (map_prod Inr id) id\n                   ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                     look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                     s qr)))\n      ((), None, ()) |\\<^sub>=\n     CNV 1\\<^sub>I ()) |\\<^sub>=\n    CNV 1\\<^sub>I () |\\<^sub>= CNV 1\\<^sub>I () \\<rhd>\n    RES (fused_resource.fuse (translate_core etran sec.core)\n          (parallel_rest key_rest auth_rest))\n     (((False, {}), sec.State_Void, {}), rinit key_rest, rinit auth_rest) =\n    RES (fused_resource.fuse ideal_core' ideal_rest')\n     (((((), None, ()), ()), (False, {}), sec.State_Void, {}), ((), ()),\n      rinit key_rest, rinit auth_rest)", "apply(subst attach_parallel_fuse'[where f_init=\"Pair ((), ())\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. RES (fused_resource.fuse\n          (attach_core\n            (\\<lambda>s.\n                case_sum\n                 (\\<lambda>ql.\n                     Generative_Probabilistic_Value.Done\n                      (Inl key.Out_Adversary, s))\n                 (\\<lambda>qr.\n                     map_gpv (map_prod Inr id) id\n                      ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                        look_callee \\<ddagger>\\<^sub>I 1\\<^sub>I)\n                        s qr)))\n            1\\<^sub>I (translate_core etran sec.core))\n          (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n            (parallel_rest key_rest auth_rest)))\n     (((((), None, ()), ()), (False, {}), sec.State_Void, {}), ((), ()),\n      rinit key_rest, rinit auth_rest) =\n    RES (fused_resource.fuse ideal_core' ideal_rest')\n     (((((), None, ()), ()), (False, {}), sec.State_Void, {}), ((), ()),\n      rinit key_rest, rinit auth_rest)", "apply(simp add: fact1[symmetric] fact2[symmetric, simplified Let_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ideal_resource =\n  RES (fused_resource.fuse ideal_core' ideal_rest')\n   (ideal_s_core', ideal_s_rest')\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Wiring and simplifying the Real construction\\<close>"], ["", "definition real_s_core' :: \"_ \\<times> 'msg key.state \\<times> 'msg auth.state\"\n  where\n    \"real_s_core' \\<equiv> (((), (), ()), (key.PState_Store, {}), (auth.State_Void, {}))\""], ["", "definition real_s_rest'\n  where\n    \"real_s_rest' \\<equiv> ideal_s_rest'\""], ["", "primcorec real_core' :: \"((unit \\<times> _) \\<times> _, _, _, _, _, _) core\"\n  where\n    \"cpoke real_core' = (\\<lambda>(s_advusr, s_core) event. \n      map_spmf (Pair s_advusr) (parallel_handler key.poke auth.poke s_core event))\"\n  | \"cfunc_adv real_core' = \\<dagger>(key.iface_adv \\<ddagger>\\<^sub>O auth.iface_adv)\"\n  | \"cfunc_usr real_core' = (\\<lambda>((s_adv, s_usr), s_core) iusr.\n      let handle_req = lsumr \\<circ> map_sum id (rsuml \\<circ> map_sum swap_sum id \\<circ> lsumr) \\<circ> rsuml in\n      let handle_ret = lsumr \\<circ> (map_sum id (rsuml \\<circ> (map_sum swap_sum id \\<circ> lsumr)) \\<circ> rsuml) in\n      map_spmf \n        (\\<lambda>((ousr, s_usr'), s_core'). (ousr, (s_adv, s_usr'), s_core'))\n        (exec_gpv \n          (key.iface_usr \\<ddagger>\\<^sub>O auth.iface_usr)\n          (map_gpv' id handle_req  handle_ret ((enc_callee \\<ddagger>\\<^sub>I dec_callee) s_usr iusr)) s_core))\""], ["", "definition real_rest'\n  where\n    \"real_rest' \\<equiv> ideal_rest'\""], ["", "subsubsection \\<open>The real attachment lemma\\<close>"], ["", "private"], ["", "lemma WT_callee_real1: \"((\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<oplus>\\<^sub>\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)) \\<oplus>\\<^sub>\\<I> ((\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<oplus>\\<^sub>\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)) \\<turnstile>c \n  (key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest) s \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<oplus>\\<^sub>\\<I>\n     (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n    ((\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<oplus>\\<^sub>\\<I>\n     (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)) \\<turnstile>c\n    (key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest) s \\<surd>", "apply(rule WT_calleeI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>call ret sa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                        ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)));\n        (ret, sa)\n        \\<in> set_spmf\n               ((key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest) s\n                 call)\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)))\n                                call", "apply(cases s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>call ret sa a b c.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                        ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)));\n        (ret, sa)\n        \\<in> set_spmf\n               ((key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest) s\n                 call);\n        s = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)))\n                                call", "apply(case_tac call)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>call ret sa a b c aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                        ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)));\n        (ret, sa)\n        \\<in> set_spmf\n               ((key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest) s\n                 call);\n        s = (a, b, c); call = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)))\n                                call\n 2. \\<And>call ret sa a b c ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                        ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)));\n        (ret, sa)\n        \\<in> set_spmf\n               ((key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest) s\n                 call);\n        s = (a, b, c); call = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)))\n                                call", "apply(rename_tac [!] x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>call ret sa a b c x.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                        ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)));\n        (ret, sa)\n        \\<in> set_spmf\n               ((key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest) s\n                 call);\n        s = (a, b, c); call = Inl x\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)))\n                                call\n 2. \\<And>call ret sa a b c x.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                        ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)));\n        (ret, sa)\n        \\<in> set_spmf\n               ((key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest) s\n                 call);\n        s = (a, b, c); call = Inr x\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)))\n                                call", "apply(case_tac [!] x)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>call ret sa a b c x aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                        ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)));\n        (ret, sa)\n        \\<in> set_spmf\n               ((key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest) s\n                 call);\n        s = (a, b, c); call = Inl x; x = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)))\n                                call\n 2. \\<And>call ret sa a b c x ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                        ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)));\n        (ret, sa)\n        \\<in> set_spmf\n               ((key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest) s\n                 call);\n        s = (a, b, c); call = Inl x; x = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)))\n                                call\n 3. \\<And>call ret sa a b c x aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                        ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)));\n        (ret, sa)\n        \\<in> set_spmf\n               ((key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest) s\n                 call);\n        s = (a, b, c); call = Inr x; x = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)))\n                                call\n 4. \\<And>call ret sa a b c x ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                        ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)));\n        (ret, sa)\n        \\<in> set_spmf\n               ((key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest) s\n                 call);\n        s = (a, b, c); call = Inr x; x = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)))\n                                call", "apply(rename_tac [!] y)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>call ret sa a b c x y.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                        ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)));\n        (ret, sa)\n        \\<in> set_spmf\n               ((key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest) s\n                 call);\n        s = (a, b, c); call = Inl x; x = Inl y\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)))\n                                call\n 2. \\<And>call ret sa a b c x y.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                        ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)));\n        (ret, sa)\n        \\<in> set_spmf\n               ((key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest) s\n                 call);\n        s = (a, b, c); call = Inl x; x = Inr y\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)))\n                                call\n 3. \\<And>call ret sa a b c x y.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                        ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)));\n        (ret, sa)\n        \\<in> set_spmf\n               ((key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest) s\n                 call);\n        s = (a, b, c); call = Inr x; x = Inl y\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)))\n                                call\n 4. \\<And>call ret sa a b c x y.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                        ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)));\n        (ret, sa)\n        \\<in> set_spmf\n               ((key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest) s\n                 call);\n        s = (a, b, c); call = Inr x; x = Inr y\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)))\n                                call", "apply(case_tac [!] y)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>call ret sa a b c x y aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                        ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)));\n        (ret, sa)\n        \\<in> set_spmf\n               ((key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest) s\n                 call);\n        s = (a, b, c); call = Inl x; x = Inl y; y = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)))\n                                call\n 2. \\<And>call ret sa a b c x y ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                        ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)));\n        (ret, sa)\n        \\<in> set_spmf\n               ((key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest) s\n                 call);\n        s = (a, b, c); call = Inl x; x = Inl y; y = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)))\n                                call\n 3. \\<And>call ret sa a b c x y aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                        ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)));\n        (ret, sa)\n        \\<in> set_spmf\n               ((key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest) s\n                 call);\n        s = (a, b, c); call = Inl x; x = Inr y; y = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)))\n                                call\n 4. \\<And>call ret sa a b c x y ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                        ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)));\n        (ret, sa)\n        \\<in> set_spmf\n               ((key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest) s\n                 call);\n        s = (a, b, c); call = Inl x; x = Inr y; y = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)))\n                                call\n 5. \\<And>call ret sa a b c x y aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                        ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)));\n        (ret, sa)\n        \\<in> set_spmf\n               ((key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest) s\n                 call);\n        s = (a, b, c); call = Inr x; x = Inl y; y = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)))\n                                call\n 6. \\<And>call ret sa a b c x y ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                        ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)));\n        (ret, sa)\n        \\<in> set_spmf\n               ((key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest) s\n                 call);\n        s = (a, b, c); call = Inr x; x = Inl y; y = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)))\n                                call\n 7. \\<And>call ret sa a b c x y aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                        ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)));\n        (ret, sa)\n        \\<in> set_spmf\n               ((key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest) s\n                 call);\n        s = (a, b, c); call = Inr x; x = Inr y; y = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)))\n                                call\n 8. \\<And>call ret sa a b c x y ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                        ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)));\n        (ret, sa)\n        \\<in> set_spmf\n               ((key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest) s\n                 call);\n        s = (a, b, c); call = Inr x; x = Inr y; y = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full)))\n                                call", "by(auto simp add: fused_resource.fuse.simps)"], ["", "private"], ["", "lemma WT_callee_real2: \"(\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<oplus>\\<^sub>\\<I> (((\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<oplus>\\<^sub>\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)) \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<turnstile>c\n  fused_resource.fuse (parallel_core key.core auth.core) (parallel_rest key_rest auth_rest) s \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<oplus>\\<^sub>\\<I>\n    (((\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<oplus>\\<^sub>\\<I>\n      (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n     \\<I>_full) \\<turnstile>c\n    fused_resource.fuse (parallel_core key.core auth.core)\n     (parallel_rest key_rest auth_rest) s \\<surd>", "apply(rule WT_calleeI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>call ret sa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call)\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call", "apply(cases s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>call ret sa a b c.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call", "apply(case_tac call)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>call ret sa a b c aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 2. \\<And>call ret sa a b c ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call", "apply(rename_tac [!] x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>call ret sa a b c x.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl x\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 2. \\<And>call ret sa a b c x.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call", "apply(case_tac [!] x)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>call ret sa a b c x aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl x; x = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 2. \\<And>call ret sa a b c x ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl x; x = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 3. \\<And>call ret sa a b c x aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 4. \\<And>call ret sa a b c x ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call", "apply(rename_tac [!] y)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>call ret sa a b c x y.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl x; x = Inl y\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 2. \\<And>call ret sa a b c x y.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl x; x = Inr y\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 3. \\<And>call ret sa a b c x y.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inl y\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 4. \\<And>call ret sa a b c x y.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inr y\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call", "apply(case_tac [!] y)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>call ret sa a b c x y aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl x; x = Inl y; y = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 2. \\<And>call ret sa a b c x y ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl x; x = Inl y; y = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 3. \\<And>call ret sa a b c x y aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl x; x = Inr y; y = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 4. \\<And>call ret sa a b c x y ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl x; x = Inr y; y = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 5. \\<And>call ret sa a b c x y aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inl y; y = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 6. \\<And>call ret sa a b c x y ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inl y; y = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 7. \\<And>call ret sa a b c x y aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inr y; y = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 8. \\<And>call ret sa a b c x y ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inr y; y = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call", "apply(rename_tac [5] z)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>call ret sa a b c x y aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl x; x = Inl y; y = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 2. \\<And>call ret sa a b c x y ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl x; x = Inl y; y = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 3. \\<And>call ret sa a b c x y aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl x; x = Inr y; y = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 4. \\<And>call ret sa a b c x y ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl x; x = Inr y; y = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 5. \\<And>call ret sa a b c x y z.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inl y; y = Inl z\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 6. \\<And>call ret sa a b c x y ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inl y; y = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 7. \\<And>call ret sa a b c x y aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inr y; y = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 8. \\<And>call ret sa a b c x y ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inr y; y = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call", "apply(rename_tac [6] z)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>call ret sa a b c x y aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl x; x = Inl y; y = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 2. \\<And>call ret sa a b c x y ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl x; x = Inl y; y = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 3. \\<And>call ret sa a b c x y aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl x; x = Inr y; y = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 4. \\<And>call ret sa a b c x y ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl x; x = Inr y; y = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 5. \\<And>call ret sa a b c x y z.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inl y; y = Inl z\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 6. \\<And>call ret sa a b c x y z.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inl y; y = Inr z\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 7. \\<And>call ret sa a b c x y aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inr y; y = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 8. \\<And>call ret sa a b c x y ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inr y; y = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call", "apply(case_tac [5] z)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>call ret sa a b c x y aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl x; x = Inl y; y = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 2. \\<And>call ret sa a b c x y ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl x; x = Inl y; y = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 3. \\<And>call ret sa a b c x y aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl x; x = Inr y; y = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 4. \\<And>call ret sa a b c x y ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl x; x = Inr y; y = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 5. \\<And>call ret sa a b c x y z aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inl y; y = Inl z;\n        z = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 6. \\<And>call ret sa a b c x y z ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inl y; y = Inl z;\n        z = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 7. \\<And>call ret sa a b c x y z.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inl y; y = Inr z\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 8. \\<And>call ret sa a b c x y aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inr y; y = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 9. \\<And>call ret sa a b c x y ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inr y; y = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call", "apply(case_tac [7] z)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>call ret sa a b c x y aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl x; x = Inl y; y = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 2. \\<And>call ret sa a b c x y ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl x; x = Inl y; y = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 3. \\<And>call ret sa a b c x y aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl x; x = Inr y; y = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 4. \\<And>call ret sa a b c x y ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inl x; x = Inr y; y = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 5. \\<And>call ret sa a b c x y z aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inl y; y = Inl z;\n        z = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 6. \\<And>call ret sa a b c x y z ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inl y; y = Inl z;\n        z = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 7. \\<And>call ret sa a b c x y z aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inl y; y = Inr z;\n        z = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 8. \\<And>call ret sa a b c x y z ba.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inl y; y = Inr z;\n        z = Inr ba\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 9. \\<And>call ret sa a b c x y aa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                        (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                         \\<I>_full));\n        (ret, sa)\n        \\<in> set_spmf\n               (fused_resource.fuse (parallel_core key.core auth.core)\n                 (parallel_rest key_rest auth_rest) s call);\n        s = (a, b, c); call = Inr x; x = Inr y; y = Inl aa\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                 (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_full))\n                                call\n 10. \\<And>call ret sa a b c x y ba.\n        \\<lbrakk>call\n                 \\<in> outs_\\<I>\n                        ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                         (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                            \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                           (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                            \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                          \\<I>_full));\n         (ret, sa)\n         \\<in> set_spmf\n                (fused_resource.fuse (parallel_core key.core auth.core)\n                  (parallel_rest key_rest auth_rest) s call);\n         s = (a, b, c); call = Inr x; x = Inr y; y = Inr ba\\<rbrakk>\n        \\<Longrightarrow> ret\n                          \\<in> responses_\\<I>\n                                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                  (((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                     \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                                    (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                     \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_full))\n                                 call", "by(auto simp add: fused_resource.fuse.simps)"], ["", "lemma attach_real: \"real_resource = RES (fused_resource.fuse real_core' real_rest') (real_s_core', real_s_rest')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_resource =\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_resource =\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "have fact1: \"real_core' = attach_core 1\\<^sub>I (attach_wiring_right parallel_wiring\\<^sub>w (enc_callee \\<ddagger>\\<^sub>I dec_callee)) \n    (parallel_core key.core auth.core) \" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_core' =\n    attach_core 1\\<^sub>I\n     (attach_wiring_right parallel_wiring\\<^sub>w\n       (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     (parallel_core key.core auth.core)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. real_core' =\n    attach_core 1\\<^sub>I\n     (attach_wiring_right parallel_wiring\\<^sub>w\n       (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     (parallel_core key.core auth.core)", "have \"cpoke ?L = cpoke ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cpoke real_core' =\n    cpoke\n     (attach_core 1\\<^sub>I\n       (attach_wiring_right parallel_wiring\\<^sub>w\n         (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n       (parallel_core key.core auth.core))", "by simp"], ["proof (state)\nthis:\n  cpoke real_core' =\n  cpoke\n   (attach_core 1\\<^sub>I\n     (attach_wiring_right parallel_wiring\\<^sub>w\n       (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     (parallel_core key.core auth.core))\n\ngoal (1 subgoal):\n 1. real_core' =\n    attach_core 1\\<^sub>I\n     (attach_wiring_right parallel_wiring\\<^sub>w\n       (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     (parallel_core key.core auth.core)", "moreover"], ["proof (state)\nthis:\n  cpoke real_core' =\n  cpoke\n   (attach_core 1\\<^sub>I\n     (attach_wiring_right parallel_wiring\\<^sub>w\n       (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     (parallel_core key.core auth.core))\n\ngoal (1 subgoal):\n 1. real_core' =\n    attach_core 1\\<^sub>I\n     (attach_wiring_right parallel_wiring\\<^sub>w\n       (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     (parallel_core key.core auth.core)", "have \"cfunc_adv ?L = cfunc_adv ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfunc_adv real_core' =\n    cfunc_adv\n     (attach_core 1\\<^sub>I\n       (attach_wiring_right parallel_wiring\\<^sub>w\n         (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n       (parallel_core key.core auth.core))", "unfolding attach_core_id_oracle_adv"], ["proof (prove)\ngoal (1 subgoal):\n 1. cfunc_adv real_core' =\n    (\\<lambda>(s_cnv, s_core) q.\n        map_spmf (\\<lambda>(out, s_core'). (out, s_cnv, s_core'))\n         (cfunc_adv (parallel_core key.core auth.core) s_core q))", "by (simp add: extend_state_oracle_def)"], ["proof (state)\nthis:\n  cfunc_adv real_core' =\n  cfunc_adv\n   (attach_core 1\\<^sub>I\n     (attach_wiring_right parallel_wiring\\<^sub>w\n       (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     (parallel_core key.core auth.core))\n\ngoal (1 subgoal):\n 1. real_core' =\n    attach_core 1\\<^sub>I\n     (attach_wiring_right parallel_wiring\\<^sub>w\n       (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     (parallel_core key.core auth.core)", "moreover"], ["proof (state)\nthis:\n  cfunc_adv real_core' =\n  cfunc_adv\n   (attach_core 1\\<^sub>I\n     (attach_wiring_right parallel_wiring\\<^sub>w\n       (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     (parallel_core key.core auth.core))\n\ngoal (1 subgoal):\n 1. real_core' =\n    attach_core 1\\<^sub>I\n     (attach_wiring_right parallel_wiring\\<^sub>w\n       (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     (parallel_core key.core auth.core)", "have \"cfunc_usr ?L = cfunc_usr ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfunc_usr real_core' =\n    cfunc_usr\n     (attach_core 1\\<^sub>I\n       (attach_wiring_right parallel_wiring\\<^sub>w\n         (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n       (parallel_core key.core auth.core))", "unfolding parallel_wiring\\<^sub>w_def swap_lassocr\\<^sub>w_def swap\\<^sub>w_def lassocr\\<^sub>w_def rassocl\\<^sub>w_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cfunc_usr real_core' =\n    cfunc_usr\n     (attach_core 1\\<^sub>I\n       (attach_wiring_right\n         ((rsuml, lsumr) \\<circ>\\<^sub>w\n          ((id, id) |\\<^sub>w\n           ((lsumr, rsuml) \\<circ>\\<^sub>w\n            ((swap_sum, swap_sum) |\\<^sub>w (id, id) \\<circ>\\<^sub>w\n             (rsuml, lsumr))) \\<circ>\\<^sub>w\n           (lsumr, rsuml)))\n         (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n       (parallel_core key.core auth.core))", "by (simp add: attach_wiring_right_simps parallel2_wiring_simps comp_wiring_simps)"], ["proof (state)\nthis:\n  cfunc_usr real_core' =\n  cfunc_usr\n   (attach_core 1\\<^sub>I\n     (attach_wiring_right parallel_wiring\\<^sub>w\n       (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     (parallel_core key.core auth.core))\n\ngoal (1 subgoal):\n 1. real_core' =\n    attach_core 1\\<^sub>I\n     (attach_wiring_right parallel_wiring\\<^sub>w\n       (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     (parallel_core key.core auth.core)", "ultimately"], ["proof (chain)\npicking this:\n  cpoke real_core' =\n  cpoke\n   (attach_core 1\\<^sub>I\n     (attach_wiring_right parallel_wiring\\<^sub>w\n       (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     (parallel_core key.core auth.core))\n  cfunc_adv real_core' =\n  cfunc_adv\n   (attach_core 1\\<^sub>I\n     (attach_wiring_right parallel_wiring\\<^sub>w\n       (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     (parallel_core key.core auth.core))\n  cfunc_usr real_core' =\n  cfunc_usr\n   (attach_core 1\\<^sub>I\n     (attach_wiring_right parallel_wiring\\<^sub>w\n       (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     (parallel_core key.core auth.core))", "show ?thesis"], ["proof (prove)\nusing this:\n  cpoke real_core' =\n  cpoke\n   (attach_core 1\\<^sub>I\n     (attach_wiring_right parallel_wiring\\<^sub>w\n       (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     (parallel_core key.core auth.core))\n  cfunc_adv real_core' =\n  cfunc_adv\n   (attach_core 1\\<^sub>I\n     (attach_wiring_right parallel_wiring\\<^sub>w\n       (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     (parallel_core key.core auth.core))\n  cfunc_usr real_core' =\n  cfunc_usr\n   (attach_core 1\\<^sub>I\n     (attach_wiring_right parallel_wiring\\<^sub>w\n       (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     (parallel_core key.core auth.core))\n\ngoal (1 subgoal):\n 1. real_core' =\n    attach_core 1\\<^sub>I\n     (attach_wiring_right parallel_wiring\\<^sub>w\n       (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     (parallel_core key.core auth.core)", "by (coinduction) blast"], ["proof (state)\nthis:\n  real_core' =\n  attach_core 1\\<^sub>I\n   (attach_wiring_right parallel_wiring\\<^sub>w\n     (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n   (parallel_core key.core auth.core)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_core' =\n  attach_core 1\\<^sub>I\n   (attach_wiring_right parallel_wiring\\<^sub>w\n     (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n   (parallel_core key.core auth.core)\n\ngoal (1 subgoal):\n 1. real_resource =\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "have fact2: \"real_rest' = attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ())) (parallel_rest key_rest auth_rest) \"  (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_rest' =\n    attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_rest' =\n    attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest)", "have \"rinit ?L = rinit ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rinit real_rest' =\n    rinit\n     (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n       (parallel_rest key_rest auth_rest))", "unfolding real_rest'_def ideal_rest'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rinit\n     (corec_rest_scheme\n       (\\<lambda>x. (((), ()), rinit key_rest, rinit auth_rest))\n       (\\<lambda>x.\n           \\<dagger>(parallel_eoracle (rfunc_adv key_rest)\n                      (rfunc_adv auth_rest)))\n       (\\<lambda>x.\n           \\<dagger>(parallel_eoracle (rfunc_usr key_rest)\n                      (rfunc_usr auth_rest)))\n       ()) =\n    rinit\n     (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n       (parallel_rest key_rest auth_rest))", "by simp"], ["proof (state)\nthis:\n  rinit real_rest' =\n  rinit\n   (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest))\n\ngoal (1 subgoal):\n 1. real_rest' =\n    attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest)", "moreover"], ["proof (state)\nthis:\n  rinit real_rest' =\n  rinit\n   (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest))\n\ngoal (1 subgoal):\n 1. real_rest' =\n    attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest)", "have \"rfunc_adv ?L = rfunc_adv ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rfunc_adv real_rest' =\n    rfunc_adv\n     (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n       (parallel_rest key_rest auth_rest))", "unfolding real_rest'_def ideal_rest'_def attach_rest_id_oracle_adv"], ["proof (prove)\ngoal (1 subgoal):\n 1. rfunc_adv\n     (corec_rest_scheme\n       (\\<lambda>x. (((), ()), rinit key_rest, rinit auth_rest))\n       (\\<lambda>x.\n           \\<dagger>(parallel_eoracle (rfunc_adv key_rest)\n                      (rfunc_adv auth_rest)))\n       (\\<lambda>x.\n           \\<dagger>(parallel_eoracle (rfunc_usr key_rest)\n                      (rfunc_usr auth_rest)))\n       ()) =\n    (\\<lambda>(s_cnv, s_core) q.\n        map_spmf (\\<lambda>(out, s_core'). (out, s_cnv, s_core'))\n         (rfunc_adv (parallel_rest key_rest auth_rest) s_core q))", "by (simp add: extend_state_oracle_def)"], ["proof (state)\nthis:\n  rfunc_adv real_rest' =\n  rfunc_adv\n   (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest))\n\ngoal (1 subgoal):\n 1. real_rest' =\n    attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest)", "moreover"], ["proof (state)\nthis:\n  rfunc_adv real_rest' =\n  rfunc_adv\n   (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest))\n\ngoal (1 subgoal):\n 1. real_rest' =\n    attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest)", "have \"rfunc_usr ?L = rfunc_usr ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rfunc_usr real_rest' =\n    rfunc_usr\n     (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n       (parallel_rest key_rest auth_rest))", "unfolding real_rest'_def ideal_rest'_def attach_rest_id_oracle_usr"], ["proof (prove)\ngoal (1 subgoal):\n 1. rfunc_usr\n     (corec_rest_scheme\n       (\\<lambda>x. (((), ()), rinit key_rest, rinit auth_rest))\n       (\\<lambda>x.\n           \\<dagger>(parallel_eoracle (rfunc_adv key_rest)\n                      (rfunc_adv auth_rest)))\n       (\\<lambda>x.\n           \\<dagger>(parallel_eoracle (rfunc_usr key_rest)\n                      (rfunc_usr auth_rest)))\n       ()) =\n    (\\<lambda>(s_cnv, s_core) q.\n        map_spmf (\\<lambda>(out, s_core'). (out, s_cnv, s_core'))\n         (rfunc_usr (parallel_rest key_rest auth_rest) s_core q))", "by (simp add: extend_state_oracle_def)"], ["proof (state)\nthis:\n  rfunc_usr real_rest' =\n  rfunc_usr\n   (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest))\n\ngoal (1 subgoal):\n 1. real_rest' =\n    attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest)", "ultimately"], ["proof (chain)\npicking this:\n  rinit real_rest' =\n  rinit\n   (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest))\n  rfunc_adv real_rest' =\n  rfunc_adv\n   (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest))\n  rfunc_usr real_rest' =\n  rfunc_usr\n   (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest))", "show ?thesis"], ["proof (prove)\nusing this:\n  rinit real_rest' =\n  rinit\n   (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest))\n  rfunc_adv real_rest' =\n  rfunc_adv\n   (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest))\n  rfunc_usr real_rest' =\n  rfunc_usr\n   (attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest))\n\ngoal (1 subgoal):\n 1. real_rest' =\n    attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n     (parallel_rest key_rest auth_rest)", "by (coinduction) blast"], ["proof (state)\nthis:\n  real_rest' =\n  attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n   (parallel_rest key_rest auth_rest)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_rest' =\n  attach_rest 1\\<^sub>I 1\\<^sub>I (Pair ((), ()))\n   (parallel_rest key_rest auth_rest)\n\ngoal (1 subgoal):\n 1. real_resource =\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_resource =\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "unfolding real_resource_def attach_c1f22_c1f22_def wiring_c1r22_c1r22_def key.resource_def auth.resource_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n     (CNV enc_callee () |\\<^sub>= CNV dec_callee ()) \\<odot>\n     parallel_wiring |\\<^sub>=\n     1\\<^sub>C) \\<odot>\n    fused_wiring \\<rhd>\n    RES (key.fuse key_rest)\n     ((key.PState_Store, {}), rinit key_rest) \\<parallel>\n    RES (auth.fuse auth_rest) ((sec.State_Void, {}), rinit auth_rest) =\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(subst resource_of_parallel_oracle[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n     (CNV enc_callee () |\\<^sub>= CNV dec_callee ()) \\<odot>\n     parallel_wiring |\\<^sub>=\n     1\\<^sub>C) \\<odot>\n    fused_wiring \\<rhd>\n    RES (key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest)\n     (((key.PState_Store, {}), rinit key_rest), (sec.State_Void, {}),\n      rinit auth_rest) =\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(subst attach_compose)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    (CNV enc_callee () |\\<^sub>= CNV dec_callee ()) \\<odot>\n    parallel_wiring |\\<^sub>=\n    1\\<^sub>C \\<rhd>\n    fused_wiring \\<rhd>\n    RES (key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest)\n     (((key.PState_Store, {}), rinit key_rest), (sec.State_Void, {}),\n      rinit auth_rest) =\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(subst attach_wiring_resource_of_oracle)"], ["proof (prove)\ngoal (4 subgoals):\n 1. wiring ?\\<I>1.0 ?\\<I>2.0 fused_wiring ?fg\n 2. ?\\<I>2.0 \n    \\<turnstile>res RES (key.fuse key_rest \\<ddagger>\\<^sub>O\n                         auth.fuse auth_rest)\n                     (((key.PState_Store, {}), rinit key_rest),\n                      (sec.State_Void, {}), rinit auth_rest) \\<surd>\n 3. outs_\\<I> ?\\<I>1.0 = UNIV\n 4. (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    (CNV enc_callee () |\\<^sub>= CNV dec_callee ()) \\<odot>\n    parallel_wiring |\\<^sub>=\n    1\\<^sub>C \\<rhd>\n    RES (apply_wiring ?fg\n          (key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest))\n     (((key.PState_Store, {}), rinit key_rest), (sec.State_Void, {}),\n      rinit auth_rest) =\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(rule wiring_intro)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ((?\\<I>1.1 \\<oplus>\\<^sub>\\<I> ?\\<I>2a1) \\<oplus>\\<^sub>\\<I>\n     (?\\<I>1a1 \\<oplus>\\<^sub>\\<I> ?\\<I>2aa1)) \\<oplus>\\<^sub>\\<I>\n    ((?\\<I>2.1 \\<oplus>\\<^sub>\\<I> ?\\<I>3.1) \\<oplus>\\<^sub>\\<I>\n     (?\\<I>2b1 \\<oplus>\\<^sub>\\<I> ?\\<I>3a1)) \n    \\<turnstile>res RES (key.fuse key_rest \\<ddagger>\\<^sub>O\n                         auth.fuse auth_rest)\n                     (((key.PState_Store, {}), rinit key_rest),\n                      (sec.State_Void, {}), rinit auth_rest) \\<surd>\n 2. outs_\\<I>\n     (((?\\<I>1.1 \\<oplus>\\<^sub>\\<I> ?\\<I>2.1) \\<oplus>\\<^sub>\\<I>\n       (?\\<I>2a1 \\<oplus>\\<^sub>\\<I> ?\\<I>3.1)) \\<oplus>\\<^sub>\\<I>\n      ((?\\<I>1a1 \\<oplus>\\<^sub>\\<I> ?\\<I>2b1) \\<oplus>\\<^sub>\\<I>\n       (?\\<I>2aa1 \\<oplus>\\<^sub>\\<I> ?\\<I>3a1))) =\n    UNIV\n 3. (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    (CNV enc_callee () |\\<^sub>= CNV dec_callee ()) \\<odot>\n    parallel_wiring |\\<^sub>=\n    1\\<^sub>C \\<rhd>\n    RES (apply_wiring fused_wiring\\<^sub>w\n          (key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest))\n     (((key.PState_Store, {}), rinit key_rest), (sec.State_Void, {}),\n      rinit auth_rest) =\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply (rule WT_resource_of_oracle[OF WT_callee_real1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. outs_\\<I>\n     (((\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<oplus>\\<^sub>\\<I>\n       (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n      ((\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<oplus>\\<^sub>\\<I>\n       (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full))) =\n    UNIV\n 2. (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    (CNV enc_callee () |\\<^sub>= CNV dec_callee ()) \\<odot>\n    parallel_wiring |\\<^sub>=\n    1\\<^sub>C \\<rhd>\n    RES (apply_wiring fused_wiring\\<^sub>w\n          (key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest))\n     (((key.PState_Store, {}), rinit key_rest), (sec.State_Void, {}),\n      rinit auth_rest) =\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    (CNV enc_callee () |\\<^sub>= CNV dec_callee ()) \\<odot>\n    parallel_wiring |\\<^sub>=\n    1\\<^sub>C \\<rhd>\n    RES (apply_wiring fused_wiring\\<^sub>w\n          (key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest))\n     (((key.PState_Store, {}), rinit key_rest), (sec.State_Void, {}),\n      rinit auth_rest) =\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    (CNV enc_callee () |\\<^sub>= CNV dec_callee ()) \\<odot>\n    parallel_wiring |\\<^sub>=\n    1\\<^sub>C \\<rhd>\n    RES (apply_wiring fused_wiring\\<^sub>w\n          (key.fuse key_rest \\<ddagger>\\<^sub>O auth.fuse auth_rest))\n     (((key.PState_Store, {}), rinit key_rest), (sec.State_Void, {}),\n      rinit auth_rest) =\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(subst parallel_oracle_fuse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    (CNV enc_callee () |\\<^sub>= CNV dec_callee ()) \\<odot>\n    parallel_wiring |\\<^sub>=\n    1\\<^sub>C \\<rhd>\n    RES (apply_state_iso parallel_state_iso\n          (fused_resource.fuse (parallel_core key.core auth.core)\n            (parallel_rest key_rest auth_rest)))\n     (((key.PState_Store, {}), rinit key_rest), (sec.State_Void, {}),\n      rinit auth_rest) =\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(subst resource_of_oracle_state_iso)"], ["proof (prove)\ngoal (2 subgoals):\n 1. state_iso parallel_state_iso\n 2. (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    (CNV enc_callee () |\\<^sub>= CNV dec_callee ()) \\<odot>\n    parallel_wiring |\\<^sub>=\n    1\\<^sub>C \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (snd parallel_state_iso\n       (((key.PState_Store, {}), rinit key_rest), (sec.State_Void, {}),\n        rinit auth_rest)) =\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    (CNV enc_callee () |\\<^sub>= CNV dec_callee ()) \\<odot>\n    parallel_wiring |\\<^sub>=\n    1\\<^sub>C \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (snd parallel_state_iso\n       (((key.PState_Store, {}), rinit key_rest), (sec.State_Void, {}),\n        rinit auth_rest)) =\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(simp add: parallel_state_iso_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    (CNV enc_callee () |\\<^sub>= CNV dec_callee ()) \\<odot>\n    parallel_wiring |\\<^sub>=\n    1\\<^sub>C \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) =\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(subst conv_callee_parallel[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (enc_callee \\<ddagger>\\<^sub>I dec_callee) ((), ()) \\<odot>\n    parallel_wiring |\\<^sub>=\n    1\\<^sub>C \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) =\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(subst eq_resource_on_UNIV_iff[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (enc_callee \\<ddagger>\\<^sub>I dec_callee) ((), ()) \\<odot>\n    parallel_wiring |\\<^sub>=\n    1\\<^sub>C \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(rule eq_resource_on_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (enc_callee \\<ddagger>\\<^sub>I dec_callee) ((), ()) \\<odot>\n    parallel_wiring |\\<^sub>=\n    1\\<^sub>C \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    ?res'\n 2. UNIV \\<turnstile>\\<^sub>R ?res' \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(rule eq_\\<I>_attach_on')"], ["proof (prove)\ngoal (4 subgoals):\n 1. ?\\<I>'3 \n    \\<turnstile>res RES (fused_resource.fuse\n                          (parallel_core key.core auth.core)\n                          (parallel_rest key_rest auth_rest))\n                     (((key.PState_Store, {}), sec.State_Void, {}),\n                      rinit key_rest, rinit auth_rest) \\<surd>\n 2. ?\\<I>3,?\\<I>'3 \\<turnstile>\\<^sub>C\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (enc_callee \\<ddagger>\\<^sub>I dec_callee) ((), ()) \\<odot>\n    parallel_wiring |\\<^sub>=\n    1\\<^sub>C \\<sim>\n    ?conv'3\n 3. UNIV \\<subseteq> outs_\\<I> ?\\<I>3\n 4. UNIV \\<turnstile>\\<^sub>R\n    ?conv'3 \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply (rule WT_resource_of_oracle[OF WT_callee_real2])"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<I>3,(\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<oplus>\\<^sub>\\<I>\n           (((\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<oplus>\\<^sub>\\<I>\n             (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n            \\<I>_full) \\<turnstile>\\<^sub>C\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (enc_callee \\<ddagger>\\<^sub>I dec_callee) ((), ()) \\<odot>\n    parallel_wiring |\\<^sub>=\n    1\\<^sub>C \\<sim>\n    ?conv'3\n 2. UNIV \\<subseteq> outs_\\<I> ?\\<I>3\n 3. UNIV \\<turnstile>\\<^sub>R\n    ?conv'3 \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(rule parallel_converter2_eq_\\<I>_cong)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ?\\<I>1.9,\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full \\<turnstile>\\<^sub>C\n    1\\<^sub>C |\\<^sub>= 1\\<^sub>C \\<sim> ?conv1'9\n 2. ?\\<I>2.9,((\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<oplus>\\<^sub>\\<I>\n              (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n             \\<I>_full \\<turnstile>\\<^sub>C\n    CNV (enc_callee \\<ddagger>\\<^sub>I dec_callee) ((), ()) \\<odot>\n    parallel_wiring |\\<^sub>=\n    1\\<^sub>C \\<sim>\n    ?conv2'9\n 3. UNIV \\<subseteq> outs_\\<I> (?\\<I>1.9 \\<oplus>\\<^sub>\\<I> ?\\<I>2.9)\n 4. UNIV \\<turnstile>\\<^sub>R\n    ?conv1'9 |\\<^sub>= ?conv2'9 \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(rule eq_\\<I>_converter_reflI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ?\\<I>1.9, \\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full \\<turnstile>\\<^sub>C\n    1\\<^sub>C |\\<^sub>= 1\\<^sub>C \\<surd>\n 2. ?\\<I>2.9,((\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<oplus>\\<^sub>\\<I>\n              (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n             \\<I>_full \\<turnstile>\\<^sub>C\n    CNV (enc_callee \\<ddagger>\\<^sub>I dec_callee) ((), ()) \\<odot>\n    parallel_wiring |\\<^sub>=\n    1\\<^sub>C \\<sim>\n    ?conv2'9\n 3. UNIV \\<subseteq> outs_\\<I> (?\\<I>1.9 \\<oplus>\\<^sub>\\<I> ?\\<I>2.9)\n 4. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>= ?conv2'9 \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(rule WT_intro)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<I>2.9,((\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<oplus>\\<^sub>\\<I>\n              (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)) \\<oplus>\\<^sub>\\<I>\n             \\<I>_full \\<turnstile>\\<^sub>C\n    CNV (enc_callee \\<ddagger>\\<^sub>I dec_callee) ((), ()) \\<odot>\n    parallel_wiring |\\<^sub>=\n    1\\<^sub>C \\<sim>\n    ?conv2'9\n 2. UNIV\n    \\<subseteq> outs_\\<I>\n                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                  ?\\<I>2.9)\n 3. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>= ?conv2'9 \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(rule parallel_converter2_eq_\\<I>_cong)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ?\\<I>1.19,(\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<oplus>\\<^sub>\\<I>\n              (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<turnstile>\\<^sub>C\n    CNV (enc_callee \\<ddagger>\\<^sub>I dec_callee) ((), ()) \\<odot>\n    parallel_wiring \\<sim>\n    ?conv1'19\n 2. ?\\<I>2.19,\\<I>_full \\<turnstile>\\<^sub>C 1\\<^sub>C \\<sim> ?conv2'19\n 3. UNIV\n    \\<subseteq> outs_\\<I>\n                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                  (?\\<I>1.19 \\<oplus>\\<^sub>\\<I> ?\\<I>2.19))\n 4. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    ?conv1'19 |\\<^sub>= ?conv2'19 \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(rule comp_converter_of_callee_wiring)"], ["proof (prove)\ngoal (5 subgoals):\n 1. wiring ?\\<I>2.22\n     ((\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<oplus>\\<^sub>\\<I>\n      (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full))\n     parallel_wiring ?w22\n 2. ?\\<I>1.19, ?\\<I>2.22 \\<turnstile>\\<^sub>C\n    CNV (enc_callee \\<ddagger>\\<^sub>I dec_callee) ((), ()) \\<surd>\n 3. ?\\<I>2.19,\\<I>_full \\<turnstile>\\<^sub>C 1\\<^sub>C \\<sim> ?conv2'19\n 4. UNIV\n    \\<subseteq> outs_\\<I>\n                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                  (?\\<I>1.19 \\<oplus>\\<^sub>\\<I> ?\\<I>2.19))\n 5. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (attach_wiring_right ?w22\n          (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     ((), ()) |\\<^sub>=\n    ?conv2'19 \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(rule wiring_intro)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ?\\<I>1.19,\n    (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<oplus>\\<^sub>\\<I>\n    (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<turnstile>\\<^sub>C\n    CNV (enc_callee \\<ddagger>\\<^sub>I dec_callee) ((), ()) \\<surd>\n 2. ?\\<I>2.19,\\<I>_full \\<turnstile>\\<^sub>C 1\\<^sub>C \\<sim> ?conv2'19\n 3. UNIV\n    \\<subseteq> outs_\\<I>\n                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                  (?\\<I>1.19 \\<oplus>\\<^sub>\\<I> ?\\<I>2.19))\n 4. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (attach_wiring_right parallel_wiring\\<^sub>w\n          (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     ((), ()) |\\<^sub>=\n    ?conv2'19 \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(subst conv_callee_parallel)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ?\\<I>1.19,\n    (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<oplus>\\<^sub>\\<I>\n    (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full) \\<turnstile>\\<^sub>C\n    CNV enc_callee () |\\<^sub>= CNV dec_callee () \\<surd>\n 2. ?\\<I>2.19,\\<I>_full \\<turnstile>\\<^sub>C 1\\<^sub>C \\<sim> ?conv2'19\n 3. UNIV\n    \\<subseteq> outs_\\<I>\n                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                  (?\\<I>1.19 \\<oplus>\\<^sub>\\<I> ?\\<I>2.19))\n 4. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (attach_wiring_right parallel_wiring\\<^sub>w\n          (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     ((), ()) |\\<^sub>=\n    ?conv2'19 \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(rule WT_intro)"], ["proof (prove)\ngoal (5 subgoals):\n 1. ?\\<I>1.29, \\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full \\<turnstile>\\<^sub>C\n    CNV enc_callee () \\<surd>\n 2. ?\\<I>1'29, \\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full \\<turnstile>\\<^sub>C\n    CNV dec_callee () \\<surd>\n 3. ?\\<I>2.19,\\<I>_full \\<turnstile>\\<^sub>C 1\\<^sub>C \\<sim> ?conv2'19\n 4. UNIV\n    \\<subseteq> outs_\\<I>\n                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                  ((?\\<I>1.29 \\<oplus>\\<^sub>\\<I>\n                    ?\\<I>1'29) \\<oplus>\\<^sub>\\<I>\n                   ?\\<I>2.19))\n 5. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (attach_wiring_right parallel_wiring\\<^sub>w\n          (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     ((), ()) |\\<^sub>=\n    ?conv2'19 \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply (rule WT_converter_of_callee[where \\<I>=\\<I>_full and \\<I>'=\"\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full\"])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s q.\n       q \\<in> outs_\\<I> \\<I>_full \\<Longrightarrow>\n       \\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full\n       \\<turnstile>g enc_callee s q \\<surd>\n 2. \\<And>s q r s'.\n       \\<lbrakk>q \\<in> outs_\\<I> \\<I>_full;\n        (r, s')\n        \\<in> results_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)\n               (enc_callee s q)\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I>_full q\n 3. ?\\<I>1'29, \\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full \\<turnstile>\\<^sub>C\n    CNV dec_callee () \\<surd>\n 4. ?\\<I>2.19,\\<I>_full \\<turnstile>\\<^sub>C 1\\<^sub>C \\<sim> ?conv2'19\n 5. UNIV\n    \\<subseteq> outs_\\<I>\n                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                  ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                    ?\\<I>1'29) \\<oplus>\\<^sub>\\<I>\n                   ?\\<I>2.19))\n 6. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (attach_wiring_right parallel_wiring\\<^sub>w\n          (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     ((), ()) |\\<^sub>=\n    ?conv2'19 \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply (rule WT_gpv_\\<I>_mono)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>s q.\n       q \\<in> outs_\\<I> \\<I>_full \\<Longrightarrow>\n       ?\\<I>40 s q \\<turnstile>g enc_callee s q \\<surd>\n 2. \\<And>s q.\n       q \\<in> outs_\\<I> \\<I>_full \\<Longrightarrow>\n       ?\\<I>40 s q \\<le> \\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full\n 3. \\<And>s q r s'.\n       \\<lbrakk>q \\<in> outs_\\<I> \\<I>_full;\n        (r, s')\n        \\<in> results_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)\n               (enc_callee s q)\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I>_full q\n 4. ?\\<I>1'29, \\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full \\<turnstile>\\<^sub>C\n    CNV dec_callee () \\<surd>\n 5. ?\\<I>2.19,\\<I>_full \\<turnstile>\\<^sub>C 1\\<^sub>C \\<sim> ?conv2'19\n 6. UNIV\n    \\<subseteq> outs_\\<I>\n                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                  ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                    ?\\<I>1'29) \\<oplus>\\<^sub>\\<I>\n                   ?\\<I>2.19))\n 7. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (attach_wiring_right parallel_wiring\\<^sub>w\n          (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     ((), ()) |\\<^sub>=\n    ?conv2'19 \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply (rule WT_gpv_full)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s q.\n       q \\<in> outs_\\<I> \\<I>_full \\<Longrightarrow>\n       \\<I>_full \\<le> \\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full\n 2. \\<And>s q r s'.\n       \\<lbrakk>q \\<in> outs_\\<I> \\<I>_full;\n        (r, s')\n        \\<in> results_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)\n               (enc_callee s q)\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I>_full q\n 3. ?\\<I>1'29, \\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full \\<turnstile>\\<^sub>C\n    CNV dec_callee () \\<surd>\n 4. ?\\<I>2.19,\\<I>_full \\<turnstile>\\<^sub>C 1\\<^sub>C \\<sim> ?conv2'19\n 5. UNIV\n    \\<subseteq> outs_\\<I>\n                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                  ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                    ?\\<I>1'29) \\<oplus>\\<^sub>\\<I>\n                   ?\\<I>2.19))\n 6. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (attach_wiring_right parallel_wiring\\<^sub>w\n          (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     ((), ()) |\\<^sub>=\n    ?conv2'19 \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply (rule \\<I>_full_le_plus_\\<I>)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>s q.\n       q \\<in> outs_\\<I> \\<I>_full \\<Longrightarrow>\n       \\<I>_full \\<le> \\<I>_full\n 2. \\<And>s q.\n       q \\<in> outs_\\<I> \\<I>_full \\<Longrightarrow>\n       \\<I>_full \\<le> \\<I>_full\n 3. \\<And>s q r s'.\n       \\<lbrakk>q \\<in> outs_\\<I> \\<I>_full;\n        (r, s')\n        \\<in> results_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)\n               (enc_callee s q)\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I>_full q\n 4. ?\\<I>1'29, \\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full \\<turnstile>\\<^sub>C\n    CNV dec_callee () \\<surd>\n 5. ?\\<I>2.19,\\<I>_full \\<turnstile>\\<^sub>C 1\\<^sub>C \\<sim> ?conv2'19\n 6. UNIV\n    \\<subseteq> outs_\\<I>\n                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                  ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                    ?\\<I>1'29) \\<oplus>\\<^sub>\\<I>\n                   ?\\<I>2.19))\n 7. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (attach_wiring_right parallel_wiring\\<^sub>w\n          (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     ((), ()) |\\<^sub>=\n    ?conv2'19 \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(rule order_refl)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s q.\n       q \\<in> outs_\\<I> \\<I>_full \\<Longrightarrow>\n       \\<I>_full \\<le> \\<I>_full\n 2. \\<And>s q r s'.\n       \\<lbrakk>q \\<in> outs_\\<I> \\<I>_full;\n        (r, s')\n        \\<in> results_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)\n               (enc_callee s q)\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I>_full q\n 3. ?\\<I>1'29, \\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full \\<turnstile>\\<^sub>C\n    CNV dec_callee () \\<surd>\n 4. ?\\<I>2.19,\\<I>_full \\<turnstile>\\<^sub>C 1\\<^sub>C \\<sim> ?conv2'19\n 5. UNIV\n    \\<subseteq> outs_\\<I>\n                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                  ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                    ?\\<I>1'29) \\<oplus>\\<^sub>\\<I>\n                   ?\\<I>2.19))\n 6. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (attach_wiring_right parallel_wiring\\<^sub>w\n          (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     ((), ()) |\\<^sub>=\n    ?conv2'19 \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(rule order_refl)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s q r s'.\n       \\<lbrakk>q \\<in> outs_\\<I> \\<I>_full;\n        (r, s')\n        \\<in> results_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)\n               (enc_callee s q)\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I>_full q\n 2. ?\\<I>1'29, \\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full \\<turnstile>\\<^sub>C\n    CNV dec_callee () \\<surd>\n 3. ?\\<I>2.19,\\<I>_full \\<turnstile>\\<^sub>C 1\\<^sub>C \\<sim> ?conv2'19\n 4. UNIV\n    \\<subseteq> outs_\\<I>\n                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                  ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                    ?\\<I>1'29) \\<oplus>\\<^sub>\\<I>\n                   ?\\<I>2.19))\n 5. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (attach_wiring_right parallel_wiring\\<^sub>w\n          (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     ((), ()) |\\<^sub>=\n    ?conv2'19 \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply (clarsimp simp add: enc_callee_def stateless_callee_def split!: sec.iusr_alice.splits key.ousr_alice.splits)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ?\\<I>1'29, \\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full \\<turnstile>\\<^sub>C\n    CNV dec_callee () \\<surd>\n 2. ?\\<I>2.19,\\<I>_full \\<turnstile>\\<^sub>C 1\\<^sub>C \\<sim> ?conv2'19\n 3. UNIV\n    \\<subseteq> outs_\\<I>\n                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                  ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                    ?\\<I>1'29) \\<oplus>\\<^sub>\\<I>\n                   ?\\<I>2.19))\n 4. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (attach_wiring_right parallel_wiring\\<^sub>w\n          (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     ((), ()) |\\<^sub>=\n    ?conv2'19 \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply (rule WT_converter_of_callee[where \\<I>=\\<I>_full and \\<I>'=\"\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s q.\n       q \\<in> outs_\\<I> \\<I>_full \\<Longrightarrow>\n       \\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full\n       \\<turnstile>g dec_callee s q \\<surd>\n 2. \\<And>s q r s'.\n       \\<lbrakk>q \\<in> outs_\\<I> \\<I>_full;\n        (r, s')\n        \\<in> results_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)\n               (dec_callee s q)\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I>_full q\n 3. ?\\<I>2.19,\\<I>_full \\<turnstile>\\<^sub>C 1\\<^sub>C \\<sim> ?conv2'19\n 4. UNIV\n    \\<subseteq> outs_\\<I>\n                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                  ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                   ?\\<I>2.19))\n 5. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (attach_wiring_right parallel_wiring\\<^sub>w\n          (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     ((), ()) |\\<^sub>=\n    ?conv2'19 \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply (rule WT_gpv_\\<I>_mono)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s q.\n       q \\<in> outs_\\<I> \\<I>_full \\<Longrightarrow>\n       ?\\<I>57 s q \\<turnstile>g dec_callee s q \\<surd>\n 2. \\<And>s q.\n       q \\<in> outs_\\<I> \\<I>_full \\<Longrightarrow>\n       ?\\<I>57 s q \\<le> \\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full\n 3. \\<And>s q r s'.\n       \\<lbrakk>q \\<in> outs_\\<I> \\<I>_full;\n        (r, s')\n        \\<in> results_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)\n               (dec_callee s q)\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I>_full q\n 4. ?\\<I>2.19,\\<I>_full \\<turnstile>\\<^sub>C 1\\<^sub>C \\<sim> ?conv2'19\n 5. UNIV\n    \\<subseteq> outs_\\<I>\n                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                  ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                   ?\\<I>2.19))\n 6. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (attach_wiring_right parallel_wiring\\<^sub>w\n          (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     ((), ()) |\\<^sub>=\n    ?conv2'19 \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply (rule WT_gpv_full)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s q.\n       q \\<in> outs_\\<I> \\<I>_full \\<Longrightarrow>\n       \\<I>_full \\<le> \\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full\n 2. \\<And>s q r s'.\n       \\<lbrakk>q \\<in> outs_\\<I> \\<I>_full;\n        (r, s')\n        \\<in> results_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)\n               (dec_callee s q)\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I>_full q\n 3. ?\\<I>2.19,\\<I>_full \\<turnstile>\\<^sub>C 1\\<^sub>C \\<sim> ?conv2'19\n 4. UNIV\n    \\<subseteq> outs_\\<I>\n                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                  ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                   ?\\<I>2.19))\n 5. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (attach_wiring_right parallel_wiring\\<^sub>w\n          (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     ((), ()) |\\<^sub>=\n    ?conv2'19 \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply (rule \\<I>_full_le_plus_\\<I>)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s q.\n       q \\<in> outs_\\<I> \\<I>_full \\<Longrightarrow>\n       \\<I>_full \\<le> \\<I>_full\n 2. \\<And>s q.\n       q \\<in> outs_\\<I> \\<I>_full \\<Longrightarrow>\n       \\<I>_full \\<le> \\<I>_full\n 3. \\<And>s q r s'.\n       \\<lbrakk>q \\<in> outs_\\<I> \\<I>_full;\n        (r, s')\n        \\<in> results_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)\n               (dec_callee s q)\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I>_full q\n 4. ?\\<I>2.19,\\<I>_full \\<turnstile>\\<^sub>C 1\\<^sub>C \\<sim> ?conv2'19\n 5. UNIV\n    \\<subseteq> outs_\\<I>\n                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                  ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                   ?\\<I>2.19))\n 6. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (attach_wiring_right parallel_wiring\\<^sub>w\n          (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     ((), ()) |\\<^sub>=\n    ?conv2'19 \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(rule order_refl)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s q.\n       q \\<in> outs_\\<I> \\<I>_full \\<Longrightarrow>\n       \\<I>_full \\<le> \\<I>_full\n 2. \\<And>s q r s'.\n       \\<lbrakk>q \\<in> outs_\\<I> \\<I>_full;\n        (r, s')\n        \\<in> results_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)\n               (dec_callee s q)\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I>_full q\n 3. ?\\<I>2.19,\\<I>_full \\<turnstile>\\<^sub>C 1\\<^sub>C \\<sim> ?conv2'19\n 4. UNIV\n    \\<subseteq> outs_\\<I>\n                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                  ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                   ?\\<I>2.19))\n 5. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (attach_wiring_right parallel_wiring\\<^sub>w\n          (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     ((), ()) |\\<^sub>=\n    ?conv2'19 \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(rule order_refl)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s q r s'.\n       \\<lbrakk>q \\<in> outs_\\<I> \\<I>_full;\n        (r, s')\n        \\<in> results_gpv (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_full)\n               (dec_callee s q)\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I> \\<I>_full q\n 2. ?\\<I>2.19,\\<I>_full \\<turnstile>\\<^sub>C 1\\<^sub>C \\<sim> ?conv2'19\n 3. UNIV\n    \\<subseteq> outs_\\<I>\n                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                  ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                   ?\\<I>2.19))\n 4. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (attach_wiring_right parallel_wiring\\<^sub>w\n          (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     ((), ()) |\\<^sub>=\n    ?conv2'19 \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply (clarsimp simp add: enc_callee_def stateless_callee_def split!: sec.iusr_alice.splits key.ousr_alice.splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?\\<I>2.19,\\<I>_full \\<turnstile>\\<^sub>C 1\\<^sub>C \\<sim> ?conv2'19\n 2. UNIV\n    \\<subseteq> outs_\\<I>\n                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                  ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                   ?\\<I>2.19))\n 3. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (attach_wiring_right parallel_wiring\\<^sub>w\n          (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     ((), ()) |\\<^sub>=\n    ?conv2'19 \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(subst id_converter_eq_self)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ?\\<I>2.19 \\<le> \\<I>_full\n 2. True\n 3. UNIV\n    \\<subseteq> outs_\\<I>\n                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                  ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                   ?\\<I>2.19))\n 4. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (attach_wiring_right parallel_wiring\\<^sub>w\n          (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     ((), ()) |\\<^sub>=\n    1\\<^sub>C \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(rule order_refl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. True\n 2. UNIV\n    \\<subseteq> outs_\\<I>\n                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                  ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                   \\<I>_full))\n 3. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (attach_wiring_right parallel_wiring\\<^sub>w\n          (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     ((), ()) |\\<^sub>=\n    1\\<^sub>C \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. UNIV\n    \\<subseteq> outs_\\<I>\n                 ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                  ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                    \\<I>_full) \\<oplus>\\<^sub>\\<I>\n                   \\<I>_full))\n 2. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (attach_wiring_right parallel_wiring\\<^sub>w\n          (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     ((), ()) |\\<^sub>=\n    1\\<^sub>C \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV \\<turnstile>\\<^sub>R\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (attach_wiring_right parallel_wiring\\<^sub>w\n          (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     ((), ()) |\\<^sub>=\n    1\\<^sub>C \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) \\<sim>\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(subst eq_resource_on_UNIV_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n    CNV (attach_wiring_right parallel_wiring\\<^sub>w\n          (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     ((), ()) |\\<^sub>=\n    1\\<^sub>C \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) =\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(subst (1 2 3) converter_of_callee_id_oracle[symmetric, of \"()\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (CNV 1\\<^sub>I () |\\<^sub>= CNV 1\\<^sub>I ()) |\\<^sub>=\n    CNV (attach_wiring_right parallel_wiring\\<^sub>w\n          (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n     ((), ()) |\\<^sub>=\n    CNV 1\\<^sub>I () \\<rhd>\n    RES (fused_resource.fuse (parallel_core key.core auth.core)\n          (parallel_rest key_rest auth_rest))\n     (((key.PState_Store, {}), sec.State_Void, {}), rinit key_rest,\n      rinit auth_rest) =\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(subst attach_parallel_fuse')"], ["proof (prove)\ngoal (1 subgoal):\n 1. RES (fused_resource.fuse\n          (attach_core 1\\<^sub>I\n            (attach_wiring_right parallel_wiring\\<^sub>w\n              (enc_callee \\<ddagger>\\<^sub>I dec_callee))\n            (parallel_core key.core auth.core))\n          (attach_rest 1\\<^sub>I 1\\<^sub>I ?f_init70\n            (parallel_rest key_rest auth_rest)))\n     ((((), (), ()), (key.PState_Store, {}), sec.State_Void, {}), ((), ()),\n      rinit key_rest, rinit auth_rest) =\n    RES (fused_resource.fuse real_core' real_rest')\n     (real_s_core', real_s_rest')", "apply(simp add: fact1 fact2 real_s_core'_def real_s_rest'_def ideal_s_rest'_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  real_resource =\n  RES (fused_resource.fuse real_core' real_rest')\n   (real_s_core', real_s_rest')\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Proving the trace-equivalence of simplified Ideal and Real constructions\\<close>"], ["", "context\nbegin"], ["", "subsubsection \\<open>Proving the trace-equivalence of cores\\<close>"], ["", "private"], ["", "abbreviation \n  \"a_I \\<equiv> \\<lambda>(x, y). ((((), x, ()), ()), y)\""], ["", "private"], ["", "abbreviation\n  \"a_R \\<equiv> \\<lambda>x. (((), (), ()), x)\""], ["", "abbreviation\n  \"asm_act \\<equiv> (\\<lambda>flg pset_sec pset_key pset_auth pset_union.\n     pset_union = pset_key <+> pset_auth \\<and>\n     (flg \\<longrightarrow> pset_sec = sec_party_of_key_party ` pset_key \\<inter> pset_auth))\""], ["", "private"], ["", "inductive S :: \"(((_ \\<times> 'msg option \\<times> _) \\<times> _) \\<times> estate \\<times> 'msg sec.state) spmf \n  \\<Rightarrow> (_ \\<times> 'msg key.state \\<times> 'msg auth.state) spmf \\<Rightarrow> bool\"\n  where\n\\<comment> \\<open>(Auth =a)@(Key =0)\\<close>\n    s_0_0: \"S (return_spmf (a_I (None, (False, s_act_ka), sec.State_Void, s_act_s))) \n      (return_spmf (a_R ((key.PState_Store, s_act_k), auth.State_Void, s_act_a)))\"\n  if \"asm_act False s_act_s s_act_k s_act_a s_act_ka\" and \"s_act_s = {}\"\n\\<comment> \\<open>(Auth =a)@(Key =1)\\<close>\n  | s_0_1: \"S (return_spmf (a_I (None, (True, s_act_ka), sec.State_Void, s_act)))\n      (map_spmf (\\<lambda>key. a_R ((key.State_Store key, s_act_k), auth.State_Void, s_act_a)) (spmf_of_set (carrier \\<L>)))\"\n  if \"asm_act True s_act s_act_k s_act_a s_act_ka\"\n\\<comment> \\<open>../(Auth =a)@(Key =1) \\# wl\\<close>\n  | s_1_1: \"S (return_spmf (a_I (None, (True ,s_act_ka), sec.State_Store msg, s_act_s)))\n      (map_spmf (\\<lambda>key. a_R ((key.State_Store key, s_act_k), auth.State_Store (key \\<oplus> msg), s_act_a)) (spmf_of_set (carrier \\<L>)))\"\n  if \"asm_act True s_act_s s_act_k s_act_a s_act_ka\" and \"key.Alice \\<in> s_act_k\" and \"auth.Alice \\<in> s_act_a\" and \"msg \\<in> carrier \\<L>\"\n  | s_2_1: \"S (return_spmf (a_I (None, (True ,s_act_ka), sec.State_Collect msg, s_act_s)))\n      (map_spmf (\\<lambda>key. a_R ((key.State_Store key, s_act_k), auth.State_Collect (key \\<oplus> msg), s_act_a)) (spmf_of_set (carrier \\<L>)))\"\n  if \"asm_act True s_act_s s_act_k s_act_a s_act_ka\" and \"key.Alice \\<in> s_act_k\" and \"auth.Alice \\<in> s_act_a\" and \"msg \\<in> carrier \\<L>\"\n  | s_3_1: \"S (return_spmf (a_I (None, (True ,s_act_ka), sec.State_Collected, s_act_s)))\n      (map_spmf (\\<lambda>key. a_R ((key.State_Store key, s_act_k), auth.State_Collected, s_act_a)) (spmf_of_set (carrier \\<L>)))\"\n  if \"asm_act True s_act_s s_act_k s_act_a s_act_ka\" and \"s_act_k = {key.Alice, key.Bob}\" and \"s_act_a = {auth.Alice, auth.Bob}\"\n\\<comment> \\<open>../(Auth =a)@(Key =1) \\# look\\<close>\n  | s_1'_1: \"S (return_spmf (a_I (Some (key \\<oplus> msg), (True ,s_act_ka), sec.State_Store msg, s_act_s)))\n      (return_spmf (a_R ((key.State_Store key, s_act_k), auth.State_Store (key \\<oplus> msg), s_act_a)))\"\n  if \"asm_act True s_act_s s_act_k s_act_a s_act_ka\" and \"key.Alice \\<in> s_act_k\" and \"auth.Alice \\<in> s_act_a\" and \"msg \\<in> carrier \\<L>\" and \"key \\<in> carrier \\<L>\"\n  | s_2'_1: \"S (return_spmf (a_I (Some (key \\<oplus> msg), (True ,s_act_ka), sec.State_Collect msg, s_act_s)))\n      (return_spmf (a_R ((key.State_Store key, s_act_k), auth.State_Collect (key \\<oplus> msg), s_act_a)))\"\n  if \"asm_act True s_act_s s_act_k s_act_a s_act_ka\" and \"key.Alice \\<in> s_act_k\" and \"auth.Alice \\<in> s_act_a\" and \"msg \\<in> carrier \\<L>\" and \"key \\<in> carrier \\<L>\"\n  | s_3'_1: \"S (return_spmf (a_I (Some (key \\<oplus> msg), (True ,s_act_ka), sec.State_Collected, s_act_s)))\n      (return_spmf (a_R ((key.State_Store key, s_act_k), auth.State_Collected, s_act_a)))\"\n  if \"asm_act True s_act_s s_act_k s_act_a s_act_ka\" and \"s_act_k = {key.Alice, key.Bob}\" and \"s_act_a = {auth.Alice, auth.Bob}\" and \"msg \\<in> carrier \\<L>\" and \"key \\<in> carrier \\<L>\""], ["", "private"], ["", "lemma trace_eq_core: \"trace_core_eq ideal_core' real_core' \n  UNIV (UNIV <+> UNIV <+> UNIV <+> (auth.Inp_Fedit ` carrier \\<L>)) ((sec.Inp_Send ` carrier \\<L>) <+> UNIV) \n  (return_spmf ideal_s_core') (return_spmf real_s_core')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_core_eq ideal_core' real_core' UNIV\n     (UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>)\n     (sec.Inp_Send ` carrier \\<L> <+> UNIV) (return_spmf ideal_s_core')\n     (return_spmf real_s_core')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace_core_eq ideal_core' real_core' UNIV\n     (UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>)\n     (sec.Inp_Send ` carrier \\<L> <+> UNIV) (return_spmf ideal_s_core')\n     (return_spmf real_s_core')", "have inj_xor: \"\\<lbrakk>msg \\<in> carrier \\<L> ; x \\<in> carrier \\<L>; y \\<in> carrier \\<L>; x \\<oplus> msg = y \\<oplus> msg\\<rbrakk> \\<Longrightarrow> x = y\" for msg x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>msg \\<in> carrier \\<L>; x \\<in> carrier \\<L>;\n     y \\<in> carrier \\<L>; x \\<oplus> msg = y \\<oplus> msg\\<rbrakk>\n    \\<Longrightarrow> x = y", "by (metis (no_types, hide_lams) local.xor_ac(2) local.xor_left_inverse)"], ["proof (state)\nthis:\n  \\<lbrakk>?msg5 \\<in> carrier \\<L>; ?x5 \\<in> carrier \\<L>;\n   ?y5 \\<in> carrier \\<L>; ?x5 \\<oplus> ?msg5 = ?y5 \\<oplus> ?msg5\\<rbrakk>\n  \\<Longrightarrow> ?x5 = ?y5\n\ngoal (1 subgoal):\n 1. trace_core_eq ideal_core' real_core' UNIV\n     (UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>)\n     (sec.Inp_Send ` carrier \\<L> <+> UNIV) (return_spmf ideal_s_core')\n     (return_spmf real_s_core')", "note [simp] = enc_callee_def dec_callee_def look_callee_def nempty_carrier finite_carrier\n    exec_gpv_bind spmf.map_comp map_bind_spmf bind_map_spmf bind_spmf_const o_def Let_def"], ["proof (state)\nthis:\n  enc_callee \\<equiv>\n  stateless_callee\n   (\\<lambda>inp.\n       case inp of\n       sec.Inp_Send msg \\<Rightarrow>\n         if msg \\<in> carrier \\<L>\n         then Generative_Probabilistic_Value.Pause (Inl key.Inp_Alice)\n               (\\<lambda>kout.\n                   case projl kout of\n                   key.Out_Alice key \\<Rightarrow>\n                     let cipher = key \\<oplus> msg\n                     in Generative_Probabilistic_Value.Pause\n                         (Inr (sec.Inp_Send cipher))\n                         (\\<lambda>_.\n                             Generative_Probabilistic_Value.Done\n                              sec.Out_Send))\n         else Fail)\n  dec_callee \\<equiv>\n  stateless_callee\n   (\\<lambda>_.\n       Generative_Probabilistic_Value.Pause (Inr sec.Inp_Recv)\n        (\\<lambda>cout.\n            case cout of Inl a \\<Rightarrow> Fail\n            | Inr (sec.Out_Recv cipher) \\<Rightarrow>\n                Generative_Probabilistic_Value.Pause (Inl key.Inp_Bob)\n                 (\\<lambda>kout.\n                     case projl kout of\n                     key.Out_Bob key \\<Rightarrow>\n                       Generative_Probabilistic_Value.Done\n                        (sec.Out_Recv (key \\<oplus> cipher)))))\n  look_callee \\<equiv>\n  \\<lambda>state inp.\n     Generative_Probabilistic_Value.Pause sec.Inp_Look\n      (\\<lambda>cout.\n          case cout of\n          sec.Out_Look msg_set \\<Rightarrow>\n            case state of\n            None \\<Rightarrow>\n              bind_gpv (lift_spmf (spmf_of_set msg_set))\n               (\\<lambda>msg.\n                   Generative_Probabilistic_Value.Done\n                    (sec.Out_Look msg, Some msg))\n            | Some msg \\<Rightarrow>\n                Generative_Probabilistic_Value.Done\n                 (sec.Out_Look msg, Some msg))\n  carrier \\<L> \\<noteq> {}\n  finite (carrier \\<L>)\n  exec_gpv ?callee (bind_gpv ?c ?f) ?s =\n  bind_spmf (exec_gpv ?callee ?c ?s)\n   (\\<lambda>xa.\n       case xa of (x, s') \\<Rightarrow> exec_gpv ?callee (?f x) s')\n  map_spmf ?f (map_spmf ?g ?p) = map_spmf (?f \\<circ> ?g) ?p\n  map_spmf ?f (bind_spmf ?p ?g) = bind_spmf ?p (map_spmf ?f \\<circ> ?g)\n  bind_spmf (map_spmf ?f ?p) ?g = bind_spmf ?p (?g \\<circ> ?f)\n  bind_spmf ?p (\\<lambda>x. ?q) = scale_spmf (weight_spmf ?p) ?q\n  ?f \\<circ> ?g = (\\<lambda>x. ?f (?g x))\n  Let ?s ?f \\<equiv> ?f ?s\n\ngoal (1 subgoal):\n 1. trace_core_eq ideal_core' real_core' UNIV\n     (UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>)\n     (sec.Inp_Send ` carrier \\<L> <+> UNIV) (return_spmf ideal_s_core')\n     (return_spmf real_s_core')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_core_eq ideal_core' real_core' UNIV\n     (UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>)\n     (sec.Inp_Send ` carrier \\<L> <+> UNIV) (return_spmf ideal_s_core')\n     (return_spmf real_s_core')", "apply (rule trace_core_eq_simI_upto[where S=S])"], ["proof (prove)\ngoal (7 subgoals):\n 1. S (return_spmf ideal_s_core') (return_spmf real_s_core')\n 2. \\<And>p q e.\n       \\<lbrakk>S p q; e \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> weight_spmf\n                          (bind_spmf p\n                            (\\<lambda>s. cpoke ideal_core' s e)) =\n                         weight_spmf\n                          (bind_spmf q (\\<lambda>s. cpoke real_core' s e))\n 3. \\<And>p q e.\n       \\<lbrakk>S p q; e \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (mk_lossless\n                            (bind_spmf p\n                              (\\<lambda>s. cpoke ideal_core' s e)))\n                          (mk_lossless\n                            (bind_spmf q\n                              (\\<lambda>s. cpoke real_core' s e)))\n 4. \\<And>p q ia.\n       \\<lbrakk>S p q;\n        ia \\<in> UNIV <+>\n                 UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf p\n                          (\\<lambda>s1.\n                              map_spmf fst (cfunc_adv ideal_core' s1 ia)) =\n                         bind_spmf q\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 ia))\n 5. \\<And>p q ia s1 s2 s1' s2' oa.\n       \\<lbrakk>S p q;\n        ia \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv ideal_core' s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv real_core' s2 ia)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf p\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (bind_spmf q\n                              (\\<lambda>s2. cfunc_adv real_core' s2 ia))\n                            oa)\n 6. \\<And>p q iu.\n       \\<lbrakk>S p q;\n        iu \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV\\<rbrakk>\n       \\<Longrightarrow> bind_spmf p\n                          (\\<lambda>s1.\n                              map_spmf fst (cfunc_usr ideal_core' s1 iu)) =\n                         bind_spmf q\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 iu))\n 7. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>S p q; iu \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr ideal_core' s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr real_core' s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf p\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (bind_spmf q\n                              (\\<lambda>s2. cfunc_usr real_core' s2 iu))\n                            ou)", "subgoal Init_OK"], ["proof (prove)\ngoal (1 subgoal):\n 1. S (return_spmf ideal_s_core') (return_spmf real_s_core')", "by (simp add: ideal_s_core'_def real_s_core'_def S.simps)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>p q e.\n       \\<lbrakk>S p q; e \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> weight_spmf\n                          (bind_spmf p\n                            (\\<lambda>s. cpoke ideal_core' s e)) =\n                         weight_spmf\n                          (bind_spmf q (\\<lambda>s. cpoke real_core' s e))\n 2. \\<And>p q e.\n       \\<lbrakk>S p q; e \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (mk_lossless\n                            (bind_spmf p\n                              (\\<lambda>s. cpoke ideal_core' s e)))\n                          (mk_lossless\n                            (bind_spmf q\n                              (\\<lambda>s. cpoke real_core' s e)))\n 3. \\<And>p q ia.\n       \\<lbrakk>S p q;\n        ia \\<in> UNIV <+>\n                 UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf p\n                          (\\<lambda>s1.\n                              map_spmf fst (cfunc_adv ideal_core' s1 ia)) =\n                         bind_spmf q\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 ia))\n 4. \\<And>p q ia s1 s2 s1' s2' oa.\n       \\<lbrakk>S p q;\n        ia \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv ideal_core' s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv real_core' s2 ia)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf p\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (bind_spmf q\n                              (\\<lambda>s2. cfunc_adv real_core' s2 ia))\n                            oa)\n 5. \\<And>p q iu.\n       \\<lbrakk>S p q;\n        iu \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV\\<rbrakk>\n       \\<Longrightarrow> bind_spmf p\n                          (\\<lambda>s1.\n                              map_spmf fst (cfunc_usr ideal_core' s1 iu)) =\n                         bind_spmf q\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 iu))\n 6. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>S p q; iu \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr ideal_core' s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr real_core' s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf p\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (bind_spmf q\n                              (\\<lambda>s2. cfunc_usr real_core' s2 iu))\n                            ou)", "subgoal POut_OK for s_i s_r query"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r; query \\<in> UNIV\\<rbrakk>\n    \\<Longrightarrow> weight_spmf\n                       (bind_spmf s_i\n                         (\\<lambda>s. cpoke ideal_core' s query)) =\n                      weight_spmf\n                       (bind_spmf s_r\n                         (\\<lambda>s. cpoke real_core' s query))", "apply (cases query)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>S s_i s_r; query \\<in> UNIV; query = Inl a\\<rbrakk>\n       \\<Longrightarrow> weight_spmf\n                          (bind_spmf s_i\n                            (\\<lambda>s. cpoke ideal_core' s query)) =\n                         weight_spmf\n                          (bind_spmf s_r\n                            (\\<lambda>s. cpoke real_core' s query))\n 2. \\<And>b.\n       \\<lbrakk>S s_i s_r; query \\<in> UNIV; query = Inr b\\<rbrakk>\n       \\<Longrightarrow> weight_spmf\n                          (bind_spmf s_i\n                            (\\<lambda>s. cpoke ideal_core' s query)) =\n                         weight_spmf\n                          (bind_spmf s_r\n                            (\\<lambda>s. cpoke real_core' s query))", "subgoal for e_key"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r; query \\<in> UNIV; query = Inl e_key\\<rbrakk>\n    \\<Longrightarrow> weight_spmf\n                       (bind_spmf s_i\n                         (\\<lambda>s. cpoke ideal_core' s query)) =\n                      weight_spmf\n                       (bind_spmf s_r\n                         (\\<lambda>s. cpoke real_core' s query))", "apply (cases e_key)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>S s_i s_r; query \\<in> UNIV; query = Inl e_key;\n        e_key = key.Event_Shell x1\\<rbrakk>\n       \\<Longrightarrow> weight_spmf\n                          (bind_spmf s_i\n                            (\\<lambda>s. cpoke ideal_core' s query)) =\n                         weight_spmf\n                          (bind_spmf s_r\n                            (\\<lambda>s. cpoke real_core' s query))\n 2. \\<lbrakk>S s_i s_r; query \\<in> UNIV; query = Inl e_key;\n     e_key = key.Event_Kernel\\<rbrakk>\n    \\<Longrightarrow> weight_spmf\n                       (bind_spmf s_i\n                         (\\<lambda>s. cpoke ideal_core' s query)) =\n                      weight_spmf\n                       (bind_spmf s_r\n                         (\\<lambda>s. cpoke real_core' s query))", "subgoal for e_shell"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r; query \\<in> UNIV; query = Inl e_key;\n     e_key = key.Event_Shell e_shell\\<rbrakk>\n    \\<Longrightarrow> weight_spmf\n                       (bind_spmf s_i\n                         (\\<lambda>s. cpoke ideal_core' s query)) =\n                      weight_spmf\n                       (bind_spmf s_r\n                         (\\<lambda>s. cpoke real_core' s query))", "by (erule S.cases) (auto simp add: map_spmf_conv_bind_spmf[symmetric] split: key.party.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r; query \\<in> UNIV; query = Inl e_key;\n     e_key = key.Event_Kernel\\<rbrakk>\n    \\<Longrightarrow> weight_spmf\n                       (bind_spmf s_i\n                         (\\<lambda>s. cpoke ideal_core' s query)) =\n                      weight_spmf\n                       (bind_spmf s_r\n                         (\\<lambda>s. cpoke real_core' s query))", "subgoal e_kernel"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r; query \\<in> UNIV; query = Inl e_key;\n     e_key = key.Event_Kernel\\<rbrakk>\n    \\<Longrightarrow> weight_spmf\n                       (bind_spmf s_i\n                         (\\<lambda>s. cpoke ideal_core' s query)) =\n                      weight_spmf\n                       (bind_spmf s_r\n                         (\\<lambda>s. cpoke real_core' s query))", "by (erule S.cases) (auto simp add: map_spmf_conv_bind_spmf[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>S s_i s_r; query \\<in> UNIV; query = Inr b\\<rbrakk>\n       \\<Longrightarrow> weight_spmf\n                          (bind_spmf s_i\n                            (\\<lambda>s. cpoke ideal_core' s query)) =\n                         weight_spmf\n                          (bind_spmf s_r\n                            (\\<lambda>s. cpoke real_core' s query))", "subgoal for e_auth"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r; query \\<in> UNIV; query = Inr e_auth\\<rbrakk>\n    \\<Longrightarrow> weight_spmf\n                       (bind_spmf s_i\n                         (\\<lambda>s. cpoke ideal_core' s query)) =\n                      weight_spmf\n                       (bind_spmf s_r\n                         (\\<lambda>s. cpoke real_core' s query))", "apply (cases e_auth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>S s_i s_r; query \\<in> UNIV; query = Inr e_auth;\n        e_auth = sec.Event_Shell x\\<rbrakk>\n       \\<Longrightarrow> weight_spmf\n                          (bind_spmf s_i\n                            (\\<lambda>s. cpoke ideal_core' s query)) =\n                         weight_spmf\n                          (bind_spmf s_r\n                            (\\<lambda>s. cpoke real_core' s query))", "subgoal for e_shell"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r; query \\<in> UNIV; query = Inr e_auth;\n     e_auth = sec.Event_Shell e_shell\\<rbrakk>\n    \\<Longrightarrow> weight_spmf\n                       (bind_spmf s_i\n                         (\\<lambda>s. cpoke ideal_core' s query)) =\n                      weight_spmf\n                       (bind_spmf s_r\n                         (\\<lambda>s. cpoke real_core' s query))", "by (erule S.cases) (auto simp add: map_spmf_conv_bind_spmf[symmetric] split:auth.party.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>p q e.\n       \\<lbrakk>S p q; e \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (mk_lossless\n                            (bind_spmf p\n                              (\\<lambda>s. cpoke ideal_core' s e)))\n                          (mk_lossless\n                            (bind_spmf q\n                              (\\<lambda>s. cpoke real_core' s e)))\n 2. \\<And>p q ia.\n       \\<lbrakk>S p q;\n        ia \\<in> UNIV <+>\n                 UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf p\n                          (\\<lambda>s1.\n                              map_spmf fst (cfunc_adv ideal_core' s1 ia)) =\n                         bind_spmf q\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 ia))\n 3. \\<And>p q ia s1 s2 s1' s2' oa.\n       \\<lbrakk>S p q;\n        ia \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv ideal_core' s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv real_core' s2 ia)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf p\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (bind_spmf q\n                              (\\<lambda>s2. cfunc_adv real_core' s2 ia))\n                            oa)\n 4. \\<And>p q iu.\n       \\<lbrakk>S p q;\n        iu \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV\\<rbrakk>\n       \\<Longrightarrow> bind_spmf p\n                          (\\<lambda>s1.\n                              map_spmf fst (cfunc_usr ideal_core' s1 iu)) =\n                         bind_spmf q\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 iu))\n 5. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>S p q; iu \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr ideal_core' s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr real_core' s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf p\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (bind_spmf q\n                              (\\<lambda>s2. cfunc_usr real_core' s2 iu))\n                            ou)", "subgoal PState_OK for s_i s_r query"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r; query \\<in> UNIV\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (mk_lossless\n                         (bind_spmf s_i\n                           (\\<lambda>s. cpoke ideal_core' s query)))\n                       (mk_lossless\n                         (bind_spmf s_r\n                           (\\<lambda>s. cpoke real_core' s query)))", "apply (cases query)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>S s_i s_r; query \\<in> UNIV; query = Inl a\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (mk_lossless\n                            (bind_spmf s_i\n                              (\\<lambda>s. cpoke ideal_core' s query)))\n                          (mk_lossless\n                            (bind_spmf s_r\n                              (\\<lambda>s. cpoke real_core' s query)))\n 2. \\<And>b.\n       \\<lbrakk>S s_i s_r; query \\<in> UNIV; query = Inr b\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (mk_lossless\n                            (bind_spmf s_i\n                              (\\<lambda>s. cpoke ideal_core' s query)))\n                          (mk_lossless\n                            (bind_spmf s_r\n                              (\\<lambda>s. cpoke real_core' s query)))", "subgoal for e_key"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r; query \\<in> UNIV; query = Inl e_key\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (mk_lossless\n                         (bind_spmf s_i\n                           (\\<lambda>s. cpoke ideal_core' s query)))\n                       (mk_lossless\n                         (bind_spmf s_r\n                           (\\<lambda>s. cpoke real_core' s query)))", "apply (cases e_key)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>S s_i s_r; query \\<in> UNIV; query = Inl e_key;\n        e_key = key.Event_Shell x1\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (mk_lossless\n                            (bind_spmf s_i\n                              (\\<lambda>s. cpoke ideal_core' s query)))\n                          (mk_lossless\n                            (bind_spmf s_r\n                              (\\<lambda>s. cpoke real_core' s query)))\n 2. \\<lbrakk>S s_i s_r; query \\<in> UNIV; query = Inl e_key;\n     e_key = key.Event_Kernel\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (mk_lossless\n                         (bind_spmf s_i\n                           (\\<lambda>s. cpoke ideal_core' s query)))\n                       (mk_lossless\n                         (bind_spmf s_r\n                           (\\<lambda>s. cpoke real_core' s query)))", "subgoal for e_shell"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r; query \\<in> UNIV; query = Inl e_key;\n     e_key = key.Event_Shell e_shell\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (mk_lossless\n                         (bind_spmf s_i\n                           (\\<lambda>s. cpoke ideal_core' s query)))\n                       (mk_lossless\n                         (bind_spmf s_r\n                           (\\<lambda>s. cpoke real_core' s query)))", "by (erule S.cases) (auto simp add: map_spmf_conv_bind_spmf[symmetric] intro!: trace_eq_simcl.base S.intros[simplified] split: key.party.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r; query \\<in> UNIV; query = Inl e_key;\n     e_key = key.Event_Kernel\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (mk_lossless\n                         (bind_spmf s_i\n                           (\\<lambda>s. cpoke ideal_core' s query)))\n                       (mk_lossless\n                         (bind_spmf s_r\n                           (\\<lambda>s. cpoke real_core' s query)))", "subgoal e_kernel"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r; query \\<in> UNIV; query = Inl e_key;\n     e_key = key.Event_Kernel\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (mk_lossless\n                         (bind_spmf s_i\n                           (\\<lambda>s. cpoke ideal_core' s query)))\n                       (mk_lossless\n                         (bind_spmf s_r\n                           (\\<lambda>s. cpoke real_core' s query)))", "by (erule S.cases) (auto simp add: map_spmf_conv_bind_spmf[symmetric] sec_party_of_key_party_def intro!: trace_eq_simcl.base S.intros[simplified] split: key.party.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>S s_i s_r; query \\<in> UNIV; query = Inr b\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (mk_lossless\n                            (bind_spmf s_i\n                              (\\<lambda>s. cpoke ideal_core' s query)))\n                          (mk_lossless\n                            (bind_spmf s_r\n                              (\\<lambda>s. cpoke real_core' s query)))", "subgoal for e_auth"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r; query \\<in> UNIV; query = Inr e_auth\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (mk_lossless\n                         (bind_spmf s_i\n                           (\\<lambda>s. cpoke ideal_core' s query)))\n                       (mk_lossless\n                         (bind_spmf s_r\n                           (\\<lambda>s. cpoke real_core' s query)))", "apply (cases e_auth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>S s_i s_r; query \\<in> UNIV; query = Inr e_auth;\n        e_auth = sec.Event_Shell x\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (mk_lossless\n                            (bind_spmf s_i\n                              (\\<lambda>s. cpoke ideal_core' s query)))\n                          (mk_lossless\n                            (bind_spmf s_r\n                              (\\<lambda>s. cpoke real_core' s query)))", "subgoal for e_shell"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r; query \\<in> UNIV; query = Inr e_auth;\n     e_auth = sec.Event_Shell e_shell\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (mk_lossless\n                         (bind_spmf s_i\n                           (\\<lambda>s. cpoke ideal_core' s query)))\n                       (mk_lossless\n                         (bind_spmf s_r\n                           (\\<lambda>s. cpoke real_core' s query)))", "by (erule S.cases) (auto simp add: map_spmf_conv_bind_spmf[symmetric] intro!: trace_eq_simcl.base S.intros[simplified] split:auth.party.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>p q ia.\n       \\<lbrakk>S p q;\n        ia \\<in> UNIV <+>\n                 UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf p\n                          (\\<lambda>s1.\n                              map_spmf fst (cfunc_adv ideal_core' s1 ia)) =\n                         bind_spmf q\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 ia))\n 2. \\<And>p q ia s1 s2 s1' s2' oa.\n       \\<lbrakk>S p q;\n        ia \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv ideal_core' s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv real_core' s2 ia)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf p\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (bind_spmf q\n                              (\\<lambda>s2. cfunc_adv real_core' s2 ia))\n                            oa)\n 3. \\<And>p q iu.\n       \\<lbrakk>S p q;\n        iu \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV\\<rbrakk>\n       \\<Longrightarrow> bind_spmf p\n                          (\\<lambda>s1.\n                              map_spmf fst (cfunc_usr ideal_core' s1 iu)) =\n                         bind_spmf q\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 iu))\n 4. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>S p q; iu \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr ideal_core' s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr real_core' s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf p\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (bind_spmf q\n                              (\\<lambda>s2. cfunc_usr real_core' s2 iu))\n                            ou)", "subgoal AOut_OK for s_i s_r query"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r;\n     query\n     \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>\\<rbrakk>\n    \\<Longrightarrow> bind_spmf s_i\n                       (\\<lambda>s1.\n                           map_spmf fst (cfunc_adv ideal_core' s1 query)) =\n                      bind_spmf s_r\n                       (\\<lambda>s2.\n                           map_spmf fst (cfunc_adv real_core' s2 query))", "apply (cases query)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>S s_i s_r;\n        query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inl a\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))\n 2. \\<And>b.\n       \\<lbrakk>S s_i s_r;\n        query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr b\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))", "subgoal for q_key"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r;\n     query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n     query = Inl q_key\\<rbrakk>\n    \\<Longrightarrow> bind_spmf s_i\n                       (\\<lambda>s1.\n                           map_spmf fst (cfunc_adv ideal_core' s1 query)) =\n                      bind_spmf s_r\n                       (\\<lambda>s2.\n                           map_spmf fst (cfunc_adv real_core' s2 query))", "by (erule S.cases) simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>S s_i s_r;\n        query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr b\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))", "subgoal for q_auth"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r;\n     query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n     query = Inr q_auth\\<rbrakk>\n    \\<Longrightarrow> bind_spmf s_i\n                       (\\<lambda>s1.\n                           map_spmf fst (cfunc_adv ideal_core' s1 query)) =\n                      bind_spmf s_r\n                       (\\<lambda>s2.\n                           map_spmf fst (cfunc_adv real_core' s2 query))", "apply (cases q_auth)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>S s_i s_r;\n        query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inl a\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))\n 2. \\<And>b.\n       \\<lbrakk>S s_i s_r;\n        query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr b\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))", "subgoal for q_auth_drop"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r;\n     query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n     query = Inr q_auth; q_auth = Inl q_auth_drop\\<rbrakk>\n    \\<Longrightarrow> bind_spmf s_i\n                       (\\<lambda>s1.\n                           map_spmf fst (cfunc_adv ideal_core' s1 query)) =\n                      bind_spmf s_r\n                       (\\<lambda>s2.\n                           map_spmf fst (cfunc_adv real_core' s2 query))", "by (erule S.cases) (simp_all add: id_oracle_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>S s_i s_r;\n        query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr b\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))", "subgoal for q_auth_lfe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r;\n     query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n     query = Inr q_auth; q_auth = Inr q_auth_lfe\\<rbrakk>\n    \\<Longrightarrow> bind_spmf s_i\n                       (\\<lambda>s1.\n                           map_spmf fst (cfunc_adv ideal_core' s1 query)) =\n                      bind_spmf s_r\n                       (\\<lambda>s2.\n                           map_spmf fst (cfunc_adv real_core' s2 query))", "apply (cases q_auth_lfe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>S s_i s_r;\n        query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl a\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))\n 2. \\<And>b.\n       \\<lbrakk>S s_i s_r;\n        query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inr b\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))", "subgoal for q_auth_look"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r;\n     query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n     query = Inr q_auth; q_auth = Inr q_auth_lfe;\n     q_auth_lfe = Inl q_auth_look\\<rbrakk>\n    \\<Longrightarrow> bind_spmf s_i\n                       (\\<lambda>s1.\n                           map_spmf fst (cfunc_adv ideal_core' s1 query)) =\n                      bind_spmf s_r\n                       (\\<lambda>s2.\n                           map_spmf fst (cfunc_adv real_core' s2 query))", "proof (erule S.cases, goal_cases)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (False, s_act_ka), sec.State_Void, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.PState_Store, s_act_k), sec.State_Void,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (False \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_s = {}\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))\n 2. \\<And>s_act s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n              s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))\n 3. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Store (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))\n 4. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collect (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))\n 5. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collected, s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob};\n        s_act_a = {sec.Alice, sec.Bob}\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))\n 6. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Store (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))\n 7. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Collect (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))\n 8. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob}; s_act_a = {sec.Alice, sec.Bob};\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))", "case (3 s_act_s s_act_k s_act_a s_act_ka msg) \\<comment> \\<open>Corresponds to @{thm [source] s_1_1}\\<close>"], ["proof (state)\nthis:\n  query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>\n  query = Inr q_auth\n  q_auth = Inr q_auth_lfe\n  q_auth_lfe = Inl q_auth_look\n  s_i =\n  return_spmf\n   (case (None, (True, s_act_ka), sec.State_Store msg, s_act_s) of\n    (x, y) \\<Rightarrow> ((((), x, ()), ()), y))\n  s_r =\n  map_spmf\n   (\\<lambda>key.\n       (((), (), ()), (key.State_Store key, s_act_k),\n        sec.State_Store (key \\<oplus> msg), s_act_a))\n   (spmf_of_set (carrier \\<L>))\n  s_act_ka = s_act_k <+> s_act_a \\<and>\n  (True \\<longrightarrow>\n   s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\n  key.Alice \\<in> s_act_k\n  sec.Alice \\<in> s_act_a\n  msg \\<in> carrier \\<L>\n\ngoal (8 subgoals):\n 1. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (False, s_act_ka), sec.State_Void, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.PState_Store, s_act_k), sec.State_Void,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (False \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_s = {}\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))\n 2. \\<And>s_act s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n              s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))\n 3. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Store (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))\n 4. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collect (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))\n 5. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collected, s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob};\n        s_act_a = {sec.Alice, sec.Bob}\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))\n 6. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Store (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))\n 7. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Collect (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))\n 8. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob}; s_act_a = {sec.Alice, sec.Bob};\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))", "then"], ["proof (chain)\npicking this:\n  query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>\n  query = Inr q_auth\n  q_auth = Inr q_auth_lfe\n  q_auth_lfe = Inl q_auth_look\n  s_i =\n  return_spmf\n   (case (None, (True, s_act_ka), sec.State_Store msg, s_act_s) of\n    (x, y) \\<Rightarrow> ((((), x, ()), ()), y))\n  s_r =\n  map_spmf\n   (\\<lambda>key.\n       (((), (), ()), (key.State_Store key, s_act_k),\n        sec.State_Store (key \\<oplus> msg), s_act_a))\n   (spmf_of_set (carrier \\<L>))\n  s_act_ka = s_act_k <+> s_act_a \\<and>\n  (True \\<longrightarrow>\n   s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\n  key.Alice \\<in> s_act_k\n  sec.Alice \\<in> s_act_a\n  msg \\<in> carrier \\<L>", "show ?case"], ["proof (prove)\nusing this:\n  query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>\n  query = Inr q_auth\n  q_auth = Inr q_auth_lfe\n  q_auth_lfe = Inl q_auth_look\n  s_i =\n  return_spmf\n   (case (None, (True, s_act_ka), sec.State_Store msg, s_act_s) of\n    (x, y) \\<Rightarrow> ((((), x, ()), ()), y))\n  s_r =\n  map_spmf\n   (\\<lambda>key.\n       (((), (), ()), (key.State_Store key, s_act_k),\n        sec.State_Store (key \\<oplus> msg), s_act_a))\n   (spmf_of_set (carrier \\<L>))\n  s_act_ka = s_act_k <+> s_act_a \\<and>\n  (True \\<longrightarrow>\n   s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\n  key.Alice \\<in> s_act_k\n  sec.Alice \\<in> s_act_a\n  msg \\<in> carrier \\<L>\n\ngoal (1 subgoal):\n 1. bind_spmf s_i\n     (\\<lambda>s1. map_spmf fst (cfunc_adv ideal_core' s1 query)) =\n    bind_spmf s_r\n     (\\<lambda>s2. map_spmf fst (cfunc_adv real_core' s2 query))", "apply(simp add: exec_gpv_extend_state_oracle exec_gpv_map_gpv_id exec_gpv_plus_oracle_right exec_gpv_plus_oracle_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>query = Inr (Inr (Inl q_auth_look));\n     q_auth = Inr (Inl q_auth_look); q_auth_lfe = Inl q_auth_look;\n     s_i =\n     return_spmf\n      ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n       sec.State_Store msg,\n       sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k),\n           sec.State_Store (key \\<oplus> msg), s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>\\<rbrakk>\n    \\<Longrightarrow> bind_spmf (spmf_of_set (carrier \\<L>))\n                       (\\<lambda>x.\n                           return_spmf (Inr (Inr (Inl (sec.Out_Look x))))) =\n                      bind_spmf (spmf_of_set (carrier \\<L>))\n                       (\\<lambda>x.\n                           return_spmf\n                            (Inr (Inr (Inl\n  (sec.Out_Look (x \\<oplus> msg))))))", "apply (subst one_time_pad[symmetric, of \"msg\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>query = Inr (Inr (Inl q_auth_look));\n     q_auth = Inr (Inl q_auth_look); q_auth_lfe = Inl q_auth_look;\n     s_i =\n     return_spmf\n      ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n       sec.State_Store msg,\n       sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k),\n           sec.State_Store (key \\<oplus> msg), s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>\\<rbrakk>\n    \\<Longrightarrow> msg \\<in> carrier \\<L>\n 2. \\<lbrakk>query = Inr (Inr (Inl q_auth_look));\n     q_auth = Inr (Inl q_auth_look); q_auth_lfe = Inl q_auth_look;\n     s_i =\n     return_spmf\n      ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n       sec.State_Store msg,\n       sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k),\n           sec.State_Store (key \\<oplus> msg), s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>\\<rbrakk>\n    \\<Longrightarrow> bind_spmf\n                       (map_spmf ((\\<oplus>) msg)\n                         (spmf_of_set (carrier \\<L>)))\n                       (\\<lambda>x.\n                           return_spmf (Inr (Inr (Inl (sec.Out_Look x))))) =\n                      bind_spmf (spmf_of_set (carrier \\<L>))\n                       (\\<lambda>x.\n                           return_spmf\n                            (Inr (Inr (Inl\n  (sec.Out_Look (x \\<oplus> msg))))))", "apply (simp_all add: xor_comm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>query = Inr (Inr (Inl q_auth_look));\n     q_auth = Inr (Inl q_auth_look); q_auth_lfe = Inl q_auth_look;\n     s_i =\n     return_spmf\n      ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n       sec.State_Store msg,\n       sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k),\n           sec.State_Store (key \\<oplus> msg), s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>\\<rbrakk>\n    \\<Longrightarrow> bind_spmf (spmf_of_set (carrier \\<L>))\n                       (\\<lambda>x.\n                           return_spmf\n                            (Inr (Inr (Inl\n  (sec.Out_Look (msg \\<oplus> x)))))) =\n                      bind_spmf (spmf_of_set (carrier \\<L>))\n                       (\\<lambda>x.\n                           return_spmf\n                            (Inr (Inr (Inl\n  (sec.Out_Look (x \\<oplus> msg))))))", "apply (rule bind_spmf_cong[OF HOL.refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>query = Inr (Inr (Inl q_auth_look));\n        q_auth = Inr (Inl q_auth_look); q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n          sec.State_Store msg,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Store (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>;\n        x \\<in> set_spmf (spmf_of_set (carrier \\<L>))\\<rbrakk>\n       \\<Longrightarrow> return_spmf\n                          (Inr (Inr (Inl\n(sec.Out_Look (msg \\<oplus> x))))) =\n                         return_spmf\n                          (Inr (Inr (Inl (sec.Out_Look (x \\<oplus> msg)))))", "by (simp add: xor_comm)"], ["proof (state)\nthis:\n  bind_spmf s_i\n   (\\<lambda>s1. map_spmf fst (cfunc_adv ideal_core' s1 query)) =\n  bind_spmf s_r (\\<lambda>s2. map_spmf fst (cfunc_adv real_core' s2 query))\n\ngoal (7 subgoals):\n 1. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (False, s_act_ka), sec.State_Void, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.PState_Store, s_act_k), sec.State_Void,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (False \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_s = {}\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))\n 2. \\<And>s_act s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n              s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))\n 3. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collect (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))\n 4. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collected, s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob};\n        s_act_a = {sec.Alice, sec.Bob}\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))\n 5. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Store (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))\n 6. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Collect (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))\n 7. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob}; s_act_a = {sec.Alice, sec.Bob};\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))", "qed simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>S s_i s_r;\n        query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inr b\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_adv ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_adv real_core' s2 query))", "subgoal for q_auth_fedit"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r;\n     query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n     query = Inr q_auth; q_auth = Inr q_auth_lfe;\n     q_auth_lfe = Inr q_auth_fedit\\<rbrakk>\n    \\<Longrightarrow> bind_spmf s_i\n                       (\\<lambda>s1.\n                           map_spmf fst (cfunc_adv ideal_core' s1 query)) =\n                      bind_spmf s_r\n                       (\\<lambda>s2.\n                           map_spmf fst (cfunc_adv real_core' s2 query))", "by (erule S.cases) (auto simp add: id_oracle_def split:auth.iadv_fedit.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>p q ia s1 s2 s1' s2' oa.\n       \\<lbrakk>S p q;\n        ia \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv ideal_core' s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv real_core' s2 ia)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf p\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (bind_spmf q\n                              (\\<lambda>s2. cfunc_adv real_core' s2 ia))\n                            oa)\n 2. \\<And>p q iu.\n       \\<lbrakk>S p q;\n        iu \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV\\<rbrakk>\n       \\<Longrightarrow> bind_spmf p\n                          (\\<lambda>s1.\n                              map_spmf fst (cfunc_usr ideal_core' s1 iu)) =\n                         bind_spmf q\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 iu))\n 3. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>S p q; iu \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr ideal_core' s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr real_core' s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf p\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (bind_spmf q\n                              (\\<lambda>s2. cfunc_usr real_core' s2 iu))\n                            ou)", "subgoal AState_OK for s_i s_r query"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r;\n     query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n     (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query)\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                         oa_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                         oa_)", "apply (cases query)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>S s_i s_r;\n        query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inl a\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)\n 2. \\<And>b.\n       \\<lbrakk>S s_i s_r;\n        query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr b\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)", "subgoal for q_key"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r;\n     query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n     (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n     query = Inl q_key\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                         oa_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                         oa_)", "by (erule S.cases) (auto simp add: map_spmf_conv_bind_spmf[symmetric] intro!: trace_eq_simcl.base S.intros[simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>S s_i s_r;\n        query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr b\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)", "subgoal for q_auth"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r;\n     query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n     (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n     query = Inr q_auth\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                         oa_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                         oa_)", "apply (cases q_auth)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>S s_i s_r;\n        query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inl a\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)\n 2. \\<And>b.\n       \\<lbrakk>S s_i s_r;\n        query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr b\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)", "subgoal for q_auth_drop"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r;\n     query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n     (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n     query = Inr q_auth; q_auth = Inl q_auth_drop\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                         oa_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                         oa_)", "by (erule S.cases) (auto simp add: id_oracle_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>S s_i s_r;\n        query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr b\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)", "subgoal for q_auth_lfe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r;\n     query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n     (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n     query = Inr q_auth; q_auth = Inr q_auth_lfe\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                         oa_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                         oa_)", "apply (cases q_auth_lfe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>S s_i s_r;\n        query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl a\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)\n 2. \\<And>b.\n       \\<lbrakk>S s_i s_r;\n        query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inr b\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)", "subgoal for q_auth_look"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r;\n     query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n     (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n     query = Inr q_auth; q_auth = Inr q_auth_lfe;\n     q_auth_lfe = Inl q_auth_look\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                         oa_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                         oa_)", "proof (erule S.cases, goal_cases)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (False, s_act_ka), sec.State_Void, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.PState_Store, s_act_k), sec.State_Void,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (False \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_s = {}\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)\n 2. \\<And>s_act s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n              s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)\n 3. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Store (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)\n 4. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collect (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)\n 5. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collected, s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob};\n        s_act_a = {sec.Alice, sec.Bob}\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)\n 6. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Store (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)\n 7. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Collect (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)\n 8. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob}; s_act_a = {sec.Alice, sec.Bob};\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)", "case (3 s_act_s s_act_k s_act_a s_act_ka msg) \\<comment> \\<open>Corresponds to @{thm [source] s_1_1}\\<close>"], ["proof (state)\nthis:\n  query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>\n  s1_ \\<in> set_spmf s_i\n  s2_ \\<in> set_spmf s_r\n  (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query)\n  (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query)\n  query = Inr q_auth\n  q_auth = Inr q_auth_lfe\n  q_auth_lfe = Inl q_auth_look\n  s_i =\n  return_spmf\n   (case (None, (True, s_act_ka), sec.State_Store msg, s_act_s) of\n    (x, y) \\<Rightarrow> ((((), x, ()), ()), y))\n  s_r =\n  map_spmf\n   (\\<lambda>key.\n       (((), (), ()), (key.State_Store key, s_act_k),\n        sec.State_Store (key \\<oplus> msg), s_act_a))\n   (spmf_of_set (carrier \\<L>))\n  s_act_ka = s_act_k <+> s_act_a \\<and>\n  (True \\<longrightarrow>\n   s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\n  key.Alice \\<in> s_act_k\n  sec.Alice \\<in> s_act_a\n  msg \\<in> carrier \\<L>\n\ngoal (8 subgoals):\n 1. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (False, s_act_ka), sec.State_Void, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.PState_Store, s_act_k), sec.State_Void,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (False \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_s = {}\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)\n 2. \\<And>s_act s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n              s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)\n 3. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Store (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)\n 4. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collect (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)\n 5. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collected, s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob};\n        s_act_a = {sec.Alice, sec.Bob}\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)\n 6. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Store (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)\n 7. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Collect (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)\n 8. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob}; s_act_a = {sec.Alice, sec.Bob};\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)", "then"], ["proof (chain)\npicking this:\n  query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>\n  s1_ \\<in> set_spmf s_i\n  s2_ \\<in> set_spmf s_r\n  (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query)\n  (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query)\n  query = Inr q_auth\n  q_auth = Inr q_auth_lfe\n  q_auth_lfe = Inl q_auth_look\n  s_i =\n  return_spmf\n   (case (None, (True, s_act_ka), sec.State_Store msg, s_act_s) of\n    (x, y) \\<Rightarrow> ((((), x, ()), ()), y))\n  s_r =\n  map_spmf\n   (\\<lambda>key.\n       (((), (), ()), (key.State_Store key, s_act_k),\n        sec.State_Store (key \\<oplus> msg), s_act_a))\n   (spmf_of_set (carrier \\<L>))\n  s_act_ka = s_act_k <+> s_act_a \\<and>\n  (True \\<longrightarrow>\n   s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\n  key.Alice \\<in> s_act_k\n  sec.Alice \\<in> s_act_a\n  msg \\<in> carrier \\<L>", "show ?case"], ["proof (prove)\nusing this:\n  query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>\n  s1_ \\<in> set_spmf s_i\n  s2_ \\<in> set_spmf s_r\n  (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query)\n  (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query)\n  query = Inr q_auth\n  q_auth = Inr q_auth_lfe\n  q_auth_lfe = Inl q_auth_look\n  s_i =\n  return_spmf\n   (case (None, (True, s_act_ka), sec.State_Store msg, s_act_s) of\n    (x, y) \\<Rightarrow> ((((), x, ()), ()), y))\n  s_r =\n  map_spmf\n   (\\<lambda>key.\n       (((), (), ()), (key.State_Store key, s_act_k),\n        sec.State_Store (key \\<oplus> msg), s_act_a))\n   (spmf_of_set (carrier \\<L>))\n  s_act_ka = s_act_k <+> s_act_a \\<and>\n  (True \\<longrightarrow>\n   s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\n  key.Alice \\<in> s_act_k\n  sec.Alice \\<in> s_act_a\n  msg \\<in> carrier \\<L>\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S\n     (cond_spmf_fst\n       (bind_spmf s_i (\\<lambda>s1. cfunc_adv ideal_core' s1 query)) oa_)\n     (cond_spmf_fst\n       (bind_spmf s_r (\\<lambda>s2. cfunc_adv real_core' s2 query)) oa_)", "apply(simp add: exec_gpv_extend_state_oracle exec_gpv_map_gpv_id exec_gpv_plus_oracle_right exec_gpv_plus_oracle_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1_ =\n             ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n              sec.State_Store msg,\n              sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s2_\n     \\<in> (\\<lambda>x.\n               (((), (), ()), (key.State_Store x, s_act_k),\n                sec.State_Store (x \\<oplus> msg), s_act_a)) `\n           carrier \\<L>;\n     \\<exists>x\\<in>carrier \\<L>.\n        oa_ = Inr (Inr (Inl (sec.Out_Look x))) \\<and>\n        s1'_ =\n        ((((), Some x, ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Store msg,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     fst s2'_ = fst s2_ \\<and>\n     (oa_, snd s2'_)\n     \\<in> set_spmf\n            ((key.iface_adv \\<ddagger>\\<^sub>O auth.iface_adv) (snd s2_)\n              (Inr (Inr (Inl q_auth_look))));\n     query = Inr (Inr (Inl q_auth_look)); q_auth = Inr (Inl q_auth_look);\n     q_auth_lfe = Inl q_auth_look;\n     s_i =\n     return_spmf\n      ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n       sec.State_Store msg,\n       sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k),\n           sec.State_Store (key \\<oplus> msg), s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf (spmf_of_set (carrier \\<L>))\n                           (\\<lambda>x.\n                               return_spmf\n                                (Inr (Inr (Inl (sec.Out_Look x))),\n                                 (((), Some x, ()), ()),\n                                 (True, s_act_k <+> s_act_a),\n                                 sec.State_Store msg,\n                                 sec_party_of_key_party ` s_act_k \\<inter>\n                                 s_act_a)))\n                         oa_)\n                       (cond_spmf_fst\n                         (bind_spmf (spmf_of_set (carrier \\<L>))\n                           (\\<lambda>x.\n                               return_spmf\n                                (Inr (Inr\n (Inl (sec.Out_Look (x \\<oplus> msg)))),\n                                 ((), (), ()), (key.State_Store x, s_act_k),\n                                 sec.State_Store (x \\<oplus> msg),\n                                 s_act_a)))\n                         oa_)", "apply (clarsimp simp add: map_spmf_conv_bind_spmf[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Store msg,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        query = Inr (Inr (Inl q_auth_look)); q_auth = Inr (Inl q_auth_look);\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n          sec.State_Store msg,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Store (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; x \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store x, s_act_k),\n         sec.State_Store (x \\<oplus> msg), s_act_a);\n        fst s2'_ = ((), (), ());\n        snd s2'_ =\n        ((key.State_Store x, s_act_k), sec.State_Store (x \\<oplus> msg),\n         s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        s1'_ =\n        ((((), Some (x \\<oplus> msg), ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Store msg,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        oa_ = Inr (Inr (Inl (sec.Out_Look (x \\<oplus> msg))))\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (map_spmf\n                              (\\<lambda>x.\n                                  (Inr (Inr (Inl (sec.Out_Look x))),\n                                   (((), Some x, ()), ()),\n                                   (True, s_act_k <+> s_act_a),\n                                   sec.State_Store msg,\n                                   sec_party_of_key_party ` s_act_k \\<inter>\n                                   s_act_a))\n                              (spmf_of_set (carrier \\<L>)))\n                            (Inr (Inr (Inl\n  (sec.Out_Look (x \\<oplus> msg))))))\n                          (cond_spmf_fst\n                            (map_spmf\n                              (\\<lambda>x.\n                                  (Inr (Inr\n   (Inl (sec.Out_Look (x \\<oplus> msg)))),\n                                   ((), (), ()),\n                                   (key.State_Store x, s_act_k),\n                                   sec.State_Store (x \\<oplus> msg),\n                                   s_act_a))\n                              (spmf_of_set (carrier \\<L>)))\n                            (Inr (Inr (Inl\n  (sec.Out_Look (x \\<oplus> msg))))))", "apply (subst (1 2) cond_spmf_fst_map_Pair1; clarsimp simp add: set_spmf_of_set inj_on_def intro: inj_xor)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa y.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Store msg,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        query = Inr (Inr (Inl q_auth_look)); q_auth = Inr (Inl q_auth_look);\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n          sec.State_Store msg,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        spmf_of_set\n         ((\\<lambda>key.\n              (((), (), ()), (key.State_Store key, s_act_k),\n               sec.State_Store (key \\<oplus> msg), s_act_a)) `\n          carrier \\<L>);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; x \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store x, s_act_k),\n         sec.State_Store (x \\<oplus> msg), s_act_a);\n        fst s2'_ = ((), (), ());\n        snd s2'_ =\n        ((key.State_Store x, s_act_k), sec.State_Store (x \\<oplus> msg),\n         s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        s1'_ =\n        ((((), Some (x \\<oplus> msg), ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Store msg,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        oa_ = Inr (Inr (Inl (sec.Out_Look (x \\<oplus> msg))));\n        xa \\<in> carrier \\<L>; y \\<in> carrier \\<L>;\n        xa \\<oplus> msg = y \\<oplus> msg\\<rbrakk>\n       \\<Longrightarrow> xa = y\n 2. \\<And>x.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Store msg,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        query = Inr (Inr (Inl q_auth_look)); q_auth = Inr (Inl q_auth_look);\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n          sec.State_Store msg,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        spmf_of_set\n         ((\\<lambda>key.\n              (((), (), ()), (key.State_Store key, s_act_k),\n               sec.State_Store (key \\<oplus> msg), s_act_a)) `\n          carrier \\<L>);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; x \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store x, s_act_k),\n         sec.State_Store (x \\<oplus> msg), s_act_a);\n        fst s2'_ = ((), (), ());\n        snd s2'_ =\n        ((key.State_Store x, s_act_k), sec.State_Store (x \\<oplus> msg),\n         s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        s1'_ =\n        ((((), Some (x \\<oplus> msg), ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Store msg,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        oa_ = Inr (Inr (Inl (sec.Out_Look (x \\<oplus> msg))))\\<rbrakk>\n       \\<Longrightarrow> S (return_spmf\n                             ((((),\n                                Some\n                                 (inv_into (carrier \\<L>)\n                                   (\\<lambda>x.\n Inr (Inr (Inl (sec.Out_Look x))))\n                                   (Inr (Inr\n    (Inl (sec.Out_Look (x \\<oplus> msg)))))),\n                                ()),\n                               ()),\n                              (True, s_act_k <+> s_act_a),\n                              sec.State_Store msg,\n                              sec_party_of_key_party ` s_act_k \\<inter>\n                              s_act_a))\n                          (return_spmf\n                            (((), (), ()),\n                             (key.State_Store\n                               (inv_into (carrier \\<L>)\n                                 (\\<lambda>x.\n                                     Inr\n(Inr (Inl (sec.Out_Look (x \\<oplus> msg)))))\n                                 (Inr (Inr\n  (Inl (sec.Out_Look (x \\<oplus> msg)))))),\n                              s_act_k),\n                             sec.State_Store\n                              (inv_into (carrier \\<L>)\n                                (\\<lambda>x.\n                                    Inr (Inr\n    (Inl (sec.Out_Look (x \\<oplus> msg)))))\n                                (Inr (Inr\n (Inl (sec.Out_Look (x \\<oplus> msg))))) \\<oplus>\n                               msg),\n                             s_act_a))", "apply (rule inj_xor, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Store msg,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        query = Inr (Inr (Inl q_auth_look)); q_auth = Inr (Inl q_auth_look);\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n          sec.State_Store msg,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        spmf_of_set\n         ((\\<lambda>key.\n              (((), (), ()), (key.State_Store key, s_act_k),\n               sec.State_Store (key \\<oplus> msg), s_act_a)) `\n          carrier \\<L>);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; x \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store x, s_act_k),\n         sec.State_Store (x \\<oplus> msg), s_act_a);\n        fst s2'_ = ((), (), ());\n        snd s2'_ =\n        ((key.State_Store x, s_act_k), sec.State_Store (x \\<oplus> msg),\n         s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        s1'_ =\n        ((((), Some (x \\<oplus> msg), ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Store msg,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        oa_ = Inr (Inr (Inl (sec.Out_Look (x \\<oplus> msg))))\\<rbrakk>\n       \\<Longrightarrow> S (return_spmf\n                             ((((),\n                                Some\n                                 (inv_into (carrier \\<L>)\n                                   (\\<lambda>x.\n Inr (Inr (Inl (sec.Out_Look x))))\n                                   (Inr (Inr\n    (Inl (sec.Out_Look (x \\<oplus> msg)))))),\n                                ()),\n                               ()),\n                              (True, s_act_k <+> s_act_a),\n                              sec.State_Store msg,\n                              sec_party_of_key_party ` s_act_k \\<inter>\n                              s_act_a))\n                          (return_spmf\n                            (((), (), ()),\n                             (key.State_Store\n                               (inv_into (carrier \\<L>)\n                                 (\\<lambda>x.\n                                     Inr\n(Inr (Inl (sec.Out_Look (x \\<oplus> msg)))))\n                                 (Inr (Inr\n  (Inl (sec.Out_Look (x \\<oplus> msg)))))),\n                              s_act_k),\n                             sec.State_Store\n                              (inv_into (carrier \\<L>)\n                                (\\<lambda>x.\n                                    Inr (Inr\n    (Inl (sec.Out_Look (x \\<oplus> msg)))))\n                                (Inr (Inr\n (Inl (sec.Out_Look (x \\<oplus> msg))))) \\<oplus>\n                               msg),\n                             s_act_a))", "apply(subst (1 2 3) inv_into_f_f)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Store msg,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        query = Inr (Inr (Inl q_auth_look)); q_auth = Inr (Inl q_auth_look);\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n          sec.State_Store msg,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        spmf_of_set\n         ((\\<lambda>key.\n              (((), (), ()), (key.State_Store key, s_act_k),\n               sec.State_Store (key \\<oplus> msg), s_act_a)) `\n          carrier \\<L>);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; x \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store x, s_act_k),\n         sec.State_Store (x \\<oplus> msg), s_act_a);\n        fst s2'_ = ((), (), ());\n        snd s2'_ =\n        ((key.State_Store x, s_act_k), sec.State_Store (x \\<oplus> msg),\n         s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        s1'_ =\n        ((((), Some (x \\<oplus> msg), ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Store msg,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        oa_ = Inr (Inr (Inl (sec.Out_Look (x \\<oplus> msg))))\\<rbrakk>\n       \\<Longrightarrow> inj_on\n                          (\\<lambda>x.\n                              Inr (Inr (Inl\n   (sec.Out_Look (x \\<oplus> msg)))))\n                          (carrier \\<L>)\n 2. \\<And>x.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Store msg,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        query = Inr (Inr (Inl q_auth_look)); q_auth = Inr (Inl q_auth_look);\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n          sec.State_Store msg,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        spmf_of_set\n         ((\\<lambda>key.\n              (((), (), ()), (key.State_Store key, s_act_k),\n               sec.State_Store (key \\<oplus> msg), s_act_a)) `\n          carrier \\<L>);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; x \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store x, s_act_k),\n         sec.State_Store (x \\<oplus> msg), s_act_a);\n        fst s2'_ = ((), (), ());\n        snd s2'_ =\n        ((key.State_Store x, s_act_k), sec.State_Store (x \\<oplus> msg),\n         s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        s1'_ =\n        ((((), Some (x \\<oplus> msg), ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Store msg,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        oa_ = Inr (Inr (Inl (sec.Out_Look (x \\<oplus> msg))))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> carrier \\<L>\n 3. \\<And>x.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Store msg,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        query = Inr (Inr (Inl q_auth_look)); q_auth = Inr (Inl q_auth_look);\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n          sec.State_Store msg,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        spmf_of_set\n         ((\\<lambda>key.\n              (((), (), ()), (key.State_Store key, s_act_k),\n               sec.State_Store (key \\<oplus> msg), s_act_a)) `\n          carrier \\<L>);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; x \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store x, s_act_k),\n         sec.State_Store (x \\<oplus> msg), s_act_a);\n        fst s2'_ = ((), (), ());\n        snd s2'_ =\n        ((key.State_Store x, s_act_k), sec.State_Store (x \\<oplus> msg),\n         s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        s1'_ =\n        ((((), Some (x \\<oplus> msg), ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Store msg,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        oa_ = Inr (Inr (Inl (sec.Out_Look (x \\<oplus> msg))))\\<rbrakk>\n       \\<Longrightarrow> inj_on\n                          (\\<lambda>x. Inr (Inr (Inl (sec.Out_Look x))))\n                          (carrier \\<L>)\n 4. \\<And>x.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Store msg,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        query = Inr (Inr (Inl q_auth_look)); q_auth = Inr (Inl q_auth_look);\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n          sec.State_Store msg,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        spmf_of_set\n         ((\\<lambda>key.\n              (((), (), ()), (key.State_Store key, s_act_k),\n               sec.State_Store (key \\<oplus> msg), s_act_a)) `\n          carrier \\<L>);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; x \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store x, s_act_k),\n         sec.State_Store (x \\<oplus> msg), s_act_a);\n        fst s2'_ = ((), (), ());\n        snd s2'_ =\n        ((key.State_Store x, s_act_k), sec.State_Store (x \\<oplus> msg),\n         s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        s1'_ =\n        ((((), Some (x \\<oplus> msg), ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Store msg,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        oa_ = Inr (Inr (Inl (sec.Out_Look (x \\<oplus> msg))))\\<rbrakk>\n       \\<Longrightarrow> x \\<oplus> msg \\<in> carrier \\<L>\n 5. \\<And>x.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Store msg,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        query = Inr (Inr (Inl q_auth_look)); q_auth = Inr (Inl q_auth_look);\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n          sec.State_Store msg,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        spmf_of_set\n         ((\\<lambda>key.\n              (((), (), ()), (key.State_Store key, s_act_k),\n               sec.State_Store (key \\<oplus> msg), s_act_a)) `\n          carrier \\<L>);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; x \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store x, s_act_k),\n         sec.State_Store (x \\<oplus> msg), s_act_a);\n        fst s2'_ = ((), (), ());\n        snd s2'_ =\n        ((key.State_Store x, s_act_k), sec.State_Store (x \\<oplus> msg),\n         s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        s1'_ =\n        ((((), Some (x \\<oplus> msg), ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Store msg,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        oa_ = Inr (Inr (Inl (sec.Out_Look (x \\<oplus> msg))))\\<rbrakk>\n       \\<Longrightarrow> S (return_spmf\n                             ((((), Some (x \\<oplus> msg), ()), ()),\n                              (True, s_act_k <+> s_act_a),\n                              sec.State_Store msg,\n                              sec_party_of_key_party ` s_act_k \\<inter>\n                              s_act_a))\n                          (return_spmf\n                            (((), (), ()), (key.State_Store x, s_act_k),\n                             sec.State_Store (x \\<oplus> msg), s_act_a))", "by (auto simp add: S.simps inj_on_def intro: inj_xor)"], ["proof (state)\nthis:\n  trace_eq_simcl S\n   (cond_spmf_fst\n     (bind_spmf s_i (\\<lambda>s1. cfunc_adv ideal_core' s1 query)) oa_)\n   (cond_spmf_fst\n     (bind_spmf s_r (\\<lambda>s2. cfunc_adv real_core' s2 query)) oa_)\n\ngoal (7 subgoals):\n 1. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (False, s_act_ka), sec.State_Void, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.PState_Store, s_act_k), sec.State_Void,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (False \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_s = {}\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)\n 2. \\<And>s_act s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n              s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)\n 3. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collect (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)\n 4. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collected, s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob};\n        s_act_a = {sec.Alice, sec.Bob}\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)\n 5. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Store (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)\n 6. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Collect (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)\n 7. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query\n                \\<in> UNIV <+>\n                      UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inl q_auth_look;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob}; s_act_a = {sec.Alice, sec.Bob};\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)", "qed (auto intro!: trace_eq_simcl.base S.intros[simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>S s_i s_r;\n        query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n        (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n        query = Inr q_auth; q_auth = Inr q_auth_lfe;\n        q_auth_lfe = Inr b\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                            oa_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                            oa_)", "subgoal for q_auth_fedit"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r;\n     query \\<in> UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (oa_, s1'_) \\<in> set_spmf (cfunc_adv ideal_core' s1_ query);\n     (oa_, s2'_) \\<in> set_spmf (cfunc_adv real_core' s2_ query);\n     query = Inr q_auth; q_auth = Inr q_auth_lfe;\n     q_auth_lfe = Inr q_auth_fedit\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_adv ideal_core' s1 query))\n                         oa_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_adv real_core' s2 query))\n                         oa_)", "by (erule S.cases) (auto simp add: map_spmf_conv_bind_spmf[symmetric] id_oracle_def intro!: trace_eq_simcl.base S.intros[simplified])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p q iu.\n       \\<lbrakk>S p q;\n        iu \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV\\<rbrakk>\n       \\<Longrightarrow> bind_spmf p\n                          (\\<lambda>s1.\n                              map_spmf fst (cfunc_usr ideal_core' s1 iu)) =\n                         bind_spmf q\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 iu))\n 2. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>S p q; iu \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr ideal_core' s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr real_core' s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf p\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (bind_spmf q\n                              (\\<lambda>s2. cfunc_usr real_core' s2 iu))\n                            ou)", "subgoal UOut_OK for s_i s_r query"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r;\n     query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV\\<rbrakk>\n    \\<Longrightarrow> bind_spmf s_i\n                       (\\<lambda>s1.\n                           map_spmf fst (cfunc_usr ideal_core' s1 query)) =\n                      bind_spmf s_r\n                       (\\<lambda>s2.\n                           map_spmf fst (cfunc_usr real_core' s2 query))", "apply (cases query)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>S s_i s_r; query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inl a\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 2. \\<And>b.\n       \\<lbrakk>S s_i s_r; query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inr b\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))", "subgoal for q_alice"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r; query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     query = Inl q_alice\\<rbrakk>\n    \\<Longrightarrow> bind_spmf s_i\n                       (\\<lambda>s1.\n                           map_spmf fst (cfunc_usr ideal_core' s1 query)) =\n                      bind_spmf s_r\n                       (\\<lambda>s2.\n                           map_spmf fst (cfunc_usr real_core' s2 query))", "proof (erule S.cases, goal_cases)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (False, s_act_ka), sec.State_Void, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.PState_Store, s_act_k), sec.State_Void,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (False \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_s = {}\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 2. \\<And>s_act s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n              s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 3. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Store (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 4. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collect (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 5. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collected, s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob};\n        s_act_a = {sec.Alice, sec.Bob}\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 6. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Store (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 7. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Collect (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 8. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob}; s_act_a = {sec.Alice, sec.Bob};\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))", "case (2 s_act_s s_act_k s_act_a s_act_ka) \\<comment> \\<open>Corresponds to @{thm [source] s_0_1}\\<close>"], ["proof (state)\nthis:\n  query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV\n  query = Inl q_alice\n  s_i =\n  return_spmf\n   (case (None, (True, s_act_ka), sec.State_Void, s_act_s) of\n    (x, y) \\<Rightarrow> ((((), x, ()), ()), y))\n  s_r =\n  map_spmf\n   (\\<lambda>key.\n       (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n        s_act_a))\n   (spmf_of_set (carrier \\<L>))\n  s_act_ka = s_act_k <+> s_act_a \\<and>\n  (True \\<longrightarrow>\n   s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\n\ngoal (8 subgoals):\n 1. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (False, s_act_ka), sec.State_Void, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.PState_Store, s_act_k), sec.State_Void,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (False \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_s = {}\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 2. \\<And>s_act s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n              s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 3. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Store (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 4. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collect (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 5. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collected, s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob};\n        s_act_a = {sec.Alice, sec.Bob}\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 6. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Store (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 7. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Collect (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 8. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob}; s_act_a = {sec.Alice, sec.Bob};\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))", "then"], ["proof (chain)\npicking this:\n  query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV\n  query = Inl q_alice\n  s_i =\n  return_spmf\n   (case (None, (True, s_act_ka), sec.State_Void, s_act_s) of\n    (x, y) \\<Rightarrow> ((((), x, ()), ()), y))\n  s_r =\n  map_spmf\n   (\\<lambda>key.\n       (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n        s_act_a))\n   (spmf_of_set (carrier \\<L>))\n  s_act_ka = s_act_k <+> s_act_a \\<and>\n  (True \\<longrightarrow>\n   s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)", "show ?case"], ["proof (prove)\nusing this:\n  query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV\n  query = Inl q_alice\n  s_i =\n  return_spmf\n   (case (None, (True, s_act_ka), sec.State_Void, s_act_s) of\n    (x, y) \\<Rightarrow> ((((), x, ()), ()), y))\n  s_r =\n  map_spmf\n   (\\<lambda>key.\n       (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n        s_act_a))\n   (spmf_of_set (carrier \\<L>))\n  s_act_ka = s_act_k <+> s_act_a \\<and>\n  (True \\<longrightarrow>\n   s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\n\ngoal (1 subgoal):\n 1. bind_spmf s_i\n     (\\<lambda>s1. map_spmf fst (cfunc_usr ideal_core' s1 query)) =\n    bind_spmf s_r\n     (\\<lambda>s2. map_spmf fst (cfunc_usr real_core' s2 query))", "apply (cases \"auth.Alice \\<in> s_act_a\"; cases \"key.Alice \\<in> s_act_k\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     query = Inl q_alice;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Void, s_act_s) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n           s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     sec.Alice \\<in> s_act_a;\n     query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV; query = Inl q_alice;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Void, s_act_s) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n           s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<in> s_act_k\\<rbrakk>\n    \\<Longrightarrow> bind_spmf s_i\n                       (\\<lambda>s1.\n                           map_spmf fst (cfunc_usr ideal_core' s1 query)) =\n                      bind_spmf s_r\n                       (\\<lambda>s2.\n                           map_spmf fst (cfunc_usr real_core' s2 query))\n 2. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     query = Inl q_alice;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Void, s_act_s) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n           s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     sec.Alice \\<in> s_act_a;\n     query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV; query = Inl q_alice;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Void, s_act_s) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n           s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<notin> s_act_k\\<rbrakk>\n    \\<Longrightarrow> bind_spmf s_i\n                       (\\<lambda>s1.\n                           map_spmf fst (cfunc_usr ideal_core' s1 query)) =\n                      bind_spmf s_r\n                       (\\<lambda>s2.\n                           map_spmf fst (cfunc_usr real_core' s2 query))\n 3. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     query = Inl q_alice;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Void, s_act_s) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n           s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     sec.Alice \\<notin> s_act_a;\n     query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV; query = Inl q_alice;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Void, s_act_s) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n           s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<in> s_act_k\\<rbrakk>\n    \\<Longrightarrow> bind_spmf s_i\n                       (\\<lambda>s1.\n                           map_spmf fst (cfunc_usr ideal_core' s1 query)) =\n                      bind_spmf s_r\n                       (\\<lambda>s2.\n                           map_spmf fst (cfunc_usr real_core' s2 query))\n 4. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     query = Inl q_alice;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Void, s_act_s) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n           s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     sec.Alice \\<notin> s_act_a;\n     query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV; query = Inl q_alice;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Void, s_act_s) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n           s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<notin> s_act_k\\<rbrakk>\n    \\<Longrightarrow> bind_spmf s_i\n                       (\\<lambda>s1.\n                           map_spmf fst (cfunc_usr ideal_core' s1 query)) =\n                      bind_spmf s_r\n                       (\\<lambda>s2.\n                           map_spmf fst (cfunc_usr real_core' s2 query))", "apply (simp_all add: stateless_callee_def split_def split!: auth.iusr_alice.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bind_spmf s_i\n   (\\<lambda>s1. map_spmf fst (cfunc_usr ideal_core' s1 query)) =\n  bind_spmf s_r (\\<lambda>s2. map_spmf fst (cfunc_usr real_core' s2 query))\n\ngoal (7 subgoals):\n 1. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (False, s_act_ka), sec.State_Void, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.PState_Store, s_act_k), sec.State_Void,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (False \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_s = {}\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 2. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Store (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 3. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collect (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 4. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collected, s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob};\n        s_act_a = {sec.Alice, sec.Bob}\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 5. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Store (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 6. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Collect (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 7. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob}; s_act_a = {sec.Alice, sec.Bob};\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))", "qed (simp_all add: stateless_callee_def split: auth.iusr_alice.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>S s_i s_r; query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inr b\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))", "subgoal for q_bob"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r; query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     query = Inr q_bob\\<rbrakk>\n    \\<Longrightarrow> bind_spmf s_i\n                       (\\<lambda>s1.\n                           map_spmf fst (cfunc_usr ideal_core' s1 query)) =\n                      bind_spmf s_r\n                       (\\<lambda>s2.\n                           map_spmf fst (cfunc_usr real_core' s2 query))", "proof (erule S.cases, goal_cases)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (False, s_act_ka), sec.State_Void, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.PState_Store, s_act_k), sec.State_Void,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (False \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_s = {}\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 2. \\<And>s_act s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n              s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 3. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Store (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 4. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collect (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 5. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collected, s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob};\n        s_act_a = {sec.Alice, sec.Bob}\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 6. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Store (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 7. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Collect (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 8. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob}; s_act_a = {sec.Alice, sec.Bob};\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))", "case (4 s_act_s s_act_k s_act_a s_act_ka msg) \\<comment> \\<open>Corresponds to @{thm [source] s_2_1}\\<close>"], ["proof (state)\nthis:\n  query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV\n  query = Inr q_bob\n  s_i =\n  return_spmf\n   (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n    (x, y) \\<Rightarrow> ((((), x, ()), ()), y))\n  s_r =\n  map_spmf\n   (\\<lambda>key.\n       (((), (), ()), (key.State_Store key, s_act_k),\n        sec.State_Collect (key \\<oplus> msg), s_act_a))\n   (spmf_of_set (carrier \\<L>))\n  s_act_ka = s_act_k <+> s_act_a \\<and>\n  (True \\<longrightarrow>\n   s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\n  key.Alice \\<in> s_act_k\n  sec.Alice \\<in> s_act_a\n  msg \\<in> carrier \\<L>\n\ngoal (8 subgoals):\n 1. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (False, s_act_ka), sec.State_Void, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.PState_Store, s_act_k), sec.State_Void,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (False \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_s = {}\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 2. \\<And>s_act s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n              s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 3. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Store (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 4. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collect (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 5. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collected, s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob};\n        s_act_a = {sec.Alice, sec.Bob}\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 6. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Store (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 7. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Collect (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 8. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob}; s_act_a = {sec.Alice, sec.Bob};\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))", "then"], ["proof (chain)\npicking this:\n  query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV\n  query = Inr q_bob\n  s_i =\n  return_spmf\n   (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n    (x, y) \\<Rightarrow> ((((), x, ()), ()), y))\n  s_r =\n  map_spmf\n   (\\<lambda>key.\n       (((), (), ()), (key.State_Store key, s_act_k),\n        sec.State_Collect (key \\<oplus> msg), s_act_a))\n   (spmf_of_set (carrier \\<L>))\n  s_act_ka = s_act_k <+> s_act_a \\<and>\n  (True \\<longrightarrow>\n   s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\n  key.Alice \\<in> s_act_k\n  sec.Alice \\<in> s_act_a\n  msg \\<in> carrier \\<L>", "show ?case"], ["proof (prove)\nusing this:\n  query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV\n  query = Inr q_bob\n  s_i =\n  return_spmf\n   (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n    (x, y) \\<Rightarrow> ((((), x, ()), ()), y))\n  s_r =\n  map_spmf\n   (\\<lambda>key.\n       (((), (), ()), (key.State_Store key, s_act_k),\n        sec.State_Collect (key \\<oplus> msg), s_act_a))\n   (spmf_of_set (carrier \\<L>))\n  s_act_ka = s_act_k <+> s_act_a \\<and>\n  (True \\<longrightarrow>\n   s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\n  key.Alice \\<in> s_act_k\n  sec.Alice \\<in> s_act_a\n  msg \\<in> carrier \\<L>\n\ngoal (1 subgoal):\n 1. bind_spmf s_i\n     (\\<lambda>s1. map_spmf fst (cfunc_usr ideal_core' s1 query)) =\n    bind_spmf s_r\n     (\\<lambda>s2. map_spmf fst (cfunc_usr real_core' s2 query))", "apply (cases \"sec.Bob \\<in> s_act_s\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     query = Inr q_bob;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k),\n           sec.State_Collect (key \\<oplus> msg), s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; sec.Bob \\<in> s_act_s\\<rbrakk>\n    \\<Longrightarrow> bind_spmf s_i\n                       (\\<lambda>s1.\n                           map_spmf fst (cfunc_usr ideal_core' s1 query)) =\n                      bind_spmf s_r\n                       (\\<lambda>s2.\n                           map_spmf fst (cfunc_usr real_core' s2 query))\n 2. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     query = Inr q_bob;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k),\n           sec.State_Collect (key \\<oplus> msg), s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; sec.Bob \\<notin> s_act_s\\<rbrakk>\n    \\<Longrightarrow> bind_spmf s_i\n                       (\\<lambda>s1.\n                           map_spmf fst (cfunc_usr ideal_core' s1 query)) =\n                      bind_spmf s_r\n                       (\\<lambda>s2.\n                           map_spmf fst (cfunc_usr real_core' s2 query))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     query = Inr q_bob;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k),\n           sec.State_Collect (key \\<oplus> msg), s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; sec.Bob \\<in> s_act_s\\<rbrakk>\n    \\<Longrightarrow> bind_spmf s_i\n                       (\\<lambda>s1.\n                           map_spmf fst (cfunc_usr ideal_core' s1 query)) =\n                      bind_spmf s_r\n                       (\\<lambda>s2.\n                           map_spmf fst (cfunc_usr real_core' s2 query))", "apply (clarsimp simp add: stateless_callee_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>query = Inr q_bob;\n     s_i =\n     return_spmf\n      ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n       sec.State_Collect msg,\n       sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k),\n           sec.State_Collect (key \\<oplus> msg), s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; s_act_ka = s_act_k <+> s_act_a;\n     s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n     key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a\\<rbrakk>\n    \\<Longrightarrow> return_spmf (Inr (sec.Out_Recv msg)) =\n                      bind_spmf (spmf_of_set (carrier \\<L>))\n                       (\\<lambda>x.\n                           return_spmf\n                            (Inr (sec.Out_Recv\n                                   (x \\<oplus> x \\<oplus> msg))))", "apply (simp add: spmf_rel_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>query = Inr q_bob;\n     rel_spmf (=) s_i\n      (return_spmf\n        ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Collect msg,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a));\n     rel_spmf (=) s_r\n      (map_spmf\n        (\\<lambda>key.\n            (((), (), ()), (key.State_Store key, s_act_k),\n             sec.State_Collect (key \\<oplus> msg), s_act_a))\n        (spmf_of_set (carrier \\<L>)));\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; s_act_ka = s_act_k <+> s_act_a;\n     s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n     key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a\\<rbrakk>\n    \\<Longrightarrow> rel_spmf (=) (return_spmf (Inr (sec.Out_Recv msg)))\n                       (bind_spmf (spmf_of_set (carrier \\<L>))\n                         (\\<lambda>x.\n                             return_spmf\n                              (Inr (sec.Out_Recv\n                                     (x \\<oplus> x \\<oplus> msg)))))", "apply (rule rel_spmf_bindI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>query = Inr q_bob;\n        rel_spmf (=) s_i\n         (return_spmf\n           ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n            sec.State_Collect msg,\n            sec_party_of_key_party ` s_act_k \\<inter> s_act_a));\n        rel_spmf (=) s_r\n         (map_spmf\n           (\\<lambda>key.\n               (((), (), ()), (key.State_Store key, s_act_k),\n                sec.State_Collect (key \\<oplus> msg), s_act_a))\n           (spmf_of_set (carrier \\<L>)));\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; s_act_ka = s_act_k <+> s_act_a;\n        s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a;\n        x \\<in> set_spmf (spmf_of_set (carrier \\<L>))\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (=) (return_spmf (Inr (sec.Out_Recv msg)))\n                          (return_spmf\n                            (Inr (sec.Out_Recv\n                                   (x \\<oplus> x \\<oplus> msg))))\n 2. \\<lbrakk>query = Inr q_bob;\n     rel_spmf (=) s_i\n      (return_spmf\n        ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Collect msg,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a));\n     rel_spmf (=) s_r\n      (map_spmf\n        (\\<lambda>key.\n            (((), (), ()), (key.State_Store key, s_act_k),\n             sec.State_Collect (key \\<oplus> msg), s_act_a))\n        (spmf_of_set (carrier \\<L>)));\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; s_act_ka = s_act_k <+> s_act_a;\n     s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n     key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a\\<rbrakk>\n    \\<Longrightarrow> lossless_spmf (spmf_of_set (carrier \\<L>))", "by simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     query = Inr q_bob;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k),\n           sec.State_Collect (key \\<oplus> msg), s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; sec.Bob \\<notin> s_act_s\\<rbrakk>\n    \\<Longrightarrow> bind_spmf s_i\n                       (\\<lambda>s1.\n                           map_spmf fst (cfunc_usr ideal_core' s1 query)) =\n                      bind_spmf s_r\n                       (\\<lambda>s2.\n                           map_spmf fst (cfunc_usr real_core' s2 query))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     query = Inr q_bob;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k),\n           sec.State_Collect (key \\<oplus> msg), s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; sec.Bob \\<notin> s_act_s\\<rbrakk>\n    \\<Longrightarrow> bind_spmf s_i\n                       (\\<lambda>s1.\n                           map_spmf fst (cfunc_usr ideal_core' s1 query)) =\n                      bind_spmf s_r\n                       (\\<lambda>s2.\n                           map_spmf fst (cfunc_usr real_core' s2 query))", "by (cases \"sec.Bob \\<in> s_act_a\") (clarsimp simp add: stateless_callee_def)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bind_spmf s_i\n   (\\<lambda>s1. map_spmf fst (cfunc_usr ideal_core' s1 query)) =\n  bind_spmf s_r (\\<lambda>s2. map_spmf fst (cfunc_usr real_core' s2 query))\n\ngoal (7 subgoals):\n 1. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (False, s_act_ka), sec.State_Void, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.PState_Store, s_act_k), sec.State_Void,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (False \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_s = {}\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 2. \\<And>s_act s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n              s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 3. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Store (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 4. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collected, s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob};\n        s_act_a = {sec.Alice, sec.Bob}\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 5. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Store (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 6. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Collect (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))\n 7. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob}; s_act_a = {sec.Alice, sec.Bob};\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> bind_spmf s_i\n                          (\\<lambda>s1.\n                              map_spmf fst\n                               (cfunc_usr ideal_core' s1 query)) =\n                         bind_spmf s_r\n                          (\\<lambda>s2.\n                              map_spmf fst (cfunc_usr real_core' s2 query))", "qed (simp_all add: stateless_callee_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>S p q; iu \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr ideal_core' s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr real_core' s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf p\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (bind_spmf q\n                              (\\<lambda>s2. cfunc_usr real_core' s2 iu))\n                            ou)", "subgoal UState_OK for s_i s_r query"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r; query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query)\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                         ou_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                         ou_)", "apply (cases query)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>S s_i s_r; query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inl a\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 2. \\<And>b.\n       \\<lbrakk>S s_i s_r; query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr b\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)", "subgoal for q_alice"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r; query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inl q_alice\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                         ou_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                         ou_)", "proof (erule S.cases, goal_cases)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (False, s_act_ka), sec.State_Void, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.PState_Store, s_act_k), sec.State_Void,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (False \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_s = {}\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 2. \\<And>s_act s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n              s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 3. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Store (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 4. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collect (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 5. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collected, s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob};\n        s_act_a = {sec.Alice, sec.Bob}\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 6. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Store (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 7. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Collect (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 8. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob}; s_act_a = {sec.Alice, sec.Bob};\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)", "case (2 s_act s_act_k s_act_a s_act_ka) \\<comment> \\<open>Corresponds to @{thm [source] s_0_1}\\<close>"], ["proof (state)\nthis:\n  query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV\n  s1_ \\<in> set_spmf s_i\n  s2_ \\<in> set_spmf s_r\n  (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query)\n  (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query)\n  query = Inl q_alice\n  s_i =\n  return_spmf\n   (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n    (x, y) \\<Rightarrow> ((((), x, ()), ()), y))\n  s_r =\n  map_spmf\n   (\\<lambda>key.\n       (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n        s_act_a))\n   (spmf_of_set (carrier \\<L>))\n  s_act_ka = s_act_k <+> s_act_a \\<and>\n  (True \\<longrightarrow>\n   s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\n\ngoal (8 subgoals):\n 1. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (False, s_act_ka), sec.State_Void, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.PState_Store, s_act_k), sec.State_Void,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (False \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_s = {}\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 2. \\<And>s_act s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n              s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 3. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Store (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 4. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collect (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 5. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collected, s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob};\n        s_act_a = {sec.Alice, sec.Bob}\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 6. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Store (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 7. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Collect (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 8. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob}; s_act_a = {sec.Alice, sec.Bob};\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)", "then"], ["proof (chain)\npicking this:\n  query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV\n  s1_ \\<in> set_spmf s_i\n  s2_ \\<in> set_spmf s_r\n  (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query)\n  (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query)\n  query = Inl q_alice\n  s_i =\n  return_spmf\n   (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n    (x, y) \\<Rightarrow> ((((), x, ()), ()), y))\n  s_r =\n  map_spmf\n   (\\<lambda>key.\n       (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n        s_act_a))\n   (spmf_of_set (carrier \\<L>))\n  s_act_ka = s_act_k <+> s_act_a \\<and>\n  (True \\<longrightarrow>\n   s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)", "show ?case"], ["proof (prove)\nusing this:\n  query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV\n  s1_ \\<in> set_spmf s_i\n  s2_ \\<in> set_spmf s_r\n  (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query)\n  (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query)\n  query = Inl q_alice\n  s_i =\n  return_spmf\n   (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n    (x, y) \\<Rightarrow> ((((), x, ()), ()), y))\n  s_r =\n  map_spmf\n   (\\<lambda>key.\n       (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n        s_act_a))\n   (spmf_of_set (carrier \\<L>))\n  s_act_ka = s_act_k <+> s_act_a \\<and>\n  (True \\<longrightarrow>\n   s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S\n     (cond_spmf_fst\n       (bind_spmf s_i (\\<lambda>s1. cfunc_usr ideal_core' s1 query)) ou_)\n     (cond_spmf_fst\n       (bind_spmf s_r (\\<lambda>s2. cfunc_usr real_core' s2 query)) ou_)", "apply (cases \"auth.Alice \\<in> s_act_a\"; cases \"key.Alice \\<in> s_act_k\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inl q_alice;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n           s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     sec.Alice \\<in> s_act_a;\n     query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inl q_alice;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n           s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<in> s_act_k\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                         ou_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                         ou_)\n 2. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inl q_alice;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n           s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     sec.Alice \\<in> s_act_a;\n     query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inl q_alice;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n           s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<notin> s_act_k\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                         ou_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                         ou_)\n 3. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inl q_alice;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n           s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     sec.Alice \\<notin> s_act_a;\n     query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inl q_alice;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n           s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<in> s_act_k\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                         ou_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                         ou_)\n 4. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inl q_alice;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n           s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     sec.Alice \\<notin> s_act_a;\n     query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inl q_alice;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n           s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<notin> s_act_k\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                         ou_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                         ou_)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inl q_alice;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n           s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     sec.Alice \\<in> s_act_a;\n     query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inl q_alice;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n           s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<in> s_act_k\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                         ou_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                         ou_)", "apply (clarsimp simp add: map_spmf_conv_bind_spmf[symmetric] stateless_callee_def split_def split!: auth.iusr_alice.split if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Void,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        sec.Alice \\<in> s_act_a; query = Inl (sec.Inp_Send xb);\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a), sec.State_Void,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n              s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        key.Alice \\<in> s_act_k; xb \\<in> carrier \\<L>;\n        q_alice = sec.Inp_Send xb; xa \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store xa, s_act_k), sec.State_Void,\n         s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        s1'_ =\n        ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Store xb,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        ou_ = Inl sec.Out_Send;\n        s2'_ =\n        (((), (), ()), (key.State_Store xa, s_act_k),\n         sec.State_Store (xa \\<oplus> xb), s_act_a)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (return_spmf\n                            ((((), None, ()), ()),\n                             (True, s_act_k <+> s_act_a),\n                             sec.State_Store xb,\n                             sec_party_of_key_party ` s_act_k \\<inter>\n                             s_act_a))\n                          (map_spmf\n                            (\\<lambda>x.\n                                (((), (), ()), (key.State_Store x, s_act_k),\n                                 sec.State_Store (x \\<oplus> xb), s_act_a))\n                            (spmf_of_set (carrier \\<L>)))", "apply(rule trace_eq_simcl.base)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Void,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        sec.Alice \\<in> s_act_a; query = Inl (sec.Inp_Send xb);\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a), sec.State_Void,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n              s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        key.Alice \\<in> s_act_k; xb \\<in> carrier \\<L>;\n        q_alice = sec.Inp_Send xb; xa \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store xa, s_act_k), sec.State_Void,\n         s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        s1'_ =\n        ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Store xb,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        ou_ = Inl sec.Out_Send;\n        s2'_ =\n        (((), (), ()), (key.State_Store xa, s_act_k),\n         sec.State_Store (xa \\<oplus> xb), s_act_a)\\<rbrakk>\n       \\<Longrightarrow> S (return_spmf\n                             ((((), None, ()), ()),\n                              (True, s_act_k <+> s_act_a),\n                              sec.State_Store xb,\n                              sec_party_of_key_party ` s_act_k \\<inter>\n                              s_act_a))\n                          (map_spmf\n                            (\\<lambda>x.\n                                (((), (), ()), (key.State_Store x, s_act_k),\n                                 sec.State_Store (x \\<oplus> xb), s_act_a))\n                            (spmf_of_set (carrier \\<L>)))", "apply (rule S.intros(3)[simplified])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa xb.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Void,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        sec.Alice \\<in> s_act_a; query = Inl (sec.Inp_Send xb);\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a), sec.State_Void,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n              s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        key.Alice \\<in> s_act_k; xb \\<in> carrier \\<L>;\n        q_alice = sec.Inp_Send xb; xa \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store xa, s_act_k), sec.State_Void,\n         s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        s1'_ =\n        ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Store xb,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        ou_ = Inl sec.Out_Send;\n        s2'_ =\n        (((), (), ()), (key.State_Store xa, s_act_k),\n         sec.State_Store (xa \\<oplus> xb), s_act_a)\\<rbrakk>\n       \\<Longrightarrow> s_act_k <+> s_act_a = s_act_k <+> s_act_a \\<and>\n                         sec_party_of_key_party ` s_act_k \\<inter> s_act_a =\n                         sec_party_of_key_party ` s_act_k \\<inter> s_act_a\n 2. \\<And>xa xb.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Void,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        sec.Alice \\<in> s_act_a; query = Inl (sec.Inp_Send xb);\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a), sec.State_Void,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n              s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        key.Alice \\<in> s_act_k; xb \\<in> carrier \\<L>;\n        q_alice = sec.Inp_Send xb; xa \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store xa, s_act_k), sec.State_Void,\n         s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        s1'_ =\n        ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Store xb,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        ou_ = Inl sec.Out_Send;\n        s2'_ =\n        (((), (), ()), (key.State_Store xa, s_act_k),\n         sec.State_Store (xa \\<oplus> xb), s_act_a)\\<rbrakk>\n       \\<Longrightarrow> key.Alice \\<in> s_act_k\n 3. \\<And>xa xb.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Void,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        sec.Alice \\<in> s_act_a; query = Inl (sec.Inp_Send xb);\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a), sec.State_Void,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n              s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        key.Alice \\<in> s_act_k; xb \\<in> carrier \\<L>;\n        q_alice = sec.Inp_Send xb; xa \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store xa, s_act_k), sec.State_Void,\n         s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        s1'_ =\n        ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Store xb,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        ou_ = Inl sec.Out_Send;\n        s2'_ =\n        (((), (), ()), (key.State_Store xa, s_act_k),\n         sec.State_Store (xa \\<oplus> xb), s_act_a)\\<rbrakk>\n       \\<Longrightarrow> sec.Alice \\<in> s_act_a\n 4. \\<And>xa xb.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Void,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        sec.Alice \\<in> s_act_a; query = Inl (sec.Inp_Send xb);\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a), sec.State_Void,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n              s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        key.Alice \\<in> s_act_k; xb \\<in> carrier \\<L>;\n        q_alice = sec.Inp_Send xb; xa \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store xa, s_act_k), sec.State_Void,\n         s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        s1'_ =\n        ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Store xb,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        ou_ = Inl sec.Out_Send;\n        s2'_ =\n        (((), (), ()), (key.State_Store xa, s_act_k),\n         sec.State_Store (xa \\<oplus> xb), s_act_a)\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> carrier \\<L>", "by simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inl q_alice;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n           s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     sec.Alice \\<in> s_act_a;\n     query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inl q_alice;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n           s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<notin> s_act_k\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                         ou_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                         ou_)\n 2. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inl q_alice;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n           s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     sec.Alice \\<notin> s_act_a;\n     query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inl q_alice;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n           s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<in> s_act_k\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                         ou_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                         ou_)\n 3. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inl q_alice;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n           s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     sec.Alice \\<notin> s_act_a;\n     query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inl q_alice;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n           s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<notin> s_act_k\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                         ou_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                         ou_)", "by (clarsimp simp add: map_spmf_conv_bind_spmf[symmetric] stateless_callee_def split_def split: auth.iusr_alice.split)+"], ["proof (state)\nthis:\n  trace_eq_simcl S\n   (cond_spmf_fst\n     (bind_spmf s_i (\\<lambda>s1. cfunc_usr ideal_core' s1 query)) ou_)\n   (cond_spmf_fst\n     (bind_spmf s_r (\\<lambda>s2. cfunc_usr real_core' s2 query)) ou_)\n\ngoal (7 subgoals):\n 1. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (False, s_act_ka), sec.State_Void, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.PState_Store, s_act_k), sec.State_Void,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (False \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_s = {}\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 2. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Store (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 3. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collect (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 4. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collected, s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob};\n        s_act_a = {sec.Alice, sec.Bob}\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 5. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Store (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 6. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Collect (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 7. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inl q_alice;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob}; s_act_a = {sec.Alice, sec.Bob};\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)", "qed (auto simp add: stateless_callee_def split: auth.iusr_alice.split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>S s_i s_r; query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr b\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)", "subgoal for q_bob"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S s_i s_r; query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inr q_bob\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                         ou_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                         ou_)", "proof (erule S.cases, goal_cases)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (False, s_act_ka), sec.State_Void, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.PState_Store, s_act_k), sec.State_Void,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (False \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_s = {}\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 2. \\<And>s_act s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n              s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 3. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Store (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 4. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collect (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 5. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collected, s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob};\n        s_act_a = {sec.Alice, sec.Bob}\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 6. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Store (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 7. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Collect (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 8. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob}; s_act_a = {sec.Alice, sec.Bob};\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)", "case (4 s_act_s s_act_k s_act_a s_act_ka msg) \\<comment> \\<open>Corresponds to @{thm [source] s_2_1}\\<close>"], ["proof (state)\nthis:\n  query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV\n  s1_ \\<in> set_spmf s_i\n  s2_ \\<in> set_spmf s_r\n  (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query)\n  (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query)\n  query = Inr q_bob\n  s_i =\n  return_spmf\n   (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n    (x, y) \\<Rightarrow> ((((), x, ()), ()), y))\n  s_r =\n  map_spmf\n   (\\<lambda>key.\n       (((), (), ()), (key.State_Store key, s_act_k),\n        sec.State_Collect (key \\<oplus> msg), s_act_a))\n   (spmf_of_set (carrier \\<L>))\n  s_act_ka = s_act_k <+> s_act_a \\<and>\n  (True \\<longrightarrow>\n   s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\n  key.Alice \\<in> s_act_k\n  sec.Alice \\<in> s_act_a\n  msg \\<in> carrier \\<L>\n\ngoal (8 subgoals):\n 1. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (False, s_act_ka), sec.State_Void, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.PState_Store, s_act_k), sec.State_Void,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (False \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_s = {}\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 2. \\<And>s_act s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n              s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 3. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Store (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 4. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collect (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 5. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collected, s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob};\n        s_act_a = {sec.Alice, sec.Bob}\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 6. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Store (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 7. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Collect (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 8. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob}; s_act_a = {sec.Alice, sec.Bob};\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)", "then"], ["proof (chain)\npicking this:\n  query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV\n  s1_ \\<in> set_spmf s_i\n  s2_ \\<in> set_spmf s_r\n  (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query)\n  (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query)\n  query = Inr q_bob\n  s_i =\n  return_spmf\n   (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n    (x, y) \\<Rightarrow> ((((), x, ()), ()), y))\n  s_r =\n  map_spmf\n   (\\<lambda>key.\n       (((), (), ()), (key.State_Store key, s_act_k),\n        sec.State_Collect (key \\<oplus> msg), s_act_a))\n   (spmf_of_set (carrier \\<L>))\n  s_act_ka = s_act_k <+> s_act_a \\<and>\n  (True \\<longrightarrow>\n   s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\n  key.Alice \\<in> s_act_k\n  sec.Alice \\<in> s_act_a\n  msg \\<in> carrier \\<L>", "show ?case"], ["proof (prove)\nusing this:\n  query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV\n  s1_ \\<in> set_spmf s_i\n  s2_ \\<in> set_spmf s_r\n  (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query)\n  (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query)\n  query = Inr q_bob\n  s_i =\n  return_spmf\n   (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n    (x, y) \\<Rightarrow> ((((), x, ()), ()), y))\n  s_r =\n  map_spmf\n   (\\<lambda>key.\n       (((), (), ()), (key.State_Store key, s_act_k),\n        sec.State_Collect (key \\<oplus> msg), s_act_a))\n   (spmf_of_set (carrier \\<L>))\n  s_act_ka = s_act_k <+> s_act_a \\<and>\n  (True \\<longrightarrow>\n   s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\n  key.Alice \\<in> s_act_k\n  sec.Alice \\<in> s_act_a\n  msg \\<in> carrier \\<L>\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S\n     (cond_spmf_fst\n       (bind_spmf s_i (\\<lambda>s1. cfunc_usr ideal_core' s1 query)) ou_)\n     (cond_spmf_fst\n       (bind_spmf s_r (\\<lambda>s2. cfunc_usr real_core' s2 query)) ou_)", "apply (cases \"sec.Bob \\<in> s_act_s\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inr q_bob;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k),\n           sec.State_Collect (key \\<oplus> msg), s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; sec.Bob \\<in> s_act_s\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                         ou_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                         ou_)\n 2. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inr q_bob;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k),\n           sec.State_Collect (key \\<oplus> msg), s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; sec.Bob \\<notin> s_act_s\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                         ou_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                         ou_)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inr q_bob;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k),\n           sec.State_Collect (key \\<oplus> msg), s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; sec.Bob \\<in> s_act_s\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                         ou_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                         ou_)", "apply (clarsimp simp add: stateless_callee_def map_spmf_conv_bind_spmf[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Collect msg,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s2'_ =\n        (((), (), ()), (key.State_Store x, s_act_k), sec.State_Collected,\n         s_act_a);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n          sec.State_Collect msg,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collect (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; x \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store x, s_act_k),\n         sec.State_Collect (x \\<oplus> msg), s_act_a);\n        ou_ = Inr (sec.Out_Recv msg);\n        s1'_ =\n        ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Collected,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (return_spmf\n                            ((((), None, ()), ()),\n                             (True, s_act_k <+> s_act_a),\n                             sec.State_Collected,\n                             sec_party_of_key_party ` s_act_k \\<inter>\n                             s_act_a))\n                          (cond_spmf_fst\n                            (map_spmf\n                              (\\<lambda>x.\n                                  (Inr (sec.Out_Recv\n   (x \\<oplus> x \\<oplus> msg)),\n                                   ((), (), ()),\n                                   (key.State_Store x, s_act_k),\n                                   sec.State_Collected, s_act_a))\n                              (spmf_of_set (carrier \\<L>)))\n                            (Inr (sec.Out_Recv msg)))", "apply (subst map_spmf_of_set_inj_on)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Collect msg,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s2'_ =\n        (((), (), ()), (key.State_Store x, s_act_k), sec.State_Collected,\n         s_act_a);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n          sec.State_Collect msg,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collect (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; x \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store x, s_act_k),\n         sec.State_Collect (x \\<oplus> msg), s_act_a);\n        ou_ = Inr (sec.Out_Recv msg);\n        s1'_ =\n        ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Collected,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a\\<rbrakk>\n       \\<Longrightarrow> inj_on\n                          (\\<lambda>x.\n                              (Inr (sec.Out_Recv\n                                     (x \\<oplus> x \\<oplus> msg)),\n                               ((), (), ()), (key.State_Store x, s_act_k),\n                               sec.State_Collected, s_act_a))\n                          (carrier \\<L>)\n 2. \\<And>x.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Collect msg,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s2'_ =\n        (((), (), ()), (key.State_Store x, s_act_k), sec.State_Collected,\n         s_act_a);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n          sec.State_Collect msg,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collect (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; x \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store x, s_act_k),\n         sec.State_Collect (x \\<oplus> msg), s_act_a);\n        ou_ = Inr (sec.Out_Recv msg);\n        s1'_ =\n        ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Collected,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (return_spmf\n                            ((((), None, ()), ()),\n                             (True, s_act_k <+> s_act_a),\n                             sec.State_Collected,\n                             sec_party_of_key_party ` s_act_k \\<inter>\n                             s_act_a))\n                          (cond_spmf_fst\n                            (spmf_of_set\n                              ((\\<lambda>x.\n                                   (Inr (sec.Out_Recv\n    (x \\<oplus> x \\<oplus> msg)),\n                                    ((), (), ()),\n                                    (key.State_Store x, s_act_k),\n                                    sec.State_Collected, s_act_a)) `\n                               carrier \\<L>))\n                            (Inr (sec.Out_Recv msg)))", "apply (simp_all add: inj_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Collect msg,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s2'_ =\n        (((), (), ()), (key.State_Store x, s_act_k), sec.State_Collected,\n         s_act_a);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n          sec.State_Collect msg,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        spmf_of_set\n         ((\\<lambda>key.\n              (((), (), ()), (key.State_Store key, s_act_k),\n               sec.State_Collect (key \\<oplus> msg), s_act_a)) `\n          carrier \\<L>);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; x \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store x, s_act_k),\n         sec.State_Collect (x \\<oplus> msg), s_act_a);\n        ou_ = Inr (sec.Out_Recv msg);\n        s1'_ =\n        ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Collected,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (return_spmf\n                            ((((), None, ()), ()),\n                             (True, s_act_k <+> s_act_a),\n                             sec.State_Collected,\n                             sec_party_of_key_party ` s_act_k \\<inter>\n                             s_act_a))\n                          (cond_spmf_fst\n                            (spmf_of_set\n                              ((\\<lambda>x.\n                                   (Inr (sec.Out_Recv msg), ((), (), ()),\n                                    (key.State_Store x, s_act_k),\n                                    sec.State_Collected, s_act_a)) `\n                               carrier \\<L>))\n                            (Inr (sec.Out_Recv msg)))", "apply (subst map_spmf_of_set_inj_on[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Collect msg,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s2'_ =\n        (((), (), ()), (key.State_Store x, s_act_k), sec.State_Collected,\n         s_act_a);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n          sec.State_Collect msg,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        spmf_of_set\n         ((\\<lambda>key.\n              (((), (), ()), (key.State_Store key, s_act_k),\n               sec.State_Collect (key \\<oplus> msg), s_act_a)) `\n          carrier \\<L>);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; x \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store x, s_act_k),\n         sec.State_Collect (x \\<oplus> msg), s_act_a);\n        ou_ = Inr (sec.Out_Recv msg);\n        s1'_ =\n        ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Collected,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a\\<rbrakk>\n       \\<Longrightarrow> inj_on\n                          (\\<lambda>x.\n                              (Inr (sec.Out_Recv msg), ((), (), ()),\n                               (key.State_Store x, s_act_k),\n                               sec.State_Collected, s_act_a))\n                          (carrier \\<L>)\n 2. \\<And>x.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Collect msg,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s2'_ =\n        (((), (), ()), (key.State_Store x, s_act_k), sec.State_Collected,\n         s_act_a);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n          sec.State_Collect msg,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        spmf_of_set\n         ((\\<lambda>key.\n              (((), (), ()), (key.State_Store key, s_act_k),\n               sec.State_Collect (key \\<oplus> msg), s_act_a)) `\n          carrier \\<L>);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; x \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store x, s_act_k),\n         sec.State_Collect (x \\<oplus> msg), s_act_a);\n        ou_ = Inr (sec.Out_Recv msg);\n        s1'_ =\n        ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Collected,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (return_spmf\n                            ((((), None, ()), ()),\n                             (True, s_act_k <+> s_act_a),\n                             sec.State_Collected,\n                             sec_party_of_key_party ` s_act_k \\<inter>\n                             s_act_a))\n                          (cond_spmf_fst\n                            (map_spmf\n                              (\\<lambda>x.\n                                  (Inr (sec.Out_Recv msg), ((), (), ()),\n                                   (key.State_Store x, s_act_k),\n                                   sec.State_Collected, s_act_a))\n                              (spmf_of_set (carrier \\<L>)))\n                            (Inr (sec.Out_Recv msg)))", "apply (simp add: inj_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Collect msg,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s2'_ =\n        (((), (), ()), (key.State_Store x, s_act_k), sec.State_Collected,\n         s_act_a);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n          sec.State_Collect msg,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        spmf_of_set\n         ((\\<lambda>key.\n              (((), (), ()), (key.State_Store key, s_act_k),\n               sec.State_Collect (key \\<oplus> msg), s_act_a)) `\n          carrier \\<L>);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; x \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store x, s_act_k),\n         sec.State_Collect (x \\<oplus> msg), s_act_a);\n        ou_ = Inr (sec.Out_Recv msg);\n        s1'_ =\n        ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Collected,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (return_spmf\n                            ((((), None, ()), ()),\n                             (True, s_act_k <+> s_act_a),\n                             sec.State_Collected,\n                             sec_party_of_key_party ` s_act_k \\<inter>\n                             s_act_a))\n                          (cond_spmf_fst\n                            (map_spmf\n                              (\\<lambda>x.\n                                  (Inr (sec.Out_Recv msg), ((), (), ()),\n                                   (key.State_Store x, s_act_k),\n                                   sec.State_Collected, s_act_a))\n                              (spmf_of_set (carrier \\<L>)))\n                            (Inr (sec.Out_Recv msg)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Collect msg,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s2'_ =\n        (((), (), ()), (key.State_Store x, s_act_k), sec.State_Collected,\n         s_act_a);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n          sec.State_Collect msg,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        spmf_of_set\n         ((\\<lambda>key.\n              (((), (), ()), (key.State_Store key, s_act_k),\n               sec.State_Collect (key \\<oplus> msg), s_act_a)) `\n          carrier \\<L>);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; x \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store x, s_act_k),\n         sec.State_Collect (x \\<oplus> msg), s_act_a);\n        ou_ = Inr (sec.Out_Recv msg);\n        s1'_ =\n        ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Collected,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (return_spmf\n                            ((((), None, ()), ()),\n                             (True, s_act_k <+> s_act_a),\n                             sec.State_Collected,\n                             sec_party_of_key_party ` s_act_k \\<inter>\n                             s_act_a))\n                          (map_spmf\n                            (\\<lambda>x.\n                                (((), (), ()), (key.State_Store x, s_act_k),\n                                 sec.State_Collected, s_act_a))\n                            (spmf_of_set (carrier \\<L>)))", "apply(rule trace_eq_simcl.base)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Collect msg,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s2'_ =\n        (((), (), ()), (key.State_Store x, s_act_k), sec.State_Collected,\n         s_act_a);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n          sec.State_Collect msg,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        spmf_of_set\n         ((\\<lambda>key.\n              (((), (), ()), (key.State_Store key, s_act_k),\n               sec.State_Collect (key \\<oplus> msg), s_act_a)) `\n          carrier \\<L>);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; x \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store x, s_act_k),\n         sec.State_Collect (x \\<oplus> msg), s_act_a);\n        ou_ = Inr (sec.Out_Recv msg);\n        s1'_ =\n        ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Collected,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a\\<rbrakk>\n       \\<Longrightarrow> S (return_spmf\n                             ((((), None, ()), ()),\n                              (True, s_act_k <+> s_act_a),\n                              sec.State_Collected,\n                              sec_party_of_key_party ` s_act_k \\<inter>\n                              s_act_a))\n                          (map_spmf\n                            (\\<lambda>x.\n                                (((), (), ()), (key.State_Store x, s_act_k),\n                                 sec.State_Collected, s_act_a))\n                            (spmf_of_set (carrier \\<L>)))", "apply (rule S.intros(5)[simplified])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Collect msg,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s2'_ =\n        (((), (), ()), (key.State_Store x, s_act_k), sec.State_Collected,\n         s_act_a);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n          sec.State_Collect msg,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        spmf_of_set\n         ((\\<lambda>key.\n              (((), (), ()), (key.State_Store key, s_act_k),\n               sec.State_Collect (key \\<oplus> msg), s_act_a)) `\n          carrier \\<L>);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; x \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store x, s_act_k),\n         sec.State_Collect (x \\<oplus> msg), s_act_a);\n        ou_ = Inr (sec.Out_Recv msg);\n        s1'_ =\n        ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Collected,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a\\<rbrakk>\n       \\<Longrightarrow> s_act_k <+> s_act_a = s_act_k <+> s_act_a \\<and>\n                         sec_party_of_key_party ` s_act_k \\<inter> s_act_a =\n                         sec_party_of_key_party ` s_act_k \\<inter> s_act_a\n 2. \\<And>x.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Collect msg,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s2'_ =\n        (((), (), ()), (key.State_Store x, s_act_k), sec.State_Collected,\n         s_act_a);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n          sec.State_Collect msg,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        spmf_of_set\n         ((\\<lambda>key.\n              (((), (), ()), (key.State_Store key, s_act_k),\n               sec.State_Collect (key \\<oplus> msg), s_act_a)) `\n          carrier \\<L>);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; x \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store x, s_act_k),\n         sec.State_Collect (x \\<oplus> msg), s_act_a);\n        ou_ = Inr (sec.Out_Recv msg);\n        s1'_ =\n        ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Collected,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a\\<rbrakk>\n       \\<Longrightarrow> s_act_k = {key.Alice, key.Bob}\n 3. \\<And>x.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Collect msg,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s2'_ =\n        (((), (), ()), (key.State_Store x, s_act_k), sec.State_Collected,\n         s_act_a);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n          sec.State_Collect msg,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        spmf_of_set\n         ((\\<lambda>key.\n              (((), (), ()), (key.State_Store key, s_act_k),\n               sec.State_Collect (key \\<oplus> msg), s_act_a)) `\n          carrier \\<L>);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; x \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store x, s_act_k),\n         sec.State_Collect (x \\<oplus> msg), s_act_a);\n        ou_ = Inr (sec.Out_Recv msg);\n        s1'_ =\n        ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Collected,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a\\<rbrakk>\n       \\<Longrightarrow> s_act_a = {sec.Alice, sec.Bob}", "apply (simp_all split: sec.party.splits )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Collect msg,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s2'_ =\n        (((), (), ()), (key.State_Store x, s_act_k), sec.State_Collected,\n         s_act_a);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n          sec.State_Collect msg,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        spmf_of_set\n         ((\\<lambda>key.\n              (((), (), ()), (key.State_Store key, s_act_k),\n               sec.State_Collect (key \\<oplus> msg), s_act_a)) `\n          carrier \\<L>);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; x \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store x, s_act_k),\n         sec.State_Collect (x \\<oplus> msg), s_act_a);\n        ou_ = Inr (sec.Out_Recv msg);\n        s1'_ =\n        ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Collected,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a\\<rbrakk>\n       \\<Longrightarrow> s_act_k = {key.Alice, key.Bob}\n 2. \\<And>x.\n       \\<lbrakk>s1_ =\n                ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n                 sec.State_Collect msg,\n                 sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s2'_ =\n        (((), (), ()), (key.State_Store x, s_act_k), sec.State_Collected,\n         s_act_a);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n          sec.State_Collect msg,\n          sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_r =\n        spmf_of_set\n         ((\\<lambda>key.\n              (((), (), ()), (key.State_Store key, s_act_k),\n               sec.State_Collect (key \\<oplus> msg), s_act_a)) `\n          carrier \\<L>);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; x \\<in> carrier \\<L>;\n        s2_ =\n        (((), (), ()), (key.State_Store x, s_act_k),\n         sec.State_Collect (x \\<oplus> msg), s_act_a);\n        ou_ = Inr (sec.Out_Recv msg);\n        s1'_ =\n        ((((), None, ()), ()), (True, s_act_k <+> s_act_a),\n         sec.State_Collected,\n         sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_ka = s_act_k <+> s_act_a;\n        s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n        key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a\\<rbrakk>\n       \\<Longrightarrow> s_act_a = {sec.Alice, sec.Bob}", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inr q_bob;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k),\n           sec.State_Collect (key \\<oplus> msg), s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; sec.Bob \\<notin> s_act_s\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                         ou_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                         ou_)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inr q_bob;\n     s_i =\n     return_spmf\n      (case (None, (True, s_act_ka), sec.State_Collect msg, s_act_s) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     map_spmf\n      (\\<lambda>key.\n          (((), (), ()), (key.State_Store key, s_act_k),\n           sec.State_Collect (key \\<oplus> msg), s_act_a))\n      (spmf_of_set (carrier \\<L>));\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; sec.Bob \\<notin> s_act_s\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                         ou_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                         ou_)", "by (clarsimp simp add: stateless_callee_def split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  trace_eq_simcl S\n   (cond_spmf_fst\n     (bind_spmf s_i (\\<lambda>s1. cfunc_usr ideal_core' s1 query)) ou_)\n   (cond_spmf_fst\n     (bind_spmf s_r (\\<lambda>s2. cfunc_usr real_core' s2 query)) ou_)\n\ngoal (7 subgoals):\n 1. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (False, s_act_ka), sec.State_Void, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.PState_Store, s_act_k), sec.State_Void,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (False \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_s = {}\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 2. \\<And>s_act s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n              s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 3. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Store (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 4. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collected, s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob};\n        s_act_a = {sec.Alice, sec.Bob}\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 5. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Store (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 6. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Collect (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 7. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob}; s_act_a = {sec.Alice, sec.Bob};\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (False, s_act_ka), sec.State_Void, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.PState_Store, s_act_k), sec.State_Void,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (False \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_s = {}\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 2. \\<And>s_act s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n              s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 3. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Store (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 4. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collected, s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob};\n        s_act_a = {sec.Alice, sec.Bob}\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 5. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Store (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 6. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Collect (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 7. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob}; s_act_a = {sec.Alice, sec.Bob};\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)", "case (7 s_act_s s_act_k s_act_a s_act_ka msg key) \\<comment> \\<open>Corresponds to @{thm [source] s_2'_1}\\<close>"], ["proof (state)\nthis:\n  query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV\n  s1_ \\<in> set_spmf s_i\n  s2_ \\<in> set_spmf s_r\n  (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query)\n  (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query)\n  query = Inr q_bob\n  s_i =\n  return_spmf\n   (case (Some (key \\<oplus> msg), (True, s_act_ka), sec.State_Collect msg,\n          s_act_s) of\n    (x, y) \\<Rightarrow> ((((), x, ()), ()), y))\n  s_r =\n  return_spmf\n   (((), (), ()), (key.State_Store key, s_act_k),\n    sec.State_Collect (key \\<oplus> msg), s_act_a)\n  s_act_ka = s_act_k <+> s_act_a \\<and>\n  (True \\<longrightarrow>\n   s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\n  key.Alice \\<in> s_act_k\n  sec.Alice \\<in> s_act_a\n  msg \\<in> carrier \\<L>\n  key \\<in> carrier \\<L>\n\ngoal (7 subgoals):\n 1. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (False, s_act_ka), sec.State_Void, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.PState_Store, s_act_k), sec.State_Void,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (False \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_s = {}\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 2. \\<And>s_act s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n              s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 3. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Store (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 4. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collected, s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob};\n        s_act_a = {sec.Alice, sec.Bob}\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 5. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Store (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 6. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collect msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Collect (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 7. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob}; s_act_a = {sec.Alice, sec.Bob};\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)", "then"], ["proof (chain)\npicking this:\n  query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV\n  s1_ \\<in> set_spmf s_i\n  s2_ \\<in> set_spmf s_r\n  (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query)\n  (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query)\n  query = Inr q_bob\n  s_i =\n  return_spmf\n   (case (Some (key \\<oplus> msg), (True, s_act_ka), sec.State_Collect msg,\n          s_act_s) of\n    (x, y) \\<Rightarrow> ((((), x, ()), ()), y))\n  s_r =\n  return_spmf\n   (((), (), ()), (key.State_Store key, s_act_k),\n    sec.State_Collect (key \\<oplus> msg), s_act_a)\n  s_act_ka = s_act_k <+> s_act_a \\<and>\n  (True \\<longrightarrow>\n   s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\n  key.Alice \\<in> s_act_k\n  sec.Alice \\<in> s_act_a\n  msg \\<in> carrier \\<L>\n  key \\<in> carrier \\<L>", "show ?case"], ["proof (prove)\nusing this:\n  query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV\n  s1_ \\<in> set_spmf s_i\n  s2_ \\<in> set_spmf s_r\n  (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query)\n  (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query)\n  query = Inr q_bob\n  s_i =\n  return_spmf\n   (case (Some (key \\<oplus> msg), (True, s_act_ka), sec.State_Collect msg,\n          s_act_s) of\n    (x, y) \\<Rightarrow> ((((), x, ()), ()), y))\n  s_r =\n  return_spmf\n   (((), (), ()), (key.State_Store key, s_act_k),\n    sec.State_Collect (key \\<oplus> msg), s_act_a)\n  s_act_ka = s_act_k <+> s_act_a \\<and>\n  (True \\<longrightarrow>\n   s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\n  key.Alice \\<in> s_act_k\n  sec.Alice \\<in> s_act_a\n  msg \\<in> carrier \\<L>\n  key \\<in> carrier \\<L>\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S\n     (cond_spmf_fst\n       (bind_spmf s_i (\\<lambda>s1. cfunc_usr ideal_core' s1 query)) ou_)\n     (cond_spmf_fst\n       (bind_spmf s_r (\\<lambda>s2. cfunc_usr real_core' s2 query)) ou_)", "apply (cases \"sec.Bob \\<in> s_act_s\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inr q_bob;\n     s_i =\n     return_spmf\n      (case (Some (key \\<oplus> msg), (True, s_act_ka),\n             sec.State_Collect msg, s_act_s) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     return_spmf\n      (((), (), ()), (key.State_Store key, s_act_k),\n       sec.State_Collect (key \\<oplus> msg), s_act_a);\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>;\n     sec.Bob \\<in> s_act_s\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                         ou_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                         ou_)\n 2. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inr q_bob;\n     s_i =\n     return_spmf\n      (case (Some (key \\<oplus> msg), (True, s_act_ka),\n             sec.State_Collect msg, s_act_s) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     return_spmf\n      (((), (), ()), (key.State_Store key, s_act_k),\n       sec.State_Collect (key \\<oplus> msg), s_act_a);\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>;\n     sec.Bob \\<notin> s_act_s\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                         ou_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                         ou_)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inr q_bob;\n     s_i =\n     return_spmf\n      (case (Some (key \\<oplus> msg), (True, s_act_ka),\n             sec.State_Collect msg, s_act_s) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     return_spmf\n      (((), (), ()), (key.State_Store key, s_act_k),\n       sec.State_Collect (key \\<oplus> msg), s_act_a);\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>;\n     sec.Bob \\<in> s_act_s\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                         ou_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                         ou_)", "apply (clarsimp simp add: stateless_callee_def map_spmf_conv_bind_spmf[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1_ =\n             ((((), Some (key \\<oplus> msg), ()), ()),\n              (True, s_act_k <+> s_act_a), sec.State_Collect msg,\n              sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s2_ =\n     (((), (), ()), (key.State_Store key, s_act_k),\n      sec.State_Collect (key \\<oplus> msg), s_act_a);\n     s2'_ =\n     (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n      s_act_a);\n     query = Inr q_bob;\n     s_i =\n     return_spmf\n      ((((), Some (key \\<oplus> msg), ()), ()), (True, s_act_k <+> s_act_a),\n       sec.State_Collect msg,\n       sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s_r =\n     return_spmf\n      (((), (), ()), (key.State_Store key, s_act_k),\n       sec.State_Collect (key \\<oplus> msg), s_act_a);\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>;\n     ou_ = Inr (sec.Out_Recv msg);\n     s1'_ =\n     ((((), Some (key \\<oplus> msg), ()), ()), (True, s_act_k <+> s_act_a),\n      sec.State_Collected,\n      sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s_act_ka = s_act_k <+> s_act_a;\n     s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n     key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a\\<rbrakk>\n    \\<Longrightarrow> S (return_spmf\n                          ((((), Some (key \\<oplus> msg), ()), ()),\n                           (True, s_act_k <+> s_act_a), sec.State_Collected,\n                           sec_party_of_key_party ` s_act_k \\<inter>\n                           s_act_a))\n                       (return_spmf\n                         (((), (), ()), (key.State_Store key, s_act_k),\n                          sec.State_Collected, s_act_a))", "apply (rule S.intros(8)[simplified])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>s1_ =\n             ((((), Some (key \\<oplus> msg), ()), ()),\n              (True, s_act_k <+> s_act_a), sec.State_Collect msg,\n              sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s2_ =\n     (((), (), ()), (key.State_Store key, s_act_k),\n      sec.State_Collect (key \\<oplus> msg), s_act_a);\n     s2'_ =\n     (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n      s_act_a);\n     query = Inr q_bob;\n     s_i =\n     return_spmf\n      ((((), Some (key \\<oplus> msg), ()), ()), (True, s_act_k <+> s_act_a),\n       sec.State_Collect msg,\n       sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s_r =\n     return_spmf\n      (((), (), ()), (key.State_Store key, s_act_k),\n       sec.State_Collect (key \\<oplus> msg), s_act_a);\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>;\n     ou_ = Inr (sec.Out_Recv msg);\n     s1'_ =\n     ((((), Some (key \\<oplus> msg), ()), ()), (True, s_act_k <+> s_act_a),\n      sec.State_Collected,\n      sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s_act_ka = s_act_k <+> s_act_a;\n     s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n     key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a\\<rbrakk>\n    \\<Longrightarrow> s_act_k <+> s_act_a = s_act_k <+> s_act_a \\<and>\n                      sec_party_of_key_party ` s_act_k \\<inter> s_act_a =\n                      sec_party_of_key_party ` s_act_k \\<inter> s_act_a\n 2. \\<lbrakk>s1_ =\n             ((((), Some (key \\<oplus> msg), ()), ()),\n              (True, s_act_k <+> s_act_a), sec.State_Collect msg,\n              sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s2_ =\n     (((), (), ()), (key.State_Store key, s_act_k),\n      sec.State_Collect (key \\<oplus> msg), s_act_a);\n     s2'_ =\n     (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n      s_act_a);\n     query = Inr q_bob;\n     s_i =\n     return_spmf\n      ((((), Some (key \\<oplus> msg), ()), ()), (True, s_act_k <+> s_act_a),\n       sec.State_Collect msg,\n       sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s_r =\n     return_spmf\n      (((), (), ()), (key.State_Store key, s_act_k),\n       sec.State_Collect (key \\<oplus> msg), s_act_a);\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>;\n     ou_ = Inr (sec.Out_Recv msg);\n     s1'_ =\n     ((((), Some (key \\<oplus> msg), ()), ()), (True, s_act_k <+> s_act_a),\n      sec.State_Collected,\n      sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s_act_ka = s_act_k <+> s_act_a;\n     s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n     key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a\\<rbrakk>\n    \\<Longrightarrow> s_act_k = {key.Alice, key.Bob}\n 3. \\<lbrakk>s1_ =\n             ((((), Some (key \\<oplus> msg), ()), ()),\n              (True, s_act_k <+> s_act_a), sec.State_Collect msg,\n              sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s2_ =\n     (((), (), ()), (key.State_Store key, s_act_k),\n      sec.State_Collect (key \\<oplus> msg), s_act_a);\n     s2'_ =\n     (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n      s_act_a);\n     query = Inr q_bob;\n     s_i =\n     return_spmf\n      ((((), Some (key \\<oplus> msg), ()), ()), (True, s_act_k <+> s_act_a),\n       sec.State_Collect msg,\n       sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s_r =\n     return_spmf\n      (((), (), ()), (key.State_Store key, s_act_k),\n       sec.State_Collect (key \\<oplus> msg), s_act_a);\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>;\n     ou_ = Inr (sec.Out_Recv msg);\n     s1'_ =\n     ((((), Some (key \\<oplus> msg), ()), ()), (True, s_act_k <+> s_act_a),\n      sec.State_Collected,\n      sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s_act_ka = s_act_k <+> s_act_a;\n     s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n     key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a\\<rbrakk>\n    \\<Longrightarrow> s_act_a = {sec.Alice, sec.Bob}\n 4. \\<lbrakk>s1_ =\n             ((((), Some (key \\<oplus> msg), ()), ()),\n              (True, s_act_k <+> s_act_a), sec.State_Collect msg,\n              sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s2_ =\n     (((), (), ()), (key.State_Store key, s_act_k),\n      sec.State_Collect (key \\<oplus> msg), s_act_a);\n     s2'_ =\n     (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n      s_act_a);\n     query = Inr q_bob;\n     s_i =\n     return_spmf\n      ((((), Some (key \\<oplus> msg), ()), ()), (True, s_act_k <+> s_act_a),\n       sec.State_Collect msg,\n       sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s_r =\n     return_spmf\n      (((), (), ()), (key.State_Store key, s_act_k),\n       sec.State_Collect (key \\<oplus> msg), s_act_a);\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>;\n     ou_ = Inr (sec.Out_Recv msg);\n     s1'_ =\n     ((((), Some (key \\<oplus> msg), ()), ()), (True, s_act_k <+> s_act_a),\n      sec.State_Collected,\n      sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s_act_ka = s_act_k <+> s_act_a;\n     s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n     key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a\\<rbrakk>\n    \\<Longrightarrow> msg \\<in> carrier \\<L>\n 5. \\<lbrakk>s1_ =\n             ((((), Some (key \\<oplus> msg), ()), ()),\n              (True, s_act_k <+> s_act_a), sec.State_Collect msg,\n              sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s2_ =\n     (((), (), ()), (key.State_Store key, s_act_k),\n      sec.State_Collect (key \\<oplus> msg), s_act_a);\n     s2'_ =\n     (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n      s_act_a);\n     query = Inr q_bob;\n     s_i =\n     return_spmf\n      ((((), Some (key \\<oplus> msg), ()), ()), (True, s_act_k <+> s_act_a),\n       sec.State_Collect msg,\n       sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s_r =\n     return_spmf\n      (((), (), ()), (key.State_Store key, s_act_k),\n       sec.State_Collect (key \\<oplus> msg), s_act_a);\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>;\n     ou_ = Inr (sec.Out_Recv msg);\n     s1'_ =\n     ((((), Some (key \\<oplus> msg), ()), ()), (True, s_act_k <+> s_act_a),\n      sec.State_Collected,\n      sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s_act_ka = s_act_k <+> s_act_a;\n     s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n     key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a\\<rbrakk>\n    \\<Longrightarrow> key \\<in> carrier \\<L>", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>s1_ =\n             ((((), Some (key \\<oplus> msg), ()), ()),\n              (True, s_act_k <+> s_act_a), sec.State_Collect msg,\n              sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s2_ =\n     (((), (), ()), (key.State_Store key, s_act_k),\n      sec.State_Collect (key \\<oplus> msg), s_act_a);\n     s2'_ =\n     (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n      s_act_a);\n     query = Inr q_bob;\n     s_i =\n     return_spmf\n      ((((), Some (key \\<oplus> msg), ()), ()), (True, s_act_k <+> s_act_a),\n       sec.State_Collect msg,\n       sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s_r =\n     return_spmf\n      (((), (), ()), (key.State_Store key, s_act_k),\n       sec.State_Collect (key \\<oplus> msg), s_act_a);\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>;\n     ou_ = Inr (sec.Out_Recv msg);\n     s1'_ =\n     ((((), Some (key \\<oplus> msg), ()), ()), (True, s_act_k <+> s_act_a),\n      sec.State_Collected,\n      sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s_act_ka = s_act_k <+> s_act_a;\n     s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n     key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a\\<rbrakk>\n    \\<Longrightarrow> s_act_k = {key.Alice, key.Bob}\n 2. \\<lbrakk>s1_ =\n             ((((), Some (key \\<oplus> msg), ()), ()),\n              (True, s_act_k <+> s_act_a), sec.State_Collect msg,\n              sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s2_ =\n     (((), (), ()), (key.State_Store key, s_act_k),\n      sec.State_Collect (key \\<oplus> msg), s_act_a);\n     s2'_ =\n     (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n      s_act_a);\n     query = Inr q_bob;\n     s_i =\n     return_spmf\n      ((((), Some (key \\<oplus> msg), ()), ()), (True, s_act_k <+> s_act_a),\n       sec.State_Collect msg,\n       sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s_r =\n     return_spmf\n      (((), (), ()), (key.State_Store key, s_act_k),\n       sec.State_Collect (key \\<oplus> msg), s_act_a);\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>;\n     ou_ = Inr (sec.Out_Recv msg);\n     s1'_ =\n     ((((), Some (key \\<oplus> msg), ()), ()), (True, s_act_k <+> s_act_a),\n      sec.State_Collected,\n      sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     s_act_ka = s_act_k <+> s_act_a;\n     s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a;\n     key.Bob \\<in> s_act_k; sec.Bob \\<in> s_act_a\\<rbrakk>\n    \\<Longrightarrow> s_act_a = {sec.Alice, sec.Bob}", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inr q_bob;\n     s_i =\n     return_spmf\n      (case (Some (key \\<oplus> msg), (True, s_act_ka),\n             sec.State_Collect msg, s_act_s) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     return_spmf\n      (((), (), ()), (key.State_Store key, s_act_k),\n       sec.State_Collect (key \\<oplus> msg), s_act_a);\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>;\n     sec.Bob \\<notin> s_act_s\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                         ou_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                         ou_)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n     s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n     (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n     (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n     query = Inr q_bob;\n     s_i =\n     return_spmf\n      (case (Some (key \\<oplus> msg), (True, s_act_ka),\n             sec.State_Collect msg, s_act_s) of\n       (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n     s_r =\n     return_spmf\n      (((), (), ()), (key.State_Store key, s_act_k),\n       sec.State_Collect (key \\<oplus> msg), s_act_a);\n     s_act_ka = s_act_k <+> s_act_a \\<and>\n     (True \\<longrightarrow>\n      s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n     key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n     msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>;\n     sec.Bob \\<notin> s_act_s\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (bind_spmf s_i\n                           (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                         ou_)\n                       (cond_spmf_fst\n                         (bind_spmf s_r\n                           (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                         ou_)", "by (clarsimp simp add: stateless_callee_def split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  trace_eq_simcl S\n   (cond_spmf_fst\n     (bind_spmf s_i (\\<lambda>s1. cfunc_usr ideal_core' s1 query)) ou_)\n   (cond_spmf_fst\n     (bind_spmf s_r (\\<lambda>s2. cfunc_usr real_core' s2 query)) ou_)\n\ngoal (6 subgoals):\n 1. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (False, s_act_ka), sec.State_Void, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.PState_Store, s_act_k), sec.State_Void,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (False \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_s = {}\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 2. \\<And>s_act s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Void, s_act) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k), sec.State_Void,\n              s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act = sec_party_of_key_party ` s_act_k \\<inter> s_act_a)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 3. \\<And>s_act_s s_act_k s_act_a s_act_ka msg.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Store (key \\<oplus> msg), s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 4. \\<And>s_act_s s_act_k s_act_a s_act_ka.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (None, (True, s_act_ka), sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        map_spmf\n         (\\<lambda>key.\n             (((), (), ()), (key.State_Store key, s_act_k),\n              sec.State_Collected, s_act_a))\n         (spmf_of_set (carrier \\<L>));\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob};\n        s_act_a = {sec.Alice, sec.Bob}\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 5. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Store msg, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k),\n          sec.State_Store (key \\<oplus> msg), s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        key.Alice \\<in> s_act_k; sec.Alice \\<in> s_act_a;\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)\n 6. \\<And>s_act_s s_act_k s_act_a s_act_ka msg key.\n       \\<lbrakk>query \\<in> sec.Inp_Send ` carrier \\<L> <+> UNIV;\n        s1_ \\<in> set_spmf s_i; s2_ \\<in> set_spmf s_r;\n        (ou_, s1'_) \\<in> set_spmf (cfunc_usr ideal_core' s1_ query);\n        (ou_, s2'_) \\<in> set_spmf (cfunc_usr real_core' s2_ query);\n        query = Inr q_bob;\n        s_i =\n        return_spmf\n         (case (Some (key \\<oplus> msg), (True, s_act_ka),\n                sec.State_Collected, s_act_s) of\n          (x, y) \\<Rightarrow> ((((), x, ()), ()), y));\n        s_r =\n        return_spmf\n         (((), (), ()), (key.State_Store key, s_act_k), sec.State_Collected,\n          s_act_a);\n        s_act_ka = s_act_k <+> s_act_a \\<and>\n        (True \\<longrightarrow>\n         s_act_s = sec_party_of_key_party ` s_act_k \\<inter> s_act_a);\n        s_act_k = {key.Alice, key.Bob}; s_act_a = {sec.Alice, sec.Bob};\n        msg \\<in> carrier \\<L>; key \\<in> carrier \\<L>\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (bind_spmf s_i\n                              (\\<lambda>s1. cfunc_usr ideal_core' s1 query))\n                            ou_)\n                          (cond_spmf_fst\n                            (bind_spmf s_r\n                              (\\<lambda>s2. cfunc_usr real_core' s2 query))\n                            ou_)", "qed (auto simp add: stateless_callee_def split: auth.iusr_alice.split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  trace_core_eq ideal_core' real_core' UNIV\n   (UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>)\n   (sec.Inp_Send ` carrier \\<L> <+> UNIV) (return_spmf ideal_s_core')\n   (return_spmf real_s_core')\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Proving the trace equivalence of fused cores and rests\\<close>"], ["", "private"], ["", "definition \\<I>_adv_core :: \"(key.iadv + 'msg auth.iadv, key.oadv + 'msg auth.oadv) \\<I>\"\n  where \"\\<I>_adv_core \\<equiv> \\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_uniform (sec.Inp_Fedit ` (carrier \\<L>)) UNIV))\""], ["", "private"], ["", "definition \\<I>_usr_core :: \"('msg sec.iusr, 'msg sec.ousr) \\<I>\"\n  where \"\\<I>_usr_core \\<equiv> \\<I>_uniform (sec.Inp_Send ` (carrier \\<L>)) UNIV \\<oplus>\\<^sub>\\<I> \\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>)\""], ["", "private"], ["", "definition invar_ideal' :: \"((_ \\<times> 'msg astate \\<times> _) \\<times> _) \\<times> estate \\<times> 'msg sec.state \\<Rightarrow> bool\"\n  where \"invar_ideal' = pred_prod (pred_prod (pred_prod (\\<lambda>_. True) (pred_prod (pred_option (\\<lambda>x. x \\<in> carrier \\<L>)) (\\<lambda>_. True))) (\\<lambda>_. True)) (pred_prod (\\<lambda>_. True) (pred_prod (sec.pred_s_kernel (\\<lambda>x. x \\<in> carrier \\<L>)) (\\<lambda>_. True)))\""], ["", "private"], ["", "definition invar_real' :: \"_ \\<times> ('msg key.s_kernel \\<times> _) \\<times> 'msg sec.s_kernel \\<times> _ \\<Rightarrow> bool\"\n  where \"invar_real' = pred_prod (\\<lambda>_. True) (pred_prod (pred_prod (key.pred_s_kernel (\\<lambda>x. x \\<in> carrier \\<L>)) (\\<lambda>_. True)) (pred_prod (sec.pred_s_kernel (\\<lambda>x. x \\<in> carrier \\<L>)) (\\<lambda>_. True)))\""], ["", "lemma invar_ideal_s_core' [simp]: \"invar_ideal' ideal_s_core'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_ideal' ideal_s_core'", "by(simp add: invar_ideal'_def ideal_s_core'_def)"], ["", "lemma invar_real_s_core' [simp]: \"invar_real' real_s_core'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_real' real_s_core'", "by(simp add: invar_real'_def real_s_core'_def)"], ["", "lemma WT_ideal_core' [WT_intro]: \"WT_core \\<I>_adv_core \\<I>_usr_core invar_ideal' ideal_core'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WT_core \\<I>_adv_core \\<I>_usr_core invar_ideal' ideal_core'", "apply(rule WT_core.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s e s'.\n       \\<lbrakk>s' \\<in> set_spmf (cpoke ideal_core' s e);\n        invar_ideal' s\\<rbrakk>\n       \\<Longrightarrow> invar_ideal' s'\n 2. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (cfunc_adv ideal_core' s x);\n        x \\<in> outs_\\<I> \\<I>_adv_core; invar_ideal' s\\<rbrakk>\n       \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_adv_core x \\<and>\n                         invar_ideal' s'\n 3. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (cfunc_usr ideal_core' s x);\n        x \\<in> outs_\\<I> \\<I>_usr_core; invar_ideal' s\\<rbrakk>\n       \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_usr_core x \\<and>\n                         invar_ideal' s'", "apply                \n    (auto split!: sum.splits option.splits if_split_asm simp add: \\<I>_adv_core_def \\<I>_usr_core_def exec_gpv_map_gpv_id exec_gpv_extend_state_oracle exec_gpv_plus_oracle_left exec_gpv_plus_oracle_right invar_ideal'_def sec.in_set_spmf_iface_drop sec.in_set_spmf_iface_look sec.in_set_spmf_iface_fedit sec.in_set_spmf_iface_alice sec.in_set_spmf_iface_bob id_oracle_def look_callee_def exec_gpv_bind set_spmf_of_set sec.poke_alt_def foldl_spmf_pair_right)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WT_ideal_rest' [WT_intro]:\n  assumes \"WT_rest \\<I>_adv_restk \\<I>_usr_restk I_key_rest key_rest\"\n    and \"WT_rest \\<I>_adv_resta \\<I>_usr_resta I_auth_rest auth_rest\"\n  shows \"WT_rest (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta) (\\<I>_usr_restk \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta) (\\<lambda>(_, s_rest). pred_prod I_key_rest I_auth_rest s_rest) ideal_rest'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WT_rest (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta)\n     (\\<I>_usr_restk \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta)\n     (\\<lambda>(uu_, s_rest). pred_prod I_key_rest I_auth_rest s_rest)\n     ideal_rest'", "by(rule WT_rest.intros)(fastforce simp add: fused_resource.fuse.simps parallel_eoracle_def dest: WT_restD_rfunc_adv[OF assms(1)] WT_restD_rfunc_adv[OF assms(2)] WT_restD_rfunc_usr[OF assms(1)] WT_restD_rfunc_usr[OF assms(2)] simp add: assms[THEN WT_restD_rinit])+"], ["", "lemma WT_real_core' [WT_intro]: \"WT_core \\<I>_adv_core \\<I>_usr_core invar_real' real_core'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WT_core \\<I>_adv_core \\<I>_usr_core invar_real' real_core'", "apply(rule WT_core.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s e s'.\n       \\<lbrakk>s' \\<in> set_spmf (cpoke real_core' s e);\n        invar_real' s\\<rbrakk>\n       \\<Longrightarrow> invar_real' s'\n 2. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (cfunc_adv real_core' s x);\n        x \\<in> outs_\\<I> \\<I>_adv_core; invar_real' s\\<rbrakk>\n       \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_adv_core x \\<and>\n                         invar_real' s'\n 3. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (cfunc_usr real_core' s x);\n        x \\<in> outs_\\<I> \\<I>_usr_core; invar_real' s\\<rbrakk>\n       \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_usr_core x \\<and>\n                         invar_real' s'", "apply(auto simp add: \\<I>_adv_core_def \\<I>_usr_core_def enc_callee_def dec_callee_def\n        stateless_callee_def Let_def exec_gpv_extend_state_oracle exec_gpv_map_gpv' exec_gpv_plus_oracle_left exec_gpv_plus_oracle_right\n        invar_real'_def in_set_spmf_parallel_handler key.in_set_spmf_poke sec.poke_alt_def auth.in_set_spmf_iface_look auth.in_set_spmf_iface_fedit\n        sec.in_set_spmf_iface_alice sec.in_set_spmf_iface_bob\n        split!: key.ousr_alice.splits key.ousr_bob.splits auth.ousr_alice.splits auth.ousr_bob.splits sum.splits if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "private"], ["", "lemma trace_eq_sec: \n    fixes \\<I>_adv_restk \\<I>_adv_resta \\<I>_usr_restk \\<I>_usr_resta \n  defines \"outs_adv \\<equiv> (UNIV <+> UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>) <+> outs_\\<I> (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta)\"\n      and \"outs_usr \\<equiv> (sec.Inp_Send ` carrier \\<L> <+> UNIV) <+> outs_\\<I> (\\<I>_usr_restk \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta)\"\n  assumes WT_key [WT_intro]: \"WT_rest \\<I>_adv_restk \\<I>_usr_restk I_key_rest key_rest\" \n      and WT_auth [WT_intro]: \"WT_rest \\<I>_adv_resta \\<I>_usr_resta I_auth_rest auth_rest\"\n    shows \"(outs_adv <+> outs_usr) \\<turnstile>\\<^sub>C fused_resource.fuse ideal_core' ideal_rest' ((ideal_s_core', ideal_s_rest')) \\<approx> \n      fused_resource.fuse real_core' real_rest' ((real_s_core', real_s_rest'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (outs_adv <+> outs_usr) \\<turnstile>\\<^sub>C\n    fused_resource.fuse ideal_core'\n     ideal_rest'((ideal_s_core', ideal_s_rest')) \\<approx>\n    fused_resource.fuse real_core' real_rest'((real_s_core', real_s_rest'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (outs_adv <+> outs_usr) \\<turnstile>\\<^sub>C\n    fused_resource.fuse ideal_core'\n     ideal_rest'((ideal_s_core', ideal_s_rest')) \\<approx>\n    fused_resource.fuse real_core' real_rest'((real_s_core', real_s_rest'))", "define e\\<I>_adv_rest :: \"(_, _ \\<times> (key.event + auth.event) list) \\<I>\"\n    where \"e\\<I>_adv_rest \\<equiv> map_\\<I> id (case_sum (map_prod Inl (map Inl)) (map_prod Inr (map Inr))) (e\\<I> \\<I>_adv_restk \\<oplus>\\<^sub>\\<I> e\\<I> \\<I>_adv_resta)\""], ["proof (state)\nthis:\n  e\\<I>_adv_rest \\<equiv>\n  map_\\<I> id (case_sum (map_prod Inl (map Inl)) (map_prod Inr (map Inr)))\n   (e\\<I> \\<I>_adv_restk \\<oplus>\\<^sub>\\<I> e\\<I> \\<I>_adv_resta)\n\ngoal (1 subgoal):\n 1. (outs_adv <+> outs_usr) \\<turnstile>\\<^sub>C\n    fused_resource.fuse ideal_core'\n     ideal_rest'((ideal_s_core', ideal_s_rest')) \\<approx>\n    fused_resource.fuse real_core' real_rest'((real_s_core', real_s_rest'))", "define e\\<I>_usr_rest :: \"(_, _ \\<times> (key.event + auth.event) list) \\<I>\"\n    where \"e\\<I>_usr_rest \\<equiv> map_\\<I> id (case_sum (map_prod Inl (map Inl)) (map_prod Inr (map Inr))) (e\\<I> \\<I>_usr_restk \\<oplus>\\<^sub>\\<I> e\\<I> \\<I>_usr_resta)\""], ["proof (state)\nthis:\n  e\\<I>_usr_rest \\<equiv>\n  map_\\<I> id (case_sum (map_prod Inl (map Inl)) (map_prod Inr (map Inr)))\n   (e\\<I> \\<I>_usr_restk \\<oplus>\\<^sub>\\<I> e\\<I> \\<I>_usr_resta)\n\ngoal (1 subgoal):\n 1. (outs_adv <+> outs_usr) \\<turnstile>\\<^sub>C\n    fused_resource.fuse ideal_core'\n     ideal_rest'((ideal_s_core', ideal_s_rest')) \\<approx>\n    fused_resource.fuse real_core' real_rest'((real_s_core', real_s_rest'))", "note I_defs = \\<I>_adv_core_def \\<I>_usr_core_def"], ["proof (state)\nthis:\n  \\<I>_adv_core \\<equiv>\n  \\<I>_full \\<oplus>\\<^sub>\\<I>\n  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV))\n  \\<I>_usr_core \\<equiv>\n  \\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV \\<oplus>\\<^sub>\\<I>\n  \\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>)\n\ngoal (1 subgoal):\n 1. (outs_adv <+> outs_usr) \\<turnstile>\\<^sub>C\n    fused_resource.fuse ideal_core'\n     ideal_rest'((ideal_s_core', ideal_s_rest')) \\<approx>\n    fused_resource.fuse real_core' real_rest'((real_s_core', real_s_rest'))", "note eI_defs = e\\<I>_adv_rest_def e\\<I>_usr_rest_def"], ["proof (state)\nthis:\n  e\\<I>_adv_rest \\<equiv>\n  map_\\<I> id (case_sum (map_prod Inl (map Inl)) (map_prod Inr (map Inr)))\n   (e\\<I> \\<I>_adv_restk \\<oplus>\\<^sub>\\<I> e\\<I> \\<I>_adv_resta)\n  e\\<I>_usr_rest \\<equiv>\n  map_\\<I> id (case_sum (map_prod Inl (map Inl)) (map_prod Inr (map Inr)))\n   (e\\<I> \\<I>_usr_restk \\<oplus>\\<^sub>\\<I> e\\<I> \\<I>_usr_resta)\n\ngoal (1 subgoal):\n 1. (outs_adv <+> outs_usr) \\<turnstile>\\<^sub>C\n    fused_resource.fuse ideal_core'\n     ideal_rest'((ideal_s_core', ideal_s_rest')) \\<approx>\n    fused_resource.fuse real_core' real_rest'((real_s_core', real_s_rest'))", "have fact1[unfolded outs_plus_\\<I>]: \n    \"trace_rest_eq ideal_rest' ideal_rest' (outs_\\<I> (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta)) (outs_\\<I> (\\<I>_usr_restk \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta)) s s\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_rest_eq ideal_rest' ideal_rest'\n     (outs_\\<I> (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta))\n     (outs_\\<I> (\\<I>_usr_restk \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta)) s s", "apply(rule rel_rest'_into_trace_rest_eq[where S=\"(=)\" and M=\"(=)\", unfolded eq_onp_def], simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_rest' (=) (=)\n     (\\<lambda>x y.\n         x \\<in> outs_\\<I> \\<I>_adv_restk <+>\n                 outs_\\<I> \\<I>_adv_resta \\<and>\n         x = y)\n     (\\<lambda>x y.\n         x \\<in> outs_\\<I> \\<I>_usr_restk <+>\n                 outs_\\<I> \\<I>_usr_resta \\<and>\n         x = y)\n     (=) (=) (=) ideal_rest' ideal_rest'", "apply(fold relator_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_rest' (rel_prod (rel_prod (=) (=)) (rel_prod (=) (=)))\n     (rel_sum (=) (=))\n     (\\<lambda>x y.\n         x \\<in> outs_\\<I> \\<I>_adv_restk <+>\n                 outs_\\<I> \\<I>_adv_resta \\<and>\n         rel_sum (=) (=) x y)\n     (\\<lambda>x y.\n         x \\<in> outs_\\<I> \\<I>_usr_restk <+>\n                 outs_\\<I> \\<I>_usr_resta \\<and>\n         rel_sum (=) (=) x y)\n     (rel_sum (=) (=)) (rel_sum (=) (=))\n     (rel_prod (rel_prod (=) (=)) (rel_prod (=) (=))) ideal_rest'\n     ideal_rest'", "apply(rule rel_rest'_mono[THEN predicate2D, rotated -1, OF HOL.refl[of ideal_rest', folded relator_eq]])"], ["proof (prove)\ngoal (6 subgoals):\n 1. rel_sum (=) (=) \\<le> rel_sum (=) (=)\n 2. (\\<lambda>x y.\n        x \\<in> outs_\\<I> \\<I>_adv_restk <+> outs_\\<I> \\<I>_adv_resta \\<and>\n        rel_sum (=) (=) x y)\n    \\<le> rel_sum (=) (=)\n 3. (\\<lambda>x y.\n        x \\<in> outs_\\<I> \\<I>_usr_restk <+> outs_\\<I> \\<I>_usr_resta \\<and>\n        rel_sum (=) (=) x y)\n    \\<le> rel_sum (=) (=)\n 4. rel_sum (=) (=) \\<le> rel_sum (=) (=)\n 5. rel_sum (=) (=) \\<le> rel_sum (=) (=)\n 6. rel_prod (rel_prod (=) (=)) (rel_prod (=) (=))\n    \\<le> rel_prod (rel_prod (=) (=)) (rel_prod (=) (=))", "by auto"], ["proof (state)\nthis:\n  trace_rest_eq ideal_rest' ideal_rest'\n   (outs_\\<I> \\<I>_adv_restk <+> outs_\\<I> \\<I>_adv_resta)\n   (outs_\\<I> \\<I>_usr_restk <+> outs_\\<I> \\<I>_usr_resta) ?s7 ?s7\n\ngoal (1 subgoal):\n 1. (outs_adv <+> outs_usr) \\<turnstile>\\<^sub>C\n    fused_resource.fuse ideal_core'\n     ideal_rest'((ideal_s_core', ideal_s_rest')) \\<approx>\n    fused_resource.fuse real_core' real_rest'((real_s_core', real_s_rest'))", "have fact2 [unfolded eI_defs]: \"callee_invariant_on (callee_of_rest ideal_rest') (\\<lambda>(_, s_rest). pred_prod I_key_rest I_auth_rest s_rest) (e\\<I>_adv_rest \\<oplus>\\<^sub>\\<I> e\\<I>_usr_rest)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on (callee_of_rest ideal_rest')\n     (\\<lambda>(uu_, s_rest). pred_prod I_key_rest I_auth_rest s_rest)\n     (e\\<I>_adv_rest \\<oplus>\\<^sub>\\<I> e\\<I>_usr_rest)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (callee_of_rest ideal_rest' s x);\n        case s of\n        (uu_, s_rest) \\<Rightarrow> pred_prod I_key_rest I_auth_rest s_rest;\n        x \\<in> outs_\\<I>\n                 (e\\<I>_adv_rest \\<oplus>\\<^sub>\\<I>\n                  e\\<I>_usr_rest)\\<rbrakk>\n       \\<Longrightarrow> case s' of\n                         (uu_, s_rest) \\<Rightarrow>\n                           pred_prod I_key_rest I_auth_rest s_rest\n 2. \\<And>s.\n       case s of\n       (uu_, s_rest) \\<Rightarrow>\n         pred_prod I_key_rest I_auth_rest s_rest \\<Longrightarrow>\n       e\\<I>_adv_rest \\<oplus>\\<^sub>\\<I> e\\<I>_usr_rest \\<turnstile>c\n       callee_of_rest ideal_rest' s \\<surd>", "subgoal for s x y s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(y, s') \\<in> set_spmf (callee_of_rest ideal_rest' s x);\n     case s of\n     (uu_, s_rest) \\<Rightarrow> pred_prod I_key_rest I_auth_rest s_rest;\n     x \\<in> outs_\\<I>\n              (e\\<I>_adv_rest \\<oplus>\\<^sub>\\<I> e\\<I>_usr_rest)\\<rbrakk>\n    \\<Longrightarrow> case s' of\n                      (uu_, s_rest) \\<Rightarrow>\n                        pred_prod I_key_rest I_auth_rest s_rest", "apply(cases \"(snd s, x)\" rule: parallel_oracle.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s1 s2 a.\n       \\<lbrakk>(y, s') \\<in> set_spmf (callee_of_rest ideal_rest' s x);\n        case s of\n        (uu_, s_rest) \\<Rightarrow> pred_prod I_key_rest I_auth_rest s_rest;\n        x \\<in> outs_\\<I>\n                 (e\\<I>_adv_rest \\<oplus>\\<^sub>\\<I> e\\<I>_usr_rest);\n        (snd s, x) = ((s1, s2), Inl a)\\<rbrakk>\n       \\<Longrightarrow> case s' of\n                         (uu_, s_rest) \\<Rightarrow>\n                           pred_prod I_key_rest I_auth_rest s_rest\n 2. \\<And>s1 s2 b.\n       \\<lbrakk>(y, s') \\<in> set_spmf (callee_of_rest ideal_rest' s x);\n        case s of\n        (uu_, s_rest) \\<Rightarrow> pred_prod I_key_rest I_auth_rest s_rest;\n        x \\<in> outs_\\<I>\n                 (e\\<I>_adv_rest \\<oplus>\\<^sub>\\<I> e\\<I>_usr_rest);\n        (snd s, x) = ((s1, s2), Inr b)\\<rbrakk>\n       \\<Longrightarrow> case s' of\n                         (uu_, s_rest) \\<Rightarrow>\n                           pred_prod I_key_rest I_auth_rest s_rest", "apply(auto 4 3 simp add: parallel_eoracle_def eI_defs split!: sum.splits dest: WT_restD(1,2)[OF WT_key] WT_restD(1,2)[OF WT_auth])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       case s of\n       (uu_, s_rest) \\<Rightarrow>\n         pred_prod I_key_rest I_auth_rest s_rest \\<Longrightarrow>\n       e\\<I>_adv_rest \\<oplus>\\<^sub>\\<I> e\\<I>_usr_rest \\<turnstile>c\n       callee_of_rest ideal_rest' s \\<surd>", "subgoal for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. case s of\n    (uu_, s_rest) \\<Rightarrow>\n      pred_prod I_key_rest I_auth_rest s_rest \\<Longrightarrow>\n    e\\<I>_adv_rest \\<oplus>\\<^sub>\\<I> e\\<I>_usr_rest \\<turnstile>c\n    callee_of_rest ideal_rest' s \\<surd>", "apply(fastforce intro!: WT_calleeI simp add: parallel_eoracle_def eI_defs image_image dest: WT_restD(1,2)[OF WT_key] WT_restD(1,2)[OF WT_auth] intro: rev_image_eqI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  callee_invariant_on (callee_of_rest ideal_rest')\n   (\\<lambda>(uu_, s_rest). pred_prod I_key_rest I_auth_rest s_rest)\n   (map_\\<I> id (case_sum (map_prod Inl (map Inl)) (map_prod Inr (map Inr)))\n     (e\\<I> \\<I>_adv_restk \\<oplus>\\<^sub>\\<I>\n      e\\<I> \\<I>_adv_resta) \\<oplus>\\<^sub>\\<I>\n    map_\\<I> id (case_sum (map_prod Inl (map Inl)) (map_prod Inr (map Inr)))\n     (e\\<I> \\<I>_usr_restk \\<oplus>\\<^sub>\\<I> e\\<I> \\<I>_usr_resta))\n\ngoal (1 subgoal):\n 1. (outs_adv <+> outs_usr) \\<turnstile>\\<^sub>C\n    fused_resource.fuse ideal_core'\n     ideal_rest'((ideal_s_core', ideal_s_rest')) \\<approx>\n    fused_resource.fuse real_core' real_rest'((real_s_core', real_s_rest'))", "have fact3[unfolded I_defs]: \"callee_invariant_on (callee_of_core ideal_core') invar_ideal' (\\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_adv_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_core))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on (callee_of_core ideal_core') invar_ideal'\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      (\\<I>_adv_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_core))", "by(rule WT_intro)+"], ["proof (state)\nthis:\n  callee_invariant_on (callee_of_core ideal_core') invar_ideal'\n   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n    ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n      (\\<I>_full \\<oplus>\\<^sub>\\<I>\n       (\\<I>_full \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>)\n         UNIV))) \\<oplus>\\<^sub>\\<I>\n     (\\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>))))\n\ngoal (1 subgoal):\n 1. (outs_adv <+> outs_usr) \\<turnstile>\\<^sub>C\n    fused_resource.fuse ideal_core'\n     ideal_rest'((ideal_s_core', ideal_s_rest')) \\<approx>\n    fused_resource.fuse real_core' real_rest'((real_s_core', real_s_rest'))", "have fact4[unfolded I_defs]: \"callee_invariant_on (callee_of_core real_core') invar_real' (\\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_adv_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_core))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on (callee_of_core real_core') invar_real'\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      (\\<I>_adv_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_core))", "by(rule WT_intro)+"], ["proof (state)\nthis:\n  callee_invariant_on (callee_of_core real_core') invar_real'\n   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n    ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n      (\\<I>_full \\<oplus>\\<^sub>\\<I>\n       (\\<I>_full \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>)\n         UNIV))) \\<oplus>\\<^sub>\\<I>\n     (\\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>))))\n\ngoal (1 subgoal):\n 1. (outs_adv <+> outs_usr) \\<turnstile>\\<^sub>C\n    fused_resource.fuse ideal_core'\n     ideal_rest'((ideal_s_core', ideal_s_rest')) \\<approx>\n    fused_resource.fuse real_core' real_rest'((real_s_core', real_s_rest'))", "note nempty_carrier[simp]"], ["proof (state)\nthis:\n  carrier \\<L> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (outs_adv <+> outs_usr) \\<turnstile>\\<^sub>C\n    fused_resource.fuse ideal_core'\n     ideal_rest'((ideal_s_core', ideal_s_rest')) \\<approx>\n    fused_resource.fuse real_core' real_rest'((real_s_core', real_s_rest'))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (outs_adv <+> outs_usr) \\<turnstile>\\<^sub>C\n    fused_resource.fuse ideal_core'\n     ideal_rest'((ideal_s_core', ideal_s_rest')) \\<approx>\n    fused_resource.fuse real_core' real_rest'((real_s_core', real_s_rest'))", "using WT_key[THEN WT_restD_rinit] WT_auth[THEN WT_restD_rinit]"], ["proof (prove)\nusing this:\n  I_key_rest (rinit key_rest)\n  I_auth_rest (rinit auth_rest)\n\ngoal (1 subgoal):\n 1. (outs_adv <+> outs_usr) \\<turnstile>\\<^sub>C\n    fused_resource.fuse ideal_core'\n     ideal_rest'((ideal_s_core', ideal_s_rest')) \\<approx>\n    fused_resource.fuse real_core' real_rest'((real_s_core', real_s_rest'))", "apply (simp add: real_rest'_def real_s_rest'_def assms(1, 2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I_key_rest (rinit key_rest);\n     I_auth_rest (rinit auth_rest)\\<rbrakk>\n    \\<Longrightarrow> (((UNIV <+>\n                         UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>) <+>\n                        outs_\\<I> \\<I>_adv_restk <+>\n                        outs_\\<I> \\<I>_adv_resta) <+>\n                       (sec.Inp_Send ` carrier \\<L> <+> UNIV) <+>\n                       outs_\\<I> \\<I>_usr_restk <+>\n                       outs_\\<I> \\<I>_usr_resta) \\<turnstile>\\<^sub>C\n                      fused_resource.fuse ideal_core'\n                       ideal_rest'((ideal_s_core', ideal_s_rest')) \\<approx>\n                      fused_resource.fuse real_core'\n                       ideal_rest'((real_s_core', ideal_s_rest'))", "thm fuse_trace_eq[where \\<I>E=\\<I>_full and \\<I>CA=\\<I>_adv_core and \\<I>CU=\\<I>_usr_core and \\<I>RA=e\\<I>_adv_rest and \\<I>RU=e\\<I>_usr_rest,unfolded eI_defs \\<I>_adv_core_def \\<I>_usr_core_def,simplified]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I_key_rest (rinit key_rest);\n     I_auth_rest (rinit auth_rest)\\<rbrakk>\n    \\<Longrightarrow> (((UNIV <+>\n                         UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>) <+>\n                        outs_\\<I> \\<I>_adv_restk <+>\n                        outs_\\<I> \\<I>_adv_resta) <+>\n                       (sec.Inp_Send ` carrier \\<L> <+> UNIV) <+>\n                       outs_\\<I> \\<I>_usr_restk <+>\n                       outs_\\<I> \\<I>_usr_resta) \\<turnstile>\\<^sub>C\n                      fused_resource.fuse ideal_core'\n                       ideal_rest'((ideal_s_core', ideal_s_rest')) \\<approx>\n                      fused_resource.fuse real_core'\n                       ideal_rest'((real_s_core', ideal_s_rest'))", "apply (rule fuse_trace_eq[where \\<I>E=\\<I>_full and \\<I>CA=\\<I>_adv_core and \\<I>CU=\\<I>_usr_core and \\<I>RA=e\\<I>_adv_rest and \\<I>RU=e\\<I>_usr_rest\n      and ?IR1.0 = \"\\<lambda>(_, s_rest). pred_prod I_key_rest I_auth_rest s_rest\"\n      and ?IR2.0 = \"\\<lambda>(_, s_rest). pred_prod I_key_rest I_auth_rest s_rest\"\n      and ?IC1.0 = invar_ideal' and ?IC2.0=invar_real',\n      unfolded eI_defs \\<I>_adv_core_def \\<I>_usr_core_def, simplified])"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>I_key_rest (rinit key_rest);\n     I_auth_rest (rinit auth_rest)\\<rbrakk>\n    \\<Longrightarrow> trace_core_eq ideal_core' real_core' UNIV\n                       (UNIV <+>\n                        UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>)\n                       (sec.Inp_Send ` carrier \\<L> <+> UNIV)\n                       (return_spmf ideal_s_core')\n                       (return_spmf real_s_core')\n 2. \\<lbrakk>I_key_rest (rinit key_rest);\n     I_auth_rest (rinit auth_rest)\\<rbrakk>\n    \\<Longrightarrow> trace_rest_eq ideal_rest' ideal_rest'\n                       (outs_\\<I> \\<I>_adv_restk <+>\n                        outs_\\<I> \\<I>_adv_resta)\n                       (outs_\\<I> \\<I>_usr_restk <+>\n                        outs_\\<I> \\<I>_usr_resta)\n                       (return_spmf ideal_s_rest')\n                       (return_spmf ideal_s_rest')\n 3. \\<lbrakk>I_key_rest (rinit key_rest);\n     I_auth_rest (rinit auth_rest)\\<rbrakk>\n    \\<Longrightarrow> callee_invariant_on (callee_of_core ideal_core')\n                       invar_ideal'\n                       (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                        ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                            \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>)\n                             UNIV))) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_uniform (sec.Inp_Send ` carrier \\<L>)\n                           UNIV \\<oplus>\\<^sub>\\<I>\n                          \\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>))))\n 4. \\<lbrakk>I_key_rest (rinit key_rest);\n     I_auth_rest (rinit auth_rest)\\<rbrakk>\n    \\<Longrightarrow> invar_ideal' ideal_s_core'\n 5. \\<lbrakk>I_key_rest (rinit key_rest);\n     I_auth_rest (rinit auth_rest)\\<rbrakk>\n    \\<Longrightarrow> callee_invariant_on (callee_of_core real_core')\n                       invar_real'\n                       (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                        ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                            \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>)\n                             UNIV))) \\<oplus>\\<^sub>\\<I>\n                         (\\<I>_uniform (sec.Inp_Send ` carrier \\<L>)\n                           UNIV \\<oplus>\\<^sub>\\<I>\n                          \\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>))))\n 6. \\<lbrakk>I_key_rest (rinit key_rest);\n     I_auth_rest (rinit auth_rest)\\<rbrakk>\n    \\<Longrightarrow> invar_real' real_s_core'\n 7. \\<lbrakk>I_key_rest (rinit key_rest);\n     I_auth_rest (rinit auth_rest)\\<rbrakk>\n    \\<Longrightarrow> callee_invariant_on (callee_of_rest ideal_rest')\n                       (\\<lambda>(uu_, s_rest).\n                           pred_prod I_key_rest I_auth_rest s_rest)\n                       (map_\\<I> id\n                         (case_sum (map_prod Inl (map Inl))\n                           (map_prod Inr (map Inr)))\n                         (e\\<I> \\<I>_adv_restk \\<oplus>\\<^sub>\\<I>\n                          e\\<I> \\<I>_adv_resta) \\<oplus>\\<^sub>\\<I>\n                        map_\\<I> id\n                         (case_sum (map_prod Inl (map Inl))\n                           (map_prod Inr (map Inr)))\n                         (e\\<I> \\<I>_usr_restk \\<oplus>\\<^sub>\\<I>\n                          e\\<I> \\<I>_usr_resta))\n 8. \\<lbrakk>I_key_rest (rinit key_rest);\n     I_auth_rest (rinit auth_rest)\\<rbrakk>\n    \\<Longrightarrow> case ideal_s_rest' of\n                      (uu_, s_rest) \\<Rightarrow>\n                        pred_prod I_key_rest I_auth_rest s_rest\n 9. \\<lbrakk>I_key_rest (rinit key_rest);\n     I_auth_rest (rinit auth_rest)\\<rbrakk>\n    \\<Longrightarrow> callee_invariant_on (callee_of_rest ideal_rest')\n                       (\\<lambda>(uu_, s_rest).\n                           pred_prod I_key_rest I_auth_rest s_rest)\n                       (map_\\<I> id\n                         (case_sum (map_prod Inl (map Inl))\n                           (map_prod Inr (map Inr)))\n                         (e\\<I> \\<I>_adv_restk \\<oplus>\\<^sub>\\<I>\n                          e\\<I> \\<I>_adv_resta) \\<oplus>\\<^sub>\\<I>\n                        map_\\<I> id\n                         (case_sum (map_prod Inl (map Inl))\n                           (map_prod Inr (map Inr)))\n                         (e\\<I> \\<I>_usr_restk \\<oplus>\\<^sub>\\<I>\n                          e\\<I> \\<I>_usr_resta))\n 10. \\<lbrakk>I_key_rest (rinit key_rest);\n      I_auth_rest (rinit auth_rest)\\<rbrakk>\n     \\<Longrightarrow> case ideal_s_rest' of\n                       (uu_, s_rest) \\<Rightarrow>\n                         pred_prod I_key_rest I_auth_rest s_rest", "by (simp_all add: trace_eq_core fact1 fact2 fact3 fact4 ideal_s_rest'_def)"], ["proof (state)\nthis:\n  (outs_adv <+> outs_usr) \\<turnstile>\\<^sub>C\n  fused_resource.fuse ideal_core'\n   ideal_rest'((ideal_s_core', ideal_s_rest')) \\<approx>\n  fused_resource.fuse real_core' real_rest'((real_s_core', real_s_rest'))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Simplifying the final resource by moving the interfaces from core to rest\\<close>"], ["", "lemma connect[unfolded \\<I>_adv_core_def \\<I>_usr_core_def]:\n    fixes \\<I>_adv_restk \\<I>_adv_resta \\<I>_usr_restk \\<I>_usr_resta \n  defines \"\\<I> \\<equiv> (\\<I>_adv_core \\<oplus>\\<^sub>\\<I> (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta)) \\<oplus>\\<^sub>\\<I> (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> (\\<I>_usr_restk \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta))\"\n  assumes [WT_intro]: \"WT_rest \\<I>_adv_restk \\<I>_usr_restk I_key_rest key_rest\" \n      and [WT_intro]: \"WT_rest \\<I>_adv_resta \\<I>_usr_resta I_auth_rest auth_rest\"\n      and \"exception_\\<I> \\<I> \\<turnstile>g D \\<surd>\"\n    shows \"connect D (obsf_resource ideal_resource) = connect D (obsf_resource real_resource)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connect_obsf D (obsf_resource ideal_resource) =\n    connect_obsf D (obsf_resource real_resource)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. connect_obsf D (obsf_resource ideal_resource) =\n    connect_obsf D (obsf_resource real_resource)", "note I_defs = \\<I>_adv_core_def \\<I>_usr_core_def"], ["proof (state)\nthis:\n  \\<I>_adv_core \\<equiv>\n  \\<I>_full \\<oplus>\\<^sub>\\<I>\n  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV))\n  \\<I>_usr_core \\<equiv>\n  \\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV \\<oplus>\\<^sub>\\<I>\n  \\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>)\n\ngoal (1 subgoal):\n 1. connect_obsf D (obsf_resource ideal_resource) =\n    connect_obsf D (obsf_resource real_resource)", "have fact1: \"\\<I> \\<turnstile>res RES (fused_resource.fuse ideal_core' ideal_rest') s \\<surd>\" \n    if \"pred_prod I_key_rest I_auth_rest (snd (snd s))\" \"invar_ideal' (fst s)\"\n    for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I> \n    \\<turnstile>res RES (fused_resource.fuse ideal_core' ideal_rest')\n                     s \\<surd>", "unfolding assms(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<I>_adv_core \\<oplus>\\<^sub>\\<I>\n     (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I>\n      \\<I>_adv_resta)) \\<oplus>\\<^sub>\\<I>\n    (\\<I>_usr_core \\<oplus>\\<^sub>\\<I>\n     (\\<I>_usr_restk \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta)) \n    \\<turnstile>res RES (fused_resource.fuse ideal_core' ideal_rest')\n                     s \\<surd>", "apply(rule callee_invariant_on.WT_resource_of_oracle[where I=\"pred_prod invar_ideal' (\\<lambda>(_, s_rest). pred_prod I_key_rest I_auth_rest s_rest)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. callee_invariant_on (fused_resource.fuse ideal_core' ideal_rest')\n     (pred_prod invar_ideal'\n       (\\<lambda>(uu_, s_rest). pred_prod I_key_rest I_auth_rest s_rest))\n     ((\\<I>_adv_core \\<oplus>\\<^sub>\\<I>\n       (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I>\n        \\<I>_adv_resta)) \\<oplus>\\<^sub>\\<I>\n      (\\<I>_usr_core \\<oplus>\\<^sub>\\<I>\n       (\\<I>_usr_restk \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta)))\n 2. pred_prod invar_ideal'\n     (\\<lambda>(uu_, s_rest). pred_prod I_key_rest I_auth_rest s_rest) s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on (fused_resource.fuse ideal_core' ideal_rest')\n     (pred_prod invar_ideal'\n       (\\<lambda>(uu_, s_rest). pred_prod I_key_rest I_auth_rest s_rest))\n     ((\\<I>_adv_core \\<oplus>\\<^sub>\\<I>\n       (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I>\n        \\<I>_adv_resta)) \\<oplus>\\<^sub>\\<I>\n      (\\<I>_usr_core \\<oplus>\\<^sub>\\<I>\n       (\\<I>_usr_restk \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta)))", "by(rule fused_resource.callee_invariant_on_fuse)(rule WT_intro)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_prod invar_ideal'\n     (\\<lambda>(uu_, s_rest). pred_prod I_key_rest I_auth_rest s_rest) s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_prod invar_ideal'\n     (\\<lambda>(uu_, s_rest). pred_prod I_key_rest I_auth_rest s_rest) s", "using that"], ["proof (prove)\nusing this:\n  pred_prod I_key_rest I_auth_rest (snd (snd s))\n  invar_ideal' (fst s)\n\ngoal (1 subgoal):\n 1. pred_prod invar_ideal'\n     (\\<lambda>(uu_, s_rest). pred_prod I_key_rest I_auth_rest s_rest) s", "by(cases s)(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>pred_prod I_key_rest I_auth_rest (snd (snd ?s7));\n   invar_ideal' (fst ?s7)\\<rbrakk>\n  \\<Longrightarrow> \\<I> \n                    \\<turnstile>res RES (fused_resource.fuse ideal_core'\n    ideal_rest')\n                                     ?s7 \\<surd>\n\ngoal (1 subgoal):\n 1. connect_obsf D (obsf_resource ideal_resource) =\n    connect_obsf D (obsf_resource real_resource)", "have fact2: \"\\<I> \\<turnstile>res RES (fused_resource.fuse real_core' real_rest') s \\<surd>\" \n    if \"pred_prod I_key_rest I_auth_rest (snd (snd s))\" \"invar_real' (fst s)\"\n    for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I> \n    \\<turnstile>res RES (fused_resource.fuse real_core' real_rest')\n                     s \\<surd>", "unfolding real_rest'_def assms(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<I>_adv_core \\<oplus>\\<^sub>\\<I>\n     (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I>\n      \\<I>_adv_resta)) \\<oplus>\\<^sub>\\<I>\n    (\\<I>_usr_core \\<oplus>\\<^sub>\\<I>\n     (\\<I>_usr_restk \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta)) \n    \\<turnstile>res RES (fused_resource.fuse real_core' ideal_rest')\n                     s \\<surd>", "apply(rule callee_invariant_on.WT_resource_of_oracle[where I=\"pred_prod invar_real' (\\<lambda>(_, s_rest). pred_prod I_key_rest I_auth_rest s_rest)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. callee_invariant_on (fused_resource.fuse real_core' ideal_rest')\n     (pred_prod invar_real'\n       (\\<lambda>(uu_, s_rest). pred_prod I_key_rest I_auth_rest s_rest))\n     ((\\<I>_adv_core \\<oplus>\\<^sub>\\<I>\n       (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I>\n        \\<I>_adv_resta)) \\<oplus>\\<^sub>\\<I>\n      (\\<I>_usr_core \\<oplus>\\<^sub>\\<I>\n       (\\<I>_usr_restk \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta)))\n 2. pred_prod invar_real'\n     (\\<lambda>(uu_, s_rest). pred_prod I_key_rest I_auth_rest s_rest) s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on (fused_resource.fuse real_core' ideal_rest')\n     (pred_prod invar_real'\n       (\\<lambda>(uu_, s_rest). pred_prod I_key_rest I_auth_rest s_rest))\n     ((\\<I>_adv_core \\<oplus>\\<^sub>\\<I>\n       (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I>\n        \\<I>_adv_resta)) \\<oplus>\\<^sub>\\<I>\n      (\\<I>_usr_core \\<oplus>\\<^sub>\\<I>\n       (\\<I>_usr_restk \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta)))", "by(rule fused_resource.callee_invariant_on_fuse)(rule WT_intro)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_prod invar_real'\n     (\\<lambda>(uu_, s_rest). pred_prod I_key_rest I_auth_rest s_rest) s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_prod invar_real'\n     (\\<lambda>(uu_, s_rest). pred_prod I_key_rest I_auth_rest s_rest) s", "using that"], ["proof (prove)\nusing this:\n  pred_prod I_key_rest I_auth_rest (snd (snd s))\n  invar_real' (fst s)\n\ngoal (1 subgoal):\n 1. pred_prod invar_real'\n     (\\<lambda>(uu_, s_rest). pred_prod I_key_rest I_auth_rest s_rest) s", "by(cases s)(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>pred_prod I_key_rest I_auth_rest (snd (snd ?s7));\n   invar_real' (fst ?s7)\\<rbrakk>\n  \\<Longrightarrow> \\<I> \n                    \\<turnstile>res RES (fused_resource.fuse real_core'\n    real_rest')\n                                     ?s7 \\<surd>\n\ngoal (1 subgoal):\n 1. connect_obsf D (obsf_resource ideal_resource) =\n    connect_obsf D (obsf_resource real_resource)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. connect_obsf D (obsf_resource ideal_resource) =\n    connect_obsf D (obsf_resource real_resource)", "unfolding attach_ideal attach_real"], ["proof (prove)\ngoal (1 subgoal):\n 1. connect_obsf D\n     (obsf_resource\n       (RES (fused_resource.fuse ideal_core' ideal_rest')\n         (ideal_s_core', ideal_s_rest'))) =\n    connect_obsf D\n     (obsf_resource\n       (RES (fused_resource.fuse real_core' real_rest')\n         (real_s_core', real_s_rest')))", "apply (rule connect_cong_trace[where \\<I>=\"exception_\\<I> \\<I>\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. ?A \\<turnstile>\\<^sub>R\n    obsf_resource\n     (RES (fused_resource.fuse ideal_core' ideal_rest')\n       (ideal_s_core', ideal_s_rest'))\n    \\<approx> obsf_resource\n               (RES (fused_resource.fuse real_core' real_rest')\n                 (real_s_core', real_s_rest'))\n 2. exception_\\<I> \\<I> \\<turnstile>g D \\<surd>\n 3. outs_gpv (exception_\\<I> \\<I>) D \\<subseteq> ?A\n 4. exception_\\<I> \\<I> \n    \\<turnstile>res obsf_resource\n                     (RES (fused_resource.fuse ideal_core' ideal_rest')\n                       (ideal_s_core', ideal_s_rest')) \\<surd>\n 5. exception_\\<I> \\<I> \n    \\<turnstile>res obsf_resource\n                     (RES (fused_resource.fuse real_core' real_rest')\n                       (real_s_core', real_s_rest')) \\<surd>", "apply (rule trace_eq_obsf_resourceI, subst trace_eq'_resource_of_oracle)"], ["proof (prove)\ngoal (5 subgoals):\n 1. ?A \\<turnstile>\\<^sub>C\n    fused_resource.fuse ideal_core'\n     ideal_rest'((ideal_s_core', ideal_s_rest')) \\<approx>\n    fused_resource.fuse real_core' real_rest'((real_s_core', real_s_rest'))\n 2. exception_\\<I> \\<I> \\<turnstile>g D \\<surd>\n 3. outs_gpv (exception_\\<I> \\<I>) D \\<subseteq> ?A\n 4. exception_\\<I> \\<I> \n    \\<turnstile>res obsf_resource\n                     (RES (fused_resource.fuse ideal_core' ideal_rest')\n                       (ideal_s_core', ideal_s_rest')) \\<surd>\n 5. exception_\\<I> \\<I> \n    \\<turnstile>res obsf_resource\n                     (RES (fused_resource.fuse real_core' real_rest')\n                       (real_s_core', real_s_rest')) \\<surd>", "apply (rule trace_eq_sec[OF assms(2) assms(3)])"], ["proof (prove)\ngoal (4 subgoals):\n 1. exception_\\<I> \\<I> \\<turnstile>g D \\<surd>\n 2. outs_gpv (exception_\\<I> \\<I>) D\n    \\<subseteq> ((UNIV <+>\n                  UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>) <+>\n                 outs_\\<I>\n                  (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta)) <+>\n                (sec.Inp_Send ` carrier \\<L> <+> UNIV) <+>\n                outs_\\<I>\n                 (\\<I>_usr_restk \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta)\n 3. exception_\\<I> \\<I> \n    \\<turnstile>res obsf_resource\n                     (RES (fused_resource.fuse ideal_core' ideal_rest')\n                       (ideal_s_core', ideal_s_rest')) \\<surd>\n 4. exception_\\<I> \\<I> \n    \\<turnstile>res obsf_resource\n                     (RES (fused_resource.fuse real_core' real_rest')\n                       (real_s_core', real_s_rest')) \\<surd>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. exception_\\<I> \\<I> \\<turnstile>g D \\<surd>", "by (rule assms(4))"], ["proof (prove)\ngoal (3 subgoals):\n 1. outs_gpv (exception_\\<I> \\<I>) D\n    \\<subseteq> ((UNIV <+>\n                  UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>) <+>\n                 outs_\\<I>\n                  (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta)) <+>\n                (sec.Inp_Send ` carrier \\<L> <+> UNIV) <+>\n                outs_\\<I>\n                 (\\<I>_usr_restk \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta)\n 2. exception_\\<I> \\<I> \n    \\<turnstile>res obsf_resource\n                     (RES (fused_resource.fuse ideal_core' ideal_rest')\n                       (ideal_s_core', ideal_s_rest')) \\<surd>\n 3. exception_\\<I> \\<I> \n    \\<turnstile>res obsf_resource\n                     (RES (fused_resource.fuse real_core' real_rest')\n                       (real_s_core', real_s_rest')) \\<surd>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. outs_gpv (exception_\\<I> \\<I>) D\n    \\<subseteq> ((UNIV <+>\n                  UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>) <+>\n                 outs_\\<I>\n                  (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta)) <+>\n                (sec.Inp_Send ` carrier \\<L> <+> UNIV) <+>\n                outs_\\<I>\n                 (\\<I>_usr_restk \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta)", "using WT_gpv_outs_gpv[OF assms(4)]"], ["proof (prove)\nusing this:\n  outs_gpv (exception_\\<I> \\<I>) D\n  \\<subseteq> outs_\\<I> (exception_\\<I> \\<I>)\n\ngoal (1 subgoal):\n 1. outs_gpv (exception_\\<I> \\<I>) D\n    \\<subseteq> ((UNIV <+>\n                  UNIV <+> UNIV <+> sec.Inp_Fedit ` carrier \\<L>) <+>\n                 outs_\\<I>\n                  (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta)) <+>\n                (sec.Inp_Send ` carrier \\<L> <+> UNIV) <+>\n                outs_\\<I>\n                 (\\<I>_usr_restk \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta)", "by(simp add: I_defs assms(1) nempty_carrier)"], ["proof (prove)\ngoal (2 subgoals):\n 1. exception_\\<I> \\<I> \n    \\<turnstile>res obsf_resource\n                     (RES (fused_resource.fuse ideal_core' ideal_rest')\n                       (ideal_s_core', ideal_s_rest')) \\<surd>\n 2. exception_\\<I> \\<I> \n    \\<turnstile>res obsf_resource\n                     (RES (fused_resource.fuse real_core' real_rest')\n                       (real_s_core', real_s_rest')) \\<surd>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. exception_\\<I> \\<I> \n    \\<turnstile>res obsf_resource\n                     (RES (fused_resource.fuse ideal_core' ideal_rest')\n                       (ideal_s_core', ideal_s_rest')) \\<surd>", "using assms(2,3)[THEN WT_restD_rinit]"], ["proof (prove)\nusing this:\n  I_key_rest (rinit key_rest)\n  I_auth_rest (rinit auth_rest)\n\ngoal (1 subgoal):\n 1. exception_\\<I> \\<I> \n    \\<turnstile>res obsf_resource\n                     (RES (fused_resource.fuse ideal_core' ideal_rest')\n                       (ideal_s_core', ideal_s_rest')) \\<surd>", "by (intro WT_obsf_resource)(rule fact1; simp add: ideal_s_rest'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. exception_\\<I> \\<I> \n    \\<turnstile>res obsf_resource\n                     (RES (fused_resource.fuse real_core' real_rest')\n                       (real_s_core', real_s_rest')) \\<surd>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. exception_\\<I> \\<I> \n    \\<turnstile>res obsf_resource\n                     (RES (fused_resource.fuse real_core' real_rest')\n                       (real_s_core', real_s_rest')) \\<surd>", "using assms(2,3)[THEN WT_restD_rinit]"], ["proof (prove)\nusing this:\n  I_key_rest (rinit key_rest)\n  I_auth_rest (rinit auth_rest)\n\ngoal (1 subgoal):\n 1. exception_\\<I> \\<I> \n    \\<turnstile>res obsf_resource\n                     (RES (fused_resource.fuse real_core' real_rest')\n                       (real_s_core', real_s_rest')) \\<surd>", "by (intro WT_obsf_resource)(rule fact2; simp add: real_s_rest'_def ideal_s_rest'_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  connect_obsf D (obsf_resource ideal_resource) =\n  connect_obsf D (obsf_resource real_resource)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "end"], ["", "subsection \\<open>Concrete security\\<close>"], ["", "context one_time_pad begin"], ["", "lemma WT_enc_callee [WT_intro]:\n  \"\\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV, \\<I>_uniform UNIV (key.Out_Alice ` carrier \\<L>) \\<oplus>\\<^sub>\\<I>  \\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV \\<turnstile>\\<^sub>C CNV enc_callee () \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV,\n    \\<I>_uniform UNIV (key.Out_Alice ` carrier \\<L>) \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV \\<turnstile>\\<^sub>C\n    CNV enc_callee () \\<surd>", "by (rule WT_converter_of_callee) (auto 4 3 simp add: enc_callee_def stateless_callee_def image_def split!: key.ousr_alice.split)"], ["", "lemma WT_dec_callee [WT_intro]:\n  \"\\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>), \\<I>_uniform UNIV (key.Out_Bob ` carrier \\<L>) \\<oplus>\\<^sub>\\<I> \\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>) \\<turnstile>\\<^sub>C CNV dec_callee () \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>),\n    \\<I>_uniform UNIV (key.Out_Bob ` carrier \\<L>) \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>) \\<turnstile>\\<^sub>C\n    CNV dec_callee () \\<surd>", "by(rule WT_converter_of_callee)(auto simp add: dec_callee_def stateless_callee_def split!: sec.ousr_bob.splits)"], ["", "lemma pfinite_enc_callee [pfinite_intro]: \n   \"pfinite_converter (\\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV) (\\<I>_uniform UNIV (key.Out_Alice ` carrier \\<L>) \\<oplus>\\<^sub>\\<I> \\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV) (CNV enc_callee ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter (\\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV)\n     (\\<I>_uniform UNIV (key.Out_Alice ` carrier \\<L>) \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV)\n     (CNV enc_callee ())", "apply(rule raw_converter_invariant.pfinite_converter_of_callee[where I=\"\\<lambda>_. True\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. raw_converter_invariant\n     (\\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV)\n     (\\<I>_uniform UNIV (key.Out_Alice ` carrier \\<L>) \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV)\n     enc_callee (\\<lambda>_. True)\n 2. \\<And>x s.\n       \\<lbrakk>x \\<in> outs_\\<I>\n                         (\\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV);\n        True\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv\n                          (\\<I>_uniform UNIV\n                            (key.Out_Alice `\n                             carrier \\<L>) \\<oplus>\\<^sub>\\<I>\n                           \\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV)\n                          (enc_callee s x)\n 3. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. raw_converter_invariant\n     (\\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV)\n     (\\<I>_uniform UNIV (key.Out_Alice ` carrier \\<L>) \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV)\n     enc_callee (\\<lambda>_. True)", "by unfold_locales(auto simp add: enc_callee_def stateless_callee_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x s.\n       \\<lbrakk>x \\<in> outs_\\<I>\n                         (\\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV);\n        True\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv\n                          (\\<I>_uniform UNIV\n                            (key.Out_Alice `\n                             carrier \\<L>) \\<oplus>\\<^sub>\\<I>\n                           \\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV)\n                          (enc_callee s x)\n 2. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<in> outs_\\<I>\n                       (\\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV);\n     True\\<rbrakk>\n    \\<Longrightarrow> pfinite_gpv\n                       (\\<I>_uniform UNIV\n                         (key.Out_Alice ` carrier \\<L>) \\<oplus>\\<^sub>\\<I>\n                        \\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV)\n                       (enc_callee s_ x_)", "by(auto simp add: enc_callee_def stateless_callee_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. True", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pfinite_dec_callee [pfinite_intro]:\n  \"pfinite_converter (\\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>)) (\\<I>_uniform UNIV (key.Out_Bob ` carrier \\<L>) \\<oplus>\\<^sub>\\<I> \\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>)) (CNV dec_callee ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter (\\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>))\n     (\\<I>_uniform UNIV (key.Out_Bob ` carrier \\<L>) \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>))\n     (CNV dec_callee ())", "apply(rule raw_converter_invariant.pfinite_converter_of_callee[where I=\"\\<lambda>_. True\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. raw_converter_invariant\n     (\\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>))\n     (\\<I>_uniform UNIV (key.Out_Bob ` carrier \\<L>) \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>))\n     dec_callee (\\<lambda>_. True)\n 2. \\<And>x s.\n       \\<lbrakk>x \\<in> outs_\\<I>\n                         (\\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>));\n        True\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv\n                          (\\<I>_uniform UNIV\n                            (key.Out_Bob ` carrier \\<L>) \\<oplus>\\<^sub>\\<I>\n                           \\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>))\n                          (dec_callee s x)\n 3. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. raw_converter_invariant\n     (\\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>))\n     (\\<I>_uniform UNIV (key.Out_Bob ` carrier \\<L>) \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>))\n     dec_callee (\\<lambda>_. True)", "by unfold_locales(auto simp add: dec_callee_def stateless_callee_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x s.\n       \\<lbrakk>x \\<in> outs_\\<I>\n                         (\\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>));\n        True\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv\n                          (\\<I>_uniform UNIV\n                            (key.Out_Bob ` carrier \\<L>) \\<oplus>\\<^sub>\\<I>\n                           \\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>))\n                          (dec_callee s x)\n 2. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<in> outs_\\<I>\n                       (\\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>));\n     True\\<rbrakk>\n    \\<Longrightarrow> pfinite_gpv\n                       (\\<I>_uniform UNIV\n                         (key.Out_Bob ` carrier \\<L>) \\<oplus>\\<^sub>\\<I>\n                        \\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>))\n                       (dec_callee s_ x_)", "by(auto simp add: dec_callee_def stateless_callee_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. True", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context \n  fixes \n    key_rest :: \"('key_s_rest, key.event, 'key_iadv_rest, 'key_iusr_rest, 'key_oadv_rest, 'key_ousr_rest) rest_wstate\" and\n    auth_rest :: \"('auth_s_rest, auth.event, 'auth_iadv_rest, 'auth_iusr_rest, 'auth_oadv_rest, 'auth_ousr_rest) rest_wstate\" and\n    \\<I>_adv_restk and \\<I>_adv_resta and \\<I>_usr_restk and \\<I>_usr_resta and I_key_rest and I_auth_rest\n  assumes \n    WT_key_rest [WT_intro]: \"WT_rest \\<I>_adv_restk \\<I>_usr_restk I_key_rest key_rest\" and \n    WT_auth_rest [WT_intro]: \"WT_rest \\<I>_adv_resta \\<I>_usr_resta I_auth_rest auth_rest\"\nbegin"], ["", "theorem secure:\n  defines \"\\<I>_real \\<equiv> ((\\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_uniform (sec.Inp_Fedit ` (carrier \\<L>)) UNIV))) \\<oplus>\\<^sub>\\<I> (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta))\" \n      and \"\\<I>_common_core \\<equiv> \\<I>_uniform (sec.Inp_Send ` (carrier \\<L>)) UNIV \\<oplus>\\<^sub>\\<I> \\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>)\"\n      and \"\\<I>_common_rest \\<equiv> \\<I>_usr_restk \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta\"\n      and \"\\<I>_ideal \\<equiv> (\\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_uniform (sec.Inp_Fedit ` (carrier \\<L>)) UNIV)) \\<oplus>\\<^sub>\\<I> (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta)\" \n    shows \"constructive_security_obsf (real_resource TYPE(_) TYPE(_) key_rest auth_rest) (sec.resource (ideal_rest key_rest auth_rest)) (sim |\\<^sub>= 1\\<^sub>C) \\<I>_real \\<I>_ideal (\\<I>_common_core \\<oplus>\\<^sub>\\<I> \\<I>_common_rest) \\<A> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constructive_security_obsf\n     (one_time_pad.real_resource \\<L> key_rest auth_rest)\n     (sec.resource (ideal_rest key_rest auth_rest))\n     (sim |\\<^sub>= 1\\<^sub>C) \\<I>_real \\<I>_ideal\n     (\\<I>_common_core \\<oplus>\\<^sub>\\<I> \\<I>_common_rest) \\<A> 0", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<I>_real \\<oplus>\\<^sub>\\<I>\n    (\\<I>_common_core \\<oplus>\\<^sub>\\<I> \\<I>_common_rest) \n    \\<turnstile>res one_time_pad.real_resource \\<L> key_rest\n                     auth_rest \\<surd>\n 2. \\<I>_ideal \\<oplus>\\<^sub>\\<I>\n    (\\<I>_common_core \\<oplus>\\<^sub>\\<I> \\<I>_common_rest) \n    \\<turnstile>res sec.resource (ideal_rest key_rest auth_rest) \\<surd>\n 3. \\<I>_real, \\<I>_ideal \\<turnstile>\\<^sub>C\n    sim |\\<^sub>= 1\\<^sub>C \\<surd>\n 4. pfinite_converter \\<I>_real \\<I>_ideal (sim |\\<^sub>= 1\\<^sub>C)\n 5. 0 \\<le> 0\n 6. exception_\\<I>\n     (\\<I>_real \\<oplus>\\<^sub>\\<I>\n      (\\<I>_common_core \\<oplus>\\<^sub>\\<I> \\<I>_common_rest))\n    \\<turnstile>g \\<A> \\<surd> \\<Longrightarrow>\n    advantage \\<A>\n     (obsf_resource\n       ((sim |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n        1\\<^sub>C |\\<^sub>= 1\\<^sub>C \\<rhd>\n        sec.resource (ideal_rest key_rest auth_rest)))\n     (obsf_resource (one_time_pad.real_resource \\<L> key_rest auth_rest))\n    \\<le> 0", "let ?\\<I>_common = \"\\<I>_common_core \\<oplus>\\<^sub>\\<I> \\<I>_common_rest\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<I>_real \\<oplus>\\<^sub>\\<I>\n    (\\<I>_common_core \\<oplus>\\<^sub>\\<I> \\<I>_common_rest) \n    \\<turnstile>res one_time_pad.real_resource \\<L> key_rest\n                     auth_rest \\<surd>\n 2. \\<I>_ideal \\<oplus>\\<^sub>\\<I>\n    (\\<I>_common_core \\<oplus>\\<^sub>\\<I> \\<I>_common_rest) \n    \\<turnstile>res sec.resource (ideal_rest key_rest auth_rest) \\<surd>\n 3. \\<I>_real, \\<I>_ideal \\<turnstile>\\<^sub>C\n    sim |\\<^sub>= 1\\<^sub>C \\<surd>\n 4. pfinite_converter \\<I>_real \\<I>_ideal (sim |\\<^sub>= 1\\<^sub>C)\n 5. 0 \\<le> 0\n 6. exception_\\<I>\n     (\\<I>_real \\<oplus>\\<^sub>\\<I>\n      (\\<I>_common_core \\<oplus>\\<^sub>\\<I> \\<I>_common_rest))\n    \\<turnstile>g \\<A> \\<surd> \\<Longrightarrow>\n    advantage \\<A>\n     (obsf_resource\n       ((sim |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n        1\\<^sub>C |\\<^sub>= 1\\<^sub>C \\<rhd>\n        sec.resource (ideal_rest key_rest auth_rest)))\n     (obsf_resource (one_time_pad.real_resource \\<L> key_rest auth_rest))\n    \\<le> 0", "show \"\\<I>_real \\<oplus>\\<^sub>\\<I> ?\\<I>_common \\<turnstile>res real_resource TYPE(_) TYPE(_) key_rest auth_rest \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_real \\<oplus>\\<^sub>\\<I>\n    (\\<I>_common_core \\<oplus>\\<^sub>\\<I> \\<I>_common_rest) \n    \\<turnstile>res one_time_pad.real_resource \\<L> key_rest\n                     auth_rest \\<surd>", "unfolding \\<I>_real_def \\<I>_common_core_def \\<I>_common_rest_def real_resource_def attach_c1f22_c1f22_def wiring_c1r22_c1r22_def fused_wiring_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n      (\\<I>_full \\<oplus>\\<^sub>\\<I>\n       (\\<I>_full \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>)\n         UNIV))) \\<oplus>\\<^sub>\\<I>\n     (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I>\n      \\<I>_adv_resta)) \\<oplus>\\<^sub>\\<I>\n    ((\\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>)) \\<oplus>\\<^sub>\\<I>\n     (\\<I>_usr_restk \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta)) \n    \\<turnstile>res ((1\\<^sub>C |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n                     (CNV enc_callee () |\\<^sub>= CNV dec_callee ()) \\<odot>\n                     parallel_wiring |\\<^sub>=\n                     1\\<^sub>C) \\<odot>\n                    (parallel_wiring |\\<^sub>= parallel_wiring) \\<odot>\n                    parallel_wiring \\<rhd>\n                    key.resource key_rest \\<parallel>\n                    auth.resource auth_rest \\<surd>", "by(rule WT_intro | simp )+"], ["proof (state)\nthis:\n  \\<I>_real \\<oplus>\\<^sub>\\<I>\n  (\\<I>_common_core \\<oplus>\\<^sub>\\<I> \\<I>_common_rest) \n  \\<turnstile>res one_time_pad.real_resource \\<L> key_rest auth_rest \\<surd>\n\ngoal (5 subgoals):\n 1. \\<I>_ideal \\<oplus>\\<^sub>\\<I>\n    (\\<I>_common_core \\<oplus>\\<^sub>\\<I> \\<I>_common_rest) \n    \\<turnstile>res sec.resource (ideal_rest key_rest auth_rest) \\<surd>\n 2. \\<I>_real, \\<I>_ideal \\<turnstile>\\<^sub>C\n    sim |\\<^sub>= 1\\<^sub>C \\<surd>\n 3. pfinite_converter \\<I>_real \\<I>_ideal (sim |\\<^sub>= 1\\<^sub>C)\n 4. 0 \\<le> 0\n 5. exception_\\<I>\n     (\\<I>_real \\<oplus>\\<^sub>\\<I>\n      (\\<I>_common_core \\<oplus>\\<^sub>\\<I> \\<I>_common_rest))\n    \\<turnstile>g \\<A> \\<surd> \\<Longrightarrow>\n    advantage \\<A>\n     (obsf_resource\n       ((sim |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n        1\\<^sub>C |\\<^sub>= 1\\<^sub>C \\<rhd>\n        sec.resource (ideal_rest key_rest auth_rest)))\n     (obsf_resource (one_time_pad.real_resource \\<L> key_rest auth_rest))\n    \\<le> 0", "show [WT_intro]: \"\\<I>_ideal \\<oplus>\\<^sub>\\<I> ?\\<I>_common \\<turnstile>res sec.resource (ideal_rest key_rest auth_rest) \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_ideal \\<oplus>\\<^sub>\\<I>\n    (\\<I>_common_core \\<oplus>\\<^sub>\\<I> \\<I>_common_rest) \n    \\<turnstile>res sec.resource (ideal_rest key_rest auth_rest) \\<surd>", "unfolding \\<I>_common_core_def \\<I>_common_rest_def \\<I>_ideal_def ideal_rest_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n      (\\<I>_full \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>)\n        UNIV)) \\<oplus>\\<^sub>\\<I>\n     (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I>\n      \\<I>_adv_resta)) \\<oplus>\\<^sub>\\<I>\n    ((\\<I>_uniform (sec.Inp_Send ` carrier \\<L>) UNIV \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform UNIV (sec.Out_Recv ` carrier \\<L>)) \\<oplus>\\<^sub>\\<I>\n     (\\<I>_usr_restk \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta)) \n    \\<turnstile>res sec.resource\n                     (translate_rest (False, {}) etran\n                       (parallel_rest key_rest auth_rest)) \\<surd>", "by(rule WT_intro)+ simp"], ["proof (state)\nthis:\n  \\<I>_ideal \\<oplus>\\<^sub>\\<I>\n  (\\<I>_common_core \\<oplus>\\<^sub>\\<I> \\<I>_common_rest) \n  \\<turnstile>res sec.resource (ideal_rest key_rest auth_rest) \\<surd>\n\ngoal (4 subgoals):\n 1. \\<I>_real, \\<I>_ideal \\<turnstile>\\<^sub>C\n    sim |\\<^sub>= 1\\<^sub>C \\<surd>\n 2. pfinite_converter \\<I>_real \\<I>_ideal (sim |\\<^sub>= 1\\<^sub>C)\n 3. 0 \\<le> 0\n 4. exception_\\<I>\n     (\\<I>_real \\<oplus>\\<^sub>\\<I>\n      (\\<I>_common_core \\<oplus>\\<^sub>\\<I> \\<I>_common_rest))\n    \\<turnstile>g \\<A> \\<surd> \\<Longrightarrow>\n    advantage \\<A>\n     (obsf_resource\n       ((sim |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n        1\\<^sub>C |\\<^sub>= 1\\<^sub>C \\<rhd>\n        sec.resource (ideal_rest key_rest auth_rest)))\n     (obsf_resource (one_time_pad.real_resource \\<L> key_rest auth_rest))\n    \\<le> 0", "show [WT_intro]: \"\\<I>_real, \\<I>_ideal \\<turnstile>\\<^sub>C sim |\\<^sub>= 1\\<^sub>C \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_real, \\<I>_ideal \\<turnstile>\\<^sub>C\n    sim |\\<^sub>= 1\\<^sub>C \\<surd>", "unfolding \\<I>_real_def \\<I>_ideal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<I>_full \\<oplus>\\<^sub>\\<I>\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      (\\<I>_full \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>)\n        UNIV))) \\<oplus>\\<^sub>\\<I>\n    (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta),\n    (\\<I>_full \\<oplus>\\<^sub>\\<I>\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV)) \\<oplus>\\<^sub>\\<I>\n    (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta) \\<turnstile>\\<^sub>C\n    sim |\\<^sub>= 1\\<^sub>C \\<surd>", "apply(rule WT_intro)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<I>_full \\<oplus>\\<^sub>\\<I>\n    (\\<I>_full \\<oplus>\\<^sub>\\<I>\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV)),\n    \\<I>_full \\<oplus>\\<^sub>\\<I>\n    (\\<I>_full \\<oplus>\\<^sub>\\<I>\n     \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV) \\<turnstile>\\<^sub>C\n    sim \\<surd>\n 2. \\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta,\n    \\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta \\<turnstile>\\<^sub>C\n    1\\<^sub>C \\<surd>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_full \\<oplus>\\<^sub>\\<I>\n    (\\<I>_full \\<oplus>\\<^sub>\\<I>\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV)),\n    \\<I>_full \\<oplus>\\<^sub>\\<I>\n    (\\<I>_full \\<oplus>\\<^sub>\\<I>\n     \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV) \\<turnstile>\\<^sub>C\n    sim \\<surd>", "unfolding sim_def Let_def look_callee_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_full \\<oplus>\\<^sub>\\<I>\n    (\\<I>_full \\<oplus>\\<^sub>\\<I>\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV)),\n    \\<I>_full \\<oplus>\\<^sub>\\<I>\n    (\\<I>_full \\<oplus>\\<^sub>\\<I>\n     \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV) \\<turnstile>\\<^sub>C\n    ldummy_converter (\\<lambda>_. key.Out_Adversary)\n     (1\\<^sub>C |\\<^sub>=\n      CNV (\\<lambda>state inp.\n              Generative_Probabilistic_Value.Pause sec.Inp_Look\n               (sec.case_oadv_look\n                 (\\<lambda>msg_set.\n                     case state of\n                     None \\<Rightarrow>\n                       bind_gpv (lift_spmf (spmf_of_set msg_set))\n                        (\\<lambda>msg.\n                            Generative_Probabilistic_Value.Done\n                             (sec.Out_Look msg, Some msg))\n                     | Some msg \\<Rightarrow>\n                         Generative_Probabilistic_Value.Done\n                          (sec.Out_Look msg, Some msg))))\n       None |\\<^sub>=\n      1\\<^sub>C) \\<surd>", "apply (fold conv_callee_parallel_id_right[where s'=\"()\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_full \\<oplus>\\<^sub>\\<I>\n    (\\<I>_full \\<oplus>\\<^sub>\\<I>\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV)),\n    \\<I>_full \\<oplus>\\<^sub>\\<I>\n    (\\<I>_full \\<oplus>\\<^sub>\\<I>\n     \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV) \\<turnstile>\\<^sub>C\n    ldummy_converter (\\<lambda>_. key.Out_Adversary)\n     (1\\<^sub>C |\\<^sub>=\n      CNV ((\\<lambda>state inp.\n               Generative_Probabilistic_Value.Pause sec.Inp_Look\n                (sec.case_oadv_look\n                  (\\<lambda>msg_set.\n                      case state of\n                      None \\<Rightarrow>\n                        bind_gpv (lift_spmf (spmf_of_set msg_set))\n                         (\\<lambda>msg.\n                             Generative_Probabilistic_Value.Done\n                              (sec.Out_Look msg, Some msg))\n                      | Some msg \\<Rightarrow>\n                          Generative_Probabilistic_Value.Done\n                           (sec.Out_Look msg,\n                            Some msg)))) \\<ddagger>\\<^sub>I\n           1\\<^sub>I)\n       (None, ())) \\<surd>", "apply (fold conv_callee_parallel_id_left[where s=\"()\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_full \\<oplus>\\<^sub>\\<I>\n    (\\<I>_full \\<oplus>\\<^sub>\\<I>\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV)),\n    \\<I>_full \\<oplus>\\<^sub>\\<I>\n    (\\<I>_full \\<oplus>\\<^sub>\\<I>\n     \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV) \\<turnstile>\\<^sub>C\n    ldummy_converter (\\<lambda>_. key.Out_Adversary)\n     (CNV (1\\<^sub>I \\<ddagger>\\<^sub>I\n           (\\<lambda>state inp.\n               Generative_Probabilistic_Value.Pause sec.Inp_Look\n                (sec.case_oadv_look\n                  (\\<lambda>msg_set.\n                      case state of\n                      None \\<Rightarrow>\n                        bind_gpv (lift_spmf (spmf_of_set msg_set))\n                         (\\<lambda>msg.\n                             Generative_Probabilistic_Value.Done\n                              (sec.Out_Look msg, Some msg))\n                      | Some msg \\<Rightarrow>\n                          Generative_Probabilistic_Value.Done\n                           (sec.Out_Look msg,\n                            Some msg)))) \\<ddagger>\\<^sub>I\n           1\\<^sub>I)\n       ((), None, ())) \\<surd>", "apply (subst ldummy_converter_of_callee)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_full \\<oplus>\\<^sub>\\<I>\n    (\\<I>_full \\<oplus>\\<^sub>\\<I>\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV)),\n    \\<I>_full \\<oplus>\\<^sub>\\<I>\n    (\\<I>_full \\<oplus>\\<^sub>\\<I>\n     \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV) \\<turnstile>\\<^sub>C\n    CNV (\\<lambda>s.\n            case_sum\n             (\\<lambda>ql.\n                 Generative_Probabilistic_Value.Done\n                  (Inl key.Out_Adversary, s))\n             (\\<lambda>qr.\n                 map_gpv (map_prod Inr id) id\n                  ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                    (\\<lambda>state inp.\n                        Generative_Probabilistic_Value.Pause sec.Inp_Look\n                         (sec.case_oadv_look\n                           (\\<lambda>msg_set.\n                               case state of\n                               None \\<Rightarrow>\n                                 bind_gpv (lift_spmf (spmf_of_set msg_set))\n                                  (\\<lambda>msg.\nGenerative_Probabilistic_Value.Done (sec.Out_Look msg, Some msg))\n                               | Some msg \\<Rightarrow>\n                                   Generative_Probabilistic_Value.Done\n                                    (sec.Out_Look msg,\n                                     Some msg)))) \\<ddagger>\\<^sub>I\n                    1\\<^sub>I)\n                    s qr)))\n     ((), None, ()) \\<surd>", "apply (rule WT_converter_of_callee)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s q.\n       q \\<in> outs_\\<I>\n                (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                 (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>)\n                    UNIV))) \\<Longrightarrow>\n       \\<I>_full \\<oplus>\\<^sub>\\<I>\n       (\\<I>_full \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV)\n       \\<turnstile>g case q of\n                     Inl ql \\<Rightarrow>\n                       Generative_Probabilistic_Value.Done\n                        (Inl key.Out_Adversary, s)\n                     | Inr qr \\<Rightarrow>\n                         map_gpv (map_prod Inr id) id\n                          ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                            (\\<lambda>state inp.\n                                Generative_Probabilistic_Value.Pause\n                                 sec.Inp_Look\n                                 (sec.case_oadv_look\n                                   (\\<lambda>msg_set.\n case state of\n None \\<Rightarrow>\n   bind_gpv (lift_spmf (spmf_of_set msg_set))\n    (\\<lambda>msg.\n        Generative_Probabilistic_Value.Done (sec.Out_Look msg, Some msg))\n | Some msg \\<Rightarrow>\n     Generative_Probabilistic_Value.Done\n      (sec.Out_Look msg, Some msg)))) \\<ddagger>\\<^sub>I\n                            1\\<^sub>I)\n                            s qr) \\<surd>\n 2. \\<And>s q r s'.\n       \\<lbrakk>q \\<in> outs_\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                            \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>)\n                             UNIV)));\n        (r, s')\n        \\<in> results_gpv\n               (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                 \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV))\n               (case q of\n                Inl ql \\<Rightarrow>\n                  Generative_Probabilistic_Value.Done\n                   (Inl key.Out_Adversary, s)\n                | Inr qr \\<Rightarrow>\n                    map_gpv (map_prod Inr id) id\n                     ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                       (\\<lambda>state inp.\n                           Generative_Probabilistic_Value.Pause sec.Inp_Look\n                            (sec.case_oadv_look\n                              (\\<lambda>msg_set.\n                                  case state of\n                                  None \\<Rightarrow>\n                                    bind_gpv\n                                     (lift_spmf (spmf_of_set msg_set))\n                                     (\\<lambda>msg.\n   Generative_Probabilistic_Value.Done (sec.Out_Look msg, Some msg))\n                                  | Some msg \\<Rightarrow>\nGenerative_Probabilistic_Value.Done\n (sec.Out_Look msg, Some msg)))) \\<ddagger>\\<^sub>I\n                       1\\<^sub>I)\n                       s qr))\\<rbrakk>\n       \\<Longrightarrow> r \\<in> responses_\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                     \\<I>_uniform\n(sec.Inp_Fedit ` carrier \\<L>) UNIV)))\n                                  q", "by (auto simp add: id_oracle_def map_gpv_conv_bind[symmetric] map_lift_spmf\n          split: auth.oadv_look.split option.split )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta,\n    \\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta \\<turnstile>\\<^sub>C\n    1\\<^sub>C \\<surd>", "by (rule WT_intro)"], ["proof (state)\nthis:\n  \\<I>_real, \\<I>_ideal \\<turnstile>\\<^sub>C sim |\\<^sub>= 1\\<^sub>C \\<surd>\n\ngoal (3 subgoals):\n 1. pfinite_converter \\<I>_real \\<I>_ideal (sim |\\<^sub>= 1\\<^sub>C)\n 2. 0 \\<le> 0\n 3. exception_\\<I>\n     (\\<I>_real \\<oplus>\\<^sub>\\<I>\n      (\\<I>_common_core \\<oplus>\\<^sub>\\<I> \\<I>_common_rest))\n    \\<turnstile>g \\<A> \\<surd> \\<Longrightarrow>\n    advantage \\<A>\n     (obsf_resource\n       ((sim |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n        1\\<^sub>C |\\<^sub>= 1\\<^sub>C \\<rhd>\n        sec.resource (ideal_rest key_rest auth_rest)))\n     (obsf_resource (one_time_pad.real_resource \\<L> key_rest auth_rest))\n    \\<le> 0", "show \"pfinite_converter \\<I>_real \\<I>_ideal (sim |\\<^sub>= 1\\<^sub>C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter \\<I>_real \\<I>_ideal (sim |\\<^sub>= 1\\<^sub>C)", "unfolding \\<I>_real_def \\<I>_ideal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter\n     ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n       (\\<I>_full \\<oplus>\\<^sub>\\<I>\n        (\\<I>_full \\<oplus>\\<^sub>\\<I>\n         \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>)\n          UNIV))) \\<oplus>\\<^sub>\\<I>\n      (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta))\n     ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n       (\\<I>_full \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>)\n         UNIV)) \\<oplus>\\<^sub>\\<I>\n      (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta))\n     (sim |\\<^sub>= 1\\<^sub>C)", "apply(rule pfinite_intro)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. pfinite_converter\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      (\\<I>_full \\<oplus>\\<^sub>\\<I>\n       (\\<I>_full \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV)))\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      (\\<I>_full \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV))\n     sim\n 2. pfinite_converter (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta)\n     (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta) 1\\<^sub>C", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      (\\<I>_full \\<oplus>\\<^sub>\\<I>\n       (\\<I>_full \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV)))\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      (\\<I>_full \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV))\n     sim", "unfolding sim_def Let_def look_callee_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      (\\<I>_full \\<oplus>\\<^sub>\\<I>\n       (\\<I>_full \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV)))\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      (\\<I>_full \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV))\n     (ldummy_converter (\\<lambda>_. key.Out_Adversary)\n       (1\\<^sub>C |\\<^sub>=\n        CNV (\\<lambda>state inp.\n                Generative_Probabilistic_Value.Pause sec.Inp_Look\n                 (sec.case_oadv_look\n                   (\\<lambda>msg_set.\n                       case state of\n                       None \\<Rightarrow>\n                         bind_gpv (lift_spmf (spmf_of_set msg_set))\n                          (\\<lambda>msg.\n                              Generative_Probabilistic_Value.Done\n                               (sec.Out_Look msg, Some msg))\n                       | Some msg \\<Rightarrow>\n                           Generative_Probabilistic_Value.Done\n                            (sec.Out_Look msg, Some msg))))\n         None |\\<^sub>=\n        1\\<^sub>C))", "apply (fold conv_callee_parallel_id_right[where s'=\"()\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      (\\<I>_full \\<oplus>\\<^sub>\\<I>\n       (\\<I>_full \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV)))\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      (\\<I>_full \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV))\n     (ldummy_converter (\\<lambda>_. key.Out_Adversary)\n       (1\\<^sub>C |\\<^sub>=\n        CNV ((\\<lambda>state inp.\n                 Generative_Probabilistic_Value.Pause sec.Inp_Look\n                  (sec.case_oadv_look\n                    (\\<lambda>msg_set.\n                        case state of\n                        None \\<Rightarrow>\n                          bind_gpv (lift_spmf (spmf_of_set msg_set))\n                           (\\<lambda>msg.\n                               Generative_Probabilistic_Value.Done\n                                (sec.Out_Look msg, Some msg))\n                        | Some msg \\<Rightarrow>\n                            Generative_Probabilistic_Value.Done\n                             (sec.Out_Look msg,\n                              Some msg)))) \\<ddagger>\\<^sub>I\n             1\\<^sub>I)\n         (None, ())))", "apply (fold conv_callee_parallel_id_left[where s=\"()\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      (\\<I>_full \\<oplus>\\<^sub>\\<I>\n       (\\<I>_full \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV)))\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      (\\<I>_full \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV))\n     (ldummy_converter (\\<lambda>_. key.Out_Adversary)\n       (CNV (1\\<^sub>I \\<ddagger>\\<^sub>I\n             (\\<lambda>state inp.\n                 Generative_Probabilistic_Value.Pause sec.Inp_Look\n                  (sec.case_oadv_look\n                    (\\<lambda>msg_set.\n                        case state of\n                        None \\<Rightarrow>\n                          bind_gpv (lift_spmf (spmf_of_set msg_set))\n                           (\\<lambda>msg.\n                               Generative_Probabilistic_Value.Done\n                                (sec.Out_Look msg, Some msg))\n                        | Some msg \\<Rightarrow>\n                            Generative_Probabilistic_Value.Done\n                             (sec.Out_Look msg,\n                              Some msg)))) \\<ddagger>\\<^sub>I\n             1\\<^sub>I)\n         ((), None, ())))", "apply (subst ldummy_converter_of_callee)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      (\\<I>_full \\<oplus>\\<^sub>\\<I>\n       (\\<I>_full \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV)))\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      (\\<I>_full \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV))\n     (CNV (\\<lambda>s.\n              case_sum\n               (\\<lambda>ql.\n                   Generative_Probabilistic_Value.Done\n                    (Inl key.Out_Adversary, s))\n               (\\<lambda>qr.\n                   map_gpv (map_prod Inr id) id\n                    ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                      (\\<lambda>state inp.\n                          Generative_Probabilistic_Value.Pause sec.Inp_Look\n                           (sec.case_oadv_look\n                             (\\<lambda>msg_set.\n                                 case state of\n                                 None \\<Rightarrow>\n                                   bind_gpv\n                                    (lift_spmf (spmf_of_set msg_set))\n                                    (\\<lambda>msg.\n  Generative_Probabilistic_Value.Done (sec.Out_Look msg, Some msg))\n                                 | Some msg \\<Rightarrow>\n                                     Generative_Probabilistic_Value.Done\n(sec.Out_Look msg, Some msg)))) \\<ddagger>\\<^sub>I\n                      1\\<^sub>I)\n                      s qr)))\n       ((), None, ()))", "apply(rule raw_converter_invariant.pfinite_converter_of_callee[where I=\"\\<lambda>_. True\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. raw_converter_invariant\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      (\\<I>_full \\<oplus>\\<^sub>\\<I>\n       (\\<I>_full \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV)))\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      (\\<I>_full \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV))\n     (\\<lambda>s.\n         case_sum\n          (\\<lambda>ql.\n              Generative_Probabilistic_Value.Done\n               (Inl key.Out_Adversary, s))\n          (\\<lambda>qr.\n              map_gpv (map_prod Inr id) id\n               ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                 (\\<lambda>state inp.\n                     Generative_Probabilistic_Value.Pause sec.Inp_Look\n                      (sec.case_oadv_look\n                        (\\<lambda>msg_set.\n                            case state of\n                            None \\<Rightarrow>\n                              bind_gpv (lift_spmf (spmf_of_set msg_set))\n                               (\\<lambda>msg.\n                                   Generative_Probabilistic_Value.Done\n                                    (sec.Out_Look msg, Some msg))\n                            | Some msg \\<Rightarrow>\n                                Generative_Probabilistic_Value.Done\n                                 (sec.Out_Look msg,\n                                  Some msg)))) \\<ddagger>\\<^sub>I\n                 1\\<^sub>I)\n                 s qr)))\n     (\\<lambda>_. True)\n 2. \\<And>x s.\n       \\<lbrakk>x \\<in> outs_\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                            \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>)\n                             UNIV)));\n        True\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                            \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>)\n                             UNIV))\n                          (case x of\n                           Inl ql \\<Rightarrow>\n                             Generative_Probabilistic_Value.Done\n                              (Inl key.Out_Adversary, s)\n                           | Inr qr \\<Rightarrow>\n                               map_gpv (map_prod Inr id) id\n                                ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                                  (\\<lambda>state inp.\nGenerative_Probabilistic_Value.Pause sec.Inp_Look\n (sec.case_oadv_look\n   (\\<lambda>msg_set.\n       case state of\n       None \\<Rightarrow>\n         bind_gpv (lift_spmf (spmf_of_set msg_set))\n          (\\<lambda>msg.\n              Generative_Probabilistic_Value.Done\n               (sec.Out_Look msg, Some msg))\n       | Some msg \\<Rightarrow>\n           Generative_Probabilistic_Value.Done\n            (sec.Out_Look msg, Some msg)))) \\<ddagger>\\<^sub>I\n                                  1\\<^sub>I)\n                                  s qr))\n 3. True", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. raw_converter_invariant\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      (\\<I>_full \\<oplus>\\<^sub>\\<I>\n       (\\<I>_full \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV)))\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      (\\<I>_full \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>) UNIV))\n     (\\<lambda>s.\n         case_sum\n          (\\<lambda>ql.\n              Generative_Probabilistic_Value.Done\n               (Inl key.Out_Adversary, s))\n          (\\<lambda>qr.\n              map_gpv (map_prod Inr id) id\n               ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                 (\\<lambda>state inp.\n                     Generative_Probabilistic_Value.Pause sec.Inp_Look\n                      (sec.case_oadv_look\n                        (\\<lambda>msg_set.\n                            case state of\n                            None \\<Rightarrow>\n                              bind_gpv (lift_spmf (spmf_of_set msg_set))\n                               (\\<lambda>msg.\n                                   Generative_Probabilistic_Value.Done\n                                    (sec.Out_Look msg, Some msg))\n                            | Some msg \\<Rightarrow>\n                                Generative_Probabilistic_Value.Done\n                                 (sec.Out_Look msg,\n                                  Some msg)))) \\<ddagger>\\<^sub>I\n                 1\\<^sub>I)\n                 s qr)))\n     (\\<lambda>_. True)", "by unfold_locales (auto split!: sum.split sec.oadv_look.split option.split \n            simp add: left_gpv_map id_oracle_def intro!: WT_intro WT_gpv_right_gpv WT_gpv_left_gpv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x s.\n       \\<lbrakk>x \\<in> outs_\\<I>\n                         (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                            \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>)\n                             UNIV)));\n        True\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv\n                          (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                           (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                            \\<I>_uniform (sec.Inp_Fedit ` carrier \\<L>)\n                             UNIV))\n                          (case x of\n                           Inl ql \\<Rightarrow>\n                             Generative_Probabilistic_Value.Done\n                              (Inl key.Out_Adversary, s)\n                           | Inr qr \\<Rightarrow>\n                               map_gpv (map_prod Inr id) id\n                                ((1\\<^sub>I \\<ddagger>\\<^sub>I\n                                  (\\<lambda>state inp.\nGenerative_Probabilistic_Value.Pause sec.Inp_Look\n (sec.case_oadv_look\n   (\\<lambda>msg_set.\n       case state of\n       None \\<Rightarrow>\n         bind_gpv (lift_spmf (spmf_of_set msg_set))\n          (\\<lambda>msg.\n              Generative_Probabilistic_Value.Done\n               (sec.Out_Look msg, Some msg))\n       | Some msg \\<Rightarrow>\n           Generative_Probabilistic_Value.Done\n            (sec.Out_Look msg, Some msg)))) \\<ddagger>\\<^sub>I\n                                  1\\<^sub>I)\n                                  s qr))\n 2. True", "by (auto split!: sum.splits sec.oadv_look.splits option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta)\n     (\\<I>_adv_restk \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta) 1\\<^sub>C", "by (rule pfinite_intro)"], ["proof (state)\nthis:\n  pfinite_converter \\<I>_real \\<I>_ideal (sim |\\<^sub>= 1\\<^sub>C)\n\ngoal (2 subgoals):\n 1. 0 \\<le> 0\n 2. exception_\\<I>\n     (\\<I>_real \\<oplus>\\<^sub>\\<I>\n      (\\<I>_common_core \\<oplus>\\<^sub>\\<I> \\<I>_common_rest))\n    \\<turnstile>g \\<A> \\<surd> \\<Longrightarrow>\n    advantage \\<A>\n     (obsf_resource\n       ((sim |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n        1\\<^sub>C |\\<^sub>= 1\\<^sub>C \\<rhd>\n        sec.resource (ideal_rest key_rest auth_rest)))\n     (obsf_resource (one_time_pad.real_resource \\<L> key_rest auth_rest))\n    \\<le> 0", "assume WT [WT_intro]: \"exception_\\<I> (\\<I>_real \\<oplus>\\<^sub>\\<I> ?\\<I>_common) \\<turnstile>g \\<A> \\<surd>\""], ["proof (state)\nthis:\n  exception_\\<I>\n   (\\<I>_real \\<oplus>\\<^sub>\\<I>\n    (\\<I>_common_core \\<oplus>\\<^sub>\\<I> \\<I>_common_rest))\n  \\<turnstile>g \\<A> \\<surd>\n\ngoal (2 subgoals):\n 1. 0 \\<le> 0\n 2. exception_\\<I>\n     (\\<I>_real \\<oplus>\\<^sub>\\<I>\n      (\\<I>_common_core \\<oplus>\\<^sub>\\<I> \\<I>_common_rest))\n    \\<turnstile>g \\<A> \\<surd> \\<Longrightarrow>\n    advantage \\<A>\n     (obsf_resource\n       ((sim |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n        1\\<^sub>C |\\<^sub>= 1\\<^sub>C \\<rhd>\n        sec.resource (ideal_rest key_rest auth_rest)))\n     (obsf_resource (one_time_pad.real_resource \\<L> key_rest auth_rest))\n    \\<le> 0", "show \"advantage \\<A> (obsf_resource ((sim |\\<^sub>= 1\\<^sub>C) |\\<^sub>= (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<rhd> sec.resource (ideal_rest key_rest auth_rest)))\n    (obsf_resource (real_resource TYPE(_) TYPE(_) key_rest auth_rest)) \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. advantage \\<A>\n     (obsf_resource\n       ((sim |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n        1\\<^sub>C |\\<^sub>= 1\\<^sub>C \\<rhd>\n        sec.resource (ideal_rest key_rest auth_rest)))\n     (obsf_resource (one_time_pad.real_resource \\<L> key_rest auth_rest))\n    \\<le> 0", "using connect[OF WT_key_rest, OF WT_auth_rest, OF WT[unfolded assms(1, 2, 3)]]"], ["proof (prove)\nusing this:\n  connect_obsf \\<A>\n   (obsf_resource (one_time_pad.ideal_resource \\<L> key_rest auth_rest)) =\n  connect_obsf \\<A>\n   (obsf_resource (one_time_pad.real_resource \\<L> key_rest auth_rest))\n\ngoal (1 subgoal):\n 1. advantage \\<A>\n     (obsf_resource\n       ((sim |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n        1\\<^sub>C |\\<^sub>= 1\\<^sub>C \\<rhd>\n        sec.resource (ideal_rest key_rest auth_rest)))\n     (obsf_resource (one_time_pad.real_resource \\<L> key_rest auth_rest))\n    \\<le> 0", "unfolding advantage_def"], ["proof (prove)\nusing this:\n  connect_obsf \\<A>\n   (obsf_resource (one_time_pad.ideal_resource \\<L> key_rest auth_rest)) =\n  connect_obsf \\<A>\n   (obsf_resource (one_time_pad.real_resource \\<L> key_rest auth_rest))\n\ngoal (1 subgoal):\n 1. \\<bar>spmf\n           (connect_obsf \\<A>\n             (obsf_resource\n               ((sim |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n                1\\<^sub>C |\\<^sub>= 1\\<^sub>C \\<rhd>\n                sec.resource (ideal_rest key_rest auth_rest))))\n           True -\n          spmf\n           (connect_obsf \\<A>\n             (obsf_resource\n               (one_time_pad.real_resource \\<L> key_rest auth_rest)))\n           True\\<bar>\n    \\<le> 0", "by (simp add: ideal_resource_def)"], ["proof (state)\nthis:\n  advantage \\<A>\n   (obsf_resource\n     ((sim |\\<^sub>= 1\\<^sub>C) |\\<^sub>=\n      1\\<^sub>C |\\<^sub>= 1\\<^sub>C \\<rhd>\n      sec.resource (ideal_rest key_rest auth_rest)))\n   (obsf_resource (one_time_pad.real_resource \\<L> key_rest auth_rest))\n  \\<le> 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> 0", "qed simp"], ["", "end"], ["", "end"], ["", "subsection \\<open>Asymptotic security\\<close>"], ["", "locale one_time_pad' =\n  fixes \\<L> :: \"security \\<Rightarrow> ('msg, 'more) boolean_algebra_scheme\"\n  assumes one_time_pad [locale_witness]: \"\\<And>\\<eta>. one_time_pad (\\<L> \\<eta>)\"\nbegin"], ["", "sublocale one_time_pad \"\\<L> \\<eta>\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. one_time_pad (\\<L> \\<eta>)", ".."], ["", "definition real_resource' where \"real_resource' rest1 rest2 \\<eta> = real_resource TYPE(_) TYPE(_) \\<eta> (rest1 \\<eta>) (rest2 \\<eta>)\""], ["", "definition ideal_resource' where \"ideal_resource' rest1 rest2 \\<eta> = sec.resource \\<eta> (ideal_rest (rest1 \\<eta>) (rest2 \\<eta>))\""], ["", "definition sim' where \"sim' \\<eta> = (sim |\\<^sub>= 1\\<^sub>C)\""], ["", "context \n  fixes \n    key_rest :: \"nat \\<Rightarrow> ('key_s_rest, key.event, 'key_iadv_rest, 'key_iusr_rest, 'key_oadv_rest, 'key_ousr_rest) rest_wstate\" and\n    auth_rest :: \"nat \\<Rightarrow> ('auth_s_rest, auth.event, 'auth_iadv_rest, 'auth_iusr_rest, 'auth_oadv_rest, 'auth_ousr_rest) rest_wstate\" and\n    \\<I>_adv_restk and \\<I>_adv_resta and \\<I>_usr_restk and \\<I>_usr_resta and I_key_rest and I_auth_rest\n  assumes \n    WT_key_res: \"\\<And>\\<eta>. WT_rest (\\<I>_adv_restk \\<eta>) (\\<I>_usr_restk \\<eta>) (I_key_rest \\<eta>) (key_rest \\<eta>)\" and \n    WT_auth_rest: \"\\<And>\\<eta>. WT_rest (\\<I>_adv_resta \\<eta>) (\\<I>_usr_resta \\<eta>) (I_auth_rest \\<eta>) (auth_rest \\<eta>)\"\nbegin"], ["", "theorem secure':\n  defines \"\\<I>_real \\<equiv> \\<lambda>\\<eta>. ((\\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_uniform (sec.Inp_Fedit ` (carrier (\\<L> \\<eta>))) UNIV))) \\<oplus>\\<^sub>\\<I> (\\<I>_adv_restk \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta \\<eta>))\"\n      and \"\\<I>_common \\<equiv> \\<lambda>\\<eta>. ((\\<I>_uniform (sec.Inp_Send ` (carrier (\\<L> \\<eta>))) UNIV \\<oplus>\\<^sub>\\<I> \\<I>_uniform UNIV (sec.Out_Recv ` carrier (\\<L> \\<eta>))) \\<oplus>\\<^sub>\\<I> (\\<I>_usr_restk \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta \\<eta>))\"\n      and \"\\<I>_ideal \\<equiv> \\<lambda>\\<eta>. (\\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_uniform (sec.Inp_Fedit ` (carrier (\\<L> \\<eta>))) UNIV)) \\<oplus>\\<^sub>\\<I> (\\<I>_adv_restk \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta \\<eta>)\" \n    shows \"constructive_security_obsf' (real_resource' key_rest auth_rest) (ideal_resource' key_rest auth_rest) sim' \\<I>_real \\<I>_ideal \\<I>_common \\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constructive_security_obsf' (real_resource' key_rest auth_rest)\n     (ideal_resource' key_rest auth_rest) sim' \\<I>_real \\<I>_ideal\n     \\<I>_common \\<A>", "proof(rule constructive_security_obsf'I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<eta>.\n       constructive_security_obsf (real_resource' key_rest auth_rest \\<eta>)\n        (ideal_resource' key_rest auth_rest \\<eta>) (sim' \\<eta>)\n        (\\<I>_real \\<eta>) (\\<I>_ideal \\<eta>) (\\<I>_common \\<eta>)\n        (\\<A> \\<eta>) (?adv \\<eta>)\n 2. (\\<And>\\<eta>.\n        exception_\\<I>\n         (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n        \\<turnstile>g \\<A> \\<eta> \\<surd>) \\<Longrightarrow>\n    Negligible.negligible ?adv", "show \"constructive_security_obsf (real_resource' key_rest auth_rest \\<eta>) (ideal_resource' key_rest auth_rest \\<eta>)\n          (sim' \\<eta>) (\\<I>_real \\<eta>) (\\<I>_ideal \\<eta>) (\\<I>_common \\<eta>) (\\<A> \\<eta>) 0\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. constructive_security_obsf (real_resource' key_rest auth_rest \\<eta>)\n     (ideal_resource' key_rest auth_rest \\<eta>) (sim' \\<eta>)\n     (\\<I>_real \\<eta>) (\\<I>_ideal \\<eta>) (\\<I>_common \\<eta>)\n     (\\<A> \\<eta>) 0", "unfolding real_resource'_def ideal_resource'_def sim'_def \\<I>_real_def \\<I>_common_def \\<I>_ideal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. constructive_security_obsf\n     (one_time_pad.real_resource (\\<L> \\<eta>) (key_rest \\<eta>)\n       (auth_rest \\<eta>))\n     (sec.resource \\<eta> (ideal_rest (key_rest \\<eta>) (auth_rest \\<eta>)))\n     (sim |\\<^sub>= 1\\<^sub>C)\n     ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n       (\\<I>_full \\<oplus>\\<^sub>\\<I>\n        (\\<I>_full \\<oplus>\\<^sub>\\<I>\n         \\<I>_uniform (sec.Inp_Fedit ` carrier (\\<L> \\<eta>))\n          UNIV))) \\<oplus>\\<^sub>\\<I>\n      (\\<I>_adv_restk \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta \\<eta>))\n     ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n       (\\<I>_full \\<oplus>\\<^sub>\\<I>\n        \\<I>_uniform (sec.Inp_Fedit ` carrier (\\<L> \\<eta>))\n         UNIV)) \\<oplus>\\<^sub>\\<I>\n      (\\<I>_adv_restk \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_adv_resta \\<eta>))\n     ((\\<I>_uniform (sec.Inp_Send ` carrier (\\<L> \\<eta>))\n        UNIV \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform UNIV\n        (sec.Out_Recv ` carrier (\\<L> \\<eta>))) \\<oplus>\\<^sub>\\<I>\n      (\\<I>_usr_restk \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_usr_resta \\<eta>))\n     (\\<A> \\<eta>) 0", "by(rule secure)(rule WT_key_res WT_auth_rest)+"], ["proof (state)\nthis:\n  constructive_security_obsf (real_resource' key_rest auth_rest ?\\<eta>4)\n   (ideal_resource' key_rest auth_rest ?\\<eta>4) (sim' ?\\<eta>4)\n   (\\<I>_real ?\\<eta>4) (\\<I>_ideal ?\\<eta>4) (\\<I>_common ?\\<eta>4)\n   (\\<A> ?\\<eta>4) 0\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>.\n        exception_\\<I>\n         (\\<I>_real \\<eta> \\<oplus>\\<^sub>\\<I> \\<I>_common \\<eta>)\n        \\<turnstile>g \\<A> \\<eta> \\<surd>) \\<Longrightarrow>\n    Negligible.negligible (\\<lambda>\\<eta>. 0)", "qed simp"], ["", "end"], ["", "end"], ["", "end"]]}