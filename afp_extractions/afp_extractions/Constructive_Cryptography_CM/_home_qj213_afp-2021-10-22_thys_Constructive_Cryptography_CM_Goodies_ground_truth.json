{"file_name": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography_CM/Goodies.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography_CM", "problem_names": ["lemma inits_map: \"inits (map f xs) = map (map f) (inits xs)\"", "lemma inits_append [simp]: \"inits (xs @ ys) = inits xs @ map ((@) xs) (inits ys)\"", "lemma inits_self_simps [simp]:\n    \"inits_self [] = []\"\n    \"inits_self (x # xs) = ([], x) # map (apfst ((#) x)) (inits_self xs)\"", "lemma inits_self_map: \"inits_self (map f xs) = map (map_prod (map f) f) (inits_self xs)\"", "lemma in_set_inits_self: \"(ys, z) \\<in> set (inits_self xs) \\<longleftrightarrow> (\\<exists>zs. xs = ys @ z # zs)\"", "lemma foldl_append: \"foldl (\\<lambda>s e. s @ [e]) s l = s @ l\"", "lemma foldl_insert: \"foldl (\\<lambda>A x. insert (f x) A) A xs = A \\<union> (f ` set xs)\"", "lemma foldl_concat_prodl: \"foldl (\\<lambda>(l, r) x. (l @ g r x, f r x)) (l, r) xs =\n    (l @ concat (map (\\<lambda>(ys, x). g (foldl f r ys) x) (inits_self xs)), foldl f r xs)\""], "translations": [["", "lemma inits_map: \"inits (map f xs) = map (map f) (inits xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inits (map f xs) = map (map f) (inits xs)", "by(induction xs) simp_all"], ["", "lemma inits_append [simp]: \"inits (xs @ ys) = inits xs @ map ((@) xs) (inits ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inits (xs @ ys) = inits xs @ map ((@) xs) (inits ys)", "by(induction xs) (simp_all)"], ["", "lemma inits_self_simps [simp]:\n    \"inits_self [] = []\"\n    \"inits_self (x # xs) = ([], x) # map (apfst ((#) x)) (inits_self xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inits_self [] = [] &&&\n    inits_self (x # xs) = ([], x) # map (apfst ((#) x)) (inits_self xs)", "by(simp_all add: inits_self_def apfst_def map_prod_def zip_map1[symmetric])"], ["", "lemma inits_self_map: \"inits_self (map f xs) = map (map_prod (map f) f) (inits_self xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inits_self (map f xs) = map (map_prod (map f) f) (inits_self xs)", "by(induction xs) (simp_all add: apfst_def prod.map_comp o_def)"], ["", "lemma in_set_inits_self: \"(ys, z) \\<in> set (inits_self xs) \\<longleftrightarrow> (\\<exists>zs. xs = ys @ z # zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((ys, z) \\<in> set (inits_self xs)) = (\\<exists>zs. xs = ys @ z # zs)", "by(induction xs arbitrary: ys z)(auto simp add: Cons_eq_append_conv apfst_def map_prod_def)"], ["", "lemma foldl_append: \"foldl (\\<lambda>s e. s @ [e]) s l = s @ l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>s e. s @ [e]) s l = s @ l", "by (induction l arbitrary: s) auto"], ["", "lemma foldl_insert: \"foldl (\\<lambda>A x. insert (f x) A) A xs = A \\<union> (f ` set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>A x. insert (f x) A) A xs = A \\<union> f ` set xs", "by(induction xs arbitrary: A) simp_all"], ["", "lemma foldl_concat_prodl: \"foldl (\\<lambda>(l, r) x. (l @ g r x, f r x)) (l, r) xs =\n    (l @ concat (map (\\<lambda>(ys, x). g (foldl f r ys) x) (inits_self xs)), foldl f r xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>(l, r) x. (l @ g r x, f r x)) (l, r) xs =\n    (l @\n     concat (map (\\<lambda>(ys, x). g (foldl f r ys) x) (inits_self xs)),\n     foldl f r xs)", "by(induction xs arbitrary: l r) (simp_all add: split_def o_def)"], ["", "end"]]}