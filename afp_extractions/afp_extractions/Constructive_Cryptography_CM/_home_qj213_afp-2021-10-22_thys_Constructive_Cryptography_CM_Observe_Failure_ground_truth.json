{"file_name": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography_CM/Observe_Failure.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography_CM", "problem_names": ["lemma obsf_resource_sel:\n  \"run_resource (obsf_resource res) x = \n   map_spmf (map_prod id (\\<lambda>resF. obsf_resource (case resF of OK res' \\<Rightarrow> res' | Fault \\<Rightarrow> fail_resource))) \n    (TRY map_spmf (map_prod OK OK) (run_resource res x) ELSE return_spmf (Fault, Fault))\"", "lemma obsf_resource_exception [simp]: \"obsf_resource fail_resource = const_resource Fault\"", "lemma obsf_resource_sel2 [simp]:\n  \"run_resource (obsf_resource res) x = \n   try_spmf (map_spmf (map_prod OK obsf_resource) (run_resource res x)) (return_spmf (Fault, const_resource Fault))\"", "lemma lossless_obsf_resource [simp]: \"lossless_resource \\<I> (obsf_resource res)\"", "lemma WT_obsf_resource [WT_intro, simp]: \"exception_\\<I> \\<I> \\<turnstile>res obsf_resource res \\<surd>\" if \"\\<I> \\<turnstile>res res \\<surd>\"", "lemma WT_obsf_distinguisher [WT_intro]:\n  \"exception_\\<I> \\<I> \\<turnstile>g obsf_distinguisher \\<A> \\<surd>\" if [WT_intro]: \"\\<I> \\<turnstile>g \\<A> \\<surd>\"", "lemma interaction_bounded_by_obsf_distinguisher [interaction_bound]:\n  \"interaction_bounded_by consider (obsf_distinguisher \\<A>) bound\"\n  if [interaction_bound]: \"interaction_bounded_by consider \\<A> bound\"", "lemma plossless_obsf_distinguisher [simp]:\n  \"plossless_gpv (exception_\\<I> \\<I>) (obsf_distinguisher \\<A>)\"\n  if \"plossless_gpv \\<I> \\<A>\" \"\\<I> \\<turnstile>g \\<A> \\<surd>\"", "lemma obsf_converter_exception [simp]: \"obsf_converter fail_converter = const_converter Fault\"", "lemma obsf_converter_sel [simp]:\n  \"run_converter (obsf_converter conv) x =\n   TRY map_gpv' (\\<lambda>y. case y of None \\<Rightarrow> (Fault, const_converter Fault) | Some(x, conv') \\<Rightarrow> (OK x, obsf_converter conv')) id option_of_exception\n         (gpv_stop (run_converter conv x))\n   ELSE Done (Fault, const_converter Fault)\"", "lemma exec_gpv_obsf_resource:\n  defines \"exec_gpv1 \\<equiv> exec_gpv\"\n    and \"exec_gpv2 \\<equiv> exec_gpv\"\n  shows\n  \"exec_gpv1 run_resource (map_gpv' id id option_of_exception (gpv_stop gpv)) (obsf_resource res) \\<upharpoonleft> {(Some x, y)|x y. True} =\n   map_spmf (map_prod Some obsf_resource) (exec_gpv2 run_resource gpv res)\"\n  (is \"?lhs = ?rhs\")", "lemma obsf_attach: \n  assumes pfinite: \"pfinite_converter \\<I> \\<I>' conv\"\n    and WT: \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\"\n    and WT_resource: \"\\<I>' \\<turnstile>res res \\<surd>\"\n  shows \"outs_\\<I> \\<I> \\<turnstile>\\<^sub>R attach (obsf_converter conv) (obsf_resource res) \\<sim> obsf_resource (attach conv res)\"", "lemma colossless_obsf_converter [simp]:\n  \"colossless_converter (exception_\\<I> \\<I>) \\<I>' (obsf_converter conv)\"", "lemma WT_obsf_converter [WT_intro]:\n  \"exception_\\<I> \\<I>, exception_\\<I> \\<I>' \\<turnstile>\\<^sub>C obsf_converter conv \\<surd>\" if \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\"", "lemma inline1_gpv_stop_obsf_converter:\n  defines \"inline1a \\<equiv> inline1\"\n    and \"inline1b \\<equiv> inline1\"\n  shows \"bind_spmf (inline1a run_converter (map_gpv' id id option_of_exception (gpv_stop gpv)) (obsf_converter conv))\n     (\\<lambda>xy. case xy of Inl (None, conv') \\<Rightarrow> return_pmf None | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv')) | Inr y \\<Rightarrow> return_spmf (Inr y)) = \n   map_spmf (map_sum (apsnd obsf_converter)\n       (apsnd (map_prod (\\<lambda>rpv input. case input of Fault \\<Rightarrow> Done (Fault, const_converter Fault) | OK input' \\<Rightarrow> \n            map_gpv' (\\<lambda>res. case res of None \\<Rightarrow> (Fault, const_converter Fault) | Some (x, conv') \\<Rightarrow> (OK x, obsf_converter conv')) id option_of_exception (try_gpv (gpv_stop (rpv input')) (Done None))) \n     (\\<lambda>rpv input. case input of Fault \\<Rightarrow> Done None | OK input' \\<Rightarrow> map_gpv' id id option_of_exception (gpv_stop (rpv input'))))))\n    (inline1b run_converter gpv conv)\"\n  (is \"?lhs = ?rhs\")", "lemma inline_gpv_stop_obsf_converter:\n  \"bind_gpv (inline run_converter (map_gpv' id id option_of_exception (gpv_stop gpv)) (obsf_converter conv)) (\\<lambda>(x, conv'). case x of None \\<Rightarrow> Fail | Some x' \\<Rightarrow> Done (x, conv')) =\n   bind_gpv (map_gpv' id id option_of_exception (gpv_stop (inline run_converter gpv conv))) (\\<lambda>x. case x of None \\<Rightarrow> Fail | Some (x', conv) \\<Rightarrow> Done (Some x', obsf_converter conv))\"", "lemma obsf_comp_converter:\n  assumes WT: \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>\" \"\\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>\"\n    and pfinite1: \"pfinite_converter \\<I> \\<I>' conv1\"\n  shows \"exception_\\<I> \\<I>, exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C obsf_converter (comp_converter conv1 conv2) \\<sim> comp_converter (obsf_converter conv1) (obsf_converter conv2)\"", "lemma resource_of_obsf_oracle_Fault [simp]:\n  \"resource_of_oracle (obsf_oracle oracle) Fault = const_resource Fault\"", "lemma obsf_resource_of_oracle [simp]:\n  \"obsf_resource (resource_of_oracle oracle s) = resource_of_oracle (obsf_oracle oracle) (OK s)\"", "lemma trace_callee_eq_obsf_Fault [simp]: \"A \\<turnstile>\\<^sub>C obsf_oracle callee1(Fault) \\<approx> obsf_oracle callee2(Fault)\"", "lemma obsf_resource_eq_\\<I>_cong: \"A \\<turnstile>\\<^sub>R obsf_resource res1 \\<sim> obsf_resource res2\" if \"A \\<turnstile>\\<^sub>R res1 \\<sim> res2\"", "lemma trace_callee_eq_obsf_oracleI:\n  assumes \"trace_callee_eq callee1 callee2 A p q\"\n  shows \"trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A (try_spmf (map_spmf OK p) (return_spmf Fault)) (try_spmf (map_spmf OK q) (return_spmf Fault))\"", "lemma trace_callee_eq'_obsf_resourceI:\n  assumes \" A \\<turnstile>\\<^sub>C callee1(s) \\<approx> callee2(s')\"\n  shows \"A \\<turnstile>\\<^sub>C obsf_oracle callee1(OK s) \\<approx> obsf_oracle callee2(OK s')\"", "lemma trace_eq_obsf_resourceI:\n  assumes \"A \\<turnstile>\\<^sub>R res1 \\<approx> res2\"\n  shows \"A \\<turnstile>\\<^sub>R obsf_resource res1 \\<approx> obsf_resource res2\"", "lemma spmf_run_obsf_oracle_obsf_distinguisher [rule_format]:\n  defines \"eg1 \\<equiv> exec_gpv\" and \"eg2 \\<equiv> exec_gpv\" shows\n  \"spmf (map_spmf fst (eg1 (obsf_oracle oracle) (obsf_distinguisher gpv) (OK s))) True =\n   spmf (map_spmf fst (eg2 oracle gpv s)) True\"\n  (is \"?lhs = ?rhs\")", "lemma spmf_obsf_distinguisher_obsf_resource_True:\n  \"spmf (connect_obsf (obsf_distinguisher \\<A>) (obsf_resource res)) True = spmf (connect \\<A> res) True\"", "lemma advantage_obsf_distinguisher: \n  \"advantage (obsf_distinguisher \\<A>) (obsf_resource ideal_resource) (obsf_resource real_resource) =\n   advantage \\<A> ideal_resource real_resource\""], "translations": [["", "lemma obsf_resource_sel:\n  \"run_resource (obsf_resource res) x = \n   map_spmf (map_prod id (\\<lambda>resF. obsf_resource (case resF of OK res' \\<Rightarrow> res' | Fault \\<Rightarrow> fail_resource))) \n    (TRY map_spmf (map_prod OK OK) (run_resource res x) ELSE return_spmf (Fault, Fault))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_resource (obsf_resource res) x =\n    map_spmf\n     (map_prod id\n       (\\<lambda>resF.\n           obsf_resource\n            (case resF of Fault \\<Rightarrow> fail_resource\n             | OK res' \\<Rightarrow> res')))\n     (TRY map_spmf (map_prod OK OK)\n           (run_resource res x) ELSE return_spmf (Fault, Fault))", "by(simp add: spmf.map_comp prod.map_comp o_def id_def)"], ["", "declare obsf_resource.simps [simp del]"], ["", "lemma obsf_resource_exception [simp]: \"obsf_resource fail_resource = const_resource Fault\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obsf_resource fail_resource = const_resource Fault", "by coinduction(simp add: rel_fun_def obsf_resource_sel)"], ["", "lemma obsf_resource_sel2 [simp]:\n  \"run_resource (obsf_resource res) x = \n   try_spmf (map_spmf (map_prod OK obsf_resource) (run_resource res x)) (return_spmf (Fault, const_resource Fault))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_resource (obsf_resource res) x =\n    TRY map_spmf (map_prod OK obsf_resource)\n         (run_resource res x) ELSE return_spmf (Fault, const_resource Fault)", "by(simp add: map_try_spmf spmf.map_comp o_def prod.map_comp obsf_resource_sel)"], ["", "lemma lossless_obsf_resource [simp]: \"lossless_resource \\<I> (obsf_resource res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_resource \\<I> (obsf_resource res)", "by(coinduction arbitrary: res) auto"], ["", "lemma WT_obsf_resource [WT_intro, simp]: \"exception_\\<I> \\<I> \\<turnstile>res obsf_resource res \\<surd>\" if \"\\<I> \\<turnstile>res res \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exception_\\<I> \\<I> \\<turnstile>res obsf_resource res \\<surd>", "using that"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>res res \\<surd>\n\ngoal (1 subgoal):\n 1. exception_\\<I> \\<I> \\<turnstile>res obsf_resource res \\<surd>", "by(coinduction arbitrary: res)(auto dest: WT_resourceD split: if_split_asm)"], ["", "type_synonym ('a, 'b) distinguisher_obsf = \"(bool, 'a, 'b exception) gpv\""], ["", "translations\n  (type) \"('a, 'b) distinguisher_obsf\" <= (type) \"(bool, 'a, 'b exception) gpv\""], ["", "abbreviation connect_obsf :: \"('a, 'b) distinguisher_obsf \\<Rightarrow> ('a, 'b) resource_obsf \\<Rightarrow> bool spmf\" where\n  \"connect_obsf == connect\""], ["", "definition obsf_distinguisher :: \"('a, 'b) distinguisher \\<Rightarrow> ('a, 'b) distinguisher_obsf\" where\n  \"obsf_distinguisher \\<D> = map_gpv' (\\<lambda>x. x = Some True) id option_of_exception (gpv_stop \\<D>)\""], ["", "lemma WT_obsf_distinguisher [WT_intro]:\n  \"exception_\\<I> \\<I> \\<turnstile>g obsf_distinguisher \\<A> \\<surd>\" if [WT_intro]: \"\\<I> \\<turnstile>g \\<A> \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exception_\\<I> \\<I> \\<turnstile>g obsf_distinguisher \\<A> \\<surd>", "unfolding obsf_distinguisher_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exception_\\<I> \\<I>\n    \\<turnstile>g map_gpv' (\\<lambda>x. x = Some True) id\n                   option_of_exception (gpv_stop \\<A>) \\<surd>", "by(rule WT_intro|simp)+"], ["", "lemma interaction_bounded_by_obsf_distinguisher [interaction_bound]:\n  \"interaction_bounded_by consider (obsf_distinguisher \\<A>) bound\"\n  if [interaction_bound]: \"interaction_bounded_by consider \\<A> bound\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_bounded_by consider (obsf_distinguisher \\<A>) bound", "unfolding obsf_distinguisher_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_bounded_by consider\n     (map_gpv' (\\<lambda>x. x = Some True) id option_of_exception\n       (gpv_stop \\<A>))\n     bound", "by(rule interaction_bound|simp)+"], ["", "lemma plossless_obsf_distinguisher [simp]:\n  \"plossless_gpv (exception_\\<I> \\<I>) (obsf_distinguisher \\<A>)\"\n  if \"plossless_gpv \\<I> \\<A>\" \"\\<I> \\<turnstile>g \\<A> \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_gpv (exception_\\<I> \\<I>) (obsf_distinguisher \\<A>)", "using that"], ["proof (prove)\nusing this:\n  plossless_gpv \\<I> \\<A>\n  \\<I> \\<turnstile>g \\<A> \\<surd>\n\ngoal (1 subgoal):\n 1. plossless_gpv (exception_\\<I> \\<I>) (obsf_distinguisher \\<A>)", "unfolding obsf_distinguisher_def"], ["proof (prove)\nusing this:\n  plossless_gpv \\<I> \\<A>\n  \\<I> \\<turnstile>g \\<A> \\<surd>\n\ngoal (1 subgoal):\n 1. plossless_gpv (exception_\\<I> \\<I>)\n     (map_gpv' (\\<lambda>x. x = Some True) id option_of_exception\n       (gpv_stop \\<A>))", "by(simp)"], ["", "type_synonym ('a, 'b, 'c, 'd) converter_obsf = \"('a, 'b exception, 'c, 'd exception) converter\""], ["", "translations                                                                                       \n  (type) \"('a, 'b, 'c, 'd) converter_obsf\" <= (type) \"('a, 'b exception, 'c, 'd exception) converter\""], ["", "primcorec obsf_converter :: \"('a, 'b, 'c, 'd) converter \\<Rightarrow> ('a, 'b, 'c, 'd) converter_obsf\" where\n  \"run_converter (obsf_converter conv) = (\\<lambda>x. \n   map_gpv (map_prod id obsf_converter) id \n    (map_gpv (\\<lambda>convF. case convF of Fault \\<Rightarrow> (Fault, fail_converter) | OK (a, conv') \\<Rightarrow> (OK a, conv')) id\n      (try_gpv (map_gpv' exception_of_option id option_of_exception (gpv_stop (run_converter conv x))) (Done Fault))))\""], ["", "lemma obsf_converter_exception [simp]: \"obsf_converter fail_converter = const_converter Fault\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obsf_converter \\<bottom>\\<^sub>C = const_converter Fault", "by(coinduction)(simp add: rel_fun_def)"], ["", "lemma obsf_converter_sel [simp]:\n  \"run_converter (obsf_converter conv) x =\n   TRY map_gpv' (\\<lambda>y. case y of None \\<Rightarrow> (Fault, const_converter Fault) | Some(x, conv') \\<Rightarrow> (OK x, obsf_converter conv')) id option_of_exception\n         (gpv_stop (run_converter conv x))\n   ELSE Done (Fault, const_converter Fault)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_converter (obsf_converter conv) x =\n    TRY map_gpv'\n         (\\<lambda>y.\n             case y of None \\<Rightarrow> (Fault, const_converter Fault)\n             | Some (x, conv') \\<Rightarrow> (OK x, obsf_converter conv'))\n         id option_of_exception\n         (gpv_stop\n           (run_converter conv x)) ELSE Done (Fault, const_converter Fault)", "by(simp add: map_try_gpv)\n    (simp add: map_gpv_conv_map_gpv' map_gpv'_comp o_def option.case_distrib[where h=\"map_prod _ _\"] split_def id_def cong del: option.case_cong)"], ["", "declare obsf_converter.sel [simp del]"], ["", "lemma exec_gpv_obsf_resource:\n  defines \"exec_gpv1 \\<equiv> exec_gpv\"\n    and \"exec_gpv2 \\<equiv> exec_gpv\"\n  shows\n  \"exec_gpv1 run_resource (map_gpv' id id option_of_exception (gpv_stop gpv)) (obsf_resource res) \\<upharpoonleft> {(Some x, y)|x y. True} =\n   map_spmf (map_prod Some obsf_resource) (exec_gpv2 run_resource gpv res)\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_gpv1 run_resource\n     (map_gpv' id id option_of_exception (gpv_stop gpv))\n     (obsf_resource res) \\<upharpoonleft>\n    {(Some x, y) |x y. True} =\n    map_spmf (map_prod Some obsf_resource) (exec_gpv2 run_resource gpv res)", "proof(rule spmf.leq_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. ord_spmf (=)\n     (exec_gpv1 run_resource\n       (map_gpv' id id option_of_exception (gpv_stop gpv))\n       (obsf_resource res) \\<upharpoonleft>\n      {(Some x, y) |x y. True})\n     (map_spmf (map_prod Some obsf_resource)\n       (exec_gpv2 run_resource gpv res))\n 2. ord_spmf (=)\n     (map_spmf (map_prod Some obsf_resource)\n       (exec_gpv2 run_resource gpv res))\n     (exec_gpv1 run_resource\n       (map_gpv' id id option_of_exception (gpv_stop gpv))\n       (obsf_resource res) \\<upharpoonleft>\n      {(Some x, y) |x y. True})", "show \"ord_spmf (=) ?lhs ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (exec_gpv1 run_resource\n       (map_gpv' id id option_of_exception (gpv_stop gpv))\n       (obsf_resource res) \\<upharpoonleft>\n      {(Some x, y) |x y. True})\n     (map_spmf (map_prod Some obsf_resource)\n       (exec_gpv2 run_resource gpv res))", "unfolding exec_gpv1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (exec_gpv run_resource\n       (map_gpv' id id option_of_exception (gpv_stop gpv))\n       (obsf_resource res) \\<upharpoonleft>\n      {(Some x, y) |x y. True})\n     (map_spmf (map_prod Some obsf_resource)\n       (exec_gpv2 run_resource gpv res))", "proof(induction arbitrary: gpv res rule: exec_gpv_fixp_induct_strong)"], ["proof (state)\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>f.\n         \\<forall>x xa.\n            ord_spmf (=)\n             (f (map_gpv' id id option_of_exception (gpv_stop x),\n                 obsf_resource xa) \\<upharpoonleft>\n              {(Some x, y) |x y. True})\n             (map_spmf (map_prod Some obsf_resource)\n               (exec_gpv2 run_resource x xa)))\n 2. \\<And>gpv res.\n       ord_spmf (=)\n        (return_pmf None \\<upharpoonleft> {(Some x, y) |x y. True})\n        (map_spmf (map_prod Some obsf_resource)\n          (exec_gpv2 run_resource gpv res))\n 3. \\<And>exec_gpv' gpv res.\n       \\<lbrakk>\\<And>c s.\n                   ord_spmf (=) (exec_gpv' c s) (exec_gpv run_resource c s);\n        \\<And>gpv res.\n           ord_spmf (=)\n            (exec_gpv' (map_gpv' id id option_of_exception (gpv_stop gpv))\n              (obsf_resource res) \\<upharpoonleft>\n             {(Some x, y) |x y. True})\n            (map_spmf (map_prod Some obsf_resource)\n              (exec_gpv2 run_resource gpv res))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (bind_spmf\n                            (the_gpv\n                              (map_gpv' id id option_of_exception\n                                (gpv_stop gpv)))\n                            (case_generat\n                              (\\<lambda>x.\n                                  return_spmf (x, obsf_resource res))\n                              (\\<lambda>out c.\n                                  bind_spmf\n                                   (run_resource (obsf_resource res) out)\n                                   (\\<lambda>(x, y).\n exec_gpv' (c x) y))) \\<upharpoonleft>\n                           {(Some x, y) |x y. True})\n                          (map_spmf (map_prod Some obsf_resource)\n                            (exec_gpv2 run_resource gpv res))", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>f.\n         \\<forall>x xa.\n            ord_spmf (=)\n             (f (map_gpv' id id option_of_exception (gpv_stop x),\n                 obsf_resource xa) \\<upharpoonleft>\n              {(Some x, y) |x y. True})\n             (map_spmf (map_prod Some obsf_resource)\n               (exec_gpv2 run_resource x xa)))\n 2. \\<And>gpv res.\n       ord_spmf (=)\n        (return_pmf None \\<upharpoonleft> {(Some x, y) |x y. True})\n        (map_spmf (map_prod Some obsf_resource)\n          (exec_gpv2 run_resource gpv res))\n 3. \\<And>exec_gpv' gpv res.\n       \\<lbrakk>\\<And>c s.\n                   ord_spmf (=) (exec_gpv' c s) (exec_gpv run_resource c s);\n        \\<And>gpv res.\n           ord_spmf (=)\n            (exec_gpv' (map_gpv' id id option_of_exception (gpv_stop gpv))\n              (obsf_resource res) \\<upharpoonleft>\n             {(Some x, y) |x y. True})\n            (map_spmf (map_prod Some obsf_resource)\n              (exec_gpv2 run_resource gpv res))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (bind_spmf\n                            (the_gpv\n                              (map_gpv' id id option_of_exception\n                                (gpv_stop gpv)))\n                            (case_generat\n                              (\\<lambda>x.\n                                  return_spmf (x, obsf_resource res))\n                              (\\<lambda>out c.\n                                  bind_spmf\n                                   (run_resource (obsf_resource res) out)\n                                   (\\<lambda>(x, y).\n exec_gpv' (c x) y))) \\<upharpoonleft>\n                           {(Some x, y) |x y. True})\n                          (map_spmf (map_prod Some obsf_resource)\n                            (exec_gpv2 run_resource gpv res))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf.admissible\n     (\\<lambda>f.\n         \\<forall>x xa.\n            ord_spmf (=)\n             (f (map_gpv' id id option_of_exception (gpv_stop x),\n                 obsf_resource xa) \\<upharpoonleft>\n              {(Some x, y) |x y. True})\n             (map_spmf (map_prod Some obsf_resource)\n               (exec_gpv2 run_resource x xa)))", "by simp"], ["proof (state)\nthis:\n  spmf.admissible\n   (\\<lambda>f.\n       \\<forall>x xa.\n          ord_spmf (=)\n           (f (map_gpv' id id option_of_exception (gpv_stop x),\n               obsf_resource xa) \\<upharpoonleft>\n            {(Some x, y) |x y. True})\n           (map_spmf (map_prod Some obsf_resource)\n             (exec_gpv2 run_resource x xa)))\n\ngoal (2 subgoals):\n 1. \\<And>gpv res.\n       ord_spmf (=)\n        (return_pmf None \\<upharpoonleft> {(Some x, y) |x y. True})\n        (map_spmf (map_prod Some obsf_resource)\n          (exec_gpv2 run_resource gpv res))\n 2. \\<And>exec_gpv' gpv res.\n       \\<lbrakk>\\<And>c s.\n                   ord_spmf (=) (exec_gpv' c s) (exec_gpv run_resource c s);\n        \\<And>gpv res.\n           ord_spmf (=)\n            (exec_gpv' (map_gpv' id id option_of_exception (gpv_stop gpv))\n              (obsf_resource res) \\<upharpoonleft>\n             {(Some x, y) |x y. True})\n            (map_spmf (map_prod Some obsf_resource)\n              (exec_gpv2 run_resource gpv res))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (bind_spmf\n                            (the_gpv\n                              (map_gpv' id id option_of_exception\n                                (gpv_stop gpv)))\n                            (case_generat\n                              (\\<lambda>x.\n                                  return_spmf (x, obsf_resource res))\n                              (\\<lambda>out c.\n                                  bind_spmf\n                                   (run_resource (obsf_resource res) out)\n                                   (\\<lambda>(x, y).\n exec_gpv' (c x) y))) \\<upharpoonleft>\n                           {(Some x, y) |x y. True})\n                          (map_spmf (map_prod Some obsf_resource)\n                            (exec_gpv2 run_resource gpv res))", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>gpv res.\n       ord_spmf (=)\n        (return_pmf None \\<upharpoonleft> {(Some x, y) |x y. True})\n        (map_spmf (map_prod Some obsf_resource)\n          (exec_gpv2 run_resource gpv res))\n 2. \\<And>exec_gpv' gpv res.\n       \\<lbrakk>\\<And>c s.\n                   ord_spmf (=) (exec_gpv' c s) (exec_gpv run_resource c s);\n        \\<And>gpv res.\n           ord_spmf (=)\n            (exec_gpv' (map_gpv' id id option_of_exception (gpv_stop gpv))\n              (obsf_resource res) \\<upharpoonleft>\n             {(Some x, y) |x y. True})\n            (map_spmf (map_prod Some obsf_resource)\n              (exec_gpv2 run_resource gpv res))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (bind_spmf\n                            (the_gpv\n                              (map_gpv' id id option_of_exception\n                                (gpv_stop gpv)))\n                            (case_generat\n                              (\\<lambda>x.\n                                  return_spmf (x, obsf_resource res))\n                              (\\<lambda>out c.\n                                  bind_spmf\n                                   (run_resource (obsf_resource res) out)\n                                   (\\<lambda>(x, y).\n exec_gpv' (c x) y))) \\<upharpoonleft>\n                           {(Some x, y) |x y. True})\n                          (map_spmf (map_prod Some obsf_resource)\n                            (exec_gpv2 run_resource gpv res))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=) (return_pmf None \\<upharpoonleft> {(Some x, y) |x y. True})\n     (map_spmf (map_prod Some obsf_resource)\n       (exec_gpv2 run_resource gpv res))", "by simp"], ["proof (state)\nthis:\n  ord_spmf (=) (return_pmf None \\<upharpoonleft> {(Some x, y) |x y. True})\n   (map_spmf (map_prod Some obsf_resource) (exec_gpv2 run_resource gpv res))\n\ngoal (1 subgoal):\n 1. \\<And>exec_gpv' gpv res.\n       \\<lbrakk>\\<And>c s.\n                   ord_spmf (=) (exec_gpv' c s) (exec_gpv run_resource c s);\n        \\<And>gpv res.\n           ord_spmf (=)\n            (exec_gpv' (map_gpv' id id option_of_exception (gpv_stop gpv))\n              (obsf_resource res) \\<upharpoonleft>\n             {(Some x, y) |x y. True})\n            (map_spmf (map_prod Some obsf_resource)\n              (exec_gpv2 run_resource gpv res))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (bind_spmf\n                            (the_gpv\n                              (map_gpv' id id option_of_exception\n                                (gpv_stop gpv)))\n                            (case_generat\n                              (\\<lambda>x.\n                                  return_spmf (x, obsf_resource res))\n                              (\\<lambda>out c.\n                                  bind_spmf\n                                   (run_resource (obsf_resource res) out)\n                                   (\\<lambda>(x, y).\n exec_gpv' (c x) y))) \\<upharpoonleft>\n                           {(Some x, y) |x y. True})\n                          (map_spmf (map_prod Some obsf_resource)\n                            (exec_gpv2 run_resource gpv res))", "case (step exec_gpv')"], ["proof (state)\nthis:\n  ord_spmf (=) (exec_gpv' ?c ?s) (exec_gpv run_resource ?c ?s)\n  ord_spmf (=)\n   (exec_gpv' (map_gpv' id id option_of_exception (gpv_stop ?gpv))\n     (obsf_resource ?res) \\<upharpoonleft>\n    {(Some x, y) |x y. True})\n   (map_spmf (map_prod Some obsf_resource)\n     (exec_gpv2 run_resource ?gpv ?res))\n\ngoal (1 subgoal):\n 1. \\<And>exec_gpv' gpv res.\n       \\<lbrakk>\\<And>c s.\n                   ord_spmf (=) (exec_gpv' c s) (exec_gpv run_resource c s);\n        \\<And>gpv res.\n           ord_spmf (=)\n            (exec_gpv' (map_gpv' id id option_of_exception (gpv_stop gpv))\n              (obsf_resource res) \\<upharpoonleft>\n             {(Some x, y) |x y. True})\n            (map_spmf (map_prod Some obsf_resource)\n              (exec_gpv2 run_resource gpv res))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (bind_spmf\n                            (the_gpv\n                              (map_gpv' id id option_of_exception\n                                (gpv_stop gpv)))\n                            (case_generat\n                              (\\<lambda>x.\n                                  return_spmf (x, obsf_resource res))\n                              (\\<lambda>out c.\n                                  bind_spmf\n                                   (run_resource (obsf_resource res) out)\n                                   (\\<lambda>(x, y).\n exec_gpv' (c x) y))) \\<upharpoonleft>\n                           {(Some x, y) |x y. True})\n                          (map_spmf (map_prod Some obsf_resource)\n                            (exec_gpv2 run_resource gpv res))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (bind_spmf\n       (the_gpv (map_gpv' id id option_of_exception (gpv_stop gpv)))\n       (case_generat (\\<lambda>x. return_spmf (x, obsf_resource res))\n         (\\<lambda>out c.\n             bind_spmf (run_resource (obsf_resource res) out)\n              (\\<lambda>(x, y). exec_gpv' (c x) y))) \\<upharpoonleft>\n      {(Some x, y) |x y. True})\n     (map_spmf (map_prod Some obsf_resource)\n       (exec_gpv2 run_resource gpv res))", "unfolding exec_gpv2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (bind_spmf\n       (the_gpv (map_gpv' id id option_of_exception (gpv_stop gpv)))\n       (case_generat (\\<lambda>x. return_spmf (x, obsf_resource res))\n         (\\<lambda>out c.\n             bind_spmf (run_resource (obsf_resource res) out)\n              (\\<lambda>(x, y). exec_gpv' (c x) y))) \\<upharpoonleft>\n      {(Some x, y) |x y. True})\n     (map_spmf (map_prod Some obsf_resource)\n       (exec_gpv run_resource gpv res))", "apply(subst exec_gpv.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (bind_spmf\n       (the_gpv (map_gpv' id id option_of_exception (gpv_stop gpv)))\n       (case_generat (\\<lambda>x. return_spmf (x, obsf_resource res))\n         (\\<lambda>out c.\n             bind_spmf (run_resource (obsf_resource res) out)\n              (\\<lambda>(x, y). exec_gpv' (c x) y))) \\<upharpoonleft>\n      {(Some x, y) |x y. True})\n     (map_spmf (map_prod Some obsf_resource)\n       (bind_spmf (the_gpv gpv)\n         (case_generat (\\<lambda>x. return_spmf (x, res))\n           (\\<lambda>out c.\n               bind_spmf (run_resource res out)\n                (\\<lambda>(x, y). exec_gpv run_resource (c x) y)))))", "apply(clarsimp simp add: map_bind_spmf bind_map_spmf restrict_bind_spmf o_def try_spmf_def intro!: ord_spmf_bind_reflI split!: generat.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n       ord_spmf (=)\n        (bind_spmf\n          (bind_pmf\n            (map_spmf (map_prod OK obsf_resource) (run_resource res x21))\n            (case_option (return_spmf (Fault, const_resource Fault))\n              return_spmf))\n          (\\<lambda>x.\n              (case x of\n               (x, xa) \\<Rightarrow>\n                 exec_gpv'\n                  (map_gpv' id id option_of_exception\n                    (case x of Fault \\<Rightarrow> Done None\n                     | OK input' \\<Rightarrow> gpv_stop (x22 input')))\n                  xa) \\<upharpoonleft>\n              {uu_. \\<exists>x y. uu_ = (Some x, y)}))\n        (bind_spmf (run_resource res x21)\n          (\\<lambda>x.\n              map_spmf (map_prod Some obsf_resource)\n               (case x of\n                (x, xa) \\<Rightarrow> exec_gpv run_resource (x22 x) xa)))", "apply(clarsimp simp add: bind_map_pmf bind_spmf_def bind_assoc_pmf bind_return_pmf spmf.leq_trans[OF restrict_spmf_mono, OF step.hyps] id_def step.IH[simplified, simplified id_def exec_gpv2_def] intro!: rel_pmf_bind_reflI split!: option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ord_spmf (=)\n   (bind_spmf (the_gpv (map_gpv' id id option_of_exception (gpv_stop gpv)))\n     (case_generat (\\<lambda>x. return_spmf (x, obsf_resource res))\n       (\\<lambda>out c.\n           bind_spmf (run_resource (obsf_resource res) out)\n            (\\<lambda>(x, y). exec_gpv' (c x) y))) \\<upharpoonleft>\n    {(Some x, y) |x y. True})\n   (map_spmf (map_prod Some obsf_resource) (exec_gpv2 run_resource gpv res))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ord_spmf (=)\n   (exec_gpv1 run_resource\n     (map_gpv' id id option_of_exception (gpv_stop gpv))\n     (obsf_resource res) \\<upharpoonleft>\n    {(Some x, y) |x y. True})\n   (map_spmf (map_prod Some obsf_resource) (exec_gpv2 run_resource gpv res))\n\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (map_spmf (map_prod Some obsf_resource)\n       (exec_gpv2 run_resource gpv res))\n     (exec_gpv1 run_resource\n       (map_gpv' id id option_of_exception (gpv_stop gpv))\n       (obsf_resource res) \\<upharpoonleft>\n      {(Some x, y) |x y. True})", "show \"ord_spmf (=) ?rhs ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (map_spmf (map_prod Some obsf_resource)\n       (exec_gpv2 run_resource gpv res))\n     (exec_gpv1 run_resource\n       (map_gpv' id id option_of_exception (gpv_stop gpv))\n       (obsf_resource res) \\<upharpoonleft>\n      {(Some x, y) |x y. True})", "unfolding exec_gpv2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (map_spmf (map_prod Some obsf_resource)\n       (exec_gpv run_resource gpv res))\n     (exec_gpv1 run_resource\n       (map_gpv' id id option_of_exception (gpv_stop gpv))\n       (obsf_resource res) \\<upharpoonleft>\n      {(Some x, y) |x y. True})", "proof(induction arbitrary: gpv res rule: exec_gpv_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>f.\n         \\<forall>x xa.\n            ord_spmf (=)\n             (map_spmf (map_prod Some obsf_resource) (f (x, xa)))\n             (exec_gpv1 run_resource\n               (map_gpv' id id option_of_exception (gpv_stop x))\n               (obsf_resource xa) \\<upharpoonleft>\n              {(Some x, y) |x y. True}))\n 2. \\<And>gpv res.\n       ord_spmf (=)\n        (map_spmf (map_prod Some obsf_resource) (return_pmf None))\n        (exec_gpv1 run_resource\n          (map_gpv' id id option_of_exception (gpv_stop gpv))\n          (obsf_resource res) \\<upharpoonleft>\n         {(Some x, y) |x y. True})\n 3. \\<And>exec_gpv gpv res.\n       (\\<And>gpv res.\n           ord_spmf (=)\n            (map_spmf (map_prod Some obsf_resource) (exec_gpv gpv res))\n            (exec_gpv1 run_resource\n              (map_gpv' id id option_of_exception (gpv_stop gpv))\n              (obsf_resource res) \\<upharpoonleft>\n             {(Some x, y) |x y. True})) \\<Longrightarrow>\n       ord_spmf (=)\n        (map_spmf (map_prod Some obsf_resource)\n          (bind_spmf (the_gpv gpv)\n            (case_generat (\\<lambda>x. return_spmf (x, res))\n              (\\<lambda>out c.\n                  bind_spmf (run_resource res out)\n                   (\\<lambda>(x, y). exec_gpv (c x) y)))))\n        (exec_gpv1 run_resource\n          (map_gpv' id id option_of_exception (gpv_stop gpv))\n          (obsf_resource res) \\<upharpoonleft>\n         {(Some x, y) |x y. True})", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>f.\n         \\<forall>x xa.\n            ord_spmf (=)\n             (map_spmf (map_prod Some obsf_resource) (f (x, xa)))\n             (exec_gpv1 run_resource\n               (map_gpv' id id option_of_exception (gpv_stop x))\n               (obsf_resource xa) \\<upharpoonleft>\n              {(Some x, y) |x y. True}))\n 2. \\<And>gpv res.\n       ord_spmf (=)\n        (map_spmf (map_prod Some obsf_resource) (return_pmf None))\n        (exec_gpv1 run_resource\n          (map_gpv' id id option_of_exception (gpv_stop gpv))\n          (obsf_resource res) \\<upharpoonleft>\n         {(Some x, y) |x y. True})\n 3. \\<And>exec_gpv gpv res.\n       (\\<And>gpv res.\n           ord_spmf (=)\n            (map_spmf (map_prod Some obsf_resource) (exec_gpv gpv res))\n            (exec_gpv1 run_resource\n              (map_gpv' id id option_of_exception (gpv_stop gpv))\n              (obsf_resource res) \\<upharpoonleft>\n             {(Some x, y) |x y. True})) \\<Longrightarrow>\n       ord_spmf (=)\n        (map_spmf (map_prod Some obsf_resource)\n          (bind_spmf (the_gpv gpv)\n            (case_generat (\\<lambda>x. return_spmf (x, res))\n              (\\<lambda>out c.\n                  bind_spmf (run_resource res out)\n                   (\\<lambda>(x, y). exec_gpv (c x) y)))))\n        (exec_gpv1 run_resource\n          (map_gpv' id id option_of_exception (gpv_stop gpv))\n          (obsf_resource res) \\<upharpoonleft>\n         {(Some x, y) |x y. True})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf.admissible\n     (\\<lambda>f.\n         \\<forall>x xa.\n            ord_spmf (=)\n             (map_spmf (map_prod Some obsf_resource) (f (x, xa)))\n             (exec_gpv1 run_resource\n               (map_gpv' id id option_of_exception (gpv_stop x))\n               (obsf_resource xa) \\<upharpoonleft>\n              {(Some x, y) |x y. True}))", "by simp"], ["proof (state)\nthis:\n  spmf.admissible\n   (\\<lambda>f.\n       \\<forall>x xa.\n          ord_spmf (=) (map_spmf (map_prod Some obsf_resource) (f (x, xa)))\n           (exec_gpv1 run_resource\n             (map_gpv' id id option_of_exception (gpv_stop x))\n             (obsf_resource xa) \\<upharpoonleft>\n            {(Some x, y) |x y. True}))\n\ngoal (2 subgoals):\n 1. \\<And>gpv res.\n       ord_spmf (=)\n        (map_spmf (map_prod Some obsf_resource) (return_pmf None))\n        (exec_gpv1 run_resource\n          (map_gpv' id id option_of_exception (gpv_stop gpv))\n          (obsf_resource res) \\<upharpoonleft>\n         {(Some x, y) |x y. True})\n 2. \\<And>exec_gpv gpv res.\n       (\\<And>gpv res.\n           ord_spmf (=)\n            (map_spmf (map_prod Some obsf_resource) (exec_gpv gpv res))\n            (exec_gpv1 run_resource\n              (map_gpv' id id option_of_exception (gpv_stop gpv))\n              (obsf_resource res) \\<upharpoonleft>\n             {(Some x, y) |x y. True})) \\<Longrightarrow>\n       ord_spmf (=)\n        (map_spmf (map_prod Some obsf_resource)\n          (bind_spmf (the_gpv gpv)\n            (case_generat (\\<lambda>x. return_spmf (x, res))\n              (\\<lambda>out c.\n                  bind_spmf (run_resource res out)\n                   (\\<lambda>(x, y). exec_gpv (c x) y)))))\n        (exec_gpv1 run_resource\n          (map_gpv' id id option_of_exception (gpv_stop gpv))\n          (obsf_resource res) \\<upharpoonleft>\n         {(Some x, y) |x y. True})", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>gpv res.\n       ord_spmf (=)\n        (map_spmf (map_prod Some obsf_resource) (return_pmf None))\n        (exec_gpv1 run_resource\n          (map_gpv' id id option_of_exception (gpv_stop gpv))\n          (obsf_resource res) \\<upharpoonleft>\n         {(Some x, y) |x y. True})\n 2. \\<And>exec_gpv gpv res.\n       (\\<And>gpv res.\n           ord_spmf (=)\n            (map_spmf (map_prod Some obsf_resource) (exec_gpv gpv res))\n            (exec_gpv1 run_resource\n              (map_gpv' id id option_of_exception (gpv_stop gpv))\n              (obsf_resource res) \\<upharpoonleft>\n             {(Some x, y) |x y. True})) \\<Longrightarrow>\n       ord_spmf (=)\n        (map_spmf (map_prod Some obsf_resource)\n          (bind_spmf (the_gpv gpv)\n            (case_generat (\\<lambda>x. return_spmf (x, res))\n              (\\<lambda>out c.\n                  bind_spmf (run_resource res out)\n                   (\\<lambda>(x, y). exec_gpv (c x) y)))))\n        (exec_gpv1 run_resource\n          (map_gpv' id id option_of_exception (gpv_stop gpv))\n          (obsf_resource res) \\<upharpoonleft>\n         {(Some x, y) |x y. True})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=) (map_spmf (map_prod Some obsf_resource) (return_pmf None))\n     (exec_gpv1 run_resource\n       (map_gpv' id id option_of_exception (gpv_stop gpv))\n       (obsf_resource res) \\<upharpoonleft>\n      {(Some x, y) |x y. True})", "by simp"], ["proof (state)\nthis:\n  ord_spmf (=) (map_spmf (map_prod Some obsf_resource) (return_pmf None))\n   (exec_gpv1 run_resource\n     (map_gpv' id id option_of_exception (gpv_stop gpv))\n     (obsf_resource res) \\<upharpoonleft>\n    {(Some x, y) |x y. True})\n\ngoal (1 subgoal):\n 1. \\<And>exec_gpv gpv res.\n       (\\<And>gpv res.\n           ord_spmf (=)\n            (map_spmf (map_prod Some obsf_resource) (exec_gpv gpv res))\n            (exec_gpv1 run_resource\n              (map_gpv' id id option_of_exception (gpv_stop gpv))\n              (obsf_resource res) \\<upharpoonleft>\n             {(Some x, y) |x y. True})) \\<Longrightarrow>\n       ord_spmf (=)\n        (map_spmf (map_prod Some obsf_resource)\n          (bind_spmf (the_gpv gpv)\n            (case_generat (\\<lambda>x. return_spmf (x, res))\n              (\\<lambda>out c.\n                  bind_spmf (run_resource res out)\n                   (\\<lambda>(x, y). exec_gpv (c x) y)))))\n        (exec_gpv1 run_resource\n          (map_gpv' id id option_of_exception (gpv_stop gpv))\n          (obsf_resource res) \\<upharpoonleft>\n         {(Some x, y) |x y. True})", "case (step exec_gpv')"], ["proof (state)\nthis:\n  ord_spmf (=)\n   (map_spmf (map_prod Some obsf_resource) (exec_gpv' ?gpv ?res))\n   (exec_gpv1 run_resource\n     (map_gpv' id id option_of_exception (gpv_stop ?gpv))\n     (obsf_resource ?res) \\<upharpoonleft>\n    {(Some x, y) |x y. True})\n\ngoal (1 subgoal):\n 1. \\<And>exec_gpv gpv res.\n       (\\<And>gpv res.\n           ord_spmf (=)\n            (map_spmf (map_prod Some obsf_resource) (exec_gpv gpv res))\n            (exec_gpv1 run_resource\n              (map_gpv' id id option_of_exception (gpv_stop gpv))\n              (obsf_resource res) \\<upharpoonleft>\n             {(Some x, y) |x y. True})) \\<Longrightarrow>\n       ord_spmf (=)\n        (map_spmf (map_prod Some obsf_resource)\n          (bind_spmf (the_gpv gpv)\n            (case_generat (\\<lambda>x. return_spmf (x, res))\n              (\\<lambda>out c.\n                  bind_spmf (run_resource res out)\n                   (\\<lambda>(x, y). exec_gpv (c x) y)))))\n        (exec_gpv1 run_resource\n          (map_gpv' id id option_of_exception (gpv_stop gpv))\n          (obsf_resource res) \\<upharpoonleft>\n         {(Some x, y) |x y. True})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (map_spmf (map_prod Some obsf_resource)\n       (bind_spmf (the_gpv gpv)\n         (case_generat (\\<lambda>x. return_spmf (x, res))\n           (\\<lambda>out c.\n               bind_spmf (run_resource res out)\n                (\\<lambda>(x, y). exec_gpv' (c x) y)))))\n     (exec_gpv1 run_resource\n       (map_gpv' id id option_of_exception (gpv_stop gpv))\n       (obsf_resource res) \\<upharpoonleft>\n      {(Some x, y) |x y. True})", "unfolding exec_gpv1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (map_spmf (map_prod Some obsf_resource)\n       (bind_spmf (the_gpv gpv)\n         (case_generat (\\<lambda>x. return_spmf (x, res))\n           (\\<lambda>out c.\n               bind_spmf (run_resource res out)\n                (\\<lambda>(x, y). exec_gpv' (c x) y)))))\n     (exec_gpv run_resource\n       (map_gpv' id id option_of_exception (gpv_stop gpv))\n       (obsf_resource res) \\<upharpoonleft>\n      {(Some x, y) |x y. True})", "apply(subst exec_gpv.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (map_spmf (map_prod Some obsf_resource)\n       (bind_spmf (the_gpv gpv)\n         (case_generat (\\<lambda>x. return_spmf (x, res))\n           (\\<lambda>out c.\n               bind_spmf (run_resource res out)\n                (\\<lambda>(x, y). exec_gpv' (c x) y)))))\n     (bind_spmf\n       (the_gpv (map_gpv' id id option_of_exception (gpv_stop gpv)))\n       (case_generat (\\<lambda>x. return_spmf (x, obsf_resource res))\n         (\\<lambda>out c.\n             bind_spmf (run_resource (obsf_resource res) out)\n              (\\<lambda>(x, y).\n                  exec_gpv run_resource (c x) y))) \\<upharpoonleft>\n      {(Some x, y) |x y. True})", "apply(clarsimp simp add: bind_map_spmf map_bind_spmf restrict_bind_spmf o_def try_spmf_def intro!: ord_spmf_bind_reflI split!: generat.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21a x22a.\n       IO x21a x22a \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n       ord_spmf (=)\n        (bind_spmf (run_resource res x21a)\n          (\\<lambda>x.\n              map_spmf (map_prod Some obsf_resource)\n               (case x of (x, xa) \\<Rightarrow> exec_gpv' (x22a x) xa)))\n        (bind_spmf\n          (bind_pmf\n            (map_spmf (map_prod OK obsf_resource) (run_resource res x21a))\n            (case_option (return_spmf (Fault, const_resource Fault))\n              return_spmf))\n          (\\<lambda>x.\n              (case x of\n               (x, xa) \\<Rightarrow>\n                 exec_gpv run_resource\n                  (map_gpv' id id option_of_exception\n                    (case x of Fault \\<Rightarrow> Done None\n                     | OK input' \\<Rightarrow> gpv_stop (x22a input')))\n                  xa) \\<upharpoonleft>\n              {uu_. \\<exists>x y. uu_ = (Some x, y)}))", "apply(clarsimp simp add: bind_spmf_def bind_assoc_pmf bind_map_pmf map_bind_pmf bind_return_pmf id_def step.IH[simplified, simplified id_def exec_gpv1_def] intro!: rel_pmf_bind_reflI split!: option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ord_spmf (=)\n   (map_spmf (map_prod Some obsf_resource)\n     (bind_spmf (the_gpv gpv)\n       (case_generat (\\<lambda>x. return_spmf (x, res))\n         (\\<lambda>out c.\n             bind_spmf (run_resource res out)\n              (\\<lambda>(x, y). exec_gpv' (c x) y)))))\n   (exec_gpv1 run_resource\n     (map_gpv' id id option_of_exception (gpv_stop gpv))\n     (obsf_resource res) \\<upharpoonleft>\n    {(Some x, y) |x y. True})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ord_spmf (=)\n   (map_spmf (map_prod Some obsf_resource) (exec_gpv2 run_resource gpv res))\n   (exec_gpv1 run_resource\n     (map_gpv' id id option_of_exception (gpv_stop gpv))\n     (obsf_resource res) \\<upharpoonleft>\n    {(Some x, y) |x y. True})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma obsf_attach: \n  assumes pfinite: \"pfinite_converter \\<I> \\<I>' conv\"\n    and WT: \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\"\n    and WT_resource: \"\\<I>' \\<turnstile>res res \\<surd>\"\n  shows \"outs_\\<I> \\<I> \\<turnstile>\\<^sub>R attach (obsf_converter conv) (obsf_resource res) \\<sim> obsf_resource (attach conv res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outs_\\<I> \\<I> \\<turnstile>\\<^sub>R\n    obsf_converter conv \\<rhd> obsf_resource res \\<sim>\n    obsf_resource (conv \\<rhd> res)", "using assms"], ["proof (prove)\nusing this:\n  pfinite_converter \\<I> \\<I>' conv\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\n  \\<I>' \\<turnstile>res res \\<surd>\n\ngoal (1 subgoal):\n 1. outs_\\<I> \\<I> \\<turnstile>\\<^sub>R\n    obsf_converter conv \\<rhd> obsf_resource res \\<sim>\n    obsf_resource (conv \\<rhd> res)", "proof(coinduction arbitrary: conv res)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a conv resa.\n       \\<lbrakk>pfinite_converter \\<I> \\<I>' conv;\n        \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>;\n        \\<I>' \\<turnstile>res resa \\<surd>; a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (rel_prod (=)\n                            (\\<lambda>res res'.\n                                (\\<exists>conv resa.\n                                    res =\n                                    obsf_converter conv \\<rhd>\n                                    obsf_resource resa \\<and>\n                                    res' =\n                                    obsf_resource (conv \\<rhd> resa) \\<and>\n                                    pfinite_converter \\<I> \\<I>' conv \\<and>\n                                    \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                    conv \\<surd> \\<and> \\<I>' \n                                    \\<turnstile>res resa \\<surd>) \\<or>\n                                outs_\\<I> \\<I> \\<turnstile>\\<^sub>R\n                                res \\<sim> res'))\n                          (run_resource\n                            (obsf_converter conv \\<rhd> obsf_resource resa)\n                            a)\n                          (run_resource (obsf_resource (conv \\<rhd> resa))\n                            a)", "case (eq_resource_on out conv res)"], ["proof (state)\nthis:\n  pfinite_converter \\<I> \\<I>' conv\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\n  \\<I>' \\<turnstile>res res \\<surd>\n  out \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. \\<And>a conv resa.\n       \\<lbrakk>pfinite_converter \\<I> \\<I>' conv;\n        \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>;\n        \\<I>' \\<turnstile>res resa \\<surd>; a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (rel_prod (=)\n                            (\\<lambda>res res'.\n                                (\\<exists>conv resa.\n                                    res =\n                                    obsf_converter conv \\<rhd>\n                                    obsf_resource resa \\<and>\n                                    res' =\n                                    obsf_resource (conv \\<rhd> resa) \\<and>\n                                    pfinite_converter \\<I> \\<I>' conv \\<and>\n                                    \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                    conv \\<surd> \\<and> \\<I>' \n                                    \\<turnstile>res resa \\<surd>) \\<or>\n                                outs_\\<I> \\<I> \\<turnstile>\\<^sub>R\n                                res \\<sim> res'))\n                          (run_resource\n                            (obsf_converter conv \\<rhd> obsf_resource resa)\n                            a)\n                          (run_resource (obsf_resource (conv \\<rhd> resa))\n                            a)", "then"], ["proof (chain)\npicking this:\n  pfinite_converter \\<I> \\<I>' conv\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\n  \\<I>' \\<turnstile>res res \\<surd>\n  out \\<in> outs_\\<I> \\<I>", "show ?case (is \"rel_spmf ?X ?lhs ?rhs\")"], ["proof (prove)\nusing this:\n  pfinite_converter \\<I> \\<I>' conv\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\n  \\<I>' \\<turnstile>res res \\<surd>\n  out \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_prod (=)\n       (\\<lambda>res res'.\n           (\\<exists>conv resa.\n               res = obsf_converter conv \\<rhd> obsf_resource resa \\<and>\n               res' = obsf_resource (conv \\<rhd> resa) \\<and>\n               pfinite_converter \\<I> \\<I>' conv \\<and>\n               \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd> \\<and> \\<I>' \n               \\<turnstile>res resa \\<surd>) \\<or>\n           outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim> res'))\n     (run_resource (obsf_converter conv \\<rhd> obsf_resource res) out)\n     (run_resource (obsf_resource (conv \\<rhd> res)) out)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>pfinite_converter \\<I> \\<I>' conv;\n     \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>;\n     \\<I>' \\<turnstile>res res \\<surd>; out \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> rel_spmf\n                       (rel_prod (=)\n                         (\\<lambda>res res'.\n                             (\\<exists>conv resa.\n                                 res =\n                                 obsf_converter conv \\<rhd>\n                                 obsf_resource resa \\<and>\n                                 res' =\n                                 obsf_resource (conv \\<rhd> resa) \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv \\<surd> \\<and> \\<I>' \n                                 \\<turnstile>res resa \\<surd>) \\<or>\n                             outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim>\n                             res'))\n                       (run_resource\n                         (obsf_converter conv \\<rhd> obsf_resource res) out)\n                       (run_resource (obsf_resource (conv \\<rhd> res)) out)", "have \"?lhs = map_spmf (\\<lambda>((b, conv'), res'). (b, conv' \\<rhd> res'))\n     (exec_gpv run_resource\n       (TRY map_gpv' (case_option (Fault, const_converter Fault) (\\<lambda>(x, conv'). (OK x, obsf_converter conv'))) id option_of_exception (gpv_stop (run_converter conv out)) ELSE Done (Fault, const_converter Fault))\n       (obsf_resource res))\"\n      (is \"_ = map_spmf ?attach (exec_gpv _ (TRY ?gpv ELSE _) _)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. run_resource (obsf_converter conv \\<rhd> obsf_resource res) out =\n    map_spmf (\\<lambda>((b, conv'), res'). (b, conv' \\<rhd> res'))\n     (exec_gpv run_resource\n       (TRY map_gpv'\n             (case_option (Fault, const_converter Fault)\n               (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n             id option_of_exception\n             (gpv_stop\n               (run_converter conv\n                 out)) ELSE Done (Fault, const_converter Fault))\n       (obsf_resource res))", "by(clarsimp)"], ["proof (state)\nthis:\n  run_resource (obsf_converter conv \\<rhd> obsf_resource res) out =\n  map_spmf (\\<lambda>((b, conv'), res'). (b, conv' \\<rhd> res'))\n   (exec_gpv run_resource\n     (TRY map_gpv'\n           (case_option (Fault, const_converter Fault)\n             (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n           id option_of_exception\n           (gpv_stop\n             (run_converter conv\n               out)) ELSE Done (Fault, const_converter Fault))\n     (obsf_resource res))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>pfinite_converter \\<I> \\<I>' conv;\n     \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>;\n     \\<I>' \\<turnstile>res res \\<surd>; out \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> rel_spmf\n                       (rel_prod (=)\n                         (\\<lambda>res res'.\n                             (\\<exists>conv resa.\n                                 res =\n                                 obsf_converter conv \\<rhd>\n                                 obsf_resource resa \\<and>\n                                 res' =\n                                 obsf_resource (conv \\<rhd> resa) \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv \\<surd> \\<and> \\<I>' \n                                 \\<turnstile>res resa \\<surd>) \\<or>\n                             outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim>\n                             res'))\n                       (run_resource\n                         (obsf_converter conv \\<rhd> obsf_resource res) out)\n                       (run_resource (obsf_resource (conv \\<rhd> res)) out)", "also"], ["proof (state)\nthis:\n  run_resource (obsf_converter conv \\<rhd> obsf_resource res) out =\n  map_spmf (\\<lambda>((b, conv'), res'). (b, conv' \\<rhd> res'))\n   (exec_gpv run_resource\n     (TRY map_gpv'\n           (case_option (Fault, const_converter Fault)\n             (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n           id option_of_exception\n           (gpv_stop\n             (run_converter conv\n               out)) ELSE Done (Fault, const_converter Fault))\n     (obsf_resource res))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>pfinite_converter \\<I> \\<I>' conv;\n     \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>;\n     \\<I>' \\<turnstile>res res \\<surd>; out \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> rel_spmf\n                       (rel_prod (=)\n                         (\\<lambda>res res'.\n                             (\\<exists>conv resa.\n                                 res =\n                                 obsf_converter conv \\<rhd>\n                                 obsf_resource resa \\<and>\n                                 res' =\n                                 obsf_resource (conv \\<rhd> resa) \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv \\<surd> \\<and> \\<I>' \n                                 \\<turnstile>res resa \\<surd>) \\<or>\n                             outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim>\n                             res'))\n                       (run_resource\n                         (obsf_converter conv \\<rhd> obsf_resource res) out)\n                       (run_resource (obsf_resource (conv \\<rhd> res)) out)", "have \"\\<dots> =  TRY map_spmf ?attach (exec_gpv run_resource ?gpv (obsf_resource res)) ELSE return_spmf (Fault, const_resource Fault)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>((b, conv'), res'). (b, conv' \\<rhd> res'))\n     (exec_gpv run_resource\n       (TRY map_gpv'\n             (case_option (Fault, const_converter Fault)\n               (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n             id option_of_exception\n             (gpv_stop\n               (run_converter conv\n                 out)) ELSE Done (Fault, const_converter Fault))\n       (obsf_resource res)) =\n    TRY map_spmf (\\<lambda>((b, conv'), res'). (b, conv' \\<rhd> res'))\n         (exec_gpv run_resource\n           (map_gpv'\n             (case_option (Fault, const_converter Fault)\n               (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n             id option_of_exception (gpv_stop (run_converter conv out)))\n           (obsf_resource\n             res)) ELSE return_spmf (Fault, const_resource Fault)", "by(rule run_lossless_resource.exec_gpv_try_gpv[where \\<I>=\"exception_\\<I> \\<I>'\"])\n        (use eq_resource_on in \\<open>auto intro!: WT_gpv_map_gpv' WT_gpv_stop pfinite_gpv_stop[THEN iffD2] dest: WT_converterD pfinite_converterD lossless_resourceD\\<close>)"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>((b, conv'), res'). (b, conv' \\<rhd> res'))\n   (exec_gpv run_resource\n     (TRY map_gpv'\n           (case_option (Fault, const_converter Fault)\n             (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n           id option_of_exception\n           (gpv_stop\n             (run_converter conv\n               out)) ELSE Done (Fault, const_converter Fault))\n     (obsf_resource res)) =\n  TRY map_spmf (\\<lambda>((b, conv'), res'). (b, conv' \\<rhd> res'))\n       (exec_gpv run_resource\n         (map_gpv'\n           (case_option (Fault, const_converter Fault)\n             (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n           id option_of_exception (gpv_stop (run_converter conv out)))\n         (obsf_resource res)) ELSE return_spmf (Fault, const_resource Fault)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>pfinite_converter \\<I> \\<I>' conv;\n     \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>;\n     \\<I>' \\<turnstile>res res \\<surd>; out \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> rel_spmf\n                       (rel_prod (=)\n                         (\\<lambda>res res'.\n                             (\\<exists>conv resa.\n                                 res =\n                                 obsf_converter conv \\<rhd>\n                                 obsf_resource resa \\<and>\n                                 res' =\n                                 obsf_resource (conv \\<rhd> resa) \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv \\<surd> \\<and> \\<I>' \n                                 \\<turnstile>res resa \\<surd>) \\<or>\n                             outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim>\n                             res'))\n                       (run_resource\n                         (obsf_converter conv \\<rhd> obsf_resource res) out)\n                       (run_resource (obsf_resource (conv \\<rhd> res)) out)", "also"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>((b, conv'), res'). (b, conv' \\<rhd> res'))\n   (exec_gpv run_resource\n     (TRY map_gpv'\n           (case_option (Fault, const_converter Fault)\n             (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n           id option_of_exception\n           (gpv_stop\n             (run_converter conv\n               out)) ELSE Done (Fault, const_converter Fault))\n     (obsf_resource res)) =\n  TRY map_spmf (\\<lambda>((b, conv'), res'). (b, conv' \\<rhd> res'))\n       (exec_gpv run_resource\n         (map_gpv'\n           (case_option (Fault, const_converter Fault)\n             (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n           id option_of_exception (gpv_stop (run_converter conv out)))\n         (obsf_resource res)) ELSE return_spmf (Fault, const_resource Fault)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>pfinite_converter \\<I> \\<I>' conv;\n     \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>;\n     \\<I>' \\<turnstile>res res \\<surd>; out \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> rel_spmf\n                       (rel_prod (=)\n                         (\\<lambda>res res'.\n                             (\\<exists>conv resa.\n                                 res =\n                                 obsf_converter conv \\<rhd>\n                                 obsf_resource resa \\<and>\n                                 res' =\n                                 obsf_resource (conv \\<rhd> resa) \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv \\<surd> \\<and> \\<I>' \n                                 \\<turnstile>res resa \\<surd>) \\<or>\n                             outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim>\n                             res'))\n                       (run_resource\n                         (obsf_converter conv \\<rhd> obsf_resource res) out)\n                       (run_resource (obsf_resource (conv \\<rhd> res)) out)", "have \"\\<dots> = TRY map_spmf (\\<lambda>(rc, res'). case rc of None \\<Rightarrow> (Fault, const_resource Fault) | Some (x, conv') \\<Rightarrow> (OK x, obsf_converter conv' \\<rhd> res'))\n            ((exec_gpv run_resource (map_gpv' id id option_of_exception (gpv_stop (run_converter conv out))) (obsf_resource res)) \\<upharpoonleft> {(Some x, y)|x y. True}) \n               ELSE return_spmf (Fault, const_resource Fault)\" (is \"_ = TRY map_spmf ?f _ ELSE ?z\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY map_spmf (\\<lambda>((b, conv'), res'). (b, conv' \\<rhd> res'))\n         (exec_gpv run_resource\n           (map_gpv'\n             (case_option (Fault, const_converter Fault)\n               (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n             id option_of_exception (gpv_stop (run_converter conv out)))\n           (obsf_resource\n             res)) ELSE return_spmf (Fault, const_resource Fault) =\n    TRY map_spmf\n         (\\<lambda>(rc, res').\n             case rc of None \\<Rightarrow> (Fault, const_resource Fault)\n             | Some (x, conv') \\<Rightarrow>\n                 (OK x, obsf_converter conv' \\<rhd> res'))\n         (exec_gpv run_resource\n           (map_gpv' id id option_of_exception\n             (gpv_stop (run_converter conv out)))\n           (obsf_resource res) \\<upharpoonleft>\n          {(Some x, y) |x y.\n           True}) ELSE return_spmf (Fault, const_resource Fault)", "by(subst map_gpv'_id12)(clarsimp simp add: map_gpv'_map_gpv_swap exec_gpv_map_gpv_id try_spmf_def restrict_spmf_def bind_map_pmf intro!: bind_pmf_cong[OF refl] split: option.split)"], ["proof (state)\nthis:\n  TRY map_spmf (\\<lambda>((b, conv'), res'). (b, conv' \\<rhd> res'))\n       (exec_gpv run_resource\n         (map_gpv'\n           (case_option (Fault, const_converter Fault)\n             (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n           id option_of_exception (gpv_stop (run_converter conv out)))\n         (obsf_resource\n           res)) ELSE return_spmf (Fault, const_resource Fault) =\n  TRY map_spmf\n       (\\<lambda>(rc, res').\n           case rc of None \\<Rightarrow> (Fault, const_resource Fault)\n           | Some (x, conv') \\<Rightarrow>\n               (OK x, obsf_converter conv' \\<rhd> res'))\n       (exec_gpv run_resource\n         (map_gpv' id id option_of_exception\n           (gpv_stop (run_converter conv out)))\n         (obsf_resource res) \\<upharpoonleft>\n        {(Some x, y) |x y.\n         True}) ELSE return_spmf (Fault, const_resource Fault)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>pfinite_converter \\<I> \\<I>' conv;\n     \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>;\n     \\<I>' \\<turnstile>res res \\<surd>; out \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> rel_spmf\n                       (rel_prod (=)\n                         (\\<lambda>res res'.\n                             (\\<exists>conv resa.\n                                 res =\n                                 obsf_converter conv \\<rhd>\n                                 obsf_resource resa \\<and>\n                                 res' =\n                                 obsf_resource (conv \\<rhd> resa) \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv \\<surd> \\<and> \\<I>' \n                                 \\<turnstile>res resa \\<surd>) \\<or>\n                             outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim>\n                             res'))\n                       (run_resource\n                         (obsf_converter conv \\<rhd> obsf_resource res) out)\n                       (run_resource (obsf_resource (conv \\<rhd> res)) out)", "also"], ["proof (state)\nthis:\n  TRY map_spmf (\\<lambda>((b, conv'), res'). (b, conv' \\<rhd> res'))\n       (exec_gpv run_resource\n         (map_gpv'\n           (case_option (Fault, const_converter Fault)\n             (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n           id option_of_exception (gpv_stop (run_converter conv out)))\n         (obsf_resource\n           res)) ELSE return_spmf (Fault, const_resource Fault) =\n  TRY map_spmf\n       (\\<lambda>(rc, res').\n           case rc of None \\<Rightarrow> (Fault, const_resource Fault)\n           | Some (x, conv') \\<Rightarrow>\n               (OK x, obsf_converter conv' \\<rhd> res'))\n       (exec_gpv run_resource\n         (map_gpv' id id option_of_exception\n           (gpv_stop (run_converter conv out)))\n         (obsf_resource res) \\<upharpoonleft>\n        {(Some x, y) |x y.\n         True}) ELSE return_spmf (Fault, const_resource Fault)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>pfinite_converter \\<I> \\<I>' conv;\n     \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>;\n     \\<I>' \\<turnstile>res res \\<surd>; out \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> rel_spmf\n                       (rel_prod (=)\n                         (\\<lambda>res res'.\n                             (\\<exists>conv resa.\n                                 res =\n                                 obsf_converter conv \\<rhd>\n                                 obsf_resource resa \\<and>\n                                 res' =\n                                 obsf_resource (conv \\<rhd> resa) \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv \\<surd> \\<and> \\<I>' \n                                 \\<turnstile>res resa \\<surd>) \\<or>\n                             outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim>\n                             res'))\n                       (run_resource\n                         (obsf_converter conv \\<rhd> obsf_resource res) out)\n                       (run_resource (obsf_resource (conv \\<rhd> res)) out)", "have \"\\<dots> = TRY map_spmf ?f (map_spmf (map_prod Some obsf_resource) (exec_gpv run_resource (run_converter conv out) res)) ELSE ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY map_spmf\n         (\\<lambda>(rc, res').\n             case rc of None \\<Rightarrow> (Fault, const_resource Fault)\n             | Some (x, conv') \\<Rightarrow>\n                 (OK x, obsf_converter conv' \\<rhd> res'))\n         (exec_gpv run_resource\n           (map_gpv' id id option_of_exception\n             (gpv_stop (run_converter conv out)))\n           (obsf_resource res) \\<upharpoonleft>\n          {(Some x, y) |x y.\n           True}) ELSE return_spmf (Fault, const_resource Fault) =\n    TRY map_spmf\n         (\\<lambda>(rc, res').\n             case rc of None \\<Rightarrow> (Fault, const_resource Fault)\n             | Some (x, conv') \\<Rightarrow>\n                 (OK x, obsf_converter conv' \\<rhd> res'))\n         (map_spmf (map_prod Some obsf_resource)\n           (exec_gpv run_resource (run_converter conv out)\n             res)) ELSE return_spmf (Fault, const_resource Fault)", "by(simp only: exec_gpv_obsf_resource)"], ["proof (state)\nthis:\n  TRY map_spmf\n       (\\<lambda>(rc, res').\n           case rc of None \\<Rightarrow> (Fault, const_resource Fault)\n           | Some (x, conv') \\<Rightarrow>\n               (OK x, obsf_converter conv' \\<rhd> res'))\n       (exec_gpv run_resource\n         (map_gpv' id id option_of_exception\n           (gpv_stop (run_converter conv out)))\n         (obsf_resource res) \\<upharpoonleft>\n        {(Some x, y) |x y.\n         True}) ELSE return_spmf (Fault, const_resource Fault) =\n  TRY map_spmf\n       (\\<lambda>(rc, res').\n           case rc of None \\<Rightarrow> (Fault, const_resource Fault)\n           | Some (x, conv') \\<Rightarrow>\n               (OK x, obsf_converter conv' \\<rhd> res'))\n       (map_spmf (map_prod Some obsf_resource)\n         (exec_gpv run_resource (run_converter conv out)\n           res)) ELSE return_spmf (Fault, const_resource Fault)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>pfinite_converter \\<I> \\<I>' conv;\n     \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>;\n     \\<I>' \\<turnstile>res res \\<surd>; out \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> rel_spmf\n                       (rel_prod (=)\n                         (\\<lambda>res res'.\n                             (\\<exists>conv resa.\n                                 res =\n                                 obsf_converter conv \\<rhd>\n                                 obsf_resource resa \\<and>\n                                 res' =\n                                 obsf_resource (conv \\<rhd> resa) \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv \\<surd> \\<and> \\<I>' \n                                 \\<turnstile>res resa \\<surd>) \\<or>\n                             outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim>\n                             res'))\n                       (run_resource\n                         (obsf_converter conv \\<rhd> obsf_resource res) out)\n                       (run_resource (obsf_resource (conv \\<rhd> res)) out)", "also"], ["proof (state)\nthis:\n  TRY map_spmf\n       (\\<lambda>(rc, res').\n           case rc of None \\<Rightarrow> (Fault, const_resource Fault)\n           | Some (x, conv') \\<Rightarrow>\n               (OK x, obsf_converter conv' \\<rhd> res'))\n       (exec_gpv run_resource\n         (map_gpv' id id option_of_exception\n           (gpv_stop (run_converter conv out)))\n         (obsf_resource res) \\<upharpoonleft>\n        {(Some x, y) |x y.\n         True}) ELSE return_spmf (Fault, const_resource Fault) =\n  TRY map_spmf\n       (\\<lambda>(rc, res').\n           case rc of None \\<Rightarrow> (Fault, const_resource Fault)\n           | Some (x, conv') \\<Rightarrow>\n               (OK x, obsf_converter conv' \\<rhd> res'))\n       (map_spmf (map_prod Some obsf_resource)\n         (exec_gpv run_resource (run_converter conv out)\n           res)) ELSE return_spmf (Fault, const_resource Fault)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>pfinite_converter \\<I> \\<I>' conv;\n     \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>;\n     \\<I>' \\<turnstile>res res \\<surd>; out \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> rel_spmf\n                       (rel_prod (=)\n                         (\\<lambda>res res'.\n                             (\\<exists>conv resa.\n                                 res =\n                                 obsf_converter conv \\<rhd>\n                                 obsf_resource resa \\<and>\n                                 res' =\n                                 obsf_resource (conv \\<rhd> resa) \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv \\<surd> \\<and> \\<I>' \n                                 \\<turnstile>res resa \\<surd>) \\<or>\n                             outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim>\n                             res'))\n                       (run_resource\n                         (obsf_converter conv \\<rhd> obsf_resource res) out)\n                       (run_resource (obsf_resource (conv \\<rhd> res)) out)", "have \"rel_spmf ?X \\<dots> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_prod (=)\n       (\\<lambda>res res'.\n           (\\<exists>conv resa.\n               res = obsf_converter conv \\<rhd> obsf_resource resa \\<and>\n               res' = obsf_resource (conv \\<rhd> resa) \\<and>\n               pfinite_converter \\<I> \\<I>' conv \\<and>\n               \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd> \\<and> \\<I>' \n               \\<turnstile>res resa \\<surd>) \\<or>\n           outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim> res'))\n     (TRY map_spmf\n           (\\<lambda>(rc, res').\n               case rc of None \\<Rightarrow> (Fault, const_resource Fault)\n               | Some (x, conv') \\<Rightarrow>\n                   (OK x, obsf_converter conv' \\<rhd> res'))\n           (map_spmf (map_prod Some obsf_resource)\n             (exec_gpv run_resource (run_converter conv out)\n               res)) ELSE return_spmf (Fault, const_resource Fault))\n     (run_resource (obsf_resource (conv \\<rhd> res)) out)", "using eq_resource_on"], ["proof (prove)\nusing this:\n  pfinite_converter \\<I> \\<I>' conv\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\n  \\<I>' \\<turnstile>res res \\<surd>\n  out \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_prod (=)\n       (\\<lambda>res res'.\n           (\\<exists>conv resa.\n               res = obsf_converter conv \\<rhd> obsf_resource resa \\<and>\n               res' = obsf_resource (conv \\<rhd> resa) \\<and>\n               pfinite_converter \\<I> \\<I>' conv \\<and>\n               \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd> \\<and> \\<I>' \n               \\<turnstile>res resa \\<surd>) \\<or>\n           outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim> res'))\n     (TRY map_spmf\n           (\\<lambda>(rc, res').\n               case rc of None \\<Rightarrow> (Fault, const_resource Fault)\n               | Some (x, conv') \\<Rightarrow>\n                   (OK x, obsf_converter conv' \\<rhd> res'))\n           (map_spmf (map_prod Some obsf_resource)\n             (exec_gpv run_resource (run_converter conv out)\n               res)) ELSE return_spmf (Fault, const_resource Fault))\n     (run_resource (obsf_resource (conv \\<rhd> res)) out)", "by(auto simp add: spmf.map_comp o_def spmf_rel_map intro!: rel_spmf_try_spmf rel_spmf_reflI)\n        (auto intro!: exI dest: run_resource.in_set_spmf_exec_gpv_into_results_gpv WT_converterD pfinite_converterD run_resource.exec_gpv_invariant)"], ["proof (state)\nthis:\n  rel_spmf\n   (rel_prod (=)\n     (\\<lambda>res res'.\n         (\\<exists>conv resa.\n             res = obsf_converter conv \\<rhd> obsf_resource resa \\<and>\n             res' = obsf_resource (conv \\<rhd> resa) \\<and>\n             pfinite_converter \\<I> \\<I>' conv \\<and>\n             \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd> \\<and> \\<I>' \n             \\<turnstile>res resa \\<surd>) \\<or>\n         outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim> res'))\n   (TRY map_spmf\n         (\\<lambda>(rc, res').\n             case rc of None \\<Rightarrow> (Fault, const_resource Fault)\n             | Some (x, conv') \\<Rightarrow>\n                 (OK x, obsf_converter conv' \\<rhd> res'))\n         (map_spmf (map_prod Some obsf_resource)\n           (exec_gpv run_resource (run_converter conv out)\n             res)) ELSE return_spmf (Fault, const_resource Fault))\n   (run_resource (obsf_resource (conv \\<rhd> res)) out)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>pfinite_converter \\<I> \\<I>' conv;\n     \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>;\n     \\<I>' \\<turnstile>res res \\<surd>; out \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> rel_spmf\n                       (rel_prod (=)\n                         (\\<lambda>res res'.\n                             (\\<exists>conv resa.\n                                 res =\n                                 obsf_converter conv \\<rhd>\n                                 obsf_resource resa \\<and>\n                                 res' =\n                                 obsf_resource (conv \\<rhd> resa) \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv \\<surd> \\<and> \\<I>' \n                                 \\<turnstile>res resa \\<surd>) \\<or>\n                             outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim>\n                             res'))\n                       (run_resource\n                         (obsf_converter conv \\<rhd> obsf_resource res) out)\n                       (run_resource (obsf_resource (conv \\<rhd> res)) out)", "finally"], ["proof (chain)\npicking this:\n  rel_spmf\n   (rel_prod (=)\n     (\\<lambda>res res'.\n         (\\<exists>conv resa.\n             res = obsf_converter conv \\<rhd> obsf_resource resa \\<and>\n             res' = obsf_resource (conv \\<rhd> resa) \\<and>\n             pfinite_converter \\<I> \\<I>' conv \\<and>\n             \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd> \\<and> \\<I>' \n             \\<turnstile>res resa \\<surd>) \\<or>\n         outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim> res'))\n   (run_resource (obsf_converter conv \\<rhd> obsf_resource res) out)\n   (run_resource (obsf_resource (conv \\<rhd> res)) out)", "show ?case"], ["proof (prove)\nusing this:\n  rel_spmf\n   (rel_prod (=)\n     (\\<lambda>res res'.\n         (\\<exists>conv resa.\n             res = obsf_converter conv \\<rhd> obsf_resource resa \\<and>\n             res' = obsf_resource (conv \\<rhd> resa) \\<and>\n             pfinite_converter \\<I> \\<I>' conv \\<and>\n             \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd> \\<and> \\<I>' \n             \\<turnstile>res resa \\<surd>) \\<or>\n         outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim> res'))\n   (run_resource (obsf_converter conv \\<rhd> obsf_resource res) out)\n   (run_resource (obsf_resource (conv \\<rhd> res)) out)\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_prod (=)\n       (\\<lambda>res res'.\n           (\\<exists>conv resa.\n               res = obsf_converter conv \\<rhd> obsf_resource resa \\<and>\n               res' = obsf_resource (conv \\<rhd> resa) \\<and>\n               pfinite_converter \\<I> \\<I>' conv \\<and>\n               \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd> \\<and> \\<I>' \n               \\<turnstile>res resa \\<surd>) \\<or>\n           outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim> res'))\n     (run_resource (obsf_converter conv \\<rhd> obsf_resource res) out)\n     (run_resource (obsf_resource (conv \\<rhd> res)) out)", "."], ["proof (state)\nthis:\n  rel_spmf\n   (rel_prod (=)\n     (\\<lambda>res res'.\n         (\\<exists>conv resa.\n             res = obsf_converter conv \\<rhd> obsf_resource resa \\<and>\n             res' = obsf_resource (conv \\<rhd> resa) \\<and>\n             pfinite_converter \\<I> \\<I>' conv \\<and>\n             \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd> \\<and> \\<I>' \n             \\<turnstile>res resa \\<surd>) \\<or>\n         outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim> res'))\n   (run_resource (obsf_converter conv \\<rhd> obsf_resource res) out)\n   (run_resource (obsf_resource (conv \\<rhd> res)) out)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_spmf\n   (rel_prod (=)\n     (\\<lambda>res res'.\n         (\\<exists>conv resa.\n             res = obsf_converter conv \\<rhd> obsf_resource resa \\<and>\n             res' = obsf_resource (conv \\<rhd> resa) \\<and>\n             pfinite_converter \\<I> \\<I>' conv \\<and>\n             \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd> \\<and> \\<I>' \n             \\<turnstile>res resa \\<surd>) \\<or>\n         outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<sim> res'))\n   (run_resource (obsf_converter conv \\<rhd> obsf_resource res) out)\n   (run_resource (obsf_resource (conv \\<rhd> res)) out)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma colossless_obsf_converter [simp]:\n  \"colossless_converter (exception_\\<I> \\<I>) \\<I>' (obsf_converter conv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. colossless_converter (exception_\\<I> \\<I>) \\<I>' (obsf_converter conv)", "by(coinduction arbitrary: conv)(auto split: option.split_asm)"], ["", "lemma WT_obsf_converter [WT_intro]:\n  \"exception_\\<I> \\<I>, exception_\\<I> \\<I>' \\<turnstile>\\<^sub>C obsf_converter conv \\<surd>\" if \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exception_\\<I> \\<I>, exception_\\<I> \\<I>' \\<turnstile>\\<^sub>C\n    obsf_converter conv \\<surd>", "using that"], ["proof (prove)\nusing this:\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\n\ngoal (1 subgoal):\n 1. exception_\\<I> \\<I>, exception_\\<I> \\<I>' \\<turnstile>\\<^sub>C\n    obsf_converter conv \\<surd>", "by(coinduction arbitrary: conv)(auto 4 3 dest: WT_converterD results_gpv_stop_SomeD split!: option.splits intro!: WT_intro)"], ["", "lemma inline1_gpv_stop_obsf_converter:\n  defines \"inline1a \\<equiv> inline1\"\n    and \"inline1b \\<equiv> inline1\"\n  shows \"bind_spmf (inline1a run_converter (map_gpv' id id option_of_exception (gpv_stop gpv)) (obsf_converter conv))\n     (\\<lambda>xy. case xy of Inl (None, conv') \\<Rightarrow> return_pmf None | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv')) | Inr y \\<Rightarrow> return_spmf (Inr y)) = \n   map_spmf (map_sum (apsnd obsf_converter)\n       (apsnd (map_prod (\\<lambda>rpv input. case input of Fault \\<Rightarrow> Done (Fault, const_converter Fault) | OK input' \\<Rightarrow> \n            map_gpv' (\\<lambda>res. case res of None \\<Rightarrow> (Fault, const_converter Fault) | Some (x, conv') \\<Rightarrow> (OK x, obsf_converter conv')) id option_of_exception (try_gpv (gpv_stop (rpv input')) (Done None))) \n     (\\<lambda>rpv input. case input of Fault \\<Rightarrow> Done None | OK input' \\<Rightarrow> map_gpv' id id option_of_exception (gpv_stop (rpv input'))))))\n    (inline1b run_converter gpv conv)\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_spmf\n     (inline1a run_converter\n       (map_gpv' id id option_of_exception (gpv_stop gpv))\n       (obsf_converter conv))\n     (\\<lambda>xy.\n         case xy of Inl (None, conv') \\<Rightarrow> return_pmf None\n         | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n         | Inr y \\<Rightarrow> return_spmf (Inr y)) =\n    map_spmf\n     (map_sum (apsnd obsf_converter)\n       (apsnd\n         (map_prod\n           (\\<lambda>rpv input.\n               case input of\n               Fault \\<Rightarrow> Done (Fault, const_converter Fault)\n               | OK input' \\<Rightarrow>\n                   map_gpv'\n                    (\\<lambda>res.\n                        case res of\n                        None \\<Rightarrow> (Fault, const_converter Fault)\n                        | Some (x, conv') \\<Rightarrow>\n                            (OK x, obsf_converter conv'))\n                    id option_of_exception\n                    (TRY gpv_stop (rpv input') ELSE Done None))\n           (\\<lambda>rpv input.\n               case input of Fault \\<Rightarrow> Done None\n               | OK input' \\<Rightarrow>\n                   map_gpv' id id option_of_exception\n                    (gpv_stop (rpv input'))))))\n     (inline1b run_converter gpv conv)", "proof(rule spmf.leq_antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. ord_spmf (=)\n     (bind_spmf\n       (inline1a run_converter\n         (map_gpv' id id option_of_exception (gpv_stop gpv))\n         (obsf_converter conv))\n       (\\<lambda>xy.\n           case xy of Inl (None, conv') \\<Rightarrow> return_pmf None\n           | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n           | Inr y \\<Rightarrow> return_spmf (Inr y)))\n     (map_spmf\n       (map_sum (apsnd obsf_converter)\n         (apsnd\n           (map_prod\n             (\\<lambda>rpv input.\n                 case input of\n                 Fault \\<Rightarrow> Done (Fault, const_converter Fault)\n                 | OK input' \\<Rightarrow>\n                     map_gpv'\n                      (\\<lambda>res.\n                          case res of\n                          None \\<Rightarrow> (Fault, const_converter Fault)\n                          | Some (x, conv') \\<Rightarrow>\n                              (OK x, obsf_converter conv'))\n                      id option_of_exception\n                      (TRY gpv_stop (rpv input') ELSE Done None))\n             (\\<lambda>rpv input.\n                 case input of Fault \\<Rightarrow> Done None\n                 | OK input' \\<Rightarrow>\n                     map_gpv' id id option_of_exception\n                      (gpv_stop (rpv input'))))))\n       (inline1b run_converter gpv conv))\n 2. ord_spmf (=)\n     (map_spmf\n       (map_sum (apsnd obsf_converter)\n         (apsnd\n           (map_prod\n             (\\<lambda>rpv input.\n                 case input of\n                 Fault \\<Rightarrow> Done (Fault, const_converter Fault)\n                 | OK input' \\<Rightarrow>\n                     map_gpv'\n                      (\\<lambda>res.\n                          case res of\n                          None \\<Rightarrow> (Fault, const_converter Fault)\n                          | Some (x, conv') \\<Rightarrow>\n                              (OK x, obsf_converter conv'))\n                      id option_of_exception\n                      (TRY gpv_stop (rpv input') ELSE Done None))\n             (\\<lambda>rpv input.\n                 case input of Fault \\<Rightarrow> Done None\n                 | OK input' \\<Rightarrow>\n                     map_gpv' id id option_of_exception\n                      (gpv_stop (rpv input'))))))\n       (inline1b run_converter gpv conv))\n     (bind_spmf\n       (inline1a run_converter\n         (map_gpv' id id option_of_exception (gpv_stop gpv))\n         (obsf_converter conv))\n       (\\<lambda>xy.\n           case xy of Inl (None, conv') \\<Rightarrow> return_pmf None\n           | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n           | Inr y \\<Rightarrow> return_spmf (Inr y)))", "show \"ord_spmf (=) ?lhs ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (bind_spmf\n       (inline1a run_converter\n         (map_gpv' id id option_of_exception (gpv_stop gpv))\n         (obsf_converter conv))\n       (\\<lambda>xy.\n           case xy of Inl (None, conv') \\<Rightarrow> return_pmf None\n           | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n           | Inr y \\<Rightarrow> return_spmf (Inr y)))\n     (map_spmf\n       (map_sum (apsnd obsf_converter)\n         (apsnd\n           (map_prod\n             (\\<lambda>rpv input.\n                 case input of\n                 Fault \\<Rightarrow> Done (Fault, const_converter Fault)\n                 | OK input' \\<Rightarrow>\n                     map_gpv'\n                      (\\<lambda>res.\n                          case res of\n                          None \\<Rightarrow> (Fault, const_converter Fault)\n                          | Some (x, conv') \\<Rightarrow>\n                              (OK x, obsf_converter conv'))\n                      id option_of_exception\n                      (TRY gpv_stop (rpv input') ELSE Done None))\n             (\\<lambda>rpv input.\n                 case input of Fault \\<Rightarrow> Done None\n                 | OK input' \\<Rightarrow>\n                     map_gpv' id id option_of_exception\n                      (gpv_stop (rpv input'))))))\n       (inline1b run_converter gpv conv))", "unfolding inline1a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (bind_spmf\n       (inline1 run_converter\n         (map_gpv' id id option_of_exception (gpv_stop gpv))\n         (obsf_converter conv))\n       (\\<lambda>xy.\n           case xy of Inl (None, conv') \\<Rightarrow> return_pmf None\n           | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n           | Inr y \\<Rightarrow> return_spmf (Inr y)))\n     (map_spmf\n       (map_sum (apsnd obsf_converter)\n         (apsnd\n           (map_prod\n             (\\<lambda>rpv input.\n                 case input of\n                 Fault \\<Rightarrow> Done (Fault, const_converter Fault)\n                 | OK input' \\<Rightarrow>\n                     map_gpv'\n                      (\\<lambda>res.\n                          case res of\n                          None \\<Rightarrow> (Fault, const_converter Fault)\n                          | Some (x, conv') \\<Rightarrow>\n                              (OK x, obsf_converter conv'))\n                      id option_of_exception\n                      (TRY gpv_stop (rpv input') ELSE Done None))\n             (\\<lambda>rpv input.\n                 case input of Fault \\<Rightarrow> Done None\n                 | OK input' \\<Rightarrow>\n                     map_gpv' id id option_of_exception\n                      (gpv_stop (rpv input'))))))\n       (inline1b run_converter gpv conv))", "proof(induction arbitrary: gpv conv rule: inline1_fixp_induct_strong)"], ["proof (state)\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>inline1'.\n         \\<forall>x xa.\n            ord_spmf (=)\n             (bind_spmf\n               (inline1'\n                 (map_gpv' id id option_of_exception (gpv_stop x),\n                  obsf_converter xa))\n               (case_sum\n                 (\\<lambda>(a, conv').\n                     case a of None \\<Rightarrow> return_pmf None\n                     | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n                 (\\<lambda>y. return_spmf (Inr y))))\n             (map_spmf\n               (map_sum (apsnd obsf_converter)\n                 (apsnd\n                   (map_prod\n                     (\\<lambda>rpv.\n                         case_exception\n                          (Done (Fault, const_converter Fault))\n                          (\\<lambda>input'.\n                              map_gpv'\n                               (case_option (Fault, const_converter Fault)\n                                 (\\<lambda>(x, conv').\n                                     (OK x, obsf_converter conv')))\n                               id option_of_exception\n                               (TRY gpv_stop (rpv input') ELSE Done None)))\n                     (\\<lambda>rpv.\n                         case_exception (Done None)\n                          (\\<lambda>input'.\n                              map_gpv' id id option_of_exception\n                               (gpv_stop (rpv input')))))))\n               (inline1b run_converter x xa)))\n 2. \\<And>gpv conv.\n       ord_spmf (=)\n        (bind_spmf (return_pmf None)\n          (case_sum\n            (\\<lambda>(a, conv').\n                case a of None \\<Rightarrow> return_pmf None\n                | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n            (\\<lambda>y. return_spmf (Inr y))))\n        (map_spmf\n          (map_sum (apsnd obsf_converter)\n            (apsnd\n              (map_prod\n                (\\<lambda>rpv.\n                    case_exception (Done (Fault, const_converter Fault))\n                     (\\<lambda>input'.\n                         map_gpv'\n                          (case_option (Fault, const_converter Fault)\n                            (\\<lambda>(x, conv').\n                                (OK x, obsf_converter conv')))\n                          id option_of_exception\n                          (TRY gpv_stop (rpv input') ELSE Done None)))\n                (\\<lambda>rpv.\n                    case_exception (Done None)\n                     (\\<lambda>input'.\n                         map_gpv' id id option_of_exception\n                          (gpv_stop (rpv input')))))))\n          (inline1b run_converter gpv conv))\n 3. \\<And>inline1' gpv conv.\n       \\<lbrakk>\\<And>gpv s.\n                   ord_spmf (=) (inline1' gpv s)\n                    (inline1 run_converter gpv s);\n        \\<And>gpv conv.\n           ord_spmf (=)\n            (bind_spmf\n              (inline1' (map_gpv' id id option_of_exception (gpv_stop gpv))\n                (obsf_converter conv))\n              (case_sum\n                (\\<lambda>(a, conv').\n                    case a of None \\<Rightarrow> return_pmf None\n                    | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n                (\\<lambda>y. return_spmf (Inr y))))\n            (map_spmf\n              (map_sum (apsnd obsf_converter)\n                (apsnd\n                  (map_prod\n                    (\\<lambda>rpv.\n                        case_exception (Done (Fault, const_converter Fault))\n                         (\\<lambda>input'.\n                             map_gpv'\n                              (case_option (Fault, const_converter Fault)\n                                (\\<lambda>(x, conv').\n                                    (OK x, obsf_converter conv')))\n                              id option_of_exception\n                              (TRY gpv_stop (rpv input') ELSE Done None)))\n                    (\\<lambda>rpv.\n                        case_exception (Done None)\n                         (\\<lambda>input'.\n                             map_gpv' id id option_of_exception\n                              (gpv_stop (rpv input')))))))\n              (inline1b run_converter gpv conv))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (bind_spmf\n                            (bind_spmf\n                              (the_gpv\n                                (map_gpv' id id option_of_exception\n                                  (gpv_stop gpv)))\n                              (case_generat\n                                (\\<lambda>x.\n                                    return_spmf\n                                     (Inl (x, obsf_converter conv)))\n                                (\\<lambda>out rpv.\n                                    bind_spmf\n                                     (the_gpv\n (run_converter (obsf_converter conv) out))\n                                     (case_generat\n (\\<lambda>(x, y). inline1' (rpv x) y)\n (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))))\n                            (case_sum\n                              (\\<lambda>(a, conv').\n                                  case a of\n                                  None \\<Rightarrow> return_pmf None\n                                  | Some x \\<Rightarrow>\nreturn_spmf (Inl (x, conv')))\n                              (\\<lambda>y. return_spmf (Inr y))))\n                          (map_spmf\n                            (map_sum (apsnd obsf_converter)\n                              (apsnd\n                                (map_prod\n                                  (\\<lambda>rpv.\ncase_exception (Done (Fault, const_converter Fault))\n (\\<lambda>input'.\n     map_gpv'\n      (case_option (Fault, const_converter Fault)\n        (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n      id option_of_exception (TRY gpv_stop (rpv input') ELSE Done None)))\n                                  (\\<lambda>rpv.\ncase_exception (Done None)\n (\\<lambda>input'.\n     map_gpv' id id option_of_exception (gpv_stop (rpv input')))))))\n                            (inline1b run_converter gpv conv))", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>inline1'.\n         \\<forall>x xa.\n            ord_spmf (=)\n             (bind_spmf\n               (inline1'\n                 (map_gpv' id id option_of_exception (gpv_stop x),\n                  obsf_converter xa))\n               (case_sum\n                 (\\<lambda>(a, conv').\n                     case a of None \\<Rightarrow> return_pmf None\n                     | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n                 (\\<lambda>y. return_spmf (Inr y))))\n             (map_spmf\n               (map_sum (apsnd obsf_converter)\n                 (apsnd\n                   (map_prod\n                     (\\<lambda>rpv.\n                         case_exception\n                          (Done (Fault, const_converter Fault))\n                          (\\<lambda>input'.\n                              map_gpv'\n                               (case_option (Fault, const_converter Fault)\n                                 (\\<lambda>(x, conv').\n                                     (OK x, obsf_converter conv')))\n                               id option_of_exception\n                               (TRY gpv_stop (rpv input') ELSE Done None)))\n                     (\\<lambda>rpv.\n                         case_exception (Done None)\n                          (\\<lambda>input'.\n                              map_gpv' id id option_of_exception\n                               (gpv_stop (rpv input')))))))\n               (inline1b run_converter x xa)))\n 2. \\<And>gpv conv.\n       ord_spmf (=)\n        (bind_spmf (return_pmf None)\n          (case_sum\n            (\\<lambda>(a, conv').\n                case a of None \\<Rightarrow> return_pmf None\n                | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n            (\\<lambda>y. return_spmf (Inr y))))\n        (map_spmf\n          (map_sum (apsnd obsf_converter)\n            (apsnd\n              (map_prod\n                (\\<lambda>rpv.\n                    case_exception (Done (Fault, const_converter Fault))\n                     (\\<lambda>input'.\n                         map_gpv'\n                          (case_option (Fault, const_converter Fault)\n                            (\\<lambda>(x, conv').\n                                (OK x, obsf_converter conv')))\n                          id option_of_exception\n                          (TRY gpv_stop (rpv input') ELSE Done None)))\n                (\\<lambda>rpv.\n                    case_exception (Done None)\n                     (\\<lambda>input'.\n                         map_gpv' id id option_of_exception\n                          (gpv_stop (rpv input')))))))\n          (inline1b run_converter gpv conv))\n 3. \\<And>inline1' gpv conv.\n       \\<lbrakk>\\<And>gpv s.\n                   ord_spmf (=) (inline1' gpv s)\n                    (inline1 run_converter gpv s);\n        \\<And>gpv conv.\n           ord_spmf (=)\n            (bind_spmf\n              (inline1' (map_gpv' id id option_of_exception (gpv_stop gpv))\n                (obsf_converter conv))\n              (case_sum\n                (\\<lambda>(a, conv').\n                    case a of None \\<Rightarrow> return_pmf None\n                    | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n                (\\<lambda>y. return_spmf (Inr y))))\n            (map_spmf\n              (map_sum (apsnd obsf_converter)\n                (apsnd\n                  (map_prod\n                    (\\<lambda>rpv.\n                        case_exception (Done (Fault, const_converter Fault))\n                         (\\<lambda>input'.\n                             map_gpv'\n                              (case_option (Fault, const_converter Fault)\n                                (\\<lambda>(x, conv').\n                                    (OK x, obsf_converter conv')))\n                              id option_of_exception\n                              (TRY gpv_stop (rpv input') ELSE Done None)))\n                    (\\<lambda>rpv.\n                        case_exception (Done None)\n                         (\\<lambda>input'.\n                             map_gpv' id id option_of_exception\n                              (gpv_stop (rpv input')))))))\n              (inline1b run_converter gpv conv))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (bind_spmf\n                            (bind_spmf\n                              (the_gpv\n                                (map_gpv' id id option_of_exception\n                                  (gpv_stop gpv)))\n                              (case_generat\n                                (\\<lambda>x.\n                                    return_spmf\n                                     (Inl (x, obsf_converter conv)))\n                                (\\<lambda>out rpv.\n                                    bind_spmf\n                                     (the_gpv\n (run_converter (obsf_converter conv) out))\n                                     (case_generat\n (\\<lambda>(x, y). inline1' (rpv x) y)\n (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))))\n                            (case_sum\n                              (\\<lambda>(a, conv').\n                                  case a of\n                                  None \\<Rightarrow> return_pmf None\n                                  | Some x \\<Rightarrow>\nreturn_spmf (Inl (x, conv')))\n                              (\\<lambda>y. return_spmf (Inr y))))\n                          (map_spmf\n                            (map_sum (apsnd obsf_converter)\n                              (apsnd\n                                (map_prod\n                                  (\\<lambda>rpv.\ncase_exception (Done (Fault, const_converter Fault))\n (\\<lambda>input'.\n     map_gpv'\n      (case_option (Fault, const_converter Fault)\n        (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n      id option_of_exception (TRY gpv_stop (rpv input') ELSE Done None)))\n                                  (\\<lambda>rpv.\ncase_exception (Done None)\n (\\<lambda>input'.\n     map_gpv' id id option_of_exception (gpv_stop (rpv input')))))))\n                            (inline1b run_converter gpv conv))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf.admissible\n     (\\<lambda>inline1'.\n         \\<forall>x xa.\n            ord_spmf (=)\n             (bind_spmf\n               (inline1'\n                 (map_gpv' id id option_of_exception (gpv_stop x),\n                  obsf_converter xa))\n               (\\<lambda>a.\n                   case a of Inl (None, conv') \\<Rightarrow> return_pmf None\n                   | Inl (Some x, conv') \\<Rightarrow>\n                       return_spmf (Inl (x, conv'))\n                   | Inr y \\<Rightarrow> return_spmf (Inr y)))\n             (map_spmf\n               (map_sum (apsnd obsf_converter)\n                 (apsnd\n                   (map_prod\n                     (\\<lambda>rpv a.\n                         case a of\n                         Fault \\<Rightarrow>\n                           Done (Fault, const_converter Fault)\n                         | OK input' \\<Rightarrow>\n                             map_gpv'\n                              (\\<lambda>a.\n                                  case a of\n                                  None \\<Rightarrow>\n                                    (Fault, const_converter Fault)\n                                  | Some (x, conv') \\<Rightarrow>\n(OK x, obsf_converter conv'))\n                              id option_of_exception\n                              (TRY gpv_stop (rpv input') ELSE Done None))\n                     (\\<lambda>rpv a.\n                         case a of Fault \\<Rightarrow> Done None\n                         | OK input' \\<Rightarrow>\n                             map_gpv' id id option_of_exception\n                              (gpv_stop (rpv input'))))))\n               (inline1b run_converter x xa)))", "by simp"], ["proof (state)\nthis:\n  spmf.admissible\n   (\\<lambda>inline1'.\n       \\<forall>x xa.\n          ord_spmf (=)\n           (bind_spmf\n             (inline1'\n               (map_gpv' id id option_of_exception (gpv_stop x),\n                obsf_converter xa))\n             (\\<lambda>a.\n                 case a of Inl (None, conv') \\<Rightarrow> return_pmf None\n                 | Inl (Some x, conv') \\<Rightarrow>\n                     return_spmf (Inl (x, conv'))\n                 | Inr y \\<Rightarrow> return_spmf (Inr y)))\n           (map_spmf\n             (map_sum (apsnd obsf_converter)\n               (apsnd\n                 (map_prod\n                   (\\<lambda>rpv a.\n                       case a of\n                       Fault \\<Rightarrow>\n                         Done (Fault, const_converter Fault)\n                       | OK input' \\<Rightarrow>\n                           map_gpv'\n                            (\\<lambda>a.\n                                case a of\n                                None \\<Rightarrow>\n                                  (Fault, const_converter Fault)\n                                | Some (x, conv') \\<Rightarrow>\n                                    (OK x, obsf_converter conv'))\n                            id option_of_exception\n                            (TRY gpv_stop (rpv input') ELSE Done None))\n                   (\\<lambda>rpv a.\n                       case a of Fault \\<Rightarrow> Done None\n                       | OK input' \\<Rightarrow>\n                           map_gpv' id id option_of_exception\n                            (gpv_stop (rpv input'))))))\n             (inline1b run_converter x xa)))\n\ngoal (2 subgoals):\n 1. \\<And>gpv conv.\n       ord_spmf (=)\n        (bind_spmf (return_pmf None)\n          (case_sum\n            (\\<lambda>(a, conv').\n                case a of None \\<Rightarrow> return_pmf None\n                | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n            (\\<lambda>y. return_spmf (Inr y))))\n        (map_spmf\n          (map_sum (apsnd obsf_converter)\n            (apsnd\n              (map_prod\n                (\\<lambda>rpv.\n                    case_exception (Done (Fault, const_converter Fault))\n                     (\\<lambda>input'.\n                         map_gpv'\n                          (case_option (Fault, const_converter Fault)\n                            (\\<lambda>(x, conv').\n                                (OK x, obsf_converter conv')))\n                          id option_of_exception\n                          (TRY gpv_stop (rpv input') ELSE Done None)))\n                (\\<lambda>rpv.\n                    case_exception (Done None)\n                     (\\<lambda>input'.\n                         map_gpv' id id option_of_exception\n                          (gpv_stop (rpv input')))))))\n          (inline1b run_converter gpv conv))\n 2. \\<And>inline1' gpv conv.\n       \\<lbrakk>\\<And>gpv s.\n                   ord_spmf (=) (inline1' gpv s)\n                    (inline1 run_converter gpv s);\n        \\<And>gpv conv.\n           ord_spmf (=)\n            (bind_spmf\n              (inline1' (map_gpv' id id option_of_exception (gpv_stop gpv))\n                (obsf_converter conv))\n              (case_sum\n                (\\<lambda>(a, conv').\n                    case a of None \\<Rightarrow> return_pmf None\n                    | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n                (\\<lambda>y. return_spmf (Inr y))))\n            (map_spmf\n              (map_sum (apsnd obsf_converter)\n                (apsnd\n                  (map_prod\n                    (\\<lambda>rpv.\n                        case_exception (Done (Fault, const_converter Fault))\n                         (\\<lambda>input'.\n                             map_gpv'\n                              (case_option (Fault, const_converter Fault)\n                                (\\<lambda>(x, conv').\n                                    (OK x, obsf_converter conv')))\n                              id option_of_exception\n                              (TRY gpv_stop (rpv input') ELSE Done None)))\n                    (\\<lambda>rpv.\n                        case_exception (Done None)\n                         (\\<lambda>input'.\n                             map_gpv' id id option_of_exception\n                              (gpv_stop (rpv input')))))))\n              (inline1b run_converter gpv conv))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (bind_spmf\n                            (bind_spmf\n                              (the_gpv\n                                (map_gpv' id id option_of_exception\n                                  (gpv_stop gpv)))\n                              (case_generat\n                                (\\<lambda>x.\n                                    return_spmf\n                                     (Inl (x, obsf_converter conv)))\n                                (\\<lambda>out rpv.\n                                    bind_spmf\n                                     (the_gpv\n (run_converter (obsf_converter conv) out))\n                                     (case_generat\n (\\<lambda>(x, y). inline1' (rpv x) y)\n (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))))\n                            (case_sum\n                              (\\<lambda>(a, conv').\n                                  case a of\n                                  None \\<Rightarrow> return_pmf None\n                                  | Some x \\<Rightarrow>\nreturn_spmf (Inl (x, conv')))\n                              (\\<lambda>y. return_spmf (Inr y))))\n                          (map_spmf\n                            (map_sum (apsnd obsf_converter)\n                              (apsnd\n                                (map_prod\n                                  (\\<lambda>rpv.\ncase_exception (Done (Fault, const_converter Fault))\n (\\<lambda>input'.\n     map_gpv'\n      (case_option (Fault, const_converter Fault)\n        (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n      id option_of_exception (TRY gpv_stop (rpv input') ELSE Done None)))\n                                  (\\<lambda>rpv.\ncase_exception (Done None)\n (\\<lambda>input'.\n     map_gpv' id id option_of_exception (gpv_stop (rpv input')))))))\n                            (inline1b run_converter gpv conv))", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>gpv conv.\n       ord_spmf (=)\n        (bind_spmf (return_pmf None)\n          (case_sum\n            (\\<lambda>(a, conv').\n                case a of None \\<Rightarrow> return_pmf None\n                | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n            (\\<lambda>y. return_spmf (Inr y))))\n        (map_spmf\n          (map_sum (apsnd obsf_converter)\n            (apsnd\n              (map_prod\n                (\\<lambda>rpv.\n                    case_exception (Done (Fault, const_converter Fault))\n                     (\\<lambda>input'.\n                         map_gpv'\n                          (case_option (Fault, const_converter Fault)\n                            (\\<lambda>(x, conv').\n                                (OK x, obsf_converter conv')))\n                          id option_of_exception\n                          (TRY gpv_stop (rpv input') ELSE Done None)))\n                (\\<lambda>rpv.\n                    case_exception (Done None)\n                     (\\<lambda>input'.\n                         map_gpv' id id option_of_exception\n                          (gpv_stop (rpv input')))))))\n          (inline1b run_converter gpv conv))\n 2. \\<And>inline1' gpv conv.\n       \\<lbrakk>\\<And>gpv s.\n                   ord_spmf (=) (inline1' gpv s)\n                    (inline1 run_converter gpv s);\n        \\<And>gpv conv.\n           ord_spmf (=)\n            (bind_spmf\n              (inline1' (map_gpv' id id option_of_exception (gpv_stop gpv))\n                (obsf_converter conv))\n              (case_sum\n                (\\<lambda>(a, conv').\n                    case a of None \\<Rightarrow> return_pmf None\n                    | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n                (\\<lambda>y. return_spmf (Inr y))))\n            (map_spmf\n              (map_sum (apsnd obsf_converter)\n                (apsnd\n                  (map_prod\n                    (\\<lambda>rpv.\n                        case_exception (Done (Fault, const_converter Fault))\n                         (\\<lambda>input'.\n                             map_gpv'\n                              (case_option (Fault, const_converter Fault)\n                                (\\<lambda>(x, conv').\n                                    (OK x, obsf_converter conv')))\n                              id option_of_exception\n                              (TRY gpv_stop (rpv input') ELSE Done None)))\n                    (\\<lambda>rpv.\n                        case_exception (Done None)\n                         (\\<lambda>input'.\n                             map_gpv' id id option_of_exception\n                              (gpv_stop (rpv input')))))))\n              (inline1b run_converter gpv conv))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (bind_spmf\n                            (bind_spmf\n                              (the_gpv\n                                (map_gpv' id id option_of_exception\n                                  (gpv_stop gpv)))\n                              (case_generat\n                                (\\<lambda>x.\n                                    return_spmf\n                                     (Inl (x, obsf_converter conv)))\n                                (\\<lambda>out rpv.\n                                    bind_spmf\n                                     (the_gpv\n (run_converter (obsf_converter conv) out))\n                                     (case_generat\n (\\<lambda>(x, y). inline1' (rpv x) y)\n (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))))\n                            (case_sum\n                              (\\<lambda>(a, conv').\n                                  case a of\n                                  None \\<Rightarrow> return_pmf None\n                                  | Some x \\<Rightarrow>\nreturn_spmf (Inl (x, conv')))\n                              (\\<lambda>y. return_spmf (Inr y))))\n                          (map_spmf\n                            (map_sum (apsnd obsf_converter)\n                              (apsnd\n                                (map_prod\n                                  (\\<lambda>rpv.\ncase_exception (Done (Fault, const_converter Fault))\n (\\<lambda>input'.\n     map_gpv'\n      (case_option (Fault, const_converter Fault)\n        (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n      id option_of_exception (TRY gpv_stop (rpv input') ELSE Done None)))\n                                  (\\<lambda>rpv.\ncase_exception (Done None)\n (\\<lambda>input'.\n     map_gpv' id id option_of_exception (gpv_stop (rpv input')))))))\n                            (inline1b run_converter gpv conv))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (bind_spmf (return_pmf None)\n       (\\<lambda>a.\n           case a of Inl (None, conv') \\<Rightarrow> return_pmf None\n           | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n           | Inr y \\<Rightarrow> return_spmf (Inr y)))\n     (map_spmf\n       (map_sum (apsnd obsf_converter)\n         (apsnd\n           (map_prod\n             (\\<lambda>rpv a.\n                 case a of\n                 Fault \\<Rightarrow> Done (Fault, const_converter Fault)\n                 | OK input' \\<Rightarrow>\n                     map_gpv'\n                      (\\<lambda>a.\n                          case a of\n                          None \\<Rightarrow> (Fault, const_converter Fault)\n                          | Some (x, conv') \\<Rightarrow>\n                              (OK x, obsf_converter conv'))\n                      id option_of_exception\n                      (TRY gpv_stop (rpv input') ELSE Done None))\n             (\\<lambda>rpv a.\n                 case a of Fault \\<Rightarrow> Done None\n                 | OK input' \\<Rightarrow>\n                     map_gpv' id id option_of_exception\n                      (gpv_stop (rpv input'))))))\n       (inline1b run_converter gpv conv))", "by simp"], ["proof (state)\nthis:\n  ord_spmf (=)\n   (bind_spmf (return_pmf None)\n     (\\<lambda>a.\n         case a of Inl (None, conv') \\<Rightarrow> return_pmf None\n         | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n         | Inr y \\<Rightarrow> return_spmf (Inr y)))\n   (map_spmf\n     (map_sum (apsnd obsf_converter)\n       (apsnd\n         (map_prod\n           (\\<lambda>rpv a.\n               case a of\n               Fault \\<Rightarrow> Done (Fault, const_converter Fault)\n               | OK input' \\<Rightarrow>\n                   map_gpv'\n                    (\\<lambda>a.\n                        case a of\n                        None \\<Rightarrow> (Fault, const_converter Fault)\n                        | Some (x, conv') \\<Rightarrow>\n                            (OK x, obsf_converter conv'))\n                    id option_of_exception\n                    (TRY gpv_stop (rpv input') ELSE Done None))\n           (\\<lambda>rpv a.\n               case a of Fault \\<Rightarrow> Done None\n               | OK input' \\<Rightarrow>\n                   map_gpv' id id option_of_exception\n                    (gpv_stop (rpv input'))))))\n     (inline1b run_converter gpv conv))\n\ngoal (1 subgoal):\n 1. \\<And>inline1' gpv conv.\n       \\<lbrakk>\\<And>gpv s.\n                   ord_spmf (=) (inline1' gpv s)\n                    (inline1 run_converter gpv s);\n        \\<And>gpv conv.\n           ord_spmf (=)\n            (bind_spmf\n              (inline1' (map_gpv' id id option_of_exception (gpv_stop gpv))\n                (obsf_converter conv))\n              (case_sum\n                (\\<lambda>(a, conv').\n                    case a of None \\<Rightarrow> return_pmf None\n                    | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n                (\\<lambda>y. return_spmf (Inr y))))\n            (map_spmf\n              (map_sum (apsnd obsf_converter)\n                (apsnd\n                  (map_prod\n                    (\\<lambda>rpv.\n                        case_exception (Done (Fault, const_converter Fault))\n                         (\\<lambda>input'.\n                             map_gpv'\n                              (case_option (Fault, const_converter Fault)\n                                (\\<lambda>(x, conv').\n                                    (OK x, obsf_converter conv')))\n                              id option_of_exception\n                              (TRY gpv_stop (rpv input') ELSE Done None)))\n                    (\\<lambda>rpv.\n                        case_exception (Done None)\n                         (\\<lambda>input'.\n                             map_gpv' id id option_of_exception\n                              (gpv_stop (rpv input')))))))\n              (inline1b run_converter gpv conv))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (bind_spmf\n                            (bind_spmf\n                              (the_gpv\n                                (map_gpv' id id option_of_exception\n                                  (gpv_stop gpv)))\n                              (case_generat\n                                (\\<lambda>x.\n                                    return_spmf\n                                     (Inl (x, obsf_converter conv)))\n                                (\\<lambda>out rpv.\n                                    bind_spmf\n                                     (the_gpv\n (run_converter (obsf_converter conv) out))\n                                     (case_generat\n (\\<lambda>(x, y). inline1' (rpv x) y)\n (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))))\n                            (case_sum\n                              (\\<lambda>(a, conv').\n                                  case a of\n                                  None \\<Rightarrow> return_pmf None\n                                  | Some x \\<Rightarrow>\nreturn_spmf (Inl (x, conv')))\n                              (\\<lambda>y. return_spmf (Inr y))))\n                          (map_spmf\n                            (map_sum (apsnd obsf_converter)\n                              (apsnd\n                                (map_prod\n                                  (\\<lambda>rpv.\ncase_exception (Done (Fault, const_converter Fault))\n (\\<lambda>input'.\n     map_gpv'\n      (case_option (Fault, const_converter Fault)\n        (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n      id option_of_exception (TRY gpv_stop (rpv input') ELSE Done None)))\n                                  (\\<lambda>rpv.\ncase_exception (Done None)\n (\\<lambda>input'.\n     map_gpv' id id option_of_exception (gpv_stop (rpv input')))))))\n                            (inline1b run_converter gpv conv))", "case (step inline1')"], ["proof (state)\nthis:\n  ord_spmf (=) (inline1' ?gpv ?s) (inline1 run_converter ?gpv ?s)\n  ord_spmf (=)\n   (bind_spmf\n     (inline1' (map_gpv' id id option_of_exception (gpv_stop ?gpv))\n       (obsf_converter ?conv))\n     (\\<lambda>a.\n         case a of Inl (None, conv') \\<Rightarrow> return_pmf None\n         | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n         | Inr y \\<Rightarrow> return_spmf (Inr y)))\n   (map_spmf\n     (map_sum (apsnd obsf_converter)\n       (apsnd\n         (map_prod\n           (\\<lambda>rpv a.\n               case a of\n               Fault \\<Rightarrow> Done (Fault, const_converter Fault)\n               | OK input' \\<Rightarrow>\n                   map_gpv'\n                    (\\<lambda>a.\n                        case a of\n                        None \\<Rightarrow> (Fault, const_converter Fault)\n                        | Some (x, conv') \\<Rightarrow>\n                            (OK x, obsf_converter conv'))\n                    id option_of_exception\n                    (TRY gpv_stop (rpv input') ELSE Done None))\n           (\\<lambda>rpv a.\n               case a of Fault \\<Rightarrow> Done None\n               | OK input' \\<Rightarrow>\n                   map_gpv' id id option_of_exception\n                    (gpv_stop (rpv input'))))))\n     (inline1b run_converter ?gpv ?conv))\n\ngoal (1 subgoal):\n 1. \\<And>inline1' gpv conv.\n       \\<lbrakk>\\<And>gpv s.\n                   ord_spmf (=) (inline1' gpv s)\n                    (inline1 run_converter gpv s);\n        \\<And>gpv conv.\n           ord_spmf (=)\n            (bind_spmf\n              (inline1' (map_gpv' id id option_of_exception (gpv_stop gpv))\n                (obsf_converter conv))\n              (case_sum\n                (\\<lambda>(a, conv').\n                    case a of None \\<Rightarrow> return_pmf None\n                    | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n                (\\<lambda>y. return_spmf (Inr y))))\n            (map_spmf\n              (map_sum (apsnd obsf_converter)\n                (apsnd\n                  (map_prod\n                    (\\<lambda>rpv.\n                        case_exception (Done (Fault, const_converter Fault))\n                         (\\<lambda>input'.\n                             map_gpv'\n                              (case_option (Fault, const_converter Fault)\n                                (\\<lambda>(x, conv').\n                                    (OK x, obsf_converter conv')))\n                              id option_of_exception\n                              (TRY gpv_stop (rpv input') ELSE Done None)))\n                    (\\<lambda>rpv.\n                        case_exception (Done None)\n                         (\\<lambda>input'.\n                             map_gpv' id id option_of_exception\n                              (gpv_stop (rpv input')))))))\n              (inline1b run_converter gpv conv))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (bind_spmf\n                            (bind_spmf\n                              (the_gpv\n                                (map_gpv' id id option_of_exception\n                                  (gpv_stop gpv)))\n                              (case_generat\n                                (\\<lambda>x.\n                                    return_spmf\n                                     (Inl (x, obsf_converter conv)))\n                                (\\<lambda>out rpv.\n                                    bind_spmf\n                                     (the_gpv\n (run_converter (obsf_converter conv) out))\n                                     (case_generat\n (\\<lambda>(x, y). inline1' (rpv x) y)\n (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))))\n                            (case_sum\n                              (\\<lambda>(a, conv').\n                                  case a of\n                                  None \\<Rightarrow> return_pmf None\n                                  | Some x \\<Rightarrow>\nreturn_spmf (Inl (x, conv')))\n                              (\\<lambda>y. return_spmf (Inr y))))\n                          (map_spmf\n                            (map_sum (apsnd obsf_converter)\n                              (apsnd\n                                (map_prod\n                                  (\\<lambda>rpv.\ncase_exception (Done (Fault, const_converter Fault))\n (\\<lambda>input'.\n     map_gpv'\n      (case_option (Fault, const_converter Fault)\n        (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n      id option_of_exception (TRY gpv_stop (rpv input') ELSE Done None)))\n                                  (\\<lambda>rpv.\ncase_exception (Done None)\n (\\<lambda>input'.\n     map_gpv' id id option_of_exception (gpv_stop (rpv input')))))))\n                            (inline1b run_converter gpv conv))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (bind_spmf\n       (bind_spmf\n         (the_gpv (map_gpv' id id option_of_exception (gpv_stop gpv)))\n         (case_generat\n           (\\<lambda>x. return_spmf (Inl (x, obsf_converter conv)))\n           (\\<lambda>out rpv.\n               bind_spmf (the_gpv (run_converter (obsf_converter conv) out))\n                (case_generat (\\<lambda>(x, y). inline1' (rpv x) y)\n                  (\\<lambda>out rpv'.\n                      return_spmf (Inr (out, rpv', rpv)))))))\n       (\\<lambda>a.\n           case a of Inl (None, conv') \\<Rightarrow> return_pmf None\n           | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n           | Inr y \\<Rightarrow> return_spmf (Inr y)))\n     (map_spmf\n       (map_sum (apsnd obsf_converter)\n         (apsnd\n           (map_prod\n             (\\<lambda>rpv a.\n                 case a of\n                 Fault \\<Rightarrow> Done (Fault, const_converter Fault)\n                 | OK input' \\<Rightarrow>\n                     map_gpv'\n                      (\\<lambda>a.\n                          case a of\n                          None \\<Rightarrow> (Fault, const_converter Fault)\n                          | Some (x, conv') \\<Rightarrow>\n                              (OK x, obsf_converter conv'))\n                      id option_of_exception\n                      (TRY gpv_stop (rpv input') ELSE Done None))\n             (\\<lambda>rpv a.\n                 case a of Fault \\<Rightarrow> Done None\n                 | OK input' \\<Rightarrow>\n                     map_gpv' id id option_of_exception\n                      (gpv_stop (rpv input'))))))\n       (inline1b run_converter gpv conv))", "unfolding inline1b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (bind_spmf\n       (bind_spmf\n         (the_gpv (map_gpv' id id option_of_exception (gpv_stop gpv)))\n         (case_generat\n           (\\<lambda>x. return_spmf (Inl (x, obsf_converter conv)))\n           (\\<lambda>out rpv.\n               bind_spmf (the_gpv (run_converter (obsf_converter conv) out))\n                (case_generat (\\<lambda>(x, y). inline1' (rpv x) y)\n                  (\\<lambda>out rpv'.\n                      return_spmf (Inr (out, rpv', rpv)))))))\n       (\\<lambda>a.\n           case a of Inl (None, conv') \\<Rightarrow> return_pmf None\n           | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n           | Inr y \\<Rightarrow> return_spmf (Inr y)))\n     (map_spmf\n       (map_sum (apsnd obsf_converter)\n         (apsnd\n           (map_prod\n             (\\<lambda>rpv a.\n                 case a of\n                 Fault \\<Rightarrow> Done (Fault, const_converter Fault)\n                 | OK input' \\<Rightarrow>\n                     map_gpv'\n                      (\\<lambda>a.\n                          case a of\n                          None \\<Rightarrow> (Fault, const_converter Fault)\n                          | Some (x, conv') \\<Rightarrow>\n                              (OK x, obsf_converter conv'))\n                      id option_of_exception\n                      (TRY gpv_stop (rpv input') ELSE Done None))\n             (\\<lambda>rpv a.\n                 case a of Fault \\<Rightarrow> Done None\n                 | OK input' \\<Rightarrow>\n                     map_gpv' id id option_of_exception\n                      (gpv_stop (rpv input'))))))\n       (inline1 run_converter gpv conv))", "apply(subst inline1_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (bind_spmf\n       (bind_spmf\n         (the_gpv (map_gpv' id id option_of_exception (gpv_stop gpv)))\n         (case_generat\n           (\\<lambda>x. return_spmf (Inl (x, obsf_converter conv)))\n           (\\<lambda>out rpv.\n               bind_spmf (the_gpv (run_converter (obsf_converter conv) out))\n                (case_generat (\\<lambda>(x, y). inline1' (rpv x) y)\n                  (\\<lambda>out rpv'.\n                      return_spmf (Inr (out, rpv', rpv)))))))\n       (case_sum\n         (\\<lambda>(a, conv').\n             case a of None \\<Rightarrow> return_pmf None\n             | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n         (\\<lambda>y. return_spmf (Inr y))))\n     (map_spmf\n       (map_sum (apsnd obsf_converter)\n         (apsnd\n           (map_prod\n             (\\<lambda>rpv.\n                 case_exception (Done (Fault, const_converter Fault))\n                  (\\<lambda>input'.\n                      map_gpv'\n                       (case_option (Fault, const_converter Fault)\n                         (\\<lambda>(x, conv').\n                             (OK x, obsf_converter conv')))\n                       id option_of_exception\n                       (TRY gpv_stop (rpv input') ELSE Done None)))\n             (\\<lambda>rpv.\n                 case_exception (Done None)\n                  (\\<lambda>input'.\n                      map_gpv' id id option_of_exception\n                       (gpv_stop (rpv input')))))))\n       (bind_spmf (the_gpv gpv)\n         (case_generat (\\<lambda>x. return_spmf (Inl (x, conv)))\n           (\\<lambda>out rpv.\n               bind_spmf (the_gpv (run_converter conv out))\n                (case_generat\n                  (\\<lambda>(x, y). inline1 run_converter (rpv x) y)\n                  (\\<lambda>out rpv'.\n                      return_spmf (Inr (out, rpv', rpv))))))))", "apply(clarsimp simp add: map_spmf_bind_spmf bind_map_spmf spmf.map_comp o_def generat.map_comp intro!: ord_spmf_bind_reflI split!: generat.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n       ord_spmf (=)\n        (bind_spmf\n          (TRY map_spmf\n                (map_generat\n                  (\\<lambda>(x, conv'). (OK x, obsf_converter conv'))\n                  (\\<lambda>x. x)\n                  (\\<lambda>x.\n                      map_fun id Inl\n                       (map_fun option_of_exception\n                         (map_gpv'\n                           (case_option (Fault, const_converter Fault)\n                             (\\<lambda>(x, conv').\n                                 (OK x, obsf_converter conv')))\n                           id option_of_exception)\n                         (case_option (Done None)\n                           (\\<lambda>input'. gpv_stop (x input'))))))\n                (the_gpv\n                  (run_converter conv\n                    x21)) ELSE return_spmf\n                                (Pure (Fault, const_converter Fault)))\n          (\\<lambda>y.\n              bind_spmf\n               (case map_generat id id\n                      (\\<lambda>c input.\n                          case c input of\n                          Inl gpv \\<Rightarrow>\n                            TRY gpv ELSE Done (Fault, const_converter Fault)\n                          | Inr gpv' \\<Rightarrow> gpv')\n                      y of\n                Pure (xa, xb) \\<Rightarrow>\n                  inline1'\n                   (map_fun option_of_exception\n                     (map_gpv' id id option_of_exception)\n                     (case_option (Done None)\n                       (\\<lambda>input'. gpv_stop (x22 input')))\n                     xa)\n                   xb\n                | IO out rpv' \\<Rightarrow>\n                    return_spmf\n                     (Inr (out, rpv',\n                           map_fun option_of_exception\n                            (map_gpv' id id option_of_exception)\n                            (case_option (Done None)\n                              (\\<lambda>input'. gpv_stop (x22 input'))))))\n               (case_sum\n                 (\\<lambda>(a, conv').\n                     case a of None \\<Rightarrow> return_pmf None\n                     | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n                 (\\<lambda>y. return_spmf (Inr y)))))\n        (bind_spmf (the_gpv (run_converter conv x21))\n          (\\<lambda>x.\n              map_spmf\n               (map_sum (apsnd obsf_converter)\n                 (apsnd\n                   (map_prod\n                     (\\<lambda>rpv.\n                         case_exception\n                          (Done (Fault, const_converter Fault))\n                          (\\<lambda>input'.\n                              map_gpv'\n                               (case_option (Fault, const_converter Fault)\n                                 (\\<lambda>(x, conv').\n                                     (OK x, obsf_converter conv')))\n                               id option_of_exception\n                               (TRY gpv_stop (rpv input') ELSE Done None)))\n                     (\\<lambda>rpv.\n                         case_exception (Done None)\n                          (\\<lambda>input'.\n                              map_gpv' id id option_of_exception\n                               (gpv_stop (rpv input')))))))\n               (case x of\n                Pure (xa, xb) \\<Rightarrow>\n                  inline1 run_converter (x22 xa) xb\n                | IO out rpv' \\<Rightarrow>\n                    return_spmf (Inr (out, rpv', x22)))))", "apply(clarsimp simp add: bind_spmf_def try_spmf_def bind_assoc_pmf bind_map_pmf bind_return_pmf intro!: rel_pmf_bind_reflI split!: option.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>IO x21 x22 \\<in> set_spmf (the_gpv gpv);\n        None \\<in> set_pmf (the_gpv (run_converter conv x21))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (bind_pmf\n                            (inline1' (Done None) (const_converter Fault))\n                            (case_option (return_pmf None)\n                              (case_sum\n                                (\\<lambda>(a, conv').\n                                    case a of\n                                    None \\<Rightarrow> return_pmf None\n                                    | Some x \\<Rightarrow>\n  return_spmf (Inl (x, conv')))\n                                (\\<lambda>y. return_spmf (Inr y)))))\n                          (return_pmf None)\n 2. \\<And>x21 x22 x2.\n       \\<lbrakk>IO x21 x22 \\<in> set_spmf (the_gpv gpv);\n        Some x2 \\<in> set_pmf (the_gpv (run_converter conv x21))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (bind_pmf\n                            (case map_generat id id\n                                   (\\<lambda>c input.\n case c input of\n Inl gpv \\<Rightarrow> TRY gpv ELSE Done (Fault, const_converter Fault)\n | Inr gpv' \\<Rightarrow> gpv')\n                                   (map_generat\n                                     (\\<lambda>(x, conv').\n   (OK x, obsf_converter conv'))\n                                     (\\<lambda>x. x)\n                                     (\\<lambda>x.\n   map_fun id Inl\n    (map_fun option_of_exception\n      (map_gpv'\n        (case_option (Fault, const_converter Fault)\n          (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n        id option_of_exception)\n      (case_option (Done None) (\\<lambda>input'. gpv_stop (x input')))))\n                                     x2) of\n                             Pure (xa, xb) \\<Rightarrow>\n                               inline1'\n                                (map_fun option_of_exception\n                                  (map_gpv' id id option_of_exception)\n                                  (case_option (Done None)\n                                    (\\<lambda>input'.\n  gpv_stop (x22 input')))\n                                  xa)\n                                xb\n                             | IO out rpv' \\<Rightarrow>\n                                 return_spmf\n                                  (Inr (out, rpv',\n  map_fun option_of_exception (map_gpv' id id option_of_exception)\n   (case_option (Done None) (\\<lambda>input'. gpv_stop (x22 input'))))))\n                            (case_option (return_pmf None)\n                              (case_sum\n                                (\\<lambda>(a, conv').\n                                    case a of\n                                    None \\<Rightarrow> return_pmf None\n                                    | Some x \\<Rightarrow>\n  return_spmf (Inl (x, conv')))\n                                (\\<lambda>y. return_spmf (Inr y)))))\n                          (map_spmf\n                            (map_sum (apsnd obsf_converter)\n                              (apsnd\n                                (map_prod\n                                  (\\<lambda>rpv.\ncase_exception (Done (Fault, const_converter Fault))\n (\\<lambda>input'.\n     map_gpv'\n      (case_option (Fault, const_converter Fault)\n        (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n      id option_of_exception (TRY gpv_stop (rpv input') ELSE Done None)))\n                                  (\\<lambda>rpv.\ncase_exception (Done None)\n (\\<lambda>input'.\n     map_gpv' id id option_of_exception (gpv_stop (rpv input')))))))\n                            (case x2 of\n                             Pure (xa, xb) \\<Rightarrow>\n                               inline1 run_converter (x22 xa) xb\n                             | IO out rpv' \\<Rightarrow>\n                                 return_spmf (Inr (out, rpv', x22))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IO x21_ x22_ \\<in> set_spmf (the_gpv gpv);\n     None \\<in> set_pmf (the_gpv (run_converter conv x21_))\\<rbrakk>\n    \\<Longrightarrow> ord_spmf (=)\n                       (bind_pmf\n                         (inline1' (Done None) (const_converter Fault))\n                         (case_option (return_pmf None)\n                           (case_sum\n                             (\\<lambda>(a, conv').\n                                 case a of\n                                 None \\<Rightarrow> return_pmf None\n                                 | Some x \\<Rightarrow>\n                                     return_spmf (Inl (x, conv')))\n                             (\\<lambda>y. return_spmf (Inr y)))))\n                       (return_pmf None)", "unfolding bind_spmf_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IO x21_ x22_ \\<in> set_spmf (the_gpv gpv);\n     None \\<in> set_pmf (the_gpv (run_converter conv x21_))\\<rbrakk>\n    \\<Longrightarrow> ord_spmf (=)\n                       (bind_spmf\n                         (inline1' (Done None) (const_converter Fault))\n                         (case_sum\n                           (\\<lambda>(a, conv').\n                               case a of None \\<Rightarrow> return_pmf None\n                               | Some x \\<Rightarrow>\n                                   return_spmf (Inl (x, conv')))\n                           (\\<lambda>y. return_spmf (Inr y))))\n                       (return_pmf None)", "by(rule ord_spmf_bindI[OF step.hyps, THEN spmf.leq_trans])\n          (auto split!: option.split intro!: ord_spmf_bindI[OF step.hyps, THEN spmf.leq_trans] ord_spmf_reflI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x2.\n       \\<lbrakk>IO x21 x22 \\<in> set_spmf (the_gpv gpv);\n        Some x2 \\<in> set_pmf (the_gpv (run_converter conv x21))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (bind_pmf\n                            (case map_generat id id\n                                   (\\<lambda>c input.\n case c input of\n Inl gpv \\<Rightarrow> TRY gpv ELSE Done (Fault, const_converter Fault)\n | Inr gpv' \\<Rightarrow> gpv')\n                                   (map_generat\n                                     (\\<lambda>(x, conv').\n   (OK x, obsf_converter conv'))\n                                     (\\<lambda>x. x)\n                                     (\\<lambda>x.\n   map_fun id Inl\n    (map_fun option_of_exception\n      (map_gpv'\n        (case_option (Fault, const_converter Fault)\n          (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n        id option_of_exception)\n      (case_option (Done None) (\\<lambda>input'. gpv_stop (x input')))))\n                                     x2) of\n                             Pure (xa, xb) \\<Rightarrow>\n                               inline1'\n                                (map_fun option_of_exception\n                                  (map_gpv' id id option_of_exception)\n                                  (case_option (Done None)\n                                    (\\<lambda>input'.\n  gpv_stop (x22 input')))\n                                  xa)\n                                xb\n                             | IO out rpv' \\<Rightarrow>\n                                 return_spmf\n                                  (Inr (out, rpv',\n  map_fun option_of_exception (map_gpv' id id option_of_exception)\n   (case_option (Done None) (\\<lambda>input'. gpv_stop (x22 input'))))))\n                            (case_option (return_pmf None)\n                              (case_sum\n                                (\\<lambda>(a, conv').\n                                    case a of\n                                    None \\<Rightarrow> return_pmf None\n                                    | Some x \\<Rightarrow>\n  return_spmf (Inl (x, conv')))\n                                (\\<lambda>y. return_spmf (Inr y)))))\n                          (map_spmf\n                            (map_sum (apsnd obsf_converter)\n                              (apsnd\n                                (map_prod\n                                  (\\<lambda>rpv.\ncase_exception (Done (Fault, const_converter Fault))\n (\\<lambda>input'.\n     map_gpv'\n      (case_option (Fault, const_converter Fault)\n        (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n      id option_of_exception (TRY gpv_stop (rpv input') ELSE Done None)))\n                                  (\\<lambda>rpv.\ncase_exception (Done None)\n (\\<lambda>input'.\n     map_gpv' id id option_of_exception (gpv_stop (rpv input')))))))\n                            (case x2 of\n                             Pure (xa, xb) \\<Rightarrow>\n                               inline1 run_converter (x22 xa) xb\n                             | IO out rpv' \\<Rightarrow>\n                                 return_spmf (Inr (out, rpv', x22))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IO x21_ x22_ \\<in> set_spmf (the_gpv gpv);\n     Some x2_ \\<in> set_pmf (the_gpv (run_converter conv x21_))\\<rbrakk>\n    \\<Longrightarrow> ord_spmf (=)\n                       (bind_pmf\n                         (case map_generat id id\n                                (\\<lambda>c input.\n                                    case c input of\n                                    Inl gpv \\<Rightarrow>\nTRY gpv ELSE Done (Fault, const_converter Fault)\n                                    | Inr gpv' \\<Rightarrow> gpv')\n                                (map_generat\n                                  (\\<lambda>(x, conv').\n(OK x, obsf_converter conv'))\n                                  (\\<lambda>x. x)\n                                  (\\<lambda>x.\nmap_fun id Inl\n (map_fun option_of_exception\n   (map_gpv'\n     (case_option (Fault, const_converter Fault)\n       (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n     id option_of_exception)\n   (case_option (Done None) (\\<lambda>input'. gpv_stop (x input')))))\n                                  x2_) of\n                          Pure (xa, xb) \\<Rightarrow>\n                            inline1'\n                             (map_fun option_of_exception\n                               (map_gpv' id id option_of_exception)\n                               (case_option (Done None)\n                                 (\\<lambda>input'. gpv_stop (x22_ input')))\n                               xa)\n                             xb\n                          | IO out rpv' \\<Rightarrow>\n                              return_spmf\n                               (Inr (out, rpv',\n                                     map_fun option_of_exception\n(map_gpv' id id option_of_exception)\n(case_option (Done None) (\\<lambda>input'. gpv_stop (x22_ input'))))))\n                         (case_option (return_pmf None)\n                           (case_sum\n                             (\\<lambda>(a, conv').\n                                 case a of\n                                 None \\<Rightarrow> return_pmf None\n                                 | Some x \\<Rightarrow>\n                                     return_spmf (Inl (x, conv')))\n                             (\\<lambda>y. return_spmf (Inr y)))))\n                       (map_spmf\n                         (map_sum (apsnd obsf_converter)\n                           (apsnd\n                             (map_prod\n                               (\\<lambda>rpv.\n                                   case_exception\n                                    (Done (Fault, const_converter Fault))\n                                    (\\<lambda>input'.\n  map_gpv'\n   (case_option (Fault, const_converter Fault)\n     (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n   id option_of_exception (TRY gpv_stop (rpv input') ELSE Done None)))\n                               (\\<lambda>rpv.\n                                   case_exception (Done None)\n                                    (\\<lambda>input'.\n  map_gpv' id id option_of_exception (gpv_stop (rpv input')))))))\n                         (case x2_ of\n                          Pure (xa, xb) \\<Rightarrow>\n                            inline1 run_converter (x22_ xa) xb\n                          | IO out rpv' \\<Rightarrow>\n                              return_spmf (Inr (out, rpv', x22_))))", "unfolding bind_spmf_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IO x21_ x22_ \\<in> set_spmf (the_gpv gpv);\n     Some x2_ \\<in> set_pmf (the_gpv (run_converter conv x21_))\\<rbrakk>\n    \\<Longrightarrow> ord_spmf (=)\n                       (bind_spmf\n                         (case map_generat id id\n                                (\\<lambda>c input.\n                                    case c input of\n                                    Inl gpv \\<Rightarrow>\nTRY gpv ELSE Done (Fault, const_converter Fault)\n                                    | Inr gpv' \\<Rightarrow> gpv')\n                                (map_generat\n                                  (\\<lambda>(x, conv').\n(OK x, obsf_converter conv'))\n                                  (\\<lambda>x. x)\n                                  (\\<lambda>x.\nmap_fun id Inl\n (map_fun option_of_exception\n   (map_gpv'\n     (case_option (Fault, const_converter Fault)\n       (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n     id option_of_exception)\n   (case_option (Done None) (\\<lambda>input'. gpv_stop (x input')))))\n                                  x2_) of\n                          Pure (xa, xb) \\<Rightarrow>\n                            inline1'\n                             (map_fun option_of_exception\n                               (map_gpv' id id option_of_exception)\n                               (case_option (Done None)\n                                 (\\<lambda>input'. gpv_stop (x22_ input')))\n                               xa)\n                             xb\n                          | IO out rpv' \\<Rightarrow>\n                              return_spmf\n                               (Inr (out, rpv',\n                                     map_fun option_of_exception\n(map_gpv' id id option_of_exception)\n(case_option (Done None) (\\<lambda>input'. gpv_stop (x22_ input'))))))\n                         (case_sum\n                           (\\<lambda>(a, conv').\n                               case a of None \\<Rightarrow> return_pmf None\n                               | Some x \\<Rightarrow>\n                                   return_spmf (Inl (x, conv')))\n                           (\\<lambda>y. return_spmf (Inr y))))\n                       (map_spmf\n                         (map_sum (apsnd obsf_converter)\n                           (apsnd\n                             (map_prod\n                               (\\<lambda>rpv.\n                                   case_exception\n                                    (Done (Fault, const_converter Fault))\n                                    (\\<lambda>input'.\n  map_gpv'\n   (case_option (Fault, const_converter Fault)\n     (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n   id option_of_exception (TRY gpv_stop (rpv input') ELSE Done None)))\n                               (\\<lambda>rpv.\n                                   case_exception (Done None)\n                                    (\\<lambda>input'.\n  map_gpv' id id option_of_exception (gpv_stop (rpv input')))))))\n                         (case x2_ of\n                          Pure (xa, xb) \\<Rightarrow>\n                            inline1 run_converter (x22_ xa) xb\n                          | IO out rpv' \\<Rightarrow>\n                              return_spmf (Inr (out, rpv', x22_))))", "by(clarsimp simp add: in_set_spmf[symmetric] inline1b_def split!: generat.split intro!: step.IH[THEN spmf.leq_trans])\n          (auto simp add: fun_eq_iff map'_try_gpv split: exception.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ord_spmf (=)\n   (bind_spmf\n     (bind_spmf\n       (the_gpv (map_gpv' id id option_of_exception (gpv_stop gpv)))\n       (case_generat\n         (\\<lambda>x. return_spmf (Inl (x, obsf_converter conv)))\n         (\\<lambda>out rpv.\n             bind_spmf (the_gpv (run_converter (obsf_converter conv) out))\n              (case_generat (\\<lambda>(x, y). inline1' (rpv x) y)\n                (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))))\n     (\\<lambda>a.\n         case a of Inl (None, conv') \\<Rightarrow> return_pmf None\n         | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n         | Inr y \\<Rightarrow> return_spmf (Inr y)))\n   (map_spmf\n     (map_sum (apsnd obsf_converter)\n       (apsnd\n         (map_prod\n           (\\<lambda>rpv a.\n               case a of\n               Fault \\<Rightarrow> Done (Fault, const_converter Fault)\n               | OK input' \\<Rightarrow>\n                   map_gpv'\n                    (\\<lambda>a.\n                        case a of\n                        None \\<Rightarrow> (Fault, const_converter Fault)\n                        | Some (x, conv') \\<Rightarrow>\n                            (OK x, obsf_converter conv'))\n                    id option_of_exception\n                    (TRY gpv_stop (rpv input') ELSE Done None))\n           (\\<lambda>rpv a.\n               case a of Fault \\<Rightarrow> Done None\n               | OK input' \\<Rightarrow>\n                   map_gpv' id id option_of_exception\n                    (gpv_stop (rpv input'))))))\n     (inline1b run_converter gpv conv))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ord_spmf (=)\n   (bind_spmf\n     (inline1a run_converter\n       (map_gpv' id id option_of_exception (gpv_stop gpv))\n       (obsf_converter conv))\n     (\\<lambda>xy.\n         case xy of Inl (None, conv') \\<Rightarrow> return_pmf None\n         | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n         | Inr y \\<Rightarrow> return_spmf (Inr y)))\n   (map_spmf\n     (map_sum (apsnd obsf_converter)\n       (apsnd\n         (map_prod\n           (\\<lambda>rpv input.\n               case input of\n               Fault \\<Rightarrow> Done (Fault, const_converter Fault)\n               | OK input' \\<Rightarrow>\n                   map_gpv'\n                    (\\<lambda>res.\n                        case res of\n                        None \\<Rightarrow> (Fault, const_converter Fault)\n                        | Some (x, conv') \\<Rightarrow>\n                            (OK x, obsf_converter conv'))\n                    id option_of_exception\n                    (TRY gpv_stop (rpv input') ELSE Done None))\n           (\\<lambda>rpv input.\n               case input of Fault \\<Rightarrow> Done None\n               | OK input' \\<Rightarrow>\n                   map_gpv' id id option_of_exception\n                    (gpv_stop (rpv input'))))))\n     (inline1b run_converter gpv conv))\n\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (map_spmf\n       (map_sum (apsnd obsf_converter)\n         (apsnd\n           (map_prod\n             (\\<lambda>rpv input.\n                 case input of\n                 Fault \\<Rightarrow> Done (Fault, const_converter Fault)\n                 | OK input' \\<Rightarrow>\n                     map_gpv'\n                      (\\<lambda>res.\n                          case res of\n                          None \\<Rightarrow> (Fault, const_converter Fault)\n                          | Some (x, conv') \\<Rightarrow>\n                              (OK x, obsf_converter conv'))\n                      id option_of_exception\n                      (TRY gpv_stop (rpv input') ELSE Done None))\n             (\\<lambda>rpv input.\n                 case input of Fault \\<Rightarrow> Done None\n                 | OK input' \\<Rightarrow>\n                     map_gpv' id id option_of_exception\n                      (gpv_stop (rpv input'))))))\n       (inline1b run_converter gpv conv))\n     (bind_spmf\n       (inline1a run_converter\n         (map_gpv' id id option_of_exception (gpv_stop gpv))\n         (obsf_converter conv))\n       (\\<lambda>xy.\n           case xy of Inl (None, conv') \\<Rightarrow> return_pmf None\n           | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n           | Inr y \\<Rightarrow> return_spmf (Inr y)))", "show \"ord_spmf (=) ?rhs ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (map_spmf\n       (map_sum (apsnd obsf_converter)\n         (apsnd\n           (map_prod\n             (\\<lambda>rpv input.\n                 case input of\n                 Fault \\<Rightarrow> Done (Fault, const_converter Fault)\n                 | OK input' \\<Rightarrow>\n                     map_gpv'\n                      (\\<lambda>res.\n                          case res of\n                          None \\<Rightarrow> (Fault, const_converter Fault)\n                          | Some (x, conv') \\<Rightarrow>\n                              (OK x, obsf_converter conv'))\n                      id option_of_exception\n                      (TRY gpv_stop (rpv input') ELSE Done None))\n             (\\<lambda>rpv input.\n                 case input of Fault \\<Rightarrow> Done None\n                 | OK input' \\<Rightarrow>\n                     map_gpv' id id option_of_exception\n                      (gpv_stop (rpv input'))))))\n       (inline1b run_converter gpv conv))\n     (bind_spmf\n       (inline1a run_converter\n         (map_gpv' id id option_of_exception (gpv_stop gpv))\n         (obsf_converter conv))\n       (\\<lambda>xy.\n           case xy of Inl (None, conv') \\<Rightarrow> return_pmf None\n           | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n           | Inr y \\<Rightarrow> return_spmf (Inr y)))", "unfolding inline1b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (map_spmf\n       (map_sum (apsnd obsf_converter)\n         (apsnd\n           (map_prod\n             (\\<lambda>rpv input.\n                 case input of\n                 Fault \\<Rightarrow> Done (Fault, const_converter Fault)\n                 | OK input' \\<Rightarrow>\n                     map_gpv'\n                      (\\<lambda>res.\n                          case res of\n                          None \\<Rightarrow> (Fault, const_converter Fault)\n                          | Some (x, conv') \\<Rightarrow>\n                              (OK x, obsf_converter conv'))\n                      id option_of_exception\n                      (TRY gpv_stop (rpv input') ELSE Done None))\n             (\\<lambda>rpv input.\n                 case input of Fault \\<Rightarrow> Done None\n                 | OK input' \\<Rightarrow>\n                     map_gpv' id id option_of_exception\n                      (gpv_stop (rpv input'))))))\n       (inline1 run_converter gpv conv))\n     (bind_spmf\n       (inline1a run_converter\n         (map_gpv' id id option_of_exception (gpv_stop gpv))\n         (obsf_converter conv))\n       (\\<lambda>xy.\n           case xy of Inl (None, conv') \\<Rightarrow> return_pmf None\n           | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n           | Inr y \\<Rightarrow> return_spmf (Inr y)))", "proof(induction arbitrary: gpv conv rule: inline1_fixp_induct_strong)"], ["proof (state)\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>inline1'.\n         \\<forall>x xa.\n            ord_spmf (=)\n             (map_spmf\n               (map_sum (apsnd obsf_converter)\n                 (apsnd\n                   (map_prod\n                     (\\<lambda>rpv.\n                         case_exception\n                          (Done (Fault, const_converter Fault))\n                          (\\<lambda>input'.\n                              map_gpv'\n                               (case_option (Fault, const_converter Fault)\n                                 (\\<lambda>(x, conv').\n                                     (OK x, obsf_converter conv')))\n                               id option_of_exception\n                               (TRY gpv_stop (rpv input') ELSE Done None)))\n                     (\\<lambda>rpv.\n                         case_exception (Done None)\n                          (\\<lambda>input'.\n                              map_gpv' id id option_of_exception\n                               (gpv_stop (rpv input')))))))\n               (inline1' (x, xa)))\n             (bind_spmf\n               (inline1a run_converter\n                 (map_gpv' id id option_of_exception (gpv_stop x))\n                 (obsf_converter xa))\n               (case_sum\n                 (\\<lambda>(a, conv').\n                     case a of None \\<Rightarrow> return_pmf None\n                     | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n                 (\\<lambda>y. return_spmf (Inr y)))))\n 2. \\<And>gpv conv.\n       ord_spmf (=)\n        (map_spmf\n          (map_sum (apsnd obsf_converter)\n            (apsnd\n              (map_prod\n                (\\<lambda>rpv.\n                    case_exception (Done (Fault, const_converter Fault))\n                     (\\<lambda>input'.\n                         map_gpv'\n                          (case_option (Fault, const_converter Fault)\n                            (\\<lambda>(x, conv').\n                                (OK x, obsf_converter conv')))\n                          id option_of_exception\n                          (TRY gpv_stop (rpv input') ELSE Done None)))\n                (\\<lambda>rpv.\n                    case_exception (Done None)\n                     (\\<lambda>input'.\n                         map_gpv' id id option_of_exception\n                          (gpv_stop (rpv input')))))))\n          (return_pmf None))\n        (bind_spmf\n          (inline1a run_converter\n            (map_gpv' id id option_of_exception (gpv_stop gpv))\n            (obsf_converter conv))\n          (case_sum\n            (\\<lambda>(a, conv').\n                case a of None \\<Rightarrow> return_pmf None\n                | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n            (\\<lambda>y. return_spmf (Inr y))))\n 3. \\<And>inline1' gpv conv.\n       \\<lbrakk>\\<And>gpv s.\n                   ord_spmf (=) (inline1' gpv s)\n                    (inline1 run_converter gpv s);\n        \\<And>gpv conv.\n           ord_spmf (=)\n            (map_spmf\n              (map_sum (apsnd obsf_converter)\n                (apsnd\n                  (map_prod\n                    (\\<lambda>rpv.\n                        case_exception (Done (Fault, const_converter Fault))\n                         (\\<lambda>input'.\n                             map_gpv'\n                              (case_option (Fault, const_converter Fault)\n                                (\\<lambda>(x, conv').\n                                    (OK x, obsf_converter conv')))\n                              id option_of_exception\n                              (TRY gpv_stop (rpv input') ELSE Done None)))\n                    (\\<lambda>rpv.\n                        case_exception (Done None)\n                         (\\<lambda>input'.\n                             map_gpv' id id option_of_exception\n                              (gpv_stop (rpv input')))))))\n              (inline1' gpv conv))\n            (bind_spmf\n              (inline1a run_converter\n                (map_gpv' id id option_of_exception (gpv_stop gpv))\n                (obsf_converter conv))\n              (case_sum\n                (\\<lambda>(a, conv').\n                    case a of None \\<Rightarrow> return_pmf None\n                    | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n                (\\<lambda>y. return_spmf (Inr y))))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf\n                            (map_sum (apsnd obsf_converter)\n                              (apsnd\n                                (map_prod\n                                  (\\<lambda>rpv.\ncase_exception (Done (Fault, const_converter Fault))\n (\\<lambda>input'.\n     map_gpv'\n      (case_option (Fault, const_converter Fault)\n        (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n      id option_of_exception (TRY gpv_stop (rpv input') ELSE Done None)))\n                                  (\\<lambda>rpv.\ncase_exception (Done None)\n (\\<lambda>input'.\n     map_gpv' id id option_of_exception (gpv_stop (rpv input')))))))\n                            (bind_spmf (the_gpv gpv)\n                              (case_generat\n                                (\\<lambda>x. return_spmf (Inl (x, conv)))\n                                (\\<lambda>out rpv.\n                                    bind_spmf\n                                     (the_gpv (run_converter conv out))\n                                     (case_generat\n (\\<lambda>(x, y). inline1' (rpv x) y)\n (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))))))\n                          (bind_spmf\n                            (inline1a run_converter\n                              (map_gpv' id id option_of_exception\n                                (gpv_stop gpv))\n                              (obsf_converter conv))\n                            (case_sum\n                              (\\<lambda>(a, conv').\n                                  case a of\n                                  None \\<Rightarrow> return_pmf None\n                                  | Some x \\<Rightarrow>\nreturn_spmf (Inl (x, conv')))\n                              (\\<lambda>y. return_spmf (Inr y))))", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>inline1'.\n         \\<forall>x xa.\n            ord_spmf (=)\n             (map_spmf\n               (map_sum (apsnd obsf_converter)\n                 (apsnd\n                   (map_prod\n                     (\\<lambda>rpv.\n                         case_exception\n                          (Done (Fault, const_converter Fault))\n                          (\\<lambda>input'.\n                              map_gpv'\n                               (case_option (Fault, const_converter Fault)\n                                 (\\<lambda>(x, conv').\n                                     (OK x, obsf_converter conv')))\n                               id option_of_exception\n                               (TRY gpv_stop (rpv input') ELSE Done None)))\n                     (\\<lambda>rpv.\n                         case_exception (Done None)\n                          (\\<lambda>input'.\n                              map_gpv' id id option_of_exception\n                               (gpv_stop (rpv input')))))))\n               (inline1' (x, xa)))\n             (bind_spmf\n               (inline1a run_converter\n                 (map_gpv' id id option_of_exception (gpv_stop x))\n                 (obsf_converter xa))\n               (case_sum\n                 (\\<lambda>(a, conv').\n                     case a of None \\<Rightarrow> return_pmf None\n                     | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n                 (\\<lambda>y. return_spmf (Inr y)))))\n 2. \\<And>gpv conv.\n       ord_spmf (=)\n        (map_spmf\n          (map_sum (apsnd obsf_converter)\n            (apsnd\n              (map_prod\n                (\\<lambda>rpv.\n                    case_exception (Done (Fault, const_converter Fault))\n                     (\\<lambda>input'.\n                         map_gpv'\n                          (case_option (Fault, const_converter Fault)\n                            (\\<lambda>(x, conv').\n                                (OK x, obsf_converter conv')))\n                          id option_of_exception\n                          (TRY gpv_stop (rpv input') ELSE Done None)))\n                (\\<lambda>rpv.\n                    case_exception (Done None)\n                     (\\<lambda>input'.\n                         map_gpv' id id option_of_exception\n                          (gpv_stop (rpv input')))))))\n          (return_pmf None))\n        (bind_spmf\n          (inline1a run_converter\n            (map_gpv' id id option_of_exception (gpv_stop gpv))\n            (obsf_converter conv))\n          (case_sum\n            (\\<lambda>(a, conv').\n                case a of None \\<Rightarrow> return_pmf None\n                | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n            (\\<lambda>y. return_spmf (Inr y))))\n 3. \\<And>inline1' gpv conv.\n       \\<lbrakk>\\<And>gpv s.\n                   ord_spmf (=) (inline1' gpv s)\n                    (inline1 run_converter gpv s);\n        \\<And>gpv conv.\n           ord_spmf (=)\n            (map_spmf\n              (map_sum (apsnd obsf_converter)\n                (apsnd\n                  (map_prod\n                    (\\<lambda>rpv.\n                        case_exception (Done (Fault, const_converter Fault))\n                         (\\<lambda>input'.\n                             map_gpv'\n                              (case_option (Fault, const_converter Fault)\n                                (\\<lambda>(x, conv').\n                                    (OK x, obsf_converter conv')))\n                              id option_of_exception\n                              (TRY gpv_stop (rpv input') ELSE Done None)))\n                    (\\<lambda>rpv.\n                        case_exception (Done None)\n                         (\\<lambda>input'.\n                             map_gpv' id id option_of_exception\n                              (gpv_stop (rpv input')))))))\n              (inline1' gpv conv))\n            (bind_spmf\n              (inline1a run_converter\n                (map_gpv' id id option_of_exception (gpv_stop gpv))\n                (obsf_converter conv))\n              (case_sum\n                (\\<lambda>(a, conv').\n                    case a of None \\<Rightarrow> return_pmf None\n                    | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n                (\\<lambda>y. return_spmf (Inr y))))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf\n                            (map_sum (apsnd obsf_converter)\n                              (apsnd\n                                (map_prod\n                                  (\\<lambda>rpv.\ncase_exception (Done (Fault, const_converter Fault))\n (\\<lambda>input'.\n     map_gpv'\n      (case_option (Fault, const_converter Fault)\n        (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n      id option_of_exception (TRY gpv_stop (rpv input') ELSE Done None)))\n                                  (\\<lambda>rpv.\ncase_exception (Done None)\n (\\<lambda>input'.\n     map_gpv' id id option_of_exception (gpv_stop (rpv input')))))))\n                            (bind_spmf (the_gpv gpv)\n                              (case_generat\n                                (\\<lambda>x. return_spmf (Inl (x, conv)))\n                                (\\<lambda>out rpv.\n                                    bind_spmf\n                                     (the_gpv (run_converter conv out))\n                                     (case_generat\n (\\<lambda>(x, y). inline1' (rpv x) y)\n (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))))))\n                          (bind_spmf\n                            (inline1a run_converter\n                              (map_gpv' id id option_of_exception\n                                (gpv_stop gpv))\n                              (obsf_converter conv))\n                            (case_sum\n                              (\\<lambda>(a, conv').\n                                  case a of\n                                  None \\<Rightarrow> return_pmf None\n                                  | Some x \\<Rightarrow>\nreturn_spmf (Inl (x, conv')))\n                              (\\<lambda>y. return_spmf (Inr y))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf.admissible\n     (\\<lambda>inline1'.\n         \\<forall>x xa.\n            ord_spmf (=)\n             (map_spmf\n               (map_sum (apsnd obsf_converter)\n                 (apsnd\n                   (map_prod\n                     (\\<lambda>rpv a.\n                         case a of\n                         Fault \\<Rightarrow>\n                           Done (Fault, const_converter Fault)\n                         | OK input' \\<Rightarrow>\n                             map_gpv'\n                              (\\<lambda>a.\n                                  case a of\n                                  None \\<Rightarrow>\n                                    (Fault, const_converter Fault)\n                                  | Some (x, conv') \\<Rightarrow>\n(OK x, obsf_converter conv'))\n                              id option_of_exception\n                              (TRY gpv_stop (rpv input') ELSE Done None))\n                     (\\<lambda>rpv a.\n                         case a of Fault \\<Rightarrow> Done None\n                         | OK input' \\<Rightarrow>\n                             map_gpv' id id option_of_exception\n                              (gpv_stop (rpv input'))))))\n               (inline1' (x, xa)))\n             (bind_spmf\n               (inline1a run_converter\n                 (map_gpv' id id option_of_exception (gpv_stop x))\n                 (obsf_converter xa))\n               (\\<lambda>a.\n                   case a of Inl (None, conv') \\<Rightarrow> return_pmf None\n                   | Inl (Some x, conv') \\<Rightarrow>\n                       return_spmf (Inl (x, conv'))\n                   | Inr y \\<Rightarrow> return_spmf (Inr y))))", "by simp"], ["proof (state)\nthis:\n  spmf.admissible\n   (\\<lambda>inline1'.\n       \\<forall>x xa.\n          ord_spmf (=)\n           (map_spmf\n             (map_sum (apsnd obsf_converter)\n               (apsnd\n                 (map_prod\n                   (\\<lambda>rpv a.\n                       case a of\n                       Fault \\<Rightarrow>\n                         Done (Fault, const_converter Fault)\n                       | OK input' \\<Rightarrow>\n                           map_gpv'\n                            (\\<lambda>a.\n                                case a of\n                                None \\<Rightarrow>\n                                  (Fault, const_converter Fault)\n                                | Some (x, conv') \\<Rightarrow>\n                                    (OK x, obsf_converter conv'))\n                            id option_of_exception\n                            (TRY gpv_stop (rpv input') ELSE Done None))\n                   (\\<lambda>rpv a.\n                       case a of Fault \\<Rightarrow> Done None\n                       | OK input' \\<Rightarrow>\n                           map_gpv' id id option_of_exception\n                            (gpv_stop (rpv input'))))))\n             (inline1' (x, xa)))\n           (bind_spmf\n             (inline1a run_converter\n               (map_gpv' id id option_of_exception (gpv_stop x))\n               (obsf_converter xa))\n             (\\<lambda>a.\n                 case a of Inl (None, conv') \\<Rightarrow> return_pmf None\n                 | Inl (Some x, conv') \\<Rightarrow>\n                     return_spmf (Inl (x, conv'))\n                 | Inr y \\<Rightarrow> return_spmf (Inr y))))\n\ngoal (2 subgoals):\n 1. \\<And>gpv conv.\n       ord_spmf (=)\n        (map_spmf\n          (map_sum (apsnd obsf_converter)\n            (apsnd\n              (map_prod\n                (\\<lambda>rpv.\n                    case_exception (Done (Fault, const_converter Fault))\n                     (\\<lambda>input'.\n                         map_gpv'\n                          (case_option (Fault, const_converter Fault)\n                            (\\<lambda>(x, conv').\n                                (OK x, obsf_converter conv')))\n                          id option_of_exception\n                          (TRY gpv_stop (rpv input') ELSE Done None)))\n                (\\<lambda>rpv.\n                    case_exception (Done None)\n                     (\\<lambda>input'.\n                         map_gpv' id id option_of_exception\n                          (gpv_stop (rpv input')))))))\n          (return_pmf None))\n        (bind_spmf\n          (inline1a run_converter\n            (map_gpv' id id option_of_exception (gpv_stop gpv))\n            (obsf_converter conv))\n          (case_sum\n            (\\<lambda>(a, conv').\n                case a of None \\<Rightarrow> return_pmf None\n                | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n            (\\<lambda>y. return_spmf (Inr y))))\n 2. \\<And>inline1' gpv conv.\n       \\<lbrakk>\\<And>gpv s.\n                   ord_spmf (=) (inline1' gpv s)\n                    (inline1 run_converter gpv s);\n        \\<And>gpv conv.\n           ord_spmf (=)\n            (map_spmf\n              (map_sum (apsnd obsf_converter)\n                (apsnd\n                  (map_prod\n                    (\\<lambda>rpv.\n                        case_exception (Done (Fault, const_converter Fault))\n                         (\\<lambda>input'.\n                             map_gpv'\n                              (case_option (Fault, const_converter Fault)\n                                (\\<lambda>(x, conv').\n                                    (OK x, obsf_converter conv')))\n                              id option_of_exception\n                              (TRY gpv_stop (rpv input') ELSE Done None)))\n                    (\\<lambda>rpv.\n                        case_exception (Done None)\n                         (\\<lambda>input'.\n                             map_gpv' id id option_of_exception\n                              (gpv_stop (rpv input')))))))\n              (inline1' gpv conv))\n            (bind_spmf\n              (inline1a run_converter\n                (map_gpv' id id option_of_exception (gpv_stop gpv))\n                (obsf_converter conv))\n              (case_sum\n                (\\<lambda>(a, conv').\n                    case a of None \\<Rightarrow> return_pmf None\n                    | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n                (\\<lambda>y. return_spmf (Inr y))))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf\n                            (map_sum (apsnd obsf_converter)\n                              (apsnd\n                                (map_prod\n                                  (\\<lambda>rpv.\ncase_exception (Done (Fault, const_converter Fault))\n (\\<lambda>input'.\n     map_gpv'\n      (case_option (Fault, const_converter Fault)\n        (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n      id option_of_exception (TRY gpv_stop (rpv input') ELSE Done None)))\n                                  (\\<lambda>rpv.\ncase_exception (Done None)\n (\\<lambda>input'.\n     map_gpv' id id option_of_exception (gpv_stop (rpv input')))))))\n                            (bind_spmf (the_gpv gpv)\n                              (case_generat\n                                (\\<lambda>x. return_spmf (Inl (x, conv)))\n                                (\\<lambda>out rpv.\n                                    bind_spmf\n                                     (the_gpv (run_converter conv out))\n                                     (case_generat\n (\\<lambda>(x, y). inline1' (rpv x) y)\n (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))))))\n                          (bind_spmf\n                            (inline1a run_converter\n                              (map_gpv' id id option_of_exception\n                                (gpv_stop gpv))\n                              (obsf_converter conv))\n                            (case_sum\n                              (\\<lambda>(a, conv').\n                                  case a of\n                                  None \\<Rightarrow> return_pmf None\n                                  | Some x \\<Rightarrow>\nreturn_spmf (Inl (x, conv')))\n                              (\\<lambda>y. return_spmf (Inr y))))", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>gpv conv.\n       ord_spmf (=)\n        (map_spmf\n          (map_sum (apsnd obsf_converter)\n            (apsnd\n              (map_prod\n                (\\<lambda>rpv.\n                    case_exception (Done (Fault, const_converter Fault))\n                     (\\<lambda>input'.\n                         map_gpv'\n                          (case_option (Fault, const_converter Fault)\n                            (\\<lambda>(x, conv').\n                                (OK x, obsf_converter conv')))\n                          id option_of_exception\n                          (TRY gpv_stop (rpv input') ELSE Done None)))\n                (\\<lambda>rpv.\n                    case_exception (Done None)\n                     (\\<lambda>input'.\n                         map_gpv' id id option_of_exception\n                          (gpv_stop (rpv input')))))))\n          (return_pmf None))\n        (bind_spmf\n          (inline1a run_converter\n            (map_gpv' id id option_of_exception (gpv_stop gpv))\n            (obsf_converter conv))\n          (case_sum\n            (\\<lambda>(a, conv').\n                case a of None \\<Rightarrow> return_pmf None\n                | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n            (\\<lambda>y. return_spmf (Inr y))))\n 2. \\<And>inline1' gpv conv.\n       \\<lbrakk>\\<And>gpv s.\n                   ord_spmf (=) (inline1' gpv s)\n                    (inline1 run_converter gpv s);\n        \\<And>gpv conv.\n           ord_spmf (=)\n            (map_spmf\n              (map_sum (apsnd obsf_converter)\n                (apsnd\n                  (map_prod\n                    (\\<lambda>rpv.\n                        case_exception (Done (Fault, const_converter Fault))\n                         (\\<lambda>input'.\n                             map_gpv'\n                              (case_option (Fault, const_converter Fault)\n                                (\\<lambda>(x, conv').\n                                    (OK x, obsf_converter conv')))\n                              id option_of_exception\n                              (TRY gpv_stop (rpv input') ELSE Done None)))\n                    (\\<lambda>rpv.\n                        case_exception (Done None)\n                         (\\<lambda>input'.\n                             map_gpv' id id option_of_exception\n                              (gpv_stop (rpv input')))))))\n              (inline1' gpv conv))\n            (bind_spmf\n              (inline1a run_converter\n                (map_gpv' id id option_of_exception (gpv_stop gpv))\n                (obsf_converter conv))\n              (case_sum\n                (\\<lambda>(a, conv').\n                    case a of None \\<Rightarrow> return_pmf None\n                    | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n                (\\<lambda>y. return_spmf (Inr y))))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf\n                            (map_sum (apsnd obsf_converter)\n                              (apsnd\n                                (map_prod\n                                  (\\<lambda>rpv.\ncase_exception (Done (Fault, const_converter Fault))\n (\\<lambda>input'.\n     map_gpv'\n      (case_option (Fault, const_converter Fault)\n        (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n      id option_of_exception (TRY gpv_stop (rpv input') ELSE Done None)))\n                                  (\\<lambda>rpv.\ncase_exception (Done None)\n (\\<lambda>input'.\n     map_gpv' id id option_of_exception (gpv_stop (rpv input')))))))\n                            (bind_spmf (the_gpv gpv)\n                              (case_generat\n                                (\\<lambda>x. return_spmf (Inl (x, conv)))\n                                (\\<lambda>out rpv.\n                                    bind_spmf\n                                     (the_gpv (run_converter conv out))\n                                     (case_generat\n (\\<lambda>(x, y). inline1' (rpv x) y)\n (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))))))\n                          (bind_spmf\n                            (inline1a run_converter\n                              (map_gpv' id id option_of_exception\n                                (gpv_stop gpv))\n                              (obsf_converter conv))\n                            (case_sum\n                              (\\<lambda>(a, conv').\n                                  case a of\n                                  None \\<Rightarrow> return_pmf None\n                                  | Some x \\<Rightarrow>\nreturn_spmf (Inl (x, conv')))\n                              (\\<lambda>y. return_spmf (Inr y))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (map_spmf\n       (map_sum (apsnd obsf_converter)\n         (apsnd\n           (map_prod\n             (\\<lambda>rpv a.\n                 case a of\n                 Fault \\<Rightarrow> Done (Fault, const_converter Fault)\n                 | OK input' \\<Rightarrow>\n                     map_gpv'\n                      (\\<lambda>a.\n                          case a of\n                          None \\<Rightarrow> (Fault, const_converter Fault)\n                          | Some (x, conv') \\<Rightarrow>\n                              (OK x, obsf_converter conv'))\n                      id option_of_exception\n                      (TRY gpv_stop (rpv input') ELSE Done None))\n             (\\<lambda>rpv a.\n                 case a of Fault \\<Rightarrow> Done None\n                 | OK input' \\<Rightarrow>\n                     map_gpv' id id option_of_exception\n                      (gpv_stop (rpv input'))))))\n       (return_pmf None))\n     (bind_spmf\n       (inline1a run_converter\n         (map_gpv' id id option_of_exception (gpv_stop gpv))\n         (obsf_converter conv))\n       (\\<lambda>a.\n           case a of Inl (None, conv') \\<Rightarrow> return_pmf None\n           | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n           | Inr y \\<Rightarrow> return_spmf (Inr y)))", "by simp"], ["proof (state)\nthis:\n  ord_spmf (=)\n   (map_spmf\n     (map_sum (apsnd obsf_converter)\n       (apsnd\n         (map_prod\n           (\\<lambda>rpv a.\n               case a of\n               Fault \\<Rightarrow> Done (Fault, const_converter Fault)\n               | OK input' \\<Rightarrow>\n                   map_gpv'\n                    (\\<lambda>a.\n                        case a of\n                        None \\<Rightarrow> (Fault, const_converter Fault)\n                        | Some (x, conv') \\<Rightarrow>\n                            (OK x, obsf_converter conv'))\n                    id option_of_exception\n                    (TRY gpv_stop (rpv input') ELSE Done None))\n           (\\<lambda>rpv a.\n               case a of Fault \\<Rightarrow> Done None\n               | OK input' \\<Rightarrow>\n                   map_gpv' id id option_of_exception\n                    (gpv_stop (rpv input'))))))\n     (return_pmf None))\n   (bind_spmf\n     (inline1a run_converter\n       (map_gpv' id id option_of_exception (gpv_stop gpv))\n       (obsf_converter conv))\n     (\\<lambda>a.\n         case a of Inl (None, conv') \\<Rightarrow> return_pmf None\n         | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n         | Inr y \\<Rightarrow> return_spmf (Inr y)))\n\ngoal (1 subgoal):\n 1. \\<And>inline1' gpv conv.\n       \\<lbrakk>\\<And>gpv s.\n                   ord_spmf (=) (inline1' gpv s)\n                    (inline1 run_converter gpv s);\n        \\<And>gpv conv.\n           ord_spmf (=)\n            (map_spmf\n              (map_sum (apsnd obsf_converter)\n                (apsnd\n                  (map_prod\n                    (\\<lambda>rpv.\n                        case_exception (Done (Fault, const_converter Fault))\n                         (\\<lambda>input'.\n                             map_gpv'\n                              (case_option (Fault, const_converter Fault)\n                                (\\<lambda>(x, conv').\n                                    (OK x, obsf_converter conv')))\n                              id option_of_exception\n                              (TRY gpv_stop (rpv input') ELSE Done None)))\n                    (\\<lambda>rpv.\n                        case_exception (Done None)\n                         (\\<lambda>input'.\n                             map_gpv' id id option_of_exception\n                              (gpv_stop (rpv input')))))))\n              (inline1' gpv conv))\n            (bind_spmf\n              (inline1a run_converter\n                (map_gpv' id id option_of_exception (gpv_stop gpv))\n                (obsf_converter conv))\n              (case_sum\n                (\\<lambda>(a, conv').\n                    case a of None \\<Rightarrow> return_pmf None\n                    | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n                (\\<lambda>y. return_spmf (Inr y))))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf\n                            (map_sum (apsnd obsf_converter)\n                              (apsnd\n                                (map_prod\n                                  (\\<lambda>rpv.\ncase_exception (Done (Fault, const_converter Fault))\n (\\<lambda>input'.\n     map_gpv'\n      (case_option (Fault, const_converter Fault)\n        (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n      id option_of_exception (TRY gpv_stop (rpv input') ELSE Done None)))\n                                  (\\<lambda>rpv.\ncase_exception (Done None)\n (\\<lambda>input'.\n     map_gpv' id id option_of_exception (gpv_stop (rpv input')))))))\n                            (bind_spmf (the_gpv gpv)\n                              (case_generat\n                                (\\<lambda>x. return_spmf (Inl (x, conv)))\n                                (\\<lambda>out rpv.\n                                    bind_spmf\n                                     (the_gpv (run_converter conv out))\n                                     (case_generat\n (\\<lambda>(x, y). inline1' (rpv x) y)\n (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))))))\n                          (bind_spmf\n                            (inline1a run_converter\n                              (map_gpv' id id option_of_exception\n                                (gpv_stop gpv))\n                              (obsf_converter conv))\n                            (case_sum\n                              (\\<lambda>(a, conv').\n                                  case a of\n                                  None \\<Rightarrow> return_pmf None\n                                  | Some x \\<Rightarrow>\nreturn_spmf (Inl (x, conv')))\n                              (\\<lambda>y. return_spmf (Inr y))))", "case (step inline1')"], ["proof (state)\nthis:\n  ord_spmf (=) (inline1' ?gpv ?s) (inline1 run_converter ?gpv ?s)\n  ord_spmf (=)\n   (map_spmf\n     (map_sum (apsnd obsf_converter)\n       (apsnd\n         (map_prod\n           (\\<lambda>rpv a.\n               case a of\n               Fault \\<Rightarrow> Done (Fault, const_converter Fault)\n               | OK input' \\<Rightarrow>\n                   map_gpv'\n                    (\\<lambda>a.\n                        case a of\n                        None \\<Rightarrow> (Fault, const_converter Fault)\n                        | Some (x, conv') \\<Rightarrow>\n                            (OK x, obsf_converter conv'))\n                    id option_of_exception\n                    (TRY gpv_stop (rpv input') ELSE Done None))\n           (\\<lambda>rpv a.\n               case a of Fault \\<Rightarrow> Done None\n               | OK input' \\<Rightarrow>\n                   map_gpv' id id option_of_exception\n                    (gpv_stop (rpv input'))))))\n     (inline1' ?gpv ?conv))\n   (bind_spmf\n     (inline1a run_converter\n       (map_gpv' id id option_of_exception (gpv_stop ?gpv))\n       (obsf_converter ?conv))\n     (\\<lambda>a.\n         case a of Inl (None, conv') \\<Rightarrow> return_pmf None\n         | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n         | Inr y \\<Rightarrow> return_spmf (Inr y)))\n\ngoal (1 subgoal):\n 1. \\<And>inline1' gpv conv.\n       \\<lbrakk>\\<And>gpv s.\n                   ord_spmf (=) (inline1' gpv s)\n                    (inline1 run_converter gpv s);\n        \\<And>gpv conv.\n           ord_spmf (=)\n            (map_spmf\n              (map_sum (apsnd obsf_converter)\n                (apsnd\n                  (map_prod\n                    (\\<lambda>rpv.\n                        case_exception (Done (Fault, const_converter Fault))\n                         (\\<lambda>input'.\n                             map_gpv'\n                              (case_option (Fault, const_converter Fault)\n                                (\\<lambda>(x, conv').\n                                    (OK x, obsf_converter conv')))\n                              id option_of_exception\n                              (TRY gpv_stop (rpv input') ELSE Done None)))\n                    (\\<lambda>rpv.\n                        case_exception (Done None)\n                         (\\<lambda>input'.\n                             map_gpv' id id option_of_exception\n                              (gpv_stop (rpv input')))))))\n              (inline1' gpv conv))\n            (bind_spmf\n              (inline1a run_converter\n                (map_gpv' id id option_of_exception (gpv_stop gpv))\n                (obsf_converter conv))\n              (case_sum\n                (\\<lambda>(a, conv').\n                    case a of None \\<Rightarrow> return_pmf None\n                    | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n                (\\<lambda>y. return_spmf (Inr y))))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf\n                            (map_sum (apsnd obsf_converter)\n                              (apsnd\n                                (map_prod\n                                  (\\<lambda>rpv.\ncase_exception (Done (Fault, const_converter Fault))\n (\\<lambda>input'.\n     map_gpv'\n      (case_option (Fault, const_converter Fault)\n        (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n      id option_of_exception (TRY gpv_stop (rpv input') ELSE Done None)))\n                                  (\\<lambda>rpv.\ncase_exception (Done None)\n (\\<lambda>input'.\n     map_gpv' id id option_of_exception (gpv_stop (rpv input')))))))\n                            (bind_spmf (the_gpv gpv)\n                              (case_generat\n                                (\\<lambda>x. return_spmf (Inl (x, conv)))\n                                (\\<lambda>out rpv.\n                                    bind_spmf\n                                     (the_gpv (run_converter conv out))\n                                     (case_generat\n (\\<lambda>(x, y). inline1' (rpv x) y)\n (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))))))\n                          (bind_spmf\n                            (inline1a run_converter\n                              (map_gpv' id id option_of_exception\n                                (gpv_stop gpv))\n                              (obsf_converter conv))\n                            (case_sum\n                              (\\<lambda>(a, conv').\n                                  case a of\n                                  None \\<Rightarrow> return_pmf None\n                                  | Some x \\<Rightarrow>\nreturn_spmf (Inl (x, conv')))\n                              (\\<lambda>y. return_spmf (Inr y))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (map_spmf\n       (map_sum (apsnd obsf_converter)\n         (apsnd\n           (map_prod\n             (\\<lambda>rpv a.\n                 case a of\n                 Fault \\<Rightarrow> Done (Fault, const_converter Fault)\n                 | OK input' \\<Rightarrow>\n                     map_gpv'\n                      (\\<lambda>a.\n                          case a of\n                          None \\<Rightarrow> (Fault, const_converter Fault)\n                          | Some (x, conv') \\<Rightarrow>\n                              (OK x, obsf_converter conv'))\n                      id option_of_exception\n                      (TRY gpv_stop (rpv input') ELSE Done None))\n             (\\<lambda>rpv a.\n                 case a of Fault \\<Rightarrow> Done None\n                 | OK input' \\<Rightarrow>\n                     map_gpv' id id option_of_exception\n                      (gpv_stop (rpv input'))))))\n       (bind_spmf (the_gpv gpv)\n         (case_generat (\\<lambda>x. return_spmf (Inl (x, conv)))\n           (\\<lambda>out rpv.\n               bind_spmf (the_gpv (run_converter conv out))\n                (case_generat (\\<lambda>(x, y). inline1' (rpv x) y)\n                  (\\<lambda>out rpv'.\n                      return_spmf (Inr (out, rpv', rpv))))))))\n     (bind_spmf\n       (inline1a run_converter\n         (map_gpv' id id option_of_exception (gpv_stop gpv))\n         (obsf_converter conv))\n       (\\<lambda>a.\n           case a of Inl (None, conv') \\<Rightarrow> return_pmf None\n           | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n           | Inr y \\<Rightarrow> return_spmf (Inr y)))", "unfolding inline1a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (map_spmf\n       (map_sum (apsnd obsf_converter)\n         (apsnd\n           (map_prod\n             (\\<lambda>rpv a.\n                 case a of\n                 Fault \\<Rightarrow> Done (Fault, const_converter Fault)\n                 | OK input' \\<Rightarrow>\n                     map_gpv'\n                      (\\<lambda>a.\n                          case a of\n                          None \\<Rightarrow> (Fault, const_converter Fault)\n                          | Some (x, conv') \\<Rightarrow>\n                              (OK x, obsf_converter conv'))\n                      id option_of_exception\n                      (TRY gpv_stop (rpv input') ELSE Done None))\n             (\\<lambda>rpv a.\n                 case a of Fault \\<Rightarrow> Done None\n                 | OK input' \\<Rightarrow>\n                     map_gpv' id id option_of_exception\n                      (gpv_stop (rpv input'))))))\n       (bind_spmf (the_gpv gpv)\n         (case_generat (\\<lambda>x. return_spmf (Inl (x, conv)))\n           (\\<lambda>out rpv.\n               bind_spmf (the_gpv (run_converter conv out))\n                (case_generat (\\<lambda>(x, y). inline1' (rpv x) y)\n                  (\\<lambda>out rpv'.\n                      return_spmf (Inr (out, rpv', rpv))))))))\n     (bind_spmf\n       (inline1 run_converter\n         (map_gpv' id id option_of_exception (gpv_stop gpv))\n         (obsf_converter conv))\n       (\\<lambda>a.\n           case a of Inl (None, conv') \\<Rightarrow> return_pmf None\n           | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n           | Inr y \\<Rightarrow> return_spmf (Inr y)))", "apply(subst inline1_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (map_spmf\n       (map_sum (apsnd obsf_converter)\n         (apsnd\n           (map_prod\n             (\\<lambda>rpv.\n                 case_exception (Done (Fault, const_converter Fault))\n                  (\\<lambda>input'.\n                      map_gpv'\n                       (case_option (Fault, const_converter Fault)\n                         (\\<lambda>(x, conv').\n                             (OK x, obsf_converter conv')))\n                       id option_of_exception\n                       (TRY gpv_stop (rpv input') ELSE Done None)))\n             (\\<lambda>rpv.\n                 case_exception (Done None)\n                  (\\<lambda>input'.\n                      map_gpv' id id option_of_exception\n                       (gpv_stop (rpv input')))))))\n       (bind_spmf (the_gpv gpv)\n         (case_generat (\\<lambda>x. return_spmf (Inl (x, conv)))\n           (\\<lambda>out rpv.\n               bind_spmf (the_gpv (run_converter conv out))\n                (case_generat (\\<lambda>(x, y). inline1' (rpv x) y)\n                  (\\<lambda>out rpv'.\n                      return_spmf (Inr (out, rpv', rpv))))))))\n     (bind_spmf\n       (bind_spmf\n         (the_gpv (map_gpv' id id option_of_exception (gpv_stop gpv)))\n         (case_generat\n           (\\<lambda>x. return_spmf (Inl (x, obsf_converter conv)))\n           (\\<lambda>out rpv.\n               bind_spmf (the_gpv (run_converter (obsf_converter conv) out))\n                (case_generat\n                  (\\<lambda>(x, y). inline1 run_converter (rpv x) y)\n                  (\\<lambda>out rpv'.\n                      return_spmf (Inr (out, rpv', rpv)))))))\n       (case_sum\n         (\\<lambda>(a, conv').\n             case a of None \\<Rightarrow> return_pmf None\n             | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n         (\\<lambda>y. return_spmf (Inr y))))", "apply(clarsimp simp add: map_spmf_bind_spmf bind_map_spmf spmf.map_comp o_def generat.map_comp intro!: ord_spmf_bind_reflI split!: generat.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21a x22a.\n       IO x21a x22a \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n       ord_spmf (=)\n        (bind_spmf (the_gpv (run_converter conv x21a))\n          (\\<lambda>x.\n              map_spmf\n               (map_sum (apsnd obsf_converter)\n                 (apsnd\n                   (map_prod\n                     (\\<lambda>rpv.\n                         case_exception\n                          (Done (Fault, const_converter Fault))\n                          (\\<lambda>input'.\n                              map_gpv'\n                               (case_option (Fault, const_converter Fault)\n                                 (\\<lambda>(x, conv').\n                                     (OK x, obsf_converter conv')))\n                               id option_of_exception\n                               (TRY gpv_stop (rpv input') ELSE Done None)))\n                     (\\<lambda>rpv.\n                         case_exception (Done None)\n                          (\\<lambda>input'.\n                              map_gpv' id id option_of_exception\n                               (gpv_stop (rpv input')))))))\n               (case x of Pure (xa, xb) \\<Rightarrow> inline1' (x22a xa) xb\n                | IO out rpv' \\<Rightarrow>\n                    return_spmf (Inr (out, rpv', x22a)))))\n        (bind_spmf\n          (TRY map_spmf\n                (map_generat\n                  (\\<lambda>(x, conv'). (OK x, obsf_converter conv'))\n                  (\\<lambda>x. x)\n                  (\\<lambda>x.\n                      map_fun id Inl\n                       (map_fun option_of_exception\n                         (map_gpv'\n                           (case_option (Fault, const_converter Fault)\n                             (\\<lambda>(x, conv').\n                                 (OK x, obsf_converter conv')))\n                           id option_of_exception)\n                         (case_option (Done None)\n                           (\\<lambda>input'. gpv_stop (x input'))))))\n                (the_gpv\n                  (run_converter conv\n                    x21a)) ELSE return_spmf\n                                 (Pure (Fault, const_converter Fault)))\n          (\\<lambda>y.\n              bind_spmf\n               (case map_generat id id\n                      (\\<lambda>c input.\n                          case c input of\n                          Inl gpv \\<Rightarrow>\n                            TRY gpv ELSE Done (Fault, const_converter Fault)\n                          | Inr gpv' \\<Rightarrow> gpv')\n                      y of\n                Pure (xa, xb) \\<Rightarrow>\n                  inline1 run_converter\n                   (map_fun option_of_exception\n                     (map_gpv' id id option_of_exception)\n                     (case_option (Done None)\n                       (\\<lambda>input'. gpv_stop (x22a input')))\n                     xa)\n                   xb\n                | IO out rpv' \\<Rightarrow>\n                    return_spmf\n                     (Inr (out, rpv',\n                           map_fun option_of_exception\n                            (map_gpv' id id option_of_exception)\n                            (case_option (Done None)\n                              (\\<lambda>input'. gpv_stop (x22a input'))))))\n               (case_sum\n                 (\\<lambda>(a, conv').\n                     case a of None \\<Rightarrow> return_pmf None\n                     | Some x \\<Rightarrow> return_spmf (Inl (x, conv')))\n                 (\\<lambda>y. return_spmf (Inr y)))))", "apply(clarsimp simp add: bind_spmf_def try_spmf_def bind_assoc_pmf bind_map_pmf bind_return_pmf intro!: rel_pmf_bind_reflI split!: option.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21a x22a x2.\n       \\<lbrakk>IO x21a x22a \\<in> set_spmf (the_gpv gpv);\n        Some x2 \\<in> set_pmf (the_gpv (run_converter conv x21a))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf\n                            (map_sum (apsnd obsf_converter)\n                              (apsnd\n                                (map_prod\n                                  (\\<lambda>rpv.\ncase_exception (Done (Fault, const_converter Fault))\n (\\<lambda>input'.\n     map_gpv'\n      (case_option (Fault, const_converter Fault)\n        (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n      id option_of_exception (TRY gpv_stop (rpv input') ELSE Done None)))\n                                  (\\<lambda>rpv.\ncase_exception (Done None)\n (\\<lambda>input'.\n     map_gpv' id id option_of_exception (gpv_stop (rpv input')))))))\n                            (case x2 of\n                             Pure (xa, xb) \\<Rightarrow>\n                               inline1' (x22a xa) xb\n                             | IO out rpv' \\<Rightarrow>\n                                 return_spmf (Inr (out, rpv', x22a))))\n                          (bind_pmf\n                            (case map_generat id id\n                                   (\\<lambda>c input.\n case c input of\n Inl gpv \\<Rightarrow> TRY gpv ELSE Done (Fault, const_converter Fault)\n | Inr gpv' \\<Rightarrow> gpv')\n                                   (map_generat\n                                     (\\<lambda>(x, conv').\n   (OK x, obsf_converter conv'))\n                                     (\\<lambda>x. x)\n                                     (\\<lambda>x.\n   map_fun id Inl\n    (map_fun option_of_exception\n      (map_gpv'\n        (case_option (Fault, const_converter Fault)\n          (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n        id option_of_exception)\n      (case_option (Done None) (\\<lambda>input'. gpv_stop (x input')))))\n                                     x2) of\n                             Pure (xa, xb) \\<Rightarrow>\n                               inline1 run_converter\n                                (map_fun option_of_exception\n                                  (map_gpv' id id option_of_exception)\n                                  (case_option (Done None)\n                                    (\\<lambda>input'.\n  gpv_stop (x22a input')))\n                                  xa)\n                                xb\n                             | IO out rpv' \\<Rightarrow>\n                                 return_spmf\n                                  (Inr (out, rpv',\n  map_fun option_of_exception (map_gpv' id id option_of_exception)\n   (case_option (Done None) (\\<lambda>input'. gpv_stop (x22a input'))))))\n                            (case_option (return_pmf None)\n                              (case_sum\n                                (\\<lambda>(a, conv').\n                                    case a of\n                                    None \\<Rightarrow> return_pmf None\n                                    | Some x \\<Rightarrow>\n  return_spmf (Inl (x, conv')))\n                                (\\<lambda>y. return_spmf (Inr y)))))", "apply(clarsimp simp add: bind_spmf_def[symmetric] in_set_spmf[symmetric] inline1a_def id_def[symmetric] split!: generat.split intro!: step.IH[THEN spmf.leq_trans])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21a x22a x21b x22b.\n       \\<lbrakk>IO x21a x22a \\<in> set_spmf (the_gpv gpv);\n        IO x21b x22b\n        \\<in> set_spmf (the_gpv (run_converter conv x21a))\\<rbrakk>\n       \\<Longrightarrow> case_exception\n                          (Done (Fault, const_converter Fault))\n                          (\\<lambda>input'.\n                              map_gpv'\n                               (case_option (Fault, const_converter Fault)\n                                 (\\<lambda>(x, conv').\n                                     (OK x, obsf_converter conv')))\n                               id option_of_exception\n                               (TRY gpv_stop\n                                     (x22b input') ELSE Done None)) =\n                         (\\<lambda>input.\n                             TRY map_gpv'\n                                  (case_option\n                                    (Fault, const_converter Fault)\n                                    (\\<lambda>(x, conv').\n  (OK x, obsf_converter conv')))\n                                  id option_of_exception\n                                  (case input of\n                                   Fault \\<Rightarrow> Done None\n                                   | OK input' \\<Rightarrow>\n gpv_stop (x22b input')) ELSE Done (Fault, const_converter Fault)) \\<and>\n                         case_exception (Done None)\n                          (\\<lambda>input'.\n                              map_gpv' id id option_of_exception\n                               (gpv_stop (x22a input'))) =\n                         map_fun option_of_exception\n                          (map_gpv' id id option_of_exception)\n                          (case_option (Done None)\n                            (\\<lambda>input'. gpv_stop (x22a input')))", "apply(auto simp add: fun_eq_iff map'_try_gpv split: exception.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ord_spmf (=)\n   (map_spmf\n     (map_sum (apsnd obsf_converter)\n       (apsnd\n         (map_prod\n           (\\<lambda>rpv a.\n               case a of\n               Fault \\<Rightarrow> Done (Fault, const_converter Fault)\n               | OK input' \\<Rightarrow>\n                   map_gpv'\n                    (\\<lambda>a.\n                        case a of\n                        None \\<Rightarrow> (Fault, const_converter Fault)\n                        | Some (x, conv') \\<Rightarrow>\n                            (OK x, obsf_converter conv'))\n                    id option_of_exception\n                    (TRY gpv_stop (rpv input') ELSE Done None))\n           (\\<lambda>rpv a.\n               case a of Fault \\<Rightarrow> Done None\n               | OK input' \\<Rightarrow>\n                   map_gpv' id id option_of_exception\n                    (gpv_stop (rpv input'))))))\n     (bind_spmf (the_gpv gpv)\n       (case_generat (\\<lambda>x. return_spmf (Inl (x, conv)))\n         (\\<lambda>out rpv.\n             bind_spmf (the_gpv (run_converter conv out))\n              (case_generat (\\<lambda>(x, y). inline1' (rpv x) y)\n                (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))))))\n   (bind_spmf\n     (inline1a run_converter\n       (map_gpv' id id option_of_exception (gpv_stop gpv))\n       (obsf_converter conv))\n     (\\<lambda>a.\n         case a of Inl (None, conv') \\<Rightarrow> return_pmf None\n         | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n         | Inr y \\<Rightarrow> return_spmf (Inr y)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ord_spmf (=)\n   (map_spmf\n     (map_sum (apsnd obsf_converter)\n       (apsnd\n         (map_prod\n           (\\<lambda>rpv input.\n               case input of\n               Fault \\<Rightarrow> Done (Fault, const_converter Fault)\n               | OK input' \\<Rightarrow>\n                   map_gpv'\n                    (\\<lambda>res.\n                        case res of\n                        None \\<Rightarrow> (Fault, const_converter Fault)\n                        | Some (x, conv') \\<Rightarrow>\n                            (OK x, obsf_converter conv'))\n                    id option_of_exception\n                    (TRY gpv_stop (rpv input') ELSE Done None))\n           (\\<lambda>rpv input.\n               case input of Fault \\<Rightarrow> Done None\n               | OK input' \\<Rightarrow>\n                   map_gpv' id id option_of_exception\n                    (gpv_stop (rpv input'))))))\n     (inline1b run_converter gpv conv))\n   (bind_spmf\n     (inline1a run_converter\n       (map_gpv' id id option_of_exception (gpv_stop gpv))\n       (obsf_converter conv))\n     (\\<lambda>xy.\n         case xy of Inl (None, conv') \\<Rightarrow> return_pmf None\n         | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n         | Inr y \\<Rightarrow> return_spmf (Inr y)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inline_gpv_stop_obsf_converter:\n  \"bind_gpv (inline run_converter (map_gpv' id id option_of_exception (gpv_stop gpv)) (obsf_converter conv)) (\\<lambda>(x, conv'). case x of None \\<Rightarrow> Fail | Some x' \\<Rightarrow> Done (x, conv')) =\n   bind_gpv (map_gpv' id id option_of_exception (gpv_stop (inline run_converter gpv conv))) (\\<lambda>x. case x of None \\<Rightarrow> Fail | Some (x', conv) \\<Rightarrow> Done (Some x', obsf_converter conv))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_gpv\n     (inline run_converter\n       (map_gpv' id id option_of_exception (gpv_stop gpv))\n       (obsf_converter conv))\n     (\\<lambda>(x, conv').\n         case x of None \\<Rightarrow> Fail\n         | Some x' \\<Rightarrow> Done (x, conv')) =\n    bind_gpv\n     (map_gpv' id id option_of_exception\n       (gpv_stop (inline run_converter gpv conv)))\n     (\\<lambda>x.\n         case x of None \\<Rightarrow> Fail\n         | Some (x', conv) \\<Rightarrow>\n             Done (Some x', obsf_converter conv))", "proof(coinduction arbitrary: gpv conv rule: gpv_coinduct_bind)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>gpva conv.\n       rel_spmf\n        (rel_generat (=) (=)\n          (rel_fun (=)\n            (\\<lambda>gpv gpv'.\n                (\\<exists>gpva conv.\n                    gpv =\n                    bind_gpv\n                     (inline run_converter\n                       (map_gpv' id id option_of_exception (gpv_stop gpva))\n                       (obsf_converter conv))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                    gpv' =\n                    bind_gpv\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop (inline run_converter gpva conv)))\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))) \\<or>\n                gpv = gpv' \\<or>\n                (\\<exists>gpv2 gpv2' f f'.\n                    gpv = bind_gpv gpv2 f \\<and>\n                    gpv' = bind_gpv gpv2' f' \\<and>\n                    rel_gpv\n                     (\\<lambda>x y.\n                         \\<exists>gpv conv.\n                            f x =\n                            bind_gpv\n                             (inline run_converter\n                               (map_gpv' id id option_of_exception\n                                 (gpv_stop gpv))\n                               (obsf_converter conv))\n                             (\\<lambda>(x, conv').\n                                 case x of None \\<Rightarrow> Fail\n                                 | Some x' \\<Rightarrow>\n                                     Done (x, conv')) \\<and>\n                            f' y =\n                            bind_gpv\n                             (map_gpv' id id option_of_exception\n                               (gpv_stop (inline run_converter gpv conv)))\n                             (case_option Fail\n                               (\\<lambda>(x', conv).\n                                   Done (Some x', obsf_converter conv))))\n                     (=) gpv2 gpv2'))))\n        (the_gpv\n          (bind_gpv\n            (inline run_converter\n              (map_gpv' id id option_of_exception (gpv_stop gpva))\n              (obsf_converter conv))\n            (\\<lambda>(x, conv').\n                case x of None \\<Rightarrow> Fail\n                | Some x' \\<Rightarrow> Done (x, conv'))))\n        (the_gpv\n          (bind_gpv\n            (map_gpv' id id option_of_exception\n              (gpv_stop (inline run_converter gpva conv)))\n            (case_option Fail\n              (\\<lambda>(x', conv). Done (Some x', obsf_converter conv)))))", "case (Eq_gpv gpv conv)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>gpva conv.\n       rel_spmf\n        (rel_generat (=) (=)\n          (rel_fun (=)\n            (\\<lambda>gpv gpv'.\n                (\\<exists>gpva conv.\n                    gpv =\n                    bind_gpv\n                     (inline run_converter\n                       (map_gpv' id id option_of_exception (gpv_stop gpva))\n                       (obsf_converter conv))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                    gpv' =\n                    bind_gpv\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop (inline run_converter gpva conv)))\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))) \\<or>\n                gpv = gpv' \\<or>\n                (\\<exists>gpv2 gpv2' f f'.\n                    gpv = bind_gpv gpv2 f \\<and>\n                    gpv' = bind_gpv gpv2' f' \\<and>\n                    rel_gpv\n                     (\\<lambda>x y.\n                         \\<exists>gpv conv.\n                            f x =\n                            bind_gpv\n                             (inline run_converter\n                               (map_gpv' id id option_of_exception\n                                 (gpv_stop gpv))\n                               (obsf_converter conv))\n                             (\\<lambda>(x, conv').\n                                 case x of None \\<Rightarrow> Fail\n                                 | Some x' \\<Rightarrow>\n                                     Done (x, conv')) \\<and>\n                            f' y =\n                            bind_gpv\n                             (map_gpv' id id option_of_exception\n                               (gpv_stop (inline run_converter gpv conv)))\n                             (case_option Fail\n                               (\\<lambda>(x', conv).\n                                   Done (Some x', obsf_converter conv))))\n                     (=) gpv2 gpv2'))))\n        (the_gpv\n          (bind_gpv\n            (inline run_converter\n              (map_gpv' id id option_of_exception (gpv_stop gpva))\n              (obsf_converter conv))\n            (\\<lambda>(x, conv').\n                case x of None \\<Rightarrow> Fail\n                | Some x' \\<Rightarrow> Done (x, conv'))))\n        (the_gpv\n          (bind_gpv\n            (map_gpv' id id option_of_exception\n              (gpv_stop (inline run_converter gpva conv)))\n            (case_option Fail\n              (\\<lambda>(x', conv). Done (Some x', obsf_converter conv)))))", "show \"?case TYPE('c \\<times> ('b, 'c, 'd, 'e) converter) TYPE('c \\<times> ('b, 'c, 'd, 'e) converter)\" (is \"rel_spmf ?X ?lhs ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_generat (=) (=)\n       (rel_fun (=)\n         (\\<lambda>gpv gpv'.\n             (\\<exists>gpva conv.\n                 gpv =\n                 bind_gpv\n                  (inline run_converter\n                    (map_gpv' id id option_of_exception (gpv_stop gpva))\n                    (obsf_converter conv))\n                  (\\<lambda>(x, conv').\n                      case x of None \\<Rightarrow> Fail\n                      | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                 gpv' =\n                 bind_gpv\n                  (map_gpv' id id option_of_exception\n                    (gpv_stop (inline run_converter gpva conv)))\n                  (case_option Fail\n                    (\\<lambda>(x', conv).\n                        Done (Some x', obsf_converter conv)))) \\<or>\n             gpv = gpv' \\<or>\n             (\\<exists>gpv2 gpv2' f f'.\n                 gpv = bind_gpv gpv2 f \\<and>\n                 gpv' = bind_gpv gpv2' f' \\<and>\n                 rel_gpv\n                  (\\<lambda>x y.\n                      \\<exists>gpv conv.\n                         f x =\n                         bind_gpv\n                          (inline run_converter\n                            (map_gpv' id id option_of_exception\n                              (gpv_stop gpv))\n                            (obsf_converter conv))\n                          (\\<lambda>(x, conv').\n                              case x of None \\<Rightarrow> Fail\n                              | Some x' \\<Rightarrow>\n                                  Done (x, conv')) \\<and>\n                         f' y =\n                         bind_gpv\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop (inline run_converter gpv conv)))\n                          (case_option Fail\n                            (\\<lambda>(x', conv).\n                                Done (Some x', obsf_converter conv))))\n                  (=) gpv2 gpv2'))))\n     (the_gpv\n       (bind_gpv\n         (inline run_converter\n           (map_gpv' id id option_of_exception (gpv_stop gpv))\n           (obsf_converter conv))\n         (\\<lambda>(x, conv').\n             case x of None \\<Rightarrow> Fail\n             | Some x' \\<Rightarrow> Done (x, conv'))))\n     (the_gpv\n       (bind_gpv\n         (map_gpv' id id option_of_exception\n           (gpv_stop (inline run_converter gpv conv)))\n         (case_option Fail\n           (\\<lambda>(x', conv). Done (Some x', obsf_converter conv)))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_generat (=) (=)\n       (rel_fun (=)\n         (\\<lambda>gpv gpv'.\n             (\\<exists>gpva conv.\n                 gpv =\n                 bind_gpv\n                  (inline run_converter\n                    (map_gpv' id id option_of_exception (gpv_stop gpva))\n                    (obsf_converter conv))\n                  (\\<lambda>(x, conv').\n                      case x of None \\<Rightarrow> Fail\n                      | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                 gpv' =\n                 bind_gpv\n                  (map_gpv' id id option_of_exception\n                    (gpv_stop (inline run_converter gpva conv)))\n                  (case_option Fail\n                    (\\<lambda>(x', conv).\n                        Done (Some x', obsf_converter conv)))) \\<or>\n             gpv = gpv' \\<or>\n             (\\<exists>gpv2 gpv2' f f'.\n                 gpv = bind_gpv gpv2 f \\<and>\n                 gpv' = bind_gpv gpv2' f' \\<and>\n                 rel_gpv\n                  (\\<lambda>x y.\n                      \\<exists>gpv conv.\n                         f x =\n                         bind_gpv\n                          (inline run_converter\n                            (map_gpv' id id option_of_exception\n                              (gpv_stop gpv))\n                            (obsf_converter conv))\n                          (\\<lambda>(x, conv').\n                              case x of None \\<Rightarrow> Fail\n                              | Some x' \\<Rightarrow>\n                                  Done (x, conv')) \\<and>\n                         f' y =\n                         bind_gpv\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop (inline run_converter gpv conv)))\n                          (case_option Fail\n                            (\\<lambda>(x', conv).\n                                Done (Some x', obsf_converter conv))))\n                  (=) gpv2 gpv2'))))\n     (the_gpv\n       (bind_gpv\n         (inline run_converter\n           (map_gpv' id id option_of_exception (gpv_stop gpv))\n           (obsf_converter conv))\n         (\\<lambda>(x, conv').\n             case x of None \\<Rightarrow> Fail\n             | Some x' \\<Rightarrow> Done (x, conv'))))\n     (the_gpv\n       (bind_gpv\n         (map_gpv' id id option_of_exception\n           (gpv_stop (inline run_converter gpv conv)))\n         (case_option Fail\n           (\\<lambda>(x', conv). Done (Some x', obsf_converter conv)))))", "have \"?lhs = map_spmf (\\<lambda>xyz. case xyz of Inl (x, conv) \\<Rightarrow> Pure (Some x, conv) | Inr (out, rpv, rpv') \\<Rightarrow> IO out (\\<lambda>input. bind_gpv (bind_gpv (rpv input) (\\<lambda>(x, y). inline run_converter (rpv' x) y)) (\\<lambda>(x, conv'). case x of None \\<Rightarrow> Fail | Some x' \\<Rightarrow> Done (x, conv'))))\n      (bind_spmf (inline1 run_converter (map_gpv' id id option_of_exception (gpv_stop gpv)) (obsf_converter conv))\n         (\\<lambda>xy. case xy of Inl (None, conv') \\<Rightarrow> return_pmf None | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv')) | Inr y \\<Rightarrow> return_spmf (Inr y)))\"\n      (is \"_ = map_spmf ?f _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. the_gpv\n     (bind_gpv\n       (inline run_converter\n         (map_gpv' id id option_of_exception (gpv_stop gpv))\n         (obsf_converter conv))\n       (\\<lambda>(x, conv').\n           case x of None \\<Rightarrow> Fail\n           | Some x' \\<Rightarrow> Done (x, conv'))) =\n    map_spmf\n     (\\<lambda>xyz.\n         case xyz of Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n         | Inr (out, rpv, rpv') \\<Rightarrow>\n             IO out\n              (\\<lambda>input.\n                  bind_gpv\n                   (bind_gpv (rpv input)\n                     (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                   (\\<lambda>(x, conv').\n                       case x of None \\<Rightarrow> Fail\n                       | Some x' \\<Rightarrow> Done (x, conv'))))\n     (bind_spmf\n       (inline1 run_converter\n         (map_gpv' id id option_of_exception (gpv_stop gpv))\n         (obsf_converter conv))\n       (\\<lambda>xy.\n           case xy of Inl (None, conv') \\<Rightarrow> return_pmf None\n           | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n           | Inr y \\<Rightarrow> return_spmf (Inr y)))", "by(auto simp del: bind_gpv_sel' simp add: bind_gpv.sel map_bind_spmf inline_sel bind_map_spmf o_def intro!: bind_spmf_cong[OF refl] split!: sum.split option.split)"], ["proof (state)\nthis:\n  the_gpv\n   (bind_gpv\n     (inline run_converter\n       (map_gpv' id id option_of_exception (gpv_stop gpv))\n       (obsf_converter conv))\n     (\\<lambda>(x, conv').\n         case x of None \\<Rightarrow> Fail\n         | Some x' \\<Rightarrow> Done (x, conv'))) =\n  map_spmf\n   (\\<lambda>xyz.\n       case xyz of Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n       | Inr (out, rpv, rpv') \\<Rightarrow>\n           IO out\n            (\\<lambda>input.\n                bind_gpv\n                 (bind_gpv (rpv input)\n                   (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                 (\\<lambda>(x, conv').\n                     case x of None \\<Rightarrow> Fail\n                     | Some x' \\<Rightarrow> Done (x, conv'))))\n   (bind_spmf\n     (inline1 run_converter\n       (map_gpv' id id option_of_exception (gpv_stop gpv))\n       (obsf_converter conv))\n     (\\<lambda>xy.\n         case xy of Inl (None, conv') \\<Rightarrow> return_pmf None\n         | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n         | Inr y \\<Rightarrow> return_spmf (Inr y)))\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_generat (=) (=)\n       (rel_fun (=)\n         (\\<lambda>gpv gpv'.\n             (\\<exists>gpva conv.\n                 gpv =\n                 bind_gpv\n                  (inline run_converter\n                    (map_gpv' id id option_of_exception (gpv_stop gpva))\n                    (obsf_converter conv))\n                  (\\<lambda>(x, conv').\n                      case x of None \\<Rightarrow> Fail\n                      | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                 gpv' =\n                 bind_gpv\n                  (map_gpv' id id option_of_exception\n                    (gpv_stop (inline run_converter gpva conv)))\n                  (case_option Fail\n                    (\\<lambda>(x', conv).\n                        Done (Some x', obsf_converter conv)))) \\<or>\n             gpv = gpv' \\<or>\n             (\\<exists>gpv2 gpv2' f f'.\n                 gpv = bind_gpv gpv2 f \\<and>\n                 gpv' = bind_gpv gpv2' f' \\<and>\n                 rel_gpv\n                  (\\<lambda>x y.\n                      \\<exists>gpv conv.\n                         f x =\n                         bind_gpv\n                          (inline run_converter\n                            (map_gpv' id id option_of_exception\n                              (gpv_stop gpv))\n                            (obsf_converter conv))\n                          (\\<lambda>(x, conv').\n                              case x of None \\<Rightarrow> Fail\n                              | Some x' \\<Rightarrow>\n                                  Done (x, conv')) \\<and>\n                         f' y =\n                         bind_gpv\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop (inline run_converter gpv conv)))\n                          (case_option Fail\n                            (\\<lambda>(x', conv).\n                                Done (Some x', obsf_converter conv))))\n                  (=) gpv2 gpv2'))))\n     (the_gpv\n       (bind_gpv\n         (inline run_converter\n           (map_gpv' id id option_of_exception (gpv_stop gpv))\n           (obsf_converter conv))\n         (\\<lambda>(x, conv').\n             case x of None \\<Rightarrow> Fail\n             | Some x' \\<Rightarrow> Done (x, conv'))))\n     (the_gpv\n       (bind_gpv\n         (map_gpv' id id option_of_exception\n           (gpv_stop (inline run_converter gpv conv)))\n         (case_option Fail\n           (\\<lambda>(x', conv). Done (Some x', obsf_converter conv)))))", "also"], ["proof (state)\nthis:\n  the_gpv\n   (bind_gpv\n     (inline run_converter\n       (map_gpv' id id option_of_exception (gpv_stop gpv))\n       (obsf_converter conv))\n     (\\<lambda>(x, conv').\n         case x of None \\<Rightarrow> Fail\n         | Some x' \\<Rightarrow> Done (x, conv'))) =\n  map_spmf\n   (\\<lambda>xyz.\n       case xyz of Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n       | Inr (out, rpv, rpv') \\<Rightarrow>\n           IO out\n            (\\<lambda>input.\n                bind_gpv\n                 (bind_gpv (rpv input)\n                   (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                 (\\<lambda>(x, conv').\n                     case x of None \\<Rightarrow> Fail\n                     | Some x' \\<Rightarrow> Done (x, conv'))))\n   (bind_spmf\n     (inline1 run_converter\n       (map_gpv' id id option_of_exception (gpv_stop gpv))\n       (obsf_converter conv))\n     (\\<lambda>xy.\n         case xy of Inl (None, conv') \\<Rightarrow> return_pmf None\n         | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n         | Inr y \\<Rightarrow> return_spmf (Inr y)))\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_generat (=) (=)\n       (rel_fun (=)\n         (\\<lambda>gpv gpv'.\n             (\\<exists>gpva conv.\n                 gpv =\n                 bind_gpv\n                  (inline run_converter\n                    (map_gpv' id id option_of_exception (gpv_stop gpva))\n                    (obsf_converter conv))\n                  (\\<lambda>(x, conv').\n                      case x of None \\<Rightarrow> Fail\n                      | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                 gpv' =\n                 bind_gpv\n                  (map_gpv' id id option_of_exception\n                    (gpv_stop (inline run_converter gpva conv)))\n                  (case_option Fail\n                    (\\<lambda>(x', conv).\n                        Done (Some x', obsf_converter conv)))) \\<or>\n             gpv = gpv' \\<or>\n             (\\<exists>gpv2 gpv2' f f'.\n                 gpv = bind_gpv gpv2 f \\<and>\n                 gpv' = bind_gpv gpv2' f' \\<and>\n                 rel_gpv\n                  (\\<lambda>x y.\n                      \\<exists>gpv conv.\n                         f x =\n                         bind_gpv\n                          (inline run_converter\n                            (map_gpv' id id option_of_exception\n                              (gpv_stop gpv))\n                            (obsf_converter conv))\n                          (\\<lambda>(x, conv').\n                              case x of None \\<Rightarrow> Fail\n                              | Some x' \\<Rightarrow>\n                                  Done (x, conv')) \\<and>\n                         f' y =\n                         bind_gpv\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop (inline run_converter gpv conv)))\n                          (case_option Fail\n                            (\\<lambda>(x', conv).\n                                Done (Some x', obsf_converter conv))))\n                  (=) gpv2 gpv2'))))\n     (the_gpv\n       (bind_gpv\n         (inline run_converter\n           (map_gpv' id id option_of_exception (gpv_stop gpv))\n           (obsf_converter conv))\n         (\\<lambda>(x, conv').\n             case x of None \\<Rightarrow> Fail\n             | Some x' \\<Rightarrow> Done (x, conv'))))\n     (the_gpv\n       (bind_gpv\n         (map_gpv' id id option_of_exception\n           (gpv_stop (inline run_converter gpv conv)))\n         (case_option Fail\n           (\\<lambda>(x', conv). Done (Some x', obsf_converter conv)))))", "have \"\\<dots> = map_spmf ?f (map_spmf (map_sum (apsnd obsf_converter) (apsnd (map_prod (\\<lambda>rpv. case_exception (Done (Fault, const_converter Fault))\n                     (\\<lambda>input'. map_gpv' (case_option (Fault, const_converter Fault) (\\<lambda>(x, conv'). (OK x, obsf_converter conv'))) id option_of_exception (TRY gpv_stop (rpv input') ELSE Done None)))\n             (\\<lambda>rpv. case_exception (Done None) (\\<lambda>input'. map_gpv' id id option_of_exception (gpv_stop (rpv input')))))))\n       (inline1 run_converter gpv conv))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf\n     (\\<lambda>xyz.\n         case xyz of Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n         | Inr (out, rpv, rpv') \\<Rightarrow>\n             IO out\n              (\\<lambda>input.\n                  bind_gpv\n                   (bind_gpv (rpv input)\n                     (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                   (\\<lambda>(x, conv').\n                       case x of None \\<Rightarrow> Fail\n                       | Some x' \\<Rightarrow> Done (x, conv'))))\n     (bind_spmf\n       (inline1 run_converter\n         (map_gpv' id id option_of_exception (gpv_stop gpv))\n         (obsf_converter conv))\n       (\\<lambda>xy.\n           case xy of Inl (None, conv') \\<Rightarrow> return_pmf None\n           | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n           | Inr y \\<Rightarrow> return_spmf (Inr y))) =\n    map_spmf\n     (\\<lambda>xyz.\n         case xyz of Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n         | Inr (out, rpv, rpv') \\<Rightarrow>\n             IO out\n              (\\<lambda>input.\n                  bind_gpv\n                   (bind_gpv (rpv input)\n                     (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                   (\\<lambda>(x, conv').\n                       case x of None \\<Rightarrow> Fail\n                       | Some x' \\<Rightarrow> Done (x, conv'))))\n     (map_spmf\n       (map_sum (apsnd obsf_converter)\n         (apsnd\n           (map_prod\n             (\\<lambda>rpv.\n                 case_exception (Done (Fault, const_converter Fault))\n                  (\\<lambda>input'.\n                      map_gpv'\n                       (case_option (Fault, const_converter Fault)\n                         (\\<lambda>(x, conv').\n                             (OK x, obsf_converter conv')))\n                       id option_of_exception\n                       (TRY gpv_stop (rpv input') ELSE Done None)))\n             (\\<lambda>rpv.\n                 case_exception (Done None)\n                  (\\<lambda>input'.\n                      map_gpv' id id option_of_exception\n                       (gpv_stop (rpv input')))))))\n       (inline1 run_converter gpv conv))", "by(simp only: inline1_gpv_stop_obsf_converter)"], ["proof (state)\nthis:\n  map_spmf\n   (\\<lambda>xyz.\n       case xyz of Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n       | Inr (out, rpv, rpv') \\<Rightarrow>\n           IO out\n            (\\<lambda>input.\n                bind_gpv\n                 (bind_gpv (rpv input)\n                   (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                 (\\<lambda>(x, conv').\n                     case x of None \\<Rightarrow> Fail\n                     | Some x' \\<Rightarrow> Done (x, conv'))))\n   (bind_spmf\n     (inline1 run_converter\n       (map_gpv' id id option_of_exception (gpv_stop gpv))\n       (obsf_converter conv))\n     (\\<lambda>xy.\n         case xy of Inl (None, conv') \\<Rightarrow> return_pmf None\n         | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n         | Inr y \\<Rightarrow> return_spmf (Inr y))) =\n  map_spmf\n   (\\<lambda>xyz.\n       case xyz of Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n       | Inr (out, rpv, rpv') \\<Rightarrow>\n           IO out\n            (\\<lambda>input.\n                bind_gpv\n                 (bind_gpv (rpv input)\n                   (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                 (\\<lambda>(x, conv').\n                     case x of None \\<Rightarrow> Fail\n                     | Some x' \\<Rightarrow> Done (x, conv'))))\n   (map_spmf\n     (map_sum (apsnd obsf_converter)\n       (apsnd\n         (map_prod\n           (\\<lambda>rpv.\n               case_exception (Done (Fault, const_converter Fault))\n                (\\<lambda>input'.\n                    map_gpv'\n                     (case_option (Fault, const_converter Fault)\n                       (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n                     id option_of_exception\n                     (TRY gpv_stop (rpv input') ELSE Done None)))\n           (\\<lambda>rpv.\n               case_exception (Done None)\n                (\\<lambda>input'.\n                    map_gpv' id id option_of_exception\n                     (gpv_stop (rpv input')))))))\n     (inline1 run_converter gpv conv))\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_generat (=) (=)\n       (rel_fun (=)\n         (\\<lambda>gpv gpv'.\n             (\\<exists>gpva conv.\n                 gpv =\n                 bind_gpv\n                  (inline run_converter\n                    (map_gpv' id id option_of_exception (gpv_stop gpva))\n                    (obsf_converter conv))\n                  (\\<lambda>(x, conv').\n                      case x of None \\<Rightarrow> Fail\n                      | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                 gpv' =\n                 bind_gpv\n                  (map_gpv' id id option_of_exception\n                    (gpv_stop (inline run_converter gpva conv)))\n                  (case_option Fail\n                    (\\<lambda>(x', conv).\n                        Done (Some x', obsf_converter conv)))) \\<or>\n             gpv = gpv' \\<or>\n             (\\<exists>gpv2 gpv2' f f'.\n                 gpv = bind_gpv gpv2 f \\<and>\n                 gpv' = bind_gpv gpv2' f' \\<and>\n                 rel_gpv\n                  (\\<lambda>x y.\n                      \\<exists>gpv conv.\n                         f x =\n                         bind_gpv\n                          (inline run_converter\n                            (map_gpv' id id option_of_exception\n                              (gpv_stop gpv))\n                            (obsf_converter conv))\n                          (\\<lambda>(x, conv').\n                              case x of None \\<Rightarrow> Fail\n                              | Some x' \\<Rightarrow>\n                                  Done (x, conv')) \\<and>\n                         f' y =\n                         bind_gpv\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop (inline run_converter gpv conv)))\n                          (case_option Fail\n                            (\\<lambda>(x', conv).\n                                Done (Some x', obsf_converter conv))))\n                  (=) gpv2 gpv2'))))\n     (the_gpv\n       (bind_gpv\n         (inline run_converter\n           (map_gpv' id id option_of_exception (gpv_stop gpv))\n           (obsf_converter conv))\n         (\\<lambda>(x, conv').\n             case x of None \\<Rightarrow> Fail\n             | Some x' \\<Rightarrow> Done (x, conv'))))\n     (the_gpv\n       (bind_gpv\n         (map_gpv' id id option_of_exception\n           (gpv_stop (inline run_converter gpv conv)))\n         (case_option Fail\n           (\\<lambda>(x', conv). Done (Some x', obsf_converter conv)))))", "also"], ["proof (state)\nthis:\n  map_spmf\n   (\\<lambda>xyz.\n       case xyz of Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n       | Inr (out, rpv, rpv') \\<Rightarrow>\n           IO out\n            (\\<lambda>input.\n                bind_gpv\n                 (bind_gpv (rpv input)\n                   (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                 (\\<lambda>(x, conv').\n                     case x of None \\<Rightarrow> Fail\n                     | Some x' \\<Rightarrow> Done (x, conv'))))\n   (bind_spmf\n     (inline1 run_converter\n       (map_gpv' id id option_of_exception (gpv_stop gpv))\n       (obsf_converter conv))\n     (\\<lambda>xy.\n         case xy of Inl (None, conv') \\<Rightarrow> return_pmf None\n         | Inl (Some x, conv') \\<Rightarrow> return_spmf (Inl (x, conv'))\n         | Inr y \\<Rightarrow> return_spmf (Inr y))) =\n  map_spmf\n   (\\<lambda>xyz.\n       case xyz of Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n       | Inr (out, rpv, rpv') \\<Rightarrow>\n           IO out\n            (\\<lambda>input.\n                bind_gpv\n                 (bind_gpv (rpv input)\n                   (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                 (\\<lambda>(x, conv').\n                     case x of None \\<Rightarrow> Fail\n                     | Some x' \\<Rightarrow> Done (x, conv'))))\n   (map_spmf\n     (map_sum (apsnd obsf_converter)\n       (apsnd\n         (map_prod\n           (\\<lambda>rpv.\n               case_exception (Done (Fault, const_converter Fault))\n                (\\<lambda>input'.\n                    map_gpv'\n                     (case_option (Fault, const_converter Fault)\n                       (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n                     id option_of_exception\n                     (TRY gpv_stop (rpv input') ELSE Done None)))\n           (\\<lambda>rpv.\n               case_exception (Done None)\n                (\\<lambda>input'.\n                    map_gpv' id id option_of_exception\n                     (gpv_stop (rpv input')))))))\n     (inline1 run_converter gpv conv))\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_generat (=) (=)\n       (rel_fun (=)\n         (\\<lambda>gpv gpv'.\n             (\\<exists>gpva conv.\n                 gpv =\n                 bind_gpv\n                  (inline run_converter\n                    (map_gpv' id id option_of_exception (gpv_stop gpva))\n                    (obsf_converter conv))\n                  (\\<lambda>(x, conv').\n                      case x of None \\<Rightarrow> Fail\n                      | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                 gpv' =\n                 bind_gpv\n                  (map_gpv' id id option_of_exception\n                    (gpv_stop (inline run_converter gpva conv)))\n                  (case_option Fail\n                    (\\<lambda>(x', conv).\n                        Done (Some x', obsf_converter conv)))) \\<or>\n             gpv = gpv' \\<or>\n             (\\<exists>gpv2 gpv2' f f'.\n                 gpv = bind_gpv gpv2 f \\<and>\n                 gpv' = bind_gpv gpv2' f' \\<and>\n                 rel_gpv\n                  (\\<lambda>x y.\n                      \\<exists>gpv conv.\n                         f x =\n                         bind_gpv\n                          (inline run_converter\n                            (map_gpv' id id option_of_exception\n                              (gpv_stop gpv))\n                            (obsf_converter conv))\n                          (\\<lambda>(x, conv').\n                              case x of None \\<Rightarrow> Fail\n                              | Some x' \\<Rightarrow>\n                                  Done (x, conv')) \\<and>\n                         f' y =\n                         bind_gpv\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop (inline run_converter gpv conv)))\n                          (case_option Fail\n                            (\\<lambda>(x', conv).\n                                Done (Some x', obsf_converter conv))))\n                  (=) gpv2 gpv2'))))\n     (the_gpv\n       (bind_gpv\n         (inline run_converter\n           (map_gpv' id id option_of_exception (gpv_stop gpv))\n           (obsf_converter conv))\n         (\\<lambda>(x, conv').\n             case x of None \\<Rightarrow> Fail\n             | Some x' \\<Rightarrow> Done (x, conv'))))\n     (the_gpv\n       (bind_gpv\n         (map_gpv' id id option_of_exception\n           (gpv_stop (inline run_converter gpv conv)))\n         (case_option Fail\n           (\\<lambda>(x', conv). Done (Some x', obsf_converter conv)))))", "have \"\\<dots> = bind_spmf (inline1 run_converter gpv conv) (\\<lambda>y. return_spmf (?f (map_sum (apsnd obsf_converter)\n                     (apsnd (map_prod (\\<lambda>rpv. case_exception (Done (Fault, const_converter Fault)) (\\<lambda>input'. map_gpv' (case_option (Fault, const_converter Fault) (\\<lambda>(x, conv'). (OK x, obsf_converter conv'))) id option_of_exception (TRY gpv_stop (rpv input') ELSE Done None)))\n                         (\\<lambda>rpv. case_exception (Done None) (\\<lambda>input'. map_gpv' id id option_of_exception (gpv_stop (rpv input'))))))\n                     y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf\n     (\\<lambda>xyz.\n         case xyz of Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n         | Inr (out, rpv, rpv') \\<Rightarrow>\n             IO out\n              (\\<lambda>input.\n                  bind_gpv\n                   (bind_gpv (rpv input)\n                     (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                   (\\<lambda>(x, conv').\n                       case x of None \\<Rightarrow> Fail\n                       | Some x' \\<Rightarrow> Done (x, conv'))))\n     (map_spmf\n       (map_sum (apsnd obsf_converter)\n         (apsnd\n           (map_prod\n             (\\<lambda>rpv.\n                 case_exception (Done (Fault, const_converter Fault))\n                  (\\<lambda>input'.\n                      map_gpv'\n                       (case_option (Fault, const_converter Fault)\n                         (\\<lambda>(x, conv').\n                             (OK x, obsf_converter conv')))\n                       id option_of_exception\n                       (TRY gpv_stop (rpv input') ELSE Done None)))\n             (\\<lambda>rpv.\n                 case_exception (Done None)\n                  (\\<lambda>input'.\n                      map_gpv' id id option_of_exception\n                       (gpv_stop (rpv input')))))))\n       (inline1 run_converter gpv conv)) =\n    bind_spmf (inline1 run_converter gpv conv)\n     (\\<lambda>y.\n         return_spmf\n          (case map_sum (apsnd obsf_converter)\n                 (apsnd\n                   (map_prod\n                     (\\<lambda>rpv.\n                         case_exception\n                          (Done (Fault, const_converter Fault))\n                          (\\<lambda>input'.\n                              map_gpv'\n                               (case_option (Fault, const_converter Fault)\n                                 (\\<lambda>(x, conv').\n                                     (OK x, obsf_converter conv')))\n                               id option_of_exception\n                               (TRY gpv_stop (rpv input') ELSE Done None)))\n                     (\\<lambda>rpv.\n                         case_exception (Done None)\n                          (\\<lambda>input'.\n                              map_gpv' id id option_of_exception\n                               (gpv_stop (rpv input'))))))\n                 y of\n           Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n           | Inr (out, rpv, rpv') \\<Rightarrow>\n               IO out\n                (\\<lambda>input.\n                    bind_gpv\n                     (bind_gpv (rpv input)\n                       (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv')))))", "by(simp add: map_spmf_conv_bind_spmf)"], ["proof (state)\nthis:\n  map_spmf\n   (\\<lambda>xyz.\n       case xyz of Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n       | Inr (out, rpv, rpv') \\<Rightarrow>\n           IO out\n            (\\<lambda>input.\n                bind_gpv\n                 (bind_gpv (rpv input)\n                   (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                 (\\<lambda>(x, conv').\n                     case x of None \\<Rightarrow> Fail\n                     | Some x' \\<Rightarrow> Done (x, conv'))))\n   (map_spmf\n     (map_sum (apsnd obsf_converter)\n       (apsnd\n         (map_prod\n           (\\<lambda>rpv.\n               case_exception (Done (Fault, const_converter Fault))\n                (\\<lambda>input'.\n                    map_gpv'\n                     (case_option (Fault, const_converter Fault)\n                       (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n                     id option_of_exception\n                     (TRY gpv_stop (rpv input') ELSE Done None)))\n           (\\<lambda>rpv.\n               case_exception (Done None)\n                (\\<lambda>input'.\n                    map_gpv' id id option_of_exception\n                     (gpv_stop (rpv input')))))))\n     (inline1 run_converter gpv conv)) =\n  bind_spmf (inline1 run_converter gpv conv)\n   (\\<lambda>y.\n       return_spmf\n        (case map_sum (apsnd obsf_converter)\n               (apsnd\n                 (map_prod\n                   (\\<lambda>rpv.\n                       case_exception (Done (Fault, const_converter Fault))\n                        (\\<lambda>input'.\n                            map_gpv'\n                             (case_option (Fault, const_converter Fault)\n                               (\\<lambda>(x, conv').\n                                   (OK x, obsf_converter conv')))\n                             id option_of_exception\n                             (TRY gpv_stop (rpv input') ELSE Done None)))\n                   (\\<lambda>rpv.\n                       case_exception (Done None)\n                        (\\<lambda>input'.\n                            map_gpv' id id option_of_exception\n                             (gpv_stop (rpv input'))))))\n               y of\n         Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n         | Inr (out, rpv, rpv') \\<Rightarrow>\n             IO out\n              (\\<lambda>input.\n                  bind_gpv\n                   (bind_gpv (rpv input)\n                     (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                   (\\<lambda>(x, conv').\n                       case x of None \\<Rightarrow> Fail\n                       | Some x' \\<Rightarrow> Done (x, conv')))))\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_generat (=) (=)\n       (rel_fun (=)\n         (\\<lambda>gpv gpv'.\n             (\\<exists>gpva conv.\n                 gpv =\n                 bind_gpv\n                  (inline run_converter\n                    (map_gpv' id id option_of_exception (gpv_stop gpva))\n                    (obsf_converter conv))\n                  (\\<lambda>(x, conv').\n                      case x of None \\<Rightarrow> Fail\n                      | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                 gpv' =\n                 bind_gpv\n                  (map_gpv' id id option_of_exception\n                    (gpv_stop (inline run_converter gpva conv)))\n                  (case_option Fail\n                    (\\<lambda>(x', conv).\n                        Done (Some x', obsf_converter conv)))) \\<or>\n             gpv = gpv' \\<or>\n             (\\<exists>gpv2 gpv2' f f'.\n                 gpv = bind_gpv gpv2 f \\<and>\n                 gpv' = bind_gpv gpv2' f' \\<and>\n                 rel_gpv\n                  (\\<lambda>x y.\n                      \\<exists>gpv conv.\n                         f x =\n                         bind_gpv\n                          (inline run_converter\n                            (map_gpv' id id option_of_exception\n                              (gpv_stop gpv))\n                            (obsf_converter conv))\n                          (\\<lambda>(x, conv').\n                              case x of None \\<Rightarrow> Fail\n                              | Some x' \\<Rightarrow>\n                                  Done (x, conv')) \\<and>\n                         f' y =\n                         bind_gpv\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop (inline run_converter gpv conv)))\n                          (case_option Fail\n                            (\\<lambda>(x', conv).\n                                Done (Some x', obsf_converter conv))))\n                  (=) gpv2 gpv2'))))\n     (the_gpv\n       (bind_gpv\n         (inline run_converter\n           (map_gpv' id id option_of_exception (gpv_stop gpv))\n           (obsf_converter conv))\n         (\\<lambda>(x, conv').\n             case x of None \\<Rightarrow> Fail\n             | Some x' \\<Rightarrow> Done (x, conv'))))\n     (the_gpv\n       (bind_gpv\n         (map_gpv' id id option_of_exception\n           (gpv_stop (inline run_converter gpv conv)))\n         (case_option Fail\n           (\\<lambda>(x', conv). Done (Some x', obsf_converter conv)))))", "also"], ["proof (state)\nthis:\n  map_spmf\n   (\\<lambda>xyz.\n       case xyz of Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n       | Inr (out, rpv, rpv') \\<Rightarrow>\n           IO out\n            (\\<lambda>input.\n                bind_gpv\n                 (bind_gpv (rpv input)\n                   (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                 (\\<lambda>(x, conv').\n                     case x of None \\<Rightarrow> Fail\n                     | Some x' \\<Rightarrow> Done (x, conv'))))\n   (map_spmf\n     (map_sum (apsnd obsf_converter)\n       (apsnd\n         (map_prod\n           (\\<lambda>rpv.\n               case_exception (Done (Fault, const_converter Fault))\n                (\\<lambda>input'.\n                    map_gpv'\n                     (case_option (Fault, const_converter Fault)\n                       (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n                     id option_of_exception\n                     (TRY gpv_stop (rpv input') ELSE Done None)))\n           (\\<lambda>rpv.\n               case_exception (Done None)\n                (\\<lambda>input'.\n                    map_gpv' id id option_of_exception\n                     (gpv_stop (rpv input')))))))\n     (inline1 run_converter gpv conv)) =\n  bind_spmf (inline1 run_converter gpv conv)\n   (\\<lambda>y.\n       return_spmf\n        (case map_sum (apsnd obsf_converter)\n               (apsnd\n                 (map_prod\n                   (\\<lambda>rpv.\n                       case_exception (Done (Fault, const_converter Fault))\n                        (\\<lambda>input'.\n                            map_gpv'\n                             (case_option (Fault, const_converter Fault)\n                               (\\<lambda>(x, conv').\n                                   (OK x, obsf_converter conv')))\n                             id option_of_exception\n                             (TRY gpv_stop (rpv input') ELSE Done None)))\n                   (\\<lambda>rpv.\n                       case_exception (Done None)\n                        (\\<lambda>input'.\n                            map_gpv' id id option_of_exception\n                             (gpv_stop (rpv input'))))))\n               y of\n         Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n         | Inr (out, rpv, rpv') \\<Rightarrow>\n             IO out\n              (\\<lambda>input.\n                  bind_gpv\n                   (bind_gpv (rpv input)\n                     (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                   (\\<lambda>(x, conv').\n                       case x of None \\<Rightarrow> Fail\n                       | Some x' \\<Rightarrow> Done (x, conv')))))\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_generat (=) (=)\n       (rel_fun (=)\n         (\\<lambda>gpv gpv'.\n             (\\<exists>gpva conv.\n                 gpv =\n                 bind_gpv\n                  (inline run_converter\n                    (map_gpv' id id option_of_exception (gpv_stop gpva))\n                    (obsf_converter conv))\n                  (\\<lambda>(x, conv').\n                      case x of None \\<Rightarrow> Fail\n                      | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                 gpv' =\n                 bind_gpv\n                  (map_gpv' id id option_of_exception\n                    (gpv_stop (inline run_converter gpva conv)))\n                  (case_option Fail\n                    (\\<lambda>(x', conv).\n                        Done (Some x', obsf_converter conv)))) \\<or>\n             gpv = gpv' \\<or>\n             (\\<exists>gpv2 gpv2' f f'.\n                 gpv = bind_gpv gpv2 f \\<and>\n                 gpv' = bind_gpv gpv2' f' \\<and>\n                 rel_gpv\n                  (\\<lambda>x y.\n                      \\<exists>gpv conv.\n                         f x =\n                         bind_gpv\n                          (inline run_converter\n                            (map_gpv' id id option_of_exception\n                              (gpv_stop gpv))\n                            (obsf_converter conv))\n                          (\\<lambda>(x, conv').\n                              case x of None \\<Rightarrow> Fail\n                              | Some x' \\<Rightarrow>\n                                  Done (x, conv')) \\<and>\n                         f' y =\n                         bind_gpv\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop (inline run_converter gpv conv)))\n                          (case_option Fail\n                            (\\<lambda>(x', conv).\n                                Done (Some x', obsf_converter conv))))\n                  (=) gpv2 gpv2'))))\n     (the_gpv\n       (bind_gpv\n         (inline run_converter\n           (map_gpv' id id option_of_exception (gpv_stop gpv))\n           (obsf_converter conv))\n         (\\<lambda>(x, conv').\n             case x of None \\<Rightarrow> Fail\n             | Some x' \\<Rightarrow> Done (x, conv'))))\n     (the_gpv\n       (bind_gpv\n         (map_gpv' id id option_of_exception\n           (gpv_stop (inline run_converter gpv conv)))\n         (case_option Fail\n           (\\<lambda>(x', conv). Done (Some x', obsf_converter conv)))))", "have \"rel_spmf ?X \\<dots> (bind_spmf (inline1 run_converter gpv conv)\n       (\\<lambda>x. map_spmf (map_generat id id ((\\<circ>) (case_sum id (\\<lambda>r. bind_gpv r (case_option Fail (\\<lambda>(x', conv). Done (Some x', obsf_converter conv)))))))\n              (case map_generat id id (map_fun option_of_exception (map_gpv' id id option_of_exception))\n                     (map_generat Some id (\\<lambda>rpv. case_option (Done None) (\\<lambda>input'. gpv_stop (rpv input')))\n                       (case x of Inl x \\<Rightarrow> Pure x\n                        | Inr (out, oracle, rpv) \\<Rightarrow> IO out (\\<lambda>input. bind_gpv (oracle input) (\\<lambda>(x, y). inline run_converter (rpv x) y)))) of\n               Pure x \\<Rightarrow>\n                 map_spmf (map_generat id id ((\\<circ>) Inl)) (the_gpv (case x of None \\<Rightarrow> Fail | Some (x', conv) \\<Rightarrow> Done (Some x', obsf_converter conv)))\n               | IO out c \\<Rightarrow> return_spmf (IO out (\\<lambda>input. Inr (c input))))))\" \n      (is \"rel_spmf _ _ ?rhs2\" is \"rel_spmf _ (bind_spmf _ ?L) (bind_spmf _ ?R)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_generat (=) (=)\n       (rel_fun (=)\n         (\\<lambda>gpv gpv'.\n             (\\<exists>gpva conv.\n                 gpv =\n                 bind_gpv\n                  (inline run_converter\n                    (map_gpv' id id option_of_exception (gpv_stop gpva))\n                    (obsf_converter conv))\n                  (\\<lambda>(x, conv').\n                      case x of None \\<Rightarrow> Fail\n                      | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                 gpv' =\n                 bind_gpv\n                  (map_gpv' id id option_of_exception\n                    (gpv_stop (inline run_converter gpva conv)))\n                  (case_option Fail\n                    (\\<lambda>(x', conv).\n                        Done (Some x', obsf_converter conv)))) \\<or>\n             gpv = gpv' \\<or>\n             (\\<exists>gpv2 gpv2' f f'.\n                 gpv = bind_gpv gpv2 f \\<and>\n                 gpv' = bind_gpv gpv2' f' \\<and>\n                 rel_gpv\n                  (\\<lambda>x y.\n                      \\<exists>gpv conv.\n                         f x =\n                         bind_gpv\n                          (inline run_converter\n                            (map_gpv' id id option_of_exception\n                              (gpv_stop gpv))\n                            (obsf_converter conv))\n                          (\\<lambda>(x, conv').\n                              case x of None \\<Rightarrow> Fail\n                              | Some x' \\<Rightarrow>\n                                  Done (x, conv')) \\<and>\n                         f' y =\n                         bind_gpv\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop (inline run_converter gpv conv)))\n                          (case_option Fail\n                            (\\<lambda>(x', conv).\n                                Done (Some x', obsf_converter conv))))\n                  (=) gpv2 gpv2'))))\n     (bind_spmf (inline1 run_converter gpv conv)\n       (\\<lambda>y.\n           return_spmf\n            (case map_sum (apsnd obsf_converter)\n                   (apsnd\n                     (map_prod\n                       (\\<lambda>rpv.\n                           case_exception\n                            (Done (Fault, const_converter Fault))\n                            (\\<lambda>input'.\n                                map_gpv'\n                                 (case_option (Fault, const_converter Fault)\n                                   (\\<lambda>(x, conv').\n (OK x, obsf_converter conv')))\n                                 id option_of_exception\n                                 (TRY gpv_stop\n (rpv input') ELSE Done None)))\n                       (\\<lambda>rpv.\n                           case_exception (Done None)\n                            (\\<lambda>input'.\n                                map_gpv' id id option_of_exception\n                                 (gpv_stop (rpv input'))))))\n                   y of\n             Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n             | Inr (out, rpv, rpv') \\<Rightarrow>\n                 IO out\n                  (\\<lambda>input.\n                      bind_gpv\n                       (bind_gpv (rpv input)\n                         (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                       (\\<lambda>(x, conv').\n                           case x of None \\<Rightarrow> Fail\n                           | Some x' \\<Rightarrow> Done (x, conv'))))))\n     (bind_spmf (inline1 run_converter gpv conv)\n       (\\<lambda>x.\n           map_spmf\n            (map_generat id id\n              ((\\<circ>)\n                (case_sum id\n                  (\\<lambda>r.\n                      bind_gpv r\n                       (case_option Fail\n                         (\\<lambda>(x', conv).\n                             Done (Some x', obsf_converter conv)))))))\n            (case map_generat id id\n                   (map_fun option_of_exception\n                     (map_gpv' id id option_of_exception))\n                   (map_generat Some id\n                     (\\<lambda>rpv.\n                         case_option (Done None)\n                          (\\<lambda>input'. gpv_stop (rpv input')))\n                     (case x of Inl x \\<Rightarrow> Pure x\n                      | Inr (out, oracle, rpv) \\<Rightarrow>\n                          IO out\n                           (\\<lambda>input.\n                               bind_gpv (oracle input)\n                                (\\<lambda>(x, y).\n                                    inline run_converter (rpv x) y)))) of\n             Pure x \\<Rightarrow>\n               map_spmf (map_generat id id ((\\<circ>) Inl))\n                (the_gpv\n                  (case x of None \\<Rightarrow> Fail\n                   | Some (x', conv) \\<Rightarrow>\n                       Done (Some x', obsf_converter conv)))\n             | IO out c \\<Rightarrow>\n                 return_spmf (IO out (\\<lambda>input. Inr (c input))))))", "proof(rule rel_spmf_bind_reflI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_spmf (inline1 run_converter gpv conv) \\<Longrightarrow>\n       rel_spmf\n        (rel_generat (=) (=)\n          (rel_fun (=)\n            (\\<lambda>gpv gpv'.\n                (\\<exists>gpva conv.\n                    gpv =\n                    bind_gpv\n                     (inline run_converter\n                       (map_gpv' id id option_of_exception (gpv_stop gpva))\n                       (obsf_converter conv))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                    gpv' =\n                    bind_gpv\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop (inline run_converter gpva conv)))\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))) \\<or>\n                gpv = gpv' \\<or>\n                (\\<exists>gpv2 gpv2' f f'.\n                    gpv = bind_gpv gpv2 f \\<and>\n                    gpv' = bind_gpv gpv2' f' \\<and>\n                    rel_gpv\n                     (\\<lambda>x y.\n                         \\<exists>gpv conv.\n                            f x =\n                            bind_gpv\n                             (inline run_converter\n                               (map_gpv' id id option_of_exception\n                                 (gpv_stop gpv))\n                               (obsf_converter conv))\n                             (\\<lambda>(x, conv').\n                                 case x of None \\<Rightarrow> Fail\n                                 | Some x' \\<Rightarrow>\n                                     Done (x, conv')) \\<and>\n                            f' y =\n                            bind_gpv\n                             (map_gpv' id id option_of_exception\n                               (gpv_stop (inline run_converter gpv conv)))\n                             (case_option Fail\n                               (\\<lambda>(x', conv).\n                                   Done (Some x', obsf_converter conv))))\n                     (=) gpv2 gpv2'))))\n        (return_spmf\n          (case map_sum (apsnd obsf_converter)\n                 (apsnd\n                   (map_prod\n                     (\\<lambda>rpv.\n                         case_exception\n                          (Done (Fault, const_converter Fault))\n                          (\\<lambda>input'.\n                              map_gpv'\n                               (case_option (Fault, const_converter Fault)\n                                 (\\<lambda>(x, conv').\n                                     (OK x, obsf_converter conv')))\n                               id option_of_exception\n                               (TRY gpv_stop (rpv input') ELSE Done None)))\n                     (\\<lambda>rpv.\n                         case_exception (Done None)\n                          (\\<lambda>input'.\n                              map_gpv' id id option_of_exception\n                               (gpv_stop (rpv input'))))))\n                 x of\n           Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n           | Inr (out, rpv, rpv') \\<Rightarrow>\n               IO out\n                (\\<lambda>input.\n                    bind_gpv\n                     (bind_gpv (rpv input)\n                       (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv')))))\n        (map_spmf\n          (map_generat id id\n            ((\\<circ>)\n              (case_sum id\n                (\\<lambda>r.\n                    bind_gpv r\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))))))\n          (case map_generat id id\n                 (map_fun option_of_exception\n                   (map_gpv' id id option_of_exception))\n                 (map_generat Some id\n                   (\\<lambda>rpv.\n                       case_option (Done None)\n                        (\\<lambda>input'. gpv_stop (rpv input')))\n                   (case x of Inl x \\<Rightarrow> Pure x\n                    | Inr (out, oracle, rpv) \\<Rightarrow>\n                        IO out\n                         (\\<lambda>input.\n                             bind_gpv (oracle input)\n                              (\\<lambda>(x, y).\n                                  inline run_converter (rpv x) y)))) of\n           Pure x \\<Rightarrow>\n             map_spmf (map_generat id id ((\\<circ>) Inl))\n              (the_gpv\n                (case x of None \\<Rightarrow> Fail\n                 | Some (x', conv) \\<Rightarrow>\n                     Done (Some x', obsf_converter conv)))\n           | IO out c \\<Rightarrow>\n               return_spmf (IO out (\\<lambda>input. Inr (c input)))))", "fix x :: \"'a \\<times> ('b, 'c, 'd, 'e) converter + 'd \\<times> ('c \\<times> ('b, 'c, 'd, 'e) converter, 'd, 'e) rpv \\<times> ('a, 'b, 'c) rpv\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_spmf (inline1 run_converter gpv conv) \\<Longrightarrow>\n       rel_spmf\n        (rel_generat (=) (=)\n          (rel_fun (=)\n            (\\<lambda>gpv gpv'.\n                (\\<exists>gpva conv.\n                    gpv =\n                    bind_gpv\n                     (inline run_converter\n                       (map_gpv' id id option_of_exception (gpv_stop gpva))\n                       (obsf_converter conv))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                    gpv' =\n                    bind_gpv\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop (inline run_converter gpva conv)))\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))) \\<or>\n                gpv = gpv' \\<or>\n                (\\<exists>gpv2 gpv2' f f'.\n                    gpv = bind_gpv gpv2 f \\<and>\n                    gpv' = bind_gpv gpv2' f' \\<and>\n                    rel_gpv\n                     (\\<lambda>x y.\n                         \\<exists>gpv conv.\n                            f x =\n                            bind_gpv\n                             (inline run_converter\n                               (map_gpv' id id option_of_exception\n                                 (gpv_stop gpv))\n                               (obsf_converter conv))\n                             (\\<lambda>(x, conv').\n                                 case x of None \\<Rightarrow> Fail\n                                 | Some x' \\<Rightarrow>\n                                     Done (x, conv')) \\<and>\n                            f' y =\n                            bind_gpv\n                             (map_gpv' id id option_of_exception\n                               (gpv_stop (inline run_converter gpv conv)))\n                             (case_option Fail\n                               (\\<lambda>(x', conv).\n                                   Done (Some x', obsf_converter conv))))\n                     (=) gpv2 gpv2'))))\n        (return_spmf\n          (case map_sum (apsnd obsf_converter)\n                 (apsnd\n                   (map_prod\n                     (\\<lambda>rpv.\n                         case_exception\n                          (Done (Fault, const_converter Fault))\n                          (\\<lambda>input'.\n                              map_gpv'\n                               (case_option (Fault, const_converter Fault)\n                                 (\\<lambda>(x, conv').\n                                     (OK x, obsf_converter conv')))\n                               id option_of_exception\n                               (TRY gpv_stop (rpv input') ELSE Done None)))\n                     (\\<lambda>rpv.\n                         case_exception (Done None)\n                          (\\<lambda>input'.\n                              map_gpv' id id option_of_exception\n                               (gpv_stop (rpv input'))))))\n                 x of\n           Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n           | Inr (out, rpv, rpv') \\<Rightarrow>\n               IO out\n                (\\<lambda>input.\n                    bind_gpv\n                     (bind_gpv (rpv input)\n                       (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv')))))\n        (map_spmf\n          (map_generat id id\n            ((\\<circ>)\n              (case_sum id\n                (\\<lambda>r.\n                    bind_gpv r\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))))))\n          (case map_generat id id\n                 (map_fun option_of_exception\n                   (map_gpv' id id option_of_exception))\n                 (map_generat Some id\n                   (\\<lambda>rpv.\n                       case_option (Done None)\n                        (\\<lambda>input'. gpv_stop (rpv input')))\n                   (case x of Inl x \\<Rightarrow> Pure x\n                    | Inr (out, oracle, rpv) \\<Rightarrow>\n                        IO out\n                         (\\<lambda>input.\n                             bind_gpv (oracle input)\n                              (\\<lambda>(x, y).\n                                  inline run_converter (rpv x) y)))) of\n           Pure x \\<Rightarrow>\n             map_spmf (map_generat id id ((\\<circ>) Inl))\n              (the_gpv\n                (case x of None \\<Rightarrow> Fail\n                 | Some (x', conv) \\<Rightarrow>\n                     Done (Some x', obsf_converter conv)))\n           | IO out c \\<Rightarrow>\n               return_spmf (IO out (\\<lambda>input. Inr (c input)))))", "assume x: \"x \\<in> set_spmf (inline1 run_converter gpv conv)\""], ["proof (state)\nthis:\n  x \\<in> set_spmf (inline1 run_converter gpv conv)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_spmf (inline1 run_converter gpv conv) \\<Longrightarrow>\n       rel_spmf\n        (rel_generat (=) (=)\n          (rel_fun (=)\n            (\\<lambda>gpv gpv'.\n                (\\<exists>gpva conv.\n                    gpv =\n                    bind_gpv\n                     (inline run_converter\n                       (map_gpv' id id option_of_exception (gpv_stop gpva))\n                       (obsf_converter conv))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                    gpv' =\n                    bind_gpv\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop (inline run_converter gpva conv)))\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))) \\<or>\n                gpv = gpv' \\<or>\n                (\\<exists>gpv2 gpv2' f f'.\n                    gpv = bind_gpv gpv2 f \\<and>\n                    gpv' = bind_gpv gpv2' f' \\<and>\n                    rel_gpv\n                     (\\<lambda>x y.\n                         \\<exists>gpv conv.\n                            f x =\n                            bind_gpv\n                             (inline run_converter\n                               (map_gpv' id id option_of_exception\n                                 (gpv_stop gpv))\n                               (obsf_converter conv))\n                             (\\<lambda>(x, conv').\n                                 case x of None \\<Rightarrow> Fail\n                                 | Some x' \\<Rightarrow>\n                                     Done (x, conv')) \\<and>\n                            f' y =\n                            bind_gpv\n                             (map_gpv' id id option_of_exception\n                               (gpv_stop (inline run_converter gpv conv)))\n                             (case_option Fail\n                               (\\<lambda>(x', conv).\n                                   Done (Some x', obsf_converter conv))))\n                     (=) gpv2 gpv2'))))\n        (return_spmf\n          (case map_sum (apsnd obsf_converter)\n                 (apsnd\n                   (map_prod\n                     (\\<lambda>rpv.\n                         case_exception\n                          (Done (Fault, const_converter Fault))\n                          (\\<lambda>input'.\n                              map_gpv'\n                               (case_option (Fault, const_converter Fault)\n                                 (\\<lambda>(x, conv').\n                                     (OK x, obsf_converter conv')))\n                               id option_of_exception\n                               (TRY gpv_stop (rpv input') ELSE Done None)))\n                     (\\<lambda>rpv.\n                         case_exception (Done None)\n                          (\\<lambda>input'.\n                              map_gpv' id id option_of_exception\n                               (gpv_stop (rpv input'))))))\n                 x of\n           Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n           | Inr (out, rpv, rpv') \\<Rightarrow>\n               IO out\n                (\\<lambda>input.\n                    bind_gpv\n                     (bind_gpv (rpv input)\n                       (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv')))))\n        (map_spmf\n          (map_generat id id\n            ((\\<circ>)\n              (case_sum id\n                (\\<lambda>r.\n                    bind_gpv r\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))))))\n          (case map_generat id id\n                 (map_fun option_of_exception\n                   (map_gpv' id id option_of_exception))\n                 (map_generat Some id\n                   (\\<lambda>rpv.\n                       case_option (Done None)\n                        (\\<lambda>input'. gpv_stop (rpv input')))\n                   (case x of Inl x \\<Rightarrow> Pure x\n                    | Inr (out, oracle, rpv) \\<Rightarrow>\n                        IO out\n                         (\\<lambda>input.\n                             bind_gpv (oracle input)\n                              (\\<lambda>(x, y).\n                                  inline run_converter (rpv x) y)))) of\n           Pure x \\<Rightarrow>\n             map_spmf (map_generat id id ((\\<circ>) Inl))\n              (the_gpv\n                (case x of None \\<Rightarrow> Fail\n                 | Some (x', conv) \\<Rightarrow>\n                     Done (Some x', obsf_converter conv)))\n           | IO out c \\<Rightarrow>\n               return_spmf (IO out (\\<lambda>input. Inr (c input)))))", "consider (Inl) a conv' where \"x = Inl (a, conv')\" | (Inr) out rpv rpv' where \"x = Inr (out, rpv, rpv')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a conv'. x = Inl (a, conv') \\<Longrightarrow> thesis;\n     \\<And>out rpv rpv'.\n        x = Inr (out, rpv, rpv') \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(cases x) auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>a conv'. x = Inl (a, conv') \\<Longrightarrow> ?thesis2;\n   \\<And>out rpv rpv'.\n      x = Inr (out, rpv, rpv') \\<Longrightarrow> ?thesis2\\<rbrakk>\n  \\<Longrightarrow> ?thesis2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set_spmf (inline1 run_converter gpv conv) \\<Longrightarrow>\n       rel_spmf\n        (rel_generat (=) (=)\n          (rel_fun (=)\n            (\\<lambda>gpv gpv'.\n                (\\<exists>gpva conv.\n                    gpv =\n                    bind_gpv\n                     (inline run_converter\n                       (map_gpv' id id option_of_exception (gpv_stop gpva))\n                       (obsf_converter conv))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                    gpv' =\n                    bind_gpv\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop (inline run_converter gpva conv)))\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))) \\<or>\n                gpv = gpv' \\<or>\n                (\\<exists>gpv2 gpv2' f f'.\n                    gpv = bind_gpv gpv2 f \\<and>\n                    gpv' = bind_gpv gpv2' f' \\<and>\n                    rel_gpv\n                     (\\<lambda>x y.\n                         \\<exists>gpv conv.\n                            f x =\n                            bind_gpv\n                             (inline run_converter\n                               (map_gpv' id id option_of_exception\n                                 (gpv_stop gpv))\n                               (obsf_converter conv))\n                             (\\<lambda>(x, conv').\n                                 case x of None \\<Rightarrow> Fail\n                                 | Some x' \\<Rightarrow>\n                                     Done (x, conv')) \\<and>\n                            f' y =\n                            bind_gpv\n                             (map_gpv' id id option_of_exception\n                               (gpv_stop (inline run_converter gpv conv)))\n                             (case_option Fail\n                               (\\<lambda>(x', conv).\n                                   Done (Some x', obsf_converter conv))))\n                     (=) gpv2 gpv2'))))\n        (return_spmf\n          (case map_sum (apsnd obsf_converter)\n                 (apsnd\n                   (map_prod\n                     (\\<lambda>rpv.\n                         case_exception\n                          (Done (Fault, const_converter Fault))\n                          (\\<lambda>input'.\n                              map_gpv'\n                               (case_option (Fault, const_converter Fault)\n                                 (\\<lambda>(x, conv').\n                                     (OK x, obsf_converter conv')))\n                               id option_of_exception\n                               (TRY gpv_stop (rpv input') ELSE Done None)))\n                     (\\<lambda>rpv.\n                         case_exception (Done None)\n                          (\\<lambda>input'.\n                              map_gpv' id id option_of_exception\n                               (gpv_stop (rpv input'))))))\n                 x of\n           Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n           | Inr (out, rpv, rpv') \\<Rightarrow>\n               IO out\n                (\\<lambda>input.\n                    bind_gpv\n                     (bind_gpv (rpv input)\n                       (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv')))))\n        (map_spmf\n          (map_generat id id\n            ((\\<circ>)\n              (case_sum id\n                (\\<lambda>r.\n                    bind_gpv r\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))))))\n          (case map_generat id id\n                 (map_fun option_of_exception\n                   (map_gpv' id id option_of_exception))\n                 (map_generat Some id\n                   (\\<lambda>rpv.\n                       case_option (Done None)\n                        (\\<lambda>input'. gpv_stop (rpv input')))\n                   (case x of Inl x \\<Rightarrow> Pure x\n                    | Inr (out, oracle, rpv) \\<Rightarrow>\n                        IO out\n                         (\\<lambda>input.\n                             bind_gpv (oracle input)\n                              (\\<lambda>(x, y).\n                                  inline run_converter (rpv x) y)))) of\n           Pure x \\<Rightarrow>\n             map_spmf (map_generat id id ((\\<circ>) Inl))\n              (the_gpv\n                (case x of None \\<Rightarrow> Fail\n                 | Some (x', conv) \\<Rightarrow>\n                     Done (Some x', obsf_converter conv)))\n           | IO out c \\<Rightarrow>\n               return_spmf (IO out (\\<lambda>input. Inr (c input)))))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>a conv'. x = Inl (a, conv') \\<Longrightarrow> ?thesis2;\n   \\<And>out rpv rpv'.\n      x = Inr (out, rpv, rpv') \\<Longrightarrow> ?thesis2\\<rbrakk>\n  \\<Longrightarrow> ?thesis2", "show \"rel_spmf ?X (?L x) (?R x)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>a conv'. x = Inl (a, conv') \\<Longrightarrow> ?thesis2;\n   \\<And>out rpv rpv'.\n      x = Inr (out, rpv, rpv') \\<Longrightarrow> ?thesis2\\<rbrakk>\n  \\<Longrightarrow> ?thesis2\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_generat (=) (=)\n       (rel_fun (=)\n         (\\<lambda>gpv gpv'.\n             (\\<exists>gpva conv.\n                 gpv =\n                 bind_gpv\n                  (inline run_converter\n                    (map_gpv' id id option_of_exception (gpv_stop gpva))\n                    (obsf_converter conv))\n                  (\\<lambda>(x, conv').\n                      case x of None \\<Rightarrow> Fail\n                      | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                 gpv' =\n                 bind_gpv\n                  (map_gpv' id id option_of_exception\n                    (gpv_stop (inline run_converter gpva conv)))\n                  (case_option Fail\n                    (\\<lambda>(x', conv).\n                        Done (Some x', obsf_converter conv)))) \\<or>\n             gpv = gpv' \\<or>\n             (\\<exists>gpv2 gpv2' f f'.\n                 gpv = bind_gpv gpv2 f \\<and>\n                 gpv' = bind_gpv gpv2' f' \\<and>\n                 rel_gpv\n                  (\\<lambda>x y.\n                      \\<exists>gpv conv.\n                         f x =\n                         bind_gpv\n                          (inline run_converter\n                            (map_gpv' id id option_of_exception\n                              (gpv_stop gpv))\n                            (obsf_converter conv))\n                          (\\<lambda>(x, conv').\n                              case x of None \\<Rightarrow> Fail\n                              | Some x' \\<Rightarrow>\n                                  Done (x, conv')) \\<and>\n                         f' y =\n                         bind_gpv\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop (inline run_converter gpv conv)))\n                          (case_option Fail\n                            (\\<lambda>(x', conv).\n                                Done (Some x', obsf_converter conv))))\n                  (=) gpv2 gpv2'))))\n     (return_spmf\n       (case map_sum (apsnd obsf_converter)\n              (apsnd\n                (map_prod\n                  (\\<lambda>rpv.\n                      case_exception (Done (Fault, const_converter Fault))\n                       (\\<lambda>input'.\n                           map_gpv'\n                            (case_option (Fault, const_converter Fault)\n                              (\\<lambda>(x, conv').\n                                  (OK x, obsf_converter conv')))\n                            id option_of_exception\n                            (TRY gpv_stop (rpv input') ELSE Done None)))\n                  (\\<lambda>rpv.\n                      case_exception (Done None)\n                       (\\<lambda>input'.\n                           map_gpv' id id option_of_exception\n                            (gpv_stop (rpv input'))))))\n              x of\n        Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n        | Inr (out, rpv, rpv') \\<Rightarrow>\n            IO out\n             (\\<lambda>input.\n                 bind_gpv\n                  (bind_gpv (rpv input)\n                    (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                  (\\<lambda>(x, conv').\n                      case x of None \\<Rightarrow> Fail\n                      | Some x' \\<Rightarrow> Done (x, conv')))))\n     (map_spmf\n       (map_generat id id\n         ((\\<circ>)\n           (case_sum id\n             (\\<lambda>r.\n                 bind_gpv r\n                  (case_option Fail\n                    (\\<lambda>(x', conv).\n                        Done (Some x', obsf_converter conv)))))))\n       (case map_generat id id\n              (map_fun option_of_exception\n                (map_gpv' id id option_of_exception))\n              (map_generat Some id\n                (\\<lambda>rpv.\n                    case_option (Done None)\n                     (\\<lambda>input'. gpv_stop (rpv input')))\n                (case x of Inl x \\<Rightarrow> Pure x\n                 | Inr (out, oracle, rpv) \\<Rightarrow>\n                     IO out\n                      (\\<lambda>input.\n                          bind_gpv (oracle input)\n                           (\\<lambda>(x, y).\n                               inline run_converter (rpv x) y)))) of\n        Pure x \\<Rightarrow>\n          map_spmf (map_generat id id ((\\<circ>) Inl))\n           (the_gpv\n             (case x of None \\<Rightarrow> Fail\n              | Some (x', conv) \\<Rightarrow>\n                  Done (Some x', obsf_converter conv)))\n        | IO out c \\<Rightarrow>\n            return_spmf (IO out (\\<lambda>input. Inr (c input)))))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a conv'.\n       x = Inl (a, conv') \\<Longrightarrow>\n       rel_spmf\n        (rel_generat (=) (=)\n          (rel_fun (=)\n            (\\<lambda>gpv gpv'.\n                (\\<exists>gpva conv.\n                    gpv =\n                    bind_gpv\n                     (inline run_converter\n                       (map_gpv' id id option_of_exception (gpv_stop gpva))\n                       (obsf_converter conv))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                    gpv' =\n                    bind_gpv\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop (inline run_converter gpva conv)))\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))) \\<or>\n                gpv = gpv' \\<or>\n                (\\<exists>gpv2 gpv2' f f'.\n                    gpv = bind_gpv gpv2 f \\<and>\n                    gpv' = bind_gpv gpv2' f' \\<and>\n                    rel_gpv\n                     (\\<lambda>x y.\n                         \\<exists>gpv conv.\n                            f x =\n                            bind_gpv\n                             (inline run_converter\n                               (map_gpv' id id option_of_exception\n                                 (gpv_stop gpv))\n                               (obsf_converter conv))\n                             (\\<lambda>(x, conv').\n                                 case x of None \\<Rightarrow> Fail\n                                 | Some x' \\<Rightarrow>\n                                     Done (x, conv')) \\<and>\n                            f' y =\n                            bind_gpv\n                             (map_gpv' id id option_of_exception\n                               (gpv_stop (inline run_converter gpv conv)))\n                             (case_option Fail\n                               (\\<lambda>(x', conv).\n                                   Done (Some x', obsf_converter conv))))\n                     (=) gpv2 gpv2'))))\n        (return_spmf\n          (case map_sum (apsnd obsf_converter)\n                 (apsnd\n                   (map_prod\n                     (\\<lambda>rpv.\n                         case_exception\n                          (Done (Fault, const_converter Fault))\n                          (\\<lambda>input'.\n                              map_gpv'\n                               (case_option (Fault, const_converter Fault)\n                                 (\\<lambda>(x, conv').\n                                     (OK x, obsf_converter conv')))\n                               id option_of_exception\n                               (TRY gpv_stop (rpv input') ELSE Done None)))\n                     (\\<lambda>rpv.\n                         case_exception (Done None)\n                          (\\<lambda>input'.\n                              map_gpv' id id option_of_exception\n                               (gpv_stop (rpv input'))))))\n                 x of\n           Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n           | Inr (out, rpv, rpv') \\<Rightarrow>\n               IO out\n                (\\<lambda>input.\n                    bind_gpv\n                     (bind_gpv (rpv input)\n                       (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv')))))\n        (map_spmf\n          (map_generat id id\n            ((\\<circ>)\n              (case_sum id\n                (\\<lambda>r.\n                    bind_gpv r\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))))))\n          (case map_generat id id\n                 (map_fun option_of_exception\n                   (map_gpv' id id option_of_exception))\n                 (map_generat Some id\n                   (\\<lambda>rpv.\n                       case_option (Done None)\n                        (\\<lambda>input'. gpv_stop (rpv input')))\n                   (case x of Inl x \\<Rightarrow> Pure x\n                    | Inr (out, oracle, rpv) \\<Rightarrow>\n                        IO out\n                         (\\<lambda>input.\n                             bind_gpv (oracle input)\n                              (\\<lambda>(x, y).\n                                  inline run_converter (rpv x) y)))) of\n           Pure x \\<Rightarrow>\n             map_spmf (map_generat id id ((\\<circ>) Inl))\n              (the_gpv\n                (case x of None \\<Rightarrow> Fail\n                 | Some (x', conv) \\<Rightarrow>\n                     Done (Some x', obsf_converter conv)))\n           | IO out c \\<Rightarrow>\n               return_spmf (IO out (\\<lambda>input. Inr (c input)))))\n 2. \\<And>out rpv rpv'.\n       x = Inr (out, rpv, rpv') \\<Longrightarrow>\n       rel_spmf\n        (rel_generat (=) (=)\n          (rel_fun (=)\n            (\\<lambda>gpv gpv'.\n                (\\<exists>gpva conv.\n                    gpv =\n                    bind_gpv\n                     (inline run_converter\n                       (map_gpv' id id option_of_exception (gpv_stop gpva))\n                       (obsf_converter conv))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                    gpv' =\n                    bind_gpv\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop (inline run_converter gpva conv)))\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))) \\<or>\n                gpv = gpv' \\<or>\n                (\\<exists>gpv2 gpv2' f f'.\n                    gpv = bind_gpv gpv2 f \\<and>\n                    gpv' = bind_gpv gpv2' f' \\<and>\n                    rel_gpv\n                     (\\<lambda>x y.\n                         \\<exists>gpv conv.\n                            f x =\n                            bind_gpv\n                             (inline run_converter\n                               (map_gpv' id id option_of_exception\n                                 (gpv_stop gpv))\n                               (obsf_converter conv))\n                             (\\<lambda>(x, conv').\n                                 case x of None \\<Rightarrow> Fail\n                                 | Some x' \\<Rightarrow>\n                                     Done (x, conv')) \\<and>\n                            f' y =\n                            bind_gpv\n                             (map_gpv' id id option_of_exception\n                               (gpv_stop (inline run_converter gpv conv)))\n                             (case_option Fail\n                               (\\<lambda>(x', conv).\n                                   Done (Some x', obsf_converter conv))))\n                     (=) gpv2 gpv2'))))\n        (return_spmf\n          (case map_sum (apsnd obsf_converter)\n                 (apsnd\n                   (map_prod\n                     (\\<lambda>rpv.\n                         case_exception\n                          (Done (Fault, const_converter Fault))\n                          (\\<lambda>input'.\n                              map_gpv'\n                               (case_option (Fault, const_converter Fault)\n                                 (\\<lambda>(x, conv').\n                                     (OK x, obsf_converter conv')))\n                               id option_of_exception\n                               (TRY gpv_stop (rpv input') ELSE Done None)))\n                     (\\<lambda>rpv.\n                         case_exception (Done None)\n                          (\\<lambda>input'.\n                              map_gpv' id id option_of_exception\n                               (gpv_stop (rpv input'))))))\n                 x of\n           Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n           | Inr (out, rpv, rpv') \\<Rightarrow>\n               IO out\n                (\\<lambda>input.\n                    bind_gpv\n                     (bind_gpv (rpv input)\n                       (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv')))))\n        (map_spmf\n          (map_generat id id\n            ((\\<circ>)\n              (case_sum id\n                (\\<lambda>r.\n                    bind_gpv r\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))))))\n          (case map_generat id id\n                 (map_fun option_of_exception\n                   (map_gpv' id id option_of_exception))\n                 (map_generat Some id\n                   (\\<lambda>rpv.\n                       case_option (Done None)\n                        (\\<lambda>input'. gpv_stop (rpv input')))\n                   (case x of Inl x \\<Rightarrow> Pure x\n                    | Inr (out, oracle, rpv) \\<Rightarrow>\n                        IO out\n                         (\\<lambda>input.\n                             bind_gpv (oracle input)\n                              (\\<lambda>(x, y).\n                                  inline run_converter (rpv x) y)))) of\n           Pure x \\<Rightarrow>\n             map_spmf (map_generat id id ((\\<circ>) Inl))\n              (the_gpv\n                (case x of None \\<Rightarrow> Fail\n                 | Some (x', conv) \\<Rightarrow>\n                     Done (Some x', obsf_converter conv)))\n           | IO out c \\<Rightarrow>\n               return_spmf (IO out (\\<lambda>input. Inr (c input)))))", "case Inr"], ["proof (state)\nthis:\n  x = Inr (out, rpv, rpv')\n\ngoal (2 subgoals):\n 1. \\<And>a conv'.\n       x = Inl (a, conv') \\<Longrightarrow>\n       rel_spmf\n        (rel_generat (=) (=)\n          (rel_fun (=)\n            (\\<lambda>gpv gpv'.\n                (\\<exists>gpva conv.\n                    gpv =\n                    bind_gpv\n                     (inline run_converter\n                       (map_gpv' id id option_of_exception (gpv_stop gpva))\n                       (obsf_converter conv))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                    gpv' =\n                    bind_gpv\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop (inline run_converter gpva conv)))\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))) \\<or>\n                gpv = gpv' \\<or>\n                (\\<exists>gpv2 gpv2' f f'.\n                    gpv = bind_gpv gpv2 f \\<and>\n                    gpv' = bind_gpv gpv2' f' \\<and>\n                    rel_gpv\n                     (\\<lambda>x y.\n                         \\<exists>gpv conv.\n                            f x =\n                            bind_gpv\n                             (inline run_converter\n                               (map_gpv' id id option_of_exception\n                                 (gpv_stop gpv))\n                               (obsf_converter conv))\n                             (\\<lambda>(x, conv').\n                                 case x of None \\<Rightarrow> Fail\n                                 | Some x' \\<Rightarrow>\n                                     Done (x, conv')) \\<and>\n                            f' y =\n                            bind_gpv\n                             (map_gpv' id id option_of_exception\n                               (gpv_stop (inline run_converter gpv conv)))\n                             (case_option Fail\n                               (\\<lambda>(x', conv).\n                                   Done (Some x', obsf_converter conv))))\n                     (=) gpv2 gpv2'))))\n        (return_spmf\n          (case map_sum (apsnd obsf_converter)\n                 (apsnd\n                   (map_prod\n                     (\\<lambda>rpv.\n                         case_exception\n                          (Done (Fault, const_converter Fault))\n                          (\\<lambda>input'.\n                              map_gpv'\n                               (case_option (Fault, const_converter Fault)\n                                 (\\<lambda>(x, conv').\n                                     (OK x, obsf_converter conv')))\n                               id option_of_exception\n                               (TRY gpv_stop (rpv input') ELSE Done None)))\n                     (\\<lambda>rpv.\n                         case_exception (Done None)\n                          (\\<lambda>input'.\n                              map_gpv' id id option_of_exception\n                               (gpv_stop (rpv input'))))))\n                 x of\n           Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n           | Inr (out, rpv, rpv') \\<Rightarrow>\n               IO out\n                (\\<lambda>input.\n                    bind_gpv\n                     (bind_gpv (rpv input)\n                       (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv')))))\n        (map_spmf\n          (map_generat id id\n            ((\\<circ>)\n              (case_sum id\n                (\\<lambda>r.\n                    bind_gpv r\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))))))\n          (case map_generat id id\n                 (map_fun option_of_exception\n                   (map_gpv' id id option_of_exception))\n                 (map_generat Some id\n                   (\\<lambda>rpv.\n                       case_option (Done None)\n                        (\\<lambda>input'. gpv_stop (rpv input')))\n                   (case x of Inl x \\<Rightarrow> Pure x\n                    | Inr (out, oracle, rpv) \\<Rightarrow>\n                        IO out\n                         (\\<lambda>input.\n                             bind_gpv (oracle input)\n                              (\\<lambda>(x, y).\n                                  inline run_converter (rpv x) y)))) of\n           Pure x \\<Rightarrow>\n             map_spmf (map_generat id id ((\\<circ>) Inl))\n              (the_gpv\n                (case x of None \\<Rightarrow> Fail\n                 | Some (x', conv) \\<Rightarrow>\n                     Done (Some x', obsf_converter conv)))\n           | IO out c \\<Rightarrow>\n               return_spmf (IO out (\\<lambda>input. Inr (c input)))))\n 2. \\<And>out rpv rpv'.\n       x = Inr (out, rpv, rpv') \\<Longrightarrow>\n       rel_spmf\n        (rel_generat (=) (=)\n          (rel_fun (=)\n            (\\<lambda>gpv gpv'.\n                (\\<exists>gpva conv.\n                    gpv =\n                    bind_gpv\n                     (inline run_converter\n                       (map_gpv' id id option_of_exception (gpv_stop gpva))\n                       (obsf_converter conv))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                    gpv' =\n                    bind_gpv\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop (inline run_converter gpva conv)))\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))) \\<or>\n                gpv = gpv' \\<or>\n                (\\<exists>gpv2 gpv2' f f'.\n                    gpv = bind_gpv gpv2 f \\<and>\n                    gpv' = bind_gpv gpv2' f' \\<and>\n                    rel_gpv\n                     (\\<lambda>x y.\n                         \\<exists>gpv conv.\n                            f x =\n                            bind_gpv\n                             (inline run_converter\n                               (map_gpv' id id option_of_exception\n                                 (gpv_stop gpv))\n                               (obsf_converter conv))\n                             (\\<lambda>(x, conv').\n                                 case x of None \\<Rightarrow> Fail\n                                 | Some x' \\<Rightarrow>\n                                     Done (x, conv')) \\<and>\n                            f' y =\n                            bind_gpv\n                             (map_gpv' id id option_of_exception\n                               (gpv_stop (inline run_converter gpv conv)))\n                             (case_option Fail\n                               (\\<lambda>(x', conv).\n                                   Done (Some x', obsf_converter conv))))\n                     (=) gpv2 gpv2'))))\n        (return_spmf\n          (case map_sum (apsnd obsf_converter)\n                 (apsnd\n                   (map_prod\n                     (\\<lambda>rpv.\n                         case_exception\n                          (Done (Fault, const_converter Fault))\n                          (\\<lambda>input'.\n                              map_gpv'\n                               (case_option (Fault, const_converter Fault)\n                                 (\\<lambda>(x, conv').\n                                     (OK x, obsf_converter conv')))\n                               id option_of_exception\n                               (TRY gpv_stop (rpv input') ELSE Done None)))\n                     (\\<lambda>rpv.\n                         case_exception (Done None)\n                          (\\<lambda>input'.\n                              map_gpv' id id option_of_exception\n                               (gpv_stop (rpv input'))))))\n                 x of\n           Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n           | Inr (out, rpv, rpv') \\<Rightarrow>\n               IO out\n                (\\<lambda>input.\n                    bind_gpv\n                     (bind_gpv (rpv input)\n                       (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv')))))\n        (map_spmf\n          (map_generat id id\n            ((\\<circ>)\n              (case_sum id\n                (\\<lambda>r.\n                    bind_gpv r\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))))))\n          (case map_generat id id\n                 (map_fun option_of_exception\n                   (map_gpv' id id option_of_exception))\n                 (map_generat Some id\n                   (\\<lambda>rpv.\n                       case_option (Done None)\n                        (\\<lambda>input'. gpv_stop (rpv input')))\n                   (case x of Inl x \\<Rightarrow> Pure x\n                    | Inr (out, oracle, rpv) \\<Rightarrow>\n                        IO out\n                         (\\<lambda>input.\n                             bind_gpv (oracle input)\n                              (\\<lambda>(x, y).\n                                  inline run_converter (rpv x) y)))) of\n           Pure x \\<Rightarrow>\n             map_spmf (map_generat id id ((\\<circ>) Inl))\n              (the_gpv\n                (case x of None \\<Rightarrow> Fail\n                 | Some (x', conv) \\<Rightarrow>\n                     Done (Some x', obsf_converter conv)))\n           | IO out c \\<Rightarrow>\n               return_spmf (IO out (\\<lambda>input. Inr (c input)))))", "have \"\\<exists>(gpv2 :: ('c \\<times> ('b, 'c, 'd, 'e) converter, 'd, 'e exception) gpv) (gpv2' :: ('c \\<times> ('b, 'c, 'd, 'e) converter, 'd, 'e exception) gpv) f f'.\n           bind_gpv (map_gpv' (case_option (Fault, const_converter Fault) (\\<lambda>p. (OK (fst p), obsf_converter (snd p)))) id option_of_exception (TRY gpv_stop (rpv input) ELSE Done None))\n             (\\<lambda>x. case fst x of Fault \\<Rightarrow> Fail | OK xa \\<Rightarrow> bind_gpv (inline run_converter (map_gpv' id id option_of_exception (gpv_stop (rpv' xa))) (snd x)) (\\<lambda>p. case fst p of None \\<Rightarrow> Fail | Some x' \\<Rightarrow> Done (Some x', snd p))) =\n             bind_gpv gpv2 f \\<and>\n           bind_gpv (map_gpv' id id option_of_exception (gpv_stop (rpv input))) (case_option Fail (\\<lambda>x. bind_gpv (map_gpv' id id option_of_exception (gpv_stop (inline run_converter (rpv' (fst x)) (snd x)))) (case_option Fail (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p)))))) =\n             bind_gpv gpv2' f' \\<and>\n           rel_gpv (\\<lambda>x y. \\<exists>gpv conv. f x = bind_gpv (inline run_converter (map_gpv' id id option_of_exception (gpv_stop gpv)) (obsf_converter conv)) (\\<lambda>p. case fst p of None \\<Rightarrow> Fail | Some x' \\<Rightarrow> Done (Some x', snd p)) \\<and>\n                     f' y = bind_gpv (map_gpv' id id option_of_exception (gpv_stop (inline run_converter gpv conv))) (case_option Fail (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p)))))\n              (=) gpv2 gpv2'\"\n          (is \"\\<exists>gpv2 gpv2' f f'. ?lhs1 input = _ \\<and> ?rhs1 input = _ \\<and> rel_gpv (?X f f') _ _ _\") for input"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>gpv2 gpv2' f f'.\n       bind_gpv\n        (map_gpv'\n          (case_option (Fault, const_converter Fault)\n            (\\<lambda>p. (OK (fst p), obsf_converter (snd p))))\n          id option_of_exception (TRY gpv_stop (rpv input) ELSE Done None))\n        (\\<lambda>x.\n            case fst x of Fault \\<Rightarrow> Fail\n            | OK xa \\<Rightarrow>\n                bind_gpv\n                 (inline run_converter\n                   (map_gpv' id id option_of_exception (gpv_stop (rpv' xa)))\n                   (snd x))\n                 (\\<lambda>p.\n                     case fst p of None \\<Rightarrow> Fail\n                     | Some x' \\<Rightarrow> Done (Some x', snd p))) =\n       bind_gpv gpv2 f \\<and>\n       bind_gpv (map_gpv' id id option_of_exception (gpv_stop (rpv input)))\n        (case_option Fail\n          (\\<lambda>x.\n              bind_gpv\n               (map_gpv' id id option_of_exception\n                 (gpv_stop (inline run_converter (rpv' (fst x)) (snd x))))\n               (case_option Fail\n                 (\\<lambda>p.\n                     Done (Some (fst p), obsf_converter (snd p)))))) =\n       bind_gpv gpv2' f' \\<and>\n       rel_gpv\n        (\\<lambda>x y.\n            \\<exists>gpv conv.\n               f x =\n               bind_gpv\n                (inline run_converter\n                  (map_gpv' id id option_of_exception (gpv_stop gpv))\n                  (obsf_converter conv))\n                (\\<lambda>p.\n                    case fst p of None \\<Rightarrow> Fail\n                    | Some x' \\<Rightarrow> Done (Some x', snd p)) \\<and>\n               f' y =\n               bind_gpv\n                (map_gpv' id id option_of_exception\n                  (gpv_stop (inline run_converter gpv conv)))\n                (case_option Fail\n                  (\\<lambda>p.\n                      Done (Some (fst p), obsf_converter (snd p)))))\n        (=) gpv2 gpv2'", "proof(intro exI conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. bind_gpv\n     (map_gpv'\n       (case_option (Fault, const_converter Fault)\n         (\\<lambda>p. (OK (fst p), obsf_converter (snd p))))\n       id option_of_exception (TRY gpv_stop (rpv input) ELSE Done None))\n     (\\<lambda>x.\n         case fst x of Fault \\<Rightarrow> Fail\n         | OK xa \\<Rightarrow>\n             bind_gpv\n              (inline run_converter\n                (map_gpv' id id option_of_exception (gpv_stop (rpv' xa)))\n                (snd x))\n              (\\<lambda>p.\n                  case fst p of None \\<Rightarrow> Fail\n                  | Some x' \\<Rightarrow> Done (Some x', snd p))) =\n    bind_gpv ?gpv2.0 ?f2\n 2. bind_gpv (map_gpv' id id option_of_exception (gpv_stop (rpv input)))\n     (case_option Fail\n       (\\<lambda>x.\n           bind_gpv\n            (map_gpv' id id option_of_exception\n              (gpv_stop (inline run_converter (rpv' (fst x)) (snd x))))\n            (case_option Fail\n              (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p)))))) =\n    bind_gpv ?gpv2'1 ?f'3\n 3. rel_gpv\n     (\\<lambda>x y.\n         \\<exists>gpv conv.\n            ?f2 x =\n            bind_gpv\n             (inline run_converter\n               (map_gpv' id id option_of_exception (gpv_stop gpv))\n               (obsf_converter conv))\n             (\\<lambda>p.\n                 case fst p of None \\<Rightarrow> Fail\n                 | Some x' \\<Rightarrow> Done (Some x', snd p)) \\<and>\n            ?f'3 y =\n            bind_gpv\n             (map_gpv' id id option_of_exception\n               (gpv_stop (inline run_converter gpv conv)))\n             (case_option Fail\n               (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p)))))\n     (=) ?gpv2.0 ?gpv2'1", "let ?gpv2 = \"bind_gpv (map_gpv' id id option_of_exception (TRY gpv_stop (rpv input) ELSE Done None)) (\\<lambda>x. case x of None \\<Rightarrow> Fail | Some x \\<Rightarrow> Done x)\""], ["proof (state)\ngoal (3 subgoals):\n 1. bind_gpv\n     (map_gpv'\n       (case_option (Fault, const_converter Fault)\n         (\\<lambda>p. (OK (fst p), obsf_converter (snd p))))\n       id option_of_exception (TRY gpv_stop (rpv input) ELSE Done None))\n     (\\<lambda>x.\n         case fst x of Fault \\<Rightarrow> Fail\n         | OK xa \\<Rightarrow>\n             bind_gpv\n              (inline run_converter\n                (map_gpv' id id option_of_exception (gpv_stop (rpv' xa)))\n                (snd x))\n              (\\<lambda>p.\n                  case fst p of None \\<Rightarrow> Fail\n                  | Some x' \\<Rightarrow> Done (Some x', snd p))) =\n    bind_gpv ?gpv2.0 ?f2\n 2. bind_gpv (map_gpv' id id option_of_exception (gpv_stop (rpv input)))\n     (case_option Fail\n       (\\<lambda>x.\n           bind_gpv\n            (map_gpv' id id option_of_exception\n              (gpv_stop (inline run_converter (rpv' (fst x)) (snd x))))\n            (case_option Fail\n              (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p)))))) =\n    bind_gpv ?gpv2'1 ?f'3\n 3. rel_gpv\n     (\\<lambda>x y.\n         \\<exists>gpv conv.\n            ?f2 x =\n            bind_gpv\n             (inline run_converter\n               (map_gpv' id id option_of_exception (gpv_stop gpv))\n               (obsf_converter conv))\n             (\\<lambda>p.\n                 case fst p of None \\<Rightarrow> Fail\n                 | Some x' \\<Rightarrow> Done (Some x', snd p)) \\<and>\n            ?f'3 y =\n            bind_gpv\n             (map_gpv' id id option_of_exception\n               (gpv_stop (inline run_converter gpv conv)))\n             (case_option Fail\n               (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p)))))\n     (=) ?gpv2.0 ?gpv2'1", "let ?gpv2' = \"bind_gpv (map_gpv' id id option_of_exception (gpv_stop (rpv input))) (\\<lambda>x. case x of None \\<Rightarrow> Fail | Some x \\<Rightarrow> Done x)\""], ["proof (state)\ngoal (3 subgoals):\n 1. bind_gpv\n     (map_gpv'\n       (case_option (Fault, const_converter Fault)\n         (\\<lambda>p. (OK (fst p), obsf_converter (snd p))))\n       id option_of_exception (TRY gpv_stop (rpv input) ELSE Done None))\n     (\\<lambda>x.\n         case fst x of Fault \\<Rightarrow> Fail\n         | OK xa \\<Rightarrow>\n             bind_gpv\n              (inline run_converter\n                (map_gpv' id id option_of_exception (gpv_stop (rpv' xa)))\n                (snd x))\n              (\\<lambda>p.\n                  case fst p of None \\<Rightarrow> Fail\n                  | Some x' \\<Rightarrow> Done (Some x', snd p))) =\n    bind_gpv ?gpv2.0 ?f2\n 2. bind_gpv (map_gpv' id id option_of_exception (gpv_stop (rpv input)))\n     (case_option Fail\n       (\\<lambda>x.\n           bind_gpv\n            (map_gpv' id id option_of_exception\n              (gpv_stop (inline run_converter (rpv' (fst x)) (snd x))))\n            (case_option Fail\n              (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p)))))) =\n    bind_gpv ?gpv2'1 ?f'3\n 3. rel_gpv\n     (\\<lambda>x y.\n         \\<exists>gpv conv.\n            ?f2 x =\n            bind_gpv\n             (inline run_converter\n               (map_gpv' id id option_of_exception (gpv_stop gpv))\n               (obsf_converter conv))\n             (\\<lambda>p.\n                 case fst p of None \\<Rightarrow> Fail\n                 | Some x' \\<Rightarrow> Done (Some x', snd p)) \\<and>\n            ?f'3 y =\n            bind_gpv\n             (map_gpv' id id option_of_exception\n               (gpv_stop (inline run_converter gpv conv)))\n             (case_option Fail\n               (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p)))))\n     (=) ?gpv2.0 ?gpv2'1", "let ?f = \"\\<lambda>x. bind_gpv (inline run_converter (map_gpv' id id option_of_exception (gpv_stop (rpv' (fst x)))) (obsf_converter (snd x))) (\\<lambda>p. case fst p of None \\<Rightarrow> Fail | Some x' \\<Rightarrow> Done (Some x', snd p))\""], ["proof (state)\ngoal (3 subgoals):\n 1. bind_gpv\n     (map_gpv'\n       (case_option (Fault, const_converter Fault)\n         (\\<lambda>p. (OK (fst p), obsf_converter (snd p))))\n       id option_of_exception (TRY gpv_stop (rpv input) ELSE Done None))\n     (\\<lambda>x.\n         case fst x of Fault \\<Rightarrow> Fail\n         | OK xa \\<Rightarrow>\n             bind_gpv\n              (inline run_converter\n                (map_gpv' id id option_of_exception (gpv_stop (rpv' xa)))\n                (snd x))\n              (\\<lambda>p.\n                  case fst p of None \\<Rightarrow> Fail\n                  | Some x' \\<Rightarrow> Done (Some x', snd p))) =\n    bind_gpv ?gpv2.0 ?f2\n 2. bind_gpv (map_gpv' id id option_of_exception (gpv_stop (rpv input)))\n     (case_option Fail\n       (\\<lambda>x.\n           bind_gpv\n            (map_gpv' id id option_of_exception\n              (gpv_stop (inline run_converter (rpv' (fst x)) (snd x))))\n            (case_option Fail\n              (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p)))))) =\n    bind_gpv ?gpv2'1 ?f'3\n 3. rel_gpv\n     (\\<lambda>x y.\n         \\<exists>gpv conv.\n            ?f2 x =\n            bind_gpv\n             (inline run_converter\n               (map_gpv' id id option_of_exception (gpv_stop gpv))\n               (obsf_converter conv))\n             (\\<lambda>p.\n                 case fst p of None \\<Rightarrow> Fail\n                 | Some x' \\<Rightarrow> Done (Some x', snd p)) \\<and>\n            ?f'3 y =\n            bind_gpv\n             (map_gpv' id id option_of_exception\n               (gpv_stop (inline run_converter gpv conv)))\n             (case_option Fail\n               (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p)))))\n     (=) ?gpv2.0 ?gpv2'1", "let ?f' = \"\\<lambda>x. bind_gpv (map_gpv' id id option_of_exception (gpv_stop (inline run_converter (rpv' (fst x)) (snd x)))) (case_option Fail (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p))))\""], ["proof (state)\ngoal (3 subgoals):\n 1. bind_gpv\n     (map_gpv'\n       (case_option (Fault, const_converter Fault)\n         (\\<lambda>p. (OK (fst p), obsf_converter (snd p))))\n       id option_of_exception (TRY gpv_stop (rpv input) ELSE Done None))\n     (\\<lambda>x.\n         case fst x of Fault \\<Rightarrow> Fail\n         | OK xa \\<Rightarrow>\n             bind_gpv\n              (inline run_converter\n                (map_gpv' id id option_of_exception (gpv_stop (rpv' xa)))\n                (snd x))\n              (\\<lambda>p.\n                  case fst p of None \\<Rightarrow> Fail\n                  | Some x' \\<Rightarrow> Done (Some x', snd p))) =\n    bind_gpv ?gpv2.0 ?f2\n 2. bind_gpv (map_gpv' id id option_of_exception (gpv_stop (rpv input)))\n     (case_option Fail\n       (\\<lambda>x.\n           bind_gpv\n            (map_gpv' id id option_of_exception\n              (gpv_stop (inline run_converter (rpv' (fst x)) (snd x))))\n            (case_option Fail\n              (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p)))))) =\n    bind_gpv ?gpv2'1 ?f'3\n 3. rel_gpv\n     (\\<lambda>x y.\n         \\<exists>gpv conv.\n            ?f2 x =\n            bind_gpv\n             (inline run_converter\n               (map_gpv' id id option_of_exception (gpv_stop gpv))\n               (obsf_converter conv))\n             (\\<lambda>p.\n                 case fst p of None \\<Rightarrow> Fail\n                 | Some x' \\<Rightarrow> Done (Some x', snd p)) \\<and>\n            ?f'3 y =\n            bind_gpv\n             (map_gpv' id id option_of_exception\n               (gpv_stop (inline run_converter gpv conv)))\n             (case_option Fail\n               (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p)))))\n     (=) ?gpv2.0 ?gpv2'1", "show \"?lhs1 input = bind_gpv ?gpv2 ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_gpv\n     (map_gpv'\n       (\\<lambda>a.\n           case a of None \\<Rightarrow> (Fault, const_converter Fault)\n           | Some p \\<Rightarrow> (OK (fst p), obsf_converter (snd p)))\n       id option_of_exception (TRY gpv_stop (rpv input) ELSE Done None))\n     (\\<lambda>x.\n         case fst x of Fault \\<Rightarrow> Fail\n         | OK xa \\<Rightarrow>\n             bind_gpv\n              (inline run_converter\n                (map_gpv' id id option_of_exception (gpv_stop (rpv' xa)))\n                (snd x))\n              (\\<lambda>p.\n                  case fst p of None \\<Rightarrow> Fail\n                  | Some x' \\<Rightarrow> Done (Some x', snd p))) =\n    bind_gpv\n     (bind_gpv\n       (map_gpv' id id option_of_exception\n         (TRY gpv_stop (rpv input) ELSE Done None))\n       (\\<lambda>x.\n           case x of None \\<Rightarrow> Fail | Some x \\<Rightarrow> Done x))\n     (\\<lambda>x.\n         bind_gpv\n          (inline run_converter\n            (map_gpv' id id option_of_exception (gpv_stop (rpv' (fst x))))\n            (obsf_converter (snd x)))\n          (\\<lambda>p.\n              case fst p of None \\<Rightarrow> Fail\n              | Some x' \\<Rightarrow> Done (Some x', snd p)))", "by(subst map_gpv'_id12[THEN trans, OF map_gpv'_map_gpv_swap])\n              (auto simp add: bind_map_gpv o_def bind_gpv_assoc intro!: bind_gpv_cong split!: option.split)"], ["proof (state)\nthis:\n  bind_gpv\n   (map_gpv'\n     (\\<lambda>a.\n         case a of None \\<Rightarrow> (Fault, const_converter Fault)\n         | Some p \\<Rightarrow> (OK (fst p), obsf_converter (snd p)))\n     id option_of_exception (TRY gpv_stop (rpv input) ELSE Done None))\n   (\\<lambda>x.\n       case fst x of Fault \\<Rightarrow> Fail\n       | OK xa \\<Rightarrow>\n           bind_gpv\n            (inline run_converter\n              (map_gpv' id id option_of_exception (gpv_stop (rpv' xa)))\n              (snd x))\n            (\\<lambda>p.\n                case fst p of None \\<Rightarrow> Fail\n                | Some x' \\<Rightarrow> Done (Some x', snd p))) =\n  bind_gpv\n   (bind_gpv\n     (map_gpv' id id option_of_exception\n       (TRY gpv_stop (rpv input) ELSE Done None))\n     (\\<lambda>x.\n         case x of None \\<Rightarrow> Fail | Some x \\<Rightarrow> Done x))\n   (\\<lambda>x.\n       bind_gpv\n        (inline run_converter\n          (map_gpv' id id option_of_exception (gpv_stop (rpv' (fst x))))\n          (obsf_converter (snd x)))\n        (\\<lambda>p.\n            case fst p of None \\<Rightarrow> Fail\n            | Some x' \\<Rightarrow> Done (Some x', snd p)))\n\ngoal (2 subgoals):\n 1. bind_gpv (map_gpv' id id option_of_exception (gpv_stop (rpv input)))\n     (case_option Fail\n       (\\<lambda>x.\n           bind_gpv\n            (map_gpv' id id option_of_exception\n              (gpv_stop (inline run_converter (rpv' (fst x)) (snd x))))\n            (case_option Fail\n              (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p)))))) =\n    bind_gpv ?gpv2'1 ?f'3\n 2. rel_gpv\n     (\\<lambda>x y.\n         \\<exists>gpv conv.\n            bind_gpv\n             (inline run_converter\n               (map_gpv' id id option_of_exception\n                 (gpv_stop (rpv' (fst x))))\n               (obsf_converter (snd x)))\n             (\\<lambda>p.\n                 case fst p of None \\<Rightarrow> Fail\n                 | Some x' \\<Rightarrow> Done (Some x', snd p)) =\n            bind_gpv\n             (inline run_converter\n               (map_gpv' id id option_of_exception (gpv_stop gpv))\n               (obsf_converter conv))\n             (\\<lambda>p.\n                 case fst p of None \\<Rightarrow> Fail\n                 | Some x' \\<Rightarrow> Done (Some x', snd p)) \\<and>\n            ?f'3 y =\n            bind_gpv\n             (map_gpv' id id option_of_exception\n               (gpv_stop (inline run_converter gpv conv)))\n             (case_option Fail\n               (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p)))))\n     (=)\n     (bind_gpv\n       (map_gpv' id id option_of_exception\n         (TRY gpv_stop (rpv input) ELSE Done None))\n       (\\<lambda>x.\n           case x of None \\<Rightarrow> Fail | Some x \\<Rightarrow> Done x))\n     ?gpv2'1", "show \"?rhs1 input = bind_gpv ?gpv2' ?f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_gpv (map_gpv' id id option_of_exception (gpv_stop (rpv input)))\n     (\\<lambda>a.\n         case a of None \\<Rightarrow> Fail\n         | Some x \\<Rightarrow>\n             bind_gpv\n              (map_gpv' id id option_of_exception\n                (gpv_stop (inline run_converter (rpv' (fst x)) (snd x))))\n              (\\<lambda>a.\n                  case a of None \\<Rightarrow> Fail\n                  | Some p \\<Rightarrow>\n                      Done (Some (fst p), obsf_converter (snd p)))) =\n    bind_gpv\n     (bind_gpv (map_gpv' id id option_of_exception (gpv_stop (rpv input)))\n       (\\<lambda>x.\n           case x of None \\<Rightarrow> Fail | Some x \\<Rightarrow> Done x))\n     (\\<lambda>x.\n         bind_gpv\n          (map_gpv' id id option_of_exception\n            (gpv_stop (inline run_converter (rpv' (fst x)) (snd x))))\n          (case_option Fail\n            (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p)))))", "by(auto simp add: bind_gpv_assoc id_def[symmetric] intro!: bind_gpv_cong split!: option.split)"], ["proof (state)\nthis:\n  bind_gpv (map_gpv' id id option_of_exception (gpv_stop (rpv input)))\n   (\\<lambda>a.\n       case a of None \\<Rightarrow> Fail\n       | Some x \\<Rightarrow>\n           bind_gpv\n            (map_gpv' id id option_of_exception\n              (gpv_stop (inline run_converter (rpv' (fst x)) (snd x))))\n            (\\<lambda>a.\n                case a of None \\<Rightarrow> Fail\n                | Some p \\<Rightarrow>\n                    Done (Some (fst p), obsf_converter (snd p)))) =\n  bind_gpv\n   (bind_gpv (map_gpv' id id option_of_exception (gpv_stop (rpv input)))\n     (\\<lambda>x.\n         case x of None \\<Rightarrow> Fail | Some x \\<Rightarrow> Done x))\n   (\\<lambda>x.\n       bind_gpv\n        (map_gpv' id id option_of_exception\n          (gpv_stop (inline run_converter (rpv' (fst x)) (snd x))))\n        (case_option Fail\n          (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p)))))\n\ngoal (1 subgoal):\n 1. rel_gpv\n     (\\<lambda>x y.\n         \\<exists>gpv conv.\n            bind_gpv\n             (inline run_converter\n               (map_gpv' id id option_of_exception\n                 (gpv_stop (rpv' (fst x))))\n               (obsf_converter (snd x)))\n             (\\<lambda>p.\n                 case fst p of None \\<Rightarrow> Fail\n                 | Some x' \\<Rightarrow> Done (Some x', snd p)) =\n            bind_gpv\n             (inline run_converter\n               (map_gpv' id id option_of_exception (gpv_stop gpv))\n               (obsf_converter conv))\n             (\\<lambda>p.\n                 case fst p of None \\<Rightarrow> Fail\n                 | Some x' \\<Rightarrow> Done (Some x', snd p)) \\<and>\n            bind_gpv\n             (map_gpv' id id option_of_exception\n               (gpv_stop (inline run_converter (rpv' (fst y)) (snd y))))\n             (case_option Fail\n               (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p)))) =\n            bind_gpv\n             (map_gpv' id id option_of_exception\n               (gpv_stop (inline run_converter gpv conv)))\n             (case_option Fail\n               (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p)))))\n     (=)\n     (bind_gpv\n       (map_gpv' id id option_of_exception\n         (TRY gpv_stop (rpv input) ELSE Done None))\n       (\\<lambda>x.\n           case x of None \\<Rightarrow> Fail | Some x \\<Rightarrow> Done x))\n     (bind_gpv (map_gpv' id id option_of_exception (gpv_stop (rpv input)))\n       (\\<lambda>x.\n           case x of None \\<Rightarrow> Fail | Some x \\<Rightarrow> Done x))", "show \"rel_gpv (?X ?f ?f') (=) ?gpv2 ?gpv2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_gpv\n     (\\<lambda>a aa.\n         \\<exists>gpv conv.\n            bind_gpv\n             (inline run_converter\n               (map_gpv' id id option_of_exception\n                 (gpv_stop (rpv' (fst a))))\n               (obsf_converter (snd a)))\n             (\\<lambda>p.\n                 case fst p of None \\<Rightarrow> Fail\n                 | Some x' \\<Rightarrow> Done (Some x', snd p)) =\n            bind_gpv\n             (inline run_converter\n               (map_gpv' id id option_of_exception (gpv_stop gpv))\n               (obsf_converter conv))\n             (\\<lambda>p.\n                 case fst p of None \\<Rightarrow> Fail\n                 | Some x' \\<Rightarrow> Done (Some x', snd p)) \\<and>\n            bind_gpv\n             (map_gpv' id id option_of_exception\n               (gpv_stop (inline run_converter (rpv' (fst aa)) (snd aa))))\n             (case_option Fail\n               (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p)))) =\n            bind_gpv\n             (map_gpv' id id option_of_exception\n               (gpv_stop (inline run_converter gpv conv)))\n             (\\<lambda>a.\n                 case a of None \\<Rightarrow> Fail\n                 | Some p \\<Rightarrow>\n                     Done (Some (fst p), obsf_converter (snd p))))\n     (=)\n     (bind_gpv\n       (map_gpv' id id option_of_exception\n         (TRY gpv_stop (rpv input) ELSE Done None))\n       (\\<lambda>x.\n           case x of None \\<Rightarrow> Fail | Some x \\<Rightarrow> Done x))\n     (bind_gpv (map_gpv' id id option_of_exception (gpv_stop (rpv input)))\n       (\\<lambda>x.\n           case x of None \\<Rightarrow> Fail | Some x \\<Rightarrow> Done x))", "using Inr x"], ["proof (prove)\nusing this:\n  x = Inr (out, rpv, rpv')\n  x \\<in> set_spmf (inline1 run_converter gpv conv)\n\ngoal (1 subgoal):\n 1. rel_gpv\n     (\\<lambda>a aa.\n         \\<exists>gpv conv.\n            bind_gpv\n             (inline run_converter\n               (map_gpv' id id option_of_exception\n                 (gpv_stop (rpv' (fst a))))\n               (obsf_converter (snd a)))\n             (\\<lambda>p.\n                 case fst p of None \\<Rightarrow> Fail\n                 | Some x' \\<Rightarrow> Done (Some x', snd p)) =\n            bind_gpv\n             (inline run_converter\n               (map_gpv' id id option_of_exception (gpv_stop gpv))\n               (obsf_converter conv))\n             (\\<lambda>p.\n                 case fst p of None \\<Rightarrow> Fail\n                 | Some x' \\<Rightarrow> Done (Some x', snd p)) \\<and>\n            bind_gpv\n             (map_gpv' id id option_of_exception\n               (gpv_stop (inline run_converter (rpv' (fst aa)) (snd aa))))\n             (case_option Fail\n               (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p)))) =\n            bind_gpv\n             (map_gpv' id id option_of_exception\n               (gpv_stop (inline run_converter gpv conv)))\n             (\\<lambda>a.\n                 case a of None \\<Rightarrow> Fail\n                 | Some p \\<Rightarrow>\n                     Done (Some (fst p), obsf_converter (snd p))))\n     (=)\n     (bind_gpv\n       (map_gpv' id id option_of_exception\n         (TRY gpv_stop (rpv input) ELSE Done None))\n       (\\<lambda>x.\n           case x of None \\<Rightarrow> Fail | Some x \\<Rightarrow> Done x))\n     (bind_gpv (map_gpv' id id option_of_exception (gpv_stop (rpv input)))\n       (\\<lambda>x.\n           case x of None \\<Rightarrow> Fail | Some x \\<Rightarrow> Done x))", "by(auto simp add: map'_try_gpv id_def[symmetric] bind_try_Done_Fail intro: gpv.rel_refl_strong)"], ["proof (state)\nthis:\n  rel_gpv\n   (\\<lambda>a aa.\n       \\<exists>gpv conv.\n          bind_gpv\n           (inline run_converter\n             (map_gpv' id id option_of_exception (gpv_stop (rpv' (fst a))))\n             (obsf_converter (snd a)))\n           (\\<lambda>p.\n               case fst p of None \\<Rightarrow> Fail\n               | Some x' \\<Rightarrow> Done (Some x', snd p)) =\n          bind_gpv\n           (inline run_converter\n             (map_gpv' id id option_of_exception (gpv_stop gpv))\n             (obsf_converter conv))\n           (\\<lambda>p.\n               case fst p of None \\<Rightarrow> Fail\n               | Some x' \\<Rightarrow> Done (Some x', snd p)) \\<and>\n          bind_gpv\n           (map_gpv' id id option_of_exception\n             (gpv_stop (inline run_converter (rpv' (fst aa)) (snd aa))))\n           (case_option Fail\n             (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p)))) =\n          bind_gpv\n           (map_gpv' id id option_of_exception\n             (gpv_stop (inline run_converter gpv conv)))\n           (\\<lambda>a.\n               case a of None \\<Rightarrow> Fail\n               | Some p \\<Rightarrow>\n                   Done (Some (fst p), obsf_converter (snd p))))\n   (=)\n   (bind_gpv\n     (map_gpv' id id option_of_exception\n       (TRY gpv_stop (rpv input) ELSE Done None))\n     (\\<lambda>x.\n         case x of None \\<Rightarrow> Fail | Some x \\<Rightarrow> Done x))\n   (bind_gpv (map_gpv' id id option_of_exception (gpv_stop (rpv input)))\n     (\\<lambda>x.\n         case x of None \\<Rightarrow> Fail | Some x \\<Rightarrow> Done x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>gpv2 gpv2' f f'.\n     bind_gpv\n      (map_gpv'\n        (case_option (Fault, const_converter Fault)\n          (\\<lambda>p. (OK (fst p), obsf_converter (snd p))))\n        id option_of_exception (TRY gpv_stop (rpv ?input2) ELSE Done None))\n      (\\<lambda>x.\n          case fst x of Fault \\<Rightarrow> Fail\n          | OK xa \\<Rightarrow>\n              bind_gpv\n               (inline run_converter\n                 (map_gpv' id id option_of_exception (gpv_stop (rpv' xa)))\n                 (snd x))\n               (\\<lambda>p.\n                   case fst p of None \\<Rightarrow> Fail\n                   | Some x' \\<Rightarrow> Done (Some x', snd p))) =\n     bind_gpv gpv2 f \\<and>\n     bind_gpv (map_gpv' id id option_of_exception (gpv_stop (rpv ?input2)))\n      (case_option Fail\n        (\\<lambda>x.\n            bind_gpv\n             (map_gpv' id id option_of_exception\n               (gpv_stop (inline run_converter (rpv' (fst x)) (snd x))))\n             (case_option Fail\n               (\\<lambda>p.\n                   Done (Some (fst p), obsf_converter (snd p)))))) =\n     bind_gpv gpv2' f' \\<and>\n     rel_gpv\n      (\\<lambda>x y.\n          \\<exists>gpv conv.\n             f x =\n             bind_gpv\n              (inline run_converter\n                (map_gpv' id id option_of_exception (gpv_stop gpv))\n                (obsf_converter conv))\n              (\\<lambda>p.\n                  case fst p of None \\<Rightarrow> Fail\n                  | Some x' \\<Rightarrow> Done (Some x', snd p)) \\<and>\n             f' y =\n             bind_gpv\n              (map_gpv' id id option_of_exception\n                (gpv_stop (inline run_converter gpv conv)))\n              (case_option Fail\n                (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p)))))\n      (=) gpv2 gpv2'\n\ngoal (2 subgoals):\n 1. \\<And>a conv'.\n       x = Inl (a, conv') \\<Longrightarrow>\n       rel_spmf\n        (rel_generat (=) (=)\n          (rel_fun (=)\n            (\\<lambda>gpv gpv'.\n                (\\<exists>gpva conv.\n                    gpv =\n                    bind_gpv\n                     (inline run_converter\n                       (map_gpv' id id option_of_exception (gpv_stop gpva))\n                       (obsf_converter conv))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                    gpv' =\n                    bind_gpv\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop (inline run_converter gpva conv)))\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))) \\<or>\n                gpv = gpv' \\<or>\n                (\\<exists>gpv2 gpv2' f f'.\n                    gpv = bind_gpv gpv2 f \\<and>\n                    gpv' = bind_gpv gpv2' f' \\<and>\n                    rel_gpv\n                     (\\<lambda>x y.\n                         \\<exists>gpv conv.\n                            f x =\n                            bind_gpv\n                             (inline run_converter\n                               (map_gpv' id id option_of_exception\n                                 (gpv_stop gpv))\n                               (obsf_converter conv))\n                             (\\<lambda>(x, conv').\n                                 case x of None \\<Rightarrow> Fail\n                                 | Some x' \\<Rightarrow>\n                                     Done (x, conv')) \\<and>\n                            f' y =\n                            bind_gpv\n                             (map_gpv' id id option_of_exception\n                               (gpv_stop (inline run_converter gpv conv)))\n                             (case_option Fail\n                               (\\<lambda>(x', conv).\n                                   Done (Some x', obsf_converter conv))))\n                     (=) gpv2 gpv2'))))\n        (return_spmf\n          (case map_sum (apsnd obsf_converter)\n                 (apsnd\n                   (map_prod\n                     (\\<lambda>rpv.\n                         case_exception\n                          (Done (Fault, const_converter Fault))\n                          (\\<lambda>input'.\n                              map_gpv'\n                               (case_option (Fault, const_converter Fault)\n                                 (\\<lambda>(x, conv').\n                                     (OK x, obsf_converter conv')))\n                               id option_of_exception\n                               (TRY gpv_stop (rpv input') ELSE Done None)))\n                     (\\<lambda>rpv.\n                         case_exception (Done None)\n                          (\\<lambda>input'.\n                              map_gpv' id id option_of_exception\n                               (gpv_stop (rpv input'))))))\n                 x of\n           Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n           | Inr (out, rpv, rpv') \\<Rightarrow>\n               IO out\n                (\\<lambda>input.\n                    bind_gpv\n                     (bind_gpv (rpv input)\n                       (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv')))))\n        (map_spmf\n          (map_generat id id\n            ((\\<circ>)\n              (case_sum id\n                (\\<lambda>r.\n                    bind_gpv r\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))))))\n          (case map_generat id id\n                 (map_fun option_of_exception\n                   (map_gpv' id id option_of_exception))\n                 (map_generat Some id\n                   (\\<lambda>rpv.\n                       case_option (Done None)\n                        (\\<lambda>input'. gpv_stop (rpv input')))\n                   (case x of Inl x \\<Rightarrow> Pure x\n                    | Inr (out, oracle, rpv) \\<Rightarrow>\n                        IO out\n                         (\\<lambda>input.\n                             bind_gpv (oracle input)\n                              (\\<lambda>(x, y).\n                                  inline run_converter (rpv x) y)))) of\n           Pure x \\<Rightarrow>\n             map_spmf (map_generat id id ((\\<circ>) Inl))\n              (the_gpv\n                (case x of None \\<Rightarrow> Fail\n                 | Some (x', conv) \\<Rightarrow>\n                     Done (Some x', obsf_converter conv)))\n           | IO out c \\<Rightarrow>\n               return_spmf (IO out (\\<lambda>input. Inr (c input)))))\n 2. \\<And>out rpv rpv'.\n       x = Inr (out, rpv, rpv') \\<Longrightarrow>\n       rel_spmf\n        (rel_generat (=) (=)\n          (rel_fun (=)\n            (\\<lambda>gpv gpv'.\n                (\\<exists>gpva conv.\n                    gpv =\n                    bind_gpv\n                     (inline run_converter\n                       (map_gpv' id id option_of_exception (gpv_stop gpva))\n                       (obsf_converter conv))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                    gpv' =\n                    bind_gpv\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop (inline run_converter gpva conv)))\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))) \\<or>\n                gpv = gpv' \\<or>\n                (\\<exists>gpv2 gpv2' f f'.\n                    gpv = bind_gpv gpv2 f \\<and>\n                    gpv' = bind_gpv gpv2' f' \\<and>\n                    rel_gpv\n                     (\\<lambda>x y.\n                         \\<exists>gpv conv.\n                            f x =\n                            bind_gpv\n                             (inline run_converter\n                               (map_gpv' id id option_of_exception\n                                 (gpv_stop gpv))\n                               (obsf_converter conv))\n                             (\\<lambda>(x, conv').\n                                 case x of None \\<Rightarrow> Fail\n                                 | Some x' \\<Rightarrow>\n                                     Done (x, conv')) \\<and>\n                            f' y =\n                            bind_gpv\n                             (map_gpv' id id option_of_exception\n                               (gpv_stop (inline run_converter gpv conv)))\n                             (case_option Fail\n                               (\\<lambda>(x', conv).\n                                   Done (Some x', obsf_converter conv))))\n                     (=) gpv2 gpv2'))))\n        (return_spmf\n          (case map_sum (apsnd obsf_converter)\n                 (apsnd\n                   (map_prod\n                     (\\<lambda>rpv.\n                         case_exception\n                          (Done (Fault, const_converter Fault))\n                          (\\<lambda>input'.\n                              map_gpv'\n                               (case_option (Fault, const_converter Fault)\n                                 (\\<lambda>(x, conv').\n                                     (OK x, obsf_converter conv')))\n                               id option_of_exception\n                               (TRY gpv_stop (rpv input') ELSE Done None)))\n                     (\\<lambda>rpv.\n                         case_exception (Done None)\n                          (\\<lambda>input'.\n                              map_gpv' id id option_of_exception\n                               (gpv_stop (rpv input'))))))\n                 x of\n           Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n           | Inr (out, rpv, rpv') \\<Rightarrow>\n               IO out\n                (\\<lambda>input.\n                    bind_gpv\n                     (bind_gpv (rpv input)\n                       (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv')))))\n        (map_spmf\n          (map_generat id id\n            ((\\<circ>)\n              (case_sum id\n                (\\<lambda>r.\n                    bind_gpv r\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))))))\n          (case map_generat id id\n                 (map_fun option_of_exception\n                   (map_gpv' id id option_of_exception))\n                 (map_generat Some id\n                   (\\<lambda>rpv.\n                       case_option (Done None)\n                        (\\<lambda>input'. gpv_stop (rpv input')))\n                   (case x of Inl x \\<Rightarrow> Pure x\n                    | Inr (out, oracle, rpv) \\<Rightarrow>\n                        IO out\n                         (\\<lambda>input.\n                             bind_gpv (oracle input)\n                              (\\<lambda>(x, y).\n                                  inline run_converter (rpv x) y)))) of\n           Pure x \\<Rightarrow>\n             map_spmf (map_generat id id ((\\<circ>) Inl))\n              (the_gpv\n                (case x of None \\<Rightarrow> Fail\n                 | Some (x', conv) \\<Rightarrow>\n                     Done (Some x', obsf_converter conv)))\n           | IO out c \\<Rightarrow>\n               return_spmf (IO out (\\<lambda>input. Inr (c input)))))", "then"], ["proof (chain)\npicking this:\n  \\<exists>gpv2 gpv2' f f'.\n     bind_gpv\n      (map_gpv'\n        (case_option (Fault, const_converter Fault)\n          (\\<lambda>p. (OK (fst p), obsf_converter (snd p))))\n        id option_of_exception (TRY gpv_stop (rpv ?input2) ELSE Done None))\n      (\\<lambda>x.\n          case fst x of Fault \\<Rightarrow> Fail\n          | OK xa \\<Rightarrow>\n              bind_gpv\n               (inline run_converter\n                 (map_gpv' id id option_of_exception (gpv_stop (rpv' xa)))\n                 (snd x))\n               (\\<lambda>p.\n                   case fst p of None \\<Rightarrow> Fail\n                   | Some x' \\<Rightarrow> Done (Some x', snd p))) =\n     bind_gpv gpv2 f \\<and>\n     bind_gpv (map_gpv' id id option_of_exception (gpv_stop (rpv ?input2)))\n      (case_option Fail\n        (\\<lambda>x.\n            bind_gpv\n             (map_gpv' id id option_of_exception\n               (gpv_stop (inline run_converter (rpv' (fst x)) (snd x))))\n             (case_option Fail\n               (\\<lambda>p.\n                   Done (Some (fst p), obsf_converter (snd p)))))) =\n     bind_gpv gpv2' f' \\<and>\n     rel_gpv\n      (\\<lambda>x y.\n          \\<exists>gpv conv.\n             f x =\n             bind_gpv\n              (inline run_converter\n                (map_gpv' id id option_of_exception (gpv_stop gpv))\n                (obsf_converter conv))\n              (\\<lambda>p.\n                  case fst p of None \\<Rightarrow> Fail\n                  | Some x' \\<Rightarrow> Done (Some x', snd p)) \\<and>\n             f' y =\n             bind_gpv\n              (map_gpv' id id option_of_exception\n                (gpv_stop (inline run_converter gpv conv)))\n              (case_option Fail\n                (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p)))))\n      (=) gpv2 gpv2'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>gpv2 gpv2' f f'.\n     bind_gpv\n      (map_gpv'\n        (case_option (Fault, const_converter Fault)\n          (\\<lambda>p. (OK (fst p), obsf_converter (snd p))))\n        id option_of_exception (TRY gpv_stop (rpv ?input2) ELSE Done None))\n      (\\<lambda>x.\n          case fst x of Fault \\<Rightarrow> Fail\n          | OK xa \\<Rightarrow>\n              bind_gpv\n               (inline run_converter\n                 (map_gpv' id id option_of_exception (gpv_stop (rpv' xa)))\n                 (snd x))\n               (\\<lambda>p.\n                   case fst p of None \\<Rightarrow> Fail\n                   | Some x' \\<Rightarrow> Done (Some x', snd p))) =\n     bind_gpv gpv2 f \\<and>\n     bind_gpv (map_gpv' id id option_of_exception (gpv_stop (rpv ?input2)))\n      (case_option Fail\n        (\\<lambda>x.\n            bind_gpv\n             (map_gpv' id id option_of_exception\n               (gpv_stop (inline run_converter (rpv' (fst x)) (snd x))))\n             (case_option Fail\n               (\\<lambda>p.\n                   Done (Some (fst p), obsf_converter (snd p)))))) =\n     bind_gpv gpv2' f' \\<and>\n     rel_gpv\n      (\\<lambda>x y.\n          \\<exists>gpv conv.\n             f x =\n             bind_gpv\n              (inline run_converter\n                (map_gpv' id id option_of_exception (gpv_stop gpv))\n                (obsf_converter conv))\n              (\\<lambda>p.\n                  case fst p of None \\<Rightarrow> Fail\n                  | Some x' \\<Rightarrow> Done (Some x', snd p)) \\<and>\n             f' y =\n             bind_gpv\n              (map_gpv' id id option_of_exception\n                (gpv_stop (inline run_converter gpv conv)))\n              (case_option Fail\n                (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p)))))\n      (=) gpv2 gpv2'\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_generat (=) (=)\n       (rel_fun (=)\n         (\\<lambda>gpv gpv'.\n             (\\<exists>gpva conv.\n                 gpv =\n                 bind_gpv\n                  (inline run_converter\n                    (map_gpv' id id option_of_exception (gpv_stop gpva))\n                    (obsf_converter conv))\n                  (\\<lambda>(x, conv').\n                      case x of None \\<Rightarrow> Fail\n                      | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                 gpv' =\n                 bind_gpv\n                  (map_gpv' id id option_of_exception\n                    (gpv_stop (inline run_converter gpva conv)))\n                  (case_option Fail\n                    (\\<lambda>(x', conv).\n                        Done (Some x', obsf_converter conv)))) \\<or>\n             gpv = gpv' \\<or>\n             (\\<exists>gpv2 gpv2' f f'.\n                 gpv = bind_gpv gpv2 f \\<and>\n                 gpv' = bind_gpv gpv2' f' \\<and>\n                 rel_gpv\n                  (\\<lambda>x y.\n                      \\<exists>gpv conv.\n                         f x =\n                         bind_gpv\n                          (inline run_converter\n                            (map_gpv' id id option_of_exception\n                              (gpv_stop gpv))\n                            (obsf_converter conv))\n                          (\\<lambda>(x, conv').\n                              case x of None \\<Rightarrow> Fail\n                              | Some x' \\<Rightarrow>\n                                  Done (x, conv')) \\<and>\n                         f' y =\n                         bind_gpv\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop (inline run_converter gpv conv)))\n                          (case_option Fail\n                            (\\<lambda>(x', conv).\n                                Done (Some x', obsf_converter conv))))\n                  (=) gpv2 gpv2'))))\n     (return_spmf\n       (case map_sum (apsnd obsf_converter)\n              (apsnd\n                (map_prod\n                  (\\<lambda>rpv.\n                      case_exception (Done (Fault, const_converter Fault))\n                       (\\<lambda>input'.\n                           map_gpv'\n                            (case_option (Fault, const_converter Fault)\n                              (\\<lambda>(x, conv').\n                                  (OK x, obsf_converter conv')))\n                            id option_of_exception\n                            (TRY gpv_stop (rpv input') ELSE Done None)))\n                  (\\<lambda>rpv.\n                      case_exception (Done None)\n                       (\\<lambda>input'.\n                           map_gpv' id id option_of_exception\n                            (gpv_stop (rpv input'))))))\n              x of\n        Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n        | Inr (out, rpv, rpv') \\<Rightarrow>\n            IO out\n             (\\<lambda>input.\n                 bind_gpv\n                  (bind_gpv (rpv input)\n                    (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                  (\\<lambda>(x, conv').\n                      case x of None \\<Rightarrow> Fail\n                      | Some x' \\<Rightarrow> Done (x, conv')))))\n     (map_spmf\n       (map_generat id id\n         ((\\<circ>)\n           (case_sum id\n             (\\<lambda>r.\n                 bind_gpv r\n                  (case_option Fail\n                    (\\<lambda>(x', conv).\n                        Done (Some x', obsf_converter conv)))))))\n       (case map_generat id id\n              (map_fun option_of_exception\n                (map_gpv' id id option_of_exception))\n              (map_generat Some id\n                (\\<lambda>rpv.\n                    case_option (Done None)\n                     (\\<lambda>input'. gpv_stop (rpv input')))\n                (case x of Inl x \\<Rightarrow> Pure x\n                 | Inr (out, oracle, rpv) \\<Rightarrow>\n                     IO out\n                      (\\<lambda>input.\n                          bind_gpv (oracle input)\n                           (\\<lambda>(x, y).\n                               inline run_converter (rpv x) y)))) of\n        Pure x \\<Rightarrow>\n          map_spmf (map_generat id id ((\\<circ>) Inl))\n           (the_gpv\n             (case x of None \\<Rightarrow> Fail\n              | Some (x', conv) \\<Rightarrow>\n                  Done (Some x', obsf_converter conv)))\n        | IO out c \\<Rightarrow>\n            return_spmf (IO out (\\<lambda>input. Inr (c input)))))", "using Inr"], ["proof (prove)\nusing this:\n  \\<exists>gpv2 gpv2' f f'.\n     bind_gpv\n      (map_gpv'\n        (case_option (Fault, const_converter Fault)\n          (\\<lambda>p. (OK (fst p), obsf_converter (snd p))))\n        id option_of_exception (TRY gpv_stop (rpv ?input2) ELSE Done None))\n      (\\<lambda>x.\n          case fst x of Fault \\<Rightarrow> Fail\n          | OK xa \\<Rightarrow>\n              bind_gpv\n               (inline run_converter\n                 (map_gpv' id id option_of_exception (gpv_stop (rpv' xa)))\n                 (snd x))\n               (\\<lambda>p.\n                   case fst p of None \\<Rightarrow> Fail\n                   | Some x' \\<Rightarrow> Done (Some x', snd p))) =\n     bind_gpv gpv2 f \\<and>\n     bind_gpv (map_gpv' id id option_of_exception (gpv_stop (rpv ?input2)))\n      (case_option Fail\n        (\\<lambda>x.\n            bind_gpv\n             (map_gpv' id id option_of_exception\n               (gpv_stop (inline run_converter (rpv' (fst x)) (snd x))))\n             (case_option Fail\n               (\\<lambda>p.\n                   Done (Some (fst p), obsf_converter (snd p)))))) =\n     bind_gpv gpv2' f' \\<and>\n     rel_gpv\n      (\\<lambda>x y.\n          \\<exists>gpv conv.\n             f x =\n             bind_gpv\n              (inline run_converter\n                (map_gpv' id id option_of_exception (gpv_stop gpv))\n                (obsf_converter conv))\n              (\\<lambda>p.\n                  case fst p of None \\<Rightarrow> Fail\n                  | Some x' \\<Rightarrow> Done (Some x', snd p)) \\<and>\n             f' y =\n             bind_gpv\n              (map_gpv' id id option_of_exception\n                (gpv_stop (inline run_converter gpv conv)))\n              (case_option Fail\n                (\\<lambda>p. Done (Some (fst p), obsf_converter (snd p)))))\n      (=) gpv2 gpv2'\n  x = Inr (out, rpv, rpv')\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_generat (=) (=)\n       (rel_fun (=)\n         (\\<lambda>gpv gpv'.\n             (\\<exists>gpva conv.\n                 gpv =\n                 bind_gpv\n                  (inline run_converter\n                    (map_gpv' id id option_of_exception (gpv_stop gpva))\n                    (obsf_converter conv))\n                  (\\<lambda>(x, conv').\n                      case x of None \\<Rightarrow> Fail\n                      | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                 gpv' =\n                 bind_gpv\n                  (map_gpv' id id option_of_exception\n                    (gpv_stop (inline run_converter gpva conv)))\n                  (case_option Fail\n                    (\\<lambda>(x', conv).\n                        Done (Some x', obsf_converter conv)))) \\<or>\n             gpv = gpv' \\<or>\n             (\\<exists>gpv2 gpv2' f f'.\n                 gpv = bind_gpv gpv2 f \\<and>\n                 gpv' = bind_gpv gpv2' f' \\<and>\n                 rel_gpv\n                  (\\<lambda>x y.\n                      \\<exists>gpv conv.\n                         f x =\n                         bind_gpv\n                          (inline run_converter\n                            (map_gpv' id id option_of_exception\n                              (gpv_stop gpv))\n                            (obsf_converter conv))\n                          (\\<lambda>(x, conv').\n                              case x of None \\<Rightarrow> Fail\n                              | Some x' \\<Rightarrow>\n                                  Done (x, conv')) \\<and>\n                         f' y =\n                         bind_gpv\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop (inline run_converter gpv conv)))\n                          (case_option Fail\n                            (\\<lambda>(x', conv).\n                                Done (Some x', obsf_converter conv))))\n                  (=) gpv2 gpv2'))))\n     (return_spmf\n       (case map_sum (apsnd obsf_converter)\n              (apsnd\n                (map_prod\n                  (\\<lambda>rpv.\n                      case_exception (Done (Fault, const_converter Fault))\n                       (\\<lambda>input'.\n                           map_gpv'\n                            (case_option (Fault, const_converter Fault)\n                              (\\<lambda>(x, conv').\n                                  (OK x, obsf_converter conv')))\n                            id option_of_exception\n                            (TRY gpv_stop (rpv input') ELSE Done None)))\n                  (\\<lambda>rpv.\n                      case_exception (Done None)\n                       (\\<lambda>input'.\n                           map_gpv' id id option_of_exception\n                            (gpv_stop (rpv input'))))))\n              x of\n        Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n        | Inr (out, rpv, rpv') \\<Rightarrow>\n            IO out\n             (\\<lambda>input.\n                 bind_gpv\n                  (bind_gpv (rpv input)\n                    (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                  (\\<lambda>(x, conv').\n                      case x of None \\<Rightarrow> Fail\n                      | Some x' \\<Rightarrow> Done (x, conv')))))\n     (map_spmf\n       (map_generat id id\n         ((\\<circ>)\n           (case_sum id\n             (\\<lambda>r.\n                 bind_gpv r\n                  (case_option Fail\n                    (\\<lambda>(x', conv).\n                        Done (Some x', obsf_converter conv)))))))\n       (case map_generat id id\n              (map_fun option_of_exception\n                (map_gpv' id id option_of_exception))\n              (map_generat Some id\n                (\\<lambda>rpv.\n                    case_option (Done None)\n                     (\\<lambda>input'. gpv_stop (rpv input')))\n                (case x of Inl x \\<Rightarrow> Pure x\n                 | Inr (out, oracle, rpv) \\<Rightarrow>\n                     IO out\n                      (\\<lambda>input.\n                          bind_gpv (oracle input)\n                           (\\<lambda>(x, y).\n                               inline run_converter (rpv x) y)))) of\n        Pure x \\<Rightarrow>\n          map_spmf (map_generat id id ((\\<circ>) Inl))\n           (the_gpv\n             (case x of None \\<Rightarrow> Fail\n              | Some (x', conv) \\<Rightarrow>\n                  Done (Some x', obsf_converter conv)))\n        | IO out c \\<Rightarrow>\n            return_spmf (IO out (\\<lambda>input. Inr (c input)))))", "by(clarsimp split!: sum.split exception.split simp add: rel_fun_def bind_gpv_assoc split_def map_gpv'_bind_gpv exception.case_distrib[where h=\"\\<lambda>x. bind_gpv (inline _ x _) _\"] option.case_distrib[where h=\"\\<lambda>x. bind_gpv (map_gpv' _ _ _ x) _\"] cong: exception.case_cong option.case_cong)"], ["proof (state)\nthis:\n  rel_spmf\n   (rel_generat (=) (=)\n     (rel_fun (=)\n       (\\<lambda>gpv gpv'.\n           (\\<exists>gpva conv.\n               gpv =\n               bind_gpv\n                (inline run_converter\n                  (map_gpv' id id option_of_exception (gpv_stop gpva))\n                  (obsf_converter conv))\n                (\\<lambda>(x, conv').\n                    case x of None \\<Rightarrow> Fail\n                    | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n               gpv' =\n               bind_gpv\n                (map_gpv' id id option_of_exception\n                  (gpv_stop (inline run_converter gpva conv)))\n                (case_option Fail\n                  (\\<lambda>(x', conv).\n                      Done (Some x', obsf_converter conv)))) \\<or>\n           gpv = gpv' \\<or>\n           (\\<exists>gpv2 gpv2' f f'.\n               gpv = bind_gpv gpv2 f \\<and>\n               gpv' = bind_gpv gpv2' f' \\<and>\n               rel_gpv\n                (\\<lambda>x y.\n                    \\<exists>gpv conv.\n                       f x =\n                       bind_gpv\n                        (inline run_converter\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop gpv))\n                          (obsf_converter conv))\n                        (\\<lambda>(x, conv').\n                            case x of None \\<Rightarrow> Fail\n                            | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                       f' y =\n                       bind_gpv\n                        (map_gpv' id id option_of_exception\n                          (gpv_stop (inline run_converter gpv conv)))\n                        (case_option Fail\n                          (\\<lambda>(x', conv).\n                              Done (Some x', obsf_converter conv))))\n                (=) gpv2 gpv2'))))\n   (return_spmf\n     (case map_sum (apsnd obsf_converter)\n            (apsnd\n              (map_prod\n                (\\<lambda>rpv.\n                    case_exception (Done (Fault, const_converter Fault))\n                     (\\<lambda>input'.\n                         map_gpv'\n                          (case_option (Fault, const_converter Fault)\n                            (\\<lambda>(x, conv').\n                                (OK x, obsf_converter conv')))\n                          id option_of_exception\n                          (TRY gpv_stop (rpv input') ELSE Done None)))\n                (\\<lambda>rpv.\n                    case_exception (Done None)\n                     (\\<lambda>input'.\n                         map_gpv' id id option_of_exception\n                          (gpv_stop (rpv input'))))))\n            x of\n      Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n      | Inr (out, rpv, rpv') \\<Rightarrow>\n          IO out\n           (\\<lambda>input.\n               bind_gpv\n                (bind_gpv (rpv input)\n                  (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                (\\<lambda>(x, conv').\n                    case x of None \\<Rightarrow> Fail\n                    | Some x' \\<Rightarrow> Done (x, conv')))))\n   (map_spmf\n     (map_generat id id\n       ((\\<circ>)\n         (case_sum id\n           (\\<lambda>r.\n               bind_gpv r\n                (case_option Fail\n                  (\\<lambda>(x', conv).\n                      Done (Some x', obsf_converter conv)))))))\n     (case map_generat id id\n            (map_fun option_of_exception\n              (map_gpv' id id option_of_exception))\n            (map_generat Some id\n              (\\<lambda>rpv.\n                  case_option (Done None)\n                   (\\<lambda>input'. gpv_stop (rpv input')))\n              (case x of Inl x \\<Rightarrow> Pure x\n               | Inr (out, oracle, rpv) \\<Rightarrow>\n                   IO out\n                    (\\<lambda>input.\n                        bind_gpv (oracle input)\n                         (\\<lambda>(x, y).\n                             inline run_converter (rpv x) y)))) of\n      Pure x \\<Rightarrow>\n        map_spmf (map_generat id id ((\\<circ>) Inl))\n         (the_gpv\n           (case x of None \\<Rightarrow> Fail\n            | Some (x', conv) \\<Rightarrow>\n                Done (Some x', obsf_converter conv)))\n      | IO out c \\<Rightarrow>\n          return_spmf (IO out (\\<lambda>input. Inr (c input)))))\n\ngoal (1 subgoal):\n 1. \\<And>a conv'.\n       x = Inl (a, conv') \\<Longrightarrow>\n       rel_spmf\n        (rel_generat (=) (=)\n          (rel_fun (=)\n            (\\<lambda>gpv gpv'.\n                (\\<exists>gpva conv.\n                    gpv =\n                    bind_gpv\n                     (inline run_converter\n                       (map_gpv' id id option_of_exception (gpv_stop gpva))\n                       (obsf_converter conv))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                    gpv' =\n                    bind_gpv\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop (inline run_converter gpva conv)))\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))) \\<or>\n                gpv = gpv' \\<or>\n                (\\<exists>gpv2 gpv2' f f'.\n                    gpv = bind_gpv gpv2 f \\<and>\n                    gpv' = bind_gpv gpv2' f' \\<and>\n                    rel_gpv\n                     (\\<lambda>x y.\n                         \\<exists>gpv conv.\n                            f x =\n                            bind_gpv\n                             (inline run_converter\n                               (map_gpv' id id option_of_exception\n                                 (gpv_stop gpv))\n                               (obsf_converter conv))\n                             (\\<lambda>(x, conv').\n                                 case x of None \\<Rightarrow> Fail\n                                 | Some x' \\<Rightarrow>\n                                     Done (x, conv')) \\<and>\n                            f' y =\n                            bind_gpv\n                             (map_gpv' id id option_of_exception\n                               (gpv_stop (inline run_converter gpv conv)))\n                             (case_option Fail\n                               (\\<lambda>(x', conv).\n                                   Done (Some x', obsf_converter conv))))\n                     (=) gpv2 gpv2'))))\n        (return_spmf\n          (case map_sum (apsnd obsf_converter)\n                 (apsnd\n                   (map_prod\n                     (\\<lambda>rpv.\n                         case_exception\n                          (Done (Fault, const_converter Fault))\n                          (\\<lambda>input'.\n                              map_gpv'\n                               (case_option (Fault, const_converter Fault)\n                                 (\\<lambda>(x, conv').\n                                     (OK x, obsf_converter conv')))\n                               id option_of_exception\n                               (TRY gpv_stop (rpv input') ELSE Done None)))\n                     (\\<lambda>rpv.\n                         case_exception (Done None)\n                          (\\<lambda>input'.\n                              map_gpv' id id option_of_exception\n                               (gpv_stop (rpv input'))))))\n                 x of\n           Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n           | Inr (out, rpv, rpv') \\<Rightarrow>\n               IO out\n                (\\<lambda>input.\n                    bind_gpv\n                     (bind_gpv (rpv input)\n                       (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv')))))\n        (map_spmf\n          (map_generat id id\n            ((\\<circ>)\n              (case_sum id\n                (\\<lambda>r.\n                    bind_gpv r\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))))))\n          (case map_generat id id\n                 (map_fun option_of_exception\n                   (map_gpv' id id option_of_exception))\n                 (map_generat Some id\n                   (\\<lambda>rpv.\n                       case_option (Done None)\n                        (\\<lambda>input'. gpv_stop (rpv input')))\n                   (case x of Inl x \\<Rightarrow> Pure x\n                    | Inr (out, oracle, rpv) \\<Rightarrow>\n                        IO out\n                         (\\<lambda>input.\n                             bind_gpv (oracle input)\n                              (\\<lambda>(x, y).\n                                  inline run_converter (rpv x) y)))) of\n           Pure x \\<Rightarrow>\n             map_spmf (map_generat id id ((\\<circ>) Inl))\n              (the_gpv\n                (case x of None \\<Rightarrow> Fail\n                 | Some (x', conv) \\<Rightarrow>\n                     Done (Some x', obsf_converter conv)))\n           | IO out c \\<Rightarrow>\n               return_spmf (IO out (\\<lambda>input. Inr (c input)))))", "qed simp"], ["proof (state)\nthis:\n  rel_spmf\n   (rel_generat (=) (=)\n     (rel_fun (=)\n       (\\<lambda>gpv gpv'.\n           (\\<exists>gpva conv.\n               gpv =\n               bind_gpv\n                (inline run_converter\n                  (map_gpv' id id option_of_exception (gpv_stop gpva))\n                  (obsf_converter conv))\n                (\\<lambda>(x, conv').\n                    case x of None \\<Rightarrow> Fail\n                    | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n               gpv' =\n               bind_gpv\n                (map_gpv' id id option_of_exception\n                  (gpv_stop (inline run_converter gpva conv)))\n                (case_option Fail\n                  (\\<lambda>(x', conv).\n                      Done (Some x', obsf_converter conv)))) \\<or>\n           gpv = gpv' \\<or>\n           (\\<exists>gpv2 gpv2' f f'.\n               gpv = bind_gpv gpv2 f \\<and>\n               gpv' = bind_gpv gpv2' f' \\<and>\n               rel_gpv\n                (\\<lambda>x y.\n                    \\<exists>gpv conv.\n                       f x =\n                       bind_gpv\n                        (inline run_converter\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop gpv))\n                          (obsf_converter conv))\n                        (\\<lambda>(x, conv').\n                            case x of None \\<Rightarrow> Fail\n                            | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                       f' y =\n                       bind_gpv\n                        (map_gpv' id id option_of_exception\n                          (gpv_stop (inline run_converter gpv conv)))\n                        (case_option Fail\n                          (\\<lambda>(x', conv).\n                              Done (Some x', obsf_converter conv))))\n                (=) gpv2 gpv2'))))\n   (return_spmf\n     (case map_sum (apsnd obsf_converter)\n            (apsnd\n              (map_prod\n                (\\<lambda>rpv.\n                    case_exception (Done (Fault, const_converter Fault))\n                     (\\<lambda>input'.\n                         map_gpv'\n                          (case_option (Fault, const_converter Fault)\n                            (\\<lambda>(x, conv').\n                                (OK x, obsf_converter conv')))\n                          id option_of_exception\n                          (TRY gpv_stop (rpv input') ELSE Done None)))\n                (\\<lambda>rpv.\n                    case_exception (Done None)\n                     (\\<lambda>input'.\n                         map_gpv' id id option_of_exception\n                          (gpv_stop (rpv input'))))))\n            x of\n      Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n      | Inr (out, rpv, rpv') \\<Rightarrow>\n          IO out\n           (\\<lambda>input.\n               bind_gpv\n                (bind_gpv (rpv input)\n                  (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                (\\<lambda>(x, conv').\n                    case x of None \\<Rightarrow> Fail\n                    | Some x' \\<Rightarrow> Done (x, conv')))))\n   (map_spmf\n     (map_generat id id\n       ((\\<circ>)\n         (case_sum id\n           (\\<lambda>r.\n               bind_gpv r\n                (case_option Fail\n                  (\\<lambda>(x', conv).\n                      Done (Some x', obsf_converter conv)))))))\n     (case map_generat id id\n            (map_fun option_of_exception\n              (map_gpv' id id option_of_exception))\n            (map_generat Some id\n              (\\<lambda>rpv.\n                  case_option (Done None)\n                   (\\<lambda>input'. gpv_stop (rpv input')))\n              (case x of Inl x \\<Rightarrow> Pure x\n               | Inr (out, oracle, rpv) \\<Rightarrow>\n                   IO out\n                    (\\<lambda>input.\n                        bind_gpv (oracle input)\n                         (\\<lambda>(x, y).\n                             inline run_converter (rpv x) y)))) of\n      Pure x \\<Rightarrow>\n        map_spmf (map_generat id id ((\\<circ>) Inl))\n         (the_gpv\n           (case x of None \\<Rightarrow> Fail\n            | Some (x', conv) \\<Rightarrow>\n                Done (Some x', obsf_converter conv)))\n      | IO out c \\<Rightarrow>\n          return_spmf (IO out (\\<lambda>input. Inr (c input)))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_spmf\n   (rel_generat (=) (=)\n     (rel_fun (=)\n       (\\<lambda>gpv gpv'.\n           (\\<exists>gpva conv.\n               gpv =\n               bind_gpv\n                (inline run_converter\n                  (map_gpv' id id option_of_exception (gpv_stop gpva))\n                  (obsf_converter conv))\n                (\\<lambda>(x, conv').\n                    case x of None \\<Rightarrow> Fail\n                    | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n               gpv' =\n               bind_gpv\n                (map_gpv' id id option_of_exception\n                  (gpv_stop (inline run_converter gpva conv)))\n                (case_option Fail\n                  (\\<lambda>(x', conv).\n                      Done (Some x', obsf_converter conv)))) \\<or>\n           gpv = gpv' \\<or>\n           (\\<exists>gpv2 gpv2' f f'.\n               gpv = bind_gpv gpv2 f \\<and>\n               gpv' = bind_gpv gpv2' f' \\<and>\n               rel_gpv\n                (\\<lambda>x y.\n                    \\<exists>gpv conv.\n                       f x =\n                       bind_gpv\n                        (inline run_converter\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop gpv))\n                          (obsf_converter conv))\n                        (\\<lambda>(x, conv').\n                            case x of None \\<Rightarrow> Fail\n                            | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                       f' y =\n                       bind_gpv\n                        (map_gpv' id id option_of_exception\n                          (gpv_stop (inline run_converter gpv conv)))\n                        (case_option Fail\n                          (\\<lambda>(x', conv).\n                              Done (Some x', obsf_converter conv))))\n                (=) gpv2 gpv2'))))\n   (bind_spmf (inline1 run_converter gpv conv)\n     (\\<lambda>y.\n         return_spmf\n          (case map_sum (apsnd obsf_converter)\n                 (apsnd\n                   (map_prod\n                     (\\<lambda>rpv.\n                         case_exception\n                          (Done (Fault, const_converter Fault))\n                          (\\<lambda>input'.\n                              map_gpv'\n                               (case_option (Fault, const_converter Fault)\n                                 (\\<lambda>(x, conv').\n                                     (OK x, obsf_converter conv')))\n                               id option_of_exception\n                               (TRY gpv_stop (rpv input') ELSE Done None)))\n                     (\\<lambda>rpv.\n                         case_exception (Done None)\n                          (\\<lambda>input'.\n                              map_gpv' id id option_of_exception\n                               (gpv_stop (rpv input'))))))\n                 y of\n           Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n           | Inr (out, rpv, rpv') \\<Rightarrow>\n               IO out\n                (\\<lambda>input.\n                    bind_gpv\n                     (bind_gpv (rpv input)\n                       (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv'))))))\n   (bind_spmf (inline1 run_converter gpv conv)\n     (\\<lambda>x.\n         map_spmf\n          (map_generat id id\n            ((\\<circ>)\n              (case_sum id\n                (\\<lambda>r.\n                    bind_gpv r\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))))))\n          (case map_generat id id\n                 (map_fun option_of_exception\n                   (map_gpv' id id option_of_exception))\n                 (map_generat Some id\n                   (\\<lambda>rpv.\n                       case_option (Done None)\n                        (\\<lambda>input'. gpv_stop (rpv input')))\n                   (case x of Inl x \\<Rightarrow> Pure x\n                    | Inr (out, oracle, rpv) \\<Rightarrow>\n                        IO out\n                         (\\<lambda>input.\n                             bind_gpv (oracle input)\n                              (\\<lambda>(x, y).\n                                  inline run_converter (rpv x) y)))) of\n           Pure x \\<Rightarrow>\n             map_spmf (map_generat id id ((\\<circ>) Inl))\n              (the_gpv\n                (case x of None \\<Rightarrow> Fail\n                 | Some (x', conv) \\<Rightarrow>\n                     Done (Some x', obsf_converter conv)))\n           | IO out c \\<Rightarrow>\n               return_spmf (IO out (\\<lambda>input. Inr (c input))))))\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_generat (=) (=)\n       (rel_fun (=)\n         (\\<lambda>gpv gpv'.\n             (\\<exists>gpva conv.\n                 gpv =\n                 bind_gpv\n                  (inline run_converter\n                    (map_gpv' id id option_of_exception (gpv_stop gpva))\n                    (obsf_converter conv))\n                  (\\<lambda>(x, conv').\n                      case x of None \\<Rightarrow> Fail\n                      | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                 gpv' =\n                 bind_gpv\n                  (map_gpv' id id option_of_exception\n                    (gpv_stop (inline run_converter gpva conv)))\n                  (case_option Fail\n                    (\\<lambda>(x', conv).\n                        Done (Some x', obsf_converter conv)))) \\<or>\n             gpv = gpv' \\<or>\n             (\\<exists>gpv2 gpv2' f f'.\n                 gpv = bind_gpv gpv2 f \\<and>\n                 gpv' = bind_gpv gpv2' f' \\<and>\n                 rel_gpv\n                  (\\<lambda>x y.\n                      \\<exists>gpv conv.\n                         f x =\n                         bind_gpv\n                          (inline run_converter\n                            (map_gpv' id id option_of_exception\n                              (gpv_stop gpv))\n                            (obsf_converter conv))\n                          (\\<lambda>(x, conv').\n                              case x of None \\<Rightarrow> Fail\n                              | Some x' \\<Rightarrow>\n                                  Done (x, conv')) \\<and>\n                         f' y =\n                         bind_gpv\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop (inline run_converter gpv conv)))\n                          (case_option Fail\n                            (\\<lambda>(x', conv).\n                                Done (Some x', obsf_converter conv))))\n                  (=) gpv2 gpv2'))))\n     (the_gpv\n       (bind_gpv\n         (inline run_converter\n           (map_gpv' id id option_of_exception (gpv_stop gpv))\n           (obsf_converter conv))\n         (\\<lambda>(x, conv').\n             case x of None \\<Rightarrow> Fail\n             | Some x' \\<Rightarrow> Done (x, conv'))))\n     (the_gpv\n       (bind_gpv\n         (map_gpv' id id option_of_exception\n           (gpv_stop (inline run_converter gpv conv)))\n         (case_option Fail\n           (\\<lambda>(x', conv). Done (Some x', obsf_converter conv)))))", "moreover"], ["proof (state)\nthis:\n  rel_spmf\n   (rel_generat (=) (=)\n     (rel_fun (=)\n       (\\<lambda>gpv gpv'.\n           (\\<exists>gpva conv.\n               gpv =\n               bind_gpv\n                (inline run_converter\n                  (map_gpv' id id option_of_exception (gpv_stop gpva))\n                  (obsf_converter conv))\n                (\\<lambda>(x, conv').\n                    case x of None \\<Rightarrow> Fail\n                    | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n               gpv' =\n               bind_gpv\n                (map_gpv' id id option_of_exception\n                  (gpv_stop (inline run_converter gpva conv)))\n                (case_option Fail\n                  (\\<lambda>(x', conv).\n                      Done (Some x', obsf_converter conv)))) \\<or>\n           gpv = gpv' \\<or>\n           (\\<exists>gpv2 gpv2' f f'.\n               gpv = bind_gpv gpv2 f \\<and>\n               gpv' = bind_gpv gpv2' f' \\<and>\n               rel_gpv\n                (\\<lambda>x y.\n                    \\<exists>gpv conv.\n                       f x =\n                       bind_gpv\n                        (inline run_converter\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop gpv))\n                          (obsf_converter conv))\n                        (\\<lambda>(x, conv').\n                            case x of None \\<Rightarrow> Fail\n                            | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                       f' y =\n                       bind_gpv\n                        (map_gpv' id id option_of_exception\n                          (gpv_stop (inline run_converter gpv conv)))\n                        (case_option Fail\n                          (\\<lambda>(x', conv).\n                              Done (Some x', obsf_converter conv))))\n                (=) gpv2 gpv2'))))\n   (bind_spmf (inline1 run_converter gpv conv)\n     (\\<lambda>y.\n         return_spmf\n          (case map_sum (apsnd obsf_converter)\n                 (apsnd\n                   (map_prod\n                     (\\<lambda>rpv.\n                         case_exception\n                          (Done (Fault, const_converter Fault))\n                          (\\<lambda>input'.\n                              map_gpv'\n                               (case_option (Fault, const_converter Fault)\n                                 (\\<lambda>(x, conv').\n                                     (OK x, obsf_converter conv')))\n                               id option_of_exception\n                               (TRY gpv_stop (rpv input') ELSE Done None)))\n                     (\\<lambda>rpv.\n                         case_exception (Done None)\n                          (\\<lambda>input'.\n                              map_gpv' id id option_of_exception\n                               (gpv_stop (rpv input'))))))\n                 y of\n           Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n           | Inr (out, rpv, rpv') \\<Rightarrow>\n               IO out\n                (\\<lambda>input.\n                    bind_gpv\n                     (bind_gpv (rpv input)\n                       (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv'))))))\n   (bind_spmf (inline1 run_converter gpv conv)\n     (\\<lambda>x.\n         map_spmf\n          (map_generat id id\n            ((\\<circ>)\n              (case_sum id\n                (\\<lambda>r.\n                    bind_gpv r\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))))))\n          (case map_generat id id\n                 (map_fun option_of_exception\n                   (map_gpv' id id option_of_exception))\n                 (map_generat Some id\n                   (\\<lambda>rpv.\n                       case_option (Done None)\n                        (\\<lambda>input'. gpv_stop (rpv input')))\n                   (case x of Inl x \\<Rightarrow> Pure x\n                    | Inr (out, oracle, rpv) \\<Rightarrow>\n                        IO out\n                         (\\<lambda>input.\n                             bind_gpv (oracle input)\n                              (\\<lambda>(x, y).\n                                  inline run_converter (rpv x) y)))) of\n           Pure x \\<Rightarrow>\n             map_spmf (map_generat id id ((\\<circ>) Inl))\n              (the_gpv\n                (case x of None \\<Rightarrow> Fail\n                 | Some (x', conv) \\<Rightarrow>\n                     Done (Some x', obsf_converter conv)))\n           | IO out c \\<Rightarrow>\n               return_spmf (IO out (\\<lambda>input. Inr (c input))))))\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_generat (=) (=)\n       (rel_fun (=)\n         (\\<lambda>gpv gpv'.\n             (\\<exists>gpva conv.\n                 gpv =\n                 bind_gpv\n                  (inline run_converter\n                    (map_gpv' id id option_of_exception (gpv_stop gpva))\n                    (obsf_converter conv))\n                  (\\<lambda>(x, conv').\n                      case x of None \\<Rightarrow> Fail\n                      | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                 gpv' =\n                 bind_gpv\n                  (map_gpv' id id option_of_exception\n                    (gpv_stop (inline run_converter gpva conv)))\n                  (case_option Fail\n                    (\\<lambda>(x', conv).\n                        Done (Some x', obsf_converter conv)))) \\<or>\n             gpv = gpv' \\<or>\n             (\\<exists>gpv2 gpv2' f f'.\n                 gpv = bind_gpv gpv2 f \\<and>\n                 gpv' = bind_gpv gpv2' f' \\<and>\n                 rel_gpv\n                  (\\<lambda>x y.\n                      \\<exists>gpv conv.\n                         f x =\n                         bind_gpv\n                          (inline run_converter\n                            (map_gpv' id id option_of_exception\n                              (gpv_stop gpv))\n                            (obsf_converter conv))\n                          (\\<lambda>(x, conv').\n                              case x of None \\<Rightarrow> Fail\n                              | Some x' \\<Rightarrow>\n                                  Done (x, conv')) \\<and>\n                         f' y =\n                         bind_gpv\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop (inline run_converter gpv conv)))\n                          (case_option Fail\n                            (\\<lambda>(x', conv).\n                                Done (Some x', obsf_converter conv))))\n                  (=) gpv2 gpv2'))))\n     (the_gpv\n       (bind_gpv\n         (inline run_converter\n           (map_gpv' id id option_of_exception (gpv_stop gpv))\n           (obsf_converter conv))\n         (\\<lambda>(x, conv').\n             case x of None \\<Rightarrow> Fail\n             | Some x' \\<Rightarrow> Done (x, conv'))))\n     (the_gpv\n       (bind_gpv\n         (map_gpv' id id option_of_exception\n           (gpv_stop (inline run_converter gpv conv)))\n         (case_option Fail\n           (\\<lambda>(x', conv). Done (Some x', obsf_converter conv)))))", "have \"?rhs2 = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_spmf (inline1 run_converter gpv conv)\n     (\\<lambda>x.\n         map_spmf\n          (map_generat id id\n            ((\\<circ>)\n              (case_sum id\n                (\\<lambda>r.\n                    bind_gpv r\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))))))\n          (case map_generat id id\n                 (map_fun option_of_exception\n                   (map_gpv' id id option_of_exception))\n                 (map_generat Some id\n                   (\\<lambda>rpv.\n                       case_option (Done None)\n                        (\\<lambda>input'. gpv_stop (rpv input')))\n                   (case x of Inl x \\<Rightarrow> Pure x\n                    | Inr (out, oracle, rpv) \\<Rightarrow>\n                        IO out\n                         (\\<lambda>input.\n                             bind_gpv (oracle input)\n                              (\\<lambda>(x, y).\n                                  inline run_converter (rpv x) y)))) of\n           Pure x \\<Rightarrow>\n             map_spmf (map_generat id id ((\\<circ>) Inl))\n              (the_gpv\n                (case x of None \\<Rightarrow> Fail\n                 | Some (x', conv) \\<Rightarrow>\n                     Done (Some x', obsf_converter conv)))\n           | IO out c \\<Rightarrow>\n               return_spmf (IO out (\\<lambda>input. Inr (c input))))) =\n    the_gpv\n     (bind_gpv\n       (map_gpv' id id option_of_exception\n         (gpv_stop (inline run_converter gpv conv)))\n       (case_option Fail\n         (\\<lambda>(x', conv). Done (Some x', obsf_converter conv))))", "by(simp del: bind_gpv_sel' add: bind_gpv.sel map_bind_spmf inline_sel bind_map_spmf o_def)"], ["proof (state)\nthis:\n  bind_spmf (inline1 run_converter gpv conv)\n   (\\<lambda>x.\n       map_spmf\n        (map_generat id id\n          ((\\<circ>)\n            (case_sum id\n              (\\<lambda>r.\n                  bind_gpv r\n                   (case_option Fail\n                     (\\<lambda>(x', conv).\n                         Done (Some x', obsf_converter conv)))))))\n        (case map_generat id id\n               (map_fun option_of_exception\n                 (map_gpv' id id option_of_exception))\n               (map_generat Some id\n                 (\\<lambda>rpv.\n                     case_option (Done None)\n                      (\\<lambda>input'. gpv_stop (rpv input')))\n                 (case x of Inl x \\<Rightarrow> Pure x\n                  | Inr (out, oracle, rpv) \\<Rightarrow>\n                      IO out\n                       (\\<lambda>input.\n                           bind_gpv (oracle input)\n                            (\\<lambda>(x, y).\n                                inline run_converter (rpv x) y)))) of\n         Pure x \\<Rightarrow>\n           map_spmf (map_generat id id ((\\<circ>) Inl))\n            (the_gpv\n              (case x of None \\<Rightarrow> Fail\n               | Some (x', conv) \\<Rightarrow>\n                   Done (Some x', obsf_converter conv)))\n         | IO out c \\<Rightarrow>\n             return_spmf (IO out (\\<lambda>input. Inr (c input))))) =\n  the_gpv\n   (bind_gpv\n     (map_gpv' id id option_of_exception\n       (gpv_stop (inline run_converter gpv conv)))\n     (case_option Fail\n       (\\<lambda>(x', conv). Done (Some x', obsf_converter conv))))\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_generat (=) (=)\n       (rel_fun (=)\n         (\\<lambda>gpv gpv'.\n             (\\<exists>gpva conv.\n                 gpv =\n                 bind_gpv\n                  (inline run_converter\n                    (map_gpv' id id option_of_exception (gpv_stop gpva))\n                    (obsf_converter conv))\n                  (\\<lambda>(x, conv').\n                      case x of None \\<Rightarrow> Fail\n                      | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                 gpv' =\n                 bind_gpv\n                  (map_gpv' id id option_of_exception\n                    (gpv_stop (inline run_converter gpva conv)))\n                  (case_option Fail\n                    (\\<lambda>(x', conv).\n                        Done (Some x', obsf_converter conv)))) \\<or>\n             gpv = gpv' \\<or>\n             (\\<exists>gpv2 gpv2' f f'.\n                 gpv = bind_gpv gpv2 f \\<and>\n                 gpv' = bind_gpv gpv2' f' \\<and>\n                 rel_gpv\n                  (\\<lambda>x y.\n                      \\<exists>gpv conv.\n                         f x =\n                         bind_gpv\n                          (inline run_converter\n                            (map_gpv' id id option_of_exception\n                              (gpv_stop gpv))\n                            (obsf_converter conv))\n                          (\\<lambda>(x, conv').\n                              case x of None \\<Rightarrow> Fail\n                              | Some x' \\<Rightarrow>\n                                  Done (x, conv')) \\<and>\n                         f' y =\n                         bind_gpv\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop (inline run_converter gpv conv)))\n                          (case_option Fail\n                            (\\<lambda>(x', conv).\n                                Done (Some x', obsf_converter conv))))\n                  (=) gpv2 gpv2'))))\n     (the_gpv\n       (bind_gpv\n         (inline run_converter\n           (map_gpv' id id option_of_exception (gpv_stop gpv))\n           (obsf_converter conv))\n         (\\<lambda>(x, conv').\n             case x of None \\<Rightarrow> Fail\n             | Some x' \\<Rightarrow> Done (x, conv'))))\n     (the_gpv\n       (bind_gpv\n         (map_gpv' id id option_of_exception\n           (gpv_stop (inline run_converter gpv conv)))\n         (case_option Fail\n           (\\<lambda>(x', conv). Done (Some x', obsf_converter conv)))))", "ultimately"], ["proof (chain)\npicking this:\n  the_gpv\n   (bind_gpv\n     (inline run_converter\n       (map_gpv' id id option_of_exception (gpv_stop gpv))\n       (obsf_converter conv))\n     (\\<lambda>(x, conv').\n         case x of None \\<Rightarrow> Fail\n         | Some x' \\<Rightarrow> Done (x, conv'))) =\n  bind_spmf (inline1 run_converter gpv conv)\n   (\\<lambda>y.\n       return_spmf\n        (case map_sum (apsnd obsf_converter)\n               (apsnd\n                 (map_prod\n                   (\\<lambda>rpv.\n                       case_exception (Done (Fault, const_converter Fault))\n                        (\\<lambda>input'.\n                            map_gpv'\n                             (case_option (Fault, const_converter Fault)\n                               (\\<lambda>(x, conv').\n                                   (OK x, obsf_converter conv')))\n                             id option_of_exception\n                             (TRY gpv_stop (rpv input') ELSE Done None)))\n                   (\\<lambda>rpv.\n                       case_exception (Done None)\n                        (\\<lambda>input'.\n                            map_gpv' id id option_of_exception\n                             (gpv_stop (rpv input'))))))\n               y of\n         Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n         | Inr (out, rpv, rpv') \\<Rightarrow>\n             IO out\n              (\\<lambda>input.\n                  bind_gpv\n                   (bind_gpv (rpv input)\n                     (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                   (\\<lambda>(x, conv').\n                       case x of None \\<Rightarrow> Fail\n                       | Some x' \\<Rightarrow> Done (x, conv')))))\n  rel_spmf\n   (rel_generat (=) (=)\n     (rel_fun (=)\n       (\\<lambda>gpv gpv'.\n           (\\<exists>gpva conv.\n               gpv =\n               bind_gpv\n                (inline run_converter\n                  (map_gpv' id id option_of_exception (gpv_stop gpva))\n                  (obsf_converter conv))\n                (\\<lambda>(x, conv').\n                    case x of None \\<Rightarrow> Fail\n                    | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n               gpv' =\n               bind_gpv\n                (map_gpv' id id option_of_exception\n                  (gpv_stop (inline run_converter gpva conv)))\n                (case_option Fail\n                  (\\<lambda>(x', conv).\n                      Done (Some x', obsf_converter conv)))) \\<or>\n           gpv = gpv' \\<or>\n           (\\<exists>gpv2 gpv2' f f'.\n               gpv = bind_gpv gpv2 f \\<and>\n               gpv' = bind_gpv gpv2' f' \\<and>\n               rel_gpv\n                (\\<lambda>x y.\n                    \\<exists>gpv conv.\n                       f x =\n                       bind_gpv\n                        (inline run_converter\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop gpv))\n                          (obsf_converter conv))\n                        (\\<lambda>(x, conv').\n                            case x of None \\<Rightarrow> Fail\n                            | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                       f' y =\n                       bind_gpv\n                        (map_gpv' id id option_of_exception\n                          (gpv_stop (inline run_converter gpv conv)))\n                        (case_option Fail\n                          (\\<lambda>(x', conv).\n                              Done (Some x', obsf_converter conv))))\n                (=) gpv2 gpv2'))))\n   (bind_spmf (inline1 run_converter gpv conv)\n     (\\<lambda>y.\n         return_spmf\n          (case map_sum (apsnd obsf_converter)\n                 (apsnd\n                   (map_prod\n                     (\\<lambda>rpv.\n                         case_exception\n                          (Done (Fault, const_converter Fault))\n                          (\\<lambda>input'.\n                              map_gpv'\n                               (case_option (Fault, const_converter Fault)\n                                 (\\<lambda>(x, conv').\n                                     (OK x, obsf_converter conv')))\n                               id option_of_exception\n                               (TRY gpv_stop (rpv input') ELSE Done None)))\n                     (\\<lambda>rpv.\n                         case_exception (Done None)\n                          (\\<lambda>input'.\n                              map_gpv' id id option_of_exception\n                               (gpv_stop (rpv input'))))))\n                 y of\n           Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n           | Inr (out, rpv, rpv') \\<Rightarrow>\n               IO out\n                (\\<lambda>input.\n                    bind_gpv\n                     (bind_gpv (rpv input)\n                       (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv'))))))\n   (bind_spmf (inline1 run_converter gpv conv)\n     (\\<lambda>x.\n         map_spmf\n          (map_generat id id\n            ((\\<circ>)\n              (case_sum id\n                (\\<lambda>r.\n                    bind_gpv r\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))))))\n          (case map_generat id id\n                 (map_fun option_of_exception\n                   (map_gpv' id id option_of_exception))\n                 (map_generat Some id\n                   (\\<lambda>rpv.\n                       case_option (Done None)\n                        (\\<lambda>input'. gpv_stop (rpv input')))\n                   (case x of Inl x \\<Rightarrow> Pure x\n                    | Inr (out, oracle, rpv) \\<Rightarrow>\n                        IO out\n                         (\\<lambda>input.\n                             bind_gpv (oracle input)\n                              (\\<lambda>(x, y).\n                                  inline run_converter (rpv x) y)))) of\n           Pure x \\<Rightarrow>\n             map_spmf (map_generat id id ((\\<circ>) Inl))\n              (the_gpv\n                (case x of None \\<Rightarrow> Fail\n                 | Some (x', conv) \\<Rightarrow>\n                     Done (Some x', obsf_converter conv)))\n           | IO out c \\<Rightarrow>\n               return_spmf (IO out (\\<lambda>input. Inr (c input))))))\n  bind_spmf (inline1 run_converter gpv conv)\n   (\\<lambda>x.\n       map_spmf\n        (map_generat id id\n          ((\\<circ>)\n            (case_sum id\n              (\\<lambda>r.\n                  bind_gpv r\n                   (case_option Fail\n                     (\\<lambda>(x', conv).\n                         Done (Some x', obsf_converter conv)))))))\n        (case map_generat id id\n               (map_fun option_of_exception\n                 (map_gpv' id id option_of_exception))\n               (map_generat Some id\n                 (\\<lambda>rpv.\n                     case_option (Done None)\n                      (\\<lambda>input'. gpv_stop (rpv input')))\n                 (case x of Inl x \\<Rightarrow> Pure x\n                  | Inr (out, oracle, rpv) \\<Rightarrow>\n                      IO out\n                       (\\<lambda>input.\n                           bind_gpv (oracle input)\n                            (\\<lambda>(x, y).\n                                inline run_converter (rpv x) y)))) of\n         Pure x \\<Rightarrow>\n           map_spmf (map_generat id id ((\\<circ>) Inl))\n            (the_gpv\n              (case x of None \\<Rightarrow> Fail\n               | Some (x', conv) \\<Rightarrow>\n                   Done (Some x', obsf_converter conv)))\n         | IO out c \\<Rightarrow>\n             return_spmf (IO out (\\<lambda>input. Inr (c input))))) =\n  the_gpv\n   (bind_gpv\n     (map_gpv' id id option_of_exception\n       (gpv_stop (inline run_converter gpv conv)))\n     (case_option Fail\n       (\\<lambda>(x', conv). Done (Some x', obsf_converter conv))))", "show ?thesis"], ["proof (prove)\nusing this:\n  the_gpv\n   (bind_gpv\n     (inline run_converter\n       (map_gpv' id id option_of_exception (gpv_stop gpv))\n       (obsf_converter conv))\n     (\\<lambda>(x, conv').\n         case x of None \\<Rightarrow> Fail\n         | Some x' \\<Rightarrow> Done (x, conv'))) =\n  bind_spmf (inline1 run_converter gpv conv)\n   (\\<lambda>y.\n       return_spmf\n        (case map_sum (apsnd obsf_converter)\n               (apsnd\n                 (map_prod\n                   (\\<lambda>rpv.\n                       case_exception (Done (Fault, const_converter Fault))\n                        (\\<lambda>input'.\n                            map_gpv'\n                             (case_option (Fault, const_converter Fault)\n                               (\\<lambda>(x, conv').\n                                   (OK x, obsf_converter conv')))\n                             id option_of_exception\n                             (TRY gpv_stop (rpv input') ELSE Done None)))\n                   (\\<lambda>rpv.\n                       case_exception (Done None)\n                        (\\<lambda>input'.\n                            map_gpv' id id option_of_exception\n                             (gpv_stop (rpv input'))))))\n               y of\n         Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n         | Inr (out, rpv, rpv') \\<Rightarrow>\n             IO out\n              (\\<lambda>input.\n                  bind_gpv\n                   (bind_gpv (rpv input)\n                     (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                   (\\<lambda>(x, conv').\n                       case x of None \\<Rightarrow> Fail\n                       | Some x' \\<Rightarrow> Done (x, conv')))))\n  rel_spmf\n   (rel_generat (=) (=)\n     (rel_fun (=)\n       (\\<lambda>gpv gpv'.\n           (\\<exists>gpva conv.\n               gpv =\n               bind_gpv\n                (inline run_converter\n                  (map_gpv' id id option_of_exception (gpv_stop gpva))\n                  (obsf_converter conv))\n                (\\<lambda>(x, conv').\n                    case x of None \\<Rightarrow> Fail\n                    | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n               gpv' =\n               bind_gpv\n                (map_gpv' id id option_of_exception\n                  (gpv_stop (inline run_converter gpva conv)))\n                (case_option Fail\n                  (\\<lambda>(x', conv).\n                      Done (Some x', obsf_converter conv)))) \\<or>\n           gpv = gpv' \\<or>\n           (\\<exists>gpv2 gpv2' f f'.\n               gpv = bind_gpv gpv2 f \\<and>\n               gpv' = bind_gpv gpv2' f' \\<and>\n               rel_gpv\n                (\\<lambda>x y.\n                    \\<exists>gpv conv.\n                       f x =\n                       bind_gpv\n                        (inline run_converter\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop gpv))\n                          (obsf_converter conv))\n                        (\\<lambda>(x, conv').\n                            case x of None \\<Rightarrow> Fail\n                            | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                       f' y =\n                       bind_gpv\n                        (map_gpv' id id option_of_exception\n                          (gpv_stop (inline run_converter gpv conv)))\n                        (case_option Fail\n                          (\\<lambda>(x', conv).\n                              Done (Some x', obsf_converter conv))))\n                (=) gpv2 gpv2'))))\n   (bind_spmf (inline1 run_converter gpv conv)\n     (\\<lambda>y.\n         return_spmf\n          (case map_sum (apsnd obsf_converter)\n                 (apsnd\n                   (map_prod\n                     (\\<lambda>rpv.\n                         case_exception\n                          (Done (Fault, const_converter Fault))\n                          (\\<lambda>input'.\n                              map_gpv'\n                               (case_option (Fault, const_converter Fault)\n                                 (\\<lambda>(x, conv').\n                                     (OK x, obsf_converter conv')))\n                               id option_of_exception\n                               (TRY gpv_stop (rpv input') ELSE Done None)))\n                     (\\<lambda>rpv.\n                         case_exception (Done None)\n                          (\\<lambda>input'.\n                              map_gpv' id id option_of_exception\n                               (gpv_stop (rpv input'))))))\n                 y of\n           Inl (x, conv) \\<Rightarrow> Pure (Some x, conv)\n           | Inr (out, rpv, rpv') \\<Rightarrow>\n               IO out\n                (\\<lambda>input.\n                    bind_gpv\n                     (bind_gpv (rpv input)\n                       (\\<lambda>(x, y). inline run_converter (rpv' x) y))\n                     (\\<lambda>(x, conv').\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow> Done (x, conv'))))))\n   (bind_spmf (inline1 run_converter gpv conv)\n     (\\<lambda>x.\n         map_spmf\n          (map_generat id id\n            ((\\<circ>)\n              (case_sum id\n                (\\<lambda>r.\n                    bind_gpv r\n                     (case_option Fail\n                       (\\<lambda>(x', conv).\n                           Done (Some x', obsf_converter conv)))))))\n          (case map_generat id id\n                 (map_fun option_of_exception\n                   (map_gpv' id id option_of_exception))\n                 (map_generat Some id\n                   (\\<lambda>rpv.\n                       case_option (Done None)\n                        (\\<lambda>input'. gpv_stop (rpv input')))\n                   (case x of Inl x \\<Rightarrow> Pure x\n                    | Inr (out, oracle, rpv) \\<Rightarrow>\n                        IO out\n                         (\\<lambda>input.\n                             bind_gpv (oracle input)\n                              (\\<lambda>(x, y).\n                                  inline run_converter (rpv x) y)))) of\n           Pure x \\<Rightarrow>\n             map_spmf (map_generat id id ((\\<circ>) Inl))\n              (the_gpv\n                (case x of None \\<Rightarrow> Fail\n                 | Some (x', conv) \\<Rightarrow>\n                     Done (Some x', obsf_converter conv)))\n           | IO out c \\<Rightarrow>\n               return_spmf (IO out (\\<lambda>input. Inr (c input))))))\n  bind_spmf (inline1 run_converter gpv conv)\n   (\\<lambda>x.\n       map_spmf\n        (map_generat id id\n          ((\\<circ>)\n            (case_sum id\n              (\\<lambda>r.\n                  bind_gpv r\n                   (case_option Fail\n                     (\\<lambda>(x', conv).\n                         Done (Some x', obsf_converter conv)))))))\n        (case map_generat id id\n               (map_fun option_of_exception\n                 (map_gpv' id id option_of_exception))\n               (map_generat Some id\n                 (\\<lambda>rpv.\n                     case_option (Done None)\n                      (\\<lambda>input'. gpv_stop (rpv input')))\n                 (case x of Inl x \\<Rightarrow> Pure x\n                  | Inr (out, oracle, rpv) \\<Rightarrow>\n                      IO out\n                       (\\<lambda>input.\n                           bind_gpv (oracle input)\n                            (\\<lambda>(x, y).\n                                inline run_converter (rpv x) y)))) of\n         Pure x \\<Rightarrow>\n           map_spmf (map_generat id id ((\\<circ>) Inl))\n            (the_gpv\n              (case x of None \\<Rightarrow> Fail\n               | Some (x', conv) \\<Rightarrow>\n                   Done (Some x', obsf_converter conv)))\n         | IO out c \\<Rightarrow>\n             return_spmf (IO out (\\<lambda>input. Inr (c input))))) =\n  the_gpv\n   (bind_gpv\n     (map_gpv' id id option_of_exception\n       (gpv_stop (inline run_converter gpv conv)))\n     (case_option Fail\n       (\\<lambda>(x', conv). Done (Some x', obsf_converter conv))))\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (rel_generat (=) (=)\n       (rel_fun (=)\n         (\\<lambda>gpv gpv'.\n             (\\<exists>gpva conv.\n                 gpv =\n                 bind_gpv\n                  (inline run_converter\n                    (map_gpv' id id option_of_exception (gpv_stop gpva))\n                    (obsf_converter conv))\n                  (\\<lambda>(x, conv').\n                      case x of None \\<Rightarrow> Fail\n                      | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                 gpv' =\n                 bind_gpv\n                  (map_gpv' id id option_of_exception\n                    (gpv_stop (inline run_converter gpva conv)))\n                  (case_option Fail\n                    (\\<lambda>(x', conv).\n                        Done (Some x', obsf_converter conv)))) \\<or>\n             gpv = gpv' \\<or>\n             (\\<exists>gpv2 gpv2' f f'.\n                 gpv = bind_gpv gpv2 f \\<and>\n                 gpv' = bind_gpv gpv2' f' \\<and>\n                 rel_gpv\n                  (\\<lambda>x y.\n                      \\<exists>gpv conv.\n                         f x =\n                         bind_gpv\n                          (inline run_converter\n                            (map_gpv' id id option_of_exception\n                              (gpv_stop gpv))\n                            (obsf_converter conv))\n                          (\\<lambda>(x, conv').\n                              case x of None \\<Rightarrow> Fail\n                              | Some x' \\<Rightarrow>\n                                  Done (x, conv')) \\<and>\n                         f' y =\n                         bind_gpv\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop (inline run_converter gpv conv)))\n                          (case_option Fail\n                            (\\<lambda>(x', conv).\n                                Done (Some x', obsf_converter conv))))\n                  (=) gpv2 gpv2'))))\n     (the_gpv\n       (bind_gpv\n         (inline run_converter\n           (map_gpv' id id option_of_exception (gpv_stop gpv))\n           (obsf_converter conv))\n         (\\<lambda>(x, conv').\n             case x of None \\<Rightarrow> Fail\n             | Some x' \\<Rightarrow> Done (x, conv'))))\n     (the_gpv\n       (bind_gpv\n         (map_gpv' id id option_of_exception\n           (gpv_stop (inline run_converter gpv conv)))\n         (case_option Fail\n           (\\<lambda>(x', conv). Done (Some x', obsf_converter conv)))))", "by(simp only:)"], ["proof (state)\nthis:\n  rel_spmf\n   (rel_generat (=) (=)\n     (rel_fun (=)\n       (\\<lambda>gpv gpv'.\n           (\\<exists>gpva conv.\n               gpv =\n               bind_gpv\n                (inline run_converter\n                  (map_gpv' id id option_of_exception (gpv_stop gpva))\n                  (obsf_converter conv))\n                (\\<lambda>(x, conv').\n                    case x of None \\<Rightarrow> Fail\n                    | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n               gpv' =\n               bind_gpv\n                (map_gpv' id id option_of_exception\n                  (gpv_stop (inline run_converter gpva conv)))\n                (case_option Fail\n                  (\\<lambda>(x', conv).\n                      Done (Some x', obsf_converter conv)))) \\<or>\n           gpv = gpv' \\<or>\n           (\\<exists>gpv2 gpv2' f f'.\n               gpv = bind_gpv gpv2 f \\<and>\n               gpv' = bind_gpv gpv2' f' \\<and>\n               rel_gpv\n                (\\<lambda>x y.\n                    \\<exists>gpv conv.\n                       f x =\n                       bind_gpv\n                        (inline run_converter\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop gpv))\n                          (obsf_converter conv))\n                        (\\<lambda>(x, conv').\n                            case x of None \\<Rightarrow> Fail\n                            | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                       f' y =\n                       bind_gpv\n                        (map_gpv' id id option_of_exception\n                          (gpv_stop (inline run_converter gpv conv)))\n                        (case_option Fail\n                          (\\<lambda>(x', conv).\n                              Done (Some x', obsf_converter conv))))\n                (=) gpv2 gpv2'))))\n   (the_gpv\n     (bind_gpv\n       (inline run_converter\n         (map_gpv' id id option_of_exception (gpv_stop gpv))\n         (obsf_converter conv))\n       (\\<lambda>(x, conv').\n           case x of None \\<Rightarrow> Fail\n           | Some x' \\<Rightarrow> Done (x, conv'))))\n   (the_gpv\n     (bind_gpv\n       (map_gpv' id id option_of_exception\n         (gpv_stop (inline run_converter gpv conv)))\n       (case_option Fail\n         (\\<lambda>(x', conv). Done (Some x', obsf_converter conv)))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_spmf\n   (rel_generat (=) (=)\n     (rel_fun (=)\n       (\\<lambda>gpv gpv'.\n           (\\<exists>gpva conv.\n               gpv =\n               bind_gpv\n                (inline run_converter\n                  (map_gpv' id id option_of_exception (gpv_stop gpva))\n                  (obsf_converter conv))\n                (\\<lambda>(x, conv').\n                    case x of None \\<Rightarrow> Fail\n                    | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n               gpv' =\n               bind_gpv\n                (map_gpv' id id option_of_exception\n                  (gpv_stop (inline run_converter gpva conv)))\n                (case_option Fail\n                  (\\<lambda>(x', conv).\n                      Done (Some x', obsf_converter conv)))) \\<or>\n           gpv = gpv' \\<or>\n           (\\<exists>gpv2 gpv2' f f'.\n               gpv = bind_gpv gpv2 f \\<and>\n               gpv' = bind_gpv gpv2' f' \\<and>\n               rel_gpv\n                (\\<lambda>x y.\n                    \\<exists>gpv conv.\n                       f x =\n                       bind_gpv\n                        (inline run_converter\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop gpv))\n                          (obsf_converter conv))\n                        (\\<lambda>(x, conv').\n                            case x of None \\<Rightarrow> Fail\n                            | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                       f' y =\n                       bind_gpv\n                        (map_gpv' id id option_of_exception\n                          (gpv_stop (inline run_converter gpv conv)))\n                        (case_option Fail\n                          (\\<lambda>(x', conv).\n                              Done (Some x', obsf_converter conv))))\n                (=) gpv2 gpv2'))))\n   (the_gpv\n     (bind_gpv\n       (inline run_converter\n         (map_gpv' id id option_of_exception (gpv_stop gpv))\n         (obsf_converter conv))\n       (\\<lambda>(x, conv').\n           case x of None \\<Rightarrow> Fail\n           | Some x' \\<Rightarrow> Done (x, conv'))))\n   (the_gpv\n     (bind_gpv\n       (map_gpv' id id option_of_exception\n         (gpv_stop (inline run_converter gpv conv)))\n       (case_option Fail\n         (\\<lambda>(x', conv). Done (Some x', obsf_converter conv)))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma obsf_comp_converter:\n  assumes WT: \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>\" \"\\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>\"\n    and pfinite1: \"pfinite_converter \\<I> \\<I>' conv1\"\n  shows \"exception_\\<I> \\<I>, exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C obsf_converter (comp_converter conv1 conv2) \\<sim> comp_converter (obsf_converter conv1) (obsf_converter conv2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exception_\\<I> \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n    obsf_converter (conv1 \\<odot> conv2) \\<sim>\n    obsf_converter conv1 \\<odot> obsf_converter conv2", "using WT pfinite1"], ["proof (prove)\nusing this:\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>\n  \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>\n  pfinite_converter \\<I> \\<I>' conv1\n\ngoal (1 subgoal):\n 1. exception_\\<I> \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n    obsf_converter (conv1 \\<odot> conv2) \\<sim>\n    obsf_converter conv1 \\<odot> obsf_converter conv2", "supply eq_\\<I>_gpv_map_gpv[simp del]"], ["proof (prove)\nusing this:\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>\n  \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>\n  pfinite_converter \\<I> \\<I>' conv1\n\ngoal (1 subgoal):\n 1. exception_\\<I> \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n    obsf_converter (conv1 \\<odot> conv2) \\<sim>\n    obsf_converter conv1 \\<odot> obsf_converter conv2", "proof(coinduction arbitrary: conv1 conv2)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q conv1 conv2.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1;\n        q \\<in> outs_\\<I> (exception_\\<I> \\<I>)\\<rbrakk>\n       \\<Longrightarrow> eq_\\<I>_gpv\n                          (rel_prod\n                            (eq_onp\n                              (\\<lambda>r.\n                                  r \\<in> responses_\\<I>\n     (exception_\\<I> \\<I>) q))\n                            (\\<lambda>conv conv'.\n                                (\\<exists>conv1 conv2.\n                                    conv =\n                                    obsf_converter\n                                     (conv1 \\<odot> conv2) \\<and>\n                                    conv' =\n                                    obsf_converter conv1 \\<odot>\n                                    obsf_converter conv2 \\<and>\n                                    \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                    conv1 \\<surd> \\<and>\n                                    \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                    conv2 \\<surd> \\<and>\n                                    pfinite_converter \\<I> \\<I>'\n                                     conv1) \\<or>\n                                exception_\\<I>\n                                 \\<I>,exception_\\<I>\n \\<I>'' \\<turnstile>\\<^sub>C\n                                conv \\<sim> conv'))\n                          (exception_\\<I> \\<I>'')\n                          (run_converter\n                            (obsf_converter (conv1 \\<odot> conv2)) q)\n                          (run_converter\n                            (obsf_converter conv1 \\<odot>\n                             obsf_converter conv2)\n                            q)", "case eq_\\<I>_converter"], ["proof (state)\nthis:\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>\n  \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>\n  pfinite_converter \\<I> \\<I>' conv1\n  q \\<in> outs_\\<I> (exception_\\<I> \\<I>)\n\ngoal (1 subgoal):\n 1. \\<And>q conv1 conv2.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1;\n        q \\<in> outs_\\<I> (exception_\\<I> \\<I>)\\<rbrakk>\n       \\<Longrightarrow> eq_\\<I>_gpv\n                          (rel_prod\n                            (eq_onp\n                              (\\<lambda>r.\n                                  r \\<in> responses_\\<I>\n     (exception_\\<I> \\<I>) q))\n                            (\\<lambda>conv conv'.\n                                (\\<exists>conv1 conv2.\n                                    conv =\n                                    obsf_converter\n                                     (conv1 \\<odot> conv2) \\<and>\n                                    conv' =\n                                    obsf_converter conv1 \\<odot>\n                                    obsf_converter conv2 \\<and>\n                                    \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                    conv1 \\<surd> \\<and>\n                                    \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                    conv2 \\<surd> \\<and>\n                                    pfinite_converter \\<I> \\<I>'\n                                     conv1) \\<or>\n                                exception_\\<I>\n                                 \\<I>,exception_\\<I>\n \\<I>'' \\<turnstile>\\<^sub>C\n                                conv \\<sim> conv'))\n                          (exception_\\<I> \\<I>'')\n                          (run_converter\n                            (obsf_converter (conv1 \\<odot> conv2)) q)\n                          (run_converter\n                            (obsf_converter conv1 \\<odot>\n                             obsf_converter conv2)\n                            q)", "show ?case (is \"eq_\\<I>_gpv ?X _ ?lhs ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv\n     (rel_prod\n       (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> (exception_\\<I> \\<I>) q))\n       (\\<lambda>conv conv'.\n           (\\<exists>conv1 conv2.\n               conv = obsf_converter (conv1 \\<odot> conv2) \\<and>\n               conv' =\n               obsf_converter conv1 \\<odot> obsf_converter conv2 \\<and>\n               \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and>\n               \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd> \\<and>\n               pfinite_converter \\<I> \\<I>' conv1) \\<or>\n           exception_\\<I> \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n           conv \\<sim> conv'))\n     (exception_\\<I> \\<I>'')\n     (run_converter (obsf_converter (conv1 \\<odot> conv2)) q)\n     (run_converter (obsf_converter conv1 \\<odot> obsf_converter conv2) q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv\n     (rel_prod\n       (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> (exception_\\<I> \\<I>) q))\n       (\\<lambda>conv conv'.\n           (\\<exists>conv1 conv2.\n               conv = obsf_converter (conv1 \\<odot> conv2) \\<and>\n               conv' =\n               obsf_converter conv1 \\<odot> obsf_converter conv2 \\<and>\n               \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and>\n               \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd> \\<and>\n               pfinite_converter \\<I> \\<I>' conv1) \\<or>\n           exception_\\<I> \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n           conv \\<sim> conv'))\n     (exception_\\<I> \\<I>'')\n     (run_converter (obsf_converter (conv1 \\<odot> conv2)) q)\n     (run_converter (obsf_converter conv1 \\<odot> obsf_converter conv2) q)", "have \"eq_\\<I>_gpv (=) (exception_\\<I> \\<I>'') ?rhs (TRY map_gpv (\\<lambda>((b, conv1'), conv2'). (b, conv1' \\<odot> conv2')) id\n               (inline run_converter\n                 (map_gpv'\n                   (case_option (Fault, const_converter Fault)\n                     (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n                   id option_of_exception (gpv_stop (run_converter conv1 q)))\n                 (obsf_converter conv2)) ELSE Done (Fault, const_converter Fault))\"\n      (is \"eq_\\<I>_gpv _ _ _ ?rhs2\" is \"eq_\\<I>_gpv _ _ _ (try_gpv (map_gpv ?f _ ?inline) ?else)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv (=) (exception_\\<I> \\<I>'')\n     (run_converter (obsf_converter conv1 \\<odot> obsf_converter conv2) q)\n     (TRY map_gpv\n           (\\<lambda>((b, conv1'), conv2'). (b, conv1' \\<odot> conv2')) id\n           (inline run_converter\n             (map_gpv'\n               (case_option (Fault, const_converter Fault)\n                 (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n               id option_of_exception (gpv_stop (run_converter conv1 q)))\n             (obsf_converter\n               conv2)) ELSE Done (Fault, const_converter Fault))", "using eq_\\<I>_converter"], ["proof (prove)\nusing this:\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>\n  \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>\n  pfinite_converter \\<I> \\<I>' conv1\n  q \\<in> outs_\\<I> (exception_\\<I> \\<I>)\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv (=) (exception_\\<I> \\<I>'')\n     (run_converter (obsf_converter conv1 \\<odot> obsf_converter conv2) q)\n     (TRY map_gpv\n           (\\<lambda>((b, conv1'), conv2'). (b, conv1' \\<odot> conv2')) id\n           (inline run_converter\n             (map_gpv'\n               (case_option (Fault, const_converter Fault)\n                 (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n               id option_of_exception (gpv_stop (run_converter conv1 q)))\n             (obsf_converter\n               conv2)) ELSE Done (Fault, const_converter Fault))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv (=) (exception_\\<I> \\<I>'')\n                       (map_gpv\n                         (\\<lambda>((b, conv1'), conv2').\n                             (b, conv1' \\<odot> conv2'))\n                         id (inline run_converter\n                              (TRY map_gpv'\n                                    (case_option\n(Fault, const_converter Fault)\n(\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n                                    id option_of_exception\n                                    (gpv_stop\n(run_converter conv1 q)) ELSE Done (Fault, const_converter Fault))\n                              (obsf_converter conv2)))\n                       (TRY map_gpv\n                             (\\<lambda>((b, conv1'), conv2').\n                                 (b, conv1' \\<odot> conv2'))\n                             id (inline run_converter\n                                  (map_gpv'\n                                    (case_option\n(Fault, const_converter Fault)\n(\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n                                    id option_of_exception\n                                    (gpv_stop (run_converter conv1 q)))\n                                  (obsf_converter\n                                    conv2)) ELSE Done\n            (Fault, const_converter Fault))", "apply(rule run_colossless_converter.inline_try_gpv[where \\<I>=\"exception_\\<I> \\<I>'\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>'\n                      \\<turnstile>g map_gpv'\n                                     (case_option\n (Fault, const_converter Fault)\n (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n                                     id option_of_exception\n                                     (gpv_stop\n (run_converter conv1 q)) \\<surd>\n 2. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> pfinite_gpv (exception_\\<I> \\<I>')\n                       (map_gpv'\n                         (case_option (Fault, const_converter Fault)\n                           (\\<lambda>(x, conv').\n                               (OK x, obsf_converter conv')))\n                         id option_of_exception\n                         (gpv_stop (run_converter conv1 q)))\n 3. \\<And>s.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        colossless_converter (exception_\\<I> \\<I>') (exception_\\<I> \\<I>'')\n         s \\<and>\n        exception_\\<I> \\<I>', exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n        s \\<surd>\\<rbrakk>\n       \\<Longrightarrow> (case ((Fault, const_converter Fault), s) of\n                          (x, xa) \\<Rightarrow>\n                            (case x of\n                             (b, conv1') \\<Rightarrow>\n                               \\<lambda>conv2'. (b, conv1' \\<odot> conv2'))\n                             xa) =\n                         (Fault, const_converter Fault)\n 4. \\<And>s x.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        x \\<in> outs_\\<I> (exception_\\<I> \\<I>');\n        colossless_converter (exception_\\<I> \\<I>') (exception_\\<I> \\<I>'')\n         s \\<and>\n        exception_\\<I> \\<I>', exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n        s \\<surd>\\<rbrakk>\n       \\<Longrightarrow> colossless_gpv (exception_\\<I> \\<I>'')\n                          (run_converter s x)\n 5. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> colossless_converter (exception_\\<I> \\<I>')\n                       (exception_\\<I> \\<I>'') (obsf_converter conv2) \\<and>\n                      exception_\\<I> \\<I>',\n                      exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n                      obsf_converter conv2 \\<surd>", "apply(auto intro!: WT_intro pfinite_gpv_stop[THEN iffD2] dest: WT_converterD pfinite_converterD colossless_converterD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eq_\\<I>_gpv (=) (exception_\\<I> \\<I>'')\n   (run_converter (obsf_converter conv1 \\<odot> obsf_converter conv2) q)\n   (TRY map_gpv (\\<lambda>((b, conv1'), conv2'). (b, conv1' \\<odot> conv2'))\n         id (inline run_converter\n              (map_gpv'\n                (case_option (Fault, const_converter Fault)\n                  (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n                id option_of_exception (gpv_stop (run_converter conv1 q)))\n              (obsf_converter\n                conv2)) ELSE Done (Fault, const_converter Fault))\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv\n     (rel_prod\n       (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> (exception_\\<I> \\<I>) q))\n       (\\<lambda>conv conv'.\n           (\\<exists>conv1 conv2.\n               conv = obsf_converter (conv1 \\<odot> conv2) \\<and>\n               conv' =\n               obsf_converter conv1 \\<odot> obsf_converter conv2 \\<and>\n               \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and>\n               \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd> \\<and>\n               pfinite_converter \\<I> \\<I>' conv1) \\<or>\n           exception_\\<I> \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n           conv \\<sim> conv'))\n     (exception_\\<I> \\<I>'')\n     (run_converter (obsf_converter (conv1 \\<odot> conv2)) q)\n     (run_converter (obsf_converter conv1 \\<odot> obsf_converter conv2) q)", "term \"bind_gpv (inline run_converter (map_gpv' id id option_of_exception (gpv_stop (run_converter conv1 q))) (obsf_converter conv2))\n           (\\<lambda>(x, conv'). case x of None \\<Rightarrow> Fail | Some x' \\<Rightarrow> Done (x, conv'))\""], ["proof (state)\nthis:\n  eq_\\<I>_gpv (=) (exception_\\<I> \\<I>'')\n   (run_converter (obsf_converter conv1 \\<odot> obsf_converter conv2) q)\n   (TRY map_gpv (\\<lambda>((b, conv1'), conv2'). (b, conv1' \\<odot> conv2'))\n         id (inline run_converter\n              (map_gpv'\n                (case_option (Fault, const_converter Fault)\n                  (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n                id option_of_exception (gpv_stop (run_converter conv1 q)))\n              (obsf_converter\n                conv2)) ELSE Done (Fault, const_converter Fault))\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv\n     (rel_prod\n       (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> (exception_\\<I> \\<I>) q))\n       (\\<lambda>conv conv'.\n           (\\<exists>conv1 conv2.\n               conv = obsf_converter (conv1 \\<odot> conv2) \\<and>\n               conv' =\n               obsf_converter conv1 \\<odot> obsf_converter conv2 \\<and>\n               \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and>\n               \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd> \\<and>\n               pfinite_converter \\<I> \\<I>' conv1) \\<or>\n           exception_\\<I> \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n           conv \\<sim> conv'))\n     (exception_\\<I> \\<I>'')\n     (run_converter (obsf_converter (conv1 \\<odot> conv2)) q)\n     (run_converter (obsf_converter conv1 \\<odot> obsf_converter conv2) q)", "also"], ["proof (state)\nthis:\n  eq_\\<I>_gpv (=) (exception_\\<I> \\<I>'')\n   (run_converter (obsf_converter conv1 \\<odot> obsf_converter conv2) q)\n   (TRY map_gpv (\\<lambda>((b, conv1'), conv2'). (b, conv1' \\<odot> conv2'))\n         id (inline run_converter\n              (map_gpv'\n                (case_option (Fault, const_converter Fault)\n                  (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n                id option_of_exception (gpv_stop (run_converter conv1 q)))\n              (obsf_converter\n                conv2)) ELSE Done (Fault, const_converter Fault))\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv\n     (rel_prod\n       (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> (exception_\\<I> \\<I>) q))\n       (\\<lambda>conv conv'.\n           (\\<exists>conv1 conv2.\n               conv = obsf_converter (conv1 \\<odot> conv2) \\<and>\n               conv' =\n               obsf_converter conv1 \\<odot> obsf_converter conv2 \\<and>\n               \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and>\n               \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd> \\<and>\n               pfinite_converter \\<I> \\<I>' conv1) \\<or>\n           exception_\\<I> \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n           conv \\<sim> conv'))\n     (exception_\\<I> \\<I>'')\n     (run_converter (obsf_converter (conv1 \\<odot> conv2)) q)\n     (run_converter (obsf_converter conv1 \\<odot> obsf_converter conv2) q)", "have \"?rhs2 = try_gpv (map_gpv ?f id\n       (map_gpv (\\<lambda>(xo, conv'). case xo of None \\<Rightarrow> ((Fault, const_converter Fault), conv') | Some (x, conv) \\<Rightarrow> ((OK x, obsf_converter conv), conv')) id\n         (bind_gpv (inline run_converter (map_gpv' id id option_of_exception (gpv_stop (run_converter conv1 q))) (obsf_converter conv2))\n           (\\<lambda>(x, conv'). case x of None \\<Rightarrow> Fail | Some x' \\<Rightarrow> Done (x, conv')))))\n        ?else\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY map_gpv (\\<lambda>((b, conv1'), conv2'). (b, conv1' \\<odot> conv2'))\n         id (inline run_converter\n              (map_gpv'\n                (case_option (Fault, const_converter Fault)\n                  (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n                id option_of_exception (gpv_stop (run_converter conv1 q)))\n              (obsf_converter\n                conv2)) ELSE Done (Fault, const_converter Fault) =\n    TRY map_gpv (\\<lambda>((b, conv1'), conv2'). (b, conv1' \\<odot> conv2'))\n         id (map_gpv\n              (\\<lambda>(xo, conv').\n                  case xo of\n                  None \\<Rightarrow> ((Fault, const_converter Fault), conv')\n                  | Some (x, conv) \\<Rightarrow>\n                      ((OK x, obsf_converter conv), conv'))\n              id (bind_gpv\n                   (inline run_converter\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop (run_converter conv1 q)))\n                     (obsf_converter conv2))\n                   (\\<lambda>(x, conv').\n                       case x of None \\<Rightarrow> Fail\n                       | Some x' \\<Rightarrow>\n                           Done\n                            (x, conv')))) ELSE Done\n          (Fault, const_converter Fault)", "apply(simp add: map_gpv_bind_gpv gpv.map_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY map_gpv (\\<lambda>((b, conv1'), conv2'). (b, conv1' \\<odot> conv2'))\n         id (inline run_converter\n              (map_gpv'\n                (case_option (Fault, const_converter Fault)\n                  (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n                id option_of_exception (gpv_stop (run_converter conv1 q)))\n              (obsf_converter\n                conv2)) ELSE Done (Fault, const_converter Fault) =\n    TRY bind_gpv\n         (inline run_converter\n           (map_gpv' id id option_of_exception\n             (gpv_stop (run_converter conv1 q)))\n           (obsf_converter conv2))\n         (\\<lambda>x.\n             map_gpv\n              (\\<lambda>((b, conv1'), conv2'). (b, conv1' \\<odot> conv2'))\n              id (map_gpv\n                   (\\<lambda>(xo, conv').\n                       case xo of\n                       None \\<Rightarrow>\n                         ((Fault, const_converter Fault), conv')\n                       | Some (xa, conv) \\<Rightarrow>\n                           ((OK xa, obsf_converter conv), conv'))\n                   id (case x of\n                       (x, conv') \\<Rightarrow>\n                         case x of None \\<Rightarrow> Fail\n                         | Some x' \\<Rightarrow>\n                             Done\n                              (x, conv')))) ELSE Done\n            (Fault, const_converter Fault)", "apply(subst try_gpv_bind_gpv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY map_gpv (\\<lambda>((b, conv1'), conv2'). (b, conv1' \\<odot> conv2'))\n         id (inline run_converter\n              (map_gpv'\n                (case_option (Fault, const_converter Fault)\n                  (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n                id option_of_exception (gpv_stop (run_converter conv1 q)))\n              (obsf_converter\n                conv2)) ELSE Done (Fault, const_converter Fault) =\n    bind_gpv\n     (TRY map_gpv Some id\n           (inline run_converter\n             (map_gpv' id id option_of_exception\n               (gpv_stop (run_converter conv1 q)))\n             (obsf_converter conv2)) ELSE Done None)\n     (case_option (Done (Fault, const_converter Fault))\n       (\\<lambda>x'.\n           TRY map_gpv\n                (\\<lambda>((b, conv1'), conv2'). (b, conv1' \\<odot> conv2'))\n                id (map_gpv\n                     (\\<lambda>(xo, conv').\n                         case xo of\n                         None \\<Rightarrow>\n                           ((Fault, const_converter Fault), conv')\n                         | Some (xa, conv) \\<Rightarrow>\n                             ((OK xa, obsf_converter conv), conv'))\n                     id (case x' of\n                         (x, conv') \\<Rightarrow>\n                           case x of None \\<Rightarrow> Fail\n                           | Some x' \\<Rightarrow>\n                               Done\n                                (x, conv'))) ELSE Done\n             (Fault, const_converter Fault)))", "apply(simp add: split_def option.case_distrib[where h=\"map_gpv _ _\"] option.case_distrib[where h=\"fst\"] option.case_distrib[where h=\"\\<lambda>x. try_gpv x _\"] cong del: option.case_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY map_gpv (\\<lambda>p. (fst (fst p), snd (fst p) \\<odot> snd p)) id\n         (inline run_converter\n           (map_gpv'\n             (case_option (Fault, const_converter Fault)\n               (\\<lambda>p. (OK (fst p), obsf_converter (snd p))))\n             id option_of_exception (gpv_stop (run_converter conv1 q)))\n           (obsf_converter\n             conv2)) ELSE Done (Fault, const_converter Fault) =\n    bind_gpv\n     (TRY map_gpv Some id\n           (inline run_converter\n             (map_gpv' id id option_of_exception\n               (gpv_stop (run_converter conv1 q)))\n             (obsf_converter conv2)) ELSE Done None)\n     (case_option (Done (Fault, const_converter Fault))\n       (\\<lambda>x'.\n           case fst x' of\n           None \\<Rightarrow> Done (Fault, const_converter Fault)\n           | Some x \\<Rightarrow>\n               Done\n                (case fst x' of None \\<Rightarrow> Fault\n                 | Some x \\<Rightarrow> OK (fst x),\n                 snd (case fst x' of\n                      None \\<Rightarrow> (Fault, const_converter Fault)\n                      | Some x \\<Rightarrow>\n                          (OK (fst x), obsf_converter (snd x))) \\<odot>\n                 snd (case fst x' of\n                      None \\<Rightarrow>\n                        ((Fault, const_converter Fault), snd x')\n                      | Some p \\<Rightarrow>\n                          ((OK (fst p), obsf_converter (snd p)), snd x')))))", "apply(subst option.case_distrib[where h=Done, symmetric, abs_def])+"], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY map_gpv (\\<lambda>p. (fst (fst p), snd (fst p) \\<odot> snd p)) id\n         (inline run_converter\n           (map_gpv'\n             (case_option (Fault, const_converter Fault)\n               (\\<lambda>p. (OK (fst p), obsf_converter (snd p))))\n             id option_of_exception (gpv_stop (run_converter conv1 q)))\n           (obsf_converter\n             conv2)) ELSE Done (Fault, const_converter Fault) =\n    bind_gpv\n     (TRY map_gpv Some id\n           (inline run_converter\n             (map_gpv' id id option_of_exception\n               (gpv_stop (run_converter conv1 q)))\n             (obsf_converter conv2)) ELSE Done None)\n     (\\<lambda>option.\n         Done\n          (case option of None \\<Rightarrow> (Fault, const_converter Fault)\n           | Some x' \\<Rightarrow>\n               case fst x' of\n               None \\<Rightarrow> (Fault, const_converter Fault)\n               | Some x \\<Rightarrow>\n                   (case fst x' of None \\<Rightarrow> Fault\n                    | Some x \\<Rightarrow> OK (fst x),\n                    snd (case fst x' of\n                         None \\<Rightarrow> (Fault, const_converter Fault)\n                         | Some x \\<Rightarrow>\n                             (OK (fst x), obsf_converter (snd x))) \\<odot>\n                    snd (case fst x' of\n                         None \\<Rightarrow>\n                           ((Fault, const_converter Fault), snd x')\n                         | Some p \\<Rightarrow>\n                             ((OK (fst p), obsf_converter (snd p)),\n                              snd x')))))", "apply(fold map_gpv_conv_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY map_gpv (\\<lambda>p. (fst (fst p), snd (fst p) \\<odot> snd p)) id\n         (inline run_converter\n           (map_gpv'\n             (case_option (Fault, const_converter Fault)\n               (\\<lambda>p. (OK (fst p), obsf_converter (snd p))))\n             id option_of_exception (gpv_stop (run_converter conv1 q)))\n           (obsf_converter\n             conv2)) ELSE Done (Fault, const_converter Fault) =\n    map_gpv\n     (\\<lambda>option.\n         case option of None \\<Rightarrow> (Fault, const_converter Fault)\n         | Some x' \\<Rightarrow>\n             case fst x' of\n             None \\<Rightarrow> (Fault, const_converter Fault)\n             | Some x \\<Rightarrow>\n                 (case fst x' of None \\<Rightarrow> Fault\n                  | Some x \\<Rightarrow> OK (fst x),\n                  snd (case fst x' of\n                       None \\<Rightarrow> (Fault, const_converter Fault)\n                       | Some x \\<Rightarrow>\n                           (OK (fst x), obsf_converter (snd x))) \\<odot>\n                  snd (case fst x' of\n                       None \\<Rightarrow>\n                         ((Fault, const_converter Fault), snd x')\n                       | Some p \\<Rightarrow>\n                           ((OK (fst p), obsf_converter (snd p)), snd x'))))\n     (\\<lambda>option. option)\n     (TRY map_gpv Some id\n           (inline run_converter\n             (map_gpv' id id option_of_exception\n               (gpv_stop (run_converter conv1 q)))\n             (obsf_converter conv2)) ELSE Done None)", "apply(simp add: map_try_gpv gpv.map_comp o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY map_gpv (\\<lambda>p. (fst (fst p), snd (fst p) \\<odot> snd p)) id\n         (inline run_converter\n           (map_gpv'\n             (case_option (Fault, const_converter Fault)\n               (\\<lambda>p. (OK (fst p), obsf_converter (snd p))))\n             id option_of_exception (gpv_stop (run_converter conv1 q)))\n           (obsf_converter\n             conv2)) ELSE Done (Fault, const_converter Fault) =\n    TRY map_gpv\n         (\\<lambda>x.\n             case fst x of None \\<Rightarrow> (Fault, const_converter Fault)\n             | Some xa \\<Rightarrow>\n                 (case fst x of None \\<Rightarrow> Fault\n                  | Some x \\<Rightarrow> OK (fst x),\n                  snd (case fst x of\n                       None \\<Rightarrow> (Fault, const_converter Fault)\n                       | Some x \\<Rightarrow>\n                           (OK (fst x), obsf_converter (snd x))) \\<odot>\n                  snd (case fst x of\n                       None \\<Rightarrow>\n                         ((Fault, const_converter Fault), snd x)\n                       | Some p \\<Rightarrow>\n                           ((OK (fst p), obsf_converter (snd p)), snd x))))\n         (\\<lambda>x. x)\n         (inline run_converter\n           (map_gpv' id id option_of_exception\n             (gpv_stop (run_converter conv1 q)))\n           (obsf_converter conv2)) ELSE Done (Fault, const_converter Fault)", "apply(rule try_gpv_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. map_gpv (\\<lambda>p. (fst (fst p), snd (fst p) \\<odot> snd p)) id\n     (inline run_converter\n       (map_gpv'\n         (case_option (Fault, const_converter Fault)\n           (\\<lambda>p. (OK (fst p), obsf_converter (snd p))))\n         id option_of_exception (gpv_stop (run_converter conv1 q)))\n       (obsf_converter conv2)) =\n    map_gpv\n     (\\<lambda>x.\n         case fst x of None \\<Rightarrow> (Fault, const_converter Fault)\n         | Some xa \\<Rightarrow>\n             (case fst x of None \\<Rightarrow> Fault\n              | Some x \\<Rightarrow> OK (fst x),\n              snd (case fst x of\n                   None \\<Rightarrow> (Fault, const_converter Fault)\n                   | Some x \\<Rightarrow>\n                       (OK (fst x), obsf_converter (snd x))) \\<odot>\n              snd (case fst x of\n                   None \\<Rightarrow>\n                     ((Fault, const_converter Fault), snd x)\n                   | Some p \\<Rightarrow>\n                       ((OK (fst p), obsf_converter (snd p)), snd x))))\n     (\\<lambda>x. x)\n     (inline run_converter\n       (map_gpv' id id option_of_exception\n         (gpv_stop (run_converter conv1 q)))\n       (obsf_converter conv2))\n 2. \\<not> colossless_gpv \\<I>_full\n            (map_gpv\n              (\\<lambda>x.\n                  case fst x of\n                  None \\<Rightarrow> (Fault, const_converter Fault)\n                  | Some xa \\<Rightarrow>\n                      (case fst x of None \\<Rightarrow> Fault\n                       | Some x \\<Rightarrow> OK (fst x),\n                       snd (case fst x of\n                            None \\<Rightarrow>\n                              (Fault, const_converter Fault)\n                            | Some x \\<Rightarrow>\n                                (OK (fst x),\n                                 obsf_converter (snd x))) \\<odot>\n                       snd (case fst x of\n                            None \\<Rightarrow>\n                              ((Fault, const_converter Fault), snd x)\n                            | Some p \\<Rightarrow>\n                                ((OK (fst p), obsf_converter (snd p)),\n                                 snd x))))\n              (\\<lambda>x. x)\n              (inline run_converter\n                (map_gpv' id id option_of_exception\n                  (gpv_stop (run_converter conv1 q)))\n                (obsf_converter conv2))) \\<Longrightarrow>\n    Done (Fault, const_converter Fault) =\n    Done (Fault, const_converter Fault)", "apply(subst map_gpv'_id12)"], ["proof (prove)\ngoal (2 subgoals):\n 1. map_gpv (\\<lambda>p. (fst (fst p), snd (fst p) \\<odot> snd p)) id\n     (inline run_converter\n       (map_gpv' id id option_of_exception\n         (map_gpv\n           (case_option (Fault, const_converter Fault)\n             (\\<lambda>p. (OK (fst p), obsf_converter (snd p))))\n           id (gpv_stop (run_converter conv1 q))))\n       (obsf_converter conv2)) =\n    map_gpv\n     (\\<lambda>x.\n         case fst x of None \\<Rightarrow> (Fault, const_converter Fault)\n         | Some xa \\<Rightarrow>\n             (case fst x of None \\<Rightarrow> Fault\n              | Some x \\<Rightarrow> OK (fst x),\n              snd (case fst x of\n                   None \\<Rightarrow> (Fault, const_converter Fault)\n                   | Some x \\<Rightarrow>\n                       (OK (fst x), obsf_converter (snd x))) \\<odot>\n              snd (case fst x of\n                   None \\<Rightarrow>\n                     ((Fault, const_converter Fault), snd x)\n                   | Some p \\<Rightarrow>\n                       ((OK (fst p), obsf_converter (snd p)), snd x))))\n     (\\<lambda>x. x)\n     (inline run_converter\n       (map_gpv' id id option_of_exception\n         (gpv_stop (run_converter conv1 q)))\n       (obsf_converter conv2))\n 2. \\<not> colossless_gpv \\<I>_full\n            (map_gpv\n              (\\<lambda>x.\n                  case fst x of\n                  None \\<Rightarrow> (Fault, const_converter Fault)\n                  | Some xa \\<Rightarrow>\n                      (case fst x of None \\<Rightarrow> Fault\n                       | Some x \\<Rightarrow> OK (fst x),\n                       snd (case fst x of\n                            None \\<Rightarrow>\n                              (Fault, const_converter Fault)\n                            | Some x \\<Rightarrow>\n                                (OK (fst x),\n                                 obsf_converter (snd x))) \\<odot>\n                       snd (case fst x of\n                            None \\<Rightarrow>\n                              ((Fault, const_converter Fault), snd x)\n                            | Some p \\<Rightarrow>\n                                ((OK (fst p), obsf_converter (snd p)),\n                                 snd x))))\n              (\\<lambda>x. x)\n              (inline run_converter\n                (map_gpv' id id option_of_exception\n                  (gpv_stop (run_converter conv1 q)))\n                (obsf_converter conv2))) \\<Longrightarrow>\n    Done (Fault, const_converter Fault) =\n    Done (Fault, const_converter Fault)", "apply(subst map_gpv'_map_gpv_swap)"], ["proof (prove)\ngoal (2 subgoals):\n 1. map_gpv (\\<lambda>p. (fst (fst p), snd (fst p) \\<odot> snd p)) id\n     (inline run_converter\n       (map_gpv\n         (id \\<circ>\n          case_option (Fault, const_converter Fault)\n           (\\<lambda>p. (OK (fst p), obsf_converter (snd p))))\n         id (map_gpv' id id option_of_exception\n              (gpv_stop (run_converter conv1 q))))\n       (obsf_converter conv2)) =\n    map_gpv\n     (\\<lambda>x.\n         case fst x of None \\<Rightarrow> (Fault, const_converter Fault)\n         | Some xa \\<Rightarrow>\n             (case fst x of None \\<Rightarrow> Fault\n              | Some x \\<Rightarrow> OK (fst x),\n              snd (case fst x of\n                   None \\<Rightarrow> (Fault, const_converter Fault)\n                   | Some x \\<Rightarrow>\n                       (OK (fst x), obsf_converter (snd x))) \\<odot>\n              snd (case fst x of\n                   None \\<Rightarrow>\n                     ((Fault, const_converter Fault), snd x)\n                   | Some p \\<Rightarrow>\n                       ((OK (fst p), obsf_converter (snd p)), snd x))))\n     (\\<lambda>x. x)\n     (inline run_converter\n       (map_gpv' id id option_of_exception\n         (gpv_stop (run_converter conv1 q)))\n       (obsf_converter conv2))\n 2. \\<not> colossless_gpv \\<I>_full\n            (map_gpv\n              (\\<lambda>x.\n                  case fst x of\n                  None \\<Rightarrow> (Fault, const_converter Fault)\n                  | Some xa \\<Rightarrow>\n                      (case fst x of None \\<Rightarrow> Fault\n                       | Some x \\<Rightarrow> OK (fst x),\n                       snd (case fst x of\n                            None \\<Rightarrow>\n                              (Fault, const_converter Fault)\n                            | Some x \\<Rightarrow>\n                                (OK (fst x),\n                                 obsf_converter (snd x))) \\<odot>\n                       snd (case fst x of\n                            None \\<Rightarrow>\n                              ((Fault, const_converter Fault), snd x)\n                            | Some p \\<Rightarrow>\n                                ((OK (fst p), obsf_converter (snd p)),\n                                 snd x))))\n              (\\<lambda>x. x)\n              (inline run_converter\n                (map_gpv' id id option_of_exception\n                  (gpv_stop (run_converter conv1 q)))\n                (obsf_converter conv2))) \\<Longrightarrow>\n    Done (Fault, const_converter Fault) =\n    Done (Fault, const_converter Fault)", "apply(simp add: inline_map_gpv gpv.map_comp id_def[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. map_gpv\n     ((\\<lambda>p. (fst (fst p), snd (fst p) \\<odot> snd p)) \\<circ>\n      apfst\n       (case_option (Fault, const_converter Fault)\n         (\\<lambda>p. (OK (fst p), obsf_converter (snd p)))))\n     id (inline run_converter\n          (map_gpv' id id option_of_exception\n            (gpv_stop (run_converter conv1 q)))\n          (obsf_converter conv2)) =\n    map_gpv\n     (\\<lambda>x.\n         case fst x of None \\<Rightarrow> (Fault, const_converter Fault)\n         | Some xa \\<Rightarrow>\n             (case fst x of None \\<Rightarrow> Fault\n              | Some x \\<Rightarrow> OK (fst x),\n              snd (case fst x of\n                   None \\<Rightarrow> (Fault, const_converter Fault)\n                   | Some x \\<Rightarrow>\n                       (OK (fst x), obsf_converter (snd x))) \\<odot>\n              snd (case fst x of\n                   None \\<Rightarrow>\n                     ((Fault, const_converter Fault), snd x)\n                   | Some p \\<Rightarrow>\n                       ((OK (fst p), obsf_converter (snd p)), snd x))))\n     id (inline run_converter\n          (map_gpv' id id option_of_exception\n            (gpv_stop (run_converter conv1 q)))\n          (obsf_converter conv2))\n 2. \\<not> colossless_gpv \\<I>_full\n            (map_gpv\n              (\\<lambda>x.\n                  case fst x of\n                  None \\<Rightarrow> (Fault, const_converter Fault)\n                  | Some xa \\<Rightarrow>\n                      (case fst x of None \\<Rightarrow> Fault\n                       | Some x \\<Rightarrow> OK (fst x),\n                       snd (case fst x of\n                            None \\<Rightarrow>\n                              (Fault, const_converter Fault)\n                            | Some x \\<Rightarrow>\n                                (OK (fst x),\n                                 obsf_converter (snd x))) \\<odot>\n                       snd (case fst x of\n                            None \\<Rightarrow>\n                              ((Fault, const_converter Fault), snd x)\n                            | Some p \\<Rightarrow>\n                                ((OK (fst p), obsf_converter (snd p)),\n                                 snd x))))\n              (\\<lambda>x. x)\n              (inline run_converter\n                (map_gpv' id id option_of_exception\n                  (gpv_stop (run_converter conv1 q)))\n                (obsf_converter conv2))) \\<Longrightarrow>\n    Done (Fault, const_converter Fault) =\n    Done (Fault, const_converter Fault)", "apply(rule gpv.map_cong[OF refl])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>z1.\n       z1 \\<in> results'_gpv\n                 (inline run_converter\n                   (map_gpv' id id option_of_exception\n                     (gpv_stop (run_converter conv1 q)))\n                   (obsf_converter conv2)) \\<Longrightarrow>\n       ((\\<lambda>p. (fst (fst p), snd (fst p) \\<odot> snd p)) \\<circ>\n        apfst\n         (case_option (Fault, const_converter Fault)\n           (\\<lambda>p. (OK (fst p), obsf_converter (snd p)))))\n        z1 =\n       (case fst z1 of None \\<Rightarrow> (Fault, const_converter Fault)\n        | Some x \\<Rightarrow>\n            (case fst z1 of None \\<Rightarrow> Fault\n             | Some x \\<Rightarrow> OK (fst x),\n             snd (case fst z1 of\n                  None \\<Rightarrow> (Fault, const_converter Fault)\n                  | Some x \\<Rightarrow>\n                      (OK (fst x), obsf_converter (snd x))) \\<odot>\n             snd (case fst z1 of\n                  None \\<Rightarrow>\n                    ((Fault, const_converter Fault), snd z1)\n                  | Some p \\<Rightarrow>\n                      ((OK (fst p), obsf_converter (snd p)), snd z1))))\n 2. \\<And>z2.\n       z2 \\<in> outs'_gpv\n                 (inline run_converter\n                   (map_gpv' id id option_of_exception\n                     (gpv_stop (run_converter conv1 q)))\n                   (obsf_converter conv2)) \\<Longrightarrow>\n       id z2 = id z2\n 3. \\<not> colossless_gpv \\<I>_full\n            (map_gpv\n              (\\<lambda>x.\n                  case fst x of\n                  None \\<Rightarrow> (Fault, const_converter Fault)\n                  | Some xa \\<Rightarrow>\n                      (case fst x of None \\<Rightarrow> Fault\n                       | Some x \\<Rightarrow> OK (fst x),\n                       snd (case fst x of\n                            None \\<Rightarrow>\n                              (Fault, const_converter Fault)\n                            | Some x \\<Rightarrow>\n                                (OK (fst x),\n                                 obsf_converter (snd x))) \\<odot>\n                       snd (case fst x of\n                            None \\<Rightarrow>\n                              ((Fault, const_converter Fault), snd x)\n                            | Some p \\<Rightarrow>\n                                ((OK (fst p), obsf_converter (snd p)),\n                                 snd x))))\n              (\\<lambda>x. x)\n              (inline run_converter\n                (map_gpv' id id option_of_exception\n                  (gpv_stop (run_converter conv1 q)))\n                (obsf_converter conv2))) \\<Longrightarrow>\n    Done (Fault, const_converter Fault) =\n    Done (Fault, const_converter Fault)", "apply(auto split: option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  TRY map_gpv (\\<lambda>((b, conv1'), conv2'). (b, conv1' \\<odot> conv2'))\n       id (inline run_converter\n            (map_gpv'\n              (case_option (Fault, const_converter Fault)\n                (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n              id option_of_exception (gpv_stop (run_converter conv1 q)))\n            (obsf_converter\n              conv2)) ELSE Done (Fault, const_converter Fault) =\n  TRY map_gpv (\\<lambda>((b, conv1'), conv2'). (b, conv1' \\<odot> conv2'))\n       id (map_gpv\n            (\\<lambda>(xo, conv').\n                case xo of\n                None \\<Rightarrow> ((Fault, const_converter Fault), conv')\n                | Some (x, conv) \\<Rightarrow>\n                    ((OK x, obsf_converter conv), conv'))\n            id (bind_gpv\n                 (inline run_converter\n                   (map_gpv' id id option_of_exception\n                     (gpv_stop (run_converter conv1 q)))\n                   (obsf_converter conv2))\n                 (\\<lambda>(x, conv').\n                     case x of None \\<Rightarrow> Fail\n                     | Some x' \\<Rightarrow>\n                         Done\n                          (x, conv')))) ELSE Done\n        (Fault, const_converter Fault)\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv\n     (rel_prod\n       (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> (exception_\\<I> \\<I>) q))\n       (\\<lambda>conv conv'.\n           (\\<exists>conv1 conv2.\n               conv = obsf_converter (conv1 \\<odot> conv2) \\<and>\n               conv' =\n               obsf_converter conv1 \\<odot> obsf_converter conv2 \\<and>\n               \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and>\n               \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd> \\<and>\n               pfinite_converter \\<I> \\<I>' conv1) \\<or>\n           exception_\\<I> \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n           conv \\<sim> conv'))\n     (exception_\\<I> \\<I>'')\n     (run_converter (obsf_converter (conv1 \\<odot> conv2)) q)\n     (run_converter (obsf_converter conv1 \\<odot> obsf_converter conv2) q)", "also"], ["proof (state)\nthis:\n  TRY map_gpv (\\<lambda>((b, conv1'), conv2'). (b, conv1' \\<odot> conv2'))\n       id (inline run_converter\n            (map_gpv'\n              (case_option (Fault, const_converter Fault)\n                (\\<lambda>(x, conv'). (OK x, obsf_converter conv')))\n              id option_of_exception (gpv_stop (run_converter conv1 q)))\n            (obsf_converter\n              conv2)) ELSE Done (Fault, const_converter Fault) =\n  TRY map_gpv (\\<lambda>((b, conv1'), conv2'). (b, conv1' \\<odot> conv2'))\n       id (map_gpv\n            (\\<lambda>(xo, conv').\n                case xo of\n                None \\<Rightarrow> ((Fault, const_converter Fault), conv')\n                | Some (x, conv) \\<Rightarrow>\n                    ((OK x, obsf_converter conv), conv'))\n            id (bind_gpv\n                 (inline run_converter\n                   (map_gpv' id id option_of_exception\n                     (gpv_stop (run_converter conv1 q)))\n                   (obsf_converter conv2))\n                 (\\<lambda>(x, conv').\n                     case x of None \\<Rightarrow> Fail\n                     | Some x' \\<Rightarrow>\n                         Done\n                          (x, conv')))) ELSE Done\n        (Fault, const_converter Fault)\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv\n     (rel_prod\n       (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> (exception_\\<I> \\<I>) q))\n       (\\<lambda>conv conv'.\n           (\\<exists>conv1 conv2.\n               conv = obsf_converter (conv1 \\<odot> conv2) \\<and>\n               conv' =\n               obsf_converter conv1 \\<odot> obsf_converter conv2 \\<and>\n               \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and>\n               \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd> \\<and>\n               pfinite_converter \\<I> \\<I>' conv1) \\<or>\n           exception_\\<I> \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n           conv \\<sim> conv'))\n     (exception_\\<I> \\<I>'')\n     (run_converter (obsf_converter (conv1 \\<odot> conv2)) q)\n     (run_converter (obsf_converter conv1 \\<odot> obsf_converter conv2) q)", "have \"\\<dots> = try_gpv (map_gpv ?f id\n       (map_gpv (\\<lambda>(xo, conv'). case xo of None \\<Rightarrow> ((Fault, const_converter Fault), conv') | Some (x, conv) \\<Rightarrow> ((OK x, obsf_converter conv), conv')) id \n(bind_gpv\n                (map_gpv' id id option_of_exception\n                  (gpv_stop (inline run_converter (run_converter conv1 q) conv2)))\n                (case_option Fail\n                  (\\<lambda>(x', conv).\n                      Done\n                       (Some x',\n                        obsf_converter\n                         conv)))))) ?else\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY map_gpv (\\<lambda>((b, conv1'), conv2'). (b, conv1' \\<odot> conv2'))\n         id (map_gpv\n              (\\<lambda>(xo, conv').\n                  case xo of\n                  None \\<Rightarrow> ((Fault, const_converter Fault), conv')\n                  | Some (x, conv) \\<Rightarrow>\n                      ((OK x, obsf_converter conv), conv'))\n              id (bind_gpv\n                   (inline run_converter\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop (run_converter conv1 q)))\n                     (obsf_converter conv2))\n                   (\\<lambda>(x, conv').\n                       case x of None \\<Rightarrow> Fail\n                       | Some x' \\<Rightarrow>\n                           Done\n                            (x, conv')))) ELSE Done\n          (Fault, const_converter Fault) =\n    TRY map_gpv (\\<lambda>((b, conv1'), conv2'). (b, conv1' \\<odot> conv2'))\n         id (map_gpv\n              (\\<lambda>(xo, conv').\n                  case xo of\n                  None \\<Rightarrow> ((Fault, const_converter Fault), conv')\n                  | Some (x, conv) \\<Rightarrow>\n                      ((OK x, obsf_converter conv), conv'))\n              id (bind_gpv\n                   (map_gpv' id id option_of_exception\n                     (gpv_stop\n                       (inline run_converter (run_converter conv1 q)\n                         conv2)))\n                   (case_option Fail\n                     (\\<lambda>(x', conv).\n                         Done\n                          (Some x',\n                           obsf_converter\n                            conv))))) ELSE Done\n      (Fault, const_converter Fault)", "by(simp only: inline_gpv_stop_obsf_converter)"], ["proof (state)\nthis:\n  TRY map_gpv (\\<lambda>((b, conv1'), conv2'). (b, conv1' \\<odot> conv2'))\n       id (map_gpv\n            (\\<lambda>(xo, conv').\n                case xo of\n                None \\<Rightarrow> ((Fault, const_converter Fault), conv')\n                | Some (x, conv) \\<Rightarrow>\n                    ((OK x, obsf_converter conv), conv'))\n            id (bind_gpv\n                 (inline run_converter\n                   (map_gpv' id id option_of_exception\n                     (gpv_stop (run_converter conv1 q)))\n                   (obsf_converter conv2))\n                 (\\<lambda>(x, conv').\n                     case x of None \\<Rightarrow> Fail\n                     | Some x' \\<Rightarrow>\n                         Done\n                          (x, conv')))) ELSE Done\n        (Fault, const_converter Fault) =\n  TRY map_gpv (\\<lambda>((b, conv1'), conv2'). (b, conv1' \\<odot> conv2'))\n       id (map_gpv\n            (\\<lambda>(xo, conv').\n                case xo of\n                None \\<Rightarrow> ((Fault, const_converter Fault), conv')\n                | Some (x, conv) \\<Rightarrow>\n                    ((OK x, obsf_converter conv), conv'))\n            id (bind_gpv\n                 (map_gpv' id id option_of_exception\n                   (gpv_stop\n                     (inline run_converter (run_converter conv1 q) conv2)))\n                 (case_option Fail\n                   (\\<lambda>(x', conv).\n                       Done\n                        (Some x',\n                         obsf_converter\n                          conv))))) ELSE Done (Fault, const_converter Fault)\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv\n     (rel_prod\n       (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> (exception_\\<I> \\<I>) q))\n       (\\<lambda>conv conv'.\n           (\\<exists>conv1 conv2.\n               conv = obsf_converter (conv1 \\<odot> conv2) \\<and>\n               conv' =\n               obsf_converter conv1 \\<odot> obsf_converter conv2 \\<and>\n               \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and>\n               \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd> \\<and>\n               pfinite_converter \\<I> \\<I>' conv1) \\<or>\n           exception_\\<I> \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n           conv \\<sim> conv'))\n     (exception_\\<I> \\<I>'')\n     (run_converter (obsf_converter (conv1 \\<odot> conv2)) q)\n     (run_converter (obsf_converter conv1 \\<odot> obsf_converter conv2) q)", "also"], ["proof (state)\nthis:\n  TRY map_gpv (\\<lambda>((b, conv1'), conv2'). (b, conv1' \\<odot> conv2'))\n       id (map_gpv\n            (\\<lambda>(xo, conv').\n                case xo of\n                None \\<Rightarrow> ((Fault, const_converter Fault), conv')\n                | Some (x, conv) \\<Rightarrow>\n                    ((OK x, obsf_converter conv), conv'))\n            id (bind_gpv\n                 (inline run_converter\n                   (map_gpv' id id option_of_exception\n                     (gpv_stop (run_converter conv1 q)))\n                   (obsf_converter conv2))\n                 (\\<lambda>(x, conv').\n                     case x of None \\<Rightarrow> Fail\n                     | Some x' \\<Rightarrow>\n                         Done\n                          (x, conv')))) ELSE Done\n        (Fault, const_converter Fault) =\n  TRY map_gpv (\\<lambda>((b, conv1'), conv2'). (b, conv1' \\<odot> conv2'))\n       id (map_gpv\n            (\\<lambda>(xo, conv').\n                case xo of\n                None \\<Rightarrow> ((Fault, const_converter Fault), conv')\n                | Some (x, conv) \\<Rightarrow>\n                    ((OK x, obsf_converter conv), conv'))\n            id (bind_gpv\n                 (map_gpv' id id option_of_exception\n                   (gpv_stop\n                     (inline run_converter (run_converter conv1 q) conv2)))\n                 (case_option Fail\n                   (\\<lambda>(x', conv).\n                       Done\n                        (Some x',\n                         obsf_converter\n                          conv))))) ELSE Done (Fault, const_converter Fault)\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv\n     (rel_prod\n       (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> (exception_\\<I> \\<I>) q))\n       (\\<lambda>conv conv'.\n           (\\<exists>conv1 conv2.\n               conv = obsf_converter (conv1 \\<odot> conv2) \\<and>\n               conv' =\n               obsf_converter conv1 \\<odot> obsf_converter conv2 \\<and>\n               \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and>\n               \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd> \\<and>\n               pfinite_converter \\<I> \\<I>' conv1) \\<or>\n           exception_\\<I> \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n           conv \\<sim> conv'))\n     (exception_\\<I> \\<I>'')\n     (run_converter (obsf_converter (conv1 \\<odot> conv2)) q)\n     (run_converter (obsf_converter conv1 \\<odot> obsf_converter conv2) q)", "have \"eq_\\<I>_gpv ?X (exception_\\<I> \\<I>'') ?lhs \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv\n     (rel_prod\n       (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> (exception_\\<I> \\<I>) q))\n       (\\<lambda>conv conv'.\n           (\\<exists>conv1 conv2.\n               conv = obsf_converter (conv1 \\<odot> conv2) \\<and>\n               conv' =\n               obsf_converter conv1 \\<odot> obsf_converter conv2 \\<and>\n               \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and>\n               \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd> \\<and>\n               pfinite_converter \\<I> \\<I>' conv1) \\<or>\n           exception_\\<I> \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n           conv \\<sim> conv'))\n     (exception_\\<I> \\<I>'')\n     (run_converter (obsf_converter (conv1 \\<odot> conv2)) q)\n     (TRY map_gpv\n           (\\<lambda>((b, conv1'), conv2'). (b, conv1' \\<odot> conv2')) id\n           (map_gpv\n             (\\<lambda>(xo, conv').\n                 case xo of\n                 None \\<Rightarrow> ((Fault, const_converter Fault), conv')\n                 | Some (x, conv) \\<Rightarrow>\n                     ((OK x, obsf_converter conv), conv'))\n             id (bind_gpv\n                  (map_gpv' id id option_of_exception\n                    (gpv_stop\n                      (inline run_converter (run_converter conv1 q) conv2)))\n                  (case_option Fail\n                    (\\<lambda>(x', conv).\n                        Done\n                         (Some x',\n                          obsf_converter\n                           conv))))) ELSE Done\n     (Fault, const_converter Fault))", "using eq_\\<I>_converter"], ["proof (prove)\nusing this:\n  \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>\n  \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>\n  pfinite_converter \\<I> \\<I>' conv1\n  q \\<in> outs_\\<I> (exception_\\<I> \\<I>)\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv\n     (rel_prod\n       (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> (exception_\\<I> \\<I>) q))\n       (\\<lambda>conv conv'.\n           (\\<exists>conv1 conv2.\n               conv = obsf_converter (conv1 \\<odot> conv2) \\<and>\n               conv' =\n               obsf_converter conv1 \\<odot> obsf_converter conv2 \\<and>\n               \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and>\n               \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd> \\<and>\n               pfinite_converter \\<I> \\<I>' conv1) \\<or>\n           exception_\\<I> \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n           conv \\<sim> conv'))\n     (exception_\\<I> \\<I>'')\n     (run_converter (obsf_converter (conv1 \\<odot> conv2)) q)\n     (TRY map_gpv\n           (\\<lambda>((b, conv1'), conv2'). (b, conv1' \\<odot> conv2')) id\n           (map_gpv\n             (\\<lambda>(xo, conv').\n                 case xo of\n                 None \\<Rightarrow> ((Fault, const_converter Fault), conv')\n                 | Some (x, conv) \\<Rightarrow>\n                     ((OK x, obsf_converter conv), conv'))\n             id (bind_gpv\n                  (map_gpv' id id option_of_exception\n                    (gpv_stop\n                      (inline run_converter (run_converter conv1 q) conv2)))\n                  (case_option Fail\n                    (\\<lambda>(x', conv).\n                        Done\n                         (Some x',\n                          obsf_converter\n                           conv))))) ELSE Done\n     (Fault, const_converter Fault))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (TRY map_gpv'\n                             (\\<lambda>y.\n                                 case y of\n                                 None \\<Rightarrow>\n                                   (Fault, const_converter Fault)\n                                 | Some (x, conv') \\<Rightarrow>\n                                     (OK x, obsf_converter conv'))\n                             id option_of_exception\n                             (gpv_stop\n                               (map_gpv\n                                 (\\<lambda>((b, conv1'), conv2').\n                                     (b, conv1' \\<odot> conv2'))\n                                 id (inline run_converter\n(run_converter conv1 q) conv2))) ELSE Done (Fault, const_converter Fault))\n                       (TRY map_gpv\n                             (\\<lambda>((b, conv1'), conv2').\n                                 (b, conv1' \\<odot> conv2'))\n                             id (map_gpv\n                                  (\\<lambda>(xo, conv').\ncase xo of None \\<Rightarrow> ((Fault, const_converter Fault), conv')\n| Some (x, conv) \\<Rightarrow> ((OK x, obsf_converter conv), conv'))\n                                  id (bind_gpv\n (map_gpv' id id option_of_exception\n   (gpv_stop (inline run_converter (run_converter conv1 q) conv2)))\n (case_option Fail\n   (\\<lambda>(x', conv).\n       Done\n        (Some x',\n         obsf_converter conv))))) ELSE Done (Fault, const_converter Fault))", "apply(simp add: map_gpv_bind_gpv gpv.map_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (TRY map_gpv'\n                             (\\<lambda>y.\n                                 case y of\n                                 None \\<Rightarrow>\n                                   (Fault, const_converter Fault)\n                                 | Some (x, conv') \\<Rightarrow>\n                                     (OK x, obsf_converter conv'))\n                             id option_of_exception\n                             (gpv_stop\n                               (map_gpv\n                                 (\\<lambda>((b, conv1'), conv2').\n                                     (b, conv1' \\<odot> conv2'))\n                                 id (inline run_converter\n(run_converter conv1 q) conv2))) ELSE Done (Fault, const_converter Fault))\n                       (TRY bind_gpv\n                             (map_gpv' id id option_of_exception\n                               (gpv_stop\n                                 (inline run_converter\n                                   (run_converter conv1 q) conv2)))\n                             (\\<lambda>x.\n                                 map_gpv\n                                  (\\<lambda>((b, conv1'), conv2').\n(b, conv1' \\<odot> conv2'))\n                                  id (map_gpv\n (\\<lambda>(xo, conv').\n     case xo of None \\<Rightarrow> ((Fault, const_converter Fault), conv')\n     | Some (xa, conv) \\<Rightarrow> ((OK xa, obsf_converter conv), conv'))\n id (case x of None \\<Rightarrow> Fail\n     | Some (x', conv) \\<Rightarrow>\n         Done\n          (Some x',\n           obsf_converter conv)))) ELSE Done (Fault, const_converter Fault))", "apply(subst try_gpv_bind_gpv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (TRY map_gpv'\n                             (case_option (Fault, const_converter Fault)\n                               (\\<lambda>(x, conv').\n                                   (OK x, obsf_converter conv')))\n                             id option_of_exception\n                             (gpv_stop\n                               (map_gpv\n                                 (\\<lambda>((b, conv1'), conv2').\n                                     (b, conv1' \\<odot> conv2'))\n                                 id (inline run_converter\n(run_converter conv1 q) conv2))) ELSE Done (Fault, const_converter Fault))\n                       (bind_gpv\n                         (TRY map_gpv Some id\n                               (map_gpv' id id option_of_exception\n                                 (gpv_stop\n                                   (inline run_converter\n                                     (run_converter conv1 q)\n                                     conv2))) ELSE Done None)\n                         (case_option (Done (Fault, const_converter Fault))\n                           (\\<lambda>x'.\n                               TRY map_gpv\n                                    (\\<lambda>((b, conv1'), conv2').\n  (b, conv1' \\<odot> conv2'))\n                                    id (map_gpv\n   (\\<lambda>(xo, conv').\n       case xo of None \\<Rightarrow> ((Fault, const_converter Fault), conv')\n       | Some (xa, conv) \\<Rightarrow>\n           ((OK xa, obsf_converter conv), conv'))\n   id (case x' of None \\<Rightarrow> Fail\n       | Some (x', conv) \\<Rightarrow>\n           Done\n            (Some x',\n             obsf_converter\n              conv))) ELSE Done (Fault, const_converter Fault))))", "apply(simp add: split_def option.case_distrib[where h=\"map_gpv _ _\"] option.case_distrib[where h=\"fst\"] option.case_distrib[where h=\"\\<lambda>x. try_gpv x _\"] cong del: option.case_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (TRY map_gpv'\n                             (case_option (Fault, const_converter Fault)\n                               (\\<lambda>p.\n                                   (OK (fst p), obsf_converter (snd p))))\n                             id option_of_exception\n                             (gpv_stop\n                               (map_gpv\n                                 (\\<lambda>p.\n                                     (fst (fst p),\nsnd (fst p) \\<odot> snd p))\n                                 id (inline run_converter\n(run_converter conv1 q) conv2))) ELSE Done (Fault, const_converter Fault))\n                       (bind_gpv\n                         (TRY map_gpv Some id\n                               (map_gpv' id id option_of_exception\n                                 (gpv_stop\n                                   (inline run_converter\n                                     (run_converter conv1 q)\n                                     conv2))) ELSE Done None)\n                         (case_option (Done (Fault, const_converter Fault))\n                           (\\<lambda>x'.\n                               case x' of\n                               None \\<Rightarrow>\n                                 Done (Fault, const_converter Fault)\n                               | Some x \\<Rightarrow>\n                                   Done\n                                    (OK (fst (fst x)),\n                                     obsf_converter (snd (fst x)) \\<odot>\n                                     obsf_converter (snd x)))))", "apply(subst option.case_distrib[where h=Done, symmetric, abs_def])+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (TRY map_gpv'\n                             (case_option (Fault, const_converter Fault)\n                               (\\<lambda>p.\n                                   (OK (fst p), obsf_converter (snd p))))\n                             id option_of_exception\n                             (gpv_stop\n                               (map_gpv\n                                 (\\<lambda>p.\n                                     (fst (fst p),\nsnd (fst p) \\<odot> snd p))\n                                 id (inline run_converter\n(run_converter conv1 q) conv2))) ELSE Done (Fault, const_converter Fault))\n                       (bind_gpv\n                         (TRY map_gpv Some id\n                               (map_gpv' id id option_of_exception\n                                 (gpv_stop\n                                   (inline run_converter\n                                     (run_converter conv1 q)\n                                     conv2))) ELSE Done None)\n                         (\\<lambda>option.\n                             Done\n                              (case option of\n                               None \\<Rightarrow>\n                                 (Fault, const_converter Fault)\n                               | Some None \\<Rightarrow>\n                                   (Fault, const_converter Fault)\n                               | Some (Some xa) \\<Rightarrow>\n                                   (OK (fst (fst xa)),\n                                    obsf_converter (snd (fst xa)) \\<odot>\n                                    obsf_converter (snd xa)))))", "apply(fold map_gpv_conv_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (TRY map_gpv'\n                             (case_option (Fault, const_converter Fault)\n                               (\\<lambda>p.\n                                   (OK (fst p), obsf_converter (snd p))))\n                             id option_of_exception\n                             (gpv_stop\n                               (map_gpv\n                                 (\\<lambda>p.\n                                     (fst (fst p),\nsnd (fst p) \\<odot> snd p))\n                                 id (inline run_converter\n(run_converter conv1 q) conv2))) ELSE Done (Fault, const_converter Fault))\n                       (map_gpv\n                         (\\<lambda>option.\n                             case option of\n                             None \\<Rightarrow>\n                               (Fault, const_converter Fault)\n                             | Some None \\<Rightarrow>\n                                 (Fault, const_converter Fault)\n                             | Some (Some xa) \\<Rightarrow>\n                                 (OK (fst (fst xa)),\n                                  obsf_converter (snd (fst xa)) \\<odot>\n                                  obsf_converter (snd xa)))\n                         (\\<lambda>option. option)\n                         (TRY map_gpv Some id\n                               (map_gpv' id id option_of_exception\n                                 (gpv_stop\n                                   (inline run_converter\n                                     (run_converter conv1 q)\n                                     conv2))) ELSE Done None))", "apply(simp add: map_try_gpv gpv.map_comp o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (TRY map_gpv'\n                             (case_option (Fault, const_converter Fault)\n                               (\\<lambda>p.\n                                   (OK (fst p), obsf_converter (snd p))))\n                             id option_of_exception\n                             (gpv_stop\n                               (map_gpv\n                                 (\\<lambda>p.\n                                     (fst (fst p),\nsnd (fst p) \\<odot> snd p))\n                                 id (inline run_converter\n(run_converter conv1 q) conv2))) ELSE Done (Fault, const_converter Fault))\n                       (TRY map_gpv\n                             (\\<lambda>x.\n                                 case x of\n                                 None \\<Rightarrow>\n                                   (Fault, const_converter Fault)\n                                 | Some x \\<Rightarrow>\n                                     (OK (fst (fst x)),\nobsf_converter (snd (fst x)) \\<odot> obsf_converter (snd x)))\n                             (\\<lambda>x. x)\n                             (map_gpv' id id option_of_exception\n                               (gpv_stop\n                                 (inline run_converter\n                                   (run_converter conv1 q)\n                                   conv2))) ELSE Done\n            (Fault, const_converter Fault))", "apply(rule eq_\\<I>_gpv_try_gpv_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (map_gpv'\n                         (case_option (Fault, const_converter Fault)\n                           (\\<lambda>p.\n                               (OK (fst p), obsf_converter (snd p))))\n                         id option_of_exception\n                         (gpv_stop\n                           (map_gpv\n                             (\\<lambda>p.\n                                 (fst (fst p), snd (fst p) \\<odot> snd p))\n                             id (inline run_converter\n                                  (run_converter conv1 q) conv2))))\n                       (map_gpv\n                         (\\<lambda>x.\n                             case x of\n                             None \\<Rightarrow>\n                               (Fault, const_converter Fault)\n                             | Some x \\<Rightarrow>\n                                 (OK (fst (fst x)),\n                                  obsf_converter (snd (fst x)) \\<odot>\n                                  obsf_converter (snd x)))\n                         (\\<lambda>x. x)\n                         (map_gpv' id id option_of_exception\n                           (gpv_stop\n                             (inline run_converter (run_converter conv1 q)\n                               conv2))))\n 2. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(subst map_gpv'_id12)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (map_gpv' id id option_of_exception\n                         (map_gpv\n                           (case_option (Fault, const_converter Fault)\n                             (\\<lambda>p.\n                                 (OK (fst p), obsf_converter (snd p))))\n                           id (gpv_stop\n                                (map_gpv\n                                  (\\<lambda>p.\n(fst (fst p), snd (fst p) \\<odot> snd p))\n                                  id (inline run_converter\n (run_converter conv1 q) conv2)))))\n                       (map_gpv\n                         (case_option (Fault, const_converter Fault)\n                           (\\<lambda>x.\n                               (OK (fst (fst x)),\n                                obsf_converter (snd (fst x)) \\<odot>\n                                obsf_converter (snd x))))\n                         (\\<lambda>x. x)\n                         (map_gpv' id id option_of_exception\n                           (gpv_stop\n                             (inline run_converter (run_converter conv1 q)\n                               conv2))))\n 2. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(subst map_gpv'_map_gpv_swap)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (map_gpv\n                         (id \\<circ>\n                          case_option (Fault, const_converter Fault)\n                           (\\<lambda>p.\n                               (OK (fst p), obsf_converter (snd p))))\n                         id (map_gpv' id id option_of_exception\n                              (gpv_stop\n                                (map_gpv\n                                  (\\<lambda>p.\n(fst (fst p), snd (fst p) \\<odot> snd p))\n                                  id (inline run_converter\n (run_converter conv1 q) conv2)))))\n                       (map_gpv\n                         (case_option (Fault, const_converter Fault)\n                           (\\<lambda>x.\n                               (OK (fst (fst x)),\n                                obsf_converter (snd (fst x)) \\<odot>\n                                obsf_converter (snd x))))\n                         (\\<lambda>x. x)\n                         (map_gpv' id id option_of_exception\n                           (gpv_stop\n                             (inline run_converter (run_converter conv1 q)\n                               conv2))))\n 2. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(simp add: eq_\\<I>_gpv_map_gpv id_def[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (\\<lambda>x y.\n                           rel_prod\n                            (eq_onp\n                              (\\<lambda>r.\n                                  r = Fault \\<or>\n                                  r \\<in> OK ` responses_\\<I> \\<I> q))\n                            (\\<lambda>conv conv'.\n                                (\\<exists>conv1 conv2.\n                                    conv =\n                                    obsf_converter\n                                     (conv1 \\<odot> conv2) \\<and>\n                                    conv' =\n                                    obsf_converter conv1 \\<odot>\n                                    obsf_converter conv2 \\<and>\n                                    \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                    conv1 \\<surd> \\<and>\n                                    \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                    conv2 \\<surd> \\<and>\n                                    pfinite_converter \\<I> \\<I>'\n                                     conv1) \\<or>\n                                exception_\\<I>\n                                 \\<I>,exception_\\<I>\n \\<I>'' \\<turnstile>\\<^sub>C\n                                conv \\<sim> conv')\n                            (case x of\n                             None \\<Rightarrow>\n                               (Fault, const_converter Fault)\n                             | Some p \\<Rightarrow>\n                                 (OK (fst p), obsf_converter (snd p)))\n                            (case y of\n                             None \\<Rightarrow>\n                               (Fault, const_converter Fault)\n                             | Some x \\<Rightarrow>\n                                 (OK (fst (fst x)),\n                                  obsf_converter (snd (fst x)) \\<odot>\n                                  obsf_converter (snd x))))\n                       (exception_\\<I> \\<I>'')\n                       (map_gpv' id id option_of_exception\n                         (gpv_stop\n                           (map_gpv\n                             (\\<lambda>p.\n                                 (fst (fst p), snd (fst p) \\<odot> snd p))\n                             id (inline run_converter\n                                  (run_converter conv1 q) conv2))))\n                       (map_gpv' id id option_of_exception\n                         (gpv_stop\n                           (inline run_converter (run_converter conv1 q)\n                             conv2)))\n 2. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(subst map_gpv_conv_map_gpv')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (\\<lambda>x y.\n                           rel_prod\n                            (eq_onp\n                              (\\<lambda>r.\n                                  r = Fault \\<or>\n                                  r \\<in> OK ` responses_\\<I> \\<I> q))\n                            (\\<lambda>conv conv'.\n                                (\\<exists>conv1 conv2.\n                                    conv =\n                                    obsf_converter\n                                     (conv1 \\<odot> conv2) \\<and>\n                                    conv' =\n                                    obsf_converter conv1 \\<odot>\n                                    obsf_converter conv2 \\<and>\n                                    \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                    conv1 \\<surd> \\<and>\n                                    \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                    conv2 \\<surd> \\<and>\n                                    pfinite_converter \\<I> \\<I>'\n                                     conv1) \\<or>\n                                exception_\\<I>\n                                 \\<I>,exception_\\<I>\n \\<I>'' \\<turnstile>\\<^sub>C\n                                conv \\<sim> conv')\n                            (case x of\n                             None \\<Rightarrow>\n                               (Fault, const_converter Fault)\n                             | Some p \\<Rightarrow>\n                                 (OK (fst p), obsf_converter (snd p)))\n                            (case y of\n                             None \\<Rightarrow>\n                               (Fault, const_converter Fault)\n                             | Some x \\<Rightarrow>\n                                 (OK (fst (fst x)),\n                                  obsf_converter (snd (fst x)) \\<odot>\n                                  obsf_converter (snd x))))\n                       (exception_\\<I> \\<I>'')\n                       (map_gpv' id id option_of_exception\n                         (gpv_stop\n                           (map_gpv'\n                             (\\<lambda>p.\n                                 (fst (fst p), snd (fst p) \\<odot> snd p))\n                             id id\n                             (inline run_converter (run_converter conv1 q)\n                               conv2))))\n                       (map_gpv' id id option_of_exception\n                         (gpv_stop\n                           (inline run_converter (run_converter conv1 q)\n                             conv2)))\n 2. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(subst gpv_stop_map')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (\\<lambda>x y.\n                           rel_prod\n                            (eq_onp\n                              (\\<lambda>r.\n                                  r = Fault \\<or>\n                                  r \\<in> OK ` responses_\\<I> \\<I> q))\n                            (\\<lambda>conv conv'.\n                                (\\<exists>conv1 conv2.\n                                    conv =\n                                    obsf_converter\n                                     (conv1 \\<odot> conv2) \\<and>\n                                    conv' =\n                                    obsf_converter conv1 \\<odot>\n                                    obsf_converter conv2 \\<and>\n                                    \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                    conv1 \\<surd> \\<and>\n                                    \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                    conv2 \\<surd> \\<and>\n                                    pfinite_converter \\<I> \\<I>'\n                                     conv1) \\<or>\n                                exception_\\<I>\n                                 \\<I>,exception_\\<I>\n \\<I>'' \\<turnstile>\\<^sub>C\n                                conv \\<sim> conv')\n                            (case x of\n                             None \\<Rightarrow>\n                               (Fault, const_converter Fault)\n                             | Some p \\<Rightarrow>\n                                 (OK (fst p), obsf_converter (snd p)))\n                            (case y of\n                             None \\<Rightarrow>\n                               (Fault, const_converter Fault)\n                             | Some x \\<Rightarrow>\n                                 (OK (fst (fst x)),\n                                  obsf_converter (snd (fst x)) \\<odot>\n                                  obsf_converter (snd x))))\n                       (exception_\\<I> \\<I>'')\n                       (map_gpv' id id option_of_exception\n                         (map_gpv'\n                           (map_option\n                             (\\<lambda>p.\n                                 (fst (fst p), snd (fst p) \\<odot> snd p)))\n                           id (map_option id)\n                           (gpv_stop\n                             (inline run_converter (run_converter conv1 q)\n                               conv2))))\n                       (map_gpv' id id option_of_exception\n                         (gpv_stop\n                           (inline run_converter (run_converter conv1 q)\n                             conv2)))\n 2. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(subst option.map_id0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (\\<lambda>x y.\n                           rel_prod\n                            (eq_onp\n                              (\\<lambda>r.\n                                  r = Fault \\<or>\n                                  r \\<in> OK ` responses_\\<I> \\<I> q))\n                            (\\<lambda>conv conv'.\n                                (\\<exists>conv1 conv2.\n                                    conv =\n                                    obsf_converter\n                                     (conv1 \\<odot> conv2) \\<and>\n                                    conv' =\n                                    obsf_converter conv1 \\<odot>\n                                    obsf_converter conv2 \\<and>\n                                    \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                    conv1 \\<surd> \\<and>\n                                    \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                    conv2 \\<surd> \\<and>\n                                    pfinite_converter \\<I> \\<I>'\n                                     conv1) \\<or>\n                                exception_\\<I>\n                                 \\<I>,exception_\\<I>\n \\<I>'' \\<turnstile>\\<^sub>C\n                                conv \\<sim> conv')\n                            (case x of\n                             None \\<Rightarrow>\n                               (Fault, const_converter Fault)\n                             | Some p \\<Rightarrow>\n                                 (OK (fst p), obsf_converter (snd p)))\n                            (case y of\n                             None \\<Rightarrow>\n                               (Fault, const_converter Fault)\n                             | Some x \\<Rightarrow>\n                                 (OK (fst (fst x)),\n                                  obsf_converter (snd (fst x)) \\<odot>\n                                  obsf_converter (snd x))))\n                       (exception_\\<I> \\<I>'')\n                       (map_gpv' id id option_of_exception\n                         (map_gpv'\n                           (map_option\n                             (\\<lambda>p.\n                                 (fst (fst p), snd (fst p) \\<odot> snd p)))\n                           id id\n                           (gpv_stop\n                             (inline run_converter (run_converter conv1 q)\n                               conv2))))\n                       (map_gpv' id id option_of_exception\n                         (gpv_stop\n                           (inline run_converter (run_converter conv1 q)\n                             conv2)))\n 2. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(subst map_gpv_conv_map_gpv'[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (\\<lambda>x y.\n                           rel_prod\n                            (eq_onp\n                              (\\<lambda>r.\n                                  r = Fault \\<or>\n                                  r \\<in> OK ` responses_\\<I> \\<I> q))\n                            (\\<lambda>conv conv'.\n                                (\\<exists>conv1 conv2.\n                                    conv =\n                                    obsf_converter\n                                     (conv1 \\<odot> conv2) \\<and>\n                                    conv' =\n                                    obsf_converter conv1 \\<odot>\n                                    obsf_converter conv2 \\<and>\n                                    \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                    conv1 \\<surd> \\<and>\n                                    \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                    conv2 \\<surd> \\<and>\n                                    pfinite_converter \\<I> \\<I>'\n                                     conv1) \\<or>\n                                exception_\\<I>\n                                 \\<I>,exception_\\<I>\n \\<I>'' \\<turnstile>\\<^sub>C\n                                conv \\<sim> conv')\n                            (case x of\n                             None \\<Rightarrow>\n                               (Fault, const_converter Fault)\n                             | Some p \\<Rightarrow>\n                                 (OK (fst p), obsf_converter (snd p)))\n                            (case y of\n                             None \\<Rightarrow>\n                               (Fault, const_converter Fault)\n                             | Some x \\<Rightarrow>\n                                 (OK (fst (fst x)),\n                                  obsf_converter (snd (fst x)) \\<odot>\n                                  obsf_converter (snd x))))\n                       (exception_\\<I> \\<I>'')\n                       (map_gpv' id id option_of_exception\n                         (map_gpv\n                           (map_option\n                             (\\<lambda>p.\n                                 (fst (fst p), snd (fst p) \\<odot> snd p)))\n                           id (gpv_stop\n                                (inline run_converter\n                                  (run_converter conv1 q) conv2))))\n                       (map_gpv' id id option_of_exception\n                         (gpv_stop\n                           (inline run_converter (run_converter conv1 q)\n                             conv2)))\n 2. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(subst map_gpv'_map_gpv_swap)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (\\<lambda>x y.\n                           rel_prod\n                            (eq_onp\n                              (\\<lambda>r.\n                                  r = Fault \\<or>\n                                  r \\<in> OK ` responses_\\<I> \\<I> q))\n                            (\\<lambda>conv conv'.\n                                (\\<exists>conv1 conv2.\n                                    conv =\n                                    obsf_converter\n                                     (conv1 \\<odot> conv2) \\<and>\n                                    conv' =\n                                    obsf_converter conv1 \\<odot>\n                                    obsf_converter conv2 \\<and>\n                                    \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                    conv1 \\<surd> \\<and>\n                                    \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                    conv2 \\<surd> \\<and>\n                                    pfinite_converter \\<I> \\<I>'\n                                     conv1) \\<or>\n                                exception_\\<I>\n                                 \\<I>,exception_\\<I>\n \\<I>'' \\<turnstile>\\<^sub>C\n                                conv \\<sim> conv')\n                            (case x of\n                             None \\<Rightarrow>\n                               (Fault, const_converter Fault)\n                             | Some p \\<Rightarrow>\n                                 (OK (fst p), obsf_converter (snd p)))\n                            (case y of\n                             None \\<Rightarrow>\n                               (Fault, const_converter Fault)\n                             | Some x \\<Rightarrow>\n                                 (OK (fst (fst x)),\n                                  obsf_converter (snd (fst x)) \\<odot>\n                                  obsf_converter (snd x))))\n                       (exception_\\<I> \\<I>'')\n                       (map_gpv\n                         (id \\<circ>\n                          map_option\n                           (\\<lambda>p.\n                               (fst (fst p), snd (fst p) \\<odot> snd p)))\n                         id (map_gpv' id id option_of_exception\n                              (gpv_stop\n                                (inline run_converter\n                                  (run_converter conv1 q) conv2))))\n                       (map_gpv' id id option_of_exception\n                         (gpv_stop\n                           (inline run_converter (run_converter conv1 q)\n                             conv2)))\n 2. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(simp add: eq_\\<I>_gpv_map_gpv id_def[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (\\<lambda>x y.\n                           rel_prod\n                            (eq_onp\n                              (\\<lambda>r.\n                                  r = Fault \\<or>\n                                  r \\<in> OK ` responses_\\<I> \\<I> q))\n                            (\\<lambda>conv conv'.\n                                (\\<exists>conv1 conv2.\n                                    conv =\n                                    obsf_converter\n                                     (conv1 \\<odot> conv2) \\<and>\n                                    conv' =\n                                    obsf_converter conv1 \\<odot>\n                                    obsf_converter conv2 \\<and>\n                                    \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                    conv1 \\<surd> \\<and>\n                                    \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                    conv2 \\<surd> \\<and>\n                                    pfinite_converter \\<I> \\<I>'\n                                     conv1) \\<or>\n                                exception_\\<I>\n                                 \\<I>,exception_\\<I>\n \\<I>'' \\<turnstile>\\<^sub>C\n                                conv \\<sim> conv')\n                            (case x of\n                             None \\<Rightarrow>\n                               (Fault, const_converter Fault)\n                             | Some x \\<Rightarrow>\n                                 ((\\<lambda>p.\n(OK (fst p), obsf_converter (snd p))) \\<circ>\n                                  (\\<lambda>p.\n(fst (fst p), snd (fst p) \\<odot> snd p)))\n                                  x)\n                            (case y of\n                             None \\<Rightarrow>\n                               (Fault, const_converter Fault)\n                             | Some x \\<Rightarrow>\n                                 (OK (fst (fst x)),\n                                  obsf_converter (snd (fst x)) \\<odot>\n                                  obsf_converter (snd x))))\n                       (exception_\\<I> \\<I>'')\n                       (map_gpv' id id option_of_exception\n                         (gpv_stop\n                           (inline run_converter (run_converter conv1 q)\n                             conv2)))\n                       (map_gpv' id id option_of_exception\n                         (gpv_stop\n                           (inline run_converter (run_converter conv1 q)\n                             conv2)))\n 2. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(rule eq_\\<I>_gpv_reflI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        x \\<in> results_gpv (exception_\\<I> \\<I>'')\n                 (map_gpv' id id option_of_exception\n                   (gpv_stop\n                     (inline run_converter (run_converter conv1 q)\n                       conv2)))\\<rbrakk>\n       \\<Longrightarrow> rel_prod\n                          (eq_onp\n                            (\\<lambda>r.\n                                r = Fault \\<or>\n                                r \\<in> OK ` responses_\\<I> \\<I> q))\n                          (\\<lambda>conv conv'.\n                              (\\<exists>conv1 conv2.\n                                  conv =\n                                  obsf_converter\n                                   (conv1 \\<odot> conv2) \\<and>\n                                  conv' =\n                                  obsf_converter conv1 \\<odot>\n                                  obsf_converter conv2 \\<and>\n                                  \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                  conv1 \\<surd> \\<and>\n                                  \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                  conv2 \\<surd> \\<and>\n                                  pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                              exception_\\<I>\n                               \\<I>,exception_\\<I>\n                                     \\<I>'' \\<turnstile>\\<^sub>C\n                              conv \\<sim> conv')\n                          (case x of\n                           None \\<Rightarrow> (Fault, const_converter Fault)\n                           | Some x \\<Rightarrow>\n                               ((\\<lambda>p.\n                                    (OK (fst p),\n                                     obsf_converter (snd p))) \\<circ>\n                                (\\<lambda>p.\n                                    (fst (fst p),\n                                     snd (fst p) \\<odot> snd p)))\n                                x)\n                          (case x of\n                           None \\<Rightarrow> (Fault, const_converter Fault)\n                           | Some x \\<Rightarrow>\n                               (OK (fst (fst x)),\n                                obsf_converter (snd (fst x)) \\<odot>\n                                obsf_converter (snd x)))\n 2. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 3. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(clarsimp split!: option.split simp add: eq_onp_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n     None\n     \\<in> results_gpv (stop_\\<I> \\<I>'')\n            (gpv_stop (inline run_converter (run_converter conv1 q) conv2));\n     \\<not> exception_\\<I> \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n     const_converter Fault \\<sim> const_converter Fault\\<rbrakk>\n    \\<Longrightarrow> \\<exists>conv1 conv2.\n                         const_converter Fault =\n                         obsf_converter (conv1 \\<odot> conv2) \\<and>\n                         const_converter Fault =\n                         obsf_converter conv1 \\<odot>\n                         obsf_converter conv2 \\<and>\n                         \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                         conv1 \\<surd> \\<and>\n                         \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                         conv2 \\<surd> \\<and>\n                         pfinite_converter \\<I> \\<I>' conv1\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        Some ((a, b), ba)\n        \\<in> results_gpv (stop_\\<I> \\<I>'')\n               (gpv_stop\n                 (inline run_converter (run_converter conv1 q)\n                   conv2))\\<rbrakk>\n       \\<Longrightarrow> OK a \\<in> OK ` responses_\\<I> \\<I> q \\<and>\n                         ((\\<exists>conv1 conv2.\n                              obsf_converter (b \\<odot> ba) =\n                              obsf_converter (conv1 \\<odot> conv2) \\<and>\n                              obsf_converter b \\<odot> obsf_converter ba =\n                              obsf_converter conv1 \\<odot>\n                              obsf_converter conv2 \\<and>\n                              \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                              conv1 \\<surd> \\<and>\n                              \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                              conv2 \\<surd> \\<and>\n                              pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                          exception_\\<I>\n                           \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n                          obsf_converter (b \\<odot> ba) \\<sim>\n                          obsf_converter b \\<odot> obsf_converter ba)\n 3. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 4. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(erule notE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n     None\n     \\<in> results_gpv (stop_\\<I> \\<I>'')\n            (gpv_stop\n              (inline run_converter (run_converter conv1 q) conv2))\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I>\n                       \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n                      const_converter Fault \\<sim> const_converter Fault\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        Some ((a, b), ba)\n        \\<in> results_gpv (stop_\\<I> \\<I>'')\n               (gpv_stop\n                 (inline run_converter (run_converter conv1 q)\n                   conv2))\\<rbrakk>\n       \\<Longrightarrow> OK a \\<in> OK ` responses_\\<I> \\<I> q \\<and>\n                         ((\\<exists>conv1 conv2.\n                              obsf_converter (b \\<odot> ba) =\n                              obsf_converter (conv1 \\<odot> conv2) \\<and>\n                              obsf_converter b \\<odot> obsf_converter ba =\n                              obsf_converter conv1 \\<odot>\n                              obsf_converter conv2 \\<and>\n                              \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                              conv1 \\<surd> \\<and>\n                              \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                              conv2 \\<surd> \\<and>\n                              pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                          exception_\\<I>\n                           \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n                          obsf_converter (b \\<odot> ba) \\<sim>\n                          obsf_converter b \\<odot> obsf_converter ba)\n 3. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 4. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(rule eq_\\<I>_converter_reflI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n     None\n     \\<in> results_gpv (stop_\\<I> \\<I>'')\n            (gpv_stop\n              (inline run_converter (run_converter conv1 q) conv2))\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>,\n                      exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n                      const_converter Fault \\<surd>\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        Some ((a, b), ba)\n        \\<in> results_gpv (stop_\\<I> \\<I>'')\n               (gpv_stop\n                 (inline run_converter (run_converter conv1 q)\n                   conv2))\\<rbrakk>\n       \\<Longrightarrow> OK a \\<in> OK ` responses_\\<I> \\<I> q \\<and>\n                         ((\\<exists>conv1 conv2.\n                              obsf_converter (b \\<odot> ba) =\n                              obsf_converter (conv1 \\<odot> conv2) \\<and>\n                              obsf_converter b \\<odot> obsf_converter ba =\n                              obsf_converter conv1 \\<odot>\n                              obsf_converter conv2 \\<and>\n                              \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                              conv1 \\<surd> \\<and>\n                              \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                              conv2 \\<surd> \\<and>\n                              pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                          exception_\\<I>\n                           \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n                          obsf_converter (b \\<odot> ba) \\<sim>\n                          obsf_converter b \\<odot> obsf_converter ba)\n 3. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 4. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        Some ((a, b), ba)\n        \\<in> results_gpv (stop_\\<I> \\<I>'')\n               (gpv_stop\n                 (inline run_converter (run_converter conv1 q)\n                   conv2))\\<rbrakk>\n       \\<Longrightarrow> OK a \\<in> OK ` responses_\\<I> \\<I> q \\<and>\n                         ((\\<exists>conv1 conv2.\n                              obsf_converter (b \\<odot> ba) =\n                              obsf_converter (conv1 \\<odot> conv2) \\<and>\n                              obsf_converter b \\<odot> obsf_converter ba =\n                              obsf_converter conv1 \\<odot>\n                              obsf_converter conv2 \\<and>\n                              \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                              conv1 \\<surd> \\<and>\n                              \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                              conv2 \\<surd> \\<and>\n                              pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                          exception_\\<I>\n                           \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n                          obsf_converter (b \\<odot> ba) \\<sim>\n                          obsf_converter b \\<odot> obsf_converter ba)\n 2. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 3. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(drule results_gpv_stop_SomeD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        ((a, b), ba)\n        \\<in> results_gpv \\<I>''\n               (inline run_converter (run_converter conv1 q) conv2)\\<rbrakk>\n       \\<Longrightarrow> OK a \\<in> OK ` responses_\\<I> \\<I> q \\<and>\n                         ((\\<exists>conv1 conv2.\n                              obsf_converter (b \\<odot> ba) =\n                              obsf_converter (conv1 \\<odot> conv2) \\<and>\n                              obsf_converter b \\<odot> obsf_converter ba =\n                              obsf_converter conv1 \\<odot>\n                              obsf_converter conv2 \\<and>\n                              \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                              conv1 \\<surd> \\<and>\n                              \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                              conv2 \\<surd> \\<and>\n                              pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                          exception_\\<I>\n                           \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n                          obsf_converter (b \\<odot> ba) \\<sim>\n                          obsf_converter b \\<odot> obsf_converter ba)\n 2. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 3. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(rule conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        ((a, b), ba)\n        \\<in> results_gpv \\<I>''\n               (inline run_converter (run_converter conv1 q) conv2)\\<rbrakk>\n       \\<Longrightarrow> OK a \\<in> OK ` responses_\\<I> \\<I> q\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        ((a, b), ba)\n        \\<in> results_gpv \\<I>''\n               (inline run_converter (run_converter conv1 q) conv2)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>conv1 conv2.\n                             obsf_converter (b \\<odot> ba) =\n                             obsf_converter (conv1 \\<odot> conv2) \\<and>\n                             obsf_converter b \\<odot> obsf_converter ba =\n                             obsf_converter conv1 \\<odot>\n                             obsf_converter conv2 \\<and>\n                             \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                             conv1 \\<surd> \\<and>\n                             \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                             conv2 \\<surd> \\<and>\n                             pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                         exception_\\<I>\n                          \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n                         obsf_converter (b \\<odot> ba) \\<sim>\n                         obsf_converter b \\<odot> obsf_converter ba\n 3. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 4. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(rule imageI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        ((a, b), ba)\n        \\<in> results_gpv \\<I>''\n               (inline run_converter (run_converter conv1 q) conv2)\\<rbrakk>\n       \\<Longrightarrow> a \\<in> responses_\\<I> \\<I> q\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        ((a, b), ba)\n        \\<in> results_gpv \\<I>''\n               (inline run_converter (run_converter conv1 q) conv2)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>conv1 conv2.\n                             obsf_converter (b \\<odot> ba) =\n                             obsf_converter (conv1 \\<odot> conv2) \\<and>\n                             obsf_converter b \\<odot> obsf_converter ba =\n                             obsf_converter conv1 \\<odot>\n                             obsf_converter conv2 \\<and>\n                             \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                             conv1 \\<surd> \\<and>\n                             \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                             conv2 \\<surd> \\<and>\n                             pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                         exception_\\<I>\n                          \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n                         obsf_converter (b \\<odot> ba) \\<sim>\n                         obsf_converter b \\<odot> obsf_converter ba\n 3. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 4. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(drule run_converter.results_gpv_inline)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> ?\\<I>53 a b ba\n                         \\<turnstile>g run_converter conv1 q \\<surd>\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> ?\\<I>53 a b ba, \\<I>'' \\<turnstile>\\<^sub>C\n                         conv2 \\<surd>\n 3. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        (a, b)\n        \\<in> results_gpv (?\\<I>53 a b ba) (run_converter conv1 q) \\<and>\n        ?\\<I>53 a b ba, \\<I>'' \\<turnstile>\\<^sub>C ba \\<surd>\\<rbrakk>\n       \\<Longrightarrow> a \\<in> responses_\\<I> \\<I> q\n 4. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        ((a, b), ba)\n        \\<in> results_gpv \\<I>''\n               (inline run_converter (run_converter conv1 q) conv2)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>conv1 conv2.\n                             obsf_converter (b \\<odot> ba) =\n                             obsf_converter (conv1 \\<odot> conv2) \\<and>\n                             obsf_converter b \\<odot> obsf_converter ba =\n                             obsf_converter conv1 \\<odot>\n                             obsf_converter conv2 \\<and>\n                             \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                             conv1 \\<surd> \\<and>\n                             \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                             conv2 \\<surd> \\<and>\n                             pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                         exception_\\<I>\n                          \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n                         obsf_converter (b \\<odot> ba) \\<sim>\n                         obsf_converter b \\<odot> obsf_converter ba\n 5. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 6. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(erule (1) WT_converterD)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        (a, b) \\<in> results_gpv \\<I>' (run_converter conv1 q) \\<and> \\<I>',\n        \\<I>'' \\<turnstile>\\<^sub>C ba \\<surd>\\<rbrakk>\n       \\<Longrightarrow> a \\<in> responses_\\<I> \\<I> q\n 3. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        ((a, b), ba)\n        \\<in> results_gpv \\<I>''\n               (inline run_converter (run_converter conv1 q) conv2)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>conv1 conv2.\n                             obsf_converter (b \\<odot> ba) =\n                             obsf_converter (conv1 \\<odot> conv2) \\<and>\n                             obsf_converter b \\<odot> obsf_converter ba =\n                             obsf_converter conv1 \\<odot>\n                             obsf_converter conv2 \\<and>\n                             \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                             conv1 \\<surd> \\<and>\n                             \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                             conv2 \\<surd> \\<and>\n                             pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                         exception_\\<I>\n                          \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n                         obsf_converter (b \\<odot> ba) \\<sim>\n                         obsf_converter b \\<odot> obsf_converter ba\n 4. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 5. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        (a, b) \\<in> results_gpv \\<I>' (run_converter conv1 q) \\<and> \\<I>',\n        \\<I>'' \\<turnstile>\\<^sub>C ba \\<surd>\\<rbrakk>\n       \\<Longrightarrow> a \\<in> responses_\\<I> \\<I> q\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        ((a, b), ba)\n        \\<in> results_gpv \\<I>''\n               (inline run_converter (run_converter conv1 q) conv2)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>conv1 conv2.\n                             obsf_converter (b \\<odot> ba) =\n                             obsf_converter (conv1 \\<odot> conv2) \\<and>\n                             obsf_converter b \\<odot> obsf_converter ba =\n                             obsf_converter conv1 \\<odot>\n                             obsf_converter conv2 \\<and>\n                             \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                             conv1 \\<surd> \\<and>\n                             \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                             conv2 \\<surd> \\<and>\n                             pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                         exception_\\<I>\n                          \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n                         obsf_converter (b \\<odot> ba) \\<sim>\n                         obsf_converter b \\<odot> obsf_converter ba\n 3. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 4. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        (a, b) \\<in> results_gpv \\<I>' (run_converter conv1 q);\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C ba \\<surd>\\<rbrakk>\n       \\<Longrightarrow> a \\<in> responses_\\<I> \\<I> q\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        ((a, b), ba)\n        \\<in> results_gpv \\<I>''\n               (inline run_converter (run_converter conv1 q) conv2)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>conv1 conv2.\n                             obsf_converter (b \\<odot> ba) =\n                             obsf_converter (conv1 \\<odot> conv2) \\<and>\n                             obsf_converter b \\<odot> obsf_converter ba =\n                             obsf_converter conv1 \\<odot>\n                             obsf_converter conv2 \\<and>\n                             \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                             conv1 \\<surd> \\<and>\n                             \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                             conv2 \\<surd> \\<and>\n                             pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                         exception_\\<I>\n                          \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n                         obsf_converter (b \\<odot> ba) \\<sim>\n                         obsf_converter b \\<odot> obsf_converter ba\n 3. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 4. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(drule (2) WT_converterD_results)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        (a, b) \\<in> results_gpv \\<I>' (run_converter conv1 q);\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C ba \\<surd>;\n        a \\<in> responses_\\<I> \\<I> q \\<and> \\<I>,\n        \\<I>' \\<turnstile>\\<^sub>C b \\<surd>\\<rbrakk>\n       \\<Longrightarrow> a \\<in> responses_\\<I> \\<I> q\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        ((a, b), ba)\n        \\<in> results_gpv \\<I>''\n               (inline run_converter (run_converter conv1 q) conv2)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>conv1 conv2.\n                             obsf_converter (b \\<odot> ba) =\n                             obsf_converter (conv1 \\<odot> conv2) \\<and>\n                             obsf_converter b \\<odot> obsf_converter ba =\n                             obsf_converter conv1 \\<odot>\n                             obsf_converter conv2 \\<and>\n                             \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                             conv1 \\<surd> \\<and>\n                             \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                             conv2 \\<surd> \\<and>\n                             pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                         exception_\\<I>\n                          \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n                         obsf_converter (b \\<odot> ba) \\<sim>\n                         obsf_converter b \\<odot> obsf_converter ba\n 3. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 4. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        ((a, b), ba)\n        \\<in> results_gpv \\<I>''\n               (inline run_converter (run_converter conv1 q) conv2)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>conv1 conv2.\n                             obsf_converter (b \\<odot> ba) =\n                             obsf_converter (conv1 \\<odot> conv2) \\<and>\n                             obsf_converter b \\<odot> obsf_converter ba =\n                             obsf_converter conv1 \\<odot>\n                             obsf_converter conv2 \\<and>\n                             \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                             conv1 \\<surd> \\<and>\n                             \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                             conv2 \\<surd> \\<and>\n                             pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                         exception_\\<I>\n                          \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n                         obsf_converter (b \\<odot> ba) \\<sim>\n                         obsf_converter b \\<odot> obsf_converter ba\n 2. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 3. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(rule disjI1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        ((a, b), ba)\n        \\<in> results_gpv \\<I>''\n               (inline run_converter (run_converter conv1 q) conv2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>conv1 conv2.\n                            obsf_converter (b \\<odot> ba) =\n                            obsf_converter (conv1 \\<odot> conv2) \\<and>\n                            obsf_converter b \\<odot> obsf_converter ba =\n                            obsf_converter conv1 \\<odot>\n                            obsf_converter conv2 \\<and>\n                            \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                            conv1 \\<surd> \\<and>\n                            \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                            conv2 \\<surd> \\<and>\n                            pfinite_converter \\<I> \\<I>' conv1\n 2. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 3. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(rule exI conjI refl)+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        ((a, b), ba)\n        \\<in> results_gpv \\<I>''\n               (inline run_converter (run_converter conv1 q) conv2)\\<rbrakk>\n       \\<Longrightarrow> \\<I>, \\<I>' \\<turnstile>\\<^sub>C b \\<surd>\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        ((a, b), ba)\n        \\<in> results_gpv \\<I>''\n               (inline run_converter (run_converter conv1 q) conv2)\\<rbrakk>\n       \\<Longrightarrow> \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                         ba \\<surd> \\<and> pfinite_converter \\<I> \\<I>' b\n 3. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 4. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(drule run_converter.results_gpv_inline)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> ?\\<I>83 a b ba\n                         \\<turnstile>g run_converter conv1 q \\<surd>\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> ?\\<I>83 a b ba, \\<I>'' \\<turnstile>\\<^sub>C\n                         conv2 \\<surd>\n 3. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        (a, b)\n        \\<in> results_gpv (?\\<I>83 a b ba) (run_converter conv1 q) \\<and>\n        ?\\<I>83 a b ba, \\<I>'' \\<turnstile>\\<^sub>C ba \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>, \\<I>' \\<turnstile>\\<^sub>C b \\<surd>\n 4. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        ((a, b), ba)\n        \\<in> results_gpv \\<I>''\n               (inline run_converter (run_converter conv1 q) conv2)\\<rbrakk>\n       \\<Longrightarrow> \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                         ba \\<surd> \\<and> pfinite_converter \\<I> \\<I>' b\n 5. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 6. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(erule (1) WT_converterD)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        (a, b) \\<in> results_gpv \\<I>' (run_converter conv1 q) \\<and> \\<I>',\n        \\<I>'' \\<turnstile>\\<^sub>C ba \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>, \\<I>' \\<turnstile>\\<^sub>C b \\<surd>\n 3. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        ((a, b), ba)\n        \\<in> results_gpv \\<I>''\n               (inline run_converter (run_converter conv1 q) conv2)\\<rbrakk>\n       \\<Longrightarrow> \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                         ba \\<surd> \\<and> pfinite_converter \\<I> \\<I>' b\n 4. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 5. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        (a, b) \\<in> results_gpv \\<I>' (run_converter conv1 q) \\<and> \\<I>',\n        \\<I>'' \\<turnstile>\\<^sub>C ba \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>, \\<I>' \\<turnstile>\\<^sub>C b \\<surd>\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        ((a, b), ba)\n        \\<in> results_gpv \\<I>''\n               (inline run_converter (run_converter conv1 q) conv2)\\<rbrakk>\n       \\<Longrightarrow> \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                         ba \\<surd> \\<and> pfinite_converter \\<I> \\<I>' b\n 3. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 4. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        (a, b) \\<in> results_gpv \\<I>' (run_converter conv1 q);\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C ba \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>, \\<I>' \\<turnstile>\\<^sub>C b \\<surd>\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        ((a, b), ba)\n        \\<in> results_gpv \\<I>''\n               (inline run_converter (run_converter conv1 q) conv2)\\<rbrakk>\n       \\<Longrightarrow> \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                         ba \\<surd> \\<and> pfinite_converter \\<I> \\<I>' b\n 3. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 4. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(drule (2) WT_converterD_results)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        (a, b) \\<in> results_gpv \\<I>' (run_converter conv1 q);\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C ba \\<surd>;\n        a \\<in> responses_\\<I> \\<I> q \\<and> \\<I>,\n        \\<I>' \\<turnstile>\\<^sub>C b \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>, \\<I>' \\<turnstile>\\<^sub>C b \\<surd>\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        ((a, b), ba)\n        \\<in> results_gpv \\<I>''\n               (inline run_converter (run_converter conv1 q) conv2)\\<rbrakk>\n       \\<Longrightarrow> \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                         ba \\<surd> \\<and> pfinite_converter \\<I> \\<I>' b\n 3. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 4. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        ((a, b), ba)\n        \\<in> results_gpv \\<I>''\n               (inline run_converter (run_converter conv1 q) conv2)\\<rbrakk>\n       \\<Longrightarrow> \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                         ba \\<surd> \\<and> pfinite_converter \\<I> \\<I>' b\n 2. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 3. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(drule run_converter.results_gpv_inline)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> ?\\<I>96 a b ba\n                         \\<turnstile>g run_converter conv1 q \\<surd>\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> ?\\<I>96 a b ba, \\<I>'' \\<turnstile>\\<^sub>C\n                         conv2 \\<surd>\n 3. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        (a, b)\n        \\<in> results_gpv (?\\<I>96 a b ba) (run_converter conv1 q) \\<and>\n        ?\\<I>96 a b ba, \\<I>'' \\<turnstile>\\<^sub>C ba \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                         ba \\<surd> \\<and> pfinite_converter \\<I> \\<I>' b\n 4. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 5. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(erule (1) WT_converterD)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>\n 2. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        (a, b) \\<in> results_gpv \\<I>' (run_converter conv1 q) \\<and> \\<I>',\n        \\<I>'' \\<turnstile>\\<^sub>C ba \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                         ba \\<surd> \\<and> pfinite_converter \\<I> \\<I>' b\n 3. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 4. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        (a, b) \\<in> results_gpv \\<I>' (run_converter conv1 q) \\<and> \\<I>',\n        \\<I>'' \\<turnstile>\\<^sub>C ba \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                         ba \\<surd> \\<and> pfinite_converter \\<I> \\<I>' b\n 2. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 3. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>;\n        (a, b) \\<in> results_gpv \\<I>' (run_converter conv1 q);\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C ba \\<surd>\\<rbrakk>\n       \\<Longrightarrow> pfinite_converter \\<I> \\<I>' b\n 2. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 3. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(drule (1) pfinite_converterD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        q \\<in> outs_\\<I> \\<I>;\n        (a, b) \\<in> results_gpv \\<I>' (run_converter conv1 q);\n        \\<I>', \\<I>'' \\<turnstile>\\<^sub>C ba \\<surd>;\n        pfinite_gpv \\<I>' (run_converter conv1 q) \\<and>\n        (\\<forall>(b, conv')\\<in>results_gpv \\<I>' (run_converter conv1 q).\n            pfinite_converter \\<I> \\<I>' conv')\\<rbrakk>\n       \\<Longrightarrow> pfinite_converter \\<I> \\<I>' b\n 2. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 3. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>''\n                      \\<turnstile>g map_gpv' id id option_of_exception\n                                     (gpv_stop\n (inline run_converter (run_converter conv1 q) conv2)) \\<surd>\n 2. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(rule WT_intro run_converter.WT_gpv_inline_invar|simp)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> ?\\<I>157 \\<turnstile>g run_converter conv1 q \\<surd>\n 2. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> ?\\<I>157, \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>\n 3. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(erule (1) WT_converterD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>\n 2. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r.\n                               r = Fault \\<or>\n                               r \\<in> OK ` responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1 conv2.\n                                 conv =\n                                 obsf_converter (conv1 \\<odot> conv2) \\<and>\n                                 conv' =\n                                 obsf_converter conv1 \\<odot>\n                                 obsf_converter conv2 \\<and>\n                                 \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and>\n                                 \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd> \\<and>\n                                 pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                             exception_\\<I>\n                              \\<I>,exception_\\<I>\n                                    \\<I>'' \\<turnstile>\\<^sub>C\n                             conv \\<sim> conv'))\n                       (exception_\\<I> \\<I>'')\n                       (Done (Fault, const_converter Fault))\n                       (Done (Fault, const_converter Fault))", "apply(simp add: eq_onp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>conv1 conv2.\n                          const_converter Fault =\n                          obsf_converter (conv1 \\<odot> conv2) \\<and>\n                          const_converter Fault =\n                          obsf_converter conv1 \\<odot>\n                          obsf_converter conv2 \\<and>\n                          \\<I>, \\<I>' \\<turnstile>\\<^sub>C\n                          conv1 \\<surd> \\<and>\n                          \\<I>', \\<I>'' \\<turnstile>\\<^sub>C\n                          conv2 \\<surd> \\<and>\n                          pfinite_converter \\<I> \\<I>' conv1) \\<or>\n                      exception_\\<I>\n                       \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n                      const_converter Fault \\<sim> const_converter Fault", "apply(rule disjI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I>\n                       \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n                      const_converter Fault \\<sim> const_converter Fault", "apply(rule eq_\\<I>_converter_reflI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd>;\n     \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd>;\n     pfinite_converter \\<I> \\<I>' conv1; q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> exception_\\<I> \\<I>,\n                      exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n                      const_converter Fault \\<surd>", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eq_\\<I>_gpv\n   (rel_prod\n     (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> (exception_\\<I> \\<I>) q))\n     (\\<lambda>conv conv'.\n         (\\<exists>conv1 conv2.\n             conv = obsf_converter (conv1 \\<odot> conv2) \\<and>\n             conv' =\n             obsf_converter conv1 \\<odot> obsf_converter conv2 \\<and>\n             \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and>\n             \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd> \\<and>\n             pfinite_converter \\<I> \\<I>' conv1) \\<or>\n         exception_\\<I> \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n         conv \\<sim> conv'))\n   (exception_\\<I> \\<I>'')\n   (run_converter (obsf_converter (conv1 \\<odot> conv2)) q)\n   (TRY map_gpv (\\<lambda>((b, conv1'), conv2'). (b, conv1' \\<odot> conv2'))\n         id (map_gpv\n              (\\<lambda>(xo, conv').\n                  case xo of\n                  None \\<Rightarrow> ((Fault, const_converter Fault), conv')\n                  | Some (x, conv) \\<Rightarrow>\n                      ((OK x, obsf_converter conv), conv'))\n              id (bind_gpv\n                   (map_gpv' id id option_of_exception\n                     (gpv_stop\n                       (inline run_converter (run_converter conv1 q)\n                         conv2)))\n                   (case_option Fail\n                     (\\<lambda>(x', conv).\n                         Done\n                          (Some x',\n                           obsf_converter\n                            conv))))) ELSE Done\n      (Fault, const_converter Fault))\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv\n     (rel_prod\n       (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> (exception_\\<I> \\<I>) q))\n       (\\<lambda>conv conv'.\n           (\\<exists>conv1 conv2.\n               conv = obsf_converter (conv1 \\<odot> conv2) \\<and>\n               conv' =\n               obsf_converter conv1 \\<odot> obsf_converter conv2 \\<and>\n               \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and>\n               \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd> \\<and>\n               pfinite_converter \\<I> \\<I>' conv1) \\<or>\n           exception_\\<I> \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n           conv \\<sim> conv'))\n     (exception_\\<I> \\<I>'')\n     (run_converter (obsf_converter (conv1 \\<odot> conv2)) q)\n     (run_converter (obsf_converter conv1 \\<odot> obsf_converter conv2) q)", "finally (eq_\\<I>_gpv_eq_OO2)"], ["proof (chain)\npicking this:\n  eq_\\<I>_gpv\n   (rel_prod\n     (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> (exception_\\<I> \\<I>) q))\n     (\\<lambda>conv conv'.\n         (\\<exists>conv1 conv2.\n             conv = obsf_converter (conv1 \\<odot> conv2) \\<and>\n             conv' =\n             obsf_converter conv1 \\<odot> obsf_converter conv2 \\<and>\n             \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and>\n             \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd> \\<and>\n             pfinite_converter \\<I> \\<I>' conv1) \\<or>\n         exception_\\<I> \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n         conv \\<sim> conv'))\n   (exception_\\<I> \\<I>'')\n   (run_converter (obsf_converter (conv1 \\<odot> conv2)) q)\n   (run_converter (obsf_converter conv1 \\<odot> obsf_converter conv2) q)", "show ?thesis"], ["proof (prove)\nusing this:\n  eq_\\<I>_gpv\n   (rel_prod\n     (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> (exception_\\<I> \\<I>) q))\n     (\\<lambda>conv conv'.\n         (\\<exists>conv1 conv2.\n             conv = obsf_converter (conv1 \\<odot> conv2) \\<and>\n             conv' =\n             obsf_converter conv1 \\<odot> obsf_converter conv2 \\<and>\n             \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and>\n             \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd> \\<and>\n             pfinite_converter \\<I> \\<I>' conv1) \\<or>\n         exception_\\<I> \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n         conv \\<sim> conv'))\n   (exception_\\<I> \\<I>'')\n   (run_converter (obsf_converter (conv1 \\<odot> conv2)) q)\n   (run_converter (obsf_converter conv1 \\<odot> obsf_converter conv2) q)\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv\n     (rel_prod\n       (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> (exception_\\<I> \\<I>) q))\n       (\\<lambda>conv conv'.\n           (\\<exists>conv1 conv2.\n               conv = obsf_converter (conv1 \\<odot> conv2) \\<and>\n               conv' =\n               obsf_converter conv1 \\<odot> obsf_converter conv2 \\<and>\n               \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and>\n               \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd> \\<and>\n               pfinite_converter \\<I> \\<I>' conv1) \\<or>\n           exception_\\<I> \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n           conv \\<sim> conv'))\n     (exception_\\<I> \\<I>'')\n     (run_converter (obsf_converter (conv1 \\<odot> conv2)) q)\n     (run_converter (obsf_converter conv1 \\<odot> obsf_converter conv2) q)", "."], ["proof (state)\nthis:\n  eq_\\<I>_gpv\n   (rel_prod\n     (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> (exception_\\<I> \\<I>) q))\n     (\\<lambda>conv conv'.\n         (\\<exists>conv1 conv2.\n             conv = obsf_converter (conv1 \\<odot> conv2) \\<and>\n             conv' =\n             obsf_converter conv1 \\<odot> obsf_converter conv2 \\<and>\n             \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and>\n             \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd> \\<and>\n             pfinite_converter \\<I> \\<I>' conv1) \\<or>\n         exception_\\<I> \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n         conv \\<sim> conv'))\n   (exception_\\<I> \\<I>'')\n   (run_converter (obsf_converter (conv1 \\<odot> conv2)) q)\n   (run_converter (obsf_converter conv1 \\<odot> obsf_converter conv2) q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eq_\\<I>_gpv\n   (rel_prod\n     (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> (exception_\\<I> \\<I>) q))\n     (\\<lambda>conv conv'.\n         (\\<exists>conv1 conv2.\n             conv = obsf_converter (conv1 \\<odot> conv2) \\<and>\n             conv' =\n             obsf_converter conv1 \\<odot> obsf_converter conv2 \\<and>\n             \\<I>, \\<I>' \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and>\n             \\<I>', \\<I>'' \\<turnstile>\\<^sub>C conv2 \\<surd> \\<and>\n             pfinite_converter \\<I> \\<I>' conv1) \\<or>\n         exception_\\<I> \\<I>,exception_\\<I> \\<I>'' \\<turnstile>\\<^sub>C\n         conv \\<sim> conv'))\n   (exception_\\<I> \\<I>'')\n   (run_converter (obsf_converter (conv1 \\<odot> conv2)) q)\n   (run_converter (obsf_converter conv1 \\<odot> obsf_converter conv2) q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resource_of_obsf_oracle_Fault [simp]:\n  \"resource_of_oracle (obsf_oracle oracle) Fault = const_resource Fault\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RES (obsf_oracle oracle) Fault = const_resource Fault", "by(coinduction)(auto simp add: rel_fun_def)"], ["", "lemma obsf_resource_of_oracle [simp]:\n  \"obsf_resource (resource_of_oracle oracle s) = resource_of_oracle (obsf_oracle oracle) (OK s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obsf_resource (RES oracle s) = RES (obsf_oracle oracle) (OK s)", "by(coinduction arbitrary: s rule: resource.coinduct_strong)\n    (auto 4 3 simp add: rel_fun_def map_try_spmf spmf_rel_map intro!: rel_spmf_try_spmf rel_spmf_reflI)"], ["", "lemma trace_callee_eq_obsf_Fault [simp]: \"A \\<turnstile>\\<^sub>C obsf_oracle callee1(Fault) \\<approx> obsf_oracle callee2(Fault)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>C obsf_oracle callee1(Fault) \\<approx>\n    obsf_oracle callee2(Fault)", "by(coinduction rule: trace_callee_eq_coinduct) auto"], ["", "lemma obsf_resource_eq_\\<I>_cong: \"A \\<turnstile>\\<^sub>R obsf_resource res1 \\<sim> obsf_resource res2\" if \"A \\<turnstile>\\<^sub>R res1 \\<sim> res2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>R obsf_resource res1 \\<sim> obsf_resource res2", "using that"], ["proof (prove)\nusing this:\n  A \\<turnstile>\\<^sub>R res1 \\<sim> res2\n\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>R obsf_resource res1 \\<sim> obsf_resource res2", "by(coinduction arbitrary: res1 res2)(fastforce intro!: rel_spmf_try_spmf simp add: spmf_rel_map elim!: rel_spmf_mono dest: eq_resource_onD)"], ["", "lemma trace_callee_eq_obsf_oracleI:\n  assumes \"trace_callee_eq callee1 callee2 A p q\"\n  shows \"trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A (try_spmf (map_spmf OK p) (return_spmf Fault)) (try_spmf (map_spmf OK q) (return_spmf Fault))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (TRY map_spmf OK p ELSE return_spmf Fault)\n     (TRY map_spmf OK q ELSE return_spmf Fault)", "using assms"], ["proof (prove)\nusing this:\n  trace_callee_eq callee1 callee2 A p q\n\ngoal (1 subgoal):\n 1. trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (TRY map_spmf OK p ELSE return_spmf Fault)\n     (TRY map_spmf OK q ELSE return_spmf Fault)", "proof(coinduction arbitrary: p q rule: trace_callee_eq_coinduct_strong)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a pa qa.\n       \\<lbrakk>trace_callee_eq callee1 callee2 A pa qa; a \\<in> A\\<rbrakk>\n       \\<Longrightarrow> bind_spmf\n                          (TRY map_spmf OK pa ELSE return_spmf Fault)\n                          (\\<lambda>s.\n                              map_spmf fst (obsf_oracle callee1 s a)) =\n                         bind_spmf\n                          (TRY map_spmf OK qa ELSE return_spmf Fault)\n                          (\\<lambda>s.\n                              map_spmf fst (obsf_oracle callee2 s a))\n 2. \\<And>a res res' b s'' s' pa qa.\n       \\<lbrakk>trace_callee_eq callee1 callee2 A pa qa; a \\<in> A;\n        res \\<in> set_spmf (TRY map_spmf OK pa ELSE return_spmf Fault);\n        (b, s'') \\<in> set_spmf (obsf_oracle callee1 res a);\n        res' \\<in> set_spmf (TRY map_spmf OK qa ELSE return_spmf Fault);\n        (b, s') \\<in> set_spmf (obsf_oracle callee2 res' a)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>p q.\n                             cond_spmf_fst\n                              (bind_spmf\n                                (TRY map_spmf OK pa ELSE return_spmf Fault)\n                                (\\<lambda>s. obsf_oracle callee1 s a))\n                              b =\n                             TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n                             cond_spmf_fst\n                              (bind_spmf\n                                (TRY map_spmf OK qa ELSE return_spmf Fault)\n                                (\\<lambda>s. obsf_oracle callee2 s a))\n                              b =\n                             TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n                             trace_callee_eq callee1 callee2 A p q) \\<or>\n                         trace_callee_eq (obsf_oracle callee1)\n                          (obsf_oracle callee2) A\n                          (cond_spmf_fst\n                            (bind_spmf\n                              (TRY map_spmf OK pa ELSE return_spmf Fault)\n                              (\\<lambda>s. obsf_oracle callee1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (bind_spmf\n                              (TRY map_spmf OK qa ELSE return_spmf Fault)\n                              (\\<lambda>s. obsf_oracle callee2 s a))\n                            b)", "case (step z p q)"], ["proof (state)\nthis:\n  trace_callee_eq callee1 callee2 A p q\n  z \\<in> A\n\ngoal (2 subgoals):\n 1. \\<And>a pa qa.\n       \\<lbrakk>trace_callee_eq callee1 callee2 A pa qa; a \\<in> A\\<rbrakk>\n       \\<Longrightarrow> bind_spmf\n                          (TRY map_spmf OK pa ELSE return_spmf Fault)\n                          (\\<lambda>s.\n                              map_spmf fst (obsf_oracle callee1 s a)) =\n                         bind_spmf\n                          (TRY map_spmf OK qa ELSE return_spmf Fault)\n                          (\\<lambda>s.\n                              map_spmf fst (obsf_oracle callee2 s a))\n 2. \\<And>a res res' b s'' s' pa qa.\n       \\<lbrakk>trace_callee_eq callee1 callee2 A pa qa; a \\<in> A;\n        res \\<in> set_spmf (TRY map_spmf OK pa ELSE return_spmf Fault);\n        (b, s'') \\<in> set_spmf (obsf_oracle callee1 res a);\n        res' \\<in> set_spmf (TRY map_spmf OK qa ELSE return_spmf Fault);\n        (b, s') \\<in> set_spmf (obsf_oracle callee2 res' a)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>p q.\n                             cond_spmf_fst\n                              (bind_spmf\n                                (TRY map_spmf OK pa ELSE return_spmf Fault)\n                                (\\<lambda>s. obsf_oracle callee1 s a))\n                              b =\n                             TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n                             cond_spmf_fst\n                              (bind_spmf\n                                (TRY map_spmf OK qa ELSE return_spmf Fault)\n                                (\\<lambda>s. obsf_oracle callee2 s a))\n                              b =\n                             TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n                             trace_callee_eq callee1 callee2 A p q) \\<or>\n                         trace_callee_eq (obsf_oracle callee1)\n                          (obsf_oracle callee2) A\n                          (cond_spmf_fst\n                            (bind_spmf\n                              (TRY map_spmf OK pa ELSE return_spmf Fault)\n                              (\\<lambda>s. obsf_oracle callee1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (bind_spmf\n                              (TRY map_spmf OK qa ELSE return_spmf Fault)\n                              (\\<lambda>s. obsf_oracle callee2 s a))\n                            b)", "have \"?lhs = map_pmf (\\<lambda>x. case x of None \\<Rightarrow> Some Fault | Some y \\<Rightarrow> Some (OK y)) (bind_spmf p (\\<lambda>s'. map_spmf fst (callee1 s' z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n     (\\<lambda>s. map_spmf fst (obsf_oracle callee1 s z)) =\n    map_pmf\n     (\\<lambda>x.\n         case x of None \\<Rightarrow> Some Fault\n         | Some y \\<Rightarrow> Some (OK y))\n     (bind_spmf p (\\<lambda>s'. map_spmf fst (callee1 s' z)))", "by(auto simp add: bind_spmf_def try_spmf_def bind_assoc_pmf map_bind_pmf bind_map_pmf bind_return_pmf option.case_distrib[where h=\"map_pmf _\"] option.case_distrib[where h=return_pmf, symmetric, abs_def] map_pmf_def[symmetric] pmf.map_comp o_def intro!: bind_pmf_cong[OF refl] pmf.map_cong[OF refl] split: option.split)"], ["proof (state)\nthis:\n  bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n   (\\<lambda>s. map_spmf fst (obsf_oracle callee1 s z)) =\n  map_pmf\n   (\\<lambda>x.\n       case x of None \\<Rightarrow> Some Fault\n       | Some y \\<Rightarrow> Some (OK y))\n   (bind_spmf p (\\<lambda>s'. map_spmf fst (callee1 s' z)))\n\ngoal (2 subgoals):\n 1. \\<And>a pa qa.\n       \\<lbrakk>trace_callee_eq callee1 callee2 A pa qa; a \\<in> A\\<rbrakk>\n       \\<Longrightarrow> bind_spmf\n                          (TRY map_spmf OK pa ELSE return_spmf Fault)\n                          (\\<lambda>s.\n                              map_spmf fst (obsf_oracle callee1 s a)) =\n                         bind_spmf\n                          (TRY map_spmf OK qa ELSE return_spmf Fault)\n                          (\\<lambda>s.\n                              map_spmf fst (obsf_oracle callee2 s a))\n 2. \\<And>a res res' b s'' s' pa qa.\n       \\<lbrakk>trace_callee_eq callee1 callee2 A pa qa; a \\<in> A;\n        res \\<in> set_spmf (TRY map_spmf OK pa ELSE return_spmf Fault);\n        (b, s'') \\<in> set_spmf (obsf_oracle callee1 res a);\n        res' \\<in> set_spmf (TRY map_spmf OK qa ELSE return_spmf Fault);\n        (b, s') \\<in> set_spmf (obsf_oracle callee2 res' a)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>p q.\n                             cond_spmf_fst\n                              (bind_spmf\n                                (TRY map_spmf OK pa ELSE return_spmf Fault)\n                                (\\<lambda>s. obsf_oracle callee1 s a))\n                              b =\n                             TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n                             cond_spmf_fst\n                              (bind_spmf\n                                (TRY map_spmf OK qa ELSE return_spmf Fault)\n                                (\\<lambda>s. obsf_oracle callee2 s a))\n                              b =\n                             TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n                             trace_callee_eq callee1 callee2 A p q) \\<or>\n                         trace_callee_eq (obsf_oracle callee1)\n                          (obsf_oracle callee2) A\n                          (cond_spmf_fst\n                            (bind_spmf\n                              (TRY map_spmf OK pa ELSE return_spmf Fault)\n                              (\\<lambda>s. obsf_oracle callee1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (bind_spmf\n                              (TRY map_spmf OK qa ELSE return_spmf Fault)\n                              (\\<lambda>s. obsf_oracle callee2 s a))\n                            b)", "also"], ["proof (state)\nthis:\n  bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n   (\\<lambda>s. map_spmf fst (obsf_oracle callee1 s z)) =\n  map_pmf\n   (\\<lambda>x.\n       case x of None \\<Rightarrow> Some Fault\n       | Some y \\<Rightarrow> Some (OK y))\n   (bind_spmf p (\\<lambda>s'. map_spmf fst (callee1 s' z)))\n\ngoal (2 subgoals):\n 1. \\<And>a pa qa.\n       \\<lbrakk>trace_callee_eq callee1 callee2 A pa qa; a \\<in> A\\<rbrakk>\n       \\<Longrightarrow> bind_spmf\n                          (TRY map_spmf OK pa ELSE return_spmf Fault)\n                          (\\<lambda>s.\n                              map_spmf fst (obsf_oracle callee1 s a)) =\n                         bind_spmf\n                          (TRY map_spmf OK qa ELSE return_spmf Fault)\n                          (\\<lambda>s.\n                              map_spmf fst (obsf_oracle callee2 s a))\n 2. \\<And>a res res' b s'' s' pa qa.\n       \\<lbrakk>trace_callee_eq callee1 callee2 A pa qa; a \\<in> A;\n        res \\<in> set_spmf (TRY map_spmf OK pa ELSE return_spmf Fault);\n        (b, s'') \\<in> set_spmf (obsf_oracle callee1 res a);\n        res' \\<in> set_spmf (TRY map_spmf OK qa ELSE return_spmf Fault);\n        (b, s') \\<in> set_spmf (obsf_oracle callee2 res' a)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>p q.\n                             cond_spmf_fst\n                              (bind_spmf\n                                (TRY map_spmf OK pa ELSE return_spmf Fault)\n                                (\\<lambda>s. obsf_oracle callee1 s a))\n                              b =\n                             TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n                             cond_spmf_fst\n                              (bind_spmf\n                                (TRY map_spmf OK qa ELSE return_spmf Fault)\n                                (\\<lambda>s. obsf_oracle callee2 s a))\n                              b =\n                             TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n                             trace_callee_eq callee1 callee2 A p q) \\<or>\n                         trace_callee_eq (obsf_oracle callee1)\n                          (obsf_oracle callee2) A\n                          (cond_spmf_fst\n                            (bind_spmf\n                              (TRY map_spmf OK pa ELSE return_spmf Fault)\n                              (\\<lambda>s. obsf_oracle callee1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (bind_spmf\n                              (TRY map_spmf OK qa ELSE return_spmf Fault)\n                              (\\<lambda>s. obsf_oracle callee2 s a))\n                            b)", "have \"bind_spmf p (\\<lambda>s'. map_spmf fst (callee1 s' z)) = bind_spmf q (\\<lambda>s'. map_spmf fst (callee2 s' z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_spmf p (\\<lambda>s'. map_spmf fst (callee1 s' z)) =\n    bind_spmf q (\\<lambda>s'. map_spmf fst (callee2 s' z))", "using step(1)[THEN trace_callee_eqD[where xs=\"[]\" and x=z]] step(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>set [] \\<subseteq> A \\<times> UNIV; z \\<in> A\\<rbrakk>\n  \\<Longrightarrow> trace_callee callee1 p [] z =\n                    trace_callee callee2 q [] z\n  z \\<in> A\n\ngoal (1 subgoal):\n 1. bind_spmf p (\\<lambda>s'. map_spmf fst (callee1 s' z)) =\n    bind_spmf q (\\<lambda>s'. map_spmf fst (callee2 s' z))", "by simp"], ["proof (state)\nthis:\n  bind_spmf p (\\<lambda>s'. map_spmf fst (callee1 s' z)) =\n  bind_spmf q (\\<lambda>s'. map_spmf fst (callee2 s' z))\n\ngoal (2 subgoals):\n 1. \\<And>a pa qa.\n       \\<lbrakk>trace_callee_eq callee1 callee2 A pa qa; a \\<in> A\\<rbrakk>\n       \\<Longrightarrow> bind_spmf\n                          (TRY map_spmf OK pa ELSE return_spmf Fault)\n                          (\\<lambda>s.\n                              map_spmf fst (obsf_oracle callee1 s a)) =\n                         bind_spmf\n                          (TRY map_spmf OK qa ELSE return_spmf Fault)\n                          (\\<lambda>s.\n                              map_spmf fst (obsf_oracle callee2 s a))\n 2. \\<And>a res res' b s'' s' pa qa.\n       \\<lbrakk>trace_callee_eq callee1 callee2 A pa qa; a \\<in> A;\n        res \\<in> set_spmf (TRY map_spmf OK pa ELSE return_spmf Fault);\n        (b, s'') \\<in> set_spmf (obsf_oracle callee1 res a);\n        res' \\<in> set_spmf (TRY map_spmf OK qa ELSE return_spmf Fault);\n        (b, s') \\<in> set_spmf (obsf_oracle callee2 res' a)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>p q.\n                             cond_spmf_fst\n                              (bind_spmf\n                                (TRY map_spmf OK pa ELSE return_spmf Fault)\n                                (\\<lambda>s. obsf_oracle callee1 s a))\n                              b =\n                             TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n                             cond_spmf_fst\n                              (bind_spmf\n                                (TRY map_spmf OK qa ELSE return_spmf Fault)\n                                (\\<lambda>s. obsf_oracle callee2 s a))\n                              b =\n                             TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n                             trace_callee_eq callee1 callee2 A p q) \\<or>\n                         trace_callee_eq (obsf_oracle callee1)\n                          (obsf_oracle callee2) A\n                          (cond_spmf_fst\n                            (bind_spmf\n                              (TRY map_spmf OK pa ELSE return_spmf Fault)\n                              (\\<lambda>s. obsf_oracle callee1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (bind_spmf\n                              (TRY map_spmf OK qa ELSE return_spmf Fault)\n                              (\\<lambda>s. obsf_oracle callee2 s a))\n                            b)", "also"], ["proof (state)\nthis:\n  bind_spmf p (\\<lambda>s'. map_spmf fst (callee1 s' z)) =\n  bind_spmf q (\\<lambda>s'. map_spmf fst (callee2 s' z))\n\ngoal (2 subgoals):\n 1. \\<And>a pa qa.\n       \\<lbrakk>trace_callee_eq callee1 callee2 A pa qa; a \\<in> A\\<rbrakk>\n       \\<Longrightarrow> bind_spmf\n                          (TRY map_spmf OK pa ELSE return_spmf Fault)\n                          (\\<lambda>s.\n                              map_spmf fst (obsf_oracle callee1 s a)) =\n                         bind_spmf\n                          (TRY map_spmf OK qa ELSE return_spmf Fault)\n                          (\\<lambda>s.\n                              map_spmf fst (obsf_oracle callee2 s a))\n 2. \\<And>a res res' b s'' s' pa qa.\n       \\<lbrakk>trace_callee_eq callee1 callee2 A pa qa; a \\<in> A;\n        res \\<in> set_spmf (TRY map_spmf OK pa ELSE return_spmf Fault);\n        (b, s'') \\<in> set_spmf (obsf_oracle callee1 res a);\n        res' \\<in> set_spmf (TRY map_spmf OK qa ELSE return_spmf Fault);\n        (b, s') \\<in> set_spmf (obsf_oracle callee2 res' a)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>p q.\n                             cond_spmf_fst\n                              (bind_spmf\n                                (TRY map_spmf OK pa ELSE return_spmf Fault)\n                                (\\<lambda>s. obsf_oracle callee1 s a))\n                              b =\n                             TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n                             cond_spmf_fst\n                              (bind_spmf\n                                (TRY map_spmf OK qa ELSE return_spmf Fault)\n                                (\\<lambda>s. obsf_oracle callee2 s a))\n                              b =\n                             TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n                             trace_callee_eq callee1 callee2 A p q) \\<or>\n                         trace_callee_eq (obsf_oracle callee1)\n                          (obsf_oracle callee2) A\n                          (cond_spmf_fst\n                            (bind_spmf\n                              (TRY map_spmf OK pa ELSE return_spmf Fault)\n                              (\\<lambda>s. obsf_oracle callee1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (bind_spmf\n                              (TRY map_spmf OK qa ELSE return_spmf Fault)\n                              (\\<lambda>s. obsf_oracle callee2 s a))\n                            b)", "have \"map_pmf (\\<lambda>x. case x of None \\<Rightarrow> Some Fault | Some y \\<Rightarrow> Some (OK y)) \\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf\n     (\\<lambda>x.\n         case x of None \\<Rightarrow> Some Fault\n         | Some y \\<Rightarrow> Some (OK y))\n     (bind_spmf q (\\<lambda>s'. map_spmf fst (callee2 s' z))) =\n    bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n     (\\<lambda>s. map_spmf fst (obsf_oracle callee2 s z))", "by(auto simp add: bind_spmf_def try_spmf_def bind_assoc_pmf map_bind_pmf bind_map_pmf bind_return_pmf option.case_distrib[where h=\"map_pmf _\"] option.case_distrib[where h=return_pmf, symmetric, abs_def] map_pmf_def[symmetric] pmf.map_comp o_def intro!: bind_pmf_cong[OF refl] pmf.map_cong[OF refl] split: option.split)"], ["proof (state)\nthis:\n  map_pmf\n   (\\<lambda>x.\n       case x of None \\<Rightarrow> Some Fault\n       | Some y \\<Rightarrow> Some (OK y))\n   (bind_spmf q (\\<lambda>s'. map_spmf fst (callee2 s' z))) =\n  bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n   (\\<lambda>s. map_spmf fst (obsf_oracle callee2 s z))\n\ngoal (2 subgoals):\n 1. \\<And>a pa qa.\n       \\<lbrakk>trace_callee_eq callee1 callee2 A pa qa; a \\<in> A\\<rbrakk>\n       \\<Longrightarrow> bind_spmf\n                          (TRY map_spmf OK pa ELSE return_spmf Fault)\n                          (\\<lambda>s.\n                              map_spmf fst (obsf_oracle callee1 s a)) =\n                         bind_spmf\n                          (TRY map_spmf OK qa ELSE return_spmf Fault)\n                          (\\<lambda>s.\n                              map_spmf fst (obsf_oracle callee2 s a))\n 2. \\<And>a res res' b s'' s' pa qa.\n       \\<lbrakk>trace_callee_eq callee1 callee2 A pa qa; a \\<in> A;\n        res \\<in> set_spmf (TRY map_spmf OK pa ELSE return_spmf Fault);\n        (b, s'') \\<in> set_spmf (obsf_oracle callee1 res a);\n        res' \\<in> set_spmf (TRY map_spmf OK qa ELSE return_spmf Fault);\n        (b, s') \\<in> set_spmf (obsf_oracle callee2 res' a)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>p q.\n                             cond_spmf_fst\n                              (bind_spmf\n                                (TRY map_spmf OK pa ELSE return_spmf Fault)\n                                (\\<lambda>s. obsf_oracle callee1 s a))\n                              b =\n                             TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n                             cond_spmf_fst\n                              (bind_spmf\n                                (TRY map_spmf OK qa ELSE return_spmf Fault)\n                                (\\<lambda>s. obsf_oracle callee2 s a))\n                              b =\n                             TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n                             trace_callee_eq callee1 callee2 A p q) \\<or>\n                         trace_callee_eq (obsf_oracle callee1)\n                          (obsf_oracle callee2) A\n                          (cond_spmf_fst\n                            (bind_spmf\n                              (TRY map_spmf OK pa ELSE return_spmf Fault)\n                              (\\<lambda>s. obsf_oracle callee1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (bind_spmf\n                              (TRY map_spmf OK qa ELSE return_spmf Fault)\n                              (\\<lambda>s. obsf_oracle callee2 s a))\n                            b)", "finally"], ["proof (chain)\npicking this:\n  bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n   (\\<lambda>s. map_spmf fst (obsf_oracle callee1 s z)) =\n  bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n   (\\<lambda>s. map_spmf fst (obsf_oracle callee2 s z))", "show ?case"], ["proof (prove)\nusing this:\n  bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n   (\\<lambda>s. map_spmf fst (obsf_oracle callee1 s z)) =\n  bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n   (\\<lambda>s. map_spmf fst (obsf_oracle callee2 s z))\n\ngoal (1 subgoal):\n 1. bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n     (\\<lambda>s. map_spmf fst (obsf_oracle callee1 s z)) =\n    bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n     (\\<lambda>s. map_spmf fst (obsf_oracle callee2 s z))", "."], ["proof (state)\nthis:\n  bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n   (\\<lambda>s. map_spmf fst (obsf_oracle callee1 s z)) =\n  bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n   (\\<lambda>s. map_spmf fst (obsf_oracle callee2 s z))\n\ngoal (1 subgoal):\n 1. \\<And>a res res' b s'' s' pa qa.\n       \\<lbrakk>trace_callee_eq callee1 callee2 A pa qa; a \\<in> A;\n        res \\<in> set_spmf (TRY map_spmf OK pa ELSE return_spmf Fault);\n        (b, s'') \\<in> set_spmf (obsf_oracle callee1 res a);\n        res' \\<in> set_spmf (TRY map_spmf OK qa ELSE return_spmf Fault);\n        (b, s') \\<in> set_spmf (obsf_oracle callee2 res' a)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>p q.\n                             cond_spmf_fst\n                              (bind_spmf\n                                (TRY map_spmf OK pa ELSE return_spmf Fault)\n                                (\\<lambda>s. obsf_oracle callee1 s a))\n                              b =\n                             TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n                             cond_spmf_fst\n                              (bind_spmf\n                                (TRY map_spmf OK qa ELSE return_spmf Fault)\n                                (\\<lambda>s. obsf_oracle callee2 s a))\n                              b =\n                             TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n                             trace_callee_eq callee1 callee2 A p q) \\<or>\n                         trace_callee_eq (obsf_oracle callee1)\n                          (obsf_oracle callee2) A\n                          (cond_spmf_fst\n                            (bind_spmf\n                              (TRY map_spmf OK pa ELSE return_spmf Fault)\n                              (\\<lambda>s. obsf_oracle callee1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (bind_spmf\n                              (TRY map_spmf OK qa ELSE return_spmf Fault)\n                              (\\<lambda>s. obsf_oracle callee2 s a))\n                            b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a res res' b s'' s' pa qa.\n       \\<lbrakk>trace_callee_eq callee1 callee2 A pa qa; a \\<in> A;\n        res \\<in> set_spmf (TRY map_spmf OK pa ELSE return_spmf Fault);\n        (b, s'') \\<in> set_spmf (obsf_oracle callee1 res a);\n        res' \\<in> set_spmf (TRY map_spmf OK qa ELSE return_spmf Fault);\n        (b, s') \\<in> set_spmf (obsf_oracle callee2 res' a)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>p q.\n                             cond_spmf_fst\n                              (bind_spmf\n                                (TRY map_spmf OK pa ELSE return_spmf Fault)\n                                (\\<lambda>s. obsf_oracle callee1 s a))\n                              b =\n                             TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n                             cond_spmf_fst\n                              (bind_spmf\n                                (TRY map_spmf OK qa ELSE return_spmf Fault)\n                                (\\<lambda>s. obsf_oracle callee2 s a))\n                              b =\n                             TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n                             trace_callee_eq callee1 callee2 A p q) \\<or>\n                         trace_callee_eq (obsf_oracle callee1)\n                          (obsf_oracle callee2) A\n                          (cond_spmf_fst\n                            (bind_spmf\n                              (TRY map_spmf OK pa ELSE return_spmf Fault)\n                              (\\<lambda>s. obsf_oracle callee1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (bind_spmf\n                              (TRY map_spmf OK qa ELSE return_spmf Fault)\n                              (\\<lambda>s. obsf_oracle callee2 s a))\n                            b)", "case (sim x s1 s2 ye s1' s2' p q)"], ["proof (state)\nthis:\n  trace_callee_eq callee1 callee2 A p q\n  x \\<in> A\n  s1 \\<in> set_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n  (ye, s1') \\<in> set_spmf (obsf_oracle callee1 s1 x)\n  s2 \\<in> set_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n  (ye, s2') \\<in> set_spmf (obsf_oracle callee2 s2 x)\n\ngoal (1 subgoal):\n 1. \\<And>a res res' b s'' s' pa qa.\n       \\<lbrakk>trace_callee_eq callee1 callee2 A pa qa; a \\<in> A;\n        res \\<in> set_spmf (TRY map_spmf OK pa ELSE return_spmf Fault);\n        (b, s'') \\<in> set_spmf (obsf_oracle callee1 res a);\n        res' \\<in> set_spmf (TRY map_spmf OK qa ELSE return_spmf Fault);\n        (b, s') \\<in> set_spmf (obsf_oracle callee2 res' a)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>p q.\n                             cond_spmf_fst\n                              (bind_spmf\n                                (TRY map_spmf OK pa ELSE return_spmf Fault)\n                                (\\<lambda>s. obsf_oracle callee1 s a))\n                              b =\n                             TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n                             cond_spmf_fst\n                              (bind_spmf\n                                (TRY map_spmf OK qa ELSE return_spmf Fault)\n                                (\\<lambda>s. obsf_oracle callee2 s a))\n                              b =\n                             TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n                             trace_callee_eq callee1 callee2 A p q) \\<or>\n                         trace_callee_eq (obsf_oracle callee1)\n                          (obsf_oracle callee2) A\n                          (cond_spmf_fst\n                            (bind_spmf\n                              (TRY map_spmf OK pa ELSE return_spmf Fault)\n                              (\\<lambda>s. obsf_oracle callee1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (bind_spmf\n                              (TRY map_spmf OK qa ELSE return_spmf Fault)\n                              (\\<lambda>s. obsf_oracle callee2 s a))\n                            b)", "have eq1: \"bind_spmf (try_spmf (map_spmf OK p) (return_spmf Fault)) (\\<lambda>s. obsf_oracle callee1 s x) = \n     try_spmf (bind_spmf p (\\<lambda>s. map_spmf (map_prod OK OK) (callee1 s x))) (return_spmf (Fault, Fault))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n     (\\<lambda>s. obsf_oracle callee1 s x) =\n    TRY bind_spmf p\n         (\\<lambda>s.\n             map_spmf (map_prod OK OK)\n              (callee1 s x)) ELSE return_spmf (Fault, Fault)", "by(auto simp add: bind_spmf_def try_spmf_def bind_assoc_pmf bind_map_pmf bind_return_pmf intro!: bind_pmf_cong[OF refl] split: option.split)"], ["proof (state)\nthis:\n  bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n   (\\<lambda>s. obsf_oracle callee1 s x) =\n  TRY bind_spmf p\n       (\\<lambda>s.\n           map_spmf (map_prod OK OK)\n            (callee1 s x)) ELSE return_spmf (Fault, Fault)\n\ngoal (1 subgoal):\n 1. \\<And>a res res' b s'' s' pa qa.\n       \\<lbrakk>trace_callee_eq callee1 callee2 A pa qa; a \\<in> A;\n        res \\<in> set_spmf (TRY map_spmf OK pa ELSE return_spmf Fault);\n        (b, s'') \\<in> set_spmf (obsf_oracle callee1 res a);\n        res' \\<in> set_spmf (TRY map_spmf OK qa ELSE return_spmf Fault);\n        (b, s') \\<in> set_spmf (obsf_oracle callee2 res' a)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>p q.\n                             cond_spmf_fst\n                              (bind_spmf\n                                (TRY map_spmf OK pa ELSE return_spmf Fault)\n                                (\\<lambda>s. obsf_oracle callee1 s a))\n                              b =\n                             TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n                             cond_spmf_fst\n                              (bind_spmf\n                                (TRY map_spmf OK qa ELSE return_spmf Fault)\n                                (\\<lambda>s. obsf_oracle callee2 s a))\n                              b =\n                             TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n                             trace_callee_eq callee1 callee2 A p q) \\<or>\n                         trace_callee_eq (obsf_oracle callee1)\n                          (obsf_oracle callee2) A\n                          (cond_spmf_fst\n                            (bind_spmf\n                              (TRY map_spmf OK pa ELSE return_spmf Fault)\n                              (\\<lambda>s. obsf_oracle callee1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (bind_spmf\n                              (TRY map_spmf OK qa ELSE return_spmf Fault)\n                              (\\<lambda>s. obsf_oracle callee2 s a))\n                            b)", "have eq2: \"bind_spmf (try_spmf (map_spmf OK q) (return_spmf Fault)) (\\<lambda>s. obsf_oracle callee2 s x) = \n     try_spmf (bind_spmf q (\\<lambda>s. map_spmf (map_prod OK OK) (callee2 s x))) (return_spmf (Fault, Fault))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n     (\\<lambda>s. obsf_oracle callee2 s x) =\n    TRY bind_spmf q\n         (\\<lambda>s.\n             map_spmf (map_prod OK OK)\n              (callee2 s x)) ELSE return_spmf (Fault, Fault)", "by(auto simp add: bind_spmf_def try_spmf_def bind_assoc_pmf bind_map_pmf bind_return_pmf intro!: bind_pmf_cong[OF refl] split: option.split)"], ["proof (state)\nthis:\n  bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n   (\\<lambda>s. obsf_oracle callee2 s x) =\n  TRY bind_spmf q\n       (\\<lambda>s.\n           map_spmf (map_prod OK OK)\n            (callee2 s x)) ELSE return_spmf (Fault, Fault)\n\ngoal (1 subgoal):\n 1. \\<And>a res res' b s'' s' pa qa.\n       \\<lbrakk>trace_callee_eq callee1 callee2 A pa qa; a \\<in> A;\n        res \\<in> set_spmf (TRY map_spmf OK pa ELSE return_spmf Fault);\n        (b, s'') \\<in> set_spmf (obsf_oracle callee1 res a);\n        res' \\<in> set_spmf (TRY map_spmf OK qa ELSE return_spmf Fault);\n        (b, s') \\<in> set_spmf (obsf_oracle callee2 res' a)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>p q.\n                             cond_spmf_fst\n                              (bind_spmf\n                                (TRY map_spmf OK pa ELSE return_spmf Fault)\n                                (\\<lambda>s. obsf_oracle callee1 s a))\n                              b =\n                             TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n                             cond_spmf_fst\n                              (bind_spmf\n                                (TRY map_spmf OK qa ELSE return_spmf Fault)\n                                (\\<lambda>s. obsf_oracle callee2 s a))\n                              b =\n                             TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n                             trace_callee_eq callee1 callee2 A p q) \\<or>\n                         trace_callee_eq (obsf_oracle callee1)\n                          (obsf_oracle callee2) A\n                          (cond_spmf_fst\n                            (bind_spmf\n                              (TRY map_spmf OK pa ELSE return_spmf Fault)\n                              (\\<lambda>s. obsf_oracle callee1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (bind_spmf\n                              (TRY map_spmf OK qa ELSE return_spmf Fault)\n                              (\\<lambda>s. obsf_oracle callee2 s a))\n                            b)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>p q.\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee1 s x))\n         ye =\n        TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee2 s x))\n         ye =\n        TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n        trace_callee_eq callee1 callee2 A p q) \\<or>\n    trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye)\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye)", "proof(cases ye)"], ["proof (state)\ngoal (2 subgoals):\n 1. ye = Fault \\<Longrightarrow>\n    (\\<exists>p q.\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee1 s x))\n         ye =\n        TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee2 s x))\n         ye =\n        TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n        trace_callee_eq callee1 callee2 A p q) \\<or>\n    trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye)\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye)\n 2. \\<And>x2.\n       ye = OK x2 \\<Longrightarrow>\n       (\\<exists>p q.\n           cond_spmf_fst\n            (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n              (\\<lambda>s. obsf_oracle callee1 s x))\n            ye =\n           TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n           cond_spmf_fst\n            (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n              (\\<lambda>s. obsf_oracle callee2 s x))\n            ye =\n           TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n           trace_callee_eq callee1 callee2 A p q) \\<or>\n       trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n        (cond_spmf_fst\n          (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n            (\\<lambda>s. obsf_oracle callee1 s x))\n          ye)\n        (cond_spmf_fst\n          (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n            (\\<lambda>s. obsf_oracle callee2 s x))\n          ye)", "case [simp]: Fault"], ["proof (state)\nthis:\n  ye = Fault\n\ngoal (2 subgoals):\n 1. ye = Fault \\<Longrightarrow>\n    (\\<exists>p q.\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee1 s x))\n         ye =\n        TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee2 s x))\n         ye =\n        TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n        trace_callee_eq callee1 callee2 A p q) \\<or>\n    trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye)\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye)\n 2. \\<And>x2.\n       ye = OK x2 \\<Longrightarrow>\n       (\\<exists>p q.\n           cond_spmf_fst\n            (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n              (\\<lambda>s. obsf_oracle callee1 s x))\n            ye =\n           TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n           cond_spmf_fst\n            (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n              (\\<lambda>s. obsf_oracle callee2 s x))\n            ye =\n           TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n           trace_callee_eq callee1 callee2 A p q) \\<or>\n       trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n        (cond_spmf_fst\n          (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n            (\\<lambda>s. obsf_oracle callee1 s x))\n          ye)\n        (cond_spmf_fst\n          (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n            (\\<lambda>s. obsf_oracle callee2 s x))\n          ye)", "have \"lossless_spmf (bind_spmf p (\\<lambda>s. map_spmf (map_prod OK OK) (callee1 s x))) \\<longleftrightarrow> lossless_spmf (bind_spmf q (\\<lambda>s. map_spmf (map_prod OK OK) (callee2 s x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf\n     (bind_spmf p (\\<lambda>s. map_spmf (map_prod OK OK) (callee1 s x))) =\n    lossless_spmf\n     (bind_spmf q (\\<lambda>s. map_spmf (map_prod OK OK) (callee2 s x)))", "using sim(1)[THEN trace_callee_eqD[where xs=\"[]\" and x=x], THEN arg_cong[where f=\"lossless_spmf\"]] sim(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>set [] \\<subseteq> A \\<times> UNIV; x \\<in> A\\<rbrakk>\n  \\<Longrightarrow> lossless_spmf (trace_callee callee1 p [] x) =\n                    lossless_spmf (trace_callee callee2 q [] x)\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. lossless_spmf\n     (bind_spmf p (\\<lambda>s. map_spmf (map_prod OK OK) (callee1 s x))) =\n    lossless_spmf\n     (bind_spmf q (\\<lambda>s. map_spmf (map_prod OK OK) (callee2 s x)))", "by simp"], ["proof (state)\nthis:\n  lossless_spmf\n   (bind_spmf p (\\<lambda>s. map_spmf (map_prod OK OK) (callee1 s x))) =\n  lossless_spmf\n   (bind_spmf q (\\<lambda>s. map_spmf (map_prod OK OK) (callee2 s x)))\n\ngoal (2 subgoals):\n 1. ye = Fault \\<Longrightarrow>\n    (\\<exists>p q.\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee1 s x))\n         ye =\n        TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee2 s x))\n         ye =\n        TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n        trace_callee_eq callee1 callee2 A p q) \\<or>\n    trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye)\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye)\n 2. \\<And>x2.\n       ye = OK x2 \\<Longrightarrow>\n       (\\<exists>p q.\n           cond_spmf_fst\n            (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n              (\\<lambda>s. obsf_oracle callee1 s x))\n            ye =\n           TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n           cond_spmf_fst\n            (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n              (\\<lambda>s. obsf_oracle callee2 s x))\n            ye =\n           TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n           trace_callee_eq callee1 callee2 A p q) \\<or>\n       trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n        (cond_spmf_fst\n          (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n            (\\<lambda>s. obsf_oracle callee1 s x))\n          ye)\n        (cond_spmf_fst\n          (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n            (\\<lambda>s. obsf_oracle callee2 s x))\n          ye)", "then"], ["proof (chain)\npicking this:\n  lossless_spmf\n   (bind_spmf p (\\<lambda>s. map_spmf (map_prod OK OK) (callee1 s x))) =\n  lossless_spmf\n   (bind_spmf q (\\<lambda>s. map_spmf (map_prod OK OK) (callee2 s x)))", "have \"?eq\""], ["proof (prove)\nusing this:\n  lossless_spmf\n   (bind_spmf p (\\<lambda>s. map_spmf (map_prod OK OK) (callee1 s x))) =\n  lossless_spmf\n   (bind_spmf q (\\<lambda>s. map_spmf (map_prod OK OK) (callee2 s x)))\n\ngoal (1 subgoal):\n 1. trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye)\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye)", "by(simp add: eq1 eq2)(subst (1 2) cond_spmf_fst_try2, auto)"], ["proof (state)\nthis:\n  trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n   (cond_spmf_fst\n     (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n       (\\<lambda>s. obsf_oracle callee1 s x))\n     ye)\n   (cond_spmf_fst\n     (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n       (\\<lambda>s. obsf_oracle callee2 s x))\n     ye)\n\ngoal (2 subgoals):\n 1. ye = Fault \\<Longrightarrow>\n    (\\<exists>p q.\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee1 s x))\n         ye =\n        TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee2 s x))\n         ye =\n        TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n        trace_callee_eq callee1 callee2 A p q) \\<or>\n    trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye)\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye)\n 2. \\<And>x2.\n       ye = OK x2 \\<Longrightarrow>\n       (\\<exists>p q.\n           cond_spmf_fst\n            (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n              (\\<lambda>s. obsf_oracle callee1 s x))\n            ye =\n           TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n           cond_spmf_fst\n            (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n              (\\<lambda>s. obsf_oracle callee2 s x))\n            ye =\n           TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n           trace_callee_eq callee1 callee2 A p q) \\<or>\n       trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n        (cond_spmf_fst\n          (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n            (\\<lambda>s. obsf_oracle callee1 s x))\n          ye)\n        (cond_spmf_fst\n          (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n            (\\<lambda>s. obsf_oracle callee2 s x))\n          ye)", "then"], ["proof (chain)\npicking this:\n  trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n   (cond_spmf_fst\n     (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n       (\\<lambda>s. obsf_oracle callee1 s x))\n     ye)\n   (cond_spmf_fst\n     (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n       (\\<lambda>s. obsf_oracle callee2 s x))\n     ye)", "show ?thesis"], ["proof (prove)\nusing this:\n  trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n   (cond_spmf_fst\n     (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n       (\\<lambda>s. obsf_oracle callee1 s x))\n     ye)\n   (cond_spmf_fst\n     (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n       (\\<lambda>s. obsf_oracle callee2 s x))\n     ye)\n\ngoal (1 subgoal):\n 1. (\\<exists>p q.\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee1 s x))\n         ye =\n        TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee2 s x))\n         ye =\n        TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n        trace_callee_eq callee1 callee2 A p q) \\<or>\n    trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye)\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye)", ".."], ["proof (state)\nthis:\n  (\\<exists>p q.\n      cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye =\n      TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n      cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye =\n      TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n      trace_callee_eq callee1 callee2 A p q) \\<or>\n  trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n   (cond_spmf_fst\n     (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n       (\\<lambda>s. obsf_oracle callee1 s x))\n     ye)\n   (cond_spmf_fst\n     (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n       (\\<lambda>s. obsf_oracle callee2 s x))\n     ye)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       ye = OK x2 \\<Longrightarrow>\n       (\\<exists>p q.\n           cond_spmf_fst\n            (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n              (\\<lambda>s. obsf_oracle callee1 s x))\n            ye =\n           TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n           cond_spmf_fst\n            (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n              (\\<lambda>s. obsf_oracle callee2 s x))\n            ye =\n           TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n           trace_callee_eq callee1 callee2 A p q) \\<or>\n       trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n        (cond_spmf_fst\n          (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n            (\\<lambda>s. obsf_oracle callee1 s x))\n          ye)\n        (cond_spmf_fst\n          (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n            (\\<lambda>s. obsf_oracle callee2 s x))\n          ye)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       ye = OK x2 \\<Longrightarrow>\n       (\\<exists>p q.\n           cond_spmf_fst\n            (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n              (\\<lambda>s. obsf_oracle callee1 s x))\n            ye =\n           TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n           cond_spmf_fst\n            (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n              (\\<lambda>s. obsf_oracle callee2 s x))\n            ye =\n           TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n           trace_callee_eq callee1 callee2 A p q) \\<or>\n       trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n        (cond_spmf_fst\n          (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n            (\\<lambda>s. obsf_oracle callee1 s x))\n          ye)\n        (cond_spmf_fst\n          (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n            (\\<lambda>s. obsf_oracle callee2 s x))\n          ye)", "case [simp]: (OK y)"], ["proof (state)\nthis:\n  ye = OK y\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       ye = OK x2 \\<Longrightarrow>\n       (\\<exists>p q.\n           cond_spmf_fst\n            (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n              (\\<lambda>s. obsf_oracle callee1 s x))\n            ye =\n           TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n           cond_spmf_fst\n            (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n              (\\<lambda>s. obsf_oracle callee2 s x))\n            ye =\n           TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n           trace_callee_eq callee1 callee2 A p q) \\<or>\n       trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n        (cond_spmf_fst\n          (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n            (\\<lambda>s. obsf_oracle callee1 s x))\n          ye)\n        (cond_spmf_fst\n          (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n            (\\<lambda>s. obsf_oracle callee2 s x))\n          ye)", "have eq3: \"fst ` set_spmf (bind_spmf p (\\<lambda>s. callee1 s x)) = fst ` set_spmf (bind_spmf q (\\<lambda>s. callee2 s x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set_spmf (bind_spmf p (\\<lambda>s. callee1 s x)) =\n    fst ` set_spmf (bind_spmf q (\\<lambda>s. callee2 s x))", "using trace_callee_eqD[OF sim(1) _ sim(2), where xs=\"[]\", THEN arg_cong[where f=\"set_spmf\"]]"], ["proof (prove)\nusing this:\n  set [] \\<subseteq> A \\<times> UNIV \\<Longrightarrow>\n  set_spmf (trace_callee callee1 p [] x) =\n  set_spmf (trace_callee callee2 q [] x)\n\ngoal (1 subgoal):\n 1. fst ` set_spmf (bind_spmf p (\\<lambda>s. callee1 s x)) =\n    fst ` set_spmf (bind_spmf q (\\<lambda>s. callee2 s x))", "by(auto simp add: bind_UNION image_UN del: equalityI)"], ["proof (state)\nthis:\n  fst ` set_spmf (bind_spmf p (\\<lambda>s. callee1 s x)) =\n  fst ` set_spmf (bind_spmf q (\\<lambda>s. callee2 s x))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       ye = OK x2 \\<Longrightarrow>\n       (\\<exists>p q.\n           cond_spmf_fst\n            (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n              (\\<lambda>s. obsf_oracle callee1 s x))\n            ye =\n           TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n           cond_spmf_fst\n            (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n              (\\<lambda>s. obsf_oracle callee2 s x))\n            ye =\n           TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n           trace_callee_eq callee1 callee2 A p q) \\<or>\n       trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n        (cond_spmf_fst\n          (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n            (\\<lambda>s. obsf_oracle callee1 s x))\n          ye)\n        (cond_spmf_fst\n          (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n            (\\<lambda>s. obsf_oracle callee2 s x))\n          ye)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>p q.\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee1 s x))\n         ye =\n        TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee2 s x))\n         ye =\n        TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n        trace_callee_eq callee1 callee2 A p q) \\<or>\n    trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye)\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye)", "proof(cases \"y \\<in> fst ` set_spmf (bind_spmf p (\\<lambda>s. callee1 s x))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<in> fst `\n            set_spmf\n             (bind_spmf p (\\<lambda>s. callee1 s x)) \\<Longrightarrow>\n    (\\<exists>p q.\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee1 s x))\n         ye =\n        TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee2 s x))\n         ye =\n        TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n        trace_callee_eq callee1 callee2 A p q) \\<or>\n    trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye)\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye)\n 2. y \\<notin> fst `\n               set_spmf\n                (bind_spmf p (\\<lambda>s. callee1 s x)) \\<Longrightarrow>\n    (\\<exists>p q.\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee1 s x))\n         ye =\n        TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee2 s x))\n         ye =\n        TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n        trace_callee_eq callee1 callee2 A p q) \\<or>\n    trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye)\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye)", "case True"], ["proof (state)\nthis:\n  y \\<in> fst ` set_spmf (bind_spmf p (\\<lambda>s. callee1 s x))\n\ngoal (2 subgoals):\n 1. y \\<in> fst `\n            set_spmf\n             (bind_spmf p (\\<lambda>s. callee1 s x)) \\<Longrightarrow>\n    (\\<exists>p q.\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee1 s x))\n         ye =\n        TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee2 s x))\n         ye =\n        TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n        trace_callee_eq callee1 callee2 A p q) \\<or>\n    trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye)\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye)\n 2. y \\<notin> fst `\n               set_spmf\n                (bind_spmf p (\\<lambda>s. callee1 s x)) \\<Longrightarrow>\n    (\\<exists>p q.\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee1 s x))\n         ye =\n        TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee2 s x))\n         ye =\n        TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n        trace_callee_eq callee1 callee2 A p q) \\<or>\n    trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye)\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye)", "have eq4: \"cond_spmf_fst (bind_spmf p (\\<lambda>s. map_spmf (apfst OK) (callee1 s x))) (OK y) = cond_spmf_fst (bind_spmf p (\\<lambda>s. callee1 s x)) y\"\n        \"cond_spmf_fst (bind_spmf q (\\<lambda>s. map_spmf (apfst OK) (callee2 s x))) (OK y) = cond_spmf_fst (bind_spmf q (\\<lambda>s. callee2 s x)) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf_fst\n     (bind_spmf p (\\<lambda>s. map_spmf (apfst OK) (callee1 s x))) (OK y) =\n    cond_spmf_fst (bind_spmf p (\\<lambda>s. callee1 s x)) y &&&\n    cond_spmf_fst\n     (bind_spmf q (\\<lambda>s. map_spmf (apfst OK) (callee2 s x))) (OK y) =\n    cond_spmf_fst (bind_spmf q (\\<lambda>s. callee2 s x)) y", "by(fold map_bind_spmf[unfolded o_def])(simp_all add: cond_spmf_fst_map_inj)"], ["proof (state)\nthis:\n  cond_spmf_fst\n   (bind_spmf p (\\<lambda>s. map_spmf (apfst OK) (callee1 s x))) (OK y) =\n  cond_spmf_fst (bind_spmf p (\\<lambda>s. callee1 s x)) y\n  cond_spmf_fst\n   (bind_spmf q (\\<lambda>s. map_spmf (apfst OK) (callee2 s x))) (OK y) =\n  cond_spmf_fst (bind_spmf q (\\<lambda>s. callee2 s x)) y\n\ngoal (2 subgoals):\n 1. y \\<in> fst `\n            set_spmf\n             (bind_spmf p (\\<lambda>s. callee1 s x)) \\<Longrightarrow>\n    (\\<exists>p q.\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee1 s x))\n         ye =\n        TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee2 s x))\n         ye =\n        TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n        trace_callee_eq callee1 callee2 A p q) \\<or>\n    trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye)\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye)\n 2. y \\<notin> fst `\n               set_spmf\n                (bind_spmf p (\\<lambda>s. callee1 s x)) \\<Longrightarrow>\n    (\\<exists>p q.\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee1 s x))\n         ye =\n        TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee2 s x))\n         ye =\n        TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n        trace_callee_eq callee1 callee2 A p q) \\<or>\n    trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye)\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye)", "have ?sim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p q.\n       cond_spmf_fst\n        (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n          (\\<lambda>s. obsf_oracle callee1 s x))\n        ye =\n       TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n       cond_spmf_fst\n        (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n          (\\<lambda>s. obsf_oracle callee2 s x))\n        ye =\n       TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n       trace_callee_eq callee1 callee2 A p q", "unfolding eq1 eq2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p q.\n       cond_spmf_fst\n        (TRY bind_spmf p\n              (\\<lambda>s.\n                  map_spmf (map_prod OK OK)\n                   (callee1 s x)) ELSE return_spmf (Fault, Fault))\n        ye =\n       TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n       cond_spmf_fst\n        (TRY bind_spmf q\n              (\\<lambda>s.\n                  map_spmf (map_prod OK OK)\n                   (callee2 s x)) ELSE return_spmf (Fault, Fault))\n        ye =\n       TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n       trace_callee_eq callee1 callee2 A p q", "apply(subst (1 2) cond_spmf_fst_try1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>qb pb. ye \\<notin> fst ` set_spmf (return_spmf (Fault, Fault))\n 2. \\<And>qb pb. ye \\<notin> fst ` set_spmf (return_spmf (Fault, Fault))\n 3. \\<exists>p q.\n       cond_spmf_fst\n        (bind_spmf p (\\<lambda>s. map_spmf (map_prod OK OK) (callee1 s x)))\n        ye =\n       TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n       cond_spmf_fst\n        (bind_spmf q (\\<lambda>s. map_spmf (map_prod OK OK) (callee2 s x)))\n        ye =\n       TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n       trace_callee_eq callee1 callee2 A p q", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>qb pb. ye \\<notin> fst ` set_spmf (return_spmf (Fault, Fault))\n 2. \\<exists>p q.\n       cond_spmf_fst\n        (bind_spmf p (\\<lambda>s. map_spmf (map_prod OK OK) (callee1 s x)))\n        ye =\n       TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n       cond_spmf_fst\n        (bind_spmf q (\\<lambda>s. map_spmf (map_prod OK OK) (callee2 s x)))\n        ye =\n       TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n       trace_callee_eq callee1 callee2 A p q", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p q.\n       cond_spmf_fst\n        (bind_spmf p (\\<lambda>s. map_spmf (map_prod OK OK) (callee1 s x)))\n        ye =\n       TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n       cond_spmf_fst\n        (bind_spmf q (\\<lambda>s. map_spmf (map_prod OK OK) (callee2 s x)))\n        ye =\n       TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n       trace_callee_eq callee1 callee2 A p q", "apply(rule exI[where x=\"cond_spmf_fst (bind_spmf p (\\<lambda>s. map_spmf (apfst OK) (callee1 s x))) ye\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q.\n       cond_spmf_fst\n        (bind_spmf p (\\<lambda>s. map_spmf (map_prod OK OK) (callee1 s x)))\n        ye =\n       TRY map_spmf OK\n            (cond_spmf_fst\n              (bind_spmf p (\\<lambda>s. map_spmf (apfst OK) (callee1 s x)))\n              ye) ELSE return_spmf Fault \\<and>\n       cond_spmf_fst\n        (bind_spmf q (\\<lambda>s. map_spmf (map_prod OK OK) (callee2 s x)))\n        ye =\n       TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n       trace_callee_eq callee1 callee2 A\n        (cond_spmf_fst\n          (bind_spmf p (\\<lambda>s. map_spmf (apfst OK) (callee1 s x))) ye)\n        q", "apply(rule exI[where x=\"cond_spmf_fst (bind_spmf q (\\<lambda>s. map_spmf (apfst OK) (callee2 s x))) ye\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf_fst\n     (bind_spmf p (\\<lambda>s. map_spmf (map_prod OK OK) (callee1 s x)))\n     ye =\n    TRY map_spmf OK\n         (cond_spmf_fst\n           (bind_spmf p (\\<lambda>s. map_spmf (apfst OK) (callee1 s x)))\n           ye) ELSE return_spmf Fault \\<and>\n    cond_spmf_fst\n     (bind_spmf q (\\<lambda>s. map_spmf (map_prod OK OK) (callee2 s x)))\n     ye =\n    TRY map_spmf OK\n         (cond_spmf_fst\n           (bind_spmf q (\\<lambda>s. map_spmf (apfst OK) (callee2 s x)))\n           ye) ELSE return_spmf Fault \\<and>\n    trace_callee_eq callee1 callee2 A\n     (cond_spmf_fst\n       (bind_spmf p (\\<lambda>s. map_spmf (apfst OK) (callee1 s x))) ye)\n     (cond_spmf_fst\n       (bind_spmf q (\\<lambda>s. map_spmf (apfst OK) (callee2 s x))) ye)", "apply(subst (1 2) try_spmf_lossless)"], ["proof (prove)\ngoal (3 subgoals):\n 1. lossless_spmf\n     (map_spmf OK\n       (cond_spmf_fst\n         (bind_spmf q (\\<lambda>s. map_spmf (apfst OK) (callee2 s x))) ye))\n 2. lossless_spmf\n     (map_spmf OK\n       (cond_spmf_fst\n         (bind_spmf p (\\<lambda>s. map_spmf (apfst OK) (callee1 s x))) ye))\n 3. cond_spmf_fst\n     (bind_spmf p (\\<lambda>s. map_spmf (map_prod OK OK) (callee1 s x)))\n     ye =\n    map_spmf OK\n     (cond_spmf_fst\n       (bind_spmf p (\\<lambda>s. map_spmf (apfst OK) (callee1 s x)))\n       ye) \\<and>\n    cond_spmf_fst\n     (bind_spmf q (\\<lambda>s. map_spmf (map_prod OK OK) (callee2 s x)))\n     ye =\n    map_spmf OK\n     (cond_spmf_fst\n       (bind_spmf q (\\<lambda>s. map_spmf (apfst OK) (callee2 s x)))\n       ye) \\<and>\n    trace_callee_eq callee1 callee2 A\n     (cond_spmf_fst\n       (bind_spmf p (\\<lambda>s. map_spmf (apfst OK) (callee1 s x))) ye)\n     (cond_spmf_fst\n       (bind_spmf q (\\<lambda>s. map_spmf (apfst OK) (callee2 s x))) ye)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf\n     (map_spmf OK\n       (cond_spmf_fst\n         (bind_spmf q (\\<lambda>s. map_spmf (apfst OK) (callee2 s x))) ye))", "using True"], ["proof (prove)\nusing this:\n  y \\<in> fst ` set_spmf (bind_spmf p (\\<lambda>s. callee1 s x))\n\ngoal (1 subgoal):\n 1. lossless_spmf\n     (map_spmf OK\n       (cond_spmf_fst\n         (bind_spmf q (\\<lambda>s. map_spmf (apfst OK) (callee2 s x))) ye))", "unfolding eq3"], ["proof (prove)\nusing this:\n  y \\<in> fst ` set_spmf (bind_spmf q (\\<lambda>s. callee2 s x))\n\ngoal (1 subgoal):\n 1. lossless_spmf\n     (map_spmf OK\n       (cond_spmf_fst\n         (bind_spmf q (\\<lambda>s. map_spmf (apfst OK) (callee2 s x))) ye))", "by(auto simp add: bind_UNION image_UN intro!: rev_bexI rev_image_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. lossless_spmf\n     (map_spmf OK\n       (cond_spmf_fst\n         (bind_spmf p (\\<lambda>s. map_spmf (apfst OK) (callee1 s x))) ye))\n 2. cond_spmf_fst\n     (bind_spmf p (\\<lambda>s. map_spmf (map_prod OK OK) (callee1 s x)))\n     ye =\n    map_spmf OK\n     (cond_spmf_fst\n       (bind_spmf p (\\<lambda>s. map_spmf (apfst OK) (callee1 s x)))\n       ye) \\<and>\n    cond_spmf_fst\n     (bind_spmf q (\\<lambda>s. map_spmf (map_prod OK OK) (callee2 s x)))\n     ye =\n    map_spmf OK\n     (cond_spmf_fst\n       (bind_spmf q (\\<lambda>s. map_spmf (apfst OK) (callee2 s x)))\n       ye) \\<and>\n    trace_callee_eq callee1 callee2 A\n     (cond_spmf_fst\n       (bind_spmf p (\\<lambda>s. map_spmf (apfst OK) (callee1 s x))) ye)\n     (cond_spmf_fst\n       (bind_spmf q (\\<lambda>s. map_spmf (apfst OK) (callee2 s x))) ye)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf\n     (map_spmf OK\n       (cond_spmf_fst\n         (bind_spmf p (\\<lambda>s. map_spmf (apfst OK) (callee1 s x))) ye))", "using True"], ["proof (prove)\nusing this:\n  y \\<in> fst ` set_spmf (bind_spmf p (\\<lambda>s. callee1 s x))\n\ngoal (1 subgoal):\n 1. lossless_spmf\n     (map_spmf OK\n       (cond_spmf_fst\n         (bind_spmf p (\\<lambda>s. map_spmf (apfst OK) (callee1 s x))) ye))", "by(auto simp add: bind_UNION image_UN intro!: rev_bexI rev_image_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf_fst\n     (bind_spmf p (\\<lambda>s. map_spmf (map_prod OK OK) (callee1 s x)))\n     ye =\n    map_spmf OK\n     (cond_spmf_fst\n       (bind_spmf p (\\<lambda>s. map_spmf (apfst OK) (callee1 s x)))\n       ye) \\<and>\n    cond_spmf_fst\n     (bind_spmf q (\\<lambda>s. map_spmf (map_prod OK OK) (callee2 s x)))\n     ye =\n    map_spmf OK\n     (cond_spmf_fst\n       (bind_spmf q (\\<lambda>s. map_spmf (apfst OK) (callee2 s x)))\n       ye) \\<and>\n    trace_callee_eq callee1 callee2 A\n     (cond_spmf_fst\n       (bind_spmf p (\\<lambda>s. map_spmf (apfst OK) (callee1 s x))) ye)\n     (cond_spmf_fst\n       (bind_spmf q (\\<lambda>s. map_spmf (apfst OK) (callee2 s x))) ye)", "apply(simp add: map_cond_spmf_fst map_bind_spmf o_def spmf.map_comp map_prod_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee_eq callee1 callee2 A\n     (cond_spmf_fst\n       (bind_spmf p (\\<lambda>s. map_spmf (apfst OK) (callee1 s x))) (OK y))\n     (cond_spmf_fst\n       (bind_spmf q (\\<lambda>s. map_spmf (apfst OK) (callee2 s x))) (OK y))", "apply(simp add: eq4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee_eq callee1 callee2 A\n     (cond_spmf_fst (bind_spmf p (\\<lambda>s. callee1 s x)) y)\n     (cond_spmf_fst (bind_spmf q (\\<lambda>s. callee2 s x)) y)", "apply(rule trace_callee_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs xa.\n       \\<lbrakk>set xs \\<subseteq> A \\<times> UNIV; xa \\<in> A\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1\n                          (cond_spmf_fst\n                            (bind_spmf p (\\<lambda>s. callee1 s x)) y)\n                          xs xa =\n                         trace_callee callee2\n                          (cond_spmf_fst\n                            (bind_spmf q (\\<lambda>s. callee2 s x)) y)\n                          xs xa", "subgoal for xs z"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set xs \\<subseteq> A \\<times> UNIV; z \\<in> A\\<rbrakk>\n    \\<Longrightarrow> trace_callee callee1\n                       (cond_spmf_fst\n                         (bind_spmf p (\\<lambda>s. callee1 s x)) y)\n                       xs z =\n                      trace_callee callee2\n                       (cond_spmf_fst\n                         (bind_spmf q (\\<lambda>s. callee2 s x)) y)\n                       xs z", "using sim(1)[THEN trace_callee_eqD[where xs=\"(x, y) # xs\" and x=z]] sim(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ((x, y) # xs) \\<subseteq> A \\<times> UNIV; z \\<in> A\\<rbrakk>\n  \\<Longrightarrow> trace_callee callee1 p ((x, y) # xs) z =\n                    trace_callee callee2 q ((x, y) # xs) z\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>set xs \\<subseteq> A \\<times> UNIV; z \\<in> A\\<rbrakk>\n    \\<Longrightarrow> trace_callee callee1\n                       (cond_spmf_fst\n                         (bind_spmf p (\\<lambda>s. callee1 s x)) y)\n                       xs z =\n                      trace_callee callee2\n                       (cond_spmf_fst\n                         (bind_spmf q (\\<lambda>s. callee2 s x)) y)\n                       xs z", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>p q.\n     cond_spmf_fst\n      (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n        (\\<lambda>s. obsf_oracle callee1 s x))\n      ye =\n     TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n     cond_spmf_fst\n      (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n        (\\<lambda>s. obsf_oracle callee2 s x))\n      ye =\n     TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n     trace_callee_eq callee1 callee2 A p q\n\ngoal (2 subgoals):\n 1. y \\<in> fst `\n            set_spmf\n             (bind_spmf p (\\<lambda>s. callee1 s x)) \\<Longrightarrow>\n    (\\<exists>p q.\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee1 s x))\n         ye =\n        TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee2 s x))\n         ye =\n        TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n        trace_callee_eq callee1 callee2 A p q) \\<or>\n    trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye)\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye)\n 2. y \\<notin> fst `\n               set_spmf\n                (bind_spmf p (\\<lambda>s. callee1 s x)) \\<Longrightarrow>\n    (\\<exists>p q.\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee1 s x))\n         ye =\n        TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee2 s x))\n         ye =\n        TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n        trace_callee_eq callee1 callee2 A p q) \\<or>\n    trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye)\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye)", "then"], ["proof (chain)\npicking this:\n  \\<exists>p q.\n     cond_spmf_fst\n      (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n        (\\<lambda>s. obsf_oracle callee1 s x))\n      ye =\n     TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n     cond_spmf_fst\n      (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n        (\\<lambda>s. obsf_oracle callee2 s x))\n      ye =\n     TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n     trace_callee_eq callee1 callee2 A p q", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>p q.\n     cond_spmf_fst\n      (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n        (\\<lambda>s. obsf_oracle callee1 s x))\n      ye =\n     TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n     cond_spmf_fst\n      (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n        (\\<lambda>s. obsf_oracle callee2 s x))\n      ye =\n     TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n     trace_callee_eq callee1 callee2 A p q\n\ngoal (1 subgoal):\n 1. (\\<exists>p q.\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee1 s x))\n         ye =\n        TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee2 s x))\n         ye =\n        TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n        trace_callee_eq callee1 callee2 A p q) \\<or>\n    trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye)\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye)", ".."], ["proof (state)\nthis:\n  (\\<exists>p q.\n      cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye =\n      TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n      cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye =\n      TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n      trace_callee_eq callee1 callee2 A p q) \\<or>\n  trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n   (cond_spmf_fst\n     (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n       (\\<lambda>s. obsf_oracle callee1 s x))\n     ye)\n   (cond_spmf_fst\n     (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n       (\\<lambda>s. obsf_oracle callee2 s x))\n     ye)\n\ngoal (1 subgoal):\n 1. y \\<notin> fst `\n               set_spmf\n                (bind_spmf p (\\<lambda>s. callee1 s x)) \\<Longrightarrow>\n    (\\<exists>p q.\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee1 s x))\n         ye =\n        TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee2 s x))\n         ye =\n        TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n        trace_callee_eq callee1 callee2 A p q) \\<or>\n    trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye)\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<notin> fst `\n               set_spmf\n                (bind_spmf p (\\<lambda>s. callee1 s x)) \\<Longrightarrow>\n    (\\<exists>p q.\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee1 s x))\n         ye =\n        TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee2 s x))\n         ye =\n        TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n        trace_callee_eq callee1 callee2 A p q) \\<or>\n    trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye)\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye)", "case False"], ["proof (state)\nthis:\n  y \\<notin> fst ` set_spmf (bind_spmf p (\\<lambda>s. callee1 s x))\n\ngoal (1 subgoal):\n 1. y \\<notin> fst `\n               set_spmf\n                (bind_spmf p (\\<lambda>s. callee1 s x)) \\<Longrightarrow>\n    (\\<exists>p q.\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee1 s x))\n         ye =\n        TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee2 s x))\n         ye =\n        TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n        trace_callee_eq callee1 callee2 A p q) \\<or>\n    trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye)\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye)", "with eq3"], ["proof (chain)\npicking this:\n  fst ` set_spmf (bind_spmf p (\\<lambda>s. callee1 s x)) =\n  fst ` set_spmf (bind_spmf q (\\<lambda>s. callee2 s x))\n  y \\<notin> fst ` set_spmf (bind_spmf p (\\<lambda>s. callee1 s x))", "have \"y \\<notin> fst ` set_spmf (bind_spmf q (\\<lambda>s. callee2 s x))\""], ["proof (prove)\nusing this:\n  fst ` set_spmf (bind_spmf p (\\<lambda>s. callee1 s x)) =\n  fst ` set_spmf (bind_spmf q (\\<lambda>s. callee2 s x))\n  y \\<notin> fst ` set_spmf (bind_spmf p (\\<lambda>s. callee1 s x))\n\ngoal (1 subgoal):\n 1. y \\<notin> fst ` set_spmf (bind_spmf q (\\<lambda>s. callee2 s x))", "by auto"], ["proof (state)\nthis:\n  y \\<notin> fst ` set_spmf (bind_spmf q (\\<lambda>s. callee2 s x))\n\ngoal (1 subgoal):\n 1. y \\<notin> fst `\n               set_spmf\n                (bind_spmf p (\\<lambda>s. callee1 s x)) \\<Longrightarrow>\n    (\\<exists>p q.\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee1 s x))\n         ye =\n        TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee2 s x))\n         ye =\n        TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n        trace_callee_eq callee1 callee2 A p q) \\<or>\n    trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye)\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye)", "with False"], ["proof (chain)\npicking this:\n  y \\<notin> fst ` set_spmf (bind_spmf p (\\<lambda>s. callee1 s x))\n  y \\<notin> fst ` set_spmf (bind_spmf q (\\<lambda>s. callee2 s x))", "have ?eq"], ["proof (prove)\nusing this:\n  y \\<notin> fst ` set_spmf (bind_spmf p (\\<lambda>s. callee1 s x))\n  y \\<notin> fst ` set_spmf (bind_spmf q (\\<lambda>s. callee2 s x))\n\ngoal (1 subgoal):\n 1. trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye)\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<notin> fst `\n                        Set.bind (set_spmf p)\n                         (set_spmf \\<circ> (\\<lambda>s. callee1 s x));\n     y \\<notin> fst `\n                Set.bind (set_spmf q)\n                 (set_spmf \\<circ> (\\<lambda>s. callee2 s x))\\<rbrakk>\n    \\<Longrightarrow> trace_callee_eq (obsf_oracle callee1)\n                       (obsf_oracle callee2) A\n                       (cond_spmf_fst\n                         (bind_spmf\n                           (TRY map_spmf OK p ELSE return_spmf Fault)\n                           (\\<lambda>s. obsf_oracle callee1 s x))\n                         (OK y))\n                       (cond_spmf_fst\n                         (bind_spmf\n                           (TRY map_spmf OK q ELSE return_spmf Fault)\n                           (\\<lambda>s. obsf_oracle callee2 s x))\n                         (OK y))", "apply(subst (1 2) cond_spmf_fst_eq_return_None[THEN iffD2])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>y \\<notin> fst `\n                        Set.bind (set_spmf p)\n                         (set_spmf \\<circ> (\\<lambda>s. callee1 s x));\n     y \\<notin> fst `\n                Set.bind (set_spmf q)\n                 (set_spmf \\<circ> (\\<lambda>s. callee2 s x))\\<rbrakk>\n    \\<Longrightarrow> OK y\n                      \\<notin> fst `\n                               set_spmf\n                                (bind_spmf\n                                  (TRY map_spmf OK q ELSE return_spmf Fault)\n                                  (\\<lambda>s. obsf_oracle callee2 s x))\n 2. \\<lbrakk>y \\<notin> fst `\n                        Set.bind (set_spmf p)\n                         (set_spmf \\<circ> (\\<lambda>s. callee1 s x));\n     y \\<notin> fst `\n                Set.bind (set_spmf q)\n                 (set_spmf \\<circ> (\\<lambda>s. callee2 s x))\\<rbrakk>\n    \\<Longrightarrow> OK y\n                      \\<notin> fst `\n                               set_spmf\n                                (bind_spmf\n                                  (TRY map_spmf OK p ELSE return_spmf Fault)\n                                  (\\<lambda>s. obsf_oracle callee1 s x))\n 3. \\<lbrakk>y \\<notin> fst `\n                        Set.bind (set_spmf p)\n                         (set_spmf \\<circ> (\\<lambda>s. callee1 s x));\n     y \\<notin> fst `\n                Set.bind (set_spmf q)\n                 (set_spmf \\<circ> (\\<lambda>s. callee2 s x))\\<rbrakk>\n    \\<Longrightarrow> trace_callee_eq (obsf_oracle callee1)\n                       (obsf_oracle callee2) A (return_pmf None)\n                       (return_pmf None)", "apply(auto simp add: bind_UNION split: if_split_asm intro: rev_image_eqI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n   (cond_spmf_fst\n     (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n       (\\<lambda>s. obsf_oracle callee1 s x))\n     ye)\n   (cond_spmf_fst\n     (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n       (\\<lambda>s. obsf_oracle callee2 s x))\n     ye)\n\ngoal (1 subgoal):\n 1. y \\<notin> fst `\n               set_spmf\n                (bind_spmf p (\\<lambda>s. callee1 s x)) \\<Longrightarrow>\n    (\\<exists>p q.\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee1 s x))\n         ye =\n        TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee2 s x))\n         ye =\n        TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n        trace_callee_eq callee1 callee2 A p q) \\<or>\n    trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye)\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye)", "then"], ["proof (chain)\npicking this:\n  trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n   (cond_spmf_fst\n     (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n       (\\<lambda>s. obsf_oracle callee1 s x))\n     ye)\n   (cond_spmf_fst\n     (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n       (\\<lambda>s. obsf_oracle callee2 s x))\n     ye)", "show ?thesis"], ["proof (prove)\nusing this:\n  trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n   (cond_spmf_fst\n     (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n       (\\<lambda>s. obsf_oracle callee1 s x))\n     ye)\n   (cond_spmf_fst\n     (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n       (\\<lambda>s. obsf_oracle callee2 s x))\n     ye)\n\ngoal (1 subgoal):\n 1. (\\<exists>p q.\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee1 s x))\n         ye =\n        TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n        cond_spmf_fst\n         (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n           (\\<lambda>s. obsf_oracle callee2 s x))\n         ye =\n        TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n        trace_callee_eq callee1 callee2 A p q) \\<or>\n    trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye)\n     (cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye)", ".."], ["proof (state)\nthis:\n  (\\<exists>p q.\n      cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye =\n      TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n      cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye =\n      TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n      trace_callee_eq callee1 callee2 A p q) \\<or>\n  trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n   (cond_spmf_fst\n     (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n       (\\<lambda>s. obsf_oracle callee1 s x))\n     ye)\n   (cond_spmf_fst\n     (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n       (\\<lambda>s. obsf_oracle callee2 s x))\n     ye)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>p q.\n      cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye =\n      TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n      cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye =\n      TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n      trace_callee_eq callee1 callee2 A p q) \\<or>\n  trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n   (cond_spmf_fst\n     (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n       (\\<lambda>s. obsf_oracle callee1 s x))\n     ye)\n   (cond_spmf_fst\n     (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n       (\\<lambda>s. obsf_oracle callee2 s x))\n     ye)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>p q.\n      cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee1 s x))\n       ye =\n      TRY map_spmf OK p ELSE return_spmf Fault \\<and>\n      cond_spmf_fst\n       (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n         (\\<lambda>s. obsf_oracle callee2 s x))\n       ye =\n      TRY map_spmf OK q ELSE return_spmf Fault \\<and>\n      trace_callee_eq callee1 callee2 A p q) \\<or>\n  trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n   (cond_spmf_fst\n     (bind_spmf (TRY map_spmf OK p ELSE return_spmf Fault)\n       (\\<lambda>s. obsf_oracle callee1 s x))\n     ye)\n   (cond_spmf_fst\n     (bind_spmf (TRY map_spmf OK q ELSE return_spmf Fault)\n       (\\<lambda>s. obsf_oracle callee2 s x))\n     ye)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_callee_eq'_obsf_resourceI:\n  assumes \" A \\<turnstile>\\<^sub>C callee1(s) \\<approx> callee2(s')\"\n  shows \"A \\<turnstile>\\<^sub>C obsf_oracle callee1(OK s) \\<approx> obsf_oracle callee2(OK s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>C obsf_oracle callee1(OK s) \\<approx>\n    obsf_oracle callee2(OK s')", "using assms[THEN trace_callee_eq_obsf_oracleI]"], ["proof (prove)\nusing this:\n  trace_callee_eq (obsf_oracle callee1) (obsf_oracle callee2) A\n   (TRY map_spmf OK (return_spmf s) ELSE return_spmf Fault)\n   (TRY map_spmf OK (return_spmf s') ELSE return_spmf Fault)\n\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>C obsf_oracle callee1(OK s) \\<approx>\n    obsf_oracle callee2(OK s')", "by simp"], ["", "lemma trace_eq_obsf_resourceI:\n  assumes \"A \\<turnstile>\\<^sub>R res1 \\<approx> res2\"\n  shows \"A \\<turnstile>\\<^sub>R obsf_resource res1 \\<approx> obsf_resource res2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>R obsf_resource res1 \\<approx> obsf_resource res2", "using assms"], ["proof (prove)\nusing this:\n  A \\<turnstile>\\<^sub>R res1 \\<approx> res2\n\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>R obsf_resource res1 \\<approx> obsf_resource res2", "apply(subst (2 4) resource_of_oracle_run_resource[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>R res1 \\<approx> res2 \\<Longrightarrow>\n    A \\<turnstile>\\<^sub>R obsf_resource (RES run_resource res1)\n    \\<approx> obsf_resource (RES run_resource res2)", "apply(subst (asm) (1 2) resource_of_oracle_run_resource[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>R RES run_resource res1\n    \\<approx> RES run_resource res2 \\<Longrightarrow>\n    A \\<turnstile>\\<^sub>R obsf_resource (RES run_resource res1)\n    \\<approx> obsf_resource (RES run_resource res2)", "apply(drule trace_callee_eq'_obsf_resourceI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>C\n    obsf_oracle run_resource(OK (RES run_resource res1)) \\<approx>\n    obsf_oracle run_resource(OK (RES run_resource res2)) \\<Longrightarrow>\n    A \\<turnstile>\\<^sub>R obsf_resource (RES run_resource res1)\n    \\<approx> obsf_resource (RES run_resource res2)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>C\n    obsf_oracle run_resource(OK (RES run_resource res1)) \\<approx>\n    obsf_oracle run_resource(OK (RES run_resource res2)) \\<Longrightarrow>\n    A \\<turnstile>\\<^sub>C obsf_oracle run_resource(OK res1) \\<approx>\n    obsf_oracle run_resource(OK res2)", "apply(simp add: resource_of_oracle_run_resource)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma spmf_run_obsf_oracle_obsf_distinguisher [rule_format]:\n  defines \"eg1 \\<equiv> exec_gpv\" and \"eg2 \\<equiv> exec_gpv\" shows\n  \"spmf (map_spmf fst (eg1 (obsf_oracle oracle) (obsf_distinguisher gpv) (OK s))) True =\n   spmf (map_spmf fst (eg2 oracle gpv s)) True\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf fst\n       (eg1 (obsf_oracle oracle) (obsf_distinguisher gpv) (OK s)))\n     True =\n    spmf (map_spmf fst (eg2 oracle gpv s)) True", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. spmf\n     (map_spmf fst\n       (eg1 (obsf_oracle oracle) (obsf_distinguisher gpv) (OK s)))\n     True\n    \\<le> spmf (map_spmf fst (eg2 oracle gpv s)) True\n 2. spmf (map_spmf fst (eg2 oracle gpv s)) True\n    \\<le> spmf\n           (map_spmf fst\n             (eg1 (obsf_oracle oracle) (obsf_distinguisher gpv) (OK s)))\n           True", "show \"?lhs \\<le> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf fst\n       (eg1 (obsf_oracle oracle) (obsf_distinguisher gpv) (OK s)))\n     True\n    \\<le> spmf (map_spmf fst (eg2 oracle gpv s)) True", "unfolding eg1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (run_gpv (obsf_oracle oracle) (obsf_distinguisher gpv) (OK s)) True\n    \\<le> spmf (map_spmf fst (eg2 oracle gpv s)) True", "proof(induction arbitrary: gpv s rule: exec_gpv_fixp_induct_strong)"], ["proof (state)\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>f.\n         \\<forall>x xa.\n            spmf (map_spmf fst (f (obsf_distinguisher x, OK xa))) True\n            \\<le> spmf (map_spmf fst (eg2 oracle x xa)) True)\n 2. \\<And>gpv s.\n       spmf (map_spmf fst (return_pmf None)) True\n       \\<le> spmf (map_spmf fst (eg2 oracle gpv s)) True\n 3. \\<And>exec_gpv' gpv s.\n       \\<lbrakk>\\<And>c s.\n                   ord_spmf (=) (exec_gpv' c s)\n                    (exec_gpv (obsf_oracle oracle) c s);\n        \\<And>gpv s.\n           spmf (map_spmf fst (exec_gpv' (obsf_distinguisher gpv) (OK s)))\n            True\n           \\<le> spmf (map_spmf fst (eg2 oracle gpv s)) True\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf fst\n                            (bind_spmf (the_gpv (obsf_distinguisher gpv))\n                              (case_generat\n                                (\\<lambda>x. return_spmf (x, OK s))\n                                (\\<lambda>out c.\n                                    bind_spmf\n                                     (obsf_oracle oracle (OK s) out)\n                                     (\\<lambda>(x, y).\n   exec_gpv' (c x) y)))))\n                          True\n                         \\<le> spmf (map_spmf fst (eg2 oracle gpv s)) True", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>f.\n         \\<forall>x xa.\n            spmf (map_spmf fst (f (obsf_distinguisher x, OK xa))) True\n            \\<le> spmf (map_spmf fst (eg2 oracle x xa)) True)\n 2. \\<And>gpv s.\n       spmf (map_spmf fst (return_pmf None)) True\n       \\<le> spmf (map_spmf fst (eg2 oracle gpv s)) True\n 3. \\<And>exec_gpv' gpv s.\n       \\<lbrakk>\\<And>c s.\n                   ord_spmf (=) (exec_gpv' c s)\n                    (exec_gpv (obsf_oracle oracle) c s);\n        \\<And>gpv s.\n           spmf (map_spmf fst (exec_gpv' (obsf_distinguisher gpv) (OK s)))\n            True\n           \\<le> spmf (map_spmf fst (eg2 oracle gpv s)) True\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf fst\n                            (bind_spmf (the_gpv (obsf_distinguisher gpv))\n                              (case_generat\n                                (\\<lambda>x. return_spmf (x, OK s))\n                                (\\<lambda>out c.\n                                    bind_spmf\n                                     (obsf_oracle oracle (OK s) out)\n                                     (\\<lambda>(x, y).\n   exec_gpv' (c x) y)))))\n                          True\n                         \\<le> spmf (map_spmf fst (eg2 oracle gpv s)) True", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf.admissible\n     (\\<lambda>f.\n         \\<forall>x xa.\n            spmf (map_spmf fst (f (obsf_distinguisher x, OK xa))) True\n            \\<le> spmf (map_spmf fst (eg2 oracle x xa)) True)", "by simp"], ["proof (state)\nthis:\n  spmf.admissible\n   (\\<lambda>f.\n       \\<forall>x xa.\n          spmf (map_spmf fst (f (obsf_distinguisher x, OK xa))) True\n          \\<le> spmf (map_spmf fst (eg2 oracle x xa)) True)\n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       spmf (map_spmf fst (return_pmf None)) True\n       \\<le> spmf (map_spmf fst (eg2 oracle gpv s)) True\n 2. \\<And>exec_gpv' gpv s.\n       \\<lbrakk>\\<And>c s.\n                   ord_spmf (=) (exec_gpv' c s)\n                    (exec_gpv (obsf_oracle oracle) c s);\n        \\<And>gpv s.\n           spmf (map_spmf fst (exec_gpv' (obsf_distinguisher gpv) (OK s)))\n            True\n           \\<le> spmf (map_spmf fst (eg2 oracle gpv s)) True\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf fst\n                            (bind_spmf (the_gpv (obsf_distinguisher gpv))\n                              (case_generat\n                                (\\<lambda>x. return_spmf (x, OK s))\n                                (\\<lambda>out c.\n                                    bind_spmf\n                                     (obsf_oracle oracle (OK s) out)\n                                     (\\<lambda>(x, y).\n   exec_gpv' (c x) y)))))\n                          True\n                         \\<le> spmf (map_spmf fst (eg2 oracle gpv s)) True", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       spmf (map_spmf fst (return_pmf None)) True\n       \\<le> spmf (map_spmf fst (eg2 oracle gpv s)) True\n 2. \\<And>exec_gpv' gpv s.\n       \\<lbrakk>\\<And>c s.\n                   ord_spmf (=) (exec_gpv' c s)\n                    (exec_gpv (obsf_oracle oracle) c s);\n        \\<And>gpv s.\n           spmf (map_spmf fst (exec_gpv' (obsf_distinguisher gpv) (OK s)))\n            True\n           \\<le> spmf (map_spmf fst (eg2 oracle gpv s)) True\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf fst\n                            (bind_spmf (the_gpv (obsf_distinguisher gpv))\n                              (case_generat\n                                (\\<lambda>x. return_spmf (x, OK s))\n                                (\\<lambda>out c.\n                                    bind_spmf\n                                     (obsf_oracle oracle (OK s) out)\n                                     (\\<lambda>(x, y).\n   exec_gpv' (c x) y)))))\n                          True\n                         \\<le> spmf (map_spmf fst (eg2 oracle gpv s)) True", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (map_spmf fst (return_pmf None)) True\n    \\<le> spmf (map_spmf fst (eg2 oracle gpv s)) True", "by simp"], ["proof (state)\nthis:\n  spmf (map_spmf fst (return_pmf None)) True\n  \\<le> spmf (map_spmf fst (eg2 oracle gpv s)) True\n\ngoal (1 subgoal):\n 1. \\<And>exec_gpv' gpv s.\n       \\<lbrakk>\\<And>c s.\n                   ord_spmf (=) (exec_gpv' c s)\n                    (exec_gpv (obsf_oracle oracle) c s);\n        \\<And>gpv s.\n           spmf (map_spmf fst (exec_gpv' (obsf_distinguisher gpv) (OK s)))\n            True\n           \\<le> spmf (map_spmf fst (eg2 oracle gpv s)) True\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf fst\n                            (bind_spmf (the_gpv (obsf_distinguisher gpv))\n                              (case_generat\n                                (\\<lambda>x. return_spmf (x, OK s))\n                                (\\<lambda>out c.\n                                    bind_spmf\n                                     (obsf_oracle oracle (OK s) out)\n                                     (\\<lambda>(x, y).\n   exec_gpv' (c x) y)))))\n                          True\n                         \\<le> spmf (map_spmf fst (eg2 oracle gpv s)) True", "case (step exec_gpv')"], ["proof (state)\nthis:\n  ord_spmf (=) (exec_gpv' ?c ?s) (exec_gpv (obsf_oracle oracle) ?c ?s)\n  spmf (map_spmf fst (exec_gpv' (obsf_distinguisher ?gpv) (OK ?s))) True\n  \\<le> spmf (map_spmf fst (eg2 oracle ?gpv ?s)) True\n\ngoal (1 subgoal):\n 1. \\<And>exec_gpv' gpv s.\n       \\<lbrakk>\\<And>c s.\n                   ord_spmf (=) (exec_gpv' c s)\n                    (exec_gpv (obsf_oracle oracle) c s);\n        \\<And>gpv s.\n           spmf (map_spmf fst (exec_gpv' (obsf_distinguisher gpv) (OK s)))\n            True\n           \\<le> spmf (map_spmf fst (eg2 oracle gpv s)) True\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf fst\n                            (bind_spmf (the_gpv (obsf_distinguisher gpv))\n                              (case_generat\n                                (\\<lambda>x. return_spmf (x, OK s))\n                                (\\<lambda>out c.\n                                    bind_spmf\n                                     (obsf_oracle oracle (OK s) out)\n                                     (\\<lambda>(x, y).\n   exec_gpv' (c x) y)))))\n                          True\n                         \\<le> spmf (map_spmf fst (eg2 oracle gpv s)) True", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf fst\n       (bind_spmf (the_gpv (obsf_distinguisher gpv))\n         (case_generat (\\<lambda>x. return_spmf (x, OK s))\n           (\\<lambda>out c.\n               bind_spmf (obsf_oracle oracle (OK s) out)\n                (\\<lambda>(x, y). exec_gpv' (c x) y)))))\n     True\n    \\<le> spmf (map_spmf fst (eg2 oracle gpv s)) True", "unfolding eg2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf fst\n       (bind_spmf (the_gpv (obsf_distinguisher gpv))\n         (case_generat (\\<lambda>x. return_spmf (x, OK s))\n           (\\<lambda>out c.\n               bind_spmf (obsf_oracle oracle (OK s) out)\n                (\\<lambda>(x, y). exec_gpv' (c x) y)))))\n     True\n    \\<le> spmf (run_gpv oracle gpv s) True", "apply(subst exec_gpv.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf fst\n       (bind_spmf (the_gpv (obsf_distinguisher gpv))\n         (case_generat (\\<lambda>x. return_spmf (x, OK s))\n           (\\<lambda>out c.\n               bind_spmf (obsf_oracle oracle (OK s) out)\n                (\\<lambda>(x, y). exec_gpv' (c x) y)))))\n     True\n    \\<le> spmf\n           (map_spmf fst\n             (bind_spmf (the_gpv gpv)\n               (case_generat (\\<lambda>x. return_spmf (x, s))\n                 (\\<lambda>out c.\n                     bind_spmf (oracle s out)\n                      (\\<lambda>(x, y). exec_gpv oracle (c x) y)))))\n           True", "apply(clarsimp simp add: obsf_distinguisher_def bind_map_spmf map_bind_spmf o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (bind_spmf (the_gpv gpv)\n       (\\<lambda>x.\n           map_spmf fst\n            (case map_generat (\\<lambda>x. x = Some True) id\n                   (map_fun option_of_exception\n                     (map_gpv' (\\<lambda>x. x = Some True) id\n                       option_of_exception))\n                   (map_generat Some id\n                     (\\<lambda>rpv.\n                         case_option (Done None)\n                          (\\<lambda>input'. gpv_stop (rpv input')))\n                     x) of\n             Pure x \\<Rightarrow> return_spmf (x, OK s)\n             | IO out c \\<Rightarrow>\n                 bind_spmf\n                  (TRY map_spmf (map_prod OK OK)\n                        (oracle s out) ELSE return_spmf (Fault, Fault))\n                  (\\<lambda>(x, y). exec_gpv' (c x) y))))\n     True\n    \\<le> spmf\n           (bind_spmf (the_gpv gpv)\n             (\\<lambda>x.\n                 map_spmf fst\n                  (case x of Pure x \\<Rightarrow> return_spmf (x, s)\n                   | IO out c \\<Rightarrow>\n                       bind_spmf (oracle s out)\n                        (\\<lambda>(x, y). exec_gpv oracle (c x) y))))\n           True", "apply(subst (1 2) spmf_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT x|measure_spmf (the_gpv gpv).\n       spmf\n        (map_spmf fst\n          (case map_generat (\\<lambda>x. x = Some True) id\n                 (map_fun option_of_exception\n                   (map_gpv' (\\<lambda>x. x = Some True) id\n                     option_of_exception))\n                 (map_generat Some id\n                   (\\<lambda>rpv.\n                       case_option (Done None)\n                        (\\<lambda>input'. gpv_stop (rpv input')))\n                   x) of\n           Pure x \\<Rightarrow> return_spmf (x, OK s)\n           | IO out c \\<Rightarrow>\n               bind_spmf\n                (TRY map_spmf (map_prod OK OK)\n                      (oracle s out) ELSE return_spmf (Fault, Fault))\n                (\\<lambda>(x, y). exec_gpv' (c x) y)))\n        True\n    \\<le> LINT x|measure_spmf (the_gpv gpv).\n             spmf\n              (map_spmf fst\n                (case x of Pure x \\<Rightarrow> return_spmf (x, s)\n                 | IO out c \\<Rightarrow>\n                     bind_spmf (oracle s out)\n                      (\\<lambda>(x, y). exec_gpv oracle (c x) y)))\n              True", "apply(rule Bochner_Integration.integral_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. integrable (measure_spmf (the_gpv gpv))\n     (\\<lambda>x.\n         spmf\n          (map_spmf fst\n            (case map_generat (\\<lambda>x. x = Some True) id\n                   (map_fun option_of_exception\n                     (map_gpv' (\\<lambda>x. x = Some True) id\n                       option_of_exception))\n                   (map_generat Some id\n                     (\\<lambda>rpv.\n                         case_option (Done None)\n                          (\\<lambda>input'. gpv_stop (rpv input')))\n                     x) of\n             Pure x \\<Rightarrow> return_spmf (x, OK s)\n             | IO out c \\<Rightarrow>\n                 bind_spmf\n                  (TRY map_spmf (map_prod OK OK)\n                        (oracle s out) ELSE return_spmf (Fault, Fault))\n                  (\\<lambda>(x, y). exec_gpv' (c x) y)))\n          True)\n 2. integrable (measure_spmf (the_gpv gpv))\n     (\\<lambda>x.\n         spmf\n          (map_spmf fst\n            (case x of Pure x \\<Rightarrow> return_spmf (x, s)\n             | IO out c \\<Rightarrow>\n                 bind_spmf (oracle s out)\n                  (\\<lambda>(x, y). exec_gpv oracle (c x) y)))\n          True)\n 3. \\<And>x.\n       x \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       spmf\n        (map_spmf fst\n          (case map_generat (\\<lambda>x. x = Some True) id\n                 (map_fun option_of_exception\n                   (map_gpv' (\\<lambda>x. x = Some True) id\n                     option_of_exception))\n                 (map_generat Some id\n                   (\\<lambda>rpv.\n                       case_option (Done None)\n                        (\\<lambda>input'. gpv_stop (rpv input')))\n                   x) of\n           Pure x \\<Rightarrow> return_spmf (x, OK s)\n           | IO out c \\<Rightarrow>\n               bind_spmf\n                (TRY map_spmf (map_prod OK OK)\n                      (oracle s out) ELSE return_spmf (Fault, Fault))\n                (\\<lambda>(x, y). exec_gpv' (c x) y)))\n        True\n       \\<le> spmf\n              (map_spmf fst\n                (case x of Pure x \\<Rightarrow> return_spmf (x, s)\n                 | IO out c \\<Rightarrow>\n                     bind_spmf (oracle s out)\n                      (\\<lambda>(x, y). exec_gpv oracle (c x) y)))\n              True", "apply(rule measure_spmf.integrable_const_bound[where B=1]; simp add: pmf_le_1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. integrable (measure_spmf (the_gpv gpv))\n     (\\<lambda>x.\n         spmf\n          (map_spmf fst\n            (case x of Pure x \\<Rightarrow> return_spmf (x, s)\n             | IO out c \\<Rightarrow>\n                 bind_spmf (oracle s out)\n                  (\\<lambda>(x, y). exec_gpv oracle (c x) y)))\n          True)\n 2. \\<And>x.\n       x \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       spmf\n        (map_spmf fst\n          (case map_generat (\\<lambda>x. x = Some True) id\n                 (map_fun option_of_exception\n                   (map_gpv' (\\<lambda>x. x = Some True) id\n                     option_of_exception))\n                 (map_generat Some id\n                   (\\<lambda>rpv.\n                       case_option (Done None)\n                        (\\<lambda>input'. gpv_stop (rpv input')))\n                   x) of\n           Pure x \\<Rightarrow> return_spmf (x, OK s)\n           | IO out c \\<Rightarrow>\n               bind_spmf\n                (TRY map_spmf (map_prod OK OK)\n                      (oracle s out) ELSE return_spmf (Fault, Fault))\n                (\\<lambda>(x, y). exec_gpv' (c x) y)))\n        True\n       \\<le> spmf\n              (map_spmf fst\n                (case x of Pure x \\<Rightarrow> return_spmf (x, s)\n                 | IO out c \\<Rightarrow>\n                     bind_spmf (oracle s out)\n                      (\\<lambda>(x, y). exec_gpv oracle (c x) y)))\n              True", "apply(rule measure_spmf.integrable_const_bound[where B=1]; simp add: pmf_le_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       spmf\n        (map_spmf fst\n          (case map_generat (\\<lambda>x. x = Some True) id\n                 (map_fun option_of_exception\n                   (map_gpv' (\\<lambda>x. x = Some True) id\n                     option_of_exception))\n                 (map_generat Some id\n                   (\\<lambda>rpv.\n                       case_option (Done None)\n                        (\\<lambda>input'. gpv_stop (rpv input')))\n                   x) of\n           Pure x \\<Rightarrow> return_spmf (x, OK s)\n           | IO out c \\<Rightarrow>\n               bind_spmf\n                (TRY map_spmf (map_prod OK OK)\n                      (oracle s out) ELSE return_spmf (Fault, Fault))\n                (\\<lambda>(x, y). exec_gpv' (c x) y)))\n        True\n       \\<le> spmf\n              (map_spmf fst\n                (case x of Pure x \\<Rightarrow> return_spmf (x, s)\n                 | IO out c \\<Rightarrow>\n                     bind_spmf (oracle s out)\n                      (\\<lambda>(x, y). exec_gpv oracle (c x) y)))\n              True", "apply(clarsimp split: generat.split simp add: map_bind_spmf o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       spmf\n        (bind_spmf\n          (TRY map_spmf (map_prod OK OK)\n                (oracle s x21) ELSE return_spmf (Fault, Fault))\n          (\\<lambda>x.\n              map_spmf fst\n               (case x of\n                (x, xa) \\<Rightarrow>\n                  exec_gpv'\n                   (map_gpv' (\\<lambda>x. x = Some True) id\n                     option_of_exception\n                     (case x of Fault \\<Rightarrow> Done None\n                      | OK input' \\<Rightarrow> gpv_stop (x22 input')))\n                   xa)))\n        True\n       \\<le> spmf\n              (bind_spmf (oracle s x21)\n                (\\<lambda>x.\n                    map_spmf fst\n                     (case x of\n                      (x, xa) \\<Rightarrow> exec_gpv oracle (x22 x) xa)))\n              True", "apply(simp add: try_spmf_def bind_spmf_pmf_assoc bind_map_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       spmf\n        (bind_pmf (oracle s x21)\n          (\\<lambda>x.\n              bind_spmf\n               (case x of None \\<Rightarrow> return_spmf (Fault, Fault)\n                | Some x \\<Rightarrow>\n                    (return_spmf \\<circ> map_prod OK OK) x)\n               (\\<lambda>x.\n                   map_spmf fst\n                    (case x of\n                     (x, xa) \\<Rightarrow>\n                       exec_gpv'\n                        (map_gpv' (\\<lambda>x. x = Some True) id\n                          option_of_exception\n                          (case x of Fault \\<Rightarrow> Done None\n                           | OK input' \\<Rightarrow> gpv_stop (x22 input')))\n                        xa))))\n        True\n       \\<le> spmf\n              (bind_spmf (oracle s x21)\n                (\\<lambda>x.\n                    map_spmf fst\n                     (case x of\n                      (x, xa) \\<Rightarrow> exec_gpv oracle (x22 x) xa)))\n              True", "apply(simp add: bind_spmf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       spmf\n        (bind_pmf (oracle s x21)\n          (\\<lambda>x.\n              bind_pmf\n               (case x of None \\<Rightarrow> return_spmf (Fault, Fault)\n                | Some x \\<Rightarrow>\n                    (return_spmf \\<circ> map_prod OK OK) x)\n               (\\<lambda>a.\n                   case a of None \\<Rightarrow> return_pmf None\n                   | Some a' \\<Rightarrow>\n                       map_spmf fst\n                        (case a' of\n                         (x, xa) \\<Rightarrow>\n                           exec_gpv'\n                            (map_gpv' (\\<lambda>x. x = Some True) id\n                              option_of_exception\n                              (case x of Fault \\<Rightarrow> Done None\n                               | OK input' \\<Rightarrow>\n                                   gpv_stop (x22 input')))\n                            xa))))\n        True\n       \\<le> spmf\n              (bind_pmf (oracle s x21)\n                (\\<lambda>a.\n                    case a of None \\<Rightarrow> return_pmf None\n                    | Some a' \\<Rightarrow>\n                        map_spmf fst\n                         (case a' of\n                          (x, xa) \\<Rightarrow>\n                            exec_gpv oracle (x22 x) xa)))\n              True", "apply(subst (1 2) pmf_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       measure_pmf.expectation (oracle s x21)\n        (\\<lambda>x.\n            spmf\n             (bind_pmf\n               (case x of None \\<Rightarrow> return_spmf (Fault, Fault)\n                | Some x \\<Rightarrow>\n                    (return_spmf \\<circ> map_prod OK OK) x)\n               (case_option (return_pmf None)\n                 (\\<lambda>a'.\n                     map_spmf fst\n                      (case a' of\n                       (x, xa) \\<Rightarrow>\n                         exec_gpv'\n                          (map_gpv' (\\<lambda>x. x = Some True) id\n                            option_of_exception\n                            (case x of Fault \\<Rightarrow> Done None\n                             | OK input' \\<Rightarrow>\n                                 gpv_stop (x22 input')))\n                          xa))))\n             True)\n       \\<le> measure_pmf.expectation (oracle s x21)\n              (\\<lambda>x.\n                  spmf\n                   (case x of None \\<Rightarrow> return_pmf None\n                    | Some a' \\<Rightarrow>\n                        map_spmf fst\n                         (case a' of\n                          (x, xa) \\<Rightarrow> exec_gpv oracle (x22 x) xa))\n                   True)", "apply(rule Bochner_Integration.integral_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       integrable (measure_pmf (oracle s x21))\n        (\\<lambda>x.\n            spmf\n             (bind_pmf\n               (case x of None \\<Rightarrow> return_spmf (Fault, Fault)\n                | Some x \\<Rightarrow>\n                    (return_spmf \\<circ> map_prod OK OK) x)\n               (case_option (return_pmf None)\n                 (\\<lambda>a'.\n                     map_spmf fst\n                      (case a' of\n                       (x, xa) \\<Rightarrow>\n                         exec_gpv'\n                          (map_gpv' (\\<lambda>x. x = Some True) id\n                            option_of_exception\n                            (case x of Fault \\<Rightarrow> Done None\n                             | OK input' \\<Rightarrow>\n                                 gpv_stop (x22 input')))\n                          xa))))\n             True)\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       integrable (measure_pmf (oracle s x21))\n        (\\<lambda>x.\n            spmf\n             (case x of None \\<Rightarrow> return_pmf None\n              | Some a' \\<Rightarrow>\n                  map_spmf fst\n                   (case a' of\n                    (x, xa) \\<Rightarrow> exec_gpv oracle (x22 x) xa))\n             True)\n 3. \\<And>x21 x22 x.\n       \\<lbrakk>IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv));\n        x \\<in> space (measure_pmf (oracle s x21))\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (bind_pmf\n                            (case x of\n                             None \\<Rightarrow> return_spmf (Fault, Fault)\n                             | Some x \\<Rightarrow>\n                                 (return_spmf \\<circ> map_prod OK OK) x)\n                            (case_option (return_pmf None)\n                              (\\<lambda>a'.\n                                  map_spmf fst\n                                   (case a' of\n                                    (x, xa) \\<Rightarrow>\nexec_gpv'\n (map_gpv' (\\<lambda>x. x = Some True) id option_of_exception\n   (case x of Fault \\<Rightarrow> Done None\n    | OK input' \\<Rightarrow> gpv_stop (x22 input')))\n xa))))\n                          True\n                         \\<le> spmf\n                                (case x of\n                                 None \\<Rightarrow> return_pmf None\n                                 | Some a' \\<Rightarrow>\n                                     map_spmf fst\n(case a' of (x, xa) \\<Rightarrow> exec_gpv oracle (x22 x) xa))\n                                True", "apply(rule measure_pmf.integrable_const_bound[where B=1]; simp add: pmf_le_1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       integrable (measure_pmf (oracle s x21))\n        (\\<lambda>x.\n            spmf\n             (case x of None \\<Rightarrow> return_pmf None\n              | Some a' \\<Rightarrow>\n                  map_spmf fst\n                   (case a' of\n                    (x, xa) \\<Rightarrow> exec_gpv oracle (x22 x) xa))\n             True)\n 2. \\<And>x21 x22 x.\n       \\<lbrakk>IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv));\n        x \\<in> space (measure_pmf (oracle s x21))\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (bind_pmf\n                            (case x of\n                             None \\<Rightarrow> return_spmf (Fault, Fault)\n                             | Some x \\<Rightarrow>\n                                 (return_spmf \\<circ> map_prod OK OK) x)\n                            (case_option (return_pmf None)\n                              (\\<lambda>a'.\n                                  map_spmf fst\n                                   (case a' of\n                                    (x, xa) \\<Rightarrow>\nexec_gpv'\n (map_gpv' (\\<lambda>x. x = Some True) id option_of_exception\n   (case x of Fault \\<Rightarrow> Done None\n    | OK input' \\<Rightarrow> gpv_stop (x22 input')))\n xa))))\n                          True\n                         \\<le> spmf\n                                (case x of\n                                 None \\<Rightarrow> return_pmf None\n                                 | Some a' \\<Rightarrow>\n                                     map_spmf fst\n(case a' of (x, xa) \\<Rightarrow> exec_gpv oracle (x22 x) xa))\n                                True", "apply(rule measure_pmf.integrable_const_bound[where B=1]; simp add: pmf_le_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x.\n       \\<lbrakk>IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv));\n        x \\<in> space (measure_pmf (oracle s x21))\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (bind_pmf\n                            (case x of\n                             None \\<Rightarrow> return_spmf (Fault, Fault)\n                             | Some x \\<Rightarrow>\n                                 (return_spmf \\<circ> map_prod OK OK) x)\n                            (case_option (return_pmf None)\n                              (\\<lambda>a'.\n                                  map_spmf fst\n                                   (case a' of\n                                    (x, xa) \\<Rightarrow>\nexec_gpv'\n (map_gpv' (\\<lambda>x. x = Some True) id option_of_exception\n   (case x of Fault \\<Rightarrow> Done None\n    | OK input' \\<Rightarrow> gpv_stop (x22 input')))\n xa))))\n                          True\n                         \\<le> spmf\n                                (case x of\n                                 None \\<Rightarrow> return_pmf None\n                                 | Some a' \\<Rightarrow>\n                                     map_spmf fst\n(case a' of (x, xa) \\<Rightarrow> exec_gpv oracle (x22 x) xa))\n                                True", "apply(clarsimp split!: option.split simp add: bind_return_pmf)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       spmf (map_spmf fst (exec_gpv' (Done False) Fault)) True = 0\n 2. \\<And>x21 x22 a b.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       spmf\n        (map_spmf fst\n          (exec_gpv'\n            (map_gpv' (\\<lambda>x. x = Some True) id option_of_exception\n              (gpv_stop (x22 a)))\n            (OK b)))\n        True\n       \\<le> spmf (run_gpv oracle (x22 a) b) True", "apply(rule antisym)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       spmf (map_spmf fst (exec_gpv' (Done False) Fault)) True \\<le> 0\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       0 \\<le> spmf (map_spmf fst (exec_gpv' (Done False) Fault)) True\n 3. \\<And>x21 x22 a b.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       spmf\n        (map_spmf fst\n          (exec_gpv'\n            (map_gpv' (\\<lambda>x. x = Some True) id option_of_exception\n              (gpv_stop (x22 a)))\n            (OK b)))\n        True\n       \\<le> spmf (run_gpv oracle (x22 a) b) True", "apply(rule order_trans)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       spmf (map_spmf fst (exec_gpv' (Done False) Fault)) True\n       \\<le> ?y71 x21 x22\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       ?y71 x21 x22 \\<le> 0\n 3. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       0 \\<le> spmf (map_spmf fst (exec_gpv' (Done False) Fault)) True\n 4. \\<And>x21 x22 a b.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       spmf\n        (map_spmf fst\n          (exec_gpv'\n            (map_gpv' (\\<lambda>x. x = Some True) id option_of_exception\n              (gpv_stop (x22 a)))\n            (OK b)))\n        True\n       \\<le> spmf (run_gpv oracle (x22 a) b) True", "apply(rule step.hyps[THEN ord_spmf_map_spmfI, THEN ord_spmf_eq_leD])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       spmf (run_gpv (obsf_oracle oracle) (Done False) Fault) True \\<le> 0\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       0 \\<le> spmf (map_spmf fst (exec_gpv' (Done False) Fault)) True\n 3. \\<And>x21 x22 a b.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       spmf\n        (map_spmf fst\n          (exec_gpv'\n            (map_gpv' (\\<lambda>x. x = Some True) id option_of_exception\n              (gpv_stop (x22 a)))\n            (OK b)))\n        True\n       \\<le> spmf (run_gpv oracle (x22 a) b) True", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       0 \\<le> spmf (map_spmf fst (exec_gpv' (Done False) Fault)) True\n 2. \\<And>x21 x22 a b.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       spmf\n        (map_spmf fst\n          (exec_gpv'\n            (map_gpv' (\\<lambda>x. x = Some True) id option_of_exception\n              (gpv_stop (x22 a)))\n            (OK b)))\n        True\n       \\<le> spmf (run_gpv oracle (x22 a) b) True", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 a b.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       spmf\n        (map_spmf fst\n          (exec_gpv'\n            (map_gpv' (\\<lambda>x. x = Some True) id option_of_exception\n              (gpv_stop (x22 a)))\n            (OK b)))\n        True\n       \\<le> spmf (run_gpv oracle (x22 a) b) True", "apply(rule step.IH[unfolded eg2_def obsf_distinguisher_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  spmf\n   (map_spmf fst\n     (bind_spmf (the_gpv (obsf_distinguisher gpv))\n       (case_generat (\\<lambda>x. return_spmf (x, OK s))\n         (\\<lambda>out c.\n             bind_spmf (obsf_oracle oracle (OK s) out)\n              (\\<lambda>(x, y). exec_gpv' (c x) y)))))\n   True\n  \\<le> spmf (map_spmf fst (eg2 oracle gpv s)) True\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  spmf\n   (map_spmf fst (eg1 (obsf_oracle oracle) (obsf_distinguisher gpv) (OK s)))\n   True\n  \\<le> spmf (map_spmf fst (eg2 oracle gpv s)) True\n\ngoal (1 subgoal):\n 1. spmf (map_spmf fst (eg2 oracle gpv s)) True\n    \\<le> spmf\n           (map_spmf fst\n             (eg1 (obsf_oracle oracle) (obsf_distinguisher gpv) (OK s)))\n           True", "show \"?rhs \\<le> ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (map_spmf fst (eg2 oracle gpv s)) True\n    \\<le> spmf\n           (map_spmf fst\n             (eg1 (obsf_oracle oracle) (obsf_distinguisher gpv) (OK s)))\n           True", "unfolding eg2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (run_gpv oracle gpv s) True\n    \\<le> spmf\n           (map_spmf fst\n             (eg1 (obsf_oracle oracle) (obsf_distinguisher gpv) (OK s)))\n           True", "proof(induction arbitrary: gpv s rule: exec_gpv_fixp_induct_strong)"], ["proof (state)\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>f.\n         \\<forall>x xa.\n            spmf (map_spmf fst (f (x, xa))) True\n            \\<le> spmf\n                   (map_spmf fst\n                     (eg1 (obsf_oracle oracle) (obsf_distinguisher x)\n                       (OK xa)))\n                   True)\n 2. \\<And>gpv s.\n       spmf (map_spmf fst (return_pmf None)) True\n       \\<le> spmf\n              (map_spmf fst\n                (eg1 (obsf_oracle oracle) (obsf_distinguisher gpv) (OK s)))\n              True\n 3. \\<And>exec_gpv' gpv s.\n       \\<lbrakk>\\<And>c s.\n                   ord_spmf (=) (exec_gpv' c s) (exec_gpv oracle c s);\n        \\<And>gpv s.\n           spmf (map_spmf fst (exec_gpv' gpv s)) True\n           \\<le> spmf\n                  (map_spmf fst\n                    (eg1 (obsf_oracle oracle) (obsf_distinguisher gpv)\n                      (OK s)))\n                  True\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf fst\n                            (bind_spmf (the_gpv gpv)\n                              (case_generat (\\<lambda>x. return_spmf (x, s))\n                                (\\<lambda>out c.\n                                    bind_spmf (oracle s out)\n                                     (\\<lambda>(x, y).\n   exec_gpv' (c x) y)))))\n                          True\n                         \\<le> spmf\n                                (map_spmf fst\n                                  (eg1 (obsf_oracle oracle)\n                                    (obsf_distinguisher gpv) (OK s)))\n                                True", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>f.\n         \\<forall>x xa.\n            spmf (map_spmf fst (f (x, xa))) True\n            \\<le> spmf\n                   (map_spmf fst\n                     (eg1 (obsf_oracle oracle) (obsf_distinguisher x)\n                       (OK xa)))\n                   True)\n 2. \\<And>gpv s.\n       spmf (map_spmf fst (return_pmf None)) True\n       \\<le> spmf\n              (map_spmf fst\n                (eg1 (obsf_oracle oracle) (obsf_distinguisher gpv) (OK s)))\n              True\n 3. \\<And>exec_gpv' gpv s.\n       \\<lbrakk>\\<And>c s.\n                   ord_spmf (=) (exec_gpv' c s) (exec_gpv oracle c s);\n        \\<And>gpv s.\n           spmf (map_spmf fst (exec_gpv' gpv s)) True\n           \\<le> spmf\n                  (map_spmf fst\n                    (eg1 (obsf_oracle oracle) (obsf_distinguisher gpv)\n                      (OK s)))\n                  True\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf fst\n                            (bind_spmf (the_gpv gpv)\n                              (case_generat (\\<lambda>x. return_spmf (x, s))\n                                (\\<lambda>out c.\n                                    bind_spmf (oracle s out)\n                                     (\\<lambda>(x, y).\n   exec_gpv' (c x) y)))))\n                          True\n                         \\<le> spmf\n                                (map_spmf fst\n                                  (eg1 (obsf_oracle oracle)\n                                    (obsf_distinguisher gpv) (OK s)))\n                                True", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf.admissible\n     (\\<lambda>f.\n         \\<forall>x xa.\n            spmf (map_spmf fst (f (x, xa))) True\n            \\<le> spmf\n                   (map_spmf fst\n                     (eg1 (obsf_oracle oracle) (obsf_distinguisher x)\n                       (OK xa)))\n                   True)", "by simp"], ["proof (state)\nthis:\n  spmf.admissible\n   (\\<lambda>f.\n       \\<forall>x xa.\n          spmf (map_spmf fst (f (x, xa))) True\n          \\<le> spmf\n                 (map_spmf fst\n                   (eg1 (obsf_oracle oracle) (obsf_distinguisher x)\n                     (OK xa)))\n                 True)\n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       spmf (map_spmf fst (return_pmf None)) True\n       \\<le> spmf\n              (map_spmf fst\n                (eg1 (obsf_oracle oracle) (obsf_distinguisher gpv) (OK s)))\n              True\n 2. \\<And>exec_gpv' gpv s.\n       \\<lbrakk>\\<And>c s.\n                   ord_spmf (=) (exec_gpv' c s) (exec_gpv oracle c s);\n        \\<And>gpv s.\n           spmf (map_spmf fst (exec_gpv' gpv s)) True\n           \\<le> spmf\n                  (map_spmf fst\n                    (eg1 (obsf_oracle oracle) (obsf_distinguisher gpv)\n                      (OK s)))\n                  True\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf fst\n                            (bind_spmf (the_gpv gpv)\n                              (case_generat (\\<lambda>x. return_spmf (x, s))\n                                (\\<lambda>out c.\n                                    bind_spmf (oracle s out)\n                                     (\\<lambda>(x, y).\n   exec_gpv' (c x) y)))))\n                          True\n                         \\<le> spmf\n                                (map_spmf fst\n                                  (eg1 (obsf_oracle oracle)\n                                    (obsf_distinguisher gpv) (OK s)))\n                                True", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       spmf (map_spmf fst (return_pmf None)) True\n       \\<le> spmf\n              (map_spmf fst\n                (eg1 (obsf_oracle oracle) (obsf_distinguisher gpv) (OK s)))\n              True\n 2. \\<And>exec_gpv' gpv s.\n       \\<lbrakk>\\<And>c s.\n                   ord_spmf (=) (exec_gpv' c s) (exec_gpv oracle c s);\n        \\<And>gpv s.\n           spmf (map_spmf fst (exec_gpv' gpv s)) True\n           \\<le> spmf\n                  (map_spmf fst\n                    (eg1 (obsf_oracle oracle) (obsf_distinguisher gpv)\n                      (OK s)))\n                  True\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf fst\n                            (bind_spmf (the_gpv gpv)\n                              (case_generat (\\<lambda>x. return_spmf (x, s))\n                                (\\<lambda>out c.\n                                    bind_spmf (oracle s out)\n                                     (\\<lambda>(x, y).\n   exec_gpv' (c x) y)))))\n                          True\n                         \\<le> spmf\n                                (map_spmf fst\n                                  (eg1 (obsf_oracle oracle)\n                                    (obsf_distinguisher gpv) (OK s)))\n                                True", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (map_spmf fst (return_pmf None)) True\n    \\<le> spmf\n           (map_spmf fst\n             (eg1 (obsf_oracle oracle) (obsf_distinguisher gpv) (OK s)))\n           True", "by simp"], ["proof (state)\nthis:\n  spmf (map_spmf fst (return_pmf None)) True\n  \\<le> spmf\n         (map_spmf fst\n           (eg1 (obsf_oracle oracle) (obsf_distinguisher gpv) (OK s)))\n         True\n\ngoal (1 subgoal):\n 1. \\<And>exec_gpv' gpv s.\n       \\<lbrakk>\\<And>c s.\n                   ord_spmf (=) (exec_gpv' c s) (exec_gpv oracle c s);\n        \\<And>gpv s.\n           spmf (map_spmf fst (exec_gpv' gpv s)) True\n           \\<le> spmf\n                  (map_spmf fst\n                    (eg1 (obsf_oracle oracle) (obsf_distinguisher gpv)\n                      (OK s)))\n                  True\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf fst\n                            (bind_spmf (the_gpv gpv)\n                              (case_generat (\\<lambda>x. return_spmf (x, s))\n                                (\\<lambda>out c.\n                                    bind_spmf (oracle s out)\n                                     (\\<lambda>(x, y).\n   exec_gpv' (c x) y)))))\n                          True\n                         \\<le> spmf\n                                (map_spmf fst\n                                  (eg1 (obsf_oracle oracle)\n                                    (obsf_distinguisher gpv) (OK s)))\n                                True", "case (step exec_gpv')"], ["proof (state)\nthis:\n  ord_spmf (=) (exec_gpv' ?c ?s) (exec_gpv oracle ?c ?s)\n  spmf (map_spmf fst (exec_gpv' ?gpv ?s)) True\n  \\<le> spmf\n         (map_spmf fst\n           (eg1 (obsf_oracle oracle) (obsf_distinguisher ?gpv) (OK ?s)))\n         True\n\ngoal (1 subgoal):\n 1. \\<And>exec_gpv' gpv s.\n       \\<lbrakk>\\<And>c s.\n                   ord_spmf (=) (exec_gpv' c s) (exec_gpv oracle c s);\n        \\<And>gpv s.\n           spmf (map_spmf fst (exec_gpv' gpv s)) True\n           \\<le> spmf\n                  (map_spmf fst\n                    (eg1 (obsf_oracle oracle) (obsf_distinguisher gpv)\n                      (OK s)))\n                  True\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (map_spmf fst\n                            (bind_spmf (the_gpv gpv)\n                              (case_generat (\\<lambda>x. return_spmf (x, s))\n                                (\\<lambda>out c.\n                                    bind_spmf (oracle s out)\n                                     (\\<lambda>(x, y).\n   exec_gpv' (c x) y)))))\n                          True\n                         \\<le> spmf\n                                (map_spmf fst\n                                  (eg1 (obsf_oracle oracle)\n                                    (obsf_distinguisher gpv) (OK s)))\n                                True", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf fst\n       (bind_spmf (the_gpv gpv)\n         (case_generat (\\<lambda>x. return_spmf (x, s))\n           (\\<lambda>out c.\n               bind_spmf (oracle s out)\n                (\\<lambda>(x, y). exec_gpv' (c x) y)))))\n     True\n    \\<le> spmf\n           (map_spmf fst\n             (eg1 (obsf_oracle oracle) (obsf_distinguisher gpv) (OK s)))\n           True", "unfolding eg1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf fst\n       (bind_spmf (the_gpv gpv)\n         (case_generat (\\<lambda>x. return_spmf (x, s))\n           (\\<lambda>out c.\n               bind_spmf (oracle s out)\n                (\\<lambda>(x, y). exec_gpv' (c x) y)))))\n     True\n    \\<le> spmf\n           (run_gpv (obsf_oracle oracle) (obsf_distinguisher gpv) (OK s))\n           True", "apply(subst exec_gpv.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (map_spmf fst\n       (bind_spmf (the_gpv gpv)\n         (case_generat (\\<lambda>x. return_spmf (x, s))\n           (\\<lambda>out c.\n               bind_spmf (oracle s out)\n                (\\<lambda>(x, y). exec_gpv' (c x) y)))))\n     True\n    \\<le> spmf\n           (map_spmf fst\n             (bind_spmf (the_gpv (obsf_distinguisher gpv))\n               (case_generat (\\<lambda>x. return_spmf (x, OK s))\n                 (\\<lambda>out c.\n                     bind_spmf (obsf_oracle oracle (OK s) out)\n                      (\\<lambda>(x, y).\n                          exec_gpv (obsf_oracle oracle) (c x) y)))))\n           True", "apply(clarsimp simp add: obsf_distinguisher_def bind_map_spmf map_bind_spmf o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (bind_spmf (the_gpv gpv)\n       (\\<lambda>x.\n           map_spmf fst\n            (case x of Pure x \\<Rightarrow> return_spmf (x, s)\n             | IO out c \\<Rightarrow>\n                 bind_spmf (oracle s out)\n                  (\\<lambda>(x, y). exec_gpv' (c x) y))))\n     True\n    \\<le> spmf\n           (bind_spmf (the_gpv gpv)\n             (\\<lambda>x.\n                 map_spmf fst\n                  (case map_generat (\\<lambda>x. x = Some True) id\n                         (map_fun option_of_exception\n                           (map_gpv' (\\<lambda>x. x = Some True) id\n                             option_of_exception))\n                         (map_generat Some id\n                           (\\<lambda>rpv.\n                               case_option (Done None)\n                                (\\<lambda>input'. gpv_stop (rpv input')))\n                           x) of\n                   Pure x \\<Rightarrow> return_spmf (x, OK s)\n                   | IO out c \\<Rightarrow>\n                       bind_spmf\n                        (TRY map_spmf (map_prod OK OK)\n                              (oracle s\n                                out) ELSE return_spmf (Fault, Fault))\n                        (\\<lambda>(x, y).\n                            exec_gpv (obsf_oracle oracle) (c x) y))))\n           True", "apply(subst (1 2) spmf_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT x|measure_spmf (the_gpv gpv).\n       spmf\n        (map_spmf fst\n          (case x of Pure x \\<Rightarrow> return_spmf (x, s)\n           | IO out c \\<Rightarrow>\n               bind_spmf (oracle s out)\n                (\\<lambda>(x, y). exec_gpv' (c x) y)))\n        True\n    \\<le> LINT x|measure_spmf (the_gpv gpv).\n             spmf\n              (map_spmf fst\n                (case map_generat (\\<lambda>x. x = Some True) id\n                       (map_fun option_of_exception\n                         (map_gpv' (\\<lambda>x. x = Some True) id\n                           option_of_exception))\n                       (map_generat Some id\n                         (\\<lambda>rpv.\n                             case_option (Done None)\n                              (\\<lambda>input'. gpv_stop (rpv input')))\n                         x) of\n                 Pure x \\<Rightarrow> return_spmf (x, OK s)\n                 | IO out c \\<Rightarrow>\n                     bind_spmf\n                      (TRY map_spmf (map_prod OK OK)\n                            (oracle s out) ELSE return_spmf (Fault, Fault))\n                      (\\<lambda>(x, y).\n                          exec_gpv (obsf_oracle oracle) (c x) y)))\n              True", "apply(rule Bochner_Integration.integral_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. integrable (measure_spmf (the_gpv gpv))\n     (\\<lambda>x.\n         spmf\n          (map_spmf fst\n            (case x of Pure x \\<Rightarrow> return_spmf (x, s)\n             | IO out c \\<Rightarrow>\n                 bind_spmf (oracle s out)\n                  (\\<lambda>(x, y). exec_gpv' (c x) y)))\n          True)\n 2. integrable (measure_spmf (the_gpv gpv))\n     (\\<lambda>x.\n         spmf\n          (map_spmf fst\n            (case map_generat (\\<lambda>x. x = Some True) id\n                   (map_fun option_of_exception\n                     (map_gpv' (\\<lambda>x. x = Some True) id\n                       option_of_exception))\n                   (map_generat Some id\n                     (\\<lambda>rpv.\n                         case_option (Done None)\n                          (\\<lambda>input'. gpv_stop (rpv input')))\n                     x) of\n             Pure x \\<Rightarrow> return_spmf (x, OK s)\n             | IO out c \\<Rightarrow>\n                 bind_spmf\n                  (TRY map_spmf (map_prod OK OK)\n                        (oracle s out) ELSE return_spmf (Fault, Fault))\n                  (\\<lambda>(x, y). exec_gpv (obsf_oracle oracle) (c x) y)))\n          True)\n 3. \\<And>x.\n       x \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       spmf\n        (map_spmf fst\n          (case x of Pure x \\<Rightarrow> return_spmf (x, s)\n           | IO out c \\<Rightarrow>\n               bind_spmf (oracle s out)\n                (\\<lambda>(x, y). exec_gpv' (c x) y)))\n        True\n       \\<le> spmf\n              (map_spmf fst\n                (case map_generat (\\<lambda>x. x = Some True) id\n                       (map_fun option_of_exception\n                         (map_gpv' (\\<lambda>x. x = Some True) id\n                           option_of_exception))\n                       (map_generat Some id\n                         (\\<lambda>rpv.\n                             case_option (Done None)\n                              (\\<lambda>input'. gpv_stop (rpv input')))\n                         x) of\n                 Pure x \\<Rightarrow> return_spmf (x, OK s)\n                 | IO out c \\<Rightarrow>\n                     bind_spmf\n                      (TRY map_spmf (map_prod OK OK)\n                            (oracle s out) ELSE return_spmf (Fault, Fault))\n                      (\\<lambda>(x, y).\n                          exec_gpv (obsf_oracle oracle) (c x) y)))\n              True", "apply(rule measure_spmf.integrable_const_bound[where B=1]; simp add: pmf_le_1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. integrable (measure_spmf (the_gpv gpv))\n     (\\<lambda>x.\n         spmf\n          (map_spmf fst\n            (case map_generat (\\<lambda>x. x = Some True) id\n                   (map_fun option_of_exception\n                     (map_gpv' (\\<lambda>x. x = Some True) id\n                       option_of_exception))\n                   (map_generat Some id\n                     (\\<lambda>rpv.\n                         case_option (Done None)\n                          (\\<lambda>input'. gpv_stop (rpv input')))\n                     x) of\n             Pure x \\<Rightarrow> return_spmf (x, OK s)\n             | IO out c \\<Rightarrow>\n                 bind_spmf\n                  (TRY map_spmf (map_prod OK OK)\n                        (oracle s out) ELSE return_spmf (Fault, Fault))\n                  (\\<lambda>(x, y). exec_gpv (obsf_oracle oracle) (c x) y)))\n          True)\n 2. \\<And>x.\n       x \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       spmf\n        (map_spmf fst\n          (case x of Pure x \\<Rightarrow> return_spmf (x, s)\n           | IO out c \\<Rightarrow>\n               bind_spmf (oracle s out)\n                (\\<lambda>(x, y). exec_gpv' (c x) y)))\n        True\n       \\<le> spmf\n              (map_spmf fst\n                (case map_generat (\\<lambda>x. x = Some True) id\n                       (map_fun option_of_exception\n                         (map_gpv' (\\<lambda>x. x = Some True) id\n                           option_of_exception))\n                       (map_generat Some id\n                         (\\<lambda>rpv.\n                             case_option (Done None)\n                              (\\<lambda>input'. gpv_stop (rpv input')))\n                         x) of\n                 Pure x \\<Rightarrow> return_spmf (x, OK s)\n                 | IO out c \\<Rightarrow>\n                     bind_spmf\n                      (TRY map_spmf (map_prod OK OK)\n                            (oracle s out) ELSE return_spmf (Fault, Fault))\n                      (\\<lambda>(x, y).\n                          exec_gpv (obsf_oracle oracle) (c x) y)))\n              True", "apply(rule measure_spmf.integrable_const_bound[where B=1]; simp add: pmf_le_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       spmf\n        (map_spmf fst\n          (case x of Pure x \\<Rightarrow> return_spmf (x, s)\n           | IO out c \\<Rightarrow>\n               bind_spmf (oracle s out)\n                (\\<lambda>(x, y). exec_gpv' (c x) y)))\n        True\n       \\<le> spmf\n              (map_spmf fst\n                (case map_generat (\\<lambda>x. x = Some True) id\n                       (map_fun option_of_exception\n                         (map_gpv' (\\<lambda>x. x = Some True) id\n                           option_of_exception))\n                       (map_generat Some id\n                         (\\<lambda>rpv.\n                             case_option (Done None)\n                              (\\<lambda>input'. gpv_stop (rpv input')))\n                         x) of\n                 Pure x \\<Rightarrow> return_spmf (x, OK s)\n                 | IO out c \\<Rightarrow>\n                     bind_spmf\n                      (TRY map_spmf (map_prod OK OK)\n                            (oracle s out) ELSE return_spmf (Fault, Fault))\n                      (\\<lambda>(x, y).\n                          exec_gpv (obsf_oracle oracle) (c x) y)))\n              True", "apply(clarsimp split: generat.split simp add: map_bind_spmf o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       spmf\n        (bind_spmf (oracle s x21)\n          (\\<lambda>x.\n              map_spmf fst\n               (case x of (x, xa) \\<Rightarrow> exec_gpv' (x22 x) xa)))\n        True\n       \\<le> spmf\n              (bind_spmf\n                (TRY map_spmf (map_prod OK OK)\n                      (oracle s x21) ELSE return_spmf (Fault, Fault))\n                (\\<lambda>x.\n                    map_spmf fst\n                     (case x of\n                      (x, xa) \\<Rightarrow>\n                        exec_gpv (obsf_oracle oracle)\n                         (map_gpv' (\\<lambda>x. x = Some True) id\n                           option_of_exception\n                           (case x of Fault \\<Rightarrow> Done None\n                            | OK input' \\<Rightarrow>\n                                gpv_stop (x22 input')))\n                         xa)))\n              True", "apply(simp add: try_spmf_def bind_spmf_pmf_assoc bind_map_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       spmf\n        (bind_spmf (oracle s x21)\n          (\\<lambda>x.\n              map_spmf fst\n               (case x of (x, xa) \\<Rightarrow> exec_gpv' (x22 x) xa)))\n        True\n       \\<le> spmf\n              (bind_pmf (oracle s x21)\n                (\\<lambda>x.\n                    bind_spmf\n                     (case x of\n                      None \\<Rightarrow> return_spmf (Fault, Fault)\n                      | Some x \\<Rightarrow>\n                          (return_spmf \\<circ> map_prod OK OK) x)\n                     (\\<lambda>x.\n                         map_spmf fst\n                          (case x of\n                           (x, xa) \\<Rightarrow>\n                             exec_gpv (obsf_oracle oracle)\n                              (map_gpv' (\\<lambda>x. x = Some True) id\n                                option_of_exception\n                                (case x of Fault \\<Rightarrow> Done None\n                                 | OK input' \\<Rightarrow>\n                                     gpv_stop (x22 input')))\n                              xa))))\n              True", "apply(simp add: bind_spmf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       spmf\n        (bind_pmf (oracle s x21)\n          (\\<lambda>a.\n              case a of None \\<Rightarrow> return_pmf None\n              | Some a' \\<Rightarrow>\n                  map_spmf fst\n                   (case a' of (x, xa) \\<Rightarrow> exec_gpv' (x22 x) xa)))\n        True\n       \\<le> spmf\n              (bind_pmf (oracle s x21)\n                (\\<lambda>x.\n                    bind_pmf\n                     (case x of\n                      None \\<Rightarrow> return_spmf (Fault, Fault)\n                      | Some x \\<Rightarrow>\n                          (return_spmf \\<circ> map_prod OK OK) x)\n                     (\\<lambda>a.\n                         case a of None \\<Rightarrow> return_pmf None\n                         | Some a' \\<Rightarrow>\n                             map_spmf fst\n                              (case a' of\n                               (x, xa) \\<Rightarrow>\n                                 exec_gpv (obsf_oracle oracle)\n                                  (map_gpv' (\\<lambda>x. x = Some True) id\n                                    option_of_exception\n                                    (case x of Fault \\<Rightarrow> Done None\n                                     | OK input' \\<Rightarrow>\n   gpv_stop (x22 input')))\n                                  xa))))\n              True", "apply(subst (1 2) pmf_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       measure_pmf.expectation (oracle s x21)\n        (\\<lambda>x.\n            spmf\n             (case x of None \\<Rightarrow> return_pmf None\n              | Some a' \\<Rightarrow>\n                  map_spmf fst\n                   (case a' of (x, xa) \\<Rightarrow> exec_gpv' (x22 x) xa))\n             True)\n       \\<le> measure_pmf.expectation (oracle s x21)\n              (\\<lambda>x.\n                  spmf\n                   (bind_pmf\n                     (case x of\n                      None \\<Rightarrow> return_spmf (Fault, Fault)\n                      | Some x \\<Rightarrow>\n                          (return_spmf \\<circ> map_prod OK OK) x)\n                     (case_option (return_pmf None)\n                       (\\<lambda>a'.\n                           map_spmf fst\n                            (case a' of\n                             (x, xa) \\<Rightarrow>\n                               exec_gpv (obsf_oracle oracle)\n                                (map_gpv' (\\<lambda>x. x = Some True) id\n                                  option_of_exception\n                                  (case x of Fault \\<Rightarrow> Done None\n                                   | OK input' \\<Rightarrow>\n gpv_stop (x22 input')))\n                                xa))))\n                   True)", "apply(rule Bochner_Integration.integral_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       integrable (measure_pmf (oracle s x21))\n        (\\<lambda>x.\n            spmf\n             (case x of None \\<Rightarrow> return_pmf None\n              | Some a' \\<Rightarrow>\n                  map_spmf fst\n                   (case a' of (x, xa) \\<Rightarrow> exec_gpv' (x22 x) xa))\n             True)\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       integrable (measure_pmf (oracle s x21))\n        (\\<lambda>x.\n            spmf\n             (bind_pmf\n               (case x of None \\<Rightarrow> return_spmf (Fault, Fault)\n                | Some x \\<Rightarrow>\n                    (return_spmf \\<circ> map_prod OK OK) x)\n               (case_option (return_pmf None)\n                 (\\<lambda>a'.\n                     map_spmf fst\n                      (case a' of\n                       (x, xa) \\<Rightarrow>\n                         exec_gpv (obsf_oracle oracle)\n                          (map_gpv' (\\<lambda>x. x = Some True) id\n                            option_of_exception\n                            (case x of Fault \\<Rightarrow> Done None\n                             | OK input' \\<Rightarrow>\n                                 gpv_stop (x22 input')))\n                          xa))))\n             True)\n 3. \\<And>x21 x22 x.\n       \\<lbrakk>IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv));\n        x \\<in> space (measure_pmf (oracle s x21))\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (case x of None \\<Rightarrow> return_pmf None\n                           | Some a' \\<Rightarrow>\n                               map_spmf fst\n                                (case a' of\n                                 (x, xa) \\<Rightarrow>\n                                   exec_gpv' (x22 x) xa))\n                          True\n                         \\<le> spmf\n                                (bind_pmf\n                                  (case x of\n                                   None \\<Rightarrow>\n                                     return_spmf (Fault, Fault)\n                                   | Some x \\<Rightarrow>\n (return_spmf \\<circ> map_prod OK OK) x)\n                                  (case_option (return_pmf None)\n                                    (\\<lambda>a'.\n  map_spmf fst\n   (case a' of\n    (x, xa) \\<Rightarrow>\n      exec_gpv (obsf_oracle oracle)\n       (map_gpv' (\\<lambda>x. x = Some True) id option_of_exception\n         (case x of Fault \\<Rightarrow> Done None\n          | OK input' \\<Rightarrow> gpv_stop (x22 input')))\n       xa))))\n                                True", "apply(rule measure_pmf.integrable_const_bound[where B=1]; simp add: pmf_le_1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       integrable (measure_pmf (oracle s x21))\n        (\\<lambda>x.\n            spmf\n             (bind_pmf\n               (case x of None \\<Rightarrow> return_spmf (Fault, Fault)\n                | Some x \\<Rightarrow>\n                    (return_spmf \\<circ> map_prod OK OK) x)\n               (case_option (return_pmf None)\n                 (\\<lambda>a'.\n                     map_spmf fst\n                      (case a' of\n                       (x, xa) \\<Rightarrow>\n                         exec_gpv (obsf_oracle oracle)\n                          (map_gpv' (\\<lambda>x. x = Some True) id\n                            option_of_exception\n                            (case x of Fault \\<Rightarrow> Done None\n                             | OK input' \\<Rightarrow>\n                                 gpv_stop (x22 input')))\n                          xa))))\n             True)\n 2. \\<And>x21 x22 x.\n       \\<lbrakk>IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv));\n        x \\<in> space (measure_pmf (oracle s x21))\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (case x of None \\<Rightarrow> return_pmf None\n                           | Some a' \\<Rightarrow>\n                               map_spmf fst\n                                (case a' of\n                                 (x, xa) \\<Rightarrow>\n                                   exec_gpv' (x22 x) xa))\n                          True\n                         \\<le> spmf\n                                (bind_pmf\n                                  (case x of\n                                   None \\<Rightarrow>\n                                     return_spmf (Fault, Fault)\n                                   | Some x \\<Rightarrow>\n (return_spmf \\<circ> map_prod OK OK) x)\n                                  (case_option (return_pmf None)\n                                    (\\<lambda>a'.\n  map_spmf fst\n   (case a' of\n    (x, xa) \\<Rightarrow>\n      exec_gpv (obsf_oracle oracle)\n       (map_gpv' (\\<lambda>x. x = Some True) id option_of_exception\n         (case x of Fault \\<Rightarrow> Done None\n          | OK input' \\<Rightarrow> gpv_stop (x22 input')))\n       xa))))\n                                True", "apply(rule measure_pmf.integrable_const_bound[where B=1]; simp add: pmf_le_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x.\n       \\<lbrakk>IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv));\n        x \\<in> space (measure_pmf (oracle s x21))\\<rbrakk>\n       \\<Longrightarrow> spmf\n                          (case x of None \\<Rightarrow> return_pmf None\n                           | Some a' \\<Rightarrow>\n                               map_spmf fst\n                                (case a' of\n                                 (x, xa) \\<Rightarrow>\n                                   exec_gpv' (x22 x) xa))\n                          True\n                         \\<le> spmf\n                                (bind_pmf\n                                  (case x of\n                                   None \\<Rightarrow>\n                                     return_spmf (Fault, Fault)\n                                   | Some x \\<Rightarrow>\n (return_spmf \\<circ> map_prod OK OK) x)\n                                  (case_option (return_pmf None)\n                                    (\\<lambda>a'.\n  map_spmf fst\n   (case a' of\n    (x, xa) \\<Rightarrow>\n      exec_gpv (obsf_oracle oracle)\n       (map_gpv' (\\<lambda>x. x = Some True) id option_of_exception\n         (case x of Fault \\<Rightarrow> Done None\n          | OK input' \\<Rightarrow> gpv_stop (x22 input')))\n       xa))))\n                                True", "apply(clarsimp split!: option.split simp add: bind_return_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 a b.\n       IO x21 x22 \\<in> space (measure_spmf (the_gpv gpv)) \\<Longrightarrow>\n       spmf (map_spmf fst (exec_gpv' (x22 a) b)) True\n       \\<le> spmf\n              (run_gpv (obsf_oracle oracle)\n                (map_gpv' (\\<lambda>x. x = Some True) id option_of_exception\n                  (gpv_stop (x22 a)))\n                (OK b))\n              True", "apply(rule step.IH[unfolded eg1_def obsf_distinguisher_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  spmf\n   (map_spmf fst\n     (bind_spmf (the_gpv gpv)\n       (case_generat (\\<lambda>x. return_spmf (x, s))\n         (\\<lambda>out c.\n             bind_spmf (oracle s out)\n              (\\<lambda>(x, y). exec_gpv' (c x) y)))))\n   True\n  \\<le> spmf\n         (map_spmf fst\n           (eg1 (obsf_oracle oracle) (obsf_distinguisher gpv) (OK s)))\n         True\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  spmf (map_spmf fst (eg2 oracle gpv s)) True\n  \\<le> spmf\n         (map_spmf fst\n           (eg1 (obsf_oracle oracle) (obsf_distinguisher gpv) (OK s)))\n         True\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma spmf_obsf_distinguisher_obsf_resource_True:\n  \"spmf (connect_obsf (obsf_distinguisher \\<A>) (obsf_resource res)) True = spmf (connect \\<A> res) True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (connect_obsf (obsf_distinguisher \\<A>) (obsf_resource res)) True =\n    spmf (connect \\<A> res) True", "unfolding connect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (run_gpv run_resource (obsf_distinguisher \\<A>) (obsf_resource res))\n     True =\n    spmf (run_gpv run_resource \\<A> res) True", "apply(subst (2) resource_of_oracle_run_resource[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf\n     (run_gpv run_resource (obsf_distinguisher \\<A>)\n       (obsf_resource (RES run_resource res)))\n     True =\n    spmf (run_gpv run_resource \\<A> res) True", "apply(simp add: exec_gpv_resource_of_oracle spmf.map_comp spmf_run_obsf_oracle_obsf_distinguisher)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma advantage_obsf_distinguisher: \n  \"advantage (obsf_distinguisher \\<A>) (obsf_resource ideal_resource) (obsf_resource real_resource) =\n   advantage \\<A> ideal_resource real_resource\""], ["proof (prove)\ngoal (1 subgoal):\n 1. advantage (obsf_distinguisher \\<A>) (obsf_resource ideal_resource)\n     (obsf_resource real_resource) =\n    advantage \\<A> ideal_resource real_resource", "unfolding advantage_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf\n           (connect_obsf (obsf_distinguisher \\<A>)\n             (obsf_resource ideal_resource))\n           True -\n          spmf\n           (connect_obsf (obsf_distinguisher \\<A>)\n             (obsf_resource real_resource))\n           True\\<bar> =\n    \\<bar>spmf (connect \\<A> ideal_resource) True -\n          spmf (connect \\<A> real_resource) True\\<bar>", "by(simp add: spmf_obsf_distinguisher_obsf_resource_True)"], ["", "end"]]}