{"file_name": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography_CM/State_Isomorphism.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography_CM", "problem_names": ["lemma apply_state_iso_id: \"apply_state_iso (id, id) = id\"", "lemma apply_state_iso_compose: \"apply_state_iso si1 (apply_state_iso si2 oracle) = \n    apply_state_iso (map_prod (\\<lambda>f. f o (fst si2)) ((o) (snd si2)) si1) oracle\"", "lemma apply_wiring_state_iso_assoc:\n    \"apply_wiring wr (apply_state_iso si oracle) = apply_state_iso si (apply_wiring wr oracle)\"", "lemma \n  resource_of_oracle_state_iso:\n  assumes \"state_iso fg\"\n  shows \"resource_of_oracle (apply_state_iso fg oracle) s = resource_of_oracle oracle (snd fg s)\"", "lemma \n  state_iso_parallel_state_iso [simp]: \"state_iso parallel_state_iso\"", "lemma \n  state_iso_fuse_par [simp]: \"state_iso iso_trisplit\"", "lemma \n  state_iso_swapar [simp]: \"state_iso iso_swapar\""], "translations": [["", "lemma apply_state_iso_id: \"apply_state_iso (id, id) = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_state_iso (id, id) = id", "by (auto simp add: apply_state_iso_def map_prod.id spmf.map_id0 map_fun_id)"], ["", "lemma apply_state_iso_compose: \"apply_state_iso si1 (apply_state_iso si2 oracle) = \n    apply_state_iso (map_prod (\\<lambda>f. f o (fst si2)) ((o) (snd si2)) si1) oracle\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_state_iso si1 (apply_state_iso si2 oracle) =\n    apply_state_iso\n     (map_prod (\\<lambda>f. f \\<circ> fst si2) ((\\<circ>) (snd si2)) si1)\n     oracle", "unfolding apply_state_iso_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case si1 of\n     (f, g) \\<Rightarrow> map_fun g (map_fun id (map_spmf (map_prod id f))))\n     ((case si2 of\n       (f, g) \\<Rightarrow>\n         map_fun g (map_fun id (map_spmf (map_prod id f))))\n       oracle) =\n    (case map_prod (\\<lambda>f. f \\<circ> fst si2) ((\\<circ>) (snd si2))\n           si1 of\n     (f, g) \\<Rightarrow> map_fun g (map_fun id (map_spmf (map_prod id f))))\n     oracle", "by (auto simp add: split_def id_def o_def map_prod_def map_fun_def map_spmf_conv_bind_spmf)"], ["", "lemma apply_wiring_state_iso_assoc:\n    \"apply_wiring wr (apply_state_iso si oracle) = apply_state_iso si (apply_wiring wr oracle)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apply_wiring wr (apply_state_iso si oracle) =\n    apply_state_iso si (apply_wiring wr oracle)", "unfolding apply_state_iso_def apply_wiring_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case wr of\n     (f, g) \\<Rightarrow> map_fun id (map_fun f (map_spmf (map_prod g id))))\n     ((case si of\n       (f, g) \\<Rightarrow>\n         map_fun g (map_fun id (map_spmf (map_prod id f))))\n       oracle) =\n    (case si of\n     (f, g) \\<Rightarrow> map_fun g (map_fun id (map_spmf (map_prod id f))))\n     ((case wr of\n       (f, g) \\<Rightarrow>\n         map_fun id (map_fun f (map_spmf (map_prod g id))))\n       oracle)", "by (auto simp add: split_def id_def o_def map_prod_def map_fun_def map_spmf_conv_bind_spmf)"], ["", "lemma \n  resource_of_oracle_state_iso:\n  assumes \"state_iso fg\"\n  shows \"resource_of_oracle (apply_state_iso fg oracle) s = resource_of_oracle oracle (snd fg s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RES (apply_state_iso fg oracle) s = RES oracle (snd fg s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. RES (apply_state_iso fg oracle) s = RES oracle (snd fg s)", "have [simp]: \"snd fg (fst fg x) = x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd fg (fst fg x) = x", "using assms"], ["proof (prove)\nusing this:\n  state_iso fg\n\ngoal (1 subgoal):\n 1. snd fg (fst fg x) = x", "by(simp add: state_iso_def split_beta type_definition.Rep_inverse)"], ["proof (state)\nthis:\n  snd fg (fst fg ?x) = ?x\n\ngoal (1 subgoal):\n 1. RES (apply_state_iso fg oracle) s = RES oracle (snd fg s)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. RES (apply_state_iso fg oracle) s = RES oracle (snd fg s)", "by(coinduction arbitrary: s)\n      (auto 4 3 simp add: rel_fun_def spmf_rel_map apply_state_iso_def split_def intro!: rel_spmf_reflI)"], ["proof (state)\nthis:\n  RES (apply_state_iso fg oracle) s = RES oracle (snd fg s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Parallel State Isomorphism\\<close>"], ["", "definition \n  parallel_state_iso :: \" (('s_core1 \\<times> 's_core2) \\<times> ('s_rest1 \\<times> 's_rest2),\n    ('s_core1 \\<times> 's_rest1) \\<times> ('s_core2 \\<times> 's_rest2)) state_iso\" \n  where\n    \"parallel_state_iso = \n      (\\<lambda>((s11, s12), (s21, s22)). ((s11, s21), (s12, s22)),\n        \\<lambda>((s11, s21), (s12, s22)). ((s11, s12), (s21, s22)))\""], ["", "lemma \n  state_iso_parallel_state_iso [simp]: \"state_iso parallel_state_iso\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_iso parallel_state_iso", "by (auto simp add: type_definition_def state_iso_def parallel_state_iso_def)"], ["", "subsection \\<open>Trisplit State Isomorphism\\<close>"], ["", "definition \n  iso_trisplit \n  where\n    \"iso_trisplit = \n      (\\<lambda>(((s11, s12), s13), (s21, s22), s23). (((s11, s21), s12, s22), s13, s23),\n        \\<lambda>(((s11, s21), s12, s22), s13, s23). (((s11, s12), s13), (s21, s22), s23))\""], ["", "lemma \n  state_iso_fuse_par [simp]: \"state_iso iso_trisplit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_iso iso_trisplit", "by(simp add: state_iso_def iso_trisplit_def; unfold_locales; simp add: split_def)"], ["", "subsection \\<open>Assocl-Swap State Isomorphism\\<close>"], ["", "definition \n  iso_swapar \n  where\n    \"iso_swapar = (\\<lambda>((sm, s1), s2). (s1, sm, s2), \\<lambda>(s1, sm, s2). ((sm, s1), s2))\""], ["", "lemma \n  state_iso_swapar [simp]: \"state_iso iso_swapar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_iso iso_swapar", "by(simp add: state_iso_def iso_swapar_def; unfold_locales; simp add: split_def)"], ["", "end"]]}