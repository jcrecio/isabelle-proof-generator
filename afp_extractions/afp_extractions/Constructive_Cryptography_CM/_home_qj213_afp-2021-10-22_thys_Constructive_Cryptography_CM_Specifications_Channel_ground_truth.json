{"file_name": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography_CM/Specifications/Channel.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography_CM", "problem_names": ["lemma Alice_neq_iff [simp]: \"Alice \\<noteq> x \\<longleftrightarrow> x = Bob\"", "lemma neq_Alice_iff [simp]: \"x \\<noteq> Alice \\<longleftrightarrow> x = Bob\"", "lemma Bob_neq_iff [simp]: \"Bob \\<noteq> x \\<longleftrightarrow> x = Alice\"", "lemma neq_Bob_iff [simp]: \"x \\<noteq> Bob \\<longleftrightarrow> x = Alice\"", "lemma Alice_in_iff_nonempty: \"Alice \\<in> A \\<longleftrightarrow> A \\<noteq> {}\" if \"Bob \\<notin> A\"", "lemma Bob_in_iff_nonempty: \"Bob \\<in> A \\<longleftrightarrow> A \\<noteq> {}\" if \"Alice \\<notin> A\"", "lemma poke_alt_def:\n  \"poke = (\\<lambda>(s, ps) e. map_spmf (Pair s) (case e of Event_Shell party \\<Rightarrow> if party \\<in> ps then return_pmf None else return_spmf (insert party ps)))\"", "lemma in_set_spmf_iface_drop: \"ys' \\<in> set_spmf (iface_drop s x) \\<longleftrightarrow> False\"", "lemma in_set_spmf_iface_look: \"ys' \\<in> set_spmf (iface_look s x) \\<longleftrightarrow>\n  (\\<exists>msg parties. s = (State_Store msg, parties) \\<and> ys' = (Out_Look (leak msg), State_Store msg, parties))\"", "lemma in_set_spmf_iface_fedit: \"ys' \\<in> set_spmf (iface_fedit s x) \\<longleftrightarrow>\n  (\\<exists>msg parties msg'. s = (State_Store msg, parties) \\<and> x = (Inp_Fedit msg') \\<and>\n      ys' = (if editable then (Out_Fedit, State_Collect msg', parties) else (Out_Fedit, State_Collect msg, parties)))\"", "lemma in_set_spmf_iface_alice: \"ys' \\<in> set_spmf (iface_alice s x) \\<longleftrightarrow>\n  (\\<exists>parties msg. s = (State_Void, parties) \\<and> x = Inp_Send msg \\<and> Alice \\<in> parties \\<and> ys' = (Out_Send, State_Store msg, parties))\"", "lemma in_set_spmf_iface_bob: \"ys' \\<in> set_spmf (iface_bob s x) \\<longleftrightarrow>\n  (\\<exists>msg parties. s = (State_Collect msg, parties) \\<and> Bob \\<in> parties \\<and> ys' = (Out_Recv msg, State_Collected, parties))\"", "lemma WT_core [WT_intro]:\n  \"WT_core (\\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_uniform (Inp_Fedit ` valid_messages) UNIV)) (\\<I>_uniform (Inp_Send ` valid_messages) UNIV \\<oplus>\\<^sub>\\<I> (\\<I>_uniform UNIV (Out_Recv ` valid_messages)))\n     (pred_prod (pred_s_kernel (\\<lambda>msg. msg \\<in> valid_messages)) (\\<lambda>_. True)) core\"", "lemma WT_fuse [WT_intro]: \n  assumes [WT_intro]: \"WT_rest \\<I>_adv_rest \\<I>_usr_rest I_rest rest\"\n    shows  \"((\\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_uniform (Inp_Fedit ` valid_messages) UNIV)) \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I> \n      ((\\<I>_uniform (Inp_Send ` valid_messages) UNIV \\<oplus>\\<^sub>\\<I> \\<I>_uniform UNIV (Out_Recv ` valid_messages)) \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest) \\<turnstile>res resource rest \\<surd>\""], "translations": [["", "lemma Alice_neq_iff [simp]: \"Alice \\<noteq> x \\<longleftrightarrow> x = Bob\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Alice \\<noteq> x) = (x = Bob)", "by(cases x) simp_all"], ["", "lemma neq_Alice_iff [simp]: \"x \\<noteq> Alice \\<longleftrightarrow> x = Bob\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<noteq> Alice) = (x = Bob)", "by(cases x) simp_all"], ["", "lemma Bob_neq_iff [simp]: \"Bob \\<noteq> x \\<longleftrightarrow> x = Alice\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Bob \\<noteq> x) = (x = Alice)", "by(cases x) simp_all"], ["", "lemma neq_Bob_iff [simp]: \"x \\<noteq> Bob \\<longleftrightarrow> x = Alice\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<noteq> Bob) = (x = Alice)", "by(cases x) simp_all"], ["", "lemma Alice_in_iff_nonempty: \"Alice \\<in> A \\<longleftrightarrow> A \\<noteq> {}\" if \"Bob \\<notin> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Alice \\<in> A) = (A \\<noteq> {})", "using that"], ["proof (prove)\nusing this:\n  Bob \\<notin> A\n\ngoal (1 subgoal):\n 1. (Alice \\<in> A) = (A \\<noteq> {})", "by(auto)(metis (full_types) party.exhaust)"], ["", "lemma Bob_in_iff_nonempty: \"Bob \\<in> A \\<longleftrightarrow> A \\<noteq> {}\" if \"Alice \\<notin> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Bob \\<in> A) = (A \\<noteq> {})", "using that"], ["proof (prove)\nusing this:\n  Alice \\<notin> A\n\ngoal (1 subgoal):\n 1. (Bob \\<in> A) = (A \\<noteq> {})", "by(auto)(metis (full_types) party.exhaust)"], ["", "subsection \\<open>Defining the event handler\\<close>"], ["", "fun poke :: \"('msg state, event) handler\"\n  where\n    \"poke (s_kernel, parties) (Event_Shell party) =\n      (if party \\<in> parties then \n        return_pmf None \n      else \n        return_spmf (s_kernel, insert party parties))\""], ["", "lemma poke_alt_def:\n  \"poke = (\\<lambda>(s, ps) e. map_spmf (Pair s) (case e of Event_Shell party \\<Rightarrow> if party \\<in> ps then return_pmf None else return_spmf (insert party ps)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poke =\n    (\\<lambda>(s, ps) e.\n        map_spmf (Pair s)\n         (case e of\n          Event_Shell party \\<Rightarrow>\n            if party \\<in> ps then return_pmf None\n            else return_spmf (insert party ps)))", "by(simp add: fun_eq_iff split: event.split)"], ["", "subsection \\<open>Defining the adversary interfaces\\<close>"], ["", "fun iface_drop :: \"('msg state, iadv_drop, oadv_drop) oracle'\"\n  where\n    \"iface_drop _ _ = return_pmf None\""], ["", "fun iface_look :: \"('msg state, iadv_look, 'leak oadv_look) oracle'\"\n  where\n    \"iface_look (State_Store msg, parties) _ =\n      return_spmf (Out_Look (leak msg), State_Store msg, parties)\"\n  | \"iface_look _ _ = return_pmf None\""], ["", "fun iface_fedit :: \"('msg state, 'msg iadv_fedit, oadv_fedit) oracle'\"\n  where\n    \"iface_fedit (State_Store msg, parties) (Inp_Fedit msg') = \n      (if editable then\n        return_spmf (Out_Fedit, State_Collect msg', parties)\n      else\n        return_spmf (Out_Fedit, State_Collect msg, parties))\"\n  | \"iface_fedit _ _ = return_pmf None\""], ["", "abbreviation iface_adv :: \"('msg state, 'msg iadv, 'leak oadv) oracle'\"\n  where\n    \"iface_adv \\<equiv> plus_oracle iface_drop (plus_oracle iface_look iface_fedit)\""], ["", "lemma in_set_spmf_iface_drop: \"ys' \\<in> set_spmf (iface_drop s x) \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ys' \\<in> set_spmf (iface_drop s x)) = False", "by simp"], ["", "lemma in_set_spmf_iface_look: \"ys' \\<in> set_spmf (iface_look s x) \\<longleftrightarrow>\n  (\\<exists>msg parties. s = (State_Store msg, parties) \\<and> ys' = (Out_Look (leak msg), State_Store msg, parties))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ys' \\<in> set_spmf (iface_look s x)) =\n    (\\<exists>msg parties.\n        s = (State_Store msg, parties) \\<and>\n        ys' = (Out_Look (leak msg), State_Store msg, parties))", "by(cases \"(s, x)\" rule: iface_look.cases) simp_all"], ["", "lemma in_set_spmf_iface_fedit: \"ys' \\<in> set_spmf (iface_fedit s x) \\<longleftrightarrow>\n  (\\<exists>msg parties msg'. s = (State_Store msg, parties) \\<and> x = (Inp_Fedit msg') \\<and>\n      ys' = (if editable then (Out_Fedit, State_Collect msg', parties) else (Out_Fedit, State_Collect msg, parties)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ys' \\<in> set_spmf (iface_fedit s x)) =\n    (\\<exists>msg parties msg'.\n        s = (State_Store msg, parties) \\<and>\n        x = Inp_Fedit msg' \\<and>\n        ys' =\n        (if editable then (Out_Fedit, State_Collect msg', parties)\n         else (Out_Fedit, State_Collect msg, parties)))", "by(cases \"(s, x)\" rule: iface_fedit.cases) simp_all"], ["", "subsection \\<open>Defining the user interfaces\\<close>"], ["", "fun iface_alice :: \"('msg state, 'msg iusr_alice, ousr_alice) oracle'\"\n  where\n    \"iface_alice (State_Void, parties) (Inp_Send msg) = \n      (if Alice \\<in> parties then\n        return_spmf (Out_Send, State_Store msg, parties)\n      else\n        return_pmf None)\"\n  | \"iface_alice _ _ = return_pmf None\""], ["", "fun iface_bob :: \"('msg state, iusr_bob, 'msg ousr_bob) oracle'\"\n  where\n    \"iface_bob (State_Collect msg, parties) _ = \n      (if Bob \\<in> parties then\n        return_spmf (Out_Recv msg, State_Collected, parties)\n      else\n        return_pmf None)\"\n  | \"iface_bob _ _ = return_pmf None\""], ["", "abbreviation iface_usr :: \"('msg state, 'msg iusr, 'msg ousr) oracle'\"\n  where\n    \"iface_usr \\<equiv> plus_oracle iface_alice iface_bob\""], ["", "lemma in_set_spmf_iface_alice: \"ys' \\<in> set_spmf (iface_alice s x) \\<longleftrightarrow>\n  (\\<exists>parties msg. s = (State_Void, parties) \\<and> x = Inp_Send msg \\<and> Alice \\<in> parties \\<and> ys' = (Out_Send, State_Store msg, parties))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ys' \\<in> set_spmf (iface_alice s x)) =\n    (\\<exists>parties msg.\n        s = (State_Void, parties) \\<and>\n        x = Inp_Send msg \\<and>\n        Alice \\<in> parties \\<and>\n        ys' = (Out_Send, State_Store msg, parties))", "by(cases \"(s, x)\" rule: iface_alice.cases) simp_all"], ["", "lemma in_set_spmf_iface_bob: \"ys' \\<in> set_spmf (iface_bob s x) \\<longleftrightarrow>\n  (\\<exists>msg parties. s = (State_Collect msg, parties) \\<and> Bob \\<in> parties \\<and> ys' = (Out_Recv msg, State_Collected, parties))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ys' \\<in> set_spmf (iface_bob s x)) =\n    (\\<exists>msg parties.\n        s = (State_Collect msg, parties) \\<and>\n        Bob \\<in> parties \\<and>\n        ys' = (Out_Recv msg, State_Collected, parties))", "by(cases \"(s, x)\" rule: iface_bob.cases) simp_all"], ["", "subsection \\<open>Defining the Fused Resource\\<close>"], ["", "primcorec core :: \"('msg state, event, 'msg iadv, 'msg iusr, 'leak oadv, 'msg ousr) core\" \n  where\n    \"cpoke core = poke\"\n  | \"cfunc_adv core = iface_adv\"\n  | \"cfunc_usr core = iface_usr\""], ["", "sublocale fused_resource core \"(State_Void, {})\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "subsubsection \\<open>Lemma showing that the resulting resource is well-typed\\<close>"], ["", "lemma WT_core [WT_intro]:\n  \"WT_core (\\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_uniform (Inp_Fedit ` valid_messages) UNIV)) (\\<I>_uniform (Inp_Send ` valid_messages) UNIV \\<oplus>\\<^sub>\\<I> (\\<I>_uniform UNIV (Out_Recv ` valid_messages)))\n     (pred_prod (pred_s_kernel (\\<lambda>msg. msg \\<in> valid_messages)) (\\<lambda>_. True)) core\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WT_core\n     (\\<I>_full \\<oplus>\\<^sub>\\<I>\n      (\\<I>_full \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform (Inp_Fedit ` valid_messages) UNIV))\n     (\\<I>_uniform (Inp_Send ` valid_messages) UNIV \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform UNIV (Out_Recv ` valid_messages))\n     (pred_prod (pred_s_kernel (\\<lambda>msg. msg \\<in> valid_messages))\n       (\\<lambda>_. True))\n     core", "apply(rule WT_core.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s e s'.\n       \\<lbrakk>s' \\<in> set_spmf (cpoke core s e);\n        pred_prod (pred_s_kernel (\\<lambda>msg. msg \\<in> valid_messages))\n         (\\<lambda>_. True) s\\<rbrakk>\n       \\<Longrightarrow> pred_prod\n                          (pred_s_kernel\n                            (\\<lambda>msg. msg \\<in> valid_messages))\n                          (\\<lambda>_. True) s'\n 2. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (cfunc_adv core s x);\n        x \\<in> outs_\\<I>\n                 (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_uniform (Inp_Fedit ` valid_messages) UNIV));\n        pred_prod (pred_s_kernel (\\<lambda>msg. msg \\<in> valid_messages))\n         (\\<lambda>_. True) s\\<rbrakk>\n       \\<Longrightarrow> y \\<in> responses_\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_uniform\n                                     (Inp_Fedit ` valid_messages) UNIV))\n                                  x \\<and>\n                         pred_prod\n                          (pred_s_kernel\n                            (\\<lambda>msg. msg \\<in> valid_messages))\n                          (\\<lambda>_. True) s'\n 3. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (cfunc_usr core s x);\n        x \\<in> outs_\\<I>\n                 (\\<I>_uniform (Inp_Send ` valid_messages)\n                   UNIV \\<oplus>\\<^sub>\\<I>\n                  \\<I>_uniform UNIV (Out_Recv ` valid_messages));\n        pred_prod (pred_s_kernel (\\<lambda>msg. msg \\<in> valid_messages))\n         (\\<lambda>_. True) s\\<rbrakk>\n       \\<Longrightarrow> y \\<in> responses_\\<I>\n                                  (\\<I>_uniform (Inp_Send ` valid_messages)\n                                    UNIV \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_uniform UNIV\n                                    (Out_Recv ` valid_messages))\n                                  x \\<and>\n                         pred_prod\n                          (pred_s_kernel\n                            (\\<lambda>msg. msg \\<in> valid_messages))\n                          (\\<lambda>_. True) s'", "subgoal for s e s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s' \\<in> set_spmf (cpoke core s e);\n     pred_prod (pred_s_kernel (\\<lambda>msg. msg \\<in> valid_messages))\n      (\\<lambda>_. True) s\\<rbrakk>\n    \\<Longrightarrow> pred_prod\n                       (pred_s_kernel\n                         (\\<lambda>msg. msg \\<in> valid_messages))\n                       (\\<lambda>_. True) s'", "by(cases \"(s, e)\" rule: poke.cases)(auto split: if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (cfunc_adv core s x);\n        x \\<in> outs_\\<I>\n                 (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                   \\<I>_uniform (Inp_Fedit ` valid_messages) UNIV));\n        pred_prod (pred_s_kernel (\\<lambda>msg. msg \\<in> valid_messages))\n         (\\<lambda>_. True) s\\<rbrakk>\n       \\<Longrightarrow> y \\<in> responses_\\<I>\n                                  (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                   (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                    \\<I>_uniform\n                                     (Inp_Fedit ` valid_messages) UNIV))\n                                  x \\<and>\n                         pred_prod\n                          (pred_s_kernel\n                            (\\<lambda>msg. msg \\<in> valid_messages))\n                          (\\<lambda>_. True) s'\n 2. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (cfunc_usr core s x);\n        x \\<in> outs_\\<I>\n                 (\\<I>_uniform (Inp_Send ` valid_messages)\n                   UNIV \\<oplus>\\<^sub>\\<I>\n                  \\<I>_uniform UNIV (Out_Recv ` valid_messages));\n        pred_prod (pred_s_kernel (\\<lambda>msg. msg \\<in> valid_messages))\n         (\\<lambda>_. True) s\\<rbrakk>\n       \\<Longrightarrow> y \\<in> responses_\\<I>\n                                  (\\<I>_uniform (Inp_Send ` valid_messages)\n                                    UNIV \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_uniform UNIV\n                                    (Out_Recv ` valid_messages))\n                                  x \\<and>\n                         pred_prod\n                          (pred_s_kernel\n                            (\\<lambda>msg. msg \\<in> valid_messages))\n                          (\\<lambda>_. True) s'", "subgoal for s x y s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(y, s') \\<in> set_spmf (cfunc_adv core s x);\n     x \\<in> outs_\\<I>\n              (\\<I>_full \\<oplus>\\<^sub>\\<I>\n               (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                \\<I>_uniform (Inp_Fedit ` valid_messages) UNIV));\n     pred_prod (pred_s_kernel (\\<lambda>msg. msg \\<in> valid_messages))\n      (\\<lambda>_. True) s\\<rbrakk>\n    \\<Longrightarrow> y \\<in> responses_\\<I>\n                               (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                 \\<I>_uniform (Inp_Fedit ` valid_messages)\n                                  UNIV))\n                               x \\<and>\n                      pred_prod\n                       (pred_s_kernel\n                         (\\<lambda>msg. msg \\<in> valid_messages))\n                       (\\<lambda>_. True) s'", "by(cases \"(s, projl (projr x))\" rule: iface_look.cases)(auto split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (cfunc_usr core s x);\n        x \\<in> outs_\\<I>\n                 (\\<I>_uniform (Inp_Send ` valid_messages)\n                   UNIV \\<oplus>\\<^sub>\\<I>\n                  \\<I>_uniform UNIV (Out_Recv ` valid_messages));\n        pred_prod (pred_s_kernel (\\<lambda>msg. msg \\<in> valid_messages))\n         (\\<lambda>_. True) s\\<rbrakk>\n       \\<Longrightarrow> y \\<in> responses_\\<I>\n                                  (\\<I>_uniform (Inp_Send ` valid_messages)\n                                    UNIV \\<oplus>\\<^sub>\\<I>\n                                   \\<I>_uniform UNIV\n                                    (Out_Recv ` valid_messages))\n                                  x \\<and>\n                         pred_prod\n                          (pred_s_kernel\n                            (\\<lambda>msg. msg \\<in> valid_messages))\n                          (\\<lambda>_. True) s'", "subgoal for s x y s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(y, s') \\<in> set_spmf (cfunc_usr core s x);\n     x \\<in> outs_\\<I>\n              (\\<I>_uniform (Inp_Send ` valid_messages)\n                UNIV \\<oplus>\\<^sub>\\<I>\n               \\<I>_uniform UNIV (Out_Recv ` valid_messages));\n     pred_prod (pred_s_kernel (\\<lambda>msg. msg \\<in> valid_messages))\n      (\\<lambda>_. True) s\\<rbrakk>\n    \\<Longrightarrow> y \\<in> responses_\\<I>\n                               (\\<I>_uniform (Inp_Send ` valid_messages)\n                                 UNIV \\<oplus>\\<^sub>\\<I>\n                                \\<I>_uniform UNIV\n                                 (Out_Recv ` valid_messages))\n                               x \\<and>\n                      pred_prod\n                       (pred_s_kernel\n                         (\\<lambda>msg. msg \\<in> valid_messages))\n                       (\\<lambda>_. True) s'", "by(cases \"(s, projl x)\" rule: iface_alice.cases)(auto split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WT_fuse [WT_intro]: \n  assumes [WT_intro]: \"WT_rest \\<I>_adv_rest \\<I>_usr_rest I_rest rest\"\n    shows  \"((\\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_full \\<oplus>\\<^sub>\\<I> \\<I>_uniform (Inp_Fedit ` valid_messages) UNIV)) \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I> \n      ((\\<I>_uniform (Inp_Send ` valid_messages) UNIV \\<oplus>\\<^sub>\\<I> \\<I>_uniform UNIV (Out_Recv ` valid_messages)) \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest) \\<turnstile>res resource rest \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<I>_full \\<oplus>\\<^sub>\\<I>\n      (\\<I>_full \\<oplus>\\<^sub>\\<I>\n       \\<I>_uniform (Inp_Fedit ` valid_messages) UNIV)) \\<oplus>\\<^sub>\\<I>\n     \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n    ((\\<I>_uniform (Inp_Send ` valid_messages) UNIV \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform UNIV (Out_Recv ` valid_messages)) \\<oplus>\\<^sub>\\<I>\n     \\<I>_usr_rest) \n    \\<turnstile>res resource rest \\<surd>", "by(rule WT_intro)+ simp"], ["", "end"], ["", "end"]]}