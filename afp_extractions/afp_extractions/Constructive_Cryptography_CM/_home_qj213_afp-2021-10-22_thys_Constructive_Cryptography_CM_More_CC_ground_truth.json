{"file_name": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography_CM/More_CC.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography_CM", "problem_names": ["lemma eq_alt_conversep: \"(=) = (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse>\"", "lemma Sigma_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_set A ===> (A ===> rel_set B) ===> rel_set (rel_prod A B)) Sigma Sigma\"", "lemma empty_eq_Plus [simp]: \"{} = A <+> B \\<longleftrightarrow> A = {} \\<and> B = {}\"", "lemma insert_Inl_Plus [simp]: \"insert (Inl x) (A <+> B) = insert x A <+> B\"", "lemma insert_Inr_Plus [simp]: \"insert (Inr x) (A <+> B) = A <+> insert x B\"", "lemma map_sum_image_Plus [simp]: \"map_sum f g ` (A <+> B) = f ` A <+> g ` B\"", "lemma Plus_subset_Plus_iff [simp]: \"A <+> B \\<subseteq> C <+> D \\<longleftrightarrow> A \\<subseteq> C \\<and> B \\<subseteq> D\"", "lemma map_sum_eq_Inl_iff: \"map_sum f g x = Inl y \\<longleftrightarrow> (\\<exists>x'. x = Inl x' \\<and> y = f x')\"", "lemma map_sum_eq_Inr_iff: \"map_sum f g x = Inr y \\<longleftrightarrow> (\\<exists>x'. x = Inr x' \\<and> y = g x')\"", "lemma surj_map_sum: \"surj (map_sum f g)\" if \"surj f\" \"surj g\"", "lemma bij_map_sumI [simp]: \"bij (map_sum f g)\" if \"bij f\" \"bij g\"", "lemma inv_map_sum [simp]:\n  \"\\<lbrakk> bij f; bij g \\<rbrakk> \\<Longrightarrow> inv_into UNIV (map_sum f g) = map_sum (inv_into UNIV f) (inv_into UNIV g)\"", "lemma admissible_le1I:\n  \"ccpo.admissible lub ord (\\<lambda>x. f x \\<le> y)\"\n  if \"cont lub ord Sup (\\<le>) f\"", "lemma admissible_le1_mcont [cont_intro]:\n  \"ccpo.admissible lub ord (\\<lambda>x. f x \\<le> y)\" if \"mcont lub ord Sup (\\<le>) f\"", "lemma eq_alt_conversep2: \"(=) = ((BNF_Def.Grp UNIV id)\\<inverse>\\<inverse>)\\<inverse>\\<inverse>\"", "lemma nn_integral_indicator_singleton1 [simp]:\n  assumes [measurable]: \"{y} \\<in> sets M\"\n  shows \"(\\<integral>\\<^sup>+x. indicator {y} x * f x \\<partial>M) = emeasure M {y} * f y\"", "lemma nn_integral_indicator_singleton1' [simp]:\n  assumes \"{y} \\<in> sets M\"\n  shows \"(\\<integral>\\<^sup>+x. indicator {x} y * f x \\<partial>M) = emeasure M {y} * f y\"", "lemma pmf_eq_1_iff: \"pmf p x = 1 \\<longleftrightarrow> p = return_pmf x\" (is \"?lhs = ?rhs\")", "lemma measure_spmf_cong: \"measure (measure_spmf p) A = measure (measure_spmf p) B\"\n  if \"A \\<inter> set_spmf p = B \\<inter> set_spmf p\"", "lemma weight_spmf'_parametric [transfer_rule]: \"rel_fun (rel_spmf A) (=) weight_spmf' weight_spmf'\"", "lemma bind_spmf_to_nat_on:\n  \"bind_spmf (map_spmf (to_nat_on (set_spmf p)) p) (\\<lambda>n. f (from_nat_into (set_spmf p) n)) = bind_spmf p f\"", "lemma try_cond_spmf_fst:\n  \"try_spmf (cond_spmf_fst p x) q = (if x \\<in> fst ` set_spmf p then cond_spmf_fst p x else q)\"", "lemma measure_try_spmf:\n  \"measure (measure_spmf (try_spmf p q)) A = measure (measure_spmf p) A + pmf p None * measure (measure_spmf q) A\"", "lemma rel_spmf_OO_trans_strong:\n  \"\\<lbrakk> rel_spmf R p q; rel_spmf S q r \\<rbrakk> \\<Longrightarrow> rel_spmf (R OO eq_onp (\\<lambda>x. x \\<in> set_spmf q) OO S) p r\"", "lemma mcont2mcont_spmf [cont_intro]:\n  \"mcont lub ord Sup (\\<le>) (\\<lambda>p. spmf (f p) x)\"\n  if \"mcont lub ord lub_spmf (ord_spmf (=)) f\"", "lemma ord_spmf_try_spmf2: \"ord_spmf R p (try_spmf p q)\" if \"rel_spmf R p p\"", "lemma ord_spmf_lossless_spmfD1:\n  assumes \"ord_spmf R p q\"\n    and \"lossless_spmf p\"\n  shows \"rel_spmf R p q\"", "lemma restrict_spmf_mono:\n  \"ord_spmf (=) p q \\<Longrightarrow> ord_spmf (=) (p \\<upharpoonleft> A) (q \\<upharpoonleft> A)\"", "lemma restrict_lub_spmf:\n  assumes chain: \"Complete_Partial_Order.chain (ord_spmf (=)) Y\"\n  shows \"restrict_spmf (lub_spmf Y) A = lub_spmf ((\\<lambda>p. restrict_spmf p A) ` Y)\" (is \"?lhs = ?rhs\")", "lemma mono2mono_restrict_spmf [THEN spmf.mono2mono]:\n  shows monotone_restrict_spmf: \"monotone (ord_spmf (=)) (ord_spmf (=)) (\\<lambda>p. p \\<upharpoonleft> A)\"", "lemma mcont2mcont_restrict_spmf [THEN spmf.mcont2mcont, cont_intro]:\n  shows  mcont_restrict_spmf: \"mcont lub_spmf (ord_spmf (=)) lub_spmf (ord_spmf (=)) (\\<lambda>p. restrict_spmf p A)\"", "lemma ord_spmf_case_option: \"ord_spmf R (case x of None \\<Rightarrow> a | Some y \\<Rightarrow> b y) (case x of None \\<Rightarrow> a' | Some y \\<Rightarrow> b' y)\"\n  if \"ord_spmf R a a'\" \"\\<And>y. ord_spmf R (b y) (b' y)\"", "lemma ord_spmf_map_spmfI: \"ord_spmf (=) (map_spmf f p) (map_spmf f q)\" if \"ord_spmf (=) p q\"", "lemma mk_lossless_cond_spmf [simp]: \"mk_lossless (cond_spmf p A) = cond_spmf p A\"", "lemma cond_bind_pmf_nonneg: \"F x \\<ge> 0\"", "lemma nonzero: \"measure (measure_pmf (bind_pmf p f)) A > 0\"", "lemma cond_bind_pmf_prob: \"(\\<integral>\\<^sup>+ x. F x \\<partial>count_space UNIV) = 1\"", "lemma pmf_cond_bind_pmf: \"pmf cond_bind_pmf x = F x\"", "lemma set_cond_bind_pmf: \"set_pmf cond_bind_pmf = {x\\<in>set_pmf p. set_pmf (f x) \\<inter> A \\<noteq> {}}\"", "lemma cond_bind_pmf: \"cond_pmf (bind_pmf p f) A = bind_pmf cond_bind_pmf (\\<lambda>x. cond_pmf (f x) A)\"\n  (is \"?lhs = ?rhs\")", "lemma cond_spmf_try1:\n  \"cond_spmf (try_spmf p q) A = cond_spmf p A\" if \"set_spmf q \\<inter> A = {}\"", "lemma cond_spmf_cong: \"cond_spmf p A = cond_spmf p B\" if \"A \\<inter> set_spmf p = B \\<inter> set_spmf p\"", "lemma cond_spmf_pair_spmf:\n  \"cond_spmf (pair_spmf p q) (A \\<times> B) = pair_spmf (cond_spmf p A) (cond_spmf q B)\" (is \"?lhs = ?rhs\")", "lemma cond_spmf_pair_spmf1:\n  \"cond_spmf_fst (map_spmf (\\<lambda>((x, s'), y). (f x, s', y)) (pair_spmf p q)) x =\n   pair_spmf (cond_spmf_fst (map_spmf (\\<lambda>(x, s'). (f x, s')) p) x) q\" (is \"?lhs = ?rhs\")\n  if \"lossless_spmf q\"", "lemma try_cond_spmf: \"try_spmf (cond_spmf p A) q = (if set_spmf p \\<inter> A \\<noteq> {} then cond_spmf p A else q)\"", "lemma cond_spmf_try2:\n  \"cond_spmf (try_spmf p q) A = (if lossless_spmf p then return_pmf None else cond_spmf q A)\" if \"set_spmf p \\<inter> A = {}\"", "lemma defined: \"\\<lbrakk> y \\<in> set_spmf (f x); y \\<in> A; x \\<in> set_spmf p \\<rbrakk> \n  \\<Longrightarrow> Some ` A \\<inter> (\\<Union>x\\<in>set_pmf p. set_pmf (case x of None \\<Rightarrow> return_pmf None | Some x \\<Rightarrow> f x)) \\<noteq> {}\"", "lemma spmf_cond_bind_spmf [simp]:\n  \"spmf (cond_bind_spmf p f A) x = spmf p x * measure (measure_spmf (f x)) A / measure (measure_spmf (bind_spmf p f)) A\"", "lemma set_cond_bind_spmf [simp]:\n  \"set_spmf (cond_bind_spmf p f A) = {x\\<in>set_spmf p. set_spmf (f x) \\<inter> A \\<noteq> {}}\"", "lemma cond_bind_spmf: \"cond_spmf (bind_spmf p f) A = bind_spmf (cond_bind_spmf p f A) (\\<lambda>x. cond_spmf (f x) A)\"", "lemma cond_spmf_fst_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_spmf (rel_prod (=) B) ===> (=) ===> rel_spmf B) cond_spmf_fst cond_spmf_fst\"", "lemma cond_spmf_fst_map_prod:\n  \"cond_spmf_fst (map_spmf (\\<lambda>(x, y). (f x, g x y)) p) (f x) = map_spmf (g x) (cond_spmf_fst p x)\"\n  if \"inj_on f (insert x (fst ` set_spmf p))\"", "lemma cond_spmf_fst_map_prod_inj:\n  \"cond_spmf_fst (map_spmf (\\<lambda>(x, y). (f x, g x y)) p) (f x) =  map_spmf (g x) (cond_spmf_fst p x)\"\n  if \"inj f\"", "lemma cond_bind_spmf_fst_map_spmf_fst:\n  \"cond_bind_spmf_fst p (map_spmf fst \\<circ> f) x = cond_bind_spmf p f ({x} \\<times> UNIV)\" (is \"?lhs = ?rhs\")", "lemma cond_spmf_fst_bind: \"cond_spmf_fst (bind_spmf p f) x = \n  bind_spmf (cond_bind_spmf_fst p (map_spmf fst \\<circ> f) x) (\\<lambda>y. cond_spmf_fst (f y) x)\"", "lemma spmf_cond_bind_spmf_fst [simp]:\n  \"spmf (cond_bind_spmf_fst p f x) i = spmf p i * spmf (f i) x / spmf (bind_spmf p f) x\"", "lemma set_cond_bind_spmf_fst [simp]:\n  \"set_spmf (cond_bind_spmf_fst p f x) = {y \\<in> set_spmf p. x \\<in> set_spmf (f y)}\"", "lemma map_cond_spmf_fst: \"map_spmf f (cond_spmf_fst p x) = cond_spmf_fst (map_spmf (apsnd f) p) x\"", "lemma cond_spmf_fst_try1:\n  \"cond_spmf_fst (try_spmf p q) x = cond_spmf_fst p x\" if \"x \\<notin> fst ` set_spmf q\"", "lemma cond_spmf_fst_try2:\n  \"cond_spmf_fst (try_spmf p q) x = (if lossless_spmf p then return_pmf None else cond_spmf_fst q x)\" if \"x \\<notin> fst ` set_spmf p\"", "lemma cond_spmf_fst_map_inj:\n  \"cond_spmf_fst (map_spmf (apfst f) p) (f x) = cond_spmf_fst p x\" if \"inj f\"", "lemma cond_spmf_fst_pair_spmf1:\n  \"cond_spmf_fst (map_spmf (\\<lambda>(x, y). (f x, g x y)) (pair_spmf p q)) a =\n   bind_spmf (cond_spmf_fst (map_spmf (\\<lambda>x. (f x, x)) p) a) (\\<lambda>x. map_spmf (g x) (mk_lossless q))\" (is \"?lhs = ?rhs\")", "lemma cond_spmf_fst_return_spmf':\n  \"cond_spmf_fst (return_spmf (x, y)) z = (if x = z then return_spmf y else return_pmf None)\"", "lemma left_gpv_lift_spmf [simp]: \"left_gpv (lift_spmf p) = lift_spmf p\"", "lemma right_gpv_lift_spmf [simp]: \"right_gpv (lift_spmf p) = lift_spmf p\"", "lemma map'_lift_spmf: \"map_gpv' f g h (lift_spmf p) = lift_spmf (map_spmf f p)\"", "lemma in_set_sample_uniform [simp]: \"x \\<in> set_spmf (sample_uniform n) \\<longleftrightarrow> x < n\"", "lemma (in cyclic_group) inj_on_generator_iff [simp]: \"\\<lbrakk> x < order G; y < order G \\<rbrakk> \\<Longrightarrow> \\<^bold>g [^] x = \\<^bold>g [^] y \\<longleftrightarrow> x = y\"", "lemma map_\\<I>_bot [simp]: \"map_\\<I> f g \\<bottom> = \\<bottom>\"", "lemma map_\\<I>_Inr_plus [simp]: \"map_\\<I> Inr f (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) = map_\\<I> id (f \\<circ> Inr) \\<I>2\"", "lemma interaction_bound_map_gpv'_le:\n  defines \"ib \\<equiv> interaction_bound\" \n  shows \"interaction_bound consider (map_gpv' f g h gpv) \\<le> ib (consider \\<circ> g) gpv\"", "lemma interaction_bounded_by_map_gpv' [interaction_bound]:\n  assumes \"interaction_bounded_by (consider \\<circ> g) gpv n\"\n  shows \"interaction_bounded_by consider (map_gpv' f g h gpv) n\"", "lemma map_gpv'_bind_gpv:\n  \"map_gpv' f g h (bind_gpv gpv F) = bind_gpv (map_gpv' id g h gpv) (\\<lambda>x. map_gpv' f g h (F x))\"", "lemma exec_gpv_map_gpv':\n  \"exec_gpv callee (map_gpv' f g h gpv) s =\n   map_spmf (map_prod f id) (exec_gpv (map_fun id (map_fun g (map_spmf (map_prod h id))) callee) gpv s)\"", "lemma colossless_gpv_sub_gpvs:\n  assumes \"colossless_gpv \\<I> gpv\" \"gpv' \\<in> sub_gpvs \\<I> gpv\"\n  shows \"colossless_gpv \\<I> gpv'\"", "lemma pfinite_gpv_sub_gpvs:\n  assumes \"pfinite_gpv \\<I> gpv\" \"gpv' \\<in> sub_gpvs \\<I> gpv\" \"\\<I> \\<turnstile>g gpv \\<surd>\"\n  shows \"pfinite_gpv \\<I> gpv'\"", "lemma pfinite_gpv_id_oracle [simp]: \"pfinite_gpv \\<I> (id_oracle s x)\" if \"x \\<in> outs_\\<I> \\<I>\"", "lemma plossless_gpv_try_gpvI:\n  assumes \"pfinite_gpv \\<I> gpv\"\n    and \"\\<not> colossless_gpv \\<I> gpv \\<Longrightarrow> plossless_gpv \\<I> gpv'\"\n  shows \"plossless_gpv \\<I> (TRY gpv ELSE gpv')\"", "lemma WT_gpv_try_gpvI [WT_intro]:\n  assumes \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and \"\\<not> colossless_gpv \\<I> gpv \\<Longrightarrow> \\<I> \\<turnstile>g gpv' \\<surd>\"\n  shows \"\\<I> \\<turnstile>g try_gpv gpv gpv' \\<surd>\"", "lemma (in callee_invariant_on) exec_gpv_try_gpv:\n  fixes exec_gpv1\n  defines \"exec_gpv1 \\<equiv> exec_gpv\"\n  assumes WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and pfinite: \"pfinite_gpv \\<I> gpv\"\n    and I: \"I s\"\n    and f: \"\\<And>s. I s \\<Longrightarrow> f (x, s) = z\"\n    and lossless: \"\\<And>s x. \\<lbrakk>x \\<in> outs_\\<I> \\<I>; I s\\<rbrakk> \\<Longrightarrow> lossless_spmf (callee s x)\"\n  shows \"map_spmf f (exec_gpv callee (try_gpv gpv (Done x)) s) =\n    try_spmf (map_spmf f (exec_gpv1 callee gpv s)) (return_spmf z)\"\n  (is \"?lhs = ?rhs\")", "lemma try_gpv_bind_gen_lossless': \\<comment> \\<open>generalises @{thm try_gpv_bind_gen_lossless}\\<close>\n  assumes lossless: \"gen_lossless_gpv b \\<I> gpv\"\n    and WT1: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and WT2: \"\\<I> \\<turnstile>g gpv' \\<surd>\"\n    and WTf: \"\\<And>x. x \\<in> results_gpv \\<I> gpv \\<Longrightarrow> \\<I> \\<turnstile>g f x \\<surd>\"\n  shows \"eq_\\<I>_gpv (=) \\<I> (TRY bind_gpv gpv f ELSE gpv') (bind_gpv gpv (\\<lambda>x. TRY f x ELSE gpv'))\"", "lemmas try_gpv_bind_lossless' = try_gpv_bind_gen_lossless'[where b=False]\n  and try_gpv_bind_colossless' = try_gpv_bind_gen_lossless'[where b=True]", "lemma try_gpv_bind_gpv:\n   \"try_gpv (bind_gpv gpv f) gpv' =\n    bind_gpv (try_gpv (map_gpv Some id gpv) (Done None)) (\\<lambda>x. case x of None \\<Rightarrow> gpv' | Some x' \\<Rightarrow> try_gpv (f x') gpv')\"", "lemma bind_gpv_try_gpv_map_Some:\n  \"bind_gpv (try_gpv (map_gpv Some id gpv) (Done None)) (\\<lambda>x. case x of None \\<Rightarrow> Fail | Some y \\<Rightarrow> f y) =\n   bind_gpv gpv f\"", "lemma try_gpv_left_gpv:\n  assumes \"\\<I> \\<turnstile>g gpv \\<surd>\" and WT2: \"\\<I> \\<turnstile>g gpv' \\<surd>\"\n  shows \"eq_\\<I>_gpv (=) (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') (try_gpv (left_gpv gpv) (left_gpv gpv')) (left_gpv (try_gpv gpv gpv'))\"", "lemma try_gpv_right_gpv:\n  assumes \"\\<I>' \\<turnstile>g gpv \\<surd>\" and WT2: \"\\<I>' \\<turnstile>g gpv' \\<surd>\"\n  shows \"eq_\\<I>_gpv (=) (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') (try_gpv (right_gpv gpv) (right_gpv gpv')) (right_gpv (try_gpv gpv gpv'))\"", "lemma bind_try_Done_Fail: \"bind_gpv (TRY gpv ELSE Done x) f = bind_gpv gpv f\" if \"f x = Fail\"", "lemma inline_map_gpv':\n  \"inline callee (map_gpv' f g h gpv) s = \n   map_gpv (apfst f) id (inline (map_fun id (map_fun g (map_gpv (apfst h) id)) callee) gpv s)\"", "lemma interaction_bound_try_gpv:\n  fixes \"consider\" defines \"ib \\<equiv> interaction_bound consider\"\n  shows \"interaction_bound consider (try_gpv gpv gpv') \\<le> ib gpv + ib gpv'\"", "lemma interaction_bounded_by_try_gpv [interaction_bound]:\n  \"interaction_bounded_by consider (try_gpv gpv1 gpv2) (bound1 + bound2)\"\n  if \"interaction_bounded_by consider gpv1 bound1\" \"interaction_bounded_by consider gpv2 bound2\"", "lemma interaction_bounded_by_gpv_stop [interaction_bound]:\n  assumes \"interaction_bounded_by consider gpv n\"\n  shows \"interaction_bounded_by consider (gpv_stop gpv) n\"", "lemma outs_stop_\\<I> [simp]: \"outs_\\<I> (stop_\\<I> \\<I>) = outs_\\<I> \\<I>\"", "lemma responses_stop_\\<I> [simp]: \n  \"responses_\\<I> (stop_\\<I> \\<I>) x = (if x \\<in> outs_\\<I> \\<I> then insert None (Some ` responses_\\<I> \\<I> x) else {})\"", "lemma stop_\\<I>_full [simp]: \"stop_\\<I> \\<I>_full = \\<I>_full\"", "lemma stop_\\<I>_uniform [simp]: \n  \"stop_\\<I> (\\<I>_uniform A B) = (if B = {} then \\<bottom> else \\<I>_uniform A (insert None (Some ` B)))\"", "lemma stop_\\<I>_bot [simp]: \"stop_\\<I> \\<bottom> = \\<bottom>\"", "lemma WT_gpv_stop [simp, WT_intro]: \"stop_\\<I> \\<I> \\<turnstile>g gpv_stop gpv \\<surd>\" if \"\\<I> \\<turnstile>g gpv \\<surd>\"", "lemma expectation_gpv_stop:\n  fixes fail and gpv :: \"('a, 'b, 'c) gpv\"\n  assumes WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n  and fail: \"fail \\<le> c\"\n  shows \"expectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c) (gpv_stop gpv) = expectation_gpv fail \\<I> (\\<lambda>_. c) gpv\" (is \"?lhs = ?rhs\")", "lemma pgen_lossless_gpv_stop:\n  fixes fail and gpv :: \"('a, 'b, 'c) gpv\"\n  assumes WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n  and fail: \"fail \\<le> 1\"\n  shows \"pgen_lossless_gpv fail (stop_\\<I> \\<I>) (gpv_stop gpv) = pgen_lossless_gpv fail \\<I> gpv\"", "lemma pfinite_gpv_stop [simp]:\n  \"pfinite_gpv (stop_\\<I> \\<I>) (gpv_stop gpv) \\<longleftrightarrow> pfinite_gpv \\<I> gpv\" if \"\\<I> \\<turnstile>g gpv \\<surd>\"", "lemma plossless_gpv_stop [simp]:\n  \"plossless_gpv (stop_\\<I> \\<I>) (gpv_stop gpv) \\<longleftrightarrow> plossless_gpv \\<I> gpv\" if \"\\<I> \\<turnstile>g gpv \\<surd>\"", "lemma results_gpv_stop_SomeD: \"Some x \\<in> results_gpv (stop_\\<I> \\<I>) (gpv_stop gpv) \\<Longrightarrow> x \\<in> results_gpv \\<I> gpv\"", "lemma Some_in_results'_gpv_gpv_stopD: \"Some xy \\<in> results'_gpv (gpv_stop gpv) \\<Longrightarrow> xy \\<in> results'_gpv gpv\"", "lemma inj_on_OK [simp]: \"inj_on OK A\"", "lemma option_of_exception_exception_of_option [simp]: \"option_of_exception (exception_of_option x) = x\"", "lemma exception_of_option_option_of_exception [simp]: \"exception_of_option (option_of_exception x) = x\"", "lemma case_exception_of_option [simp]: \"case_exception f g (exception_of_option x) = case_option f g x\"", "lemma case_option_of_exception [simp]: \"case_option f g (option_of_exception x) = case_exception f g x\"", "lemma surj_exception_of_option [simp]: \"surj exception_of_option\"", "lemma surj_option_of_exception [simp]: \"surj option_of_exception\"", "lemma case_map_exception [simp]: \"case_exception f g (map_exception h x) = case_exception f (g \\<circ> h) x\"", "lemma outs_exception_\\<I> [simp]: \"outs_\\<I> (exception_\\<I> \\<I>) = outs_\\<I> \\<I>\"", "lemma responses_exception_\\<I> [simp]: \n  \"responses_\\<I> (exception_\\<I> \\<I>) x = (if x \\<in> outs_\\<I> \\<I> then insert Fault (OK ` responses_\\<I> \\<I> x) else {})\"", "lemma map_\\<I>_full [simp]: \"map_\\<I> f g \\<I>_full = \\<I>_uniform UNIV (range g)\"", "lemma exception_\\<I>_full [simp]: \"exception_\\<I> \\<I>_full = \\<I>_full\"", "lemma exception_\\<I>_uniform [simp]: \n  \"exception_\\<I> (\\<I>_uniform A B) = (if B = {} then \\<bottom> else \\<I>_uniform A (insert Fault (OK ` B)))\"", "lemma option_of_exception_\\<I> [simp]: \"map_\\<I> id option_of_exception (exception_\\<I> \\<I>) = stop_\\<I> \\<I>\"", "lemma exception_of_option_\\<I> [simp]: \"map_\\<I> id exception_of_option (stop_\\<I> \\<I>) = exception_\\<I> \\<I>\"", "lemma lossless_spmf_inline1:\n  assumes lossless: \"\\<And>s x. \\<lbrakk> x \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> lossless_spmf (the_gpv (callee s x))\"\n    and I: \"I s\"\n  shows \"lossless_spmf (inline1 callee gpv s)\"", "lemma (in raw_converter_invariant) inline1_try_gpv:\n  defines \"inline1' \\<equiv> inline1\"\n  assumes WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and pfinite: \"pfinite_gpv \\<I> gpv\"\n    and f: \"\\<And>s. I s \\<Longrightarrow> f (x, s) = z\"\n    and lossless: \"\\<And>s x. \\<lbrakk> x \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> colossless_gpv \\<I>' (callee s x)\"\n    and I: \"I s\"\n  shows \"map_spmf (map_sum f id) (inline1 callee (try_gpv gpv (Done x)) s) =\n   try_spmf (map_spmf (map_sum f (\\<lambda>(out, c, rpv). (out, c, \\<lambda>input. try_gpv (rpv input) (Done x)))) (inline1' callee gpv s)) (return_spmf (Inl z))\"\n  (is \"?lhs = ?rhs\")", "lemma (in raw_converter_invariant) inline_try_gpv:\n  assumes WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and pfinite: \"pfinite_gpv \\<I> gpv\"\n    and f: \"\\<And>s. I s \\<Longrightarrow> f (x, s) = z\"\n    and lossless: \"\\<And>s x. \\<lbrakk> x \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> colossless_gpv \\<I>' (callee s x)\"\n    and I: \"I s\"\n  shows \"eq_\\<I>_gpv (=) \\<I>' (map_gpv f id (inline callee (try_gpv gpv (Done x)) s)) (try_gpv (map_gpv f id (inline callee gpv s)) (Done z))\"\n  (is \"eq_\\<I>_gpv _ _ ?lhs ?rhs\")", "lemma cr_prod2_simps [simp]: \"cr_prod2 x A a (b, c) \\<longleftrightarrow> A a c \\<and> x = b\"", "lemma cr_prod2I: \"A a b \\<Longrightarrow> cr_prod2 x A a (x, b)\"", "lemma cr_prod2_Grp: \"cr_prod2 x (BNF_Def.Grp A f) = BNF_Def.Grp A (\\<lambda>b. (x, f b))\"", "lemma extend_state_oracle_transfer': includes lifting_syntax shows\n  \"((S ===> C ===> rel_spmf (rel_prod R S)) ===> cr_prod2 s S ===> C ===> rel_spmf (rel_prod R (cr_prod2 s S))) (\\<lambda>oracle. oracle) extend_state_oracle\"", "lemma exec_gpv_extend_state_oracle:\n  \"exec_gpv (extend_state_oracle callee) gpv (s, s') =\n  map_spmf (\\<lambda>(x, s''). (x, (s, s''))) (exec_gpv callee gpv s')\"", "lemma WT_resource_\\<I>_uniform_UNIV [simp]: \"\\<I>_uniform A UNIV \\<turnstile>res res \\<surd>\"", "lemma WT_converter_of_callee_invar:\n  assumes WT: \"\\<And>s q. \\<lbrakk> q \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> \\<I>' \\<turnstile>g callee s q \\<surd>\"\n    and res: \"\\<And>s q r s'. \\<lbrakk> (r, s') \\<in> results_gpv \\<I>' (callee s q); q \\<in> outs_\\<I> \\<I>; I s  \\<rbrakk> \\<Longrightarrow> r \\<in> responses_\\<I> \\<I> q \\<and> I s'\"\n    and I: \"I s\"\n  shows \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C converter_of_callee callee s \\<surd>\"", "lemma eq_\\<I>_gpv_eq_OO:\n  assumes \"eq_\\<I>_gpv (=) \\<I> gpv gpv'\" \"eq_\\<I>_gpv A \\<I> gpv' gpv''\"\n  shows \"eq_\\<I>_gpv A \\<I> gpv gpv''\"", "lemma eq_\\<I>_gpv_eq_OO2:\n  assumes \"eq_\\<I>_gpv (=) \\<I> gpv'' gpv'\" \"eq_\\<I>_gpv A \\<I> gpv gpv'\"\n  shows \"eq_\\<I>_gpv A \\<I> gpv gpv''\"", "lemma eq_\\<I>_gpv_try_gpv_cong:\n  assumes \"eq_\\<I>_gpv A \\<I> gpv1 gpv1'\"\n    and \"eq_\\<I>_gpv A \\<I> gpv2 gpv2'\"\n  shows \"eq_\\<I>_gpv A \\<I> (try_gpv gpv1 gpv2) (try_gpv gpv1' gpv2')\"", "lemma eq_\\<I>_gpv_map_gpv':\n  assumes \"eq_\\<I>_gpv (BNF_Def.vimage2p f f' A) (map_\\<I> g h \\<I>) gpv1 gpv2\"\n  shows \"eq_\\<I>_gpv A \\<I> (map_gpv' f g h gpv1) (map_gpv' f' g h gpv2)\"", "lemma eq_\\<I>_converter_map_converter:\n  assumes \"map_\\<I> (inv_into UNIV f) (inv_into UNIV g) \\<I>, map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv1 \\<sim> conv2\"\n    and \"inj f\" \"surj g\"\n  shows \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C map_converter f g f' g' conv1 \\<sim> map_converter f g f' g' conv2\"", "lemma resource_of_oracle_run_resource: \"resource_of_oracle run_resource res = res\"", "lemma connect_map_gpv':\n  \"connect (map_gpv' f g h adv) res = map_spmf f (connect adv (map_resource g h res))\"", "lemma WT_fail_resource [WT_intro]: \"\\<I> \\<turnstile>res fail_resource \\<surd>\"", "lemma const_resource_sel [simp]: \"run_resource (const_resource y) = (\\<lambda>_. return_spmf (y, const_resource y))\"", "lemma lossless_const_resource [simp]: \"lossless_resource \\<I> (const_resource y)\"", "lemma WT_const_resource [simp]:\n  \"\\<I> \\<turnstile>res const_resource y \\<surd> \\<longleftrightarrow> (\\<forall>x\\<in>outs_\\<I> \\<I>. y \\<in> responses_\\<I> \\<I> x)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")", "lemma const_converter_sel [simp]: \"run_converter (const_converter y) = (\\<lambda>_. Done (y, const_converter y))\"", "lemma attach_const_converter [simp]: \"attach (const_converter y) res = const_resource y\"", "lemma comp_const_converter [simp]: \"comp_converter (const_converter x) conv = const_converter x\"", "lemma interaction_bounded_const_converter [simp, interaction_bound]: \n  \"interaction_any_bounded_converter (const_converter Fault) bound\"", "lemma merge_exception_converter_sel [simp]:\n  \"run_converter merge_exception_converter x =\n   Pause x (\\<lambda>y. Done (case merge_exception y of Fault \\<Rightarrow> (Fault, const_converter Fault) | OK y' \\<Rightarrow> (OK y', merge_exception_converter)))\"", "lemma plossless_const_converter[simp]: \"plossless_converter \\<I> \\<I>' (const_converter x)\"", "lemma plossless_merge_exception_converter [simp]:\n  \"plossless_converter (exception_\\<I> (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')) (exception_\\<I> \\<I> \\<oplus>\\<^sub>\\<I> exception_\\<I> \\<I>') merge_exception_converter\"", "lemma WT_const_converter [WT_intro, simp]:\n  \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C const_converter x \\<surd>\" if \"\\<forall>q \\<in> outs_\\<I> \\<I>. x \\<in> responses_\\<I> \\<I> q\"", "lemma WT_merge_exception_converter [WT_intro, simp]: \n  \"exception_\\<I> (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2'), exception_\\<I> \\<I>1' \\<oplus>\\<^sub>\\<I> exception_\\<I> \\<I>2' \\<turnstile>\\<^sub>C merge_exception_converter \\<surd>\"", "lemma inline_left_gpv_merge_exception_converter:\n  \"bind_gpv (inline run_converter (map_gpv' id id option_of_exception (gpv_stop (left_gpv gpv))) merge_exception_converter) (\\<lambda>(x, conv'). case x of None \\<Rightarrow> Fail | Some x' \\<Rightarrow> Done (x, conv')) =\n   bind_gpv (left_gpv (map_gpv' id id option_of_exception (gpv_stop gpv))) (\\<lambda>x. case x of None \\<Rightarrow> Fail | Some x' \\<Rightarrow> Done (x, merge_exception_converter))\"", "lemma inline_right_gpv_merge_exception_converter:\n  \"bind_gpv (inline run_converter (map_gpv' id id option_of_exception (gpv_stop (right_gpv gpv))) merge_exception_converter) (\\<lambda>(x, conv'). case x of None \\<Rightarrow> Fail | Some x' \\<Rightarrow> Done (x, conv')) =\n   bind_gpv (right_gpv (map_gpv' id id option_of_exception (gpv_stop gpv))) (\\<lambda>x. case x of None \\<Rightarrow> Fail | Some x' \\<Rightarrow> Done (x, merge_exception_converter))\"", "lemma lassocr_inverse: \"rassocl\\<^sub>C \\<odot> lassocr\\<^sub>C = 1\\<^sub>C\"", "lemma rassocl_inverse: \"lassocr\\<^sub>C \\<odot> rassocl\\<^sub>C = 1\\<^sub>C\"", "lemma swap_sum_swap_sum [simp]: \"swap_sum (swap_sum x) = x\"", "lemma inj_on_lsumr [simp]: \"inj_on lsumr A\"", "lemma inj_on_rsuml [simp]: \"inj_on rsuml A\"", "lemma bij_lsumr [simp]: \"bij lsumr\"", "lemma bij_swap_sum [simp]: \"bij swap_sum\"", "lemma bij_rsuml [simp]: \"bij rsuml\"", "lemma bij_lassocr_swap_sum [simp]: \"bij lassocr_swap_sum\"", "lemma inj_lassocr_swap_sum [simp]: \"inj lassocr_swap_sum\"", "lemma inv_rsuml [simp]: \"inv_into UNIV rsuml = lsumr\"", "lemma inv_lsumr [simp]: \"inv_into UNIV lsumr = rsuml\"", "lemma lassocr_swap_sum_inverse [simp]: \"lassocr_swap_sum (lassocr_swap_sum x) = x\"", "lemma inv_lassocr_swap_sum [simp]: \"inv_into UNIV lassocr_swap_sum = lassocr_swap_sum\"", "lemma swap_inverse: \"swap\\<^sub>C \\<odot> swap\\<^sub>C = 1\\<^sub>C\"", "lemma swap_lassocr_inverse: \"\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3), \\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C swap_lassocr \\<odot> swap_lassocr \\<sim> 1\\<^sub>C\"\n  (is \"?\\<I>,_ \\<turnstile>\\<^sub>C ?lhs \\<sim> _\")", "lemma parallel_wiring_inverse:\n  \"(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4),(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C parallel_wiring \\<odot> parallel_wiring \\<sim> 1\\<^sub>C\"\n  (is \"?\\<I>, _ \\<turnstile>\\<^sub>C ?lhs \\<sim> _\")", "lemma \n  attach_wiring_right_simps: \n    \"attach_wiring_right (f, g) = map_fun id (map_fun id (map_gpv' id f g))\"", "lemma \n  comp_converter_of_callee_wiring:\n  assumes wiring: \"wiring \\<I>2 \\<I>3 conv w\"\n      and WT: \"\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C CNV callee s \\<surd>\"\n  shows \"\\<I>1, \\<I>3 \\<turnstile>\\<^sub>C CNV callee s \\<odot> conv \\<sim> CNV (attach_wiring_right w callee) s\"", "lemma attach_wiring_right_comp_wiring:\n  \"attach_wiring_right (w1 \\<circ>\\<^sub>w w2) callee = attach_wiring_right w2 (attach_wiring_right w1 callee)\"", "lemma attach_wiring_comp_wiring:\n  \"attach_wiring (w1 \\<circ>\\<^sub>w w2) callee = attach_wiring w1 (attach_wiring w2 callee)\"", "lemma pfinite_converter_coinduct[consumes 1, case_names pfinite_converter, case_conclusion pfinite_converter pfinite step, coinduct pred: pfinite_converter]:\n  assumes \"X conv\"\n    and step: \"\\<And>conv a. \\<lbrakk> X conv; a \\<in> outs_\\<I> \\<I> \\<rbrakk> \\<Longrightarrow> pfinite_gpv \\<I>' (run_converter conv a) \\<and>\n     (\\<forall>(b, conv') \\<in> results_gpv \\<I>' (run_converter conv a). X conv' \\<or> pfinite_converter \\<I> \\<I>' conv')\"\n  shows \"pfinite_converter \\<I> \\<I>' conv\"", "lemma pfinite_converterD:\n  \"\\<lbrakk> pfinite_converter \\<I> \\<I>' conv; a \\<in> outs_\\<I> \\<I> \\<rbrakk> \n  \\<Longrightarrow> pfinite_gpv \\<I>' (run_converter conv a) \\<and>\n     (\\<forall>(b, conv') \\<in> results_gpv \\<I>' (run_converter conv a). pfinite_converter \\<I> \\<I>' conv')\"", "lemma pfinite_converter_bot1 [simp]: \"pfinite_converter bot \\<I> conv\"", "lemma pfinite_converter_mono:\n  assumes *: \"pfinite_converter \\<I>1 \\<I>2 conv\"\n    and le: \"outs_\\<I> \\<I>1' \\<subseteq> outs_\\<I> \\<I>1\" \"\\<I>2 \\<le> \\<I>2'\"\n    and WT: \"\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv \\<surd>\"\n  shows \"pfinite_converter \\<I>1' \\<I>2' conv\"", "lemma pfinite_converter_of_callee:\n  assumes step: \"\\<And>x s. \\<lbrakk> x \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> pfinite_gpv \\<I>' (callee s x)\"\n    and I: \"I s\"\n  shows \"pfinite_converter \\<I> \\<I>' (converter_of_callee callee s)\"", "lemma raw_converter_invariant_run_pfinite_converter: \n  \"raw_converter_invariant \\<I> \\<I>' run_converter (\\<lambda>conv. pfinite_converter \\<I> \\<I>' conv \\<and> \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<surd>)\"", "lemma pfinite_id_converter [pfinite_intro]: \"pfinite_converter \\<I> \\<I> id_converter\"", "lemma pfinite_fail_converter [pfinite_intro]: \"pfinite_converter \\<I> \\<I>' fail_converter\"", "lemma pfinite_parallel_converter2 [pfinite_intro]:\n  \"pfinite_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') (conv1 |\\<^sub>= conv2)\"\n  if \"pfinite_converter \\<I>1 \\<I>1' conv1\" \"pfinite_converter \\<I>2 \\<I>2' conv2\"", "lemma expectation_gpv_1_le_inline:\n  defines \"expectation_gpv2 \\<equiv> expectation_gpv 1 \\<I>'\"\n  assumes callee: \"\\<And>s x. \\<lbrakk> x \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> pfinite_gpv \\<I>' (callee s x)\"\n    and WT_gpv: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and I: \"I s\"\n    and f_le_1: \"\\<And>x. f x \\<le> 1\"\n  shows \"expectation_gpv 1 \\<I> f gpv \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee gpv s)\"", "lemma pfinite_inline:\n  assumes fin: \"pfinite_gpv \\<I> gpv\"\n    and WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and callee: \"\\<And>s x. \\<lbrakk> x \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> pfinite_gpv \\<I>' (callee s x)\"\n    and I: \"I s\"\n  shows \"pfinite_gpv \\<I>' (inline callee gpv s)\"", "lemma pfinite_comp_converter [pfinite_intro]:\n  \"pfinite_converter \\<I>1 \\<I>3 (conv1 \\<odot> conv2)\"\n  if \"pfinite_converter \\<I>1 \\<I>2 conv1\" \"pfinite_converter \\<I>2 \\<I>3 conv2\" \"\\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>\" \"\\<I>2,\\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>\"", "lemma pfinite_map_converter [pfinite_intro]:\n  \"pfinite_converter \\<I>  \\<I>' (map_converter f g f' g' conv)\" if \n  *: \"pfinite_converter (map_\\<I> (inv_into UNIV f) (inv_into UNIV g) \\<I>) (map_\\<I> f' g' \\<I>') conv\"\n  and f: \"inj f\" and g: \"surj g\"", "lemma pfinite_lassocr\\<^sub>C [pfinite_intro]: \"pfinite_converter ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3) (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)) lassocr\\<^sub>C\"", "lemma pfinite_rassocl\\<^sub>C [pfinite_intro]: \"pfinite_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)) ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3) rassocl\\<^sub>C\"", "lemma pfinite_swap\\<^sub>C [pfinite_intro]: \"pfinite_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1) swap\\<^sub>C\"", "lemma pfinite_swap_lassocr [pfinite_intro]: \"pfinite_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)) (\\<I>2 \\<oplus>\\<^sub>\\<I> (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3)) swap_lassocr\"", "lemma pfinite_swap_rassocl [pfinite_intro]: \"pfinite_converter ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3) ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<oplus>\\<^sub>\\<I> \\<I>2) swap_rassocl\"", "lemma pfinite_parallel_wiring [pfinite_intro]:\n  \"pfinite_converter ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4)) ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>4)) parallel_wiring\"", "lemma pfinite_parallel_converter [pfinite_intro]:\n  \"pfinite_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<I>3 (conv1 |\\<^sub>\\<propto> conv2)\"\n  if \"pfinite_converter \\<I>1 \\<I>3 conv1\" and \"pfinite_converter \\<I>2 \\<I>3 conv2\"", "lemma pfinite_converter_of_resource [simp, pfinite_intro]: \"pfinite_converter \\<I>1 \\<I>2 (converter_of_resource res)\"", "lemma colossless_converter_coinduct[consumes 1, case_names colossless_converter, case_conclusion colossless_converter plossless step, coinduct pred: colossless_converter]:\n  assumes \"X conv\"\n    and step: \"\\<And>conv a. \\<lbrakk> X conv; a \\<in> outs_\\<I> \\<I> \\<rbrakk> \\<Longrightarrow> colossless_gpv \\<I>' (run_converter conv a) \\<and>\n     (\\<forall>(b, conv') \\<in> results_gpv \\<I>' (run_converter conv a). X conv' \\<or> colossless_converter \\<I> \\<I>' conv')\"\n  shows \"colossless_converter \\<I> \\<I>' conv\"", "lemma colossless_converterD:\n  \"\\<lbrakk> colossless_converter \\<I> \\<I>' conv; a \\<in> outs_\\<I> \\<I> \\<rbrakk> \n  \\<Longrightarrow> colossless_gpv \\<I>' (run_converter conv a) \\<and>\n     (\\<forall>(b, conv') \\<in> results_gpv \\<I>' (run_converter conv a). colossless_converter \\<I> \\<I>' conv')\"", "lemma colossless_converter_bot1 [simp]: \"colossless_converter bot \\<I> conv\"", "lemma raw_converter_invariant_run_colossless_converter: \"raw_converter_invariant \\<I> \\<I>' run_converter (\\<lambda>conv. colossless_converter \\<I> \\<I>' conv \\<and> \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<surd>)\"", "lemma colossless_const_converter [simp]: \"colossless_converter \\<I> \\<I>' (const_converter x)\"", "lemma distinguish_trace_eq: (* generalized from Distinguisher.thy *)\n  assumes distinguish: \"\\<And>distinguisher. \\<I> \\<turnstile>g distinguisher \\<surd> \\<Longrightarrow> connect distinguisher res = connect distinguisher res'\"\n  shows \"outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<approx> res'\"", "lemma attach_trace_eq':\n  assumes eq: \"outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res1 \\<approx> res2\"\n    and WT1 [WT_intro]: \"\\<I> \\<turnstile>res res1 \\<surd>\"\n    and WT2 [WT_intro]: \"\\<I> \\<turnstile>res res2 \\<surd>\"\n    and WT_conv [WT_intro]: \"\\<I>',\\<I> \\<turnstile>\\<^sub>C conv \\<surd>\"\n  shows \"outs_\\<I> \\<I>' \\<turnstile>\\<^sub>R conv \\<rhd> res1 \\<approx> conv \\<rhd> res2\"", "lemma trace_callee_eq_trans [trans]:\n  \"\\<lbrakk> trace_callee_eq callee1 callee2 A p q; trace_callee_eq callee2 callee3 A q r \\<rbrakk>\n   \\<Longrightarrow> trace_callee_eq callee1 callee3 A p r\"", "lemma trace_eq'_parallel_resource:\n  fixes res1 :: \"('a, 'b) resource\" and res2 :: \"('c, 'd) resource\"\n  assumes 1: \"trace_eq' A res1 res1'\"\n    and 2: \"trace_eq' B res2 res2'\"\n  shows \"trace_eq' (A <+> B) (res1 \\<parallel> res2) (res1' \\<parallel> res2')\"", "lemma trace_callee_return_pmf_None [simp]:\n  \"trace_callee_eq callee1 callee2 A (return_pmf None) (return_pmf None)\"", "lemma trace_callee_eq_sym [sym]: \"trace_callee_eq callee1 callee2 A p q \\<Longrightarrow> trace_callee_eq callee2 callee1 A q p\"", "lemma eq_resource_on_imp_trace_eq: \"A \\<turnstile>\\<^sub>R res1 \\<approx> res2\" if \"A \\<turnstile>\\<^sub>R res1 \\<sim> res2\"", "lemma advantage_nonneg: \"0 \\<le> advantage \\<A> res1 res2\"", "lemma comp_converter_of_resource_conv_parallel_converter:\n  \"(converter_of_resource res |\\<^sub>\\<propto> 1\\<^sub>C) \\<odot> conv = converter_of_resource res |\\<^sub>\\<propto> conv\"", "lemma comp_converter_of_resource_conv_parallel_converter2:\n  \"(1\\<^sub>C |\\<^sub>\\<propto> converter_of_resource res) \\<odot> conv = conv |\\<^sub>\\<propto> converter_of_resource res\"", "lemma parallel_converter_map_converter:\n  \"map_converter f g f' g' conv1 |\\<^sub>\\<propto> map_converter f'' g'' f' g' conv2 = \n   map_converter (map_sum f f'') (map_sum g g'') f' g' (conv1 |\\<^sub>\\<propto> conv2)\"", "lemma map_converter_parallel_converter_out2:\n  \"conv1 |\\<^sub>\\<propto> map_converter f g id id conv2 = map_converter (map_sum id f) (map_sum id g) id id (conv1 |\\<^sub>\\<propto> conv2)\"", "lemma parallel_converter_assoc2:\n  \"parallel_converter conv1 (parallel_converter conv2 conv3) =                                   \n   map_converter lsumr rsuml id id (parallel_converter (parallel_converter conv1 conv2) conv3)\"", "lemma parallel_converter_of_resource:\n  \"converter_of_resource res1 |\\<^sub>\\<propto> converter_of_resource res2 = converter_of_resource (res1 \\<parallel> res2)\"", "lemma map_Inr_parallel_converter:\n  \"map_converter Inr f g h (conv1 |\\<^sub>\\<propto> conv2) = map_converter id (f \\<circ> Inr) g h conv2\"\n  (is \"?lhs = ?rhs\")", "lemma map_Inl_parallel_converter:\n  \"map_converter Inl f g h (conv1 |\\<^sub>\\<propto> conv2) = map_converter id (f \\<circ> Inl) g h conv1\"\n  (is \"?lhs = ?rhs\")", "lemma left_interface_parallel_converter:\n  \"left_interface (conv1 |\\<^sub>\\<propto> conv2) = left_interface conv1 |\\<^sub>\\<propto> left_interface conv2\"", "lemma right_interface_parallel_converter:\n  \"right_interface (conv1 |\\<^sub>\\<propto> conv2) = right_interface conv1 |\\<^sub>\\<propto> right_interface conv2\"", "lemma left_interface_converter_of_resource [simp]: \n  \"left_interface (converter_of_resource res) = converter_of_resource res\"", "lemma right_interface_converter_of_resource [simp]: \n  \"right_interface (converter_of_resource res) = converter_of_resource res\"", "lemma parallel_converter_swap: \"map_converter swap_sum swap_sum id id (conv1 |\\<^sub>\\<propto> conv2) = conv2 |\\<^sub>\\<propto> conv1\"", "lemma eq_\\<I>_converter_map_converter':\n  assumes \"\\<I>'', map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv1 \\<sim> conv2\"\n    and \"f ` outs_\\<I> \\<I> \\<subseteq> outs_\\<I> \\<I>''\"\n    and \"\\<forall>q\\<in>outs_\\<I> \\<I>. g ` responses_\\<I> \\<I>'' (f q) \\<subseteq> responses_\\<I> \\<I> q\"\n  shows \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C map_converter f g f' g' conv1 \\<sim> map_converter f g f' g' conv2\"", "lemma parallel_converter_eq_\\<I>_cong:\n  \"\\<lbrakk> \\<I>1, \\<I> \\<turnstile>\\<^sub>C conv1 \\<sim> conv1'; \\<I>2, \\<I> \\<turnstile>\\<^sub>C conv2 \\<sim> conv2' \\<rbrakk>\n  \\<Longrightarrow> \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2, \\<I> \\<turnstile>\\<^sub>C parallel_converter conv1 conv2 \\<sim> parallel_converter conv1' conv2'\"", "lemma\n  exec_gpv_parallel_oracle_right: \n    \"exec_gpv (oracle1 \\<ddagger>\\<^sub>O oracle2) (right_gpv gpv) s = exec_gpv (\\<dagger>oracle2) gpv s\"", "lemma\n  exec_gpv_parallel_oracle_left: \n    \"exec_gpv (oracle1 \\<ddagger>\\<^sub>O oracle2) (left_gpv gpv) s = exec_gpv (oracle1\\<dagger>) gpv s\" (is \"?L = ?R\")"], "translations": [["", "lemma eq_alt_conversep: \"(=) = (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (=) = (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse>", "by(simp add: Grp_def fun_eq_iff)"], ["", "parametric_constant \n  swap_parametric [transfer_rule]: prod.swap_def"], ["", "lemma Sigma_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_set A ===> (A ===> rel_set B) ===> rel_set (rel_prod A B)) Sigma Sigma\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> (A ===> rel_set B) ===> rel_set (rel_prod A B)) Sigma\n     Sigma", "unfolding Sigma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> (A ===> rel_set B) ===> rel_set (rel_prod A B))\n     (\\<lambda>A B. \\<Union>x\\<in>A. \\<Union>y\\<in>B x. {(x, y)})\n     (\\<lambda>A B. \\<Union>x\\<in>A. \\<Union>y\\<in>B x. {(x, y)})", "by transfer_prover"], ["", "lemma empty_eq_Plus [simp]: \"{} = A <+> B \\<longleftrightarrow> A = {} \\<and> B = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({} = A <+> B) = (A = {} \\<and> B = {})", "by auto"], ["", "lemma insert_Inl_Plus [simp]: \"insert (Inl x) (A <+> B) = insert x A <+> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (Inl x) (A <+> B) = insert x A <+> B", "by auto"], ["", "lemma insert_Inr_Plus [simp]: \"insert (Inr x) (A <+> B) = A <+> insert x B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (Inr x) (A <+> B) = A <+> insert x B", "by auto"], ["", "lemma map_sum_image_Plus [simp]: \"map_sum f g ` (A <+> B) = f ` A <+> g ` B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_sum f g ` (A <+> B) = f ` A <+> g ` B", "by(auto intro: rev_image_eqI)"], ["", "lemma Plus_subset_Plus_iff [simp]: \"A <+> B \\<subseteq> C <+> D \\<longleftrightarrow> A \\<subseteq> C \\<and> B \\<subseteq> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A <+> B \\<subseteq> C <+> D) = (A \\<subseteq> C \\<and> B \\<subseteq> D)", "by auto"], ["", "lemma map_sum_eq_Inl_iff: \"map_sum f g x = Inl y \\<longleftrightarrow> (\\<exists>x'. x = Inl x' \\<and> y = f x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_sum f g x = Inl y) = (\\<exists>x'. x = Inl x' \\<and> y = f x')", "by(cases x) auto"], ["", "lemma map_sum_eq_Inr_iff: \"map_sum f g x = Inr y \\<longleftrightarrow> (\\<exists>x'. x = Inr x' \\<and> y = g x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_sum f g x = Inr y) = (\\<exists>x'. x = Inr x' \\<and> y = g x')", "by(cases x) auto"], ["", "lemma surj_map_sum: \"surj (map_sum f g)\" if \"surj f\" \"surj g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj (map_sum f g)", "apply(safe; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> range (map_sum f g)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> range (map_sum f g)", "using that"], ["proof (prove)\nusing this:\n  surj f\n  surj g\n\ngoal (1 subgoal):\n 1. x \\<in> range (map_sum f g)", "by(cases x)(auto 4 3 intro: image_eqI[where x=\"Inl _\"] image_eqI[where x=\"Inr _\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bij_map_sumI [simp]: \"bij (map_sum f g)\" if \"bij f\" \"bij g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij (map_sum f g)", "using that"], ["proof (prove)\nusing this:\n  bij f\n  bij g\n\ngoal (1 subgoal):\n 1. bij (map_sum f g)", "by(clarsimp simp add: bij_def sum.inj_map surj_map_sum)"], ["", "lemma inv_map_sum [simp]:\n  \"\\<lbrakk> bij f; bij g \\<rbrakk> \\<Longrightarrow> inv_into UNIV (map_sum f g) = map_sum (inv_into UNIV f) (inv_into UNIV g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bij f; bij g\\<rbrakk>\n    \\<Longrightarrow> inv (map_sum f g) = map_sum (inv f) (inv g)", "by(rule inj_imp_inv_eq)(simp_all add: sum.map_comp sum.inj_map bij_def surj_iff sum.map_id)"], ["", "context conditionally_complete_lattice begin"], ["", "lemma admissible_le1I:\n  \"ccpo.admissible lub ord (\\<lambda>x. f x \\<le> y)\"\n  if \"cont lub ord Sup (\\<le>) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible lub ord (\\<lambda>x. f x \\<le> y)", "by(rule ccpo.admissibleI)(auto simp add: that[THEN contD] intro!: cSUP_least)"], ["", "lemma admissible_le1_mcont [cont_intro]:\n  \"ccpo.admissible lub ord (\\<lambda>x. f x \\<le> y)\" if \"mcont lub ord Sup (\\<le>) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible lub ord (\\<lambda>x. f x \\<le> y)", "using that"], ["proof (prove)\nusing this:\n  mcont lub ord Sup (\\<le>) f\n\ngoal (1 subgoal):\n 1. ccpo.admissible lub ord (\\<lambda>x. f x \\<le> y)", "by(simp add: admissible_le1I mcont_def)"], ["", "end"], ["", "lemma eq_alt_conversep2: \"(=) = ((BNF_Def.Grp UNIV id)\\<inverse>\\<inverse>)\\<inverse>\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (=) = (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse>\\<inverse>\\<inverse>", "by(auto simp add: Grp_def fun_eq_iff)"], ["", "lemma nn_integral_indicator_singleton1 [simp]:\n  assumes [measurable]: \"{y} \\<in> sets M\"\n  shows \"(\\<integral>\\<^sup>+x. indicator {y} x * f x \\<partial>M) = emeasure M {y} * f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. indicator {y} x * f x \\<partial>M =\n    emeasure M {y} * f y", "by(simp add: mult.commute)"], ["", "lemma nn_integral_indicator_singleton1' [simp]:\n  assumes \"{y} \\<in> sets M\"\n  shows \"(\\<integral>\\<^sup>+x. indicator {x} y * f x \\<partial>M) = emeasure M {y} * f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. indicator {x} y * f x \\<partial>M =\n    emeasure M {y} * f y", "by(subst nn_integral_indicator_singleton1[symmetric, OF assms])(rule nn_integral_cong; simp split: split_indicator)"], ["", "subsection \\<open>Probabilities\\<close>"], ["", "lemma pmf_eq_1_iff: \"pmf p x = 1 \\<longleftrightarrow> p = return_pmf x\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pmf p x = 1) = (p = return_pmf x)", "proof(rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. pmf p x = 1 \\<Longrightarrow> p = return_pmf x\n 2. p = return_pmf x \\<Longrightarrow> pmf p x = 1", "assume ?lhs"], ["proof (state)\nthis:\n  pmf p x = 1\n\ngoal (2 subgoals):\n 1. pmf p x = 1 \\<Longrightarrow> p = return_pmf x\n 2. p = return_pmf x \\<Longrightarrow> pmf p x = 1", "have \"pmf p i = 0\" if \"x \\<noteq> i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf p i = 0", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. pmf p i \\<le> 0\n 2. 0 \\<le> pmf p i", "have \"pmf p i + 1 \\<le> pmf p i + pmf p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf p i + 1 \\<le> pmf p i + pmf p x", "using \\<open>?lhs\\<close>"], ["proof (prove)\nusing this:\n  pmf p x = 1\n\ngoal (1 subgoal):\n 1. pmf p i + 1 \\<le> pmf p i + pmf p x", "by simp"], ["proof (state)\nthis:\n  pmf p i + 1 \\<le> pmf p i + pmf p x\n\ngoal (2 subgoals):\n 1. pmf p i \\<le> 0\n 2. 0 \\<le> pmf p i", "also"], ["proof (state)\nthis:\n  pmf p i + 1 \\<le> pmf p i + pmf p x\n\ngoal (2 subgoals):\n 1. pmf p i \\<le> 0\n 2. 0 \\<le> pmf p i", "have \"\\<dots> = measure (measure_pmf p) {i, x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf p i + pmf p x = measure_pmf.prob p {i, x}", "using that"], ["proof (prove)\nusing this:\n  x \\<noteq> i\n\ngoal (1 subgoal):\n 1. pmf p i + pmf p x = measure_pmf.prob p {i, x}", "by(subst measure_pmf.finite_measure_eq_sum_singleton)(simp_all add: pmf.rep_eq)"], ["proof (state)\nthis:\n  pmf p i + pmf p x = measure_pmf.prob p {i, x}\n\ngoal (2 subgoals):\n 1. pmf p i \\<le> 0\n 2. 0 \\<le> pmf p i", "also"], ["proof (state)\nthis:\n  pmf p i + pmf p x = measure_pmf.prob p {i, x}\n\ngoal (2 subgoals):\n 1. pmf p i \\<le> 0\n 2. 0 \\<le> pmf p i", "have \"\\<dots> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob p {i, x} \\<le> 1", "by(rule measure_pmf.subprob_measure_le_1)"], ["proof (state)\nthis:\n  measure_pmf.prob p {i, x} \\<le> 1\n\ngoal (2 subgoals):\n 1. pmf p i \\<le> 0\n 2. 0 \\<le> pmf p i", "finally"], ["proof (chain)\npicking this:\n  pmf p i + 1 \\<le> 1", "show \"pmf p i \\<le> 0\""], ["proof (prove)\nusing this:\n  pmf p i + 1 \\<le> 1\n\ngoal (1 subgoal):\n 1. pmf p i \\<le> 0", "by simp"], ["proof (state)\nthis:\n  pmf p i \\<le> 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> pmf p i", "qed(rule pmf_nonneg)"], ["proof (state)\nthis:\n  x \\<noteq> ?i \\<Longrightarrow> pmf p ?i = 0\n\ngoal (2 subgoals):\n 1. pmf p x = 1 \\<Longrightarrow> p = return_pmf x\n 2. p = return_pmf x \\<Longrightarrow> pmf p x = 1", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> ?i \\<Longrightarrow> pmf p ?i = 0", "show ?rhs if ?lhs"], ["proof (prove)\nusing this:\n  x \\<noteq> ?i \\<Longrightarrow> pmf p ?i = 0\n\ngoal (1 subgoal):\n 1. p = return_pmf x", "by(intro pmf_eqI)(auto simp add: that split: split_indicator)"], ["proof (state)\nthis:\n  pmf p x = 1 \\<Longrightarrow> p = return_pmf x\n\ngoal (1 subgoal):\n 1. p = return_pmf x \\<Longrightarrow> pmf p x = 1", "qed simp"], ["", "lemma measure_spmf_cong: \"measure (measure_spmf p) A = measure (measure_spmf p) B\"\n  if \"A \\<inter> set_spmf p = B \\<inter> set_spmf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf p) A =\n    Sigma_Algebra.measure (measure_spmf p) B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf p) A =\n    Sigma_Algebra.measure (measure_spmf p) B", "have \"measure (measure_spmf p) A = measure (measure_spmf p) (A \\<inter> set_spmf p) + measure (measure_spmf p) (A - set_spmf p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf p) A =\n    Sigma_Algebra.measure (measure_spmf p) (A \\<inter> set_spmf p) +\n    Sigma_Algebra.measure (measure_spmf p) (A - set_spmf p)", "by(subst measure_spmf.finite_measure_Union[symmetric])(auto intro: arg_cong2[where f=measure])"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf p) A =\n  Sigma_Algebra.measure (measure_spmf p) (A \\<inter> set_spmf p) +\n  Sigma_Algebra.measure (measure_spmf p) (A - set_spmf p)\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf p) A =\n    Sigma_Algebra.measure (measure_spmf p) B", "also"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf p) A =\n  Sigma_Algebra.measure (measure_spmf p) (A \\<inter> set_spmf p) +\n  Sigma_Algebra.measure (measure_spmf p) (A - set_spmf p)\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf p) A =\n    Sigma_Algebra.measure (measure_spmf p) B", "have \"measure (measure_spmf p) (A - set_spmf p) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf p) (A - set_spmf p) = 0", "by(simp add: measure_spmf_zero_iff)"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf p) (A - set_spmf p) = 0\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf p) A =\n    Sigma_Algebra.measure (measure_spmf p) B", "also"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf p) (A - set_spmf p) = 0\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf p) A =\n    Sigma_Algebra.measure (measure_spmf p) B", "have \"0 = measure (measure_spmf p) (B - set_spmf p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = Sigma_Algebra.measure (measure_spmf p) (B - set_spmf p)", "by(simp add: measure_spmf_zero_iff)"], ["proof (state)\nthis:\n  0 = Sigma_Algebra.measure (measure_spmf p) (B - set_spmf p)\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf p) A =\n    Sigma_Algebra.measure (measure_spmf p) B", "also"], ["proof (state)\nthis:\n  0 = Sigma_Algebra.measure (measure_spmf p) (B - set_spmf p)\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf p) A =\n    Sigma_Algebra.measure (measure_spmf p) B", "have \"measure (measure_spmf p) (A \\<inter> set_spmf p) + \\<dots> = measure (measure_spmf p) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf p) (A \\<inter> set_spmf p) +\n    Sigma_Algebra.measure (measure_spmf p) (B - set_spmf p) =\n    Sigma_Algebra.measure (measure_spmf p) B", "unfolding that"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf p) (B \\<inter> set_spmf p) +\n    Sigma_Algebra.measure (measure_spmf p) (B - set_spmf p) =\n    Sigma_Algebra.measure (measure_spmf p) B", "by(subst measure_spmf.finite_measure_Union[symmetric])(auto intro: arg_cong2[where f=measure])"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf p) (A \\<inter> set_spmf p) +\n  Sigma_Algebra.measure (measure_spmf p) (B - set_spmf p) =\n  Sigma_Algebra.measure (measure_spmf p) B\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf p) A =\n    Sigma_Algebra.measure (measure_spmf p) B", "finally"], ["proof (chain)\npicking this:\n  Sigma_Algebra.measure (measure_spmf p) A =\n  Sigma_Algebra.measure (measure_spmf p) B", "show ?thesis"], ["proof (prove)\nusing this:\n  Sigma_Algebra.measure (measure_spmf p) A =\n  Sigma_Algebra.measure (measure_spmf p) B\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf p) A =\n    Sigma_Algebra.measure (measure_spmf p) B", "."], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf p) A =\n  Sigma_Algebra.measure (measure_spmf p) B\n\ngoal:\nNo subgoals!", "qed"], ["", "definition weight_spmf' where \"weight_spmf' = weight_spmf\""], ["", "lemma weight_spmf'_parametric [transfer_rule]: \"rel_fun (rel_spmf A) (=) weight_spmf' weight_spmf'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_spmf A) (=) weight_spmf' weight_spmf'", "unfolding weight_spmf'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (rel_spmf A) (=) weight_spmf weight_spmf", "by(rule weight_spmf_parametric)"], ["", "lemma bind_spmf_to_nat_on:\n  \"bind_spmf (map_spmf (to_nat_on (set_spmf p)) p) (\\<lambda>n. f (from_nat_into (set_spmf p) n)) = bind_spmf p f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (to_nat_on (set_spmf p)) p \\<bind>\n    (\\<lambda>n. f (from_nat_into (set_spmf p) n)) =\n    p \\<bind> f", "by(simp add: bind_map_spmf cong: bind_spmf_cong)"], ["", "lemma try_cond_spmf_fst:\n  \"try_spmf (cond_spmf_fst p x) q = (if x \\<in> fst ` set_spmf p then cond_spmf_fst p x else q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY cond_spmf_fst p x ELSE q =\n    (if x \\<in> fst ` set_spmf p then cond_spmf_fst p x else q)", "by (metis cond_spmf_fst_eq_return_None lossless_cond_spmf_fst try_spmf_lossless try_spmf_return_None)"], ["", "lemma measure_try_spmf:\n  \"measure (measure_spmf (try_spmf p q)) A = measure (measure_spmf p) A + pmf p None * measure (measure_spmf q) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (TRY p ELSE q)) A =\n    Sigma_Algebra.measure (measure_spmf p) A +\n    pmf p None * Sigma_Algebra.measure (measure_spmf q) A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (TRY p ELSE q)) A =\n    Sigma_Algebra.measure (measure_spmf p) A +\n    pmf p None * Sigma_Algebra.measure (measure_spmf q) A", "have \"emeasure (measure_spmf (try_spmf p q)) A = emeasure (measure_spmf p) A + pmf p None * emeasure (measure_spmf q) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_spmf (TRY p ELSE q)) A =\n    emeasure (measure_spmf p) A +\n    ennreal (pmf p None) * emeasure (measure_spmf q) A", "by(fold nn_integral_spmf)(simp add: spmf_try_spmf nn_integral_add ennreal_mult' nn_integral_cmult)"], ["proof (state)\nthis:\n  emeasure (measure_spmf (TRY p ELSE q)) A =\n  emeasure (measure_spmf p) A +\n  ennreal (pmf p None) * emeasure (measure_spmf q) A\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (TRY p ELSE q)) A =\n    Sigma_Algebra.measure (measure_spmf p) A +\n    pmf p None * Sigma_Algebra.measure (measure_spmf q) A", "then"], ["proof (chain)\npicking this:\n  emeasure (measure_spmf (TRY p ELSE q)) A =\n  emeasure (measure_spmf p) A +\n  ennreal (pmf p None) * emeasure (measure_spmf q) A", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure (measure_spmf (TRY p ELSE q)) A =\n  emeasure (measure_spmf p) A +\n  ennreal (pmf p None) * emeasure (measure_spmf q) A\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure (measure_spmf (TRY p ELSE q)) A =\n    Sigma_Algebra.measure (measure_spmf p) A +\n    pmf p None * Sigma_Algebra.measure (measure_spmf q) A", "by(simp add: measure_spmf.emeasure_eq_measure ennreal_mult'[symmetric] ennreal_plus[symmetric] del: ennreal_plus)"], ["proof (state)\nthis:\n  Sigma_Algebra.measure (measure_spmf (TRY p ELSE q)) A =\n  Sigma_Algebra.measure (measure_spmf p) A +\n  pmf p None * Sigma_Algebra.measure (measure_spmf q) A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_spmf_OO_trans_strong:\n  \"\\<lbrakk> rel_spmf R p q; rel_spmf S q r \\<rbrakk> \\<Longrightarrow> rel_spmf (R OO eq_onp (\\<lambda>x. x \\<in> set_spmf q) OO S) p r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel_spmf R p q; rel_spmf S q r\\<rbrakk>\n    \\<Longrightarrow> rel_spmf\n                       (R OO eq_onp (\\<lambda>x. x \\<in> set_spmf q) OO S) p\n                       r", "by(auto intro: rel_spmf_OO_trans rel_spmf_reflI simp add: eq_onp_def)"], ["", "lemma mcont2mcont_spmf [cont_intro]:\n  \"mcont lub ord Sup (\\<le>) (\\<lambda>p. spmf (f p) x)\"\n  if \"mcont lub ord lub_spmf (ord_spmf (=)) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lub ord Sup (\\<le>) (\\<lambda>p. spmf (f p) x)", "using that"], ["proof (prove)\nusing this:\n  mcont lub ord lub_spmf (ord_spmf (=)) f\n\ngoal (1 subgoal):\n 1. mcont lub ord Sup (\\<le>) (\\<lambda>p. spmf (f p) x)", "unfolding mcont_def"], ["proof (prove)\nusing this:\n  monotone ord (ord_spmf (=)) f \\<and>\n  cont lub ord lub_spmf (ord_spmf (=)) f\n\ngoal (1 subgoal):\n 1. monotone ord (\\<le>) (\\<lambda>p. spmf (f p) x) \\<and>\n    cont lub ord Sup (\\<le>) (\\<lambda>p. spmf (f p) x)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>monotone ord (ord_spmf (=)) f;\n     cont lub ord lub_spmf (ord_spmf (=)) f\\<rbrakk>\n    \\<Longrightarrow> monotone ord (\\<le>) (\\<lambda>p. spmf (f p) x)\n 2. \\<lbrakk>monotone ord (ord_spmf (=)) f;\n     cont lub ord lub_spmf (ord_spmf (=)) f\\<rbrakk>\n    \\<Longrightarrow> cont lub ord Sup (\\<le>) (\\<lambda>p. spmf (f p) x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>monotone ord (ord_spmf (=)) f;\n     cont lub ord lub_spmf (ord_spmf (=)) f\\<rbrakk>\n    \\<Longrightarrow> monotone ord (\\<le>) (\\<lambda>p. spmf (f p) x)", "by(rule monotone2monotone, rule monotone_spmf; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>monotone ord (ord_spmf (=)) f;\n     cont lub ord lub_spmf (ord_spmf (=)) f\\<rbrakk>\n    \\<Longrightarrow> cont lub ord Sup (\\<le>) (\\<lambda>p. spmf (f p) x)", "apply(rule contI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>monotone ord (ord_spmf (=)) f;\n        cont lub ord lub_spmf (ord_spmf (=)) f;\n        Complete_Partial_Order.chain ord Y; Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> spmf (f (lub Y)) x =\n                         (\\<Squnion>p\\<in>Y. spmf (f p) x)", "apply(subst contD[where f=f and luba=lub]; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>monotone ord (ord_spmf (=)) f;\n        cont lub ord lub_spmf (ord_spmf (=)) f;\n        Complete_Partial_Order.chain ord Y; Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> spmf (lub_spmf (f ` Y)) x =\n                         (\\<Squnion>p\\<in>Y. spmf (f p) x)", "apply(subst cont_spmf[THEN contD])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>monotone ord (ord_spmf (=)) f;\n        cont lub ord lub_spmf (ord_spmf (=)) f;\n        Complete_Partial_Order.chain ord Y; Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Complete_Partial_Order.chain (ord_spmf (=)) (f ` Y)\n 2. \\<And>Y.\n       \\<lbrakk>monotone ord (ord_spmf (=)) f;\n        cont lub ord lub_spmf (ord_spmf (=)) f;\n        Complete_Partial_Order.chain ord Y; Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> f ` Y \\<noteq> {}\n 3. \\<And>Y.\n       \\<lbrakk>monotone ord (ord_spmf (=)) f;\n        cont lub ord lub_spmf (ord_spmf (=)) f;\n        Complete_Partial_Order.chain ord Y; Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>p\\<in>f ` Y. spmf p x) =\n                         (\\<Squnion>p\\<in>Y. spmf (f p) x)", "apply(erule (2) chain_imageI[OF _ monotoneD])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>monotone ord (ord_spmf (=)) f;\n        cont lub ord lub_spmf (ord_spmf (=)) f;\n        Complete_Partial_Order.chain ord Y; Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> f ` Y \\<noteq> {}\n 2. \\<And>Y.\n       \\<lbrakk>monotone ord (ord_spmf (=)) f;\n        cont lub ord lub_spmf (ord_spmf (=)) f;\n        Complete_Partial_Order.chain ord Y; Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>p\\<in>f ` Y. spmf p x) =\n                         (\\<Squnion>p\\<in>Y. spmf (f p) x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>monotone ord (ord_spmf (=)) f;\n        cont lub ord lub_spmf (ord_spmf (=)) f;\n        Complete_Partial_Order.chain ord Y; Y \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>p\\<in>f ` Y. spmf p x) =\n                         (\\<Squnion>p\\<in>Y. spmf (f p) x)", "apply(simp add: image_image)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ord_spmf_try_spmf2: \"ord_spmf R p (try_spmf p q)\" if \"rel_spmf R p p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf R p (TRY p ELSE q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ord_spmf R p (TRY p ELSE q)", "have \"ord_spmf R (bind_pmf p return_pmf) (try_spmf p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf R (p \\<bind> return_pmf) (TRY p ELSE q)", "unfolding try_spmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf R (p \\<bind> return_pmf) (p \\<bind> case_option q return_spmf)", "by(rule rel_pmf_bindI[where R=\"rel_option R\"])\n       (use that in \\<open>auto simp add: rel_pmf_return_pmf1 elim!: option.rel_cases\\<close>)"], ["proof (state)\nthis:\n  ord_spmf R (p \\<bind> return_pmf) (TRY p ELSE q)\n\ngoal (1 subgoal):\n 1. ord_spmf R p (TRY p ELSE q)", "then"], ["proof (chain)\npicking this:\n  ord_spmf R (p \\<bind> return_pmf) (TRY p ELSE q)", "show ?thesis"], ["proof (prove)\nusing this:\n  ord_spmf R (p \\<bind> return_pmf) (TRY p ELSE q)\n\ngoal (1 subgoal):\n 1. ord_spmf R p (TRY p ELSE q)", "by(simp add: bind_return_pmf')"], ["proof (state)\nthis:\n  ord_spmf R p (TRY p ELSE q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ord_spmf_lossless_spmfD1:\n  assumes \"ord_spmf R p q\"\n    and \"lossless_spmf p\"\n  shows \"rel_spmf R p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf R p q", "by (metis (no_types, lifting) assms lossless_iff_set_pmf_None option.simps(11) ord_option.cases pmf.rel_mono_strong)"], ["", "lemma restrict_spmf_mono:\n  \"ord_spmf (=) p q \\<Longrightarrow> ord_spmf (=) (p \\<upharpoonleft> A) (q \\<upharpoonleft> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=) p q \\<Longrightarrow>\n    ord_spmf (=) (p \\<upharpoonleft> A) (q \\<upharpoonleft> A)", "by(auto simp add: restrict_spmf_def pmf.rel_map elim!: pmf.rel_mono_strong elim: ord_option.cases)"], ["", "lemma restrict_lub_spmf:\n  assumes chain: \"Complete_Partial_Order.chain (ord_spmf (=)) Y\"\n  shows \"restrict_spmf (lub_spmf Y) A = lub_spmf ((\\<lambda>p. restrict_spmf p A) ` Y)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lub_spmf Y \\<upharpoonleft> A =\n    lub_spmf ((\\<lambda>p. p \\<upharpoonleft> A) ` Y)", "proof(cases \"Y = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Y = {} \\<Longrightarrow>\n    lub_spmf Y \\<upharpoonleft> A =\n    lub_spmf ((\\<lambda>p. p \\<upharpoonleft> A) ` Y)\n 2. Y \\<noteq> {} \\<Longrightarrow>\n    lub_spmf Y \\<upharpoonleft> A =\n    lub_spmf ((\\<lambda>p. p \\<upharpoonleft> A) ` Y)", "case Y: False"], ["proof (state)\nthis:\n  Y \\<noteq> {}\n\ngoal (2 subgoals):\n 1. Y = {} \\<Longrightarrow>\n    lub_spmf Y \\<upharpoonleft> A =\n    lub_spmf ((\\<lambda>p. p \\<upharpoonleft> A) ` Y)\n 2. Y \\<noteq> {} \\<Longrightarrow>\n    lub_spmf Y \\<upharpoonleft> A =\n    lub_spmf ((\\<lambda>p. p \\<upharpoonleft> A) ` Y)", "have chain': \"Complete_Partial_Order.chain (ord_spmf (=)) ((\\<lambda>p. p \\<upharpoonleft> A) ` Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (ord_spmf (=))\n     ((\\<lambda>p. p \\<upharpoonleft> A) ` Y)", "using chain"], ["proof (prove)\nusing this:\n  Complete_Partial_Order.chain (ord_spmf (=)) Y\n\ngoal (1 subgoal):\n 1. Complete_Partial_Order.chain (ord_spmf (=))\n     ((\\<lambda>p. p \\<upharpoonleft> A) ` Y)", "by(rule chain_imageI)(auto intro: restrict_spmf_mono)"], ["proof (state)\nthis:\n  Complete_Partial_Order.chain (ord_spmf (=))\n   ((\\<lambda>p. p \\<upharpoonleft> A) ` Y)\n\ngoal (2 subgoals):\n 1. Y = {} \\<Longrightarrow>\n    lub_spmf Y \\<upharpoonleft> A =\n    lub_spmf ((\\<lambda>p. p \\<upharpoonleft> A) ` Y)\n 2. Y \\<noteq> {} \\<Longrightarrow>\n    lub_spmf Y \\<upharpoonleft> A =\n    lub_spmf ((\\<lambda>p. p \\<upharpoonleft> A) ` Y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lub_spmf Y \\<upharpoonleft> A =\n    lub_spmf ((\\<lambda>p. p \\<upharpoonleft> A) ` Y)", "by(rule spmf_eqI)(simp add: spmf_lub_spmf[OF chain'] Y image_image spmf_restrict_spmf spmf_lub_spmf[OF chain])"], ["proof (state)\nthis:\n  lub_spmf Y \\<upharpoonleft> A =\n  lub_spmf ((\\<lambda>p. p \\<upharpoonleft> A) ` Y)\n\ngoal (1 subgoal):\n 1. Y = {} \\<Longrightarrow>\n    lub_spmf Y \\<upharpoonleft> A =\n    lub_spmf ((\\<lambda>p. p \\<upharpoonleft> A) ` Y)", "qed simp"], ["", "lemma mono2mono_restrict_spmf [THEN spmf.mono2mono]:\n  shows monotone_restrict_spmf: \"monotone (ord_spmf (=)) (ord_spmf (=)) (\\<lambda>p. p \\<upharpoonleft> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone (ord_spmf (=)) (ord_spmf (=))\n     (\\<lambda>p. p \\<upharpoonleft> A)", "by(rule monotoneI)(rule restrict_spmf_mono)"], ["", "lemma mcont2mcont_restrict_spmf [THEN spmf.mcont2mcont, cont_intro]:\n  shows  mcont_restrict_spmf: \"mcont lub_spmf (ord_spmf (=)) lub_spmf (ord_spmf (=)) (\\<lambda>p. restrict_spmf p A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mcont lub_spmf (ord_spmf (=)) lub_spmf (ord_spmf (=))\n     (\\<lambda>p. p \\<upharpoonleft> A)", "using monotone_restrict_spmf"], ["proof (prove)\nusing this:\n  monotone (ord_spmf (=)) (ord_spmf (=)) (\\<lambda>p. p \\<upharpoonleft> ?A)\n\ngoal (1 subgoal):\n 1. mcont lub_spmf (ord_spmf (=)) lub_spmf (ord_spmf (=))\n     (\\<lambda>p. p \\<upharpoonleft> A)", "by(rule mcontI)(simp add: contI restrict_lub_spmf)"], ["", "lemma ord_spmf_case_option: \"ord_spmf R (case x of None \\<Rightarrow> a | Some y \\<Rightarrow> b y) (case x of None \\<Rightarrow> a' | Some y \\<Rightarrow> b' y)\"\n  if \"ord_spmf R a a'\" \"\\<And>y. ord_spmf R (b y) (b' y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf R (case x of None \\<Rightarrow> a | Some y \\<Rightarrow> b y)\n     (case x of None \\<Rightarrow> a' | Some y \\<Rightarrow> b' y)", "using that"], ["proof (prove)\nusing this:\n  ord_spmf R a a'\n  ord_spmf R (b ?y) (b' ?y)\n\ngoal (1 subgoal):\n 1. ord_spmf R (case x of None \\<Rightarrow> a | Some y \\<Rightarrow> b y)\n     (case x of None \\<Rightarrow> a' | Some y \\<Rightarrow> b' y)", "by(cases x) auto"], ["", "lemma ord_spmf_map_spmfI: \"ord_spmf (=) (map_spmf f p) (map_spmf f q)\" if \"ord_spmf (=) p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=) (map_spmf f p) (map_spmf f q)", "using that"], ["proof (prove)\nusing this:\n  ord_spmf (=) p q\n\ngoal (1 subgoal):\n 1. ord_spmf (=) (map_spmf f p) (map_spmf f q)", "by(auto simp add: pmf.rel_map elim!: pmf.rel_mono_strong ord_option.cases)"], ["", "subsubsection \\<open>Conditional probabilities\\<close>"], ["", "lemma mk_lossless_cond_spmf [simp]: \"mk_lossless (cond_spmf p A) = cond_spmf p A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_lossless (cond_spmf p A) = cond_spmf p A", "by(simp add: cond_spmf_alt)"], ["", "context\n  fixes p :: \"'a pmf\"\n    and f :: \"'a \\<Rightarrow> 'b pmf\"\n    and A :: \"'b set\"\n    and F :: \"'a \\<Rightarrow> real\"\n  defines \"F \\<equiv> \\<lambda>x. pmf p x * measure (measure_pmf (f x)) A / measure (measure_pmf (bind_pmf p f)) A\"\nbegin"], ["", "definition cond_bind_pmf :: \"'a pmf\" where \"cond_bind_pmf = embed_pmf F\""], ["", "lemma cond_bind_pmf_nonneg: \"F x \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> F x", "by(simp add: F_def)"], ["", "context assumes defined: \"A \\<inter> (\\<Union>x\\<in>set_pmf p. set_pmf (f x)) \\<noteq> {}\" begin"], ["", "private"], ["", "lemma nonzero: \"measure (measure_pmf (bind_pmf p f)) A > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < measure_pmf.prob (p \\<bind> f) A", "using defined"], ["proof (prove)\nusing this:\n  A \\<inter> (\\<Union>x\\<in>set_pmf p. set_pmf (f x)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. 0 < measure_pmf.prob (p \\<bind> f) A", "by(auto 4 3 intro: measure_pmf_posI)"], ["", "lemma cond_bind_pmf_prob: \"(\\<integral>\\<^sup>+ x. F x \\<partial>count_space UNIV) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (F x)) = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (F x)) = 1", "have nonzero': \"(\\<integral>\\<^sup>+ x. ennreal (pmf p x) * ennreal (measure_pmf.prob (f x) A) \\<partial>count_space UNIV) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal (pmf p x) * ennreal (measure_pmf.prob (f x) A)) \\<noteq>\n    0", "using defined"], ["proof (prove)\nusing this:\n  A \\<inter> (\\<Union>x\\<in>set_pmf p. set_pmf (f x)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal (pmf p x) * ennreal (measure_pmf.prob (f x) A)) \\<noteq>\n    0", "by(auto simp add: nn_integral_0_iff_AE AE_count_space pmf_eq_0_set_pmf measure_pmf_zero_iff)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     ennreal (pmf p x) * ennreal (measure_pmf.prob (f x) A)) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (F x)) = 1", "have finite: \"(\\<integral>\\<^sup>+ x. ennreal (pmf p x) * ennreal (measure_pmf.prob (f x) A) \\<partial>count_space UNIV) < \\<top>\" (is \"?lhs < _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal (pmf p x) * ennreal (measure_pmf.prob (f x) A))\n    < \\<top>", "proof(rule order.strict_trans1)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal (pmf p x) * ennreal (measure_pmf.prob (f x) A))\n    \\<le> ?b\n 2. ?b < \\<top>", "show \"?lhs \\<le> (\\<integral>\\<^sup>+ x. ennreal (pmf p x) * 1 \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal (pmf p x) * ennreal (measure_pmf.prob (f x) A))\n    \\<le> (\\<Sum>\\<^sup>+ x. ennreal (pmf p x) * 1)", "by(rule nn_integral_mono)(simp add: mult_left_le)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x. ennreal (pmf p x) * ennreal (measure_pmf.prob (f x) A))\n  \\<le> (\\<Sum>\\<^sup>+ x. ennreal (pmf p x) * 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (pmf p x) * 1) < \\<top>", "show \"\\<dots> < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (pmf p x) * 1) < \\<top>", "by(simp add: nn_integral_pmf_eq_1)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x. ennreal (pmf p x) * 1) < \\<top>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x. ennreal (pmf p x) * ennreal (measure_pmf.prob (f x) A))\n  < \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (F x)) = 1", "have \"(\\<integral>\\<^sup>+ x. F x \\<partial>count_space UNIV) = \n    (\\<Sum>\\<^sup>+ x. ennreal (pmf p x * measure_pmf.prob (f x) A)) / emeasure (measure_pmf (bind_pmf p f)) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (F x)) =\n    (\\<Sum>\\<^sup>+ x. ennreal (pmf p x * measure_pmf.prob (f x) A)) /\n    emeasure (measure_pmf (p \\<bind> f)) A", "using nonzero"], ["proof (prove)\nusing this:\n  0 < measure_pmf.prob (p \\<bind> f) A\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (F x)) =\n    (\\<Sum>\\<^sup>+ x. ennreal (pmf p x * measure_pmf.prob (f x) A)) /\n    emeasure (measure_pmf (p \\<bind> f)) A", "unfolding F_def measure_pmf.emeasure_eq_measure"], ["proof (prove)\nusing this:\n  0 < measure_pmf.prob (p \\<bind> f) A\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (pmf p x * measure_pmf.prob (f x) A /\n         measure_pmf.prob (p \\<bind> f) A)) =\n    (\\<Sum>\\<^sup>+ x. ennreal (pmf p x * measure_pmf.prob (f x) A)) /\n    ennreal (measure_pmf.prob (p \\<bind> f) A)", "by(simp add: divide_ennreal[symmetric] divide_ennreal_def nn_integral_multc)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x. ennreal (F x)) =\n  (\\<Sum>\\<^sup>+ x. ennreal (pmf p x * measure_pmf.prob (f x) A)) /\n  emeasure (measure_pmf (p \\<bind> f)) A\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (F x)) = 1", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x. ennreal (F x)) =\n  (\\<Sum>\\<^sup>+ x. ennreal (pmf p x * measure_pmf.prob (f x) A)) /\n  emeasure (measure_pmf (p \\<bind> f)) A\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (F x)) = 1", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (pmf p x * measure_pmf.prob (f x) A)) /\n    emeasure (measure_pmf (p \\<bind> f)) A =\n    1", "unfolding emeasure_bind_pmf"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (pmf p x * measure_pmf.prob (f x) A)) /\n    \\<integral>\\<^sup>+ x. emeasure (measure_pmf (f x)) A\n                       \\<partial>measure_pmf p =\n    1", "by(simp add: measure_pmf.emeasure_eq_measure nn_integral_measure_pmf ennreal_mult' nonzero' finite)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x. ennreal (pmf p x * measure_pmf.prob (f x) A)) /\n  emeasure (measure_pmf (p \\<bind> f)) A =\n  1\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (F x)) = 1", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>\\<^sup>+ x. ennreal (F x)) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<^sup>+ x. ennreal (F x)) = 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (F x)) = 1", "."], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x. ennreal (F x)) = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pmf_cond_bind_pmf: \"pmf cond_bind_pmf x = F x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf local.cond_bind_pmf x = F x", "unfolding cond_bind_pmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (embed_pmf F) x = F x", "by(rule pmf_embed_pmf[OF cond_bind_pmf_nonneg cond_bind_pmf_prob])"], ["", "lemma set_cond_bind_pmf: \"set_pmf cond_bind_pmf = {x\\<in>set_pmf p. set_pmf (f x) \\<inter> A \\<noteq> {}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_pmf local.cond_bind_pmf =\n    {x \\<in> set_pmf p. set_pmf (f x) \\<inter> A \\<noteq> {}}", "unfolding cond_bind_pmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_pmf (embed_pmf F) =\n    {x \\<in> set_pmf p. set_pmf (f x) \\<inter> A \\<noteq> {}}", "by(subst set_embed_pmf[OF cond_bind_pmf_nonneg cond_bind_pmf_prob])\n    (auto simp add: F_def pmf_eq_0_set_pmf measure_pmf_zero_iff)"], ["", "lemma cond_bind_pmf: \"cond_pmf (bind_pmf p f) A = bind_pmf cond_bind_pmf (\\<lambda>x. cond_pmf (f x) A)\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_pmf (p \\<bind> f) A =\n    local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)", "proof(rule pmf_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (cond_pmf (p \\<bind> f) A) i =\n       pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (cond_pmf (p \\<bind> f) A) i =\n       pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i", "have \"ennreal (pmf ?lhs i) = ennreal (pmf ?rhs i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n    ennreal\n     (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)", "proof(cases \"i \\<in> A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<in> A \\<Longrightarrow>\n    ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n    ennreal\n     (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)\n 2. i \\<notin> A \\<Longrightarrow>\n    ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n    ennreal\n     (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)", "case True"], ["proof (state)\nthis:\n  i \\<in> A\n\ngoal (2 subgoals):\n 1. i \\<in> A \\<Longrightarrow>\n    ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n    ennreal\n     (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)\n 2. i \\<notin> A \\<Longrightarrow>\n    ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n    ennreal\n     (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)", "have \"ennreal (pmf ?lhs i) = (\\<integral>\\<^sup>+ x. ennreal (pmf p x) * ennreal (pmf (f x) i) / ennreal (measure_pmf.prob (p \\<bind> f) A) \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n    (\\<Sum>\\<^sup>+ x.\n       ennreal (pmf p x) * ennreal (pmf (f x) i) /\n       ennreal (measure_pmf.prob (p \\<bind> f) A))", "using True defined"], ["proof (prove)\nusing this:\n  i \\<in> A\n  A \\<inter> (\\<Union>x\\<in>set_pmf p. set_pmf (f x)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n    (\\<Sum>\\<^sup>+ x.\n       ennreal (pmf p x) * ennreal (pmf (f x) i) /\n       ennreal (measure_pmf.prob (p \\<bind> f) A))", "by(simp add: pmf_cond bind_UNION Int_commute divide_ennreal[symmetric] nonzero ennreal_pmf_bind)\n        (simp add: divide_ennreal_def nn_integral_multc[symmetric] nn_integral_measure_pmf)"], ["proof (state)\nthis:\n  ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n  (\\<Sum>\\<^sup>+ x.\n     ennreal (pmf p x) * ennreal (pmf (f x) i) /\n     ennreal (measure_pmf.prob (p \\<bind> f) A))\n\ngoal (2 subgoals):\n 1. i \\<in> A \\<Longrightarrow>\n    ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n    ennreal\n     (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)\n 2. i \\<notin> A \\<Longrightarrow>\n    ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n    ennreal\n     (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)", "also"], ["proof (state)\nthis:\n  ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n  (\\<Sum>\\<^sup>+ x.\n     ennreal (pmf p x) * ennreal (pmf (f x) i) /\n     ennreal (measure_pmf.prob (p \\<bind> f) A))\n\ngoal (2 subgoals):\n 1. i \\<in> A \\<Longrightarrow>\n    ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n    ennreal\n     (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)\n 2. i \\<notin> A \\<Longrightarrow>\n    ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n    ennreal\n     (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)", "have \"\\<dots> =  (\\<integral>\\<^sup>+ x. ennreal (F x) * ennreal (pmf (cond_pmf (f x) A) i) \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal (pmf p x) * ennreal (pmf (f x) i) /\n       ennreal (measure_pmf.prob (p \\<bind> f) A)) =\n    (\\<Sum>\\<^sup>+ x. ennreal (F x) * ennreal (pmf (cond_pmf (f x) A) i))", "using True nonzero"], ["proof (prove)\nusing this:\n  i \\<in> A\n  0 < measure_pmf.prob (p \\<bind> f) A\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal (pmf p x) * ennreal (pmf (f x) i) /\n       ennreal (measure_pmf.prob (p \\<bind> f) A)) =\n    (\\<Sum>\\<^sup>+ x. ennreal (F x) * ennreal (pmf (cond_pmf (f x) A) i))", "apply(intro nn_integral_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>i \\<in> A; 0 < measure_pmf.prob (p \\<bind> f) A;\n        x \\<in> space (count_space UNIV)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf p x) * ennreal (pmf (f x) i) /\n                         ennreal (measure_pmf.prob (p \\<bind> f) A) =\n                         ennreal (F x) * ennreal (pmf (cond_pmf (f x) A) i)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<in> A; 0 < measure_pmf.prob (p \\<bind> f) A;\n     x \\<in> space (count_space UNIV)\\<rbrakk>\n    \\<Longrightarrow> ennreal (pmf p x) * ennreal (pmf (f x) i) /\n                      ennreal (measure_pmf.prob (p \\<bind> f) A) =\n                      ennreal (F x) * ennreal (pmf (cond_pmf (f x) A) i)", "by(clarsimp simp add: F_def ennreal_mult'[symmetric] divide_ennreal)\n          (cases \"measure_pmf.prob (f x) A = 0\"; auto simp add: pmf_cond pmf_eq_0_set_pmf measure_pmf_zero_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     ennreal (pmf p x) * ennreal (pmf (f x) i) /\n     ennreal (measure_pmf.prob (p \\<bind> f) A)) =\n  (\\<Sum>\\<^sup>+ x. ennreal (F x) * ennreal (pmf (cond_pmf (f x) A) i))\n\ngoal (2 subgoals):\n 1. i \\<in> A \\<Longrightarrow>\n    ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n    ennreal\n     (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)\n 2. i \\<notin> A \\<Longrightarrow>\n    ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n    ennreal\n     (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     ennreal (pmf p x) * ennreal (pmf (f x) i) /\n     ennreal (measure_pmf.prob (p \\<bind> f) A)) =\n  (\\<Sum>\\<^sup>+ x. ennreal (F x) * ennreal (pmf (cond_pmf (f x) A) i))\n\ngoal (2 subgoals):\n 1. i \\<in> A \\<Longrightarrow>\n    ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n    ennreal\n     (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)\n 2. i \\<notin> A \\<Longrightarrow>\n    ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n    ennreal\n     (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)", "have \"\\<dots> = ennreal (pmf ?rhs i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x. ennreal (F x) * ennreal (pmf (cond_pmf (f x) A) i)) =\n    ennreal\n     (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)", "by(simp add: ennreal_pmf_bind nn_integral_measure_pmf pmf_cond_bind_pmf)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x. ennreal (F x) * ennreal (pmf (cond_pmf (f x) A) i)) =\n  ennreal\n   (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)\n\ngoal (2 subgoals):\n 1. i \\<in> A \\<Longrightarrow>\n    ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n    ennreal\n     (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)\n 2. i \\<notin> A \\<Longrightarrow>\n    ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n    ennreal\n     (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)", "finally"], ["proof (chain)\npicking this:\n  ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n  ennreal\n   (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)", "show ?thesis"], ["proof (prove)\nusing this:\n  ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n  ennreal\n   (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)\n\ngoal (1 subgoal):\n 1. ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n    ennreal\n     (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)", "."], ["proof (state)\nthis:\n  ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n  ennreal\n   (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)\n\ngoal (1 subgoal):\n 1. i \\<notin> A \\<Longrightarrow>\n    ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n    ennreal\n     (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<notin> A \\<Longrightarrow>\n    ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n    ennreal\n     (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)", "case False"], ["proof (state)\nthis:\n  i \\<notin> A\n\ngoal (1 subgoal):\n 1. i \\<notin> A \\<Longrightarrow>\n    ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n    ennreal\n     (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)", "then"], ["proof (chain)\npicking this:\n  i \\<notin> A", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<notin> A\n\ngoal (1 subgoal):\n 1. ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n    ennreal\n     (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)", "using defined"], ["proof (prove)\nusing this:\n  i \\<notin> A\n  A \\<inter> (\\<Union>x\\<in>set_pmf p. set_pmf (f x)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n    ennreal\n     (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)", "by(simp add: pmf_cond bind_UNION Int_commute pmf_eq_0_set_pmf set_cond_bind_pmf)"], ["proof (state)\nthis:\n  ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n  ennreal\n   (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n  ennreal\n   (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (cond_pmf (p \\<bind> f) A) i =\n       pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i", "then"], ["proof (chain)\npicking this:\n  ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n  ennreal\n   (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)", "show \"pmf ?lhs i = pmf ?rhs i\""], ["proof (prove)\nusing this:\n  ennreal (pmf (cond_pmf (p \\<bind> f) A) i) =\n  ennreal\n   (pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i)\n\ngoal (1 subgoal):\n 1. pmf (cond_pmf (p \\<bind> f) A) i =\n    pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i", "by simp"], ["proof (state)\nthis:\n  pmf (cond_pmf (p \\<bind> f) A) i =\n  pmf (local.cond_bind_pmf \\<bind> (\\<lambda>x. cond_pmf (f x) A)) i\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "lemma cond_spmf_try1:\n  \"cond_spmf (try_spmf p q) A = cond_spmf p A\" if \"set_spmf q \\<inter> A = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf (TRY p ELSE q) A = cond_spmf p A", "apply(rule spmf_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. spmf (cond_spmf (TRY p ELSE q) A) i = spmf (cond_spmf p A) i", "using that"], ["proof (prove)\nusing this:\n  set_spmf q \\<inter> A = {}\n\ngoal (1 subgoal):\n 1. \\<And>i. spmf (cond_spmf (TRY p ELSE q) A) i = spmf (cond_spmf p A) i", "apply(auto simp add: spmf_try_spmf measure_try_spmf measure_spmf_zero_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>set_spmf q \\<inter> A = {}; i \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (spmf p i + pmf p None * spmf q i) /\n                         (Sigma_Algebra.measure (measure_spmf p) A +\n                          pmf p None *\n                          Sigma_Algebra.measure (measure_spmf q) A) =\n                         spmf p i / Sigma_Algebra.measure (measure_spmf p) A", "apply(subst (2) spmf_eq_0_set_spmf[THEN iffD2])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>set_spmf q \\<inter> A = {}; i \\<in> A\\<rbrakk>\n       \\<Longrightarrow> i \\<notin> set_spmf q\n 2. \\<And>i.\n       \\<lbrakk>set_spmf q \\<inter> A = {}; i \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (spmf p i + pmf p None * 0) /\n                         (Sigma_Algebra.measure (measure_spmf p) A +\n                          pmf p None *\n                          Sigma_Algebra.measure (measure_spmf q) A) =\n                         spmf p i / Sigma_Algebra.measure (measure_spmf p) A", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>set_spmf q \\<inter> A = {}; i \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (spmf p i + pmf p None * 0) /\n                         (Sigma_Algebra.measure (measure_spmf p) A +\n                          pmf p None *\n                          Sigma_Algebra.measure (measure_spmf q) A) =\n                         spmf p i / Sigma_Algebra.measure (measure_spmf p) A", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>set_spmf q \\<inter> A = {}; i \\<in> A\\<rbrakk>\n       \\<Longrightarrow> spmf p i = 0 \\<or>\n                         pmf p None = 0 \\<or>\n                         Sigma_Algebra.measure (measure_spmf q) A = 0", "apply(simp add: measure_try_spmf measure_spmf_zero_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cond_spmf_cong: \"cond_spmf p A = cond_spmf p B\" if \"A \\<inter> set_spmf p = B \\<inter> set_spmf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf p A = cond_spmf p B", "apply(rule spmf_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. spmf (cond_spmf p A) i = spmf (cond_spmf p B) i", "using that"], ["proof (prove)\nusing this:\n  A \\<inter> set_spmf p = B \\<inter> set_spmf p\n\ngoal (1 subgoal):\n 1. \\<And>i. spmf (cond_spmf p A) i = spmf (cond_spmf p B) i", "by(auto simp add: measure_spmf_zero_iff spmf_eq_0_set_spmf measure_spmf_cong[OF that])"], ["", "lemma cond_spmf_pair_spmf:\n  \"cond_spmf (pair_spmf p q) (A \\<times> B) = pair_spmf (cond_spmf p A) (cond_spmf q B)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf (pair_spmf p q) (A \\<times> B) =\n    pair_spmf (cond_spmf p A) (cond_spmf q B)", "proof(rule spmf_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       spmf (cond_spmf (pair_spmf p q) (A \\<times> B)) i =\n       spmf (pair_spmf (cond_spmf p A) (cond_spmf q B)) i", "show \"spmf ?lhs i = spmf ?rhs i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (cond_spmf (pair_spmf p q) (A \\<times> B)) i =\n    spmf (pair_spmf (cond_spmf p A) (cond_spmf q B)) i", "proof(cases i)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       i = (a, b) \\<Longrightarrow>\n       spmf (cond_spmf (pair_spmf p q) (A \\<times> B)) i =\n       spmf (pair_spmf (cond_spmf p A) (cond_spmf q B)) i", "case i [simp]: (Pair a b)"], ["proof (state)\nthis:\n  i = (a, b)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       i = (a, b) \\<Longrightarrow>\n       spmf (cond_spmf (pair_spmf p q) (A \\<times> B)) i =\n       spmf (pair_spmf (cond_spmf p A) (cond_spmf q B)) i", "then"], ["proof (chain)\npicking this:\n  i = (a, b)", "show ?thesis"], ["proof (prove)\nusing this:\n  i = (a, b)\n\ngoal (1 subgoal):\n 1. spmf (cond_spmf (pair_spmf p q) (A \\<times> B)) i =\n    spmf (pair_spmf (cond_spmf p A) (cond_spmf q B)) i", "by(simp add: measure_pair_spmf_times)"], ["proof (state)\nthis:\n  spmf (cond_spmf (pair_spmf p q) (A \\<times> B)) i =\n  spmf (pair_spmf (cond_spmf p A) (cond_spmf q B)) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  spmf (cond_spmf (pair_spmf p q) (A \\<times> B)) ?i =\n  spmf (pair_spmf (cond_spmf p A) (cond_spmf q B)) ?i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cond_spmf_pair_spmf1:\n  \"cond_spmf_fst (map_spmf (\\<lambda>((x, s'), y). (f x, s', y)) (pair_spmf p q)) x =\n   pair_spmf (cond_spmf_fst (map_spmf (\\<lambda>(x, s'). (f x, s')) p) x) q\" (is \"?lhs = ?rhs\")\n  if \"lossless_spmf q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf_fst\n     (map_spmf (\\<lambda>((x, s'), y). (f x, s', y)) (pair_spmf p q)) x =\n    pair_spmf (cond_spmf_fst (map_spmf (\\<lambda>(x, s'). (f x, s')) p) x) q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cond_spmf_fst\n     (map_spmf (\\<lambda>((x, s'), y). (f x, s', y)) (pair_spmf p q)) x =\n    pair_spmf (cond_spmf_fst (map_spmf (\\<lambda>(x, s'). (f x, s')) p) x) q", "have \"?lhs = map_spmf (\\<lambda>((_, s'), y). (s', y)) (cond_spmf (pair_spmf p q) ((\\<lambda>((x, s'), y). (f x, s', y)) -` ({x} \\<times> UNIV)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf_fst\n     (map_spmf (\\<lambda>((x, s'), y). (f x, s', y)) (pair_spmf p q)) x =\n    map_spmf (\\<lambda>((uu_, s'), y). (s', y))\n     (cond_spmf (pair_spmf p q)\n       ((\\<lambda>((x, s'), y). (f x, s', y)) -` ({x} \\<times> UNIV)))", "by(simp add: cond_spmf_fst_def spmf.map_comp o_def split_def)"], ["proof (state)\nthis:\n  cond_spmf_fst\n   (map_spmf (\\<lambda>((x, s'), y). (f x, s', y)) (pair_spmf p q)) x =\n  map_spmf (\\<lambda>((uu_, s'), y). (s', y))\n   (cond_spmf (pair_spmf p q)\n     ((\\<lambda>((x, s'), y). (f x, s', y)) -` ({x} \\<times> UNIV)))\n\ngoal (1 subgoal):\n 1. cond_spmf_fst\n     (map_spmf (\\<lambda>((x, s'), y). (f x, s', y)) (pair_spmf p q)) x =\n    pair_spmf (cond_spmf_fst (map_spmf (\\<lambda>(x, s'). (f x, s')) p) x) q", "also"], ["proof (state)\nthis:\n  cond_spmf_fst\n   (map_spmf (\\<lambda>((x, s'), y). (f x, s', y)) (pair_spmf p q)) x =\n  map_spmf (\\<lambda>((uu_, s'), y). (s', y))\n   (cond_spmf (pair_spmf p q)\n     ((\\<lambda>((x, s'), y). (f x, s', y)) -` ({x} \\<times> UNIV)))\n\ngoal (1 subgoal):\n 1. cond_spmf_fst\n     (map_spmf (\\<lambda>((x, s'), y). (f x, s', y)) (pair_spmf p q)) x =\n    pair_spmf (cond_spmf_fst (map_spmf (\\<lambda>(x, s'). (f x, s')) p) x) q", "have \"((\\<lambda>((x, s'), y). (f x, s', y)) -` ({x} \\<times> UNIV)) = ((\\<lambda>(x, y). (f x, y)) -` ({x} \\<times> UNIV)) \\<times> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>((x, s'), y). (f x, s', y)) -` ({x} \\<times> UNIV) =\n    (\\<lambda>(x, y). (f x, y)) -` ({x} \\<times> UNIV) \\<times> UNIV", "by(auto)"], ["proof (state)\nthis:\n  (\\<lambda>((x, s'), y). (f x, s', y)) -` ({x} \\<times> UNIV) =\n  (\\<lambda>(x, y). (f x, y)) -` ({x} \\<times> UNIV) \\<times> UNIV\n\ngoal (1 subgoal):\n 1. cond_spmf_fst\n     (map_spmf (\\<lambda>((x, s'), y). (f x, s', y)) (pair_spmf p q)) x =\n    pair_spmf (cond_spmf_fst (map_spmf (\\<lambda>(x, s'). (f x, s')) p) x) q", "also"], ["proof (state)\nthis:\n  (\\<lambda>((x, s'), y). (f x, s', y)) -` ({x} \\<times> UNIV) =\n  (\\<lambda>(x, y). (f x, y)) -` ({x} \\<times> UNIV) \\<times> UNIV\n\ngoal (1 subgoal):\n 1. cond_spmf_fst\n     (map_spmf (\\<lambda>((x, s'), y). (f x, s', y)) (pair_spmf p q)) x =\n    pair_spmf (cond_spmf_fst (map_spmf (\\<lambda>(x, s'). (f x, s')) p) x) q", "have \"map_spmf (\\<lambda>((_, s'), y). (s', y)) (cond_spmf (pair_spmf p q) \\<dots>) = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>((uu_, s'), y). (s', y))\n     (cond_spmf (pair_spmf p q)\n       ((\\<lambda>(x, y). (f x, y)) -` ({x} \\<times> UNIV) \\<times> UNIV)) =\n    pair_spmf (cond_spmf_fst (map_spmf (\\<lambda>(x, s'). (f x, s')) p) x) q", "by(simp add: cond_spmf_fst_def cond_spmf_pair_spmf that spmf.map_comp pair_map_spmf1 apfst_def map_prod_def split_def)"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>((uu_, s'), y). (s', y))\n   (cond_spmf (pair_spmf p q)\n     ((\\<lambda>(x, y). (f x, y)) -` ({x} \\<times> UNIV) \\<times> UNIV)) =\n  pair_spmf (cond_spmf_fst (map_spmf (\\<lambda>(x, s'). (f x, s')) p) x) q\n\ngoal (1 subgoal):\n 1. cond_spmf_fst\n     (map_spmf (\\<lambda>((x, s'), y). (f x, s', y)) (pair_spmf p q)) x =\n    pair_spmf (cond_spmf_fst (map_spmf (\\<lambda>(x, s'). (f x, s')) p) x) q", "finally"], ["proof (chain)\npicking this:\n  cond_spmf_fst\n   (map_spmf\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of (x, s') \\<Rightarrow> \\<lambda>y. (f x, s', y)) b)\n     (pair_spmf p q))\n   x =\n  pair_spmf (cond_spmf_fst (map_spmf (\\<lambda>(x, s'). (f x, s')) p) x) q", "show ?thesis"], ["proof (prove)\nusing this:\n  cond_spmf_fst\n   (map_spmf\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of (x, s') \\<Rightarrow> \\<lambda>y. (f x, s', y)) b)\n     (pair_spmf p q))\n   x =\n  pair_spmf (cond_spmf_fst (map_spmf (\\<lambda>(x, s'). (f x, s')) p) x) q\n\ngoal (1 subgoal):\n 1. cond_spmf_fst\n     (map_spmf (\\<lambda>((x, s'), y). (f x, s', y)) (pair_spmf p q)) x =\n    pair_spmf (cond_spmf_fst (map_spmf (\\<lambda>(x, s'). (f x, s')) p) x) q", "."], ["proof (state)\nthis:\n  cond_spmf_fst\n   (map_spmf (\\<lambda>((x, s'), y). (f x, s', y)) (pair_spmf p q)) x =\n  pair_spmf (cond_spmf_fst (map_spmf (\\<lambda>(x, s'). (f x, s')) p) x) q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma try_cond_spmf: \"try_spmf (cond_spmf p A) q = (if set_spmf p \\<inter> A \\<noteq> {} then cond_spmf p A else q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY cond_spmf p A ELSE q =\n    (if set_spmf p \\<inter> A \\<noteq> {} then cond_spmf p A else q)", "apply(clarsimp simp add: cond_spmf_def lossless_iff_set_pmf_None intro!: try_spmf_lossless)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set_spmf p \\<inter> A \\<noteq> {};\n     None \\<in> set_pmf (cond_pmf p (Some ` A))\\<rbrakk>\n    \\<Longrightarrow> False", "apply(subst (asm) set_cond_pmf)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set_spmf p \\<inter> A \\<noteq> {} \\<Longrightarrow>\n    set_pmf p \\<inter> Some ` A \\<noteq> {}\n 2. \\<lbrakk>set_spmf p \\<inter> A \\<noteq> {};\n     None \\<in> set_pmf p \\<inter> Some ` A\\<rbrakk>\n    \\<Longrightarrow> False", "apply(auto simp add: in_set_spmf)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cond_spmf_try2:\n  \"cond_spmf (try_spmf p q) A = (if lossless_spmf p then return_pmf None else cond_spmf q A)\" if \"set_spmf p \\<inter> A = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf (TRY p ELSE q) A =\n    (if lossless_spmf p then return_pmf None else cond_spmf q A)", "apply(rule spmf_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       spmf (cond_spmf (TRY p ELSE q) A) i =\n       spmf (if lossless_spmf p then return_pmf None else cond_spmf q A) i", "using that"], ["proof (prove)\nusing this:\n  set_spmf p \\<inter> A = {}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       spmf (cond_spmf (TRY p ELSE q) A) i =\n       spmf (if lossless_spmf p then return_pmf None else cond_spmf q A) i", "apply(auto simp add: spmf_try_spmf measure_try_spmf measure_spmf_zero_iff lossless_iff_pmf_None)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>set_spmf p \\<inter> A = {}; pmf p None \\<noteq> 0;\n        i \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (spmf p i + pmf p None * spmf q i) /\n                         (Sigma_Algebra.measure (measure_spmf p) A +\n                          pmf p None *\n                          Sigma_Algebra.measure (measure_spmf q) A) =\n                         spmf q i / Sigma_Algebra.measure (measure_spmf q) A", "apply(subst spmf_eq_0_set_spmf[THEN iffD2])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>set_spmf p \\<inter> A = {}; pmf p None \\<noteq> 0;\n        i \\<in> A\\<rbrakk>\n       \\<Longrightarrow> i \\<notin> set_spmf p\n 2. \\<And>i.\n       \\<lbrakk>set_spmf p \\<inter> A = {}; pmf p None \\<noteq> 0;\n        i \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (0 + pmf p None * spmf q i) /\n                         (Sigma_Algebra.measure (measure_spmf p) A +\n                          pmf p None *\n                          Sigma_Algebra.measure (measure_spmf q) A) =\n                         spmf q i / Sigma_Algebra.measure (measure_spmf q) A", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>set_spmf p \\<inter> A = {}; pmf p None \\<noteq> 0;\n        i \\<in> A\\<rbrakk>\n       \\<Longrightarrow> (0 + pmf p None * spmf q i) /\n                         (Sigma_Algebra.measure (measure_spmf p) A +\n                          pmf p None *\n                          Sigma_Algebra.measure (measure_spmf q) A) =\n                         spmf q i / Sigma_Algebra.measure (measure_spmf q) A", "apply(simp add: measure_spmf_zero_iff[THEN iffD2])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition cond_bind_spmf :: \"'a spmf \\<Rightarrow> ('a \\<Rightarrow> 'b spmf) \\<Rightarrow> 'b set \\<Rightarrow> 'a spmf\" where \n  \"cond_bind_spmf p f A = \n   (if \\<exists>x\\<in>set_spmf p. set_spmf (f x) \\<inter> A \\<noteq> {} then \n     cond_bind_pmf p (\\<lambda>x. case x of None \\<Rightarrow> return_pmf None | Some x \\<Rightarrow> f x) (Some ` A)\n    else return_pmf None)\""], ["", "context begin"], ["", "private"], ["", "lemma defined: \"\\<lbrakk> y \\<in> set_spmf (f x); y \\<in> A; x \\<in> set_spmf p \\<rbrakk> \n  \\<Longrightarrow> Some ` A \\<inter> (\\<Union>x\\<in>set_pmf p. set_pmf (case x of None \\<Rightarrow> return_pmf None | Some x \\<Rightarrow> f x)) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> set_spmf (f x); y \\<in> A; x \\<in> set_spmf p\\<rbrakk>\n    \\<Longrightarrow> Some ` A \\<inter>\n                      (\\<Union>x\\<in>set_pmf p.\n                          set_pmf\n                           (case x of None \\<Rightarrow> return_pmf None\n                            | Some x \\<Rightarrow> f x)) \\<noteq>\n                      {}", "by(fastforce simp add: in_set_spmf bind_spmf_def)"], ["", "lemma spmf_cond_bind_spmf [simp]:\n  \"spmf (cond_bind_spmf p f A) x = spmf p x * measure (measure_spmf (f x)) A / measure (measure_spmf (bind_spmf p f)) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (cond_bind_spmf p f A) x =\n    spmf p x * Sigma_Algebra.measure (measure_spmf (f x)) A /\n    Sigma_Algebra.measure (measure_spmf (p \\<bind> f)) A", "by(clarsimp simp add: cond_bind_spmf_def measure_spmf_zero_iff bind_UNION pmf_cond_bind_pmf defined split!: if_split)\n     (fastforce simp add: in_set_spmf bind_spmf_def measure_measure_spmf_conv_measure_pmf)+"], ["", "lemma set_cond_bind_spmf [simp]:\n  \"set_spmf (cond_bind_spmf p f A) = {x\\<in>set_spmf p. set_spmf (f x) \\<inter> A \\<noteq> {}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_spmf (cond_bind_spmf p f A) =\n    {x \\<in> set_spmf p. set_spmf (f x) \\<inter> A \\<noteq> {}}", "by(clarsimp simp add: cond_bind_spmf_def set_spmf_def bind_UNION)\n    (subst set_cond_bind_pmf; fastforce simp add: measure_measure_spmf_conv_measure_pmf)"], ["", "lemma cond_bind_spmf: \"cond_spmf (bind_spmf p f) A = bind_spmf (cond_bind_spmf p f A) (\\<lambda>x. cond_spmf (f x) A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf (p \\<bind> f) A =\n    cond_bind_spmf p f A \\<bind> (\\<lambda>x. cond_spmf (f x) A)", "by(auto simp add: cond_spmf_def bind_UNION cond_bind_spmf_def split!: if_splits)\n    (fastforce split: option.splits simp add: cond_bind_pmf set_cond_bind_pmf defined in_set_spmf bind_spmf_def intro!: bind_pmf_cong[OF refl])"], ["", "end"], ["", "lemma cond_spmf_fst_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_spmf (rel_prod (=) B) ===> (=) ===> rel_spmf B) cond_spmf_fst cond_spmf_fst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_spmf (rel_prod (=) B) ===> (=) ===> rel_spmf B) cond_spmf_fst\n     cond_spmf_fst", "apply(rule rel_funI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_spmf (rel_prod (=) B) x y; xa = ya\\<rbrakk>\n       \\<Longrightarrow> rel_spmf B (cond_spmf_fst x xa)\n                          (cond_spmf_fst y ya)", "apply(clarsimp simp add: cond_spmf_fst_def spmf_rel_map elim!: rel_spmfE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ya pq.\n       \\<forall>a b aa ba.\n          ((a, b), aa, ba) \\<in> set_spmf pq \\<longrightarrow>\n          a = aa \\<and> B b ba \\<Longrightarrow>\n       rel_spmf (\\<lambda>x y. B (snd (fst x)) (snd (snd y)))\n        (cond_spmf pq (fst -` ({ya} \\<times> UNIV)))\n        (cond_spmf pq (snd -` ({ya} \\<times> UNIV)))", "subgoal for x pq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b aa ba.\n       ((a, b), aa, ba) \\<in> set_spmf pq \\<longrightarrow>\n       a = aa \\<and> B b ba \\<Longrightarrow>\n    rel_spmf (\\<lambda>x y. B (snd (fst x)) (snd (snd y)))\n     (cond_spmf pq (fst -` ({x} \\<times> UNIV)))\n     (cond_spmf pq (snd -` ({x} \\<times> UNIV)))", "by(subst (1 2) cond_spmf_cong[where B=\"fst -` ({x} \\<times> UNIV) \\<inter> snd -` ({x} \\<times> UNIV)\"])\n      (fastforce intro: rel_spmf_reflI)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cond_spmf_fst_map_prod:\n  \"cond_spmf_fst (map_spmf (\\<lambda>(x, y). (f x, g x y)) p) (f x) = map_spmf (g x) (cond_spmf_fst p x)\"\n  if \"inj_on f (insert x (fst ` set_spmf p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf_fst (map_spmf (\\<lambda>(x, y). (f x, g x y)) p) (f x) =\n    map_spmf (g x) (cond_spmf_fst p x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cond_spmf_fst (map_spmf (\\<lambda>(x, y). (f x, g x y)) p) (f x) =\n    map_spmf (g x) (cond_spmf_fst p x)", "have \"cond_spmf p ((\\<lambda>(x, y). (f x, g x y)) -` ({f x} \\<times> UNIV)) = cond_spmf p (((\\<lambda>(x, y). (f x, g x y)) -` ({f x} \\<times> UNIV)) \\<inter> set_spmf p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf p ((\\<lambda>(x, y). (f x, g x y)) -` ({f x} \\<times> UNIV)) =\n    cond_spmf p\n     ((\\<lambda>(x, y). (f x, g x y)) -` ({f x} \\<times> UNIV) \\<inter>\n      set_spmf p)", "by(rule cond_spmf_cong) simp"], ["proof (state)\nthis:\n  cond_spmf p ((\\<lambda>(x, y). (f x, g x y)) -` ({f x} \\<times> UNIV)) =\n  cond_spmf p\n   ((\\<lambda>(x, y). (f x, g x y)) -` ({f x} \\<times> UNIV) \\<inter>\n    set_spmf p)\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (map_spmf (\\<lambda>(x, y). (f x, g x y)) p) (f x) =\n    map_spmf (g x) (cond_spmf_fst p x)", "also"], ["proof (state)\nthis:\n  cond_spmf p ((\\<lambda>(x, y). (f x, g x y)) -` ({f x} \\<times> UNIV)) =\n  cond_spmf p\n   ((\\<lambda>(x, y). (f x, g x y)) -` ({f x} \\<times> UNIV) \\<inter>\n    set_spmf p)\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (map_spmf (\\<lambda>(x, y). (f x, g x y)) p) (f x) =\n    map_spmf (g x) (cond_spmf_fst p x)", "have \"((\\<lambda>(x, y). (f x, g x y)) -` ({f x} \\<times> UNIV)) \\<inter> set_spmf p = ({x} \\<times> UNIV) \\<inter> set_spmf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). (f x, g x y)) -` ({f x} \\<times> UNIV) \\<inter>\n    set_spmf p =\n    {x} \\<times> UNIV \\<inter> set_spmf p", "using that"], ["proof (prove)\nusing this:\n  inj_on f (insert x (fst ` set_spmf p))\n\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). (f x, g x y)) -` ({f x} \\<times> UNIV) \\<inter>\n    set_spmf p =\n    {x} \\<times> UNIV \\<inter> set_spmf p", "by(auto 4 3 dest: inj_onD intro: rev_image_eqI)"], ["proof (state)\nthis:\n  (\\<lambda>(x, y). (f x, g x y)) -` ({f x} \\<times> UNIV) \\<inter>\n  set_spmf p =\n  {x} \\<times> UNIV \\<inter> set_spmf p\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (map_spmf (\\<lambda>(x, y). (f x, g x y)) p) (f x) =\n    map_spmf (g x) (cond_spmf_fst p x)", "also"], ["proof (state)\nthis:\n  (\\<lambda>(x, y). (f x, g x y)) -` ({f x} \\<times> UNIV) \\<inter>\n  set_spmf p =\n  {x} \\<times> UNIV \\<inter> set_spmf p\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (map_spmf (\\<lambda>(x, y). (f x, g x y)) p) (f x) =\n    map_spmf (g x) (cond_spmf_fst p x)", "have \"cond_spmf p \\<dots> = cond_spmf p ({x} \\<times> UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf p ({x} \\<times> UNIV \\<inter> set_spmf p) =\n    cond_spmf p ({x} \\<times> UNIV)", "by(rule cond_spmf_cong) simp"], ["proof (state)\nthis:\n  cond_spmf p ({x} \\<times> UNIV \\<inter> set_spmf p) =\n  cond_spmf p ({x} \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (map_spmf (\\<lambda>(x, y). (f x, g x y)) p) (f x) =\n    map_spmf (g x) (cond_spmf_fst p x)", "finally"], ["proof (chain)\npicking this:\n  cond_spmf p\n   ((\\<lambda>a. case a of (x, y) \\<Rightarrow> (f x, g x y)) -`\n    ({f x} \\<times> UNIV)) =\n  cond_spmf p ({x} \\<times> UNIV)", "show ?thesis"], ["proof (prove)\nusing this:\n  cond_spmf p\n   ((\\<lambda>a. case a of (x, y) \\<Rightarrow> (f x, g x y)) -`\n    ({f x} \\<times> UNIV)) =\n  cond_spmf p ({x} \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (map_spmf (\\<lambda>(x, y). (f x, g x y)) p) (f x) =\n    map_spmf (g x) (cond_spmf_fst p x)", "by(auto simp add: cond_spmf_fst_def spmf.map_comp o_def split_def intro: map_spmf_cong)"], ["proof (state)\nthis:\n  cond_spmf_fst (map_spmf (\\<lambda>(x, y). (f x, g x y)) p) (f x) =\n  map_spmf (g x) (cond_spmf_fst p x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cond_spmf_fst_map_prod_inj:\n  \"cond_spmf_fst (map_spmf (\\<lambda>(x, y). (f x, g x y)) p) (f x) =  map_spmf (g x) (cond_spmf_fst p x)\"\n  if \"inj f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf_fst (map_spmf (\\<lambda>(x, y). (f x, g x y)) p) (f x) =\n    map_spmf (g x) (cond_spmf_fst p x)", "apply(rule cond_spmf_fst_map_prod)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f (insert x (fst ` set_spmf p))", "using that"], ["proof (prove)\nusing this:\n  inj f\n\ngoal (1 subgoal):\n 1. inj_on f (insert x (fst ` set_spmf p))", "by(simp add: inj_on_def)"], ["", "definition cond_bind_spmf_fst :: \"'a spmf \\<Rightarrow> ('a \\<Rightarrow> 'b spmf) \\<Rightarrow> 'b \\<Rightarrow> 'a spmf\" where\n  \"cond_bind_spmf_fst p f x = cond_bind_spmf p (map_spmf (\\<lambda>b. (b, ())) \\<circ> f) ({x} \\<times> UNIV)\""], ["", "lemma cond_bind_spmf_fst_map_spmf_fst:\n  \"cond_bind_spmf_fst p (map_spmf fst \\<circ> f) x = cond_bind_spmf p f ({x} \\<times> UNIV)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_bind_spmf_fst p (map_spmf fst \\<circ> f) x =\n    cond_bind_spmf p f ({x} \\<times> UNIV)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cond_bind_spmf_fst p (map_spmf fst \\<circ> f) x =\n    cond_bind_spmf p f ({x} \\<times> UNIV)", "have [simp]: \"(\\<lambda>x. (fst x, ())) -` ({x} \\<times> UNIV) = {x} \\<times> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. (fst x, ())) -` ({x} \\<times> UNIV) = {x} \\<times> UNIV", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. (fst x, ())) -` ({x} \\<times> UNIV) = {x} \\<times> UNIV\n\ngoal (1 subgoal):\n 1. cond_bind_spmf_fst p (map_spmf fst \\<circ> f) x =\n    cond_bind_spmf p f ({x} \\<times> UNIV)", "have \"?lhs = cond_bind_spmf p (\\<lambda>x. map_spmf (\\<lambda>x. (fst x, ())) (f x)) ({x} \\<times> UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_bind_spmf_fst p (map_spmf fst \\<circ> f) x =\n    cond_bind_spmf p (\\<lambda>x. map_spmf (\\<lambda>x. (fst x, ())) (f x))\n     ({x} \\<times> UNIV)", "by(simp add: cond_bind_spmf_fst_def spmf.map_comp o_def)"], ["proof (state)\nthis:\n  cond_bind_spmf_fst p (map_spmf fst \\<circ> f) x =\n  cond_bind_spmf p (\\<lambda>x. map_spmf (\\<lambda>x. (fst x, ())) (f x))\n   ({x} \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. cond_bind_spmf_fst p (map_spmf fst \\<circ> f) x =\n    cond_bind_spmf p f ({x} \\<times> UNIV)", "also"], ["proof (state)\nthis:\n  cond_bind_spmf_fst p (map_spmf fst \\<circ> f) x =\n  cond_bind_spmf p (\\<lambda>x. map_spmf (\\<lambda>x. (fst x, ())) (f x))\n   ({x} \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. cond_bind_spmf_fst p (map_spmf fst \\<circ> f) x =\n    cond_bind_spmf p f ({x} \\<times> UNIV)", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_bind_spmf p (\\<lambda>x. map_spmf (\\<lambda>x. (fst x, ())) (f x))\n     ({x} \\<times> UNIV) =\n    cond_bind_spmf p f ({x} \\<times> UNIV)", "by(rule spmf_eqI)(simp add: measure_map_spmf map_bind_spmf[unfolded o_def, symmetric])"], ["proof (state)\nthis:\n  cond_bind_spmf p (\\<lambda>x. map_spmf (\\<lambda>x. (fst x, ())) (f x))\n   ({x} \\<times> UNIV) =\n  cond_bind_spmf p f ({x} \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. cond_bind_spmf_fst p (map_spmf fst \\<circ> f) x =\n    cond_bind_spmf p f ({x} \\<times> UNIV)", "finally"], ["proof (chain)\npicking this:\n  cond_bind_spmf_fst p (map_spmf fst \\<circ> f) x =\n  cond_bind_spmf p f ({x} \\<times> UNIV)", "show ?thesis"], ["proof (prove)\nusing this:\n  cond_bind_spmf_fst p (map_spmf fst \\<circ> f) x =\n  cond_bind_spmf p f ({x} \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. cond_bind_spmf_fst p (map_spmf fst \\<circ> f) x =\n    cond_bind_spmf p f ({x} \\<times> UNIV)", "."], ["proof (state)\nthis:\n  cond_bind_spmf_fst p (map_spmf fst \\<circ> f) x =\n  cond_bind_spmf p f ({x} \\<times> UNIV)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cond_spmf_fst_bind: \"cond_spmf_fst (bind_spmf p f) x = \n  bind_spmf (cond_bind_spmf_fst p (map_spmf fst \\<circ> f) x) (\\<lambda>y. cond_spmf_fst (f y) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf_fst (p \\<bind> f) x =\n    cond_bind_spmf_fst p (map_spmf fst \\<circ> f) x \\<bind>\n    (\\<lambda>y. cond_spmf_fst (f y) x)", "by(simp add: cond_spmf_fst_def cond_bind_spmf map_bind_spmf cond_bind_spmf_fst_map_spmf_fst)(simp add: o_def)"], ["", "lemma spmf_cond_bind_spmf_fst [simp]:\n  \"spmf (cond_bind_spmf_fst p f x) i = spmf p i * spmf (f i) x / spmf (bind_spmf p f) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (cond_bind_spmf_fst p f x) i =\n    spmf p i * spmf (f i) x / spmf (p \\<bind> f) x", "by(simp add: cond_bind_spmf_fst_def)\n    (auto simp add: spmf_conv_measure_spmf measure_map_spmf map_bind_spmf[symmetric] intro!: arg_cong2[where f=\"(/)\"] arg_cong2[where f=\"(*)\"] arg_cong2[where f=\"measure\"])"], ["", "lemma set_cond_bind_spmf_fst [simp]:\n  \"set_spmf (cond_bind_spmf_fst p f x) = {y \\<in> set_spmf p. x \\<in> set_spmf (f y)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_spmf (cond_bind_spmf_fst p f x) =\n    {y \\<in> set_spmf p. x \\<in> set_spmf (f y)}", "by(auto simp add: cond_bind_spmf_fst_def intro: rev_image_eqI)"], ["", "lemma map_cond_spmf_fst: \"map_spmf f (cond_spmf_fst p x) = cond_spmf_fst (map_spmf (apsnd f) p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf f (cond_spmf_fst p x) = cond_spmf_fst (map_spmf (apsnd f) p) x", "by(auto simp add: cond_spmf_fst_def spmf.map_comp intro!: map_spmf_cong arg_cong2[where f=\"cond_spmf\"])"], ["", "lemma cond_spmf_fst_try1:\n  \"cond_spmf_fst (try_spmf p q) x = cond_spmf_fst p x\" if \"x \\<notin> fst ` set_spmf q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf_fst (TRY p ELSE q) x = cond_spmf_fst p x", "using that"], ["proof (prove)\nusing this:\n  x \\<notin> fst ` set_spmf q\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (TRY p ELSE q) x = cond_spmf_fst p x", "apply(simp add: cond_spmf_fst_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> fst ` set_spmf q \\<Longrightarrow>\n    map_spmf snd (cond_spmf (TRY p ELSE q) ({x} \\<times> UNIV)) =\n    map_spmf snd (cond_spmf p ({x} \\<times> UNIV))", "apply(subst cond_spmf_try1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<notin> fst ` set_spmf q \\<Longrightarrow>\n    set_spmf q \\<inter> {x} \\<times> UNIV = {}\n 2. x \\<notin> fst ` set_spmf q \\<Longrightarrow>\n    map_spmf snd (cond_spmf p ({x} \\<times> UNIV)) =\n    map_spmf snd (cond_spmf p ({x} \\<times> UNIV))", "apply(auto intro: rev_image_eqI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cond_spmf_fst_try2:\n  \"cond_spmf_fst (try_spmf p q) x = (if lossless_spmf p then return_pmf None else cond_spmf_fst q x)\" if \"x \\<notin> fst ` set_spmf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf_fst (TRY p ELSE q) x =\n    (if lossless_spmf p then return_pmf None else cond_spmf_fst q x)", "using that"], ["proof (prove)\nusing this:\n  x \\<notin> fst ` set_spmf p\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (TRY p ELSE q) x =\n    (if lossless_spmf p then return_pmf None else cond_spmf_fst q x)", "apply(simp add: cond_spmf_fst_def split!: if_split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> fst ` set_spmf p; lossless_spmf p\\<rbrakk>\n    \\<Longrightarrow> map_spmf snd (cond_spmf p ({x} \\<times> UNIV)) =\n                      return_pmf None\n 2. \\<lbrakk>x \\<notin> fst ` set_spmf p; \\<not> lossless_spmf p\\<rbrakk>\n    \\<Longrightarrow> map_spmf snd\n                       (cond_spmf (TRY p ELSE q) ({x} \\<times> UNIV)) =\n                      map_spmf snd (cond_spmf q ({x} \\<times> UNIV))", "apply (metis cond_spmf_fst_def cond_spmf_fst_eq_return_None)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> fst ` set_spmf p; \\<not> lossless_spmf p\\<rbrakk>\n    \\<Longrightarrow> map_spmf snd\n                       (cond_spmf (TRY p ELSE q) ({x} \\<times> UNIV)) =\n                      map_spmf snd (cond_spmf q ({x} \\<times> UNIV))", "by (metis cond_spmf_fst_def cond_spmf_try2 lossless_cond_spmf lossless_cond_spmf_fst lossless_map_spmf)"], ["", "lemma cond_spmf_fst_map_inj:\n  \"cond_spmf_fst (map_spmf (apfst f) p) (f x) = cond_spmf_fst p x\" if \"inj f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf_fst (map_spmf (apfst f) p) (f x) = cond_spmf_fst p x", "by(auto simp add: cond_spmf_fst_def spmf.map_comp intro!: map_spmf_cong arg_cong2[where f=cond_spmf] dest: injD[OF that])"], ["", "lemma cond_spmf_fst_pair_spmf1:\n  \"cond_spmf_fst (map_spmf (\\<lambda>(x, y). (f x, g x y)) (pair_spmf p q)) a =\n   bind_spmf (cond_spmf_fst (map_spmf (\\<lambda>x. (f x, x)) p) a) (\\<lambda>x. map_spmf (g x) (mk_lossless q))\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf_fst (map_spmf (\\<lambda>(x, y). (f x, g x y)) (pair_spmf p q))\n     a =\n    cond_spmf_fst (map_spmf (\\<lambda>x. (f x, x)) p) a \\<bind>\n    (\\<lambda>x. map_spmf (g x) (mk_lossless q))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cond_spmf_fst (map_spmf (\\<lambda>(x, y). (f x, g x y)) (pair_spmf p q))\n     a =\n    cond_spmf_fst (map_spmf (\\<lambda>x. (f x, x)) p) a \\<bind>\n    (\\<lambda>x. map_spmf (g x) (mk_lossless q))", "have \"(\\<lambda>(x, y). (f x, g x y)) -` ({a} \\<times> UNIV) = f -` {a} \\<times> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). (f x, g x y)) -` ({a} \\<times> UNIV) =\n    f -` {a} \\<times> UNIV", "by(auto)"], ["proof (state)\nthis:\n  (\\<lambda>(x, y). (f x, g x y)) -` ({a} \\<times> UNIV) =\n  f -` {a} \\<times> UNIV\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (map_spmf (\\<lambda>(x, y). (f x, g x y)) (pair_spmf p q))\n     a =\n    cond_spmf_fst (map_spmf (\\<lambda>x. (f x, x)) p) a \\<bind>\n    (\\<lambda>x. map_spmf (g x) (mk_lossless q))", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>(x, y). (f x, g x y)) -` ({a} \\<times> UNIV) =\n  f -` {a} \\<times> UNIV\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (map_spmf (\\<lambda>(x, y). (f x, g x y)) (pair_spmf p q))\n     a =\n    cond_spmf_fst (map_spmf (\\<lambda>x. (f x, x)) p) a \\<bind>\n    (\\<lambda>x. map_spmf (g x) (mk_lossless q))", "have \"(\\<lambda>x. (f x, x)) -` ({a} \\<times> UNIV) = f -` {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. (f x, x)) -` ({a} \\<times> UNIV) = f -` {a}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. (f x, x)) -` ({a} \\<times> UNIV) = f -` {a}\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (map_spmf (\\<lambda>(x, y). (f x, g x y)) (pair_spmf p q))\n     a =\n    cond_spmf_fst (map_spmf (\\<lambda>x. (f x, x)) p) a \\<bind>\n    (\\<lambda>x. map_spmf (g x) (mk_lossless q))", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>(x, y). (f x, g x y)) -` ({a} \\<times> UNIV) =\n  f -` {a} \\<times> UNIV\n  (\\<lambda>x. (f x, x)) -` ({a} \\<times> UNIV) = f -` {a}", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>(x, y). (f x, g x y)) -` ({a} \\<times> UNIV) =\n  f -` {a} \\<times> UNIV\n  (\\<lambda>x. (f x, x)) -` ({a} \\<times> UNIV) = f -` {a}\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (map_spmf (\\<lambda>(x, y). (f x, g x y)) (pair_spmf p q))\n     a =\n    cond_spmf_fst (map_spmf (\\<lambda>x. (f x, x)) p) a \\<bind>\n    (\\<lambda>x. map_spmf (g x) (mk_lossless q))", "by(simp add: cond_spmf_fst_def spmf.map_comp o_def split_beta cond_spmf_pair_spmf)\n      (simp add: pair_spmf_alt_def map_bind_spmf o_def map_spmf_conv_bind_spmf)"], ["proof (state)\nthis:\n  cond_spmf_fst (map_spmf (\\<lambda>(x, y). (f x, g x y)) (pair_spmf p q))\n   a =\n  cond_spmf_fst (map_spmf (\\<lambda>x. (f x, x)) p) a \\<bind>\n  (\\<lambda>x. map_spmf (g x) (mk_lossless q))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cond_spmf_fst_return_spmf':\n  \"cond_spmf_fst (return_spmf (x, y)) z = (if x = z then return_spmf y else return_pmf None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf_fst (return_spmf (x, y)) z =\n    (if x = z then return_spmf y else return_pmf None)", "by(simp add: cond_spmf_fst_def)"], ["", "section \\<open>Material for CryptHOL\\<close>"], ["", "lemma left_gpv_lift_spmf [simp]: \"left_gpv (lift_spmf p) = lift_spmf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_gpv (lift_spmf p) = lift_spmf p", "by(rule gpv.expand)(simp add: spmf.map_comp o_def)"], ["", "lemma right_gpv_lift_spmf [simp]: \"right_gpv (lift_spmf p) = lift_spmf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_gpv (lift_spmf p) = lift_spmf p", "by(rule gpv.expand)(simp add: spmf.map_comp o_def)"], ["", "lemma map'_lift_spmf: \"map_gpv' f g h (lift_spmf p) = lift_spmf (map_spmf f p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_gpv' f g h (lift_spmf p) = lift_spmf (map_spmf f p)", "by(rule gpv.expand)(simp add: gpv.map_sel spmf.map_comp o_def)"], ["", "lemma in_set_sample_uniform [simp]: \"x \\<in> set_spmf (sample_uniform n) \\<longleftrightarrow> x < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set_spmf (sample_uniform n)) = (x < n)", "by(simp add: sample_uniform_def)"], ["", "lemma (in cyclic_group) inj_on_generator_iff [simp]: \"\\<lbrakk> x < order G; y < order G \\<rbrakk> \\<Longrightarrow> \\<^bold>g [^] x = \\<^bold>g [^] y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < order G; y < order G\\<rbrakk>\n    \\<Longrightarrow> (\\<^bold>g [^] x = \\<^bold>g [^] y) = (x = y)", "using inj_on_generator"], ["proof (prove)\nusing this:\n  inj_on (([^]) \\<^bold>g) {..<order G}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < order G; y < order G\\<rbrakk>\n    \\<Longrightarrow> (\\<^bold>g [^] x = \\<^bold>g [^] y) = (x = y)", "by(auto simp add: inj_on_def)"], ["", "lemma map_\\<I>_bot [simp]: \"map_\\<I> f g \\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_\\<I> f g \\<bottom> = \\<bottom>", "unfolding bot_\\<I>_def map_\\<I>_\\<I>_uniform"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_uniform (f -` {}) (range g) = \\<I>_uniform {} UNIV", "by simp"], ["", "lemma map_\\<I>_Inr_plus [simp]: \"map_\\<I> Inr f (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) = map_\\<I> id (f \\<circ> Inr) \\<I>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_\\<I> Inr f (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) =\n    map_\\<I> id (f \\<circ> Inr) \\<I>2", "by(rule \\<I>_eqI) auto"], ["", "lemma interaction_bound_map_gpv'_le:\n  defines \"ib \\<equiv> interaction_bound\" \n  shows \"interaction_bound consider (map_gpv' f g h gpv) \\<le> ib (consider \\<circ> g) gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_bound consider (map_gpv' f g h gpv)\n    \\<le> ib (consider \\<circ> g) gpv", "proof(induction arbitrary: gpv rule: interaction_bound_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x. a (map_gpv' f g h x) \\<le> ib (consider \\<circ> g) x)\n 2. \\<And>gpv. 0 \\<le> ib (consider \\<circ> g) gpv\n 3. \\<And>interaction_bound' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   interaction_bound' (map_gpv' f g h gpv)\n                   \\<le> ib (consider \\<circ> g) gpv;\n        \\<And>gpv.\n           interaction_bound' gpv \\<le> interaction_bound consider gpv;\n        \\<And>gpv.\n           interaction_bound' gpv\n           \\<le> (\\<Squnion>generat\\<in>set_spmf (the_gpv gpv).\n                     case generat of Pure x \\<Rightarrow> 0\n                     | IO out c \\<Rightarrow>\n                         if consider out\n                         then eSuc\n                               (\\<Squnion>input.\n                                   interaction_bound' (c input))\n                         else \\<Squnion>input.\n                                 interaction_bound' (c input))\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> (case_generat (\\<lambda>x. 0)\n(\\<lambda>out c.\n    if consider out\n    then eSuc (\\<Squnion>input. interaction_bound' (c input))\n    else \\<Squnion>input. interaction_bound' (c input)) `\n                                     set_spmf\n(the_gpv (map_gpv' f g h gpv)))\n                         \\<le> ib (consider \\<circ> g) gpv", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x. a (map_gpv' f g h x) \\<le> ib (consider \\<circ> g) x)\n 2. \\<And>gpv. 0 \\<le> ib (consider \\<circ> g) gpv\n 3. \\<And>interaction_bound' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   interaction_bound' (map_gpv' f g h gpv)\n                   \\<le> ib (consider \\<circ> g) gpv;\n        \\<And>gpv.\n           interaction_bound' gpv \\<le> interaction_bound consider gpv;\n        \\<And>gpv.\n           interaction_bound' gpv\n           \\<le> (\\<Squnion>generat\\<in>set_spmf (the_gpv gpv).\n                     case generat of Pure x \\<Rightarrow> 0\n                     | IO out c \\<Rightarrow>\n                         if consider out\n                         then eSuc\n                               (\\<Squnion>input.\n                                   interaction_bound' (c input))\n                         else \\<Squnion>input.\n                                 interaction_bound' (c input))\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> (case_generat (\\<lambda>x. 0)\n(\\<lambda>out c.\n    if consider out\n    then eSuc (\\<Squnion>input. interaction_bound' (c input))\n    else \\<Squnion>input. interaction_bound' (c input)) `\n                                     set_spmf\n(the_gpv (map_gpv' f g h gpv)))\n                         \\<le> ib (consider \\<circ> g) gpv", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x. a (map_gpv' f g h x) \\<le> ib (consider \\<circ> g) x)", "by simp"], ["proof (state)\nthis:\n  lfp.admissible\n   (\\<lambda>a.\n       \\<forall>x. a (map_gpv' f g h x) \\<le> ib (consider \\<circ> g) x)\n\ngoal (2 subgoals):\n 1. \\<And>gpv. 0 \\<le> ib (consider \\<circ> g) gpv\n 2. \\<And>interaction_bound' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   interaction_bound' (map_gpv' f g h gpv)\n                   \\<le> ib (consider \\<circ> g) gpv;\n        \\<And>gpv.\n           interaction_bound' gpv \\<le> interaction_bound consider gpv;\n        \\<And>gpv.\n           interaction_bound' gpv\n           \\<le> (\\<Squnion>generat\\<in>set_spmf (the_gpv gpv).\n                     case generat of Pure x \\<Rightarrow> 0\n                     | IO out c \\<Rightarrow>\n                         if consider out\n                         then eSuc\n                               (\\<Squnion>input.\n                                   interaction_bound' (c input))\n                         else \\<Squnion>input.\n                                 interaction_bound' (c input))\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> (case_generat (\\<lambda>x. 0)\n(\\<lambda>out c.\n    if consider out\n    then eSuc (\\<Squnion>input. interaction_bound' (c input))\n    else \\<Squnion>input. interaction_bound' (c input)) `\n                                     set_spmf\n(the_gpv (map_gpv' f g h gpv)))\n                         \\<le> ib (consider \\<circ> g) gpv", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>gpv. 0 \\<le> ib (consider \\<circ> g) gpv\n 2. \\<And>interaction_bound' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   interaction_bound' (map_gpv' f g h gpv)\n                   \\<le> ib (consider \\<circ> g) gpv;\n        \\<And>gpv.\n           interaction_bound' gpv \\<le> interaction_bound consider gpv;\n        \\<And>gpv.\n           interaction_bound' gpv\n           \\<le> (\\<Squnion>generat\\<in>set_spmf (the_gpv gpv).\n                     case generat of Pure x \\<Rightarrow> 0\n                     | IO out c \\<Rightarrow>\n                         if consider out\n                         then eSuc\n                               (\\<Squnion>input.\n                                   interaction_bound' (c input))\n                         else \\<Squnion>input.\n                                 interaction_bound' (c input))\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> (case_generat (\\<lambda>x. 0)\n(\\<lambda>out c.\n    if consider out\n    then eSuc (\\<Squnion>input. interaction_bound' (c input))\n    else \\<Squnion>input. interaction_bound' (c input)) `\n                                     set_spmf\n(the_gpv (map_gpv' f g h gpv)))\n                         \\<le> ib (consider \\<circ> g) gpv", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> ib (consider \\<circ> g) gpv", "by simp"], ["proof (state)\nthis:\n  0 \\<le> ib (consider \\<circ> g) gpv\n\ngoal (1 subgoal):\n 1. \\<And>interaction_bound' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   interaction_bound' (map_gpv' f g h gpv)\n                   \\<le> ib (consider \\<circ> g) gpv;\n        \\<And>gpv.\n           interaction_bound' gpv \\<le> interaction_bound consider gpv;\n        \\<And>gpv.\n           interaction_bound' gpv\n           \\<le> (\\<Squnion>generat\\<in>set_spmf (the_gpv gpv).\n                     case generat of Pure x \\<Rightarrow> 0\n                     | IO out c \\<Rightarrow>\n                         if consider out\n                         then eSuc\n                               (\\<Squnion>input.\n                                   interaction_bound' (c input))\n                         else \\<Squnion>input.\n                                 interaction_bound' (c input))\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> (case_generat (\\<lambda>x. 0)\n(\\<lambda>out c.\n    if consider out\n    then eSuc (\\<Squnion>input. interaction_bound' (c input))\n    else \\<Squnion>input. interaction_bound' (c input)) `\n                                     set_spmf\n(the_gpv (map_gpv' f g h gpv)))\n                         \\<le> ib (consider \\<circ> g) gpv", "case (step interaction_bound')"], ["proof (state)\nthis:\n  interaction_bound' (map_gpv' f g h ?gpv)\n  \\<le> ib (consider \\<circ> g) ?gpv\n  interaction_bound' ?gpv \\<le> interaction_bound consider ?gpv\n  interaction_bound' ?gpv\n  \\<le> (\\<Squnion>generat\\<in>set_spmf (the_gpv ?gpv).\n            case generat of Pure x \\<Rightarrow> 0\n            | IO out c \\<Rightarrow>\n                if consider out\n                then eSuc (\\<Squnion>input. interaction_bound' (c input))\n                else \\<Squnion>input. interaction_bound' (c input))\n\ngoal (1 subgoal):\n 1. \\<And>interaction_bound' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   interaction_bound' (map_gpv' f g h gpv)\n                   \\<le> ib (consider \\<circ> g) gpv;\n        \\<And>gpv.\n           interaction_bound' gpv \\<le> interaction_bound consider gpv;\n        \\<And>gpv.\n           interaction_bound' gpv\n           \\<le> (\\<Squnion>generat\\<in>set_spmf (the_gpv gpv).\n                     case generat of Pure x \\<Rightarrow> 0\n                     | IO out c \\<Rightarrow>\n                         if consider out\n                         then eSuc\n                               (\\<Squnion>input.\n                                   interaction_bound' (c input))\n                         else \\<Squnion>input.\n                                 interaction_bound' (c input))\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> (case_generat (\\<lambda>x. 0)\n(\\<lambda>out c.\n    if consider out\n    then eSuc (\\<Squnion>input. interaction_bound' (c input))\n    else \\<Squnion>input. interaction_bound' (c input)) `\n                                     set_spmf\n(the_gpv (map_gpv' f g h gpv)))\n                         \\<le> ib (consider \\<circ> g) gpv", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>generat\\<in>set_spmf (the_gpv (map_gpv' f g h gpv)).\n        case generat of Pure x \\<Rightarrow> 0\n        | IO out c \\<Rightarrow>\n            if consider out\n            then eSuc (\\<Squnion>input. interaction_bound' (c input))\n            else \\<Squnion>input. interaction_bound' (c input))\n    \\<le> ib (consider \\<circ> g) gpv", "unfolding ib_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>generat\\<in>set_spmf (the_gpv (map_gpv' f g h gpv)).\n        case generat of Pure x \\<Rightarrow> 0\n        | IO out c \\<Rightarrow>\n            if consider out\n            then eSuc (\\<Squnion>input. interaction_bound' (c input))\n            else \\<Squnion>input. interaction_bound' (c input))\n    \\<le> interaction_bound (consider \\<circ> g) gpv", "by(subst interaction_bound.simps)\n      (auto simp add: image_comp ib_def split: generat.split intro!: SUP_mono rev_bexI step.IH[unfolded ib_def])"], ["proof (state)\nthis:\n  (\\<Squnion>generat\\<in>set_spmf (the_gpv (map_gpv' f g h gpv)).\n      case generat of Pure x \\<Rightarrow> 0\n      | IO out c \\<Rightarrow>\n          if consider out\n          then eSuc (\\<Squnion>input. interaction_bound' (c input))\n          else \\<Squnion>input. interaction_bound' (c input))\n  \\<le> ib (consider \\<circ> g) gpv\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma interaction_bounded_by_map_gpv' [interaction_bound]:\n  assumes \"interaction_bounded_by (consider \\<circ> g) gpv n\"\n  shows \"interaction_bounded_by consider (map_gpv' f g h gpv) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_bounded_by consider (map_gpv' f g h gpv) n", "using assms interaction_bound_map_gpv'_le[of \"consider\" f g h gpv]"], ["proof (prove)\nusing this:\n  interaction_bounded_by (consider \\<circ> g) gpv n\n  interaction_bound consider (map_gpv' f g h gpv)\n  \\<le> interaction_bound (consider \\<circ> g) gpv\n\ngoal (1 subgoal):\n 1. interaction_bounded_by consider (map_gpv' f g h gpv) n", "by(simp add: interaction_bounded_by.simps)"], ["", "lemma map_gpv'_bind_gpv:\n  \"map_gpv' f g h (bind_gpv gpv F) = bind_gpv (map_gpv' id g h gpv) (\\<lambda>x. map_gpv' f g h (F x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_gpv' f g h (gpv \\<bind> F) =\n    map_gpv' id g h gpv \\<bind> (\\<lambda>x. map_gpv' f g h (F x))", "by(coinduction arbitrary: gpv rule: gpv.coinduct_strong)\n    (auto simp del: bind_gpv_sel' simp add: bind_gpv.sel spmf_rel_map bind_map_spmf generat.rel_map rel_fun_def intro!: rel_spmf_bind_reflI rel_spmf_reflI generat.rel_refl_strong split!: generat.split)"], ["", "lemma exec_gpv_map_gpv':\n  \"exec_gpv callee (map_gpv' f g h gpv) s =\n   map_spmf (map_prod f id) (exec_gpv (map_fun id (map_fun g (map_spmf (map_prod h id))) callee) gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_gpv callee (map_gpv' f g h gpv) s =\n    map_spmf (map_prod f id)\n     (exec_gpv (map_fun id (map_fun g (map_spmf (map_prod h id))) callee)\n       gpv s)", "using exec_gpv_parametric'[\n    where S=\"(=)\" and CALL=\"BNF_Def.Grp UNIV g\" and R=\"conversep (BNF_Def.Grp UNIV h)\" and A=\"BNF_Def.Grp UNIV f\",\n     unfolded rel_gpv''_Grp, simplified]"], ["proof (prove)\nusing this:\n  rel_fun\n   (rel_fun (=)\n     (rel_fun (BNF_Def.Grp UNIV g)\n       (rel_spmf (rel_prod (BNF_Def.Grp UNIV h)\\<inverse>\\<inverse> (=)))))\n   (rel_fun (BNF_Def.Grp UNIV (map_gpv' f g h))\n     (rel_fun (=) (rel_spmf (rel_prod (BNF_Def.Grp UNIV f) (=)))))\n   exec_gpv exec_gpv\n\ngoal (1 subgoal):\n 1. exec_gpv callee (map_gpv' f g h gpv) s =\n    map_spmf (map_prod f id)\n     (exec_gpv (map_fun id (map_fun g (map_spmf (map_prod h id))) callee)\n       gpv s)", "apply(subst (asm) (2) conversep_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_fun (=)\n       (rel_fun (BNF_Def.Grp UNIV g)\n         (rel_spmf\n           (rel_prod (BNF_Def.Grp UNIV h)\\<inverse>\\<inverse>\n             (=)\\<inverse>\\<inverse>))))\n     (rel_fun (BNF_Def.Grp UNIV (map_gpv' f g h))\n       (rel_fun (=) (rel_spmf (rel_prod (BNF_Def.Grp UNIV f) (=)))))\n     exec_gpv exec_gpv \\<Longrightarrow>\n    exec_gpv callee (map_gpv' f g h gpv) s =\n    map_spmf (map_prod f id)\n     (exec_gpv (map_fun id (map_fun g (map_spmf (map_prod h id))) callee)\n       gpv s)", "apply(subst (asm) prod.rel_conversep)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_fun (=)\n       (rel_fun (BNF_Def.Grp UNIV g)\n         (rel_spmf\n           (rel_prod (BNF_Def.Grp UNIV h) (=))\\<inverse>\\<inverse>)))\n     (rel_fun (BNF_Def.Grp UNIV (map_gpv' f g h))\n       (rel_fun (=) (rel_spmf (rel_prod (BNF_Def.Grp UNIV f) (=)))))\n     exec_gpv exec_gpv \\<Longrightarrow>\n    exec_gpv callee (map_gpv' f g h gpv) s =\n    map_spmf (map_prod f id)\n     (exec_gpv (map_fun id (map_fun g (map_spmf (map_prod h id))) callee)\n       gpv s)", "apply(subst (asm) (2 4) eq_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_fun (=)\n       (rel_fun (BNF_Def.Grp UNIV g)\n         (rel_spmf\n           (rel_prod (BNF_Def.Grp UNIV h)\n             (BNF_Def.Grp UNIV id))\\<inverse>\\<inverse>)))\n     (rel_fun (BNF_Def.Grp UNIV (map_gpv' f g h))\n       (rel_fun (=)\n         (rel_spmf (rel_prod (BNF_Def.Grp UNIV f) (BNF_Def.Grp UNIV id)))))\n     exec_gpv exec_gpv \\<Longrightarrow>\n    exec_gpv callee (map_gpv' f g h gpv) s =\n    map_spmf (map_prod f id)\n     (exec_gpv (map_fun id (map_fun g (map_spmf (map_prod h id))) callee)\n       gpv s)", "apply(subst (asm) prod.rel_Grp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_fun (=)\n       (rel_fun (BNF_Def.Grp UNIV g)\n         (rel_spmf\n           (BNF_Def.Grp\n             {x. Basic_BNFs.fsts x \\<subseteq> UNIV \\<and>\n                 Basic_BNFs.snds x \\<subseteq> UNIV}\n             (map_prod h id))\\<inverse>\\<inverse>)))\n     (rel_fun (BNF_Def.Grp UNIV (map_gpv' f g h))\n       (rel_fun (=)\n         (rel_spmf (rel_prod (BNF_Def.Grp UNIV f) (BNF_Def.Grp UNIV id)))))\n     exec_gpv exec_gpv \\<Longrightarrow>\n    exec_gpv callee (map_gpv' f g h gpv) s =\n    map_spmf (map_prod f id)\n     (exec_gpv (map_fun id (map_fun g (map_spmf (map_prod h id))) callee)\n       gpv s)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_fun (=)\n       (rel_fun (BNF_Def.Grp UNIV g)\n         (rel_spmf (BNF_Def.Grp UNIV (map_prod h id))\\<inverse>\\<inverse>)))\n     (rel_fun (BNF_Def.Grp UNIV (map_gpv' f g h))\n       (rel_fun (=)\n         (rel_spmf (rel_prod (BNF_Def.Grp UNIV f) (BNF_Def.Grp UNIV id)))))\n     exec_gpv exec_gpv \\<Longrightarrow>\n    exec_gpv callee (map_gpv' f g h gpv) s =\n    map_spmf (map_prod f id)\n     (exec_gpv (map_fun id (map_fun g (map_spmf (map_prod h id))) callee)\n       gpv s)", "apply(subst (asm) spmf_rel_conversep)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_fun (=)\n       (rel_fun (BNF_Def.Grp UNIV g)\n         (rel_spmf (BNF_Def.Grp UNIV (map_prod h id)))\\<inverse>\\<inverse>))\n     (rel_fun (BNF_Def.Grp UNIV (map_gpv' f g h))\n       (rel_fun (=)\n         (rel_spmf (rel_prod (BNF_Def.Grp UNIV f) (BNF_Def.Grp UNIV id)))))\n     exec_gpv exec_gpv \\<Longrightarrow>\n    exec_gpv callee (map_gpv' f g h gpv) s =\n    map_spmf (map_prod f id)\n     (exec_gpv (map_fun id (map_fun g (map_spmf (map_prod h id))) callee)\n       gpv s)", "apply(subst (asm) option.rel_Grp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_fun (=)\n       (rel_fun (BNF_Def.Grp UNIV g)\n         (rel_pmf\n           (BNF_Def.Grp {x. set_option x \\<subseteq> UNIV}\n             (map_option (map_prod h id))))\\<inverse>\\<inverse>))\n     (rel_fun (BNF_Def.Grp UNIV (map_gpv' f g h))\n       (rel_fun (=)\n         (rel_spmf (rel_prod (BNF_Def.Grp UNIV f) (BNF_Def.Grp UNIV id)))))\n     exec_gpv exec_gpv \\<Longrightarrow>\n    exec_gpv callee (map_gpv' f g h gpv) s =\n    map_spmf (map_prod f id)\n     (exec_gpv (map_fun id (map_fun g (map_spmf (map_prod h id))) callee)\n       gpv s)", "apply(subst (asm) pmf.rel_Grp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_fun (=)\n       (rel_fun (BNF_Def.Grp UNIV g)\n         (BNF_Def.Grp\n           {x. set_pmf x \\<subseteq> {x. set_option x \\<subseteq> UNIV}}\n           (map_spmf (map_prod h id)))\\<inverse>\\<inverse>))\n     (rel_fun (BNF_Def.Grp UNIV (map_gpv' f g h))\n       (rel_fun (=)\n         (rel_spmf (rel_prod (BNF_Def.Grp UNIV f) (BNF_Def.Grp UNIV id)))))\n     exec_gpv exec_gpv \\<Longrightarrow>\n    exec_gpv callee (map_gpv' f g h gpv) s =\n    map_spmf (map_prod f id)\n     (exec_gpv (map_fun id (map_fun g (map_spmf (map_prod h id))) callee)\n       gpv s)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_fun (=)\n       (rel_fun (BNF_Def.Grp UNIV g)\n         (BNF_Def.Grp UNIV (map_spmf (map_prod h id)))\\<inverse>\\<inverse>))\n     (rel_fun (BNF_Def.Grp UNIV (map_gpv' f g h))\n       (rel_fun (=)\n         (rel_spmf (rel_prod (BNF_Def.Grp UNIV f) (BNF_Def.Grp UNIV id)))))\n     exec_gpv exec_gpv \\<Longrightarrow>\n    exec_gpv callee (map_gpv' f g h gpv) s =\n    map_spmf (map_prod f id)\n     (exec_gpv (map_fun id (map_fun g (map_spmf (map_prod h id))) callee)\n       gpv s)", "apply(subst (asm) prod.rel_Grp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_fun (=)\n       (rel_fun (BNF_Def.Grp UNIV g)\n         (BNF_Def.Grp UNIV (map_spmf (map_prod h id)))\\<inverse>\\<inverse>))\n     (rel_fun (BNF_Def.Grp UNIV (map_gpv' f g h))\n       (rel_fun (=)\n         (rel_spmf\n           (BNF_Def.Grp\n             {x. Basic_BNFs.fsts x \\<subseteq> UNIV \\<and>\n                 Basic_BNFs.snds x \\<subseteq> UNIV}\n             (map_prod f id)))))\n     exec_gpv exec_gpv \\<Longrightarrow>\n    exec_gpv callee (map_gpv' f g h gpv) s =\n    map_spmf (map_prod f id)\n     (exec_gpv (map_fun id (map_fun g (map_spmf (map_prod h id))) callee)\n       gpv s)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_fun (=)\n       (rel_fun (BNF_Def.Grp UNIV g)\n         (BNF_Def.Grp UNIV (map_spmf (map_prod h id)))\\<inverse>\\<inverse>))\n     (rel_fun (BNF_Def.Grp UNIV (map_gpv' f g h))\n       (rel_fun (=) (rel_spmf (BNF_Def.Grp UNIV (map_prod f id)))))\n     exec_gpv exec_gpv \\<Longrightarrow>\n    exec_gpv callee (map_gpv' f g h gpv) s =\n    map_spmf (map_prod f id)\n     (exec_gpv (map_fun id (map_fun g (map_spmf (map_prod h id))) callee)\n       gpv s)", "apply(subst (asm) (1 3) conversep_conversep[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_fun (=)\\<inverse>\\<inverse>\\<inverse>\\<inverse>\n       (rel_fun (BNF_Def.Grp UNIV g)\\<inverse>\\<inverse>\\<inverse>\\<inverse>\n         (BNF_Def.Grp UNIV (map_spmf (map_prod h id)))\\<inverse>\\<inverse>))\n     (rel_fun (BNF_Def.Grp UNIV (map_gpv' f g h))\n       (rel_fun (=) (rel_spmf (BNF_Def.Grp UNIV (map_prod f id)))))\n     exec_gpv exec_gpv \\<Longrightarrow>\n    exec_gpv callee (map_gpv' f g h gpv) s =\n    map_spmf (map_prod f id)\n     (exec_gpv (map_fun id (map_fun g (map_spmf (map_prod h id))) callee)\n       gpv s)", "apply(subst (asm) rel_fun_conversep)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_fun (=)\\<inverse>\\<inverse>\\<inverse>\\<inverse>\n       (rel_fun (BNF_Def.Grp UNIV g)\\<inverse>\\<inverse>\n         (BNF_Def.Grp UNIV (map_spmf (map_prod h id))))\\<inverse>\\<inverse>)\n     (rel_fun (BNF_Def.Grp UNIV (map_gpv' f g h))\n       (rel_fun (=) (rel_spmf (BNF_Def.Grp UNIV (map_prod f id)))))\n     exec_gpv exec_gpv \\<Longrightarrow>\n    exec_gpv callee (map_gpv' f g h gpv) s =\n    map_spmf (map_prod f id)\n     (exec_gpv (map_fun id (map_fun g (map_spmf (map_prod h id))) callee)\n       gpv s)", "apply(subst (asm) rel_fun_Grp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_fun (=)\\<inverse>\\<inverse>\\<inverse>\\<inverse>\n       (BNF_Def.Grp {f. f ` range g \\<subseteq> UNIV}\n         (map_fun g (map_spmf (map_prod h id))))\\<inverse>\\<inverse>)\n     (rel_fun (BNF_Def.Grp UNIV (map_gpv' f g h))\n       (rel_fun (=) (rel_spmf (BNF_Def.Grp UNIV (map_prod f id)))))\n     exec_gpv exec_gpv \\<Longrightarrow>\n    exec_gpv callee (map_gpv' f g h gpv) s =\n    map_spmf (map_prod f id)\n     (exec_gpv (map_fun id (map_fun g (map_spmf (map_prod h id))) callee)\n       gpv s)", "apply(subst (asm) rel_fun_conversep)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_fun (=)\\<inverse>\\<inverse>\n       (BNF_Def.Grp {f. f ` range g \\<subseteq> UNIV}\n         (map_fun g (map_spmf (map_prod h id)))))\\<inverse>\\<inverse>\n     (rel_fun (BNF_Def.Grp UNIV (map_gpv' f g h))\n       (rel_fun (=) (rel_spmf (BNF_Def.Grp UNIV (map_prod f id)))))\n     exec_gpv exec_gpv \\<Longrightarrow>\n    exec_gpv callee (map_gpv' f g h gpv) s =\n    map_spmf (map_prod f id)\n     (exec_gpv (map_fun id (map_fun g (map_spmf (map_prod h id))) callee)\n       gpv s)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_fun (=)\n       (BNF_Def.Grp UNIV\n         (map_fun g (map_spmf (map_prod h id)))))\\<inverse>\\<inverse>\n     (rel_fun (BNF_Def.Grp UNIV (map_gpv' f g h))\n       (rel_fun (=) (rel_spmf (BNF_Def.Grp UNIV (map_prod f id)))))\n     exec_gpv exec_gpv \\<Longrightarrow>\n    exec_gpv callee (map_gpv' f g h gpv) s =\n    map_spmf (map_prod f id)\n     (exec_gpv (map_fun id (map_fun g (map_spmf (map_prod h id))) callee)\n       gpv s)", "apply(simp add: option.rel_Grp pmf.rel_Grp fun.rel_Grp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (BNF_Def.Grp UNIV\n       ((\\<circ>)\n         (map_fun g (map_spmf (map_prod h id)))))\\<inverse>\\<inverse>\n     (rel_fun (BNF_Def.Grp UNIV (map_gpv' f g h))\n       (BNF_Def.Grp UNIV ((\\<circ>) (map_spmf (map_prod f id)))))\n     exec_gpv exec_gpv \\<Longrightarrow>\n    exec_gpv callee (map_gpv' f g h gpv) s =\n    map_spmf (map_prod f id)\n     (exec_gpv (map_fun id (map_fun g (map_spmf (map_prod h id))) callee)\n       gpv s)", "apply(simp add: rel_fun_def BNF_Def.Grp_def o_def map_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y x.\n       exec_gpv y (map_gpv' f g h x) =\n       (\\<lambda>xa.\n           map_spmf (map_prod f id)\n            (exec_gpv (\\<lambda>x xa. map_spmf (map_prod h id) (y x (g xa)))\n              x xa)) \\<Longrightarrow>\n    exec_gpv callee (map_gpv' f g h gpv) s =\n    map_spmf (map_prod f id)\n     (exec_gpv (\\<lambda>x xa. map_spmf (map_prod h id) (callee x (g xa)))\n       gpv s)", "apply(erule allE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_gpv ?y33 (map_gpv' f g h ?x35) =\n    (\\<lambda>x.\n        map_spmf (map_prod f id)\n         (exec_gpv (\\<lambda>x xa. map_spmf (map_prod h id) (?y33 x (g xa)))\n           ?x35 x)) \\<Longrightarrow>\n    exec_gpv callee (map_gpv' f g h gpv) s =\n    map_spmf (map_prod f id)\n     (exec_gpv (\\<lambda>x xa. map_spmf (map_prod h id) (callee x (g xa)))\n       gpv s)", "apply(drule fun_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_gpv ?y33 (map_gpv' f g h ?x35) ?x37 =\n    map_spmf (map_prod f id)\n     (exec_gpv (\\<lambda>x xa. map_spmf (map_prod h id) (?y33 x (g xa)))\n       ?x35 ?x37) \\<Longrightarrow>\n    exec_gpv callee (map_gpv' f g h gpv) s =\n    map_spmf (map_prod f id)\n     (exec_gpv (\\<lambda>x xa. map_spmf (map_prod h id) (callee x (g xa)))\n       gpv s)", "apply(erule trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (map_prod f id)\n     (exec_gpv (\\<lambda>x xa. map_spmf (map_prod h id) (callee x (g xa)))\n       gpv s) =\n    map_spmf (map_prod f id)\n     (exec_gpv (\\<lambda>x xa. map_spmf (map_prod h id) (callee x (g xa)))\n       gpv s)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma colossless_gpv_sub_gpvs:\n  assumes \"colossless_gpv \\<I> gpv\" \"gpv' \\<in> sub_gpvs \\<I> gpv\"\n  shows \"colossless_gpv \\<I> gpv'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. colossless_gpv \\<I> gpv'", "using assms(2,1)"], ["proof (prove)\nusing this:\n  gpv' \\<in> sub_gpvs \\<I> gpv\n  colossless_gpv \\<I> gpv\n\ngoal (1 subgoal):\n 1. colossless_gpv \\<I> gpv'", "by(induction)(auto dest: colossless_gpvD)"], ["", "lemma pfinite_gpv_sub_gpvs:\n  assumes \"pfinite_gpv \\<I> gpv\" \"gpv' \\<in> sub_gpvs \\<I> gpv\" \"\\<I> \\<turnstile>g gpv \\<surd>\"\n  shows \"pfinite_gpv \\<I> gpv'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_gpv \\<I> gpv'", "using assms(2,1,3)"], ["proof (prove)\nusing this:\n  gpv' \\<in> sub_gpvs \\<I> gpv\n  pfinite_gpv \\<I> gpv\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. pfinite_gpv \\<I> gpv'", "by(induction)(auto dest: pfinite_gpv_ContD WT_gpvD)"], ["", "lemma pfinite_gpv_id_oracle [simp]: \"pfinite_gpv \\<I> (id_oracle s x)\" if \"x \\<in> outs_\\<I> \\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_gpv \\<I> (1\\<^sub>I s x)", "by(simp add: id_oracle_def pgen_lossless_gpv_PauseI[OF that])"], ["", "subsection \\<open>@{term try_gpv}\\<close>"], ["", "lemma plossless_gpv_try_gpvI:\n  assumes \"pfinite_gpv \\<I> gpv\"\n    and \"\\<not> colossless_gpv \\<I> gpv \\<Longrightarrow> plossless_gpv \\<I> gpv'\"\n  shows \"plossless_gpv \\<I> (TRY gpv ELSE gpv')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_gpv \\<I> (TRY gpv ELSE gpv')", "using assms"], ["proof (prove)\nusing this:\n  pfinite_gpv \\<I> gpv\n  \\<not> colossless_gpv \\<I> gpv \\<Longrightarrow> plossless_gpv \\<I> gpv'\n\ngoal (1 subgoal):\n 1. plossless_gpv \\<I> (TRY gpv ELSE gpv')", "unfolding pgen_lossless_gpv_def"], ["proof (prove)\nusing this:\n  expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv = 1\n  \\<not> colossless_gpv \\<I> gpv \\<Longrightarrow>\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv' = 1\n\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I> (\\<lambda>_. 1) (TRY gpv ELSE gpv') = 1", "by(cases \"colossless_gpv \\<I> gpv\")(simp cong: expectation_gpv_cong_fail, simp)"], ["", "lemma WT_gpv_try_gpvI [WT_intro]:\n  assumes \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and \"\\<not> colossless_gpv \\<I> gpv \\<Longrightarrow> \\<I> \\<turnstile>g gpv' \\<surd>\"\n  shows \"\\<I> \\<turnstile>g try_gpv gpv gpv' \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>g TRY gpv ELSE gpv' \\<surd>", "using assms"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  \\<not> colossless_gpv \\<I> gpv \\<Longrightarrow>\n  \\<I> \\<turnstile>g gpv' \\<surd>\n\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>g TRY gpv ELSE gpv' \\<surd>", "by(coinduction arbitrary: gpv)(auto 4 4 dest: WT_gpvD colossless_gpvD split: if_split_asm)"], ["", "lemma (in callee_invariant_on) exec_gpv_try_gpv:\n  fixes exec_gpv1\n  defines \"exec_gpv1 \\<equiv> exec_gpv\"\n  assumes WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and pfinite: \"pfinite_gpv \\<I> gpv\"\n    and I: \"I s\"\n    and f: \"\\<And>s. I s \\<Longrightarrow> f (x, s) = z\"\n    and lossless: \"\\<And>s x. \\<lbrakk>x \\<in> outs_\\<I> \\<I>; I s\\<rbrakk> \\<Longrightarrow> lossless_spmf (callee s x)\"\n  shows \"map_spmf f (exec_gpv callee (try_gpv gpv (Done x)) s) =\n    try_spmf (map_spmf f (exec_gpv1 callee gpv s)) (return_spmf z)\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf f (exec_gpv callee (TRY gpv ELSE Done x) s) =\n    TRY map_spmf f (exec_gpv1 callee gpv s) ELSE return_spmf z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_spmf f (exec_gpv callee (TRY gpv ELSE Done x) s) =\n    TRY map_spmf f (exec_gpv1 callee gpv s) ELSE return_spmf z", "note [[show_variants]]"], ["proof (state)\nthis:\n  TERM _\n\ngoal (1 subgoal):\n 1. map_spmf f (exec_gpv callee (TRY gpv ELSE Done x) s) =\n    TRY map_spmf f (exec_gpv1 callee gpv s) ELSE return_spmf z", "have le: \"ord_spmf (=) ?lhs ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=) (map_spmf f (exec_gpv callee (TRY gpv ELSE Done x) s))\n     (TRY map_spmf f (exec_gpv1 callee gpv s) ELSE return_spmf z)", "using WT I"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. ord_spmf (=) (map_spmf f (exec_gpv callee (TRY gpv ELSE Done x) s))\n     (TRY map_spmf f (exec_gpv1 callee gpv s) ELSE return_spmf z)", "proof(induction arbitrary: gpv s rule: exec_gpv_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>fa.\n         \\<forall>xa.\n            \\<I> \\<turnstile>g xa \\<surd> \\<longrightarrow>\n            (\\<forall>xb.\n                I xb \\<longrightarrow>\n                ord_spmf (=) (map_spmf f (fa (TRY xa ELSE Done x, xb)))\n                 (TRY map_spmf f\n                       (exec_gpv1 callee xa xb) ELSE return_spmf z)))\n 2. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=) (map_spmf f (return_pmf None))\n                          (TRY map_spmf f\n                                (exec_gpv1 callee gpv s) ELSE return_spmf z)\n 3. \\<And>exec_gpv gpv s.\n       \\<lbrakk>\\<And>gpv s.\n                   \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n                   \\<Longrightarrow> ord_spmf (=)\n(map_spmf f (exec_gpv (TRY gpv ELSE Done x) s))\n(TRY map_spmf f (exec_gpv1 callee gpv s) ELSE return_spmf z);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf f\n                            (bind_spmf (the_gpv (TRY gpv ELSE Done x))\n                              (case_generat (\\<lambda>x. return_spmf (x, s))\n                                (\\<lambda>out c.\n                                    bind_spmf (callee s out)\n                                     (\\<lambda>(x, y). exec_gpv (c x) y)))))\n                          (TRY map_spmf f\n                                (exec_gpv1 callee gpv s) ELSE return_spmf z)", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>fa.\n         \\<forall>xa.\n            \\<I> \\<turnstile>g xa \\<surd> \\<longrightarrow>\n            (\\<forall>xb.\n                I xb \\<longrightarrow>\n                ord_spmf (=) (map_spmf f (fa (TRY xa ELSE Done x, xb)))\n                 (TRY map_spmf f\n                       (exec_gpv1 callee xa xb) ELSE return_spmf z)))\n 2. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=) (map_spmf f (return_pmf None))\n                          (TRY map_spmf f\n                                (exec_gpv1 callee gpv s) ELSE return_spmf z)\n 3. \\<And>exec_gpv gpv s.\n       \\<lbrakk>\\<And>gpv s.\n                   \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n                   \\<Longrightarrow> ord_spmf (=)\n(map_spmf f (exec_gpv (TRY gpv ELSE Done x) s))\n(TRY map_spmf f (exec_gpv1 callee gpv s) ELSE return_spmf z);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf f\n                            (bind_spmf (the_gpv (TRY gpv ELSE Done x))\n                              (case_generat (\\<lambda>x. return_spmf (x, s))\n                                (\\<lambda>out c.\n                                    bind_spmf (callee s out)\n                                     (\\<lambda>(x, y). exec_gpv (c x) y)))))\n                          (TRY map_spmf f\n                                (exec_gpv1 callee gpv s) ELSE return_spmf z)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf.admissible\n     (\\<lambda>fa.\n         \\<forall>xa.\n            \\<I> \\<turnstile>g xa \\<surd> \\<longrightarrow>\n            (\\<forall>xb.\n                I xb \\<longrightarrow>\n                ord_spmf (=) (map_spmf f (fa (TRY xa ELSE Done x, xb)))\n                 (TRY map_spmf f\n                       (exec_gpv1 callee xa xb) ELSE return_spmf z)))", "by simp"], ["proof (state)\nthis:\n  spmf.admissible\n   (\\<lambda>fa.\n       \\<forall>xa.\n          \\<I> \\<turnstile>g xa \\<surd> \\<longrightarrow>\n          (\\<forall>xb.\n              I xb \\<longrightarrow>\n              ord_spmf (=) (map_spmf f (fa (TRY xa ELSE Done x, xb)))\n               (TRY map_spmf f\n                     (exec_gpv1 callee xa xb) ELSE return_spmf z)))\n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=) (map_spmf f (return_pmf None))\n                          (TRY map_spmf f\n                                (exec_gpv1 callee gpv s) ELSE return_spmf z)\n 2. \\<And>exec_gpv gpv s.\n       \\<lbrakk>\\<And>gpv s.\n                   \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n                   \\<Longrightarrow> ord_spmf (=)\n(map_spmf f (exec_gpv (TRY gpv ELSE Done x) s))\n(TRY map_spmf f (exec_gpv1 callee gpv s) ELSE return_spmf z);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf f\n                            (bind_spmf (the_gpv (TRY gpv ELSE Done x))\n                              (case_generat (\\<lambda>x. return_spmf (x, s))\n                                (\\<lambda>out c.\n                                    bind_spmf (callee s out)\n                                     (\\<lambda>(x, y). exec_gpv (c x) y)))))\n                          (TRY map_spmf f\n                                (exec_gpv1 callee gpv s) ELSE return_spmf z)", "case bottom"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=) (map_spmf f (return_pmf None))\n                          (TRY map_spmf f\n                                (exec_gpv1 callee gpv s) ELSE return_spmf z)\n 2. \\<And>exec_gpv gpv s.\n       \\<lbrakk>\\<And>gpv s.\n                   \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n                   \\<Longrightarrow> ord_spmf (=)\n(map_spmf f (exec_gpv (TRY gpv ELSE Done x) s))\n(TRY map_spmf f (exec_gpv1 callee gpv s) ELSE return_spmf z);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf f\n                            (bind_spmf (the_gpv (TRY gpv ELSE Done x))\n                              (case_generat (\\<lambda>x. return_spmf (x, s))\n                                (\\<lambda>out c.\n                                    bind_spmf (callee s out)\n                                     (\\<lambda>(x, y). exec_gpv (c x) y)))))\n                          (TRY map_spmf f\n                                (exec_gpv1 callee gpv s) ELSE return_spmf z)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=) (map_spmf f (return_pmf None))\n     (TRY map_spmf f (exec_gpv1 callee gpv s) ELSE return_spmf z)", "by simp"], ["proof (state)\nthis:\n  ord_spmf (=) (map_spmf f (return_pmf None))\n   (TRY map_spmf f (exec_gpv1 callee gpv s) ELSE return_spmf z)\n\ngoal (1 subgoal):\n 1. \\<And>exec_gpv gpv s.\n       \\<lbrakk>\\<And>gpv s.\n                   \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n                   \\<Longrightarrow> ord_spmf (=)\n(map_spmf f (exec_gpv (TRY gpv ELSE Done x) s))\n(TRY map_spmf f (exec_gpv1 callee gpv s) ELSE return_spmf z);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf f\n                            (bind_spmf (the_gpv (TRY gpv ELSE Done x))\n                              (case_generat (\\<lambda>x. return_spmf (x, s))\n                                (\\<lambda>out c.\n                                    bind_spmf (callee s out)\n                                     (\\<lambda>(x, y). exec_gpv (c x) y)))))\n                          (TRY map_spmf f\n                                (exec_gpv1 callee gpv s) ELSE return_spmf z)", "case (step exec_gpv')"], ["proof (state)\nthis:\n  \\<lbrakk>\\<I> \\<turnstile>g ?gpv \\<surd>; I ?s\\<rbrakk>\n  \\<Longrightarrow> ord_spmf (=)\n                     (map_spmf f (exec_gpv' (TRY ?gpv ELSE Done x) ?s))\n                     (TRY map_spmf f\n                           (exec_gpv1 callee ?gpv ?s) ELSE return_spmf z)\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. \\<And>exec_gpv gpv s.\n       \\<lbrakk>\\<And>gpv s.\n                   \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n                   \\<Longrightarrow> ord_spmf (=)\n(map_spmf f (exec_gpv (TRY gpv ELSE Done x) s))\n(TRY map_spmf f (exec_gpv1 callee gpv s) ELSE return_spmf z);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf f\n                            (bind_spmf (the_gpv (TRY gpv ELSE Done x))\n                              (case_generat (\\<lambda>x. return_spmf (x, s))\n                                (\\<lambda>out c.\n                                    bind_spmf (callee s out)\n                                     (\\<lambda>(x, y). exec_gpv (c x) y)))))\n                          (TRY map_spmf f\n                                (exec_gpv1 callee gpv s) ELSE return_spmf z)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (map_spmf f\n       (bind_spmf (the_gpv (TRY gpv ELSE Done x))\n         (case_generat (\\<lambda>x. return_spmf (x, s))\n           (\\<lambda>out c.\n               bind_spmf (callee s out)\n                (\\<lambda>(x, y). exec_gpv' (c x) y)))))\n     (TRY map_spmf f (exec_gpv1 callee gpv s) ELSE return_spmf z)", "using step.prems"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (map_spmf f\n       (bind_spmf (the_gpv (TRY gpv ELSE Done x))\n         (case_generat (\\<lambda>x. return_spmf (x, s))\n           (\\<lambda>out c.\n               bind_spmf (callee s out)\n                (\\<lambda>(x, y). exec_gpv' (c x) y)))))\n     (TRY map_spmf f (exec_gpv1 callee gpv s) ELSE return_spmf z)", "unfolding exec_gpv1_def"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (map_spmf f\n       (bind_spmf (the_gpv (TRY gpv ELSE Done x))\n         (case_generat (\\<lambda>x. return_spmf (x, s))\n           (\\<lambda>out c.\n               bind_spmf (callee s out)\n                (\\<lambda>(x, y). exec_gpv' (c x) y)))))\n     (TRY map_spmf f (exec_gpv callee gpv s) ELSE return_spmf z)", "apply(subst exec_gpv.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> ord_spmf (=)\n                       (map_spmf f\n                         (bind_spmf (the_gpv (TRY gpv ELSE Done x))\n                           (case_generat (\\<lambda>x. return_spmf (x, s))\n                             (\\<lambda>out c.\n                                 bind_spmf (callee s out)\n                                  (\\<lambda>(x, y). exec_gpv' (c x) y)))))\n                       (TRY map_spmf f\n                             (bind_spmf (the_gpv gpv)\n                               (case_generat\n                                 (\\<lambda>x. return_spmf (x, s))\n                                 (\\<lambda>out c.\n                                     bind_spmf (callee s out)\n(\\<lambda>(x, y). exec_gpv callee (c x) y)))) ELSE return_spmf z)", "apply(simp add: map_spmf_bind_spmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> ord_spmf (=)\n                       (bind_spmf\n                         (map_spmf\n                           (map_generat id id\n                             (\\<lambda>c input.\n                                 case c input of\n                                 Inl gpv \\<Rightarrow> TRY gpv ELSE Done x\n                                 | Inr gpv' \\<Rightarrow> gpv'))\n                           (TRY map_spmf\n                                 (map_generat id id (map_fun id Inl))\n                                 (the_gpv gpv) ELSE return_spmf (Pure x)))\n                         (map_spmf f \\<circ>\n                          case_generat (\\<lambda>x. return_spmf (x, s))\n                           (\\<lambda>out c.\n                               bind_spmf (callee s out)\n                                (\\<lambda>(x, y). exec_gpv' (c x) y))))\n                       (TRY bind_spmf (the_gpv gpv)\n                             (map_spmf f \\<circ>\n                              case_generat (\\<lambda>x. return_spmf (x, s))\n                               (\\<lambda>out c.\n                                   bind_spmf (callee s out)\n                                    (\\<lambda>(x, y).\n  exec_gpv callee (c x) y))) ELSE return_spmf z)", "apply(subst (1 2) try_spmf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> ord_spmf (=)\n                       (bind_spmf\n                         (map_spmf\n                           (map_generat id id\n                             (\\<lambda>c input.\n                                 case c input of\n                                 Inl gpv \\<Rightarrow> TRY gpv ELSE Done x\n                                 | Inr gpv' \\<Rightarrow> gpv'))\n                           (bind_pmf\n                             (map_spmf (map_generat id id (map_fun id Inl))\n                               (the_gpv gpv))\n                             (case_option (return_spmf (Pure x))\n                               return_spmf)))\n                         (map_spmf f \\<circ>\n                          case_generat (\\<lambda>x. return_spmf (x, s))\n                           (\\<lambda>out c.\n                               bind_spmf (callee s out)\n                                (\\<lambda>(x, y). exec_gpv' (c x) y))))\n                       (bind_pmf\n                         (bind_spmf (the_gpv gpv)\n                           (map_spmf f \\<circ>\n                            case_generat (\\<lambda>x. return_spmf (x, s))\n                             (\\<lambda>out c.\n                                 bind_spmf (callee s out)\n                                  (\\<lambda>(x, y).\nexec_gpv callee (c x) y))))\n                         (case_option (return_spmf z) return_spmf))", "apply(simp add: map_bind_pmf bind_spmf_pmf_assoc o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> ord_spmf (=)\n                       (bind_pmf\n                         (map_spmf (map_generat id id (map_fun id Inl))\n                           (the_gpv gpv))\n                         (\\<lambda>xa.\n                             bind_spmf\n                              (map_spmf\n                                (map_generat id id\n                                  (\\<lambda>c input.\ncase c input of Inl gpv \\<Rightarrow> TRY gpv ELSE Done x\n| Inr gpv' \\<Rightarrow> gpv'))\n                                (case xa of\n                                 None \\<Rightarrow> return_spmf (Pure x)\n                                 | Some y \\<Rightarrow> return_spmf y))\n                              (\\<lambda>x.\n                                  map_spmf f\n                                   (case x of\n                                    Pure x \\<Rightarrow> return_spmf (x, s)\n                                    | IO out c \\<Rightarrow>\n  bind_spmf (callee s out) (\\<lambda>(x, y). exec_gpv' (c x) y)))))\n                       (bind_pmf\n                         (bind_spmf (the_gpv gpv)\n                           (\\<lambda>x.\n                               map_spmf f\n                                (case x of\n                                 Pure x \\<Rightarrow> return_spmf (x, s)\n                                 | IO out c \\<Rightarrow>\n                                     bind_spmf (callee s out)\n(\\<lambda>(x, y). exec_gpv callee (c x) y))))\n                         (case_option (return_spmf z) return_spmf))", "apply(simp add: bind_spmf_def bind_map_pmf bind_assoc_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> ord_spmf (=)\n                       (bind_pmf (the_gpv gpv)\n                         (\\<lambda>xa.\n                             bind_pmf\n                              (case xa of\n                               None \\<Rightarrow> return_spmf (Pure x)\n                               | Some x \\<Rightarrow>\n                                   (return_spmf \\<circ>\n                                    map_generat id id (map_fun id Inl))\n                                    x)\n                              (case_option (return_pmf None)\n                                ((\\<lambda>a'.\n                                     map_spmf f\n(case a' of Pure x \\<Rightarrow> return_spmf (x, s)\n | IO out c \\<Rightarrow>\n     bind_spmf (callee s out) (\\<lambda>(x, y). exec_gpv' (c x) y))) \\<circ>\n                                 map_generat id id\n                                  (\\<lambda>c input.\ncase c input of Inl gpv \\<Rightarrow> TRY gpv ELSE Done x\n| Inr gpv' \\<Rightarrow> gpv')))))\n                       (bind_pmf (the_gpv gpv)\n                         (\\<lambda>x.\n                             bind_pmf\n                              (case x of None \\<Rightarrow> return_pmf None\n                               | Some a' \\<Rightarrow>\n                                   map_spmf f\n                                    (case a' of\n                                     Pure x \\<Rightarrow> return_spmf (x, s)\n                                     | IO out c \\<Rightarrow>\n   bind_spmf (callee s out) (\\<lambda>(x, y). exec_gpv callee (c x) y)))\n                              (case_option (return_spmf z) return_spmf)))", "apply(rule rel_pmf_bindI[where R=\"eq_onp (\\<lambda>x. x \\<in> set_pmf (the_gpv gpv))\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> rel_pmf\n                       (eq_onp (\\<lambda>x. x \\<in> set_pmf (the_gpv gpv)))\n                       (the_gpv gpv) (the_gpv gpv)\n 2. \\<And>xa y.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        eq_onp (\\<lambda>x. x \\<in> set_pmf (the_gpv gpv)) xa y\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (bind_pmf\n                            (case xa of\n                             None \\<Rightarrow> return_spmf (Pure x)\n                             | Some x \\<Rightarrow>\n                                 (return_spmf \\<circ>\n                                  map_generat id id (map_fun id Inl))\n                                  x)\n                            (case_option (return_pmf None)\n                              ((\\<lambda>a'.\n                                   map_spmf f\n                                    (case a' of\n                                     Pure x \\<Rightarrow> return_spmf (x, s)\n                                     | IO out c \\<Rightarrow>\n   bind_spmf (callee s out) (\\<lambda>(x, y). exec_gpv' (c x) y))) \\<circ>\n                               map_generat id id\n                                (\\<lambda>c input.\n                                    case c input of\n                                    Inl gpv \\<Rightarrow>\nTRY gpv ELSE Done x\n                                    | Inr gpv' \\<Rightarrow> gpv'))))\n                          (bind_pmf\n                            (case y of None \\<Rightarrow> return_pmf None\n                             | Some a' \\<Rightarrow>\n                                 map_spmf f\n                                  (case a' of\n                                   Pure x \\<Rightarrow> return_spmf (x, s)\n                                   | IO out c \\<Rightarrow>\n bind_spmf (callee s out) (\\<lambda>(x, y). exec_gpv callee (c x) y)))\n                            (case_option (return_spmf z) return_spmf))", "apply(rule pmf.rel_refl_strong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        z \\<in> set_pmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> eq_onp (\\<lambda>x. x \\<in> set_pmf (the_gpv gpv))\n                          z z\n 2. \\<And>xa y.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        eq_onp (\\<lambda>x. x \\<in> set_pmf (the_gpv gpv)) xa y\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (bind_pmf\n                            (case xa of\n                             None \\<Rightarrow> return_spmf (Pure x)\n                             | Some x \\<Rightarrow>\n                                 (return_spmf \\<circ>\n                                  map_generat id id (map_fun id Inl))\n                                  x)\n                            (case_option (return_pmf None)\n                              ((\\<lambda>a'.\n                                   map_spmf f\n                                    (case a' of\n                                     Pure x \\<Rightarrow> return_spmf (x, s)\n                                     | IO out c \\<Rightarrow>\n   bind_spmf (callee s out) (\\<lambda>(x, y). exec_gpv' (c x) y))) \\<circ>\n                               map_generat id id\n                                (\\<lambda>c input.\n                                    case c input of\n                                    Inl gpv \\<Rightarrow>\nTRY gpv ELSE Done x\n                                    | Inr gpv' \\<Rightarrow> gpv'))))\n                          (bind_pmf\n                            (case y of None \\<Rightarrow> return_pmf None\n                             | Some a' \\<Rightarrow>\n                                 map_spmf f\n                                  (case a' of\n                                   Pure x \\<Rightarrow> return_spmf (x, s)\n                                   | IO out c \\<Rightarrow>\n bind_spmf (callee s out) (\\<lambda>(x, y). exec_gpv callee (c x) y)))\n                            (case_option (return_spmf z) return_spmf))", "apply(simp add: eq_onp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        eq_onp (\\<lambda>x. x \\<in> set_pmf (the_gpv gpv)) xa y\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (bind_pmf\n                            (case xa of\n                             None \\<Rightarrow> return_spmf (Pure x)\n                             | Some x \\<Rightarrow>\n                                 (return_spmf \\<circ>\n                                  map_generat id id (map_fun id Inl))\n                                  x)\n                            (case_option (return_pmf None)\n                              ((\\<lambda>a'.\n                                   map_spmf f\n                                    (case a' of\n                                     Pure x \\<Rightarrow> return_spmf (x, s)\n                                     | IO out c \\<Rightarrow>\n   bind_spmf (callee s out) (\\<lambda>(x, y). exec_gpv' (c x) y))) \\<circ>\n                               map_generat id id\n                                (\\<lambda>c input.\n                                    case c input of\n                                    Inl gpv \\<Rightarrow>\nTRY gpv ELSE Done x\n                                    | Inr gpv' \\<Rightarrow> gpv'))))\n                          (bind_pmf\n                            (case y of None \\<Rightarrow> return_pmf None\n                             | Some a' \\<Rightarrow>\n                                 map_spmf f\n                                  (case a' of\n                                   Pure x \\<Rightarrow> return_spmf (x, s)\n                                   | IO out c \\<Rightarrow>\n bind_spmf (callee s out) (\\<lambda>(x, y). exec_gpv callee (c x) y)))\n                            (case_option (return_spmf z) return_spmf))", "apply(clarsimp split!: option.split generat.split simp add: bind_return_pmf f map_spmf_bind_spmf o_def eq_onp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21a x22a.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        Some (IO x21a x22a) \\<in> set_pmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (bind_spmf (callee s x21a)\n                            (\\<lambda>xa.\n                                map_spmf f\n                                 (case xa of\n                                  (xa, xb) \\<Rightarrow>\n                                    exec_gpv' (TRY x22a xa ELSE Done x)\n                                     xb)))\n                          (bind_pmf\n                            (bind_spmf (callee s x21a)\n                              (\\<lambda>x.\n                                  map_spmf f\n                                   (case x of\n                                    (x, xa) \\<Rightarrow>\nexec_gpv callee (x22a x) xa)))\n                            (case_option (return_spmf z) return_spmf))", "apply(simp add: bind_spmf_def bind_assoc_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21a x22a.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        Some (IO x21a x22a) \\<in> set_pmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (bind_pmf (callee s x21a)\n                            (\\<lambda>a.\n                                case a of None \\<Rightarrow> return_pmf None\n                                | Some a' \\<Rightarrow>\n                                    map_spmf f\n                                     (case a' of\n(xa, xb) \\<Rightarrow> exec_gpv' (TRY x22a xa ELSE Done x) xb)))\n                          (bind_pmf (callee s x21a)\n                            (\\<lambda>x.\n                                bind_pmf\n                                 (case x of\n                                  None \\<Rightarrow> return_pmf None\n                                  | Some a' \\<Rightarrow>\nmap_spmf f (case a' of (x, xa) \\<Rightarrow> exec_gpv callee (x22a x) xa))\n                                 (case_option (return_spmf z) return_spmf)))", "subgoal for out c"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n     Some (IO out c) \\<in> set_pmf (the_gpv gpv)\\<rbrakk>\n    \\<Longrightarrow> ord_spmf (=)\n                       (bind_pmf (callee s out)\n                         (\\<lambda>a.\n                             case a of None \\<Rightarrow> return_pmf None\n                             | Some a' \\<Rightarrow>\n                                 map_spmf f\n                                  (case a' of\n                                   (xa, xb) \\<Rightarrow>\n                                     exec_gpv' (TRY c xa ELSE Done x) xb)))\n                       (bind_pmf (callee s out)\n                         (\\<lambda>x.\n                             bind_pmf\n                              (case x of None \\<Rightarrow> return_pmf None\n                               | Some a' \\<Rightarrow>\n                                   map_spmf f\n                                    (case a' of\n                                     (x, xa) \\<Rightarrow>\n exec_gpv callee (c x) xa))\n                              (case_option (return_spmf z) return_spmf)))", "apply(rule rel_pmf_bindI[where R=\"eq_onp (\\<lambda>x. x \\<in> set_pmf (callee s out))\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n     Some (IO out c) \\<in> set_pmf (the_gpv gpv)\\<rbrakk>\n    \\<Longrightarrow> rel_pmf\n                       (eq_onp (\\<lambda>x. x \\<in> set_pmf (callee s out)))\n                       (callee s out) (callee s out)\n 2. \\<And>xa y.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        Some (IO out c) \\<in> set_pmf (the_gpv gpv);\n        eq_onp (\\<lambda>x. x \\<in> set_pmf (callee s out)) xa y\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (case xa of None \\<Rightarrow> return_pmf None\n                           | Some a' \\<Rightarrow>\n                               map_spmf f\n                                (case a' of\n                                 (xa, xb) \\<Rightarrow>\n                                   exec_gpv' (TRY c xa ELSE Done x) xb))\n                          (bind_pmf\n                            (case y of None \\<Rightarrow> return_pmf None\n                             | Some a' \\<Rightarrow>\n                                 map_spmf f\n                                  (case a' of\n                                   (x, xa) \\<Rightarrow>\n                                     exec_gpv callee (c x) xa))\n                            (case_option (return_spmf z) return_spmf))", "apply(rule pmf.rel_refl_strong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        Some (IO out c) \\<in> set_pmf (the_gpv gpv);\n        z \\<in> set_pmf (callee s out)\\<rbrakk>\n       \\<Longrightarrow> eq_onp (\\<lambda>x. x \\<in> set_pmf (callee s out))\n                          z z\n 2. \\<And>xa y.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        Some (IO out c) \\<in> set_pmf (the_gpv gpv);\n        eq_onp (\\<lambda>x. x \\<in> set_pmf (callee s out)) xa y\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (case xa of None \\<Rightarrow> return_pmf None\n                           | Some a' \\<Rightarrow>\n                               map_spmf f\n                                (case a' of\n                                 (xa, xb) \\<Rightarrow>\n                                   exec_gpv' (TRY c xa ELSE Done x) xb))\n                          (bind_pmf\n                            (case y of None \\<Rightarrow> return_pmf None\n                             | Some a' \\<Rightarrow>\n                                 map_spmf f\n                                  (case a' of\n                                   (x, xa) \\<Rightarrow>\n                                     exec_gpv callee (c x) xa))\n                            (case_option (return_spmf z) return_spmf))", "apply(simp add: eq_onp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        Some (IO out c) \\<in> set_pmf (the_gpv gpv);\n        eq_onp (\\<lambda>x. x \\<in> set_pmf (callee s out)) xa y\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (case xa of None \\<Rightarrow> return_pmf None\n                           | Some a' \\<Rightarrow>\n                               map_spmf f\n                                (case a' of\n                                 (xa, xb) \\<Rightarrow>\n                                   exec_gpv' (TRY c xa ELSE Done x) xb))\n                          (bind_pmf\n                            (case y of None \\<Rightarrow> return_pmf None\n                             | Some a' \\<Rightarrow>\n                                 map_spmf f\n                                  (case a' of\n                                   (x, xa) \\<Rightarrow>\n                                     exec_gpv callee (c x) xa))\n                            (case_option (return_spmf z) return_spmf))", "apply(clarsimp split!: option.split simp add: eq_onp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        Some (IO out c) \\<in> set_pmf (the_gpv gpv);\n        Some (a, b) \\<in> set_pmf (callee s out)\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf f (exec_gpv' (TRY c a ELSE Done x) b))\n                          (bind_pmf (map_spmf f (exec_gpv callee (c a) b))\n                            (case_option (return_spmf z) return_spmf))", "apply(simp add: in_set_spmf[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        (a, b) \\<in> set_spmf (callee s out)\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf f (exec_gpv' (TRY c a ELSE Done x) b))\n                          (bind_pmf (map_spmf f (exec_gpv callee (c a) b))\n                            (case_option (return_spmf z) return_spmf))", "apply(rule spmf.leq_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        (a, b) \\<in> set_spmf (callee s out)\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf f (exec_gpv' (TRY c a ELSE Done x) b))\n                          (?y15 a b)\n 2. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        (a, b) \\<in> set_spmf (callee s out)\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=) (?y15 a b)\n                          (bind_pmf (map_spmf f (exec_gpv callee (c a) b))\n                            (case_option (return_spmf z) return_spmf))", "apply(rule step.IH)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        (a, b) \\<in> set_spmf (callee s out)\\<rbrakk>\n       \\<Longrightarrow> \\<I> \\<turnstile>g c a \\<surd>\n 2. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        (a, b) \\<in> set_spmf (callee s out)\\<rbrakk>\n       \\<Longrightarrow> I b\n 3. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        (a, b) \\<in> set_spmf (callee s out)\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (TRY map_spmf f\n                                (exec_gpv1 callee (c a)\n                                  b) ELSE return_spmf z)\n                          (bind_pmf (map_spmf f (exec_gpv callee (c a) b))\n                            (case_option (return_spmf z) return_spmf))", "apply(frule (1) WT_gpvD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        (a, b) \\<in> set_spmf (callee s out);\n        out \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> \\<I> \\<turnstile>g c a \\<surd>\n 2. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        (a, b) \\<in> set_spmf (callee s out)\\<rbrakk>\n       \\<Longrightarrow> I b\n 3. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        (a, b) \\<in> set_spmf (callee s out)\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (TRY map_spmf f\n                                (exec_gpv1 callee (c a)\n                                  b) ELSE return_spmf z)\n                          (bind_pmf (map_spmf f (exec_gpv callee (c a) b))\n                            (case_option (return_spmf z) return_spmf))", "apply(erule (1) WT_gpvD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>I s; IO out c \\<in> set_spmf (the_gpv gpv);\n        (a, b) \\<in> set_spmf (callee s out);\n        out \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> a \\<in> responses_\\<I> \\<I> out\n 2. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        (a, b) \\<in> set_spmf (callee s out)\\<rbrakk>\n       \\<Longrightarrow> I b\n 3. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        (a, b) \\<in> set_spmf (callee s out)\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (TRY map_spmf f\n                                (exec_gpv1 callee (c a)\n                                  b) ELSE return_spmf z)\n                          (bind_pmf (map_spmf f (exec_gpv callee (c a) b))\n                            (case_option (return_spmf z) return_spmf))", "apply(drule WT_callee)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>IO out c \\<in> set_spmf (the_gpv gpv);\n        (a, b) \\<in> set_spmf (callee s out); out \\<in> outs_\\<I> \\<I>;\n        \\<I> \\<turnstile>c callee s \\<surd>\\<rbrakk>\n       \\<Longrightarrow> a \\<in> responses_\\<I> \\<I> out\n 2. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        (a, b) \\<in> set_spmf (callee s out)\\<rbrakk>\n       \\<Longrightarrow> I b\n 3. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        (a, b) \\<in> set_spmf (callee s out)\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (TRY map_spmf f\n                                (exec_gpv1 callee (c a)\n                                  b) ELSE return_spmf z)\n                          (bind_pmf (map_spmf f (exec_gpv callee (c a) b))\n                            (case_option (return_spmf z) return_spmf))", "apply(erule (2) WT_calleeD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        (a, b) \\<in> set_spmf (callee s out)\\<rbrakk>\n       \\<Longrightarrow> I b\n 2. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        (a, b) \\<in> set_spmf (callee s out)\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (TRY map_spmf f\n                                (exec_gpv1 callee (c a)\n                                  b) ELSE return_spmf z)\n                          (bind_pmf (map_spmf f (exec_gpv callee (c a) b))\n                            (case_option (return_spmf z) return_spmf))", "apply(frule (1) WT_gpvD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        (a, b) \\<in> set_spmf (callee s out);\n        out \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> I b\n 2. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        (a, b) \\<in> set_spmf (callee s out)\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (TRY map_spmf f\n                                (exec_gpv1 callee (c a)\n                                  b) ELSE return_spmf z)\n                          (bind_pmf (map_spmf f (exec_gpv callee (c a) b))\n                            (case_option (return_spmf z) return_spmf))", "apply(erule (2) callee_invariant)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        (a, b) \\<in> set_spmf (callee s out)\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (TRY map_spmf f\n                                (exec_gpv1 callee (c a)\n                                  b) ELSE return_spmf z)\n                          (bind_pmf (map_spmf f (exec_gpv callee (c a) b))\n                            (case_option (return_spmf z) return_spmf))", "apply(simp add: try_spmf_def exec_gpv1_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ord_spmf (=)\n   (map_spmf f\n     (bind_spmf (the_gpv (TRY gpv ELSE Done x))\n       (case_generat (\\<lambda>x. return_spmf (x, s))\n         (\\<lambda>out c.\n             bind_spmf (callee s out)\n              (\\<lambda>(x, y). exec_gpv' (c x) y)))))\n   (TRY map_spmf f (exec_gpv1 callee gpv s) ELSE return_spmf z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ord_spmf (=) (map_spmf f (exec_gpv callee (TRY gpv ELSE Done x) s))\n   (TRY map_spmf f (exec_gpv1 callee gpv s) ELSE return_spmf z)\n\ngoal (1 subgoal):\n 1. map_spmf f (exec_gpv callee (TRY gpv ELSE Done x) s) =\n    TRY map_spmf f (exec_gpv1 callee gpv s) ELSE return_spmf z", "have \"lossless_spmf ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (map_spmf f (exec_gpv callee (TRY gpv ELSE Done x) s))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (exec_gpv callee (TRY gpv ELSE Done x) s)", "apply(rule plossless_exec_gpv)"], ["proof (prove)\ngoal (4 subgoals):\n 1. plossless_gpv \\<I> (TRY gpv ELSE Done x)\n 2. \\<I> \\<turnstile>g TRY gpv ELSE Done x \\<surd>\n 3. \\<And>s x.\n       \\<lbrakk>x \\<in> outs_\\<I> \\<I>; I s\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (callee s x)\n 4. I s", "apply(rule plossless_gpv_try_gpvI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. pfinite_gpv \\<I> gpv\n 2. \\<not> colossless_gpv \\<I> gpv \\<Longrightarrow>\n    plossless_gpv \\<I> (Done x)\n 3. \\<I> \\<turnstile>g TRY gpv ELSE Done x \\<surd>\n 4. \\<And>s x.\n       \\<lbrakk>x \\<in> outs_\\<I> \\<I>; I s\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (callee s x)\n 5. I s", "apply(rule pfinite)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<not> colossless_gpv \\<I> gpv \\<Longrightarrow>\n    plossless_gpv \\<I> (Done x)\n 2. \\<I> \\<turnstile>g TRY gpv ELSE Done x \\<surd>\n 3. \\<And>s x.\n       \\<lbrakk>x \\<in> outs_\\<I> \\<I>; I s\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (callee s x)\n 4. I s", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<I> \\<turnstile>g TRY gpv ELSE Done x \\<surd>\n 2. \\<And>s x.\n       \\<lbrakk>x \\<in> outs_\\<I> \\<I>; I s\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (callee s x)\n 3. I s", "apply(rule WT_gpv_try_gpvI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<I> \\<turnstile>g gpv \\<surd>\n 2. \\<not> colossless_gpv \\<I> gpv \\<Longrightarrow>\n    \\<I> \\<turnstile>g Done x \\<surd>\n 3. \\<And>s x.\n       \\<lbrakk>x \\<in> outs_\\<I> \\<I>; I s\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (callee s x)\n 4. I s", "apply(simp add: WT)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<not> colossless_gpv \\<I> gpv \\<Longrightarrow>\n    \\<I> \\<turnstile>g Done x \\<surd>\n 2. \\<And>s x.\n       \\<lbrakk>x \\<in> outs_\\<I> \\<I>; I s\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (callee s x)\n 3. I s", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s x.\n       \\<lbrakk>x \\<in> outs_\\<I> \\<I>; I s\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (callee s x)\n 2. I s", "apply(simp add: lossless)"], ["proof (prove)\ngoal (1 subgoal):\n 1. I s", "apply(simp add: I)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lossless_spmf (map_spmf f (exec_gpv callee (TRY gpv ELSE Done x) s))\n\ngoal (1 subgoal):\n 1. map_spmf f (exec_gpv callee (TRY gpv ELSE Done x) s) =\n    TRY map_spmf f (exec_gpv1 callee gpv s) ELSE return_spmf z", "from ord_spmf_lossless_spmfD1[OF le this]"], ["proof (chain)\npicking this:\n  rel_spmf (=) (map_spmf f (exec_gpv callee (TRY gpv ELSE Done x) s))\n   (TRY map_spmf f (exec_gpv1 callee gpv s) ELSE return_spmf z)", "show ?thesis"], ["proof (prove)\nusing this:\n  rel_spmf (=) (map_spmf f (exec_gpv callee (TRY gpv ELSE Done x) s))\n   (TRY map_spmf f (exec_gpv1 callee gpv s) ELSE return_spmf z)\n\ngoal (1 subgoal):\n 1. map_spmf f (exec_gpv callee (TRY gpv ELSE Done x) s) =\n    TRY map_spmf f (exec_gpv1 callee gpv s) ELSE return_spmf z", "by(simp add: spmf_rel_eq)"], ["proof (state)\nthis:\n  map_spmf f (exec_gpv callee (TRY gpv ELSE Done x) s) =\n  TRY map_spmf f (exec_gpv1 callee gpv s) ELSE return_spmf z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma try_gpv_bind_gen_lossless': \\<comment> \\<open>generalises @{thm try_gpv_bind_gen_lossless}\\<close>\n  assumes lossless: \"gen_lossless_gpv b \\<I> gpv\"\n    and WT1: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and WT2: \"\\<I> \\<turnstile>g gpv' \\<surd>\"\n    and WTf: \"\\<And>x. x \\<in> results_gpv \\<I> gpv \\<Longrightarrow> \\<I> \\<turnstile>g f x \\<surd>\"\n  shows \"eq_\\<I>_gpv (=) \\<I> (TRY bind_gpv gpv f ELSE gpv') (bind_gpv gpv (\\<lambda>x. TRY f x ELSE gpv'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv (=) \\<I> (TRY gpv \\<bind> f ELSE gpv')\n     (gpv \\<bind> (\\<lambda>x. TRY f x ELSE gpv'))", "using lossless WT1 WTf"], ["proof (prove)\nusing this:\n  gen_lossless_gpv b \\<I> gpv\n  \\<I> \\<turnstile>g gpv \\<surd>\n  ?x \\<in> results_gpv \\<I> gpv \\<Longrightarrow>\n  \\<I> \\<turnstile>g f ?x \\<surd>\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv (=) \\<I> (TRY gpv \\<bind> f ELSE gpv')\n     (gpv \\<bind> (\\<lambda>x. TRY f x ELSE gpv'))", "proof(coinduction arbitrary: gpv)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>gpva.\n       \\<lbrakk>gen_lossless_gpv b \\<I> gpva;\n        \\<I> \\<turnstile>g gpva \\<surd>;\n        \\<forall>x.\n           x \\<in> results_gpv \\<I> gpva \\<longrightarrow>\n           \\<I> \\<turnstile>g f x \\<surd>\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (eq_\\<I>_generat (=) \\<I>\n                            (\\<lambda>gpv gpv'a.\n                                (\\<exists>gpva.\n                                    gpv =\n                                    TRY gpva \\<bind> f ELSE gpv' \\<and>\n                                    gpv'a =\n                                    gpva \\<bind>\n                                    (\\<lambda>x. TRY f x ELSE gpv') \\<and>\n                                    gen_lossless_gpv b \\<I> gpva \\<and>\n                                    \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n                                    (\\<forall>x.\n  x \\<in> results_gpv \\<I> gpva \\<longrightarrow>\n  \\<I> \\<turnstile>g f x \\<surd>)) \\<or>\n                                eq_\\<I>_gpv (=) \\<I> gpv gpv'a))\n                          (the_gpv (TRY gpva \\<bind> f ELSE gpv'))\n                          (the_gpv\n                            (gpva \\<bind> (\\<lambda>x. TRY f x ELSE gpv')))", "case (eq_\\<I>_gpv gpv)"], ["proof (state)\nthis:\n  gen_lossless_gpv b \\<I> gpv\n  \\<I> \\<turnstile>g gpv \\<surd>\n  \\<forall>x.\n     x \\<in> results_gpv \\<I> gpv \\<longrightarrow>\n     \\<I> \\<turnstile>g f x \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>gpva.\n       \\<lbrakk>gen_lossless_gpv b \\<I> gpva;\n        \\<I> \\<turnstile>g gpva \\<surd>;\n        \\<forall>x.\n           x \\<in> results_gpv \\<I> gpva \\<longrightarrow>\n           \\<I> \\<turnstile>g f x \\<surd>\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (eq_\\<I>_generat (=) \\<I>\n                            (\\<lambda>gpv gpv'a.\n                                (\\<exists>gpva.\n                                    gpv =\n                                    TRY gpva \\<bind> f ELSE gpv' \\<and>\n                                    gpv'a =\n                                    gpva \\<bind>\n                                    (\\<lambda>x. TRY f x ELSE gpv') \\<and>\n                                    gen_lossless_gpv b \\<I> gpva \\<and>\n                                    \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n                                    (\\<forall>x.\n  x \\<in> results_gpv \\<I> gpva \\<longrightarrow>\n  \\<I> \\<turnstile>g f x \\<surd>)) \\<or>\n                                eq_\\<I>_gpv (=) \\<I> gpv gpv'a))\n                          (the_gpv (TRY gpva \\<bind> f ELSE gpv'))\n                          (the_gpv\n                            (gpva \\<bind> (\\<lambda>x. TRY f x ELSE gpv')))", "note [simp] = spmf_rel_map generat.rel_map map_spmf_bind_spmf\n    and [intro!] = rel_spmf_reflI rel_generat_reflI rel_funI"], ["proof (state)\nthis:\n  rel_spmf ?R (map_spmf ?f ?x) = rel_spmf (\\<lambda>x. ?R (?f x)) ?x\n  rel_spmf ?R ?x (map_spmf ?g ?y) =\n  rel_spmf (\\<lambda>x y. ?R x (?g y)) ?x ?y\n  rel_generat ?S1b ?S2b ?S3b (map_generat ?i1.0 ?i2.0 ?i3.0 ?x) ?y =\n  rel_generat (\\<lambda>x. ?S1b (?i1.0 x)) (\\<lambda>x. ?S2b (?i2.0 x))\n   (\\<lambda>x. ?S3b (?i3.0 x)) ?x ?y\n  rel_generat ?S1a ?S2a ?S3a ?x (map_generat ?g1.0 ?g2.0 ?g3.0 ?y) =\n  rel_generat (\\<lambda>x y. ?S1a x (?g1.0 y))\n   (\\<lambda>x y. ?S2a x (?g2.0 y)) (\\<lambda>x y. ?S3a x (?g3.0 y)) ?x ?y\n  map_spmf ?f (?p \\<bind> ?g) = ?p \\<bind> map_spmf ?f \\<circ> ?g\n  (\\<And>x. x \\<in> set_spmf ?p \\<Longrightarrow> ?P x x) \\<Longrightarrow>\n  rel_spmf ?P ?p ?p\n  \\<lbrakk>\\<And>y. y \\<in> generat_pures ?x \\<Longrightarrow> ?A y y;\n   \\<And>out. out \\<in> generat_outs ?x \\<Longrightarrow> ?B out out;\n   \\<And>cont.\n      cont \\<in> generat_conts ?x \\<Longrightarrow> ?C cont cont\\<rbrakk>\n  \\<Longrightarrow> rel_generat ?A ?B ?C ?x ?x\n  (\\<And>x y. ?A x y \\<Longrightarrow> ?B (?f x) (?g y)) \\<Longrightarrow>\n  rel_fun ?A ?B ?f ?g\n\ngoal (1 subgoal):\n 1. \\<And>gpva.\n       \\<lbrakk>gen_lossless_gpv b \\<I> gpva;\n        \\<I> \\<turnstile>g gpva \\<surd>;\n        \\<forall>x.\n           x \\<in> results_gpv \\<I> gpva \\<longrightarrow>\n           \\<I> \\<turnstile>g f x \\<surd>\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (eq_\\<I>_generat (=) \\<I>\n                            (\\<lambda>gpv gpv'a.\n                                (\\<exists>gpva.\n                                    gpv =\n                                    TRY gpva \\<bind> f ELSE gpv' \\<and>\n                                    gpv'a =\n                                    gpva \\<bind>\n                                    (\\<lambda>x. TRY f x ELSE gpv') \\<and>\n                                    gen_lossless_gpv b \\<I> gpva \\<and>\n                                    \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n                                    (\\<forall>x.\n  x \\<in> results_gpv \\<I> gpva \\<longrightarrow>\n  \\<I> \\<turnstile>g f x \\<surd>)) \\<or>\n                                eq_\\<I>_gpv (=) \\<I> gpv gpv'a))\n                          (the_gpv (TRY gpva \\<bind> f ELSE gpv'))\n                          (the_gpv\n                            (gpva \\<bind> (\\<lambda>x. TRY f x ELSE gpv')))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (eq_\\<I>_generat (=) \\<I>\n       (\\<lambda>gpv gpv'a.\n           (\\<exists>gpva.\n               gpv = TRY gpva \\<bind> f ELSE gpv' \\<and>\n               gpv'a = gpva \\<bind> (\\<lambda>x. TRY f x ELSE gpv') \\<and>\n               gen_lossless_gpv b \\<I> gpva \\<and>\n               \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n               (\\<forall>x.\n                   x \\<in> results_gpv \\<I> gpva \\<longrightarrow>\n                   \\<I> \\<turnstile>g f x \\<surd>)) \\<or>\n           eq_\\<I>_gpv (=) \\<I> gpv gpv'a))\n     (the_gpv (TRY gpv \\<bind> f ELSE gpv'))\n     (the_gpv (gpv \\<bind> (\\<lambda>x. TRY f x ELSE gpv')))", "using gen_lossless_gpvD[OF eq_\\<I>_gpv(1)] WT_gpvD[OF eq_\\<I>_gpv(2)] WT_gpvD[OF WT2] WT_gpvD[OF eq_\\<I>_gpv(3)[rule_format, OF results_gpv.Pure]] WT2"], ["proof (prove)\nusing this:\n  lossless_spmf (the_gpv gpv)\n  \\<lbrakk>IO ?out ?c \\<in> set_spmf (the_gpv gpv);\n   ?input \\<in> responses_\\<I> \\<I> ?out\\<rbrakk>\n  \\<Longrightarrow> gen_lossless_gpv b \\<I> (?c ?input)\n  IO ?out ?c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n  ?out \\<in> outs_\\<I> \\<I>\n  \\<lbrakk>IO ?out ?c \\<in> set_spmf (the_gpv gpv);\n   ?input \\<in> responses_\\<I> \\<I> ?out\\<rbrakk>\n  \\<Longrightarrow> \\<I> \\<turnstile>g ?c ?input \\<surd>\n  IO ?out ?c \\<in> set_spmf (the_gpv gpv') \\<Longrightarrow>\n  ?out \\<in> outs_\\<I> \\<I>\n  \\<lbrakk>IO ?out ?c \\<in> set_spmf (the_gpv gpv');\n   ?input \\<in> responses_\\<I> \\<I> ?out\\<rbrakk>\n  \\<Longrightarrow> \\<I> \\<turnstile>g ?c ?input \\<surd>\n  \\<lbrakk>Pure ?x1 \\<in> set_spmf (the_gpv gpv);\n   IO ?out ?c \\<in> set_spmf (the_gpv (f ?x1))\\<rbrakk>\n  \\<Longrightarrow> ?out \\<in> outs_\\<I> \\<I>\n  \\<lbrakk>Pure ?x1 \\<in> set_spmf (the_gpv gpv);\n   IO ?out ?c \\<in> set_spmf (the_gpv (f ?x1));\n   ?input \\<in> responses_\\<I> \\<I> ?out\\<rbrakk>\n  \\<Longrightarrow> \\<I> \\<turnstile>g ?c ?input \\<surd>\n  \\<I> \\<turnstile>g gpv' \\<surd>\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (eq_\\<I>_generat (=) \\<I>\n       (\\<lambda>gpv gpv'a.\n           (\\<exists>gpva.\n               gpv = TRY gpva \\<bind> f ELSE gpv' \\<and>\n               gpv'a = gpva \\<bind> (\\<lambda>x. TRY f x ELSE gpv') \\<and>\n               gen_lossless_gpv b \\<I> gpva \\<and>\n               \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n               (\\<forall>x.\n                   x \\<in> results_gpv \\<I> gpva \\<longrightarrow>\n                   \\<I> \\<turnstile>g f x \\<surd>)) \\<or>\n           eq_\\<I>_gpv (=) \\<I> gpv gpv'a))\n     (the_gpv (TRY gpv \\<bind> f ELSE gpv'))\n     (the_gpv (gpv \\<bind> (\\<lambda>x. TRY f x ELSE gpv')))", "apply(auto simp del: bind_gpv_sel' simp add: bind_gpv.sel try_spmf_bind_spmf_lossless generat.map_comp o_def intro!: rel_spmf_bind_reflI rel_spmf_try_spmf split!: generat.split)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x.\n       \\<lbrakk>lossless_spmf (the_gpv gpv);\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf (the_gpv gpv);\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> gen_lossless_gpv b \\<I> (c input);\n        \\<And>out c.\n           IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n           out \\<in> outs_\\<I> \\<I>;\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf (the_gpv gpv);\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> \\<I> \\<turnstile>g c input \\<surd>;\n        \\<And>out c.\n           IO out c \\<in> set_spmf (the_gpv gpv') \\<Longrightarrow>\n           out \\<in> outs_\\<I> \\<I>;\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf (the_gpv gpv');\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> \\<I> \\<turnstile>g c input \\<surd>;\n        \\<And>x out c.\n           \\<lbrakk>Pure x \\<in> set_spmf (the_gpv gpv);\n            IO out c \\<in> set_spmf (the_gpv (f x))\\<rbrakk>\n           \\<Longrightarrow> out \\<in> outs_\\<I> \\<I>;\n        \\<And>x out c input.\n           \\<lbrakk>Pure x \\<in> set_spmf (the_gpv gpv);\n            IO out c \\<in> set_spmf (the_gpv (f x));\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> \\<I> \\<turnstile>g c input \\<surd>;\n        \\<I> \\<turnstile>g gpv' \\<surd>;\n        Pure x1 \\<in> set_spmf (the_gpv gpv);\n        x \\<in> set_spmf (the_gpv (f x1))\\<rbrakk>\n       \\<Longrightarrow> eq_\\<I>_generat (=) \\<I>\n                          (\\<lambda>x y.\n                              (\\<exists>gpv.\n                                  x = TRY gpv \\<bind> f ELSE gpv' \\<and>\n                                  y =\n                                  gpv \\<bind>\n                                  (\\<lambda>x. TRY f x ELSE gpv') \\<and>\n                                  gen_lossless_gpv b \\<I> gpv \\<and>\n                                  \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                                  (\\<forall>x.\nx \\<in> results_gpv \\<I> gpv \\<longrightarrow>\n\\<I> \\<turnstile>g f x \\<surd>)) \\<or>\n                              eq_\\<I>_gpv (=) \\<I> x y)\n                          (map_generat (\\<lambda>x. x) (\\<lambda>x. x)\n                            (\\<lambda>x input. TRY x input ELSE gpv') x)\n                          (map_generat (\\<lambda>x. x) (\\<lambda>x. x)\n                            (\\<lambda>x input. TRY x input ELSE gpv') x)\n 2. \\<And>x1 xa.\n       \\<lbrakk>lossless_spmf (the_gpv gpv);\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf (the_gpv gpv);\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> gen_lossless_gpv b \\<I> (c input);\n        \\<And>out c.\n           IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n           out \\<in> outs_\\<I> \\<I>;\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf (the_gpv gpv);\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> \\<I> \\<turnstile>g c input \\<surd>;\n        \\<And>out c.\n           IO out c \\<in> set_spmf (the_gpv gpv') \\<Longrightarrow>\n           out \\<in> outs_\\<I> \\<I>;\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf (the_gpv gpv');\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> \\<I> \\<turnstile>g c input \\<surd>;\n        \\<And>x out c.\n           \\<lbrakk>Pure x \\<in> set_spmf (the_gpv gpv);\n            IO out c \\<in> set_spmf (the_gpv (f x))\\<rbrakk>\n           \\<Longrightarrow> out \\<in> outs_\\<I> \\<I>;\n        \\<And>x out c input.\n           \\<lbrakk>Pure x \\<in> set_spmf (the_gpv gpv);\n            IO out c \\<in> set_spmf (the_gpv (f x));\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> \\<I> \\<turnstile>g c input \\<surd>;\n        \\<I> \\<turnstile>g gpv' \\<surd>;\n        Pure x1 \\<in> set_spmf (the_gpv gpv);\n        \\<not> lossless_spmf (the_gpv (f x1));\n        xa \\<in> set_spmf (the_gpv gpv')\\<rbrakk>\n       \\<Longrightarrow> eq_\\<I>_generat (=) \\<I>\n                          (\\<lambda>x y.\n                              (\\<exists>gpv.\n                                  x = TRY gpv \\<bind> f ELSE gpv' \\<and>\n                                  y =\n                                  gpv \\<bind>\n                                  (\\<lambda>x. TRY f x ELSE gpv') \\<and>\n                                  gen_lossless_gpv b \\<I> gpv \\<and>\n                                  \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                                  (\\<forall>x.\nx \\<in> results_gpv \\<I> gpv \\<longrightarrow>\n\\<I> \\<turnstile>g f x \\<surd>)) \\<or>\n                              eq_\\<I>_gpv (=) \\<I> x y)\n                          (map_generat (\\<lambda>x. x) (\\<lambda>x. x)\n                            (\\<lambda>x. x) xa)\n                          (map_generat (\\<lambda>x. x) (\\<lambda>x. x)\n                            (\\<lambda>x. x) xa)\n 3. \\<And>x21 x22 x.\n       \\<lbrakk>lossless_spmf (the_gpv gpv);\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf (the_gpv gpv);\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> gen_lossless_gpv b \\<I> (c input);\n        \\<And>out c.\n           IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n           out \\<in> outs_\\<I> \\<I>;\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf (the_gpv gpv);\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> \\<I> \\<turnstile>g c input \\<surd>;\n        \\<And>out c.\n           IO out c \\<in> set_spmf (the_gpv gpv') \\<Longrightarrow>\n           out \\<in> outs_\\<I> \\<I>;\n        \\<And>out c input.\n           \\<lbrakk>IO out c \\<in> set_spmf (the_gpv gpv');\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> \\<I> \\<turnstile>g c input \\<surd>;\n        \\<And>x out c.\n           \\<lbrakk>Pure x \\<in> set_spmf (the_gpv gpv);\n            IO out c \\<in> set_spmf (the_gpv (f x))\\<rbrakk>\n           \\<Longrightarrow> out \\<in> outs_\\<I> \\<I>;\n        \\<And>x out c input.\n           \\<lbrakk>Pure x \\<in> set_spmf (the_gpv gpv);\n            IO out c \\<in> set_spmf (the_gpv (f x));\n            input \\<in> responses_\\<I> \\<I> out\\<rbrakk>\n           \\<Longrightarrow> \\<I> \\<turnstile>g c input \\<surd>;\n        \\<I> \\<turnstile>g gpv' \\<surd>;\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv);\n        x \\<in> responses_\\<I> \\<I> x21;\n        \\<not> eq_\\<I>_gpv (=) \\<I> (TRY x22 x \\<bind> f ELSE gpv')\n                (x22 x \\<bind> (\\<lambda>x. TRY f x ELSE gpv'))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gpv.\n                            TRY x22 x \\<bind> f ELSE gpv' =\n                            TRY gpv \\<bind> f ELSE gpv' \\<and>\n                            x22 x \\<bind> (\\<lambda>x. TRY f x ELSE gpv') =\n                            gpv \\<bind>\n                            (\\<lambda>x. TRY f x ELSE gpv') \\<and>\n                            gen_lossless_gpv b \\<I> gpv \\<and>\n                            \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                            (\\<forall>x.\n                                x \\<in> results_gpv \\<I>\n   gpv \\<longrightarrow>\n                                \\<I> \\<turnstile>g f x \\<surd>)", "apply(auto 4 4 intro!: eq_\\<I>_gpv(3)[rule_format] eq_\\<I>_gpv_reflI eq_\\<I>_generat_reflI intro: results_gpv.IO WT_intro)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_spmf\n   (eq_\\<I>_generat (=) \\<I>\n     (\\<lambda>gpv gpv'a.\n         (\\<exists>gpva.\n             gpv = TRY gpva \\<bind> f ELSE gpv' \\<and>\n             gpv'a = gpva \\<bind> (\\<lambda>x. TRY f x ELSE gpv') \\<and>\n             gen_lossless_gpv b \\<I> gpva \\<and>\n             \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n             (\\<forall>x.\n                 x \\<in> results_gpv \\<I> gpva \\<longrightarrow>\n                 \\<I> \\<turnstile>g f x \\<surd>)) \\<or>\n         eq_\\<I>_gpv (=) \\<I> gpv gpv'a))\n   (the_gpv (TRY gpv \\<bind> f ELSE gpv'))\n   (the_gpv (gpv \\<bind> (\\<lambda>x. TRY f x ELSE gpv')))\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>We instantiate the parameter @{term b} such that it can be used as a conditional simp rule.\\<close>"], ["", "lemmas try_gpv_bind_lossless' = try_gpv_bind_gen_lossless'[where b=False]\n  and try_gpv_bind_colossless' = try_gpv_bind_gen_lossless'[where b=True]"], ["", "lemma try_gpv_bind_gpv:\n   \"try_gpv (bind_gpv gpv f) gpv' =\n    bind_gpv (try_gpv (map_gpv Some id gpv) (Done None)) (\\<lambda>x. case x of None \\<Rightarrow> gpv' | Some x' \\<Rightarrow> try_gpv (f x') gpv')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY gpv \\<bind> f ELSE gpv' =\n    TRY map_gpv Some id gpv ELSE Done None \\<bind>\n    (\\<lambda>x.\n        case x of None \\<Rightarrow> gpv'\n        | Some x' \\<Rightarrow> TRY f x' ELSE gpv')", "by(coinduction arbitrary: gpv rule: gpv.coinduct_strong)\n    (auto simp add: rel_fun_def generat.rel_map bind_return_pmf spmf_rel_map map_bind_spmf o_def bind_gpv.sel bind_map_spmf try_spmf_def bind_spmf_def spmf.map_comp bind_map_pmf bind_assoc_pmf gpv.map_sel simp del: bind_gpv_sel' intro!: rel_pmf_bind_reflI generat.rel_refl_strong rel_spmf_reflI split!: option.split generat.split)"], ["", "lemma bind_gpv_try_gpv_map_Some:\n  \"bind_gpv (try_gpv (map_gpv Some id gpv) (Done None)) (\\<lambda>x. case x of None \\<Rightarrow> Fail | Some y \\<Rightarrow> f y) =\n   bind_gpv gpv f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY map_gpv Some id gpv ELSE Done None \\<bind>\n    (\\<lambda>x.\n        case x of None \\<Rightarrow> Fail | Some y \\<Rightarrow> f y) =\n    gpv \\<bind> f", "by(coinduction arbitrary: gpv rule: gpv.coinduct_strong)\n    (auto simp add: bind_gpv.sel map_bind_spmf bind_map_spmf try_spmf_def bind_spmf_def spmf_rel_map bind_map_pmf gpv.map_sel bind_assoc_pmf bind_return_pmf generat.rel_map rel_fun_def simp del: bind_gpv_sel' intro!: rel_pmf_bind_reflI rel_spmf_reflI generat.rel_refl_strong split!: option.split generat.split)"], ["", "lemma try_gpv_left_gpv:\n  assumes \"\\<I> \\<turnstile>g gpv \\<surd>\" and WT2: \"\\<I> \\<turnstile>g gpv' \\<surd>\"\n  shows \"eq_\\<I>_gpv (=) (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') (try_gpv (left_gpv gpv) (left_gpv gpv')) (left_gpv (try_gpv gpv gpv'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv (=) (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n     (TRY left_gpv gpv ELSE left_gpv gpv') (left_gpv (TRY gpv ELSE gpv'))", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv (=) (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n     (TRY left_gpv gpv ELSE left_gpv gpv') (left_gpv (TRY gpv ELSE gpv'))", "apply(coinduction arbitrary: gpv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>gpva.\n       \\<I> \\<turnstile>g gpva \\<surd> \\<Longrightarrow>\n       rel_spmf\n        (eq_\\<I>_generat (=) (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n          (\\<lambda>gpv gpv'a.\n              (\\<exists>gpva.\n                  gpv = TRY left_gpv gpva ELSE left_gpv gpv' \\<and>\n                  gpv'a = left_gpv (TRY gpva ELSE gpv') \\<and>\n                  \\<I> \\<turnstile>g gpva \\<surd>) \\<or>\n              eq_\\<I>_gpv (=) (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') gpv gpv'a))\n        (the_gpv (TRY left_gpv gpva ELSE left_gpv gpv'))\n        (the_gpv (left_gpv (TRY gpva ELSE gpv')))", "apply(auto simp add: map_try_spmf spmf.map_comp o_def generat.map_comp spmf_rel_map intro!: rel_spmf_try_spmf rel_spmf_reflI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>gpva x.\n       \\<lbrakk>\\<I> \\<turnstile>g gpva \\<surd>;\n        x \\<in> set_spmf (the_gpv gpva)\\<rbrakk>\n       \\<Longrightarrow> eq_\\<I>_generat (=)\n                          (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n                          (\\<lambda>gpv gpv'a.\n                              (\\<exists>gpva.\n                                  gpv =\n                                  TRY left_gpv\n gpva ELSE left_gpv gpv' \\<and>\n                                  gpv'a =\n                                  left_gpv (TRY gpva ELSE gpv') \\<and>\n                                  \\<I> \\<turnstile>g gpva \\<surd>) \\<or>\n                              eq_\\<I>_gpv (=)\n                               (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') gpv gpv'a)\n                          (map_generat (\\<lambda>x. x) Inl\n                            (\\<lambda>x input.\n                                TRY left_rpv x input ELSE left_gpv gpv')\n                            x)\n                          (map_generat (\\<lambda>x. x) Inl\n                            (\\<lambda>x.\n                                left_rpv\n                                 (\\<lambda>input'. TRY x input' ELSE gpv'))\n                            x)\n 2. \\<And>gpva xa.\n       \\<lbrakk>\\<I> \\<turnstile>g gpva \\<surd>;\n        \\<not> lossless_spmf (the_gpv gpva);\n        xa \\<in> set_spmf (the_gpv gpv')\\<rbrakk>\n       \\<Longrightarrow> eq_\\<I>_generat (=)\n                          (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n                          (\\<lambda>gpv gpv'a.\n                              (\\<exists>gpva.\n                                  gpv =\n                                  TRY left_gpv\n gpva ELSE left_gpv gpv' \\<and>\n                                  gpv'a =\n                                  left_gpv (TRY gpva ELSE gpv') \\<and>\n                                  \\<I> \\<turnstile>g gpva \\<surd>) \\<or>\n                              eq_\\<I>_gpv (=)\n                               (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') gpv gpv'a)\n                          (map_generat (\\<lambda>x. x) Inl left_rpv xa)\n                          (map_generat (\\<lambda>x. x) Inl left_rpv xa)", "subgoal for gpv generat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>;\n     generat \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_generat (=) (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n                       (\\<lambda>gpv gpv'a.\n                           (\\<exists>gpva.\n                               gpv =\n                               TRY left_gpv gpva ELSE left_gpv gpv' \\<and>\n                               gpv'a = left_gpv (TRY gpva ELSE gpv') \\<and>\n                               \\<I> \\<turnstile>g gpva \\<surd>) \\<or>\n                           eq_\\<I>_gpv (=) (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n                            gpv gpv'a)\n                       (map_generat (\\<lambda>x. x) Inl\n                         (\\<lambda>x input.\n                             TRY left_rpv x input ELSE left_gpv gpv')\n                         generat)\n                       (map_generat (\\<lambda>x. x) Inl\n                         (\\<lambda>x.\n                             left_rpv\n                              (\\<lambda>input'. TRY x input' ELSE gpv'))\n                         generat)", "by(cases generat)(auto dest: WT_gpvD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>gpva xa.\n       \\<lbrakk>\\<I> \\<turnstile>g gpva \\<surd>;\n        \\<not> lossless_spmf (the_gpv gpva);\n        xa \\<in> set_spmf (the_gpv gpv')\\<rbrakk>\n       \\<Longrightarrow> eq_\\<I>_generat (=)\n                          (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n                          (\\<lambda>gpv gpv'a.\n                              (\\<exists>gpva.\n                                  gpv =\n                                  TRY left_gpv\n gpva ELSE left_gpv gpv' \\<and>\n                                  gpv'a =\n                                  left_gpv (TRY gpva ELSE gpv') \\<and>\n                                  \\<I> \\<turnstile>g gpva \\<surd>) \\<or>\n                              eq_\\<I>_gpv (=)\n                               (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') gpv gpv'a)\n                          (map_generat (\\<lambda>x. x) Inl left_rpv xa)\n                          (map_generat (\\<lambda>x. x) Inl left_rpv xa)", "subgoal for gpv generat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>;\n     \\<not> lossless_spmf (the_gpv gpv);\n     generat \\<in> set_spmf (the_gpv gpv')\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_generat (=) (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n                       (\\<lambda>gpv gpv'a.\n                           (\\<exists>gpva.\n                               gpv =\n                               TRY left_gpv gpva ELSE left_gpv gpv' \\<and>\n                               gpv'a = left_gpv (TRY gpva ELSE gpv') \\<and>\n                               \\<I> \\<turnstile>g gpva \\<surd>) \\<or>\n                           eq_\\<I>_gpv (=) (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n                            gpv gpv'a)\n                       (map_generat (\\<lambda>x. x) Inl left_rpv generat)\n                       (map_generat (\\<lambda>x. x) Inl left_rpv generat)", "using WT2"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv' \\<surd>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>;\n     \\<not> lossless_spmf (the_gpv gpv);\n     generat \\<in> set_spmf (the_gpv gpv')\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_generat (=) (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n                       (\\<lambda>gpv gpv'a.\n                           (\\<exists>gpva.\n                               gpv =\n                               TRY left_gpv gpva ELSE left_gpv gpv' \\<and>\n                               gpv'a = left_gpv (TRY gpva ELSE gpv') \\<and>\n                               \\<I> \\<turnstile>g gpva \\<surd>) \\<or>\n                           eq_\\<I>_gpv (=) (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n                            gpv gpv'a)\n                       (map_generat (\\<lambda>x. x) Inl left_rpv generat)\n                       (map_generat (\\<lambda>x. x) Inl left_rpv generat)", "by(cases generat)(auto 4 4 dest: WT_gpvD intro!: eq_\\<I>_gpv_reflI WT_gpv_left_gpv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma try_gpv_right_gpv:\n  assumes \"\\<I>' \\<turnstile>g gpv \\<surd>\" and WT2: \"\\<I>' \\<turnstile>g gpv' \\<surd>\"\n  shows \"eq_\\<I>_gpv (=) (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') (try_gpv (right_gpv gpv) (right_gpv gpv')) (right_gpv (try_gpv gpv gpv'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv (=) (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n     (TRY right_gpv gpv ELSE right_gpv gpv') (right_gpv (TRY gpv ELSE gpv'))", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<I>' \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv (=) (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n     (TRY right_gpv gpv ELSE right_gpv gpv') (right_gpv (TRY gpv ELSE gpv'))", "apply(coinduction arbitrary: gpv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>gpva.\n       \\<I>' \\<turnstile>g gpva \\<surd> \\<Longrightarrow>\n       rel_spmf\n        (eq_\\<I>_generat (=) (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n          (\\<lambda>gpv gpv'a.\n              (\\<exists>gpva.\n                  gpv = TRY right_gpv gpva ELSE right_gpv gpv' \\<and>\n                  gpv'a = right_gpv (TRY gpva ELSE gpv') \\<and>\n                  \\<I>' \\<turnstile>g gpva \\<surd>) \\<or>\n              eq_\\<I>_gpv (=) (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') gpv gpv'a))\n        (the_gpv (TRY right_gpv gpva ELSE right_gpv gpv'))\n        (the_gpv (right_gpv (TRY gpva ELSE gpv')))", "apply(auto simp add: map_try_spmf spmf.map_comp o_def generat.map_comp spmf_rel_map intro!: rel_spmf_try_spmf rel_spmf_reflI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>gpva x.\n       \\<lbrakk>\\<I>' \\<turnstile>g gpva \\<surd>;\n        x \\<in> set_spmf (the_gpv gpva)\\<rbrakk>\n       \\<Longrightarrow> eq_\\<I>_generat (=)\n                          (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n                          (\\<lambda>gpv gpv'a.\n                              (\\<exists>gpva.\n                                  gpv =\n                                  TRY right_gpv\n gpva ELSE right_gpv gpv' \\<and>\n                                  gpv'a =\n                                  right_gpv (TRY gpva ELSE gpv') \\<and>\n                                  \\<I>' \\<turnstile>g gpva \\<surd>) \\<or>\n                              eq_\\<I>_gpv (=)\n                               (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') gpv gpv'a)\n                          (map_generat (\\<lambda>x. x) Inr\n                            (\\<lambda>x input.\n                                TRY right_rpv x input ELSE right_gpv gpv')\n                            x)\n                          (map_generat (\\<lambda>x. x) Inr\n                            (\\<lambda>x.\n                                right_rpv\n                                 (\\<lambda>input'. TRY x input' ELSE gpv'))\n                            x)\n 2. \\<And>gpva xa.\n       \\<lbrakk>\\<I>' \\<turnstile>g gpva \\<surd>;\n        \\<not> lossless_spmf (the_gpv gpva);\n        xa \\<in> set_spmf (the_gpv gpv')\\<rbrakk>\n       \\<Longrightarrow> eq_\\<I>_generat (=)\n                          (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n                          (\\<lambda>gpv gpv'a.\n                              (\\<exists>gpva.\n                                  gpv =\n                                  TRY right_gpv\n gpva ELSE right_gpv gpv' \\<and>\n                                  gpv'a =\n                                  right_gpv (TRY gpva ELSE gpv') \\<and>\n                                  \\<I>' \\<turnstile>g gpva \\<surd>) \\<or>\n                              eq_\\<I>_gpv (=)\n                               (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') gpv gpv'a)\n                          (map_generat (\\<lambda>x. x) Inr right_rpv xa)\n                          (map_generat (\\<lambda>x. x) Inr right_rpv xa)", "subgoal for gpv generat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>' \\<turnstile>g gpv \\<surd>;\n     generat \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_generat (=) (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n                       (\\<lambda>gpv gpv'a.\n                           (\\<exists>gpva.\n                               gpv =\n                               TRY right_gpv gpva ELSE right_gpv gpv' \\<and>\n                               gpv'a = right_gpv (TRY gpva ELSE gpv') \\<and>\n                               \\<I>' \\<turnstile>g gpva \\<surd>) \\<or>\n                           eq_\\<I>_gpv (=) (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n                            gpv gpv'a)\n                       (map_generat (\\<lambda>x. x) Inr\n                         (\\<lambda>x input.\n                             TRY right_rpv x input ELSE right_gpv gpv')\n                         generat)\n                       (map_generat (\\<lambda>x. x) Inr\n                         (\\<lambda>x.\n                             right_rpv\n                              (\\<lambda>input'. TRY x input' ELSE gpv'))\n                         generat)", "by(cases generat)(auto dest: WT_gpvD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>gpva xa.\n       \\<lbrakk>\\<I>' \\<turnstile>g gpva \\<surd>;\n        \\<not> lossless_spmf (the_gpv gpva);\n        xa \\<in> set_spmf (the_gpv gpv')\\<rbrakk>\n       \\<Longrightarrow> eq_\\<I>_generat (=)\n                          (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n                          (\\<lambda>gpv gpv'a.\n                              (\\<exists>gpva.\n                                  gpv =\n                                  TRY right_gpv\n gpva ELSE right_gpv gpv' \\<and>\n                                  gpv'a =\n                                  right_gpv (TRY gpva ELSE gpv') \\<and>\n                                  \\<I>' \\<turnstile>g gpva \\<surd>) \\<or>\n                              eq_\\<I>_gpv (=)\n                               (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>') gpv gpv'a)\n                          (map_generat (\\<lambda>x. x) Inr right_rpv xa)\n                          (map_generat (\\<lambda>x. x) Inr right_rpv xa)", "subgoal for gpv generat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>' \\<turnstile>g gpv \\<surd>;\n     \\<not> lossless_spmf (the_gpv gpv);\n     generat \\<in> set_spmf (the_gpv gpv')\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_generat (=) (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n                       (\\<lambda>gpv gpv'a.\n                           (\\<exists>gpva.\n                               gpv =\n                               TRY right_gpv gpva ELSE right_gpv gpv' \\<and>\n                               gpv'a = right_gpv (TRY gpva ELSE gpv') \\<and>\n                               \\<I>' \\<turnstile>g gpva \\<surd>) \\<or>\n                           eq_\\<I>_gpv (=) (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n                            gpv gpv'a)\n                       (map_generat (\\<lambda>x. x) Inr right_rpv generat)\n                       (map_generat (\\<lambda>x. x) Inr right_rpv generat)", "using WT2"], ["proof (prove)\nusing this:\n  \\<I>' \\<turnstile>g gpv' \\<surd>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>' \\<turnstile>g gpv \\<surd>;\n     \\<not> lossless_spmf (the_gpv gpv);\n     generat \\<in> set_spmf (the_gpv gpv')\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_generat (=) (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n                       (\\<lambda>gpv gpv'a.\n                           (\\<exists>gpva.\n                               gpv =\n                               TRY right_gpv gpva ELSE right_gpv gpv' \\<and>\n                               gpv'a = right_gpv (TRY gpva ELSE gpv') \\<and>\n                               \\<I>' \\<turnstile>g gpva \\<surd>) \\<or>\n                           eq_\\<I>_gpv (=) (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')\n                            gpv gpv'a)\n                       (map_generat (\\<lambda>x. x) Inr right_rpv generat)\n                       (map_generat (\\<lambda>x. x) Inr right_rpv generat)", "by(cases generat)(auto 4 4 dest: WT_gpvD intro!: eq_\\<I>_gpv_reflI WT_gpv_right_gpv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bind_try_Done_Fail: \"bind_gpv (TRY gpv ELSE Done x) f = bind_gpv gpv f\" if \"f x = Fail\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY gpv ELSE Done x \\<bind> f = gpv \\<bind> f", "apply(coinduction arbitrary: gpv rule: gpv.coinduct_strong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>gpva.\n       rel_spmf\n        (rel_generat (=) (=)\n          (rel_fun (=)\n            (\\<lambda>gpv gpv'.\n                (\\<exists>gpva.\n                    gpv = TRY gpva ELSE Done x \\<bind> f \\<and>\n                    gpv' = gpva \\<bind> f) \\<or>\n                gpv = gpv')))\n        (the_gpv (TRY gpva ELSE Done x \\<bind> f))\n        (the_gpv (gpva \\<bind> f))", "apply(auto simp del: bind_gpv_sel' simp add: bind_gpv.sel map_bind_spmf bind_map_spmf try_spmf_def bind_spmf_def map_bind_pmf bind_assoc_pmf bind_map_pmf bind_return_pmf spmf.map_comp o_def that rel_fun_def intro!: rel_pmf_bind_reflI rel_spmf_reflI generat.rel_refl_strong split!: option.split generat.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inline_map_gpv':\n  \"inline callee (map_gpv' f g h gpv) s = \n   map_gpv (apfst f) id (inline (map_fun id (map_fun g (map_gpv (apfst h) id)) callee) gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inline callee (map_gpv' f g h gpv) s =\n    map_gpv (apfst f) id\n     (inline (map_fun id (map_fun g (map_gpv (apfst h) id)) callee) gpv s)", "using inline_parametric'[where S=\"(=)\" and C=\"BNF_Def.Grp UNIV g\" and R=\"conversep (BNF_Def.Grp UNIV h)\" and A=\"BNF_Def.Grp UNIV f\" and C'=\"(=)\" and R'=\"(=)\"]"], ["proof (prove)\nusing this:\n  rel_fun\n   (rel_fun (=)\n     (rel_fun (BNF_Def.Grp UNIV g)\n       (rel_gpv'' (rel_prod (BNF_Def.Grp UNIV h)\\<inverse>\\<inverse> (=))\n         (=) (=))))\n   (rel_fun\n     (rel_gpv'' (BNF_Def.Grp UNIV f) (BNF_Def.Grp UNIV g)\n       (BNF_Def.Grp UNIV h)\\<inverse>\\<inverse>)\n     (rel_fun (=) (rel_gpv'' (rel_prod (BNF_Def.Grp UNIV f) (=)) (=) (=))))\n   inline inline\n\ngoal (1 subgoal):\n 1. inline callee (map_gpv' f g h gpv) s =\n    map_gpv (apfst f) id\n     (inline (map_fun id (map_fun g (map_gpv (apfst h) id)) callee) gpv s)", "apply(subst (asm) (2 3 8) eq_alt_conversep)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_fun (=)\n       (rel_fun (BNF_Def.Grp UNIV g)\n         (rel_gpv''\n           (rel_prod (BNF_Def.Grp UNIV h)\\<inverse>\\<inverse>\n             (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse>)\n           (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse> (=))))\n     (rel_fun\n       (rel_gpv'' (BNF_Def.Grp UNIV f) (BNF_Def.Grp UNIV g)\n         (BNF_Def.Grp UNIV h)\\<inverse>\\<inverse>)\n       (rel_fun (=)\n         (rel_gpv'' (rel_prod (BNF_Def.Grp UNIV f) (=)) (=)\n           (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse>)))\n     inline inline \\<Longrightarrow>\n    inline callee (map_gpv' f g h gpv) s =\n    map_gpv (apfst f) id\n     (inline (map_fun id (map_fun g (map_gpv (apfst h) id)) callee) gpv s)", "apply(subst (asm) (1 3 4 5) eq_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_fun (BNF_Def.Grp UNIV id)\n       (rel_fun (BNF_Def.Grp UNIV g)\n         (rel_gpv''\n           (rel_prod (BNF_Def.Grp UNIV h)\\<inverse>\\<inverse>\n             (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse>)\n           (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse> (=))))\n     (rel_fun\n       (rel_gpv'' (BNF_Def.Grp UNIV f) (BNF_Def.Grp UNIV g)\n         (BNF_Def.Grp UNIV h)\\<inverse>\\<inverse>)\n       (rel_fun (BNF_Def.Grp UNIV id)\n         (rel_gpv'' (rel_prod (BNF_Def.Grp UNIV f) (BNF_Def.Grp UNIV id))\n           (BNF_Def.Grp UNIV id)\n           (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse>)))\n     inline inline \\<Longrightarrow>\n    inline callee (map_gpv' f g h gpv) s =\n    map_gpv (apfst f) id\n     (inline (map_fun id (map_fun g (map_gpv (apfst h) id)) callee) gpv s)", "apply(subst (asm) (1) eq_alt_conversep2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_fun (BNF_Def.Grp UNIV id)\n       (rel_fun (BNF_Def.Grp UNIV g)\n         (rel_gpv''\n           (rel_prod (BNF_Def.Grp UNIV h)\\<inverse>\\<inverse>\n             (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse>)\n           (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse>\n           (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse>\\<inverse>\\<inverse>)))\n     (rel_fun\n       (rel_gpv'' (BNF_Def.Grp UNIV f) (BNF_Def.Grp UNIV g)\n         (BNF_Def.Grp UNIV h)\\<inverse>\\<inverse>)\n       (rel_fun (BNF_Def.Grp UNIV id)\n         (rel_gpv'' (rel_prod (BNF_Def.Grp UNIV f) (BNF_Def.Grp UNIV id))\n           (BNF_Def.Grp UNIV id)\n           (BNF_Def.Grp UNIV id)\\<inverse>\\<inverse>)))\n     inline inline \\<Longrightarrow>\n    inline callee (map_gpv' f g h gpv) s =\n    map_gpv (apfst f) id\n     (inline (map_fun id (map_fun g (map_gpv (apfst h) id)) callee) gpv s)", "apply(unfold prod.rel_conversep rel_gpv''_conversep prod.rel_Grp rel_gpv''_Grp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun\n     (rel_fun (BNF_Def.Grp UNIV id)\n       (rel_fun (BNF_Def.Grp UNIV g)\n         (BNF_Def.Grp\n           {x. results_gpv (\\<I>_uniform UNIV (range id)) x\n               \\<subseteq> {x. Basic_BNFs.fsts x \\<subseteq> UNIV \\<and>\n                               Basic_BNFs.snds x \\<subseteq> UNIV} \\<and>\n               outs_gpv (\\<I>_uniform UNIV (range id)) x \\<subseteq> UNIV}\n           (map_gpv' (map_prod h id) id id))\\<inverse>\\<inverse>))\n     (rel_fun\n       (BNF_Def.Grp\n         {x. results_gpv (\\<I>_uniform UNIV (range h)) x\n             \\<subseteq> UNIV \\<and>\n             outs_gpv (\\<I>_uniform UNIV (range h)) x \\<subseteq> UNIV}\n         (map_gpv' f g h))\n       (rel_fun (BNF_Def.Grp UNIV id)\n         (BNF_Def.Grp\n           {x. results_gpv (\\<I>_uniform UNIV (range id)) x\n               \\<subseteq> {x. Basic_BNFs.fsts x \\<subseteq> UNIV \\<and>\n                               Basic_BNFs.snds x \\<subseteq> UNIV} \\<and>\n               outs_gpv (\\<I>_uniform UNIV (range id)) x \\<subseteq> UNIV}\n           (map_gpv' (map_prod f id) id id))))\n     inline inline \\<Longrightarrow>\n    inline callee (map_gpv' f g h gpv) s =\n    map_gpv (apfst f) id\n     (inline (map_fun id (map_fun g (map_gpv (apfst h) id)) callee) gpv s)", "apply(force simp add: rel_fun_def Grp_def map_gpv_conv_map_gpv' map_fun_def[abs_def] o_def apfst_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma interaction_bound_try_gpv:\n  fixes \"consider\" defines \"ib \\<equiv> interaction_bound consider\"\n  shows \"interaction_bound consider (try_gpv gpv gpv') \\<le> ib gpv + ib gpv'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_bound consider (TRY gpv ELSE gpv') \\<le> ib gpv + ib gpv'", "proof(induction arbitrary: gpv gpv' rule: interaction_bound_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a. \\<forall>x xa. a (TRY x ELSE xa) \\<le> ib x + ib xa)\n 2. \\<And>gpv gpv'. 0 \\<le> ib gpv + ib gpv'\n 3. \\<And>interaction_bound' gpv gpv'.\n       \\<lbrakk>\\<And>gpv gpv'.\n                   interaction_bound' (TRY gpv ELSE gpv')\n                   \\<le> ib gpv + ib gpv';\n        \\<And>gpv.\n           interaction_bound' gpv \\<le> interaction_bound consider gpv;\n        \\<And>gpv.\n           interaction_bound' gpv\n           \\<le> (\\<Squnion>generat\\<in>set_spmf (the_gpv gpv).\n                     case generat of Pure x \\<Rightarrow> 0\n                     | IO out c \\<Rightarrow>\n                         if consider out\n                         then eSuc\n                               (\\<Squnion>input.\n                                   interaction_bound' (c input))\n                         else \\<Squnion>input.\n                                 interaction_bound' (c input))\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> (case_generat (\\<lambda>x. 0)\n(\\<lambda>out c.\n    if consider out\n    then eSuc (\\<Squnion>input. interaction_bound' (c input))\n    else \\<Squnion>input. interaction_bound' (c input)) `\n                                     set_spmf (the_gpv (TRY gpv ELSE gpv')))\n                         \\<le> ib gpv + ib gpv'", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a. \\<forall>x xa. a (TRY x ELSE xa) \\<le> ib x + ib xa)\n 2. \\<And>gpv gpv'. 0 \\<le> ib gpv + ib gpv'\n 3. \\<And>interaction_bound' gpv gpv'.\n       \\<lbrakk>\\<And>gpv gpv'.\n                   interaction_bound' (TRY gpv ELSE gpv')\n                   \\<le> ib gpv + ib gpv';\n        \\<And>gpv.\n           interaction_bound' gpv \\<le> interaction_bound consider gpv;\n        \\<And>gpv.\n           interaction_bound' gpv\n           \\<le> (\\<Squnion>generat\\<in>set_spmf (the_gpv gpv).\n                     case generat of Pure x \\<Rightarrow> 0\n                     | IO out c \\<Rightarrow>\n                         if consider out\n                         then eSuc\n                               (\\<Squnion>input.\n                                   interaction_bound' (c input))\n                         else \\<Squnion>input.\n                                 interaction_bound' (c input))\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> (case_generat (\\<lambda>x. 0)\n(\\<lambda>out c.\n    if consider out\n    then eSuc (\\<Squnion>input. interaction_bound' (c input))\n    else \\<Squnion>input. interaction_bound' (c input)) `\n                                     set_spmf (the_gpv (TRY gpv ELSE gpv')))\n                         \\<le> ib gpv + ib gpv'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp.admissible\n     (\\<lambda>a. \\<forall>x xa. a (TRY x ELSE xa) \\<le> ib x + ib xa)", "by simp"], ["proof (state)\nthis:\n  lfp.admissible\n   (\\<lambda>a. \\<forall>x xa. a (TRY x ELSE xa) \\<le> ib x + ib xa)\n\ngoal (2 subgoals):\n 1. \\<And>gpv gpv'. 0 \\<le> ib gpv + ib gpv'\n 2. \\<And>interaction_bound' gpv gpv'.\n       \\<lbrakk>\\<And>gpv gpv'.\n                   interaction_bound' (TRY gpv ELSE gpv')\n                   \\<le> ib gpv + ib gpv';\n        \\<And>gpv.\n           interaction_bound' gpv \\<le> interaction_bound consider gpv;\n        \\<And>gpv.\n           interaction_bound' gpv\n           \\<le> (\\<Squnion>generat\\<in>set_spmf (the_gpv gpv).\n                     case generat of Pure x \\<Rightarrow> 0\n                     | IO out c \\<Rightarrow>\n                         if consider out\n                         then eSuc\n                               (\\<Squnion>input.\n                                   interaction_bound' (c input))\n                         else \\<Squnion>input.\n                                 interaction_bound' (c input))\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> (case_generat (\\<lambda>x. 0)\n(\\<lambda>out c.\n    if consider out\n    then eSuc (\\<Squnion>input. interaction_bound' (c input))\n    else \\<Squnion>input. interaction_bound' (c input)) `\n                                     set_spmf (the_gpv (TRY gpv ELSE gpv')))\n                         \\<le> ib gpv + ib gpv'", "case bottom"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>gpv gpv'. 0 \\<le> ib gpv + ib gpv'\n 2. \\<And>interaction_bound' gpv gpv'.\n       \\<lbrakk>\\<And>gpv gpv'.\n                   interaction_bound' (TRY gpv ELSE gpv')\n                   \\<le> ib gpv + ib gpv';\n        \\<And>gpv.\n           interaction_bound' gpv \\<le> interaction_bound consider gpv;\n        \\<And>gpv.\n           interaction_bound' gpv\n           \\<le> (\\<Squnion>generat\\<in>set_spmf (the_gpv gpv).\n                     case generat of Pure x \\<Rightarrow> 0\n                     | IO out c \\<Rightarrow>\n                         if consider out\n                         then eSuc\n                               (\\<Squnion>input.\n                                   interaction_bound' (c input))\n                         else \\<Squnion>input.\n                                 interaction_bound' (c input))\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> (case_generat (\\<lambda>x. 0)\n(\\<lambda>out c.\n    if consider out\n    then eSuc (\\<Squnion>input. interaction_bound' (c input))\n    else \\<Squnion>input. interaction_bound' (c input)) `\n                                     set_spmf (the_gpv (TRY gpv ELSE gpv')))\n                         \\<le> ib gpv + ib gpv'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> ib gpv + ib gpv'", "by simp"], ["proof (state)\nthis:\n  0 \\<le> ib gpv + ib gpv'\n\ngoal (1 subgoal):\n 1. \\<And>interaction_bound' gpv gpv'.\n       \\<lbrakk>\\<And>gpv gpv'.\n                   interaction_bound' (TRY gpv ELSE gpv')\n                   \\<le> ib gpv + ib gpv';\n        \\<And>gpv.\n           interaction_bound' gpv \\<le> interaction_bound consider gpv;\n        \\<And>gpv.\n           interaction_bound' gpv\n           \\<le> (\\<Squnion>generat\\<in>set_spmf (the_gpv gpv).\n                     case generat of Pure x \\<Rightarrow> 0\n                     | IO out c \\<Rightarrow>\n                         if consider out\n                         then eSuc\n                               (\\<Squnion>input.\n                                   interaction_bound' (c input))\n                         else \\<Squnion>input.\n                                 interaction_bound' (c input))\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> (case_generat (\\<lambda>x. 0)\n(\\<lambda>out c.\n    if consider out\n    then eSuc (\\<Squnion>input. interaction_bound' (c input))\n    else \\<Squnion>input. interaction_bound' (c input)) `\n                                     set_spmf (the_gpv (TRY gpv ELSE gpv')))\n                         \\<le> ib gpv + ib gpv'", "case (step interaction_bound')"], ["proof (state)\nthis:\n  interaction_bound' (TRY ?gpv ELSE ?gpv') \\<le> ib ?gpv + ib ?gpv'\n  interaction_bound' ?gpv \\<le> interaction_bound consider ?gpv\n  interaction_bound' ?gpv\n  \\<le> (\\<Squnion>generat\\<in>set_spmf (the_gpv ?gpv).\n            case generat of Pure x \\<Rightarrow> 0\n            | IO out c \\<Rightarrow>\n                if consider out\n                then eSuc (\\<Squnion>input. interaction_bound' (c input))\n                else \\<Squnion>input. interaction_bound' (c input))\n\ngoal (1 subgoal):\n 1. \\<And>interaction_bound' gpv gpv'.\n       \\<lbrakk>\\<And>gpv gpv'.\n                   interaction_bound' (TRY gpv ELSE gpv')\n                   \\<le> ib gpv + ib gpv';\n        \\<And>gpv.\n           interaction_bound' gpv \\<le> interaction_bound consider gpv;\n        \\<And>gpv.\n           interaction_bound' gpv\n           \\<le> (\\<Squnion>generat\\<in>set_spmf (the_gpv gpv).\n                     case generat of Pure x \\<Rightarrow> 0\n                     | IO out c \\<Rightarrow>\n                         if consider out\n                         then eSuc\n                               (\\<Squnion>input.\n                                   interaction_bound' (c input))\n                         else \\<Squnion>input.\n                                 interaction_bound' (c input))\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> (case_generat (\\<lambda>x. 0)\n(\\<lambda>out c.\n    if consider out\n    then eSuc (\\<Squnion>input. interaction_bound' (c input))\n    else \\<Squnion>input. interaction_bound' (c input)) `\n                                     set_spmf (the_gpv (TRY gpv ELSE gpv')))\n                         \\<le> ib gpv + ib gpv'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>generat\\<in>set_spmf (the_gpv (TRY gpv ELSE gpv')).\n        case generat of Pure x \\<Rightarrow> 0\n        | IO out c \\<Rightarrow>\n            if consider out\n            then eSuc (\\<Squnion>input. interaction_bound' (c input))\n            else \\<Squnion>input. interaction_bound' (c input))\n    \\<le> ib gpv + ib gpv'", "unfolding ib_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>generat\\<in>set_spmf (the_gpv (TRY gpv ELSE gpv')).\n        case generat of Pure x \\<Rightarrow> 0\n        | IO out c \\<Rightarrow>\n            if consider out\n            then eSuc (\\<Squnion>input. interaction_bound' (c input))\n            else \\<Squnion>input. interaction_bound' (c input))\n    \\<le> interaction_bound consider gpv + interaction_bound consider gpv'", "apply(clarsimp simp add: generat.map_comp image_image o_def case_map_generat cong del: generat.case_cong split!: if_split generat.split intro!: SUP_least)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x21 c'.\n       \\<lbrakk>lossless_spmf (the_gpv gpv);\n        IO x21 c' \\<in> set_spmf (the_gpv gpv); consider x21\\<rbrakk>\n       \\<Longrightarrow> eSuc\n                          (\\<Squnion>input.\n                              interaction_bound' (TRY c' input ELSE gpv'))\n                         \\<le> interaction_bound consider gpv +\n                               interaction_bound consider gpv'\n 2. \\<And>x21 c' input.\n       \\<lbrakk>lossless_spmf (the_gpv gpv);\n        IO x21 c' \\<in> set_spmf (the_gpv gpv); \\<not> consider x21\\<rbrakk>\n       \\<Longrightarrow> interaction_bound' (TRY c' input ELSE gpv')\n                         \\<le> interaction_bound consider gpv +\n                               interaction_bound consider gpv'\n 3. \\<And>x21 c'.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21 c' \\<in> set_spmf (the_gpv gpv); consider x21\\<rbrakk>\n       \\<Longrightarrow> eSuc\n                          (\\<Squnion>input.\n                              interaction_bound' (TRY c' input ELSE gpv'))\n                         \\<le> interaction_bound consider gpv +\n                               interaction_bound consider gpv'\n 4. \\<And>x21 c' input.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21 c' \\<in> set_spmf (the_gpv gpv); \\<not> consider x21\\<rbrakk>\n       \\<Longrightarrow> interaction_bound' (TRY c' input ELSE gpv')\n                         \\<le> interaction_bound consider gpv +\n                               interaction_bound consider gpv'\n 5. \\<And>x21 x22.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv'); consider x21\\<rbrakk>\n       \\<Longrightarrow> eSuc\n                          (\\<Squnion>input. interaction_bound' (x22 input))\n                         \\<le> interaction_bound consider gpv +\n                               interaction_bound consider gpv'\n 6. \\<And>x21 x22 input.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv');\n        \\<not> consider x21\\<rbrakk>\n       \\<Longrightarrow> interaction_bound' (x22 input)\n                         \\<le> interaction_bound consider gpv +\n                               interaction_bound consider gpv'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input.\n                           interaction_bound' (TRY c'_ input ELSE gpv'))\n                      \\<le> interaction_bound consider gpv +\n                            interaction_bound consider gpv'", "apply(subst interaction_bound.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input.\n                           interaction_bound' (TRY c'_ input ELSE gpv'))\n                      \\<le> \\<Squnion> (case_generat (\\<lambda>x. 0)\n   (\\<lambda>out c.\n       if consider out\n       then eSuc (\\<Squnion>input. interaction_bound consider (c input))\n       else \\<Squnion>input. interaction_bound consider (c input)) `\n  set_spmf (the_gpv gpv)) +\n                            interaction_bound consider gpv'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input.\n                           interaction_bound' (TRY c'_ input ELSE gpv'))\n                      \\<le> (\\<Squnion>x\\<in>set_spmf (the_gpv gpv).\n                                case x of Pure x \\<Rightarrow> 0\n                                | IO out c \\<Rightarrow>\n                                    if consider out\n                                    then eSuc\n    (\\<Squnion>input. interaction_bound consider (c input))\n                                    else \\<Squnion>input.\n      interaction_bound consider (c input)) +\n                            interaction_bound consider gpv'", "apply(subst Sup_image_eadd1[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> case_generat (\\<lambda>x. 0)\n                       (\\<lambda>out c.\n                           if consider out\n                           then eSuc\n                                 (\\<Squnion>input.\n                                     interaction_bound consider (c input))\n                           else \\<Squnion>input.\n                                   interaction_bound consider (c input)) `\n                      set_spmf (the_gpv gpv) \\<noteq>\n                      {}\n 2. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input.\n                           interaction_bound' (TRY c'_ input ELSE gpv'))\n                      \\<le> (\\<Squnion>y\\<in>case_generat (\\<lambda>x. 0)\n        (\\<lambda>out c.\n            if consider out\n            then eSuc\n                  (\\<Squnion>input. interaction_bound consider (c input))\n            else \\<Squnion>input. interaction_bound consider (c input)) `\n       set_spmf (the_gpv gpv).\n                                y + interaction_bound consider gpv')", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input.\n                           interaction_bound' (TRY c'_ input ELSE gpv'))\n                      \\<le> (\\<Squnion>y\\<in>case_generat (\\<lambda>x. 0)\n        (\\<lambda>out c.\n            if consider out\n            then eSuc\n                  (\\<Squnion>input. interaction_bound consider (c input))\n            else \\<Squnion>input. interaction_bound consider (c input)) `\n       set_spmf (the_gpv gpv).\n                                y + interaction_bound consider gpv')", "apply(rule SUP_upper2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?y7\n                      \\<in> case_generat (\\<lambda>x. 0)\n                             (\\<lambda>out c.\n                                 if consider out\n                                 then eSuc\n (\\<Squnion>input. interaction_bound consider (c input))\n                                 else \\<Squnion>input.\n   interaction_bound consider (c input)) `\n                            set_spmf (the_gpv gpv)\n 2. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input.\n                           interaction_bound' (TRY c'_ input ELSE gpv'))\n                      \\<le> ?y7 + interaction_bound consider gpv'", "apply(rule rev_image_eqI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?x10 \\<in> set_spmf (the_gpv gpv)\n 2. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?y7 =\n                      (case ?x10 of Pure x \\<Rightarrow> 0\n                       | IO out c \\<Rightarrow>\n                           if consider out\n                           then eSuc\n                                 (\\<Squnion>input.\n                                     interaction_bound consider (c input))\n                           else \\<Squnion>input.\n                                   interaction_bound consider (c input))\n 3. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input.\n                           interaction_bound' (TRY c'_ input ELSE gpv'))\n                      \\<le> ?y7 + interaction_bound consider gpv'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?y7 =\n                      (case IO x21_ c'_ of Pure x \\<Rightarrow> 0\n                       | IO out c \\<Rightarrow>\n                           if consider out\n                           then eSuc\n                                 (\\<Squnion>input.\n                                     interaction_bound consider (c input))\n                           else \\<Squnion>input.\n                                   interaction_bound consider (c input))\n 2. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input.\n                           interaction_bound' (TRY c'_ input ELSE gpv'))\n                      \\<le> ?y7 + interaction_bound consider gpv'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input.\n                           interaction_bound' (TRY c'_ input ELSE gpv'))\n                      \\<le> eSuc\n                             (\\<Squnion>input.\n                                 interaction_bound consider (c'_ input)) +\n                            interaction_bound consider gpv'", "apply(simp add: iadd_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> (\\<Squnion>input.\n                          interaction_bound' (TRY c'_ input ELSE gpv'))\n                      \\<le> (\\<Squnion>input.\n                                interaction_bound consider (c'_ input)) +\n                            interaction_bound consider gpv'", "apply(subst Sup_image_eadd1[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> range\n                       (\\<lambda>input.\n                           interaction_bound consider (c'_ input)) \\<noteq>\n                      {}\n 2. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> (\\<Squnion>input.\n                          interaction_bound' (TRY c'_ input ELSE gpv'))\n                      \\<le> (\\<Squnion>y\\<in>range\n        (\\<lambda>input. interaction_bound consider (c'_ input)).\n                                y + interaction_bound consider gpv')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> (\\<Squnion>input.\n                          interaction_bound' (TRY c'_ input ELSE gpv'))\n                      \\<le> (\\<Squnion>y\\<in>range\n        (\\<lambda>input. interaction_bound consider (c'_ input)).\n                                y + interaction_bound consider gpv')", "apply(rule SUP_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>input.\n       \\<lbrakk>lossless_spmf (the_gpv gpv);\n        IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_;\n        input \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>range\n   (\\<lambda>input. interaction_bound consider (c'_ input)).\n                            interaction_bound' (TRY c'_ input ELSE gpv')\n                            \\<le> m + interaction_bound consider gpv'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>input.\n       \\<lbrakk>lossless_spmf (the_gpv gpv);\n        IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            interaction_bound' (TRY c'_ input ELSE gpv')\n                            \\<le> interaction_bound consider (c'_ m) +\n                                  interaction_bound consider gpv'", "apply(rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>input.\n       \\<lbrakk>lossless_spmf (the_gpv gpv);\n        IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n       \\<Longrightarrow> interaction_bound' (TRY c'_ input ELSE gpv')\n                         \\<le> interaction_bound consider\n                                (c'_ (?m16 input)) +\n                               interaction_bound consider gpv'", "apply(rule step.IH[unfolded ib_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x21 c' input.\n       \\<lbrakk>lossless_spmf (the_gpv gpv);\n        IO x21 c' \\<in> set_spmf (the_gpv gpv); \\<not> consider x21\\<rbrakk>\n       \\<Longrightarrow> interaction_bound' (TRY c' input ELSE gpv')\n                         \\<le> interaction_bound consider gpv +\n                               interaction_bound consider gpv'\n 2. \\<And>x21 c'.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21 c' \\<in> set_spmf (the_gpv gpv); consider x21\\<rbrakk>\n       \\<Longrightarrow> eSuc\n                          (\\<Squnion>input.\n                              interaction_bound' (TRY c' input ELSE gpv'))\n                         \\<le> interaction_bound consider gpv +\n                               interaction_bound consider gpv'\n 3. \\<And>x21 c' input.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21 c' \\<in> set_spmf (the_gpv gpv); \\<not> consider x21\\<rbrakk>\n       \\<Longrightarrow> interaction_bound' (TRY c' input ELSE gpv')\n                         \\<le> interaction_bound consider gpv +\n                               interaction_bound consider gpv'\n 4. \\<And>x21 x22.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv'); consider x21\\<rbrakk>\n       \\<Longrightarrow> eSuc\n                          (\\<Squnion>input. interaction_bound' (x22 input))\n                         \\<le> interaction_bound consider gpv +\n                               interaction_bound consider gpv'\n 5. \\<And>x21 x22 input.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv');\n        \\<not> consider x21\\<rbrakk>\n       \\<Longrightarrow> interaction_bound' (x22 input)\n                         \\<le> interaction_bound consider gpv +\n                               interaction_bound consider gpv'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> interaction_bound consider gpv +\n                            interaction_bound consider gpv'", "apply(subst interaction_bound.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> \\<Squnion> (case_generat (\\<lambda>x. 0)\n   (\\<lambda>out c.\n       if consider out\n       then eSuc (\\<Squnion>input. interaction_bound consider (c input))\n       else \\<Squnion>input. interaction_bound consider (c input)) `\n  set_spmf (the_gpv gpv)) +\n                            interaction_bound consider gpv'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> (\\<Squnion>x\\<in>set_spmf (the_gpv gpv).\n                                case x of Pure x \\<Rightarrow> 0\n                                | IO out c \\<Rightarrow>\n                                    if consider out\n                                    then eSuc\n    (\\<Squnion>input. interaction_bound consider (c input))\n                                    else \\<Squnion>input.\n      interaction_bound consider (c input)) +\n                            interaction_bound consider gpv'", "apply(subst Sup_image_eadd1[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> case_generat (\\<lambda>x. 0)\n                       (\\<lambda>out c.\n                           if consider out\n                           then eSuc\n                                 (\\<Squnion>input.\n                                     interaction_bound consider (c input))\n                           else \\<Squnion>input.\n                                   interaction_bound consider (c input)) `\n                      set_spmf (the_gpv gpv) \\<noteq>\n                      {}\n 2. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> (\\<Squnion>y\\<in>case_generat (\\<lambda>x. 0)\n        (\\<lambda>out c.\n            if consider out\n            then eSuc\n                  (\\<Squnion>input. interaction_bound consider (c input))\n            else \\<Squnion>input. interaction_bound consider (c input)) `\n       set_spmf (the_gpv gpv).\n                                y + interaction_bound consider gpv')", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> (\\<Squnion>y\\<in>case_generat (\\<lambda>x. 0)\n        (\\<lambda>out c.\n            if consider out\n            then eSuc\n                  (\\<Squnion>input. interaction_bound consider (c input))\n            else \\<Squnion>input. interaction_bound consider (c input)) `\n       set_spmf (the_gpv gpv).\n                                y + interaction_bound consider gpv')", "apply(rule SUP_upper2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?y7\n                      \\<in> case_generat (\\<lambda>x. 0)\n                             (\\<lambda>out c.\n                                 if consider out\n                                 then eSuc\n (\\<Squnion>input. interaction_bound consider (c input))\n                                 else \\<Squnion>input.\n   interaction_bound consider (c input)) `\n                            set_spmf (the_gpv gpv)\n 2. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> ?y7 + interaction_bound consider gpv'", "apply(rule rev_image_eqI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?x10 \\<in> set_spmf (the_gpv gpv)\n 2. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?y7 =\n                      (case ?x10 of Pure x \\<Rightarrow> 0\n                       | IO out c \\<Rightarrow>\n                           if consider out\n                           then eSuc\n                                 (\\<Squnion>input.\n                                     interaction_bound consider (c input))\n                           else \\<Squnion>input.\n                                   interaction_bound consider (c input))\n 3. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> ?y7 + interaction_bound consider gpv'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?y7 =\n                      (case IO x21_ c'_ of Pure x \\<Rightarrow> 0\n                       | IO out c \\<Rightarrow>\n                           if consider out\n                           then eSuc\n                                 (\\<Squnion>input.\n                                     interaction_bound consider (c input))\n                           else \\<Squnion>input.\n                                   interaction_bound consider (c input))\n 2. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> ?y7 + interaction_bound consider gpv'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> (\\<Squnion>input.\n                                interaction_bound consider (c'_ input)) +\n                            interaction_bound consider gpv'", "apply(subst Sup_image_eadd1[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> range\n                       (\\<lambda>input.\n                           interaction_bound consider (c'_ input)) \\<noteq>\n                      {}\n 2. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> (\\<Squnion>y\\<in>range\n        (\\<lambda>input. interaction_bound consider (c'_ input)).\n                                y + interaction_bound consider gpv')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> (\\<Squnion>y\\<in>range\n        (\\<lambda>input. interaction_bound consider (c'_ input)).\n                                y + interaction_bound consider gpv')", "apply(rule SUP_upper2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?y14\n                      \\<in> range\n                             (\\<lambda>input.\n                                 interaction_bound consider (c'_ input))\n 2. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> ?y14 + interaction_bound consider gpv'", "apply(rule rev_image_eqI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?x17 \\<in> UNIV\n 2. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?y14 = interaction_bound consider (c'_ ?x17)\n 3. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> ?y14 + interaction_bound consider gpv'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?y14 = interaction_bound consider (c'_ ?x17)\n 2. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> ?y14 + interaction_bound consider gpv'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> interaction_bound consider (c'_ ?x17) +\n                            interaction_bound consider gpv'", "apply(rule step.IH[unfolded ib_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x21 c'.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21 c' \\<in> set_spmf (the_gpv gpv); consider x21\\<rbrakk>\n       \\<Longrightarrow> eSuc\n                          (\\<Squnion>input.\n                              interaction_bound' (TRY c' input ELSE gpv'))\n                         \\<le> interaction_bound consider gpv +\n                               interaction_bound consider gpv'\n 2. \\<And>x21 c' input.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21 c' \\<in> set_spmf (the_gpv gpv); \\<not> consider x21\\<rbrakk>\n       \\<Longrightarrow> interaction_bound' (TRY c' input ELSE gpv')\n                         \\<le> interaction_bound consider gpv +\n                               interaction_bound consider gpv'\n 3. \\<And>x21 x22.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv'); consider x21\\<rbrakk>\n       \\<Longrightarrow> eSuc\n                          (\\<Squnion>input. interaction_bound' (x22 input))\n                         \\<le> interaction_bound consider gpv +\n                               interaction_bound consider gpv'\n 4. \\<And>x21 x22 input.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv');\n        \\<not> consider x21\\<rbrakk>\n       \\<Longrightarrow> interaction_bound' (x22 input)\n                         \\<le> interaction_bound consider gpv +\n                               interaction_bound consider gpv'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input.\n                           interaction_bound' (TRY c'_ input ELSE gpv'))\n                      \\<le> interaction_bound consider gpv +\n                            interaction_bound consider gpv'", "apply(subst interaction_bound.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input.\n                           interaction_bound' (TRY c'_ input ELSE gpv'))\n                      \\<le> \\<Squnion> (case_generat (\\<lambda>x. 0)\n   (\\<lambda>out c.\n       if consider out\n       then eSuc (\\<Squnion>input. interaction_bound consider (c input))\n       else \\<Squnion>input. interaction_bound consider (c input)) `\n  set_spmf (the_gpv gpv)) +\n                            interaction_bound consider gpv'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input.\n                           interaction_bound' (TRY c'_ input ELSE gpv'))\n                      \\<le> (\\<Squnion>x\\<in>set_spmf (the_gpv gpv).\n                                case x of Pure x \\<Rightarrow> 0\n                                | IO out c \\<Rightarrow>\n                                    if consider out\n                                    then eSuc\n    (\\<Squnion>input. interaction_bound consider (c input))\n                                    else \\<Squnion>input.\n      interaction_bound consider (c input)) +\n                            interaction_bound consider gpv'", "apply(subst Sup_image_eadd1[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> case_generat (\\<lambda>x. 0)\n                       (\\<lambda>out c.\n                           if consider out\n                           then eSuc\n                                 (\\<Squnion>input.\n                                     interaction_bound consider (c input))\n                           else \\<Squnion>input.\n                                   interaction_bound consider (c input)) `\n                      set_spmf (the_gpv gpv) \\<noteq>\n                      {}\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input.\n                           interaction_bound' (TRY c'_ input ELSE gpv'))\n                      \\<le> (\\<Squnion>y\\<in>case_generat (\\<lambda>x. 0)\n        (\\<lambda>out c.\n            if consider out\n            then eSuc\n                  (\\<Squnion>input. interaction_bound consider (c input))\n            else \\<Squnion>input. interaction_bound consider (c input)) `\n       set_spmf (the_gpv gpv).\n                                y + interaction_bound consider gpv')", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input.\n                           interaction_bound' (TRY c'_ input ELSE gpv'))\n                      \\<le> (\\<Squnion>y\\<in>case_generat (\\<lambda>x. 0)\n        (\\<lambda>out c.\n            if consider out\n            then eSuc\n                  (\\<Squnion>input. interaction_bound consider (c input))\n            else \\<Squnion>input. interaction_bound consider (c input)) `\n       set_spmf (the_gpv gpv).\n                                y + interaction_bound consider gpv')", "apply(rule SUP_upper2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?y7\n                      \\<in> case_generat (\\<lambda>x. 0)\n                             (\\<lambda>out c.\n                                 if consider out\n                                 then eSuc\n (\\<Squnion>input. interaction_bound consider (c input))\n                                 else \\<Squnion>input.\n   interaction_bound consider (c input)) `\n                            set_spmf (the_gpv gpv)\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input.\n                           interaction_bound' (TRY c'_ input ELSE gpv'))\n                      \\<le> ?y7 + interaction_bound consider gpv'", "apply(rule rev_image_eqI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?x10 \\<in> set_spmf (the_gpv gpv)\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?y7 =\n                      (case ?x10 of Pure x \\<Rightarrow> 0\n                       | IO out c \\<Rightarrow>\n                           if consider out\n                           then eSuc\n                                 (\\<Squnion>input.\n                                     interaction_bound consider (c input))\n                           else \\<Squnion>input.\n                                   interaction_bound consider (c input))\n 3. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input.\n                           interaction_bound' (TRY c'_ input ELSE gpv'))\n                      \\<le> ?y7 + interaction_bound consider gpv'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?y7 =\n                      (case IO x21_ c'_ of Pure x \\<Rightarrow> 0\n                       | IO out c \\<Rightarrow>\n                           if consider out\n                           then eSuc\n                                 (\\<Squnion>input.\n                                     interaction_bound consider (c input))\n                           else \\<Squnion>input.\n                                   interaction_bound consider (c input))\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input.\n                           interaction_bound' (TRY c'_ input ELSE gpv'))\n                      \\<le> ?y7 + interaction_bound consider gpv'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input.\n                           interaction_bound' (TRY c'_ input ELSE gpv'))\n                      \\<le> eSuc\n                             (\\<Squnion>input.\n                                 interaction_bound consider (c'_ input)) +\n                            interaction_bound consider gpv'", "apply(simp add: iadd_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> (\\<Squnion>input.\n                          interaction_bound' (TRY c'_ input ELSE gpv'))\n                      \\<le> (\\<Squnion>input.\n                                interaction_bound consider (c'_ input)) +\n                            interaction_bound consider gpv'", "apply(subst Sup_image_eadd1[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> range\n                       (\\<lambda>input.\n                           interaction_bound consider (c'_ input)) \\<noteq>\n                      {}\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> (\\<Squnion>input.\n                          interaction_bound' (TRY c'_ input ELSE gpv'))\n                      \\<le> (\\<Squnion>y\\<in>range\n        (\\<lambda>input. interaction_bound consider (c'_ input)).\n                                y + interaction_bound consider gpv')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n    \\<Longrightarrow> (\\<Squnion>input.\n                          interaction_bound' (TRY c'_ input ELSE gpv'))\n                      \\<le> (\\<Squnion>y\\<in>range\n        (\\<lambda>input. interaction_bound consider (c'_ input)).\n                                y + interaction_bound consider gpv')", "apply(rule SUP_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>input.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_;\n        input \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>range\n   (\\<lambda>input. interaction_bound consider (c'_ input)).\n                            interaction_bound' (TRY c'_ input ELSE gpv')\n                            \\<le> m + interaction_bound consider gpv'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>input.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            interaction_bound' (TRY c'_ input ELSE gpv')\n                            \\<le> interaction_bound consider (c'_ m) +\n                                  interaction_bound consider gpv'", "apply(rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>input.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); consider x21_\\<rbrakk>\n       \\<Longrightarrow> interaction_bound' (TRY c'_ input ELSE gpv')\n                         \\<le> interaction_bound consider\n                                (c'_ (?m16 input)) +\n                               interaction_bound consider gpv'", "apply(rule step.IH[unfolded ib_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 c' input.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21 c' \\<in> set_spmf (the_gpv gpv); \\<not> consider x21\\<rbrakk>\n       \\<Longrightarrow> interaction_bound' (TRY c' input ELSE gpv')\n                         \\<le> interaction_bound consider gpv +\n                               interaction_bound consider gpv'\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv'); consider x21\\<rbrakk>\n       \\<Longrightarrow> eSuc\n                          (\\<Squnion>input. interaction_bound' (x22 input))\n                         \\<le> interaction_bound consider gpv +\n                               interaction_bound consider gpv'\n 3. \\<And>x21 x22 input.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv');\n        \\<not> consider x21\\<rbrakk>\n       \\<Longrightarrow> interaction_bound' (x22 input)\n                         \\<le> interaction_bound consider gpv +\n                               interaction_bound consider gpv'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> interaction_bound consider gpv +\n                            interaction_bound consider gpv'", "apply(subst interaction_bound.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> \\<Squnion> (case_generat (\\<lambda>x. 0)\n   (\\<lambda>out c.\n       if consider out\n       then eSuc (\\<Squnion>input. interaction_bound consider (c input))\n       else \\<Squnion>input. interaction_bound consider (c input)) `\n  set_spmf (the_gpv gpv)) +\n                            interaction_bound consider gpv'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> (\\<Squnion>x\\<in>set_spmf (the_gpv gpv).\n                                case x of Pure x \\<Rightarrow> 0\n                                | IO out c \\<Rightarrow>\n                                    if consider out\n                                    then eSuc\n    (\\<Squnion>input. interaction_bound consider (c input))\n                                    else \\<Squnion>input.\n      interaction_bound consider (c input)) +\n                            interaction_bound consider gpv'", "apply(subst Sup_image_eadd1[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> case_generat (\\<lambda>x. 0)\n                       (\\<lambda>out c.\n                           if consider out\n                           then eSuc\n                                 (\\<Squnion>input.\n                                     interaction_bound consider (c input))\n                           else \\<Squnion>input.\n                                   interaction_bound consider (c input)) `\n                      set_spmf (the_gpv gpv) \\<noteq>\n                      {}\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> (\\<Squnion>y\\<in>case_generat (\\<lambda>x. 0)\n        (\\<lambda>out c.\n            if consider out\n            then eSuc\n                  (\\<Squnion>input. interaction_bound consider (c input))\n            else \\<Squnion>input. interaction_bound consider (c input)) `\n       set_spmf (the_gpv gpv).\n                                y + interaction_bound consider gpv')", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> (\\<Squnion>y\\<in>case_generat (\\<lambda>x. 0)\n        (\\<lambda>out c.\n            if consider out\n            then eSuc\n                  (\\<Squnion>input. interaction_bound consider (c input))\n            else \\<Squnion>input. interaction_bound consider (c input)) `\n       set_spmf (the_gpv gpv).\n                                y + interaction_bound consider gpv')", "apply(rule SUP_upper2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?y7\n                      \\<in> case_generat (\\<lambda>x. 0)\n                             (\\<lambda>out c.\n                                 if consider out\n                                 then eSuc\n (\\<Squnion>input. interaction_bound consider (c input))\n                                 else \\<Squnion>input.\n   interaction_bound consider (c input)) `\n                            set_spmf (the_gpv gpv)\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> ?y7 + interaction_bound consider gpv'", "apply(rule rev_image_eqI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?x10 \\<in> set_spmf (the_gpv gpv)\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?y7 =\n                      (case ?x10 of Pure x \\<Rightarrow> 0\n                       | IO out c \\<Rightarrow>\n                           if consider out\n                           then eSuc\n                                 (\\<Squnion>input.\n                                     interaction_bound consider (c input))\n                           else \\<Squnion>input.\n                                   interaction_bound consider (c input))\n 3. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> ?y7 + interaction_bound consider gpv'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?y7 =\n                      (case IO x21_ c'_ of Pure x \\<Rightarrow> 0\n                       | IO out c \\<Rightarrow>\n                           if consider out\n                           then eSuc\n                                 (\\<Squnion>input.\n                                     interaction_bound consider (c input))\n                           else \\<Squnion>input.\n                                   interaction_bound consider (c input))\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> ?y7 + interaction_bound consider gpv'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> (\\<Squnion>input.\n                                interaction_bound consider (c'_ input)) +\n                            interaction_bound consider gpv'", "apply(subst Sup_image_eadd1[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> range\n                       (\\<lambda>input.\n                           interaction_bound consider (c'_ input)) \\<noteq>\n                      {}\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> (\\<Squnion>y\\<in>range\n        (\\<lambda>input. interaction_bound consider (c'_ input)).\n                                y + interaction_bound consider gpv')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> (\\<Squnion>y\\<in>range\n        (\\<lambda>input. interaction_bound consider (c'_ input)).\n                                y + interaction_bound consider gpv')", "apply(rule SUP_upper2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?y14\n                      \\<in> range\n                             (\\<lambda>input.\n                                 interaction_bound consider (c'_ input))\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> ?y14 + interaction_bound consider gpv'", "apply(rule rev_image_eqI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?x17 \\<in> UNIV\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?y14 = interaction_bound consider (c'_ ?x17)\n 3. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> ?y14 + interaction_bound consider gpv'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?y14 = interaction_bound consider (c'_ ?x17)\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> ?y14 + interaction_bound consider gpv'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ c'_ \\<in> set_spmf (the_gpv gpv); \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (TRY c'_ input_ ELSE gpv')\n                      \\<le> interaction_bound consider (c'_ ?x17) +\n                            interaction_bound consider gpv'", "apply(rule step.IH[unfolded ib_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv'); consider x21\\<rbrakk>\n       \\<Longrightarrow> eSuc\n                          (\\<Squnion>input. interaction_bound' (x22 input))\n                         \\<le> interaction_bound consider gpv +\n                               interaction_bound consider gpv'\n 2. \\<And>x21 x22 input.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv');\n        \\<not> consider x21\\<rbrakk>\n       \\<Longrightarrow> interaction_bound' (x22 input)\n                         \\<le> interaction_bound consider gpv +\n                               interaction_bound consider gpv'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv'); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input. interaction_bound' (x22_ input))\n                      \\<le> interaction_bound consider gpv +\n                            interaction_bound consider gpv'", "apply(subst (2) interaction_bound.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv'); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input. interaction_bound' (x22_ input))\n                      \\<le> interaction_bound consider gpv +\n                            \\<Squnion> (case_generat (\\<lambda>x. 0)\n   (\\<lambda>out c.\n       if consider out\n       then eSuc (\\<Squnion>input. interaction_bound consider (c input))\n       else \\<Squnion>input. interaction_bound consider (c input)) `\n  set_spmf (the_gpv gpv'))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv'); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input. interaction_bound' (x22_ input))\n                      \\<le> interaction_bound consider gpv +\n                            (\\<Squnion>x\\<in>set_spmf (the_gpv gpv').\n                                case x of Pure x \\<Rightarrow> 0\n                                | IO out c \\<Rightarrow>\n                                    if consider out\n                                    then eSuc\n    (\\<Squnion>input. interaction_bound consider (c input))\n                                    else \\<Squnion>input.\n      interaction_bound consider (c input))", "apply(subst Sup_image_eadd2[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv'); consider x21_\\<rbrakk>\n    \\<Longrightarrow> case_generat (\\<lambda>x. 0)\n                       (\\<lambda>out c.\n                           if consider out\n                           then eSuc\n                                 (\\<Squnion>input.\n                                     interaction_bound consider (c input))\n                           else \\<Squnion>input.\n                                   interaction_bound consider (c input)) `\n                      set_spmf (the_gpv gpv') \\<noteq>\n                      {}\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv'); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input. interaction_bound' (x22_ input))\n                      \\<le> \\<Squnion> ((+)\n   (interaction_bound consider gpv) `\n  case_generat (\\<lambda>x. 0)\n   (\\<lambda>out c.\n       if consider out\n       then eSuc (\\<Squnion>input. interaction_bound consider (c input))\n       else \\<Squnion>input. interaction_bound consider (c input)) `\n  set_spmf (the_gpv gpv'))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv'); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input. interaction_bound' (x22_ input))\n                      \\<le> \\<Squnion> ((+)\n   (interaction_bound consider gpv) `\n  case_generat (\\<lambda>x. 0)\n   (\\<lambda>out c.\n       if consider out\n       then eSuc (\\<Squnion>input. interaction_bound consider (c input))\n       else \\<Squnion>input. interaction_bound consider (c input)) `\n  set_spmf (the_gpv gpv'))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv'); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input. interaction_bound' (x22_ input))\n                      \\<le> \\<Squnion> ((+)\n   (interaction_bound consider gpv) `\n  (\\<lambda>x.\n      case x of Pure x \\<Rightarrow> 0\n      | IO out c \\<Rightarrow>\n          if consider out\n          then eSuc (\\<Squnion>input. interaction_bound consider (c input))\n          else \\<Squnion>input. interaction_bound consider (c input)) `\n  set_spmf (the_gpv gpv'))", "apply(rule SUP_upper2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv'); consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?x8\n                      \\<in> (\\<lambda>x.\n                                case x of Pure x \\<Rightarrow> 0\n                                | IO out c \\<Rightarrow>\n                                    if consider out\n                                    then eSuc\n    (\\<Squnion>input. interaction_bound consider (c input))\n                                    else \\<Squnion>input.\n      interaction_bound consider (c input)) `\n                            set_spmf (the_gpv gpv')\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv'); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input. interaction_bound' (x22_ input))\n                      \\<le> interaction_bound consider gpv + ?x8", "apply(rule rev_image_eqI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv'); consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?x11 \\<in> set_spmf (the_gpv gpv')\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv'); consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?x8 =\n                      (case ?x11 of Pure x \\<Rightarrow> 0\n                       | IO out c \\<Rightarrow>\n                           if consider out\n                           then eSuc\n                                 (\\<Squnion>input.\n                                     interaction_bound consider (c input))\n                           else \\<Squnion>input.\n                                   interaction_bound consider (c input))\n 3. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv'); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input. interaction_bound' (x22_ input))\n                      \\<le> interaction_bound consider gpv + ?x8", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv'); consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?x8 =\n                      (case IO x21_ x22_ of Pure x \\<Rightarrow> 0\n                       | IO out c \\<Rightarrow>\n                           if consider out\n                           then eSuc\n                                 (\\<Squnion>input.\n                                     interaction_bound consider (c input))\n                           else \\<Squnion>input.\n                                   interaction_bound consider (c input))\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv'); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input. interaction_bound' (x22_ input))\n                      \\<le> interaction_bound consider gpv + ?x8", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv'); consider x21_\\<rbrakk>\n    \\<Longrightarrow> eSuc\n                       (\\<Squnion>input. interaction_bound' (x22_ input))\n                      \\<le> interaction_bound consider gpv +\n                            eSuc\n                             (\\<Squnion>input.\n                                 interaction_bound consider (x22_ input))", "apply(simp add: iadd_Suc_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv'); consider x21_\\<rbrakk>\n    \\<Longrightarrow> (\\<Squnion>input. interaction_bound' (x22_ input))\n                      \\<le> interaction_bound consider gpv +\n                            (\\<Squnion>input.\n                                interaction_bound consider (x22_ input))", "apply(subst Sup_image_eadd2[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv'); consider x21_\\<rbrakk>\n    \\<Longrightarrow> range\n                       (\\<lambda>input.\n                           interaction_bound consider (x22_ input)) \\<noteq>\n                      {}\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv'); consider x21_\\<rbrakk>\n    \\<Longrightarrow> (\\<Squnion>input. interaction_bound' (x22_ input))\n                      \\<le> \\<Squnion> ((+)\n   (interaction_bound consider gpv) `\n  range (\\<lambda>input. interaction_bound consider (x22_ input)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv'); consider x21_\\<rbrakk>\n    \\<Longrightarrow> (\\<Squnion>input. interaction_bound' (x22_ input))\n                      \\<le> \\<Squnion> ((+)\n   (interaction_bound consider gpv) `\n  range (\\<lambda>input. interaction_bound consider (x22_ input)))", "apply(rule SUP_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>input.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21_ x22_ \\<in> set_spmf (the_gpv gpv'); consider x21_;\n        input \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>range\n   (\\<lambda>input. interaction_bound consider (x22_ input)).\n                            interaction_bound' (x22_ input)\n                            \\<le> interaction_bound consider gpv + m", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>input.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21_ x22_ \\<in> set_spmf (the_gpv gpv'); consider x21_\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m.\n                            interaction_bound' (x22_ input)\n                            \\<le> interaction_bound consider gpv +\n                                  interaction_bound consider (x22_ m)", "apply(rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>input.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21_ x22_ \\<in> set_spmf (the_gpv gpv'); consider x21_\\<rbrakk>\n       \\<Longrightarrow> interaction_bound' (x22_ input)\n                         \\<le> interaction_bound consider gpv +\n                               interaction_bound consider\n                                (x22_ (?m17 input))", "apply(rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>input.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21_ x22_ \\<in> set_spmf (the_gpv gpv'); consider x21_\\<rbrakk>\n       \\<Longrightarrow> interaction_bound' (x22_ input) \\<le> ?y19 input\n 2. \\<And>input.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21_ x22_ \\<in> set_spmf (the_gpv gpv'); consider x21_\\<rbrakk>\n       \\<Longrightarrow> ?y19 input\n                         \\<le> interaction_bound consider gpv +\n                               interaction_bound consider\n                                (x22_ (?m17 input))", "apply(rule step.hyps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>input.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21_ x22_ \\<in> set_spmf (the_gpv gpv'); consider x21_\\<rbrakk>\n       \\<Longrightarrow> interaction_bound consider (x22_ input)\n                         \\<le> interaction_bound consider gpv +\n                               interaction_bound consider\n                                (x22_ (?m17 input))", "apply(rule enat_le_plus_same)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 input.\n       \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv');\n        \\<not> consider x21\\<rbrakk>\n       \\<Longrightarrow> interaction_bound' (x22 input)\n                         \\<le> interaction_bound consider gpv +\n                               interaction_bound consider gpv'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (x22_ input_)\n                      \\<le> interaction_bound consider gpv +\n                            interaction_bound consider gpv'", "apply(subst (2) interaction_bound.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (x22_ input_)\n                      \\<le> interaction_bound consider gpv +\n                            \\<Squnion> (case_generat (\\<lambda>x. 0)\n   (\\<lambda>out c.\n       if consider out\n       then eSuc (\\<Squnion>input. interaction_bound consider (c input))\n       else \\<Squnion>input. interaction_bound consider (c input)) `\n  set_spmf (the_gpv gpv'))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (x22_ input_)\n                      \\<le> interaction_bound consider gpv +\n                            (\\<Squnion>x\\<in>set_spmf (the_gpv gpv').\n                                case x of Pure x \\<Rightarrow> 0\n                                | IO out c \\<Rightarrow>\n                                    if consider out\n                                    then eSuc\n    (\\<Squnion>input. interaction_bound consider (c input))\n                                    else \\<Squnion>input.\n      interaction_bound consider (c input))", "apply(subst Sup_image_eadd2[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> case_generat (\\<lambda>x. 0)\n                       (\\<lambda>out c.\n                           if consider out\n                           then eSuc\n                                 (\\<Squnion>input.\n                                     interaction_bound consider (c input))\n                           else \\<Squnion>input.\n                                   interaction_bound consider (c input)) `\n                      set_spmf (the_gpv gpv') \\<noteq>\n                      {}\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (x22_ input_)\n                      \\<le> \\<Squnion> ((+)\n   (interaction_bound consider gpv) `\n  case_generat (\\<lambda>x. 0)\n   (\\<lambda>out c.\n       if consider out\n       then eSuc (\\<Squnion>input. interaction_bound consider (c input))\n       else \\<Squnion>input. interaction_bound consider (c input)) `\n  set_spmf (the_gpv gpv'))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (x22_ input_)\n                      \\<le> \\<Squnion> ((+)\n   (interaction_bound consider gpv) `\n  case_generat (\\<lambda>x. 0)\n   (\\<lambda>out c.\n       if consider out\n       then eSuc (\\<Squnion>input. interaction_bound consider (c input))\n       else \\<Squnion>input. interaction_bound consider (c input)) `\n  set_spmf (the_gpv gpv'))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (x22_ input_)\n                      \\<le> \\<Squnion> ((+)\n   (interaction_bound consider gpv) `\n  (\\<lambda>x.\n      case x of Pure x \\<Rightarrow> 0\n      | IO out c \\<Rightarrow>\n          if consider out\n          then eSuc (\\<Squnion>input. interaction_bound consider (c input))\n          else \\<Squnion>input. interaction_bound consider (c input)) `\n  set_spmf (the_gpv gpv'))", "apply(rule SUP_upper2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?x8\n                      \\<in> (\\<lambda>x.\n                                case x of Pure x \\<Rightarrow> 0\n                                | IO out c \\<Rightarrow>\n                                    if consider out\n                                    then eSuc\n    (\\<Squnion>input. interaction_bound consider (c input))\n                                    else \\<Squnion>input.\n      interaction_bound consider (c input)) `\n                            set_spmf (the_gpv gpv')\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (x22_ input_)\n                      \\<le> interaction_bound consider gpv + ?x8", "apply(rule rev_image_eqI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?x11 \\<in> set_spmf (the_gpv gpv')\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?x8 =\n                      (case ?x11 of Pure x \\<Rightarrow> 0\n                       | IO out c \\<Rightarrow>\n                           if consider out\n                           then eSuc\n                                 (\\<Squnion>input.\n                                     interaction_bound consider (c input))\n                           else \\<Squnion>input.\n                                   interaction_bound consider (c input))\n 3. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (x22_ input_)\n                      \\<le> interaction_bound consider gpv + ?x8", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?x8 =\n                      (case IO x21_ x22_ of Pure x \\<Rightarrow> 0\n                       | IO out c \\<Rightarrow>\n                           if consider out\n                           then eSuc\n                                 (\\<Squnion>input.\n                                     interaction_bound consider (c input))\n                           else \\<Squnion>input.\n                                   interaction_bound consider (c input))\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (x22_ input_)\n                      \\<le> interaction_bound consider gpv + ?x8", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (x22_ input_)\n                      \\<le> interaction_bound consider gpv +\n                            (\\<Squnion>input.\n                                interaction_bound consider (x22_ input))", "apply(subst Sup_image_eadd2[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> range\n                       (\\<lambda>input.\n                           interaction_bound consider (x22_ input)) \\<noteq>\n                      {}\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (x22_ input_)\n                      \\<le> \\<Squnion> ((+)\n   (interaction_bound consider gpv) `\n  range (\\<lambda>input. interaction_bound consider (x22_ input)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (x22_ input_)\n                      \\<le> \\<Squnion> ((+)\n   (interaction_bound consider gpv) `\n  range (\\<lambda>input. interaction_bound consider (x22_ input)))", "apply(rule SUP_upper2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?i15\n                      \\<in> range\n                             (\\<lambda>input.\n                                 interaction_bound consider (x22_ input))\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (x22_ input_)\n                      \\<le> interaction_bound consider gpv + ?i15", "apply(rule imageI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?x18 \\<in> UNIV\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (x22_ input_)\n                      \\<le> interaction_bound consider gpv +\n                            interaction_bound consider (x22_ ?x18)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (x22_ input_)\n                      \\<le> interaction_bound consider gpv +\n                            interaction_bound consider (x22_ ?x18)", "apply(rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound' (x22_ input_) \\<le> ?y20\n 2. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> ?y20\n                      \\<le> interaction_bound consider gpv +\n                            interaction_bound consider (x22_ ?x18)", "apply(rule step.hyps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> lossless_spmf (the_gpv gpv);\n     IO x21_ x22_ \\<in> set_spmf (the_gpv gpv');\n     \\<not> consider x21_\\<rbrakk>\n    \\<Longrightarrow> interaction_bound consider (x22_ input_)\n                      \\<le> interaction_bound consider gpv +\n                            interaction_bound consider (x22_ ?x18)", "apply(rule enat_le_plus_same)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Squnion>generat\\<in>set_spmf (the_gpv (TRY gpv ELSE gpv')).\n      case generat of Pure x \\<Rightarrow> 0\n      | IO out c \\<Rightarrow>\n          if consider out\n          then eSuc (\\<Squnion>input. interaction_bound' (c input))\n          else \\<Squnion>input. interaction_bound' (c input))\n  \\<le> ib gpv + ib gpv'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma interaction_bounded_by_try_gpv [interaction_bound]:\n  \"interaction_bounded_by consider (try_gpv gpv1 gpv2) (bound1 + bound2)\"\n  if \"interaction_bounded_by consider gpv1 bound1\" \"interaction_bounded_by consider gpv2 bound2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_bounded_by consider (TRY gpv1 ELSE gpv2) (bound1 + bound2)", "using that interaction_bound_try_gpv[of \"consider\" gpv1 gpv2]"], ["proof (prove)\nusing this:\n  interaction_bounded_by consider gpv1 bound1\n  interaction_bounded_by consider gpv2 bound2\n  interaction_bound consider (TRY gpv1 ELSE gpv2)\n  \\<le> interaction_bound consider gpv1 + interaction_bound consider gpv2\n\ngoal (1 subgoal):\n 1. interaction_bounded_by consider (TRY gpv1 ELSE gpv2) (bound1 + bound2)", "by(simp add: interaction_bounded_by.simps)(meson add_left_mono_trans add_right_mono le_left_mono)"], ["", "subsection \\<open>term \\<open>gpv_stop\\<close>\\<close>"], ["", "lemma interaction_bounded_by_gpv_stop [interaction_bound]:\n  assumes \"interaction_bounded_by consider gpv n\"\n  shows \"interaction_bounded_by consider (gpv_stop gpv) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_bounded_by consider (gpv_stop gpv) n", "using assms"], ["proof (prove)\nusing this:\n  interaction_bounded_by consider gpv n\n\ngoal (1 subgoal):\n 1. interaction_bounded_by consider (gpv_stop gpv) n", "by(simp add: interaction_bounded_by.simps)"], ["", "context includes \\<I>.lifting begin"], ["", "lift_definition stop_\\<I> :: \"('a, 'b) \\<I> \\<Rightarrow> ('a, 'b option) \\<I>\" is\n  \"\\<lambda>resp x. if (resp x = {}) then {} else insert None (Some ` resp x)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma outs_stop_\\<I> [simp]: \"outs_\\<I> (stop_\\<I> \\<I>) = outs_\\<I> \\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outs_\\<I> (stop_\\<I> \\<I>) = outs_\\<I> \\<I>", "by transfer auto"], ["", "lemma responses_stop_\\<I> [simp]: \n  \"responses_\\<I> (stop_\\<I> \\<I>) x = (if x \\<in> outs_\\<I> \\<I> then insert None (Some ` responses_\\<I> \\<I> x) else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. responses_\\<I> (stop_\\<I> \\<I>) x =\n    (if x \\<in> outs_\\<I> \\<I>\n     then insert None (Some ` responses_\\<I> \\<I> x) else {})", "by transfer auto"], ["", "lemma stop_\\<I>_full [simp]: \"stop_\\<I> \\<I>_full = \\<I>_full\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stop_\\<I> \\<I>_full = \\<I>_full", "by transfer(auto simp add: fun_eq_iff notin_range_Some)"], ["", "lemma stop_\\<I>_uniform [simp]: \n  \"stop_\\<I> (\\<I>_uniform A B) = (if B = {} then \\<bottom> else \\<I>_uniform A (insert None (Some ` B)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stop_\\<I> (\\<I>_uniform A B) =\n    (if B = {} then \\<bottom> else \\<I>_uniform A (insert None (Some ` B)))", "unfolding bot_\\<I>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. stop_\\<I> (\\<I>_uniform A B) =\n    (if B = {} then \\<I>_uniform {} UNIV\n     else \\<I>_uniform A (insert None (Some ` B)))", "by transfer(simp add: fun_eq_iff)"], ["", "lifting_update \\<I>.lifting"], ["", "lifting_forget \\<I>.lifting"], ["", "end"], ["", "lemma stop_\\<I>_bot [simp]: \"stop_\\<I> \\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stop_\\<I> \\<bottom> = \\<bottom>", "by(simp only: bot_\\<I>_def stop_\\<I>_uniform)(simp)"], ["", "lemma WT_gpv_stop [simp, WT_intro]: \"stop_\\<I> \\<I> \\<turnstile>g gpv_stop gpv \\<surd>\" if \"\\<I> \\<turnstile>g gpv \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stop_\\<I> \\<I> \\<turnstile>g gpv_stop gpv \\<surd>", "using that"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. stop_\\<I> \\<I> \\<turnstile>g gpv_stop gpv \\<surd>", "by(coinduction arbitrary: gpv)(auto 4 3 dest: WT_gpvD)"], ["", "lemma expectation_gpv_stop:\n  fixes fail and gpv :: \"('a, 'b, 'c) gpv\"\n  assumes WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n  and fail: \"fail \\<le> c\"\n  shows \"expectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c) (gpv_stop gpv) = expectation_gpv fail \\<I> (\\<lambda>_. c) gpv\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c) (gpv_stop gpv) =\n    expectation_gpv fail \\<I> (\\<lambda>_. c) gpv", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. expectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c) (gpv_stop gpv)\n    \\<le> expectation_gpv fail \\<I> (\\<lambda>_. c) gpv\n 2. expectation_gpv fail \\<I> (\\<lambda>_. c) gpv\n    \\<le> expectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c)\n           (gpv_stop gpv)", "show \"expectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c) (gpv_stop gpv) \\<le> expectation_gpv fail \\<I> (\\<lambda>_. c) gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c) (gpv_stop gpv)\n    \\<le> expectation_gpv fail \\<I> (\\<lambda>_. c) gpv", "using WT"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. expectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c) (gpv_stop gpv)\n    \\<le> expectation_gpv fail \\<I> (\\<lambda>_. c) gpv", "proof(induction arbitrary: gpv rule: parallel_fixp_induct_1_1[OF complete_lattice_partial_function_definitions complete_lattice_partial_function_definitions expectation_gpv.mono expectation_gpv.mono expectation_gpv_def expectation_gpv_def, case_names adm bottom step])"], ["proof (state)\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa.\n            \\<I> \\<turnstile>g xa \\<surd> \\<longrightarrow>\n            fst x (gpv_stop xa) \\<le> snd x xa)\n 2. \\<And>gpv.\n       \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n       \\<Squnion> {} \\<le> \\<Squnion> {}\n 3. \\<And>f g gpv.\n       \\<lbrakk>\\<And>gpv.\n                   \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n                   f (gpv_stop gpv) \\<le> g gpv;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N\n                          (measure_spmf (the_gpv (gpv_stop gpv)))\n                          (case_generat (\\<lambda>x. c)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I>\n           (stop_\\<I> \\<I>) out.\n                                   f (c r))) +\n                         fail * ennreal (pmf (the_gpv (gpv_stop gpv)) None)\n                         \\<le> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                                (case_generat (\\<lambda>x. c)\n                                  (\\<lambda>out c.\n\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. g (c r))) +\n                               fail * ennreal (pmf (the_gpv gpv) None)", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa.\n            \\<I> \\<turnstile>g xa \\<surd> \\<longrightarrow>\n            fst x (gpv_stop xa) \\<le> snd x xa)\n 2. \\<And>gpv.\n       \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n       \\<Squnion> {} \\<le> \\<Squnion> {}\n 3. \\<And>f g gpv.\n       \\<lbrakk>\\<And>gpv.\n                   \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n                   f (gpv_stop gpv) \\<le> g gpv;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N\n                          (measure_spmf (the_gpv (gpv_stop gpv)))\n                          (case_generat (\\<lambda>x. c)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I>\n           (stop_\\<I> \\<I>) out.\n                                   f (c r))) +\n                         fail * ennreal (pmf (the_gpv (gpv_stop gpv)) None)\n                         \\<le> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                                (case_generat (\\<lambda>x. c)\n                                  (\\<lambda>out c.\n\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. g (c r))) +\n                               fail * ennreal (pmf (the_gpv gpv) None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n     (rel_prod lfp.le_fun lfp.le_fun)\n     (\\<lambda>x.\n         \\<forall>xa.\n            \\<I> \\<turnstile>g xa \\<surd> \\<longrightarrow>\n            fst x (gpv_stop xa) \\<le> snd x xa)", "by simp"], ["proof (state)\nthis:\n  ccpo.admissible (prod_lub lfp.lub_fun lfp.lub_fun)\n   (rel_prod lfp.le_fun lfp.le_fun)\n   (\\<lambda>x.\n       \\<forall>xa.\n          \\<I> \\<turnstile>g xa \\<surd> \\<longrightarrow>\n          fst x (gpv_stop xa) \\<le> snd x xa)\n\ngoal (2 subgoals):\n 1. \\<And>gpv.\n       \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n       \\<Squnion> {} \\<le> \\<Squnion> {}\n 2. \\<And>f g gpv.\n       \\<lbrakk>\\<And>gpv.\n                   \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n                   f (gpv_stop gpv) \\<le> g gpv;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N\n                          (measure_spmf (the_gpv (gpv_stop gpv)))\n                          (case_generat (\\<lambda>x. c)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I>\n           (stop_\\<I> \\<I>) out.\n                                   f (c r))) +\n                         fail * ennreal (pmf (the_gpv (gpv_stop gpv)) None)\n                         \\<le> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                                (case_generat (\\<lambda>x. c)\n                                  (\\<lambda>out c.\n\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. g (c r))) +\n                               fail * ennreal (pmf (the_gpv gpv) None)", "case bottom"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>gpv.\n       \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n       \\<Squnion> {} \\<le> \\<Squnion> {}\n 2. \\<And>f g gpv.\n       \\<lbrakk>\\<And>gpv.\n                   \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n                   f (gpv_stop gpv) \\<le> g gpv;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N\n                          (measure_spmf (the_gpv (gpv_stop gpv)))\n                          (case_generat (\\<lambda>x. c)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I>\n           (stop_\\<I> \\<I>) out.\n                                   f (c r))) +\n                         fail * ennreal (pmf (the_gpv (gpv_stop gpv)) None)\n                         \\<le> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                                (case_generat (\\<lambda>x. c)\n                                  (\\<lambda>out c.\n\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. g (c r))) +\n                               fail * ennreal (pmf (the_gpv gpv) None)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> {} \\<le> \\<Squnion> {}", "by simp"], ["proof (state)\nthis:\n  \\<Squnion> {} \\<le> \\<Squnion> {}\n\ngoal (1 subgoal):\n 1. \\<And>f g gpv.\n       \\<lbrakk>\\<And>gpv.\n                   \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n                   f (gpv_stop gpv) \\<le> g gpv;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N\n                          (measure_spmf (the_gpv (gpv_stop gpv)))\n                          (case_generat (\\<lambda>x. c)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I>\n           (stop_\\<I> \\<I>) out.\n                                   f (c r))) +\n                         fail * ennreal (pmf (the_gpv (gpv_stop gpv)) None)\n                         \\<le> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                                (case_generat (\\<lambda>x. c)\n                                  (\\<lambda>out c.\n\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. g (c r))) +\n                               fail * ennreal (pmf (the_gpv gpv) None)", "case (step f g)"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>g ?gpv \\<surd> \\<Longrightarrow>\n  f (gpv_stop ?gpv) \\<le> g ?gpv\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>f g gpv.\n       \\<lbrakk>\\<And>gpv.\n                   \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n                   f (gpv_stop gpv) \\<le> g gpv;\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N\n                          (measure_spmf (the_gpv (gpv_stop gpv)))\n                          (case_generat (\\<lambda>x. c)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I>\n           (stop_\\<I> \\<I>) out.\n                                   f (c r))) +\n                         fail * ennreal (pmf (the_gpv (gpv_stop gpv)) None)\n                         \\<le> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                                (case_generat (\\<lambda>x. c)\n                                  (\\<lambda>out c.\n\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. g (c r))) +\n                               fail * ennreal (pmf (the_gpv gpv) None)", "then"], ["proof (chain)\npicking this:\n  \\<I> \\<turnstile>g ?gpv \\<surd> \\<Longrightarrow>\n  f (gpv_stop ?gpv) \\<le> g ?gpv\n  \\<I> \\<turnstile>g gpv \\<surd>", "show ?case"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g ?gpv \\<surd> \\<Longrightarrow>\n  f (gpv_stop ?gpv) \\<le> g ?gpv\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> c\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I>\n         (stop_\\<I> \\<I>) out.\n                                 f (c r))\n                       \\<partial>measure_spmf (the_gpv (gpv_stop gpv)) +\n    fail * ennreal (pmf (the_gpv (gpv_stop gpv)) None)\n    \\<le> \\<integral>\\<^sup>+ generat.\n                               (case generat of Pure x \\<Rightarrow> c\n                                | IO out c \\<Rightarrow>\n                                    \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n g (c r))\n                             \\<partial>measure_spmf (the_gpv gpv) +\n          fail * ennreal (pmf (the_gpv gpv) None)", "apply(simp add: pmf_map_spmf_None measure_spmf_return_spmf nn_integral_return)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>gpv.\n                \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n                f (gpv_stop gpv) \\<le> g gpv;\n     \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n    \\<Longrightarrow> fail * ennreal (pmf (the_gpv gpv) None) = \\<top> \\<or>\n                      integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                       (case_generat (\\<lambda>x. c)\n                         (\\<lambda>out c.\n                             \\<Sqinter>x\\<in>if out \\<in> outs_\\<I> \\<I>\n       then insert None (Some ` responses_\\<I> \\<I> out) else {}.\n                                f (c x)) \\<circ>\n                        map_generat Some id\n                         (\\<lambda>rpv.\n                             case_option (Done None)\n                              (\\<lambda>input'. gpv_stop (rpv input'))))\n                      \\<le> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                             (case_generat (\\<lambda>x. c)\n                               (\\<lambda>out c.\n                                   \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\ng (c r)))", "apply(rule disjI2 nn_integral_mono_AE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>gpv.\n                \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n                f (gpv_stop gpv) \\<le> g gpv;\n     \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n    \\<Longrightarrow> AE x in measure_spmf\n                               (the_gpv\n                                 gpv). (case_generat (\\<lambda>x. c)\n   (\\<lambda>out c.\n       \\<Sqinter>x\\<in>if out \\<in> outs_\\<I> \\<I>\n                       then insert None (Some ` responses_\\<I> \\<I> out)\n                       else {}.\n          f (c x)) \\<circ>\n  map_generat Some id\n   (\\<lambda>rpv.\n       case_option (Done None) (\\<lambda>input'. gpv_stop (rpv input'))))\n  x\n \\<le> (case x of Pure x \\<Rightarrow> c\n        | IO out c \\<Rightarrow>\n            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. g (c r))", "apply(auto split!: generat.split simp add: image_image dest: WT_gpvD intro!: le_infI2 INF_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> c\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> (stop_\\<I> \\<I>)\n       out.\n                               f (c r))\n                     \\<partial>measure_spmf (the_gpv (gpv_stop gpv)) +\n  fail * ennreal (pmf (the_gpv (gpv_stop gpv)) None)\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (case generat of Pure x \\<Rightarrow> c\n                              | IO out c \\<Rightarrow>\n                                  \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                     g (c r))\n                           \\<partial>measure_spmf (the_gpv gpv) +\n        fail * ennreal (pmf (the_gpv gpv) None)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  expectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c) (gpv_stop gpv)\n  \\<le> expectation_gpv fail \\<I> (\\<lambda>_. c) gpv\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. c) gpv\n    \\<le> expectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c)\n           (gpv_stop gpv)", "define stop :: \"('a option, 'b, 'c option) gpv \\<Rightarrow> _\" where \"stop = expectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c)\""], ["proof (state)\nthis:\n  stop = expectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c)\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. c) gpv\n    \\<le> expectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c)\n           (gpv_stop gpv)", "show \"?rhs \\<le> stop (gpv_stop gpv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. c) gpv \\<le> stop (gpv_stop gpv)", "using WT"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. expectation_gpv fail \\<I> (\\<lambda>_. c) gpv \\<le> stop (gpv_stop gpv)", "proof(induction arbitrary: gpv rule: expectation_gpv_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            a x \\<le> stop (gpv_stop x))\n 2. \\<And>gpv.\n       \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n       0 \\<le> stop (gpv_stop gpv)\n 3. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv \\<le> stop (gpv_stop gpv);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. c)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> stop (gpv_stop gpv)", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            a x \\<le> stop (gpv_stop x))\n 2. \\<And>gpv.\n       \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n       0 \\<le> stop (gpv_stop gpv)\n 3. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv \\<le> stop (gpv_stop gpv);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. c)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> stop (gpv_stop gpv)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            a x \\<le> stop (gpv_stop x))", "by simp"], ["proof (state)\nthis:\n  lfp.admissible\n   (\\<lambda>a.\n       \\<forall>x.\n          \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n          a x \\<le> stop (gpv_stop x))\n\ngoal (2 subgoals):\n 1. \\<And>gpv.\n       \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n       0 \\<le> stop (gpv_stop gpv)\n 2. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv \\<le> stop (gpv_stop gpv);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. c)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> stop (gpv_stop gpv)", "case bottom"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>gpv.\n       \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n       0 \\<le> stop (gpv_stop gpv)\n 2. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv \\<le> stop (gpv_stop gpv);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. c)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> stop (gpv_stop gpv)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> stop (gpv_stop gpv)", "by simp"], ["proof (state)\nthis:\n  0 \\<le> stop (gpv_stop gpv)\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv \\<le> stop (gpv_stop gpv);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. c)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> stop (gpv_stop gpv)", "case (step expectation_gpv')"], ["proof (state)\nthis:\n  expectation_gpv' ?gpv \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) ?gpv\n  \\<I> \\<turnstile>g ?gpv \\<surd> \\<Longrightarrow>\n  expectation_gpv' ?gpv \\<le> stop (gpv_stop ?gpv)\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv \\<le> stop (gpv_stop gpv);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. c)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> stop (gpv_stop gpv)", "have \"expectation_gpv' gpv' \\<le> c\" if \"\\<I> \\<turnstile>g gpv' \\<surd>\" for gpv'"], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv' gpv' \\<le> c", "using expectation_gpv_const_le[of \\<I> gpv' fail c] fail step.hyps(1)[of gpv'] that"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv' \\<surd> \\<Longrightarrow>\n  expectation_gpv fail \\<I> (\\<lambda>_. c) gpv' \\<le> max c fail\n  fail \\<le> c\n  expectation_gpv' gpv' \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv'\n  \\<I> \\<turnstile>g gpv' \\<surd>\n\ngoal (1 subgoal):\n 1. expectation_gpv' gpv' \\<le> c", "by(simp add: max_def split: if_split_asm)"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>g ?gpv' \\<surd> \\<Longrightarrow>\n  expectation_gpv' ?gpv' \\<le> c\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv \\<le> stop (gpv_stop gpv);\n        \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. c)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         fail * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> stop (gpv_stop gpv)", "then"], ["proof (chain)\npicking this:\n  \\<I> \\<turnstile>g ?gpv' \\<surd> \\<Longrightarrow>\n  expectation_gpv' ?gpv' \\<le> c", "show ?case"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g ?gpv' \\<surd> \\<Longrightarrow>\n  expectation_gpv' ?gpv' \\<le> c\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> c\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail * ennreal (pmf (the_gpv gpv) None)\n    \\<le> stop (gpv_stop gpv)", "using step"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g ?gpv' \\<surd> \\<Longrightarrow>\n  expectation_gpv' ?gpv' \\<le> c\n  expectation_gpv' ?gpv \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) ?gpv\n  \\<I> \\<turnstile>g ?gpv \\<surd> \\<Longrightarrow>\n  expectation_gpv' ?gpv \\<le> stop (gpv_stop ?gpv)\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> c\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail * ennreal (pmf (the_gpv gpv) None)\n    \\<le> stop (gpv_stop gpv)", "unfolding stop_def"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g ?gpv' \\<surd> \\<Longrightarrow>\n  expectation_gpv' ?gpv' \\<le> c\n  expectation_gpv' ?gpv \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) ?gpv\n  \\<I> \\<turnstile>g ?gpv \\<surd> \\<Longrightarrow>\n  expectation_gpv' ?gpv\n  \\<le> expectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c)\n         (gpv_stop ?gpv)\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> c\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    fail * ennreal (pmf (the_gpv gpv) None)\n    \\<le> expectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c)\n           (gpv_stop gpv)", "apply(subst expectation_gpv.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>gpv'.\n                \\<I> \\<turnstile>g gpv' \\<surd> \\<Longrightarrow>\n                expectation_gpv' gpv' \\<le> c;\n     \\<And>gpv.\n        expectation_gpv' gpv\n        \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n     \\<And>gpv.\n        \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n        expectation_gpv' gpv\n        \\<le> expectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c)\n               (gpv_stop gpv);\n     \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n    \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                       (case_generat (\\<lambda>x. c)\n                         (\\<lambda>out c.\n                             \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                expectation_gpv' (c r))) +\n                      fail * ennreal (pmf (the_gpv gpv) None)\n                      \\<le> integral\\<^sup>N\n                             (measure_spmf (the_gpv (gpv_stop gpv)))\n                             (case_generat (\\<lambda>x. c)\n                               (\\<lambda>out ca.\n                                   \\<Sqinter>r\\<in>responses_\\<I>\n              (stop_\\<I> \\<I>) out.\nexpectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c) (ca r))) +\n                            fail *\n                            ennreal (pmf (the_gpv (gpv_stop gpv)) None)", "apply(simp add: pmf_map_spmf_None)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>gpv'.\n                \\<I> \\<turnstile>g gpv' \\<surd> \\<Longrightarrow>\n                expectation_gpv' gpv' \\<le> c;\n     \\<And>gpv.\n        expectation_gpv' gpv\n        \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n     \\<And>gpv.\n        \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n        expectation_gpv' gpv\n        \\<le> expectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c)\n               (gpv_stop gpv);\n     \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n    \\<Longrightarrow> fail * ennreal (pmf (the_gpv gpv) None) = \\<top> \\<or>\n                      integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                       (case_generat (\\<lambda>x. c)\n                         (\\<lambda>out c.\n                             \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                expectation_gpv' (c r)))\n                      \\<le> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                             (case_generat (\\<lambda>x. c)\n                               (\\<lambda>out ca.\n                                   \\<Sqinter>x\\<in>if out\n                \\<in> outs_\\<I> \\<I>\n             then insert None (Some ` responses_\\<I> \\<I> out) else {}.\nexpectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c) (ca x)) \\<circ>\n                              map_generat Some id\n                               (\\<lambda>rpv.\n                                   case_option (Done None)\n                                    (\\<lambda>input'.\n  gpv_stop (rpv input'))))", "apply(rule disjI2 nn_integral_mono_AE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>gpv'.\n                \\<I> \\<turnstile>g gpv' \\<surd> \\<Longrightarrow>\n                expectation_gpv' gpv' \\<le> c;\n     \\<And>gpv.\n        expectation_gpv' gpv\n        \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n     \\<And>gpv.\n        \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n        expectation_gpv' gpv\n        \\<le> expectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c)\n               (gpv_stop gpv);\n     \\<I> \\<turnstile>g gpv \\<surd>\\<rbrakk>\n    \\<Longrightarrow> AE x in measure_spmf\n                               (the_gpv\n                                 gpv). (case x of Pure x \\<Rightarrow> c\n  | IO out c \\<Rightarrow>\n      \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n \\<le> (case_generat (\\<lambda>x. c)\n         (\\<lambda>out ca.\n             \\<Sqinter>x\\<in>if out \\<in> outs_\\<I> \\<I>\n                             then insert None\n                                   (Some ` responses_\\<I> \\<I> out)\n                             else {}.\n                expectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c)\n                 (ca x)) \\<circ>\n        map_generat Some id\n         (\\<lambda>rpv.\n             case_option (Done None)\n              (\\<lambda>input'. gpv_stop (rpv input'))))\n        x", "apply(clarsimp split!: generat.split simp add: image_image)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21a x22a.\n       \\<lbrakk>\\<And>gpv'.\n                   \\<I> \\<turnstile>g gpv' \\<surd> \\<Longrightarrow>\n                   expectation_gpv' gpv' \\<le> c;\n        \\<And>gpv.\n           expectation_gpv' gpv\n           \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv\n           \\<le> expectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c)\n                  (gpv_stop gpv);\n        \\<I> \\<turnstile>g gpv \\<surd>;\n        IO x21a x22a \\<in> set_spmf (the_gpv gpv);\n        x21a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21a.\n                             expectation_gpv' (x22a r))\n                         \\<le> c\n 2. \\<And>x21a x22a.\n       \\<lbrakk>\\<And>gpv'.\n                   \\<I> \\<turnstile>g gpv' \\<surd> \\<Longrightarrow>\n                   expectation_gpv' gpv' \\<le> c;\n        \\<And>gpv.\n           expectation_gpv' gpv\n           \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv\n           \\<le> expectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c)\n                  (gpv_stop gpv);\n        \\<I> \\<turnstile>g gpv \\<surd>;\n        IO x21a x22a \\<in> set_spmf (the_gpv gpv);\n        x21a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21a.\n                             expectation_gpv' (x22a r))\n                         \\<le> (\\<Sqinter>x\\<in>responses_\\<I> \\<I> x21a.\n                                   expectation_gpv fail (stop_\\<I> \\<I>)\n                                    (\\<lambda>_. c) (gpv_stop (x22a x)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>gpv'.\n                \\<I> \\<turnstile>g gpv' \\<surd> \\<Longrightarrow>\n                expectation_gpv' gpv' \\<le> c;\n     \\<And>gpv.\n        expectation_gpv' gpv\n        \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n     \\<And>gpv.\n        \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n        expectation_gpv' gpv\n        \\<le> expectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c)\n               (gpv_stop gpv);\n     \\<I> \\<turnstile>g gpv \\<surd>;\n     IO x21a_ x22a_ \\<in> set_spmf (the_gpv gpv);\n     x21a_ \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21a_.\n                          expectation_gpv' (x22a_ r))\n                      \\<le> c", "by(auto 4 3 simp add: in_outs_\\<I>_iff_responses_\\<I> dest: WT_gpv_ContD intro: INF_lower2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21a x22a.\n       \\<lbrakk>\\<And>gpv'.\n                   \\<I> \\<turnstile>g gpv' \\<surd> \\<Longrightarrow>\n                   expectation_gpv' gpv' \\<le> c;\n        \\<And>gpv.\n           expectation_gpv' gpv\n           \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n        \\<And>gpv.\n           \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n           expectation_gpv' gpv\n           \\<le> expectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c)\n                  (gpv_stop gpv);\n        \\<I> \\<turnstile>g gpv \\<surd>;\n        IO x21a x22a \\<in> set_spmf (the_gpv gpv);\n        x21a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21a.\n                             expectation_gpv' (x22a r))\n                         \\<le> (\\<Sqinter>x\\<in>responses_\\<I> \\<I> x21a.\n                                   expectation_gpv fail (stop_\\<I> \\<I>)\n                                    (\\<lambda>_. c) (gpv_stop (x22a x)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>gpv'.\n                \\<I> \\<turnstile>g gpv' \\<surd> \\<Longrightarrow>\n                expectation_gpv' gpv' \\<le> c;\n     \\<And>gpv.\n        expectation_gpv' gpv\n        \\<le> expectation_gpv fail \\<I> (\\<lambda>a. c) gpv;\n     \\<And>gpv.\n        \\<I> \\<turnstile>g gpv \\<surd> \\<Longrightarrow>\n        expectation_gpv' gpv\n        \\<le> expectation_gpv fail (stop_\\<I> \\<I>) (\\<lambda>_. c)\n               (gpv_stop gpv);\n     \\<I> \\<turnstile>g gpv \\<surd>;\n     IO x21a_ x22a_ \\<in> set_spmf (the_gpv gpv);\n     x21a_ \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21a_.\n                          expectation_gpv' (x22a_ r))\n                      \\<le> (\\<Sqinter>x\\<in>responses_\\<I> \\<I> x21a_.\n                                expectation_gpv fail (stop_\\<I> \\<I>)\n                                 (\\<lambda>_. c) (gpv_stop (x22a_ x)))", "by(auto intro!: INF_mono rev_bexI dest: WT_gpvD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> c\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  fail * ennreal (pmf (the_gpv gpv) None)\n  \\<le> stop (gpv_stop gpv)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  expectation_gpv fail \\<I> (\\<lambda>_. c) gpv \\<le> stop (gpv_stop gpv)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pgen_lossless_gpv_stop:\n  fixes fail and gpv :: \"('a, 'b, 'c) gpv\"\n  assumes WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n  and fail: \"fail \\<le> 1\"\n  shows \"pgen_lossless_gpv fail (stop_\\<I> \\<I>) (gpv_stop gpv) = pgen_lossless_gpv fail \\<I> gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pgen_lossless_gpv fail (stop_\\<I> \\<I>) (gpv_stop gpv) =\n    pgen_lossless_gpv fail \\<I> gpv", "by(simp add: pgen_lossless_gpv_def expectation_gpv_stop assms)"], ["", "lemma pfinite_gpv_stop [simp]:\n  \"pfinite_gpv (stop_\\<I> \\<I>) (gpv_stop gpv) \\<longleftrightarrow> pfinite_gpv \\<I> gpv\" if \"\\<I> \\<turnstile>g gpv \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_gpv (stop_\\<I> \\<I>) (gpv_stop gpv) = pfinite_gpv \\<I> gpv", "using that"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. pfinite_gpv (stop_\\<I> \\<I>) (gpv_stop gpv) = pfinite_gpv \\<I> gpv", "by(simp add: pgen_lossless_gpv_stop)"], ["", "lemma plossless_gpv_stop [simp]:\n  \"plossless_gpv (stop_\\<I> \\<I>) (gpv_stop gpv) \\<longleftrightarrow> plossless_gpv \\<I> gpv\" if \"\\<I> \\<turnstile>g gpv \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_gpv (stop_\\<I> \\<I>) (gpv_stop gpv) = plossless_gpv \\<I> gpv", "using that"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. plossless_gpv (stop_\\<I> \\<I>) (gpv_stop gpv) = plossless_gpv \\<I> gpv", "by(simp add: pgen_lossless_gpv_stop)"], ["", "lemma results_gpv_stop_SomeD: \"Some x \\<in> results_gpv (stop_\\<I> \\<I>) (gpv_stop gpv) \\<Longrightarrow> x \\<in> results_gpv \\<I> gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some x\n    \\<in> results_gpv (stop_\\<I> \\<I>) (gpv_stop gpv) \\<Longrightarrow>\n    x \\<in> results_gpv \\<I> gpv", "by(induction gpv'\\<equiv>\"gpv_stop gpv\" arbitrary: gpv rule: results_gpv.induct)\n    (auto 4 3 intro: results_gpv.intros split: if_split_asm)"], ["", "lemma Some_in_results'_gpv_gpv_stopD: \"Some xy \\<in> results'_gpv (gpv_stop gpv) \\<Longrightarrow> xy \\<in> results'_gpv gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some xy \\<in> results'_gpv (gpv_stop gpv) \\<Longrightarrow>\n    xy \\<in> results'_gpv gpv", "unfolding results_gpv_\\<I>_full[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Some xy \\<in> results_gpv \\<I>_full (gpv_stop gpv) \\<Longrightarrow>\n    xy \\<in> results_gpv \\<I>_full gpv", "by(rule results_gpv_stop_SomeD) simp"], ["", "subsection \\<open>term \\<open>exception_\\<I>\\<close>\\<close>"], ["", "datatype 's exception = Fault | OK (ok: 's)"], ["", "lemma inj_on_OK [simp]: \"inj_on OK A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on OK A", "by(auto simp add: inj_on_def)"], ["", "function join_exception :: \"'a exception \\<Rightarrow> 'b exception \\<Rightarrow> ('a \\<times> 'b) exception\" where\n  \"join_exception Fault _ = Fault\"\n| \"join_exception _ Fault = Fault\"\n| \"join_exception (OK a) (OK b) = OK (a, b)\""], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>uu_. x = (Fault, uu_) \\<Longrightarrow> P;\n        \\<And>uv_. x = (uv_, Fault) \\<Longrightarrow> P;\n        \\<And>a b. x = (OK a, OK b) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>uu_ uua_.\n       (Fault, uu_) = (Fault, uua_) \\<Longrightarrow> Fault = Fault\n 3. \\<And>uu_ uv_.\n       (Fault, uu_) = (uv_, Fault) \\<Longrightarrow> Fault = Fault\n 4. \\<And>uu_ a b.\n       (Fault, uu_) = (OK a, OK b) \\<Longrightarrow> Fault = OK (a, b)\n 5. \\<And>uv_ uva_.\n       (uv_, Fault) = (uva_, Fault) \\<Longrightarrow> Fault = Fault\n 6. \\<And>uv_ a b.\n       (uv_, Fault) = (OK a, OK b) \\<Longrightarrow> Fault = OK (a, b)\n 7. \\<And>a b aa ba.\n       (OK a, OK b) = (OK aa, OK ba) \\<Longrightarrow>\n       OK (a, b) = OK (aa, ba)", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All join_exception_dom", "by lexicographic_order"], ["", "primrec merge_exception :: \"'a exception + 'b exception \\<Rightarrow> ('a + 'b) exception\" where\n  \"merge_exception (Inl x) = map_exception Inl x\"\n| \"merge_exception (Inr y) = map_exception Inr y\""], ["", "fun option_of_exception :: \"'a exception \\<Rightarrow> 'a option\" where\n  \"option_of_exception Fault = None\"\n| \"option_of_exception (OK x) = Some x\""], ["", "fun exception_of_option :: \"'a option \\<Rightarrow> 'a exception\" where\n  \"exception_of_option None = Fault\"\n| \"exception_of_option (Some x) = OK x\""], ["", "lemma option_of_exception_exception_of_option [simp]: \"option_of_exception (exception_of_option x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. option_of_exception (exception_of_option x) = x", "by(cases x) simp_all"], ["", "lemma exception_of_option_option_of_exception [simp]: \"exception_of_option (option_of_exception x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exception_of_option (option_of_exception x) = x", "by(cases x) simp_all"], ["", "lemma case_exception_of_option [simp]: \"case_exception f g (exception_of_option x) = case_option f g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case exception_of_option x of Fault \\<Rightarrow> f\n     | OK x \\<Rightarrow> g x) =\n    (case x of None \\<Rightarrow> f | Some x \\<Rightarrow> g x)", "by(simp split: exception.split option.split)"], ["", "lemma case_option_of_exception [simp]: \"case_option f g (option_of_exception x) = case_exception f g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case option_of_exception x of None \\<Rightarrow> f\n     | Some x \\<Rightarrow> g x) =\n    (case x of Fault \\<Rightarrow> f | OK x \\<Rightarrow> g x)", "by(simp split: exception.split option.split)"], ["", "lemma surj_exception_of_option [simp]: \"surj exception_of_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj exception_of_option", "by(rule surjI[where f=\"option_of_exception\"])(simp)"], ["", "lemma surj_option_of_exception [simp]: \"surj option_of_exception\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surj option_of_exception", "by(rule surjI[where f=\"exception_of_option\"])(simp)"], ["", "lemma case_map_exception [simp]: \"case_exception f g (map_exception h x) = case_exception f (g \\<circ> h) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case map_exception h x of Fault \\<Rightarrow> f\n     | OK x \\<Rightarrow> g x) =\n    (case x of Fault \\<Rightarrow> f | OK x \\<Rightarrow> (g \\<circ> h) x)", "by(simp split: exception.split)"], ["", "definition exception_\\<I> :: \"('a, 'b) \\<I> \\<Rightarrow> ('a, 'b exception) \\<I>\" where \n  \"exception_\\<I> \\<I> = map_\\<I> id exception_of_option (stop_\\<I> \\<I>)\""], ["", "lemma outs_exception_\\<I> [simp]: \"outs_\\<I> (exception_\\<I> \\<I>) = outs_\\<I> \\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outs_\\<I> (exception_\\<I> \\<I>) = outs_\\<I> \\<I>", "by(simp add: exception_\\<I>_def)"], ["", "lemma responses_exception_\\<I> [simp]: \n  \"responses_\\<I> (exception_\\<I> \\<I>) x = (if x \\<in> outs_\\<I> \\<I> then insert Fault (OK ` responses_\\<I> \\<I> x) else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. responses_\\<I> (exception_\\<I> \\<I>) x =\n    (if x \\<in> outs_\\<I> \\<I>\n     then insert Fault (OK ` responses_\\<I> \\<I> x) else {})", "by(simp add: exception_\\<I>_def image_image)"], ["", "lemma map_\\<I>_full [simp]: \"map_\\<I> f g \\<I>_full = \\<I>_uniform UNIV (range g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_\\<I> f g \\<I>_full = \\<I>_uniform UNIV (range g)", "unfolding \\<I>_uniform_UNIV[symmetric] map_\\<I>_\\<I>_uniform"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_uniform (f -` UNIV) (range g) = \\<I>_uniform UNIV (range g)", "by simp"], ["", "lemma exception_\\<I>_full [simp]: \"exception_\\<I> \\<I>_full = \\<I>_full\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exception_\\<I> \\<I>_full = \\<I>_full", "unfolding exception_\\<I>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_\\<I> id exception_of_option (stop_\\<I> \\<I>_full) = \\<I>_full", "by simp"], ["", "lemma exception_\\<I>_uniform [simp]: \n  \"exception_\\<I> (\\<I>_uniform A B) = (if B = {} then \\<bottom> else \\<I>_uniform A (insert Fault (OK ` B)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exception_\\<I> (\\<I>_uniform A B) =\n    (if B = {} then \\<bottom> else \\<I>_uniform A (insert Fault (OK ` B)))", "by(simp add: exception_\\<I>_def image_image)"], ["", "lemma option_of_exception_\\<I> [simp]: \"map_\\<I> id option_of_exception (exception_\\<I> \\<I>) = stop_\\<I> \\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_\\<I> id option_of_exception (exception_\\<I> \\<I>) = stop_\\<I> \\<I>", "by(simp add: exception_\\<I>_def o_def id_def[symmetric])"], ["", "lemma exception_of_option_\\<I> [simp]: \"map_\\<I> id exception_of_option (stop_\\<I> \\<I>) = exception_\\<I> \\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_\\<I> id exception_of_option (stop_\\<I> \\<I>) = exception_\\<I> \\<I>", "by(simp add: exception_\\<I>_def)"], ["", "subsection \\<open>inline\\<close>"], ["", "context raw_converter_invariant begin"], ["", "context\n  fixes gpv :: \"('a, 'call, 'ret) gpv\"\n  assumes gpv: \"plossless_gpv \\<I> gpv\" \"\\<I> \\<turnstile>g gpv \\<surd>\"\nbegin"], ["", "lemma lossless_spmf_inline1:\n  assumes lossless: \"\\<And>s x. \\<lbrakk> x \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> lossless_spmf (the_gpv (callee s x))\"\n    and I: \"I s\"\n  shows \"lossless_spmf (inline1 callee gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (inline1 callee gpv s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lossless_spmf (inline1 callee gpv s)", "have \"1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv", "using gpv"], ["proof (prove)\nusing this:\n  plossless_gpv \\<I> gpv\n  \\<I> \\<turnstile>g gpv \\<surd>\n\ngoal (1 subgoal):\n 1. 1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv", "by(simp add: pgen_lossless_gpv_def)"], ["proof (state)\nthis:\n  1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n\ngoal (1 subgoal):\n 1. lossless_spmf (inline1 callee gpv s)", "also"], ["proof (state)\nthis:\n  1 = expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n\ngoal (1 subgoal):\n 1. lossless_spmf (inline1 callee gpv s)", "have \"\\<dots> \\<le> weight_spmf (inline1 callee gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n    \\<le> ennreal (weight_spmf (inline1 callee gpv s))", "using gpv(2) I"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n    \\<le> ennreal (weight_spmf (inline1 callee gpv s))", "proof(induction arbitrary: gpv s rule: expectation_gpv_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            (\\<forall>xa.\n                I xa \\<longrightarrow>\n                a x \\<le> ennreal (weight_spmf (inline1 callee x xa))))\n 2. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> ennreal\n                                  (weight_spmf (inline1 callee gpv s))\n 3. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv 0 \\<I> (\\<lambda>a. 1) gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> ennreal\n                                    (weight_spmf (inline1 callee gpv s));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. 1)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> ennreal (weight_spmf (inline1 callee gpv s))", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            (\\<forall>xa.\n                I xa \\<longrightarrow>\n                a x \\<le> ennreal (weight_spmf (inline1 callee x xa))))\n 2. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> ennreal\n                                  (weight_spmf (inline1 callee gpv s))\n 3. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv 0 \\<I> (\\<lambda>a. 1) gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> ennreal\n                                    (weight_spmf (inline1 callee gpv s));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. 1)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> ennreal (weight_spmf (inline1 callee gpv s))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            (\\<forall>xa.\n                I xa \\<longrightarrow>\n                a x \\<le> ennreal (weight_spmf (inline1 callee x xa))))", "by simp"], ["proof (state)\nthis:\n  lfp.admissible\n   (\\<lambda>a.\n       \\<forall>x.\n          \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n          (\\<forall>xa.\n              I xa \\<longrightarrow>\n              a x \\<le> ennreal (weight_spmf (inline1 callee x xa))))\n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> ennreal\n                                  (weight_spmf (inline1 callee gpv s))\n 2. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv 0 \\<I> (\\<lambda>a. 1) gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> ennreal\n                                    (weight_spmf (inline1 callee gpv s));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. 1)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> ennreal (weight_spmf (inline1 callee gpv s))", "case bottom"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> ennreal\n                                  (weight_spmf (inline1 callee gpv s))\n 2. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv 0 \\<I> (\\<lambda>a. 1) gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> ennreal\n                                    (weight_spmf (inline1 callee gpv s));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. 1)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> ennreal (weight_spmf (inline1 callee gpv s))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> ennreal (weight_spmf (inline1 callee gpv s))", "by simp"], ["proof (state)\nthis:\n  0 \\<le> ennreal (weight_spmf (inline1 callee gpv s))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv 0 \\<I> (\\<lambda>a. 1) gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> ennreal\n                                    (weight_spmf (inline1 callee gpv s));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. 1)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> ennreal (weight_spmf (inline1 callee gpv s))", "case (step expectation_gpv')"], ["proof (state)\nthis:\n  expectation_gpv' ?gpv \\<le> expectation_gpv 0 \\<I> (\\<lambda>a. 1) ?gpv\n  \\<lbrakk>\\<I> \\<turnstile>g ?gpv \\<surd>; I ?s\\<rbrakk>\n  \\<Longrightarrow> expectation_gpv' ?gpv\n                    \\<le> ennreal (weight_spmf (inline1 callee ?gpv ?s))\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv 0 \\<I> (\\<lambda>a. 1) gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> ennreal\n                                    (weight_spmf (inline1 callee gpv s));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. 1)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> ennreal (weight_spmf (inline1 callee gpv s))", "{"], ["proof (state)\nthis:\n  expectation_gpv' ?gpv \\<le> expectation_gpv 0 \\<I> (\\<lambda>a. 1) ?gpv\n  \\<lbrakk>\\<I> \\<turnstile>g ?gpv \\<surd>; I ?s\\<rbrakk>\n  \\<Longrightarrow> expectation_gpv' ?gpv\n                    \\<le> ennreal (weight_spmf (inline1 callee ?gpv ?s))\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv 0 \\<I> (\\<lambda>a. 1) gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> ennreal\n                                    (weight_spmf (inline1 callee gpv s));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. 1)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> ennreal (weight_spmf (inline1 callee gpv s))", "fix out c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv 0 \\<I> (\\<lambda>a. 1) gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> ennreal\n                                    (weight_spmf (inline1 callee gpv s));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. 1)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> ennreal (weight_spmf (inline1 callee gpv s))", "assume IO: \"IO out c \\<in> set_spmf (the_gpv gpv)\""], ["proof (state)\nthis:\n  IO out c \\<in> set_spmf (the_gpv gpv)\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv 0 \\<I> (\\<lambda>a. 1) gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> ennreal\n                                    (weight_spmf (inline1 callee gpv s));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. 1)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> ennreal (weight_spmf (inline1 callee gpv s))", "with step.prems"], ["proof (chain)\npicking this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n  IO out c \\<in> set_spmf (the_gpv gpv)", "have out: \"out \\<in> outs_\\<I> \\<I>\""], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n  IO out c \\<in> set_spmf (the_gpv gpv)\n\ngoal (1 subgoal):\n 1. out \\<in> outs_\\<I> \\<I>", "by(auto dest: WT_gpvD)"], ["proof (state)\nthis:\n  out \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv 0 \\<I> (\\<lambda>a. 1) gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> ennreal\n                                    (weight_spmf (inline1 callee gpv s));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. 1)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> ennreal (weight_spmf (inline1 callee gpv s))", "from out[unfolded in_outs_\\<I>_iff_responses_\\<I>]"], ["proof (chain)\npicking this:\n  responses_\\<I> \\<I> out \\<noteq> {}", "obtain input where input: \"input \\<in> responses_\\<I> \\<I> out\""], ["proof (prove)\nusing this:\n  responses_\\<I> \\<I> out \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>input.\n        input \\<in> responses_\\<I> \\<I> out \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  input \\<in> responses_\\<I> \\<I> out\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv 0 \\<I> (\\<lambda>a. 1) gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> ennreal\n                                    (weight_spmf (inline1 callee gpv s));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. 1)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> ennreal (weight_spmf (inline1 callee gpv s))", "from out"], ["proof (chain)\npicking this:\n  out \\<in> outs_\\<I> \\<I>", "have \"(\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) = \\<integral>\\<^sup>+ x. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) \\<partial>measure_spmf (the_gpv (callee s out))\""], ["proof (prove)\nusing this:\n  out \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) =\n    \\<integral>\\<^sup>+ x. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv (callee s out))", "using lossless \\<open>I s\\<close>"], ["proof (prove)\nusing this:\n  out \\<in> outs_\\<I> \\<I>\n  \\<lbrakk>?x \\<in> outs_\\<I> \\<I>; I ?s\\<rbrakk>\n  \\<Longrightarrow> lossless_spmf (the_gpv (callee ?s ?x))\n  I s\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) =\n    \\<integral>\\<^sup>+ x. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv (callee s out))", "by(simp add: lossless_spmf_def measure_spmf.emeasure_eq_measure)"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) =\n  \\<integral>\\<^sup>+ x. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                             expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv 0 \\<I> (\\<lambda>a. 1) gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> ennreal\n                                    (weight_spmf (inline1 callee gpv s));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. 1)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> ennreal (weight_spmf (inline1 callee gpv s))", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) =\n  \\<integral>\\<^sup>+ x. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                             expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv 0 \\<I> (\\<lambda>a. 1) gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> ennreal\n                                    (weight_spmf (inline1 callee gpv s));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. 1)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> ennreal (weight_spmf (inline1 callee gpv s))", "have \"\\<dots> \\<le> \\<integral>\\<^sup>+ generat. (case generat of Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s') | _ \\<Rightarrow> 1) \\<partial>measure_spmf (the_gpv (callee s out))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv (callee s out))\n    \\<le> \\<integral>\\<^sup>+ x. ennreal\n                                  (case x of\n                                   Pure (r, s') \\<Rightarrow>\n                                     weight_spmf (inline1 callee (c r) s')\n                                   | IO b ca \\<Rightarrow> 1)\n                             \\<partial>measure_spmf (the_gpv (callee s out))", "apply(intro nn_integral_mono_AE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x in measure_spmf\n             (the_gpv\n               (callee s\n                 out)). (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                            expectation_gpv' (c r))\n                        \\<le> ennreal\n                               (case x of\n                                Pure (r, s') \\<Rightarrow>\n                                  weight_spmf (inline1 callee (c r) s')\n                                | IO b ca \\<Rightarrow> 1)", "apply(clarsimp split!: generat.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       Pure (a, b) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> ennreal (weight_spmf (inline1 callee (c a) b))\n 2. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> 1", "subgoal Pure"], ["proof (prove)\ngoal (1 subgoal):\n 1. Pure (a_, b_) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n    (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> ennreal (weight_spmf (inline1 callee (c a_) b_))", "apply(rule INF_lower2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Pure (a_, b_) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n    ?r \\<in> responses_\\<I> \\<I> out\n 2. Pure (a_, b_) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n    expectation_gpv' (c ?r)\n    \\<le> ennreal (weight_spmf (inline1 callee (c a_) b_))", "apply(fastforce dest: results_callee[OF out \\<open>I s\\<close>, THEN subsetD, OF results_gpv.Pure])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Pure (a_, b_) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n    expectation_gpv' (c a_)\n    \\<le> ennreal (weight_spmf (inline1 callee (c a_) b_))", "apply(rule step.IH)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Pure (a_, b_) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n    \\<I> \\<turnstile>g c a_ \\<surd>\n 2. Pure (a_, b_) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n    I b_", "apply(fastforce intro: WT_gpvD[OF step.prems(1) IO] dest: results_callee[OF out \\<open>I s\\<close>, THEN subsetD, OF results_gpv.Pure])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Pure (a_, b_) \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n    I b_", "apply(fastforce dest: results_callee[OF out \\<open>I s\\<close>, THEN subsetD, OF results_gpv.Pure])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       IO x21 x22 \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> 1", "subgoal IO"], ["proof (prove)\ngoal (1 subgoal):\n 1. IO x21_ x22_ \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n    (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> 1", "apply(rule INF_lower2[OF input])"], ["proof (prove)\ngoal (1 subgoal):\n 1. IO x21_ x22_ \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n    expectation_gpv' (c input) \\<le> 1", "apply(rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. IO x21_ x22_ \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n    expectation_gpv' (c input) \\<le> ?y2\n 2. IO x21_ x22_ \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n    ?y2 \\<le> 1", "apply(rule step.hyps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. IO x21_ x22_ \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n    expectation_gpv 0 \\<I> (\\<lambda>a. 1) (c input) \\<le> 1", "apply(rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. IO x21_ x22_ \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n    expectation_gpv 0 \\<I> (\\<lambda>a. 1) (c input) \\<le> ?y6\n 2. IO x21_ x22_ \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n    ?y6 \\<le> 1", "apply(rule expectation_gpv_const_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. IO x21_ x22_ \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n    \\<I> \\<turnstile>g c input \\<surd>\n 2. IO x21_ x22_ \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n    max 1 0 \\<le> 1", "apply(rule WT_gpvD[OF step.prems(1) IO])"], ["proof (prove)\ngoal (2 subgoals):\n 1. IO x21_ x22_ \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n    input \\<in> responses_\\<I> \\<I> out\n 2. IO x21_ x22_ \\<in> set_spmf (the_gpv (callee s out)) \\<Longrightarrow>\n    max 1 0 \\<le> 1", "apply(simp_all add: input)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                             expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv (callee s out))\n  \\<le> \\<integral>\\<^sup>+ x. ennreal\n                                (case x of\n                                 Pure (r, s') \\<Rightarrow>\n                                   weight_spmf (inline1 callee (c r) s')\n                                 | IO b ca \\<Rightarrow> 1)\n                           \\<partial>measure_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv 0 \\<I> (\\<lambda>a. 1) gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> ennreal\n                                    (weight_spmf (inline1 callee gpv s));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. 1)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> ennreal (weight_spmf (inline1 callee gpv s))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> \\<integral>\\<^sup>+ x. ennreal\n                                (case x of\n                                 Pure (r, s') \\<Rightarrow>\n                                   weight_spmf (inline1 callee (c r) s')\n                                 | IO b ca \\<Rightarrow> 1)\n                           \\<partial>measure_spmf (the_gpv (callee s out))", "have \"(\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> \\<integral>\\<^sup>+ x. ennreal\n                                (case x of\n                                 Pure (r, s') \\<Rightarrow>\n                                   weight_spmf (inline1 callee (c r) s')\n                                 | IO b ca \\<Rightarrow> 1)\n                           \\<partial>measure_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> \\<integral>\\<^sup>+ x. ennreal\n                                  (case x of\n                                   Pure (r, s') \\<Rightarrow>\n                                     weight_spmf (inline1 callee (c r) s')\n                                   | IO b ca \\<Rightarrow> 1)\n                             \\<partial>measure_spmf (the_gpv (callee s out))", "."], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> \\<integral>\\<^sup>+ x. ennreal\n                                (case x of\n                                 Pure (r, s') \\<Rightarrow>\n                                   weight_spmf (inline1 callee (c r) s')\n                                 | IO b ca \\<Rightarrow> 1)\n                           \\<partial>measure_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv 0 \\<I> (\\<lambda>a. 1) gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> ennreal\n                                    (weight_spmf (inline1 callee gpv s));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. 1)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> ennreal (weight_spmf (inline1 callee gpv s))", "}"], ["proof (state)\nthis:\n  IO ?out2 ?c2 \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> ?out2. expectation_gpv' (?c2 r))\n  \\<le> \\<integral>\\<^sup>+ x. ennreal\n                                (case x of\n                                 Pure (r, s') \\<Rightarrow>\n                                   weight_spmf (inline1 callee (?c2 r) s')\n                                 | IO b ca \\<Rightarrow> 1)\n                           \\<partial>measure_spmf (the_gpv (callee s ?out2))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv\n                   \\<le> expectation_gpv 0 \\<I> (\\<lambda>a. 1) gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> ennreal\n                                    (weight_spmf (inline1 callee gpv s));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat (\\<lambda>x. 1)\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         0 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> ennreal (weight_spmf (inline1 callee gpv s))", "then"], ["proof (chain)\npicking this:\n  IO ?out2 ?c2 \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> ?out2. expectation_gpv' (?c2 r))\n  \\<le> \\<integral>\\<^sup>+ x. ennreal\n                                (case x of\n                                 Pure (r, s') \\<Rightarrow>\n                                   weight_spmf (inline1 callee (?c2 r) s')\n                                 | IO b ca \\<Rightarrow> 1)\n                           \\<partial>measure_spmf (the_gpv (callee s ?out2))", "show ?case"], ["proof (prove)\nusing this:\n  IO ?out2 ?c2 \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> ?out2. expectation_gpv' (?c2 r))\n  \\<le> \\<integral>\\<^sup>+ x. ennreal\n                                (case x of\n                                 Pure (r, s') \\<Rightarrow>\n                                   weight_spmf (inline1 callee (?c2 r) s')\n                                 | IO b ca \\<Rightarrow> 1)\n                           \\<partial>measure_spmf (the_gpv (callee s ?out2))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> 1\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    0 * ennreal (pmf (the_gpv gpv) None)\n    \\<le> ennreal (weight_spmf (inline1 callee gpv s))", "using step.prems"], ["proof (prove)\nusing this:\n  IO ?out2 ?c2 \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> ?out2. expectation_gpv' (?c2 r))\n  \\<le> \\<integral>\\<^sup>+ x. ennreal\n                                (case x of\n                                 Pure (r, s') \\<Rightarrow>\n                                   weight_spmf (inline1 callee (?c2 r) s')\n                                 | IO b ca \\<Rightarrow> 1)\n                           \\<partial>measure_spmf (the_gpv (callee s ?out2))\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> 1\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    0 * ennreal (pmf (the_gpv gpv) None)\n    \\<le> ennreal (weight_spmf (inline1 callee gpv s))", "apply(subst inline1.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>out c.\n                IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                    expectation_gpv' (c r))\n                \\<le> \\<integral>\\<^sup>+ x.\n     ennreal\n      (case x of\n       Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n       | IO b ca \\<Rightarrow> 1)\n   \\<partial>measure_spmf (the_gpv (callee s out));\n     \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                       (case_generat (\\<lambda>x. 1)\n                         (\\<lambda>out c.\n                             \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                expectation_gpv' (c r))) +\n                      0 * ennreal (pmf (the_gpv gpv) None)\n                      \\<le> ennreal\n                             (Sigma_Algebra.measure\n                               (measure_spmf\n                                 (the_gpv gpv \\<bind>\n                                  case_generat\n                                   (\\<lambda>x. return_spmf (Inl (x, s)))\n                                   (\\<lambda>out rpv.\n the_gpv (callee s out) \\<bind>\n case_generat (\\<lambda>(x, y). inline1 callee (rpv x) y)\n  (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))))\n                               (space\n                                 (measure_spmf (inline1 callee gpv s))))", "apply(simp add: measure_spmf.emeasure_eq_measure[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>out c.\n                IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                    expectation_gpv' (c r))\n                \\<le> \\<integral>\\<^sup>+ x.\n     ennreal\n      (case x of\n       Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n       | IO b ca \\<Rightarrow> 1)\n   \\<partial>measure_spmf (the_gpv (callee s out));\n     \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                       (case_generat (\\<lambda>x. 1)\n                         (\\<lambda>out c.\n                             \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                expectation_gpv' (c r)))\n                      \\<le> emeasure\n                             (measure_spmf\n                               (the_gpv gpv \\<bind>\n                                case_generat\n                                 (\\<lambda>x. return_spmf (Inl (x, s)))\n                                 (\\<lambda>out rpv.\n                                     the_gpv (callee s out) \\<bind>\n                                     case_generat\n(\\<lambda>(x, y). inline1 callee (rpv x) y)\n(\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))))\n                             (space (measure_spmf (inline1 callee gpv s)))", "apply(simp add: measure_spmf_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>out c.\n                IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                    expectation_gpv' (c r))\n                \\<le> \\<integral>\\<^sup>+ x.\n     ennreal\n      (case x of\n       Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n       | IO b ca \\<Rightarrow> 1)\n   \\<partial>measure_spmf (the_gpv (callee s out));\n     \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                       (case_generat (\\<lambda>x. 1)\n                         (\\<lambda>out c.\n                             \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                expectation_gpv' (c r)))\n                      \\<le> emeasure\n                             (measure_spmf (the_gpv gpv) \\<bind>\n                              measure_spmf \\<circ>\n                              case_generat\n                               (\\<lambda>x. return_spmf (Inl (x, s)))\n                               (\\<lambda>out rpv.\n                                   the_gpv (callee s out) \\<bind>\n                                   case_generat\n                                    (\\<lambda>(x, y).\n  inline1 callee (rpv x) y)\n                                    (\\<lambda>out rpv'.\n  return_spmf (Inr (out, rpv', rpv)))))\n                             (space (measure_spmf (inline1 callee gpv s)))", "apply(subst emeasure_bind[where N=\"count_space UNIV\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>out c.\n                IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                    expectation_gpv' (c r))\n                \\<le> \\<integral>\\<^sup>+ x.\n     ennreal\n      (case x of\n       Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n       | IO b ca \\<Rightarrow> 1)\n   \\<partial>measure_spmf (the_gpv (callee s out));\n     \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> space (measure_spmf (the_gpv gpv)) \\<noteq> {}\n 2. \\<lbrakk>\\<And>out c.\n                IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                    expectation_gpv' (c r))\n                \\<le> \\<integral>\\<^sup>+ x.\n     ennreal\n      (case x of\n       Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n       | IO b ca \\<Rightarrow> 1)\n   \\<partial>measure_spmf (the_gpv (callee s out));\n     \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> measure_spmf \\<circ>\n                      case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n                       (\\<lambda>out rpv.\n                           the_gpv (callee s out) \\<bind>\n                           case_generat\n                            (\\<lambda>(x, y). inline1 callee (rpv x) y)\n                            (\\<lambda>out rpv'.\n                                return_spmf (Inr (out, rpv', rpv))))\n                      \\<in> measure_spmf (the_gpv gpv) \\<rightarrow>\\<^sub>M\n                            subprob_algebra (count_space UNIV)\n 3. \\<lbrakk>\\<And>out c.\n                IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                    expectation_gpv' (c r))\n                \\<le> \\<integral>\\<^sup>+ x.\n     ennreal\n      (case x of\n       Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n       | IO b ca \\<Rightarrow> 1)\n   \\<partial>measure_spmf (the_gpv (callee s out));\n     \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> space (measure_spmf (inline1 callee gpv s))\n                      \\<in> sets (count_space UNIV)\n 4. \\<lbrakk>\\<And>out c.\n                IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                    expectation_gpv' (c r))\n                \\<le> \\<integral>\\<^sup>+ x.\n     ennreal\n      (case x of\n       Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n       | IO b ca \\<Rightarrow> 1)\n   \\<partial>measure_spmf (the_gpv (callee s out));\n     \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                       (case_generat (\\<lambda>x. 1)\n                         (\\<lambda>out c.\n                             \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                expectation_gpv' (c r)))\n                      \\<le> \\<integral>\\<^sup>+ x.\n           emeasure\n            ((measure_spmf \\<circ>\n              case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n               (\\<lambda>out rpv.\n                   the_gpv (callee s out) \\<bind>\n                   case_generat (\\<lambda>(x, y). inline1 callee (rpv x) y)\n                    (\\<lambda>out rpv'.\n                        return_spmf (Inr (out, rpv', rpv)))))\n              x)\n            (space (measure_spmf (inline1 callee gpv s)))\n         \\<partial>measure_spmf (the_gpv gpv)", "apply(simp add: space_measure_spmf)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>out c.\n                IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                    expectation_gpv' (c r))\n                \\<le> \\<integral>\\<^sup>+ x.\n     ennreal\n      (case x of\n       Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n       | IO b ca \\<Rightarrow> 1)\n   \\<partial>measure_spmf (the_gpv (callee s out));\n     \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> measure_spmf \\<circ>\n                      case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n                       (\\<lambda>out rpv.\n                           the_gpv (callee s out) \\<bind>\n                           case_generat\n                            (\\<lambda>(x, y). inline1 callee (rpv x) y)\n                            (\\<lambda>out rpv'.\n                                return_spmf (Inr (out, rpv', rpv))))\n                      \\<in> measure_spmf (the_gpv gpv) \\<rightarrow>\\<^sub>M\n                            subprob_algebra (count_space UNIV)\n 2. \\<lbrakk>\\<And>out c.\n                IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                    expectation_gpv' (c r))\n                \\<le> \\<integral>\\<^sup>+ x.\n     ennreal\n      (case x of\n       Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n       | IO b ca \\<Rightarrow> 1)\n   \\<partial>measure_spmf (the_gpv (callee s out));\n     \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> space (measure_spmf (inline1 callee gpv s))\n                      \\<in> sets (count_space UNIV)\n 3. \\<lbrakk>\\<And>out c.\n                IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                    expectation_gpv' (c r))\n                \\<le> \\<integral>\\<^sup>+ x.\n     ennreal\n      (case x of\n       Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n       | IO b ca \\<Rightarrow> 1)\n   \\<partial>measure_spmf (the_gpv (callee s out));\n     \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                       (case_generat (\\<lambda>x. 1)\n                         (\\<lambda>out c.\n                             \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                expectation_gpv' (c r)))\n                      \\<le> \\<integral>\\<^sup>+ x.\n           emeasure\n            ((measure_spmf \\<circ>\n              case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n               (\\<lambda>out rpv.\n                   the_gpv (callee s out) \\<bind>\n                   case_generat (\\<lambda>(x, y). inline1 callee (rpv x) y)\n                    (\\<lambda>out rpv'.\n                        return_spmf (Inr (out, rpv', rpv)))))\n              x)\n            (space (measure_spmf (inline1 callee gpv s)))\n         \\<partial>measure_spmf (the_gpv gpv)", "apply(simp add: o_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>out c.\n                IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                    expectation_gpv' (c r))\n                \\<le> \\<integral>\\<^sup>+ x.\n     ennreal\n      (case x of\n       Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n       | IO b ca \\<Rightarrow> 1)\n   \\<partial>measure_spmf (the_gpv (callee s out));\n     \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> space (measure_spmf (inline1 callee gpv s))\n                      \\<in> sets (count_space UNIV)\n 2. \\<lbrakk>\\<And>out c.\n                IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                    expectation_gpv' (c r))\n                \\<le> \\<integral>\\<^sup>+ x.\n     ennreal\n      (case x of\n       Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n       | IO b ca \\<Rightarrow> 1)\n   \\<partial>measure_spmf (the_gpv (callee s out));\n     \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                       (case_generat (\\<lambda>x. 1)\n                         (\\<lambda>out c.\n                             \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                expectation_gpv' (c r)))\n                      \\<le> \\<integral>\\<^sup>+ x.\n           emeasure\n            ((measure_spmf \\<circ>\n              case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n               (\\<lambda>out rpv.\n                   the_gpv (callee s out) \\<bind>\n                   case_generat (\\<lambda>(x, y). inline1 callee (rpv x) y)\n                    (\\<lambda>out rpv'.\n                        return_spmf (Inr (out, rpv', rpv)))))\n              x)\n            (space (measure_spmf (inline1 callee gpv s)))\n         \\<partial>measure_spmf (the_gpv gpv)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>out c.\n                IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                    expectation_gpv' (c r))\n                \\<le> \\<integral>\\<^sup>+ x.\n     ennreal\n      (case x of\n       Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n       | IO b ca \\<Rightarrow> 1)\n   \\<partial>measure_spmf (the_gpv (callee s out));\n     \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                       (case_generat (\\<lambda>x. 1)\n                         (\\<lambda>out c.\n                             \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                expectation_gpv' (c r)))\n                      \\<le> \\<integral>\\<^sup>+ x.\n           emeasure\n            ((measure_spmf \\<circ>\n              case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n               (\\<lambda>out rpv.\n                   the_gpv (callee s out) \\<bind>\n                   case_generat (\\<lambda>(x, y). inline1 callee (rpv x) y)\n                    (\\<lambda>out rpv'.\n                        return_spmf (Inr (out, rpv', rpv)))))\n              x)\n            (space (measure_spmf (inline1 callee gpv s)))\n         \\<partial>measure_spmf (the_gpv gpv)", "apply(rule nn_integral_mono_AE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>out c.\n                IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                    expectation_gpv' (c r))\n                \\<le> \\<integral>\\<^sup>+ x.\n     ennreal\n      (case x of\n       Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n       | IO b ca \\<Rightarrow> 1)\n   \\<partial>measure_spmf (the_gpv (callee s out));\n     \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> AE x in measure_spmf\n                               (the_gpv\n                                 gpv). (case x of Pure x \\<Rightarrow> 1\n  | IO out c \\<Rightarrow>\n      \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n \\<le> emeasure\n        ((measure_spmf \\<circ>\n          case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n           (\\<lambda>out rpv.\n               the_gpv (callee s out) \\<bind>\n               case_generat (\\<lambda>(x, y). inline1 callee (rpv x) y)\n                (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))\n          x)\n        (space (measure_spmf (inline1 callee gpv s)))", "apply(clarsimp split!: generat.split simp add: measure_spmf_return_spmf space_measure_spmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> \\<integral>\\<^sup>+ x.\n        ennreal\n         (case x of\n          Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n          | IO b ca \\<Rightarrow> 1)\n      \\<partial>measure_spmf (the_gpv (callee s out));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> emeasure\n                                (measure_spmf\n                                  (the_gpv (callee s x21) \\<bind>\n                                   case_generat\n                                    (\\<lambda>(x, y).\n  inline1 callee (x22 x) y)\n                                    (\\<lambda>out rpv'.\n  return_spmf (Inr (out, rpv', x22)))))\n                                UNIV", "apply(simp add: measure_spmf_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> \\<integral>\\<^sup>+ x.\n        ennreal\n         (case x of\n          Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n          | IO b ca \\<Rightarrow> 1)\n      \\<partial>measure_spmf (the_gpv (callee s out));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> emeasure\n                                (measure_spmf\n                                  (the_gpv (callee s x21)) \\<bind>\n                                 measure_spmf \\<circ>\n                                 case_generat\n                                  (\\<lambda>(x, y).\ninline1 callee (x22 x) y)\n                                  (\\<lambda>out rpv'.\nreturn_spmf (Inr (out, rpv', x22))))\n                                UNIV", "apply(subst emeasure_bind[where N=\"count_space UNIV\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> \\<integral>\\<^sup>+ x.\n        ennreal\n         (case x of\n          Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n          | IO b ca \\<Rightarrow> 1)\n      \\<partial>measure_spmf (the_gpv (callee s out));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> space\n                          (measure_spmf (the_gpv (callee s x21))) \\<noteq>\n                         {}\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> \\<integral>\\<^sup>+ x.\n        ennreal\n         (case x of\n          Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n          | IO b ca \\<Rightarrow> 1)\n      \\<partial>measure_spmf (the_gpv (callee s out));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> measure_spmf \\<circ>\n                         case_generat\n                          (\\<lambda>(x, y). inline1 callee (x22 x) y)\n                          (\\<lambda>out rpv'.\n                              return_spmf (Inr (out, rpv', x22)))\n                         \\<in> measure_spmf\n                                (the_gpv\n                                  (callee s x21)) \\<rightarrow>\\<^sub>M\n                               subprob_algebra (count_space UNIV)\n 3. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> \\<integral>\\<^sup>+ x.\n        ennreal\n         (case x of\n          Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n          | IO b ca \\<Rightarrow> 1)\n      \\<partial>measure_spmf (the_gpv (callee s out));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> UNIV \\<in> sets (count_space UNIV)\n 4. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> \\<integral>\\<^sup>+ x.\n        ennreal\n         (case x of\n          Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n          | IO b ca \\<Rightarrow> 1)\n      \\<partial>measure_spmf (the_gpv (callee s out));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> \\<integral>\\<^sup>+ x.\n              emeasure\n               ((measure_spmf \\<circ>\n                 case_generat (\\<lambda>(x, y). inline1 callee (x22 x) y)\n                  (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', x22))))\n                 x)\n               UNIV\n            \\<partial>measure_spmf (the_gpv (callee s x21))", "apply(simp add: space_measure_spmf)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> \\<integral>\\<^sup>+ x.\n        ennreal\n         (case x of\n          Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n          | IO b ca \\<Rightarrow> 1)\n      \\<partial>measure_spmf (the_gpv (callee s out));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> measure_spmf \\<circ>\n                         case_generat\n                          (\\<lambda>(x, y). inline1 callee (x22 x) y)\n                          (\\<lambda>out rpv'.\n                              return_spmf (Inr (out, rpv', x22)))\n                         \\<in> measure_spmf\n                                (the_gpv\n                                  (callee s x21)) \\<rightarrow>\\<^sub>M\n                               subprob_algebra (count_space UNIV)\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> \\<integral>\\<^sup>+ x.\n        ennreal\n         (case x of\n          Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n          | IO b ca \\<Rightarrow> 1)\n      \\<partial>measure_spmf (the_gpv (callee s out));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> UNIV \\<in> sets (count_space UNIV)\n 3. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> \\<integral>\\<^sup>+ x.\n        ennreal\n         (case x of\n          Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n          | IO b ca \\<Rightarrow> 1)\n      \\<partial>measure_spmf (the_gpv (callee s out));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> \\<integral>\\<^sup>+ x.\n              emeasure\n               ((measure_spmf \\<circ>\n                 case_generat (\\<lambda>(x, y). inline1 callee (x22 x) y)\n                  (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', x22))))\n                 x)\n               UNIV\n            \\<partial>measure_spmf (the_gpv (callee s x21))", "apply(simp add: o_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> \\<integral>\\<^sup>+ x.\n        ennreal\n         (case x of\n          Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n          | IO b ca \\<Rightarrow> 1)\n      \\<partial>measure_spmf (the_gpv (callee s out));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> UNIV \\<in> sets (count_space UNIV)\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> \\<integral>\\<^sup>+ x.\n        ennreal\n         (case x of\n          Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n          | IO b ca \\<Rightarrow> 1)\n      \\<partial>measure_spmf (the_gpv (callee s out));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> \\<integral>\\<^sup>+ x.\n              emeasure\n               ((measure_spmf \\<circ>\n                 case_generat (\\<lambda>(x, y). inline1 callee (x22 x) y)\n                  (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', x22))))\n                 x)\n               UNIV\n            \\<partial>measure_spmf (the_gpv (callee s x21))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> \\<integral>\\<^sup>+ x.\n        ennreal\n         (case x of\n          Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n          | IO b ca \\<Rightarrow> 1)\n      \\<partial>measure_spmf (the_gpv (callee s out));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> \\<integral>\\<^sup>+ x.\n              emeasure\n               ((measure_spmf \\<circ>\n                 case_generat (\\<lambda>(x, y). inline1 callee (x22 x) y)\n                  (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', x22))))\n                 x)\n               UNIV\n            \\<partial>measure_spmf (the_gpv (callee s x21))", "apply (simp add: measure_spmf.emeasure_eq_measure)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> \\<integral>\\<^sup>+ x.\n        ennreal\n         (case x of\n          Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n          | IO b ca \\<Rightarrow> 1)\n      \\<partial>measure_spmf (the_gpv (callee s out));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> \\<integral>\\<^sup>+ x.\n              ennreal\n               (Sigma_Algebra.measure\n                 (measure_spmf\n                   (case x of\n                    Pure (xa, xb) \\<Rightarrow> inline1 callee (x22 xa) xb\n                    | IO out rpv' \\<Rightarrow>\n                        return_spmf (Inr (out, rpv', x22))))\n                 UNIV)\n            \\<partial>measure_spmf (the_gpv (callee s x21))", "apply(subst generat.case_distrib[where h=\"\\<lambda>x. measure (measure_spmf x) _\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>out c.\n                   IO out c \\<in> set_spmf (the_gpv gpv) \\<Longrightarrow>\n                   (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                       expectation_gpv' (c r))\n                   \\<le> \\<integral>\\<^sup>+ x.\n        ennreal\n         (case x of\n          Pure (r, s') \\<Rightarrow> weight_spmf (inline1 callee (c r) s')\n          | IO b ca \\<Rightarrow> 1)\n      \\<partial>measure_spmf (the_gpv (callee s out));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO x21 x22 \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> x21.\n                             expectation_gpv' (x22 r))\n                         \\<le> \\<integral>\\<^sup>+ x.\n              ennreal\n               (case x of\n                Pure x \\<Rightarrow>\n                  Sigma_Algebra.measure\n                   (measure_spmf\n                     (case x of\n                      (x, xa) \\<Rightarrow> inline1 callee (x22 x) xa))\n                   UNIV\n                | IO x1 x2 \\<Rightarrow>\n                    Sigma_Algebra.measure\n                     (measure_spmf (return_spmf (Inr (x1, x2, x22)))) UNIV)\n            \\<partial>measure_spmf (the_gpv (callee s x21))", "apply(simp add: split_def measure_spmf_return_spmf space_measure_spmf measure_return cong del: generat.case_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> 1\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  0 * ennreal (pmf (the_gpv gpv) None)\n  \\<le> ennreal (weight_spmf (inline1 callee gpv s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  expectation_gpv 0 \\<I> (\\<lambda>_. 1) gpv\n  \\<le> ennreal (weight_spmf (inline1 callee gpv s))\n\ngoal (1 subgoal):\n 1. lossless_spmf (inline1 callee gpv s)", "finally"], ["proof (chain)\npicking this:\n  1 \\<le> ennreal (weight_spmf (inline1 callee gpv s))", "show ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> ennreal (weight_spmf (inline1 callee gpv s))\n\ngoal (1 subgoal):\n 1. lossless_spmf (inline1 callee gpv s)", "using weight_spmf_le_1[of \"inline1 callee gpv s\"]"], ["proof (prove)\nusing this:\n  1 \\<le> ennreal (weight_spmf (inline1 callee gpv s))\n  weight_spmf (inline1 callee gpv s) \\<le> 1\n\ngoal (1 subgoal):\n 1. lossless_spmf (inline1 callee gpv s)", "by(simp add: lossless_spmf_def)"], ["proof (state)\nthis:\n  lossless_spmf (inline1 callee gpv s)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "lemma (in raw_converter_invariant) inline1_try_gpv:\n  defines \"inline1' \\<equiv> inline1\"\n  assumes WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and pfinite: \"pfinite_gpv \\<I> gpv\"\n    and f: \"\\<And>s. I s \\<Longrightarrow> f (x, s) = z\"\n    and lossless: \"\\<And>s x. \\<lbrakk> x \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> colossless_gpv \\<I>' (callee s x)\"\n    and I: \"I s\"\n  shows \"map_spmf (map_sum f id) (inline1 callee (try_gpv gpv (Done x)) s) =\n   try_spmf (map_spmf (map_sum f (\\<lambda>(out, c, rpv). (out, c, \\<lambda>input. try_gpv (rpv input) (Done x)))) (inline1' callee gpv s)) (return_spmf (Inl z))\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (map_sum f id) (inline1 callee (TRY gpv ELSE Done x) s) =\n    TRY map_spmf\n         (map_sum f\n           (\\<lambda>(out, c, rpv).\n               (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n         (inline1' callee gpv s) ELSE return_spmf (Inl z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_spmf (map_sum f id) (inline1 callee (TRY gpv ELSE Done x) s) =\n    TRY map_spmf\n         (map_sum f\n           (\\<lambda>(out, c, rpv).\n               (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n         (inline1' callee gpv s) ELSE return_spmf (Inl z)", "have le: \"ord_spmf (=) ?lhs ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (map_spmf (map_sum f id) (inline1 callee (TRY gpv ELSE Done x) s))\n     (TRY map_spmf\n           (map_sum f\n             (\\<lambda>(out, c, rpv).\n                 (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n           (inline1' callee gpv s) ELSE return_spmf (Inl z))", "using WT I"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (map_spmf (map_sum f id) (inline1 callee (TRY gpv ELSE Done x) s))\n     (TRY map_spmf\n           (map_sum f\n             (\\<lambda>(out, c, rpv).\n                 (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n           (inline1' callee gpv s) ELSE return_spmf (Inl z))", "proof(induction arbitrary: gpv s rule: inline1_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>inline1'a.\n         \\<forall>xa.\n            \\<I> \\<turnstile>g xa \\<surd> \\<longrightarrow>\n            (\\<forall>xb.\n                I xb \\<longrightarrow>\n                ord_spmf (=)\n                 (map_spmf (map_sum f id)\n                   (inline1'a (TRY xa ELSE Done x, xb)))\n                 (TRY map_spmf\n                       (map_sum f\n                         (\\<lambda>(out, c, rpv).\n                             (out, c,\n                              \\<lambda>input. TRY rpv input ELSE Done x)))\n                       (inline1' callee xa xb) ELSE return_spmf (Inl z))))\n 2. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf (map_sum f id) (return_pmf None))\n                          (TRY map_spmf\n                                (map_sum f\n                                  (\\<lambda>(out, c, rpv).\n(out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n                                (inline1' callee gpv\n                                  s) ELSE return_spmf (Inl z))\n 3. \\<And>inline1'a gpv s.\n       \\<lbrakk>\\<And>gpv s.\n                   \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n                   \\<Longrightarrow> ord_spmf (=)\n(map_spmf (map_sum f id) (inline1'a (TRY gpv ELSE Done x) s))\n(TRY map_spmf\n      (map_sum f\n        (\\<lambda>(out, c, rpv).\n            (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n      (inline1' callee gpv s) ELSE return_spmf (Inl z));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf (map_sum f id)\n                            (the_gpv (TRY gpv ELSE Done x) \\<bind>\n                             case_generat\n                              (\\<lambda>x. return_spmf (Inl (x, s)))\n                              (\\<lambda>out rpv.\n                                  the_gpv (callee s out) \\<bind>\n                                  case_generat\n                                   (\\<lambda>(x, y). inline1'a (rpv x) y)\n                                   (\\<lambda>out rpv'.\n return_spmf (Inr (out, rpv', rpv))))))\n                          (TRY map_spmf\n                                (map_sum f\n                                  (\\<lambda>(out, c, rpv).\n(out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n                                (inline1' callee gpv\n                                  s) ELSE return_spmf (Inl z))", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. spmf.admissible\n     (\\<lambda>inline1'a.\n         \\<forall>xa.\n            \\<I> \\<turnstile>g xa \\<surd> \\<longrightarrow>\n            (\\<forall>xb.\n                I xb \\<longrightarrow>\n                ord_spmf (=)\n                 (map_spmf (map_sum f id)\n                   (inline1'a (TRY xa ELSE Done x, xb)))\n                 (TRY map_spmf\n                       (map_sum f\n                         (\\<lambda>(out, c, rpv).\n                             (out, c,\n                              \\<lambda>input. TRY rpv input ELSE Done x)))\n                       (inline1' callee xa xb) ELSE return_spmf (Inl z))))\n 2. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf (map_sum f id) (return_pmf None))\n                          (TRY map_spmf\n                                (map_sum f\n                                  (\\<lambda>(out, c, rpv).\n(out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n                                (inline1' callee gpv\n                                  s) ELSE return_spmf (Inl z))\n 3. \\<And>inline1'a gpv s.\n       \\<lbrakk>\\<And>gpv s.\n                   \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n                   \\<Longrightarrow> ord_spmf (=)\n(map_spmf (map_sum f id) (inline1'a (TRY gpv ELSE Done x) s))\n(TRY map_spmf\n      (map_sum f\n        (\\<lambda>(out, c, rpv).\n            (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n      (inline1' callee gpv s) ELSE return_spmf (Inl z));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf (map_sum f id)\n                            (the_gpv (TRY gpv ELSE Done x) \\<bind>\n                             case_generat\n                              (\\<lambda>x. return_spmf (Inl (x, s)))\n                              (\\<lambda>out rpv.\n                                  the_gpv (callee s out) \\<bind>\n                                  case_generat\n                                   (\\<lambda>(x, y). inline1'a (rpv x) y)\n                                   (\\<lambda>out rpv'.\n return_spmf (Inr (out, rpv', rpv))))))\n                          (TRY map_spmf\n                                (map_sum f\n                                  (\\<lambda>(out, c, rpv).\n(out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n                                (inline1' callee gpv\n                                  s) ELSE return_spmf (Inl z))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf.admissible\n     (\\<lambda>inline1'a.\n         \\<forall>xa.\n            \\<I> \\<turnstile>g xa \\<surd> \\<longrightarrow>\n            (\\<forall>xaa.\n                I xaa \\<longrightarrow>\n                ord_spmf (=)\n                 (map_spmf (map_sum f id)\n                   (inline1'a (TRY xa ELSE Done x, xaa)))\n                 (TRY map_spmf\n                       (map_sum f\n                         (\\<lambda>a.\n                             case a of\n                             (out, c, rpv) \\<Rightarrow>\n                               (out, c,\n                                \\<lambda>input. TRY rpv input ELSE Done x)))\n                       (inline1' callee xa xaa) ELSE return_spmf (Inl z))))", "by simp"], ["proof (state)\nthis:\n  spmf.admissible\n   (\\<lambda>inline1'a.\n       \\<forall>xa.\n          \\<I> \\<turnstile>g xa \\<surd> \\<longrightarrow>\n          (\\<forall>xaa.\n              I xaa \\<longrightarrow>\n              ord_spmf (=)\n               (map_spmf (map_sum f id)\n                 (inline1'a (TRY xa ELSE Done x, xaa)))\n               (TRY map_spmf\n                     (map_sum f\n                       (\\<lambda>a.\n                           case a of\n                           (out, c, rpv) \\<Rightarrow>\n                             (out, c,\n                              \\<lambda>input. TRY rpv input ELSE Done x)))\n                     (inline1' callee xa xaa) ELSE return_spmf (Inl z))))\n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf (map_sum f id) (return_pmf None))\n                          (TRY map_spmf\n                                (map_sum f\n                                  (\\<lambda>(out, c, rpv).\n(out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n                                (inline1' callee gpv\n                                  s) ELSE return_spmf (Inl z))\n 2. \\<And>inline1'a gpv s.\n       \\<lbrakk>\\<And>gpv s.\n                   \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n                   \\<Longrightarrow> ord_spmf (=)\n(map_spmf (map_sum f id) (inline1'a (TRY gpv ELSE Done x) s))\n(TRY map_spmf\n      (map_sum f\n        (\\<lambda>(out, c, rpv).\n            (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n      (inline1' callee gpv s) ELSE return_spmf (Inl z));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf (map_sum f id)\n                            (the_gpv (TRY gpv ELSE Done x) \\<bind>\n                             case_generat\n                              (\\<lambda>x. return_spmf (Inl (x, s)))\n                              (\\<lambda>out rpv.\n                                  the_gpv (callee s out) \\<bind>\n                                  case_generat\n                                   (\\<lambda>(x, y). inline1'a (rpv x) y)\n                                   (\\<lambda>out rpv'.\n return_spmf (Inr (out, rpv', rpv))))))\n                          (TRY map_spmf\n                                (map_sum f\n                                  (\\<lambda>(out, c, rpv).\n(out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n                                (inline1' callee gpv\n                                  s) ELSE return_spmf (Inl z))", "case bottom"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf (map_sum f id) (return_pmf None))\n                          (TRY map_spmf\n                                (map_sum f\n                                  (\\<lambda>(out, c, rpv).\n(out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n                                (inline1' callee gpv\n                                  s) ELSE return_spmf (Inl z))\n 2. \\<And>inline1'a gpv s.\n       \\<lbrakk>\\<And>gpv s.\n                   \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n                   \\<Longrightarrow> ord_spmf (=)\n(map_spmf (map_sum f id) (inline1'a (TRY gpv ELSE Done x) s))\n(TRY map_spmf\n      (map_sum f\n        (\\<lambda>(out, c, rpv).\n            (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n      (inline1' callee gpv s) ELSE return_spmf (Inl z));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf (map_sum f id)\n                            (the_gpv (TRY gpv ELSE Done x) \\<bind>\n                             case_generat\n                              (\\<lambda>x. return_spmf (Inl (x, s)))\n                              (\\<lambda>out rpv.\n                                  the_gpv (callee s out) \\<bind>\n                                  case_generat\n                                   (\\<lambda>(x, y). inline1'a (rpv x) y)\n                                   (\\<lambda>out rpv'.\n return_spmf (Inr (out, rpv', rpv))))))\n                          (TRY map_spmf\n                                (map_sum f\n                                  (\\<lambda>(out, c, rpv).\n(out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n                                (inline1' callee gpv\n                                  s) ELSE return_spmf (Inl z))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=) (map_spmf (map_sum f id) (return_pmf None))\n     (TRY map_spmf\n           (map_sum f\n             (\\<lambda>a.\n                 case a of\n                 (out, c, rpv) \\<Rightarrow>\n                   (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n           (inline1' callee gpv s) ELSE return_spmf (Inl z))", "by simp"], ["proof (state)\nthis:\n  ord_spmf (=) (map_spmf (map_sum f id) (return_pmf None))\n   (TRY map_spmf\n         (map_sum f\n           (\\<lambda>a.\n               case a of\n               (out, c, rpv) \\<Rightarrow>\n                 (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n         (inline1' callee gpv s) ELSE return_spmf (Inl z))\n\ngoal (1 subgoal):\n 1. \\<And>inline1'a gpv s.\n       \\<lbrakk>\\<And>gpv s.\n                   \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n                   \\<Longrightarrow> ord_spmf (=)\n(map_spmf (map_sum f id) (inline1'a (TRY gpv ELSE Done x) s))\n(TRY map_spmf\n      (map_sum f\n        (\\<lambda>(out, c, rpv).\n            (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n      (inline1' callee gpv s) ELSE return_spmf (Inl z));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf (map_sum f id)\n                            (the_gpv (TRY gpv ELSE Done x) \\<bind>\n                             case_generat\n                              (\\<lambda>x. return_spmf (Inl (x, s)))\n                              (\\<lambda>out rpv.\n                                  the_gpv (callee s out) \\<bind>\n                                  case_generat\n                                   (\\<lambda>(x, y). inline1'a (rpv x) y)\n                                   (\\<lambda>out rpv'.\n return_spmf (Inr (out, rpv', rpv))))))\n                          (TRY map_spmf\n                                (map_sum f\n                                  (\\<lambda>(out, c, rpv).\n(out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n                                (inline1' callee gpv\n                                  s) ELSE return_spmf (Inl z))", "case (step inline1'')"], ["proof (state)\nthis:\n  \\<lbrakk>\\<I> \\<turnstile>g ?gpv \\<surd>; I ?s\\<rbrakk>\n  \\<Longrightarrow> ord_spmf (=)\n                     (map_spmf (map_sum f id)\n                       (inline1'' (TRY ?gpv ELSE Done x) ?s))\n                     (TRY map_spmf\n                           (map_sum f\n                             (\\<lambda>a.\n                                 case a of\n                                 (out, c, rpv) \\<Rightarrow>\n                                   (out, c,\n                                    \\<lambda>input.\n TRY rpv input ELSE Done x)))\n                           (inline1' callee ?gpv\n                             ?s) ELSE return_spmf (Inl z))\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. \\<And>inline1'a gpv s.\n       \\<lbrakk>\\<And>gpv s.\n                   \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n                   \\<Longrightarrow> ord_spmf (=)\n(map_spmf (map_sum f id) (inline1'a (TRY gpv ELSE Done x) s))\n(TRY map_spmf\n      (map_sum f\n        (\\<lambda>(out, c, rpv).\n            (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n      (inline1' callee gpv s) ELSE return_spmf (Inl z));\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf (map_sum f id)\n                            (the_gpv (TRY gpv ELSE Done x) \\<bind>\n                             case_generat\n                              (\\<lambda>x. return_spmf (Inl (x, s)))\n                              (\\<lambda>out rpv.\n                                  the_gpv (callee s out) \\<bind>\n                                  case_generat\n                                   (\\<lambda>(x, y). inline1'a (rpv x) y)\n                                   (\\<lambda>out rpv'.\n return_spmf (Inr (out, rpv', rpv))))))\n                          (TRY map_spmf\n                                (map_sum f\n                                  (\\<lambda>(out, c, rpv).\n(out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n                                (inline1' callee gpv\n                                  s) ELSE return_spmf (Inl z))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (map_spmf (map_sum f id)\n       (the_gpv (TRY gpv ELSE Done x) \\<bind>\n        case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n         (\\<lambda>out rpv.\n             the_gpv (callee s out) \\<bind>\n             case_generat (\\<lambda>(x, y). inline1'' (rpv x) y)\n              (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))))\n     (TRY map_spmf\n           (map_sum f\n             (\\<lambda>a.\n                 case a of\n                 (out, c, rpv) \\<Rightarrow>\n                   (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n           (inline1' callee gpv s) ELSE return_spmf (Inl z))", "using step.prems"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (map_spmf (map_sum f id)\n       (the_gpv (TRY gpv ELSE Done x) \\<bind>\n        case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n         (\\<lambda>out rpv.\n             the_gpv (callee s out) \\<bind>\n             case_generat (\\<lambda>(x, y). inline1'' (rpv x) y)\n              (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))))\n     (TRY map_spmf\n           (map_sum f\n             (\\<lambda>a.\n                 case a of\n                 (out, c, rpv) \\<Rightarrow>\n                   (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n           (inline1' callee gpv s) ELSE return_spmf (Inl z))", "unfolding inline1'_def"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. ord_spmf (=)\n     (map_spmf (map_sum f id)\n       (the_gpv (TRY gpv ELSE Done x) \\<bind>\n        case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n         (\\<lambda>out rpv.\n             the_gpv (callee s out) \\<bind>\n             case_generat (\\<lambda>(x, y). inline1'' (rpv x) y)\n              (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))))\n     (TRY map_spmf\n           (map_sum f\n             (\\<lambda>a.\n                 case a of\n                 (out, c, rpv) \\<Rightarrow>\n                   (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n           (inline1 callee gpv s) ELSE return_spmf (Inl z))", "apply(subst inline1.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> ord_spmf (=)\n                       (map_spmf (map_sum f id)\n                         (the_gpv (TRY gpv ELSE Done x) \\<bind>\n                          case_generat\n                           (\\<lambda>x. return_spmf (Inl (x, s)))\n                           (\\<lambda>out rpv.\n                               the_gpv (callee s out) \\<bind>\n                               case_generat\n                                (\\<lambda>(x, y). inline1'' (rpv x) y)\n                                (\\<lambda>out rpv'.\n                                    return_spmf (Inr (out, rpv', rpv))))))\n                       (TRY map_spmf\n                             (map_sum f\n                               (\\<lambda>(out, c, rpv).\n                                   (out, c,\n                                    \\<lambda>input.\n TRY rpv input ELSE Done x)))\n                             (the_gpv gpv \\<bind>\n                              case_generat\n                               (\\<lambda>x. return_spmf (Inl (x, s)))\n                               (\\<lambda>out rpv.\n                                   the_gpv (callee s out) \\<bind>\n                                   case_generat\n                                    (\\<lambda>(x, y).\n  inline1 callee (rpv x) y)\n                                    (\\<lambda>out rpv'.\n  return_spmf (Inr (out, rpv', rpv))))) ELSE return_spmf (Inl z))", "apply(simp add: bind_map_spmf map_bind_spmf o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> ord_spmf (=)\n                       (TRY map_spmf (map_generat id id (map_fun id Inl))\n                             (the_gpv gpv) ELSE return_spmf (Pure x) \\<bind>\n                        (\\<lambda>xa.\n                            map_spmf (map_sum f id)\n                             (case map_generat id id\n                                    (\\<lambda>c input.\n  case c input of Inl gpv \\<Rightarrow> TRY gpv ELSE Done x\n  | Inr gpv' \\<Rightarrow> gpv')\n                                    xa of\n                              Pure x \\<Rightarrow> return_spmf (Inl (x, s))\n                              | IO out rpv \\<Rightarrow>\n                                  the_gpv (callee s out) \\<bind>\n                                  case_generat\n                                   (\\<lambda>(x, y). inline1'' (rpv x) y)\n                                   (\\<lambda>out rpv'.\n return_spmf (Inr (out, rpv', rpv))))))\n                       (TRY the_gpv gpv \\<bind>\n                            (\\<lambda>xa.\n                                map_spmf\n                                 (map_sum f\n                                   (\\<lambda>(out, c, rpv).\n (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n                                 (case xa of\n                                  Pure x \\<Rightarrow>\n                                    return_spmf (Inl (x, s))\n                                  | IO out rpv \\<Rightarrow>\nthe_gpv (callee s out) \\<bind>\ncase_generat (\\<lambda>(x, y). inline1 callee (rpv x) y)\n (\\<lambda>out rpv'.\n     return_spmf (Inr (out, rpv', rpv))))) ELSE return_spmf (Inl z))", "apply(simp add: try_spmf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> ord_spmf (=)\n                       (map_spmf (map_generat id id (map_fun id Inl))\n                         (the_gpv gpv) \\<bind>\n                        (\\<lambda>xa.\n                            case xa of\n                            None \\<Rightarrow> return_spmf (Pure x)\n                            | Some y \\<Rightarrow> return_spmf y) \\<bind>\n                        (\\<lambda>xa.\n                            map_spmf (map_sum f id)\n                             (case map_generat id id\n                                    (\\<lambda>c input.\n  case c input of Inl gpv \\<Rightarrow> TRY gpv ELSE Done x\n  | Inr gpv' \\<Rightarrow> gpv')\n                                    xa of\n                              Pure x \\<Rightarrow> return_spmf (Inl (x, s))\n                              | IO out rpv \\<Rightarrow>\n                                  the_gpv (callee s out) \\<bind>\n                                  case_generat\n                                   (\\<lambda>(x, y). inline1'' (rpv x) y)\n                                   (\\<lambda>out rpv'.\n return_spmf (Inr (out, rpv', rpv))))))\n                       (the_gpv gpv \\<bind>\n                        (\\<lambda>xa.\n                            map_spmf\n                             (map_sum f\n                               (\\<lambda>(out, c, rpv).\n                                   (out, c,\n                                    \\<lambda>input.\n TRY rpv input ELSE Done x)))\n                             (case xa of\n                              Pure x \\<Rightarrow> return_spmf (Inl (x, s))\n                              | IO out rpv \\<Rightarrow>\n                                  the_gpv (callee s out) \\<bind>\n                                  case_generat\n                                   (\\<lambda>(x, y).\n inline1 callee (rpv x) y)\n                                   (\\<lambda>out rpv'.\n return_spmf (Inr (out, rpv', rpv))))) \\<bind>\n                        (\\<lambda>x.\n                            case x of None \\<Rightarrow> return_spmf (Inl z)\n                            | Some y \\<Rightarrow> return_spmf y))", "apply(subst bind_spmf_pmf_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> ord_spmf (=)\n                       (map_spmf (map_generat id id (map_fun id Inl))\n                         (the_gpv gpv) \\<bind>\n                        (\\<lambda>xa.\n                            (case xa of\n                             None \\<Rightarrow> return_spmf (Pure x)\n                             | Some y \\<Rightarrow> return_spmf y) \\<bind>\n                            (\\<lambda>xa.\n                                map_spmf (map_sum f id)\n                                 (case map_generat id id\n  (\\<lambda>c input.\n      case c input of Inl gpv \\<Rightarrow> TRY gpv ELSE Done x\n      | Inr gpv' \\<Rightarrow> gpv')\n  xa of\n                                  Pure x \\<Rightarrow>\n                                    return_spmf (Inl (x, s))\n                                  | IO out rpv \\<Rightarrow>\nthe_gpv (callee s out) \\<bind>\ncase_generat (\\<lambda>(x, y). inline1'' (rpv x) y)\n (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))))\n                       (the_gpv gpv \\<bind>\n                        (\\<lambda>xa.\n                            map_spmf\n                             (map_sum f\n                               (\\<lambda>(out, c, rpv).\n                                   (out, c,\n                                    \\<lambda>input.\n TRY rpv input ELSE Done x)))\n                             (case xa of\n                              Pure x \\<Rightarrow> return_spmf (Inl (x, s))\n                              | IO out rpv \\<Rightarrow>\n                                  the_gpv (callee s out) \\<bind>\n                                  case_generat\n                                   (\\<lambda>(x, y).\n inline1 callee (rpv x) y)\n                                   (\\<lambda>out rpv'.\n return_spmf (Inr (out, rpv', rpv))))) \\<bind>\n                        case_option (return_spmf (Inl z)) return_spmf)", "apply(simp add: bind_map_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> ord_spmf (=)\n                       (the_gpv gpv \\<bind>\n                        (\\<lambda>xa.\n                            (case xa of\n                             None \\<Rightarrow> return_spmf (Pure x)\n                             | Some x \\<Rightarrow>\n                                 (return_spmf \\<circ>\n                                  map_generat id id (map_fun id Inl))\n                                  x) \\<bind>\n                            (\\<lambda>xa.\n                                map_spmf (map_sum f id)\n                                 (case map_generat id id\n  (\\<lambda>c input.\n      case c input of Inl gpv \\<Rightarrow> TRY gpv ELSE Done x\n      | Inr gpv' \\<Rightarrow> gpv')\n  xa of\n                                  Pure x \\<Rightarrow>\n                                    return_spmf (Inl (x, s))\n                                  | IO out rpv \\<Rightarrow>\nthe_gpv (callee s out) \\<bind>\ncase_generat (\\<lambda>(x, y). inline1'' (rpv x) y)\n (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))))\n                       (the_gpv gpv \\<bind>\n                        (\\<lambda>xa.\n                            map_spmf\n                             (map_sum f\n                               (\\<lambda>(out, c, rpv).\n                                   (out, c,\n                                    \\<lambda>input.\n TRY rpv input ELSE Done x)))\n                             (case xa of\n                              Pure x \\<Rightarrow> return_spmf (Inl (x, s))\n                              | IO out rpv \\<Rightarrow>\n                                  the_gpv (callee s out) \\<bind>\n                                  case_generat\n                                   (\\<lambda>(x, y).\n inline1 callee (rpv x) y)\n                                   (\\<lambda>out rpv'.\n return_spmf (Inr (out, rpv', rpv))))) \\<bind>\n                        case_option (return_spmf (Inl z)) return_spmf)", "apply(subst (3) bind_spmf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> ord_spmf (=)\n                       (the_gpv gpv \\<bind>\n                        (\\<lambda>xa.\n                            (case xa of\n                             None \\<Rightarrow> return_spmf (Pure x)\n                             | Some x \\<Rightarrow>\n                                 (return_spmf \\<circ>\n                                  map_generat id id (map_fun id Inl))\n                                  x) \\<bind>\n                            (\\<lambda>xa.\n                                map_spmf (map_sum f id)\n                                 (case map_generat id id\n  (\\<lambda>c input.\n      case c input of Inl gpv \\<Rightarrow> TRY gpv ELSE Done x\n      | Inr gpv' \\<Rightarrow> gpv')\n  xa of\n                                  Pure x \\<Rightarrow>\n                                    return_spmf (Inl (x, s))\n                                  | IO out rpv \\<Rightarrow>\nthe_gpv (callee s out) \\<bind>\ncase_generat (\\<lambda>(x, y). inline1'' (rpv x) y)\n (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))))\n                       (the_gpv gpv \\<bind>\n                        case_option (return_pmf None)\n                         (\\<lambda>a'.\n                             map_spmf\n                              (map_sum f\n                                (\\<lambda>(out, c, rpv).\n                                    (out, c,\n                                     \\<lambda>input.\n  TRY rpv input ELSE Done x)))\n                              (case a' of\n                               Pure x \\<Rightarrow> return_spmf (Inl (x, s))\n                               | IO out rpv \\<Rightarrow>\n                                   the_gpv (callee s out) \\<bind>\n                                   case_generat\n                                    (\\<lambda>(x, y).\n  inline1 callee (rpv x) y)\n                                    (\\<lambda>out rpv'.\n  return_spmf (Inr (out, rpv', rpv))))) \\<bind>\n                        case_option (return_spmf (Inl z)) return_spmf)", "apply(simp add: bind_assoc_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> ord_spmf (=)\n                       (the_gpv gpv \\<bind>\n                        (\\<lambda>xa.\n                            (case xa of\n                             None \\<Rightarrow> return_spmf (Pure x)\n                             | Some x \\<Rightarrow>\n                                 (return_spmf \\<circ>\n                                  map_generat id id (map_fun id Inl))\n                                  x) \\<bind>\n                            (\\<lambda>xa.\n                                map_spmf (map_sum f id)\n                                 (case map_generat id id\n  (\\<lambda>c input.\n      case c input of Inl gpv \\<Rightarrow> TRY gpv ELSE Done x\n      | Inr gpv' \\<Rightarrow> gpv')\n  xa of\n                                  Pure x \\<Rightarrow>\n                                    return_spmf (Inl (x, s))\n                                  | IO out rpv \\<Rightarrow>\nthe_gpv (callee s out) \\<bind>\ncase_generat (\\<lambda>(x, y). inline1'' (rpv x) y)\n (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv)))))))\n                       (the_gpv gpv \\<bind>\n                        (\\<lambda>xa.\n                            (case xa of None \\<Rightarrow> return_pmf None\n                             | Some a' \\<Rightarrow>\n                                 map_spmf\n                                  (map_sum f\n                                    (\\<lambda>(out, c, rpv).\n  (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n                                  (case a' of\n                                   Pure x \\<Rightarrow>\n                                     return_spmf (Inl (x, s))\n                                   | IO out rpv \\<Rightarrow>\n the_gpv (callee s out) \\<bind>\n case_generat (\\<lambda>(x, y). inline1 callee (rpv x) y)\n  (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))) \\<bind>\n                            case_option (return_spmf (Inl z)) return_spmf))", "apply(rule rel_pmf_bindI[where R=\"eq_onp (\\<lambda>x. x \\<in> set_pmf (the_gpv gpv))\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n    \\<Longrightarrow> rel_pmf\n                       (eq_onp (\\<lambda>x. x \\<in> set_pmf (the_gpv gpv)))\n                       (the_gpv gpv) (the_gpv gpv)\n 2. \\<And>xa y.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        eq_onp (\\<lambda>x. x \\<in> set_pmf (the_gpv gpv)) xa y\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          ((case xa of\n                            None \\<Rightarrow> return_spmf (Pure x)\n                            | Some x \\<Rightarrow>\n                                (return_spmf \\<circ>\n                                 map_generat id id (map_fun id Inl))\n                                 x) \\<bind>\n                           (\\<lambda>xa.\n                               map_spmf (map_sum f id)\n                                (case map_generat id id\n (\\<lambda>c input.\n     case c input of Inl gpv \\<Rightarrow> TRY gpv ELSE Done x\n     | Inr gpv' \\<Rightarrow> gpv')\n xa of\n                                 Pure x \\<Rightarrow>\n                                   return_spmf (Inl (x, s))\n                                 | IO out rpv \\<Rightarrow>\n                                     the_gpv (callee s out) \\<bind>\n                                     case_generat\n(\\<lambda>(x, y). inline1'' (rpv x) y)\n(\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))))\n                          ((case y of None \\<Rightarrow> return_pmf None\n                            | Some a' \\<Rightarrow>\n                                map_spmf\n                                 (map_sum f\n                                   (\\<lambda>(out, c, rpv).\n (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n                                 (case a' of\n                                  Pure x \\<Rightarrow>\n                                    return_spmf (Inl (x, s))\n                                  | IO out rpv \\<Rightarrow>\nthe_gpv (callee s out) \\<bind>\ncase_generat (\\<lambda>(x, y). inline1 callee (rpv x) y)\n (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))) \\<bind>\n                           case_option (return_spmf (Inl z)) return_spmf)", "apply(rule pmf.rel_refl_strong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        z \\<in> set_pmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> eq_onp (\\<lambda>x. x \\<in> set_pmf (the_gpv gpv))\n                          z z\n 2. \\<And>xa y.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        eq_onp (\\<lambda>x. x \\<in> set_pmf (the_gpv gpv)) xa y\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          ((case xa of\n                            None \\<Rightarrow> return_spmf (Pure x)\n                            | Some x \\<Rightarrow>\n                                (return_spmf \\<circ>\n                                 map_generat id id (map_fun id Inl))\n                                 x) \\<bind>\n                           (\\<lambda>xa.\n                               map_spmf (map_sum f id)\n                                (case map_generat id id\n (\\<lambda>c input.\n     case c input of Inl gpv \\<Rightarrow> TRY gpv ELSE Done x\n     | Inr gpv' \\<Rightarrow> gpv')\n xa of\n                                 Pure x \\<Rightarrow>\n                                   return_spmf (Inl (x, s))\n                                 | IO out rpv \\<Rightarrow>\n                                     the_gpv (callee s out) \\<bind>\n                                     case_generat\n(\\<lambda>(x, y). inline1'' (rpv x) y)\n(\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))))\n                          ((case y of None \\<Rightarrow> return_pmf None\n                            | Some a' \\<Rightarrow>\n                                map_spmf\n                                 (map_sum f\n                                   (\\<lambda>(out, c, rpv).\n (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n                                 (case a' of\n                                  Pure x \\<Rightarrow>\n                                    return_spmf (Inl (x, s))\n                                  | IO out rpv \\<Rightarrow>\nthe_gpv (callee s out) \\<bind>\ncase_generat (\\<lambda>(x, y). inline1 callee (rpv x) y)\n (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))) \\<bind>\n                           case_option (return_spmf (Inl z)) return_spmf)", "apply(simp add: eq_onp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        eq_onp (\\<lambda>x. x \\<in> set_pmf (the_gpv gpv)) xa y\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          ((case xa of\n                            None \\<Rightarrow> return_spmf (Pure x)\n                            | Some x \\<Rightarrow>\n                                (return_spmf \\<circ>\n                                 map_generat id id (map_fun id Inl))\n                                 x) \\<bind>\n                           (\\<lambda>xa.\n                               map_spmf (map_sum f id)\n                                (case map_generat id id\n (\\<lambda>c input.\n     case c input of Inl gpv \\<Rightarrow> TRY gpv ELSE Done x\n     | Inr gpv' \\<Rightarrow> gpv')\n xa of\n                                 Pure x \\<Rightarrow>\n                                   return_spmf (Inl (x, s))\n                                 | IO out rpv \\<Rightarrow>\n                                     the_gpv (callee s out) \\<bind>\n                                     case_generat\n(\\<lambda>(x, y). inline1'' (rpv x) y)\n(\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))))\n                          ((case y of None \\<Rightarrow> return_pmf None\n                            | Some a' \\<Rightarrow>\n                                map_spmf\n                                 (map_sum f\n                                   (\\<lambda>(out, c, rpv).\n (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n                                 (case a' of\n                                  Pure x \\<Rightarrow>\n                                    return_spmf (Inl (x, s))\n                                  | IO out rpv \\<Rightarrow>\nthe_gpv (callee s out) \\<bind>\ncase_generat (\\<lambda>(x, y). inline1 callee (rpv x) y)\n (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))) \\<bind>\n                           case_option (return_spmf (Inl z)) return_spmf)", "apply(clarsimp simp add: eq_onp_def bind_return_pmf f split!: option.split generat.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21a x22a.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        Some (IO x21a x22a) \\<in> set_pmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf (map_sum f id)\n                            (the_gpv (callee s x21a) \\<bind>\n                             case_generat\n                              (\\<lambda>(xa, y).\n                                  inline1'' (TRY x22a xa ELSE Done x) y)\n                              (\\<lambda>out rpv'.\n                                  return_spmf\n                                   (Inr (out, rpv',\n   \\<lambda>input. TRY x22a input ELSE Done x)))))\n                          (map_spmf\n                            (map_sum f\n                              (\\<lambda>(out, c, rpv).\n                                  (out, c,\n                                   \\<lambda>input.\nTRY rpv input ELSE Done x)))\n                            (the_gpv (callee s x21a) \\<bind>\n                             case_generat\n                              (\\<lambda>(x, y). inline1 callee (x22a x) y)\n                              (\\<lambda>out rpv'.\n                                  return_spmf\n                                   (Inr (out, rpv', x22a)))) \\<bind>\n                           case_option (return_spmf (Inl z)) return_spmf)", "subgoal for out c"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n     Some (IO out c) \\<in> set_pmf (the_gpv gpv)\\<rbrakk>\n    \\<Longrightarrow> ord_spmf (=)\n                       (map_spmf (map_sum f id)\n                         (the_gpv (callee s out) \\<bind>\n                          case_generat\n                           (\\<lambda>(xa, y).\n                               inline1'' (TRY c xa ELSE Done x) y)\n                           (\\<lambda>out rpv'.\n                               return_spmf\n                                (Inr (out, rpv',\n\\<lambda>input. TRY c input ELSE Done x)))))\n                       (map_spmf\n                         (map_sum f\n                           (\\<lambda>(out, c, rpv).\n                               (out, c,\n                                \\<lambda>input. TRY rpv input ELSE Done x)))\n                         (the_gpv (callee s out) \\<bind>\n                          case_generat\n                           (\\<lambda>(x, y). inline1 callee (c x) y)\n                           (\\<lambda>out rpv'.\n                               return_spmf (Inr (out, rpv', c)))) \\<bind>\n                        case_option (return_spmf (Inl z)) return_spmf)", "apply(simp add: in_set_spmf[symmetric] bind_map_pmf map_bind_spmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n     IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n    \\<Longrightarrow> ord_spmf (=)\n                       (the_gpv (callee s out) \\<bind>\n                        map_spmf (map_sum f id) \\<circ>\n                        case_generat\n                         (\\<lambda>(xa, y).\n                             inline1'' (TRY c xa ELSE Done x) y)\n                         (\\<lambda>out rpv'.\n                             return_spmf\n                              (Inr (out, rpv',\n                                    \\<lambda>input.\n TRY c input ELSE Done x))))\n                       (the_gpv (callee s out) \\<bind>\n                        map_spmf\n                         (map_sum f\n                           (\\<lambda>(out, c, rpv).\n                               (out, c,\n                                \\<lambda>input.\n                                   TRY rpv input ELSE Done x))) \\<circ>\n                        case_generat\n                         (\\<lambda>(x, y). inline1 callee (c x) y)\n                         (\\<lambda>out rpv'.\n                             return_spmf (Inr (out, rpv', c))) \\<bind>\n                        case_option (return_spmf (Inl z)) return_spmf)", "apply(subst option.case_distrib[where h=return_pmf, symmetric, abs_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n     IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n    \\<Longrightarrow> ord_spmf (=)\n                       (the_gpv (callee s out) \\<bind>\n                        map_spmf (map_sum f id) \\<circ>\n                        case_generat\n                         (\\<lambda>(xa, y).\n                             inline1'' (TRY c xa ELSE Done x) y)\n                         (\\<lambda>out rpv'.\n                             return_spmf\n                              (Inr (out, rpv',\n                                    \\<lambda>input.\n TRY c input ELSE Done x))))\n                       (the_gpv (callee s out) \\<bind>\n                        map_spmf\n                         (map_sum f\n                           (\\<lambda>(out, c, rpv).\n                               (out, c,\n                                \\<lambda>input.\n                                   TRY rpv input ELSE Done x))) \\<circ>\n                        case_generat\n                         (\\<lambda>(x, y). inline1 callee (c x) y)\n                         (\\<lambda>out rpv'.\n                             return_spmf (Inr (out, rpv', c))) \\<bind>\n                        (\\<lambda>option.\n                            return_pmf\n                             (case option of None \\<Rightarrow> Some (Inl z)\n                              | Some x \\<Rightarrow> Some x)))", "apply(fold map_pmf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n     IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n    \\<Longrightarrow> ord_spmf (=)\n                       (the_gpv (callee s out) \\<bind>\n                        map_spmf (map_sum f id) \\<circ>\n                        case_generat\n                         (\\<lambda>(xa, y).\n                             inline1'' (TRY c xa ELSE Done x) y)\n                         (\\<lambda>out rpv'.\n                             return_spmf\n                              (Inr (out, rpv',\n                                    \\<lambda>input.\n TRY c input ELSE Done x))))\n                       (map_pmf\n                         (\\<lambda>option.\n                             case option of None \\<Rightarrow> Some (Inl z)\n                             | Some x \\<Rightarrow> Some x)\n                         (the_gpv (callee s out) \\<bind>\n                          map_spmf\n                           (map_sum f\n                             (\\<lambda>(out, c, rpv).\n                                 (out, c,\n                                  \\<lambda>input.\n                                     TRY rpv input ELSE Done x))) \\<circ>\n                          case_generat\n                           (\\<lambda>(x, y). inline1 callee (c x) y)\n                           (\\<lambda>out rpv'.\n                               return_spmf (Inr (out, rpv', c)))))", "apply(simp add: bind_spmf_def map_bind_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n     IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n    \\<Longrightarrow> ord_spmf (=)\n                       (the_gpv (callee s out) \\<bind>\n                        (\\<lambda>a.\n                            case a of None \\<Rightarrow> return_pmf None\n                            | Some a' \\<Rightarrow>\n                                (map_spmf (map_sum f id) \\<circ>\n                                 case_generat\n                                  (\\<lambda>(xa, y).\ninline1'' (TRY c xa ELSE Done x) y)\n                                  (\\<lambda>out rpv'.\nreturn_spmf (Inr (out, rpv', \\<lambda>input. TRY c input ELSE Done x))))\n                                 a'))\n                       (the_gpv (callee s out) \\<bind>\n                        (\\<lambda>xa.\n                            map_pmf (case_option (Some (Inl z)) Some)\n                             (case xa of None \\<Rightarrow> return_pmf None\n                              | Some xa \\<Rightarrow>\n                                  (map_spmf\n                                    (map_sum f\n(\\<lambda>(out, c, rpv).\n    (out, c, \\<lambda>input. TRY rpv input ELSE Done x))) \\<circ>\n                                   case_generat\n                                    (\\<lambda>(x, y).\n  inline1 callee (c x) y)\n                                    (\\<lambda>out rpv'.\n  return_spmf (Inr (out, rpv', c))))\n                                   xa)))", "apply(rule rel_pmf_bindI[where R=\"eq_onp (\\<lambda>x. x \\<in> set_pmf (the_gpv (callee s out)))\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n     IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n    \\<Longrightarrow> rel_pmf\n                       (eq_onp\n                         (\\<lambda>x.\n                             x \\<in> set_pmf (the_gpv (callee s out))))\n                       (the_gpv (callee s out)) (the_gpv (callee s out))\n 2. \\<And>xa y.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        eq_onp (\\<lambda>x. x \\<in> set_pmf (the_gpv (callee s out))) xa\n         y\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (case xa of None \\<Rightarrow> return_pmf None\n                           | Some a' \\<Rightarrow>\n                               (map_spmf (map_sum f id) \\<circ>\n                                case_generat\n                                 (\\<lambda>(xa, y).\n                                     inline1'' (TRY c xa ELSE Done x) y)\n                                 (\\<lambda>out rpv'.\n                                     return_spmf\n(Inr (out, rpv', \\<lambda>input. TRY c input ELSE Done x))))\n                                a')\n                          (map_pmf (case_option (Some (Inl z)) Some)\n                            (case y of None \\<Rightarrow> return_pmf None\n                             | Some xa \\<Rightarrow>\n                                 (map_spmf\n                                   (map_sum f\n                                     (\\<lambda>(out, c, rpv).\n   (out, c, \\<lambda>input. TRY rpv input ELSE Done x))) \\<circ>\n                                  case_generat\n                                   (\\<lambda>(x, y). inline1 callee (c x) y)\n                                   (\\<lambda>out rpv'.\n return_spmf (Inr (out, rpv', c))))\n                                  xa))", "apply(rule pmf.rel_refl_strong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        z \\<in> set_pmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> eq_onp\n                          (\\<lambda>x.\n                              x \\<in> set_pmf (the_gpv (callee s out)))\n                          z z\n 2. \\<And>xa y.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        eq_onp (\\<lambda>x. x \\<in> set_pmf (the_gpv (callee s out))) xa\n         y\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (case xa of None \\<Rightarrow> return_pmf None\n                           | Some a' \\<Rightarrow>\n                               (map_spmf (map_sum f id) \\<circ>\n                                case_generat\n                                 (\\<lambda>(xa, y).\n                                     inline1'' (TRY c xa ELSE Done x) y)\n                                 (\\<lambda>out rpv'.\n                                     return_spmf\n(Inr (out, rpv', \\<lambda>input. TRY c input ELSE Done x))))\n                                a')\n                          (map_pmf (case_option (Some (Inl z)) Some)\n                            (case y of None \\<Rightarrow> return_pmf None\n                             | Some xa \\<Rightarrow>\n                                 (map_spmf\n                                   (map_sum f\n                                     (\\<lambda>(out, c, rpv).\n   (out, c, \\<lambda>input. TRY rpv input ELSE Done x))) \\<circ>\n                                  case_generat\n                                   (\\<lambda>(x, y). inline1 callee (c x) y)\n                                   (\\<lambda>out rpv'.\n return_spmf (Inr (out, rpv', c))))\n                                  xa))", "apply(simp add: eq_onp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        eq_onp (\\<lambda>x. x \\<in> set_pmf (the_gpv (callee s out))) xa\n         y\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (case xa of None \\<Rightarrow> return_pmf None\n                           | Some a' \\<Rightarrow>\n                               (map_spmf (map_sum f id) \\<circ>\n                                case_generat\n                                 (\\<lambda>(xa, y).\n                                     inline1'' (TRY c xa ELSE Done x) y)\n                                 (\\<lambda>out rpv'.\n                                     return_spmf\n(Inr (out, rpv', \\<lambda>input. TRY c input ELSE Done x))))\n                                a')\n                          (map_pmf (case_option (Some (Inl z)) Some)\n                            (case y of None \\<Rightarrow> return_pmf None\n                             | Some xa \\<Rightarrow>\n                                 (map_spmf\n                                   (map_sum f\n                                     (\\<lambda>(out, c, rpv).\n   (out, c, \\<lambda>input. TRY rpv input ELSE Done x))) \\<circ>\n                                  case_generat\n                                   (\\<lambda>(x, y). inline1 callee (c x) y)\n                                   (\\<lambda>out rpv'.\n return_spmf (Inr (out, rpv', c))))\n                                  xa))", "apply(simp add: in_set_spmf[symmetric] bind_map_pmf map_bind_spmf eq_onp_def split!: option.split generat.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        Pure (a, b) \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf (map_sum f id)\n                            (inline1'' (TRY c a ELSE Done x) b))\n                          (map_pmf (case_option (Some (Inl z)) Some)\n                            (map_spmf\n                              (map_sum f\n                                (\\<lambda>(out, c, rpv).\n                                    (out, c,\n                                     \\<lambda>input.\n  TRY rpv input ELSE Done x)))\n                              (inline1 callee (c a) b)))", "apply(rule spmf.leq_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        Pure (a, b) \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf (map_sum f id)\n                            (inline1'' (TRY c a ELSE Done x) b))\n                          (?y29 a b)\n 2. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        Pure (a, b) \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=) (?y29 a b)\n                          (map_pmf (case_option (Some (Inl z)) Some)\n                            (map_spmf\n                              (map_sum f\n                                (\\<lambda>(out, c, rpv).\n                                    (out, c,\n                                     \\<lambda>input.\n  TRY rpv input ELSE Done x)))\n                              (inline1 callee (c a) b)))", "apply(rule step.IH[unfolded inline1'_def])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        Pure (a, b) \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> \\<I> \\<turnstile>g c a \\<surd>\n 2. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        Pure (a, b) \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> I b\n 3. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        Pure (a, b) \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (TRY map_spmf\n                                (map_sum f\n                                  (\\<lambda>a.\ncase a of\n(out, c, rpv) \\<Rightarrow>\n  (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n                                (inline1 callee (c a)\n                                  b) ELSE return_spmf (Inl z))\n                          (map_pmf (case_option (Some (Inl z)) Some)\n                            (map_spmf\n                              (map_sum f\n                                (\\<lambda>(out, c, rpv).\n                                    (out, c,\n                                     \\<lambda>input.\n  TRY rpv input ELSE Done x)))\n                              (inline1 callee (c a) b)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n     IO out c \\<in> set_spmf (the_gpv gpv);\n     Pure (a_, b_) \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n    \\<Longrightarrow> \\<I> \\<turnstile>g c a_ \\<surd>", "by(auto dest: results_callee[THEN subsetD, OF _ _ results_gpv.Pure, rotated -1] WT_gpvD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        Pure (a, b) \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> I b\n 2. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        Pure (a, b) \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (TRY map_spmf\n                                (map_sum f\n                                  (\\<lambda>a.\ncase a of\n(out, c, rpv) \\<Rightarrow>\n  (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n                                (inline1 callee (c a)\n                                  b) ELSE return_spmf (Inl z))\n                          (map_pmf (case_option (Some (Inl z)) Some)\n                            (map_spmf\n                              (map_sum f\n                                (\\<lambda>(out, c, rpv).\n                                    (out, c,\n                                     \\<lambda>input.\n  TRY rpv input ELSE Done x)))\n                              (inline1 callee (c a) b)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n     IO out c \\<in> set_spmf (the_gpv gpv);\n     Pure (a_, b_) \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n    \\<Longrightarrow> I b_", "by(auto dest: results_callee[THEN subsetD, OF _ _ results_gpv.Pure, rotated -1] WT_gpvD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        Pure (a, b) \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (TRY map_spmf\n                                (map_sum f\n                                  (\\<lambda>a.\ncase a of\n(out, c, rpv) \\<Rightarrow>\n  (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n                                (inline1 callee (c a)\n                                  b) ELSE return_spmf (Inl z))\n                          (map_pmf (case_option (Some (Inl z)) Some)\n                            (map_spmf\n                              (map_sum f\n                                (\\<lambda>(out, c, rpv).\n                                    (out, c,\n                                     \\<lambda>input.\n  TRY rpv input ELSE Done x)))\n                              (inline1 callee (c a) b)))", "apply(simp add: try_spmf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        Pure (a, b) \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf\n                            (map_sum f\n                              (\\<lambda>(out, c, rpv).\n                                  (out, c,\n                                   \\<lambda>input.\nTRY rpv input ELSE Done x)))\n                            (inline1 callee (c a) b) \\<bind>\n                           (\\<lambda>x.\n                               case x of\n                               None \\<Rightarrow> return_spmf (Inl z)\n                               | Some y \\<Rightarrow> return_spmf y))\n                          (map_pmf (case_option (Some (Inl z)) Some)\n                            (map_spmf\n                              (map_sum f\n                                (\\<lambda>(out, c, rpv).\n                                    (out, c,\n                                     \\<lambda>input.\n  TRY rpv input ELSE Done x)))\n                              (inline1 callee (c a) b)))", "apply(subst option.case_distrib[where h=return_pmf, symmetric, abs_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        Pure (a, b) \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_spmf\n                            (map_sum f\n                              (\\<lambda>(out, c, rpv).\n                                  (out, c,\n                                   \\<lambda>input.\nTRY rpv input ELSE Done x)))\n                            (inline1 callee (c a) b) \\<bind>\n                           (\\<lambda>option.\n                               return_pmf\n                                (case option of\n                                 None \\<Rightarrow> Some (Inl z)\n                                 | Some x \\<Rightarrow> Some x)))\n                          (map_pmf (case_option (Some (Inl z)) Some)\n                            (map_spmf\n                              (map_sum f\n                                (\\<lambda>(out, c, rpv).\n                                    (out, c,\n                                     \\<lambda>input.\n  TRY rpv input ELSE Done x)))\n                              (inline1 callee (c a) b)))", "apply(fold map_pmf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s;\n        IO out c \\<in> set_spmf (the_gpv gpv);\n        Pure (a, b) \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ord_spmf (=)\n                          (map_pmf\n                            (\\<lambda>option.\n                                case option of\n                                None \\<Rightarrow> Some (Inl z)\n                                | Some x \\<Rightarrow> Some x)\n                            (map_spmf\n                              (map_sum f\n                                (\\<lambda>(out, c, rpv).\n                                    (out, c,\n                                     \\<lambda>input.\n  TRY rpv input ELSE Done x)))\n                              (inline1 callee (c a) b)))\n                          (map_pmf (case_option (Some (Inl z)) Some)\n                            (map_spmf\n                              (map_sum f\n                                (\\<lambda>(out, c, rpv).\n                                    (out, c,\n                                     \\<lambda>input.\n  TRY rpv input ELSE Done x)))\n                              (inline1 callee (c a) b)))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ord_spmf (=)\n   (map_spmf (map_sum f id)\n     (the_gpv (TRY gpv ELSE Done x) \\<bind>\n      case_generat (\\<lambda>x. return_spmf (Inl (x, s)))\n       (\\<lambda>out rpv.\n           the_gpv (callee s out) \\<bind>\n           case_generat (\\<lambda>(x, y). inline1'' (rpv x) y)\n            (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', rpv))))))\n   (TRY map_spmf\n         (map_sum f\n           (\\<lambda>a.\n               case a of\n               (out, c, rpv) \\<Rightarrow>\n                 (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n         (inline1' callee gpv s) ELSE return_spmf (Inl z))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ord_spmf (=)\n   (map_spmf (map_sum f id) (inline1 callee (TRY gpv ELSE Done x) s))\n   (TRY map_spmf\n         (map_sum f\n           (\\<lambda>(out, c, rpv).\n               (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n         (inline1' callee gpv s) ELSE return_spmf (Inl z))\n\ngoal (1 subgoal):\n 1. map_spmf (map_sum f id) (inline1 callee (TRY gpv ELSE Done x) s) =\n    TRY map_spmf\n         (map_sum f\n           (\\<lambda>(out, c, rpv).\n               (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n         (inline1' callee gpv s) ELSE return_spmf (Inl z)", "have \"lossless_spmf ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf\n     (map_spmf (map_sum f id) (inline1 callee (TRY gpv ELSE Done x) s))", "using I"], ["proof (prove)\nusing this:\n  I s\n\ngoal (1 subgoal):\n 1. lossless_spmf\n     (map_spmf (map_sum f id) (inline1 callee (TRY gpv ELSE Done x) s))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. I s \\<Longrightarrow>\n    lossless_spmf (inline1 callee (TRY gpv ELSE Done x) s)", "apply(rule lossless_spmf_inline1)"], ["proof (prove)\ngoal (4 subgoals):\n 1. I s \\<Longrightarrow> plossless_gpv \\<I> (TRY gpv ELSE Done x)\n 2. I s \\<Longrightarrow> \\<I> \\<turnstile>g TRY gpv ELSE Done x \\<surd>\n 3. \\<And>sa x.\n       \\<lbrakk>I s; x \\<in> outs_\\<I> \\<I>; I sa\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (the_gpv (callee sa x))\n 4. I s \\<Longrightarrow> I s", "apply(rule plossless_gpv_try_gpvI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. I s \\<Longrightarrow> pfinite_gpv \\<I> gpv\n 2. \\<lbrakk>I s; \\<not> colossless_gpv \\<I> gpv\\<rbrakk>\n    \\<Longrightarrow> plossless_gpv \\<I> (Done x)\n 3. I s \\<Longrightarrow> \\<I> \\<turnstile>g TRY gpv ELSE Done x \\<surd>\n 4. \\<And>sa x.\n       \\<lbrakk>I s; x \\<in> outs_\\<I> \\<I>; I sa\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (the_gpv (callee sa x))\n 5. I s \\<Longrightarrow> I s", "apply(rule pfinite)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>I s; \\<not> colossless_gpv \\<I> gpv\\<rbrakk>\n    \\<Longrightarrow> plossless_gpv \\<I> (Done x)\n 2. I s \\<Longrightarrow> \\<I> \\<turnstile>g TRY gpv ELSE Done x \\<surd>\n 3. \\<And>sa x.\n       \\<lbrakk>I s; x \\<in> outs_\\<I> \\<I>; I sa\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (the_gpv (callee sa x))\n 4. I s \\<Longrightarrow> I s", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. I s \\<Longrightarrow> \\<I> \\<turnstile>g TRY gpv ELSE Done x \\<surd>\n 2. \\<And>sa x.\n       \\<lbrakk>I s; x \\<in> outs_\\<I> \\<I>; I sa\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (the_gpv (callee sa x))\n 3. I s \\<Longrightarrow> I s", "apply(rule WT_gpv_try_gpvI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. I s \\<Longrightarrow> \\<I> \\<turnstile>g gpv \\<surd>\n 2. \\<lbrakk>I s; \\<not> colossless_gpv \\<I> gpv\\<rbrakk>\n    \\<Longrightarrow> \\<I> \\<turnstile>g Done x \\<surd>\n 3. \\<And>sa x.\n       \\<lbrakk>I s; x \\<in> outs_\\<I> \\<I>; I sa\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (the_gpv (callee sa x))\n 4. I s \\<Longrightarrow> I s", "apply(rule WT)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>I s; \\<not> colossless_gpv \\<I> gpv\\<rbrakk>\n    \\<Longrightarrow> \\<I> \\<turnstile>g Done x \\<surd>\n 2. \\<And>sa x.\n       \\<lbrakk>I s; x \\<in> outs_\\<I> \\<I>; I sa\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (the_gpv (callee sa x))\n 3. I s \\<Longrightarrow> I s", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>sa x.\n       \\<lbrakk>I s; x \\<in> outs_\\<I> \\<I>; I sa\\<rbrakk>\n       \\<Longrightarrow> lossless_spmf (the_gpv (callee sa x))\n 2. I s \\<Longrightarrow> I s", "apply(rule colossless_gpv_lossless_spmfD[OF lossless])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>sa x.\n       \\<lbrakk>I s; x \\<in> outs_\\<I> \\<I>; I sa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> outs_\\<I> \\<I>\n 2. \\<And>sa x.\n       \\<lbrakk>I s; x \\<in> outs_\\<I> \\<I>; I sa\\<rbrakk>\n       \\<Longrightarrow> I sa\n 3. I s \\<Longrightarrow> I s", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lossless_spmf\n   (map_spmf (map_sum f id) (inline1 callee (TRY gpv ELSE Done x) s))\n\ngoal (1 subgoal):\n 1. map_spmf (map_sum f id) (inline1 callee (TRY gpv ELSE Done x) s) =\n    TRY map_spmf\n         (map_sum f\n           (\\<lambda>(out, c, rpv).\n               (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n         (inline1' callee gpv s) ELSE return_spmf (Inl z)", "from ord_spmf_lossless_spmfD1[OF le this]"], ["proof (chain)\npicking this:\n  rel_spmf (=)\n   (map_spmf (map_sum f id) (inline1 callee (TRY gpv ELSE Done x) s))\n   (TRY map_spmf\n         (map_sum f\n           (\\<lambda>(out, c, rpv).\n               (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n         (inline1' callee gpv s) ELSE return_spmf (Inl z))", "show ?thesis"], ["proof (prove)\nusing this:\n  rel_spmf (=)\n   (map_spmf (map_sum f id) (inline1 callee (TRY gpv ELSE Done x) s))\n   (TRY map_spmf\n         (map_sum f\n           (\\<lambda>(out, c, rpv).\n               (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n         (inline1' callee gpv s) ELSE return_spmf (Inl z))\n\ngoal (1 subgoal):\n 1. map_spmf (map_sum f id) (inline1 callee (TRY gpv ELSE Done x) s) =\n    TRY map_spmf\n         (map_sum f\n           (\\<lambda>(out, c, rpv).\n               (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n         (inline1' callee gpv s) ELSE return_spmf (Inl z)", "by(simp add: spmf_rel_eq)"], ["proof (state)\nthis:\n  map_spmf (map_sum f id) (inline1 callee (TRY gpv ELSE Done x) s) =\n  TRY map_spmf\n       (map_sum f\n         (\\<lambda>(out, c, rpv).\n             (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n       (inline1' callee gpv s) ELSE return_spmf (Inl z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in raw_converter_invariant) inline_try_gpv:\n  assumes WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and pfinite: \"pfinite_gpv \\<I> gpv\"\n    and f: \"\\<And>s. I s \\<Longrightarrow> f (x, s) = z\"\n    and lossless: \"\\<And>s x. \\<lbrakk> x \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> colossless_gpv \\<I>' (callee s x)\"\n    and I: \"I s\"\n  shows \"eq_\\<I>_gpv (=) \\<I>' (map_gpv f id (inline callee (try_gpv gpv (Done x)) s)) (try_gpv (map_gpv f id (inline callee gpv s)) (Done z))\"\n  (is \"eq_\\<I>_gpv _ _ ?lhs ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv (=) \\<I>'\n     (map_gpv f id (inline callee (TRY gpv ELSE Done x) s))\n     (TRY map_gpv f id (inline callee gpv s) ELSE Done z)", "using WT pfinite I"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  pfinite_gpv \\<I> gpv\n  I s\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv (=) \\<I>'\n     (map_gpv f id (inline callee (TRY gpv ELSE Done x) s))\n     (TRY map_gpv f id (inline callee gpv s) ELSE Done z)", "proof(coinduction arbitrary: gpv s rule: eq_\\<I>_gpv_coinduct_bind)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>gpva s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpva \\<surd>; pfinite_gpv \\<I> gpva;\n        I s\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (eq_\\<I>_generat (=) \\<I>'\n                            (\\<lambda>gpv gpv'.\n                                (\\<exists>gpva s.\n                                    gpv =\n                                    map_gpv f id\n                                     (inline callee (TRY gpva ELSE Done x)\n s) \\<and>\n                                    gpv' =\n                                    TRY map_gpv f id\n   (inline callee gpva s) ELSE Done z \\<and>\n                                    \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n                                    pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n                                eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n                                (\\<exists>gpv'' gpv''' B fa g.\n                                    gpv = gpv'' \\<bind> fa \\<and>\n                                    gpv' = gpv''' \\<bind> g \\<and>\n                                    eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n                                    rel_fun B\n                                     (\\<lambda>gpva__ gpv'__.\n   \\<exists>gpv s.\n      gpva__ = map_gpv f id (inline callee (TRY gpv ELSE Done x) s) \\<and>\n      gpv'__ = TRY map_gpv f id (inline callee gpv s) ELSE Done z \\<and>\n      \\<I> \\<turnstile>g gpv \\<surd> \\<and> pfinite_gpv \\<I> gpv \\<and> I s)\n                                     fa g)))\n                          (the_gpv\n                            (map_gpv f id\n                              (inline callee (TRY gpva ELSE Done x) s)))\n                          (the_gpv\n                            (TRY map_gpv f id\n                                  (inline callee gpva s) ELSE Done z))", "case (eq_\\<I>_gpv gpv s)"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  pfinite_gpv \\<I> gpv\n  I s\n\ngoal (1 subgoal):\n 1. \\<And>gpva s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpva \\<surd>; pfinite_gpv \\<I> gpva;\n        I s\\<rbrakk>\n       \\<Longrightarrow> rel_spmf\n                          (eq_\\<I>_generat (=) \\<I>'\n                            (\\<lambda>gpv gpv'.\n                                (\\<exists>gpva s.\n                                    gpv =\n                                    map_gpv f id\n                                     (inline callee (TRY gpva ELSE Done x)\n s) \\<and>\n                                    gpv' =\n                                    TRY map_gpv f id\n   (inline callee gpva s) ELSE Done z \\<and>\n                                    \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n                                    pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n                                eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n                                (\\<exists>gpv'' gpv''' B fa g.\n                                    gpv = gpv'' \\<bind> fa \\<and>\n                                    gpv' = gpv''' \\<bind> g \\<and>\n                                    eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n                                    rel_fun B\n                                     (\\<lambda>gpva__ gpv'__.\n   \\<exists>gpv s.\n      gpva__ = map_gpv f id (inline callee (TRY gpv ELSE Done x) s) \\<and>\n      gpv'__ = TRY map_gpv f id (inline callee gpv s) ELSE Done z \\<and>\n      \\<I> \\<turnstile>g gpv \\<surd> \\<and> pfinite_gpv \\<I> gpv \\<and> I s)\n                                     fa g)))\n                          (the_gpv\n                            (map_gpv f id\n                              (inline callee (TRY gpva ELSE Done x) s)))\n                          (the_gpv\n                            (TRY map_gpv f id\n                                  (inline callee gpva s) ELSE Done z))", "show \"?case TYPE(('ret \\<times> 's) option) TYPE(('ret \\<times> 's) option)\" (is \"rel_spmf (eq_\\<I>_generat _ _ ?X) ?lhs ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (eq_\\<I>_generat (=) \\<I>'\n       (\\<lambda>gpv gpv'.\n           (\\<exists>gpva s.\n               gpv =\n               map_gpv f id (inline callee (TRY gpva ELSE Done x) s) \\<and>\n               gpv' =\n               TRY map_gpv f id (inline callee gpva s) ELSE Done z \\<and>\n               \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n               pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n           eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n           (\\<exists>gpv'' gpv''' B fa g.\n               gpv = gpv'' \\<bind> fa \\<and>\n               gpv' = gpv''' \\<bind> g \\<and>\n               eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n               rel_fun B\n                (\\<lambda>gpva__ gpv'__.\n                    \\<exists>gpv s.\n                       gpva__ =\n                       map_gpv f id\n                        (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                       gpv'__ =\n                       TRY map_gpv f id\n                            (inline callee gpv s) ELSE Done z \\<and>\n                       \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                       pfinite_gpv \\<I> gpv \\<and> I s)\n                fa g)))\n     (the_gpv (map_gpv f id (inline callee (TRY gpv ELSE Done x) s)))\n     (the_gpv (TRY map_gpv f id (inline callee gpv s) ELSE Done z))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_spmf\n     (eq_\\<I>_generat (=) \\<I>'\n       (\\<lambda>gpv gpv'.\n           (\\<exists>gpva s.\n               gpv =\n               map_gpv f id (inline callee (TRY gpva ELSE Done x) s) \\<and>\n               gpv' =\n               TRY map_gpv f id (inline callee gpva s) ELSE Done z \\<and>\n               \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n               pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n           eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n           (\\<exists>gpv'' gpv''' B fa g.\n               gpv = gpv'' \\<bind> fa \\<and>\n               gpv' = gpv''' \\<bind> g \\<and>\n               eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n               rel_fun B\n                (\\<lambda>gpva__ gpv'__.\n                    \\<exists>gpv s.\n                       gpva__ =\n                       map_gpv f id\n                        (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                       gpv'__ =\n                       TRY map_gpv f id\n                            (inline callee gpv s) ELSE Done z \\<and>\n                       \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                       pfinite_gpv \\<I> gpv \\<and> I s)\n                fa g)))\n     (the_gpv (map_gpv f id (inline callee (TRY gpv ELSE Done x) s)))\n     (the_gpv (TRY map_gpv f id (inline callee gpv s) ELSE Done z))", "have \"?lhs = map_spmf\n           (\\<lambda>x. case x of Inl rs \\<Rightarrow> Pure rs | Inr (out, oracle, rpv) \\<Rightarrow> IO out (\\<lambda>input. \n               map_gpv f id (bind_gpv (try_gpv (map_gpv Some id (oracle input)) (Done None)) (\\<lambda>xy. case xy of None \\<Rightarrow> Fail | Some (x, y) \\<Rightarrow> inline callee (rpv x) y))))\n           (map_spmf (map_sum f id) (inline1 callee (TRY gpv ELSE Done x) s))\"\n      (is \"_ = map_spmf ?f ?lhs2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. the_gpv (map_gpv f id (inline callee (TRY gpv ELSE Done x) s)) =\n    map_spmf\n     (\\<lambda>x.\n         case x of Inl rs \\<Rightarrow> Pure rs\n         | Inr (out, oracle, rpv) \\<Rightarrow>\n             IO out\n              (\\<lambda>input.\n                  map_gpv f id\n                   (TRY map_gpv Some id\n                         (oracle input) ELSE Done None \\<bind>\n                    (\\<lambda>xy.\n                        case xy of None \\<Rightarrow> Fail\n                        | Some (x, y) \\<Rightarrow>\n                            inline callee (rpv x) y))))\n     (map_spmf (map_sum f id) (inline1 callee (TRY gpv ELSE Done x) s))", "by(auto simp add: gpv.map_sel inline_sel spmf.map_comp o_def bind_gpv_try_gpv_map_Some intro!: map_spmf_cong[OF refl] split: sum.split)"], ["proof (state)\nthis:\n  the_gpv (map_gpv f id (inline callee (TRY gpv ELSE Done x) s)) =\n  map_spmf\n   (\\<lambda>x.\n       case x of Inl rs \\<Rightarrow> Pure rs\n       | Inr (out, oracle, rpv) \\<Rightarrow>\n           IO out\n            (\\<lambda>input.\n                map_gpv f id\n                 (TRY map_gpv Some id (oracle input) ELSE Done None \\<bind>\n                  (\\<lambda>xy.\n                      case xy of None \\<Rightarrow> Fail\n                      | Some (x, y) \\<Rightarrow>\n                          inline callee (rpv x) y))))\n   (map_spmf (map_sum f id) (inline1 callee (TRY gpv ELSE Done x) s))\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (eq_\\<I>_generat (=) \\<I>'\n       (\\<lambda>gpv gpv'.\n           (\\<exists>gpva s.\n               gpv =\n               map_gpv f id (inline callee (TRY gpva ELSE Done x) s) \\<and>\n               gpv' =\n               TRY map_gpv f id (inline callee gpva s) ELSE Done z \\<and>\n               \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n               pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n           eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n           (\\<exists>gpv'' gpv''' B fa g.\n               gpv = gpv'' \\<bind> fa \\<and>\n               gpv' = gpv''' \\<bind> g \\<and>\n               eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n               rel_fun B\n                (\\<lambda>gpva__ gpv'__.\n                    \\<exists>gpv s.\n                       gpva__ =\n                       map_gpv f id\n                        (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                       gpv'__ =\n                       TRY map_gpv f id\n                            (inline callee gpv s) ELSE Done z \\<and>\n                       \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                       pfinite_gpv \\<I> gpv \\<and> I s)\n                fa g)))\n     (the_gpv (map_gpv f id (inline callee (TRY gpv ELSE Done x) s)))\n     (the_gpv (TRY map_gpv f id (inline callee gpv s) ELSE Done z))", "also"], ["proof (state)\nthis:\n  the_gpv (map_gpv f id (inline callee (TRY gpv ELSE Done x) s)) =\n  map_spmf\n   (\\<lambda>x.\n       case x of Inl rs \\<Rightarrow> Pure rs\n       | Inr (out, oracle, rpv) \\<Rightarrow>\n           IO out\n            (\\<lambda>input.\n                map_gpv f id\n                 (TRY map_gpv Some id (oracle input) ELSE Done None \\<bind>\n                  (\\<lambda>xy.\n                      case xy of None \\<Rightarrow> Fail\n                      | Some (x, y) \\<Rightarrow>\n                          inline callee (rpv x) y))))\n   (map_spmf (map_sum f id) (inline1 callee (TRY gpv ELSE Done x) s))\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (eq_\\<I>_generat (=) \\<I>'\n       (\\<lambda>gpv gpv'.\n           (\\<exists>gpva s.\n               gpv =\n               map_gpv f id (inline callee (TRY gpva ELSE Done x) s) \\<and>\n               gpv' =\n               TRY map_gpv f id (inline callee gpva s) ELSE Done z \\<and>\n               \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n               pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n           eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n           (\\<exists>gpv'' gpv''' B fa g.\n               gpv = gpv'' \\<bind> fa \\<and>\n               gpv' = gpv''' \\<bind> g \\<and>\n               eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n               rel_fun B\n                (\\<lambda>gpva__ gpv'__.\n                    \\<exists>gpv s.\n                       gpva__ =\n                       map_gpv f id\n                        (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                       gpv'__ =\n                       TRY map_gpv f id\n                            (inline callee gpv s) ELSE Done z \\<and>\n                       \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                       pfinite_gpv \\<I> gpv \\<and> I s)\n                fa g)))\n     (the_gpv (map_gpv f id (inline callee (TRY gpv ELSE Done x) s)))\n     (the_gpv (TRY map_gpv f id (inline callee gpv s) ELSE Done z))", "from eq_\\<I>_gpv"], ["proof (chain)\npicking this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  pfinite_gpv \\<I> gpv\n  I s", "have \"?lhs2 = TRY map_spmf (map_sum f (\\<lambda>(out, c, rpv). (out, c, \\<lambda>input. TRY rpv input ELSE Done x))) (inline1 callee gpv s) ELSE return_spmf (Inl z)\""], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  pfinite_gpv \\<I> gpv\n  I s\n\ngoal (1 subgoal):\n 1. map_spmf (map_sum f id) (inline1 callee (TRY gpv ELSE Done x) s) =\n    TRY map_spmf\n         (map_sum f\n           (\\<lambda>(out, c, rpv).\n               (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n         (inline1 callee gpv s) ELSE return_spmf (Inl z)", "by(intro inline1_try_gpv)(auto intro: f lossless)"], ["proof (state)\nthis:\n  map_spmf (map_sum f id) (inline1 callee (TRY gpv ELSE Done x) s) =\n  TRY map_spmf\n       (map_sum f\n         (\\<lambda>(out, c, rpv).\n             (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n       (inline1 callee gpv s) ELSE return_spmf (Inl z)\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (eq_\\<I>_generat (=) \\<I>'\n       (\\<lambda>gpv gpv'.\n           (\\<exists>gpva s.\n               gpv =\n               map_gpv f id (inline callee (TRY gpva ELSE Done x) s) \\<and>\n               gpv' =\n               TRY map_gpv f id (inline callee gpva s) ELSE Done z \\<and>\n               \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n               pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n           eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n           (\\<exists>gpv'' gpv''' B fa g.\n               gpv = gpv'' \\<bind> fa \\<and>\n               gpv' = gpv''' \\<bind> g \\<and>\n               eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n               rel_fun B\n                (\\<lambda>gpva__ gpv'__.\n                    \\<exists>gpv s.\n                       gpva__ =\n                       map_gpv f id\n                        (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                       gpv'__ =\n                       TRY map_gpv f id\n                            (inline callee gpv s) ELSE Done z \\<and>\n                       \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                       pfinite_gpv \\<I> gpv \\<and> I s)\n                fa g)))\n     (the_gpv (map_gpv f id (inline callee (TRY gpv ELSE Done x) s)))\n     (the_gpv (TRY map_gpv f id (inline callee gpv s) ELSE Done z))", "also"], ["proof (state)\nthis:\n  map_spmf (map_sum f id) (inline1 callee (TRY gpv ELSE Done x) s) =\n  TRY map_spmf\n       (map_sum f\n         (\\<lambda>(out, c, rpv).\n             (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n       (inline1 callee gpv s) ELSE return_spmf (Inl z)\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (eq_\\<I>_generat (=) \\<I>'\n       (\\<lambda>gpv gpv'.\n           (\\<exists>gpva s.\n               gpv =\n               map_gpv f id (inline callee (TRY gpva ELSE Done x) s) \\<and>\n               gpv' =\n               TRY map_gpv f id (inline callee gpva s) ELSE Done z \\<and>\n               \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n               pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n           eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n           (\\<exists>gpv'' gpv''' B fa g.\n               gpv = gpv'' \\<bind> fa \\<and>\n               gpv' = gpv''' \\<bind> g \\<and>\n               eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n               rel_fun B\n                (\\<lambda>gpva__ gpv'__.\n                    \\<exists>gpv s.\n                       gpva__ =\n                       map_gpv f id\n                        (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                       gpv'__ =\n                       TRY map_gpv f id\n                            (inline callee gpv s) ELSE Done z \\<and>\n                       \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                       pfinite_gpv \\<I> gpv \\<and> I s)\n                fa g)))\n     (the_gpv (map_gpv f id (inline callee (TRY gpv ELSE Done x) s)))\n     (the_gpv (TRY map_gpv f id (inline callee gpv s) ELSE Done z))", "have \"\\<dots> = map_spmf (\\<lambda>y. case y of None \\<Rightarrow> Inl z | Some x' \\<Rightarrow> map_sum f (\\<lambda>(out, c, rpv). (out, c, \\<lambda>input. try_gpv (rpv input) (Done x))) x') \n        (try_spmf (map_spmf Some (inline1 callee gpv s)) (return_spmf None))\"\n      (is \"_ = ?lhs3\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. TRY map_spmf\n         (map_sum f\n           (\\<lambda>(out, c, rpv).\n               (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n         (inline1 callee gpv s) ELSE return_spmf (Inl z) =\n    map_spmf\n     (\\<lambda>y.\n         case y of None \\<Rightarrow> Inl z\n         | Some x' \\<Rightarrow>\n             map_sum f\n              (\\<lambda>(out, c, rpv).\n                  (out, c, \\<lambda>input. TRY rpv input ELSE Done x))\n              x')\n     (TRY map_spmf Some (inline1 callee gpv s) ELSE return_spmf None)", "by(simp add: map_try_spmf spmf.map_comp o_def)"], ["proof (state)\nthis:\n  TRY map_spmf\n       (map_sum f\n         (\\<lambda>(out, c, rpv).\n             (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n       (inline1 callee gpv s) ELSE return_spmf (Inl z) =\n  map_spmf\n   (\\<lambda>y.\n       case y of None \\<Rightarrow> Inl z\n       | Some x' \\<Rightarrow>\n           map_sum f\n            (\\<lambda>(out, c, rpv).\n                (out, c, \\<lambda>input. TRY rpv input ELSE Done x))\n            x')\n   (TRY map_spmf Some (inline1 callee gpv s) ELSE return_spmf None)\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (eq_\\<I>_generat (=) \\<I>'\n       (\\<lambda>gpv gpv'.\n           (\\<exists>gpva s.\n               gpv =\n               map_gpv f id (inline callee (TRY gpva ELSE Done x) s) \\<and>\n               gpv' =\n               TRY map_gpv f id (inline callee gpva s) ELSE Done z \\<and>\n               \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n               pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n           eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n           (\\<exists>gpv'' gpv''' B fa g.\n               gpv = gpv'' \\<bind> fa \\<and>\n               gpv' = gpv''' \\<bind> g \\<and>\n               eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n               rel_fun B\n                (\\<lambda>gpva__ gpv'__.\n                    \\<exists>gpv s.\n                       gpva__ =\n                       map_gpv f id\n                        (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                       gpv'__ =\n                       TRY map_gpv f id\n                            (inline callee gpv s) ELSE Done z \\<and>\n                       \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                       pfinite_gpv \\<I> gpv \\<and> I s)\n                fa g)))\n     (the_gpv (map_gpv f id (inline callee (TRY gpv ELSE Done x) s)))\n     (the_gpv (TRY map_gpv f id (inline callee gpv s) ELSE Done z))", "also"], ["proof (state)\nthis:\n  TRY map_spmf\n       (map_sum f\n         (\\<lambda>(out, c, rpv).\n             (out, c, \\<lambda>input. TRY rpv input ELSE Done x)))\n       (inline1 callee gpv s) ELSE return_spmf (Inl z) =\n  map_spmf\n   (\\<lambda>y.\n       case y of None \\<Rightarrow> Inl z\n       | Some x' \\<Rightarrow>\n           map_sum f\n            (\\<lambda>(out, c, rpv).\n                (out, c, \\<lambda>input. TRY rpv input ELSE Done x))\n            x')\n   (TRY map_spmf Some (inline1 callee gpv s) ELSE return_spmf None)\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (eq_\\<I>_generat (=) \\<I>'\n       (\\<lambda>gpv gpv'.\n           (\\<exists>gpva s.\n               gpv =\n               map_gpv f id (inline callee (TRY gpva ELSE Done x) s) \\<and>\n               gpv' =\n               TRY map_gpv f id (inline callee gpva s) ELSE Done z \\<and>\n               \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n               pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n           eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n           (\\<exists>gpv'' gpv''' B fa g.\n               gpv = gpv'' \\<bind> fa \\<and>\n               gpv' = gpv''' \\<bind> g \\<and>\n               eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n               rel_fun B\n                (\\<lambda>gpva__ gpv'__.\n                    \\<exists>gpv s.\n                       gpva__ =\n                       map_gpv f id\n                        (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                       gpv'__ =\n                       TRY map_gpv f id\n                            (inline callee gpv s) ELSE Done z \\<and>\n                       \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                       pfinite_gpv \\<I> gpv \\<and> I s)\n                fa g)))\n     (the_gpv (map_gpv f id (inline callee (TRY gpv ELSE Done x) s)))\n     (the_gpv (TRY map_gpv f id (inline callee gpv s) ELSE Done z))", "have \"?rhs = map_spmf (\\<lambda>y. case y of None \\<Rightarrow> Pure z | Some (Inl x) \\<Rightarrow> Pure (f x)\n           | Some (Inr (out, oracle, rpv)) \\<Rightarrow> IO out (\\<lambda>input. try_gpv (map_gpv f id (bind_gpv (oracle input) (\\<lambda>(x, y). inline callee (rpv x) y))) (Done z)))\n       (try_spmf (map_spmf Some (inline1 callee gpv s)) (return_spmf None))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_gpv (TRY map_gpv f id (inline callee gpv s) ELSE Done z) =\n    map_spmf\n     (\\<lambda>y.\n         case y of None \\<Rightarrow> Pure z\n         | Some (Inl x) \\<Rightarrow> Pure (f x)\n         | Some (Inr (out, oracle, rpv)) \\<Rightarrow>\n             IO out\n              (\\<lambda>input.\n                  TRY map_gpv f id\n                       (oracle input \\<bind>\n                        (\\<lambda>(x, y).\n                            inline callee (rpv x) y)) ELSE Done z))\n     (TRY map_spmf Some (inline1 callee gpv s) ELSE return_spmf None)", "by(auto simp add: gpv.map_sel inline_sel spmf.map_comp o_def generat.map_comp spmf_rel_map map_try_spmf intro!: try_spmf_cong map_spmf_cong split: sum.split)"], ["proof (state)\nthis:\n  the_gpv (TRY map_gpv f id (inline callee gpv s) ELSE Done z) =\n  map_spmf\n   (\\<lambda>y.\n       case y of None \\<Rightarrow> Pure z\n       | Some (Inl x) \\<Rightarrow> Pure (f x)\n       | Some (Inr (out, oracle, rpv)) \\<Rightarrow>\n           IO out\n            (\\<lambda>input.\n                TRY map_gpv f id\n                     (oracle input \\<bind>\n                      (\\<lambda>(x, y).\n                          inline callee (rpv x) y)) ELSE Done z))\n   (TRY map_spmf Some (inline1 callee gpv s) ELSE return_spmf None)\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (eq_\\<I>_generat (=) \\<I>'\n       (\\<lambda>gpv gpv'.\n           (\\<exists>gpva s.\n               gpv =\n               map_gpv f id (inline callee (TRY gpva ELSE Done x) s) \\<and>\n               gpv' =\n               TRY map_gpv f id (inline callee gpva s) ELSE Done z \\<and>\n               \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n               pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n           eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n           (\\<exists>gpv'' gpv''' B fa g.\n               gpv = gpv'' \\<bind> fa \\<and>\n               gpv' = gpv''' \\<bind> g \\<and>\n               eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n               rel_fun B\n                (\\<lambda>gpva__ gpv'__.\n                    \\<exists>gpv s.\n                       gpva__ =\n                       map_gpv f id\n                        (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                       gpv'__ =\n                       TRY map_gpv f id\n                            (inline callee gpv s) ELSE Done z \\<and>\n                       \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                       pfinite_gpv \\<I> gpv \\<and> I s)\n                fa g)))\n     (the_gpv (map_gpv f id (inline callee (TRY gpv ELSE Done x) s)))\n     (the_gpv (TRY map_gpv f id (inline callee gpv s) ELSE Done z))", "moreover"], ["proof (state)\nthis:\n  the_gpv (TRY map_gpv f id (inline callee gpv s) ELSE Done z) =\n  map_spmf\n   (\\<lambda>y.\n       case y of None \\<Rightarrow> Pure z\n       | Some (Inl x) \\<Rightarrow> Pure (f x)\n       | Some (Inr (out, oracle, rpv)) \\<Rightarrow>\n           IO out\n            (\\<lambda>input.\n                TRY map_gpv f id\n                     (oracle input \\<bind>\n                      (\\<lambda>(x, y).\n                          inline callee (rpv x) y)) ELSE Done z))\n   (TRY map_spmf Some (inline1 callee gpv s) ELSE return_spmf None)\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (eq_\\<I>_generat (=) \\<I>'\n       (\\<lambda>gpv gpv'.\n           (\\<exists>gpva s.\n               gpv =\n               map_gpv f id (inline callee (TRY gpva ELSE Done x) s) \\<and>\n               gpv' =\n               TRY map_gpv f id (inline callee gpva s) ELSE Done z \\<and>\n               \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n               pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n           eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n           (\\<exists>gpv'' gpv''' B fa g.\n               gpv = gpv'' \\<bind> fa \\<and>\n               gpv' = gpv''' \\<bind> g \\<and>\n               eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n               rel_fun B\n                (\\<lambda>gpva__ gpv'__.\n                    \\<exists>gpv s.\n                       gpva__ =\n                       map_gpv f id\n                        (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                       gpv'__ =\n                       TRY map_gpv f id\n                            (inline callee gpv s) ELSE Done z \\<and>\n                       \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                       pfinite_gpv \\<I> gpv \\<and> I s)\n                fa g)))\n     (the_gpv (map_gpv f id (inline callee (TRY gpv ELSE Done x) s)))\n     (the_gpv (TRY map_gpv f id (inline callee gpv s) ELSE Done z))", "have \"rel_spmf (eq_\\<I>_generat (=) \\<I>' ?X) (map_spmf ?f ?lhs3) \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (eq_\\<I>_generat (=) \\<I>'\n       (\\<lambda>gpv gpv'.\n           (\\<exists>gpva s.\n               gpv =\n               map_gpv f id (inline callee (TRY gpva ELSE Done x) s) \\<and>\n               gpv' =\n               TRY map_gpv f id (inline callee gpva s) ELSE Done z \\<and>\n               \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n               pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n           eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n           (\\<exists>gpv'' gpv''' B fa g.\n               gpv = gpv'' \\<bind> fa \\<and>\n               gpv' = gpv''' \\<bind> g \\<and>\n               eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n               rel_fun B\n                (\\<lambda>gpva__ gpv'__.\n                    \\<exists>gpv s.\n                       gpva__ =\n                       map_gpv f id\n                        (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                       gpv'__ =\n                       TRY map_gpv f id\n                            (inline callee gpv s) ELSE Done z \\<and>\n                       \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                       pfinite_gpv \\<I> gpv \\<and> I s)\n                fa g)))\n     (map_spmf\n       (\\<lambda>x.\n           case x of Inl rs \\<Rightarrow> Pure rs\n           | Inr (out, oracle, rpv) \\<Rightarrow>\n               IO out\n                (\\<lambda>input.\n                    map_gpv f id\n                     (TRY map_gpv Some id\n                           (oracle input) ELSE Done None \\<bind>\n                      (\\<lambda>xy.\n                          case xy of None \\<Rightarrow> Fail\n                          | Some (x, y) \\<Rightarrow>\n                              inline callee (rpv x) y))))\n       (map_spmf\n         (\\<lambda>y.\n             case y of None \\<Rightarrow> Inl z\n             | Some x' \\<Rightarrow>\n                 map_sum f\n                  (\\<lambda>(out, c, rpv).\n                      (out, c, \\<lambda>input. TRY rpv input ELSE Done x))\n                  x')\n         (TRY map_spmf Some (inline1 callee gpv s) ELSE return_spmf None)))\n     (map_spmf\n       (\\<lambda>y.\n           case y of None \\<Rightarrow> Pure z\n           | Some (Inl x) \\<Rightarrow> Pure (f x)\n           | Some (Inr (out, oracle, rpv)) \\<Rightarrow>\n               IO out\n                (\\<lambda>input.\n                    TRY map_gpv f id\n                         (oracle input \\<bind>\n                          (\\<lambda>(x, y).\n                              inline callee (rpv x) y)) ELSE Done z))\n       (TRY map_spmf Some (inline1 callee gpv s) ELSE return_spmf None))", "apply(clarsimp simp add: gpv.map_sel inline_sel spmf.map_comp o_def generat.map_comp spmf_rel_map intro!: rel_spmf_reflI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> Some ` set_spmf (inline1 callee gpv s) \\<or>\n       xa \\<in> (if lossless_spmf (inline1 callee gpv s) then {}\n                 else set_spmf (return_spmf None)) \\<Longrightarrow>\n       eq_\\<I>_generat (=) \\<I>'\n        (\\<lambda>gpv gpv'.\n            (\\<exists>gpva s.\n                gpv =\n                map_gpv f id (inline callee (TRY gpva ELSE Done x) s) \\<and>\n                gpv' =\n                TRY map_gpv f id (inline callee gpva s) ELSE Done z \\<and>\n                \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n                pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n            eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n            (\\<exists>gpv'' gpv''' B fa.\n                gpv = gpv'' \\<bind> fa \\<and>\n                (\\<exists>g.\n                    gpv' = gpv''' \\<bind> g \\<and>\n                    eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n                    rel_fun B\n                     (\\<lambda>gpva__ gpv'__.\n                         \\<exists>gpv s.\n                            gpva__ =\n                            map_gpv f id\n                             (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                            gpv'__ =\n                            TRY map_gpv f id\n                                 (inline callee gpv s) ELSE Done z \\<and>\n                            \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                            pfinite_gpv \\<I> gpv \\<and> I s)\n                     fa g)))\n        (case case xa of None \\<Rightarrow> Inl z\n              | Some xa \\<Rightarrow>\n                  map_sum f\n                   (\\<lambda>(out, c, rpv).\n                       (out, c, \\<lambda>input. TRY rpv input ELSE Done x))\n                   xa of\n         Inl x \\<Rightarrow> Pure x\n         | Inr (out, oracle, rpv) \\<Rightarrow>\n             IO out\n              (\\<lambda>input.\n                  map_gpv f id\n                   (TRY map_gpv Some id\n                         (oracle input) ELSE Done None \\<bind>\n                    case_option Fail\n                     (\\<lambda>(x, y). inline callee (rpv x) y))))\n        (case xa of None \\<Rightarrow> Pure z\n         | Some (Inl xa) \\<Rightarrow> Pure (f xa)\n         | Some (Inr (out, oracle, rpv)) \\<Rightarrow>\n             IO out\n              (\\<lambda>input.\n                  TRY map_gpv f id\n                       (oracle input \\<bind>\n                        (\\<lambda>(x, y).\n                            inline callee (rpv x) y)) ELSE Done z))", "apply(erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> Some ` set_spmf (inline1 callee gpv s) \\<Longrightarrow>\n       eq_\\<I>_generat (=) \\<I>'\n        (\\<lambda>gpv gpv'.\n            (\\<exists>gpva s.\n                gpv =\n                map_gpv f id (inline callee (TRY gpva ELSE Done x) s) \\<and>\n                gpv' =\n                TRY map_gpv f id (inline callee gpva s) ELSE Done z \\<and>\n                \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n                pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n            eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n            (\\<exists>gpv'' gpv''' B fa.\n                gpv = gpv'' \\<bind> fa \\<and>\n                (\\<exists>g.\n                    gpv' = gpv''' \\<bind> g \\<and>\n                    eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n                    rel_fun B\n                     (\\<lambda>gpva__ gpv'__.\n                         \\<exists>gpv s.\n                            gpva__ =\n                            map_gpv f id\n                             (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                            gpv'__ =\n                            TRY map_gpv f id\n                                 (inline callee gpv s) ELSE Done z \\<and>\n                            \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                            pfinite_gpv \\<I> gpv \\<and> I s)\n                     fa g)))\n        (case case xa of None \\<Rightarrow> Inl z\n              | Some xa \\<Rightarrow>\n                  map_sum f\n                   (\\<lambda>(out, c, rpv).\n                       (out, c, \\<lambda>input. TRY rpv input ELSE Done x))\n                   xa of\n         Inl x \\<Rightarrow> Pure x\n         | Inr (out, oracle, rpv) \\<Rightarrow>\n             IO out\n              (\\<lambda>input.\n                  map_gpv f id\n                   (TRY map_gpv Some id\n                         (oracle input) ELSE Done None \\<bind>\n                    case_option Fail\n                     (\\<lambda>(x, y). inline callee (rpv x) y))))\n        (case xa of None \\<Rightarrow> Pure z\n         | Some (Inl xa) \\<Rightarrow> Pure (f xa)\n         | Some (Inr (out, oracle, rpv)) \\<Rightarrow>\n             IO out\n              (\\<lambda>input.\n                  TRY map_gpv f id\n                       (oracle input \\<bind>\n                        (\\<lambda>(x, y).\n                            inline callee (rpv x) y)) ELSE Done z))\n 2. \\<And>xa.\n       xa \\<in> (if lossless_spmf (inline1 callee gpv s) then {}\n                 else set_spmf (return_spmf None)) \\<Longrightarrow>\n       eq_\\<I>_generat (=) \\<I>'\n        (\\<lambda>gpv gpv'.\n            (\\<exists>gpva s.\n                gpv =\n                map_gpv f id (inline callee (TRY gpva ELSE Done x) s) \\<and>\n                gpv' =\n                TRY map_gpv f id (inline callee gpva s) ELSE Done z \\<and>\n                \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n                pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n            eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n            (\\<exists>gpv'' gpv''' B fa.\n                gpv = gpv'' \\<bind> fa \\<and>\n                (\\<exists>g.\n                    gpv' = gpv''' \\<bind> g \\<and>\n                    eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n                    rel_fun B\n                     (\\<lambda>gpva__ gpv'__.\n                         \\<exists>gpv s.\n                            gpva__ =\n                            map_gpv f id\n                             (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                            gpv'__ =\n                            TRY map_gpv f id\n                                 (inline callee gpv s) ELSE Done z \\<and>\n                            \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                            pfinite_gpv \\<I> gpv \\<and> I s)\n                     fa g)))\n        (case case xa of None \\<Rightarrow> Inl z\n              | Some xa \\<Rightarrow>\n                  map_sum f\n                   (\\<lambda>(out, c, rpv).\n                       (out, c, \\<lambda>input. TRY rpv input ELSE Done x))\n                   xa of\n         Inl x \\<Rightarrow> Pure x\n         | Inr (out, oracle, rpv) \\<Rightarrow>\n             IO out\n              (\\<lambda>input.\n                  map_gpv f id\n                   (TRY map_gpv Some id\n                         (oracle input) ELSE Done None \\<bind>\n                    case_option Fail\n                     (\\<lambda>(x, y). inline callee (rpv x) y))))\n        (case xa of None \\<Rightarrow> Pure z\n         | Some (Inl xa) \\<Rightarrow> Pure (f xa)\n         | Some (Inr (out, oracle, rpv)) \\<Rightarrow>\n             IO out\n              (\\<lambda>input.\n                  TRY map_gpv f id\n                       (oracle input \\<bind>\n                        (\\<lambda>(x, y).\n                            inline callee (rpv x) y)) ELSE Done z))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. xa_ \\<in> Some ` set_spmf (inline1 callee gpv s) \\<Longrightarrow>\n    eq_\\<I>_generat (=) \\<I>'\n     (\\<lambda>gpv gpv'.\n         (\\<exists>gpva s.\n             gpv =\n             map_gpv f id (inline callee (TRY gpva ELSE Done x) s) \\<and>\n             gpv' =\n             TRY map_gpv f id (inline callee gpva s) ELSE Done z \\<and>\n             \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n             pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n         eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n         (\\<exists>gpv'' gpv''' B fa.\n             gpv = gpv'' \\<bind> fa \\<and>\n             (\\<exists>g.\n                 gpv' = gpv''' \\<bind> g \\<and>\n                 eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n                 rel_fun B\n                  (\\<lambda>gpva__ gpv'__.\n                      \\<exists>gpv s.\n                         gpva__ =\n                         map_gpv f id\n                          (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                         gpv'__ =\n                         TRY map_gpv f id\n                              (inline callee gpv s) ELSE Done z \\<and>\n                         \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                         pfinite_gpv \\<I> gpv \\<and> I s)\n                  fa g)))\n     (case case xa_ of None \\<Rightarrow> Inl z\n           | Some xa \\<Rightarrow>\n               map_sum f\n                (\\<lambda>(out, c, rpv).\n                    (out, c, \\<lambda>input. TRY rpv input ELSE Done x))\n                xa of\n      Inl x \\<Rightarrow> Pure x\n      | Inr (out, oracle, rpv) \\<Rightarrow>\n          IO out\n           (\\<lambda>input.\n               map_gpv f id\n                (TRY map_gpv Some id (oracle input) ELSE Done None \\<bind>\n                 case_option Fail\n                  (\\<lambda>(x, y). inline callee (rpv x) y))))\n     (case xa_ of None \\<Rightarrow> Pure z\n      | Some (Inl xa) \\<Rightarrow> Pure (f xa)\n      | Some (Inr (out, oracle, rpv)) \\<Rightarrow>\n          IO out\n           (\\<lambda>input.\n               TRY map_gpv f id\n                    (oracle input \\<bind>\n                     (\\<lambda>(x, y).\n                         inline callee (rpv x) y)) ELSE Done z))", "apply(clarsimp split!: generat.split sum.split simp add: map_gpv_id_bind_gpv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>Inr (a, aa, ba) \\<in> set_spmf (inline1 callee gpv s);\n        xa_ = Some (Inr (a, aa, ba))\\<rbrakk>\n       \\<Longrightarrow> a \\<in> outs_\\<I> \\<I>' \\<and>\n                         (\\<forall>xa.\n                             xa \\<in> responses_\\<I> \\<I>'\n a \\<longrightarrow>\n                             (\\<exists>gpv s.\n                                 TRY map_gpv Some id\n(aa xa) ELSE Done None \\<bind>\n                                 map_gpv f id \\<circ>\n                                 case_option Fail\n                                  (\\<lambda>(xa, y).\ninline callee (TRY ba xa ELSE Done x) y) =\n                                 map_gpv f id\n                                  (inline callee (TRY gpv ELSE Done x)\n                                    s) \\<and>\n                                 TRY aa xa \\<bind>\n                                     map_gpv f id \\<circ>\n                                     (\\<lambda>(x, y).\n   inline callee (ba x) y) ELSE Done z =\n                                 TRY map_gpv f id\n(inline callee gpv s) ELSE Done z \\<and>\n                                 \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                                 pfinite_gpv \\<I> gpv \\<and> I s) \\<or>\n                             eq_\\<I>_gpv (=) \\<I>'\n                              (TRY map_gpv Some id\n                                    (aa xa) ELSE Done None \\<bind>\n                               map_gpv f id \\<circ>\n                               case_option Fail\n                                (\\<lambda>(xa, y).\n                                    inline callee (TRY ba xa ELSE Done x)\n                                     y))\n                              (TRY aa xa \\<bind>\n                                   map_gpv f id \\<circ>\n                                   (\\<lambda>(x, y).\n inline callee (ba x) y) ELSE Done z) \\<or>\n                             (\\<exists>gpv'' gpv''' B fa.\n                                 TRY map_gpv Some id\n(aa xa) ELSE Done None \\<bind>\n                                 map_gpv f id \\<circ>\n                                 case_option Fail\n                                  (\\<lambda>(xa, y).\ninline callee (TRY ba xa ELSE Done x) y) =\n                                 gpv'' \\<bind> fa \\<and>\n                                 (\\<exists>g.\n                                     TRY aa xa \\<bind>\n   map_gpv f id \\<circ>\n   (\\<lambda>(x, y). inline callee (ba x) y) ELSE Done z =\n                                     gpv''' \\<bind> g \\<and>\n                                     eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n                                     rel_fun B\n(\\<lambda>gpva__ gpv'__.\n    \\<exists>gpv s.\n       gpva__ = map_gpv f id (inline callee (TRY gpv ELSE Done x) s) \\<and>\n       gpv'__ = TRY map_gpv f id (inline callee gpv s) ELSE Done z \\<and>\n       \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n       pfinite_gpv \\<I> gpv \\<and> I s)\nfa g)))", "apply(subst (3) try_gpv_bind_gpv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>Inr (a, aa, ba) \\<in> set_spmf (inline1 callee gpv s);\n        xa_ = Some (Inr (a, aa, ba))\\<rbrakk>\n       \\<Longrightarrow> a \\<in> outs_\\<I> \\<I>' \\<and>\n                         (\\<forall>xa.\n                             xa \\<in> responses_\\<I> \\<I>'\n a \\<longrightarrow>\n                             (\\<exists>gpv s.\n                                 TRY map_gpv Some id\n(aa xa) ELSE Done None \\<bind>\n                                 map_gpv f id \\<circ>\n                                 case_option Fail\n                                  (\\<lambda>(xa, y).\ninline callee (TRY ba xa ELSE Done x) y) =\n                                 map_gpv f id\n                                  (inline callee (TRY gpv ELSE Done x)\n                                    s) \\<and>\n                                 TRY aa xa \\<bind>\n                                     map_gpv f id \\<circ>\n                                     (\\<lambda>(x, y).\n   inline callee (ba x) y) ELSE Done z =\n                                 TRY map_gpv f id\n(inline callee gpv s) ELSE Done z \\<and>\n                                 \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                                 pfinite_gpv \\<I> gpv \\<and> I s) \\<or>\n                             eq_\\<I>_gpv (=) \\<I>'\n                              (TRY map_gpv Some id\n                                    (aa xa) ELSE Done None \\<bind>\n                               map_gpv f id \\<circ>\n                               case_option Fail\n                                (\\<lambda>(xa, y).\n                                    inline callee (TRY ba xa ELSE Done x)\n                                     y))\n                              (TRY aa xa \\<bind>\n                                   map_gpv f id \\<circ>\n                                   (\\<lambda>(x, y).\n inline callee (ba x) y) ELSE Done z) \\<or>\n                             (\\<exists>gpv'' gpv''' B fa.\n                                 TRY map_gpv Some id\n(aa xa) ELSE Done None \\<bind>\n                                 map_gpv f id \\<circ>\n                                 case_option Fail\n                                  (\\<lambda>(xa, y).\ninline callee (TRY ba xa ELSE Done x) y) =\n                                 gpv'' \\<bind> fa \\<and>\n                                 (\\<exists>g.\n                                     TRY map_gpv Some id\n    (aa xa) ELSE Done None \\<bind>\n                                     case_option (Done z)\n(\\<lambda>x'.\n    TRY (map_gpv f id \\<circ> (\\<lambda>(x, y). inline callee (ba x) y))\n         x' ELSE Done z) =\n                                     gpv''' \\<bind> g \\<and>\n                                     eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n                                     rel_fun B\n(\\<lambda>gpva__ gpv'__.\n    \\<exists>gpv s.\n       gpva__ = map_gpv f id (inline callee (TRY gpv ELSE Done x) s) \\<and>\n       gpv'__ = TRY map_gpv f id (inline callee gpv s) ELSE Done z \\<and>\n       \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n       pfinite_gpv \\<I> gpv \\<and> I s)\nfa g)))", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa ba.\n       \\<lbrakk>Inr (a, aa, ba) \\<in> set_spmf (inline1 callee gpv s);\n        xa_ = Some (Inr (a, aa, ba))\\<rbrakk>\n       \\<Longrightarrow> a \\<in> outs_\\<I> \\<I>'\n 2. \\<And>a aa ba.\n       \\<lbrakk>Inr (a, aa, ba) \\<in> set_spmf (inline1 callee gpv s);\n        xa_ = Some (Inr (a, aa, ba))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            xa \\<in> responses_\\<I> \\<I>'\na \\<longrightarrow>\n                            (\\<exists>gpv s.\n                                TRY map_gpv Some id\n                                     (aa xa) ELSE Done None \\<bind>\n                                map_gpv f id \\<circ>\n                                case_option Fail\n                                 (\\<lambda>(xa, y).\n                                     inline callee (TRY ba xa ELSE Done x)\ny) =\n                                map_gpv f id\n                                 (inline callee (TRY gpv ELSE Done x)\n                                   s) \\<and>\n                                TRY aa xa \\<bind>\n                                    map_gpv f id \\<circ>\n                                    (\\<lambda>(x, y).\n  inline callee (ba x) y) ELSE Done z =\n                                TRY map_gpv f id\n                                     (inline callee gpv\n s) ELSE Done z \\<and>\n                                \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                                pfinite_gpv \\<I> gpv \\<and> I s) \\<or>\n                            eq_\\<I>_gpv (=) \\<I>'\n                             (TRY map_gpv Some id\n                                   (aa xa) ELSE Done None \\<bind>\n                              map_gpv f id \\<circ>\n                              case_option Fail\n                               (\\<lambda>(xa, y).\n                                   inline callee (TRY ba xa ELSE Done x) y))\n                             (TRY aa xa \\<bind>\n                                  map_gpv f id \\<circ>\n                                  (\\<lambda>(x, y).\ninline callee (ba x) y) ELSE Done z) \\<or>\n                            (\\<exists>gpv'' gpv''' B fa.\n                                TRY map_gpv Some id\n                                     (aa xa) ELSE Done None \\<bind>\n                                map_gpv f id \\<circ>\n                                case_option Fail\n                                 (\\<lambda>(xa, y).\n                                     inline callee (TRY ba xa ELSE Done x)\ny) =\n                                gpv'' \\<bind> fa \\<and>\n                                (\\<exists>g.\n                                    TRY map_gpv Some id\n   (aa xa) ELSE Done None \\<bind>\n                                    case_option (Done z)\n                                     (\\<lambda>x'.\n   TRY (map_gpv f id \\<circ> (\\<lambda>(x, y). inline callee (ba x) y))\n        x' ELSE Done z) =\n                                    gpv''' \\<bind> g \\<and>\n                                    eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n                                    rel_fun B\n                                     (\\<lambda>gpva__ gpv'__.\n   \\<exists>gpv s.\n      gpva__ = map_gpv f id (inline callee (TRY gpv ELSE Done x) s) \\<and>\n      gpv'__ = TRY map_gpv f id (inline callee gpv s) ELSE Done z \\<and>\n      \\<I> \\<turnstile>g gpv \\<surd> \\<and> pfinite_gpv \\<I> gpv \\<and> I s)\n                                     fa g))", "apply(erule WT_gpv_inline1[OF _ eq_\\<I>_gpv(1,3)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ba.\n       \\<lbrakk>Inr (a, aa, ba) \\<in> set_spmf (inline1 callee gpv s);\n        xa_ = Some (Inr (a, aa, ba))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa.\n                            xa \\<in> responses_\\<I> \\<I>'\na \\<longrightarrow>\n                            (\\<exists>gpv s.\n                                TRY map_gpv Some id\n                                     (aa xa) ELSE Done None \\<bind>\n                                map_gpv f id \\<circ>\n                                case_option Fail\n                                 (\\<lambda>(xa, y).\n                                     inline callee (TRY ba xa ELSE Done x)\ny) =\n                                map_gpv f id\n                                 (inline callee (TRY gpv ELSE Done x)\n                                   s) \\<and>\n                                TRY aa xa \\<bind>\n                                    map_gpv f id \\<circ>\n                                    (\\<lambda>(x, y).\n  inline callee (ba x) y) ELSE Done z =\n                                TRY map_gpv f id\n                                     (inline callee gpv\n s) ELSE Done z \\<and>\n                                \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                                pfinite_gpv \\<I> gpv \\<and> I s) \\<or>\n                            eq_\\<I>_gpv (=) \\<I>'\n                             (TRY map_gpv Some id\n                                   (aa xa) ELSE Done None \\<bind>\n                              map_gpv f id \\<circ>\n                              case_option Fail\n                               (\\<lambda>(xa, y).\n                                   inline callee (TRY ba xa ELSE Done x) y))\n                             (TRY aa xa \\<bind>\n                                  map_gpv f id \\<circ>\n                                  (\\<lambda>(x, y).\ninline callee (ba x) y) ELSE Done z) \\<or>\n                            (\\<exists>gpv'' gpv''' B fa.\n                                TRY map_gpv Some id\n                                     (aa xa) ELSE Done None \\<bind>\n                                map_gpv f id \\<circ>\n                                case_option Fail\n                                 (\\<lambda>(xa, y).\n                                     inline callee (TRY ba xa ELSE Done x)\ny) =\n                                gpv'' \\<bind> fa \\<and>\n                                (\\<exists>g.\n                                    TRY map_gpv Some id\n   (aa xa) ELSE Done None \\<bind>\n                                    case_option (Done z)\n                                     (\\<lambda>x'.\n   TRY (map_gpv f id \\<circ> (\\<lambda>(x, y). inline callee (ba x) y))\n        x' ELSE Done z) =\n                                    gpv''' \\<bind> g \\<and>\n                                    eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n                                    rel_fun B\n                                     (\\<lambda>gpva__ gpv'__.\n   \\<exists>gpv s.\n      gpva__ = map_gpv f id (inline callee (TRY gpv ELSE Done x) s) \\<and>\n      gpv'__ = TRY map_gpv f id (inline callee gpv s) ELSE Done z \\<and>\n      \\<I> \\<turnstile>g gpv \\<surd> \\<and> pfinite_gpv \\<I> gpv \\<and> I s)\n                                     fa g))", "apply(rule strip)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ba xb.\n       \\<lbrakk>Inr (a, aa, ba) \\<in> set_spmf (inline1 callee gpv s);\n        xa_ = Some (Inr (a, aa, ba));\n        xb \\<in> responses_\\<I> \\<I>' a\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>gpv s.\n                             TRY map_gpv Some id\n                                  (aa xb) ELSE Done None \\<bind>\n                             map_gpv f id \\<circ>\n                             case_option Fail\n                              (\\<lambda>(xa, y).\n                                  inline callee (TRY ba xa ELSE Done x) y) =\n                             map_gpv f id\n                              (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                             TRY aa xb \\<bind>\n                                 map_gpv f id \\<circ>\n                                 (\\<lambda>(x, y).\n                                     inline callee (ba x) y) ELSE Done z =\n                             TRY map_gpv f id\n                                  (inline callee gpv s) ELSE Done z \\<and>\n                             \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                             pfinite_gpv \\<I> gpv \\<and> I s) \\<or>\n                         eq_\\<I>_gpv (=) \\<I>'\n                          (TRY map_gpv Some id\n                                (aa xb) ELSE Done None \\<bind>\n                           map_gpv f id \\<circ>\n                           case_option Fail\n                            (\\<lambda>(xa, y).\n                                inline callee (TRY ba xa ELSE Done x) y))\n                          (TRY aa xb \\<bind>\n                               map_gpv f id \\<circ>\n                               (\\<lambda>(x, y).\n                                   inline callee (ba x)\n                                    y) ELSE Done z) \\<or>\n                         (\\<exists>gpv'' gpv''' B fa.\n                             TRY map_gpv Some id\n                                  (aa xb) ELSE Done None \\<bind>\n                             map_gpv f id \\<circ>\n                             case_option Fail\n                              (\\<lambda>(xa, y).\n                                  inline callee (TRY ba xa ELSE Done x) y) =\n                             gpv'' \\<bind> fa \\<and>\n                             (\\<exists>g.\n                                 TRY map_gpv Some id\n(aa xb) ELSE Done None \\<bind>\n                                 case_option (Done z)\n                                  (\\<lambda>x'.\nTRY (map_gpv f id \\<circ> (\\<lambda>(x, y). inline callee (ba x) y))\n     x' ELSE Done z) =\n                                 gpv''' \\<bind> g \\<and>\n                                 eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n                                 rel_fun B\n                                  (\\<lambda>gpva__ gpv'__.\n\\<exists>gpv s.\n   gpva__ = map_gpv f id (inline callee (TRY gpv ELSE Done x) s) \\<and>\n   gpv'__ = TRY map_gpv f id (inline callee gpv s) ELSE Done z \\<and>\n   \\<I> \\<turnstile>g gpv \\<surd> \\<and> pfinite_gpv \\<I> gpv \\<and> I s)\n                                  fa g))", "apply(rule disjI2)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ba xb.\n       \\<lbrakk>Inr (a, aa, ba) \\<in> set_spmf (inline1 callee gpv s);\n        xa_ = Some (Inr (a, aa, ba));\n        xb \\<in> responses_\\<I> \\<I>' a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gpv'' gpv''' B fa.\n                            TRY map_gpv Some id\n                                 (aa xb) ELSE Done None \\<bind>\n                            map_gpv f id \\<circ>\n                            case_option Fail\n                             (\\<lambda>(xa, y).\n                                 inline callee (TRY ba xa ELSE Done x) y) =\n                            gpv'' \\<bind> fa \\<and>\n                            (\\<exists>g.\n                                TRY map_gpv Some id\n                                     (aa xb) ELSE Done None \\<bind>\n                                case_option (Done z)\n                                 (\\<lambda>x'.\n                                     TRY (map_gpv f id \\<circ>\n    (\\<lambda>(x, y). inline callee (ba x) y))\n    x' ELSE Done z) =\n                                gpv''' \\<bind> g \\<and>\n                                eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n                                rel_fun B\n                                 (\\<lambda>gpva__ gpv'__.\n                                     \\<exists>gpv s.\n  gpva__ = map_gpv f id (inline callee (TRY gpv ELSE Done x) s) \\<and>\n  gpv'__ = TRY map_gpv f id (inline callee gpv s) ELSE Done z \\<and>\n  \\<I> \\<turnstile>g gpv \\<surd> \\<and> pfinite_gpv \\<I> gpv \\<and> I s)\n                                 fa g)", "subgoal for out rpv rpv' input"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gpv'' gpv''' B fa.\n                         TRY map_gpv Some id\n                              (rpv input) ELSE Done None \\<bind>\n                         map_gpv f id \\<circ>\n                         case_option Fail\n                          (\\<lambda>(xa, y).\n                              inline callee (TRY rpv' xa ELSE Done x) y) =\n                         gpv'' \\<bind> fa \\<and>\n                         (\\<exists>g.\n                             TRY map_gpv Some id\n                                  (rpv input) ELSE Done None \\<bind>\n                             case_option (Done z)\n                              (\\<lambda>x'.\n                                  TRY (map_gpv f id \\<circ>\n (\\<lambda>(x, y). inline callee (rpv' x) y))\n x' ELSE Done z) =\n                             gpv''' \\<bind> g \\<and>\n                             eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n                             rel_fun B\n                              (\\<lambda>gpva__ gpv'__.\n                                  \\<exists>gpv s.\n                                     gpva__ =\n                                     map_gpv f id\n(inline callee (TRY gpv ELSE Done x) s) \\<and>\n                                     gpv'__ =\n                                     TRY map_gpv f id\n    (inline callee gpv s) ELSE Done z \\<and>\n                                     \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                                     pfinite_gpv \\<I> gpv \\<and> I s)\n                              fa g)", "apply(rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gpv''' B fa.\n                         TRY map_gpv Some id\n                              (rpv input) ELSE Done None \\<bind>\n                         map_gpv f id \\<circ>\n                         case_option Fail\n                          (\\<lambda>(xa, y).\n                              inline callee (TRY rpv' xa ELSE Done x) y) =\n                         ?gpv'' \\<bind> fa \\<and>\n                         (\\<exists>g.\n                             TRY map_gpv Some id\n                                  (rpv input) ELSE Done None \\<bind>\n                             case_option (Done z)\n                              (\\<lambda>x'.\n                                  TRY (map_gpv f id \\<circ>\n (\\<lambda>(x, y). inline callee (rpv' x) y))\n x' ELSE Done z) =\n                             gpv''' \\<bind> g \\<and>\n                             eq_\\<I>_gpv B \\<I>' ?gpv'' gpv''' \\<and>\n                             rel_fun B\n                              (\\<lambda>gpva__ gpv'__.\n                                  \\<exists>gpv s.\n                                     gpva__ =\n                                     map_gpv f id\n(inline callee (TRY gpv ELSE Done x) s) \\<and>\n                                     gpv'__ =\n                                     TRY map_gpv f id\n    (inline callee gpv s) ELSE Done z \\<and>\n                                     \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                                     pfinite_gpv \\<I> gpv \\<and> I s)\n                              fa g)", "apply(rule exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out\\<rbrakk>\n    \\<Longrightarrow> \\<exists>B fa.\n                         TRY map_gpv Some id\n                              (rpv input) ELSE Done None \\<bind>\n                         map_gpv f id \\<circ>\n                         case_option Fail\n                          (\\<lambda>(xa, y).\n                              inline callee (TRY rpv' xa ELSE Done x) y) =\n                         ?gpv'' \\<bind> fa \\<and>\n                         (\\<exists>g.\n                             TRY map_gpv Some id\n                                  (rpv input) ELSE Done None \\<bind>\n                             case_option (Done z)\n                              (\\<lambda>x'.\n                                  TRY (map_gpv f id \\<circ>\n (\\<lambda>(x, y). inline callee (rpv' x) y))\n x' ELSE Done z) =\n                             ?gpv'''2 \\<bind> g \\<and>\n                             eq_\\<I>_gpv B \\<I>' ?gpv'' ?gpv'''2 \\<and>\n                             rel_fun B\n                              (\\<lambda>gpva__ gpv'__.\n                                  \\<exists>gpv s.\n                                     gpva__ =\n                                     map_gpv f id\n(inline callee (TRY gpv ELSE Done x) s) \\<and>\n                                     gpv'__ =\n                                     TRY map_gpv f id\n    (inline callee gpv s) ELSE Done z \\<and>\n                                     \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                                     pfinite_gpv \\<I> gpv \\<and> I s)\n                              fa g)", "apply(rule exI[where x=\"\\<lambda>x y. x = y \\<and> y \\<in> results_gpv \\<I>' (TRY map_gpv Some id (rpv input) ELSE Done None)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out\\<rbrakk>\n    \\<Longrightarrow> \\<exists>fa.\n                         TRY map_gpv Some id\n                              (rpv input) ELSE Done None \\<bind>\n                         map_gpv f id \\<circ>\n                         case_option Fail\n                          (\\<lambda>(xa, y).\n                              inline callee (TRY rpv' xa ELSE Done x) y) =\n                         ?gpv'' \\<bind> fa \\<and>\n                         (\\<exists>g.\n                             TRY map_gpv Some id\n                                  (rpv input) ELSE Done None \\<bind>\n                             case_option (Done z)\n                              (\\<lambda>x'.\n                                  TRY (map_gpv f id \\<circ>\n (\\<lambda>(x, y). inline callee (rpv' x) y))\n x' ELSE Done z) =\n                             ?gpv'''2 \\<bind> g \\<and>\n                             eq_\\<I>_gpv\n                              (\\<lambda>B y.\n                                  B = y \\<and>\n                                  y \\<in> results_gpv \\<I>'\n     (TRY map_gpv Some id (rpv input) ELSE Done None))\n                              \\<I>' ?gpv'' ?gpv'''2 \\<and>\n                             rel_fun\n                              (\\<lambda>B y.\n                                  B = y \\<and>\n                                  y \\<in> results_gpv \\<I>'\n     (TRY map_gpv Some id (rpv input) ELSE Done None))\n                              (\\<lambda>gpva__ gpv'__.\n                                  \\<exists>gpv s.\n                                     gpva__ =\n                                     map_gpv f id\n(inline callee (TRY gpv ELSE Done x) s) \\<and>\n                                     gpv'__ =\n                                     TRY map_gpv f id\n    (inline callee gpv s) ELSE Done z \\<and>\n                                     \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                                     pfinite_gpv \\<I> gpv \\<and> I s)\n                              fa g)", "apply(rule exI conjI refl)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (\\<lambda>B y.\n                           B = y \\<and>\n                           y \\<in> results_gpv \\<I>'\n                                    (TRY map_gpv Some id\n    (rpv input) ELSE Done None))\n                       \\<I>'\n                       (TRY map_gpv Some id (rpv input) ELSE Done None)\n                       (TRY map_gpv Some id (rpv input) ELSE Done None)\n 2. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out\\<rbrakk>\n    \\<Longrightarrow> rel_fun\n                       (\\<lambda>B y.\n                           B = y \\<and>\n                           y \\<in> results_gpv \\<I>'\n                                    (TRY map_gpv Some id\n    (rpv input) ELSE Done None))\n                       (\\<lambda>gpva__ gpv'__.\n                           \\<exists>gpv s.\n                              gpva__ =\n                              map_gpv f id\n                               (inline callee (TRY gpv ELSE Done x)\n                                 s) \\<and>\n                              gpv'__ =\n                              TRY map_gpv f id\n                                   (inline callee gpv s) ELSE Done z \\<and>\n                              \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                              pfinite_gpv \\<I> gpv \\<and> I s)\n                       (map_gpv f id \\<circ>\n                        case_option Fail\n                         (\\<lambda>(xa, y).\n                             inline callee (TRY rpv' xa ELSE Done x) y))\n                       (case_option (Done z)\n                         (\\<lambda>x'.\n                             TRY (map_gpv f id \\<circ>\n                                  (\\<lambda>(x, y).\ninline callee (rpv' x) y))\n                                  x' ELSE Done z))", "apply(rule eq_\\<I>_gpv_reflI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n        xa_ = Some (Inr (out, rpv, rpv'));\n        input \\<in> responses_\\<I> \\<I>' out;\n        x \\<in> results_gpv \\<I>'\n                 (TRY map_gpv Some id (rpv input) ELSE Done None)\\<rbrakk>\n       \\<Longrightarrow> x = x \\<and>\n                         x \\<in> results_gpv \\<I>'\n                                  (TRY map_gpv Some id\n  (rpv input) ELSE Done None)\n 2. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out\\<rbrakk>\n    \\<Longrightarrow> \\<I>'\n                      \\<turnstile>g TRY map_gpv Some id\n   (rpv input) ELSE Done None \\<surd>\n 3. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out\\<rbrakk>\n    \\<Longrightarrow> rel_fun\n                       (\\<lambda>B y.\n                           B = y \\<and>\n                           y \\<in> results_gpv \\<I>'\n                                    (TRY map_gpv Some id\n    (rpv input) ELSE Done None))\n                       (\\<lambda>gpva__ gpv'__.\n                           \\<exists>gpv s.\n                              gpva__ =\n                              map_gpv f id\n                               (inline callee (TRY gpv ELSE Done x)\n                                 s) \\<and>\n                              gpv'__ =\n                              TRY map_gpv f id\n                                   (inline callee gpv s) ELSE Done z \\<and>\n                              \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                              pfinite_gpv \\<I> gpv \\<and> I s)\n                       (map_gpv f id \\<circ>\n                        case_option Fail\n                         (\\<lambda>(xa, y).\n                             inline callee (TRY rpv' xa ELSE Done x) y))\n                       (case_option (Done z)\n                         (\\<lambda>x'.\n                             TRY (map_gpv f id \\<circ>\n                                  (\\<lambda>(x, y).\ninline callee (rpv' x) y))\n                                  x' ELSE Done z))", "apply(simp add: eq_onp_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out\\<rbrakk>\n    \\<Longrightarrow> \\<I>'\n                      \\<turnstile>g TRY map_gpv Some id\n   (rpv input) ELSE Done None \\<surd>\n 2. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out\\<rbrakk>\n    \\<Longrightarrow> rel_fun\n                       (\\<lambda>B y.\n                           B = y \\<and>\n                           y \\<in> results_gpv \\<I>'\n                                    (TRY map_gpv Some id\n    (rpv input) ELSE Done None))\n                       (\\<lambda>gpva__ gpv'__.\n                           \\<exists>gpv s.\n                              gpva__ =\n                              map_gpv f id\n                               (inline callee (TRY gpv ELSE Done x)\n                                 s) \\<and>\n                              gpv'__ =\n                              TRY map_gpv f id\n                                   (inline callee gpv s) ELSE Done z \\<and>\n                              \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                              pfinite_gpv \\<I> gpv \\<and> I s)\n                       (map_gpv f id \\<circ>\n                        case_option Fail\n                         (\\<lambda>(xa, y).\n                             inline callee (TRY rpv' xa ELSE Done x) y))\n                       (case_option (Done z)\n                         (\\<lambda>x'.\n                             TRY (map_gpv f id \\<circ>\n                                  (\\<lambda>(x, y).\ninline callee (rpv' x) y))\n                                  x' ELSE Done z))", "apply(rule WT_intro)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out\\<rbrakk>\n    \\<Longrightarrow> \\<I>'\n                      \\<turnstile>g map_gpv Some id (rpv input) \\<surd>\n 2. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out;\n     \\<not> colossless_gpv \\<I>' (map_gpv Some id (rpv input))\\<rbrakk>\n    \\<Longrightarrow> \\<I>' \\<turnstile>g Done None \\<surd>\n 3. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out\\<rbrakk>\n    \\<Longrightarrow> rel_fun\n                       (\\<lambda>B y.\n                           B = y \\<and>\n                           y \\<in> results_gpv \\<I>'\n                                    (TRY map_gpv Some id\n    (rpv input) ELSE Done None))\n                       (\\<lambda>gpva__ gpv'__.\n                           \\<exists>gpv s.\n                              gpva__ =\n                              map_gpv f id\n                               (inline callee (TRY gpv ELSE Done x)\n                                 s) \\<and>\n                              gpv'__ =\n                              TRY map_gpv f id\n                                   (inline callee gpv s) ELSE Done z \\<and>\n                              \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                              pfinite_gpv \\<I> gpv \\<and> I s)\n                       (map_gpv f id \\<circ>\n                        case_option Fail\n                         (\\<lambda>(xa, y).\n                             inline callee (TRY rpv' xa ELSE Done x) y))\n                       (case_option (Done z)\n                         (\\<lambda>x'.\n                             TRY (map_gpv f id \\<circ>\n                                  (\\<lambda>(x, y).\ninline callee (rpv' x) y))\n                                  x' ELSE Done z))", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out\\<rbrakk>\n    \\<Longrightarrow> \\<I>' \\<turnstile>g rpv input \\<surd>\n 2. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out;\n     \\<not> colossless_gpv \\<I>' (map_gpv Some id (rpv input))\\<rbrakk>\n    \\<Longrightarrow> \\<I>' \\<turnstile>g Done None \\<surd>\n 3. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out\\<rbrakk>\n    \\<Longrightarrow> rel_fun\n                       (\\<lambda>B y.\n                           B = y \\<and>\n                           y \\<in> results_gpv \\<I>'\n                                    (TRY map_gpv Some id\n    (rpv input) ELSE Done None))\n                       (\\<lambda>gpva__ gpv'__.\n                           \\<exists>gpv s.\n                              gpva__ =\n                              map_gpv f id\n                               (inline callee (TRY gpv ELSE Done x)\n                                 s) \\<and>\n                              gpv'__ =\n                              TRY map_gpv f id\n                                   (inline callee gpv s) ELSE Done z \\<and>\n                              \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                              pfinite_gpv \\<I> gpv \\<and> I s)\n                       (map_gpv f id \\<circ>\n                        case_option Fail\n                         (\\<lambda>(xa, y).\n                             inline callee (TRY rpv' xa ELSE Done x) y))\n                       (case_option (Done z)\n                         (\\<lambda>x'.\n                             TRY (map_gpv f id \\<circ>\n                                  (\\<lambda>(x, y).\ninline callee (rpv' x) y))\n                                  x' ELSE Done z))", "apply(erule (1) WT_gpv_inline1[OF _ eq_\\<I>_gpv(1,3)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out;\n     \\<not> colossless_gpv \\<I>' (map_gpv Some id (rpv input))\\<rbrakk>\n    \\<Longrightarrow> \\<I>' \\<turnstile>g Done None \\<surd>\n 2. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out\\<rbrakk>\n    \\<Longrightarrow> rel_fun\n                       (\\<lambda>B y.\n                           B = y \\<and>\n                           y \\<in> results_gpv \\<I>'\n                                    (TRY map_gpv Some id\n    (rpv input) ELSE Done None))\n                       (\\<lambda>gpva__ gpv'__.\n                           \\<exists>gpv s.\n                              gpva__ =\n                              map_gpv f id\n                               (inline callee (TRY gpv ELSE Done x)\n                                 s) \\<and>\n                              gpv'__ =\n                              TRY map_gpv f id\n                                   (inline callee gpv s) ELSE Done z \\<and>\n                              \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                              pfinite_gpv \\<I> gpv \\<and> I s)\n                       (map_gpv f id \\<circ>\n                        case_option Fail\n                         (\\<lambda>(xa, y).\n                             inline callee (TRY rpv' xa ELSE Done x) y))\n                       (case_option (Done z)\n                         (\\<lambda>x'.\n                             TRY (map_gpv f id \\<circ>\n                                  (\\<lambda>(x, y).\ninline callee (rpv' x) y))\n                                  x' ELSE Done z))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out\\<rbrakk>\n    \\<Longrightarrow> rel_fun\n                       (\\<lambda>B y.\n                           B = y \\<and>\n                           y \\<in> results_gpv \\<I>'\n                                    (TRY map_gpv Some id\n    (rpv input) ELSE Done None))\n                       (\\<lambda>gpva__ gpv'__.\n                           \\<exists>gpv s.\n                              gpva__ =\n                              map_gpv f id\n                               (inline callee (TRY gpv ELSE Done x)\n                                 s) \\<and>\n                              gpv'__ =\n                              TRY map_gpv f id\n                                   (inline callee gpv s) ELSE Done z \\<and>\n                              \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                              pfinite_gpv \\<I> gpv \\<and> I s)\n                       (map_gpv f id \\<circ>\n                        case_option Fail\n                         (\\<lambda>(xa, y).\n                             inline callee (TRY rpv' xa ELSE Done x) y))\n                       (case_option (Done z)\n                         (\\<lambda>x'.\n                             TRY (map_gpv f id \\<circ>\n                                  (\\<lambda>(x, y).\ninline callee (rpv' x) y))\n                                  x' ELSE Done z))", "apply(rule rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xaa y.\n       \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n        xa_ = Some (Inr (out, rpv, rpv'));\n        input \\<in> responses_\\<I> \\<I>' out;\n        xaa = y \\<and>\n        y \\<in> results_gpv \\<I>'\n                 (TRY map_gpv Some id (rpv input) ELSE Done None)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gpv s.\n                            (map_gpv f id \\<circ>\n                             case_option Fail\n                              (\\<lambda>(xa, y).\n                                  inline callee (TRY rpv' xa ELSE Done x)\n                                   y))\n                             xaa =\n                            map_gpv f id\n                             (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                            (case y of None \\<Rightarrow> Done z\n                             | Some x' \\<Rightarrow>\n                                 TRY (map_gpv f id \\<circ>\n(\\<lambda>(x, y). inline callee (rpv' x) y))\nx' ELSE Done z) =\n                            TRY map_gpv f id\n                                 (inline callee gpv s) ELSE Done z \\<and>\n                            \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                            pfinite_gpv \\<I> gpv \\<and> I s", "apply(clarsimp simp add: eq_onp_def split: if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n        xa_ = Some (Inr (out, rpv, rpv'));\n        input \\<in> responses_\\<I> \\<I>' out;\n        colossless_gpv \\<I>' (rpv input);\n        (a, b) \\<in> results_gpv \\<I>' (rpv input)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gpv s.\n                            map_gpv f id\n                             (inline callee (TRY rpv' a ELSE Done x) b) =\n                            map_gpv f id\n                             (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                            TRY map_gpv f id\n                                 (inline callee (rpv' a) b) ELSE Done z =\n                            TRY map_gpv f id\n                                 (inline callee gpv s) ELSE Done z \\<and>\n                            \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                            pfinite_gpv \\<I> gpv \\<and> I s\n 2. \\<And>xaa.\n       \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n        xa_ = Some (Inr (out, rpv, rpv'));\n        input \\<in> responses_\\<I> \\<I>' out;\n        \\<not> colossless_gpv \\<I>' (rpv input);\n        xaa \\<in> Some ` results_gpv \\<I>' (rpv input) \\<or>\n        xaa = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gpv s.\n                            map_gpv f id\n                             (case xaa of None \\<Rightarrow> Fail\n                              | Some (xb, xc) \\<Rightarrow>\n                                  inline callee (TRY rpv' xb ELSE Done x)\n                                   xc) =\n                            map_gpv f id\n                             (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                            (case xaa of None \\<Rightarrow> Done z\n                             | Some x' \\<Rightarrow>\n                                 TRY (map_gpv f id \\<circ>\n(\\<lambda>(x, y). inline callee (rpv' x) y))\nx' ELSE Done z) =\n                            TRY map_gpv f id\n                                 (inline callee gpv s) ELSE Done z \\<and>\n                            \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                            pfinite_gpv \\<I> gpv \\<and> I s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out; colossless_gpv \\<I>' (rpv input);\n     (a_, b_) \\<in> results_gpv \\<I>' (rpv input)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gpv s.\n                         map_gpv f id\n                          (inline callee (TRY rpv' a_ ELSE Done x) b_) =\n                         map_gpv f id\n                          (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                         TRY map_gpv f id\n                              (inline callee (rpv' a_) b_) ELSE Done z =\n                         TRY map_gpv f id\n                              (inline callee gpv s) ELSE Done z \\<and>\n                         \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                         pfinite_gpv \\<I> gpv \\<and> I s", "apply(rule exI conjI refl)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out; colossless_gpv \\<I>' (rpv input);\n     (a_, b_) \\<in> results_gpv \\<I>' (rpv input)\\<rbrakk>\n    \\<Longrightarrow> \\<I> \\<turnstile>g rpv' a_ \\<surd>\n 2. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out; colossless_gpv \\<I>' (rpv input);\n     (a_, b_) \\<in> results_gpv \\<I>' (rpv input)\\<rbrakk>\n    \\<Longrightarrow> pfinite_gpv \\<I> (rpv' a_) \\<and> I b_", "apply(drule (2) WT_gpv_inline1(3)[OF _ eq_\\<I>_gpv(1,3)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out; colossless_gpv \\<I>' (rpv input);\n     (a_, b_) \\<in> results_gpv \\<I>' (rpv input);\n     \\<I> \\<turnstile>g rpv' a_ \\<surd> \\<and> I b_\\<rbrakk>\n    \\<Longrightarrow> \\<I> \\<turnstile>g rpv' a_ \\<surd>\n 2. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out; colossless_gpv \\<I>' (rpv input);\n     (a_, b_) \\<in> results_gpv \\<I>' (rpv input)\\<rbrakk>\n    \\<Longrightarrow> pfinite_gpv \\<I> (rpv' a_) \\<and> I b_", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out; colossless_gpv \\<I>' (rpv input);\n     (a_, b_) \\<in> results_gpv \\<I>' (rpv input)\\<rbrakk>\n    \\<Longrightarrow> pfinite_gpv \\<I> (rpv' a_) \\<and> I b_", "apply(frule (2) WT_gpv_inline1(3)[OF _ eq_\\<I>_gpv(1,3)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out; colossless_gpv \\<I>' (rpv input);\n     (a_, b_) \\<in> results_gpv \\<I>' (rpv input);\n     \\<I> \\<turnstile>g rpv' a_ \\<surd> \\<and> I b_\\<rbrakk>\n    \\<Longrightarrow> pfinite_gpv \\<I> (rpv' a_) \\<and> I b_", "apply(drule (2) inline1_in_sub_gpvs[OF _ _ _ eq_\\<I>_gpv(1,3)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out; colossless_gpv \\<I>' (rpv input);\n     (a_, b_) \\<in> results_gpv \\<I>' (rpv input);\n     \\<I> \\<turnstile>g rpv' a_ \\<surd> \\<and> I b_;\n     rpv' a_ \\<in> sub_gpvs \\<I> gpv \\<and> I b_\\<rbrakk>\n    \\<Longrightarrow> pfinite_gpv \\<I> (rpv' a_) \\<and> I b_", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out; colossless_gpv \\<I>' (rpv input);\n     (a_, b_) \\<in> results_gpv \\<I>' (rpv input);\n     \\<I> \\<turnstile>g rpv' a_ \\<surd>; rpv' a_ \\<in> sub_gpvs \\<I> gpv;\n     I b_\\<rbrakk>\n    \\<Longrightarrow> pfinite_gpv \\<I> (rpv' a_)", "apply(erule pfinite_gpv_sub_gpvs[OF eq_\\<I>_gpv(2) _ eq_\\<I>_gpv(1)])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xaa.\n       \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n        xa_ = Some (Inr (out, rpv, rpv'));\n        input \\<in> responses_\\<I> \\<I>' out;\n        \\<not> colossless_gpv \\<I>' (rpv input);\n        xaa \\<in> Some ` results_gpv \\<I>' (rpv input) \\<or>\n        xaa = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gpv s.\n                            map_gpv f id\n                             (case xaa of None \\<Rightarrow> Fail\n                              | Some (xb, xc) \\<Rightarrow>\n                                  inline callee (TRY rpv' xb ELSE Done x)\n                                   xc) =\n                            map_gpv f id\n                             (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                            (case xaa of None \\<Rightarrow> Done z\n                             | Some x' \\<Rightarrow>\n                                 TRY (map_gpv f id \\<circ>\n(\\<lambda>(x, y). inline callee (rpv' x) y))\nx' ELSE Done z) =\n                            TRY map_gpv f id\n                                 (inline callee gpv s) ELSE Done z \\<and>\n                            \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                            pfinite_gpv \\<I> gpv \\<and> I s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out;\n     \\<not> colossless_gpv \\<I>' (rpv input);\n     xb_ \\<in> Some ` results_gpv \\<I>' (rpv input) \\<or>\n     xb_ = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gpv s.\n                         map_gpv f id\n                          (case xb_ of None \\<Rightarrow> Fail\n                           | Some (xb, xc) \\<Rightarrow>\n                               inline callee (TRY rpv' xb ELSE Done x) xc) =\n                         map_gpv f id\n                          (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                         (case xb_ of None \\<Rightarrow> Done z\n                          | Some x' \\<Rightarrow>\n                              TRY (map_gpv f id \\<circ>\n                                   (\\<lambda>(x, y).\n inline callee (rpv' x) y))\n                                   x' ELSE Done z) =\n                         TRY map_gpv f id\n                              (inline callee gpv s) ELSE Done z \\<and>\n                         \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                         pfinite_gpv \\<I> gpv \\<and> I s", "apply(erule disjE; clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n        xa_ = Some (Inr (out, rpv, rpv'));\n        input \\<in> responses_\\<I> \\<I>' out;\n        \\<not> colossless_gpv \\<I>' (rpv input);\n        (a, b) \\<in> results_gpv \\<I>' (rpv input);\n        xb_ = Some (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gpv s.\n                            map_gpv f id\n                             (inline callee (TRY rpv' a ELSE Done x) b) =\n                            map_gpv f id\n                             (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                            TRY map_gpv f id\n                                 (inline callee (rpv' a) b) ELSE Done z =\n                            TRY map_gpv f id\n                                 (inline callee gpv s) ELSE Done z \\<and>\n                            \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                            pfinite_gpv \\<I> gpv \\<and> I s\n 2. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out;\n     \\<not> colossless_gpv \\<I>' (rpv input); xb_ = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gpv s.\n                         Fail =\n                         map_gpv f id\n                          (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                         Done z =\n                         TRY map_gpv f id\n                              (inline callee gpv s) ELSE Done z \\<and>\n                         \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                         pfinite_gpv \\<I> gpv \\<and> I s", "apply(rule exI conjI refl)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n        xa_ = Some (Inr (out, rpv, rpv'));\n        input \\<in> responses_\\<I> \\<I>' out;\n        \\<not> colossless_gpv \\<I>' (rpv input);\n        (a, b) \\<in> results_gpv \\<I>' (rpv input);\n        xb_ = Some (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<I> \\<turnstile>g rpv' a \\<surd>\n 2. \\<And>a b.\n       \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n        xa_ = Some (Inr (out, rpv, rpv'));\n        input \\<in> responses_\\<I> \\<I>' out;\n        \\<not> colossless_gpv \\<I>' (rpv input);\n        (a, b) \\<in> results_gpv \\<I>' (rpv input);\n        xb_ = Some (a, b)\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv \\<I> (rpv' a) \\<and> I b\n 3. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out;\n     \\<not> colossless_gpv \\<I>' (rpv input); xb_ = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gpv s.\n                         Fail =\n                         map_gpv f id\n                          (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                         Done z =\n                         TRY map_gpv f id\n                              (inline callee gpv s) ELSE Done z \\<and>\n                         \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                         pfinite_gpv \\<I> gpv \\<and> I s", "apply(drule (2) WT_gpv_inline1(3)[OF _ eq_\\<I>_gpv(1,3)])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>xa_ = Some (Inr (out, rpv, rpv'));\n        input \\<in> responses_\\<I> \\<I>' out;\n        \\<not> colossless_gpv \\<I>' (rpv input);\n        (a, b) \\<in> results_gpv \\<I>' (rpv input); xb_ = Some (a, b);\n        \\<I> \\<turnstile>g rpv' a \\<surd> \\<and> I b\\<rbrakk>\n       \\<Longrightarrow> \\<I> \\<turnstile>g rpv' a \\<surd>\n 2. \\<And>a b.\n       \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n        xa_ = Some (Inr (out, rpv, rpv'));\n        input \\<in> responses_\\<I> \\<I>' out;\n        \\<not> colossless_gpv \\<I>' (rpv input);\n        (a, b) \\<in> results_gpv \\<I>' (rpv input);\n        xb_ = Some (a, b)\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv \\<I> (rpv' a) \\<and> I b\n 3. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out;\n     \\<not> colossless_gpv \\<I>' (rpv input); xb_ = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gpv s.\n                         Fail =\n                         map_gpv f id\n                          (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                         Done z =\n                         TRY map_gpv f id\n                              (inline callee gpv s) ELSE Done z \\<and>\n                         \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                         pfinite_gpv \\<I> gpv \\<and> I s", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n        xa_ = Some (Inr (out, rpv, rpv'));\n        input \\<in> responses_\\<I> \\<I>' out;\n        \\<not> colossless_gpv \\<I>' (rpv input);\n        (a, b) \\<in> results_gpv \\<I>' (rpv input);\n        xb_ = Some (a, b)\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv \\<I> (rpv' a) \\<and> I b\n 2. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out;\n     \\<not> colossless_gpv \\<I>' (rpv input); xb_ = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gpv s.\n                         Fail =\n                         map_gpv f id\n                          (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                         Done z =\n                         TRY map_gpv f id\n                              (inline callee gpv s) ELSE Done z \\<and>\n                         \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                         pfinite_gpv \\<I> gpv \\<and> I s", "apply(frule (2) WT_gpv_inline1(3)[OF _ eq_\\<I>_gpv(1,3)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n        xa_ = Some (Inr (out, rpv, rpv'));\n        input \\<in> responses_\\<I> \\<I>' out;\n        \\<not> colossless_gpv \\<I>' (rpv input);\n        (a, b) \\<in> results_gpv \\<I>' (rpv input); xb_ = Some (a, b);\n        \\<I> \\<turnstile>g rpv' a \\<surd> \\<and> I b\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv \\<I> (rpv' a) \\<and> I b\n 2. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out;\n     \\<not> colossless_gpv \\<I>' (rpv input); xb_ = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gpv s.\n                         Fail =\n                         map_gpv f id\n                          (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                         Done z =\n                         TRY map_gpv f id\n                              (inline callee gpv s) ELSE Done z \\<and>\n                         \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                         pfinite_gpv \\<I> gpv \\<and> I s", "apply(drule (2) inline1_in_sub_gpvs[OF _ _ _ eq_\\<I>_gpv(1,3)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>xa_ = Some (Inr (out, rpv, rpv'));\n        input \\<in> responses_\\<I> \\<I>' out;\n        \\<not> colossless_gpv \\<I>' (rpv input);\n        (a, b) \\<in> results_gpv \\<I>' (rpv input); xb_ = Some (a, b);\n        \\<I> \\<turnstile>g rpv' a \\<surd> \\<and> I b;\n        rpv' a \\<in> sub_gpvs \\<I> gpv \\<and> I b\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv \\<I> (rpv' a) \\<and> I b\n 2. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out;\n     \\<not> colossless_gpv \\<I>' (rpv input); xb_ = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gpv s.\n                         Fail =\n                         map_gpv f id\n                          (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                         Done z =\n                         TRY map_gpv f id\n                              (inline callee gpv s) ELSE Done z \\<and>\n                         \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                         pfinite_gpv \\<I> gpv \\<and> I s", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>xa_ = Some (Inr (out, rpv, rpv'));\n        input \\<in> responses_\\<I> \\<I>' out;\n        \\<not> colossless_gpv \\<I>' (rpv input);\n        (a, b) \\<in> results_gpv \\<I>' (rpv input); xb_ = Some (a, b);\n        \\<I> \\<turnstile>g rpv' a \\<surd>; rpv' a \\<in> sub_gpvs \\<I> gpv;\n        I b\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv \\<I> (rpv' a)\n 2. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out;\n     \\<not> colossless_gpv \\<I>' (rpv input); xb_ = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gpv s.\n                         Fail =\n                         map_gpv f id\n                          (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                         Done z =\n                         TRY map_gpv f id\n                              (inline callee gpv s) ELSE Done z \\<and>\n                         \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                         pfinite_gpv \\<I> gpv \\<and> I s", "apply(erule pfinite_gpv_sub_gpvs[OF eq_\\<I>_gpv(2) _ eq_\\<I>_gpv(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out;\n     \\<not> colossless_gpv \\<I>' (rpv input); xb_ = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gpv s.\n                         Fail =\n                         map_gpv f id\n                          (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                         Done z =\n                         TRY map_gpv f id\n                              (inline callee gpv s) ELSE Done z \\<and>\n                         \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                         pfinite_gpv \\<I> gpv \\<and> I s", "apply(erule notE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Inr (out, rpv, rpv') \\<in> set_spmf (inline1 callee gpv s);\n     xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out; xb_ = None\\<rbrakk>\n    \\<Longrightarrow> colossless_gpv \\<I>' (rpv input)", "apply(drule inline1_in_sub_gpvs_callee[OF _ eq_\\<I>_gpv(1,3)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xa_ = Some (Inr (out, rpv, rpv'));\n     input \\<in> responses_\\<I> \\<I>' out; xb_ = None;\n     \\<exists>call\\<in>outs_\\<I> \\<I>.\n        \\<exists>s.\n           I s \\<and>\n           (\\<forall>x\\<in>responses_\\<I> \\<I>' out.\n               rpv x \\<in> sub_gpvs \\<I>' (callee s call))\\<rbrakk>\n    \\<Longrightarrow> colossless_gpv \\<I>' (rpv input)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>call s.\n       \\<lbrakk>xa_ = Some (Inr (out, rpv, rpv'));\n        input \\<in> responses_\\<I> \\<I>' out; xb_ = None;\n        call \\<in> outs_\\<I> \\<I>; I s;\n        \\<forall>x\\<in>responses_\\<I> \\<I>' out.\n           rpv x \\<in> sub_gpvs \\<I>' (callee s call)\\<rbrakk>\n       \\<Longrightarrow> colossless_gpv \\<I>' (rpv input)", "apply(drule (1) bspec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>call s.\n       \\<lbrakk>xa_ = Some (Inr (out, rpv, rpv'));\n        input \\<in> responses_\\<I> \\<I>' out; xb_ = None;\n        call \\<in> outs_\\<I> \\<I>; I s;\n        rpv input \\<in> sub_gpvs \\<I>' (callee s call)\\<rbrakk>\n       \\<Longrightarrow> colossless_gpv \\<I>' (rpv input)", "apply(erule colossless_gpv_sub_gpvs[rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>call s.\n       \\<lbrakk>xa_ = Some (Inr (out, rpv, rpv'));\n        input \\<in> responses_\\<I> \\<I>' out; xb_ = None;\n        call \\<in> outs_\\<I> \\<I>; I s\\<rbrakk>\n       \\<Longrightarrow> colossless_gpv \\<I>' (callee s call)", "apply(rule lossless; simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> (if lossless_spmf (inline1 callee gpv s) then {}\n                 else set_spmf (return_spmf None)) \\<Longrightarrow>\n       eq_\\<I>_generat (=) \\<I>'\n        (\\<lambda>gpv gpv'.\n            (\\<exists>gpva s.\n                gpv =\n                map_gpv f id (inline callee (TRY gpva ELSE Done x) s) \\<and>\n                gpv' =\n                TRY map_gpv f id (inline callee gpva s) ELSE Done z \\<and>\n                \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n                pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n            eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n            (\\<exists>gpv'' gpv''' B fa.\n                gpv = gpv'' \\<bind> fa \\<and>\n                (\\<exists>g.\n                    gpv' = gpv''' \\<bind> g \\<and>\n                    eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n                    rel_fun B\n                     (\\<lambda>gpva__ gpv'__.\n                         \\<exists>gpv s.\n                            gpva__ =\n                            map_gpv f id\n                             (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                            gpv'__ =\n                            TRY map_gpv f id\n                                 (inline callee gpv s) ELSE Done z \\<and>\n                            \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                            pfinite_gpv \\<I> gpv \\<and> I s)\n                     fa g)))\n        (case case xa of None \\<Rightarrow> Inl z\n              | Some xa \\<Rightarrow>\n                  map_sum f\n                   (\\<lambda>(out, c, rpv).\n                       (out, c, \\<lambda>input. TRY rpv input ELSE Done x))\n                   xa of\n         Inl x \\<Rightarrow> Pure x\n         | Inr (out, oracle, rpv) \\<Rightarrow>\n             IO out\n              (\\<lambda>input.\n                  map_gpv f id\n                   (TRY map_gpv Some id\n                         (oracle input) ELSE Done None \\<bind>\n                    case_option Fail\n                     (\\<lambda>(x, y). inline callee (rpv x) y))))\n        (case xa of None \\<Rightarrow> Pure z\n         | Some (Inl xa) \\<Rightarrow> Pure (f xa)\n         | Some (Inr (out, oracle, rpv)) \\<Rightarrow>\n             IO out\n              (\\<lambda>input.\n                  TRY map_gpv f id\n                       (oracle input \\<bind>\n                        (\\<lambda>(x, y).\n                            inline callee (rpv x) y)) ELSE Done z))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. xa_\n    \\<in> (if lossless_spmf (inline1 callee gpv s) then {}\n           else set_spmf (return_spmf None)) \\<Longrightarrow>\n    eq_\\<I>_generat (=) \\<I>'\n     (\\<lambda>gpv gpv'.\n         (\\<exists>gpva s.\n             gpv =\n             map_gpv f id (inline callee (TRY gpva ELSE Done x) s) \\<and>\n             gpv' =\n             TRY map_gpv f id (inline callee gpva s) ELSE Done z \\<and>\n             \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n             pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n         eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n         (\\<exists>gpv'' gpv''' B fa.\n             gpv = gpv'' \\<bind> fa \\<and>\n             (\\<exists>g.\n                 gpv' = gpv''' \\<bind> g \\<and>\n                 eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n                 rel_fun B\n                  (\\<lambda>gpva__ gpv'__.\n                      \\<exists>gpv s.\n                         gpva__ =\n                         map_gpv f id\n                          (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                         gpv'__ =\n                         TRY map_gpv f id\n                              (inline callee gpv s) ELSE Done z \\<and>\n                         \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                         pfinite_gpv \\<I> gpv \\<and> I s)\n                  fa g)))\n     (case case xa_ of None \\<Rightarrow> Inl z\n           | Some xa \\<Rightarrow>\n               map_sum f\n                (\\<lambda>(out, c, rpv).\n                    (out, c, \\<lambda>input. TRY rpv input ELSE Done x))\n                xa of\n      Inl x \\<Rightarrow> Pure x\n      | Inr (out, oracle, rpv) \\<Rightarrow>\n          IO out\n           (\\<lambda>input.\n               map_gpv f id\n                (TRY map_gpv Some id (oracle input) ELSE Done None \\<bind>\n                 case_option Fail\n                  (\\<lambda>(x, y). inline callee (rpv x) y))))\n     (case xa_ of None \\<Rightarrow> Pure z\n      | Some (Inl xa) \\<Rightarrow> Pure (f xa)\n      | Some (Inr (out, oracle, rpv)) \\<Rightarrow>\n          IO out\n           (\\<lambda>input.\n               TRY map_gpv f id\n                    (oracle input \\<bind>\n                     (\\<lambda>(x, y).\n                         inline callee (rpv x) y)) ELSE Done z))", "by(clarsimp split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_spmf\n   (eq_\\<I>_generat (=) \\<I>'\n     (\\<lambda>gpv gpv'.\n         (\\<exists>gpva s.\n             gpv =\n             map_gpv f id (inline callee (TRY gpva ELSE Done x) s) \\<and>\n             gpv' =\n             TRY map_gpv f id (inline callee gpva s) ELSE Done z \\<and>\n             \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n             pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n         eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n         (\\<exists>gpv'' gpv''' B fa g.\n             gpv = gpv'' \\<bind> fa \\<and>\n             gpv' = gpv''' \\<bind> g \\<and>\n             eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n             rel_fun B\n              (\\<lambda>gpva__ gpv'__.\n                  \\<exists>gpv s.\n                     gpva__ =\n                     map_gpv f id\n                      (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                     gpv'__ =\n                     TRY map_gpv f id\n                          (inline callee gpv s) ELSE Done z \\<and>\n                     \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                     pfinite_gpv \\<I> gpv \\<and> I s)\n              fa g)))\n   (map_spmf\n     (\\<lambda>x.\n         case x of Inl rs \\<Rightarrow> Pure rs\n         | Inr (out, oracle, rpv) \\<Rightarrow>\n             IO out\n              (\\<lambda>input.\n                  map_gpv f id\n                   (TRY map_gpv Some id\n                         (oracle input) ELSE Done None \\<bind>\n                    (\\<lambda>xy.\n                        case xy of None \\<Rightarrow> Fail\n                        | Some (x, y) \\<Rightarrow>\n                            inline callee (rpv x) y))))\n     (map_spmf\n       (\\<lambda>y.\n           case y of None \\<Rightarrow> Inl z\n           | Some x' \\<Rightarrow>\n               map_sum f\n                (\\<lambda>(out, c, rpv).\n                    (out, c, \\<lambda>input. TRY rpv input ELSE Done x))\n                x')\n       (TRY map_spmf Some (inline1 callee gpv s) ELSE return_spmf None)))\n   (map_spmf\n     (\\<lambda>y.\n         case y of None \\<Rightarrow> Pure z\n         | Some (Inl x) \\<Rightarrow> Pure (f x)\n         | Some (Inr (out, oracle, rpv)) \\<Rightarrow>\n             IO out\n              (\\<lambda>input.\n                  TRY map_gpv f id\n                       (oracle input \\<bind>\n                        (\\<lambda>(x, y).\n                            inline callee (rpv x) y)) ELSE Done z))\n     (TRY map_spmf Some (inline1 callee gpv s) ELSE return_spmf None))\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (eq_\\<I>_generat (=) \\<I>'\n       (\\<lambda>gpv gpv'.\n           (\\<exists>gpva s.\n               gpv =\n               map_gpv f id (inline callee (TRY gpva ELSE Done x) s) \\<and>\n               gpv' =\n               TRY map_gpv f id (inline callee gpva s) ELSE Done z \\<and>\n               \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n               pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n           eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n           (\\<exists>gpv'' gpv''' B fa g.\n               gpv = gpv'' \\<bind> fa \\<and>\n               gpv' = gpv''' \\<bind> g \\<and>\n               eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n               rel_fun B\n                (\\<lambda>gpva__ gpv'__.\n                    \\<exists>gpv s.\n                       gpva__ =\n                       map_gpv f id\n                        (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                       gpv'__ =\n                       TRY map_gpv f id\n                            (inline callee gpv s) ELSE Done z \\<and>\n                       \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                       pfinite_gpv \\<I> gpv \\<and> I s)\n                fa g)))\n     (the_gpv (map_gpv f id (inline callee (TRY gpv ELSE Done x) s)))\n     (the_gpv (TRY map_gpv f id (inline callee gpv s) ELSE Done z))", "ultimately"], ["proof (chain)\npicking this:\n  the_gpv (map_gpv f id (inline callee (TRY gpv ELSE Done x) s)) =\n  map_spmf\n   (\\<lambda>x.\n       case x of Inl rs \\<Rightarrow> Pure rs\n       | Inr (out, oracle, rpv) \\<Rightarrow>\n           IO out\n            (\\<lambda>input.\n                map_gpv f id\n                 (TRY map_gpv Some id (oracle input) ELSE Done None \\<bind>\n                  (\\<lambda>xy.\n                      case xy of None \\<Rightarrow> Fail\n                      | Some (x, y) \\<Rightarrow>\n                          inline callee (rpv x) y))))\n   (map_spmf\n     (\\<lambda>y.\n         case y of None \\<Rightarrow> Inl z\n         | Some x' \\<Rightarrow>\n             map_sum f\n              (\\<lambda>(out, c, rpv).\n                  (out, c, \\<lambda>input. TRY rpv input ELSE Done x))\n              x')\n     (TRY map_spmf Some (inline1 callee gpv s) ELSE return_spmf None))\n  the_gpv (TRY map_gpv f id (inline callee gpv s) ELSE Done z) =\n  map_spmf\n   (\\<lambda>y.\n       case y of None \\<Rightarrow> Pure z\n       | Some (Inl x) \\<Rightarrow> Pure (f x)\n       | Some (Inr (out, oracle, rpv)) \\<Rightarrow>\n           IO out\n            (\\<lambda>input.\n                TRY map_gpv f id\n                     (oracle input \\<bind>\n                      (\\<lambda>(x, y).\n                          inline callee (rpv x) y)) ELSE Done z))\n   (TRY map_spmf Some (inline1 callee gpv s) ELSE return_spmf None)\n  rel_spmf\n   (eq_\\<I>_generat (=) \\<I>'\n     (\\<lambda>gpv gpv'.\n         (\\<exists>gpva s.\n             gpv =\n             map_gpv f id (inline callee (TRY gpva ELSE Done x) s) \\<and>\n             gpv' =\n             TRY map_gpv f id (inline callee gpva s) ELSE Done z \\<and>\n             \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n             pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n         eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n         (\\<exists>gpv'' gpv''' B fa g.\n             gpv = gpv'' \\<bind> fa \\<and>\n             gpv' = gpv''' \\<bind> g \\<and>\n             eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n             rel_fun B\n              (\\<lambda>gpva__ gpv'__.\n                  \\<exists>gpv s.\n                     gpva__ =\n                     map_gpv f id\n                      (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                     gpv'__ =\n                     TRY map_gpv f id\n                          (inline callee gpv s) ELSE Done z \\<and>\n                     \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                     pfinite_gpv \\<I> gpv \\<and> I s)\n              fa g)))\n   (map_spmf\n     (\\<lambda>x.\n         case x of Inl rs \\<Rightarrow> Pure rs\n         | Inr (out, oracle, rpv) \\<Rightarrow>\n             IO out\n              (\\<lambda>input.\n                  map_gpv f id\n                   (TRY map_gpv Some id\n                         (oracle input) ELSE Done None \\<bind>\n                    (\\<lambda>xy.\n                        case xy of None \\<Rightarrow> Fail\n                        | Some (x, y) \\<Rightarrow>\n                            inline callee (rpv x) y))))\n     (map_spmf\n       (\\<lambda>y.\n           case y of None \\<Rightarrow> Inl z\n           | Some x' \\<Rightarrow>\n               map_sum f\n                (\\<lambda>(out, c, rpv).\n                    (out, c, \\<lambda>input. TRY rpv input ELSE Done x))\n                x')\n       (TRY map_spmf Some (inline1 callee gpv s) ELSE return_spmf None)))\n   (map_spmf\n     (\\<lambda>y.\n         case y of None \\<Rightarrow> Pure z\n         | Some (Inl x) \\<Rightarrow> Pure (f x)\n         | Some (Inr (out, oracle, rpv)) \\<Rightarrow>\n             IO out\n              (\\<lambda>input.\n                  TRY map_gpv f id\n                       (oracle input \\<bind>\n                        (\\<lambda>(x, y).\n                            inline callee (rpv x) y)) ELSE Done z))\n     (TRY map_spmf Some (inline1 callee gpv s) ELSE return_spmf None))", "show ?thesis"], ["proof (prove)\nusing this:\n  the_gpv (map_gpv f id (inline callee (TRY gpv ELSE Done x) s)) =\n  map_spmf\n   (\\<lambda>x.\n       case x of Inl rs \\<Rightarrow> Pure rs\n       | Inr (out, oracle, rpv) \\<Rightarrow>\n           IO out\n            (\\<lambda>input.\n                map_gpv f id\n                 (TRY map_gpv Some id (oracle input) ELSE Done None \\<bind>\n                  (\\<lambda>xy.\n                      case xy of None \\<Rightarrow> Fail\n                      | Some (x, y) \\<Rightarrow>\n                          inline callee (rpv x) y))))\n   (map_spmf\n     (\\<lambda>y.\n         case y of None \\<Rightarrow> Inl z\n         | Some x' \\<Rightarrow>\n             map_sum f\n              (\\<lambda>(out, c, rpv).\n                  (out, c, \\<lambda>input. TRY rpv input ELSE Done x))\n              x')\n     (TRY map_spmf Some (inline1 callee gpv s) ELSE return_spmf None))\n  the_gpv (TRY map_gpv f id (inline callee gpv s) ELSE Done z) =\n  map_spmf\n   (\\<lambda>y.\n       case y of None \\<Rightarrow> Pure z\n       | Some (Inl x) \\<Rightarrow> Pure (f x)\n       | Some (Inr (out, oracle, rpv)) \\<Rightarrow>\n           IO out\n            (\\<lambda>input.\n                TRY map_gpv f id\n                     (oracle input \\<bind>\n                      (\\<lambda>(x, y).\n                          inline callee (rpv x) y)) ELSE Done z))\n   (TRY map_spmf Some (inline1 callee gpv s) ELSE return_spmf None)\n  rel_spmf\n   (eq_\\<I>_generat (=) \\<I>'\n     (\\<lambda>gpv gpv'.\n         (\\<exists>gpva s.\n             gpv =\n             map_gpv f id (inline callee (TRY gpva ELSE Done x) s) \\<and>\n             gpv' =\n             TRY map_gpv f id (inline callee gpva s) ELSE Done z \\<and>\n             \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n             pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n         eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n         (\\<exists>gpv'' gpv''' B fa g.\n             gpv = gpv'' \\<bind> fa \\<and>\n             gpv' = gpv''' \\<bind> g \\<and>\n             eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n             rel_fun B\n              (\\<lambda>gpva__ gpv'__.\n                  \\<exists>gpv s.\n                     gpva__ =\n                     map_gpv f id\n                      (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                     gpv'__ =\n                     TRY map_gpv f id\n                          (inline callee gpv s) ELSE Done z \\<and>\n                     \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                     pfinite_gpv \\<I> gpv \\<and> I s)\n              fa g)))\n   (map_spmf\n     (\\<lambda>x.\n         case x of Inl rs \\<Rightarrow> Pure rs\n         | Inr (out, oracle, rpv) \\<Rightarrow>\n             IO out\n              (\\<lambda>input.\n                  map_gpv f id\n                   (TRY map_gpv Some id\n                         (oracle input) ELSE Done None \\<bind>\n                    (\\<lambda>xy.\n                        case xy of None \\<Rightarrow> Fail\n                        | Some (x, y) \\<Rightarrow>\n                            inline callee (rpv x) y))))\n     (map_spmf\n       (\\<lambda>y.\n           case y of None \\<Rightarrow> Inl z\n           | Some x' \\<Rightarrow>\n               map_sum f\n                (\\<lambda>(out, c, rpv).\n                    (out, c, \\<lambda>input. TRY rpv input ELSE Done x))\n                x')\n       (TRY map_spmf Some (inline1 callee gpv s) ELSE return_spmf None)))\n   (map_spmf\n     (\\<lambda>y.\n         case y of None \\<Rightarrow> Pure z\n         | Some (Inl x) \\<Rightarrow> Pure (f x)\n         | Some (Inr (out, oracle, rpv)) \\<Rightarrow>\n             IO out\n              (\\<lambda>input.\n                  TRY map_gpv f id\n                       (oracle input \\<bind>\n                        (\\<lambda>(x, y).\n                            inline callee (rpv x) y)) ELSE Done z))\n     (TRY map_spmf Some (inline1 callee gpv s) ELSE return_spmf None))\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (eq_\\<I>_generat (=) \\<I>'\n       (\\<lambda>gpv gpv'.\n           (\\<exists>gpva s.\n               gpv =\n               map_gpv f id (inline callee (TRY gpva ELSE Done x) s) \\<and>\n               gpv' =\n               TRY map_gpv f id (inline callee gpva s) ELSE Done z \\<and>\n               \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n               pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n           eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n           (\\<exists>gpv'' gpv''' B fa g.\n               gpv = gpv'' \\<bind> fa \\<and>\n               gpv' = gpv''' \\<bind> g \\<and>\n               eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n               rel_fun B\n                (\\<lambda>gpva__ gpv'__.\n                    \\<exists>gpv s.\n                       gpva__ =\n                       map_gpv f id\n                        (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                       gpv'__ =\n                       TRY map_gpv f id\n                            (inline callee gpv s) ELSE Done z \\<and>\n                       \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                       pfinite_gpv \\<I> gpv \\<and> I s)\n                fa g)))\n     (the_gpv (map_gpv f id (inline callee (TRY gpv ELSE Done x) s)))\n     (the_gpv (TRY map_gpv f id (inline callee gpv s) ELSE Done z))", "by(simp only:)"], ["proof (state)\nthis:\n  rel_spmf\n   (eq_\\<I>_generat (=) \\<I>'\n     (\\<lambda>gpv gpv'.\n         (\\<exists>gpva s.\n             gpv =\n             map_gpv f id (inline callee (TRY gpva ELSE Done x) s) \\<and>\n             gpv' =\n             TRY map_gpv f id (inline callee gpva s) ELSE Done z \\<and>\n             \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n             pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n         eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n         (\\<exists>gpv'' gpv''' B fa g.\n             gpv = gpv'' \\<bind> fa \\<and>\n             gpv' = gpv''' \\<bind> g \\<and>\n             eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n             rel_fun B\n              (\\<lambda>gpva__ gpv'__.\n                  \\<exists>gpv s.\n                     gpva__ =\n                     map_gpv f id\n                      (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                     gpv'__ =\n                     TRY map_gpv f id\n                          (inline callee gpv s) ELSE Done z \\<and>\n                     \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                     pfinite_gpv \\<I> gpv \\<and> I s)\n              fa g)))\n   (the_gpv (map_gpv f id (inline callee (TRY gpv ELSE Done x) s)))\n   (the_gpv (TRY map_gpv f id (inline callee gpv s) ELSE Done z))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_spmf\n   (eq_\\<I>_generat (=) \\<I>'\n     (\\<lambda>gpv gpv'.\n         (\\<exists>gpva s.\n             gpv =\n             map_gpv f id (inline callee (TRY gpva ELSE Done x) s) \\<and>\n             gpv' =\n             TRY map_gpv f id (inline callee gpva s) ELSE Done z \\<and>\n             \\<I> \\<turnstile>g gpva \\<surd> \\<and>\n             pfinite_gpv \\<I> gpva \\<and> I s) \\<or>\n         eq_\\<I>_gpv (=) \\<I>' gpv gpv' \\<or>\n         (\\<exists>gpv'' gpv''' B fa g.\n             gpv = gpv'' \\<bind> fa \\<and>\n             gpv' = gpv''' \\<bind> g \\<and>\n             eq_\\<I>_gpv B \\<I>' gpv'' gpv''' \\<and>\n             rel_fun B\n              (\\<lambda>gpva__ gpv'__.\n                  \\<exists>gpv s.\n                     gpva__ =\n                     map_gpv f id\n                      (inline callee (TRY gpv ELSE Done x) s) \\<and>\n                     gpv'__ =\n                     TRY map_gpv f id\n                          (inline callee gpv s) ELSE Done z \\<and>\n                     \\<I> \\<turnstile>g gpv \\<surd> \\<and>\n                     pfinite_gpv \\<I> gpv \\<and> I s)\n              fa g)))\n   (the_gpv (map_gpv f id (inline callee (TRY gpv ELSE Done x) s)))\n   (the_gpv (TRY map_gpv f id (inline callee gpv s) ELSE Done z))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition cr_prod2 :: \"'a \\<Rightarrow> ('b \\<Rightarrow> 'c \\<Rightarrow> bool) \\<Rightarrow> 'b \\<Rightarrow> 'a \\<times> 'c \\<Rightarrow> bool\" where\n  \"cr_prod2 x A = (\\<lambda>b (a, c). A b c \\<and> x = a)\""], ["", "lemma cr_prod2_simps [simp]: \"cr_prod2 x A a (b, c) \\<longleftrightarrow> A a c \\<and> x = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cr_prod2 x A a (b, c) = (A a c \\<and> x = b)", "by(simp add: cr_prod2_def)"], ["", "lemma cr_prod2I: \"A a b \\<Longrightarrow> cr_prod2 x A a (x, b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A a b \\<Longrightarrow> cr_prod2 x A a (x, b)", "by simp"], ["", "lemma cr_prod2_Grp: \"cr_prod2 x (BNF_Def.Grp A f) = BNF_Def.Grp A (\\<lambda>b. (x, f b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cr_prod2 x (BNF_Def.Grp A f) = BNF_Def.Grp A (\\<lambda>b. (x, f b))", "by(auto simp add: Grp_def fun_eq_iff)"], ["", "(* A stronger version of the existing extend_state_oracle_transfer *)"], ["", "lemma extend_state_oracle_transfer': includes lifting_syntax shows\n  \"((S ===> C ===> rel_spmf (rel_prod R S)) ===> cr_prod2 s S ===> C ===> rel_spmf (rel_prod R (cr_prod2 s S))) (\\<lambda>oracle. oracle) extend_state_oracle\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> C ===> rel_spmf (rel_prod R S)) ===>\n     cr_prod2 s S ===> C ===> rel_spmf (rel_prod R (cr_prod2 s S)))\n     (\\<lambda>oracle. oracle) extend_state_oracle", "unfolding extend_state_oracle_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> C ===> rel_spmf (rel_prod R S)) ===>\n     cr_prod2 s S ===> C ===> rel_spmf (rel_prod R (cr_prod2 s S)))\n     (\\<lambda>oracle. oracle)\n     (\\<lambda>callee (s', s) x.\n         map_spmf (\\<lambda>(y, s). (y, s', s)) (callee s x))", "apply(rule rel_funI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(S ===> C ===> rel_spmf (rel_prod R S)) x y;\n        cr_prod2 s S xa ya; C xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod R (cr_prod2 s S)) (x xa xb)\n                          ((case ya of\n                            (s', s) \\<Rightarrow>\n                              \\<lambda>x.\n                                 map_spmf (\\<lambda>(y, s). (y, s', s))\n                                  (y s x))\n                            yb)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa b xb yb.\n       \\<lbrakk>(S ===> C ===> rel_spmf (rel_prod R S)) x y; S xa b;\n        C xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod R (cr_prod2 s S)) (x xa xb)\n                          (map_spmf (\\<lambda>(y, sa). (y, s, sa)) (y b yb))", "apply(drule (1) rel_funD)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa b xb yb.\n       \\<lbrakk>S xa b; C xb yb;\n        rel_spmf (rel_prod R S) (x xa xb) (y b yb)\\<rbrakk>\n       \\<Longrightarrow> rel_spmf (rel_prod R (cr_prod2 s S)) (x xa xb)\n                          (map_spmf (\\<lambda>(y, sa). (y, s, sa)) (y b yb))", "apply(auto simp add: spmf_rel_map split_def dest: rel_funD intro: rel_spmf_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* @Reza: This is a proof based on parametricity,\n using the relation cr_prod2 s (=) to fix the first component of the extended callee state to s *)"], ["", "lemma exec_gpv_extend_state_oracle:\n  \"exec_gpv (extend_state_oracle callee) gpv (s, s') =\n  map_spmf (\\<lambda>(x, s''). (x, (s, s''))) (exec_gpv callee gpv s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_gpv \\<dagger>callee gpv (s, s') =\n    map_spmf (\\<lambda>(x, s''). (x, s, s'')) (exec_gpv callee gpv s')", "using exec_gpv_parametric'[THEN rel_funD, OF extend_state_oracle_transfer'[THEN rel_funD], of \"(=)\" \"(=)\" \"(=)\" callee callee \"(=)\" s]"], ["proof (prove)\nusing this:\n  rel_fun (=) (rel_fun (=) (rel_spmf (rel_prod (=) (=)))) callee\n   callee \\<Longrightarrow>\n  rel_fun (rel_gpv'' (=) (=) (=))\n   (rel_fun (cr_prod2 s (=)) (rel_spmf (rel_prod (=) (cr_prod2 s (=)))))\n   (exec_gpv callee) (exec_gpv \\<dagger>callee)\n\ngoal (1 subgoal):\n 1. exec_gpv \\<dagger>callee gpv (s, s') =\n    map_spmf (\\<lambda>(x, s''). (x, s, s'')) (exec_gpv callee gpv s')", "unfolding relator_eq rel_gpv''_eq"], ["proof (prove)\nusing this:\n  callee = callee \\<Longrightarrow>\n  rel_fun (=)\n   (rel_fun (cr_prod2 s (=)) (rel_spmf (rel_prod (=) (cr_prod2 s (=)))))\n   (exec_gpv callee) (exec_gpv \\<dagger>callee)\n\ngoal (1 subgoal):\n 1. exec_gpv \\<dagger>callee gpv (s, s') =\n    map_spmf (\\<lambda>(x, s''). (x, s, s'')) (exec_gpv callee gpv s')", "apply(clarsimp simp add: rel_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa a b.\n       xa = b \\<and> s = a \\<longrightarrow>\n       rel_spmf (rel_prod (=) (cr_prod2 a (=))) (exec_gpv callee x b)\n        (exec_gpv \\<dagger>callee x (a, b)) \\<Longrightarrow>\n    exec_gpv \\<dagger>callee gpv (s, s') =\n    map_spmf (\\<lambda>(x, s''). (x, s, s'')) (exec_gpv callee gpv s')", "apply(unfold eq_alt cr_prod2_Grp prod.rel_Grp option.rel_Grp pmf.rel_Grp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa a b.\n       BNF_Def.Grp UNIV id xa b \\<and>\n       BNF_Def.Grp UNIV id s a \\<longrightarrow>\n       BNF_Def.Grp\n        {x. set_pmf x\n            \\<subseteq> {x. set_option x\n                            \\<subseteq> {x.\n   Basic_BNFs.fsts x \\<subseteq> UNIV \\<and>\n   Basic_BNFs.snds x \\<subseteq> UNIV}}}\n        (map_spmf (map_prod id (\\<lambda>b. (a, id b))))\n        (exec_gpv callee x b)\n        (exec_gpv \\<dagger>callee x (a, b)) \\<Longrightarrow>\n    BNF_Def.Grp UNIV id (exec_gpv \\<dagger>callee gpv (s, s'))\n     (map_spmf (\\<lambda>(x, s''). (x, s, s'')) (exec_gpv callee gpv s'))", "apply(simp add: Grp_def map_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa.\n       exec_gpv \\<dagger>callee x (s, xa) =\n       map_spmf (\\<lambda>(x, y). (x, s, y))\n        (exec_gpv callee x xa) \\<Longrightarrow>\n    map_spmf (\\<lambda>(x, s''). (x, s, s'')) (exec_gpv callee gpv s') =\n    exec_gpv \\<dagger>callee gpv (s, s')", "apply(blast intro: sym)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "section \\<open>Material for Constructive Crypto\\<close>"], ["", "lemma WT_resource_\\<I>_uniform_UNIV [simp]: \"\\<I>_uniform A UNIV \\<turnstile>res res \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_uniform A UNIV \\<turnstile>res res \\<surd>", "by(coinduction arbitrary: res) auto"], ["", "lemma WT_converter_of_callee_invar:\n  assumes WT: \"\\<And>s q. \\<lbrakk> q \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> \\<I>' \\<turnstile>g callee s q \\<surd>\"\n    and res: \"\\<And>s q r s'. \\<lbrakk> (r, s') \\<in> results_gpv \\<I>' (callee s q); q \\<in> outs_\\<I> \\<I>; I s  \\<rbrakk> \\<Longrightarrow> r \\<in> responses_\\<I> \\<I> q \\<and> I s'\"\n    and I: \"I s\"\n  shows \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C converter_of_callee callee s \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C CNV callee s \\<surd>", "using I"], ["proof (prove)\nusing this:\n  I s\n\ngoal (1 subgoal):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C CNV callee s \\<surd>", "by(coinduction arbitrary: s)(auto simp add: WT res)"], ["", "lemma eq_\\<I>_gpv_eq_OO:\n  assumes \"eq_\\<I>_gpv (=) \\<I> gpv gpv'\" \"eq_\\<I>_gpv A \\<I> gpv' gpv''\"\n  shows \"eq_\\<I>_gpv A \\<I> gpv gpv''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv gpv''", "using eq_\\<I>_gpv_relcompp[THEN fun_cong, THEN fun_cong, THEN iffD2, OF relcomppI, OF assms]"], ["proof (prove)\nusing this:\n  eq_\\<I>_gpv ((=) OO A) \\<I> gpv gpv''\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv gpv''", "by(simp add: eq_OO)"], ["", "lemma eq_\\<I>_gpv_eq_OO2:\n  assumes \"eq_\\<I>_gpv (=) \\<I> gpv'' gpv'\" \"eq_\\<I>_gpv A \\<I> gpv gpv'\"\n  shows \"eq_\\<I>_gpv A \\<I> gpv gpv''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv gpv''", "using eq_\\<I>_gpv_relcompp[where A'=\"conversep (=)\", THEN fun_cong, THEN fun_cong, THEN iffD2, OF relcomppI, OF assms(2)] assms(1)"], ["proof (prove)\nusing this:\n  eq_\\<I>_gpv (=)\\<inverse>\\<inverse> \\<I> gpv' ?x1 \\<Longrightarrow>\n  eq_\\<I>_gpv (A OO (=)\\<inverse>\\<inverse>) \\<I> gpv ?x1\n  eq_\\<I>_gpv (=) \\<I> gpv'' gpv'\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv gpv''", "unfolding eq_\\<I>_gpv_conversep"], ["proof (prove)\nusing this:\n  (eq_\\<I>_gpv (=) \\<I>)\\<inverse>\\<inverse> gpv' ?x1 \\<Longrightarrow>\n  eq_\\<I>_gpv (A OO (=)\\<inverse>\\<inverse>) \\<I> gpv ?x1\n  eq_\\<I>_gpv (=) \\<I> gpv'' gpv'\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> gpv gpv''", "by(simp add: OO_eq)"], ["", "lemma eq_\\<I>_gpv_try_gpv_cong:\n  assumes \"eq_\\<I>_gpv A \\<I> gpv1 gpv1'\"\n    and \"eq_\\<I>_gpv A \\<I> gpv2 gpv2'\"\n  shows \"eq_\\<I>_gpv A \\<I> (try_gpv gpv1 gpv2) (try_gpv gpv1' gpv2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> (TRY gpv1 ELSE gpv2) (TRY gpv1' ELSE gpv2')", "using assms(1)"], ["proof (prove)\nusing this:\n  eq_\\<I>_gpv A \\<I> gpv1 gpv1'\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> (TRY gpv1 ELSE gpv2) (TRY gpv1' ELSE gpv2')", "apply(coinduction arbitrary: gpv1 gpv1')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>gpv1 gpv1'.\n       eq_\\<I>_gpv A \\<I> gpv1 gpv1' \\<Longrightarrow>\n       rel_spmf\n        (eq_\\<I>_generat A \\<I>\n          (\\<lambda>gpv gpv'.\n              (\\<exists>gpv1 gpv1'.\n                  gpv = TRY gpv1 ELSE gpv2 \\<and>\n                  gpv' = TRY gpv1' ELSE gpv2' \\<and>\n                  eq_\\<I>_gpv A \\<I> gpv1 gpv1') \\<or>\n              eq_\\<I>_gpv A \\<I> gpv gpv'))\n        (the_gpv (TRY gpv1 ELSE gpv2)) (the_gpv (TRY gpv1' ELSE gpv2'))", "using assms(2)"], ["proof (prove)\nusing this:\n  eq_\\<I>_gpv A \\<I> gpv2 gpv2'\n\ngoal (1 subgoal):\n 1. \\<And>gpv1 gpv1'.\n       eq_\\<I>_gpv A \\<I> gpv1 gpv1' \\<Longrightarrow>\n       rel_spmf\n        (eq_\\<I>_generat A \\<I>\n          (\\<lambda>gpv gpv'.\n              (\\<exists>gpv1 gpv1'.\n                  gpv = TRY gpv1 ELSE gpv2 \\<and>\n                  gpv' = TRY gpv1' ELSE gpv2' \\<and>\n                  eq_\\<I>_gpv A \\<I> gpv1 gpv1') \\<or>\n              eq_\\<I>_gpv A \\<I> gpv gpv'))\n        (the_gpv (TRY gpv1 ELSE gpv2)) (the_gpv (TRY gpv1' ELSE gpv2'))", "apply(fastforce simp add: spmf_rel_map intro!: rel_spmf_try_spmf dest: eq_\\<I>_gpvD elim!: rel_spmf_mono_strong eq_\\<I>_generat.cases)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma eq_\\<I>_gpv_map_gpv':\n  assumes \"eq_\\<I>_gpv (BNF_Def.vimage2p f f' A) (map_\\<I> g h \\<I>) gpv1 gpv2\"\n  shows \"eq_\\<I>_gpv A \\<I> (map_gpv' f g h gpv1) (map_gpv' f' g h gpv2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> (map_gpv' f g h gpv1) (map_gpv' f' g h gpv2)", "using assms"], ["proof (prove)\nusing this:\n  eq_\\<I>_gpv (BNF_Def.vimage2p f f' A) (map_\\<I> g h \\<I>) gpv1 gpv2\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv A \\<I> (map_gpv' f g h gpv1) (map_gpv' f' g h gpv2)", "proof(coinduction arbitrary: gpv1 gpv2)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>gpv1 gpv2.\n       eq_\\<I>_gpv (BNF_Def.vimage2p f f' A) (map_\\<I> g h \\<I>) gpv1\n        gpv2 \\<Longrightarrow>\n       rel_spmf\n        (eq_\\<I>_generat A \\<I>\n          (\\<lambda>gpv gpv'.\n              (\\<exists>gpv1 gpv2.\n                  gpv = map_gpv' f g h gpv1 \\<and>\n                  gpv' = map_gpv' f' g h gpv2 \\<and>\n                  eq_\\<I>_gpv (BNF_Def.vimage2p f f' A) (map_\\<I> g h \\<I>)\n                   gpv1 gpv2) \\<or>\n              eq_\\<I>_gpv A \\<I> gpv gpv'))\n        (the_gpv (map_gpv' f g h gpv1)) (the_gpv (map_gpv' f' g h gpv2))", "case eq_\\<I>_gpv"], ["proof (state)\nthis:\n  eq_\\<I>_gpv (BNF_Def.vimage2p f f' A) (map_\\<I> g h \\<I>) gpv1 gpv2\n\ngoal (1 subgoal):\n 1. \\<And>gpv1 gpv2.\n       eq_\\<I>_gpv (BNF_Def.vimage2p f f' A) (map_\\<I> g h \\<I>) gpv1\n        gpv2 \\<Longrightarrow>\n       rel_spmf\n        (eq_\\<I>_generat A \\<I>\n          (\\<lambda>gpv gpv'.\n              (\\<exists>gpv1 gpv2.\n                  gpv = map_gpv' f g h gpv1 \\<and>\n                  gpv' = map_gpv' f' g h gpv2 \\<and>\n                  eq_\\<I>_gpv (BNF_Def.vimage2p f f' A) (map_\\<I> g h \\<I>)\n                   gpv1 gpv2) \\<or>\n              eq_\\<I>_gpv A \\<I> gpv gpv'))\n        (the_gpv (map_gpv' f g h gpv1)) (the_gpv (map_gpv' f' g h gpv2))", "from this[THEN eq_\\<I>_gpvD]"], ["proof (chain)\npicking this:\n  rel_spmf\n   (eq_\\<I>_generat (BNF_Def.vimage2p f f' A) (map_\\<I> g h \\<I>)\n     (eq_\\<I>_gpv (BNF_Def.vimage2p f f' A) (map_\\<I> g h \\<I>)))\n   (the_gpv gpv1) (the_gpv gpv2)", "show ?case"], ["proof (prove)\nusing this:\n  rel_spmf\n   (eq_\\<I>_generat (BNF_Def.vimage2p f f' A) (map_\\<I> g h \\<I>)\n     (eq_\\<I>_gpv (BNF_Def.vimage2p f f' A) (map_\\<I> g h \\<I>)))\n   (the_gpv gpv1) (the_gpv gpv2)\n\ngoal (1 subgoal):\n 1. rel_spmf\n     (eq_\\<I>_generat A \\<I>\n       (\\<lambda>gpv gpv'.\n           (\\<exists>gpv1 gpv2.\n               gpv = map_gpv' f g h gpv1 \\<and>\n               gpv' = map_gpv' f' g h gpv2 \\<and>\n               eq_\\<I>_gpv (BNF_Def.vimage2p f f' A) (map_\\<I> g h \\<I>)\n                gpv1 gpv2) \\<or>\n           eq_\\<I>_gpv A \\<I> gpv gpv'))\n     (the_gpv (map_gpv' f g h gpv1)) (the_gpv (map_gpv' f' g h gpv2))", "apply(simp add: spmf_rel_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf\n     (eq_\\<I>_generat (BNF_Def.vimage2p f f' A) (map_\\<I> g h \\<I>)\n       (eq_\\<I>_gpv (BNF_Def.vimage2p f f' A) (map_\\<I> g h \\<I>)))\n     (the_gpv gpv1) (the_gpv gpv2) \\<Longrightarrow>\n    rel_spmf\n     (\\<lambda>x y.\n         eq_\\<I>_generat A \\<I>\n          (\\<lambda>gpv gpv'.\n              (\\<exists>gpv1.\n                  gpv = map_gpv' f g h gpv1 \\<and>\n                  (\\<exists>gpv2.\n                      gpv' = map_gpv' f' g h gpv2 \\<and>\n                      eq_\\<I>_gpv (BNF_Def.vimage2p f f' A)\n                       (map_\\<I> g h \\<I>) gpv1 gpv2)) \\<or>\n              eq_\\<I>_gpv A \\<I> gpv gpv')\n          (map_generat f g (map_fun h (map_gpv' f g h)) x)\n          (map_generat f' g (map_fun h (map_gpv' f' g h)) y))\n     (the_gpv gpv1) (the_gpv gpv2)", "apply(erule rel_spmf_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       eq_\\<I>_generat (BNF_Def.vimage2p f f' A) (map_\\<I> g h \\<I>)\n        (eq_\\<I>_gpv (BNF_Def.vimage2p f f' A) (map_\\<I> g h \\<I>)) x\n        y \\<Longrightarrow>\n       eq_\\<I>_generat A \\<I>\n        (\\<lambda>gpv gpv'.\n            (\\<exists>gpv1.\n                gpv = map_gpv' f g h gpv1 \\<and>\n                (\\<exists>gpv2.\n                    gpv' = map_gpv' f' g h gpv2 \\<and>\n                    eq_\\<I>_gpv (BNF_Def.vimage2p f f' A)\n                     (map_\\<I> g h \\<I>) gpv1 gpv2)) \\<or>\n            eq_\\<I>_gpv A \\<I> gpv gpv')\n        (map_generat f g (map_fun h (map_gpv' f g h)) x)\n        (map_generat f' g (map_fun h (map_gpv' f' g h)) y)", "apply(auto 4 4 simp add: BNF_Def.vimage2p_def elim!: eq_\\<I>_generat.cases)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_spmf\n   (eq_\\<I>_generat A \\<I>\n     (\\<lambda>gpv gpv'.\n         (\\<exists>gpv1 gpv2.\n             gpv = map_gpv' f g h gpv1 \\<and>\n             gpv' = map_gpv' f' g h gpv2 \\<and>\n             eq_\\<I>_gpv (BNF_Def.vimage2p f f' A) (map_\\<I> g h \\<I>) gpv1\n              gpv2) \\<or>\n         eq_\\<I>_gpv A \\<I> gpv gpv'))\n   (the_gpv (map_gpv' f g h gpv1)) (the_gpv (map_gpv' f' g h gpv2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eq_\\<I>_converter_map_converter:\n  assumes \"map_\\<I> (inv_into UNIV f) (inv_into UNIV g) \\<I>, map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv1 \\<sim> conv2\"\n    and \"inj f\" \"surj g\"\n  shows \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C map_converter f g f' g' conv1 \\<sim> map_converter f g f' g' conv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>,\\<I>' \\<turnstile>\\<^sub>C map_converter f g f' g' conv1 \\<sim>\n    map_converter f g f' g' conv2", "using assms(1)"], ["proof (prove)\nusing this:\n  map_\\<I> (inv f) (inv g) \\<I>,map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\n  conv1 \\<sim> conv2\n\ngoal (1 subgoal):\n 1. \\<I>,\\<I>' \\<turnstile>\\<^sub>C map_converter f g f' g' conv1 \\<sim>\n    map_converter f g f' g' conv2", "proof(coinduction arbitrary: conv1 conv2)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q conv1 conv2.\n       \\<lbrakk>map_\\<I> (inv f) (inv g)\n                 \\<I>,map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\n                conv1 \\<sim> conv2;\n        q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> eq_\\<I>_gpv\n                          (rel_prod\n                            (eq_onp\n                              (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q))\n                            (\\<lambda>conv conv'.\n                                (\\<exists>conv1 conv2.\n                                    conv =\n                                    map_converter f g f' g' conv1 \\<and>\n                                    conv' =\n                                    map_converter f g f' g' conv2 \\<and>\n                                    map_\\<I> (inv f) (inv g)\n                                     \\<I>,map_\\<I> f' g'\n     \\<I>' \\<turnstile>\\<^sub>C\n                                    conv1 \\<sim> conv2) \\<or>\n                                \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim>\n                                conv'))\n                          \\<I>'\n                          (run_converter (map_converter f g f' g' conv1) q)\n                          (run_converter (map_converter f g f' g' conv2) q)", "case eq_\\<I>_converter"], ["proof (state)\nthis:\n  map_\\<I> (inv f) (inv g) \\<I>,map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\n  conv1 \\<sim> conv2\n  q \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. \\<And>q conv1 conv2.\n       \\<lbrakk>map_\\<I> (inv f) (inv g)\n                 \\<I>,map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\n                conv1 \\<sim> conv2;\n        q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> eq_\\<I>_gpv\n                          (rel_prod\n                            (eq_onp\n                              (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q))\n                            (\\<lambda>conv conv'.\n                                (\\<exists>conv1 conv2.\n                                    conv =\n                                    map_converter f g f' g' conv1 \\<and>\n                                    conv' =\n                                    map_converter f g f' g' conv2 \\<and>\n                                    map_\\<I> (inv f) (inv g)\n                                     \\<I>,map_\\<I> f' g'\n     \\<I>' \\<turnstile>\\<^sub>C\n                                    conv1 \\<sim> conv2) \\<or>\n                                \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim>\n                                conv'))\n                          \\<I>'\n                          (run_converter (map_converter f g f' g' conv1) q)\n                          (run_converter (map_converter f g f' g' conv2) q)", "from this(2)"], ["proof (chain)\npicking this:\n  q \\<in> outs_\\<I> \\<I>", "have \"f q \\<in> outs_\\<I> (map_\\<I> (inv_into UNIV f) (inv_into UNIV g) \\<I>)\""], ["proof (prove)\nusing this:\n  q \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. f q \\<in> outs_\\<I> (map_\\<I> (inv f) (inv g) \\<I>)", "using assms(2)"], ["proof (prove)\nusing this:\n  q \\<in> outs_\\<I> \\<I>\n  inj f\n\ngoal (1 subgoal):\n 1. f q \\<in> outs_\\<I> (map_\\<I> (inv f) (inv g) \\<I>)", "by simp"], ["proof (state)\nthis:\n  f q \\<in> outs_\\<I> (map_\\<I> (inv f) (inv g) \\<I>)\n\ngoal (1 subgoal):\n 1. \\<And>q conv1 conv2.\n       \\<lbrakk>map_\\<I> (inv f) (inv g)\n                 \\<I>,map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\n                conv1 \\<sim> conv2;\n        q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> eq_\\<I>_gpv\n                          (rel_prod\n                            (eq_onp\n                              (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q))\n                            (\\<lambda>conv conv'.\n                                (\\<exists>conv1 conv2.\n                                    conv =\n                                    map_converter f g f' g' conv1 \\<and>\n                                    conv' =\n                                    map_converter f g f' g' conv2 \\<and>\n                                    map_\\<I> (inv f) (inv g)\n                                     \\<I>,map_\\<I> f' g'\n     \\<I>' \\<turnstile>\\<^sub>C\n                                    conv1 \\<sim> conv2) \\<or>\n                                \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim>\n                                conv'))\n                          \\<I>'\n                          (run_converter (map_converter f g f' g' conv1) q)\n                          (run_converter (map_converter f g f' g' conv2) q)", "from eq_\\<I>_converter(1)[THEN eq_\\<I>_converterD, OF this]"], ["proof (chain)\npicking this:\n  eq_\\<I>_gpv\n   (rel_prod\n     (eq_onp\n       (\\<lambda>r.\n           r \\<in> responses_\\<I> (map_\\<I> (inv f) (inv g) \\<I>) (f q)))\n     (eq_\\<I>_converter (map_\\<I> (inv f) (inv g) \\<I>)\n       (map_\\<I> f' g' \\<I>')))\n   (map_\\<I> f' g' \\<I>') (run_converter conv1 (f q))\n   (run_converter conv2 (f q))", "show ?case"], ["proof (prove)\nusing this:\n  eq_\\<I>_gpv\n   (rel_prod\n     (eq_onp\n       (\\<lambda>r.\n           r \\<in> responses_\\<I> (map_\\<I> (inv f) (inv g) \\<I>) (f q)))\n     (eq_\\<I>_converter (map_\\<I> (inv f) (inv g) \\<I>)\n       (map_\\<I> f' g' \\<I>')))\n   (map_\\<I> f' g' \\<I>') (run_converter conv1 (f q))\n   (run_converter conv2 (f q))\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv\n     (rel_prod (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q))\n       (\\<lambda>conv conv'.\n           (\\<exists>conv1 conv2.\n               conv = map_converter f g f' g' conv1 \\<and>\n               conv' = map_converter f g f' g' conv2 \\<and>\n               map_\\<I> (inv f) (inv g)\n                \\<I>,map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\n               conv1 \\<sim> conv2) \\<or>\n           \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv'))\n     \\<I>' (run_converter (map_converter f g f' g' conv1) q)\n     (run_converter (map_converter f g f' g' conv2) q)", "using assms(2,3)"], ["proof (prove)\nusing this:\n  eq_\\<I>_gpv\n   (rel_prod\n     (eq_onp\n       (\\<lambda>r.\n           r \\<in> responses_\\<I> (map_\\<I> (inv f) (inv g) \\<I>) (f q)))\n     (eq_\\<I>_converter (map_\\<I> (inv f) (inv g) \\<I>)\n       (map_\\<I> f' g' \\<I>')))\n   (map_\\<I> f' g' \\<I>') (run_converter conv1 (f q))\n   (run_converter conv2 (f q))\n  inj f\n  surj g\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv\n     (rel_prod (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q))\n       (\\<lambda>conv conv'.\n           (\\<exists>conv1 conv2.\n               conv = map_converter f g f' g' conv1 \\<and>\n               conv' = map_converter f g f' g' conv2 \\<and>\n               map_\\<I> (inv f) (inv g)\n                \\<I>,map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\n               conv1 \\<sim> conv2) \\<or>\n           \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv'))\n     \\<I>' (run_converter (map_converter f g f' g' conv1) q)\n     (run_converter (map_converter f g f' g' conv2) q)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eq_\\<I>_gpv\n              (rel_prod\n                (eq_onp (\\<lambda>r. r \\<in> inv g ` responses_\\<I> \\<I> q))\n                (eq_\\<I>_converter (map_\\<I> (inv f) (inv g) \\<I>)\n                  (map_\\<I> f' g' \\<I>')))\n              (map_\\<I> f' g' \\<I>') (run_converter conv1 (f q))\n              (run_converter conv2 (f q));\n     inj f; surj g\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1.\n                                 conv = map_converter f g f' g' conv1 \\<and>\n                                 (\\<exists>conv2.\n                                     conv' =\n                                     map_converter f g f' g' conv2 \\<and>\n                                     map_\\<I> (inv f) (inv g)\n\\<I>,map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\n                                     conv1 \\<sim> conv2)) \\<or>\n                             \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim>\n                             conv'))\n                       \\<I>'\n                       (map_gpv' (map_prod g (map_converter f g f' g')) f'\n                         g' (run_converter conv1 (f q)))\n                       (map_gpv' (map_prod g (map_converter f g f' g')) f'\n                         g' (run_converter conv2 (f q)))", "apply(rule eq_\\<I>_gpv_map_gpv')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eq_\\<I>_gpv\n              (rel_prod\n                (eq_onp (\\<lambda>r. r \\<in> inv g ` responses_\\<I> \\<I> q))\n                (eq_\\<I>_converter (map_\\<I> (inv f) (inv g) \\<I>)\n                  (map_\\<I> f' g' \\<I>')))\n              (map_\\<I> f' g' \\<I>') (run_converter conv1 (f q))\n              (run_converter conv2 (f q));\n     inj f; surj g\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (BNF_Def.vimage2p\n                         (map_prod g (map_converter f g f' g'))\n                         (map_prod g (map_converter f g f' g'))\n                         (rel_prod\n                           (eq_onp\n                             (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q))\n                           (\\<lambda>conv conv'.\n                               (\\<exists>conv1.\n                                   conv =\n                                   map_converter f g f' g' conv1 \\<and>\n                                   (\\<exists>conv2.\n conv' = map_converter f g f' g' conv2 \\<and>\n map_\\<I> (inv f) (inv g) \\<I>,map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\n conv1 \\<sim> conv2)) \\<or>\n                               \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim>\n                               conv')))\n                       (map_\\<I> f' g' \\<I>') (run_converter conv1 (f q))\n                       (run_converter conv2 (f q))", "apply(simp add: BNF_Def.vimage2p_def prod.rel_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eq_\\<I>_gpv\n              (rel_prod\n                (eq_onp (\\<lambda>r. r \\<in> inv g ` responses_\\<I> \\<I> q))\n                (eq_\\<I>_converter (map_\\<I> (inv f) (inv g) \\<I>)\n                  (map_\\<I> f' g' \\<I>')))\n              (map_\\<I> f' g' \\<I>') (run_converter conv1 (f q))\n              (run_converter conv2 (f q));\n     inj f; surj g\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (\\<lambda>x y.\n                             eq_onp\n                              (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q)\n                              (g x) (g y))\n                         (\\<lambda>x y.\n                             (\\<exists>conv1.\n                                 map_converter f g f' g' x =\n                                 map_converter f g f' g' conv1 \\<and>\n                                 (\\<exists>conv2.\n                                     map_converter f g f' g' y =\n                                     map_converter f g f' g' conv2 \\<and>\n                                     map_\\<I> (inv f) (inv g)\n\\<I>,map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\n                                     conv1 \\<sim> conv2)) \\<or>\n                             \\<I>,\\<I>' \\<turnstile>\\<^sub>C\n                             map_converter f g f' g' x \\<sim>\n                             map_converter f g f' g' y))\n                       (map_\\<I> f' g' \\<I>') (run_converter conv1 (f q))\n                       (run_converter conv2 (f q))", "apply(erule eq_\\<I>_gpv_mono')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>inj f; surj g;\n        rel_prod\n         (eq_onp (\\<lambda>r. r \\<in> inv g ` responses_\\<I> \\<I> q))\n         (eq_\\<I>_converter (map_\\<I> (inv f) (inv g) \\<I>)\n           (map_\\<I> f' g' \\<I>'))\n         x y\\<rbrakk>\n       \\<Longrightarrow> rel_prod\n                          (\\<lambda>x y.\n                              eq_onp\n                               (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q)\n                               (g x) (g y))\n                          (\\<lambda>x y.\n                              (\\<exists>conv1.\n                                  map_converter f g f' g' x =\n                                  map_converter f g f' g' conv1 \\<and>\n                                  (\\<exists>conv2.\nmap_converter f g f' g' y = map_converter f g f' g' conv2 \\<and>\nmap_\\<I> (inv f) (inv g) \\<I>,map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\nconv1 \\<sim> conv2)) \\<or>\n                              \\<I>,\\<I>' \\<turnstile>\\<^sub>C\n                              map_converter f g f' g' x \\<sim>\n                              map_converter f g f' g' y)\n                          x y\n 2. \\<lbrakk>inj f; surj g\\<rbrakk>\n    \\<Longrightarrow> map_\\<I> f' g' \\<I>' \\<le> map_\\<I> f' g' \\<I>'", "apply(auto 4 4 simp add: eq_onp_def surj_f_inv_f)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eq_\\<I>_gpv\n   (rel_prod (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q))\n     (\\<lambda>conv conv'.\n         (\\<exists>conv1 conv2.\n             conv = map_converter f g f' g' conv1 \\<and>\n             conv' = map_converter f g f' g' conv2 \\<and>\n             map_\\<I> (inv f) (inv g)\n              \\<I>,map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\n             conv1 \\<sim> conv2) \\<or>\n         \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv'))\n   \\<I>' (run_converter (map_converter f g f' g' conv1) q)\n   (run_converter (map_converter f g f' g' conv2) q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resource_of_oracle_run_resource: \"resource_of_oracle run_resource res = res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RES run_resource res = res", "by(coinduction arbitrary: res)(auto simp add: rel_fun_def spmf_rel_map intro!: rel_spmf_reflI)"], ["", "lemma connect_map_gpv':\n  \"connect (map_gpv' f g h adv) res = map_spmf f (connect adv (map_resource g h res))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connect (map_gpv' f g h adv) res =\n    map_spmf f (connect adv (map_resource g h res))", "unfolding connect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. run_gpv run_resource (map_gpv' f g h adv) res =\n    map_spmf f (run_gpv run_resource adv (map_resource g h res))", "by(subst (3) resource_of_oracle_run_resource[symmetric])\n    (simp add: exec_gpv_map_gpv' map_resource_resource_of_oracle spmf.map_comp exec_gpv_resource_of_oracle)"], ["", "primcorec fail_resource :: \"('a, 'b) resource\" where\n  \"run_resource fail_resource = (\\<lambda>_. return_pmf None)\""], ["", "lemma WT_fail_resource [WT_intro]: \"\\<I> \\<turnstile>res fail_resource \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>res fail_resource \\<surd>", "by(rule WT_resourceI) simp"], ["", "context fixes y :: \"'b\" begin"], ["", "primcorec const_resource :: \"('a, 'b) resource\" where\n  \"run_resource const_resource = (\\<lambda>_. map_spmf (map_prod id (\\<lambda>_. const_resource)) (return_spmf (y, ())))\""], ["", "end"], ["", "lemma const_resource_sel [simp]: \"run_resource (const_resource y) = (\\<lambda>_. return_spmf (y, const_resource y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_resource (const_resource y) =\n    (\\<lambda>_. return_spmf (y, const_resource y))", "by simp"], ["", "declare const_resource.sel [simp del]"], ["", "lemma lossless_const_resource [simp]: \"lossless_resource \\<I> (const_resource y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_resource \\<I> (const_resource y)", "by(coinduction) simp"], ["", "lemma WT_const_resource [simp]:\n  \"\\<I> \\<turnstile>res const_resource y \\<surd> \\<longleftrightarrow> (\\<forall>x\\<in>outs_\\<I> \\<I>. y \\<in> responses_\\<I> \\<I> x)\" (is \"?lhs \\<longleftrightarrow> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>res const_resource y \\<surd> =\n    (\\<forall>x\\<in>outs_\\<I> \\<I>. y \\<in> responses_\\<I> \\<I> x)", "proof(intro iffI ballI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<I> \\<turnstile>res const_resource y \\<surd>;\n        x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> y \\<in> responses_\\<I> \\<I> x\n 2. \\<forall>x\\<in>outs_\\<I> \\<I>.\n       y \\<in> responses_\\<I> \\<I> x \\<Longrightarrow>\n    \\<I> \\<turnstile>res const_resource y \\<surd>", "show \"y \\<in> responses_\\<I> \\<I> x\" if ?lhs and \"x \\<in> outs_\\<I> \\<I>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> responses_\\<I> \\<I> x", "using WT_resourceD[OF that]"], ["proof (prove)\nusing this:\n  (?r, ?res')\n  \\<in> set_spmf (run_resource (const_resource y) x) \\<Longrightarrow>\n  ?r \\<in> responses_\\<I> \\<I> x \\<and> \\<I> \\<turnstile>res ?res' \\<surd>\n\ngoal (1 subgoal):\n 1. y \\<in> responses_\\<I> \\<I> x", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<I> \\<turnstile>res const_resource y \\<surd>;\n   ?x \\<in> outs_\\<I> \\<I>\\<rbrakk>\n  \\<Longrightarrow> y \\<in> responses_\\<I> \\<I> ?x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>outs_\\<I> \\<I>.\n       y \\<in> responses_\\<I> \\<I> x \\<Longrightarrow>\n    \\<I> \\<turnstile>res const_resource y \\<surd>", "show ?lhs if ?rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>res const_resource y \\<surd>", "using that"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>outs_\\<I> \\<I>. y \\<in> responses_\\<I> \\<I> x\n\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>res const_resource y \\<surd>", "by(coinduction)(auto)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>outs_\\<I> \\<I>.\n     y \\<in> responses_\\<I> \\<I> x \\<Longrightarrow>\n  \\<I> \\<turnstile>res const_resource y \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "context fixes y :: \"'b\" begin"], ["", "primcorec const_converter :: \"('a, 'b, 'c, 'd) converter\" where\n  \"run_converter const_converter = (\\<lambda>_. map_gpv (map_prod id (\\<lambda>_. const_converter)) id (Done (y, ())))\""], ["", "end"], ["", "lemma const_converter_sel [simp]: \"run_converter (const_converter y) = (\\<lambda>_. Done (y, const_converter y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_converter (const_converter y) =\n    (\\<lambda>_. Done (y, const_converter y))", "by simp"], ["", "lemma attach_const_converter [simp]: \"attach (const_converter y) res = const_resource y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const_converter y \\<rhd> res = const_resource y", "by(coinduction)(simp add: rel_fun_def)"], ["", "declare const_converter.sel [simp del]"], ["", "lemma comp_const_converter [simp]: \"comp_converter (const_converter x) conv = const_converter x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const_converter x \\<odot> conv = const_converter x", "by(coinduction)(simp add: rel_fun_def)"], ["", "lemma interaction_bounded_const_converter [simp, interaction_bound]: \n  \"interaction_any_bounded_converter (const_converter Fault) bound\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interaction_any_bounded_converter (const_converter Fault) bound", "by(coinduction) simp"], ["", "primcorec merge_exception_converter :: \"('a, ('b + 'c) exception, 'a, 'b exception + 'c exception) converter\" where\n  \"run_converter merge_exception_converter = \n   (\\<lambda>x. map_gpv (map_prod id (\\<lambda>conv. case conv of None \\<Rightarrow> merge_exception_converter | Some conv' \\<Rightarrow> conv')) id (\n     Pause x (\\<lambda>y. Done (case merge_exception y of Fault \\<Rightarrow> (Fault, Some (const_converter Fault))\n                              | OK y' \\<Rightarrow> (OK y', None)))))\""], ["", "lemma merge_exception_converter_sel [simp]:\n  \"run_converter merge_exception_converter x =\n   Pause x (\\<lambda>y. Done (case merge_exception y of Fault \\<Rightarrow> (Fault, const_converter Fault) | OK y' \\<Rightarrow> (OK y', merge_exception_converter)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_converter merge_exception_converter x =\n    Pause x\n     (\\<lambda>y.\n         Done\n          (case merge_exception y of\n           Fault \\<Rightarrow> (Fault, const_converter Fault)\n           | OK y' \\<Rightarrow> (OK y', merge_exception_converter)))", "by(simp add: o_def fun_eq_iff split: exception.split)"], ["", "declare merge_exception_converter.sel[simp del]"], ["", "lemma plossless_const_converter[simp]: \"plossless_converter \\<I> \\<I>' (const_converter x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter \\<I> \\<I>' (const_converter x)", "by(coinduction) auto"], ["", "lemma plossless_merge_exception_converter [simp]:\n  \"plossless_converter (exception_\\<I> (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>')) (exception_\\<I> \\<I> \\<oplus>\\<^sub>\\<I> exception_\\<I> \\<I>') merge_exception_converter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plossless_converter (exception_\\<I> (\\<I> \\<oplus>\\<^sub>\\<I> \\<I>'))\n     (exception_\\<I> \\<I> \\<oplus>\\<^sub>\\<I> exception_\\<I> \\<I>')\n     merge_exception_converter", "by(coinduction) auto"], ["", "lemma WT_const_converter [WT_intro, simp]:\n  \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C const_converter x \\<surd>\" if \"\\<forall>q \\<in> outs_\\<I> \\<I>. x \\<in> responses_\\<I> \\<I> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>, \\<I>' \\<turnstile>\\<^sub>C const_converter x \\<surd>", "by(coinduction)(auto simp add: that)"], ["", "lemma WT_merge_exception_converter [WT_intro, simp]: \n  \"exception_\\<I> (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2'), exception_\\<I> \\<I>1' \\<oplus>\\<^sub>\\<I> exception_\\<I> \\<I>2' \\<turnstile>\\<^sub>C merge_exception_converter \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exception_\\<I> (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2'),\n    exception_\\<I> \\<I>1' \\<oplus>\\<^sub>\\<I>\n    exception_\\<I> \\<I>2' \\<turnstile>\\<^sub>C\n    merge_exception_converter \\<surd>", "by(coinduction) auto"], ["", "lemma inline_left_gpv_merge_exception_converter:\n  \"bind_gpv (inline run_converter (map_gpv' id id option_of_exception (gpv_stop (left_gpv gpv))) merge_exception_converter) (\\<lambda>(x, conv'). case x of None \\<Rightarrow> Fail | Some x' \\<Rightarrow> Done (x, conv')) =\n   bind_gpv (left_gpv (map_gpv' id id option_of_exception (gpv_stop gpv))) (\\<lambda>x. case x of None \\<Rightarrow> Fail | Some x' \\<Rightarrow> Done (x, merge_exception_converter))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inline run_converter\n     (map_gpv' id id option_of_exception (gpv_stop (left_gpv gpv)))\n     merge_exception_converter \\<bind>\n    (\\<lambda>(x, conv').\n        case x of None \\<Rightarrow> Fail\n        | Some x' \\<Rightarrow> Done (x, conv')) =\n    left_gpv (map_gpv' id id option_of_exception (gpv_stop gpv)) \\<bind>\n    (\\<lambda>x.\n        case x of None \\<Rightarrow> Fail\n        | Some x' \\<Rightarrow> Done (x, merge_exception_converter))", "apply(coinduction arbitrary: gpv rule: gpv.coinduct_strong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>gpva.\n       rel_spmf\n        (rel_generat (=) (=)\n          (rel_fun (=)\n            (\\<lambda>gpv gpv'.\n                (\\<exists>gpva.\n                    gpv =\n                    inline run_converter\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop (left_gpv gpva)))\n                     merge_exception_converter \\<bind>\n                    (\\<lambda>(x, conv').\n                        case x of None \\<Rightarrow> Fail\n                        | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                    gpv' =\n                    left_gpv\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop gpva)) \\<bind>\n                    (\\<lambda>x.\n                        case x of None \\<Rightarrow> Fail\n                        | Some x' \\<Rightarrow>\n                            Done (x, merge_exception_converter))) \\<or>\n                gpv = gpv')))\n        (the_gpv\n          (inline run_converter\n            (map_gpv' id id option_of_exception (gpv_stop (left_gpv gpva)))\n            merge_exception_converter \\<bind>\n           (\\<lambda>(x, conv').\n               case x of None \\<Rightarrow> Fail\n               | Some x' \\<Rightarrow> Done (x, conv'))))\n        (the_gpv\n          (left_gpv\n            (map_gpv' id id option_of_exception (gpv_stop gpva)) \\<bind>\n           (\\<lambda>x.\n               case x of None \\<Rightarrow> Fail\n               | Some x' \\<Rightarrow>\n                   Done (x, merge_exception_converter))))", "apply(simp add: bind_gpv.sel inline_sel map_bind_spmf bind_map_spmf del: bind_gpv_sel')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>gpva.\n       rel_spmf\n        (rel_generat (=) (=)\n          (rel_fun (=)\n            (\\<lambda>gpv gpv'.\n                (\\<exists>gpva.\n                    gpv =\n                    inline run_converter\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop (left_gpv gpva)))\n                     merge_exception_converter \\<bind>\n                    (\\<lambda>(x, conv').\n                        case x of None \\<Rightarrow> Fail\n                        | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                    gpv' =\n                    left_gpv\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop gpva)) \\<bind>\n                    (\\<lambda>x.\n                        case x of None \\<Rightarrow> Fail\n                        | Some x' \\<Rightarrow>\n                            Done (x, merge_exception_converter))) \\<or>\n                gpv = gpv')))\n        (inline1 run_converter\n          (map_gpv' id id option_of_exception (gpv_stop (left_gpv gpva)))\n          merge_exception_converter \\<bind>\n         map_spmf\n          (map_generat id id\n            ((\\<circ>)\n              (case_sum id\n                (\\<lambda>r.\n                    r \\<bind>\n                    (\\<lambda>(x, conv').\n                        case x of None \\<Rightarrow> Fail\n                        | Some x' \\<Rightarrow> Done (x, conv')))))) \\<circ>\n         (case_generat\n           (\\<lambda>x.\n               map_spmf (map_generat id id ((\\<circ>) Inl))\n                (the_gpv\n                  (case x of\n                   (x, conv') \\<Rightarrow>\n                     case x of None \\<Rightarrow> Fail\n                     | Some x' \\<Rightarrow> Done (x, conv'))))\n           (\\<lambda>out c.\n               return_spmf (IO out (\\<lambda>input. Inr (c input)))) \\<circ>\n          case_sum Pure\n           (\\<lambda>(out, oracle, rpv).\n               IO out\n                (\\<lambda>input.\n                    oracle input \\<bind>\n                    (\\<lambda>(x, y). inline run_converter (rpv x) y)))))\n        (the_gpv gpva \\<bind>\n         map_spmf\n          (map_generat id id\n            ((\\<circ>)\n              (case_sum id\n                (\\<lambda>r.\n                    r \\<bind>\n                    (\\<lambda>x.\n                        case x of None \\<Rightarrow> Fail\n                        | Some x' \\<Rightarrow>\n                            Done (x, merge_exception_converter)))))) \\<circ>\n         (case_generat\n           (\\<lambda>x.\n               map_spmf (map_generat id id ((\\<circ>) Inl))\n                (the_gpv\n                  (case x of None \\<Rightarrow> Fail\n                   | Some x' \\<Rightarrow>\n                       Done (x, merge_exception_converter))))\n           (\\<lambda>out c.\n               return_spmf (IO out (\\<lambda>input. Inr (c input)))) \\<circ>\n          map_generat id Inl left_rpv \\<circ>\n          map_generat id id\n           (map_fun option_of_exception\n             (map_gpv' id id option_of_exception)) \\<circ>\n          map_generat Some id\n           (\\<lambda>rpv.\n               case_option (Done None)\n                (\\<lambda>input'. gpv_stop (rpv input')))))", "apply(subst inline1_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>gpva.\n       rel_spmf\n        (rel_generat (=) (=)\n          (rel_fun (=)\n            (\\<lambda>gpv gpv'.\n                (\\<exists>gpva.\n                    gpv =\n                    inline run_converter\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop (left_gpv gpva)))\n                     merge_exception_converter \\<bind>\n                    (\\<lambda>(x, conv').\n                        case x of None \\<Rightarrow> Fail\n                        | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                    gpv' =\n                    left_gpv\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop gpva)) \\<bind>\n                    (\\<lambda>x.\n                        case x of None \\<Rightarrow> Fail\n                        | Some x' \\<Rightarrow>\n                            Done (x, merge_exception_converter))) \\<or>\n                gpv = gpv')))\n        (the_gpv\n          (map_gpv' id id option_of_exception\n            (gpv_stop (left_gpv gpva))) \\<bind>\n         case_generat\n          (\\<lambda>x. return_spmf (Inl (x, merge_exception_converter)))\n          (\\<lambda>out rpv.\n              the_gpv (run_converter merge_exception_converter out) \\<bind>\n              case_generat\n               (\\<lambda>(x, y). inline1 run_converter (rpv x) y)\n               (\\<lambda>out rpv'.\n                   return_spmf (Inr (out, rpv', rpv)))) \\<bind>\n         map_spmf\n          (map_generat id id\n            ((\\<circ>)\n              (case_sum id\n                (\\<lambda>r.\n                    r \\<bind>\n                    (\\<lambda>(x, conv').\n                        case x of None \\<Rightarrow> Fail\n                        | Some x' \\<Rightarrow> Done (x, conv')))))) \\<circ>\n         (case_generat\n           (\\<lambda>x.\n               map_spmf (map_generat id id ((\\<circ>) Inl))\n                (the_gpv\n                  (case x of\n                   (x, conv') \\<Rightarrow>\n                     case x of None \\<Rightarrow> Fail\n                     | Some x' \\<Rightarrow> Done (x, conv'))))\n           (\\<lambda>out c.\n               return_spmf (IO out (\\<lambda>input. Inr (c input)))) \\<circ>\n          case_sum Pure\n           (\\<lambda>(out, oracle, rpv).\n               IO out\n                (\\<lambda>input.\n                    oracle input \\<bind>\n                    (\\<lambda>(x, y). inline run_converter (rpv x) y)))))\n        (the_gpv gpva \\<bind>\n         map_spmf\n          (map_generat id id\n            ((\\<circ>)\n              (case_sum id\n                (\\<lambda>r.\n                    r \\<bind>\n                    (\\<lambda>x.\n                        case x of None \\<Rightarrow> Fail\n                        | Some x' \\<Rightarrow>\n                            Done (x, merge_exception_converter)))))) \\<circ>\n         (case_generat\n           (\\<lambda>x.\n               map_spmf (map_generat id id ((\\<circ>) Inl))\n                (the_gpv\n                  (case x of None \\<Rightarrow> Fail\n                   | Some x' \\<Rightarrow>\n                       Done (x, merge_exception_converter))))\n           (\\<lambda>out c.\n               return_spmf (IO out (\\<lambda>input. Inr (c input)))) \\<circ>\n          map_generat id Inl left_rpv \\<circ>\n          map_generat id id\n           (map_fun option_of_exception\n             (map_gpv' id id option_of_exception)) \\<circ>\n          map_generat Some id\n           (\\<lambda>rpv.\n               case_option (Done None)\n                (\\<lambda>input'. gpv_stop (rpv input')))))", "apply(clarsimp simp add: bind_map_spmf intro!: rel_spmf_bind_reflI simp add: generat.map_comp case_map_generat o_def split!: generat.split intro!: rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>gpva out' c' y.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpva);\n        (case case merge_exception y of\n              Fault \\<Rightarrow> (Fault, const_converter Fault)\n              | OK y' \\<Rightarrow> (OK y', merge_exception_converter) of\n         (x, xa) \\<Rightarrow>\n           inline run_converter\n            (map_gpv' id id option_of_exception\n              (case x of Fault \\<Rightarrow> Done None\n               | OK input' \\<Rightarrow> gpv_stop (left_rpv c' input')))\n            xa) \\<bind>\n        (\\<lambda>(x, conv').\n            case x of None \\<Rightarrow> Fail\n            | Some x' \\<Rightarrow> Done (x, conv')) \\<noteq>\n        left_rpv\n         (\\<lambda>input'.\n             map_gpv' id id option_of_exception\n              (case input' of Fault \\<Rightarrow> Done None\n               | OK input' \\<Rightarrow> gpv_stop (c' input')))\n         y \\<bind>\n        (\\<lambda>x.\n            case x of None \\<Rightarrow> Fail\n            | Some x' \\<Rightarrow>\n                Done (x, merge_exception_converter))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gpv.\n                            (case case merge_exception y of\n                                  Fault \\<Rightarrow>\n                                    (Fault, const_converter Fault)\n                                  | OK y' \\<Rightarrow>\n(OK y', merge_exception_converter) of\n                             (x, xa) \\<Rightarrow>\n                               inline run_converter\n                                (map_gpv' id id option_of_exception\n                                  (case x of Fault \\<Rightarrow> Done None\n                                   | OK input' \\<Rightarrow>\n gpv_stop (left_rpv c' input')))\n                                xa) \\<bind>\n                            (\\<lambda>(x, conv').\n                                case x of None \\<Rightarrow> Fail\n                                | Some x' \\<Rightarrow> Done (x, conv')) =\n                            inline run_converter\n                             (map_gpv' id id option_of_exception\n                               (gpv_stop (left_gpv gpv)))\n                             merge_exception_converter \\<bind>\n                            (\\<lambda>(x, conv').\n                                case x of None \\<Rightarrow> Fail\n                                | Some x' \\<Rightarrow>\n                                    Done (x, conv')) \\<and>\n                            left_rpv\n                             (\\<lambda>input'.\n                                 map_gpv' id id option_of_exception\n                                  (case input' of\n                                   Fault \\<Rightarrow> Done None\n                                   | OK input' \\<Rightarrow>\n gpv_stop (c' input')))\n                             y \\<bind>\n                            (\\<lambda>x.\n                                case x of None \\<Rightarrow> Fail\n                                | Some x' \\<Rightarrow>\n                                    Done (x, merge_exception_converter)) =\n                            left_gpv\n                             (map_gpv' id id option_of_exception\n                               (gpv_stop gpv)) \\<bind>\n                            (\\<lambda>x.\n                                case x of None \\<Rightarrow> Fail\n                                | Some x' \\<Rightarrow>\n                                    Done (x, merge_exception_converter))", "subgoal for gpv out c input"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IO out c \\<in> set_spmf (the_gpv gpv);\n     (case case merge_exception input of\n           Fault \\<Rightarrow> (Fault, const_converter Fault)\n           | OK y' \\<Rightarrow> (OK y', merge_exception_converter) of\n      (x, xa) \\<Rightarrow>\n        inline run_converter\n         (map_gpv' id id option_of_exception\n           (case x of Fault \\<Rightarrow> Done None\n            | OK input' \\<Rightarrow> gpv_stop (left_rpv c input')))\n         xa) \\<bind>\n     (\\<lambda>(x, conv').\n         case x of None \\<Rightarrow> Fail\n         | Some x' \\<Rightarrow> Done (x, conv')) \\<noteq>\n     left_rpv\n      (\\<lambda>input'.\n          map_gpv' id id option_of_exception\n           (case input' of Fault \\<Rightarrow> Done None\n            | OK input' \\<Rightarrow> gpv_stop (c input')))\n      input \\<bind>\n     (\\<lambda>x.\n         case x of None \\<Rightarrow> Fail\n         | Some x' \\<Rightarrow>\n             Done (x, merge_exception_converter))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gpv.\n                         (case case merge_exception input of\n                               Fault \\<Rightarrow>\n                                 (Fault, const_converter Fault)\n                               | OK y' \\<Rightarrow>\n                                   (OK y', merge_exception_converter) of\n                          (x, xa) \\<Rightarrow>\n                            inline run_converter\n                             (map_gpv' id id option_of_exception\n                               (case x of Fault \\<Rightarrow> Done None\n                                | OK input' \\<Rightarrow>\n                                    gpv_stop (left_rpv c input')))\n                             xa) \\<bind>\n                         (\\<lambda>(x, conv').\n                             case x of None \\<Rightarrow> Fail\n                             | Some x' \\<Rightarrow> Done (x, conv')) =\n                         inline run_converter\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop (left_gpv gpv)))\n                          merge_exception_converter \\<bind>\n                         (\\<lambda>(x, conv').\n                             case x of None \\<Rightarrow> Fail\n                             | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                         left_rpv\n                          (\\<lambda>input'.\n                              map_gpv' id id option_of_exception\n                               (case input' of Fault \\<Rightarrow> Done None\n                                | OK input' \\<Rightarrow>\n                                    gpv_stop (c input')))\n                          input \\<bind>\n                         (\\<lambda>x.\n                             case x of None \\<Rightarrow> Fail\n                             | Some x' \\<Rightarrow>\n                                 Done (x, merge_exception_converter)) =\n                         left_gpv\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop gpv)) \\<bind>\n                         (\\<lambda>x.\n                             case x of None \\<Rightarrow> Fail\n                             | Some x' \\<Rightarrow>\n                                 Done (x, merge_exception_converter))", "by(cases input; auto split!: exception.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inline_right_gpv_merge_exception_converter:\n  \"bind_gpv (inline run_converter (map_gpv' id id option_of_exception (gpv_stop (right_gpv gpv))) merge_exception_converter) (\\<lambda>(x, conv'). case x of None \\<Rightarrow> Fail | Some x' \\<Rightarrow> Done (x, conv')) =\n   bind_gpv (right_gpv (map_gpv' id id option_of_exception (gpv_stop gpv))) (\\<lambda>x. case x of None \\<Rightarrow> Fail | Some x' \\<Rightarrow> Done (x, merge_exception_converter))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inline run_converter\n     (map_gpv' id id option_of_exception (gpv_stop (right_gpv gpv)))\n     merge_exception_converter \\<bind>\n    (\\<lambda>(x, conv').\n        case x of None \\<Rightarrow> Fail\n        | Some x' \\<Rightarrow> Done (x, conv')) =\n    right_gpv (map_gpv' id id option_of_exception (gpv_stop gpv)) \\<bind>\n    (\\<lambda>x.\n        case x of None \\<Rightarrow> Fail\n        | Some x' \\<Rightarrow> Done (x, merge_exception_converter))", "apply(coinduction arbitrary: gpv rule: gpv.coinduct_strong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>gpva.\n       rel_spmf\n        (rel_generat (=) (=)\n          (rel_fun (=)\n            (\\<lambda>gpv gpv'.\n                (\\<exists>gpva.\n                    gpv =\n                    inline run_converter\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop (right_gpv gpva)))\n                     merge_exception_converter \\<bind>\n                    (\\<lambda>(x, conv').\n                        case x of None \\<Rightarrow> Fail\n                        | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                    gpv' =\n                    right_gpv\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop gpva)) \\<bind>\n                    (\\<lambda>x.\n                        case x of None \\<Rightarrow> Fail\n                        | Some x' \\<Rightarrow>\n                            Done (x, merge_exception_converter))) \\<or>\n                gpv = gpv')))\n        (the_gpv\n          (inline run_converter\n            (map_gpv' id id option_of_exception (gpv_stop (right_gpv gpva)))\n            merge_exception_converter \\<bind>\n           (\\<lambda>(x, conv').\n               case x of None \\<Rightarrow> Fail\n               | Some x' \\<Rightarrow> Done (x, conv'))))\n        (the_gpv\n          (right_gpv\n            (map_gpv' id id option_of_exception (gpv_stop gpva)) \\<bind>\n           (\\<lambda>x.\n               case x of None \\<Rightarrow> Fail\n               | Some x' \\<Rightarrow>\n                   Done (x, merge_exception_converter))))", "apply(simp add: bind_gpv.sel inline_sel map_bind_spmf bind_map_spmf del: bind_gpv_sel')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>gpva.\n       rel_spmf\n        (rel_generat (=) (=)\n          (rel_fun (=)\n            (\\<lambda>gpv gpv'.\n                (\\<exists>gpva.\n                    gpv =\n                    inline run_converter\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop (right_gpv gpva)))\n                     merge_exception_converter \\<bind>\n                    (\\<lambda>(x, conv').\n                        case x of None \\<Rightarrow> Fail\n                        | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                    gpv' =\n                    right_gpv\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop gpva)) \\<bind>\n                    (\\<lambda>x.\n                        case x of None \\<Rightarrow> Fail\n                        | Some x' \\<Rightarrow>\n                            Done (x, merge_exception_converter))) \\<or>\n                gpv = gpv')))\n        (inline1 run_converter\n          (map_gpv' id id option_of_exception (gpv_stop (right_gpv gpva)))\n          merge_exception_converter \\<bind>\n         map_spmf\n          (map_generat id id\n            ((\\<circ>)\n              (case_sum id\n                (\\<lambda>r.\n                    r \\<bind>\n                    (\\<lambda>(x, conv').\n                        case x of None \\<Rightarrow> Fail\n                        | Some x' \\<Rightarrow> Done (x, conv')))))) \\<circ>\n         (case_generat\n           (\\<lambda>x.\n               map_spmf (map_generat id id ((\\<circ>) Inl))\n                (the_gpv\n                  (case x of\n                   (x, conv') \\<Rightarrow>\n                     case x of None \\<Rightarrow> Fail\n                     | Some x' \\<Rightarrow> Done (x, conv'))))\n           (\\<lambda>out c.\n               return_spmf (IO out (\\<lambda>input. Inr (c input)))) \\<circ>\n          case_sum Pure\n           (\\<lambda>(out, oracle, rpv).\n               IO out\n                (\\<lambda>input.\n                    oracle input \\<bind>\n                    (\\<lambda>(x, y). inline run_converter (rpv x) y)))))\n        (the_gpv gpva \\<bind>\n         map_spmf\n          (map_generat id id\n            ((\\<circ>)\n              (case_sum id\n                (\\<lambda>r.\n                    r \\<bind>\n                    (\\<lambda>x.\n                        case x of None \\<Rightarrow> Fail\n                        | Some x' \\<Rightarrow>\n                            Done (x, merge_exception_converter)))))) \\<circ>\n         (case_generat\n           (\\<lambda>x.\n               map_spmf (map_generat id id ((\\<circ>) Inl))\n                (the_gpv\n                  (case x of None \\<Rightarrow> Fail\n                   | Some x' \\<Rightarrow>\n                       Done (x, merge_exception_converter))))\n           (\\<lambda>out c.\n               return_spmf (IO out (\\<lambda>input. Inr (c input)))) \\<circ>\n          map_generat id Inr right_rpv \\<circ>\n          map_generat id id\n           (map_fun option_of_exception\n             (map_gpv' id id option_of_exception)) \\<circ>\n          map_generat Some id\n           (\\<lambda>rpv.\n               case_option (Done None)\n                (\\<lambda>input'. gpv_stop (rpv input')))))", "apply(subst inline1_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>gpva.\n       rel_spmf\n        (rel_generat (=) (=)\n          (rel_fun (=)\n            (\\<lambda>gpv gpv'.\n                (\\<exists>gpva.\n                    gpv =\n                    inline run_converter\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop (right_gpv gpva)))\n                     merge_exception_converter \\<bind>\n                    (\\<lambda>(x, conv').\n                        case x of None \\<Rightarrow> Fail\n                        | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                    gpv' =\n                    right_gpv\n                     (map_gpv' id id option_of_exception\n                       (gpv_stop gpva)) \\<bind>\n                    (\\<lambda>x.\n                        case x of None \\<Rightarrow> Fail\n                        | Some x' \\<Rightarrow>\n                            Done (x, merge_exception_converter))) \\<or>\n                gpv = gpv')))\n        (the_gpv\n          (map_gpv' id id option_of_exception\n            (gpv_stop (right_gpv gpva))) \\<bind>\n         case_generat\n          (\\<lambda>x. return_spmf (Inl (x, merge_exception_converter)))\n          (\\<lambda>out rpv.\n              the_gpv (run_converter merge_exception_converter out) \\<bind>\n              case_generat\n               (\\<lambda>(x, y). inline1 run_converter (rpv x) y)\n               (\\<lambda>out rpv'.\n                   return_spmf (Inr (out, rpv', rpv)))) \\<bind>\n         map_spmf\n          (map_generat id id\n            ((\\<circ>)\n              (case_sum id\n                (\\<lambda>r.\n                    r \\<bind>\n                    (\\<lambda>(x, conv').\n                        case x of None \\<Rightarrow> Fail\n                        | Some x' \\<Rightarrow> Done (x, conv')))))) \\<circ>\n         (case_generat\n           (\\<lambda>x.\n               map_spmf (map_generat id id ((\\<circ>) Inl))\n                (the_gpv\n                  (case x of\n                   (x, conv') \\<Rightarrow>\n                     case x of None \\<Rightarrow> Fail\n                     | Some x' \\<Rightarrow> Done (x, conv'))))\n           (\\<lambda>out c.\n               return_spmf (IO out (\\<lambda>input. Inr (c input)))) \\<circ>\n          case_sum Pure\n           (\\<lambda>(out, oracle, rpv).\n               IO out\n                (\\<lambda>input.\n                    oracle input \\<bind>\n                    (\\<lambda>(x, y). inline run_converter (rpv x) y)))))\n        (the_gpv gpva \\<bind>\n         map_spmf\n          (map_generat id id\n            ((\\<circ>)\n              (case_sum id\n                (\\<lambda>r.\n                    r \\<bind>\n                    (\\<lambda>x.\n                        case x of None \\<Rightarrow> Fail\n                        | Some x' \\<Rightarrow>\n                            Done (x, merge_exception_converter)))))) \\<circ>\n         (case_generat\n           (\\<lambda>x.\n               map_spmf (map_generat id id ((\\<circ>) Inl))\n                (the_gpv\n                  (case x of None \\<Rightarrow> Fail\n                   | Some x' \\<Rightarrow>\n                       Done (x, merge_exception_converter))))\n           (\\<lambda>out c.\n               return_spmf (IO out (\\<lambda>input. Inr (c input)))) \\<circ>\n          map_generat id Inr right_rpv \\<circ>\n          map_generat id id\n           (map_fun option_of_exception\n             (map_gpv' id id option_of_exception)) \\<circ>\n          map_generat Some id\n           (\\<lambda>rpv.\n               case_option (Done None)\n                (\\<lambda>input'. gpv_stop (rpv input')))))", "apply(clarsimp simp add: bind_map_spmf intro!: rel_spmf_bind_reflI simp add: generat.map_comp case_map_generat o_def split!: generat.split intro!: rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>gpva out' c' y.\n       \\<lbrakk>IO out' c' \\<in> set_spmf (the_gpv gpva);\n        (case case merge_exception y of\n              Fault \\<Rightarrow> (Fault, const_converter Fault)\n              | OK y' \\<Rightarrow> (OK y', merge_exception_converter) of\n         (x, xa) \\<Rightarrow>\n           inline run_converter\n            (map_gpv' id id option_of_exception\n              (case x of Fault \\<Rightarrow> Done None\n               | OK input' \\<Rightarrow> gpv_stop (right_rpv c' input')))\n            xa) \\<bind>\n        (\\<lambda>(x, conv').\n            case x of None \\<Rightarrow> Fail\n            | Some x' \\<Rightarrow> Done (x, conv')) \\<noteq>\n        right_rpv\n         (\\<lambda>input'.\n             map_gpv' id id option_of_exception\n              (case input' of Fault \\<Rightarrow> Done None\n               | OK input' \\<Rightarrow> gpv_stop (c' input')))\n         y \\<bind>\n        (\\<lambda>x.\n            case x of None \\<Rightarrow> Fail\n            | Some x' \\<Rightarrow>\n                Done (x, merge_exception_converter))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gpv.\n                            (case case merge_exception y of\n                                  Fault \\<Rightarrow>\n                                    (Fault, const_converter Fault)\n                                  | OK y' \\<Rightarrow>\n(OK y', merge_exception_converter) of\n                             (x, xa) \\<Rightarrow>\n                               inline run_converter\n                                (map_gpv' id id option_of_exception\n                                  (case x of Fault \\<Rightarrow> Done None\n                                   | OK input' \\<Rightarrow>\n gpv_stop (right_rpv c' input')))\n                                xa) \\<bind>\n                            (\\<lambda>(x, conv').\n                                case x of None \\<Rightarrow> Fail\n                                | Some x' \\<Rightarrow> Done (x, conv')) =\n                            inline run_converter\n                             (map_gpv' id id option_of_exception\n                               (gpv_stop (right_gpv gpv)))\n                             merge_exception_converter \\<bind>\n                            (\\<lambda>(x, conv').\n                                case x of None \\<Rightarrow> Fail\n                                | Some x' \\<Rightarrow>\n                                    Done (x, conv')) \\<and>\n                            right_rpv\n                             (\\<lambda>input'.\n                                 map_gpv' id id option_of_exception\n                                  (case input' of\n                                   Fault \\<Rightarrow> Done None\n                                   | OK input' \\<Rightarrow>\n gpv_stop (c' input')))\n                             y \\<bind>\n                            (\\<lambda>x.\n                                case x of None \\<Rightarrow> Fail\n                                | Some x' \\<Rightarrow>\n                                    Done (x, merge_exception_converter)) =\n                            right_gpv\n                             (map_gpv' id id option_of_exception\n                               (gpv_stop gpv)) \\<bind>\n                            (\\<lambda>x.\n                                case x of None \\<Rightarrow> Fail\n                                | Some x' \\<Rightarrow>\n                                    Done (x, merge_exception_converter))", "subgoal for gpv out c input"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>IO out c \\<in> set_spmf (the_gpv gpv);\n     (case case merge_exception input of\n           Fault \\<Rightarrow> (Fault, const_converter Fault)\n           | OK y' \\<Rightarrow> (OK y', merge_exception_converter) of\n      (x, xa) \\<Rightarrow>\n        inline run_converter\n         (map_gpv' id id option_of_exception\n           (case x of Fault \\<Rightarrow> Done None\n            | OK input' \\<Rightarrow> gpv_stop (right_rpv c input')))\n         xa) \\<bind>\n     (\\<lambda>(x, conv').\n         case x of None \\<Rightarrow> Fail\n         | Some x' \\<Rightarrow> Done (x, conv')) \\<noteq>\n     right_rpv\n      (\\<lambda>input'.\n          map_gpv' id id option_of_exception\n           (case input' of Fault \\<Rightarrow> Done None\n            | OK input' \\<Rightarrow> gpv_stop (c input')))\n      input \\<bind>\n     (\\<lambda>x.\n         case x of None \\<Rightarrow> Fail\n         | Some x' \\<Rightarrow>\n             Done (x, merge_exception_converter))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gpv.\n                         (case case merge_exception input of\n                               Fault \\<Rightarrow>\n                                 (Fault, const_converter Fault)\n                               | OK y' \\<Rightarrow>\n                                   (OK y', merge_exception_converter) of\n                          (x, xa) \\<Rightarrow>\n                            inline run_converter\n                             (map_gpv' id id option_of_exception\n                               (case x of Fault \\<Rightarrow> Done None\n                                | OK input' \\<Rightarrow>\n                                    gpv_stop (right_rpv c input')))\n                             xa) \\<bind>\n                         (\\<lambda>(x, conv').\n                             case x of None \\<Rightarrow> Fail\n                             | Some x' \\<Rightarrow> Done (x, conv')) =\n                         inline run_converter\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop (right_gpv gpv)))\n                          merge_exception_converter \\<bind>\n                         (\\<lambda>(x, conv').\n                             case x of None \\<Rightarrow> Fail\n                             | Some x' \\<Rightarrow> Done (x, conv')) \\<and>\n                         right_rpv\n                          (\\<lambda>input'.\n                              map_gpv' id id option_of_exception\n                               (case input' of Fault \\<Rightarrow> Done None\n                                | OK input' \\<Rightarrow>\n                                    gpv_stop (c input')))\n                          input \\<bind>\n                         (\\<lambda>x.\n                             case x of None \\<Rightarrow> Fail\n                             | Some x' \\<Rightarrow>\n                                 Done (x, merge_exception_converter)) =\n                         right_gpv\n                          (map_gpv' id id option_of_exception\n                            (gpv_stop gpv)) \\<bind>\n                         (\\<lambda>x.\n                             case x of None \\<Rightarrow> Fail\n                             | Some x' \\<Rightarrow>\n                                 Done (x, merge_exception_converter))", "by(cases input; auto split!: exception.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>@{theory Constructive_Cryptography.Wiring}\\<close>"], ["", "abbreviation (input) \n  id_wiring :: \"('a, 'b, 'a, 'b) wiring\" (\"1\\<^sub>w\")\n  where\n    \"id_wiring \\<equiv> (id, id)\""], ["", "definition \n  swap_lassocr\\<^sub>w :: \"('a + 'b + 'c, 'd + 'e + 'f, 'b + 'a + 'c, 'e + 'd + 'f) wiring\" \n  where\n    \"swap_lassocr\\<^sub>w \\<equiv> rassocl\\<^sub>w \\<circ>\\<^sub>w ((swap\\<^sub>w |\\<^sub>w 1\\<^sub>w) \\<circ>\\<^sub>w lassocr\\<^sub>w)\""], ["", "schematic_goal \n  wiring_swap_lassocr[wiring_intro]: \"wiring ?\\<I>1 ?\\<I>2 swap_lassocr swap_lassocr\\<^sub>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wiring ?\\<I>1 ?\\<I>2 swap_lassocr swap_lassocr\\<^sub>w", "unfolding swap_lassocr_def swap_lassocr\\<^sub>w_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wiring ?\\<I>1 ?\\<I>2\n     (rassocl\\<^sub>C \\<odot>\n      (swap\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot> lassocr\\<^sub>C)\n     (rassocl\\<^sub>w \\<circ>\\<^sub>w\n      (swap\\<^sub>w |\\<^sub>w (id, id) \\<circ>\\<^sub>w lassocr\\<^sub>w))", "by(rule wiring_intro)+"], ["", "definition \n  parallel_wiring\\<^sub>w :: \"(('a + 'b) + ('c + 'd), ('e + 'f) + ('g + 'h),\n   ('a + 'c) + ('b + 'd), ('e + 'g) + ('f + 'h)) wiring\" \n  where\n    \"parallel_wiring\\<^sub>w \\<equiv> lassocr\\<^sub>w \\<circ>\\<^sub>w ((1\\<^sub>w |\\<^sub>w swap_lassocr\\<^sub>w) \\<circ>\\<^sub>w rassocl\\<^sub>w)\""], ["", "schematic_goal \n  wiring_parallel_wiring[wiring_intro]: \"wiring ?\\<I>1 ?\\<I>2 parallel_wiring parallel_wiring\\<^sub>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wiring ?\\<I>1 ?\\<I>2 parallel_wiring parallel_wiring\\<^sub>w", "unfolding parallel_wiring_def parallel_wiring\\<^sub>w_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wiring ?\\<I>1 ?\\<I>2\n     (lassocr\\<^sub>C \\<odot>\n      (1\\<^sub>C |\\<^sub>= swap_lassocr) \\<odot> rassocl\\<^sub>C)\n     (lassocr\\<^sub>w \\<circ>\\<^sub>w\n      ((id, id) |\\<^sub>w swap_lassocr\\<^sub>w \\<circ>\\<^sub>w\n       rassocl\\<^sub>w))", "by(rule wiring_intro)+"], ["", "lemma lassocr_inverse: \"rassocl\\<^sub>C \\<odot> lassocr\\<^sub>C = 1\\<^sub>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rassocl\\<^sub>C \\<odot> lassocr\\<^sub>C = 1\\<^sub>C", "unfolding rassocl\\<^sub>C_def lassocr\\<^sub>C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter lsumr rsuml id id 1\\<^sub>C \\<odot>\n    map_converter rsuml lsumr id id 1\\<^sub>C =\n    1\\<^sub>C", "apply(simp add: comp_converter_map1_out comp_converter_map_converter2 comp_converter_id_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter lsumr rsuml rsuml lsumr 1\\<^sub>C = 1\\<^sub>C", "apply(subst map_converter_id_move_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter id id (rsuml \\<circ> lsumr) (rsuml \\<circ> lsumr)\n     1\\<^sub>C =\n    1\\<^sub>C", "apply(simp add: o_def id_def[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rassocl_inverse: \"lassocr\\<^sub>C \\<odot> rassocl\\<^sub>C = 1\\<^sub>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lassocr\\<^sub>C \\<odot> rassocl\\<^sub>C = 1\\<^sub>C", "unfolding rassocl\\<^sub>C_def lassocr\\<^sub>C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter rsuml lsumr id id 1\\<^sub>C \\<odot>\n    map_converter lsumr rsuml id id 1\\<^sub>C =\n    1\\<^sub>C", "apply(simp add: comp_converter_map1_out comp_converter_map_converter2 comp_converter_id_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter rsuml lsumr lsumr rsuml 1\\<^sub>C = 1\\<^sub>C", "apply(subst map_converter_id_move_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter id id (lsumr \\<circ> rsuml) (lsumr \\<circ> rsuml)\n     1\\<^sub>C =\n    1\\<^sub>C", "apply(simp add: o_def id_def[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma swap_sum_swap_sum [simp]: \"swap_sum (swap_sum x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap_sum (swap_sum x) = x", "by(cases x) simp_all"], ["", "lemma inj_on_lsumr [simp]: \"inj_on lsumr A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on lsumr A", "by(auto simp add: inj_on_def elim: lsumr.elims)"], ["", "lemma inj_on_rsuml [simp]: \"inj_on rsuml A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on rsuml A", "by(auto simp add: inj_on_def elim: rsuml.elims)"], ["", "lemma bij_lsumr [simp]: \"bij lsumr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij lsumr", "by(rule o_bij[where g=rsuml]) auto"], ["", "lemma bij_swap_sum [simp]: \"bij swap_sum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij swap_sum", "by(rule o_bij[where g=swap_sum]) auto"], ["", "lemma bij_rsuml [simp]: \"bij rsuml\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij rsuml", "by(rule o_bij[where g=lsumr]) auto"], ["", "lemma bij_lassocr_swap_sum [simp]: \"bij lassocr_swap_sum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij lassocr_swap_sum", "unfolding lassocr_swap_sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij (rsuml \\<circ> map_sum swap_sum id \\<circ> lsumr)", "by(simp add: bij_comp)"], ["", "lemma inj_lassocr_swap_sum [simp]: \"inj lassocr_swap_sum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj lassocr_swap_sum", "by(simp add: bij_is_inj)"], ["", "lemma inv_rsuml [simp]: \"inv_into UNIV rsuml = lsumr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv rsuml = lsumr", "by(rule inj_imp_inv_eq) auto"], ["", "lemma inv_lsumr [simp]: \"inv_into UNIV lsumr = rsuml\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv lsumr = rsuml", "by(rule inj_imp_inv_eq) auto"], ["", "lemma lassocr_swap_sum_inverse [simp]: \"lassocr_swap_sum (lassocr_swap_sum x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lassocr_swap_sum (lassocr_swap_sum x) = x", "by(simp add: lassocr_swap_sum_def sum.map_comp o_def id_def[symmetric] sum.map_id)"], ["", "lemma inv_lassocr_swap_sum [simp]: \"inv_into UNIV lassocr_swap_sum = lassocr_swap_sum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv lassocr_swap_sum = lassocr_swap_sum", "by(rule inj_imp_inv_eq)(simp_all add: sum.map_comp sum.inj_map bij_def surj_iff sum.map_id)"], ["", "lemma swap_inverse: \"swap\\<^sub>C \\<odot> swap\\<^sub>C = 1\\<^sub>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap\\<^sub>C \\<odot> swap\\<^sub>C = 1\\<^sub>C", "unfolding swap\\<^sub>C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter swap_sum swap_sum id id 1\\<^sub>C \\<odot>\n    map_converter swap_sum swap_sum id id 1\\<^sub>C =\n    1\\<^sub>C", "apply(simp add: comp_converter_map1_out comp_converter_map_converter2 comp_converter_id_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter swap_sum swap_sum swap_sum swap_sum 1\\<^sub>C = 1\\<^sub>C", "apply(subst map_converter_id_move_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter id id (swap_sum \\<circ> swap_sum)\n     (swap_sum \\<circ> swap_sum) 1\\<^sub>C =\n    1\\<^sub>C", "apply(simp add: o_def id_def[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma swap_lassocr_inverse: \"\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3), \\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C swap_lassocr \\<odot> swap_lassocr \\<sim> 1\\<^sub>C\"\n  (is \"?\\<I>,_ \\<turnstile>\\<^sub>C ?lhs \\<sim> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I>\n    (\\<I>2 \\<oplus>\\<^sub>\\<I>\n     \\<I>3),\\<I>1 \\<oplus>\\<^sub>\\<I>\n            (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C\n    swap_lassocr \\<odot> swap_lassocr \\<sim> 1\\<^sub>C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I>\n    (\\<I>2 \\<oplus>\\<^sub>\\<I>\n     \\<I>3),\\<I>1 \\<oplus>\\<^sub>\\<I>\n            (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C\n    swap_lassocr \\<odot> swap_lassocr \\<sim> 1\\<^sub>C", "have \"?lhs = (rassocl\\<^sub>C \\<odot> (swap\\<^sub>C |\\<^sub>= 1\\<^sub>C)) \\<odot> (lassocr\\<^sub>C \\<odot> rassocl\\<^sub>C) \\<odot> ((swap\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot> lassocr\\<^sub>C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap_lassocr \\<odot> swap_lassocr =\n    (rassocl\\<^sub>C \\<odot> (swap\\<^sub>C |\\<^sub>= 1\\<^sub>C)) \\<odot>\n    (lassocr\\<^sub>C \\<odot> rassocl\\<^sub>C) \\<odot>\n    (swap\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot> lassocr\\<^sub>C", "by(simp add: swap_lassocr_def comp_converter_assoc)"], ["proof (state)\nthis:\n  swap_lassocr \\<odot> swap_lassocr =\n  (rassocl\\<^sub>C \\<odot> (swap\\<^sub>C |\\<^sub>= 1\\<^sub>C)) \\<odot>\n  (lassocr\\<^sub>C \\<odot> rassocl\\<^sub>C) \\<odot>\n  (swap\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot> lassocr\\<^sub>C\n\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I>\n    (\\<I>2 \\<oplus>\\<^sub>\\<I>\n     \\<I>3),\\<I>1 \\<oplus>\\<^sub>\\<I>\n            (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C\n    swap_lassocr \\<odot> swap_lassocr \\<sim> 1\\<^sub>C", "also"], ["proof (state)\nthis:\n  swap_lassocr \\<odot> swap_lassocr =\n  (rassocl\\<^sub>C \\<odot> (swap\\<^sub>C |\\<^sub>= 1\\<^sub>C)) \\<odot>\n  (lassocr\\<^sub>C \\<odot> rassocl\\<^sub>C) \\<odot>\n  (swap\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot> lassocr\\<^sub>C\n\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I>\n    (\\<I>2 \\<oplus>\\<^sub>\\<I>\n     \\<I>3),\\<I>1 \\<oplus>\\<^sub>\\<I>\n            (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C\n    swap_lassocr \\<odot> swap_lassocr \\<sim> 1\\<^sub>C", "have \"\\<dots> = rassocl\\<^sub>C \\<odot> ((swap\\<^sub>C \\<odot> swap\\<^sub>C) |\\<^sub>= 1\\<^sub>C) \\<odot> lassocr\\<^sub>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rassocl\\<^sub>C \\<odot> (swap\\<^sub>C |\\<^sub>= 1\\<^sub>C)) \\<odot>\n    (lassocr\\<^sub>C \\<odot> rassocl\\<^sub>C) \\<odot>\n    (swap\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot> lassocr\\<^sub>C =\n    rassocl\\<^sub>C \\<odot>\n    (swap\\<^sub>C \\<odot> swap\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot>\n    lassocr\\<^sub>C", "unfolding rassocl_inverse comp_converter_id_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rassocl\\<^sub>C \\<odot> (swap\\<^sub>C |\\<^sub>= 1\\<^sub>C)) \\<odot>\n    (swap\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot> lassocr\\<^sub>C =\n    rassocl\\<^sub>C \\<odot>\n    (swap\\<^sub>C \\<odot> swap\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot>\n    lassocr\\<^sub>C", "by(simp add: parallel_converter2_comp1_out comp_converter_assoc)"], ["proof (state)\nthis:\n  (rassocl\\<^sub>C \\<odot> (swap\\<^sub>C |\\<^sub>= 1\\<^sub>C)) \\<odot>\n  (lassocr\\<^sub>C \\<odot> rassocl\\<^sub>C) \\<odot>\n  (swap\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot> lassocr\\<^sub>C =\n  rassocl\\<^sub>C \\<odot>\n  (swap\\<^sub>C \\<odot> swap\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot>\n  lassocr\\<^sub>C\n\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I>\n    (\\<I>2 \\<oplus>\\<^sub>\\<I>\n     \\<I>3),\\<I>1 \\<oplus>\\<^sub>\\<I>\n            (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C\n    swap_lassocr \\<odot> swap_lassocr \\<sim> 1\\<^sub>C", "also"], ["proof (state)\nthis:\n  (rassocl\\<^sub>C \\<odot> (swap\\<^sub>C |\\<^sub>= 1\\<^sub>C)) \\<odot>\n  (lassocr\\<^sub>C \\<odot> rassocl\\<^sub>C) \\<odot>\n  (swap\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot> lassocr\\<^sub>C =\n  rassocl\\<^sub>C \\<odot>\n  (swap\\<^sub>C \\<odot> swap\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot>\n  lassocr\\<^sub>C\n\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I>\n    (\\<I>2 \\<oplus>\\<^sub>\\<I>\n     \\<I>3),\\<I>1 \\<oplus>\\<^sub>\\<I>\n            (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C\n    swap_lassocr \\<odot> swap_lassocr \\<sim> 1\\<^sub>C", "have \"?\\<I>,?\\<I> \\<turnstile>\\<^sub>C \\<dots> \\<sim> rassocl\\<^sub>C \\<odot> 1\\<^sub>C \\<odot> lassocr\\<^sub>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I>\n    (\\<I>2 \\<oplus>\\<^sub>\\<I>\n     \\<I>3),\\<I>1 \\<oplus>\\<^sub>\\<I>\n            (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C\n    rassocl\\<^sub>C \\<odot>\n    (swap\\<^sub>C \\<odot> swap\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot>\n    lassocr\\<^sub>C \\<sim>\n    rassocl\\<^sub>C \\<odot> 1\\<^sub>C \\<odot> lassocr\\<^sub>C", "unfolding swap_inverse"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I>\n    (\\<I>2 \\<oplus>\\<^sub>\\<I>\n     \\<I>3),\\<I>1 \\<oplus>\\<^sub>\\<I>\n            (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C\n    rassocl\\<^sub>C \\<odot>\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot> lassocr\\<^sub>C \\<sim>\n    rassocl\\<^sub>C \\<odot> 1\\<^sub>C \\<odot> lassocr\\<^sub>C", "by(rule eq_\\<I>_converter_reflI eq_\\<I>_comp_cong WT_intro parallel_converter2_id_id)+"], ["proof (state)\nthis:\n  \\<I>1 \\<oplus>\\<^sub>\\<I>\n  (\\<I>2 \\<oplus>\\<^sub>\\<I>\n   \\<I>3),\\<I>1 \\<oplus>\\<^sub>\\<I>\n          (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C\n  rassocl\\<^sub>C \\<odot>\n  (swap\\<^sub>C \\<odot> swap\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot>\n  lassocr\\<^sub>C \\<sim>\n  rassocl\\<^sub>C \\<odot> 1\\<^sub>C \\<odot> lassocr\\<^sub>C\n\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I>\n    (\\<I>2 \\<oplus>\\<^sub>\\<I>\n     \\<I>3),\\<I>1 \\<oplus>\\<^sub>\\<I>\n            (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C\n    swap_lassocr \\<odot> swap_lassocr \\<sim> 1\\<^sub>C", "also"], ["proof (state)\nthis:\n  \\<I>1 \\<oplus>\\<^sub>\\<I>\n  (\\<I>2 \\<oplus>\\<^sub>\\<I>\n   \\<I>3),\\<I>1 \\<oplus>\\<^sub>\\<I>\n          (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C\n  rassocl\\<^sub>C \\<odot>\n  (swap\\<^sub>C \\<odot> swap\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot>\n  lassocr\\<^sub>C \\<sim>\n  rassocl\\<^sub>C \\<odot> 1\\<^sub>C \\<odot> lassocr\\<^sub>C\n\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I>\n    (\\<I>2 \\<oplus>\\<^sub>\\<I>\n     \\<I>3),\\<I>1 \\<oplus>\\<^sub>\\<I>\n            (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C\n    swap_lassocr \\<odot> swap_lassocr \\<sim> 1\\<^sub>C", "have \"rassocl\\<^sub>C \\<odot> 1\\<^sub>C \\<odot> lassocr\\<^sub>C = 1\\<^sub>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rassocl\\<^sub>C \\<odot> 1\\<^sub>C \\<odot> lassocr\\<^sub>C = 1\\<^sub>C", "by(simp add: comp_converter_id_left lassocr_inverse)"], ["proof (state)\nthis:\n  rassocl\\<^sub>C \\<odot> 1\\<^sub>C \\<odot> lassocr\\<^sub>C = 1\\<^sub>C\n\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I>\n    (\\<I>2 \\<oplus>\\<^sub>\\<I>\n     \\<I>3),\\<I>1 \\<oplus>\\<^sub>\\<I>\n            (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C\n    swap_lassocr \\<odot> swap_lassocr \\<sim> 1\\<^sub>C", "finally"], ["proof (chain)\npicking this:\n  \\<I>1 \\<oplus>\\<^sub>\\<I>\n  (\\<I>2 \\<oplus>\\<^sub>\\<I>\n   \\<I>3),\\<I>1 \\<oplus>\\<^sub>\\<I>\n          (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C\n  swap_lassocr \\<odot> swap_lassocr \\<sim> 1\\<^sub>C", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<I>1 \\<oplus>\\<^sub>\\<I>\n  (\\<I>2 \\<oplus>\\<^sub>\\<I>\n   \\<I>3),\\<I>1 \\<oplus>\\<^sub>\\<I>\n          (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C\n  swap_lassocr \\<odot> swap_lassocr \\<sim> 1\\<^sub>C\n\ngoal (1 subgoal):\n 1. \\<I>1 \\<oplus>\\<^sub>\\<I>\n    (\\<I>2 \\<oplus>\\<^sub>\\<I>\n     \\<I>3),\\<I>1 \\<oplus>\\<^sub>\\<I>\n            (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C\n    swap_lassocr \\<odot> swap_lassocr \\<sim> 1\\<^sub>C", "."], ["proof (state)\nthis:\n  \\<I>1 \\<oplus>\\<^sub>\\<I>\n  (\\<I>2 \\<oplus>\\<^sub>\\<I>\n   \\<I>3),\\<I>1 \\<oplus>\\<^sub>\\<I>\n          (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<turnstile>\\<^sub>C\n  swap_lassocr \\<odot> swap_lassocr \\<sim> 1\\<^sub>C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma parallel_wiring_inverse:\n  \"(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4),(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C parallel_wiring \\<odot> parallel_wiring \\<sim> 1\\<^sub>C\"\n  (is \"?\\<I>, _ \\<turnstile>\\<^sub>C ?lhs \\<sim> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n    (\\<I>3 \\<oplus>\\<^sub>\\<I>\n     \\<I>4),(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n            (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C\n    parallel_wiring \\<odot> parallel_wiring \\<sim> 1\\<^sub>C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n    (\\<I>3 \\<oplus>\\<^sub>\\<I>\n     \\<I>4),(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n            (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C\n    parallel_wiring \\<odot> parallel_wiring \\<sim> 1\\<^sub>C", "have \"?lhs = (lassocr\\<^sub>C \\<odot> (1\\<^sub>C |\\<^sub>= swap_lassocr)) \\<odot> (rassocl\\<^sub>C \\<odot> lassocr\\<^sub>C) \\<odot> ((1\\<^sub>C |\\<^sub>= swap_lassocr) \\<odot> rassocl\\<^sub>C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parallel_wiring \\<odot> parallel_wiring =\n    (lassocr\\<^sub>C \\<odot> (1\\<^sub>C |\\<^sub>= swap_lassocr)) \\<odot>\n    (rassocl\\<^sub>C \\<odot> lassocr\\<^sub>C) \\<odot>\n    (1\\<^sub>C |\\<^sub>= swap_lassocr) \\<odot> rassocl\\<^sub>C", "by(simp add: parallel_wiring_def comp_converter_assoc)"], ["proof (state)\nthis:\n  parallel_wiring \\<odot> parallel_wiring =\n  (lassocr\\<^sub>C \\<odot> (1\\<^sub>C |\\<^sub>= swap_lassocr)) \\<odot>\n  (rassocl\\<^sub>C \\<odot> lassocr\\<^sub>C) \\<odot>\n  (1\\<^sub>C |\\<^sub>= swap_lassocr) \\<odot> rassocl\\<^sub>C\n\ngoal (1 subgoal):\n 1. (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n    (\\<I>3 \\<oplus>\\<^sub>\\<I>\n     \\<I>4),(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n            (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C\n    parallel_wiring \\<odot> parallel_wiring \\<sim> 1\\<^sub>C", "also"], ["proof (state)\nthis:\n  parallel_wiring \\<odot> parallel_wiring =\n  (lassocr\\<^sub>C \\<odot> (1\\<^sub>C |\\<^sub>= swap_lassocr)) \\<odot>\n  (rassocl\\<^sub>C \\<odot> lassocr\\<^sub>C) \\<odot>\n  (1\\<^sub>C |\\<^sub>= swap_lassocr) \\<odot> rassocl\\<^sub>C\n\ngoal (1 subgoal):\n 1. (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n    (\\<I>3 \\<oplus>\\<^sub>\\<I>\n     \\<I>4),(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n            (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C\n    parallel_wiring \\<odot> parallel_wiring \\<sim> 1\\<^sub>C", "have \"\\<dots> = (lassocr\\<^sub>C \\<odot> (1\\<^sub>C |\\<^sub>= swap_lassocr)) \\<odot> (1\\<^sub>C |\\<^sub>= swap_lassocr) \\<odot> rassocl\\<^sub>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lassocr\\<^sub>C \\<odot> (1\\<^sub>C |\\<^sub>= swap_lassocr)) \\<odot>\n    (rassocl\\<^sub>C \\<odot> lassocr\\<^sub>C) \\<odot>\n    (1\\<^sub>C |\\<^sub>= swap_lassocr) \\<odot> rassocl\\<^sub>C =\n    (lassocr\\<^sub>C \\<odot> (1\\<^sub>C |\\<^sub>= swap_lassocr)) \\<odot>\n    (1\\<^sub>C |\\<^sub>= swap_lassocr) \\<odot> rassocl\\<^sub>C", "by(simp add: lassocr_inverse comp_converter_id_left)"], ["proof (state)\nthis:\n  (lassocr\\<^sub>C \\<odot> (1\\<^sub>C |\\<^sub>= swap_lassocr)) \\<odot>\n  (rassocl\\<^sub>C \\<odot> lassocr\\<^sub>C) \\<odot>\n  (1\\<^sub>C |\\<^sub>= swap_lassocr) \\<odot> rassocl\\<^sub>C =\n  (lassocr\\<^sub>C \\<odot> (1\\<^sub>C |\\<^sub>= swap_lassocr)) \\<odot>\n  (1\\<^sub>C |\\<^sub>= swap_lassocr) \\<odot> rassocl\\<^sub>C\n\ngoal (1 subgoal):\n 1. (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n    (\\<I>3 \\<oplus>\\<^sub>\\<I>\n     \\<I>4),(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n            (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C\n    parallel_wiring \\<odot> parallel_wiring \\<sim> 1\\<^sub>C", "also"], ["proof (state)\nthis:\n  (lassocr\\<^sub>C \\<odot> (1\\<^sub>C |\\<^sub>= swap_lassocr)) \\<odot>\n  (rassocl\\<^sub>C \\<odot> lassocr\\<^sub>C) \\<odot>\n  (1\\<^sub>C |\\<^sub>= swap_lassocr) \\<odot> rassocl\\<^sub>C =\n  (lassocr\\<^sub>C \\<odot> (1\\<^sub>C |\\<^sub>= swap_lassocr)) \\<odot>\n  (1\\<^sub>C |\\<^sub>= swap_lassocr) \\<odot> rassocl\\<^sub>C\n\ngoal (1 subgoal):\n 1. (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n    (\\<I>3 \\<oplus>\\<^sub>\\<I>\n     \\<I>4),(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n            (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C\n    parallel_wiring \\<odot> parallel_wiring \\<sim> 1\\<^sub>C", "have \"\\<dots> = lassocr\\<^sub>C \\<odot> (1\\<^sub>C |\\<^sub>= (swap_lassocr \\<odot> swap_lassocr)) \\<odot> rassocl\\<^sub>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lassocr\\<^sub>C \\<odot> (1\\<^sub>C |\\<^sub>= swap_lassocr)) \\<odot>\n    (1\\<^sub>C |\\<^sub>= swap_lassocr) \\<odot> rassocl\\<^sub>C =\n    lassocr\\<^sub>C \\<odot>\n    (1\\<^sub>C |\\<^sub>= swap_lassocr \\<odot> swap_lassocr) \\<odot>\n    rassocl\\<^sub>C", "by(simp add: parallel_converter2_comp2_out comp_converter_assoc)"], ["proof (state)\nthis:\n  (lassocr\\<^sub>C \\<odot> (1\\<^sub>C |\\<^sub>= swap_lassocr)) \\<odot>\n  (1\\<^sub>C |\\<^sub>= swap_lassocr) \\<odot> rassocl\\<^sub>C =\n  lassocr\\<^sub>C \\<odot>\n  (1\\<^sub>C |\\<^sub>= swap_lassocr \\<odot> swap_lassocr) \\<odot>\n  rassocl\\<^sub>C\n\ngoal (1 subgoal):\n 1. (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n    (\\<I>3 \\<oplus>\\<^sub>\\<I>\n     \\<I>4),(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n            (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C\n    parallel_wiring \\<odot> parallel_wiring \\<sim> 1\\<^sub>C", "also"], ["proof (state)\nthis:\n  (lassocr\\<^sub>C \\<odot> (1\\<^sub>C |\\<^sub>= swap_lassocr)) \\<odot>\n  (1\\<^sub>C |\\<^sub>= swap_lassocr) \\<odot> rassocl\\<^sub>C =\n  lassocr\\<^sub>C \\<odot>\n  (1\\<^sub>C |\\<^sub>= swap_lassocr \\<odot> swap_lassocr) \\<odot>\n  rassocl\\<^sub>C\n\ngoal (1 subgoal):\n 1. (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n    (\\<I>3 \\<oplus>\\<^sub>\\<I>\n     \\<I>4),(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n            (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C\n    parallel_wiring \\<odot> parallel_wiring \\<sim> 1\\<^sub>C", "have \"?\\<I>,?\\<I> \\<turnstile>\\<^sub>C \\<dots> \\<sim> lassocr\\<^sub>C \\<odot> (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot> rassocl\\<^sub>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n    (\\<I>3 \\<oplus>\\<^sub>\\<I>\n     \\<I>4),(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n            (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C\n    lassocr\\<^sub>C \\<odot>\n    (1\\<^sub>C |\\<^sub>= swap_lassocr \\<odot> swap_lassocr) \\<odot>\n    rassocl\\<^sub>C \\<sim>\n    lassocr\\<^sub>C \\<odot>\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot> rassocl\\<^sub>C", "by(rule eq_\\<I>_converter_reflI eq_\\<I>_comp_cong parallel_converter2_eq_\\<I>_cong WT_intro swap_lassocr_inverse)+"], ["proof (state)\nthis:\n  (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n  (\\<I>3 \\<oplus>\\<^sub>\\<I>\n   \\<I>4),(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n          (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C\n  lassocr\\<^sub>C \\<odot>\n  (1\\<^sub>C |\\<^sub>= swap_lassocr \\<odot> swap_lassocr) \\<odot>\n  rassocl\\<^sub>C \\<sim>\n  lassocr\\<^sub>C \\<odot>\n  (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot> rassocl\\<^sub>C\n\ngoal (1 subgoal):\n 1. (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n    (\\<I>3 \\<oplus>\\<^sub>\\<I>\n     \\<I>4),(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n            (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C\n    parallel_wiring \\<odot> parallel_wiring \\<sim> 1\\<^sub>C", "also"], ["proof (state)\nthis:\n  (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n  (\\<I>3 \\<oplus>\\<^sub>\\<I>\n   \\<I>4),(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n          (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C\n  lassocr\\<^sub>C \\<odot>\n  (1\\<^sub>C |\\<^sub>= swap_lassocr \\<odot> swap_lassocr) \\<odot>\n  rassocl\\<^sub>C \\<sim>\n  lassocr\\<^sub>C \\<odot>\n  (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot> rassocl\\<^sub>C\n\ngoal (1 subgoal):\n 1. (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n    (\\<I>3 \\<oplus>\\<^sub>\\<I>\n     \\<I>4),(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n            (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C\n    parallel_wiring \\<odot> parallel_wiring \\<sim> 1\\<^sub>C", "have \"?\\<I>,?\\<I> \\<turnstile>\\<^sub>C lassocr\\<^sub>C \\<odot> (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot> rassocl\\<^sub>C \\<sim> lassocr\\<^sub>C \\<odot> 1\\<^sub>C \\<odot> rassocl\\<^sub>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n    (\\<I>3 \\<oplus>\\<^sub>\\<I>\n     \\<I>4),(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n            (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C\n    lassocr\\<^sub>C \\<odot>\n    (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot> rassocl\\<^sub>C \\<sim>\n    lassocr\\<^sub>C \\<odot> 1\\<^sub>C \\<odot> rassocl\\<^sub>C", "by(rule eq_\\<I>_converter_reflI eq_\\<I>_comp_cong parallel_converter2_id_id WT_intro)+"], ["proof (state)\nthis:\n  (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n  (\\<I>3 \\<oplus>\\<^sub>\\<I>\n   \\<I>4),(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n          (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C\n  lassocr\\<^sub>C \\<odot>\n  (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot> rassocl\\<^sub>C \\<sim>\n  lassocr\\<^sub>C \\<odot> 1\\<^sub>C \\<odot> rassocl\\<^sub>C\n\ngoal (1 subgoal):\n 1. (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n    (\\<I>3 \\<oplus>\\<^sub>\\<I>\n     \\<I>4),(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n            (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C\n    parallel_wiring \\<odot> parallel_wiring \\<sim> 1\\<^sub>C", "also"], ["proof (state)\nthis:\n  (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n  (\\<I>3 \\<oplus>\\<^sub>\\<I>\n   \\<I>4),(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n          (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C\n  lassocr\\<^sub>C \\<odot>\n  (1\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot> rassocl\\<^sub>C \\<sim>\n  lassocr\\<^sub>C \\<odot> 1\\<^sub>C \\<odot> rassocl\\<^sub>C\n\ngoal (1 subgoal):\n 1. (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n    (\\<I>3 \\<oplus>\\<^sub>\\<I>\n     \\<I>4),(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n            (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C\n    parallel_wiring \\<odot> parallel_wiring \\<sim> 1\\<^sub>C", "have \"lassocr\\<^sub>C \\<odot> 1\\<^sub>C \\<odot> rassocl\\<^sub>C = 1\\<^sub>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lassocr\\<^sub>C \\<odot> 1\\<^sub>C \\<odot> rassocl\\<^sub>C = 1\\<^sub>C", "by(simp add: comp_converter_id_left rassocl_inverse)"], ["proof (state)\nthis:\n  lassocr\\<^sub>C \\<odot> 1\\<^sub>C \\<odot> rassocl\\<^sub>C = 1\\<^sub>C\n\ngoal (1 subgoal):\n 1. (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n    (\\<I>3 \\<oplus>\\<^sub>\\<I>\n     \\<I>4),(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n            (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C\n    parallel_wiring \\<odot> parallel_wiring \\<sim> 1\\<^sub>C", "finally"], ["proof (chain)\npicking this:\n  (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n  (\\<I>3 \\<oplus>\\<^sub>\\<I>\n   \\<I>4),(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n          (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C\n  parallel_wiring \\<odot> parallel_wiring \\<sim> 1\\<^sub>C", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n  (\\<I>3 \\<oplus>\\<^sub>\\<I>\n   \\<I>4),(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n          (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C\n  parallel_wiring \\<odot> parallel_wiring \\<sim> 1\\<^sub>C\n\ngoal (1 subgoal):\n 1. (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n    (\\<I>3 \\<oplus>\\<^sub>\\<I>\n     \\<I>4),(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n            (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C\n    parallel_wiring \\<odot> parallel_wiring \\<sim> 1\\<^sub>C", "."], ["proof (state)\nthis:\n  (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n  (\\<I>3 \\<oplus>\\<^sub>\\<I>\n   \\<I>4),(\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n          (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4) \\<turnstile>\\<^sub>C\n  parallel_wiring \\<odot> parallel_wiring \\<sim> 1\\<^sub>C\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open> Analogous to @{term \\<open>attach_wiring\\<close>} in Wiring.thy\\<close>"], ["", "definition \n  attach_wiring_right :: \"\n    ('a, 'b, 'c, 'd) wiring \\<Rightarrow> \n      ('s \\<Rightarrow> 'e \\<Rightarrow> ('f \\<times> 's, 'a, 'b) gpv) \\<Rightarrow> ('s \\<Rightarrow> 'e \\<Rightarrow> ('f \\<times> 's, 'c, 'd) gpv)\"\n  where \n    \"attach_wiring_right = (\\<lambda>(f, g). map_fun id (map_fun id (map_gpv' id f g)))\""], ["", "lemma \n  attach_wiring_right_simps: \n    \"attach_wiring_right (f, g) = map_fun id (map_fun id (map_gpv' id f g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. attach_wiring_right (f, g) = map_fun id (map_fun id (map_gpv' id f g))", "by(simp add: attach_wiring_right_def)"], ["", "lemma \n  comp_converter_of_callee_wiring:\n  assumes wiring: \"wiring \\<I>2 \\<I>3 conv w\"\n      and WT: \"\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C CNV callee s \\<surd>\"\n  shows \"\\<I>1, \\<I>3 \\<turnstile>\\<^sub>C CNV callee s \\<odot> conv \\<sim> CNV (attach_wiring_right w callee) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C CNV callee s \\<odot> conv \\<sim>\n    CNV (attach_wiring_right w callee) s", "using wiring"], ["proof (prove)\nusing this:\n  wiring \\<I>2 \\<I>3 conv w\n\ngoal (1 subgoal):\n 1. \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C CNV callee s \\<odot> conv \\<sim>\n    CNV (attach_wiring_right w callee) s", "proof cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>w = (f, g);\n        \\<I>2,\\<I>3 \\<turnstile>\\<^sub>C conv \\<sim>\n        map_converter id id f g 1\\<^sub>C;\n        \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C\n                         CNV callee s \\<odot> conv \\<sim>\n                         CNV (attach_wiring_right w callee) s", "case (wiring f g)"], ["proof (state)\nthis:\n  w = (f, g)\n  \\<I>2,\\<I>3 \\<turnstile>\\<^sub>C conv \\<sim>\n  map_converter id id f g 1\\<^sub>C\n  \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>w = (f, g);\n        \\<I>2,\\<I>3 \\<turnstile>\\<^sub>C conv \\<sim>\n        map_converter id id f g 1\\<^sub>C;\n        \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C\n                         CNV callee s \\<odot> conv \\<sim>\n                         CNV (attach_wiring_right w callee) s", "from _ wiring(2)"], ["proof (chain)\npicking this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  \\<I>2,\\<I>3 \\<turnstile>\\<^sub>C conv \\<sim>\n  map_converter id id f g 1\\<^sub>C", "have \"\\<I>1,\\<I>3 \\<turnstile>\\<^sub>C CNV callee s \\<odot> conv \\<sim> CNV callee s \\<odot> map_converter id id f g 1\\<^sub>C\""], ["proof (prove)\nusing this:\n  PROP ?psi \\<Longrightarrow> PROP ?psi\n  \\<I>2,\\<I>3 \\<turnstile>\\<^sub>C conv \\<sim>\n  map_converter id id f g 1\\<^sub>C\n\ngoal (1 subgoal):\n 1. \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C CNV callee s \\<odot> conv \\<sim>\n    CNV callee s \\<odot> map_converter id id f g 1\\<^sub>C", "by(rule eq_\\<I>_comp_cong)(rule eq_\\<I>_converter_reflI[OF WT])"], ["proof (state)\nthis:\n  \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C CNV callee s \\<odot> conv \\<sim>\n  CNV callee s \\<odot> map_converter id id f g 1\\<^sub>C\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>w = (f, g);\n        \\<I>2,\\<I>3 \\<turnstile>\\<^sub>C conv \\<sim>\n        map_converter id id f g 1\\<^sub>C;\n        \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C\n                         CNV callee s \\<odot> conv \\<sim>\n                         CNV (attach_wiring_right w callee) s", "also"], ["proof (state)\nthis:\n  \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C CNV callee s \\<odot> conv \\<sim>\n  CNV callee s \\<odot> map_converter id id f g 1\\<^sub>C\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>w = (f, g);\n        \\<I>2,\\<I>3 \\<turnstile>\\<^sub>C conv \\<sim>\n        map_converter id id f g 1\\<^sub>C;\n        \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C\n                         CNV callee s \\<odot> conv \\<sim>\n                         CNV (attach_wiring_right w callee) s", "have \"CNV callee s \\<odot> map_converter id id f g 1\\<^sub>C = map_converter id id f g (CNV callee s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV callee s \\<odot> map_converter id id f g 1\\<^sub>C =\n    map_converter id id f g (CNV callee s)", "by(subst comp_converter_map_converter2)(simp add: comp_converter_id_right)"], ["proof (state)\nthis:\n  CNV callee s \\<odot> map_converter id id f g 1\\<^sub>C =\n  map_converter id id f g (CNV callee s)\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>w = (f, g);\n        \\<I>2,\\<I>3 \\<turnstile>\\<^sub>C conv \\<sim>\n        map_converter id id f g 1\\<^sub>C;\n        \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C\n                         CNV callee s \\<odot> conv \\<sim>\n                         CNV (attach_wiring_right w callee) s", "also"], ["proof (state)\nthis:\n  CNV callee s \\<odot> map_converter id id f g 1\\<^sub>C =\n  map_converter id id f g (CNV callee s)\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>w = (f, g);\n        \\<I>2,\\<I>3 \\<turnstile>\\<^sub>C conv \\<sim>\n        map_converter id id f g 1\\<^sub>C;\n        \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C\n                         CNV callee s \\<odot> conv \\<sim>\n                         CNV (attach_wiring_right w callee) s", "have \"\\<dots> = CNV (attach_wiring_right w callee) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter id id f g (CNV callee s) =\n    CNV (attach_wiring_right w callee) s", "by(simp add: map_converter_of_callee attach_wiring_right_simps wiring(1) prod.map_id0)"], ["proof (state)\nthis:\n  map_converter id id f g (CNV callee s) =\n  CNV (attach_wiring_right w callee) s\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       \\<lbrakk>w = (f, g);\n        \\<I>2,\\<I>3 \\<turnstile>\\<^sub>C conv \\<sim>\n        map_converter id id f g 1\\<^sub>C;\n        \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv \\<surd>\\<rbrakk>\n       \\<Longrightarrow> \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C\n                         CNV callee s \\<odot> conv \\<sim>\n                         CNV (attach_wiring_right w callee) s", "finally"], ["proof (chain)\npicking this:\n  \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C CNV callee s \\<odot> conv \\<sim>\n  CNV (attach_wiring_right w callee) s", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C CNV callee s \\<odot> conv \\<sim>\n  CNV (attach_wiring_right w callee) s\n\ngoal (1 subgoal):\n 1. \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C CNV callee s \\<odot> conv \\<sim>\n    CNV (attach_wiring_right w callee) s", "."], ["proof (state)\nthis:\n  \\<I>1,\\<I>3 \\<turnstile>\\<^sub>C CNV callee s \\<odot> conv \\<sim>\n  CNV (attach_wiring_right w callee) s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma attach_wiring_right_comp_wiring:\n  \"attach_wiring_right (w1 \\<circ>\\<^sub>w w2) callee = attach_wiring_right w2 (attach_wiring_right w1 callee)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. attach_wiring_right (w1 \\<circ>\\<^sub>w w2) callee =\n    attach_wiring_right w2 (attach_wiring_right w1 callee)", "by(simp add: attach_wiring_right_def comp_wiring_def split_def map_fun_def o_def map_gpv'_comp id_def fun_eq_iff)"], ["", "lemma attach_wiring_comp_wiring:\n  \"attach_wiring (w1 \\<circ>\\<^sub>w w2) callee = attach_wiring w1 (attach_wiring w2 callee)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. attach_wiring (w1 \\<circ>\\<^sub>w w2) callee =\n    attach_wiring w1 (attach_wiring w2 callee)", "unfolding attach_wiring_def comp_wiring_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (case w1 of\n           (f, g) \\<Rightarrow>\n             \\<lambda>(f', g'). (f' \\<circ> f, g \\<circ> g'))\n           w2 of\n     (f, g) \\<Rightarrow>\n       map_fun id (map_fun f (map_gpv (map_prod g id) id)))\n     callee =\n    (case w1 of\n     (f, g) \\<Rightarrow>\n       map_fun id (map_fun f (map_gpv (map_prod g id) id)))\n     ((case w2 of\n       (f, g) \\<Rightarrow>\n         map_fun id (map_fun f (map_gpv (map_prod g id) id)))\n       callee)", "by (simp add: split_def map_fun_def o_def map_gpv_conv_map_gpv' map_gpv'_comp id_def map_prod_def)"], ["", "subsection \\<open>Probabilistic finite converter\\<close>"], ["", "coinductive pfinite_converter :: \"('a, 'b) \\<I> \\<Rightarrow> ('c, 'd) \\<I> \\<Rightarrow> ('a, 'b, 'c, 'd) converter \\<Rightarrow> bool\" \n  for \\<I> \\<I>' where\n  pfinite_converterI: \"pfinite_converter \\<I> \\<I>' conv\" if \n  \"\\<And>a. a \\<in> outs_\\<I> \\<I> \\<Longrightarrow> pfinite_gpv \\<I>' (run_converter conv a)\"\n  \"\\<And>a b conv'. \\<lbrakk> a \\<in> outs_\\<I> \\<I>; (b, conv') \\<in> results_gpv \\<I>' (run_converter conv a) \\<rbrakk> \\<Longrightarrow> pfinite_converter \\<I> \\<I>' conv'\""], ["", "lemma pfinite_converter_coinduct[consumes 1, case_names pfinite_converter, case_conclusion pfinite_converter pfinite step, coinduct pred: pfinite_converter]:\n  assumes \"X conv\"\n    and step: \"\\<And>conv a. \\<lbrakk> X conv; a \\<in> outs_\\<I> \\<I> \\<rbrakk> \\<Longrightarrow> pfinite_gpv \\<I>' (run_converter conv a) \\<and>\n     (\\<forall>(b, conv') \\<in> results_gpv \\<I>' (run_converter conv a). X conv' \\<or> pfinite_converter \\<I> \\<I>' conv')\"\n  shows \"pfinite_converter \\<I> \\<I>' conv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter \\<I> \\<I>' conv", "using assms(1)"], ["proof (prove)\nusing this:\n  X conv\n\ngoal (1 subgoal):\n 1. pfinite_converter \\<I> \\<I>' conv", "by(rule pfinite_converter.coinduct)(auto dest: step)"], ["", "lemma pfinite_converterD:\n  \"\\<lbrakk> pfinite_converter \\<I> \\<I>' conv; a \\<in> outs_\\<I> \\<I> \\<rbrakk> \n  \\<Longrightarrow> pfinite_gpv \\<I>' (run_converter conv a) \\<and>\n     (\\<forall>(b, conv') \\<in> results_gpv \\<I>' (run_converter conv a). pfinite_converter \\<I> \\<I>' conv')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pfinite_converter \\<I> \\<I>' conv;\n     a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> pfinite_gpv \\<I>' (run_converter conv a) \\<and>\n                      (\\<forall>(b, conv')\n                                \\<in>results_gpv \\<I>'\n(run_converter conv a).\n                          pfinite_converter \\<I> \\<I>' conv')", "by(auto elim: pfinite_converter.cases)"], ["", "lemma pfinite_converter_bot1 [simp]: \"pfinite_converter bot \\<I> conv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter \\<bottom> \\<I> conv", "by(rule pfinite_converterI) auto"], ["", "lemma pfinite_converter_mono:\n  assumes *: \"pfinite_converter \\<I>1 \\<I>2 conv\"\n    and le: \"outs_\\<I> \\<I>1' \\<subseteq> outs_\\<I> \\<I>1\" \"\\<I>2 \\<le> \\<I>2'\"\n    and WT: \"\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv \\<surd>\"\n  shows \"pfinite_converter \\<I>1' \\<I>2' conv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter \\<I>1' \\<I>2' conv", "using * WT"], ["proof (prove)\nusing this:\n  pfinite_converter \\<I>1 \\<I>2 conv\n  \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv \\<surd>\n\ngoal (1 subgoal):\n 1. pfinite_converter \\<I>1' \\<I>2' conv", "apply(coinduction arbitrary: conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a conva.\n       \\<lbrakk>pfinite_converter \\<I>1 \\<I>2 conva;\n        \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        a \\<in> outs_\\<I> \\<I>1'\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv \\<I>2' (run_converter conva a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>2'\n   (run_converter conva a).\n                             (\\<exists>conv.\n                                 conv' = conv \\<and>\n                                 pfinite_converter \\<I>1 \\<I>2 conv \\<and>\n                                 \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                                 conv \\<surd>) \\<or>\n                             pfinite_converter \\<I>1' \\<I>2' conv')", "apply(drule pfinite_converterD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        a \\<in> outs_\\<I> \\<I>1'\\<rbrakk>\n       \\<Longrightarrow> ?a5 a conva \\<in> outs_\\<I> \\<I>1\n 2. \\<And>a conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        a \\<in> outs_\\<I> \\<I>1';\n        pfinite_gpv \\<I>2 (run_converter conva (?a5 a conva)) \\<and>\n        (\\<forall>(b, conv')\n                  \\<in>results_gpv \\<I>2\n                        (run_converter conva (?a5 a conva)).\n            pfinite_converter \\<I>1 \\<I>2 conv')\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv \\<I>2' (run_converter conva a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>2'\n   (run_converter conva a).\n                             (\\<exists>conv.\n                                 conv' = conv \\<and>\n                                 pfinite_converter \\<I>1 \\<I>2 conv \\<and>\n                                 \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                                 conv \\<surd>) \\<or>\n                             pfinite_converter \\<I>1' \\<I>2' conv')", "apply(erule le(1)[THEN subsetD])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a conva.\n       \\<lbrakk>\\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conva \\<surd>;\n        a \\<in> outs_\\<I> \\<I>1';\n        pfinite_gpv \\<I>2 (run_converter conva a) \\<and>\n        (\\<forall>(b, conv')\\<in>results_gpv \\<I>2 (run_converter conva a).\n            pfinite_converter \\<I>1 \\<I>2 conv')\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv \\<I>2' (run_converter conva a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>2'\n   (run_converter conva a).\n                             (\\<exists>conv.\n                                 conv' = conv \\<and>\n                                 pfinite_converter \\<I>1 \\<I>2 conv \\<and>\n                                 \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                                 conv \\<surd>) \\<or>\n                             pfinite_converter \\<I>1' \\<I>2' conv')", "apply(drule WT_converterD')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a conva.\n       \\<lbrakk>a \\<in> outs_\\<I> \\<I>1';\n        pfinite_gpv \\<I>2 (run_converter conva a) \\<and>\n        (\\<forall>(b, conv')\\<in>results_gpv \\<I>2 (run_converter conva a).\n            pfinite_converter \\<I>1 \\<I>2 conv')\\<rbrakk>\n       \\<Longrightarrow> ?q9 a conva \\<in> outs_\\<I> \\<I>1\n 2. \\<And>a conva.\n       \\<lbrakk>a \\<in> outs_\\<I> \\<I>1';\n        pfinite_gpv \\<I>2 (run_converter conva a) \\<and>\n        (\\<forall>(b, conv')\\<in>results_gpv \\<I>2 (run_converter conva a).\n            pfinite_converter \\<I>1 \\<I>2 conv');\n        \\<I>2 \\<turnstile>g run_converter conva (?q9 a conva) \\<surd> \\<and>\n        (\\<forall>(r, conv')\n                  \\<in>results_gpv \\<I>2\n                        (run_converter conva (?q9 a conva)).\n            r \\<in> responses_\\<I> \\<I>1 (?q9 a conva) \\<and> \\<I>1,\n            \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>)\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv \\<I>2' (run_converter conva a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>2'\n   (run_converter conva a).\n                             (\\<exists>conv.\n                                 conv' = conv \\<and>\n                                 pfinite_converter \\<I>1 \\<I>2 conv \\<and>\n                                 \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                                 conv \\<surd>) \\<or>\n                             pfinite_converter \\<I>1' \\<I>2' conv')", "apply(erule le(1)[THEN subsetD])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a conva.\n       \\<lbrakk>a \\<in> outs_\\<I> \\<I>1';\n        pfinite_gpv \\<I>2 (run_converter conva a) \\<and>\n        (\\<forall>(b, conv')\\<in>results_gpv \\<I>2 (run_converter conva a).\n            pfinite_converter \\<I>1 \\<I>2 conv');\n        \\<I>2 \\<turnstile>g run_converter conva a \\<surd> \\<and>\n        (\\<forall>(r, conv')\\<in>results_gpv \\<I>2 (run_converter conva a).\n            r \\<in> responses_\\<I> \\<I>1 a \\<and> \\<I>1,\n            \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>)\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv \\<I>2' (run_converter conva a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>2'\n   (run_converter conva a).\n                             (\\<exists>conv.\n                                 conv' = conv \\<and>\n                                 pfinite_converter \\<I>1 \\<I>2 conv \\<and>\n                                 \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                                 conv \\<surd>) \\<or>\n                             pfinite_converter \\<I>1' \\<I>2' conv')", "using le(2)[THEN responses_\\<I>_mono]"], ["proof (prove)\nusing this:\n  ?x \\<in> outs_\\<I> \\<I>2 \\<Longrightarrow>\n  responses_\\<I> \\<I>2' ?x \\<subseteq> responses_\\<I> \\<I>2 ?x\n\ngoal (1 subgoal):\n 1. \\<And>a conva.\n       \\<lbrakk>a \\<in> outs_\\<I> \\<I>1';\n        pfinite_gpv \\<I>2 (run_converter conva a) \\<and>\n        (\\<forall>(b, conv')\\<in>results_gpv \\<I>2 (run_converter conva a).\n            pfinite_converter \\<I>1 \\<I>2 conv');\n        \\<I>2 \\<turnstile>g run_converter conva a \\<surd> \\<and>\n        (\\<forall>(r, conv')\\<in>results_gpv \\<I>2 (run_converter conva a).\n            r \\<in> responses_\\<I> \\<I>1 a \\<and> \\<I>1,\n            \\<I>2 \\<turnstile>\\<^sub>C conv' \\<surd>)\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv \\<I>2' (run_converter conva a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>2'\n   (run_converter conva a).\n                             (\\<exists>conv.\n                                 conv' = conv \\<and>\n                                 pfinite_converter \\<I>1 \\<I>2 conv \\<and>\n                                 \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                                 conv \\<surd>) \\<or>\n                             pfinite_converter \\<I>1' \\<I>2' conv')", "by(auto intro: pfinite_gpv_mono[OF _ le(2)] results_gpv_mono[OF le(2), THEN subsetD] dest: bspec)"], ["", "context raw_converter_invariant begin"], ["", "lemma pfinite_converter_of_callee:\n  assumes step: \"\\<And>x s. \\<lbrakk> x \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> pfinite_gpv \\<I>' (callee s x)\"\n    and I: \"I s\"\n  shows \"pfinite_converter \\<I> \\<I>' (converter_of_callee callee s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter \\<I> \\<I>' (CNV callee s)", "using I"], ["proof (prove)\nusing this:\n  I s\n\ngoal (1 subgoal):\n 1. pfinite_converter \\<I> \\<I>' (CNV callee s)", "by(coinduction arbitrary: s)(auto 4 3 simp add: step dest: results_callee)"], ["", "end"], ["", "lemma raw_converter_invariant_run_pfinite_converter: \n  \"raw_converter_invariant \\<I> \\<I>' run_converter (\\<lambda>conv. pfinite_converter \\<I> \\<I>' conv \\<and> \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<surd>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. raw_converter_invariant \\<I> \\<I>' run_converter\n     (\\<lambda>conv.\n         pfinite_converter \\<I> \\<I>' conv \\<and> \\<I>,\n         \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>)", "by(unfold_locales)(auto dest: WT_converterD pfinite_converterD)"], ["", "interpretation run_pfinite_converter: raw_converter_invariant\n  \\<I> \\<I>' run_converter \"\\<lambda>conv. pfinite_converter \\<I> \\<I>' conv \\<and> \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\" for \\<I> \\<I>'"], ["proof (prove)\ngoal (1 subgoal):\n 1. raw_converter_invariant \\<I> \\<I>' run_converter\n     (\\<lambda>conv.\n         pfinite_converter \\<I> \\<I>' conv \\<and> \\<I>,\n         \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>)", "by(rule raw_converter_invariant_run_pfinite_converter)"], ["", "named_theorems pfinite_intro \"Introduction rules for probabilistic finiteness\""], ["", "lemma pfinite_id_converter [pfinite_intro]: \"pfinite_converter \\<I> \\<I> id_converter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter \\<I> \\<I> 1\\<^sub>C", "by(coinduction) simp"], ["", "lemma pfinite_fail_converter [pfinite_intro]: \"pfinite_converter \\<I> \\<I>' fail_converter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter \\<I> \\<I>' \\<bottom>\\<^sub>C", "by coinduction simp"], ["", "lemma pfinite_parallel_converter2 [pfinite_intro]:\n  \"pfinite_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') (conv1 |\\<^sub>= conv2)\"\n  if \"pfinite_converter \\<I>1 \\<I>1' conv1\" \"pfinite_converter \\<I>2 \\<I>2' conv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n     (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') (conv1 |\\<^sub>= conv2)", "using that"], ["proof (prove)\nusing this:\n  pfinite_converter \\<I>1 \\<I>1' conv1\n  pfinite_converter \\<I>2 \\<I>2' conv2\n\ngoal (1 subgoal):\n 1. pfinite_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n     (\\<I>1' \\<oplus>\\<^sub>\\<I> \\<I>2') (conv1 |\\<^sub>= conv2)", "by(coinduction arbitrary: conv1 conv2)(fastforce dest: pfinite_converterD)"], ["", "context raw_converter_invariant begin"], ["", "lemma expectation_gpv_1_le_inline:\n  defines \"expectation_gpv2 \\<equiv> expectation_gpv 1 \\<I>'\"\n  assumes callee: \"\\<And>s x. \\<lbrakk> x \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> pfinite_gpv \\<I>' (callee s x)\"\n    and WT_gpv: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and I: \"I s\"\n    and f_le_1: \"\\<And>x. f x \\<le> 1\"\n  shows \"expectation_gpv 1 \\<I> f gpv \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 1 \\<I> f gpv\n    \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee gpv s)", "using WT_gpv I"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. expectation_gpv 1 \\<I> f gpv\n    \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee gpv s)", "proof(induction arbitrary: gpv s rule: expectation_gpv_fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            (\\<forall>xa.\n                I xa \\<longrightarrow>\n                a x\n                \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                       (inline callee x xa)))\n 2. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                  (inline callee gpv s)\n 3. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 1 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         1 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "case adm"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            (\\<forall>xa.\n                I xa \\<longrightarrow>\n                a x\n                \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                       (inline callee x xa)))\n 2. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                  (inline callee gpv s)\n 3. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 1 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         1 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp.admissible\n     (\\<lambda>a.\n         \\<forall>x.\n            \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n            (\\<forall>xa.\n                I xa \\<longrightarrow>\n                a x\n                \\<le> expectation_gpv2\n                       (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n                       (inline callee x xa)))", "by simp"], ["proof (state)\nthis:\n  lfp.admissible\n   (\\<lambda>a.\n       \\<forall>x.\n          \\<I> \\<turnstile>g x \\<surd> \\<longrightarrow>\n          (\\<forall>xa.\n              I xa \\<longrightarrow>\n              a x\n              \\<le> expectation_gpv2\n                     (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n                     (inline callee x xa)))\n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                  (inline callee gpv s)\n 2. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 1 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         1 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "case bottom"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (2 subgoals):\n 1. \\<And>gpv s.\n       \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                  (inline callee gpv s)\n 2. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 1 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         1 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> expectation_gpv2\n             (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n             (inline callee gpv s)", "by simp"], ["proof (state)\nthis:\n  0 \\<le> expectation_gpv2 (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n           (inline callee gpv s)\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 1 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         1 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "case (step expectation_gpv')"], ["proof (state)\nthis:\n  expectation_gpv' ?gpv \\<le> expectation_gpv 1 \\<I> f ?gpv\n  \\<lbrakk>\\<I> \\<turnstile>g ?gpv \\<surd>; I ?s\\<rbrakk>\n  \\<Longrightarrow> expectation_gpv' ?gpv\n                    \\<le> expectation_gpv2\n                           (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n                           (inline callee ?gpv ?s)\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 1 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         1 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "have \"(\\<integral>\\<^sup>+ x. (case x of Pure a \\<Rightarrow> f a | IO out c \\<Rightarrow> \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) \\<partial>measure_spmf (the_gpv gpv)) + 1 * ennreal (pmf (the_gpv gpv) None) = \n    (\\<Sum>\\<^sup>+ x. pmf (the_gpv gpv) x * (case x of Some (Pure a) \\<Rightarrow> f a | Some (IO out c) \\<Rightarrow> \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r) | None \\<Rightarrow> 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. (case x of Pure a \\<Rightarrow> f a\n                            | IO out c \\<Rightarrow>\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    1 * ennreal (pmf (the_gpv gpv) None) =\n    (\\<Sum>\\<^sup>+ x.\n       ennreal (pmf (the_gpv gpv) x) *\n       (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n        | Some (IO out c) \\<Rightarrow>\n            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n               expectation_gpv' (c r)))", "apply(simp add: nn_integral_measure_spmf_conv_measure_pmf nn_integral_restrict_space nn_integral_measure_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal (pmf (the_gpv gpv) x) *\n       ((case the x of Pure x \\<Rightarrow> f x\n         | IO out c \\<Rightarrow>\n             \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                expectation_gpv' (c r)) *\n        indicator (range Some) x)) +\n    ennreal (pmf (the_gpv gpv) None) =\n    (\\<Sum>\\<^sup>+ x.\n       ennreal (pmf (the_gpv gpv) x) *\n       (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n        | Some (IO out c) \\<Rightarrow>\n            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n               expectation_gpv' (c r)))", "apply(subst (2) nn_integral_disjoint_pair_countspace[where B=\"range Some\" and C=\"{None}\", simplified, folded UNIV_option_conv, simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal (pmf (the_gpv gpv) x) *\n       ((case the x of Pure x \\<Rightarrow> f x\n         | IO out c \\<Rightarrow>\n             \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                expectation_gpv' (c r)) *\n        indicator (range Some) x)) +\n    ennreal (pmf (the_gpv gpv) None) =\n    (\\<integral>\\<^sup>+x\\<in>range Some.\n                        (ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure xa) \\<Rightarrow> f xa\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r)))\n     \\<partial>count_space UNIV) +\n    ennreal (pmf (the_gpv gpv) None) *\n    (case None of None \\<Rightarrow> 1 | Some (Pure xa) \\<Rightarrow> f xa\n     | Some (IO out c) \\<Rightarrow>\n         \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))", "apply(auto simp add: mult.commute intro!: nn_integral_cong split: split_indicator)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. (case x of Pure a \\<Rightarrow> f a\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  1 * ennreal (pmf (the_gpv gpv) None) =\n  (\\<Sum>\\<^sup>+ x.\n     ennreal (pmf (the_gpv gpv) x) *\n     (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n      | Some (IO out c) \\<Rightarrow>\n          \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 1 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         1 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. (case x of Pure a \\<Rightarrow> f a\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  1 * ennreal (pmf (the_gpv gpv) None) =\n  (\\<Sum>\\<^sup>+ x.\n     ennreal (pmf (the_gpv gpv) x) *\n     (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n      | Some (IO out c) \\<Rightarrow>\n          \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 1 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         1 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "have \"\\<dots> \\<le> (\\<Sum>\\<^sup>+ x. pmf (the_gpv gpv) x * (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a | Some (IO out c) \\<Rightarrow> \n          (\\<Sum>\\<^sup>+ x. ennreal (pmf (the_gpv (callee s out) \\<bind> case_generat (\\<lambda>(x, y). inline1 callee (c x) y) (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c)))) x) *\n            (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n             | Some (Inr (r, rpv, rpv')) \\<Rightarrow> \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r. expectation_gpv 1 \\<I>' (\\<lambda>(x, s'). expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv' x) s')) (rpv x)))))\"\n    (is \"nn_integral _ ?lhs \\<le> nn_integral _ ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal (pmf (the_gpv gpv) x) *\n       (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n        | Some (IO out c) \\<Rightarrow>\n            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n               expectation_gpv' (c r)))\n    \\<le> (\\<Sum>\\<^sup>+ x.\n             ennreal (pmf (the_gpv gpv) x) *\n             (case x of None \\<Rightarrow> 1\n              | Some (Pure a) \\<Rightarrow> f a\n              | Some (IO out c) \\<Rightarrow>\n                  \\<Sum>\\<^sup>+ x.\n                    ennreal\n                     (pmf (the_gpv (callee s out) \\<bind>\n                           case_generat\n                            (\\<lambda>(x, y). inline1 callee (c x) y)\n                            (\\<lambda>out rpv'.\n                                return_spmf (Inr (out, rpv', c))))\n                       x) *\n                    (case x of None \\<Rightarrow> 1\n                     | Some (Inl (a, s)) \\<Rightarrow> f a\n                     | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                         \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                            expectation_gpv 1 \\<I>'\n                             (\\<lambda>(x, s').\n                                 expectation_gpv 1 \\<I>'\n                                  (\\<lambda>(x, s). f x)\n                                  (inline callee (rpv' x) s'))\n                             (rpv x))))", "proof(rule nn_integral_mono)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (count_space UNIV) \\<Longrightarrow>\n       ennreal (pmf (the_gpv gpv) x) *\n       (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n        | Some (IO out c) \\<Rightarrow>\n            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> ennreal (pmf (the_gpv gpv) x) *\n             (case x of None \\<Rightarrow> 1\n              | Some (Pure a) \\<Rightarrow> f a\n              | Some (IO out c) \\<Rightarrow>\n                  \\<Sum>\\<^sup>+ x.\n                    ennreal\n                     (pmf (the_gpv (callee s out) \\<bind>\n                           case_generat\n                            (\\<lambda>(x, y). inline1 callee (c x) y)\n                            (\\<lambda>out rpv'.\n                                return_spmf (Inr (out, rpv', c))))\n                       x) *\n                    (case x of None \\<Rightarrow> 1\n                     | Some (Inl (a, s)) \\<Rightarrow> f a\n                     | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                         \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                            expectation_gpv 1 \\<I>'\n                             (\\<lambda>(x, s').\n                                 expectation_gpv 1 \\<I>'\n                                  (\\<lambda>(x, s). f x)\n                                  (inline callee (rpv' x) s'))\n                             (rpv x)))", "fix x :: \"('a, 'call, ('a, 'call, 'ret) rpv) generat option\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (count_space UNIV) \\<Longrightarrow>\n       ennreal (pmf (the_gpv gpv) x) *\n       (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n        | Some (IO out c) \\<Rightarrow>\n            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> ennreal (pmf (the_gpv gpv) x) *\n             (case x of None \\<Rightarrow> 1\n              | Some (Pure a) \\<Rightarrow> f a\n              | Some (IO out c) \\<Rightarrow>\n                  \\<Sum>\\<^sup>+ x.\n                    ennreal\n                     (pmf (the_gpv (callee s out) \\<bind>\n                           case_generat\n                            (\\<lambda>(x, y). inline1 callee (c x) y)\n                            (\\<lambda>out rpv'.\n                                return_spmf (Inr (out, rpv', c))))\n                       x) *\n                    (case x of None \\<Rightarrow> 1\n                     | Some (Inl (a, s)) \\<Rightarrow> f a\n                     | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                         \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                            expectation_gpv 1 \\<I>'\n                             (\\<lambda>(x, s').\n                                 expectation_gpv 1 \\<I>'\n                                  (\\<lambda>(x, s). f x)\n                                  (inline callee (rpv' x) s'))\n                             (rpv x)))", "consider (None) \"x = None\" | (Pure) a where \"x = Some (Pure a)\" \n      | (IO) out c where \"x = Some (IO out c)\" \"IO out c \\<in> set_spmf (the_gpv gpv)\"\n      | (outside) out c where \"x = Some (IO out c)\" \"IO out c \\<notin> set_spmf (the_gpv gpv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = None \\<Longrightarrow> thesis;\n     \\<And>a. x = Some (Pure a) \\<Longrightarrow> thesis;\n     \\<And>out c.\n        \\<lbrakk>x = Some (IO out c);\n         IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>out c.\n        \\<lbrakk>x = Some (IO out c);\n         IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis dest_IO.elims not_None_eq)"], ["proof (state)\nthis:\n  \\<lbrakk>x = None \\<Longrightarrow> ?thesis;\n   \\<And>a. x = Some (Pure a) \\<Longrightarrow> ?thesis;\n   \\<And>out c.\n      \\<lbrakk>x = Some (IO out c);\n       IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>out c.\n      \\<lbrakk>x = Some (IO out c);\n       IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (count_space UNIV) \\<Longrightarrow>\n       ennreal (pmf (the_gpv gpv) x) *\n       (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n        | Some (IO out c) \\<Rightarrow>\n            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> ennreal (pmf (the_gpv gpv) x) *\n             (case x of None \\<Rightarrow> 1\n              | Some (Pure a) \\<Rightarrow> f a\n              | Some (IO out c) \\<Rightarrow>\n                  \\<Sum>\\<^sup>+ x.\n                    ennreal\n                     (pmf (the_gpv (callee s out) \\<bind>\n                           case_generat\n                            (\\<lambda>(x, y). inline1 callee (c x) y)\n                            (\\<lambda>out rpv'.\n                                return_spmf (Inr (out, rpv', c))))\n                       x) *\n                    (case x of None \\<Rightarrow> 1\n                     | Some (Inl (a, s)) \\<Rightarrow> f a\n                     | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                         \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                            expectation_gpv 1 \\<I>'\n                             (\\<lambda>(x, s').\n                                 expectation_gpv 1 \\<I>'\n                                  (\\<lambda>(x, s). f x)\n                                  (inline callee (rpv' x) s'))\n                             (rpv x)))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>x = None \\<Longrightarrow> ?thesis;\n   \\<And>a. x = Some (Pure a) \\<Longrightarrow> ?thesis;\n   \\<And>out c.\n      \\<lbrakk>x = Some (IO out c);\n       IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>out c.\n      \\<lbrakk>x = Some (IO out c);\n       IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"?lhs x \\<le> ?rhs x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x = None \\<Longrightarrow> ?thesis;\n   \\<And>a. x = Some (Pure a) \\<Longrightarrow> ?thesis;\n   \\<And>out c.\n      \\<lbrakk>x = Some (IO out c);\n       IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>out c.\n      \\<lbrakk>x = Some (IO out c);\n       IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. ennreal (pmf (the_gpv gpv) x) *\n    (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n     | Some (IO out c) \\<Rightarrow>\n         \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> ennreal (pmf (the_gpv gpv) x) *\n          (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n           | Some (IO out c) \\<Rightarrow>\n               \\<Sum>\\<^sup>+ x.\n                 ennreal\n                  (pmf (the_gpv (callee s out) \\<bind>\n                        case_generat\n                         (\\<lambda>(x, y). inline1 callee (c x) y)\n                         (\\<lambda>out rpv'.\n                             return_spmf (Inr (out, rpv', c))))\n                    x) *\n                 (case x of None \\<Rightarrow> 1\n                  | Some (Inl (a, s)) \\<Rightarrow> f a\n                  | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                      \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                         expectation_gpv 1 \\<I>'\n                          (\\<lambda>(x, s').\n                              expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                               (inline callee (rpv' x) s'))\n                          (rpv x)))", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. x = None \\<Longrightarrow>\n    ennreal (pmf (the_gpv gpv) x) *\n    (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n     | Some (IO out c) \\<Rightarrow>\n         \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> ennreal (pmf (the_gpv gpv) x) *\n          (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n           | Some (IO out c) \\<Rightarrow>\n               \\<Sum>\\<^sup>+ x.\n                 ennreal\n                  (pmf (the_gpv (callee s out) \\<bind>\n                        case_generat\n                         (\\<lambda>(x, y). inline1 callee (c x) y)\n                         (\\<lambda>out rpv'.\n                             return_spmf (Inr (out, rpv', c))))\n                    x) *\n                 (case x of None \\<Rightarrow> 1\n                  | Some (Inl (a, s)) \\<Rightarrow> f a\n                  | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                      \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                         expectation_gpv 1 \\<I>'\n                          (\\<lambda>(x, s').\n                              expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                               (inline callee (rpv' x) s'))\n                          (rpv x)))\n 2. \\<And>a.\n       x = Some (Pure a) \\<Longrightarrow>\n       ennreal (pmf (the_gpv gpv) x) *\n       (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n        | Some (IO out c) \\<Rightarrow>\n            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> ennreal (pmf (the_gpv gpv) x) *\n             (case x of None \\<Rightarrow> 1\n              | Some (Pure a) \\<Rightarrow> f a\n              | Some (IO out c) \\<Rightarrow>\n                  \\<Sum>\\<^sup>+ x.\n                    ennreal\n                     (pmf (the_gpv (callee s out) \\<bind>\n                           case_generat\n                            (\\<lambda>(x, y). inline1 callee (c x) y)\n                            (\\<lambda>out rpv'.\n                                return_spmf (Inr (out, rpv', c))))\n                       x) *\n                    (case x of None \\<Rightarrow> 1\n                     | Some (Inl (a, s)) \\<Rightarrow> f a\n                     | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                         \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                            expectation_gpv 1 \\<I>'\n                             (\\<lambda>(x, s').\n                                 expectation_gpv 1 \\<I>'\n                                  (\\<lambda>(x, s). f x)\n                                  (inline callee (rpv' x) s'))\n                             (rpv x)))\n 3. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))\n 4. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "case None"], ["proof (state)\nthis:\n  x = None\n\ngoal (4 subgoals):\n 1. x = None \\<Longrightarrow>\n    ennreal (pmf (the_gpv gpv) x) *\n    (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n     | Some (IO out c) \\<Rightarrow>\n         \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> ennreal (pmf (the_gpv gpv) x) *\n          (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n           | Some (IO out c) \\<Rightarrow>\n               \\<Sum>\\<^sup>+ x.\n                 ennreal\n                  (pmf (the_gpv (callee s out) \\<bind>\n                        case_generat\n                         (\\<lambda>(x, y). inline1 callee (c x) y)\n                         (\\<lambda>out rpv'.\n                             return_spmf (Inr (out, rpv', c))))\n                    x) *\n                 (case x of None \\<Rightarrow> 1\n                  | Some (Inl (a, s)) \\<Rightarrow> f a\n                  | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                      \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                         expectation_gpv 1 \\<I>'\n                          (\\<lambda>(x, s').\n                              expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                               (inline callee (rpv' x) s'))\n                          (rpv x)))\n 2. \\<And>a.\n       x = Some (Pure a) \\<Longrightarrow>\n       ennreal (pmf (the_gpv gpv) x) *\n       (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n        | Some (IO out c) \\<Rightarrow>\n            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> ennreal (pmf (the_gpv gpv) x) *\n             (case x of None \\<Rightarrow> 1\n              | Some (Pure a) \\<Rightarrow> f a\n              | Some (IO out c) \\<Rightarrow>\n                  \\<Sum>\\<^sup>+ x.\n                    ennreal\n                     (pmf (the_gpv (callee s out) \\<bind>\n                           case_generat\n                            (\\<lambda>(x, y). inline1 callee (c x) y)\n                            (\\<lambda>out rpv'.\n                                return_spmf (Inr (out, rpv', c))))\n                       x) *\n                    (case x of None \\<Rightarrow> 1\n                     | Some (Inl (a, s)) \\<Rightarrow> f a\n                     | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                         \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                            expectation_gpv 1 \\<I>'\n                             (\\<lambda>(x, s').\n                                 expectation_gpv 1 \\<I>'\n                                  (\\<lambda>(x, s). f x)\n                                  (inline callee (rpv' x) s'))\n                             (rpv x)))\n 3. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))\n 4. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "then"], ["proof (chain)\npicking this:\n  x = None", "show ?thesis"], ["proof (prove)\nusing this:\n  x = None\n\ngoal (1 subgoal):\n 1. ennreal (pmf (the_gpv gpv) x) *\n    (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n     | Some (IO out c) \\<Rightarrow>\n         \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> ennreal (pmf (the_gpv gpv) x) *\n          (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n           | Some (IO out c) \\<Rightarrow>\n               \\<Sum>\\<^sup>+ x.\n                 ennreal\n                  (pmf (the_gpv (callee s out) \\<bind>\n                        case_generat\n                         (\\<lambda>(x, y). inline1 callee (c x) y)\n                         (\\<lambda>out rpv'.\n                             return_spmf (Inr (out, rpv', c))))\n                    x) *\n                 (case x of None \\<Rightarrow> 1\n                  | Some (Inl (a, s)) \\<Rightarrow> f a\n                  | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                      \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                         expectation_gpv 1 \\<I>'\n                          (\\<lambda>(x, s').\n                              expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                               (inline callee (rpv' x) s'))\n                          (rpv x)))", "by simp"], ["proof (state)\nthis:\n  ennreal (pmf (the_gpv gpv) x) *\n  (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n   | Some (IO out c) \\<Rightarrow>\n       \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> ennreal (pmf (the_gpv gpv) x) *\n        (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n         | Some (IO out c) \\<Rightarrow>\n             \\<Sum>\\<^sup>+ x.\n               ennreal\n                (pmf (the_gpv (callee s out) \\<bind>\n                      case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n                       (\\<lambda>out rpv'.\n                           return_spmf (Inr (out, rpv', c))))\n                  x) *\n               (case x of None \\<Rightarrow> 1\n                | Some (Inl (a, s)) \\<Rightarrow> f a\n                | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                       expectation_gpv 1 \\<I>'\n                        (\\<lambda>(x, s').\n                            expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv' x) s'))\n                        (rpv x)))\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       x = Some (Pure a) \\<Longrightarrow>\n       ennreal (pmf (the_gpv gpv) x) *\n       (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n        | Some (IO out c) \\<Rightarrow>\n            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> ennreal (pmf (the_gpv gpv) x) *\n             (case x of None \\<Rightarrow> 1\n              | Some (Pure a) \\<Rightarrow> f a\n              | Some (IO out c) \\<Rightarrow>\n                  \\<Sum>\\<^sup>+ x.\n                    ennreal\n                     (pmf (the_gpv (callee s out) \\<bind>\n                           case_generat\n                            (\\<lambda>(x, y). inline1 callee (c x) y)\n                            (\\<lambda>out rpv'.\n                                return_spmf (Inr (out, rpv', c))))\n                       x) *\n                    (case x of None \\<Rightarrow> 1\n                     | Some (Inl (a, s)) \\<Rightarrow> f a\n                     | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                         \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                            expectation_gpv 1 \\<I>'\n                             (\\<lambda>(x, s').\n                                 expectation_gpv 1 \\<I>'\n                                  (\\<lambda>(x, s). f x)\n                                  (inline callee (rpv' x) s'))\n                             (rpv x)))\n 2. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))\n 3. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a.\n       x = Some (Pure a) \\<Longrightarrow>\n       ennreal (pmf (the_gpv gpv) x) *\n       (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n        | Some (IO out c) \\<Rightarrow>\n            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> ennreal (pmf (the_gpv gpv) x) *\n             (case x of None \\<Rightarrow> 1\n              | Some (Pure a) \\<Rightarrow> f a\n              | Some (IO out c) \\<Rightarrow>\n                  \\<Sum>\\<^sup>+ x.\n                    ennreal\n                     (pmf (the_gpv (callee s out) \\<bind>\n                           case_generat\n                            (\\<lambda>(x, y). inline1 callee (c x) y)\n                            (\\<lambda>out rpv'.\n                                return_spmf (Inr (out, rpv', c))))\n                       x) *\n                    (case x of None \\<Rightarrow> 1\n                     | Some (Inl (a, s)) \\<Rightarrow> f a\n                     | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                         \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                            expectation_gpv 1 \\<I>'\n                             (\\<lambda>(x, s').\n                                 expectation_gpv 1 \\<I>'\n                                  (\\<lambda>(x, s). f x)\n                                  (inline callee (rpv' x) s'))\n                             (rpv x)))\n 2. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))\n 3. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "case Pure"], ["proof (state)\nthis:\n  x = Some (Pure a)\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       x = Some (Pure a) \\<Longrightarrow>\n       ennreal (pmf (the_gpv gpv) x) *\n       (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n        | Some (IO out c) \\<Rightarrow>\n            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> ennreal (pmf (the_gpv gpv) x) *\n             (case x of None \\<Rightarrow> 1\n              | Some (Pure a) \\<Rightarrow> f a\n              | Some (IO out c) \\<Rightarrow>\n                  \\<Sum>\\<^sup>+ x.\n                    ennreal\n                     (pmf (the_gpv (callee s out) \\<bind>\n                           case_generat\n                            (\\<lambda>(x, y). inline1 callee (c x) y)\n                            (\\<lambda>out rpv'.\n                                return_spmf (Inr (out, rpv', c))))\n                       x) *\n                    (case x of None \\<Rightarrow> 1\n                     | Some (Inl (a, s)) \\<Rightarrow> f a\n                     | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                         \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                            expectation_gpv 1 \\<I>'\n                             (\\<lambda>(x, s').\n                                 expectation_gpv 1 \\<I>'\n                                  (\\<lambda>(x, s). f x)\n                                  (inline callee (rpv' x) s'))\n                             (rpv x)))\n 2. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))\n 3. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "then"], ["proof (chain)\npicking this:\n  x = Some (Pure a)", "show ?thesis"], ["proof (prove)\nusing this:\n  x = Some (Pure a)\n\ngoal (1 subgoal):\n 1. ennreal (pmf (the_gpv gpv) x) *\n    (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n     | Some (IO out c) \\<Rightarrow>\n         \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> ennreal (pmf (the_gpv gpv) x) *\n          (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n           | Some (IO out c) \\<Rightarrow>\n               \\<Sum>\\<^sup>+ x.\n                 ennreal\n                  (pmf (the_gpv (callee s out) \\<bind>\n                        case_generat\n                         (\\<lambda>(x, y). inline1 callee (c x) y)\n                         (\\<lambda>out rpv'.\n                             return_spmf (Inr (out, rpv', c))))\n                    x) *\n                 (case x of None \\<Rightarrow> 1\n                  | Some (Inl (a, s)) \\<Rightarrow> f a\n                  | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                      \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                         expectation_gpv 1 \\<I>'\n                          (\\<lambda>(x, s').\n                              expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                               (inline callee (rpv' x) s'))\n                          (rpv x)))", "by simp"], ["proof (state)\nthis:\n  ennreal (pmf (the_gpv gpv) x) *\n  (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n   | Some (IO out c) \\<Rightarrow>\n       \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> ennreal (pmf (the_gpv gpv) x) *\n        (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n         | Some (IO out c) \\<Rightarrow>\n             \\<Sum>\\<^sup>+ x.\n               ennreal\n                (pmf (the_gpv (callee s out) \\<bind>\n                      case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n                       (\\<lambda>out rpv'.\n                           return_spmf (Inr (out, rpv', c))))\n                  x) *\n               (case x of None \\<Rightarrow> 1\n                | Some (Inl (a, s)) \\<Rightarrow> f a\n                | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                       expectation_gpv 1 \\<I>'\n                        (\\<lambda>(x, s').\n                            expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv' x) s'))\n                        (rpv x)))\n\ngoal (2 subgoals):\n 1. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))\n 2. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))\n 2. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "case (IO out c)"], ["proof (state)\nthis:\n  x = Some (IO out c)\n  IO out c \\<in> set_spmf (the_gpv gpv)\n\ngoal (2 subgoals):\n 1. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))\n 2. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "with step.prems"], ["proof (chain)\npicking this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n  x = Some (IO out c)\n  IO out c \\<in> set_spmf (the_gpv gpv)", "have out: \"out \\<in> outs_\\<I> \\<I>\""], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n  x = Some (IO out c)\n  IO out c \\<in> set_spmf (the_gpv gpv)\n\ngoal (1 subgoal):\n 1. out \\<in> outs_\\<I> \\<I>", "by(auto dest: WT_gpvD)"], ["proof (state)\nthis:\n  out \\<in> outs_\\<I> \\<I>\n\ngoal (2 subgoals):\n 1. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))\n 2. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "then"], ["proof (chain)\npicking this:\n  out \\<in> outs_\\<I> \\<I>", "obtain response where resp: \"response \\<in> responses_\\<I> \\<I> out\""], ["proof (prove)\nusing this:\n  out \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. (\\<And>response.\n        response \\<in> responses_\\<I> \\<I> out \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding in_outs_\\<I>_iff_responses_\\<I>"], ["proof (prove)\nusing this:\n  responses_\\<I> \\<I> out \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>response.\n        response \\<in> responses_\\<I> \\<I> out \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  response \\<in> responses_\\<I> \\<I> out\n\ngoal (2 subgoals):\n 1. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))\n 2. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "with out step.prems IO"], ["proof (chain)\npicking this:\n  out \\<in> outs_\\<I> \\<I>\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n  x = Some (IO out c)\n  IO out c \\<in> set_spmf (the_gpv gpv)\n  response \\<in> responses_\\<I> \\<I> out", "have WT_resp [WT_intro]: \"\\<I> \\<turnstile>g c response \\<surd>\""], ["proof (prove)\nusing this:\n  out \\<in> outs_\\<I> \\<I>\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n  x = Some (IO out c)\n  IO out c \\<in> set_spmf (the_gpv gpv)\n  response \\<in> responses_\\<I> \\<I> out\n\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>g c response \\<surd>", "by(auto dest: WT_gpvD)"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>g c response \\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))\n 2. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "have exp_resp: \"expectation_gpv' (c response) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv' (c response) \\<le> 1", "using step.hyps[of \"c response\"] expectation_gpv_mono[of 1 1 f \"\\<lambda>_. 1\" \\<I> \"c response\"] expectation_gpv_const_le[OF WT_resp, of 1 1]"], ["proof (prove)\nusing this:\n  expectation_gpv' (c response) \\<le> expectation_gpv 1 \\<I> f (c response)\n  \\<lbrakk>1 \\<le> 1; f \\<le> (\\<lambda>_. 1)\\<rbrakk>\n  \\<Longrightarrow> expectation_gpv 1 \\<I> f (c response)\n                    \\<le> expectation_gpv 1 \\<I> (\\<lambda>_. 1)\n                           (c response)\n  expectation_gpv 1 \\<I> (\\<lambda>_. 1) (c response) \\<le> max 1 1\n\ngoal (1 subgoal):\n 1. expectation_gpv' (c response) \\<le> 1", "by(simp add: le_fun_def f_le_1)"], ["proof (state)\nthis:\n  expectation_gpv' (c response) \\<le> 1\n\ngoal (2 subgoals):\n 1. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))\n 2. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "have \"(\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) = \n        (\\<integral>\\<^sup>+ generat. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) \\<partial>measure_spmf (the_gpv (callee s out))) +\n        (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) * (1 - ennreal (weight_spmf (the_gpv (callee s out))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) =\n    \\<integral>\\<^sup>+ generat.\n                         (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                             expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv (callee s out)) +\n    (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) *\n    (1 - ennreal (weight_spmf (the_gpv (callee s out))))", "by(simp add: measure_spmf.emeasure_eq_measure add_mult_distrib2[symmetric] semiring_class.distrib_left[symmetric] add_diff_inverse_ennreal weight_spmf_le_1)"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) =\n  \\<integral>\\<^sup>+ generat.\n                       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                           expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv (callee s out)) +\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) *\n  (1 - ennreal (weight_spmf (the_gpv (callee s out))))\n\ngoal (2 subgoals):\n 1. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))\n 2. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) =\n  \\<integral>\\<^sup>+ generat.\n                       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                           expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv (callee s out)) +\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) *\n  (1 - ennreal (weight_spmf (the_gpv (callee s out))))\n\ngoal (2 subgoals):\n 1. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))\n 2. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "have \"\\<dots> \\<le> (\\<integral>\\<^sup>+ generat. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) \\<partial>measure_spmf (the_gpv (callee s out))) +\n        1 * ennreal (pmf (the_gpv (callee s out)) None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                             expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv (callee s out)) +\n    (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) *\n    (1 - ennreal (weight_spmf (the_gpv (callee s out))))\n    \\<le> \\<integral>\\<^sup>+ generat.\n                               (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))\n                             \\<partial>measure_spmf\n  (the_gpv (callee s out)) +\n          1 * ennreal (pmf (the_gpv (callee s out)) None)", "unfolding pmf_None_eq_weight_spmf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                             expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv (callee s out)) +\n    (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) *\n    (1 - ennreal (weight_spmf (the_gpv (callee s out))))\n    \\<le> \\<integral>\\<^sup>+ generat.\n                               (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))\n                             \\<partial>measure_spmf\n  (the_gpv (callee s out)) +\n          1 * ennreal (1 - weight_spmf (the_gpv (callee s out)))", "by(intro add_mono mult_mono order_refl INF_lower2[OF resp])(auto simp add: ennreal_minus[symmetric] weight_spmf_le_1 exp_resp)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                           expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv (callee s out)) +\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) *\n  (1 - ennreal (weight_spmf (the_gpv (callee s out))))\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                           \\<partial>measure_spmf (the_gpv (callee s out)) +\n        1 * ennreal (pmf (the_gpv (callee s out)) None)\n\ngoal (2 subgoals):\n 1. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))\n 2. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                           expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv (callee s out)) +\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) *\n  (1 - ennreal (weight_spmf (the_gpv (callee s out))))\n  \\<le> \\<integral>\\<^sup>+ generat.\n                             (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                           \\<partial>measure_spmf (the_gpv (callee s out)) +\n        1 * ennreal (pmf (the_gpv (callee s out)) None)\n\ngoal (2 subgoals):\n 1. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))\n 2. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "have \"\\<dots> = (\\<Sum>\\<^sup>+ z. ennreal (pmf (the_gpv (callee s out)) z) * (case z of None \\<Rightarrow> 1 | Some generat \\<Rightarrow> (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                             expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv (callee s out)) +\n    1 * ennreal (pmf (the_gpv (callee s out)) None) =\n    (\\<Sum>\\<^sup>+ z.\n       ennreal (pmf (the_gpv (callee s out)) z) *\n       (case z of None \\<Rightarrow> 1\n        | Some generat \\<Rightarrow>\n            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n               expectation_gpv' (c r)))", "apply(simp add: nn_integral_measure_spmf_conv_measure_pmf nn_integral_restrict_space nn_integral_measure_pmf del: nn_integral_const)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal (pmf (the_gpv (callee s out)) x) *\n       ((\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) *\n        indicator (range Some) x)) +\n    ennreal (pmf (the_gpv (callee s out)) None) =\n    (\\<Sum>\\<^sup>+ z.\n       ennreal (pmf (the_gpv (callee s out)) z) *\n       (case z of None \\<Rightarrow> 1\n        | Some generat \\<Rightarrow>\n            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n               expectation_gpv' (c r)))", "apply(subst (2) nn_integral_disjoint_pair_countspace[where B=\"range Some\" and C=\"{None}\", simplified, folded UNIV_option_conv, simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal (pmf (the_gpv (callee s out)) x) *\n       ((\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) *\n        indicator (range Some) x)) +\n    ennreal (pmf (the_gpv (callee s out)) None) =\n    (\\<integral>\\<^sup>+x\\<in>range Some.\n                        (ennreal (pmf (the_gpv (callee s out)) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r)))\n     \\<partial>count_space UNIV) +\n    ennreal (pmf (the_gpv (callee s out)) None) *\n    (case None of None \\<Rightarrow> 1\n     | Some generat \\<Rightarrow>\n         \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))", "apply(auto simp add: mult.commute intro!: nn_integral_cong split: split_indicator)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                           expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv (callee s out)) +\n  1 * ennreal (pmf (the_gpv (callee s out)) None) =\n  (\\<Sum>\\<^sup>+ z.\n     ennreal (pmf (the_gpv (callee s out)) z) *\n     (case z of None \\<Rightarrow> 1\n      | Some generat \\<Rightarrow>\n          \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n\ngoal (2 subgoals):\n 1. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))\n 2. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                           expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv (callee s out)) +\n  1 * ennreal (pmf (the_gpv (callee s out)) None) =\n  (\\<Sum>\\<^sup>+ z.\n     ennreal (pmf (the_gpv (callee s out)) z) *\n     (case z of None \\<Rightarrow> 1\n      | Some generat \\<Rightarrow>\n          \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n\ngoal (2 subgoals):\n 1. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))\n 2. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "have \"\\<dots> \\<le> (\\<Sum>\\<^sup>+ z. ennreal (pmf (the_gpv (callee s out)) z) *\n         (case z of None \\<Rightarrow> 1 | Some (IO out' rpv') \\<Rightarrow> \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'. expectation_gpv 1 \\<I>' (\\<lambda>(x, s'). expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c x) s')) (rpv' x)\n          | Some (Pure (r, s')) \\<Rightarrow> (\\<Sum>\\<^sup>+ x. ennreal (pmf (inline1 callee (c r) s') x) * (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n                  \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'. expectation_gpv 1 \\<I>' (\\<lambda>(x, s'). expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv' x) s')) (rpv x)))))\"\n         (is \"nn_integral _ ?lhs2 \\<le> nn_integral _ ?rhs2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ z.\n       ennreal (pmf (the_gpv (callee s out)) z) *\n       (case z of None \\<Rightarrow> 1\n        | Some generat \\<Rightarrow>\n            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n               expectation_gpv' (c r)))\n    \\<le> (\\<Sum>\\<^sup>+ z.\n             ennreal (pmf (the_gpv (callee s out)) z) *\n             (case z of None \\<Rightarrow> 1\n              | Some (Pure (r, s')) \\<Rightarrow>\n                  \\<Sum>\\<^sup>+ x.\n                    ennreal (pmf (inline1 callee (c r) s') x) *\n                    (case x of None \\<Rightarrow> 1\n                     | Some (Inl (a, s)) \\<Rightarrow> f a\n                     | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n                         \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                            expectation_gpv 1 \\<I>'\n                             (\\<lambda>(x, s').\n                                 expectation_gpv 1 \\<I>'\n                                  (\\<lambda>(x, s). f x)\n                                  (inline callee (rpv' x) s'))\n                             (rpv x))\n              | Some (IO out' rpv') \\<Rightarrow>\n                  \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                     expectation_gpv 1 \\<I>'\n                      (\\<lambda>(x, s').\n                          expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                           (inline callee (c x) s'))\n                      (rpv' x)))", "proof(intro nn_integral_mono)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (count_space UNIV) \\<Longrightarrow>\n       ennreal (pmf (the_gpv (callee s out)) x) *\n       (case x of None \\<Rightarrow> 1\n        | Some generat \\<Rightarrow>\n            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> ennreal (pmf (the_gpv (callee s out)) x) *\n             (case x of None \\<Rightarrow> 1\n              | Some (Pure (r, s')) \\<Rightarrow>\n                  \\<Sum>\\<^sup>+ x.\n                    ennreal (pmf (inline1 callee (c r) s') x) *\n                    (case x of None \\<Rightarrow> 1\n                     | Some (Inl (a, s)) \\<Rightarrow> f a\n                     | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n                         \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                            expectation_gpv 1 \\<I>'\n                             (\\<lambda>(x, s').\n                                 expectation_gpv 1 \\<I>'\n                                  (\\<lambda>(x, s). f x)\n                                  (inline callee (rpv' x) s'))\n                             (rpv x))\n              | Some (IO out' rpv') \\<Rightarrow>\n                  \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                     expectation_gpv 1 \\<I>'\n                      (\\<lambda>(x, s').\n                          expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                           (inline callee (c x) s'))\n                      (rpv' x))", "fix z :: \"('ret \\<times> 's, 'call', ('ret \\<times> 's, 'call', 'ret') rpv) generat option\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (count_space UNIV) \\<Longrightarrow>\n       ennreal (pmf (the_gpv (callee s out)) x) *\n       (case x of None \\<Rightarrow> 1\n        | Some generat \\<Rightarrow>\n            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> ennreal (pmf (the_gpv (callee s out)) x) *\n             (case x of None \\<Rightarrow> 1\n              | Some (Pure (r, s')) \\<Rightarrow>\n                  \\<Sum>\\<^sup>+ x.\n                    ennreal (pmf (inline1 callee (c r) s') x) *\n                    (case x of None \\<Rightarrow> 1\n                     | Some (Inl (a, s)) \\<Rightarrow> f a\n                     | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n                         \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                            expectation_gpv 1 \\<I>'\n                             (\\<lambda>(x, s').\n                                 expectation_gpv 1 \\<I>'\n                                  (\\<lambda>(x, s). f x)\n                                  (inline callee (rpv' x) s'))\n                             (rpv x))\n              | Some (IO out' rpv') \\<Rightarrow>\n                  \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                     expectation_gpv 1 \\<I>'\n                      (\\<lambda>(x, s').\n                          expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                           (inline callee (c x) s'))\n                      (rpv' x))", "consider (None) \"z = None\" | (Pure) x' s' where \"z = Some (Pure (x', s'))\" \"Pure (x', s') \\<in> set_spmf (the_gpv (callee s out))\"\n          | (IO') out' c' where \"z = Some (IO out' c')\" \"IO out' c' \\<in> set_spmf (the_gpv (callee s out))\"\n          | (outside) generat where \"z = Some generat\" \"generat \\<notin> set_spmf (the_gpv (callee s out))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z = None \\<Longrightarrow> thesis;\n     \\<And>x' s'.\n        \\<lbrakk>z = Some (Pure (x', s'));\n         Pure (x', s') \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>out' c'.\n        \\<lbrakk>z = Some (IO out' c');\n         IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>generat.\n        \\<lbrakk>z = Some generat;\n         generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis dest_IO.elims not_Some_eq old.prod.exhaust)"], ["proof (state)\nthis:\n  \\<lbrakk>z = None \\<Longrightarrow> ?thesis;\n   \\<And>x' s'.\n      \\<lbrakk>z = Some (Pure (x', s'));\n       Pure (x', s') \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>out' c'.\n      \\<lbrakk>z = Some (IO out' c');\n       IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>generat.\n      \\<lbrakk>z = Some generat;\n       generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (count_space UNIV) \\<Longrightarrow>\n       ennreal (pmf (the_gpv (callee s out)) x) *\n       (case x of None \\<Rightarrow> 1\n        | Some generat \\<Rightarrow>\n            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n       \\<le> ennreal (pmf (the_gpv (callee s out)) x) *\n             (case x of None \\<Rightarrow> 1\n              | Some (Pure (r, s')) \\<Rightarrow>\n                  \\<Sum>\\<^sup>+ x.\n                    ennreal (pmf (inline1 callee (c r) s') x) *\n                    (case x of None \\<Rightarrow> 1\n                     | Some (Inl (a, s)) \\<Rightarrow> f a\n                     | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n                         \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                            expectation_gpv 1 \\<I>'\n                             (\\<lambda>(x, s').\n                                 expectation_gpv 1 \\<I>'\n                                  (\\<lambda>(x, s). f x)\n                                  (inline callee (rpv' x) s'))\n                             (rpv x))\n              | Some (IO out' rpv') \\<Rightarrow>\n                  \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                     expectation_gpv 1 \\<I>'\n                      (\\<lambda>(x, s').\n                          expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                           (inline callee (c x) s'))\n                      (rpv' x))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>z = None \\<Longrightarrow> ?thesis;\n   \\<And>x' s'.\n      \\<lbrakk>z = Some (Pure (x', s'));\n       Pure (x', s') \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>out' c'.\n      \\<lbrakk>z = Some (IO out' c');\n       IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>generat.\n      \\<lbrakk>z = Some generat;\n       generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"?lhs2 z \\<le> ?rhs2 z\""], ["proof (prove)\nusing this:\n  \\<lbrakk>z = None \\<Longrightarrow> ?thesis;\n   \\<And>x' s'.\n      \\<lbrakk>z = Some (Pure (x', s'));\n       Pure (x', s') \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>out' c'.\n      \\<lbrakk>z = Some (IO out' c');\n       IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>generat.\n      \\<lbrakk>z = Some generat;\n       generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. ennreal (pmf (the_gpv (callee s out)) z) *\n    (case z of None \\<Rightarrow> 1\n     | Some generat \\<Rightarrow>\n         \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n          (case z of None \\<Rightarrow> 1\n           | Some (Pure (r, s')) \\<Rightarrow>\n               \\<Sum>\\<^sup>+ x.\n                 ennreal (pmf (inline1 callee (c r) s') x) *\n                 (case x of None \\<Rightarrow> 1\n                  | Some (Inl (a, s)) \\<Rightarrow> f a\n                  | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n                      \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                         expectation_gpv 1 \\<I>'\n                          (\\<lambda>(x, s').\n                              expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                               (inline callee (rpv' x) s'))\n                          (rpv x))\n           | Some (IO out' rpv') \\<Rightarrow>\n               \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                  expectation_gpv 1 \\<I>'\n                   (\\<lambda>(x, s').\n                       expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                        (inline callee (c x) s'))\n                   (rpv' x))", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. z = None \\<Longrightarrow>\n    ennreal (pmf (the_gpv (callee s out)) z) *\n    (case z of None \\<Rightarrow> 1\n     | Some generat \\<Rightarrow>\n         \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n          (case z of None \\<Rightarrow> 1\n           | Some (Pure (r, s')) \\<Rightarrow>\n               \\<Sum>\\<^sup>+ x.\n                 ennreal (pmf (inline1 callee (c r) s') x) *\n                 (case x of None \\<Rightarrow> 1\n                  | Some (Inl (a, s)) \\<Rightarrow> f a\n                  | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n                      \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                         expectation_gpv 1 \\<I>'\n                          (\\<lambda>(x, s').\n                              expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                               (inline callee (rpv' x) s'))\n                          (rpv x))\n           | Some (IO out' rpv') \\<Rightarrow>\n               \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                  expectation_gpv 1 \\<I>'\n                   (\\<lambda>(x, s').\n                       expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                        (inline callee (c x) s'))\n                   (rpv' x))\n 2. \\<And>x' s'.\n       \\<lbrakk>z = Some (Pure (x', s'));\n        Pure (x', s') \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 3. \\<And>out' c'.\n       \\<lbrakk>z = Some (IO out' c');\n        IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 4. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "case None"], ["proof (state)\nthis:\n  z = None\n\ngoal (4 subgoals):\n 1. z = None \\<Longrightarrow>\n    ennreal (pmf (the_gpv (callee s out)) z) *\n    (case z of None \\<Rightarrow> 1\n     | Some generat \\<Rightarrow>\n         \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n          (case z of None \\<Rightarrow> 1\n           | Some (Pure (r, s')) \\<Rightarrow>\n               \\<Sum>\\<^sup>+ x.\n                 ennreal (pmf (inline1 callee (c r) s') x) *\n                 (case x of None \\<Rightarrow> 1\n                  | Some (Inl (a, s)) \\<Rightarrow> f a\n                  | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n                      \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                         expectation_gpv 1 \\<I>'\n                          (\\<lambda>(x, s').\n                              expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                               (inline callee (rpv' x) s'))\n                          (rpv x))\n           | Some (IO out' rpv') \\<Rightarrow>\n               \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                  expectation_gpv 1 \\<I>'\n                   (\\<lambda>(x, s').\n                       expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                        (inline callee (c x) s'))\n                   (rpv' x))\n 2. \\<And>x' s'.\n       \\<lbrakk>z = Some (Pure (x', s'));\n        Pure (x', s') \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 3. \\<And>out' c'.\n       \\<lbrakk>z = Some (IO out' c');\n        IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 4. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "then"], ["proof (chain)\npicking this:\n  z = None", "show ?thesis"], ["proof (prove)\nusing this:\n  z = None\n\ngoal (1 subgoal):\n 1. ennreal (pmf (the_gpv (callee s out)) z) *\n    (case z of None \\<Rightarrow> 1\n     | Some generat \\<Rightarrow>\n         \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n          (case z of None \\<Rightarrow> 1\n           | Some (Pure (r, s')) \\<Rightarrow>\n               \\<Sum>\\<^sup>+ x.\n                 ennreal (pmf (inline1 callee (c r) s') x) *\n                 (case x of None \\<Rightarrow> 1\n                  | Some (Inl (a, s)) \\<Rightarrow> f a\n                  | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n                      \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                         expectation_gpv 1 \\<I>'\n                          (\\<lambda>(x, s').\n                              expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                               (inline callee (rpv' x) s'))\n                          (rpv x))\n           | Some (IO out' rpv') \\<Rightarrow>\n               \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                  expectation_gpv 1 \\<I>'\n                   (\\<lambda>(x, s').\n                       expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                        (inline callee (c x) s'))\n                   (rpv' x))", "by simp"], ["proof (state)\nthis:\n  ennreal (pmf (the_gpv (callee s out)) z) *\n  (case z of None \\<Rightarrow> 1\n   | Some generat \\<Rightarrow>\n       \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n        (case z of None \\<Rightarrow> 1\n         | Some (Pure (r, s')) \\<Rightarrow>\n             \\<Sum>\\<^sup>+ x.\n               ennreal (pmf (inline1 callee (c r) s') x) *\n               (case x of None \\<Rightarrow> 1\n                | Some (Inl (a, s)) \\<Rightarrow> f a\n                | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 1 \\<I>'\n                        (\\<lambda>(x, s').\n                            expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv' x) s'))\n                        (rpv x))\n         | Some (IO out' rpv') \\<Rightarrow>\n             \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                expectation_gpv 1 \\<I>'\n                 (\\<lambda>(x, s').\n                     expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                      (inline callee (c x) s'))\n                 (rpv' x))\n\ngoal (3 subgoals):\n 1. \\<And>x' s'.\n       \\<lbrakk>z = Some (Pure (x', s'));\n        Pure (x', s') \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 2. \\<And>out' c'.\n       \\<lbrakk>z = Some (IO out' c');\n        IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 3. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x' s'.\n       \\<lbrakk>z = Some (Pure (x', s'));\n        Pure (x', s') \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 2. \\<And>out' c'.\n       \\<lbrakk>z = Some (IO out' c');\n        IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 3. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "case Pure"], ["proof (state)\nthis:\n  z = Some (Pure (x', s'))\n  Pure (x', s') \\<in> set_spmf (the_gpv (callee s out))\n\ngoal (3 subgoals):\n 1. \\<And>x' s'.\n       \\<lbrakk>z = Some (Pure (x', s'));\n        Pure (x', s') \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 2. \\<And>out' c'.\n       \\<lbrakk>z = Some (IO out' c');\n        IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 3. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "hence \"(x', s') \\<in> results_gpv \\<I>' (callee s out)\""], ["proof (prove)\nusing this:\n  z = Some (Pure (x', s'))\n  Pure (x', s') \\<in> set_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. (x', s') \\<in> results_gpv \\<I>' (callee s out)", "by(simp add: results_gpv.Pure)"], ["proof (state)\nthis:\n  (x', s') \\<in> results_gpv \\<I>' (callee s out)\n\ngoal (3 subgoals):\n 1. \\<And>x' s'.\n       \\<lbrakk>z = Some (Pure (x', s'));\n        Pure (x', s') \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 2. \\<And>out' c'.\n       \\<lbrakk>z = Some (IO out' c');\n        IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 3. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "with results_callee step.prems out"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> outs_\\<I> \\<I>; I ?s\\<rbrakk>\n  \\<Longrightarrow> results_gpv \\<I>' (callee ?s ?x)\n                    \\<subseteq> responses_\\<I> \\<I> ?x \\<times> {s. I s}\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n  out \\<in> outs_\\<I> \\<I>\n  (x', s') \\<in> results_gpv \\<I>' (callee s out)", "have x: \"x' \\<in> responses_\\<I> \\<I> out\" and s': \"I s'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> outs_\\<I> \\<I>; I ?s\\<rbrakk>\n  \\<Longrightarrow> results_gpv \\<I>' (callee ?s ?x)\n                    \\<subseteq> responses_\\<I> \\<I> ?x \\<times> {s. I s}\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n  out \\<in> outs_\\<I> \\<I>\n  (x', s') \\<in> results_gpv \\<I>' (callee s out)\n\ngoal (1 subgoal):\n 1. x' \\<in> responses_\\<I> \\<I> out &&& I s'", "by auto"], ["proof (state)\nthis:\n  x' \\<in> responses_\\<I> \\<I> out\n  I s'\n\ngoal (3 subgoals):\n 1. \\<And>x' s'.\n       \\<lbrakk>z = Some (Pure (x', s'));\n        Pure (x', s') \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 2. \\<And>out' c'.\n       \\<lbrakk>z = Some (IO out' c');\n        IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 3. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "with IO out step.prems"], ["proof (chain)\npicking this:\n  x = Some (IO out c)\n  IO out c \\<in> set_spmf (the_gpv gpv)\n  out \\<in> outs_\\<I> \\<I>\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n  x' \\<in> responses_\\<I> \\<I> out\n  I s'", "have WT_c [WT_intro]: \"\\<I> \\<turnstile>g c x' \\<surd>\""], ["proof (prove)\nusing this:\n  x = Some (IO out c)\n  IO out c \\<in> set_spmf (the_gpv gpv)\n  out \\<in> outs_\\<I> \\<I>\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n  x' \\<in> responses_\\<I> \\<I> out\n  I s'\n\ngoal (1 subgoal):\n 1. \\<I> \\<turnstile>g c x' \\<surd>", "by(auto dest: WT_gpvD)"], ["proof (state)\nthis:\n  \\<I> \\<turnstile>g c x' \\<surd>\n\ngoal (3 subgoals):\n 1. \\<And>x' s'.\n       \\<lbrakk>z = Some (Pure (x', s'));\n        Pure (x', s') \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 2. \\<And>out' c'.\n       \\<lbrakk>z = Some (IO out' c');\n        IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 3. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "from x"], ["proof (chain)\npicking this:\n  x' \\<in> responses_\\<I> \\<I> out", "have \"(INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) \\<le> expectation_gpv' (c x')\""], ["proof (prove)\nusing this:\n  x' \\<in> responses_\\<I> \\<I> out\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> expectation_gpv' (c x')", "by(rule INF_lower)"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> expectation_gpv' (c x')\n\ngoal (3 subgoals):\n 1. \\<And>x' s'.\n       \\<lbrakk>z = Some (Pure (x', s'));\n        Pure (x', s') \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 2. \\<And>out' c'.\n       \\<lbrakk>z = Some (IO out' c');\n        IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 3. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> expectation_gpv' (c x')\n\ngoal (3 subgoals):\n 1. \\<And>x' s'.\n       \\<lbrakk>z = Some (Pure (x', s'));\n        Pure (x', s') \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 2. \\<And>out' c'.\n       \\<lbrakk>z = Some (IO out' c');\n        IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 3. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "have \"\\<dots> \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x') s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv' (c x')\n    \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x') s')", "using WT_c s'"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g c x' \\<surd>\n  I s'\n\ngoal (1 subgoal):\n 1. expectation_gpv' (c x')\n    \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x') s')", "by(rule step.IH)"], ["proof (state)\nthis:\n  expectation_gpv' (c x')\n  \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x') s')\n\ngoal (3 subgoals):\n 1. \\<And>x' s'.\n       \\<lbrakk>z = Some (Pure (x', s'));\n        Pure (x', s') \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 2. \\<And>out' c'.\n       \\<lbrakk>z = Some (IO out' c');\n        IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 3. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "also"], ["proof (state)\nthis:\n  expectation_gpv' (c x')\n  \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x') s')\n\ngoal (3 subgoals):\n 1. \\<And>x' s'.\n       \\<lbrakk>z = Some (Pure (x', s'));\n        Pure (x', s') \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 2. \\<And>out' c'.\n       \\<lbrakk>z = Some (IO out' c');\n        IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 3. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "have \"\\<dots> = \\<integral>\\<^sup>+ xx. (case xx of Inl (x, _) \\<Rightarrow> f x \n               | Inr (out', callee', rpv) \\<Rightarrow> INF r'\\<in>responses_\\<I> \\<I>' out'. expectation_gpv 1 \\<I>' (\\<lambda>(r, s'). expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv r) s')) (callee' r'))\n            \\<partial>measure_spmf (inline1 callee (c x') s') + ennreal (pmf (the_gpv (inline callee (c x') s')) None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x') s') =\n    \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                             | Inr (out', callee', rpv) \\<Rightarrow>\n                                 \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                    expectation_gpv 1 \\<I>'\n                                     (\\<lambda>(r, s').\n   expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n    (inline callee (rpv r) s'))\n                                     (callee' r'))\n                       \\<partial>measure_spmf (inline1 callee (c x') s') +\n    ennreal (pmf (the_gpv (inline callee (c x') s')) None)", "unfolding expectation_gpv2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n     (inline callee (c x') s') =\n    \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                             | Inr (out', callee', rpv) \\<Rightarrow>\n                                 \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                    expectation_gpv 1 \\<I>'\n                                     (\\<lambda>(r, s').\n   expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n    (inline callee (rpv r) s'))\n                                     (callee' r'))\n                       \\<partial>measure_spmf (inline1 callee (c x') s') +\n    ennreal (pmf (the_gpv (inline callee (c x') s')) None)", "by(subst expectation_gpv.simps)(auto simp add: inline_sel split_def o_def intro!: nn_integral_cong split: generat.split sum.split)"], ["proof (state)\nthis:\n  expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x') s') =\n  \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                           | Inr (out', callee', rpv) \\<Rightarrow>\n                               \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                  expectation_gpv 1 \\<I>'\n                                   (\\<lambda>(r, s').\n expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                   (callee' r'))\n                     \\<partial>measure_spmf (inline1 callee (c x') s') +\n  ennreal (pmf (the_gpv (inline callee (c x') s')) None)\n\ngoal (3 subgoals):\n 1. \\<And>x' s'.\n       \\<lbrakk>z = Some (Pure (x', s'));\n        Pure (x', s') \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 2. \\<And>out' c'.\n       \\<lbrakk>z = Some (IO out' c');\n        IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 3. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "also"], ["proof (state)\nthis:\n  expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c x') s') =\n  \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                           | Inr (out', callee', rpv) \\<Rightarrow>\n                               \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                  expectation_gpv 1 \\<I>'\n                                   (\\<lambda>(r, s').\n expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                   (callee' r'))\n                     \\<partial>measure_spmf (inline1 callee (c x') s') +\n  ennreal (pmf (the_gpv (inline callee (c x') s')) None)\n\ngoal (3 subgoals):\n 1. \\<And>x' s'.\n       \\<lbrakk>z = Some (Pure (x', s'));\n        Pure (x', s') \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 2. \\<And>out' c'.\n       \\<lbrakk>z = Some (IO out' c');\n        IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 3. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "have \"\\<dots> = (\\<Sum>\\<^sup>+ xx. ennreal (pmf (inline1 callee (c x') s') xx) * (case xx of None \\<Rightarrow> 1 | Some (Inl (x, _)) \\<Rightarrow> f x \n            | Some (Inr (out', callee', rpv)) \\<Rightarrow> INF r'\\<in>responses_\\<I> \\<I>' out'. expectation_gpv 1 \\<I>' (\\<lambda>(r, s'). expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv r) s')) (callee' r')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                             | Inr (out', callee', rpv) \\<Rightarrow>\n                                 \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                    expectation_gpv 1 \\<I>'\n                                     (\\<lambda>(r, s').\n   expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n    (inline callee (rpv r) s'))\n                                     (callee' r'))\n                       \\<partial>measure_spmf (inline1 callee (c x') s') +\n    ennreal (pmf (the_gpv (inline callee (c x') s')) None) =\n    (\\<Sum>\\<^sup>+ xx.\n       ennreal (pmf (inline1 callee (c x') s') xx) *\n       (case xx of None \\<Rightarrow> 1\n        | Some (Inl (x, xa)) \\<Rightarrow> f x\n        | Some (Inr (out', callee', rpv)) \\<Rightarrow>\n            \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n               expectation_gpv 1 \\<I>'\n                (\\<lambda>(r, s').\n                    expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (rpv r) s'))\n                (callee' r')))", "apply(subst inline_sel)"], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (measure_spmf (inline1 callee (c x') s'))\n     (case_sum (\\<lambda>(x, xa). f x)\n       (\\<lambda>(out', callee', rpv).\n           \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n              expectation_gpv 1 \\<I>'\n               (\\<lambda>(r, s').\n                   expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                    (inline callee (rpv r) s'))\n               (callee' r'))) +\n    ennreal\n     (pmf (map_spmf\n            (case_sum Pure\n              (\\<lambda>(out, oracle, rpv).\n                  IO out\n                   (\\<lambda>input.\n                       oracle input \\<bind>\n                       (\\<lambda>(x, y). inline callee (rpv x) y))))\n            (inline1 callee (c x') s'))\n       None) =\n    (\\<Sum>\\<^sup>+ xx.\n       ennreal (pmf (inline1 callee (c x') s') xx) *\n       (case xx of None \\<Rightarrow> 1\n        | Some (Inl (x, xaa)) \\<Rightarrow> f x\n        | Some (Inr (out', callee', rpv)) \\<Rightarrow>\n            \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n               expectation_gpv 1 \\<I>'\n                (\\<lambda>(r, s').\n                    expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (rpv r) s'))\n                (callee' r')))", "apply(simp add: nn_integral_measure_spmf_conv_measure_pmf nn_integral_restrict_space nn_integral_measure_pmf pmf_map_spmf_None del: nn_integral_const)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal (pmf (inline1 callee (c x') s') x) *\n       ((case the x of Inl (xa, xaa) \\<Rightarrow> f xa\n         | Inr (out', callee', rpv) \\<Rightarrow>\n             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                expectation_gpv 1 \\<I>'\n                 (\\<lambda>(r, s').\n                     expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                      (inline callee (rpv r) s'))\n                 (callee' r')) *\n        indicator (range Some) x)) +\n    ennreal (pmf (inline1 callee (c x') s') None) =\n    (\\<Sum>\\<^sup>+ xx.\n       ennreal (pmf (inline1 callee (c x') s') xx) *\n       (case xx of None \\<Rightarrow> 1\n        | Some (Inl (x, xaa)) \\<Rightarrow> f x\n        | Some (Inr (out', callee', rpv)) \\<Rightarrow>\n            \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n               expectation_gpv 1 \\<I>'\n                (\\<lambda>(r, s').\n                    expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (rpv r) s'))\n                (callee' r')))", "apply(subst (2) nn_integral_disjoint_pair_countspace[where B=\"range Some\" and C=\"{None}\", simplified, folded UNIV_option_conv, simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal (pmf (inline1 callee (c x') s') x) *\n       ((case the x of Inl (xa, xaa) \\<Rightarrow> f xa\n         | Inr (out', callee', rpv) \\<Rightarrow>\n             \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                expectation_gpv 1 \\<I>'\n                 (\\<lambda>(r, s').\n                     expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                      (inline callee (rpv r) s'))\n                 (callee' r')) *\n        indicator (range Some) x)) +\n    ennreal (pmf (inline1 callee (c x') s') None) =\n    (\\<integral>\\<^sup>+x\\<in>range Some.\n                        (ennreal (pmf (inline1 callee (c x') s') x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Inl (x, xaa)) \\<Rightarrow> f x\n                          | Some (Inr (out', callee', rpv)) \\<Rightarrow>\n                              \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                 expectation_gpv 1 \\<I>'\n                                  (\\<lambda>(r, s').\nexpectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                  (callee' r')))\n     \\<partial>count_space UNIV) +\n    ennreal (pmf (inline1 callee (c x') s') None) *\n    (case None of None \\<Rightarrow> 1\n     | Some (Inl (x, xaa)) \\<Rightarrow> f x\n     | Some (Inr (out', callee', rpv)) \\<Rightarrow>\n         \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n            expectation_gpv 1 \\<I>'\n             (\\<lambda>(r, s').\n                 expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                  (inline callee (rpv r) s'))\n             (callee' r'))", "apply(auto simp add: mult.commute intro!: nn_integral_cong split: split_indicator)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ xx. (case xx of Inl (x, xa) \\<Rightarrow> f x\n                           | Inr (out', callee', rpv) \\<Rightarrow>\n                               \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                                  expectation_gpv 1 \\<I>'\n                                   (\\<lambda>(r, s').\n expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv r) s'))\n                                   (callee' r'))\n                     \\<partial>measure_spmf (inline1 callee (c x') s') +\n  ennreal (pmf (the_gpv (inline callee (c x') s')) None) =\n  (\\<Sum>\\<^sup>+ xx.\n     ennreal (pmf (inline1 callee (c x') s') xx) *\n     (case xx of None \\<Rightarrow> 1 | Some (Inl (x, xa)) \\<Rightarrow> f x\n      | Some (Inr (out', callee', rpv)) \\<Rightarrow>\n          \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n             expectation_gpv 1 \\<I>'\n              (\\<lambda>(r, s').\n                  expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (rpv r) s'))\n              (callee' r')))\n\ngoal (3 subgoals):\n 1. \\<And>x' s'.\n       \\<lbrakk>z = Some (Pure (x', s'));\n        Pure (x', s') \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 2. \\<And>out' c'.\n       \\<lbrakk>z = Some (IO out' c');\n        IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 3. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> (\\<Sum>\\<^sup>+ xx.\n           ennreal (pmf (inline1 callee (c x') s') xx) *\n           (case xx of None \\<Rightarrow> 1\n            | Some (Inl (x, xa)) \\<Rightarrow> f x\n            | Some (Inr (out', callee', rpv)) \\<Rightarrow>\n                \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                   expectation_gpv 1 \\<I>'\n                    (\\<lambda>(r, s').\n                        expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                         (inline callee (rpv r) s'))\n                    (callee' r')))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> (\\<Sum>\\<^sup>+ xx.\n           ennreal (pmf (inline1 callee (c x') s') xx) *\n           (case xx of None \\<Rightarrow> 1\n            | Some (Inl (x, xa)) \\<Rightarrow> f x\n            | Some (Inr (out', callee', rpv)) \\<Rightarrow>\n                \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                   expectation_gpv 1 \\<I>'\n                    (\\<lambda>(r, s').\n                        expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                         (inline callee (rpv r) s'))\n                    (callee' r')))\n\ngoal (1 subgoal):\n 1. ennreal (pmf (the_gpv (callee s out)) z) *\n    (case z of None \\<Rightarrow> 1\n     | Some generat \\<Rightarrow>\n         \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n          (case z of None \\<Rightarrow> 1\n           | Some (Pure (r, s')) \\<Rightarrow>\n               \\<Sum>\\<^sup>+ x.\n                 ennreal (pmf (inline1 callee (c r) s') x) *\n                 (case x of None \\<Rightarrow> 1\n                  | Some (Inl (a, s)) \\<Rightarrow> f a\n                  | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n                      \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                         expectation_gpv 1 \\<I>'\n                          (\\<lambda>(x, s').\n                              expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                               (inline callee (rpv' x) s'))\n                          (rpv x))\n           | Some (IO out' rpv') \\<Rightarrow>\n               \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                  expectation_gpv 1 \\<I>'\n                   (\\<lambda>(x, s').\n                       expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                        (inline callee (c x) s'))\n                   (rpv' x))", "using Pure"], ["proof (prove)\nusing this:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> (\\<Sum>\\<^sup>+ xx.\n           ennreal (pmf (inline1 callee (c x') s') xx) *\n           (case xx of None \\<Rightarrow> 1\n            | Some (Inl (x, xa)) \\<Rightarrow> f x\n            | Some (Inr (out', callee', rpv)) \\<Rightarrow>\n                \\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n                   expectation_gpv 1 \\<I>'\n                    (\\<lambda>(r, s').\n                        expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                         (inline callee (rpv r) s'))\n                    (callee' r')))\n  z = Some (Pure (x', s'))\n  Pure (x', s') \\<in> set_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. ennreal (pmf (the_gpv (callee s out)) z) *\n    (case z of None \\<Rightarrow> 1\n     | Some generat \\<Rightarrow>\n         \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n          (case z of None \\<Rightarrow> 1\n           | Some (Pure (r, s')) \\<Rightarrow>\n               \\<Sum>\\<^sup>+ x.\n                 ennreal (pmf (inline1 callee (c r) s') x) *\n                 (case x of None \\<Rightarrow> 1\n                  | Some (Inl (a, s)) \\<Rightarrow> f a\n                  | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n                      \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                         expectation_gpv 1 \\<I>'\n                          (\\<lambda>(x, s').\n                              expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                               (inline callee (rpv' x) s'))\n                          (rpv x))\n           | Some (IO out' rpv') \\<Rightarrow>\n               \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                  expectation_gpv 1 \\<I>'\n                   (\\<lambda>(x, s').\n                       expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                        (inline callee (c x) s'))\n                   (rpv' x))", "by(simp add: mult_mono)"], ["proof (state)\nthis:\n  ennreal (pmf (the_gpv (callee s out)) z) *\n  (case z of None \\<Rightarrow> 1\n   | Some generat \\<Rightarrow>\n       \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n        (case z of None \\<Rightarrow> 1\n         | Some (Pure (r, s')) \\<Rightarrow>\n             \\<Sum>\\<^sup>+ x.\n               ennreal (pmf (inline1 callee (c r) s') x) *\n               (case x of None \\<Rightarrow> 1\n                | Some (Inl (a, s)) \\<Rightarrow> f a\n                | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 1 \\<I>'\n                        (\\<lambda>(x, s').\n                            expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv' x) s'))\n                        (rpv x))\n         | Some (IO out' rpv') \\<Rightarrow>\n             \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                expectation_gpv 1 \\<I>'\n                 (\\<lambda>(x, s').\n                     expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                      (inline callee (c x) s'))\n                 (rpv' x))\n\ngoal (2 subgoals):\n 1. \\<And>out' c'.\n       \\<lbrakk>z = Some (IO out' c');\n        IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 2. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>out' c'.\n       \\<lbrakk>z = Some (IO out' c');\n        IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 2. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "case IO'"], ["proof (state)\nthis:\n  z = Some (IO out' c')\n  IO out' c' \\<in> set_spmf (the_gpv (callee s out))\n\ngoal (2 subgoals):\n 1. \\<And>out' c'.\n       \\<lbrakk>z = Some (IO out' c');\n        IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 2. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "then"], ["proof (chain)\npicking this:\n  z = Some (IO out' c')\n  IO out' c' \\<in> set_spmf (the_gpv (callee s out))", "have out': \"out' \\<in> outs_\\<I> \\<I>'\""], ["proof (prove)\nusing this:\n  z = Some (IO out' c')\n  IO out' c' \\<in> set_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. out' \\<in> outs_\\<I> \\<I>'", "using WT_callee out step.prems"], ["proof (prove)\nusing this:\n  z = Some (IO out' c')\n  IO out' c' \\<in> set_spmf (the_gpv (callee s out))\n  \\<lbrakk>?x \\<in> outs_\\<I> \\<I>; I ?s\\<rbrakk>\n  \\<Longrightarrow> \\<I>' \\<turnstile>g callee ?s ?x \\<surd>\n  out \\<in> outs_\\<I> \\<I>\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. out' \\<in> outs_\\<I> \\<I>'", "by(auto dest: WT_gpvD)"], ["proof (state)\nthis:\n  out' \\<in> outs_\\<I> \\<I>'\n\ngoal (2 subgoals):\n 1. \\<And>out' c'.\n       \\<lbrakk>z = Some (IO out' c');\n        IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 2. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "have \"(INF r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)) \\<le> min (INF (r, s')\\<in>(\\<Union>r'\\<in>responses_\\<I> \\<I>' out'. results_gpv \\<I>' (c' r')). expectation_gpv' (c r)) 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> min (\\<Sqinter>(r,\n                  s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                             results_gpv \\<I>' (c' r').\n                  expectation_gpv' (c r))\n           1", "using IO' results_callee[OF out, of s] step.prems"], ["proof (prove)\nusing this:\n  z = Some (IO out' c')\n  IO out' c' \\<in> set_spmf (the_gpv (callee s out))\n  I s \\<Longrightarrow>\n  results_gpv \\<I>' (callee s out)\n  \\<subseteq> responses_\\<I> \\<I> out \\<times> {s. I s}\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> min (\\<Sqinter>(r,\n                  s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                             results_gpv \\<I>' (c' r').\n                  expectation_gpv' (c r))\n           1", "by(intro INF_mono min.boundedI)(auto intro: results_gpv.IO intro!: INF_lower2[OF resp] exp_resp)"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> min (\\<Sqinter>(r,\n                s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                           results_gpv \\<I>' (c' r').\n                expectation_gpv' (c r))\n         1\n\ngoal (2 subgoals):\n 1. \\<And>out' c'.\n       \\<lbrakk>z = Some (IO out' c');\n        IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 2. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> min (\\<Sqinter>(r,\n                s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                           results_gpv \\<I>' (c' r').\n                expectation_gpv' (c r))\n         1\n\ngoal (2 subgoals):\n 1. \\<And>out' c'.\n       \\<lbrakk>z = Some (IO out' c');\n        IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 2. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "have \"\\<dots> \\<le> (INF r'\\<in>responses_\\<I> \\<I>' out'. min (INF (r, s')\\<in>results_gpv \\<I>' (c' r'). expectation_gpv' (c r)) 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (\\<Sqinter>(r,\n            s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                       results_gpv \\<I>' (c' r').\n            expectation_gpv' (c r))\n     1\n    \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n              min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' r').\n                      expectation_gpv' (c r))\n               1)", "using resp out'"], ["proof (prove)\nusing this:\n  response \\<in> responses_\\<I> \\<I> out\n  out' \\<in> outs_\\<I> \\<I>'\n\ngoal (1 subgoal):\n 1. min (\\<Sqinter>(r,\n            s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                       results_gpv \\<I>' (c' r').\n            expectation_gpv' (c r))\n     1\n    \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n              min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' r').\n                      expectation_gpv' (c r))\n               1)", "unfolding inf_min[symmetric] in_outs_\\<I>_iff_responses_\\<I>"], ["proof (prove)\nusing this:\n  response \\<in> responses_\\<I> \\<I> out\n  responses_\\<I> \\<I>' out' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>(r,\n        s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                   results_gpv \\<I>' (c' r').\n        expectation_gpv' (c r)) \\<sqinter>\n    1\n    \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n              (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' r').\n                  expectation_gpv' (c r)) \\<sqinter>\n              1)", "by(subst INF_inf_const2)(auto simp add: INF_UNION)"], ["proof (state)\nthis:\n  min (\\<Sqinter>(r,\n          s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                     results_gpv \\<I>' (c' r').\n          expectation_gpv' (c r))\n   1\n  \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n            min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' r').\n                    expectation_gpv' (c r))\n             1)\n\ngoal (2 subgoals):\n 1. \\<And>out' c'.\n       \\<lbrakk>z = Some (IO out' c');\n        IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 2. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "also"], ["proof (state)\nthis:\n  min (\\<Sqinter>(r,\n          s')\\<in>\\<Union>r'\\<in>responses_\\<I> \\<I>' out'.\n                     results_gpv \\<I>' (c' r').\n          expectation_gpv' (c r))\n   1\n  \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n            min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' r').\n                    expectation_gpv' (c r))\n             1)\n\ngoal (2 subgoals):\n 1. \\<And>out' c'.\n       \\<lbrakk>z = Some (IO out' c');\n        IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 2. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "have \"\\<dots> \\<le> (INF r'\\<in>responses_\\<I> \\<I>' out'. expectation_gpv 1 \\<I>' (\\<lambda>(r', s'). expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x) (inline callee (c r') s')) (c' r'))\"\n            (is \"_ \\<le> (INF r'\\<in>_. ?r r')\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n        min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' r').\n                expectation_gpv' (c r))\n         1)\n    \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n              expectation_gpv 1 \\<I>'\n               (\\<lambda>(r', s').\n                   expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                    (inline callee (c r') s'))\n               (c' r'))", "proof(rule INF_mono, rule bexI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' (?r'2 m)).\n               expectation_gpv' (c r))\n        1\n       \\<le> expectation_gpv 1 \\<I>'\n              (\\<lambda>(r', s').\n                  expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c r') s'))\n              (c' m)\n 2. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       ?r'2 m \\<in> responses_\\<I> \\<I>' out'", "fix r'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' (?r'2 m)).\n               expectation_gpv' (c r))\n        1\n       \\<le> expectation_gpv 1 \\<I>'\n              (\\<lambda>(r', s').\n                  expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c r') s'))\n              (c' m)\n 2. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       ?r'2 m \\<in> responses_\\<I> \\<I>' out'", "assume r': \"r' \\<in> responses_\\<I> \\<I>' out'\""], ["proof (state)\nthis:\n  r' \\<in> responses_\\<I> \\<I>' out'\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' (?r'2 m)).\n               expectation_gpv' (c r))\n        1\n       \\<le> expectation_gpv 1 \\<I>'\n              (\\<lambda>(r', s').\n                  expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c r') s'))\n              (c' m)\n 2. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       ?r'2 m \\<in> responses_\\<I> \\<I>' out'", "have fin: \"pfinite_gpv \\<I>' (c' r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_gpv \\<I>' (c' r')", "using callee[OF out, of s] IO' r' WT_callee[OF out, of s] step.prems"], ["proof (prove)\nusing this:\n  I s \\<Longrightarrow> pfinite_gpv \\<I>' (callee s out)\n  z = Some (IO out' c')\n  IO out' c' \\<in> set_spmf (the_gpv (callee s out))\n  r' \\<in> responses_\\<I> \\<I>' out'\n  I s \\<Longrightarrow> \\<I>' \\<turnstile>g callee s out \\<surd>\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. pfinite_gpv \\<I>' (c' r')", "by(auto dest: pfinite_gpv_ContD)"], ["proof (state)\nthis:\n  pfinite_gpv \\<I>' (c' r')\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' (?r'2 m)).\n               expectation_gpv' (c r))\n        1\n       \\<le> expectation_gpv 1 \\<I>'\n              (\\<lambda>(r', s').\n                  expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c r') s'))\n              (c' m)\n 2. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       ?r'2 m \\<in> responses_\\<I> \\<I>' out'", "have \"min (INF (r, s')\\<in>results_gpv \\<I>' (c' r'). expectation_gpv' (c r)) 1 \\<le> min (INF (r, s')\\<in>results_gpv \\<I>' (c' r'). expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c r) s')) 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' r').\n            expectation_gpv' (c r))\n     1\n    \\<le> min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' r').\n                  expectation_gpv2 (\\<lambda>(x, s). f x)\n                   (inline callee (c r) s'))\n           1", "using IO IO' step.prems out results_callee[OF out, of s] r'"], ["proof (prove)\nusing this:\n  x = Some (IO out c)\n  IO out c \\<in> set_spmf (the_gpv gpv)\n  z = Some (IO out' c')\n  IO out' c' \\<in> set_spmf (the_gpv (callee s out))\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n  out \\<in> outs_\\<I> \\<I>\n  I s \\<Longrightarrow>\n  results_gpv \\<I>' (callee s out)\n  \\<subseteq> responses_\\<I> \\<I> out \\<times> {s. I s}\n  r' \\<in> responses_\\<I> \\<I>' out'\n\ngoal (1 subgoal):\n 1. min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' r').\n            expectation_gpv' (c r))\n     1\n    \\<le> min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' r').\n                  expectation_gpv2 (\\<lambda>(x, s). f x)\n                   (inline callee (c r) s'))\n           1", "by(intro min.mono)(auto intro!: INF_mono rev_bexI step.IH dest: WT_gpv_ContD intro: results_gpv.IO)"], ["proof (state)\nthis:\n  min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' r').\n          expectation_gpv' (c r))\n   1\n  \\<le> min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' r').\n                expectation_gpv2 (\\<lambda>(x, s). f x)\n                 (inline callee (c r) s'))\n         1\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' (?r'2 m)).\n               expectation_gpv' (c r))\n        1\n       \\<le> expectation_gpv 1 \\<I>'\n              (\\<lambda>(r', s').\n                  expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c r') s'))\n              (c' m)\n 2. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       ?r'2 m \\<in> responses_\\<I> \\<I>' out'", "also"], ["proof (state)\nthis:\n  min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' r').\n          expectation_gpv' (c r))\n   1\n  \\<le> min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' r').\n                expectation_gpv2 (\\<lambda>(x, s). f x)\n                 (inline callee (c r) s'))\n         1\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' (?r'2 m)).\n               expectation_gpv' (c r))\n        1\n       \\<le> expectation_gpv 1 \\<I>'\n              (\\<lambda>(r', s').\n                  expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c r') s'))\n              (c' m)\n 2. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       ?r'2 m \\<in> responses_\\<I> \\<I>' out'", "have \"\\<dots> \\<le> ?r r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' r').\n            expectation_gpv2 (\\<lambda>(x, s). f x)\n             (inline callee (c r) s'))\n     1\n    \\<le> expectation_gpv 1 \\<I>'\n           (\\<lambda>(r', s').\n               expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                (inline callee (c r') s'))\n           (c' r')", "unfolding expectation_gpv2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' r').\n            expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n             (inline callee (c r) s'))\n     1\n    \\<le> expectation_gpv 1 \\<I>'\n           (\\<lambda>(r', s').\n               expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                (inline callee (c r') s'))\n           (c' r')", "using fin"], ["proof (prove)\nusing this:\n  pfinite_gpv \\<I>' (c' r')\n\ngoal (1 subgoal):\n 1. min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' r').\n            expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n             (inline callee (c r) s'))\n     1\n    \\<le> expectation_gpv 1 \\<I>'\n           (\\<lambda>(r', s').\n               expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                (inline callee (c r') s'))\n           (c' r')", "by(rule pfinite_INF_le_expectation_gpv)"], ["proof (state)\nthis:\n  min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' r').\n          expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee (c r) s'))\n   1\n  \\<le> expectation_gpv 1 \\<I>'\n         (\\<lambda>(r', s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (c r') s'))\n         (c' r')\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' (?r'2 m)).\n               expectation_gpv' (c r))\n        1\n       \\<le> expectation_gpv 1 \\<I>'\n              (\\<lambda>(r', s').\n                  expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c r') s'))\n              (c' m)\n 2. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       ?r'2 m \\<in> responses_\\<I> \\<I>' out'", "finally"], ["proof (chain)\npicking this:\n  min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' r').\n          expectation_gpv' (c r))\n   1\n  \\<le> expectation_gpv 1 \\<I>'\n         (\\<lambda>(r', s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (c r') s'))\n         (c' r')", "show \"min (INF (r, s')\\<in>results_gpv \\<I>' (c' r'). expectation_gpv' (c r)) 1 \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' r').\n          expectation_gpv' (c r))\n   1\n  \\<le> expectation_gpv 1 \\<I>'\n         (\\<lambda>(r', s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (c r') s'))\n         (c' r')\n\ngoal (1 subgoal):\n 1. min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' r').\n            expectation_gpv' (c r))\n     1\n    \\<le> expectation_gpv 1 \\<I>'\n           (\\<lambda>(r', s').\n               expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                (inline callee (c r') s'))\n           (c' r')", "."], ["proof (state)\nthis:\n  min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' r').\n          expectation_gpv' (c r))\n   1\n  \\<le> expectation_gpv 1 \\<I>'\n         (\\<lambda>(r', s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (c r') s'))\n         (c' r')\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       m \\<in> responses_\\<I> \\<I>' out' \\<Longrightarrow>\n       m \\<in> responses_\\<I> \\<I>' out'", "qed"], ["proof (state)\nthis:\n  (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n      min (\\<Sqinter>(r, s')\\<in>results_gpv \\<I>' (c' r').\n              expectation_gpv' (c r))\n       1)\n  \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n            expectation_gpv 1 \\<I>'\n             (\\<lambda>(r', s').\n                 expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                  (inline callee (c r') s'))\n             (c' r'))\n\ngoal (2 subgoals):\n 1. \\<And>out' c'.\n       \\<lbrakk>z = Some (IO out' c');\n        IO out' c' \\<in> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))\n 2. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n            expectation_gpv 1 \\<I>'\n             (\\<lambda>(r', s').\n                 expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                  (inline callee (c r') s'))\n             (c' r'))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n            expectation_gpv 1 \\<I>'\n             (\\<lambda>(r', s').\n                 expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                  (inline callee (c r') s'))\n             (c' r'))\n\ngoal (1 subgoal):\n 1. ennreal (pmf (the_gpv (callee s out)) z) *\n    (case z of None \\<Rightarrow> 1\n     | Some generat \\<Rightarrow>\n         \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n          (case z of None \\<Rightarrow> 1\n           | Some (Pure (r, s')) \\<Rightarrow>\n               \\<Sum>\\<^sup>+ x.\n                 ennreal (pmf (inline1 callee (c r) s') x) *\n                 (case x of None \\<Rightarrow> 1\n                  | Some (Inl (a, s)) \\<Rightarrow> f a\n                  | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n                      \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                         expectation_gpv 1 \\<I>'\n                          (\\<lambda>(x, s').\n                              expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                               (inline callee (rpv' x) s'))\n                          (rpv x))\n           | Some (IO out' rpv') \\<Rightarrow>\n               \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                  expectation_gpv 1 \\<I>'\n                   (\\<lambda>(x, s').\n                       expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                        (inline callee (c x) s'))\n                   (rpv' x))", "using IO'"], ["proof (prove)\nusing this:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> (\\<Sqinter>r'\\<in>responses_\\<I> \\<I>' out'.\n            expectation_gpv 1 \\<I>'\n             (\\<lambda>(r', s').\n                 expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                  (inline callee (c r') s'))\n             (c' r'))\n  z = Some (IO out' c')\n  IO out' c' \\<in> set_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. ennreal (pmf (the_gpv (callee s out)) z) *\n    (case z of None \\<Rightarrow> 1\n     | Some generat \\<Rightarrow>\n         \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n          (case z of None \\<Rightarrow> 1\n           | Some (Pure (r, s')) \\<Rightarrow>\n               \\<Sum>\\<^sup>+ x.\n                 ennreal (pmf (inline1 callee (c r) s') x) *\n                 (case x of None \\<Rightarrow> 1\n                  | Some (Inl (a, s)) \\<Rightarrow> f a\n                  | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n                      \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                         expectation_gpv 1 \\<I>'\n                          (\\<lambda>(x, s').\n                              expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                               (inline callee (rpv' x) s'))\n                          (rpv x))\n           | Some (IO out' rpv') \\<Rightarrow>\n               \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                  expectation_gpv 1 \\<I>'\n                   (\\<lambda>(x, s').\n                       expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                        (inline callee (c x) s'))\n                   (rpv' x))", "by(simp add: mult_mono)"], ["proof (state)\nthis:\n  ennreal (pmf (the_gpv (callee s out)) z) *\n  (case z of None \\<Rightarrow> 1\n   | Some generat \\<Rightarrow>\n       \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n        (case z of None \\<Rightarrow> 1\n         | Some (Pure (r, s')) \\<Rightarrow>\n             \\<Sum>\\<^sup>+ x.\n               ennreal (pmf (inline1 callee (c r) s') x) *\n               (case x of None \\<Rightarrow> 1\n                | Some (Inl (a, s)) \\<Rightarrow> f a\n                | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 1 \\<I>'\n                        (\\<lambda>(x, s').\n                            expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv' x) s'))\n                        (rpv x))\n         | Some (IO out' rpv') \\<Rightarrow>\n             \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                expectation_gpv 1 \\<I>'\n                 (\\<lambda>(x, s').\n                     expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                      (inline callee (c x) s'))\n                 (rpv' x))\n\ngoal (1 subgoal):\n 1. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "case outside"], ["proof (state)\nthis:\n  z = Some generat\n  generat \\<notin> set_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. \\<And>generat.\n       \\<lbrakk>z = Some generat;\n        generat \\<notin> set_spmf (the_gpv (callee s out))\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv (callee s out)) z) *\n                         (case z of None \\<Rightarrow> 1\n                          | Some generat \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n                               (case z of None \\<Rightarrow> 1\n                                | Some (Pure (r, s')) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal (pmf (inline1 callee (c r) s') x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x))\n                                | Some (IO out' rpv') \\<Rightarrow>\n                                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>'\n               out'.\n expectation_gpv 1 \\<I>'\n  (\\<lambda>(x, s').\n      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n       (inline callee (c x) s'))\n  (rpv' x))", "then"], ["proof (chain)\npicking this:\n  z = Some generat\n  generat \\<notin> set_spmf (the_gpv (callee s out))", "show ?thesis"], ["proof (prove)\nusing this:\n  z = Some generat\n  generat \\<notin> set_spmf (the_gpv (callee s out))\n\ngoal (1 subgoal):\n 1. ennreal (pmf (the_gpv (callee s out)) z) *\n    (case z of None \\<Rightarrow> 1\n     | Some generat \\<Rightarrow>\n         \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n          (case z of None \\<Rightarrow> 1\n           | Some (Pure (r, s')) \\<Rightarrow>\n               \\<Sum>\\<^sup>+ x.\n                 ennreal (pmf (inline1 callee (c r) s') x) *\n                 (case x of None \\<Rightarrow> 1\n                  | Some (Inl (a, s)) \\<Rightarrow> f a\n                  | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n                      \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                         expectation_gpv 1 \\<I>'\n                          (\\<lambda>(x, s').\n                              expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                               (inline callee (rpv' x) s'))\n                          (rpv x))\n           | Some (IO out' rpv') \\<Rightarrow>\n               \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                  expectation_gpv 1 \\<I>'\n                   (\\<lambda>(x, s').\n                       expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                        (inline callee (c x) s'))\n                   (rpv' x))", "by(simp add: in_set_spmf_iff_spmf)"], ["proof (state)\nthis:\n  ennreal (pmf (the_gpv (callee s out)) z) *\n  (case z of None \\<Rightarrow> 1\n   | Some generat \\<Rightarrow>\n       \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n        (case z of None \\<Rightarrow> 1\n         | Some (Pure (r, s')) \\<Rightarrow>\n             \\<Sum>\\<^sup>+ x.\n               ennreal (pmf (inline1 callee (c r) s') x) *\n               (case x of None \\<Rightarrow> 1\n                | Some (Inl (a, s)) \\<Rightarrow> f a\n                | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 1 \\<I>'\n                        (\\<lambda>(x, s').\n                            expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv' x) s'))\n                        (rpv x))\n         | Some (IO out' rpv') \\<Rightarrow>\n             \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                expectation_gpv 1 \\<I>'\n                 (\\<lambda>(x, s').\n                     expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                      (inline callee (c x) s'))\n                 (rpv' x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ennreal (pmf (the_gpv (callee s out)) z) *\n  (case z of None \\<Rightarrow> 1\n   | Some generat \\<Rightarrow>\n       \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> ennreal (pmf (the_gpv (callee s out)) z) *\n        (case z of None \\<Rightarrow> 1\n         | Some (Pure (r, s')) \\<Rightarrow>\n             \\<Sum>\\<^sup>+ x.\n               ennreal (pmf (inline1 callee (c r) s') x) *\n               (case x of None \\<Rightarrow> 1\n                | Some (Inl (a, s)) \\<Rightarrow> f a\n                | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                       expectation_gpv 1 \\<I>'\n                        (\\<lambda>(x, s').\n                            expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv' x) s'))\n                        (rpv x))\n         | Some (IO out' rpv') \\<Rightarrow>\n             \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                expectation_gpv 1 \\<I>'\n                 (\\<lambda>(x, s').\n                     expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                      (inline callee (c x) s'))\n                 (rpv' x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ z.\n     ennreal (pmf (the_gpv (callee s out)) z) *\n     (case z of None \\<Rightarrow> 1\n      | Some generat \\<Rightarrow>\n          \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n  \\<le> (\\<Sum>\\<^sup>+ z.\n           ennreal (pmf (the_gpv (callee s out)) z) *\n           (case z of None \\<Rightarrow> 1\n            | Some (Pure (r, s')) \\<Rightarrow>\n                \\<Sum>\\<^sup>+ x.\n                  ennreal (pmf (inline1 callee (c r) s') x) *\n                  (case x of None \\<Rightarrow> 1\n                   | Some (Inl (a, s)) \\<Rightarrow> f a\n                   | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n                       \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                          expectation_gpv 1 \\<I>'\n                           (\\<lambda>(x, s').\n                               expectation_gpv 1 \\<I>'\n                                (\\<lambda>(x, s). f x)\n                                (inline callee (rpv' x) s'))\n                           (rpv x))\n            | Some (IO out' rpv') \\<Rightarrow>\n                \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                   expectation_gpv 1 \\<I>'\n                    (\\<lambda>(x, s').\n                        expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                         (inline callee (c x) s'))\n                    (rpv' x)))\n\ngoal (2 subgoals):\n 1. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))\n 2. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ z.\n     ennreal (pmf (the_gpv (callee s out)) z) *\n     (case z of None \\<Rightarrow> 1\n      | Some generat \\<Rightarrow>\n          \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n  \\<le> (\\<Sum>\\<^sup>+ z.\n           ennreal (pmf (the_gpv (callee s out)) z) *\n           (case z of None \\<Rightarrow> 1\n            | Some (Pure (r, s')) \\<Rightarrow>\n                \\<Sum>\\<^sup>+ x.\n                  ennreal (pmf (inline1 callee (c r) s') x) *\n                  (case x of None \\<Rightarrow> 1\n                   | Some (Inl (a, s)) \\<Rightarrow> f a\n                   | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n                       \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                          expectation_gpv 1 \\<I>'\n                           (\\<lambda>(x, s').\n                               expectation_gpv 1 \\<I>'\n                                (\\<lambda>(x, s). f x)\n                                (inline callee (rpv' x) s'))\n                           (rpv x))\n            | Some (IO out' rpv') \\<Rightarrow>\n                \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                   expectation_gpv 1 \\<I>'\n                    (\\<lambda>(x, s').\n                        expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                         (inline callee (c x) s'))\n                    (rpv' x)))\n\ngoal (2 subgoals):\n 1. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))\n 2. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "have \"\\<dots> = (\\<Sum>\\<^sup>+ z. \\<Sum>\\<^sup>+ x.\n             ennreal (pmf (the_gpv (callee s out)) z) *\n             ennreal (pmf (case z of None \\<Rightarrow> return_pmf None | Some (Pure (x, xb)) \\<Rightarrow> inline1 callee (c x) xb | Some (IO out rpv') \\<Rightarrow> return_spmf (Inr (out, rpv', c))) x) *\n             (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a | Some (Inr (out, rpv, rpv')) \\<Rightarrow> \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n                expectation_gpv 1 \\<I>' (\\<lambda>(x, s'). expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv' x) s')) (rpv x)))\"\n        (is \"\\<dots> = (\\<Sum>\\<^sup>+ z. \\<Sum>\\<^sup>+ x. ?f x z)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ z.\n       ennreal (pmf (the_gpv (callee s out)) z) *\n       (case z of None \\<Rightarrow> 1\n        | Some (Pure (r, s')) \\<Rightarrow>\n            \\<Sum>\\<^sup>+ x.\n              ennreal (pmf (inline1 callee (c r) s') x) *\n              (case x of None \\<Rightarrow> 1\n               | Some (Inl (a, s)) \\<Rightarrow> f a\n               | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n                   \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                      expectation_gpv 1 \\<I>'\n                       (\\<lambda>(x, s').\n                           expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                            (inline callee (rpv' x) s'))\n                       (rpv x))\n        | Some (IO out' rpv') \\<Rightarrow>\n            \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n               expectation_gpv 1 \\<I>'\n                (\\<lambda>(x, s').\n                    expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (c x) s'))\n                (rpv' x))) =\n    (\\<Sum>\\<^sup>+ z.\n       \\<Sum>\\<^sup>+ x.\n         ennreal (pmf (the_gpv (callee s out)) z) *\n         ennreal\n          (pmf (case z of None \\<Rightarrow> return_pmf None\n                | Some (Pure (x, xb)) \\<Rightarrow> inline1 callee (c x) xb\n                | Some (IO out rpv') \\<Rightarrow>\n                    return_spmf (Inr (out, rpv', c)))\n            x) *\n         (case x of None \\<Rightarrow> 1\n          | Some (Inl (a, s)) \\<Rightarrow> f a\n          | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n              \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n                 expectation_gpv 1 \\<I>'\n                  (\\<lambda>(x, s').\n                      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (rpv' x) s'))\n                  (rpv x)))", "by(auto intro!: nn_integral_cong split!: option.split generat.split simp add: mult.assoc nn_integral_cmult ennreal_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ z.\n     ennreal (pmf (the_gpv (callee s out)) z) *\n     (case z of None \\<Rightarrow> 1\n      | Some (Pure (r, s')) \\<Rightarrow>\n          \\<Sum>\\<^sup>+ x.\n            ennreal (pmf (inline1 callee (c r) s') x) *\n            (case x of None \\<Rightarrow> 1\n             | Some (Inl (a, s)) \\<Rightarrow> f a\n             | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n                 \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                    expectation_gpv 1 \\<I>'\n                     (\\<lambda>(x, s').\n                         expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                          (inline callee (rpv' x) s'))\n                     (rpv x))\n      | Some (IO out' rpv') \\<Rightarrow>\n          \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n             expectation_gpv 1 \\<I>'\n              (\\<lambda>(x, s').\n                  expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c x) s'))\n              (rpv' x))) =\n  (\\<Sum>\\<^sup>+ z.\n     \\<Sum>\\<^sup>+ x.\n       ennreal (pmf (the_gpv (callee s out)) z) *\n       ennreal\n        (pmf (case z of None \\<Rightarrow> return_pmf None\n              | Some (Pure (x, xb)) \\<Rightarrow> inline1 callee (c x) xb\n              | Some (IO out rpv') \\<Rightarrow>\n                  return_spmf (Inr (out, rpv', c)))\n          x) *\n       (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n        | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n            \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n               expectation_gpv 1 \\<I>'\n                (\\<lambda>(x, s').\n                    expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (rpv' x) s'))\n                (rpv x)))\n\ngoal (2 subgoals):\n 1. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))\n 2. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ z.\n     ennreal (pmf (the_gpv (callee s out)) z) *\n     (case z of None \\<Rightarrow> 1\n      | Some (Pure (r, s')) \\<Rightarrow>\n          \\<Sum>\\<^sup>+ x.\n            ennreal (pmf (inline1 callee (c r) s') x) *\n            (case x of None \\<Rightarrow> 1\n             | Some (Inl (a, s)) \\<Rightarrow> f a\n             | Some (Inr (out', rpv, rpv')) \\<Rightarrow>\n                 \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n                    expectation_gpv 1 \\<I>'\n                     (\\<lambda>(x, s').\n                         expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                          (inline callee (rpv' x) s'))\n                     (rpv x))\n      | Some (IO out' rpv') \\<Rightarrow>\n          \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out'.\n             expectation_gpv 1 \\<I>'\n              (\\<lambda>(x, s').\n                  expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (c x) s'))\n              (rpv' x))) =\n  (\\<Sum>\\<^sup>+ z.\n     \\<Sum>\\<^sup>+ x.\n       ennreal (pmf (the_gpv (callee s out)) z) *\n       ennreal\n        (pmf (case z of None \\<Rightarrow> return_pmf None\n              | Some (Pure (x, xb)) \\<Rightarrow> inline1 callee (c x) xb\n              | Some (IO out rpv') \\<Rightarrow>\n                  return_spmf (Inr (out, rpv', c)))\n          x) *\n       (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n        | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n            \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n               expectation_gpv 1 \\<I>'\n                (\\<lambda>(x, s').\n                    expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (rpv' x) s'))\n                (rpv x)))\n\ngoal (2 subgoals):\n 1. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))\n 2. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "have \"(\\<Sum>\\<^sup>+ z. \\<Sum>\\<^sup>+ x. ?f x z) = (\\<Sum>\\<^sup>+ x. \\<Sum>\\<^sup>+ z. ?f x z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ z.\n       \\<Sum>\\<^sup>+ x.\n         ennreal (pmf (the_gpv (callee s out)) z) *\n         ennreal\n          (pmf (case z of None \\<Rightarrow> return_pmf None\n                | Some (Pure (x, xb)) \\<Rightarrow> inline1 callee (c x) xb\n                | Some (IO out rpv') \\<Rightarrow>\n                    return_spmf (Inr (out, rpv', c)))\n            x) *\n         (case x of None \\<Rightarrow> 1\n          | Some (Inl (a, s)) \\<Rightarrow> f a\n          | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n              \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n                 expectation_gpv 1 \\<I>'\n                  (\\<lambda>(x, s').\n                      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (rpv' x) s'))\n                  (rpv x))) =\n    (\\<Sum>\\<^sup>+ x.\n       \\<Sum>\\<^sup>+ z.\n         ennreal (pmf (the_gpv (callee s out)) z) *\n         ennreal\n          (pmf (case z of None \\<Rightarrow> return_pmf None\n                | Some (Pure (x, xb)) \\<Rightarrow> inline1 callee (c x) xb\n                | Some (IO out rpv') \\<Rightarrow>\n                    return_spmf (Inr (out, rpv', c)))\n            x) *\n         (case x of None \\<Rightarrow> 1\n          | Some (Inl (a, s)) \\<Rightarrow> f a\n          | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n              \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n                 expectation_gpv 1 \\<I>'\n                  (\\<lambda>(x, s').\n                      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (rpv' x) s'))\n                  (rpv x)))", "by(subst nn_integral_fst_count_space[where f=\"case_prod _\", simplified])(simp add: nn_integral_snd_count_space[symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ z.\n     \\<Sum>\\<^sup>+ x.\n       ennreal (pmf (the_gpv (callee s out)) z) *\n       ennreal\n        (pmf (case z of None \\<Rightarrow> return_pmf None\n              | Some (Pure (x, xb)) \\<Rightarrow> inline1 callee (c x) xb\n              | Some (IO out rpv') \\<Rightarrow>\n                  return_spmf (Inr (out, rpv', c)))\n          x) *\n       (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n        | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n            \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n               expectation_gpv 1 \\<I>'\n                (\\<lambda>(x, s').\n                    expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (rpv' x) s'))\n                (rpv x))) =\n  (\\<Sum>\\<^sup>+ x.\n     \\<Sum>\\<^sup>+ z.\n       ennreal (pmf (the_gpv (callee s out)) z) *\n       ennreal\n        (pmf (case z of None \\<Rightarrow> return_pmf None\n              | Some (Pure (x, xb)) \\<Rightarrow> inline1 callee (c x) xb\n              | Some (IO out rpv') \\<Rightarrow>\n                  return_spmf (Inr (out, rpv', c)))\n          x) *\n       (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n        | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n            \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n               expectation_gpv 1 \\<I>'\n                (\\<lambda>(x, s').\n                    expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (rpv' x) s'))\n                (rpv x)))\n\ngoal (2 subgoals):\n 1. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))\n 2. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ z.\n     \\<Sum>\\<^sup>+ x.\n       ennreal (pmf (the_gpv (callee s out)) z) *\n       ennreal\n        (pmf (case z of None \\<Rightarrow> return_pmf None\n              | Some (Pure (x, xb)) \\<Rightarrow> inline1 callee (c x) xb\n              | Some (IO out rpv') \\<Rightarrow>\n                  return_spmf (Inr (out, rpv', c)))\n          x) *\n       (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n        | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n            \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n               expectation_gpv 1 \\<I>'\n                (\\<lambda>(x, s').\n                    expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (rpv' x) s'))\n                (rpv x))) =\n  (\\<Sum>\\<^sup>+ x.\n     \\<Sum>\\<^sup>+ z.\n       ennreal (pmf (the_gpv (callee s out)) z) *\n       ennreal\n        (pmf (case z of None \\<Rightarrow> return_pmf None\n              | Some (Pure (x, xb)) \\<Rightarrow> inline1 callee (c x) xb\n              | Some (IO out rpv') \\<Rightarrow>\n                  return_spmf (Inr (out, rpv', c)))\n          x) *\n       (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n        | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n            \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n               expectation_gpv 1 \\<I>'\n                (\\<lambda>(x, s').\n                    expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (rpv' x) s'))\n                (rpv x)))\n\ngoal (2 subgoals):\n 1. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))\n 2. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "have \"\\<dots> = (\\<Sum>\\<^sup>+ x.\n              ennreal (pmf (the_gpv (callee s out) \\<bind> case_generat (\\<lambda>(x, y). inline1 callee (c x) y) (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c)))) x) *\n              (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                   \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r. expectation_gpv 1 \\<I>' (\\<lambda>(x, s'). expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv' x) s')) (rpv x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       \\<Sum>\\<^sup>+ z.\n         ennreal (pmf (the_gpv (callee s out)) z) *\n         ennreal\n          (pmf (case z of None \\<Rightarrow> return_pmf None\n                | Some (Pure (x, xb)) \\<Rightarrow> inline1 callee (c x) xb\n                | Some (IO out rpv') \\<Rightarrow>\n                    return_spmf (Inr (out, rpv', c)))\n            x) *\n         (case x of None \\<Rightarrow> 1\n          | Some (Inl (a, s)) \\<Rightarrow> f a\n          | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n              \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n                 expectation_gpv 1 \\<I>'\n                  (\\<lambda>(x, s').\n                      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (rpv' x) s'))\n                  (rpv x))) =\n    (\\<Sum>\\<^sup>+ x.\n       ennreal\n        (pmf (the_gpv (callee s out) \\<bind>\n              case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n               (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n          x) *\n       (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n        | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n            \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n               expectation_gpv 1 \\<I>'\n                (\\<lambda>(x, s').\n                    expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (rpv' x) s'))\n                (rpv x)))", "by(simp add: bind_spmf_def ennreal_pmf_bind nn_integral_multc[symmetric] nn_integral_measure_pmf)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     \\<Sum>\\<^sup>+ z.\n       ennreal (pmf (the_gpv (callee s out)) z) *\n       ennreal\n        (pmf (case z of None \\<Rightarrow> return_pmf None\n              | Some (Pure (x, xb)) \\<Rightarrow> inline1 callee (c x) xb\n              | Some (IO out rpv') \\<Rightarrow>\n                  return_spmf (Inr (out, rpv', c)))\n          x) *\n       (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n        | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n            \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n               expectation_gpv 1 \\<I>'\n                (\\<lambda>(x, s').\n                    expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (rpv' x) s'))\n                (rpv x))) =\n  (\\<Sum>\\<^sup>+ x.\n     ennreal\n      (pmf (the_gpv (callee s out) \\<bind>\n            case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n             (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n        x) *\n     (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n      | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n          \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n             expectation_gpv 1 \\<I>'\n              (\\<lambda>(x, s').\n                  expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (rpv' x) s'))\n              (rpv x)))\n\ngoal (2 subgoals):\n 1. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<in> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))\n 2. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> (\\<Sum>\\<^sup>+ x.\n           ennreal\n            (pmf (the_gpv (callee s out) \\<bind>\n                  case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n                   (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n              x) *\n           (case x of None \\<Rightarrow> 1\n            | Some (Inl (a, s)) \\<Rightarrow> f a\n            | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                   expectation_gpv 1 \\<I>'\n                    (\\<lambda>(x, s').\n                        expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                         (inline callee (rpv' x) s'))\n                    (rpv x)))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> (\\<Sum>\\<^sup>+ x.\n           ennreal\n            (pmf (the_gpv (callee s out) \\<bind>\n                  case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n                   (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n              x) *\n           (case x of None \\<Rightarrow> 1\n            | Some (Inl (a, s)) \\<Rightarrow> f a\n            | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                   expectation_gpv 1 \\<I>'\n                    (\\<lambda>(x, s').\n                        expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                         (inline callee (rpv' x) s'))\n                    (rpv x)))\n\ngoal (1 subgoal):\n 1. ennreal (pmf (the_gpv gpv) x) *\n    (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n     | Some (IO out c) \\<Rightarrow>\n         \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> ennreal (pmf (the_gpv gpv) x) *\n          (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n           | Some (IO out c) \\<Rightarrow>\n               \\<Sum>\\<^sup>+ x.\n                 ennreal\n                  (pmf (the_gpv (callee s out) \\<bind>\n                        case_generat\n                         (\\<lambda>(x, y). inline1 callee (c x) y)\n                         (\\<lambda>out rpv'.\n                             return_spmf (Inr (out, rpv', c))))\n                    x) *\n                 (case x of None \\<Rightarrow> 1\n                  | Some (Inl (a, s)) \\<Rightarrow> f a\n                  | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                      \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                         expectation_gpv 1 \\<I>'\n                          (\\<lambda>(x, s').\n                              expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                               (inline callee (rpv' x) s'))\n                          (rpv x)))", "using IO"], ["proof (prove)\nusing this:\n  (\\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> (\\<Sum>\\<^sup>+ x.\n           ennreal\n            (pmf (the_gpv (callee s out) \\<bind>\n                  case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n                   (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n              x) *\n           (case x of None \\<Rightarrow> 1\n            | Some (Inl (a, s)) \\<Rightarrow> f a\n            | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                   expectation_gpv 1 \\<I>'\n                    (\\<lambda>(x, s').\n                        expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                         (inline callee (rpv' x) s'))\n                    (rpv x)))\n  x = Some (IO out c)\n  IO out c \\<in> set_spmf (the_gpv gpv)\n\ngoal (1 subgoal):\n 1. ennreal (pmf (the_gpv gpv) x) *\n    (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n     | Some (IO out c) \\<Rightarrow>\n         \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> ennreal (pmf (the_gpv gpv) x) *\n          (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n           | Some (IO out c) \\<Rightarrow>\n               \\<Sum>\\<^sup>+ x.\n                 ennreal\n                  (pmf (the_gpv (callee s out) \\<bind>\n                        case_generat\n                         (\\<lambda>(x, y). inline1 callee (c x) y)\n                         (\\<lambda>out rpv'.\n                             return_spmf (Inr (out, rpv', c))))\n                    x) *\n                 (case x of None \\<Rightarrow> 1\n                  | Some (Inl (a, s)) \\<Rightarrow> f a\n                  | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                      \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                         expectation_gpv 1 \\<I>'\n                          (\\<lambda>(x, s').\n                              expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                               (inline callee (rpv' x) s'))\n                          (rpv x)))", "by(auto intro!: mult_mono)"], ["proof (state)\nthis:\n  ennreal (pmf (the_gpv gpv) x) *\n  (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n   | Some (IO out c) \\<Rightarrow>\n       \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> ennreal (pmf (the_gpv gpv) x) *\n        (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n         | Some (IO out c) \\<Rightarrow>\n             \\<Sum>\\<^sup>+ x.\n               ennreal\n                (pmf (the_gpv (callee s out) \\<bind>\n                      case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n                       (\\<lambda>out rpv'.\n                           return_spmf (Inr (out, rpv', c))))\n                  x) *\n               (case x of None \\<Rightarrow> 1\n                | Some (Inl (a, s)) \\<Rightarrow> f a\n                | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                       expectation_gpv 1 \\<I>'\n                        (\\<lambda>(x, s').\n                            expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv' x) s'))\n                        (rpv x)))\n\ngoal (1 subgoal):\n 1. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "case outside"], ["proof (state)\nthis:\n  x = Some (IO out c)\n  IO out c \\<notin> set_spmf (the_gpv gpv)\n\ngoal (1 subgoal):\n 1. \\<And>out c.\n       \\<lbrakk>x = Some (IO out c);\n        IO out c \\<notin> set_spmf (the_gpv gpv)\\<rbrakk>\n       \\<Longrightarrow> ennreal (pmf (the_gpv gpv) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Pure a) \\<Rightarrow> f a\n                          | Some (IO out c) \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                         \\<le> ennreal (pmf (the_gpv gpv) x) *\n                               (case x of None \\<Rightarrow> 1\n                                | Some (Pure a) \\<Rightarrow> f a\n                                | Some (IO out c) \\<Rightarrow>\n                                    \\<Sum>\\<^sup>+ x.\nennreal\n (pmf (the_gpv (callee s out) \\<bind>\n       case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n        (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n   x) *\n(case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n     \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n        expectation_gpv 1 \\<I>'\n         (\\<lambda>(x, s').\n             expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n              (inline callee (rpv' x) s'))\n         (rpv x)))", "then"], ["proof (chain)\npicking this:\n  x = Some (IO out c)\n  IO out c \\<notin> set_spmf (the_gpv gpv)", "show ?thesis"], ["proof (prove)\nusing this:\n  x = Some (IO out c)\n  IO out c \\<notin> set_spmf (the_gpv gpv)\n\ngoal (1 subgoal):\n 1. ennreal (pmf (the_gpv gpv) x) *\n    (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n     | Some (IO out c) \\<Rightarrow>\n         \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n    \\<le> ennreal (pmf (the_gpv gpv) x) *\n          (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n           | Some (IO out c) \\<Rightarrow>\n               \\<Sum>\\<^sup>+ x.\n                 ennreal\n                  (pmf (the_gpv (callee s out) \\<bind>\n                        case_generat\n                         (\\<lambda>(x, y). inline1 callee (c x) y)\n                         (\\<lambda>out rpv'.\n                             return_spmf (Inr (out, rpv', c))))\n                    x) *\n                 (case x of None \\<Rightarrow> 1\n                  | Some (Inl (a, s)) \\<Rightarrow> f a\n                  | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                      \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                         expectation_gpv 1 \\<I>'\n                          (\\<lambda>(x, s').\n                              expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                               (inline callee (rpv' x) s'))\n                          (rpv x)))", "by(simp add: in_set_spmf_iff_spmf)"], ["proof (state)\nthis:\n  ennreal (pmf (the_gpv gpv) x) *\n  (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n   | Some (IO out c) \\<Rightarrow>\n       \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> ennreal (pmf (the_gpv gpv) x) *\n        (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n         | Some (IO out c) \\<Rightarrow>\n             \\<Sum>\\<^sup>+ x.\n               ennreal\n                (pmf (the_gpv (callee s out) \\<bind>\n                      case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n                       (\\<lambda>out rpv'.\n                           return_spmf (Inr (out, rpv', c))))\n                  x) *\n               (case x of None \\<Rightarrow> 1\n                | Some (Inl (a, s)) \\<Rightarrow> f a\n                | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                       expectation_gpv 1 \\<I>'\n                        (\\<lambda>(x, s').\n                            expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv' x) s'))\n                        (rpv x)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ennreal (pmf (the_gpv gpv) x) *\n  (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n   | Some (IO out c) \\<Rightarrow>\n       \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r))\n  \\<le> ennreal (pmf (the_gpv gpv) x) *\n        (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n         | Some (IO out c) \\<Rightarrow>\n             \\<Sum>\\<^sup>+ x.\n               ennreal\n                (pmf (the_gpv (callee s out) \\<bind>\n                      case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n                       (\\<lambda>out rpv'.\n                           return_spmf (Inr (out, rpv', c))))\n                  x) *\n               (case x of None \\<Rightarrow> 1\n                | Some (Inl (a, s)) \\<Rightarrow> f a\n                | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                    \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                       expectation_gpv 1 \\<I>'\n                        (\\<lambda>(x, s').\n                            expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                             (inline callee (rpv' x) s'))\n                        (rpv x)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     ennreal (pmf (the_gpv gpv) x) *\n     (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n      | Some (IO out c) \\<Rightarrow>\n          \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n  \\<le> (\\<Sum>\\<^sup>+ x.\n           ennreal (pmf (the_gpv gpv) x) *\n           (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n            | Some (IO out c) \\<Rightarrow>\n                \\<Sum>\\<^sup>+ x.\n                  ennreal\n                   (pmf (the_gpv (callee s out) \\<bind>\n                         case_generat\n                          (\\<lambda>(x, y). inline1 callee (c x) y)\n                          (\\<lambda>out rpv'.\n                              return_spmf (Inr (out, rpv', c))))\n                     x) *\n                  (case x of None \\<Rightarrow> 1\n                   | Some (Inl (a, s)) \\<Rightarrow> f a\n                   | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                       \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                          expectation_gpv 1 \\<I>'\n                           (\\<lambda>(x, s').\n                               expectation_gpv 1 \\<I>'\n                                (\\<lambda>(x, s). f x)\n                                (inline callee (rpv' x) s'))\n                           (rpv x))))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 1 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         1 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     ennreal (pmf (the_gpv gpv) x) *\n     (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n      | Some (IO out c) \\<Rightarrow>\n          \\<Sqinter>r\\<in>responses_\\<I> \\<I> out. expectation_gpv' (c r)))\n  \\<le> (\\<Sum>\\<^sup>+ x.\n           ennreal (pmf (the_gpv gpv) x) *\n           (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n            | Some (IO out c) \\<Rightarrow>\n                \\<Sum>\\<^sup>+ x.\n                  ennreal\n                   (pmf (the_gpv (callee s out) \\<bind>\n                         case_generat\n                          (\\<lambda>(x, y). inline1 callee (c x) y)\n                          (\\<lambda>out rpv'.\n                              return_spmf (Inr (out, rpv', c))))\n                     x) *\n                  (case x of None \\<Rightarrow> 1\n                   | Some (Inl (a, s)) \\<Rightarrow> f a\n                   | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                       \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                          expectation_gpv 1 \\<I>'\n                           (\\<lambda>(x, s').\n                               expectation_gpv 1 \\<I>'\n                                (\\<lambda>(x, s). f x)\n                                (inline callee (rpv' x) s'))\n                           (rpv x))))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 1 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         1 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "have \"\\<dots> = (\\<Sum>\\<^sup>+ y. \\<Sum>\\<^sup>+ x.\n         ennreal (pmf (the_gpv gpv) y) *\n         ennreal (case y of None \\<Rightarrow> pmf (return_pmf None) x | Some (Pure xa) \\<Rightarrow> pmf (return_spmf (Inl (xa, s))) x\n                | Some (IO out rpv) \\<Rightarrow>\n                    pmf (bind_spmf (the_gpv (callee s out)) (\\<lambda>generat' \\<Rightarrow> case generat' of Pure (x, y) \\<Rightarrow> inline1 callee (rpv x) y | IO out rpv' \\<Rightarrow> return_spmf (Inr (out, rpv', rpv)))) x) *\n         (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a \n         | Some (Inr (out, rpv, rpv')) \\<Rightarrow> \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out. expectation_gpv 1 \\<I>' (\\<lambda>(x, s'). expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv' x) s')) (rpv x)))\"\n    (is \"_ = (\\<Sum>\\<^sup>+ y. \\<Sum>\\<^sup>+ x. ?f x y)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal (pmf (the_gpv gpv) x) *\n       (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n        | Some (IO out c) \\<Rightarrow>\n            \\<Sum>\\<^sup>+ x.\n              ennreal\n               (pmf (the_gpv (callee s out) \\<bind>\n                     case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n                      (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n                 x) *\n              (case x of None \\<Rightarrow> 1\n               | Some (Inl (a, s)) \\<Rightarrow> f a\n               | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                   \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                      expectation_gpv 1 \\<I>'\n                       (\\<lambda>(x, s').\n                           expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                            (inline callee (rpv' x) s'))\n                       (rpv x)))) =\n    (\\<Sum>\\<^sup>+ y.\n       \\<Sum>\\<^sup>+ x.\n         ennreal (pmf (the_gpv gpv) y) *\n         ennreal\n          (case y of None \\<Rightarrow> pmf (return_pmf None) x\n           | Some (Pure xa) \\<Rightarrow> pmf (return_spmf (Inl (xa, s))) x\n           | Some (IO out rpv) \\<Rightarrow>\n               pmf (the_gpv (callee s out) \\<bind>\n                    (\\<lambda>x.\n                        case x of\n                        Pure (x, y) \\<Rightarrow> inline1 callee (rpv x) y\n                        | IO out rpv' \\<Rightarrow>\n                            return_spmf (Inr (out, rpv', rpv))))\n                x) *\n         (case x of None \\<Rightarrow> 1\n          | Some (Inl (a, s)) \\<Rightarrow> f a\n          | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n              \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n                 expectation_gpv 1 \\<I>'\n                  (\\<lambda>(x, s').\n                      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (rpv' x) s'))\n                  (rpv x)))", "by(auto intro!: nn_integral_cong split!: option.split generat.split simp add: nn_integral_cmult mult.assoc ennreal_indicator)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     ennreal (pmf (the_gpv gpv) x) *\n     (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n      | Some (IO out c) \\<Rightarrow>\n          \\<Sum>\\<^sup>+ x.\n            ennreal\n             (pmf (the_gpv (callee s out) \\<bind>\n                   case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n                    (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n               x) *\n            (case x of None \\<Rightarrow> 1\n             | Some (Inl (a, s)) \\<Rightarrow> f a\n             | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                 \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                    expectation_gpv 1 \\<I>'\n                     (\\<lambda>(x, s').\n                         expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                          (inline callee (rpv' x) s'))\n                     (rpv x)))) =\n  (\\<Sum>\\<^sup>+ y.\n     \\<Sum>\\<^sup>+ x.\n       ennreal (pmf (the_gpv gpv) y) *\n       ennreal\n        (case y of None \\<Rightarrow> pmf (return_pmf None) x\n         | Some (Pure xa) \\<Rightarrow> pmf (return_spmf (Inl (xa, s))) x\n         | Some (IO out rpv) \\<Rightarrow>\n             pmf (the_gpv (callee s out) \\<bind>\n                  (\\<lambda>x.\n                      case x of\n                      Pure (x, y) \\<Rightarrow> inline1 callee (rpv x) y\n                      | IO out rpv' \\<Rightarrow>\n                          return_spmf (Inr (out, rpv', rpv))))\n              x) *\n       (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n        | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n            \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n               expectation_gpv 1 \\<I>'\n                (\\<lambda>(x, s').\n                    expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (rpv' x) s'))\n                (rpv x)))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 1 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         1 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     ennreal (pmf (the_gpv gpv) x) *\n     (case x of None \\<Rightarrow> 1 | Some (Pure a) \\<Rightarrow> f a\n      | Some (IO out c) \\<Rightarrow>\n          \\<Sum>\\<^sup>+ x.\n            ennreal\n             (pmf (the_gpv (callee s out) \\<bind>\n                   case_generat (\\<lambda>(x, y). inline1 callee (c x) y)\n                    (\\<lambda>out rpv'. return_spmf (Inr (out, rpv', c))))\n               x) *\n            (case x of None \\<Rightarrow> 1\n             | Some (Inl (a, s)) \\<Rightarrow> f a\n             | Some (Inr (r, rpv, rpv')) \\<Rightarrow>\n                 \\<Sqinter>x\\<in>responses_\\<I> \\<I>' r.\n                    expectation_gpv 1 \\<I>'\n                     (\\<lambda>(x, s').\n                         expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                          (inline callee (rpv' x) s'))\n                     (rpv x)))) =\n  (\\<Sum>\\<^sup>+ y.\n     \\<Sum>\\<^sup>+ x.\n       ennreal (pmf (the_gpv gpv) y) *\n       ennreal\n        (case y of None \\<Rightarrow> pmf (return_pmf None) x\n         | Some (Pure xa) \\<Rightarrow> pmf (return_spmf (Inl (xa, s))) x\n         | Some (IO out rpv) \\<Rightarrow>\n             pmf (the_gpv (callee s out) \\<bind>\n                  (\\<lambda>x.\n                      case x of\n                      Pure (x, y) \\<Rightarrow> inline1 callee (rpv x) y\n                      | IO out rpv' \\<Rightarrow>\n                          return_spmf (Inr (out, rpv', rpv))))\n              x) *\n       (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n        | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n            \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n               expectation_gpv 1 \\<I>'\n                (\\<lambda>(x, s').\n                    expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (rpv' x) s'))\n                (rpv x)))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 1 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         1 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "have \"(\\<Sum>\\<^sup>+ y. \\<Sum>\\<^sup>+ x. ?f x y) = (\\<Sum>\\<^sup>+ x. \\<Sum>\\<^sup>+ y. ?f x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ y.\n       \\<Sum>\\<^sup>+ x.\n         ennreal (pmf (the_gpv gpv) y) *\n         ennreal\n          (case y of None \\<Rightarrow> pmf (return_pmf None) x\n           | Some (Pure xa) \\<Rightarrow> pmf (return_spmf (Inl (xa, s))) x\n           | Some (IO out rpv) \\<Rightarrow>\n               pmf (the_gpv (callee s out) \\<bind>\n                    (\\<lambda>x.\n                        case x of\n                        Pure (x, y) \\<Rightarrow> inline1 callee (rpv x) y\n                        | IO out rpv' \\<Rightarrow>\n                            return_spmf (Inr (out, rpv', rpv))))\n                x) *\n         (case x of None \\<Rightarrow> 1\n          | Some (Inl (a, s)) \\<Rightarrow> f a\n          | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n              \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n                 expectation_gpv 1 \\<I>'\n                  (\\<lambda>(x, s').\n                      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (rpv' x) s'))\n                  (rpv x))) =\n    (\\<Sum>\\<^sup>+ x.\n       \\<Sum>\\<^sup>+ y.\n         ennreal (pmf (the_gpv gpv) y) *\n         ennreal\n          (case y of None \\<Rightarrow> pmf (return_pmf None) x\n           | Some (Pure xa) \\<Rightarrow> pmf (return_spmf (Inl (xa, s))) x\n           | Some (IO out rpv) \\<Rightarrow>\n               pmf (the_gpv (callee s out) \\<bind>\n                    (\\<lambda>x.\n                        case x of\n                        Pure (x, y) \\<Rightarrow> inline1 callee (rpv x) y\n                        | IO out rpv' \\<Rightarrow>\n                            return_spmf (Inr (out, rpv', rpv))))\n                x) *\n         (case x of None \\<Rightarrow> 1\n          | Some (Inl (a, s)) \\<Rightarrow> f a\n          | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n              \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n                 expectation_gpv 1 \\<I>'\n                  (\\<lambda>(x, s').\n                      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (rpv' x) s'))\n                  (rpv x)))", "by(subst nn_integral_fst_count_space[where f=\"case_prod _\", simplified])(simp add: nn_integral_snd_count_space[symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     \\<Sum>\\<^sup>+ x.\n       ennreal (pmf (the_gpv gpv) y) *\n       ennreal\n        (case y of None \\<Rightarrow> pmf (return_pmf None) x\n         | Some (Pure xa) \\<Rightarrow> pmf (return_spmf (Inl (xa, s))) x\n         | Some (IO out rpv) \\<Rightarrow>\n             pmf (the_gpv (callee s out) \\<bind>\n                  (\\<lambda>x.\n                      case x of\n                      Pure (x, y) \\<Rightarrow> inline1 callee (rpv x) y\n                      | IO out rpv' \\<Rightarrow>\n                          return_spmf (Inr (out, rpv', rpv))))\n              x) *\n       (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n        | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n            \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n               expectation_gpv 1 \\<I>'\n                (\\<lambda>(x, s').\n                    expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (rpv' x) s'))\n                (rpv x))) =\n  (\\<Sum>\\<^sup>+ x.\n     \\<Sum>\\<^sup>+ y.\n       ennreal (pmf (the_gpv gpv) y) *\n       ennreal\n        (case y of None \\<Rightarrow> pmf (return_pmf None) x\n         | Some (Pure xa) \\<Rightarrow> pmf (return_spmf (Inl (xa, s))) x\n         | Some (IO out rpv) \\<Rightarrow>\n             pmf (the_gpv (callee s out) \\<bind>\n                  (\\<lambda>x.\n                      case x of\n                      Pure (x, y) \\<Rightarrow> inline1 callee (rpv x) y\n                      | IO out rpv' \\<Rightarrow>\n                          return_spmf (Inr (out, rpv', rpv))))\n              x) *\n       (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n        | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n            \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n               expectation_gpv 1 \\<I>'\n                (\\<lambda>(x, s').\n                    expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (rpv' x) s'))\n                (rpv x)))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 1 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         1 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ y.\n     \\<Sum>\\<^sup>+ x.\n       ennreal (pmf (the_gpv gpv) y) *\n       ennreal\n        (case y of None \\<Rightarrow> pmf (return_pmf None) x\n         | Some (Pure xa) \\<Rightarrow> pmf (return_spmf (Inl (xa, s))) x\n         | Some (IO out rpv) \\<Rightarrow>\n             pmf (the_gpv (callee s out) \\<bind>\n                  (\\<lambda>x.\n                      case x of\n                      Pure (x, y) \\<Rightarrow> inline1 callee (rpv x) y\n                      | IO out rpv' \\<Rightarrow>\n                          return_spmf (Inr (out, rpv', rpv))))\n              x) *\n       (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n        | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n            \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n               expectation_gpv 1 \\<I>'\n                (\\<lambda>(x, s').\n                    expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (rpv' x) s'))\n                (rpv x))) =\n  (\\<Sum>\\<^sup>+ x.\n     \\<Sum>\\<^sup>+ y.\n       ennreal (pmf (the_gpv gpv) y) *\n       ennreal\n        (case y of None \\<Rightarrow> pmf (return_pmf None) x\n         | Some (Pure xa) \\<Rightarrow> pmf (return_spmf (Inl (xa, s))) x\n         | Some (IO out rpv) \\<Rightarrow>\n             pmf (the_gpv (callee s out) \\<bind>\n                  (\\<lambda>x.\n                      case x of\n                      Pure (x, y) \\<Rightarrow> inline1 callee (rpv x) y\n                      | IO out rpv' \\<Rightarrow>\n                          return_spmf (Inr (out, rpv', rpv))))\n              x) *\n       (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n        | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n            \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n               expectation_gpv 1 \\<I>'\n                (\\<lambda>(x, s').\n                    expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (rpv' x) s'))\n                (rpv x)))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 1 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         1 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "have \"\\<dots> = (\\<Sum>\\<^sup>+ x. (pmf (inline1 callee gpv s) x) * (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a |\n        Some (Inr (out, rpv, rpv')) \\<Rightarrow> \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out. expectation_gpv 1 \\<I>' (\\<lambda>(x, s'). expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv' x) s')) (rpv x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       \\<Sum>\\<^sup>+ y.\n         ennreal (pmf (the_gpv gpv) y) *\n         ennreal\n          (case y of None \\<Rightarrow> pmf (return_pmf None) x\n           | Some (Pure xa) \\<Rightarrow> pmf (return_spmf (Inl (xa, s))) x\n           | Some (IO out rpv) \\<Rightarrow>\n               pmf (the_gpv (callee s out) \\<bind>\n                    (\\<lambda>x.\n                        case x of\n                        Pure (x, y) \\<Rightarrow> inline1 callee (rpv x) y\n                        | IO out rpv' \\<Rightarrow>\n                            return_spmf (Inr (out, rpv', rpv))))\n                x) *\n         (case x of None \\<Rightarrow> 1\n          | Some (Inl (a, s)) \\<Rightarrow> f a\n          | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n              \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n                 expectation_gpv 1 \\<I>'\n                  (\\<lambda>(x, s').\n                      expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                       (inline callee (rpv' x) s'))\n                  (rpv x))) =\n    (\\<Sum>\\<^sup>+ x.\n       ennreal (pmf (inline1 callee gpv s) x) *\n       (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n        | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n            \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n               expectation_gpv 1 \\<I>'\n                (\\<lambda>(x, s').\n                    expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (rpv' x) s'))\n                (rpv x)))", "by(rewrite in \"_ = \\<hole>\" inline1.simps)\n      (auto simp add: bind_spmf_def ennreal_pmf_bind nn_integral_multc[symmetric] nn_integral_measure_pmf intro!: nn_integral_cong split: option.split generat.split)"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     \\<Sum>\\<^sup>+ y.\n       ennreal (pmf (the_gpv gpv) y) *\n       ennreal\n        (case y of None \\<Rightarrow> pmf (return_pmf None) x\n         | Some (Pure xa) \\<Rightarrow> pmf (return_spmf (Inl (xa, s))) x\n         | Some (IO out rpv) \\<Rightarrow>\n             pmf (the_gpv (callee s out) \\<bind>\n                  (\\<lambda>x.\n                      case x of\n                      Pure (x, y) \\<Rightarrow> inline1 callee (rpv x) y\n                      | IO out rpv' \\<Rightarrow>\n                          return_spmf (Inr (out, rpv', rpv))))\n              x) *\n       (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n        | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n            \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n               expectation_gpv 1 \\<I>'\n                (\\<lambda>(x, s').\n                    expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (rpv' x) s'))\n                (rpv x))) =\n  (\\<Sum>\\<^sup>+ x.\n     ennreal (pmf (inline1 callee gpv s) x) *\n     (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n      | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n          \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n             expectation_gpv 1 \\<I>'\n              (\\<lambda>(x, s').\n                  expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (rpv' x) s'))\n              (rpv x)))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 1 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         1 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     \\<Sum>\\<^sup>+ y.\n       ennreal (pmf (the_gpv gpv) y) *\n       ennreal\n        (case y of None \\<Rightarrow> pmf (return_pmf None) x\n         | Some (Pure xa) \\<Rightarrow> pmf (return_spmf (Inl (xa, s))) x\n         | Some (IO out rpv) \\<Rightarrow>\n             pmf (the_gpv (callee s out) \\<bind>\n                  (\\<lambda>x.\n                      case x of\n                      Pure (x, y) \\<Rightarrow> inline1 callee (rpv x) y\n                      | IO out rpv' \\<Rightarrow>\n                          return_spmf (Inr (out, rpv', rpv))))\n              x) *\n       (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n        | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n            \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n               expectation_gpv 1 \\<I>'\n                (\\<lambda>(x, s').\n                    expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (rpv' x) s'))\n                (rpv x))) =\n  (\\<Sum>\\<^sup>+ x.\n     ennreal (pmf (inline1 callee gpv s) x) *\n     (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n      | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n          \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n             expectation_gpv 1 \\<I>'\n              (\\<lambda>(x, s').\n                  expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (rpv' x) s'))\n              (rpv x)))\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 1 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         1 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "have \"\\<dots> = (\\<integral>\\<^sup>+ res. (case res of Inl (a, s) \\<Rightarrow> f a\n            | Inr (out, rpv, rpv') \\<Rightarrow> \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out. expectation_gpv 1 \\<I>' (\\<lambda>(x, s'). expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv' x) s')) (rpv x))\n       \\<partial>measure_spmf (inline1 callee gpv s) +\n    ennreal (pmf (inline1 callee gpv s) None))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal (pmf (inline1 callee gpv s) x) *\n       (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n        | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n            \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n               expectation_gpv 1 \\<I>'\n                (\\<lambda>(x, s').\n                    expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (rpv' x) s'))\n                (rpv x))) =\n    \\<integral>\\<^sup>+ res.\n                         (case res of Inl (a, s) \\<Rightarrow> f a\n                          | Inr (out, rpv, rpv') \\<Rightarrow>\n                              \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n                                 expectation_gpv 1 \\<I>'\n                                  (\\<lambda>(x, s').\nexpectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv' x) s'))\n                                  (rpv x))\n                       \\<partial>measure_spmf (inline1 callee gpv s) +\n    ennreal (pmf (inline1 callee gpv s) None)", "apply(simp add: nn_integral_measure_spmf_conv_measure_pmf nn_integral_restrict_space nn_integral_measure_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<^sup>+ x.\n       ennreal (pmf (inline1 callee gpv s) x) *\n       (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n        | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n            \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n               expectation_gpv 1 \\<I>'\n                (\\<lambda>(x, s').\n                    expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                     (inline callee (rpv' x) s'))\n                (rpv x))) =\n    (\\<Sum>\\<^sup>+ x.\n       ennreal (pmf (inline1 callee gpv s) x) *\n       ((case the x of Inl (a, s) \\<Rightarrow> f a\n         | Inr (out, rpv, rpv') \\<Rightarrow>\n             \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n                expectation_gpv 1 \\<I>'\n                 (\\<lambda>(x, s').\n                     expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                      (inline callee (rpv' x) s'))\n                 (rpv x)) *\n        indicator (range Some) x)) +\n    ennreal (pmf (inline1 callee gpv s) None)", "apply(subst nn_integral_disjoint_pair_countspace[where B=\"range Some\" and C=\"{None}\", simplified, folded UNIV_option_conv, simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+x\\<in>range Some.\n                        (ennreal (pmf (inline1 callee gpv s) x) *\n                         (case x of None \\<Rightarrow> 1\n                          | Some (Inl (a, s)) \\<Rightarrow> f a\n                          | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n                              \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n                                 expectation_gpv 1 \\<I>'\n                                  (\\<lambda>(x, s').\nexpectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv' x) s'))\n                                  (rpv x)))\n     \\<partial>count_space UNIV) +\n    ennreal (pmf (inline1 callee gpv s) None) *\n    (case None of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n     | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n         \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n            expectation_gpv 1 \\<I>'\n             (\\<lambda>(x, s').\n                 expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                  (inline callee (rpv' x) s'))\n             (rpv x)) =\n    (\\<Sum>\\<^sup>+ x.\n       ennreal (pmf (inline1 callee gpv s) x) *\n       ((case the x of Inl (a, s) \\<Rightarrow> f a\n         | Inr (out, rpv, rpv') \\<Rightarrow>\n             \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n                expectation_gpv 1 \\<I>'\n                 (\\<lambda>(x, s').\n                     expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                      (inline callee (rpv' x) s'))\n                 (rpv x)) *\n        indicator (range Some) x)) +\n    ennreal (pmf (inline1 callee gpv s) None)", "apply(auto simp add: mult.commute intro!: nn_integral_cong split: split_indicator)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     ennreal (pmf (inline1 callee gpv s) x) *\n     (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n      | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n          \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n             expectation_gpv 1 \\<I>'\n              (\\<lambda>(x, s').\n                  expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (rpv' x) s'))\n              (rpv x))) =\n  \\<integral>\\<^sup>+ res.\n                       (case res of Inl (a, s) \\<Rightarrow> f a\n                        | Inr (out, rpv, rpv') \\<Rightarrow>\n                            \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n                               expectation_gpv 1 \\<I>'\n                                (\\<lambda>(x, s').\n                                    expectation_gpv 1 \\<I>'\n                                     (\\<lambda>(x, s). f x)\n                                     (inline callee (rpv' x) s'))\n                                (rpv x))\n                     \\<partial>measure_spmf (inline1 callee gpv s) +\n  ennreal (pmf (inline1 callee gpv s) None)\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 1 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         1 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<^sup>+ x.\n     ennreal (pmf (inline1 callee gpv s) x) *\n     (case x of None \\<Rightarrow> 1 | Some (Inl (a, s)) \\<Rightarrow> f a\n      | Some (Inr (out, rpv, rpv')) \\<Rightarrow>\n          \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n             expectation_gpv 1 \\<I>'\n              (\\<lambda>(x, s').\n                  expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x)\n                   (inline callee (rpv' x) s'))\n              (rpv x))) =\n  \\<integral>\\<^sup>+ res.\n                       (case res of Inl (a, s) \\<Rightarrow> f a\n                        | Inr (out, rpv, rpv') \\<Rightarrow>\n                            \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n                               expectation_gpv 1 \\<I>'\n                                (\\<lambda>(x, s').\n                                    expectation_gpv 1 \\<I>'\n                                     (\\<lambda>(x, s). f x)\n                                     (inline callee (rpv' x) s'))\n                                (rpv x))\n                     \\<partial>measure_spmf (inline1 callee gpv s) +\n  ennreal (pmf (inline1 callee gpv s) None)\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 1 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         1 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "have \"\\<dots> = expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ res.\n                         (case res of Inl (a, s) \\<Rightarrow> f a\n                          | Inr (out, rpv, rpv') \\<Rightarrow>\n                              \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n                                 expectation_gpv 1 \\<I>'\n                                  (\\<lambda>(x, s').\nexpectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv' x) s'))\n                                  (rpv x))\n                       \\<partial>measure_spmf (inline1 callee gpv s) +\n    ennreal (pmf (inline1 callee gpv s) None) =\n    expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee gpv s)", "unfolding expectation_gpv2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ res.\n                         (case res of Inl (a, s) \\<Rightarrow> f a\n                          | Inr (out, rpv, rpv') \\<Rightarrow>\n                              \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n                                 expectation_gpv 1 \\<I>'\n                                  (\\<lambda>(x, s').\nexpectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x) (inline callee (rpv' x) s'))\n                                  (rpv x))\n                       \\<partial>measure_spmf (inline1 callee gpv s) +\n    ennreal (pmf (inline1 callee gpv s) None) =\n    expectation_gpv 1 \\<I>' (\\<lambda>(x, s). f x) (inline callee gpv s)", "by(rewrite in \"_ = \\<hole>\" expectation_gpv.simps, subst (1 2) inline_sel)\n      (simp add: o_def pmf_map_spmf_None sum.case_distrib[where h=\"case_generat _ _\"] split_def cong: sum.case_cong)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ res.\n                       (case res of Inl (a, s) \\<Rightarrow> f a\n                        | Inr (out, rpv, rpv') \\<Rightarrow>\n                            \\<Sqinter>x\\<in>responses_\\<I> \\<I>' out.\n                               expectation_gpv 1 \\<I>'\n                                (\\<lambda>(x, s').\n                                    expectation_gpv 1 \\<I>'\n                                     (\\<lambda>(x, s). f x)\n                                     (inline callee (rpv' x) s'))\n                                (rpv x))\n                     \\<partial>measure_spmf (inline1 callee gpv s) +\n  ennreal (pmf (inline1 callee gpv s) None) =\n  expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee gpv s)\n\ngoal (1 subgoal):\n 1. \\<And>expectation_gpv' gpv s.\n       \\<lbrakk>\\<And>gpv.\n                   expectation_gpv' gpv \\<le> expectation_gpv 1 \\<I> f gpv;\n        \\<And>gpv s.\n           \\<lbrakk>\\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n           \\<Longrightarrow> expectation_gpv' gpv\n                             \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                    (inline callee gpv s);\n        \\<I> \\<turnstile>g gpv \\<surd>; I s\\<rbrakk>\n       \\<Longrightarrow> integral\\<^sup>N (measure_spmf (the_gpv gpv))\n                          (case_generat f\n                            (\\<lambda>out c.\n                                \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                   expectation_gpv' (c r))) +\n                         1 * ennreal (pmf (the_gpv gpv) None)\n                         \\<le> expectation_gpv2 (\\<lambda>(x, s). f x)\n                                (inline callee gpv s)", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ x. (case x of Pure a \\<Rightarrow> f a\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  1 * ennreal (pmf (the_gpv gpv) None)\n  \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee gpv s)", "show ?case"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. (case x of Pure a \\<Rightarrow> f a\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  1 * ennreal (pmf (the_gpv gpv) None)\n  \\<le> expectation_gpv2 (\\<lambda>(x, s). f x) (inline callee gpv s)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ generat.\n                         (case generat of Pure x \\<Rightarrow> f x\n                          | IO out c \\<Rightarrow>\n                              \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                                 expectation_gpv' (c r))\n                       \\<partial>measure_spmf (the_gpv gpv) +\n    1 * ennreal (pmf (the_gpv gpv) None)\n    \\<le> expectation_gpv2 (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n           (inline callee gpv s)", "."], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ generat.\n                       (case generat of Pure x \\<Rightarrow> f x\n                        | IO out c \\<Rightarrow>\n                            \\<Sqinter>r\\<in>responses_\\<I> \\<I> out.\n                               expectation_gpv' (c r))\n                     \\<partial>measure_spmf (the_gpv gpv) +\n  1 * ennreal (pmf (the_gpv gpv) None)\n  \\<le> expectation_gpv2 (\\<lambda>a. case a of (x, s) \\<Rightarrow> f x)\n         (inline callee gpv s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pfinite_inline:\n  assumes fin: \"pfinite_gpv \\<I> gpv\"\n    and WT: \"\\<I> \\<turnstile>g gpv \\<surd>\"\n    and callee: \"\\<And>s x. \\<lbrakk> x \\<in> outs_\\<I> \\<I>; I s \\<rbrakk> \\<Longrightarrow> pfinite_gpv \\<I>' (callee s x)\"\n    and I: \"I s\"\n  shows \"pfinite_gpv \\<I>' (inline callee gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_gpv \\<I>' (inline callee gpv s)", "unfolding pgen_lossless_gpv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 1 \\<I>' (\\<lambda>_. 1) (inline callee gpv s) = 1", "proof(rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. expectation_gpv 1 \\<I>' (\\<lambda>_. 1) (inline callee gpv s) \\<le> 1\n 2. 1 \\<le> expectation_gpv 1 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "have WT': \"\\<I>' \\<turnstile>g inline callee gpv s \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>' \\<turnstile>g inline callee gpv s \\<surd>", "using WT I"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g gpv \\<surd>\n  I s\n\ngoal (1 subgoal):\n 1. \\<I>' \\<turnstile>g inline callee gpv s \\<surd>", "by(rule WT_gpv_inline_invar)"], ["proof (state)\nthis:\n  \\<I>' \\<turnstile>g inline callee gpv s \\<surd>\n\ngoal (2 subgoals):\n 1. expectation_gpv 1 \\<I>' (\\<lambda>_. 1) (inline callee gpv s) \\<le> 1\n 2. 1 \\<le> expectation_gpv 1 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "from expectation_gpv_const_le[OF WT', of 1 1]"], ["proof (chain)\npicking this:\n  expectation_gpv 1 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)\n  \\<le> max 1 1", "show \"expectation_gpv 1 \\<I>' (\\<lambda>_. 1) (inline callee gpv s) \\<le> 1\""], ["proof (prove)\nusing this:\n  expectation_gpv 1 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)\n  \\<le> max 1 1\n\ngoal (1 subgoal):\n 1. expectation_gpv 1 \\<I>' (\\<lambda>_. 1) (inline callee gpv s) \\<le> 1", "by(simp add: max_def)"], ["proof (state)\nthis:\n  expectation_gpv 1 \\<I>' (\\<lambda>_. 1) (inline callee gpv s) \\<le> 1\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv 1 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "have \"1 = expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv", "using fin"], ["proof (prove)\nusing this:\n  pfinite_gpv \\<I> gpv\n\ngoal (1 subgoal):\n 1. 1 = expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv", "by(simp add: pgen_lossless_gpv_def)"], ["proof (state)\nthis:\n  1 = expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv 1 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "also"], ["proof (state)\nthis:\n  1 = expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv 1 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "have \"\\<dots> \\<le> expectation_gpv 1 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv\n    \\<le> expectation_gpv 1 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "by(rule expectation_gpv_1_le_inline[unfolded split_def]; rule callee I WT WT_callee order_refl)"], ["proof (state)\nthis:\n  expectation_gpv 1 \\<I> (\\<lambda>_. 1) gpv\n  \\<le> expectation_gpv 1 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv 1 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "finally"], ["proof (chain)\npicking this:\n  1 \\<le> expectation_gpv 1 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "show \"1 \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  1 \\<le> expectation_gpv 1 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)\n\ngoal (1 subgoal):\n 1. 1 \\<le> expectation_gpv 1 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)", "."], ["proof (state)\nthis:\n  1 \\<le> expectation_gpv 1 \\<I>' (\\<lambda>_. 1) (inline callee gpv s)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma pfinite_comp_converter [pfinite_intro]:\n  \"pfinite_converter \\<I>1 \\<I>3 (conv1 \\<odot> conv2)\"\n  if \"pfinite_converter \\<I>1 \\<I>2 conv1\" \"pfinite_converter \\<I>2 \\<I>3 conv2\" \"\\<I>1,\\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>\" \"\\<I>2,\\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter \\<I>1 \\<I>3 (conv1 \\<odot> conv2)", "using that"], ["proof (prove)\nusing this:\n  pfinite_converter \\<I>1 \\<I>2 conv1\n  pfinite_converter \\<I>2 \\<I>3 conv2\n  \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>\n  \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>\n\ngoal (1 subgoal):\n 1. pfinite_converter \\<I>1 \\<I>3 (conv1 \\<odot> conv2)", "proof(coinduction arbitrary: conv1 conv2)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a conv1 conv2.\n       \\<lbrakk>pfinite_converter \\<I>1 \\<I>2 conv1;\n        pfinite_converter \\<I>2 \\<I>3 conv2;\n        \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        a \\<in> outs_\\<I> \\<I>1\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv \\<I>3\n                          (run_converter (conv1 \\<odot> conv2) a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>3\n   (run_converter (conv1 \\<odot> conv2) a).\n                             (\\<exists>conv1 conv2.\n                                 conv' = conv1 \\<odot> conv2 \\<and>\n                                 pfinite_converter \\<I>1 \\<I>2 conv1 \\<and>\n                                 pfinite_converter \\<I>2 \\<I>3 conv2 \\<and>\n                                 \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and> \\<I>2,\n                                 \\<I>3 \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd>) \\<or>\n                             pfinite_converter \\<I>1 \\<I>3 conv')", "case pfinite_converter"], ["proof (state)\nthis:\n  pfinite_converter \\<I>1 \\<I>2 conv1\n  pfinite_converter \\<I>2 \\<I>3 conv2\n  \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>\n  \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>\n  a \\<in> outs_\\<I> \\<I>1\n\ngoal (1 subgoal):\n 1. \\<And>a conv1 conv2.\n       \\<lbrakk>pfinite_converter \\<I>1 \\<I>2 conv1;\n        pfinite_converter \\<I>2 \\<I>3 conv2;\n        \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        a \\<in> outs_\\<I> \\<I>1\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv \\<I>3\n                          (run_converter (conv1 \\<odot> conv2) a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>3\n   (run_converter (conv1 \\<odot> conv2) a).\n                             (\\<exists>conv1 conv2.\n                                 conv' = conv1 \\<odot> conv2 \\<and>\n                                 pfinite_converter \\<I>1 \\<I>2 conv1 \\<and>\n                                 pfinite_converter \\<I>2 \\<I>3 conv2 \\<and>\n                                 \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and> \\<I>2,\n                                 \\<I>3 \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd>) \\<or>\n                             pfinite_converter \\<I>1 \\<I>3 conv')", "have conv1: \"pfinite_gpv \\<I>2 (run_converter conv1 a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_gpv \\<I>2 (run_converter conv1 a)", "using pfinite_converter(1, 5)"], ["proof (prove)\nusing this:\n  pfinite_converter \\<I>1 \\<I>2 conv1\n  a \\<in> outs_\\<I> \\<I>1\n\ngoal (1 subgoal):\n 1. pfinite_gpv \\<I>2 (run_converter conv1 a)", "by(simp add: pfinite_converterD)"], ["proof (state)\nthis:\n  pfinite_gpv \\<I>2 (run_converter conv1 a)\n\ngoal (1 subgoal):\n 1. \\<And>a conv1 conv2.\n       \\<lbrakk>pfinite_converter \\<I>1 \\<I>2 conv1;\n        pfinite_converter \\<I>2 \\<I>3 conv2;\n        \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        a \\<in> outs_\\<I> \\<I>1\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv \\<I>3\n                          (run_converter (conv1 \\<odot> conv2) a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>3\n   (run_converter (conv1 \\<odot> conv2) a).\n                             (\\<exists>conv1 conv2.\n                                 conv' = conv1 \\<odot> conv2 \\<and>\n                                 pfinite_converter \\<I>1 \\<I>2 conv1 \\<and>\n                                 pfinite_converter \\<I>2 \\<I>3 conv2 \\<and>\n                                 \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and> \\<I>2,\n                                 \\<I>3 \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd>) \\<or>\n                             pfinite_converter \\<I>1 \\<I>3 conv')", "have conv2: \"\\<I>2 \\<turnstile>g run_converter conv1 a \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>2 \\<turnstile>g run_converter conv1 a \\<surd>", "using pfinite_converter(3, 5)"], ["proof (prove)\nusing this:\n  \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>\n  a \\<in> outs_\\<I> \\<I>1\n\ngoal (1 subgoal):\n 1. \\<I>2 \\<turnstile>g run_converter conv1 a \\<surd>", "by(simp add: WT_converterD)"], ["proof (state)\nthis:\n  \\<I>2 \\<turnstile>g run_converter conv1 a \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>a conv1 conv2.\n       \\<lbrakk>pfinite_converter \\<I>1 \\<I>2 conv1;\n        pfinite_converter \\<I>2 \\<I>3 conv2;\n        \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        a \\<in> outs_\\<I> \\<I>1\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv \\<I>3\n                          (run_converter (conv1 \\<odot> conv2) a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>3\n   (run_converter (conv1 \\<odot> conv2) a).\n                             (\\<exists>conv1 conv2.\n                                 conv' = conv1 \\<odot> conv2 \\<and>\n                                 pfinite_converter \\<I>1 \\<I>2 conv1 \\<and>\n                                 pfinite_converter \\<I>2 \\<I>3 conv2 \\<and>\n                                 \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and> \\<I>2,\n                                 \\<I>3 \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd>) \\<or>\n                             pfinite_converter \\<I>1 \\<I>3 conv')", "have ?pfinite"], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_gpv \\<I>3 (run_converter (conv1 \\<odot> conv2) a)", "using pfinite_converter(2,4,5)"], ["proof (prove)\nusing this:\n  pfinite_converter \\<I>2 \\<I>3 conv2\n  \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>\n  a \\<in> outs_\\<I> \\<I>1\n\ngoal (1 subgoal):\n 1. pfinite_gpv \\<I>3 (run_converter (conv1 \\<odot> conv2) a)", "by(auto intro!:run_pfinite_converter.pfinite_inline[OF conv1] dest: pfinite_converterD intro: conv2)"], ["proof (state)\nthis:\n  pfinite_gpv \\<I>3 (run_converter (conv1 \\<odot> conv2) a)\n\ngoal (1 subgoal):\n 1. \\<And>a conv1 conv2.\n       \\<lbrakk>pfinite_converter \\<I>1 \\<I>2 conv1;\n        pfinite_converter \\<I>2 \\<I>3 conv2;\n        \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        a \\<in> outs_\\<I> \\<I>1\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv \\<I>3\n                          (run_converter (conv1 \\<odot> conv2) a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>3\n   (run_converter (conv1 \\<odot> conv2) a).\n                             (\\<exists>conv1 conv2.\n                                 conv' = conv1 \\<odot> conv2 \\<and>\n                                 pfinite_converter \\<I>1 \\<I>2 conv1 \\<and>\n                                 pfinite_converter \\<I>2 \\<I>3 conv2 \\<and>\n                                 \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and> \\<I>2,\n                                 \\<I>3 \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd>) \\<or>\n                             pfinite_converter \\<I>1 \\<I>3 conv')", "moreover"], ["proof (state)\nthis:\n  pfinite_gpv \\<I>3 (run_converter (conv1 \\<odot> conv2) a)\n\ngoal (1 subgoal):\n 1. \\<And>a conv1 conv2.\n       \\<lbrakk>pfinite_converter \\<I>1 \\<I>2 conv1;\n        pfinite_converter \\<I>2 \\<I>3 conv2;\n        \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        a \\<in> outs_\\<I> \\<I>1\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv \\<I>3\n                          (run_converter (conv1 \\<odot> conv2) a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>3\n   (run_converter (conv1 \\<odot> conv2) a).\n                             (\\<exists>conv1 conv2.\n                                 conv' = conv1 \\<odot> conv2 \\<and>\n                                 pfinite_converter \\<I>1 \\<I>2 conv1 \\<and>\n                                 pfinite_converter \\<I>2 \\<I>3 conv2 \\<and>\n                                 \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and> \\<I>2,\n                                 \\<I>3 \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd>) \\<or>\n                             pfinite_converter \\<I>1 \\<I>3 conv')", "have ?step (is \"\\<forall>(b, conv')\\<in>?res. ?P b conv' \\<or> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(b, conv')\n             \\<in>results_gpv \\<I>3 (run_converter (conv1 \\<odot> conv2) a).\n       (\\<exists>conv1 conv2.\n           conv' = conv1 \\<odot> conv2 \\<and>\n           pfinite_converter \\<I>1 \\<I>2 conv1 \\<and>\n           pfinite_converter \\<I>2 \\<I>3 conv2 \\<and>\n           \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and> \\<I>2,\n           \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>) \\<or>\n       pfinite_converter \\<I>1 \\<I>3 conv'", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b)\n                \\<in> results_gpv \\<I>3\n                       (run_converter (conv1 \\<odot> conv2) a);\n        \\<not> pfinite_converter \\<I>1 \\<I>3 b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>conv1 conv2.\n                            b = conv1 \\<odot> conv2 \\<and>\n                            pfinite_converter \\<I>1 \\<I>2 conv1 \\<and>\n                            pfinite_converter \\<I>2 \\<I>3 conv2 \\<and>\n                            \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                            conv1 \\<surd> \\<and> \\<I>2,\n                            \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>", "fix b conv''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b)\n                \\<in> results_gpv \\<I>3\n                       (run_converter (conv1 \\<odot> conv2) a);\n        \\<not> pfinite_converter \\<I>1 \\<I>3 b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>conv1 conv2.\n                            b = conv1 \\<odot> conv2 \\<and>\n                            pfinite_converter \\<I>1 \\<I>2 conv1 \\<and>\n                            pfinite_converter \\<I>2 \\<I>3 conv2 \\<and>\n                            \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                            conv1 \\<surd> \\<and> \\<I>2,\n                            \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>", "assume \"(b, conv'') \\<in> ?res\""], ["proof (state)\nthis:\n  (b, conv'')\n  \\<in> results_gpv \\<I>3 (run_converter (conv1 \\<odot> conv2) a)\n\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b)\n                \\<in> results_gpv \\<I>3\n                       (run_converter (conv1 \\<odot> conv2) a);\n        \\<not> pfinite_converter \\<I>1 \\<I>3 b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>conv1 conv2.\n                            b = conv1 \\<odot> conv2 \\<and>\n                            pfinite_converter \\<I>1 \\<I>2 conv1 \\<and>\n                            pfinite_converter \\<I>2 \\<I>3 conv2 \\<and>\n                            \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                            conv1 \\<surd> \\<and> \\<I>2,\n                            \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>", "then"], ["proof (chain)\npicking this:\n  (b, conv'')\n  \\<in> results_gpv \\<I>3 (run_converter (conv1 \\<odot> conv2) a)", "obtain conv1' conv2' where [simp]: \"conv'' = comp_converter conv1' conv2'\" \n      and inline: \"((b, conv1'), conv2') \\<in> results_gpv \\<I>3 (inline run_converter (run_converter conv1 a) conv2)\""], ["proof (prove)\nusing this:\n  (b, conv'')\n  \\<in> results_gpv \\<I>3 (run_converter (conv1 \\<odot> conv2) a)\n\ngoal (1 subgoal):\n 1. (\\<And>conv1' conv2'.\n        \\<lbrakk>conv'' = conv1' \\<odot> conv2';\n         ((b, conv1'), conv2')\n         \\<in> results_gpv \\<I>3\n                (inline run_converter (run_converter conv1 a)\n                  conv2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  conv'' = conv1' \\<odot> conv2'\n  ((b, conv1'), conv2')\n  \\<in> results_gpv \\<I>3\n         (inline run_converter (run_converter conv1 a) conv2)\n\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b)\n                \\<in> results_gpv \\<I>3\n                       (run_converter (conv1 \\<odot> conv2) a);\n        \\<not> pfinite_converter \\<I>1 \\<I>3 b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>conv1 conv2.\n                            b = conv1 \\<odot> conv2 \\<and>\n                            pfinite_converter \\<I>1 \\<I>2 conv1 \\<and>\n                            pfinite_converter \\<I>2 \\<I>3 conv2 \\<and>\n                            \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                            conv1 \\<surd> \\<and> \\<I>2,\n                            \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>", "from run_pfinite_converter.results_gpv_inline[OF inline conv2] pfinite_converter(2,4)"], ["proof (chain)\npicking this:\n  pfinite_converter \\<I>2 \\<I>3 conv2 \\<and> \\<I>2,\n  \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd> \\<Longrightarrow>\n  (b, conv1') \\<in> results_gpv \\<I>2 (run_converter conv1 a) \\<and>\n  pfinite_converter \\<I>2 \\<I>3 conv2' \\<and> \\<I>2,\n  \\<I>3 \\<turnstile>\\<^sub>C conv2' \\<surd>\n  pfinite_converter \\<I>2 \\<I>3 conv2\n  \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>", "have run: \"(b, conv1') \\<in> results_gpv \\<I>2 (run_converter conv1 a)\"\n      and *: \"pfinite_converter \\<I>2 \\<I>3 conv2'\" \"\\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv2' \\<surd>\""], ["proof (prove)\nusing this:\n  pfinite_converter \\<I>2 \\<I>3 conv2 \\<and> \\<I>2,\n  \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd> \\<Longrightarrow>\n  (b, conv1') \\<in> results_gpv \\<I>2 (run_converter conv1 a) \\<and>\n  pfinite_converter \\<I>2 \\<I>3 conv2' \\<and> \\<I>2,\n  \\<I>3 \\<turnstile>\\<^sub>C conv2' \\<surd>\n  pfinite_converter \\<I>2 \\<I>3 conv2\n  \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>\n\ngoal (1 subgoal):\n 1. (b, conv1') \\<in> results_gpv \\<I>2 (run_converter conv1 a) &&&\n    pfinite_converter \\<I>2 \\<I>3 conv2' &&&\n    \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv2' \\<surd>", "by auto"], ["proof (state)\nthis:\n  (b, conv1') \\<in> results_gpv \\<I>2 (run_converter conv1 a)\n  pfinite_converter \\<I>2 \\<I>3 conv2'\n  \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv2' \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b)\n                \\<in> results_gpv \\<I>3\n                       (run_converter (conv1 \\<odot> conv2) a);\n        \\<not> pfinite_converter \\<I>1 \\<I>3 b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>conv1 conv2.\n                            b = conv1 \\<odot> conv2 \\<and>\n                            pfinite_converter \\<I>1 \\<I>2 conv1 \\<and>\n                            pfinite_converter \\<I>2 \\<I>3 conv2 \\<and>\n                            \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                            conv1 \\<surd> \\<and> \\<I>2,\n                            \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>", "with WT_converterD(2)[OF pfinite_converter(3,5) run] pfinite_converterD[THEN conjunct2, rule_format, OF pfinite_converter(1,5) run]"], ["proof (chain)\npicking this:\n  b \\<in> responses_\\<I> \\<I>1 a \\<and> \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n  conv1' \\<surd>\n  case (b, conv1') of (b, x) \\<Rightarrow> pfinite_converter \\<I>1 \\<I>2 x\n  (b, conv1') \\<in> results_gpv \\<I>2 (run_converter conv1 a)\n  pfinite_converter \\<I>2 \\<I>3 conv2'\n  \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv2' \\<surd>", "show \"?P b conv''\""], ["proof (prove)\nusing this:\n  b \\<in> responses_\\<I> \\<I>1 a \\<and> \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n  conv1' \\<surd>\n  case (b, conv1') of (b, x) \\<Rightarrow> pfinite_converter \\<I>1 \\<I>2 x\n  (b, conv1') \\<in> results_gpv \\<I>2 (run_converter conv1 a)\n  pfinite_converter \\<I>2 \\<I>3 conv2'\n  \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv2' \\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>conv1 conv2.\n       conv'' = conv1 \\<odot> conv2 \\<and>\n       pfinite_converter \\<I>1 \\<I>2 conv1 \\<and>\n       pfinite_converter \\<I>2 \\<I>3 conv2 \\<and>\n       \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and> \\<I>2,\n       \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>", "by auto"], ["proof (state)\nthis:\n  \\<exists>conv1 conv2.\n     conv'' = conv1 \\<odot> conv2 \\<and>\n     pfinite_converter \\<I>1 \\<I>2 conv1 \\<and>\n     pfinite_converter \\<I>2 \\<I>3 conv2 \\<and>\n     \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and> \\<I>2,\n     \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>(b, conv')\n           \\<in>results_gpv \\<I>3 (run_converter (conv1 \\<odot> conv2) a).\n     (\\<exists>conv1 conv2.\n         conv' = conv1 \\<odot> conv2 \\<and>\n         pfinite_converter \\<I>1 \\<I>2 conv1 \\<and>\n         pfinite_converter \\<I>2 \\<I>3 conv2 \\<and>\n         \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and> \\<I>2,\n         \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>) \\<or>\n     pfinite_converter \\<I>1 \\<I>3 conv'\n\ngoal (1 subgoal):\n 1. \\<And>a conv1 conv2.\n       \\<lbrakk>pfinite_converter \\<I>1 \\<I>2 conv1;\n        pfinite_converter \\<I>2 \\<I>3 conv2;\n        \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd>;\n        \\<I>2, \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>;\n        a \\<in> outs_\\<I> \\<I>1\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv \\<I>3\n                          (run_converter (conv1 \\<odot> conv2) a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>3\n   (run_converter (conv1 \\<odot> conv2) a).\n                             (\\<exists>conv1 conv2.\n                                 conv' = conv1 \\<odot> conv2 \\<and>\n                                 pfinite_converter \\<I>1 \\<I>2 conv1 \\<and>\n                                 pfinite_converter \\<I>2 \\<I>3 conv2 \\<and>\n                                 \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C\n                                 conv1 \\<surd> \\<and> \\<I>2,\n                                 \\<I>3 \\<turnstile>\\<^sub>C\n                                 conv2 \\<surd>) \\<or>\n                             pfinite_converter \\<I>1 \\<I>3 conv')", "ultimately"], ["proof (chain)\npicking this:\n  pfinite_gpv \\<I>3 (run_converter (conv1 \\<odot> conv2) a)\n  \\<forall>(b, conv')\n           \\<in>results_gpv \\<I>3 (run_converter (conv1 \\<odot> conv2) a).\n     (\\<exists>conv1 conv2.\n         conv' = conv1 \\<odot> conv2 \\<and>\n         pfinite_converter \\<I>1 \\<I>2 conv1 \\<and>\n         pfinite_converter \\<I>2 \\<I>3 conv2 \\<and>\n         \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and> \\<I>2,\n         \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>) \\<or>\n     pfinite_converter \\<I>1 \\<I>3 conv'", "show ?case"], ["proof (prove)\nusing this:\n  pfinite_gpv \\<I>3 (run_converter (conv1 \\<odot> conv2) a)\n  \\<forall>(b, conv')\n           \\<in>results_gpv \\<I>3 (run_converter (conv1 \\<odot> conv2) a).\n     (\\<exists>conv1 conv2.\n         conv' = conv1 \\<odot> conv2 \\<and>\n         pfinite_converter \\<I>1 \\<I>2 conv1 \\<and>\n         pfinite_converter \\<I>2 \\<I>3 conv2 \\<and>\n         \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and> \\<I>2,\n         \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>) \\<or>\n     pfinite_converter \\<I>1 \\<I>3 conv'\n\ngoal (1 subgoal):\n 1. pfinite_gpv \\<I>3 (run_converter (conv1 \\<odot> conv2) a) \\<and>\n    (\\<forall>(b, conv')\n              \\<in>results_gpv \\<I>3\n                    (run_converter (conv1 \\<odot> conv2) a).\n        (\\<exists>conv1 conv2.\n            conv' = conv1 \\<odot> conv2 \\<and>\n            pfinite_converter \\<I>1 \\<I>2 conv1 \\<and>\n            pfinite_converter \\<I>2 \\<I>3 conv2 \\<and>\n            \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and> \\<I>2,\n            \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>) \\<or>\n        pfinite_converter \\<I>1 \\<I>3 conv')", ".."], ["proof (state)\nthis:\n  pfinite_gpv \\<I>3 (run_converter (conv1 \\<odot> conv2) a) \\<and>\n  (\\<forall>(b, conv')\n            \\<in>results_gpv \\<I>3 (run_converter (conv1 \\<odot> conv2) a).\n      (\\<exists>conv1 conv2.\n          conv' = conv1 \\<odot> conv2 \\<and>\n          pfinite_converter \\<I>1 \\<I>2 conv1 \\<and>\n          pfinite_converter \\<I>2 \\<I>3 conv2 \\<and>\n          \\<I>1, \\<I>2 \\<turnstile>\\<^sub>C conv1 \\<surd> \\<and> \\<I>2,\n          \\<I>3 \\<turnstile>\\<^sub>C conv2 \\<surd>) \\<or>\n      pfinite_converter \\<I>1 \\<I>3 conv')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pfinite_map_converter [pfinite_intro]:\n  \"pfinite_converter \\<I>  \\<I>' (map_converter f g f' g' conv)\" if \n  *: \"pfinite_converter (map_\\<I> (inv_into UNIV f) (inv_into UNIV g) \\<I>) (map_\\<I> f' g' \\<I>') conv\"\n  and f: \"inj f\" and g: \"surj g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter \\<I> \\<I>' (map_converter f g f' g' conv)", "using *"], ["proof (prove)\nusing this:\n  pfinite_converter (map_\\<I> (inv f) (inv g) \\<I>) (map_\\<I> f' g' \\<I>')\n   conv\n\ngoal (1 subgoal):\n 1. pfinite_converter \\<I> \\<I>' (map_converter f g f' g' conv)", "proof(coinduction arbitrary: conv)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a conva.\n       \\<lbrakk>pfinite_converter (map_\\<I> (inv f) (inv g) \\<I>)\n                 (map_\\<I> f' g' \\<I>') conva;\n        a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv \\<I>'\n                          (run_converter (map_converter f g f' g' conva)\n                            a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>'\n   (run_converter (map_converter f g f' g' conva) a).\n                             (\\<exists>conv.\n                                 conv' = map_converter f g f' g' conv \\<and>\n                                 pfinite_converter\n                                  (map_\\<I> (inv f) (inv g) \\<I>)\n                                  (map_\\<I> f' g' \\<I>') conv) \\<or>\n                             pfinite_converter \\<I> \\<I>' conv')", "case (pfinite_converter a conv)"], ["proof (state)\nthis:\n  pfinite_converter (map_\\<I> (inv f) (inv g) \\<I>) (map_\\<I> f' g' \\<I>')\n   conv\n  a \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. \\<And>a conva.\n       \\<lbrakk>pfinite_converter (map_\\<I> (inv f) (inv g) \\<I>)\n                 (map_\\<I> f' g' \\<I>') conva;\n        a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv \\<I>'\n                          (run_converter (map_converter f g f' g' conva)\n                            a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>'\n   (run_converter (map_converter f g f' g' conva) a).\n                             (\\<exists>conv.\n                                 conv' = map_converter f g f' g' conv \\<and>\n                                 pfinite_converter\n                                  (map_\\<I> (inv f) (inv g) \\<I>)\n                                  (map_\\<I> f' g' \\<I>') conv) \\<or>\n                             pfinite_converter \\<I> \\<I>' conv')", "with f"], ["proof (chain)\npicking this:\n  inj f\n  pfinite_converter (map_\\<I> (inv f) (inv g) \\<I>) (map_\\<I> f' g' \\<I>')\n   conv\n  a \\<in> outs_\\<I> \\<I>", "have a: \"inv_into UNIV f (f a) \\<in> outs_\\<I> \\<I>\""], ["proof (prove)\nusing this:\n  inj f\n  pfinite_converter (map_\\<I> (inv f) (inv g) \\<I>) (map_\\<I> f' g' \\<I>')\n   conv\n  a \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. inv f (f a) \\<in> outs_\\<I> \\<I>", "by simp"], ["proof (state)\nthis:\n  inv f (f a) \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. \\<And>a conva.\n       \\<lbrakk>pfinite_converter (map_\\<I> (inv f) (inv g) \\<I>)\n                 (map_\\<I> f' g' \\<I>') conva;\n        a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv \\<I>'\n                          (run_converter (map_converter f g f' g' conva)\n                            a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>'\n   (run_converter (map_converter f g f' g' conva) a).\n                             (\\<exists>conv.\n                                 conv' = map_converter f g f' g' conv \\<and>\n                                 pfinite_converter\n                                  (map_\\<I> (inv f) (inv g) \\<I>)\n                                  (map_\\<I> f' g' \\<I>') conv) \\<or>\n                             pfinite_converter \\<I> \\<I>' conv')", "with pfinite_converterD[OF \\<open>pfinite_converter _ _ conv\\<close>, of \"f a\"]"], ["proof (chain)\npicking this:\n  f a \\<in> outs_\\<I> (map_\\<I> (inv f) (inv g) \\<I>) \\<Longrightarrow>\n  pfinite_gpv (map_\\<I> f' g' \\<I>') (run_converter conv (f a)) \\<and>\n  (\\<forall>(b, conv')\n            \\<in>results_gpv (map_\\<I> f' g' \\<I>')\n                  (run_converter conv (f a)).\n      pfinite_converter (map_\\<I> (inv f) (inv g) \\<I>)\n       (map_\\<I> f' g' \\<I>') conv')\n  inv f (f a) \\<in> outs_\\<I> \\<I>", "have \"?pfinite\""], ["proof (prove)\nusing this:\n  f a \\<in> outs_\\<I> (map_\\<I> (inv f) (inv g) \\<I>) \\<Longrightarrow>\n  pfinite_gpv (map_\\<I> f' g' \\<I>') (run_converter conv (f a)) \\<and>\n  (\\<forall>(b, conv')\n            \\<in>results_gpv (map_\\<I> f' g' \\<I>')\n                  (run_converter conv (f a)).\n      pfinite_converter (map_\\<I> (inv f) (inv g) \\<I>)\n       (map_\\<I> f' g' \\<I>') conv')\n  inv f (f a) \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. pfinite_gpv \\<I>' (run_converter (map_converter f g f' g' conv) a)", "by simp"], ["proof (state)\nthis:\n  pfinite_gpv \\<I>' (run_converter (map_converter f g f' g' conv) a)\n\ngoal (1 subgoal):\n 1. \\<And>a conva.\n       \\<lbrakk>pfinite_converter (map_\\<I> (inv f) (inv g) \\<I>)\n                 (map_\\<I> f' g' \\<I>') conva;\n        a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv \\<I>'\n                          (run_converter (map_converter f g f' g' conva)\n                            a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>'\n   (run_converter (map_converter f g f' g' conva) a).\n                             (\\<exists>conv.\n                                 conv' = map_converter f g f' g' conv \\<and>\n                                 pfinite_converter\n                                  (map_\\<I> (inv f) (inv g) \\<I>)\n                                  (map_\\<I> f' g' \\<I>') conv) \\<or>\n                             pfinite_converter \\<I> \\<I>' conv')", "moreover"], ["proof (state)\nthis:\n  pfinite_gpv \\<I>' (run_converter (map_converter f g f' g' conv) a)\n\ngoal (1 subgoal):\n 1. \\<And>a conva.\n       \\<lbrakk>pfinite_converter (map_\\<I> (inv f) (inv g) \\<I>)\n                 (map_\\<I> f' g' \\<I>') conva;\n        a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv \\<I>'\n                          (run_converter (map_converter f g f' g' conva)\n                            a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>'\n   (run_converter (map_converter f g f' g' conva) a).\n                             (\\<exists>conv.\n                                 conv' = map_converter f g f' g' conv \\<and>\n                                 pfinite_converter\n                                  (map_\\<I> (inv f) (inv g) \\<I>)\n                                  (map_\\<I> f' g' \\<I>') conv) \\<or>\n                             pfinite_converter \\<I> \\<I>' conv')", "have ?step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(b, conv')\n             \\<in>results_gpv \\<I>'\n                   (run_converter (map_converter f g f' g' conv) a).\n       (\\<exists>conv.\n           conv' = map_converter f g f' g' conv \\<and>\n           pfinite_converter (map_\\<I> (inv f) (inv g) \\<I>)\n            (map_\\<I> f' g' \\<I>') conv) \\<or>\n       pfinite_converter \\<I> \\<I>' conv'", "proof(safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b)\n                \\<in> results_gpv \\<I>'\n                       (run_converter (map_converter f g f' g' conv) a);\n        \\<not> pfinite_converter \\<I> \\<I>' b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>conv.\n                            b = map_converter f g f' g' conv \\<and>\n                            pfinite_converter\n                             (map_\\<I> (inv f) (inv g) \\<I>)\n                             (map_\\<I> f' g' \\<I>') conv", "fix r conv'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b)\n                \\<in> results_gpv \\<I>'\n                       (run_converter (map_converter f g f' g' conv) a);\n        \\<not> pfinite_converter \\<I> \\<I>' b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>conv.\n                            b = map_converter f g f' g' conv \\<and>\n                            pfinite_converter\n                             (map_\\<I> (inv f) (inv g) \\<I>)\n                             (map_\\<I> f' g' \\<I>') conv", "assume \"(r, conv') \\<in> results_gpv \\<I>' (run_converter (map_converter f g f' g' conv) a)\""], ["proof (state)\nthis:\n  (r, conv')\n  \\<in> results_gpv \\<I>' (run_converter (map_converter f g f' g' conv) a)\n\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b)\n                \\<in> results_gpv \\<I>'\n                       (run_converter (map_converter f g f' g' conv) a);\n        \\<not> pfinite_converter \\<I> \\<I>' b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>conv.\n                            b = map_converter f g f' g' conv \\<and>\n                            pfinite_converter\n                             (map_\\<I> (inv f) (inv g) \\<I>)\n                             (map_\\<I> f' g' \\<I>') conv", "then"], ["proof (chain)\npicking this:\n  (r, conv')\n  \\<in> results_gpv \\<I>' (run_converter (map_converter f g f' g' conv) a)", "obtain r' conv''\n      where results: \"(r', conv'') \\<in> results_gpv (map_\\<I> f' g' \\<I>') (run_converter conv (f a))\"\n        and r: \"r = g r'\"\n        and conv': \"conv' = map_converter f g f' g' conv''\""], ["proof (prove)\nusing this:\n  (r, conv')\n  \\<in> results_gpv \\<I>' (run_converter (map_converter f g f' g' conv) a)\n\ngoal (1 subgoal):\n 1. (\\<And>r' conv''.\n        \\<lbrakk>(r', conv'')\n                 \\<in> results_gpv (map_\\<I> f' g' \\<I>')\n                        (run_converter conv (f a));\n         r = g r'; conv' = map_converter f g f' g' conv''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (r', conv'')\n  \\<in> results_gpv (map_\\<I> f' g' \\<I>') (run_converter conv (f a))\n  r = g r'\n  conv' = map_converter f g f' g' conv''\n\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(aa, b)\n                \\<in> results_gpv \\<I>'\n                       (run_converter (map_converter f g f' g' conv) a);\n        \\<not> pfinite_converter \\<I> \\<I>' b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>conv.\n                            b = map_converter f g f' g' conv \\<and>\n                            pfinite_converter\n                             (map_\\<I> (inv f) (inv g) \\<I>)\n                             (map_\\<I> f' g' \\<I>') conv", "from pfinite_converterD[OF \\<open>pfinite_converter _ _ conv\\<close>, THEN conjunct2, rule_format, OF _ results] a r conv'"], ["proof (chain)\npicking this:\n  f a \\<in> outs_\\<I> (map_\\<I> (inv f) (inv g) \\<I>) \\<Longrightarrow>\n  case (r', conv'') of\n  (b, x) \\<Rightarrow>\n    pfinite_converter (map_\\<I> (inv f) (inv g) \\<I>) (map_\\<I> f' g' \\<I>')\n     x\n  inv f (f a) \\<in> outs_\\<I> \\<I>\n  r = g r'\n  conv' = map_converter f g f' g' conv''", "show \"\\<exists>conv. conv' = map_converter f g f' g' conv \\<and>\n              pfinite_converter (map_\\<I> (inv_into UNIV f) (inv_into UNIV g) \\<I>) (map_\\<I> f' g' \\<I>') conv\""], ["proof (prove)\nusing this:\n  f a \\<in> outs_\\<I> (map_\\<I> (inv f) (inv g) \\<I>) \\<Longrightarrow>\n  case (r', conv'') of\n  (b, x) \\<Rightarrow>\n    pfinite_converter (map_\\<I> (inv f) (inv g) \\<I>) (map_\\<I> f' g' \\<I>')\n     x\n  inv f (f a) \\<in> outs_\\<I> \\<I>\n  r = g r'\n  conv' = map_converter f g f' g' conv''\n\ngoal (1 subgoal):\n 1. \\<exists>conv.\n       conv' = map_converter f g f' g' conv \\<and>\n       pfinite_converter (map_\\<I> (inv f) (inv g) \\<I>)\n        (map_\\<I> f' g' \\<I>') conv", "by auto"], ["proof (state)\nthis:\n  \\<exists>conv.\n     conv' = map_converter f g f' g' conv \\<and>\n     pfinite_converter (map_\\<I> (inv f) (inv g) \\<I>)\n      (map_\\<I> f' g' \\<I>') conv\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>(b, conv')\n           \\<in>results_gpv \\<I>'\n                 (run_converter (map_converter f g f' g' conv) a).\n     (\\<exists>conv.\n         conv' = map_converter f g f' g' conv \\<and>\n         pfinite_converter (map_\\<I> (inv f) (inv g) \\<I>)\n          (map_\\<I> f' g' \\<I>') conv) \\<or>\n     pfinite_converter \\<I> \\<I>' conv'\n\ngoal (1 subgoal):\n 1. \\<And>a conva.\n       \\<lbrakk>pfinite_converter (map_\\<I> (inv f) (inv g) \\<I>)\n                 (map_\\<I> f' g' \\<I>') conva;\n        a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> pfinite_gpv \\<I>'\n                          (run_converter (map_converter f g f' g' conva)\n                            a) \\<and>\n                         (\\<forall>(b, conv')\n                                   \\<in>results_gpv \\<I>'\n   (run_converter (map_converter f g f' g' conva) a).\n                             (\\<exists>conv.\n                                 conv' = map_converter f g f' g' conv \\<and>\n                                 pfinite_converter\n                                  (map_\\<I> (inv f) (inv g) \\<I>)\n                                  (map_\\<I> f' g' \\<I>') conv) \\<or>\n                             pfinite_converter \\<I> \\<I>' conv')", "ultimately"], ["proof (chain)\npicking this:\n  pfinite_gpv \\<I>' (run_converter (map_converter f g f' g' conv) a)\n  \\<forall>(b, conv')\n           \\<in>results_gpv \\<I>'\n                 (run_converter (map_converter f g f' g' conv) a).\n     (\\<exists>conv.\n         conv' = map_converter f g f' g' conv \\<and>\n         pfinite_converter (map_\\<I> (inv f) (inv g) \\<I>)\n          (map_\\<I> f' g' \\<I>') conv) \\<or>\n     pfinite_converter \\<I> \\<I>' conv'", "show ?case"], ["proof (prove)\nusing this:\n  pfinite_gpv \\<I>' (run_converter (map_converter f g f' g' conv) a)\n  \\<forall>(b, conv')\n           \\<in>results_gpv \\<I>'\n                 (run_converter (map_converter f g f' g' conv) a).\n     (\\<exists>conv.\n         conv' = map_converter f g f' g' conv \\<and>\n         pfinite_converter (map_\\<I> (inv f) (inv g) \\<I>)\n          (map_\\<I> f' g' \\<I>') conv) \\<or>\n     pfinite_converter \\<I> \\<I>' conv'\n\ngoal (1 subgoal):\n 1. pfinite_gpv \\<I>'\n     (run_converter (map_converter f g f' g' conv) a) \\<and>\n    (\\<forall>(b, conv')\n              \\<in>results_gpv \\<I>'\n                    (run_converter (map_converter f g f' g' conv) a).\n        (\\<exists>conv.\n            conv' = map_converter f g f' g' conv \\<and>\n            pfinite_converter (map_\\<I> (inv f) (inv g) \\<I>)\n             (map_\\<I> f' g' \\<I>') conv) \\<or>\n        pfinite_converter \\<I> \\<I>' conv')", ".."], ["proof (state)\nthis:\n  pfinite_gpv \\<I>' (run_converter (map_converter f g f' g' conv) a) \\<and>\n  (\\<forall>(b, conv')\n            \\<in>results_gpv \\<I>'\n                  (run_converter (map_converter f g f' g' conv) a).\n      (\\<exists>conv.\n          conv' = map_converter f g f' g' conv \\<and>\n          pfinite_converter (map_\\<I> (inv f) (inv g) \\<I>)\n           (map_\\<I> f' g' \\<I>') conv) \\<or>\n      pfinite_converter \\<I> \\<I>' conv')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pfinite_lassocr\\<^sub>C [pfinite_intro]: \"pfinite_converter ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3) (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)) lassocr\\<^sub>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter\n     ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3)\n     (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3))\n     lassocr\\<^sub>C", "by(coinduction)(auto simp add: lassocr\\<^sub>C_def)"], ["", "lemma pfinite_rassocl\\<^sub>C [pfinite_intro]: \"pfinite_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)) ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3) rassocl\\<^sub>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter\n     (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3))\n     ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3)\n     rassocl\\<^sub>C", "by(coinduction)(auto simp add: rassocl\\<^sub>C_def)"], ["", "lemma pfinite_swap\\<^sub>C [pfinite_intro]: \"pfinite_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1) swap\\<^sub>C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2)\n     (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>1) swap\\<^sub>C", "by(coinduction)(auto simp add: swap\\<^sub>C_def)"], ["", "lemma pfinite_swap_lassocr [pfinite_intro]: \"pfinite_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3)) (\\<I>2 \\<oplus>\\<^sub>\\<I> (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3)) swap_lassocr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter\n     (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3))\n     (\\<I>2 \\<oplus>\\<^sub>\\<I> (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3))\n     swap_lassocr", "unfolding swap_lassocr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter\n     (\\<I>1 \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>3))\n     (\\<I>2 \\<oplus>\\<^sub>\\<I> (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3))\n     (rassocl\\<^sub>C \\<odot>\n      (swap\\<^sub>C |\\<^sub>= 1\\<^sub>C) \\<odot> lassocr\\<^sub>C)", "by(rule pfinite_intro WT_intro)+"], ["", "lemma pfinite_swap_rassocl [pfinite_intro]: \"pfinite_converter ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3) ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<oplus>\\<^sub>\\<I> \\<I>2) swap_rassocl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter\n     ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3)\n     ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<oplus>\\<^sub>\\<I> \\<I>2)\n     swap_rassocl", "unfolding swap_rassocl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter\n     ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> \\<I>3)\n     ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<oplus>\\<^sub>\\<I> \\<I>2)\n     (lassocr\\<^sub>C \\<odot>\n      (1\\<^sub>C |\\<^sub>= swap\\<^sub>C) \\<odot> rassocl\\<^sub>C)", "by(rule pfinite_intro WT_intro)+"], ["", "lemma pfinite_parallel_wiring [pfinite_intro]:\n  \"pfinite_converter ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I> (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4)) ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<oplus>\\<^sub>\\<I> (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>4)) parallel_wiring\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter\n     ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n      (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4))\n     ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<oplus>\\<^sub>\\<I>\n      (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>4))\n     parallel_wiring", "unfolding parallel_wiring_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter\n     ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<oplus>\\<^sub>\\<I>\n      (\\<I>3 \\<oplus>\\<^sub>\\<I> \\<I>4))\n     ((\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>3) \\<oplus>\\<^sub>\\<I>\n      (\\<I>2 \\<oplus>\\<^sub>\\<I> \\<I>4))\n     (lassocr\\<^sub>C \\<odot>\n      (1\\<^sub>C |\\<^sub>= swap_lassocr) \\<odot> rassocl\\<^sub>C)", "by(rule pfinite_intro WT_intro)+"], ["", "lemma pfinite_parallel_converter [pfinite_intro]:\n  \"pfinite_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<I>3 (conv1 |\\<^sub>\\<propto> conv2)\"\n  if \"pfinite_converter \\<I>1 \\<I>3 conv1\" and \"pfinite_converter \\<I>2 \\<I>3 conv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<I>3\n     (conv1 |\\<^sub>\\<propto> conv2)", "using that"], ["proof (prove)\nusing this:\n  pfinite_converter \\<I>1 \\<I>3 conv1\n  pfinite_converter \\<I>2 \\<I>3 conv2\n\ngoal (1 subgoal):\n 1. pfinite_converter (\\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2) \\<I>3\n     (conv1 |\\<^sub>\\<propto> conv2)", "by(coinduction arbitrary: conv1 conv2)(fastforce dest: pfinite_converterD)"], ["", "lemma pfinite_converter_of_resource [simp, pfinite_intro]: \"pfinite_converter \\<I>1 \\<I>2 (converter_of_resource res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pfinite_converter \\<I>1 \\<I>2 (converter_of_resource res)", "by(coinduction arbitrary: res) auto"], ["", "subsection \\<open>colossless converter\\<close>"], ["", "coinductive colossless_converter :: \"('a, 'b) \\<I> \\<Rightarrow> ('c, 'd) \\<I> \\<Rightarrow> ('a, 'b, 'c, 'd) converter \\<Rightarrow> bool\"\n  for \\<I> \\<I>' where\n  colossless_converterI:\n  \"colossless_converter \\<I> \\<I>' conv\" if \n    \"\\<And>a. a \\<in> outs_\\<I> \\<I> \\<Longrightarrow> colossless_gpv \\<I>' (run_converter conv a)\"\n    \"\\<And>a b conv'. \\<lbrakk> a \\<in> outs_\\<I> \\<I>; (b, conv') \\<in> results_gpv \\<I>' (run_converter conv a) \\<rbrakk> \\<Longrightarrow> colossless_converter \\<I> \\<I>' conv'\""], ["", "lemma colossless_converter_coinduct[consumes 1, case_names colossless_converter, case_conclusion colossless_converter plossless step, coinduct pred: colossless_converter]:\n  assumes \"X conv\"\n    and step: \"\\<And>conv a. \\<lbrakk> X conv; a \\<in> outs_\\<I> \\<I> \\<rbrakk> \\<Longrightarrow> colossless_gpv \\<I>' (run_converter conv a) \\<and>\n     (\\<forall>(b, conv') \\<in> results_gpv \\<I>' (run_converter conv a). X conv' \\<or> colossless_converter \\<I> \\<I>' conv')\"\n  shows \"colossless_converter \\<I> \\<I>' conv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. colossless_converter \\<I> \\<I>' conv", "using assms(1)"], ["proof (prove)\nusing this:\n  X conv\n\ngoal (1 subgoal):\n 1. colossless_converter \\<I> \\<I>' conv", "by(rule colossless_converter.coinduct)(auto dest: step)"], ["", "lemma colossless_converterD:\n  \"\\<lbrakk> colossless_converter \\<I> \\<I>' conv; a \\<in> outs_\\<I> \\<I> \\<rbrakk> \n  \\<Longrightarrow> colossless_gpv \\<I>' (run_converter conv a) \\<and>\n     (\\<forall>(b, conv') \\<in> results_gpv \\<I>' (run_converter conv a). colossless_converter \\<I> \\<I>' conv')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>colossless_converter \\<I> \\<I>' conv;\n     a \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> colossless_gpv \\<I>' (run_converter conv a) \\<and>\n                      (\\<forall>(b, conv')\n                                \\<in>results_gpv \\<I>'\n(run_converter conv a).\n                          colossless_converter \\<I> \\<I>' conv')", "by(auto elim: colossless_converter.cases)"], ["", "lemma colossless_converter_bot1 [simp]: \"colossless_converter bot \\<I> conv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. colossless_converter \\<bottom> \\<I> conv", "by(rule colossless_converterI) auto"], ["", "lemma raw_converter_invariant_run_colossless_converter: \"raw_converter_invariant \\<I> \\<I>' run_converter (\\<lambda>conv. colossless_converter \\<I> \\<I>' conv \\<and> \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<surd>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. raw_converter_invariant \\<I> \\<I>' run_converter\n     (\\<lambda>conv.\n         colossless_converter \\<I> \\<I>' conv \\<and> \\<I>,\n         \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>)", "by(unfold_locales)(auto dest: WT_converterD colossless_converterD)"], ["", "interpretation run_colossless_converter: raw_converter_invariant\n  \\<I> \\<I>' run_converter \"\\<lambda>conv. colossless_converter \\<I> \\<I>' conv \\<and> \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<surd>\" for \\<I> \\<I>'"], ["proof (prove)\ngoal (1 subgoal):\n 1. raw_converter_invariant \\<I> \\<I>' run_converter\n     (\\<lambda>conv.\n         colossless_converter \\<I> \\<I>' conv \\<and> \\<I>,\n         \\<I>' \\<turnstile>\\<^sub>C conv \\<surd>)", "by(rule raw_converter_invariant_run_colossless_converter)"], ["", "lemma colossless_const_converter [simp]: \"colossless_converter \\<I> \\<I>' (const_converter x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. colossless_converter \\<I> \\<I>' (const_converter x)", "by(coinduction)(auto)"], ["", "subsection \\<open>trace equivalence\\<close>"], ["", "lemma distinguish_trace_eq: (* generalized from Distinguisher.thy *)\n  assumes distinguish: \"\\<And>distinguisher. \\<I> \\<turnstile>g distinguisher \\<surd> \\<Longrightarrow> connect distinguisher res = connect distinguisher res'\"\n  shows \"outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<approx> res'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<approx> res'", "using assms"], ["proof (prove)\nusing this:\n  \\<I> \\<turnstile>g ?distinguisher \\<surd> \\<Longrightarrow>\n  connect ?distinguisher res = connect ?distinguisher res'\n\ngoal (1 subgoal):\n 1. outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res \\<approx> res'", "by(rule distinguish_trace_eq)(auto intro: WT_fail_resource)"], ["", "lemma attach_trace_eq':\n  assumes eq: \"outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res1 \\<approx> res2\"\n    and WT1 [WT_intro]: \"\\<I> \\<turnstile>res res1 \\<surd>\"\n    and WT2 [WT_intro]: \"\\<I> \\<turnstile>res res2 \\<surd>\"\n    and WT_conv [WT_intro]: \"\\<I>',\\<I> \\<turnstile>\\<^sub>C conv \\<surd>\"\n  shows \"outs_\\<I> \\<I>' \\<turnstile>\\<^sub>R conv \\<rhd> res1 \\<approx> conv \\<rhd> res2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outs_\\<I> \\<I>' \\<turnstile>\\<^sub>R conv \\<rhd> res1\n    \\<approx> conv \\<rhd> res2", "proof(rule distinguish_trace_eq)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>distinguisher.\n       \\<I>' \\<turnstile>g distinguisher \\<surd> \\<Longrightarrow>\n       connect distinguisher (conv \\<rhd> res1) =\n       connect distinguisher (conv \\<rhd> res2)", "fix \\<D> :: \"('c, 'd) distinguisher\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>distinguisher.\n       \\<I>' \\<turnstile>g distinguisher \\<surd> \\<Longrightarrow>\n       connect distinguisher (conv \\<rhd> res1) =\n       connect distinguisher (conv \\<rhd> res2)", "assume [WT_intro]: \"\\<I>' \\<turnstile>g \\<D> \\<surd>\""], ["proof (state)\nthis:\n  \\<I>' \\<turnstile>g \\<D> \\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>distinguisher.\n       \\<I>' \\<turnstile>g distinguisher \\<surd> \\<Longrightarrow>\n       connect distinguisher (conv \\<rhd> res1) =\n       connect distinguisher (conv \\<rhd> res2)", "have \"connect (absorb \\<D> conv) res1 = connect (absorb \\<D> conv) res2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connect (absorb \\<D> conv) res1 = connect (absorb \\<D> conv) res2", "using eq"], ["proof (prove)\nusing this:\n  outs_\\<I> \\<I> \\<turnstile>\\<^sub>R res1 \\<approx> res2\n\ngoal (1 subgoal):\n 1. connect (absorb \\<D> conv) res1 = connect (absorb \\<D> conv) res2", "by(rule connect_cong_trace)(rule WT_intro | fold WT_gpv_iff_outs_gpv)+"], ["proof (state)\nthis:\n  connect (absorb \\<D> conv) res1 = connect (absorb \\<D> conv) res2\n\ngoal (1 subgoal):\n 1. \\<And>distinguisher.\n       \\<I>' \\<turnstile>g distinguisher \\<surd> \\<Longrightarrow>\n       connect distinguisher (conv \\<rhd> res1) =\n       connect distinguisher (conv \\<rhd> res2)", "then"], ["proof (chain)\npicking this:\n  connect (absorb \\<D> conv) res1 = connect (absorb \\<D> conv) res2", "show \"connect \\<D> (conv \\<rhd> res1) = connect \\<D> (conv \\<rhd> res2)\""], ["proof (prove)\nusing this:\n  connect (absorb \\<D> conv) res1 = connect (absorb \\<D> conv) res2\n\ngoal (1 subgoal):\n 1. connect \\<D> (conv \\<rhd> res1) = connect \\<D> (conv \\<rhd> res2)", "by(simp add: distinguish_attach)"], ["proof (state)\nthis:\n  connect \\<D> (conv \\<rhd> res1) = connect \\<D> (conv \\<rhd> res2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_callee_eq_trans [trans]:\n  \"\\<lbrakk> trace_callee_eq callee1 callee2 A p q; trace_callee_eq callee2 callee3 A q r \\<rbrakk>\n   \\<Longrightarrow> trace_callee_eq callee1 callee3 A p r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trace_callee_eq callee1 callee2 A p q;\n     trace_callee_eq callee2 callee3 A q r\\<rbrakk>\n    \\<Longrightarrow> trace_callee_eq callee1 callee3 A p r", "by(simp add: trace_callee_eq_def)"], ["", "lemma trace_eq'_parallel_resource:\n  fixes res1 :: \"('a, 'b) resource\" and res2 :: \"('c, 'd) resource\"\n  assumes 1: \"trace_eq' A res1 res1'\"\n    and 2: \"trace_eq' B res2 res2'\"\n  shows \"trace_eq' (A <+> B) (res1 \\<parallel> res2) (res1' \\<parallel> res2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A <+> B) \\<turnstile>\\<^sub>R res1 \\<parallel> res2\n    \\<approx> res1' \\<parallel> res2'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (A <+> B) \\<turnstile>\\<^sub>R res1 \\<parallel> res2\n    \\<approx> res1' \\<parallel> res2'", "let ?\\<I> = \"\\<I>_uniform A (UNIV :: 'b set) \\<oplus>\\<^sub>\\<I> \\<I>_uniform B (UNIV :: 'd set)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (A <+> B) \\<turnstile>\\<^sub>R res1 \\<parallel> res2\n    \\<approx> res1' \\<parallel> res2'", "have \"trace_eq' (outs_\\<I> ?\\<I>) (res1 \\<parallel> res2) (res1' \\<parallel> res2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outs_\\<I>\n     (\\<I>_uniform A UNIV \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform B UNIV) \\<turnstile>\\<^sub>R\n    res1 \\<parallel> res2 \\<approx> res1' \\<parallel> res2", "apply(subst (1 2) attach_converter_of_resource_conv_parallel_resource2[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. outs_\\<I>\n     (\\<I>_uniform A UNIV \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform B UNIV) \\<turnstile>\\<^sub>R\n    1\\<^sub>C |\\<^sub>\\<propto> converter_of_resource res2 \\<rhd> res1\n    \\<approx> 1\\<^sub>C |\\<^sub>\\<propto> converter_of_resource res2 \\<rhd>\n              res1'", "apply(rule attach_trace_eq'[where ?\\<I> = \"\\<I>_uniform A UNIV\"]; auto simp add: 1 intro: WT_intro WT_resource_\\<I>_uniform_UNIV)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  outs_\\<I>\n   (\\<I>_uniform A UNIV \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform B UNIV) \\<turnstile>\\<^sub>R\n  res1 \\<parallel> res2 \\<approx> res1' \\<parallel> res2\n\ngoal (1 subgoal):\n 1. (A <+> B) \\<turnstile>\\<^sub>R res1 \\<parallel> res2\n    \\<approx> res1' \\<parallel> res2'", "also"], ["proof (state)\nthis:\n  outs_\\<I>\n   (\\<I>_uniform A UNIV \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform B UNIV) \\<turnstile>\\<^sub>R\n  res1 \\<parallel> res2 \\<approx> res1' \\<parallel> res2\n\ngoal (1 subgoal):\n 1. (A <+> B) \\<turnstile>\\<^sub>R res1 \\<parallel> res2\n    \\<approx> res1' \\<parallel> res2'", "have \"trace_eq' (outs_\\<I> ?\\<I>) (res1' \\<parallel> res2) (res1' \\<parallel> res2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outs_\\<I>\n     (\\<I>_uniform A UNIV \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform B UNIV) \\<turnstile>\\<^sub>R\n    res1' \\<parallel> res2 \\<approx> res1' \\<parallel> res2'", "apply(subst (1 2) attach_converter_of_resource_conv_parallel_resource[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. outs_\\<I>\n     (\\<I>_uniform A UNIV \\<oplus>\\<^sub>\\<I>\n      \\<I>_uniform B UNIV) \\<turnstile>\\<^sub>R\n    converter_of_resource res1' |\\<^sub>\\<propto> 1\\<^sub>C \\<rhd> res2\n    \\<approx> converter_of_resource res1' |\\<^sub>\\<propto> 1\\<^sub>C \\<rhd>\n              res2'", "apply(rule attach_trace_eq'[where ?\\<I> = \"\\<I>_uniform B UNIV\"]; auto simp add: 2 intro: WT_intro WT_resource_\\<I>_uniform_UNIV)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  outs_\\<I>\n   (\\<I>_uniform A UNIV \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform B UNIV) \\<turnstile>\\<^sub>R\n  res1' \\<parallel> res2 \\<approx> res1' \\<parallel> res2'\n\ngoal (1 subgoal):\n 1. (A <+> B) \\<turnstile>\\<^sub>R res1 \\<parallel> res2\n    \\<approx> res1' \\<parallel> res2'", "finally"], ["proof (chain)\npicking this:\n  outs_\\<I>\n   (\\<I>_uniform A UNIV \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform B UNIV) \\<turnstile>\\<^sub>R\n  res1 \\<parallel> res2 \\<approx> res1' \\<parallel> res2'", "show ?thesis"], ["proof (prove)\nusing this:\n  outs_\\<I>\n   (\\<I>_uniform A UNIV \\<oplus>\\<^sub>\\<I>\n    \\<I>_uniform B UNIV) \\<turnstile>\\<^sub>R\n  res1 \\<parallel> res2 \\<approx> res1' \\<parallel> res2'\n\ngoal (1 subgoal):\n 1. (A <+> B) \\<turnstile>\\<^sub>R res1 \\<parallel> res2\n    \\<approx> res1' \\<parallel> res2'", "by simp"], ["proof (state)\nthis:\n  (A <+> B) \\<turnstile>\\<^sub>R res1 \\<parallel> res2\n  \\<approx> res1' \\<parallel> res2'\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition trace_callee_eq_coinduct [consumes 1, case_names step sim]: (* stronger version of trace'_eq_simI *)\n  fixes callee1 :: \"('a, 'b, 's1) callee\" and callee2 :: \"('a, 'b, 's2) callee\"\n  assumes start: \"S p q\"\n    and step: \"\\<And>p q a. \\<lbrakk> S p q; a \\<in> A \\<rbrakk> \\<Longrightarrow>\n      bind_spmf p (\\<lambda>s. map_spmf fst (callee1 s a)) = bind_spmf q (\\<lambda>s. map_spmf fst (callee2 s a))\"\n    and sim: \"\\<And>p q a res res' b s'' s'. \\<lbrakk> S p q; a \\<in> A; res \\<in> set_spmf p; (b, s'') \\<in> set_spmf (callee1 res a); res' \\<in> set_spmf q; (b, s') \\<in> set_spmf (callee2 res' a) \\<rbrakk>\n      \\<Longrightarrow> S (cond_spmf_fst (bind_spmf p (\\<lambda>s. callee1 s a)) b)\n            (cond_spmf_fst (bind_spmf q (\\<lambda>s. callee2 s a)) b)\"\n  shows \"trace_callee_eq callee1 callee2 A p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee_eq callee1 callee2 A p q", "proof(rule trace_callee_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> A \\<times> UNIV; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p xs x =\n                         trace_callee callee2 q xs x", "fix xs :: \"('a \\<times> 'b) list\" and z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> A \\<times> UNIV; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p xs x =\n                         trace_callee callee2 q xs x", "assume xs: \"set xs \\<subseteq> A \\<times> UNIV\" and z: \"z \\<in> A\""], ["proof (state)\nthis:\n  set xs \\<subseteq> A \\<times> UNIV\n  z \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>xs x.\n       \\<lbrakk>set xs \\<subseteq> A \\<times> UNIV; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p xs x =\n                         trace_callee callee2 q xs x", "from start"], ["proof (chain)\npicking this:\n  S p q", "show \"trace_callee callee1 p xs z = trace_callee callee2 q xs z\""], ["proof (prove)\nusing this:\n  S p q\n\ngoal (1 subgoal):\n 1. trace_callee callee1 p xs z = trace_callee callee2 q xs z", "using xs"], ["proof (prove)\nusing this:\n  S p q\n  set xs \\<subseteq> A \\<times> UNIV\n\ngoal (1 subgoal):\n 1. trace_callee callee1 p xs z = trace_callee callee2 q xs z", "proof(induction xs arbitrary: p q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p q.\n       \\<lbrakk>S p q; set [] \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p [] z =\n                         trace_callee callee2 q [] z\n 2. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>S p q;\n                    set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> trace_callee callee1 p xs z =\n                                     trace_callee callee2 q xs z;\n        S p q; set (a # xs) \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p (a # xs) z =\n                         trace_callee callee2 q (a # xs) z", "case Nil"], ["proof (state)\nthis:\n  S p q\n  set [] \\<subseteq> A \\<times> UNIV\n\ngoal (2 subgoals):\n 1. \\<And>p q.\n       \\<lbrakk>S p q; set [] \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p [] z =\n                         trace_callee callee2 q [] z\n 2. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>S p q;\n                    set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> trace_callee callee1 p xs z =\n                                     trace_callee callee2 q xs z;\n        S p q; set (a # xs) \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p (a # xs) z =\n                         trace_callee callee2 q (a # xs) z", "then"], ["proof (chain)\npicking this:\n  S p q\n  set [] \\<subseteq> A \\<times> UNIV", "show ?case"], ["proof (prove)\nusing this:\n  S p q\n  set [] \\<subseteq> A \\<times> UNIV\n\ngoal (1 subgoal):\n 1. trace_callee callee1 p [] z = trace_callee callee2 q [] z", "using z"], ["proof (prove)\nusing this:\n  S p q\n  set [] \\<subseteq> A \\<times> UNIV\n  z \\<in> A\n\ngoal (1 subgoal):\n 1. trace_callee callee1 p [] z = trace_callee callee2 q [] z", "by(simp add: step)"], ["proof (state)\nthis:\n  trace_callee callee1 p [] z = trace_callee callee2 q [] z\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>S p q;\n                    set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> trace_callee callee1 p xs z =\n                                     trace_callee callee2 q xs z;\n        S p q; set (a # xs) \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p (a # xs) z =\n                         trace_callee callee2 q (a # xs) z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>S p q;\n                    set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> trace_callee callee1 p xs z =\n                                     trace_callee callee2 q xs z;\n        S p q; set (a # xs) \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p (a # xs) z =\n                         trace_callee callee2 q (a # xs) z", "case (Cons xy xs)"], ["proof (state)\nthis:\n  \\<lbrakk>S ?p ?q; set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n  \\<Longrightarrow> trace_callee callee1 ?p xs z =\n                    trace_callee callee2 ?q xs z\n  S p q\n  set (xy # xs) \\<subseteq> A \\<times> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>S p q;\n                    set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> trace_callee callee1 p xs z =\n                                     trace_callee callee2 q xs z;\n        S p q; set (a # xs) \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p (a # xs) z =\n                         trace_callee callee2 q (a # xs) z", "obtain x y where xy [simp]: \"xy = (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y. xy = (x, y) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases xy)"], ["proof (state)\nthis:\n  xy = (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>S p q;\n                    set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> trace_callee callee1 p xs z =\n                                     trace_callee callee2 q xs z;\n        S p q; set (a # xs) \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p (a # xs) z =\n                         trace_callee callee2 q (a # xs) z", "have \"trace_callee callee1 p (xy # xs) z = \n      trace_callee callee1 (cond_spmf_fst (bind_spmf p (\\<lambda>s. callee1 s x)) y) xs z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee callee1 p (xy # xs) z =\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z", "by(simp add: bind_map_spmf split_def o_def)"], ["proof (state)\nthis:\n  trace_callee callee1 p (xy # xs) z =\n  trace_callee callee1\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>S p q;\n                    set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> trace_callee callee1 p xs z =\n                                     trace_callee callee2 q xs z;\n        S p q; set (a # xs) \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p (a # xs) z =\n                         trace_callee callee2 q (a # xs) z", "also"], ["proof (state)\nthis:\n  trace_callee callee1 p (xy # xs) z =\n  trace_callee callee1\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>S p q;\n                    set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> trace_callee callee1 p xs z =\n                                     trace_callee callee2 q xs z;\n        S p q; set (a # xs) \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p (a # xs) z =\n                         trace_callee callee2 q (a # xs) z", "have \"\\<dots> = trace_callee callee2 (cond_spmf_fst (bind_spmf q (\\<lambda>s. callee2 s x)) y) xs z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "proof(cases \"\\<exists>s \\<in> set_spmf q. \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>s\\<in>set_spmf q.\n       \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z\n 2. \\<not> (\\<exists>s\\<in>set_spmf q.\n               \\<exists>s'.\n                  (y, s') \\<in> set_spmf (callee2 s x)) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "case True"], ["proof (state)\nthis:\n  \\<exists>s\\<in>set_spmf q.\n     \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x)\n\ngoal (2 subgoals):\n 1. \\<exists>s\\<in>set_spmf q.\n       \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z\n 2. \\<not> (\\<exists>s\\<in>set_spmf q.\n               \\<exists>s'.\n                  (y, s') \\<in> set_spmf (callee2 s x)) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "then"], ["proof (chain)\npicking this:\n  \\<exists>s\\<in>set_spmf q.\n     \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x)", "obtain s s' where ss': \"s \\<in> set_spmf q\" \"(y, s') \\<in> set_spmf (callee2 s x)\""], ["proof (prove)\nusing this:\n  \\<exists>s\\<in>set_spmf q.\n     \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x)\n\ngoal (1 subgoal):\n 1. (\\<And>s s'.\n        \\<lbrakk>s \\<in> set_spmf q;\n         (y, s') \\<in> set_spmf (callee2 s x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s \\<in> set_spmf q\n  (y, s') \\<in> set_spmf (callee2 s x)\n\ngoal (2 subgoals):\n 1. \\<exists>s\\<in>set_spmf q.\n       \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z\n 2. \\<not> (\\<exists>s\\<in>set_spmf q.\n               \\<exists>s'.\n                  (y, s') \\<in> set_spmf (callee2 s x)) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "from Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>S ?p ?q; set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n  \\<Longrightarrow> trace_callee callee1 ?p xs z =\n                    trace_callee callee2 ?q xs z\n  S p q\n  set (xy # xs) \\<subseteq> A \\<times> UNIV", "have \"x \\<in> A\""], ["proof (prove)\nusing this:\n  \\<lbrakk>S ?p ?q; set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n  \\<Longrightarrow> trace_callee callee1 ?p xs z =\n                    trace_callee callee2 ?q xs z\n  S p q\n  set (xy # xs) \\<subseteq> A \\<times> UNIV\n\ngoal (1 subgoal):\n 1. x \\<in> A", "by simp"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (2 subgoals):\n 1. \\<exists>s\\<in>set_spmf q.\n       \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z\n 2. \\<not> (\\<exists>s\\<in>set_spmf q.\n               \\<exists>s'.\n                  (y, s') \\<in> set_spmf (callee2 s x)) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "from ss' step[THEN arg_cong[where f=\"set_spmf\"], OF \\<open>S p q\\<close> this]"], ["proof (chain)\npicking this:\n  s \\<in> set_spmf q\n  (y, s') \\<in> set_spmf (callee2 s x)\n  set_spmf (p \\<bind> (\\<lambda>s. map_spmf fst (callee1 s x))) =\n  set_spmf (q \\<bind> (\\<lambda>s. map_spmf fst (callee2 s x)))", "obtain ss ss'\n        where \"ss \\<in> set_spmf p\" \"(y, ss') \\<in> set_spmf (callee1 ss x)\""], ["proof (prove)\nusing this:\n  s \\<in> set_spmf q\n  (y, s') \\<in> set_spmf (callee2 s x)\n  set_spmf (p \\<bind> (\\<lambda>s. map_spmf fst (callee1 s x))) =\n  set_spmf (q \\<bind> (\\<lambda>s. map_spmf fst (callee2 s x)))\n\ngoal (1 subgoal):\n 1. (\\<And>ss ss'.\n        \\<lbrakk>ss \\<in> set_spmf p;\n         (y, ss') \\<in> set_spmf (callee1 ss x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(clarsimp simp add: bind_UNION) force"], ["proof (state)\nthis:\n  ss \\<in> set_spmf p\n  (y, ss') \\<in> set_spmf (callee1 ss x)\n\ngoal (2 subgoals):\n 1. \\<exists>s\\<in>set_spmf q.\n       \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z\n 2. \\<not> (\\<exists>s\\<in>set_spmf q.\n               \\<exists>s'.\n                  (y, s') \\<in> set_spmf (callee2 s x)) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "from sim[OF \\<open>S p q\\<close> _ this ss']"], ["proof (chain)\npicking this:\n  x \\<in> A \\<Longrightarrow>\n  S (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Longrightarrow>\n  S (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y)\n\ngoal (1 subgoal):\n 1. trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "using Cons.prems"], ["proof (prove)\nusing this:\n  x \\<in> A \\<Longrightarrow>\n  S (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y)\n  S p q\n  set (xy # xs) \\<subseteq> A \\<times> UNIV\n\ngoal (1 subgoal):\n 1. trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "by (auto intro: Cons.IH)"], ["proof (state)\nthis:\n  trace_callee callee1\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n  trace_callee callee2\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>s\\<in>set_spmf q.\n               \\<exists>s'.\n                  (y, s') \\<in> set_spmf (callee2 s x)) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>s\\<in>set_spmf q.\n               \\<exists>s'.\n                  (y, s') \\<in> set_spmf (callee2 s x)) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>s\\<in>set_spmf q.\n             \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>s\\<in>set_spmf q.\n               \\<exists>s'.\n                  (y, s') \\<in> set_spmf (callee2 s x)) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>s\\<in>set_spmf q.\n             \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x))", "have \"cond_spmf_fst (bind_spmf q (\\<lambda>s. callee2 s x)) y = return_pmf None\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>s\\<in>set_spmf q.\n             \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x))\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y = return_pmf None", "by(auto simp add: bind_eq_return_pmf_None)"], ["proof (state)\nthis:\n  cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y = return_pmf None\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>s\\<in>set_spmf q.\n               \\<exists>s'.\n                  (y, s') \\<in> set_spmf (callee2 s x)) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "moreover"], ["proof (state)\nthis:\n  cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y = return_pmf None\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>s\\<in>set_spmf q.\n               \\<exists>s'.\n                  (y, s') \\<in> set_spmf (callee2 s x)) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "from step[OF \\<open>S p q\\<close>, of x, THEN arg_cong[where f=set_spmf], THEN eq_refl] Cons.prems False"], ["proof (chain)\npicking this:\n  x \\<in> A \\<Longrightarrow>\n  set_spmf (p \\<bind> (\\<lambda>s. map_spmf fst (callee1 s x)))\n  \\<subseteq> set_spmf (q \\<bind> (\\<lambda>s. map_spmf fst (callee2 s x)))\n  S p q\n  set (xy # xs) \\<subseteq> A \\<times> UNIV\n  \\<not> (\\<exists>s\\<in>set_spmf q.\n             \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x))", "have \"cond_spmf_fst (bind_spmf p (\\<lambda>s. callee1 s x)) y = return_pmf None\""], ["proof (prove)\nusing this:\n  x \\<in> A \\<Longrightarrow>\n  set_spmf (p \\<bind> (\\<lambda>s. map_spmf fst (callee1 s x)))\n  \\<subseteq> set_spmf (q \\<bind> (\\<lambda>s. map_spmf fst (callee2 s x)))\n  S p q\n  set (xy # xs) \\<subseteq> A \\<times> UNIV\n  \\<not> (\\<exists>s\\<in>set_spmf q.\n             \\<exists>s'. (y, s') \\<in> set_spmf (callee2 s x))\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y = return_pmf None", "by(clarsimp simp add: bind_eq_return_pmf_None)(rule ccontr; fastforce)"], ["proof (state)\nthis:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y = return_pmf None\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>s\\<in>set_spmf q.\n               \\<exists>s'.\n                  (y, s') \\<in> set_spmf (callee2 s x)) \\<Longrightarrow>\n    trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "ultimately"], ["proof (chain)\npicking this:\n  cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y = return_pmf None\n  cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y = return_pmf None", "show ?thesis"], ["proof (prove)\nusing this:\n  cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y = return_pmf None\n  cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y = return_pmf None\n\ngoal (1 subgoal):\n 1. trace_callee callee1\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n    trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z", "by(simp del: cond_spmf_fst_eq_return_None)"], ["proof (state)\nthis:\n  trace_callee callee1\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n  trace_callee callee2\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trace_callee callee1\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n  trace_callee callee2\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>S p q;\n                    set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> trace_callee callee1 p xs z =\n                                     trace_callee callee2 q xs z;\n        S p q; set (a # xs) \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p (a # xs) z =\n                         trace_callee callee2 q (a # xs) z", "also"], ["proof (state)\nthis:\n  trace_callee callee1\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s x)) y) xs z =\n  trace_callee callee2\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>S p q;\n                    set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> trace_callee callee1 p xs z =\n                                     trace_callee callee2 q xs z;\n        S p q; set (a # xs) \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p (a # xs) z =\n                         trace_callee callee2 q (a # xs) z", "have \"\\<dots> = trace_callee callee2 q (xy # xs) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee callee2\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z =\n    trace_callee callee2 q (xy # xs) z", "by(simp add: split_def o_def)"], ["proof (state)\nthis:\n  trace_callee callee2\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s x)) y) xs z =\n  trace_callee callee2 q (xy # xs) z\n\ngoal (1 subgoal):\n 1. \\<And>a xs p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>S p q;\n                    set xs \\<subseteq> A \\<times> UNIV\\<rbrakk>\n                   \\<Longrightarrow> trace_callee callee1 p xs z =\n                                     trace_callee callee2 q xs z;\n        S p q; set (a # xs) \\<subseteq> A \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1 p (a # xs) z =\n                         trace_callee callee2 q (a # xs) z", "finally"], ["proof (chain)\npicking this:\n  trace_callee callee1 p (xy # xs) z = trace_callee callee2 q (xy # xs) z", "show ?case"], ["proof (prove)\nusing this:\n  trace_callee callee1 p (xy # xs) z = trace_callee callee2 q (xy # xs) z\n\ngoal (1 subgoal):\n 1. trace_callee callee1 p (xy # xs) z = trace_callee callee2 q (xy # xs) z", "."], ["proof (state)\nthis:\n  trace_callee callee1 p (xy # xs) z = trace_callee callee2 q (xy # xs) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trace_callee callee1 p xs z = trace_callee callee2 q xs z\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition trace_callee_eq_coinduct_strong [consumes 1, case_names step sim, case_conclusion step lhs rhs, case_conclusion sim sim eq]:\n  fixes callee1 :: \"('a, 'b, 's1) callee\" and callee2 :: \"('a, 'b, 's2) callee\"\n  assumes start: \"S p q\"\n    and step: \"\\<And>p q a. \\<lbrakk> S p q; a \\<in> A \\<rbrakk> \\<Longrightarrow>\n      bind_spmf p (\\<lambda>s. map_spmf fst (callee1 s a)) = bind_spmf q (\\<lambda>s. map_spmf fst (callee2 s a))\"\n    and sim: \"\\<And>p q a res res' b s'' s'. \\<lbrakk> S p q; a \\<in> A; res \\<in> set_spmf p; (b, s'') \\<in> set_spmf (callee1 res a); res' \\<in> set_spmf q; (b, s') \\<in> set_spmf (callee2 res' a) \\<rbrakk>\n      \\<Longrightarrow> S (cond_spmf_fst (bind_spmf p (\\<lambda>s. callee1 s a)) b)\n            (cond_spmf_fst (bind_spmf q (\\<lambda>s. callee2 s a)) b) \\<or>\n          trace_callee_eq callee1 callee2 A (cond_spmf_fst (bind_spmf p (\\<lambda>s. callee1 s a)) b) (cond_spmf_fst (bind_spmf q (\\<lambda>s. callee2 s a)) b)\"\n  shows \"trace_callee_eq callee1 callee2 A p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee_eq callee1 callee2 A p q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace_callee_eq callee1 callee2 A p q", "from start"], ["proof (chain)\npicking this:\n  S p q", "have \"S p q \\<or> trace_callee_eq callee1 callee2 A p q\""], ["proof (prove)\nusing this:\n  S p q\n\ngoal (1 subgoal):\n 1. S p q \\<or> trace_callee_eq callee1 callee2 A p q", "by simp"], ["proof (state)\nthis:\n  S p q \\<or> trace_callee_eq callee1 callee2 A p q\n\ngoal (1 subgoal):\n 1. trace_callee_eq callee1 callee2 A p q", "thus ?thesis"], ["proof (prove)\nusing this:\n  S p q \\<or> trace_callee_eq callee1 callee2 A p q\n\ngoal (1 subgoal):\n 1. trace_callee_eq callee1 callee2 A p q", "apply(rule trace_callee_eq_coinduct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p q a.\n       \\<lbrakk>S p q \\<or> trace_callee_eq callee1 callee2 A p q;\n        a \\<in> A\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s. map_spmf fst (callee1 s a)) =\n                         q \\<bind> (\\<lambda>s. map_spmf fst (callee2 s a))\n 2. \\<And>p q a res res' b s'' s'.\n       \\<lbrakk>S p q \\<or> trace_callee_eq callee1 callee2 A p q;\n        a \\<in> A; res \\<in> set_spmf p;\n        (b, s'') \\<in> set_spmf (callee1 res a); res' \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee2 res' a)\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b) \\<or>\n                         trace_callee_eq callee1 callee2 A\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "apply(erule disjE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>p q a.\n       \\<lbrakk>a \\<in> A; S p q\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s. map_spmf fst (callee1 s a)) =\n                         q \\<bind> (\\<lambda>s. map_spmf fst (callee2 s a))\n 2. \\<And>p q a.\n       \\<lbrakk>a \\<in> A; trace_callee_eq callee1 callee2 A p q\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s. map_spmf fst (callee1 s a)) =\n                         q \\<bind> (\\<lambda>s. map_spmf fst (callee2 s a))\n 3. \\<And>p q a res res' b s'' s'.\n       \\<lbrakk>S p q \\<or> trace_callee_eq callee1 callee2 A p q;\n        a \\<in> A; res \\<in> set_spmf p;\n        (b, s'') \\<in> set_spmf (callee1 res a); res' \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee2 res' a)\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b) \\<or>\n                         trace_callee_eq callee1 callee2 A\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "apply(erule (1) step)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p q a.\n       \\<lbrakk>a \\<in> A; trace_callee_eq callee1 callee2 A p q\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s. map_spmf fst (callee1 s a)) =\n                         q \\<bind> (\\<lambda>s. map_spmf fst (callee2 s a))\n 2. \\<And>p q a res res' b s'' s'.\n       \\<lbrakk>S p q \\<or> trace_callee_eq callee1 callee2 A p q;\n        a \\<in> A; res \\<in> set_spmf p;\n        (b, s'') \\<in> set_spmf (callee1 res a); res' \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee2 res' a)\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b) \\<or>\n                         trace_callee_eq callee1 callee2 A\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "apply(drule trace_callee_eqD[where xs=\"[]\"]; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q a res res' b s'' s'.\n       \\<lbrakk>S p q \\<or> trace_callee_eq callee1 callee2 A p q;\n        a \\<in> A; res \\<in> set_spmf p;\n        (b, s'') \\<in> set_spmf (callee1 res a); res' \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee2 res' a)\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b) \\<or>\n                         trace_callee_eq callee1 callee2 A\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "apply(erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p q a res res' b s'' s'.\n       \\<lbrakk>a \\<in> A; res \\<in> set_spmf p;\n        (b, s'') \\<in> set_spmf (callee1 res a); res' \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee2 res' a); S p q\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b) \\<or>\n                         trace_callee_eq callee1 callee2 A\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b)\n 2. \\<And>p q a res res' b s'' s'.\n       \\<lbrakk>a \\<in> A; res \\<in> set_spmf p;\n        (b, s'') \\<in> set_spmf (callee1 res a); res' \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee2 res' a);\n        trace_callee_eq callee1 callee2 A p q\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b) \\<or>\n                         trace_callee_eq callee1 callee2 A\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "apply(erule (5) sim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q a res res' b s'' s'.\n       \\<lbrakk>a \\<in> A; res \\<in> set_spmf p;\n        (b, s'') \\<in> set_spmf (callee1 res a); res' \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee2 res' a);\n        trace_callee_eq callee1 callee2 A p q\\<rbrakk>\n       \\<Longrightarrow> S (cond_spmf_fst\n                             (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b) \\<or>\n                         trace_callee_eq callee1 callee2 A\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "apply(rule disjI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q a res res' b s'' s'.\n       \\<lbrakk>a \\<in> A; res \\<in> set_spmf p;\n        (b, s'') \\<in> set_spmf (callee1 res a); res' \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee2 res' a);\n        trace_callee_eq callee1 callee2 A p q\\<rbrakk>\n       \\<Longrightarrow> trace_callee_eq callee1 callee2 A\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "apply(rule trace_callee_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q a res res' b s'' s' xs x.\n       \\<lbrakk>a \\<in> A; res \\<in> set_spmf p;\n        (b, s'') \\<in> set_spmf (callee1 res a); res' \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee2 res' a);\n        trace_callee_eq callee1 callee2 A p q;\n        set xs \\<subseteq> A \\<times> UNIV; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          xs x =\n                         trace_callee callee2\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b)\n                          xs x", "apply(drule trace_callee_eqD[where xs=\"(_, _) # _\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>p q a res res' b s'' s' xs x.\n       \\<lbrakk>a \\<in> A; res \\<in> set_spmf p;\n        (b, s'') \\<in> set_spmf (callee1 res a); res' \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee2 res' a);\n        set xs \\<subseteq> A \\<times> UNIV; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> set ((?uu33 p q a res res' b s'' s' xs x,\n                               ?uua33 p q a res res' b s'' s' xs x) #\n                              ?uub33 p q a res res' b s'' s' xs x)\n                         \\<subseteq> A \\<times> UNIV\n 2. \\<And>p q a res res' b s'' s' xs x.\n       \\<lbrakk>a \\<in> A; res \\<in> set_spmf p;\n        (b, s'') \\<in> set_spmf (callee1 res a); res' \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee2 res' a);\n        set xs \\<subseteq> A \\<times> UNIV; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> ?x33 p q a res res' b s'' s' xs x \\<in> A\n 3. \\<And>p q a res res' b s'' s' xs x.\n       \\<lbrakk>a \\<in> A; res \\<in> set_spmf p;\n        (b, s'') \\<in> set_spmf (callee1 res a); res' \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee2 res' a);\n        set xs \\<subseteq> A \\<times> UNIV; x \\<in> A;\n        trace_callee callee1 p\n         ((?uu33 p q a res res' b s'' s' xs x,\n           ?uua33 p q a res res' b s'' s' xs x) #\n          ?uub33 p q a res res' b s'' s' xs x)\n         (?x33 p q a res res' b s'' s' xs x) =\n        trace_callee callee2 q\n         ((?uu33 p q a res res' b s'' s' xs x,\n           ?uua33 p q a res res' b s'' s' xs x) #\n          ?uub33 p q a res res' b s'' s' xs x)\n         (?x33 p q a res res' b s'' s' xs x)\\<rbrakk>\n       \\<Longrightarrow> trace_callee callee1\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          xs x =\n                         trace_callee callee2\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b)\n                          xs x", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  trace_callee_eq callee1 callee2 A p q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_callee_return_pmf_None [simp]:\n  \"trace_callee_eq callee1 callee2 A (return_pmf None) (return_pmf None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee_eq callee1 callee2 A (return_pmf None) (return_pmf None)", "by(rule trace_callee_eqI) simp"], ["", "lemma trace_callee_eq_sym [sym]: \"trace_callee_eq callee1 callee2 A p q \\<Longrightarrow> trace_callee_eq callee2 callee1 A q p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee_eq callee1 callee2 A p q \\<Longrightarrow>\n    trace_callee_eq callee2 callee1 A q p", "by(simp add: trace_callee_eq_def)"], ["", "lemma eq_resource_on_imp_trace_eq: \"A \\<turnstile>\\<^sub>R res1 \\<approx> res2\" if \"A \\<turnstile>\\<^sub>R res1 \\<sim> res2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>R res1 \\<approx> res2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>R res1 \\<approx> res2", "have \"outs_\\<I> (\\<I>_uniform A UNIV :: ('a, 'b) \\<I>) \\<turnstile>\\<^sub>R res1 \\<approx> res2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outs_\\<I> (\\<I>_uniform A UNIV) \\<turnstile>\\<^sub>R res1 \\<approx> res2", "using that"], ["proof (prove)\nusing this:\n  A \\<turnstile>\\<^sub>R res1 \\<sim> res2\n\ngoal (1 subgoal):\n 1. outs_\\<I> (\\<I>_uniform A UNIV) \\<turnstile>\\<^sub>R res1 \\<approx> res2", "by -(rule distinguish_trace_eq[OF connect_eq_resource_cong], simp+)"], ["proof (state)\nthis:\n  outs_\\<I> (\\<I>_uniform A UNIV) \\<turnstile>\\<^sub>R res1 \\<approx> res2\n\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>R res1 \\<approx> res2", "thus ?thesis"], ["proof (prove)\nusing this:\n  outs_\\<I> (\\<I>_uniform A UNIV) \\<turnstile>\\<^sub>R res1 \\<approx> res2\n\ngoal (1 subgoal):\n 1. A \\<turnstile>\\<^sub>R res1 \\<approx> res2", "by simp"], ["proof (state)\nthis:\n  A \\<turnstile>\\<^sub>R res1 \\<approx> res2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma advantage_nonneg: \"0 \\<le> advantage \\<A> res1 res2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> advantage \\<A> res1 res2", "by(simp add: advantage_def)"], ["", "lemma comp_converter_of_resource_conv_parallel_converter:\n  \"(converter_of_resource res |\\<^sub>\\<propto> 1\\<^sub>C) \\<odot> conv = converter_of_resource res |\\<^sub>\\<propto> conv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (converter_of_resource res |\\<^sub>\\<propto> 1\\<^sub>C) \\<odot> conv =\n    converter_of_resource res |\\<^sub>\\<propto> conv", "by(coinduction arbitrary: res conv)\n    (auto 4 3 simp add: rel_fun_def gpv.map_comp map_lift_spmf spmf_rel_map split_def map_gpv_conv_bind[symmetric] id_def[symmetric] gpv.rel_map split!: sum.split intro!: rel_spmf_reflI gpv.rel_refl_strong)"], ["", "lemma comp_converter_of_resource_conv_parallel_converter2:\n  \"(1\\<^sub>C |\\<^sub>\\<propto> converter_of_resource res) \\<odot> conv = conv |\\<^sub>\\<propto> converter_of_resource res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1\\<^sub>C |\\<^sub>\\<propto> converter_of_resource res) \\<odot> conv =\n    conv |\\<^sub>\\<propto> converter_of_resource res", "by(coinduction arbitrary: res conv)\n    (auto 4 3 simp add: rel_fun_def gpv.map_comp map_lift_spmf spmf_rel_map split_def map_gpv_conv_bind[symmetric] id_def[symmetric] gpv.rel_map split!: sum.split intro!: rel_spmf_reflI gpv.rel_refl_strong)"], ["", "lemma parallel_converter_map_converter:\n  \"map_converter f g f' g' conv1 |\\<^sub>\\<propto> map_converter f'' g'' f' g' conv2 = \n   map_converter (map_sum f f'') (map_sum g g'') f' g' (conv1 |\\<^sub>\\<propto> conv2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter f g f' g' conv1 |\\<^sub>\\<propto>\n    map_converter f'' g'' f' g' conv2 =\n    map_converter (map_sum f f'') (map_sum g g'') f' g'\n     (conv1 |\\<^sub>\\<propto> conv2)", "using parallel_callee_parametric[\n      where A=\"conversep (BNF_Def.Grp UNIV f)\" and B=\"BNF_Def.Grp UNIV g\" and C=\"BNF_Def.Grp UNIV f'\" and R=\"conversep (BNF_Def.Grp UNIV g')\" and A'=\"conversep (BNF_Def.Grp UNIV f'')\" and B'=\"BNF_Def.Grp UNIV g''\",\n      unfolded rel_converter_Grp sum.rel_conversep sum.rel_Grp,\n      simplified,\n      unfolded rel_converter_Grp]"], ["proof (prove)\nusing this:\n  rel_fun (BNF_Def.Grp UNIV (map_converter f g f' g'))\n   (rel_fun (BNF_Def.Grp UNIV (map_converter f'' g'' f' g'))\n     (BNF_Def.Grp\n       {conv.\n        results_converter (\\<I>_uniform (range (map_sum f f'')) UNIV)\n         (\\<I>_uniform UNIV (range g')) conv\n        \\<subseteq> UNIV \\<and>\n        outs_converter (\\<I>_uniform (range (map_sum f f'')) UNIV)\n         (\\<I>_uniform UNIV (range g')) conv\n        \\<subseteq> UNIV}\n       (map_converter (map_sum f f'') (map_sum g g'') f' g')))\n   (|\\<^sub>\\<propto>) (|\\<^sub>\\<propto>)\n\ngoal (1 subgoal):\n 1. map_converter f g f' g' conv1 |\\<^sub>\\<propto>\n    map_converter f'' g'' f' g' conv2 =\n    map_converter (map_sum f f'') (map_sum g g'') f' g'\n     (conv1 |\\<^sub>\\<propto> conv2)", "by(simp add: rel_fun_def Grp_def)"], ["", "lemma map_converter_parallel_converter_out2:\n  \"conv1 |\\<^sub>\\<propto> map_converter f g id id conv2 = map_converter (map_sum id f) (map_sum id g) id id (conv1 |\\<^sub>\\<propto> conv2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conv1 |\\<^sub>\\<propto> map_converter f g id id conv2 =\n    map_converter (map_sum id f) (map_sum id g) id id\n     (conv1 |\\<^sub>\\<propto> conv2)", "by(rule parallel_converter_map_converter[where f=id and g=id and f'=id and g'=id, simplified])"], ["", "lemma parallel_converter_assoc2:\n  \"parallel_converter conv1 (parallel_converter conv2 conv3) =                                   \n   map_converter lsumr rsuml id id (parallel_converter (parallel_converter conv1 conv2) conv3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conv1 |\\<^sub>\\<propto> conv2 |\\<^sub>\\<propto> conv3 =\n    map_converter lsumr rsuml id id\n     ((conv1 |\\<^sub>\\<propto> conv2) |\\<^sub>\\<propto> conv3)", "by(coinduction arbitrary: conv1 conv2 conv3)\n    (auto 4 5 intro!: rel_funI gpv.rel_refl_strong split: sum.split simp add: gpv.rel_map map_gpv'_id map_gpv_conv_map_gpv'[symmetric])"], ["", "lemma parallel_converter_of_resource:\n  \"converter_of_resource res1 |\\<^sub>\\<propto> converter_of_resource res2 = converter_of_resource (res1 \\<parallel> res2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. converter_of_resource res1 |\\<^sub>\\<propto>\n    converter_of_resource res2 =\n    converter_of_resource (res1 \\<parallel> res2)", "by(coinduction arbitrary: res1 res2)\n    (auto 4 3 simp add: rel_fun_def map_lift_spmf spmf_rel_map intro!: rel_spmf_reflI split!: sum.split)"], ["", "lemma map_Inr_parallel_converter:\n  \"map_converter Inr f g h (conv1 |\\<^sub>\\<propto> conv2) = map_converter id (f \\<circ> Inr) g h conv2\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter Inr f g h (conv1 |\\<^sub>\\<propto> conv2) =\n    map_converter id (f \\<circ> Inr) g h conv2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_converter Inr f g h (conv1 |\\<^sub>\\<propto> conv2) =\n    map_converter id (f \\<circ> Inr) g h conv2", "have \"?lhs = map_converter Inr f id id (map_converter id id g h conv1 |\\<^sub>\\<propto> map_converter id id g h conv2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter Inr f g h (conv1 |\\<^sub>\\<propto> conv2) =\n    map_converter Inr f id id\n     (map_converter id id g h conv1 |\\<^sub>\\<propto>\n      map_converter id id g h conv2)", "by(simp add: parallel_converter_map_converter sum.map_id0)"], ["proof (state)\nthis:\n  map_converter Inr f g h (conv1 |\\<^sub>\\<propto> conv2) =\n  map_converter Inr f id id\n   (map_converter id id g h conv1 |\\<^sub>\\<propto>\n    map_converter id id g h conv2)\n\ngoal (1 subgoal):\n 1. map_converter Inr f g h (conv1 |\\<^sub>\\<propto> conv2) =\n    map_converter id (f \\<circ> Inr) g h conv2", "also"], ["proof (state)\nthis:\n  map_converter Inr f g h (conv1 |\\<^sub>\\<propto> conv2) =\n  map_converter Inr f id id\n   (map_converter id id g h conv1 |\\<^sub>\\<propto>\n    map_converter id id g h conv2)\n\ngoal (1 subgoal):\n 1. map_converter Inr f g h (conv1 |\\<^sub>\\<propto> conv2) =\n    map_converter id (f \\<circ> Inr) g h conv2", "have \"map_converter Inr f id id (conv1 |\\<^sub>\\<propto> conv2) = map_converter id (f \\<circ> Inr) id id conv2\" for conv1 conv2"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter Inr f id id (conv1 |\\<^sub>\\<propto> conv2) =\n    map_converter id (f \\<circ> Inr) id id conv2", "by(coinduction arbitrary: conv2)\n      (auto simp add: rel_fun_def map_gpv_conv_map_gpv'[symmetric] gpv.rel_map intro!: gpv.rel_refl_strong)"], ["proof (state)\nthis:\n  map_converter Inr f id id (?conv1.1 |\\<^sub>\\<propto> ?conv2.1) =\n  map_converter id (f \\<circ> Inr) id id ?conv2.1\n\ngoal (1 subgoal):\n 1. map_converter Inr f g h (conv1 |\\<^sub>\\<propto> conv2) =\n    map_converter id (f \\<circ> Inr) g h conv2", "also"], ["proof (state)\nthis:\n  map_converter Inr f id id (?conv1.1 |\\<^sub>\\<propto> ?conv2.1) =\n  map_converter id (f \\<circ> Inr) id id ?conv2.1\n\ngoal (1 subgoal):\n 1. map_converter Inr f g h (conv1 |\\<^sub>\\<propto> conv2) =\n    map_converter id (f \\<circ> Inr) g h conv2", "have \"map_converter id (f \\<circ> Inr) id id (map_converter id id g h conv2) = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter id (f \\<circ> Inr) id id (map_converter id id g h conv2) =\n    map_converter id (f \\<circ> Inr) g h conv2", "by simp"], ["proof (state)\nthis:\n  map_converter id (f \\<circ> Inr) id id (map_converter id id g h conv2) =\n  map_converter id (f \\<circ> Inr) g h conv2\n\ngoal (1 subgoal):\n 1. map_converter Inr f g h (conv1 |\\<^sub>\\<propto> conv2) =\n    map_converter id (f \\<circ> Inr) g h conv2", "finally"], ["proof (chain)\npicking this:\n  map_converter Inr f g h (conv1 |\\<^sub>\\<propto> conv2) =\n  map_converter id (f \\<circ> Inr) g h conv2", "show ?thesis"], ["proof (prove)\nusing this:\n  map_converter Inr f g h (conv1 |\\<^sub>\\<propto> conv2) =\n  map_converter id (f \\<circ> Inr) g h conv2\n\ngoal (1 subgoal):\n 1. map_converter Inr f g h (conv1 |\\<^sub>\\<propto> conv2) =\n    map_converter id (f \\<circ> Inr) g h conv2", "."], ["proof (state)\nthis:\n  map_converter Inr f g h (conv1 |\\<^sub>\\<propto> conv2) =\n  map_converter id (f \\<circ> Inr) g h conv2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_Inl_parallel_converter:\n  \"map_converter Inl f g h (conv1 |\\<^sub>\\<propto> conv2) = map_converter id (f \\<circ> Inl) g h conv1\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter Inl f g h (conv1 |\\<^sub>\\<propto> conv2) =\n    map_converter id (f \\<circ> Inl) g h conv1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_converter Inl f g h (conv1 |\\<^sub>\\<propto> conv2) =\n    map_converter id (f \\<circ> Inl) g h conv1", "have \"?lhs = map_converter Inl f id id (map_converter id id g h conv1 |\\<^sub>\\<propto> map_converter id id g h conv2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter Inl f g h (conv1 |\\<^sub>\\<propto> conv2) =\n    map_converter Inl f id id\n     (map_converter id id g h conv1 |\\<^sub>\\<propto>\n      map_converter id id g h conv2)", "by(simp add: parallel_converter_map_converter sum.map_id0)"], ["proof (state)\nthis:\n  map_converter Inl f g h (conv1 |\\<^sub>\\<propto> conv2) =\n  map_converter Inl f id id\n   (map_converter id id g h conv1 |\\<^sub>\\<propto>\n    map_converter id id g h conv2)\n\ngoal (1 subgoal):\n 1. map_converter Inl f g h (conv1 |\\<^sub>\\<propto> conv2) =\n    map_converter id (f \\<circ> Inl) g h conv1", "also"], ["proof (state)\nthis:\n  map_converter Inl f g h (conv1 |\\<^sub>\\<propto> conv2) =\n  map_converter Inl f id id\n   (map_converter id id g h conv1 |\\<^sub>\\<propto>\n    map_converter id id g h conv2)\n\ngoal (1 subgoal):\n 1. map_converter Inl f g h (conv1 |\\<^sub>\\<propto> conv2) =\n    map_converter id (f \\<circ> Inl) g h conv1", "have \"map_converter Inl f id id (conv1 |\\<^sub>\\<propto> conv2) = map_converter id (f \\<circ> Inl) id id conv1\" for conv1 conv2"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter Inl f id id (conv1 |\\<^sub>\\<propto> conv2) =\n    map_converter id (f \\<circ> Inl) id id conv1", "by(coinduction arbitrary: conv1)\n      (auto simp add: rel_fun_def map_gpv_conv_map_gpv'[symmetric] gpv.rel_map intro!: gpv.rel_refl_strong)"], ["proof (state)\nthis:\n  map_converter Inl f id id (?conv1.1 |\\<^sub>\\<propto> ?conv2.1) =\n  map_converter id (f \\<circ> Inl) id id ?conv1.1\n\ngoal (1 subgoal):\n 1. map_converter Inl f g h (conv1 |\\<^sub>\\<propto> conv2) =\n    map_converter id (f \\<circ> Inl) g h conv1", "also"], ["proof (state)\nthis:\n  map_converter Inl f id id (?conv1.1 |\\<^sub>\\<propto> ?conv2.1) =\n  map_converter id (f \\<circ> Inl) id id ?conv1.1\n\ngoal (1 subgoal):\n 1. map_converter Inl f g h (conv1 |\\<^sub>\\<propto> conv2) =\n    map_converter id (f \\<circ> Inl) g h conv1", "have \"map_converter id (f \\<circ> Inl) id id (map_converter id id g h conv1) = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter id (f \\<circ> Inl) id id (map_converter id id g h conv1) =\n    map_converter id (f \\<circ> Inl) g h conv1", "by simp"], ["proof (state)\nthis:\n  map_converter id (f \\<circ> Inl) id id (map_converter id id g h conv1) =\n  map_converter id (f \\<circ> Inl) g h conv1\n\ngoal (1 subgoal):\n 1. map_converter Inl f g h (conv1 |\\<^sub>\\<propto> conv2) =\n    map_converter id (f \\<circ> Inl) g h conv1", "finally"], ["proof (chain)\npicking this:\n  map_converter Inl f g h (conv1 |\\<^sub>\\<propto> conv2) =\n  map_converter id (f \\<circ> Inl) g h conv1", "show ?thesis"], ["proof (prove)\nusing this:\n  map_converter Inl f g h (conv1 |\\<^sub>\\<propto> conv2) =\n  map_converter id (f \\<circ> Inl) g h conv1\n\ngoal (1 subgoal):\n 1. map_converter Inl f g h (conv1 |\\<^sub>\\<propto> conv2) =\n    map_converter id (f \\<circ> Inl) g h conv1", "."], ["proof (state)\nthis:\n  map_converter Inl f g h (conv1 |\\<^sub>\\<propto> conv2) =\n  map_converter id (f \\<circ> Inl) g h conv1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma left_interface_parallel_converter:\n  \"left_interface (conv1 |\\<^sub>\\<propto> conv2) = left_interface conv1 |\\<^sub>\\<propto> left_interface conv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_interface (conv1 |\\<^sub>\\<propto> conv2) =\n    left_interface conv1 |\\<^sub>\\<propto> left_interface conv2", "by(coinduction arbitrary: conv1 conv2)\n    (auto 4 3 split!: sum.split simp add: rel_fun_def gpv.rel_map left_gpv_map[where h=id] sum.map_id0 intro!: gpv.rel_refl_strong)"], ["", "lemma right_interface_parallel_converter:\n  \"right_interface (conv1 |\\<^sub>\\<propto> conv2) = right_interface conv1 |\\<^sub>\\<propto> right_interface conv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_interface (conv1 |\\<^sub>\\<propto> conv2) =\n    right_interface conv1 |\\<^sub>\\<propto> right_interface conv2", "by(coinduction arbitrary: conv1 conv2)\n    (auto 4 3 split!: sum.split simp add: rel_fun_def gpv.rel_map right_gpv_map[where h=id] sum.map_id0 intro!: gpv.rel_refl_strong)"], ["", "lemma left_interface_converter_of_resource [simp]: \n  \"left_interface (converter_of_resource res) = converter_of_resource res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_interface (converter_of_resource res) = converter_of_resource res", "by(coinduction arbitrary: res)(auto simp add: rel_fun_def map_lift_spmf spmf_rel_map intro!: rel_spmf_reflI)"], ["", "lemma right_interface_converter_of_resource [simp]: \n  \"right_interface (converter_of_resource res) = converter_of_resource res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_interface (converter_of_resource res) = converter_of_resource res", "by(coinduction arbitrary: res)(auto simp add: rel_fun_def map_lift_spmf spmf_rel_map intro!: rel_spmf_reflI)"], ["", "lemma parallel_converter_swap: \"map_converter swap_sum swap_sum id id (conv1 |\\<^sub>\\<propto> conv2) = conv2 |\\<^sub>\\<propto> conv1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_converter swap_sum swap_sum id id (conv1 |\\<^sub>\\<propto> conv2) =\n    conv2 |\\<^sub>\\<propto> conv1", "by(coinduction arbitrary: conv1 conv2)\n    (auto 4 3 split!: sum.split simp add: rel_fun_def map_gpv_conv_map_gpv'[symmetric] gpv.rel_map intro!: gpv.rel_refl_strong)"], ["", "lemma eq_\\<I>_converter_map_converter':\n  assumes \"\\<I>'', map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv1 \\<sim> conv2\"\n    and \"f ` outs_\\<I> \\<I> \\<subseteq> outs_\\<I> \\<I>''\"\n    and \"\\<forall>q\\<in>outs_\\<I> \\<I>. g ` responses_\\<I> \\<I>'' (f q) \\<subseteq> responses_\\<I> \\<I> q\"\n  shows \"\\<I>, \\<I>' \\<turnstile>\\<^sub>C map_converter f g f' g' conv1 \\<sim> map_converter f g f' g' conv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>,\\<I>' \\<turnstile>\\<^sub>C map_converter f g f' g' conv1 \\<sim>\n    map_converter f g f' g' conv2", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<I>'',map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv1 \\<sim> conv2\n\ngoal (1 subgoal):\n 1. \\<I>,\\<I>' \\<turnstile>\\<^sub>C map_converter f g f' g' conv1 \\<sim>\n    map_converter f g f' g' conv2", "proof(coinduction arbitrary: conv1 conv2)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q conv1 conv2.\n       \\<lbrakk>\\<I>'',map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\n                conv1 \\<sim> conv2;\n        q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> eq_\\<I>_gpv\n                          (rel_prod\n                            (eq_onp\n                              (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q))\n                            (\\<lambda>conv conv'.\n                                (\\<exists>conv1 conv2.\n                                    conv =\n                                    map_converter f g f' g' conv1 \\<and>\n                                    conv' =\n                                    map_converter f g f' g' conv2 \\<and>\n                                    \\<I>'',map_\\<I> f' g'\n      \\<I>' \\<turnstile>\\<^sub>C\n                                    conv1 \\<sim> conv2) \\<or>\n                                \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim>\n                                conv'))\n                          \\<I>'\n                          (run_converter (map_converter f g f' g' conv1) q)\n                          (run_converter (map_converter f g f' g' conv2) q)", "case eq_\\<I>_converter"], ["proof (state)\nthis:\n  \\<I>'',map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv1 \\<sim> conv2\n  q \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. \\<And>q conv1 conv2.\n       \\<lbrakk>\\<I>'',map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\n                conv1 \\<sim> conv2;\n        q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> eq_\\<I>_gpv\n                          (rel_prod\n                            (eq_onp\n                              (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q))\n                            (\\<lambda>conv conv'.\n                                (\\<exists>conv1 conv2.\n                                    conv =\n                                    map_converter f g f' g' conv1 \\<and>\n                                    conv' =\n                                    map_converter f g f' g' conv2 \\<and>\n                                    \\<I>'',map_\\<I> f' g'\n      \\<I>' \\<turnstile>\\<^sub>C\n                                    conv1 \\<sim> conv2) \\<or>\n                                \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim>\n                                conv'))\n                          \\<I>'\n                          (run_converter (map_converter f g f' g' conv1) q)\n                          (run_converter (map_converter f g f' g' conv2) q)", "from this(2)"], ["proof (chain)\npicking this:\n  q \\<in> outs_\\<I> \\<I>", "have \"f q \\<in> outs_\\<I> \\<I>''\""], ["proof (prove)\nusing this:\n  q \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. f q \\<in> outs_\\<I> \\<I>''", "using assms(2)"], ["proof (prove)\nusing this:\n  q \\<in> outs_\\<I> \\<I>\n  f ` outs_\\<I> \\<I> \\<subseteq> outs_\\<I> \\<I>''\n\ngoal (1 subgoal):\n 1. f q \\<in> outs_\\<I> \\<I>''", "by auto"], ["proof (state)\nthis:\n  f q \\<in> outs_\\<I> \\<I>''\n\ngoal (1 subgoal):\n 1. \\<And>q conv1 conv2.\n       \\<lbrakk>\\<I>'',map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C\n                conv1 \\<sim> conv2;\n        q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n       \\<Longrightarrow> eq_\\<I>_gpv\n                          (rel_prod\n                            (eq_onp\n                              (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q))\n                            (\\<lambda>conv conv'.\n                                (\\<exists>conv1 conv2.\n                                    conv =\n                                    map_converter f g f' g' conv1 \\<and>\n                                    conv' =\n                                    map_converter f g f' g' conv2 \\<and>\n                                    \\<I>'',map_\\<I> f' g'\n      \\<I>' \\<turnstile>\\<^sub>C\n                                    conv1 \\<sim> conv2) \\<or>\n                                \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim>\n                                conv'))\n                          \\<I>'\n                          (run_converter (map_converter f g f' g' conv1) q)\n                          (run_converter (map_converter f g f' g' conv2) q)", "from eq_\\<I>_converter(1)[THEN eq_\\<I>_converterD, OF this] eq_\\<I>_converter(2)"], ["proof (chain)\npicking this:\n  eq_\\<I>_gpv\n   (rel_prod (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> \\<I>'' (f q)))\n     (eq_\\<I>_converter \\<I>'' (map_\\<I> f' g' \\<I>')))\n   (map_\\<I> f' g' \\<I>') (run_converter conv1 (f q))\n   (run_converter conv2 (f q))\n  q \\<in> outs_\\<I> \\<I>", "show ?case"], ["proof (prove)\nusing this:\n  eq_\\<I>_gpv\n   (rel_prod (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> \\<I>'' (f q)))\n     (eq_\\<I>_converter \\<I>'' (map_\\<I> f' g' \\<I>')))\n   (map_\\<I> f' g' \\<I>') (run_converter conv1 (f q))\n   (run_converter conv2 (f q))\n  q \\<in> outs_\\<I> \\<I>\n\ngoal (1 subgoal):\n 1. eq_\\<I>_gpv\n     (rel_prod (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q))\n       (\\<lambda>conv conv'.\n           (\\<exists>conv1 conv2.\n               conv = map_converter f g f' g' conv1 \\<and>\n               conv' = map_converter f g f' g' conv2 \\<and>\n               \\<I>'',map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv1 \\<sim>\n               conv2) \\<or>\n           \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv'))\n     \\<I>' (run_converter (map_converter f g f' g' conv1) q)\n     (run_converter (map_converter f g f' g' conv2) q)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eq_\\<I>_gpv\n              (rel_prod\n                (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> \\<I>'' (f q)))\n                (eq_\\<I>_converter \\<I>'' (map_\\<I> f' g' \\<I>')))\n              (map_\\<I> f' g' \\<I>') (run_converter conv1 (f q))\n              (run_converter conv2 (f q));\n     q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (eq_onp\n                           (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q))\n                         (\\<lambda>conv conv'.\n                             (\\<exists>conv1.\n                                 conv = map_converter f g f' g' conv1 \\<and>\n                                 (\\<exists>conv2.\n                                     conv' =\n                                     map_converter f g f' g' conv2 \\<and>\n                                     \\<I>'',map_\\<I> f' g'\n       \\<I>' \\<turnstile>\\<^sub>C\n                                     conv1 \\<sim> conv2)) \\<or>\n                             \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim>\n                             conv'))\n                       \\<I>'\n                       (map_gpv' (map_prod g (map_converter f g f' g')) f'\n                         g' (run_converter conv1 (f q)))\n                       (map_gpv' (map_prod g (map_converter f g f' g')) f'\n                         g' (run_converter conv2 (f q)))", "apply(rule eq_\\<I>_gpv_map_gpv')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eq_\\<I>_gpv\n              (rel_prod\n                (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> \\<I>'' (f q)))\n                (eq_\\<I>_converter \\<I>'' (map_\\<I> f' g' \\<I>')))\n              (map_\\<I> f' g' \\<I>') (run_converter conv1 (f q))\n              (run_converter conv2 (f q));\n     q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (BNF_Def.vimage2p\n                         (map_prod g (map_converter f g f' g'))\n                         (map_prod g (map_converter f g f' g'))\n                         (rel_prod\n                           (eq_onp\n                             (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q))\n                           (\\<lambda>conv conv'.\n                               (\\<exists>conv1.\n                                   conv =\n                                   map_converter f g f' g' conv1 \\<and>\n                                   (\\<exists>conv2.\n conv' = map_converter f g f' g' conv2 \\<and>\n \\<I>'',map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv1 \\<sim> conv2)) \\<or>\n                               \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim>\n                               conv')))\n                       (map_\\<I> f' g' \\<I>') (run_converter conv1 (f q))\n                       (run_converter conv2 (f q))", "apply(simp add: BNF_Def.vimage2p_def prod.rel_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eq_\\<I>_gpv\n              (rel_prod\n                (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> \\<I>'' (f q)))\n                (eq_\\<I>_converter \\<I>'' (map_\\<I> f' g' \\<I>')))\n              (map_\\<I> f' g' \\<I>') (run_converter conv1 (f q))\n              (run_converter conv2 (f q));\n     q \\<in> outs_\\<I> \\<I>\\<rbrakk>\n    \\<Longrightarrow> eq_\\<I>_gpv\n                       (rel_prod\n                         (\\<lambda>x y.\n                             eq_onp\n                              (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q)\n                              (g x) (g y))\n                         (\\<lambda>x y.\n                             (\\<exists>conv1.\n                                 map_converter f g f' g' x =\n                                 map_converter f g f' g' conv1 \\<and>\n                                 (\\<exists>conv2.\n                                     map_converter f g f' g' y =\n                                     map_converter f g f' g' conv2 \\<and>\n                                     \\<I>'',map_\\<I> f' g'\n       \\<I>' \\<turnstile>\\<^sub>C\n                                     conv1 \\<sim> conv2)) \\<or>\n                             \\<I>,\\<I>' \\<turnstile>\\<^sub>C\n                             map_converter f g f' g' x \\<sim>\n                             map_converter f g f' g' y))\n                       (map_\\<I> f' g' \\<I>') (run_converter conv1 (f q))\n                       (run_converter conv2 (f q))", "apply(erule eq_\\<I>_gpv_mono')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>q \\<in> outs_\\<I> \\<I>;\n        rel_prod (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> \\<I>'' (f q)))\n         (eq_\\<I>_converter \\<I>'' (map_\\<I> f' g' \\<I>')) x y\\<rbrakk>\n       \\<Longrightarrow> rel_prod\n                          (\\<lambda>x y.\n                              eq_onp\n                               (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q)\n                               (g x) (g y))\n                          (\\<lambda>x y.\n                              (\\<exists>conv1.\n                                  map_converter f g f' g' x =\n                                  map_converter f g f' g' conv1 \\<and>\n                                  (\\<exists>conv2.\nmap_converter f g f' g' y = map_converter f g f' g' conv2 \\<and>\n\\<I>'',map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv1 \\<sim> conv2)) \\<or>\n                              \\<I>,\\<I>' \\<turnstile>\\<^sub>C\n                              map_converter f g f' g' x \\<sim>\n                              map_converter f g f' g' y)\n                          x y\n 2. q \\<in> outs_\\<I> \\<I> \\<Longrightarrow>\n    map_\\<I> f' g' \\<I>' \\<le> map_\\<I> f' g' \\<I>'", "using assms(3)"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>outs_\\<I> \\<I>.\n     g ` responses_\\<I> \\<I>'' (f q) \\<subseteq> responses_\\<I> \\<I> q\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>q \\<in> outs_\\<I> \\<I>;\n        rel_prod (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> \\<I>'' (f q)))\n         (eq_\\<I>_converter \\<I>'' (map_\\<I> f' g' \\<I>')) x y\\<rbrakk>\n       \\<Longrightarrow> rel_prod\n                          (\\<lambda>x y.\n                              eq_onp\n                               (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q)\n                               (g x) (g y))\n                          (\\<lambda>x y.\n                              (\\<exists>conv1.\n                                  map_converter f g f' g' x =\n                                  map_converter f g f' g' conv1 \\<and>\n                                  (\\<exists>conv2.\nmap_converter f g f' g' y = map_converter f g f' g' conv2 \\<and>\n\\<I>'',map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv1 \\<sim> conv2)) \\<or>\n                              \\<I>,\\<I>' \\<turnstile>\\<^sub>C\n                              map_converter f g f' g' x \\<sim>\n                              map_converter f g f' g' y)\n                          x y\n 2. q \\<in> outs_\\<I> \\<I> \\<Longrightarrow>\n    map_\\<I> f' g' \\<I>' \\<le> map_\\<I> f' g' \\<I>'", "apply(auto 4 4 simp add: eq_onp_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eq_\\<I>_gpv\n   (rel_prod (eq_onp (\\<lambda>r. r \\<in> responses_\\<I> \\<I> q))\n     (\\<lambda>conv conv'.\n         (\\<exists>conv1 conv2.\n             conv = map_converter f g f' g' conv1 \\<and>\n             conv' = map_converter f g f' g' conv2 \\<and>\n             \\<I>'',map_\\<I> f' g' \\<I>' \\<turnstile>\\<^sub>C conv1 \\<sim>\n             conv2) \\<or>\n         \\<I>,\\<I>' \\<turnstile>\\<^sub>C conv \\<sim> conv'))\n   \\<I>' (run_converter (map_converter f g f' g' conv1) q)\n   (run_converter (map_converter f g f' g' conv2) q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma parallel_converter_eq_\\<I>_cong:\n  \"\\<lbrakk> \\<I>1, \\<I> \\<turnstile>\\<^sub>C conv1 \\<sim> conv1'; \\<I>2, \\<I> \\<turnstile>\\<^sub>C conv2 \\<sim> conv2' \\<rbrakk>\n  \\<Longrightarrow> \\<I>1 \\<oplus>\\<^sub>\\<I> \\<I>2, \\<I> \\<turnstile>\\<^sub>C parallel_converter conv1 conv2 \\<sim> parallel_converter conv1' conv2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<I>1,\\<I> \\<turnstile>\\<^sub>C conv1 \\<sim> conv1';\n     \\<I>2,\\<I> \\<turnstile>\\<^sub>C conv2 \\<sim> conv2'\\<rbrakk>\n    \\<Longrightarrow> \\<I>1 \\<oplus>\\<^sub>\\<I>\n                      \\<I>2,\\<I> \\<turnstile>\\<^sub>C\n                      conv1 |\\<^sub>\\<propto> conv2 \\<sim>\n                      conv1' |\\<^sub>\\<propto> conv2'", "by(coinduction arbitrary: conv1 conv2 conv1' conv2')\n    (fastforce dest: eq_\\<I>_converterD elim!: eq_\\<I>_gpv_mono' simp add: eq_onp_def)\n\n\\<comment> \\<open>Helper lemmas for simplyfing @{term exec_gpv}\\<close>"], ["", "lemma\n  exec_gpv_parallel_oracle_right: \n    \"exec_gpv (oracle1 \\<ddagger>\\<^sub>O oracle2) (right_gpv gpv) s = exec_gpv (\\<dagger>oracle2) gpv s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_gpv (oracle1 \\<ddagger>\\<^sub>O oracle2) (right_gpv gpv) s =\n    exec_gpv \\<dagger>oracle2 gpv s", "unfolding spmf_rel_eq[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (=)\n     (exec_gpv (oracle1 \\<ddagger>\\<^sub>O oracle2) (right_gpv gpv) s)\n     (exec_gpv \\<dagger>oracle2 gpv s)", "apply (rule rel_spmf_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rel_spmf ?A\n     (exec_gpv (oracle1 \\<ddagger>\\<^sub>O oracle2) (right_gpv gpv) s)\n     (exec_gpv \\<dagger>oracle2 gpv s)\n 2. \\<And>x y. ?A x y \\<Longrightarrow> x = y", "by (rule exec_gpv_parametric'[where S=\"(=)\" and A=\"(=)\" and CALL=\"\\<lambda>l r. l = Inr r\" and R=\"\\<lambda>l r. l = Inr r\" , THEN rel_funD, THEN rel_funD, THEN rel_funD ])\n    (auto simp add: prod.rel_eq extend_state_oracle_def parallel_oracle_def split_def\n      spmf_rel_map1 spmf_rel_map2 map_prod_def rel_spmf_reflI right_gpv_Inr_transfer intro!:rel_funI)"], ["", "lemma\n  exec_gpv_parallel_oracle_left: \n    \"exec_gpv (oracle1 \\<ddagger>\\<^sub>O oracle2) (left_gpv gpv) s = exec_gpv (oracle1\\<dagger>) gpv s\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_gpv (oracle1 \\<ddagger>\\<^sub>O oracle2) (left_gpv gpv) s =\n    exec_gpv oracle1\\<dagger> gpv s", "unfolding spmf_rel_eq[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf (=)\n     (exec_gpv (oracle1 \\<ddagger>\\<^sub>O oracle2) (left_gpv gpv) s)\n     (exec_gpv oracle1\\<dagger> gpv s)", "apply (rule rel_spmf_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rel_spmf ?A\n     (exec_gpv (oracle1 \\<ddagger>\\<^sub>O oracle2) (left_gpv gpv) s)\n     (exec_gpv oracle1\\<dagger> gpv s)\n 2. \\<And>x y. ?A x y \\<Longrightarrow> x = y", "by (rule exec_gpv_parametric'[where S=\"(=)\" and A=\"(=)\" and CALL=\"\\<lambda>l r. l = Inl r\" and R=\"\\<lambda>l r. l = Inl r\" , THEN rel_funD, THEN rel_funD, THEN rel_funD ])\n     (auto simp add: prod.rel_eq extend_state_oracle2_def parallel_oracle_def split_def\n       spmf_rel_map1 spmf_rel_map2 map_prod_def rel_spmf_reflI left_gpv_Inl_transfer intro!:rel_funI)"], ["", "end"]]}