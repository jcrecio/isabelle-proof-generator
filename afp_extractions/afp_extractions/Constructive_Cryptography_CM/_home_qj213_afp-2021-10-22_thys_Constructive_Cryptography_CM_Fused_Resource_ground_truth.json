{"file_name": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography_CM/Fused_Resource.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Constructive_Cryptography_CM", "problem_names": ["lemma outs_\\<I>_e\\<I>[simp]: \"outs_\\<I> (e\\<I> \\<I>) = outs_\\<I> \\<I>\"", "lemma responses_\\<I>_e\\<I> [simp]: \"responses_\\<I> (e\\<I> \\<I>) x = responses_\\<I> \\<I> x \\<times> UNIV\"", "lemma e\\<I>_map_\\<I>: \"e\\<I> (map_\\<I> f g \\<I>) = map_\\<I> f (apfst g) (e\\<I> \\<I>)\"", "lemma e\\<I>_inverse [simp]: \"map_\\<I> id fst (e\\<I> \\<I>) = \\<I>\"", "lemma parallel_handler_left:\n  \"map_fun id (map_fun Inl id) (parallel_handler left right) = \n    (\\<lambda>(s_l, s_r) q. map_spmf (\\<lambda>s_l'. (s_l', s_r)) (left s_l q))\"", "lemma parallel_handler_right:\n  \"map_fun id (map_fun Inr id) (parallel_handler left right) = \n    (\\<lambda>(s_l, s_r) q. map_spmf (\\<lambda>s_r'. (s_l, s_r')) (right s_r q))\"", "lemma in_set_spmf_parallel_handler:\n  \"s' \\<in> set_spmf (parallel_handler left right s x) \\<longleftrightarrow>\n  (case x of Inl e \\<Rightarrow> fst s' \\<in> set_spmf (left (fst s) e) \\<and> snd s' = snd s\n    | Inr e \\<Rightarrow> snd s' \\<in> set_spmf (right (snd s) e) \\<and> fst s' = fst s)\"", "lemma \n  rel_core'_eq [relator_eq]:\n    \"rel_core' (=) (=) (=) (=) (=) (=) = (=)\"", "lemma \n  rel_core'_mono [relator_mono]:\n    \"rel_core' S E IA IU OA OU \\<le> rel_core' S E' IA' IU' OA' OU'\"\n  if \"E' \\<le> E\" \"IA' \\<le> IA\" \"IU' \\<le> IU\" \"OA \\<le> OA'\" \"OU \\<le> OU'\"", "lemma \n  cpoke_parametric [transfer_rule]:\n    \"(rel_core' S E IA IU OA OU ===> S ===> E ===> rel_spmf S) cpoke cpoke\"", "lemma \n  cfunc_adv_parametric [transfer_rule]:\n    \"(rel_core' S E IA IU OA OU ===> S ===> IA ===> rel_spmf (rel_prod OA S)) cfunc_adv cfunc_adv\"", "lemma \n  cfunc_usr_parametric [transfer_rule]:\n    \"(rel_core' S E IA IU OA OU ===> S ===> IU ===> rel_spmf (rel_prod OU S)) cfunc_usr cfunc_usr\"", "lemma \n  Core_parametric [transfer_rule]:\n    \"((S ===> E ===> rel_spmf S) ===> (S ===> IA ===> rel_spmf (rel_prod OA S)) ===> (S ===> IU ===> rel_spmf (rel_prod OU S))\n   ===> rel_core' S E IA IU OA OU) Core Core\"", "lemma \n  case_core_parametric [transfer_rule]:\n    \"(((S ===> E ===> rel_spmf S) ===> \n        (S ===> IA ===> rel_spmf (rel_prod OA S)) ===> \n        (S ===> IU ===> rel_spmf (rel_prod OU S)) ===> X) ===> \n      rel_core' S E IA IU OA OU ===> X) case_core case_core\"", "lemma \n  corec_core_parametric [transfer_rule]:\n    \"((X ===> S ===> E ===> rel_spmf S) ===> \n      (X ===> S ===> IA ===> rel_spmf (rel_prod OA S)) ===> \n      (X ===> S ===> IU ===> rel_spmf (rel_prod OU S)) ===> \n      X ===> rel_core' S E IA IU OA OU) corec_core corec_core\"", "lemmas map_core'_simps [simp] = map_core'.ctr[where core=\"Core _ _ _\", simplified]", "lemma core'_rel_Grp:\n  \"rel_core' (=) (BNF_Def.Grp UNIV e)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV ia)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV iu)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV oa) (BNF_Def.Grp UNIV ou)\n   = BNF_Def.Grp UNIV (map_core' e ia iu oa ou)\"", "lemma WT_coreD:\n  assumes \"WT_core \\<I>_adv \\<I>_usr I core\"\n  shows WT_coreD_cpoke: \"\\<And>s e s'. \\<lbrakk> s' \\<in> set_spmf (cpoke core s e); I s \\<rbrakk> \\<Longrightarrow> I s'\"\n    and WT_coreD_cfunc_adv: \"\\<And>s x y s'. \\<lbrakk> (y, s') \\<in> set_spmf (cfunc_adv core s x); x \\<in> outs_\\<I> \\<I>_adv; I s \\<rbrakk> \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_adv x \\<and> I s'\"\n    and WT_coreD_cfund_usr: \"\\<And>s x y s'. \\<lbrakk> (y, s') \\<in> set_spmf (cfunc_usr core s x); x \\<in> outs_\\<I> \\<I>_usr; I s \\<rbrakk> \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_usr x \\<and> I s'\"", "lemma WT_coreD_foldl_spmf_cpoke:\n  assumes \"WT_core \\<I>_adv \\<I>_usr I core\"\n    and \"s' \\<in> set_spmf (foldl_spmf (cpoke core) p es)\"\n    and \"\\<forall>s \\<in> set_spmf p. I s\"\n  shows \"I s'\"", "lemma WT_core_trivial:\n  assumes adv: \"\\<And>s. \\<I>_adv \\<turnstile>c cfunc_adv core s \\<surd>\"\n    and usr: \"\\<And>s. \\<I>_usr \\<turnstile>c cfunc_usr core s \\<surd>\"\n  shows \"WT_core \\<I>_adv \\<I>_usr (\\<lambda>_. True) core\"", "lemma \n  rel_rest'_eq [relator_eq]:\n    \"rel_rest' (=) (=) (=) (=) (=) (=) (=) = (=)\"", "lemma \n  rel_rest'_mono [relator_mono]:\n    \"rel_rest' S E IA IU OA OU M \\<le> rel_rest' S E' IA' IU' OA' OU' M'\"\n  if \"E \\<le> E'\" \"IA' \\<le> IA\" \"IU' \\<le> IU\" \"OA \\<le> OA'\" \"OU \\<le> OU'\" \"M \\<le> M'\"", "lemma rel_rest'_sel: \"rel_rest' S E IA IU OA OU M rest1 rest2\"\n  if \"M (rinit rest1) (rinit rest2)\"\n  and \"(S ===> IA ===> rel_spmf (rel_prod (rel_prod OA (list_all2 E)) S)) (rfunc_adv rest1) (rfunc_adv rest2)\" \n  and \"(S ===> IU ===> rel_spmf (rel_prod (rel_prod OU (list_all2 E)) S)) (rfunc_usr rest1) (rfunc_usr rest2)\"", "lemma rinit_parametric [transfer_rule]: \"(rel_rest' S E IA IU OA OU M ===> M) rinit rinit\"", "lemma rfunc_adv_parametric [transfer_rule]:\n  \"(rel_rest' S E IA IU OA OU M ===> S ===> IA ===> rel_spmf (rel_prod (rel_prod OA (list_all2 E)) S)) rfunc_adv rfunc_adv\"", "lemma rfunc_usr_parametric [transfer_rule]:\n  \"(rel_rest' S E IA IU OA OU M ===> S ===> IU ===> rel_spmf (rel_prod (rel_prod OU (list_all2 E)) S)) rfunc_usr rfunc_usr\"", "lemma Rest_parametric [transfer_rule]:\n  \"(M ===> (S ===> IA ===> rel_spmf (rel_prod (rel_prod OA (list_all2 E)) S))\n    ===> (S ===> IU ===> rel_spmf (rel_prod (rel_prod OU (list_all2 E)) S))\n   ===> rel_rest' S E IA IU OA OU M) Rest Rest\"", "lemma case_rest_scheme_parametric [transfer_rule]:\n  \"((M ===> \n    (S ===> IA ===> rel_spmf (rel_prod (rel_prod OA (list_all2 E)) S)) ===> \n    (S ===> IU ===> rel_spmf (rel_prod (rel_prod OU (list_all2 E)) S)) ===> X) ===> \n  rel_rest' S E IA IU OA OU M ===> X) case_rest_scheme case_rest_scheme\"", "lemma corec_rest_scheme_parametric [transfer_rule]:\n    \"((X ===> M) ===> \n      (X ===> S ===> IA ===> rel_spmf (rel_prod (rel_prod OA (list_all2 E)) S)) ===> \n      (X ===> S ===> IU ===> rel_spmf (rel_prod (rel_prod OU (list_all2 E)) S)) ===> \n      X ===> rel_rest' S E IA IU OA OU M) corec_rest_scheme corec_rest_scheme\"", "lemmas map_rest'_simps [simp] = map_rest'.ctr[where rest=\"Rest _ _ _\", simplified]", "lemma rest'_rel_Grp:\n  \"rel_rest' (=) (BNF_Def.Grp UNIV e) (BNF_Def.Grp UNIV ia)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV iu)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV oa) (BNF_Def.Grp UNIV ou) (BNF_Def.Grp UNIV m)\n   = BNF_Def.Grp UNIV (map_rest' e ia iu oa ou m)\"", "lemma WT_restD:\n  assumes \"WT_rest \\<I>_adv \\<I>_usr I rest\"\n  shows WT_restD_rfunc_adv: \"\\<And>s x y es s'. \\<lbrakk> ((y, es), s') \\<in> set_spmf (rfunc_adv rest s x); x \\<in> outs_\\<I> \\<I>_adv; I s \\<rbrakk> \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_adv x \\<and> I s'\"\n    and WT_restD_rfunc_usr: \"\\<And>s x y es s'. \\<lbrakk> ((y, es), s') \\<in> set_spmf (rfunc_usr rest s x); x \\<in> outs_\\<I> \\<I>_usr; I s \\<rbrakk> \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_usr x \\<and> I s'\"\n    and WT_restD_rinit: \"I (rinit rest)\"", "lemma callee_invariant_on_fuse:\n  assumes \"WT_core \\<I>_adv_core \\<I>_usr_core I_core core\" \n    and \"WT_rest \\<I>_adv_rest \\<I>_usr_rest I_rest rest\"\n  shows \"callee_invariant_on (fuse rest) (pred_prod I_core I_rest) ((\\<I>_adv_core \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I> (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest))\"", "lemma WT_resource [WT_intro]:\n  assumes \"WT_core \\<I>_adv_core \\<I>_usr_core I_core core\"\n    and \"WT_rest \\<I>_adv_rest \\<I>_usr_rest I_rest rest\"\n    and \"I_core core_init\"\n  shows \"(\\<I>_adv_core \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I> (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest) \\<turnstile>res resource rest \\<surd>\"", "lemma \n  attach_core_id_oracle_adv: \"cfunc_adv (attach_core 1\\<^sub>I cnv core) = \n    (\\<lambda>(s_cnv, s_core) q. map_spmf (\\<lambda>(out, s_core'). (out, s_cnv, s_core')) (cfunc_adv core s_core q))\"", "lemma \n  attach_core_id_oracle_usr: \"cfunc_usr (attach_core cnv 1\\<^sub>I core) = \n    (\\<lambda>(s_cnv, s_core) q. map_spmf (\\<lambda>(out, s_core'). (out, s_cnv, s_core')) (cfunc_usr core s_core q))\"", "lemma WT_parallel_rest [WT_intro]:\n  \"WT_rest (\\<I>_adv1 \\<oplus>\\<^sub>\\<I> \\<I>_adv2) (\\<I>_usr1 \\<oplus>\\<^sub>\\<I> \\<I>_usr2) (pred_prod I1 I2) (parallel_rest rest1 rest2)\"\n  if \"WT_rest \\<I>_adv1 \\<I>_usr1 I1 rest1\"\n  and \"WT_rest \\<I>_adv2 \\<I>_usr2 I2 rest2\"", "lemma \n  attach_rest_id_oracle_adv: \"rfunc_adv (attach_rest 1\\<^sub>I cnv f_init rest) = \n    (\\<lambda>(s_cnv, s_core) q. map_spmf (\\<lambda>(out, s_core'). (out, s_cnv, s_core')) (rfunc_adv rest s_core q))\"", "lemma\n  attach_rest_id_oracle_usr: \"rfunc_usr (attach_rest cnv 1\\<^sub>I f_init rest) = \n    (\\<lambda>(s_cnv, s_core) q. map_spmf (\\<lambda>(out, s_core'). (out, s_cnv, s_core')) (rfunc_usr rest s_core q))\"", "lemma trace_core'_parametric [transfer_rule]:\n  \"(rel_core' S E IA IU (=) (=) ===>\n      rel_spmf S ===>\n      list_all2 (rel_sum E (rel_sum (rel_prod IA (=)) (rel_prod IU (=)))) ===>\n      rel_prod (E ===> (=)) (rel_prod (IA ===> (=)) (IU ===> (=))))\n      trace_core' trace_core'\"", "lemma trace_core_eqD:\n  assumes \"trace_core_eq core1 core2 E IA IU p q\"\n    and \"set tr \\<subseteq> E <+> (IA \\<times> UNIV) <+> (IU \\<times> UNIV)\"\n  shows trace_core_eqD_cpoke: \n      \"e \\<in> E \\<Longrightarrow> fst (trace_core' core1 p tr) e = fst (trace_core' core2 q tr) e\"\n    and trace_core_eqD_cfunc_adv: \n      \"ia \\<in> IA \\<Longrightarrow> fst (snd (trace_core' core1 p tr)) ia = fst (snd (trace_core' core2 q tr)) ia\"\n    and trace_core_eqD_cfunc_usr:\n      \"iu \\<in> IU \\<Longrightarrow> snd (snd (trace_core' core1 p tr)) iu = snd (snd (trace_core' core2 q tr)) iu\"", "lemma trace_core_eqI:\n  assumes \"\\<And>tr e. \\<lbrakk> set tr \\<subseteq> E <+> (IA \\<times> UNIV) <+> (IU \\<times> UNIV); e \\<in> E \\<rbrakk> \n     \\<Longrightarrow> fst (trace_core' core1 p tr) e = fst (trace_core' core2 q tr) e\"\n    and \"\\<And>tr ia. \\<lbrakk> set tr \\<subseteq> E <+> (IA \\<times> UNIV) <+> (IU \\<times> UNIV); ia \\<in> IA \\<rbrakk>\n     \\<Longrightarrow> fst (snd (trace_core' core1 p tr)) ia = fst (snd (trace_core' core2 q tr)) ia\"\n    and \"\\<And>tr iu. \\<lbrakk> set tr \\<subseteq> E <+> (IA \\<times> UNIV) <+> (IU \\<times> UNIV); iu \\<in> IU \\<rbrakk>\n     \\<Longrightarrow> snd (snd (trace_core' core1 p tr)) iu = snd (snd (trace_core' core2 q tr)) iu\"\n  shows \"trace_core_eq core1 core2 E IA IU p q\"", "lemma trace_core_return_pmf_None [simp]:\n  \"trace_core' core (return_pmf None) tr = (\\<lambda>_. 0, \\<lambda>_. return_pmf None, \\<lambda>_. return_pmf None)\"", "lemma rel_core'_into_trace_core_eq: \"trace_core_eq core core' E IA IU p q\" \n  if \"rel_core' S (eq_onp (\\<lambda>e. e \\<in> E)) (eq_onp (\\<lambda>ia. ia \\<in> IA)) (eq_onp (\\<lambda>iu. iu \\<in> IU)) (=) (=) core core'\"\n     \"rel_spmf S p q\"", "lemma trace_core_eq_simI:\n  fixes core1 :: \"('s_core, 'event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\"\n    and core2 :: \"('s_core', 'event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\"\n    and S :: \"'s_core spmf \\<Rightarrow> 's_core' spmf \\<Rightarrow> bool\"\n  assumes start: \"S p q\"\n    and step_cpoke: \"\\<And>p q e. \\<lbrakk> S p q; e \\<in> E \\<rbrakk> \\<Longrightarrow> \n      weight_spmf (bind_spmf p (\\<lambda>s. cpoke core1 s e)) = weight_spmf (bind_spmf q (\\<lambda>s. cpoke core2 s e))\"\n    and sim_cpoke: \"\\<And>p q e. \\<lbrakk> S p q; e \\<in> E \\<rbrakk> \\<Longrightarrow> \n      S (mk_lossless (bind_spmf p (\\<lambda>s. cpoke core1 s e))) (mk_lossless (bind_spmf q (\\<lambda>s. cpoke core2 s e)))\"\n    and step_cfunc_adv: \"\\<And>p q ia. \\<lbrakk> S p q; ia \\<in> IA \\<rbrakk> \\<Longrightarrow> \n      bind_spmf p (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ia)) = bind_spmf q (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\"\n    and sim_cfunc_adv: \"\\<And>p q ia s1 s2 s1' s2' oa. \\<lbrakk> S p q; ia \\<in> IA; \n      s1 \\<in> set_spmf p; s2 \\<in> set_spmf q; (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia); (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia) \\<rbrakk>\n      \\<Longrightarrow> S (cond_spmf_fst (bind_spmf p (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa) (cond_spmf_fst (bind_spmf q (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa)\"\n    and step_cfunc_usr: \"\\<And>p q iu. \\<lbrakk> S p q; iu \\<in> IU \\<rbrakk> \\<Longrightarrow> \n      bind_spmf p (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 iu)) = bind_spmf q (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\"\n    and sim_cfunc_usr: \"\\<And>p q iu s1 s2 s1' s2' ou. \\<lbrakk> S p q; iu \\<in> IU; \n      s1 \\<in> set_spmf p; s2 \\<in> set_spmf q; (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu); (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu) \\<rbrakk>\n      \\<Longrightarrow> S (cond_spmf_fst (bind_spmf p (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou) (cond_spmf_fst (bind_spmf q (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou)\"\n  shows \"trace_core_eq core1 core2 E IA IU p q\"", "lemma trace_core_conv_trace_core_aux:\n  \"trace_core' core p tr = \n   (\\<lambda>e. weight_spmf (bind_spmf (trace_core_aux core p tr) (\\<lambda>s. cpoke core s e)),\n    \\<lambda>ia. bind_spmf (trace_core_aux core p tr) (\\<lambda>s. map_spmf fst (cfunc_adv core s ia)),\n    \\<lambda>iu. bind_spmf (trace_core_aux core p tr) (\\<lambda>s. map_spmf fst (cfunc_usr core s iu)))\"", "lemma trace_core_aux_append:\n  \"trace_core_aux core p (tr @ tr') = trace_core_aux core (trace_core_aux core p tr) tr'\"", "lemma trace_core_closure_start: \"trace_core_closure core1 core2 E IA IU p q p q\"", "lemma trace_core_closure_step:\n  assumes \"trace_core_eq core1 core2 E IA IU p q\"\n    and \"trace_core_closure core1 core2 E IA IU p q p' q'\"\n  shows trace_core_closure_step_cpoke:\n    \"e \\<in> E \\<Longrightarrow> weight_spmf (bind_spmf p' (\\<lambda>s. cpoke core1 s e)) = weight_spmf (bind_spmf q' (\\<lambda>s. cpoke core2 s e))\"\n    (is \"PROP ?thesis1\")\n    and trace_core_closure_step_cfunc_adv: \n    \"ia \\<in> IA \\<Longrightarrow> bind_spmf p' (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ia)) = bind_spmf q' (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\"\n    (is \"PROP ?thesis2\")\n    and trace_core_closure_step_cfunc_usr:\n    \"iu \\<in> IU \\<Longrightarrow> bind_spmf p' (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 iu)) = bind_spmf q' (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\"\n    (is \"PROP ?thesis3\")", "lemma trace_core_closure_sim:\n  fixes core1 core2 E IA IU p q\n  defines \"S \\<equiv> trace_core_closure core1 core2 E IA IU p q\"\n  assumes \"S p' q'\"\n  shows trace_core_closure_sim_cpoke:\n    \"e \\<in> E \\<Longrightarrow> S (mk_lossless (bind_spmf p' (\\<lambda>s. cpoke core1 s e))) (mk_lossless (bind_spmf q' (\\<lambda>s. cpoke core2 s e)))\"\n    (is \"PROP ?thesis1\")\n    and trace_core_closure_sim_cfunc_adv: \"ia \\<in> IA \n    \\<Longrightarrow> S (cond_spmf_fst (bind_spmf p' (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa) \n          (cond_spmf_fst (bind_spmf q' (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa)\"\n    (is \"PROP ?thesis2\")\n    and trace_core_closure_sim_cfunc_usr: \"iu \\<in> IU \n    \\<Longrightarrow> S (cond_spmf_fst (bind_spmf p' (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou)\n          (cond_spmf_fst (bind_spmf q' (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou)\"\n    (is \"PROP ?thesis3\")", "lemma trace_rest'_parametric [transfer_rule]:\n  \"(rel_rest' S (=) IA IU (=) (=) M ===> rel_spmf S ===>\n      list_all2 (rel_sum (rel_prod IA (=)) (rel_prod IU (=))) ===>\n      rel_prod (IA ===> (=)) (IU ===> (=)))\n      trace_rest' trace_rest'\"", "lemma trace_rest_eqD:\n  assumes \"trace_rest_eq rest1 rest2 IA IU p q\"\n    and \"set tr \\<subseteq> (IA \\<times> UNIV) <+> (IU \\<times> UNIV)\"\n  shows trace_rest_eqD_rfunc_adv:\n     \"ia \\<in> IA \\<Longrightarrow> fst (trace_rest' rest1 p tr) ia = fst (trace_rest' rest2 q tr) ia\"\n    and trace_rest_eqD_rfunc_usr:\n     \"iu \\<in> IU \\<Longrightarrow> snd (trace_rest' rest1 p tr) iu = snd (trace_rest' rest2 q tr) iu\"", "lemma trace_rest_eqI:\n  assumes \"\\<And>tr ia. \\<lbrakk> set tr \\<subseteq> (IA \\<times> UNIV) <+> (IU \\<times> UNIV); ia \\<in> IA \\<rbrakk>\n     \\<Longrightarrow> fst (trace_rest' rest1 p tr) ia = fst (trace_rest' rest2 q tr) ia\"\n    and \"\\<And>tr iu. \\<lbrakk> set tr \\<subseteq> (IA \\<times> UNIV) <+> (IU \\<times> UNIV); iu \\<in> IU \\<rbrakk>\n      \\<Longrightarrow> snd (trace_rest' rest1 p tr) iu = snd (trace_rest' rest2 q tr) iu\"\n  shows \"trace_rest_eq rest1 rest2 IA IU p q\"", "lemma trace_rest_return_pmf_None [simp]:\n  \"trace_rest' rest (return_pmf None) tr = (\\<lambda>_. return_pmf None, \\<lambda>_. return_pmf None)\"", "lemma rel_rest'_into_trace_rest_eq: \"trace_rest_eq rest rest' IA IU p q\" \n  if \"rel_rest' S (=) (eq_onp (\\<lambda>ia. ia \\<in> IA)) (eq_onp (\\<lambda>iu. iu \\<in> IU)) (=) (=) M rest rest'\"\n     \"rel_spmf S p q\"", "lemma trace_rest_eq_simI:\n  fixes rest1 :: \"('s_rest, 'event, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest, 'more) rest_scheme\"\n    and rest2 :: \"('s_rest', 'event, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest, 'more) rest_scheme\"\n    and S :: \"'s_rest spmf \\<Rightarrow> 's_rest' spmf \\<Rightarrow> bool\"\n  assumes start: \"S p q\"\n    and step_rfunc_adv: \"\\<And>p q ia. \\<lbrakk> S p q; ia \\<in> IA \\<rbrakk> \\<Longrightarrow> \n      bind_spmf p (\\<lambda>s1. map_spmf fst (rfunc_adv rest1 s1 ia)) = bind_spmf q (\\<lambda>s2. map_spmf fst (rfunc_adv rest2 s2 ia))\"\n    and sim_rfunc_adv: \"\\<And>p q ia s1 s2 s1' s2' oa. \\<lbrakk> S p q; ia \\<in> IA; \n      s1 \\<in> set_spmf p; s2 \\<in> set_spmf q; (oa, s1') \\<in> set_spmf (rfunc_adv rest1 s1 ia); (oa, s2') \\<in> set_spmf (rfunc_adv rest2 s2 ia) \\<rbrakk>\n      \\<Longrightarrow> S (cond_spmf_fst (bind_spmf p (\\<lambda>s1. rfunc_adv rest1 s1 ia)) oa) (cond_spmf_fst (bind_spmf q (\\<lambda>s2. rfunc_adv rest2 s2 ia)) oa)\"\n    and step_rfunc_usr: \"\\<And>p q iu. \\<lbrakk> S p q; iu \\<in> IU \\<rbrakk> \\<Longrightarrow> \n      bind_spmf p (\\<lambda>s1. map_spmf fst (rfunc_usr rest1 s1 iu)) = bind_spmf q (\\<lambda>s2. map_spmf fst (rfunc_usr rest2 s2 iu))\"\n    and sim_rfunc_usr: \"\\<And>p q iu s1 s2 s1' s2' ou. \\<lbrakk> S p q; iu \\<in> IU; \n      s1 \\<in> set_spmf p; s2 \\<in> set_spmf q; (ou, s1') \\<in> set_spmf (rfunc_usr rest1 s1 iu); (ou, s2') \\<in> set_spmf (rfunc_usr rest2 s2 iu) \\<rbrakk>\n      \\<Longrightarrow> S (cond_spmf_fst (bind_spmf p (\\<lambda>s1. rfunc_usr rest1 s1 iu)) ou) (cond_spmf_fst (bind_spmf q (\\<lambda>s2. rfunc_usr rest2 s2 iu)) ou)\"\n  shows \"trace_rest_eq rest1 rest2 IA IU p q\"", "lemma trace_rest_conv_trace_rest_aux:\n  \"trace_rest' rest p tr = \n   (\\<lambda>ia. bind_spmf (trace_rest_aux rest p tr) (\\<lambda>s. map_spmf fst (rfunc_adv rest s ia)),\n    \\<lambda>iu. bind_spmf (trace_rest_aux rest p tr) (\\<lambda>s. map_spmf fst (rfunc_usr rest s iu)))\"", "lemma trace_rest_aux_append:\n  \"trace_rest_aux rest p (tr @ tr') = trace_rest_aux rest (trace_rest_aux rest p tr) tr'\"", "lemma trace_rest_closure_start: \"trace_rest_closure rest1 rest2 IA IU p q p q\"", "lemma trace_rest_closure_step:\n  assumes \"trace_rest_eq rest1 rest2 IA IU p q\"\n    and \"trace_rest_closure rest1 rest2 IA IU p q p' q'\"\n  shows trace_rest_closure_step_rfunc_adv: \n    \"ia \\<in> IA \\<Longrightarrow> bind_spmf p' (\\<lambda>s1. map_spmf fst (rfunc_adv rest1 s1 ia)) = bind_spmf q' (\\<lambda>s2. map_spmf fst (rfunc_adv rest2 s2 ia))\"\n    (is \"PROP ?thesis1\")\n    and trace_rest_closure_step_rfunc_usr:\n    \"iu \\<in> IU \\<Longrightarrow> bind_spmf p' (\\<lambda>s1. map_spmf fst (rfunc_usr rest1 s1 iu)) = bind_spmf q' (\\<lambda>s2. map_spmf fst (rfunc_usr rest2 s2 iu))\"\n    (is \"PROP ?thesis2\")", "lemma trace_rest_closure_sim:\n  fixes rest1 rest2 IA IU p q\n  defines \"S \\<equiv> trace_rest_closure rest1 rest2 IA IU p q\"\n  assumes \"S p' q'\"\n  shows trace_rest_closure_sim_rfunc_adv: \"ia \\<in> IA \n    \\<Longrightarrow> S (cond_spmf_fst (bind_spmf p' (\\<lambda>s1. rfunc_adv rest1 s1 ia)) oa) \n          (cond_spmf_fst (bind_spmf q' (\\<lambda>s2. rfunc_adv rest2 s2 ia)) oa)\"\n    (is \"PROP ?thesis1\")\n    and trace_rest_closure_sim_rfunc_usr: \"iu \\<in> IU \n    \\<Longrightarrow> S (cond_spmf_fst (bind_spmf p' (\\<lambda>s1. rfunc_usr rest1 s1 iu)) ou)\n          (cond_spmf_fst (bind_spmf q' (\\<lambda>s2. rfunc_usr rest2 s2 iu)) ou)\"\n    (is \"PROP ?thesis2\")", "lemma callee_of_core_simps [simp]:\n  \"callee_of_core core s (Inl e) = map_spmf (Pair (Inl ())) (cpoke core s e)\"\n  \"callee_of_core core s (Inr (Inl iadv_core)) = map_spmf (apfst (Inr \\<circ> Inl)) (cfunc_adv core s iadv_core)\"\n  \"callee_of_core core s (Inr (Inr iusr_core)) = map_spmf (apfst (Inr \\<circ> Inr)) (cfunc_usr core s iusr_core)\"", "lemma WT_callee_of_core [WT_intro]:\n  assumes WT: \"WT_core \\<I>_adv \\<I>_usr I core\"\n     and I: \"I s\"\n   shows \"\\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_adv \\<oplus>\\<^sub>\\<I> \\<I>_usr) \\<turnstile>c callee_of_core core s \\<surd>\"", "lemma WT_core_callee_invariant_on [WT_intro]:\n  assumes WT: \"WT_core \\<I>_adv \\<I>_usr I core\"\n  shows \"callee_invariant_on (callee_of_core core) I (\\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_adv \\<oplus>\\<^sub>\\<I> \\<I>_usr))\"", "lemma callee_of_rest_simps [simp]:\n  \"callee_of_rest rest s (Inl iadv_rest) = map_spmf (apfst Inl) (rfunc_adv rest s iadv_rest)\"\n  \"callee_of_rest rest s (Inr iusr_rest) = map_spmf (apfst Inr) (rfunc_usr rest s iusr_rest)\"", "lemma WT_callee_of_rest [WT_intro]:\n  assumes WT: \"WT_rest \\<I>_adv \\<I>_usr I rest\"\n    and I: \"I s\"\n  shows \"e\\<I> \\<I>_adv \\<oplus>\\<^sub>\\<I> e\\<I> \\<I>_usr \\<turnstile>c callee_of_rest rest s \\<surd>\"", "lemma fuse_converter:\n  \"resource_of_oracle (fused_resource.fuse core rest) (s_core, s_rest) = \n  fuse_converter \\<rhd> (resource_of_oracle (callee_of_core core) s_core \\<parallel> resource_of_oracle (callee_of_rest rest) s_rest)\"", "lemma trace_eq_callee_of_coreI:\n  \"trace_callee_eq (callee_of_core core1) (callee_of_core core2) (E <+> IA <+> IU) p q\"\n  if \"trace_core_eq core1 core2 E IA IU p q\"", "lemma trace_eq_callee_of_restI:\n  \"trace_callee_eq (callee_of_rest rest1) (callee_of_rest rest2) (IA <+> IU) p q\"\n  if \"trace_rest_eq rest1 rest2 IA IU p q\"", "lemma trace_callee_resource_of_oracle:\n  \"trace_callee run_resource (map_spmf (resource_of_oracle callee) p) = trace_callee callee p\"\n  (is \"?lhs = ?rhs\")", "lemma trace_callee_resource_of_oracle':\n  \"trace_callee run_resource (return_spmf (resource_of_oracle callee s)) = trace_callee callee (return_spmf s)\"", "lemma trace_eq_resource_of_oracle:\n  \"trace_eq A (map_spmf (resource_of_oracle callee1) p) (map_spmf (resource_of_oracle callee2) q) =\n   trace_callee_eq callee1 callee2 A p q\"", "lemma WT_fuse_converter [WT_intro]:\n  \"(\\<I>AC \\<oplus>\\<^sub>\\<I> map_\\<I> id fst \\<I>AR) \\<oplus>\\<^sub>\\<I> (\\<I>UC \\<oplus>\\<^sub>\\<I> map_\\<I> id fst \\<I>UR), (\\<I>E \\<oplus>\\<^sub>\\<I> (\\<I>AC \\<oplus>\\<^sub>\\<I> \\<I>UC)) \\<oplus>\\<^sub>\\<I> (\\<I>AR \\<oplus>\\<^sub>\\<I> \\<I>UR) \\<turnstile>\\<^sub>C fuse_converter \\<surd>\"\n  if \"\\<forall>x. \\<forall>(y, es)\\<in>responses_\\<I> \\<I>AR x. set es \\<subseteq> outs_\\<I> \\<I>E\" \"\\<forall>x. \\<forall>(y, es)\\<in>responses_\\<I> \\<I>UR x. set es \\<subseteq> outs_\\<I> \\<I>E\"", "theorem fuse_trace_eq:\n  fixes core1 :: \"('s_core, 'event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\"\n    and core2 :: \"('s_core', 'event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\"\n    and rest1 :: \"('s_rest, 'event, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest, 'more1) rest_scheme\"\n    and rest2 :: \"('s_rest', 'event, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest, 'more2) rest_scheme\"\n  assumes core: \"trace_core_eq core1 core2 (outs_\\<I> \\<I>E) (outs_\\<I> \\<I>CA) (outs_\\<I> \\<I>CU) (return_spmf s_core) (return_spmf s_core')\"\n    and rest: \"trace_rest_eq rest1 rest2 (outs_\\<I> \\<I>RA) (outs_\\<I> \\<I>RU) (return_spmf s_rest) (return_spmf s_rest')\"\n    and IC1: \"callee_invariant_on (callee_of_core core1) IC1 (\\<I>E \\<oplus>\\<^sub>\\<I> (\\<I>CA \\<oplus>\\<^sub>\\<I> \\<I>CU))\" \"IC1 s_core\"\n    and IC2: \"callee_invariant_on (callee_of_core core2) IC2 (\\<I>E \\<oplus>\\<^sub>\\<I> (\\<I>CA \\<oplus>\\<^sub>\\<I> \\<I>CU))\" \"IC2 s_core'\"\n    and IR1: \"callee_invariant_on (callee_of_rest rest1) IR1 (\\<I>RA \\<oplus>\\<^sub>\\<I> \\<I>RU)\" \"IR1 s_rest\"\n    and IR2: \"callee_invariant_on (callee_of_rest rest2) IR2 (\\<I>RA \\<oplus>\\<^sub>\\<I> \\<I>RU)\" \"IR2 s_rest'\"\n    and E1 [WT_intro]: \"\\<forall>x. \\<forall>(y, es)\\<in>responses_\\<I> \\<I>RA x. set es \\<subseteq> outs_\\<I> \\<I>E\"\n    and E2 [WT_intro]: \"\\<forall>x. \\<forall>(y, es)\\<in>responses_\\<I> \\<I>RU x. set es \\<subseteq> outs_\\<I> \\<I>E\"\n  shows \"trace_callee_eq (fused_resource.fuse core1 rest1) (fused_resource.fuse core2 rest2)\n    ((outs_\\<I> \\<I>CA <+> outs_\\<I> \\<I>RA) <+> (outs_\\<I> \\<I>CU <+> outs_\\<I> \\<I>RU)) (return_spmf (s_core, s_rest)) (return_spmf (s_core', s_rest'))\"", "lemma trace_eq_simcl_bindI [intro?]: \"trace_eq_simcl S (bind_spmf p f) (bind_spmf p g)\"\n  if \"\\<And>x. x \\<in> set_spmf p \\<Longrightarrow> S (f x) (g x)\"", "lemma trace_eq_simcl_bind: \"trace_eq_simcl S (bind_spmf p f) (bind_spmf p g)\"\n  if *: \"\\<And>x :: 'a. x \\<in> set_spmf p \\<Longrightarrow> trace_eq_simcl S (f x) (g x)\"", "lemma trace_eq_simcl_bind1_scale: \"trace_eq_simcl S (bind_spmf p f) (scale_spmf (weight_spmf p) q)\"\n  if \"\\<forall>x\\<in>set_spmf p. trace_eq_simcl S (f x) q\"", "lemma trace_eq_simcl_bind1: \"trace_eq_simcl S (bind_spmf p f) q\"\n  if \"\\<forall>x\\<in>set_spmf p. trace_eq_simcl S (f x) q\" \"lossless_spmf p\"", "lemma trace_eq_simcl_bind2_scale: \"trace_eq_simcl S (scale_spmf (weight_spmf q) p) (bind_spmf q f)\"\n  if \"\\<forall>x\\<in>set_spmf q. trace_eq_simcl S p (f x)\"", "lemma trace_eq_simcl_bind2: \"trace_eq_simcl S p (bind_spmf q f)\"\n  if \"\\<forall>x\\<in>set_spmf q. trace_eq_simcl S p (f x)\" \"lossless_spmf q\"", "lemma trace_eq_simcl_return_pmf_None [simp, intro!]: \"trace_eq_simcl S (return_pmf None) (return_pmf None)\" \n  for S :: \"'s1 spmf \\<Rightarrow> 's2 spmf \\<Rightarrow> bool\"", "lemma trace_eq_simcl_map: \"trace_eq_simcl S (map_spmf f p) (map_spmf g p)\"\n  if \"\\<forall>x\\<in>set_spmf p. S (return_spmf (f x)) (return_spmf (g x))\"", "lemma trace_eq_simcl_map1: \"trace_eq_simcl S (map_spmf f p) q\"\n  if \"\\<forall>x\\<in>set_spmf p. trace_eq_simcl S (return_spmf (f x)) q\" \"lossless_spmf p\"", "lemma trace_eq_simcl_map2: \"trace_eq_simcl S p (map_spmf f q)\"\n  if \"\\<forall>x\\<in>set_spmf q. trace_eq_simcl S p (return_spmf (f x))\" \"lossless_spmf q\"", "lemma trace_eq_simcl_return_spmf [simp]: \"trace_eq_simcl S (return_spmf x) (return_spmf y) \\<longleftrightarrow> S (return_spmf x) (return_spmf y)\"", "lemma trace_eq_simcl_callee:\n  fixes callee1 :: \"('a, 'b, 's1) callee\" and callee2 :: \"('a, 'b, 's2) callee\"\n  assumes step: \"\\<And>p q a. \\<lbrakk> S p q; a \\<in> A \\<rbrakk> \\<Longrightarrow>\n      bind_spmf p (\\<lambda>s. map_spmf fst (callee1 s a)) = bind_spmf q (\\<lambda>s. map_spmf fst (callee2 s a))\"\n    and sim: \"\\<And>p q a res b s'. \\<lbrakk> S p q; a \\<in> A; res \\<in> set_spmf q; (b, s') \\<in> set_spmf (callee2 res a) \\<rbrakk>\n      \\<Longrightarrow> trace_eq_simcl S (cond_spmf_fst (bind_spmf p (\\<lambda>s. callee1 s a)) b)\n            (cond_spmf_fst (bind_spmf q (\\<lambda>s. callee2 s a)) b)\"\n    and start: \"trace_eq_simcl S p q\" and a: \"a \\<in> A\"\n  shows trace_eq_simcl_callee_step: \"bind_spmf p (\\<lambda>s. map_spmf fst (callee1 s a)) = bind_spmf q (\\<lambda>s. map_spmf fst (callee2 s a))\" (is \"?step\")\n    and trace_eq_simcl_callee_sim: \"\\<And>res b s'. \\<lbrakk> res \\<in> set_spmf q; (b, s') \\<in> set_spmf (callee2 res a) \\<rbrakk>\n      \\<Longrightarrow> trace_eq_simcl S (cond_spmf_fst (bind_spmf p (\\<lambda>s. callee1 s a)) b)\n                            (cond_spmf_fst (bind_spmf q (\\<lambda>s. callee2 s a)) b)\" (is \"\\<And>res b s'. \\<lbrakk> ?res res; ?b res b s' \\<rbrakk> \\<Longrightarrow> ?sim res b s'\")", "lemma trace_core_eq_simI_upto:\n  fixes core1 :: \"('s_core, 'event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\"\n    and core2 :: \"('s_core', 'event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\"\n    and S :: \"'s_core spmf \\<Rightarrow> 's_core' spmf \\<Rightarrow> bool\"\n  assumes start: \"S p q\"\n    and step_cpoke: \"\\<And>p q e. \\<lbrakk> S p q; e \\<in> E \\<rbrakk> \\<Longrightarrow> \n      weight_spmf (bind_spmf p (\\<lambda>s. cpoke core1 s e)) = weight_spmf (bind_spmf q (\\<lambda>s. cpoke core2 s e))\"\n    and sim_cpoke: \"\\<And>p q e. \\<lbrakk> S p q; e \\<in> E \\<rbrakk> \\<Longrightarrow> \n      trace_eq_simcl S (mk_lossless (bind_spmf p (\\<lambda>s. cpoke core1 s e))) (mk_lossless (bind_spmf q (\\<lambda>s. cpoke core2 s e)))\"\n    and step_cfunc_adv: \"\\<And>p q ia. \\<lbrakk> S p q; ia \\<in> IA \\<rbrakk> \\<Longrightarrow> \n      bind_spmf p (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ia)) = bind_spmf q (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\"\n    and sim_cfunc_adv: \"\\<And>p q ia s1 s2 s1' s2' oa. \\<lbrakk> S p q; ia \\<in> IA; \n      s1 \\<in> set_spmf p; s2 \\<in> set_spmf q; (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia); (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia) \\<rbrakk>\n      \\<Longrightarrow> trace_eq_simcl S (cond_spmf_fst (bind_spmf p (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa) (cond_spmf_fst (bind_spmf q (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa)\"\n    and step_cfunc_usr: \"\\<And>p q iu. \\<lbrakk> S p q; iu \\<in> IU \\<rbrakk> \\<Longrightarrow> \n      bind_spmf p (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 iu)) = bind_spmf q (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\"\n    and sim_cfunc_usr: \"\\<And>p q iu s1 s2 s1' s2' ou. \\<lbrakk> S p q; iu \\<in> IU; \n      s1 \\<in> set_spmf p; s2 \\<in> set_spmf q; (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu); (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu) \\<rbrakk>\n      \\<Longrightarrow> trace_eq_simcl S (cond_spmf_fst (bind_spmf p (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou) (cond_spmf_fst (bind_spmf q (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou)\"\n  shows \"trace_core_eq core1 core2 E IA IU p q\"", "lemma fuse_core_with_rest:\n  fixes core :: \"('s_core, 'event1 + 'event2, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\"\n    and rest1 :: \"('s_rest1, 'event1, 'iadv_rest1, 'iusr_rest1, 'oadv_rest1, 'ousr_rest1, 'more1) rest_scheme\"\n    and rest2 :: \"('s_rest2, 'event2, 'iadv_rest2, 'iusr_rest2, 'oadv_rest2, 'ousr_rest2, 'more2) rest_scheme\"\n  shows\n  \"fused_resource.fuse core (parallel_rest rest1 rest2) (s_core, (s_rest1, s_rest2)) = \n   map_fun (map_sum (lsumr \\<circ> map_sum id swap_sum) (lsumr \\<circ> map_sum id swap_sum)) (map_spmf (map_prod (map_sum (map_sum id swap_sum \\<circ> rsuml) (map_sum id swap_sum \\<circ> rsuml)) (map_prod id prod.swap \\<circ> rprodl)))\n   (fused_resource.fuse (core_with_rest core rest2) rest1 ((s_core, s_rest2), s_rest1))\""], "translations": [["", "lemma outs_\\<I>_e\\<I>[simp]: \"outs_\\<I> (e\\<I> \\<I>) = outs_\\<I> \\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outs_\\<I> (e\\<I> \\<I>) = outs_\\<I> \\<I>", "by transfer simp"], ["", "lemma responses_\\<I>_e\\<I> [simp]: \"responses_\\<I> (e\\<I> \\<I>) x = responses_\\<I> \\<I> x \\<times> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. responses_\\<I> (e\\<I> \\<I>) x = responses_\\<I> \\<I> x \\<times> UNIV", "by transfer simp"], ["", "lemma e\\<I>_map_\\<I>: \"e\\<I> (map_\\<I> f g \\<I>) = map_\\<I> f (apfst g) (e\\<I> \\<I>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e\\<I> (map_\\<I> f g \\<I>) = map_\\<I> f (apfst g) (e\\<I> \\<I>)", "by transfer(auto simp add: fun_eq_iff intro: rev_image_eqI)"], ["", "lemma e\\<I>_inverse [simp]: \"map_\\<I> id fst (e\\<I> \\<I>) = \\<I>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_\\<I> id fst (e\\<I> \\<I>) = \\<I>", "by transfer auto"], ["", "end"], ["", "lifting_update \\<I>.lifting"], ["", "lifting_forget \\<I>.lifting"], ["", "section \\<open>Fused Resource\\<close>"], ["", "subsection \\<open>Event Oracles -- they generate events\\<close>"], ["", "type_synonym \n  ('state, 'event, 'input, 'output) eoracle = \"('state, 'input, 'output \\<times> 'event list) oracle'\""], ["", "definition\n  parallel_eoracle :: \"\n    ('s1, 'e1, 'i1, 'o1) eoracle \\<Rightarrow> ('s2, 'e2, 'i2, 'o2) eoracle \\<Rightarrow>\n      ('s1 \\<times> 's2, 'e1 + 'e2, 'i1 + 'i2, 'o1 + 'o2) eoracle\"\n  where\n    \"parallel_eoracle eoracle1 eoracle2 state \\<equiv>\n       comp\n        (map_spmf \n          (map_prod \n            (case_sum \n              (map_prod Inl (map Inl)) \n              (map_prod Inr (map Inr))) \n            id))\n        (parallel_oracle eoracle1 eoracle2 state)\""], ["", "definition\n  plus_eoracle :: \"\n    ('s, 'e1, 'i1, 'o1) eoracle \\<Rightarrow> ('s, 'e2, 'i2, 'o2) eoracle \\<Rightarrow>\n      ('s, 'e1 + 'e2, 'i1 + 'i2, 'o1 + 'o2) eoracle\"\n  where\n    \"plus_eoracle eoracle1 eoracle2 state \\<equiv>\n       comp\n        (map_spmf \n          (map_prod \n            (case_sum \n              (map_prod Inl (map Inl)) \n              (map_prod Inr (map Inr))) \n            id))\n        (plus_oracle eoracle1 eoracle2 state)\""], ["", "definition\n  translate_eoracle :: \"\n    ('s_event, 'e1, 'e2 list) oracle' \\<Rightarrow> ('s_event \\<times> 's, 'e1, 'i, 'o) eoracle \\<Rightarrow>\n      ('s_event \\<times> 's, 'e2, 'i, 'o) eoracle\"\n  where\n    \"translate_eoracle translator eoracle state inp \\<equiv> \n      bind_spmf\n        (eoracle state inp)\n        (\\<lambda>((out, e_in), s).\n          let conc = (\\<lambda>(es, st) e. map_spmf (map_prod ((@) es) id) (translator st e)) in do {\n          (e_out, s_event) \\<leftarrow> foldl_spmf conc (return_spmf ([], fst s)) e_in;\n          return_spmf ((out, e_out), s_event, snd s)\n        })\""], ["", "subsection \\<open>Event Handlers -- they absorb (and silently handle) events\\<close>"], ["", "type_synonym\n  ('state, 'event) handler = \"'state \\<Rightarrow> 'event \\<Rightarrow> 'state spmf\""], ["", "fun\n  parallel_handler :: \"('s1, 'e1) handler \\<Rightarrow> ('s2, 'e2) handler \\<Rightarrow> ('s1 \\<times> 's2, 'e1 + 'e2) handler\"\n  where\n    \"parallel_handler left _ s (Inl e1) = map_spmf (\\<lambda>s1'. (s1', snd s)) (left (fst s) e1)\"\n  | \"parallel_handler _ right s (Inr e2) = map_spmf (\\<lambda>s2'. (fst s, s2')) (right (snd s) e2)\""], ["", "definition\n  plus_handler :: \"('s, 'e1) handler \\<Rightarrow> ('s, 'e2) handler \\<Rightarrow> ('s, 'e1 + 'e2) handler\"\n  where\n    \"plus_handler left right s \\<equiv> case_sum (left s) (right s)\""], ["", "lemma parallel_handler_left:\n  \"map_fun id (map_fun Inl id) (parallel_handler left right) = \n    (\\<lambda>(s_l, s_r) q. map_spmf (\\<lambda>s_l'. (s_l', s_r)) (left s_l q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_fun id (map_fun Inl id) (parallel_handler left right) =\n    (\\<lambda>(s_l, s_r) q.\n        map_spmf (\\<lambda>s_l'. (s_l', s_r)) (left s_l q))", "by force"], ["", "lemma parallel_handler_right:\n  \"map_fun id (map_fun Inr id) (parallel_handler left right) = \n    (\\<lambda>(s_l, s_r) q. map_spmf (\\<lambda>s_r'. (s_l, s_r')) (right s_r q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_fun id (map_fun Inr id) (parallel_handler left right) =\n    (\\<lambda>(s_l, s_r) q. map_spmf (Pair s_l) (right s_r q))", "by force"], ["", "lemma in_set_spmf_parallel_handler:\n  \"s' \\<in> set_spmf (parallel_handler left right s x) \\<longleftrightarrow>\n  (case x of Inl e \\<Rightarrow> fst s' \\<in> set_spmf (left (fst s) e) \\<and> snd s' = snd s\n    | Inr e \\<Rightarrow> snd s' \\<in> set_spmf (right (snd s) e) \\<and> fst s' = fst s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s' \\<in> set_spmf (parallel_handler left right s x)) =\n    (case x of\n     Inl e \\<Rightarrow>\n       fst s' \\<in> set_spmf (left (fst s) e) \\<and> snd s' = snd s\n     | Inr e \\<Rightarrow>\n         snd s' \\<in> set_spmf (right (snd s) e) \\<and> fst s' = fst s)", "by(cases s; cases s'; auto split: sum.split)"], ["", "subsection \\<open>Fused Resource Construction\\<close>"], ["", "codatatype \n  ('s_core, 'event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core =\n    Core\n      (cpoke: \"('s_core, 'event) handler\")\n      (cfunc_adv: \"('s_core, 'iadv_core, 'oadv_core) oracle'\")\n      (cfunc_usr: \"('s_core, 'iusr_core, 'ousr_core) oracle'\")"], ["", "declare core.sel_transfer[transfer_rule del]"], ["", "declare core.ctr_transfer[transfer_rule del]"], ["", "declare core.case_transfer[transfer_rule del]"], ["", "context \n  includes lifting_syntax \nbegin"], ["", "inductive \n  rel_core':: \"\n    ('s_core \\<Rightarrow> 's_core' \\<Rightarrow> bool) \\<Rightarrow> \n    ('event \\<Rightarrow> 'event' \\<Rightarrow> bool) \\<Rightarrow> \n    ('iadv_core \\<Rightarrow> 'iadv_core' \\<Rightarrow> bool) \\<Rightarrow>\n    ('iusr_core \\<Rightarrow> 'iusr_core' \\<Rightarrow> bool) \\<Rightarrow> \n    ('oadv_core \\<Rightarrow> 'oadv_core' \\<Rightarrow> bool) \\<Rightarrow> \n    ('ousr_core \\<Rightarrow> 'ousr_core' \\<Rightarrow> bool) \\<Rightarrow>\n    ('s_core, 'event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core \\<Rightarrow> \n    ('s_core', 'event', 'iadv_core', 'iusr_core', 'oadv_core', 'ousr_core') core \\<Rightarrow> bool\"\n  for S E IA IU OA OU\n  where \"rel_core' S E IA IU OA OU (Core cpoke cfunc_adv cfunc_usr) (Core cpoke' cfunc_adv' cfunc_usr')\"\n  if \n    \"(S ===> E ===> rel_spmf S) cpoke cpoke'\" and \n    \"(S ===> IA ===> rel_spmf (rel_prod OA S)) cfunc_adv cfunc_adv'\" and \n    \"(S ===> IU ===> rel_spmf (rel_prod OU S)) cfunc_usr cfunc_usr'\"\n  for cpoke cfunc_adv cfunc_usr"], ["", "inductive_simps \n  rel_core'_simps [simp]: \n    \"rel_core' S E IA IU OA OU (Core cpoke' cfunc_adv' cfunc_usr') (Core cpoke'' cfunc_adv'' cfunc_usr'')\""], ["", "lemma \n  rel_core'_eq [relator_eq]:\n    \"rel_core' (=) (=) (=) (=) (=) (=) = (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_core' (=) (=) (=) (=) (=) (=) = (=)", "apply(intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa. rel_core' (=) (=) (=) (=) (=) (=) x xa = (x = xa)", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_core' (=) (=) (=) (=) (=) (=) x y = (x = y)", "by(cases x; cases y)(auto simp add: fun_eq_iff rel_fun_def relator_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \n  rel_core'_mono [relator_mono]:\n    \"rel_core' S E IA IU OA OU \\<le> rel_core' S E' IA' IU' OA' OU'\"\n  if \"E' \\<le> E\" \"IA' \\<le> IA\" \"IU' \\<le> IU\" \"OA \\<le> OA'\" \"OU \\<le> OU'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_core' S E IA IU OA OU \\<le> rel_core' S E' IA' IU' OA' OU'", "apply(rule predicate2I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rel_core' S E IA IU OA OU x y \\<Longrightarrow>\n       rel_core' S E' IA' IU' OA' OU' x y", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_core' S E IA IU OA OU x y \\<Longrightarrow>\n    rel_core' S E' IA' IU' OA' OU' x y", "apply(cases x; cases y; clarsimp; intro conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x3 x1a x2a x3a.\n       \\<lbrakk>x = Core x1 x2 x3; y = Core x1a x2a x3a;\n        (S ===> E ===> rel_spmf S) x1 x1a;\n        (S ===> IA ===> rel_spmf (rel_prod OA S)) x2 x2a;\n        (S ===> IU ===> rel_spmf (rel_prod OU S)) x3 x3a\\<rbrakk>\n       \\<Longrightarrow> (S ===> E' ===> rel_spmf S) x1 x1a\n 2. \\<And>x1 x2 x3 x1a x2a x3a.\n       \\<lbrakk>x = Core x1 x2 x3; y = Core x1a x2a x3a;\n        (S ===> E ===> rel_spmf S) x1 x1a;\n        (S ===> IA ===> rel_spmf (rel_prod OA S)) x2 x2a;\n        (S ===> IU ===> rel_spmf (rel_prod OU S)) x3 x3a\\<rbrakk>\n       \\<Longrightarrow> (S ===> IA' ===> rel_spmf (rel_prod OA' S)) x2 x2a\n 3. \\<And>x1 x2 x3 x1a x2a x3a.\n       \\<lbrakk>x = Core x1 x2 x3; y = Core x1a x2a x3a;\n        (S ===> E ===> rel_spmf S) x1 x1a;\n        (S ===> IA ===> rel_spmf (rel_prod OA S)) x2 x2a;\n        (S ===> IU ===> rel_spmf (rel_prod OU S)) x3 x3a\\<rbrakk>\n       \\<Longrightarrow> (S ===> IU' ===> rel_spmf (rel_prod OU' S)) x3 x3a", "apply(erule rel_fun_mono rel_spmf_mono prod.rel_mono[THEN predicate2D, rotated -1] |\n        rule impI that order_refl | erule that[THEN predicate2D] | erule rel_spmf_mono | assumption)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \n  cpoke_parametric [transfer_rule]:\n    \"(rel_core' S E IA IU OA OU ===> S ===> E ===> rel_spmf S) cpoke cpoke\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_core' S E IA IU OA OU ===> S ===> E ===> rel_spmf S) cpoke cpoke", "by(rule rel_funI; erule rel_core'.cases; simp)"], ["", "lemma \n  cfunc_adv_parametric [transfer_rule]:\n    \"(rel_core' S E IA IU OA OU ===> S ===> IA ===> rel_spmf (rel_prod OA S)) cfunc_adv cfunc_adv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_core' S E IA IU OA OU ===> S ===> IA ===> rel_spmf (rel_prod OA S))\n     cfunc_adv cfunc_adv", "by(rule rel_funI; erule rel_core'.cases; simp)"], ["", "lemma \n  cfunc_usr_parametric [transfer_rule]:\n    \"(rel_core' S E IA IU OA OU ===> S ===> IU ===> rel_spmf (rel_prod OU S)) cfunc_usr cfunc_usr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_core' S E IA IU OA OU ===> S ===> IU ===> rel_spmf (rel_prod OU S))\n     cfunc_usr cfunc_usr", "by(rule rel_funI; erule rel_core'.cases; simp)"], ["", "lemma \n  Core_parametric [transfer_rule]:\n    \"((S ===> E ===> rel_spmf S) ===> (S ===> IA ===> rel_spmf (rel_prod OA S)) ===> (S ===> IU ===> rel_spmf (rel_prod OU S))\n   ===> rel_core' S E IA IU OA OU) Core Core\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> E ===> rel_spmf S) ===>\n     (S ===> IA ===> rel_spmf (rel_prod OA S)) ===>\n     (S ===> IU ===> rel_spmf (rel_prod OU S)) ===>\n     rel_core' S E IA IU OA OU)\n     Core Core", "by(rule rel_funI)+ simp"], ["", "lemma \n  case_core_parametric [transfer_rule]:\n    \"(((S ===> E ===> rel_spmf S) ===> \n        (S ===> IA ===> rel_spmf (rel_prod OA S)) ===> \n        (S ===> IU ===> rel_spmf (rel_prod OU S)) ===> X) ===> \n      rel_core' S E IA IU OA OU ===> X) case_core case_core\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((S ===> E ===> rel_spmf S) ===>\n      (S ===> IA ===> rel_spmf (rel_prod OA S)) ===>\n      (S ===> IU ===> rel_spmf (rel_prod OU S)) ===> X) ===>\n     rel_core' S E IA IU OA OU ===> X)\n     case_core case_core", "by(rule rel_funI)+(auto 4 4 split: core.split dest: rel_funD)"], ["", "lemma \n  corec_core_parametric [transfer_rule]:\n    \"((X ===> S ===> E ===> rel_spmf S) ===> \n      (X ===> S ===> IA ===> rel_spmf (rel_prod OA S)) ===> \n      (X ===> S ===> IU ===> rel_spmf (rel_prod OU S)) ===> \n      X ===> rel_core' S E IA IU OA OU) corec_core corec_core\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((X ===> S ===> E ===> rel_spmf S) ===>\n     (X ===> S ===> IA ===> rel_spmf (rel_prod OA S)) ===>\n     (X ===> S ===> IU ===> rel_spmf (rel_prod OU S)) ===>\n     X ===> rel_core' S E IA IU OA OU)\n     corec_core corec_core", "by(rule rel_funI)+(auto simp add: core.corec dest: rel_funD)"], ["", "primcorec map_core' ::\n   \"('event' \\<Rightarrow> 'event) \\<Rightarrow> \n    ('iadv_core' \\<Rightarrow> 'iadv_core) \\<Rightarrow>\n    ('iusr_core' \\<Rightarrow> 'iusr_core) \\<Rightarrow> \n    ('oadv_core \\<Rightarrow> 'oadv_core') \\<Rightarrow> \n    ('ousr_core \\<Rightarrow> 'ousr_core') \\<Rightarrow>\n    ('s_core, 'event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core \\<Rightarrow> \n    ('s_core, 'event', 'iadv_core', 'iusr_core', 'oadv_core', 'ousr_core') core\"\n   where\n  \"cpoke (map_core' e ia iu oa ou core) = (id ---> e ---> id) (cpoke core)\"\n| \"cfunc_adv (map_core' e ia iu oa ou core) = (id ---> ia ---> map_spmf (map_prod oa id)) (cfunc_adv core)\"\n| \"cfunc_usr (map_core' e ia iu oa ou core) = (id ---> iu ---> map_spmf (map_prod ou id)) (cfunc_usr core)\""], ["", "lemmas map_core'_simps [simp] = map_core'.ctr[where core=\"Core _ _ _\", simplified]"], ["", "parametric_constant map_core'_parametric[transfer_rule]: map_core'_def"], ["", "lemma core'_rel_Grp:\n  \"rel_core' (=) (BNF_Def.Grp UNIV e)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV ia)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV iu)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV oa) (BNF_Def.Grp UNIV ou)\n   = BNF_Def.Grp UNIV (map_core' e ia iu oa ou)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_core' (=) (BNF_Def.Grp UNIV e)\\<inverse>\\<inverse>\n     (BNF_Def.Grp UNIV ia)\\<inverse>\\<inverse>\n     (BNF_Def.Grp UNIV iu)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV oa)\n     (BNF_Def.Grp UNIV ou) =\n    BNF_Def.Grp UNIV (map_core' e ia iu oa ou)", "apply(intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       rel_core' (=) (BNF_Def.Grp UNIV e)\\<inverse>\\<inverse>\n        (BNF_Def.Grp UNIV ia)\\<inverse>\\<inverse>\n        (BNF_Def.Grp UNIV iu)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV oa)\n        (BNF_Def.Grp UNIV ou) x xa =\n       BNF_Def.Grp UNIV (map_core' e ia iu oa ou) x xa", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_core' (=) (BNF_Def.Grp UNIV e)\\<inverse>\\<inverse>\n     (BNF_Def.Grp UNIV ia)\\<inverse>\\<inverse>\n     (BNF_Def.Grp UNIV iu)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV oa)\n     (BNF_Def.Grp UNIV ou) x y =\n    BNF_Def.Grp UNIV (map_core' e ia iu oa ou) x y", "apply(cases x; cases y; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x1a x2a x3a.\n       \\<lbrakk>x = Core x1 x2 x3; y = Core x1a x2a x3a\\<rbrakk>\n       \\<Longrightarrow> (((=) ===>\n                           (BNF_Def.Grp UNIV e)\\<inverse>\\<inverse> ===>\n                           rel_spmf (=))\n                           x1 x1a \\<and>\n                          ((=) ===>\n                           (BNF_Def.Grp UNIV ia)\\<inverse>\\<inverse> ===>\n                           rel_spmf (rel_prod (BNF_Def.Grp UNIV oa) (=)))\n                           x2 x2a \\<and>\n                          ((=) ===>\n                           (BNF_Def.Grp UNIV iu)\\<inverse>\\<inverse> ===>\n                           rel_spmf (rel_prod (BNF_Def.Grp UNIV ou) (=)))\n                           x3 x3a) =\n                         BNF_Def.Grp UNIV (map_core' e ia iu oa ou)\n                          (Core x1 x2 x3) (Core x1a x2a x3a)", "apply(subst (2 4 6) eq_alt_conversep)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x1a x2a x3a.\n       \\<lbrakk>x = Core x1 x2 x3; y = Core x1a x2a x3a\\<rbrakk>\n       \\<Longrightarrow> (((BNF_Def.Grp UNIV id)\\<inverse>\\<inverse> ===>\n                           (BNF_Def.Grp UNIV e)\\<inverse>\\<inverse> ===>\n                           rel_spmf (=))\n                           x1 x1a \\<and>\n                          ((BNF_Def.Grp UNIV id)\\<inverse>\\<inverse> ===>\n                           (BNF_Def.Grp UNIV ia)\\<inverse>\\<inverse> ===>\n                           rel_spmf (rel_prod (BNF_Def.Grp UNIV oa) (=)))\n                           x2 x2a \\<and>\n                          ((BNF_Def.Grp UNIV id)\\<inverse>\\<inverse> ===>\n                           (BNF_Def.Grp UNIV iu)\\<inverse>\\<inverse> ===>\n                           rel_spmf (rel_prod (BNF_Def.Grp UNIV ou) (=)))\n                           x3 x3a) =\n                         BNF_Def.Grp UNIV (map_core' e ia iu oa ou)\n                          (Core x1 x2 x3) (Core x1a x2a x3a)", "apply(subst (2 3 4) eq_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x1a x2a x3a.\n       \\<lbrakk>x = Core x1 x2 x3; y = Core x1a x2a x3a\\<rbrakk>\n       \\<Longrightarrow> (((BNF_Def.Grp UNIV id)\\<inverse>\\<inverse> ===>\n                           (BNF_Def.Grp UNIV e)\\<inverse>\\<inverse> ===>\n                           rel_spmf (BNF_Def.Grp UNIV id))\n                           x1 x1a \\<and>\n                          ((BNF_Def.Grp UNIV id)\\<inverse>\\<inverse> ===>\n                           (BNF_Def.Grp UNIV ia)\\<inverse>\\<inverse> ===>\n                           rel_spmf\n                            (rel_prod (BNF_Def.Grp UNIV oa)\n                              (BNF_Def.Grp UNIV id)))\n                           x2 x2a \\<and>\n                          ((BNF_Def.Grp UNIV id)\\<inverse>\\<inverse> ===>\n                           (BNF_Def.Grp UNIV iu)\\<inverse>\\<inverse> ===>\n                           rel_spmf\n                            (rel_prod (BNF_Def.Grp UNIV ou)\n                              (BNF_Def.Grp UNIV id)))\n                           x3 x3a) =\n                         BNF_Def.Grp UNIV (map_core' e ia iu oa ou)\n                          (Core x1 x2 x3) (Core x1a x2a x3a)", "apply(simp add: pmf.rel_Grp option.rel_Grp prod.rel_Grp rel_fun_conversep_grp_grp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x1a x2a x3a.\n       \\<lbrakk>x = Core x1 x2 x3; y = Core x1a x2a x3a\\<rbrakk>\n       \\<Longrightarrow> (BNF_Def.Grp UNIV (id ---> e ---> map_spmf id) x1\n                           x1a \\<and>\n                          BNF_Def.Grp UNIV\n                           (id ---> ia ---> map_spmf (map_prod oa id)) x2\n                           x2a \\<and>\n                          BNF_Def.Grp UNIV\n                           (id ---> iu ---> map_spmf (map_prod ou id)) x3\n                           x3a) =\n                         BNF_Def.Grp UNIV (map_core' e ia iu oa ou)\n                          (Core x1 x2 x3) (Core x1a x2a x3a)", "apply(auto simp add: Grp_def spmf.map_id[abs_def] id_def[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "inductive WT_core :: \"('iadv, 'oadv) \\<I> \\<Rightarrow> ('iusr, 'ousr) \\<I> \\<Rightarrow> ('s \\<Rightarrow> bool) \\<Rightarrow> ('s, 'event, 'iadv, 'iusr, 'oadv, 'ousr) core \\<Rightarrow> bool\"\n  for \\<I>_adv \\<I>_usr I core where\n  \"WT_core \\<I>_adv \\<I>_usr I core\" if\n  \"\\<And>s e s'. \\<lbrakk> s' \\<in> set_spmf (cpoke core s e); I s \\<rbrakk> \\<Longrightarrow> I s'\"\n  \"\\<And>s x y s'. \\<lbrakk> (y, s') \\<in> set_spmf (cfunc_adv core s x); x \\<in> outs_\\<I> \\<I>_adv; I s \\<rbrakk> \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_adv x \\<and> I s'\"\n  \"\\<And>s x y s'. \\<lbrakk> (y, s') \\<in> set_spmf (cfunc_usr core s x); x \\<in> outs_\\<I> \\<I>_usr; I s \\<rbrakk> \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_usr x \\<and> I s'\""], ["", "lemma WT_coreD:\n  assumes \"WT_core \\<I>_adv \\<I>_usr I core\"\n  shows WT_coreD_cpoke: \"\\<And>s e s'. \\<lbrakk> s' \\<in> set_spmf (cpoke core s e); I s \\<rbrakk> \\<Longrightarrow> I s'\"\n    and WT_coreD_cfunc_adv: \"\\<And>s x y s'. \\<lbrakk> (y, s') \\<in> set_spmf (cfunc_adv core s x); x \\<in> outs_\\<I> \\<I>_adv; I s \\<rbrakk> \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_adv x \\<and> I s'\"\n    and WT_coreD_cfund_usr: \"\\<And>s x y s'. \\<lbrakk> (y, s') \\<in> set_spmf (cfunc_usr core s x); x \\<in> outs_\\<I> \\<I>_usr; I s \\<rbrakk> \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_usr x \\<and> I s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s e s'.\n        \\<lbrakk>s' \\<in> set_spmf (cpoke core s e); I s\\<rbrakk>\n        \\<Longrightarrow> I s') &&&\n    (\\<And>s x y s'.\n        \\<lbrakk>(y, s') \\<in> set_spmf (cfunc_adv core s x);\n         x \\<in> outs_\\<I> \\<I>_adv; I s\\<rbrakk>\n        \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_adv x \\<and> I s') &&&\n    (\\<And>s x y s'.\n        \\<lbrakk>(y, s') \\<in> set_spmf (cfunc_usr core s x);\n         x \\<in> outs_\\<I> \\<I>_usr; I s\\<rbrakk>\n        \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_usr x \\<and> I s')", "using assms"], ["proof (prove)\nusing this:\n  WT_core \\<I>_adv \\<I>_usr I core\n\ngoal (1 subgoal):\n 1. (\\<And>s e s'.\n        \\<lbrakk>s' \\<in> set_spmf (cpoke core s e); I s\\<rbrakk>\n        \\<Longrightarrow> I s') &&&\n    (\\<And>s x y s'.\n        \\<lbrakk>(y, s') \\<in> set_spmf (cfunc_adv core s x);\n         x \\<in> outs_\\<I> \\<I>_adv; I s\\<rbrakk>\n        \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_adv x \\<and> I s') &&&\n    (\\<And>s x y s'.\n        \\<lbrakk>(y, s') \\<in> set_spmf (cfunc_usr core s x);\n         x \\<in> outs_\\<I> \\<I>_usr; I s\\<rbrakk>\n        \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_usr x \\<and> I s')", "by(auto elim!: WT_core.cases)"], ["", "lemma WT_coreD_foldl_spmf_cpoke:\n  assumes \"WT_core \\<I>_adv \\<I>_usr I core\"\n    and \"s' \\<in> set_spmf (foldl_spmf (cpoke core) p es)\"\n    and \"\\<forall>s \\<in> set_spmf p. I s\"\n  shows \"I s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I s'", "using assms(2, 3)"], ["proof (prove)\nusing this:\n  s' \\<in> set_spmf (foldl_spmf (cpoke core) p es)\n  \\<forall>s\\<in>set_spmf p. I s\n\ngoal (1 subgoal):\n 1. I s'", "by(induction es arbitrary: p)(fastforce dest: WT_coreD_cpoke[OF assms(1)] simp add: bind_UNION)+"], ["", "lemma WT_core_trivial:\n  assumes adv: \"\\<And>s. \\<I>_adv \\<turnstile>c cfunc_adv core s \\<surd>\"\n    and usr: \"\\<And>s. \\<I>_usr \\<turnstile>c cfunc_usr core s \\<surd>\"\n  shows \"WT_core \\<I>_adv \\<I>_usr (\\<lambda>_. True) core\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WT_core \\<I>_adv \\<I>_usr (\\<lambda>_. True) core", "by(rule WT_core.intros)(auto dest: assms[THEN WT_calleeD])"], ["", "codatatype \n  ('s_rest, 'event, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest, 'more) rest_scheme =\n    Rest\n      (rinit: \"'more\")\n      (rfunc_adv: \"('s_rest, 'event, 'iadv_rest, 'oadv_rest) eoracle\")\n      (rfunc_usr: \"('s_rest, 'event, 'iusr_rest, 'ousr_rest) eoracle\")"], ["", "declare rest_scheme.sel_transfer[transfer_rule del]"], ["", "declare rest_scheme.ctr_transfer[transfer_rule del]"], ["", "declare rest_scheme.case_transfer[transfer_rule del]"], ["", "context \n  includes lifting_syntax \nbegin"], ["", "inductive \n  rel_rest':: \"\n    ('s_rest \\<Rightarrow> 's_rest' \\<Rightarrow> bool) \\<Rightarrow> \n    ('event \\<Rightarrow> 'event' \\<Rightarrow> bool) \\<Rightarrow> \n    ('iadv_rest \\<Rightarrow> 'iadv_rest' \\<Rightarrow> bool) \\<Rightarrow>\n    ('iusr_rest \\<Rightarrow> 'iusr_rest' \\<Rightarrow> bool) \\<Rightarrow> \n    ('oadv_rest \\<Rightarrow> 'oadv_rest' \\<Rightarrow> bool) \\<Rightarrow> \n    ('ousr_rest \\<Rightarrow> 'ousr_rest' \\<Rightarrow> bool) \\<Rightarrow>\n    ('more \\<Rightarrow> 'more' \\<Rightarrow> bool) \\<Rightarrow> \n    ('s_rest, 'event, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest, 'more) rest_scheme \\<Rightarrow> \n    ('s_rest', 'event', 'iadv_rest', 'iusr_rest', 'oadv_rest', 'ousr_rest', 'more') rest_scheme \\<Rightarrow> bool\"\n  for S E IA IU OA OU M\n  where \"rel_rest' S E IA IU OA OU M (Rest rinit rfunc_adv rfunc_usr) (Rest rinit' rfunc_adv' rfunc_usr')\"\n  if \n    \"M rinit rinit'\" and \n    \"(S ===> IA ===> rel_spmf (rel_prod (rel_prod OA (list_all2 E)) S)) rfunc_adv rfunc_adv'\" and \n    \"(S ===> IU ===> rel_spmf (rel_prod (rel_prod OU (list_all2 E)) S)) rfunc_usr rfunc_usr'\"\n  for rinit rfunc_adv rfunc_usr"], ["", "inductive_simps \n  rel_rest'_simps [simp]: \n    \"rel_rest' S E IA IU OA OU M (Rest rinit' rfunc_adv' rfunc_usr') (Rest rinit'' rfunc_adv'' rfunc_usr'')\""], ["", "lemma \n  rel_rest'_eq [relator_eq]:\n    \"rel_rest' (=) (=) (=) (=) (=) (=) (=) = (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_rest' (=) (=) (=) (=) (=) (=) (=) = (=)", "apply(intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa. rel_rest' (=) (=) (=) (=) (=) (=) (=) x xa = (x = xa)", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_rest' (=) (=) (=) (=) (=) (=) (=) x y = (x = y)", "by(cases x; cases y)(auto simp add: fun_eq_iff rel_fun_def relator_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \n  rel_rest'_mono [relator_mono]:\n    \"rel_rest' S E IA IU OA OU M \\<le> rel_rest' S E' IA' IU' OA' OU' M'\"\n  if \"E \\<le> E'\" \"IA' \\<le> IA\" \"IU' \\<le> IU\" \"OA \\<le> OA'\" \"OU \\<le> OU'\" \"M \\<le> M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_rest' S E IA IU OA OU M \\<le> rel_rest' S E' IA' IU' OA' OU' M'", "apply(rule predicate2I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       rel_rest' S E IA IU OA OU M x y \\<Longrightarrow>\n       rel_rest' S E' IA' IU' OA' OU' M' x y", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_rest' S E IA IU OA OU M x y \\<Longrightarrow>\n    rel_rest' S E' IA' IU' OA' OU' M' x y", "apply(cases x; cases y; clarsimp; intro conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x3 x1a x2a x3a.\n       \\<lbrakk>x = Rest x1 x2 x3; y = Rest x1a x2a x3a; M x1 x1a;\n        (S ===> IA ===> rel_spmf (rel_prod (rel_prod OA (list_all2 E)) S))\n         x2 x2a;\n        (S ===> IU ===> rel_spmf (rel_prod (rel_prod OU (list_all2 E)) S))\n         x3 x3a\\<rbrakk>\n       \\<Longrightarrow> M' x1 x1a\n 2. \\<And>x1 x2 x3 x1a x2a x3a.\n       \\<lbrakk>x = Rest x1 x2 x3; y = Rest x1a x2a x3a; M x1 x1a;\n        (S ===> IA ===> rel_spmf (rel_prod (rel_prod OA (list_all2 E)) S))\n         x2 x2a;\n        (S ===> IU ===> rel_spmf (rel_prod (rel_prod OU (list_all2 E)) S))\n         x3 x3a\\<rbrakk>\n       \\<Longrightarrow> (S ===>\n                          IA' ===>\n                          rel_spmf\n                           (rel_prod (rel_prod OA' (list_all2 E')) S))\n                          x2 x2a\n 3. \\<And>x1 x2 x3 x1a x2a x3a.\n       \\<lbrakk>x = Rest x1 x2 x3; y = Rest x1a x2a x3a; M x1 x1a;\n        (S ===> IA ===> rel_spmf (rel_prod (rel_prod OA (list_all2 E)) S))\n         x2 x2a;\n        (S ===> IU ===> rel_spmf (rel_prod (rel_prod OU (list_all2 E)) S))\n         x3 x3a\\<rbrakk>\n       \\<Longrightarrow> (S ===>\n                          IU' ===>\n                          rel_spmf\n                           (rel_prod (rel_prod OU' (list_all2 E')) S))\n                          x3 x3a", "apply(erule rel_fun_mono rel_spmf_mono prod.rel_mono[THEN predicate2D, rotated -1] |\n        rule impI that order_refl prod.rel_mono list.rel_mono | erule that[THEN predicate2D] | erule rel_spmf_mono | assumption)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rel_rest'_sel: \"rel_rest' S E IA IU OA OU M rest1 rest2\"\n  if \"M (rinit rest1) (rinit rest2)\"\n  and \"(S ===> IA ===> rel_spmf (rel_prod (rel_prod OA (list_all2 E)) S)) (rfunc_adv rest1) (rfunc_adv rest2)\" \n  and \"(S ===> IU ===> rel_spmf (rel_prod (rel_prod OU (list_all2 E)) S)) (rfunc_usr rest1) (rfunc_usr rest2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_rest' S E IA IU OA OU M rest1 rest2", "using that"], ["proof (prove)\nusing this:\n  M (rinit rest1) (rinit rest2)\n  (S ===> IA ===> rel_spmf (rel_prod (rel_prod OA (list_all2 E)) S))\n   (rfunc_adv rest1) (rfunc_adv rest2)\n  (S ===> IU ===> rel_spmf (rel_prod (rel_prod OU (list_all2 E)) S))\n   (rfunc_usr rest1) (rfunc_usr rest2)\n\ngoal (1 subgoal):\n 1. rel_rest' S E IA IU OA OU M rest1 rest2", "by(cases rest1; cases rest2) simp"], ["", "lemma rinit_parametric [transfer_rule]: \"(rel_rest' S E IA IU OA OU M ===> M) rinit rinit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_rest' S E IA IU OA OU M ===> M) rinit rinit", "by(rule rel_funI; erule rel_rest'.cases; simp)"], ["", "lemma rfunc_adv_parametric [transfer_rule]:\n  \"(rel_rest' S E IA IU OA OU M ===> S ===> IA ===> rel_spmf (rel_prod (rel_prod OA (list_all2 E)) S)) rfunc_adv rfunc_adv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_rest' S E IA IU OA OU M ===>\n     S ===> IA ===> rel_spmf (rel_prod (rel_prod OA (list_all2 E)) S))\n     rfunc_adv rfunc_adv", "by(rule rel_funI; erule rel_rest'.cases; simp)"], ["", "lemma rfunc_usr_parametric [transfer_rule]:\n  \"(rel_rest' S E IA IU OA OU M ===> S ===> IU ===> rel_spmf (rel_prod (rel_prod OU (list_all2 E)) S)) rfunc_usr rfunc_usr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_rest' S E IA IU OA OU M ===>\n     S ===> IU ===> rel_spmf (rel_prod (rel_prod OU (list_all2 E)) S))\n     rfunc_usr rfunc_usr", "by(rule rel_funI; erule rel_rest'.cases; simp)"], ["", "lemma Rest_parametric [transfer_rule]:\n  \"(M ===> (S ===> IA ===> rel_spmf (rel_prod (rel_prod OA (list_all2 E)) S))\n    ===> (S ===> IU ===> rel_spmf (rel_prod (rel_prod OU (list_all2 E)) S))\n   ===> rel_rest' S E IA IU OA OU M) Rest Rest\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M ===>\n     (S ===> IA ===> rel_spmf (rel_prod (rel_prod OA (list_all2 E)) S)) ===>\n     (S ===> IU ===> rel_spmf (rel_prod (rel_prod OU (list_all2 E)) S)) ===>\n     rel_rest' S E IA IU OA OU M)\n     Rest Rest", "by(rule rel_funI)+ simp"], ["", "lemma case_rest_scheme_parametric [transfer_rule]:\n  \"((M ===> \n    (S ===> IA ===> rel_spmf (rel_prod (rel_prod OA (list_all2 E)) S)) ===> \n    (S ===> IU ===> rel_spmf (rel_prod (rel_prod OU (list_all2 E)) S)) ===> X) ===> \n  rel_rest' S E IA IU OA OU M ===> X) case_rest_scheme case_rest_scheme\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((M ===>\n      (S ===>\n       IA ===> rel_spmf (rel_prod (rel_prod OA (list_all2 E)) S)) ===>\n      (S ===>\n       IU ===> rel_spmf (rel_prod (rel_prod OU (list_all2 E)) S)) ===>\n      X) ===>\n     rel_rest' S E IA IU OA OU M ===> X)\n     case_rest_scheme case_rest_scheme", "by(rule rel_funI)+(auto 4 4 split: rest_scheme.split dest: rel_funD)"], ["", "lemma corec_rest_scheme_parametric [transfer_rule]:\n    \"((X ===> M) ===> \n      (X ===> S ===> IA ===> rel_spmf (rel_prod (rel_prod OA (list_all2 E)) S)) ===> \n      (X ===> S ===> IU ===> rel_spmf (rel_prod (rel_prod OU (list_all2 E)) S)) ===> \n      X ===> rel_rest' S E IA IU OA OU M) corec_rest_scheme corec_rest_scheme\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((X ===> M) ===>\n     (X ===>\n      S ===> IA ===> rel_spmf (rel_prod (rel_prod OA (list_all2 E)) S)) ===>\n     (X ===>\n      S ===> IU ===> rel_spmf (rel_prod (rel_prod OU (list_all2 E)) S)) ===>\n     X ===> rel_rest' S E IA IU OA OU M)\n     corec_rest_scheme corec_rest_scheme", "by(rule rel_funI)+(auto simp add: rest_scheme.corec dest: rel_funD)"], ["", "primcorec map_rest' ::\n   \"('event \\<Rightarrow> 'event') \\<Rightarrow> \n    ('iadv_rest' \\<Rightarrow> 'iadv_rest) \\<Rightarrow>\n    ('iusr_rest' \\<Rightarrow> 'iusr_rest) \\<Rightarrow> \n    ('oadv_rest \\<Rightarrow> 'oadv_rest') \\<Rightarrow> \n    ('ousr_rest \\<Rightarrow> 'ousr_rest') \\<Rightarrow>\n    ('more \\<Rightarrow> 'more') \\<Rightarrow>\n    ('s_rest, 'event, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest, 'more) rest_scheme \\<Rightarrow> \n    ('s_rest, 'event', 'iadv_rest', 'iusr_rest', 'oadv_rest', 'ousr_rest', 'more') rest_scheme\"\n   where\n  \"rinit (map_rest' e ia iu oa ou m rest) = m (rinit rest)\"\n| \"rfunc_adv (map_rest' e ia iu oa ou m rest) =\n   (id ---> ia ---> map_spmf (map_prod (map_prod oa (map e)) id)) (rfunc_adv rest)\"\n| \"rfunc_usr (map_rest' e ia iu oa ou m rest) =\n   (id ---> iu ---> map_spmf (map_prod (map_prod ou (map e)) id)) (rfunc_usr rest)\""], ["", "lemmas map_rest'_simps [simp] = map_rest'.ctr[where rest=\"Rest _ _ _\", simplified]"], ["", "parametric_constant map_rest'_parametric[transfer_rule]: map_rest'_def"], ["", "lemma rest'_rel_Grp:\n  \"rel_rest' (=) (BNF_Def.Grp UNIV e) (BNF_Def.Grp UNIV ia)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV iu)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV oa) (BNF_Def.Grp UNIV ou) (BNF_Def.Grp UNIV m)\n   = BNF_Def.Grp UNIV (map_rest' e ia iu oa ou m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_rest' (=) (BNF_Def.Grp UNIV e)\n     (BNF_Def.Grp UNIV ia)\\<inverse>\\<inverse>\n     (BNF_Def.Grp UNIV iu)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV oa)\n     (BNF_Def.Grp UNIV ou) (BNF_Def.Grp UNIV m) =\n    BNF_Def.Grp UNIV (map_rest' e ia iu oa ou m)", "apply(intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       rel_rest' (=) (BNF_Def.Grp UNIV e)\n        (BNF_Def.Grp UNIV ia)\\<inverse>\\<inverse>\n        (BNF_Def.Grp UNIV iu)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV oa)\n        (BNF_Def.Grp UNIV ou) (BNF_Def.Grp UNIV m) x xa =\n       BNF_Def.Grp UNIV (map_rest' e ia iu oa ou m) x xa", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_rest' (=) (BNF_Def.Grp UNIV e)\n     (BNF_Def.Grp UNIV ia)\\<inverse>\\<inverse>\n     (BNF_Def.Grp UNIV iu)\\<inverse>\\<inverse> (BNF_Def.Grp UNIV oa)\n     (BNF_Def.Grp UNIV ou) (BNF_Def.Grp UNIV m) x y =\n    BNF_Def.Grp UNIV (map_rest' e ia iu oa ou m) x y", "apply(cases x; cases y; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x1a x2a x3a.\n       \\<lbrakk>x = Rest x1 x2 x3; y = Rest x1a x2a x3a\\<rbrakk>\n       \\<Longrightarrow> (BNF_Def.Grp UNIV m x1 x1a \\<and>\n                          ((=) ===>\n                           (BNF_Def.Grp UNIV ia)\\<inverse>\\<inverse> ===>\n                           rel_spmf\n                            (rel_prod\n                              (rel_prod (BNF_Def.Grp UNIV oa)\n                                (list_all2 (BNF_Def.Grp UNIV e)))\n                              (=)))\n                           x2 x2a \\<and>\n                          ((=) ===>\n                           (BNF_Def.Grp UNIV iu)\\<inverse>\\<inverse> ===>\n                           rel_spmf\n                            (rel_prod\n                              (rel_prod (BNF_Def.Grp UNIV ou)\n                                (list_all2 (BNF_Def.Grp UNIV e)))\n                              (=)))\n                           x3 x3a) =\n                         BNF_Def.Grp UNIV (map_rest' e ia iu oa ou m)\n                          (Rest x1 x2 x3) (Rest x1a x2a x3a)", "apply(subst (2 4) eq_alt_conversep)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x1a x2a x3a.\n       \\<lbrakk>x = Rest x1 x2 x3; y = Rest x1a x2a x3a\\<rbrakk>\n       \\<Longrightarrow> (BNF_Def.Grp UNIV m x1 x1a \\<and>\n                          ((BNF_Def.Grp UNIV id)\\<inverse>\\<inverse> ===>\n                           (BNF_Def.Grp UNIV ia)\\<inverse>\\<inverse> ===>\n                           rel_spmf\n                            (rel_prod\n                              (rel_prod (BNF_Def.Grp UNIV oa)\n                                (list_all2 (BNF_Def.Grp UNIV e)))\n                              (=)))\n                           x2 x2a \\<and>\n                          ((BNF_Def.Grp UNIV id)\\<inverse>\\<inverse> ===>\n                           (BNF_Def.Grp UNIV iu)\\<inverse>\\<inverse> ===>\n                           rel_spmf\n                            (rel_prod\n                              (rel_prod (BNF_Def.Grp UNIV ou)\n                                (list_all2 (BNF_Def.Grp UNIV e)))\n                              (=)))\n                           x3 x3a) =\n                         BNF_Def.Grp UNIV (map_rest' e ia iu oa ou m)\n                          (Rest x1 x2 x3) (Rest x1a x2a x3a)", "apply(subst (2 3) eq_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x1a x2a x3a.\n       \\<lbrakk>x = Rest x1 x2 x3; y = Rest x1a x2a x3a\\<rbrakk>\n       \\<Longrightarrow> (BNF_Def.Grp UNIV m x1 x1a \\<and>\n                          ((BNF_Def.Grp UNIV id)\\<inverse>\\<inverse> ===>\n                           (BNF_Def.Grp UNIV ia)\\<inverse>\\<inverse> ===>\n                           rel_spmf\n                            (rel_prod\n                              (rel_prod (BNF_Def.Grp UNIV oa)\n                                (list_all2 (BNF_Def.Grp UNIV e)))\n                              (BNF_Def.Grp UNIV id)))\n                           x2 x2a \\<and>\n                          ((BNF_Def.Grp UNIV id)\\<inverse>\\<inverse> ===>\n                           (BNF_Def.Grp UNIV iu)\\<inverse>\\<inverse> ===>\n                           rel_spmf\n                            (rel_prod\n                              (rel_prod (BNF_Def.Grp UNIV ou)\n                                (list_all2 (BNF_Def.Grp UNIV e)))\n                              (BNF_Def.Grp UNIV id)))\n                           x3 x3a) =\n                         BNF_Def.Grp UNIV (map_rest' e ia iu oa ou m)\n                          (Rest x1 x2 x3) (Rest x1a x2a x3a)", "apply(simp add: pmf.rel_Grp list.rel_Grp option.rel_Grp prod.rel_Grp rel_fun_conversep_grp_grp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x1a x2a x3a.\n       \\<lbrakk>x = Rest x1 x2 x3; y = Rest x1a x2a x3a\\<rbrakk>\n       \\<Longrightarrow> (BNF_Def.Grp UNIV m x1 x1a \\<and>\n                          BNF_Def.Grp UNIV\n                           (id --->\n                            ia --->\n                            map_spmf (map_prod (map_prod oa (map e)) id))\n                           x2 x2a \\<and>\n                          BNF_Def.Grp UNIV\n                           (id --->\n                            iu --->\n                            map_spmf (map_prod (map_prod ou (map e)) id))\n                           x3 x3a) =\n                         BNF_Def.Grp UNIV (map_rest' e ia iu oa ou m)\n                          (Rest x1 x2 x3) (Rest x1a x2a x3a)", "apply(auto simp add: Grp_def spmf.map_id[abs_def] id_def[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "type_synonym \n  ('s_rest, 'event, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest) rest_wstate =\n    \"('s_rest, 'event, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest, 's_rest) rest_scheme\""], ["", "inductive WT_rest :: \"('iadv, 'oadv) \\<I> \\<Rightarrow> ('iusr, 'ousr) \\<I> \\<Rightarrow> ('s \\<Rightarrow> bool) \\<Rightarrow> ('s, 'event, 'iadv, 'iusr, 'oadv, 'ousr) rest_wstate \\<Rightarrow> bool\"\n  for \\<I>_adv \\<I>_usr I rest where\n  \"WT_rest \\<I>_adv \\<I>_usr I rest\" if\n  \"\\<And>s x y es s'. \\<lbrakk> ((y, es), s') \\<in> set_spmf (rfunc_adv rest s x); x \\<in> outs_\\<I> \\<I>_adv; I s \\<rbrakk> \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_adv x \\<and> I s'\"\n  \"\\<And>s x y es s'. \\<lbrakk> ((y, es), s') \\<in> set_spmf (rfunc_usr rest s x); x \\<in> outs_\\<I> \\<I>_usr; I s \\<rbrakk> \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_usr x \\<and> I s'\"\n  \"I (rinit rest)\""], ["", "lemma WT_restD:\n  assumes \"WT_rest \\<I>_adv \\<I>_usr I rest\"\n  shows WT_restD_rfunc_adv: \"\\<And>s x y es s'. \\<lbrakk> ((y, es), s') \\<in> set_spmf (rfunc_adv rest s x); x \\<in> outs_\\<I> \\<I>_adv; I s \\<rbrakk> \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_adv x \\<and> I s'\"\n    and WT_restD_rfunc_usr: \"\\<And>s x y es s'. \\<lbrakk> ((y, es), s') \\<in> set_spmf (rfunc_usr rest s x); x \\<in> outs_\\<I> \\<I>_usr; I s \\<rbrakk> \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_usr x \\<and> I s'\"\n    and WT_restD_rinit: \"I (rinit rest)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s x y es s'.\n        \\<lbrakk>((y, es), s') \\<in> set_spmf (rfunc_adv rest s x);\n         x \\<in> outs_\\<I> \\<I>_adv; I s\\<rbrakk>\n        \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_adv x \\<and> I s') &&&\n    (\\<And>s x y es s'.\n        \\<lbrakk>((y, es), s') \\<in> set_spmf (rfunc_usr rest s x);\n         x \\<in> outs_\\<I> \\<I>_usr; I s\\<rbrakk>\n        \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_usr x \\<and> I s') &&&\n    I (rinit rest)", "using assms"], ["proof (prove)\nusing this:\n  WT_rest \\<I>_adv \\<I>_usr I rest\n\ngoal (1 subgoal):\n 1. (\\<And>s x y es s'.\n        \\<lbrakk>((y, es), s') \\<in> set_spmf (rfunc_adv rest s x);\n         x \\<in> outs_\\<I> \\<I>_adv; I s\\<rbrakk>\n        \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_adv x \\<and> I s') &&&\n    (\\<And>s x y es s'.\n        \\<lbrakk>((y, es), s') \\<in> set_spmf (rfunc_usr rest s x);\n         x \\<in> outs_\\<I> \\<I>_usr; I s\\<rbrakk>\n        \\<Longrightarrow> y \\<in> responses_\\<I> \\<I>_usr x \\<and> I s') &&&\n    I (rinit rest)", "by(auto elim!: WT_rest.cases)"], ["", "abbreviation\n  fuse_cfunc :: \"\n    ('o \\<Rightarrow> 'x) \\<Rightarrow> ('s_core, 'i, 'o) oracle' \\<Rightarrow> ('s_core \\<times> 's_rest, 'i , 'x) oracle'\"\n  where\n  \"fuse_cfunc redirect cfunc state inp  \\<equiv> do {\n    let handle = map_prod redirect (prod.swap o Pair (snd state));\n    (os_cfunc :: 'o \\<times> 's_core) \\<leftarrow> cfunc (fst state) inp;\n    return_spmf (handle os_cfunc)\n  }\""], ["", "abbreviation\n  fuse_rfunc :: \"\n    ('o \\<Rightarrow> 'x) \\<Rightarrow> ('s_rest, 'e, 'i, 'o) eoracle \\<Rightarrow> ('s_core, 'e) handler \\<Rightarrow> \n      ('s_core \\<times> 's_rest, 'i , 'x) oracle'\"\n  where\n  \"fuse_rfunc redirect rfunc notify state inp \\<equiv> \n    bind_spmf \n      (rfunc (snd state) inp)\n      (\\<lambda>((o_rfunc, e_lst), s_rfunc). \n        bind_spmf \n          (foldl_spmf notify (return_spmf (fst state)) e_lst)\n          (\\<lambda>s_notify. return_spmf (redirect o_rfunc, s_notify, s_rfunc)))\n  \""], ["", "locale fused_resource =\n  fixes \n    core :: \"('s_core, 'event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\" and \n    core_init :: 's_core\nbegin"], ["", "fun\n  fuse :: \"\n    ('s_rest, 'event, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest, 'm) rest_scheme \\<Rightarrow>\n    ('s_core \\<times> 's_rest, \n      ('iadv_core + 'iadv_rest) + ('iusr_core + 'iusr_rest),  \n      ('oadv_core + 'oadv_rest) + ('ousr_core + 'ousr_rest)) oracle'\" \n  where\n    \"fuse rest state (Inl (Inl iadv_core)) = \n      fuse_cfunc (Inl o Inl) (cfunc_adv core) state iadv_core\"\n  | \"fuse rest state (Inl (Inr iadv_rest)) = \n      fuse_rfunc (Inl o Inr) (rfunc_adv rest) (cpoke core) state iadv_rest\"\n  | \"fuse rest state (Inr (Inl iusr_core)) = \n      fuse_cfunc (Inr o Inl) (cfunc_usr core) state iusr_core\"\n  | \"fuse rest state (Inr (Inr iusr_rest)) = \n      fuse_rfunc (Inr o Inr) (rfunc_usr rest) (cpoke core) state iusr_rest\""], ["", "case_of_simps fuse_case: fused_resource.fuse.simps"], ["", "lemma callee_invariant_on_fuse:\n  assumes \"WT_core \\<I>_adv_core \\<I>_usr_core I_core core\" \n    and \"WT_rest \\<I>_adv_rest \\<I>_usr_rest I_rest rest\"\n  shows \"callee_invariant_on (fuse rest) (pred_prod I_core I_rest) ((\\<I>_adv_core \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I> (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on (fuse rest) (pred_prod I_core I_rest)\n     ((\\<I>_adv_core \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n      (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest))", "proof(unfold_locales, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (fuse rest s x);\n        pred_prod I_core I_rest s;\n        x \\<in> outs_\\<I>\n                 ((\\<I>_adv_core \\<oplus>\\<^sub>\\<I>\n                   \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n                  (\\<I>_usr_core \\<oplus>\\<^sub>\\<I>\n                   \\<I>_usr_rest))\\<rbrakk>\n       \\<Longrightarrow> pred_prod I_core I_rest s'\n 2. \\<And>s.\n       pred_prod I_core I_rest s \\<Longrightarrow>\n       (\\<I>_adv_core \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n       (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest) \\<turnstile>c\n       fuse rest s \\<surd>", "case (1 s x y s')"], ["proof (state)\nthis:\n  (y, s') \\<in> set_spmf (fuse rest s x)\n  pred_prod I_core I_rest s\n  x \\<in> outs_\\<I>\n           ((\\<I>_adv_core \\<oplus>\\<^sub>\\<I>\n             \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n            (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest))\n\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (fuse rest s x);\n        pred_prod I_core I_rest s;\n        x \\<in> outs_\\<I>\n                 ((\\<I>_adv_core \\<oplus>\\<^sub>\\<I>\n                   \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n                  (\\<I>_usr_core \\<oplus>\\<^sub>\\<I>\n                   \\<I>_usr_rest))\\<rbrakk>\n       \\<Longrightarrow> pred_prod I_core I_rest s'\n 2. \\<And>s.\n       pred_prod I_core I_rest s \\<Longrightarrow>\n       (\\<I>_adv_core \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n       (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest) \\<turnstile>c\n       fuse rest s \\<surd>", "then"], ["proof (chain)\npicking this:\n  (y, s') \\<in> set_spmf (fuse rest s x)\n  pred_prod I_core I_rest s\n  x \\<in> outs_\\<I>\n           ((\\<I>_adv_core \\<oplus>\\<^sub>\\<I>\n             \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n            (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest))", "show ?case"], ["proof (prove)\nusing this:\n  (y, s') \\<in> set_spmf (fuse rest s x)\n  pred_prod I_core I_rest s\n  x \\<in> outs_\\<I>\n           ((\\<I>_adv_core \\<oplus>\\<^sub>\\<I>\n             \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n            (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest))\n\ngoal (1 subgoal):\n 1. pred_prod I_core I_rest s'", "using assms"], ["proof (prove)\nusing this:\n  (y, s') \\<in> set_spmf (fuse rest s x)\n  pred_prod I_core I_rest s\n  x \\<in> outs_\\<I>\n           ((\\<I>_adv_core \\<oplus>\\<^sub>\\<I>\n             \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n            (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest))\n  WT_core \\<I>_adv_core \\<I>_usr_core I_core core\n  WT_rest \\<I>_adv_rest \\<I>_usr_rest I_rest rest\n\ngoal (1 subgoal):\n 1. pred_prod I_core I_rest s'", "by(cases s; cases s')(auto 4 4 dest: WT_restD WT_coreD WT_coreD_foldl_spmf_cpoke)"], ["proof (state)\nthis:\n  pred_prod I_core I_rest s'\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       pred_prod I_core I_rest s \\<Longrightarrow>\n       (\\<I>_adv_core \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n       (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest) \\<turnstile>c\n       fuse rest s \\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       pred_prod I_core I_rest s \\<Longrightarrow>\n       (\\<I>_adv_core \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n       (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest) \\<turnstile>c\n       fuse rest s \\<surd>", "case (2 s)"], ["proof (state)\nthis:\n  pred_prod I_core I_rest s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       pred_prod I_core I_rest s \\<Longrightarrow>\n       (\\<I>_adv_core \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n       (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest) \\<turnstile>c\n       fuse rest s \\<surd>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<I>_adv_core \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n    (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest) \\<turnstile>c\n    fuse rest s \\<surd>", "apply(rule WT_calleeI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>call ret sa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       ((\\<I>_adv_core \\<oplus>\\<^sub>\\<I>\n                         \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n                        (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest));\n        (ret, sa) \\<in> set_spmf (fuse rest s call)\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                ((\\<I>_adv_core \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n                                 (\\<I>_usr_core \\<oplus>\\<^sub>\\<I>\n                                  \\<I>_usr_rest))\n                                call", "subgoal for x y s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> outs_\\<I>\n                      ((\\<I>_adv_core \\<oplus>\\<^sub>\\<I>\n                        \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n                       (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest));\n     (y, s') \\<in> set_spmf (fuse rest s x)\\<rbrakk>\n    \\<Longrightarrow> y \\<in> responses_\\<I>\n                               ((\\<I>_adv_core \\<oplus>\\<^sub>\\<I>\n                                 \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n                                (\\<I>_usr_core \\<oplus>\\<^sub>\\<I>\n                                 \\<I>_usr_rest))\n                               x", "using 2 assms"], ["proof (prove)\nusing this:\n  pred_prod I_core I_rest s\n  WT_core \\<I>_adv_core \\<I>_usr_core I_core core\n  WT_rest \\<I>_adv_rest \\<I>_usr_rest I_rest rest\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> outs_\\<I>\n                      ((\\<I>_adv_core \\<oplus>\\<^sub>\\<I>\n                        \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n                       (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest));\n     (y, s') \\<in> set_spmf (fuse rest s x)\\<rbrakk>\n    \\<Longrightarrow> y \\<in> responses_\\<I>\n                               ((\\<I>_adv_core \\<oplus>\\<^sub>\\<I>\n                                 \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n                                (\\<I>_usr_core \\<oplus>\\<^sub>\\<I>\n                                 \\<I>_usr_rest))\n                               x", "by (cases \"(rest, s, x)\" rule: fuse.cases) (auto simp add: pred_prod_beta dest: WT_restD WT_coreD )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<I>_adv_core \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n  (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest) \\<turnstile>c\n  fuse rest s \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \n  resource :: \"\n    ('s_rest, 'event, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest) rest_wstate \\<Rightarrow>\n    (('iadv_core + 'iadv_rest) + ('iusr_core + 'iusr_rest),\n      ('oadv_core + 'oadv_rest) + ('ousr_core + 'ousr_rest)) resource\" \n  where\n    \"resource rest = resource_of_oracle (fuse rest) (core_init, rinit rest)\""], ["", "lemma WT_resource [WT_intro]:\n  assumes \"WT_core \\<I>_adv_core \\<I>_usr_core I_core core\"\n    and \"WT_rest \\<I>_adv_rest \\<I>_usr_rest I_rest rest\"\n    and \"I_core core_init\"\n  shows \"(\\<I>_adv_core \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I> (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest) \\<turnstile>res resource rest \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<I>_adv_core \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n    (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest) \n    \\<turnstile>res resource rest \\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<I>_adv_core \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n    (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest) \n    \\<turnstile>res resource rest \\<surd>", "interpret callee_invariant_on \"fuse rest\" \"pred_prod I_core I_rest\" \"(\\<I>_adv_core \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I> (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on (fuse rest) (pred_prod I_core I_rest)\n     ((\\<I>_adv_core \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n      (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest))", "using assms(1,2)"], ["proof (prove)\nusing this:\n  WT_core \\<I>_adv_core \\<I>_usr_core I_core core\n  WT_rest \\<I>_adv_rest \\<I>_usr_rest I_rest rest\n\ngoal (1 subgoal):\n 1. callee_invariant_on (fuse rest) (pred_prod I_core I_rest)\n     ((\\<I>_adv_core \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n      (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest))", "by(rule callee_invariant_on_fuse)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<I>_adv_core \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n    (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest) \n    \\<turnstile>res resource rest \\<surd>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<I>_adv_core \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n    (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest) \n    \\<turnstile>res resource rest \\<surd>", "unfolding resource_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<I>_adv_core \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n    (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest) \n    \\<turnstile>res RES (fuse rest) (core_init, rinit rest) \\<surd>", "by(rule WT_resource_of_oracle)(simp add: assms(3) WT_restD_rinit[OF assms(2)])"], ["proof (state)\nthis:\n  (\\<I>_adv_core \\<oplus>\\<^sub>\\<I> \\<I>_adv_rest) \\<oplus>\\<^sub>\\<I>\n  (\\<I>_usr_core \\<oplus>\\<^sub>\\<I> \\<I>_usr_rest) \n  \\<turnstile>res resource rest \\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "parametric_constant \n  fuse_parametric [transfer_rule]: fused_resource.fuse_case"], ["", "subsection \\<open>More helpful construction functions\\<close>"], ["", "context\n  fixes\n    core1 :: \"('s_core1, 'event1, 'iadv_core1, 'iusr_core1, 'oadv_core1, 'ousr_core1) core\" and\n    core2 :: \"('s_core2, 'event2, 'iadv_core2, 'iusr_core2, 'oadv_core2, 'ousr_core2) core\"\nbegin"], ["", "primcorec parallel_core :: \"\n  ('s_core1 \\<times> 's_core2, 'event1 + 'event2, \n   'iadv_core1 + 'iadv_core2, 'iusr_core1 + 'iusr_core2,\n   'oadv_core1 + 'oadv_core2, 'ousr_core1 + 'ousr_core2) core\" \n  where\n    \"cpoke parallel_core = parallel_handler (cpoke core1) (cpoke core2)\"\n  | \"cfunc_adv parallel_core = parallel_oracle (cfunc_adv core1) (cfunc_adv core2)\"\n  | \"cfunc_usr parallel_core = parallel_oracle (cfunc_usr core1) (cfunc_usr core2)\""], ["", "end"], ["", "context\n  fixes\n    cnv_adv :: \"'s_adv \\<Rightarrow> 'iadv \\<Rightarrow> ('oadv \\<times> 's_adv, 'iadv_core, 'oadv_core) gpv\" and\n    cnv_usr :: \"'s_usr \\<Rightarrow> 'iusr \\<Rightarrow> ('ousr \\<times> 's_usr, 'iusr_core, 'ousr_core) gpv\" and\n    core :: \"('s_core, 'event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\"\nbegin"], ["", "primcorec \n  attach_core :: \"(('s_adv \\<times> 's_usr) \\<times> 's_core, 'event, 'iadv, 'iusr, 'oadv, 'ousr) core\"\n  where\n    \"cpoke attach_core = (\\<lambda>(s_advusr, s_core) event. \n      map_spmf (\\<lambda>s_core'. (s_advusr, s_core')) (cpoke core s_core event))\"\n  | \"cfunc_adv attach_core = (\\<lambda>((s_adv, s_usr), s_core) iadv. \n      map_spmf \n        (\\<lambda>((oadv, s_adv'), s_core'). (oadv, ((s_adv', s_usr), s_core'))) \n        (exec_gpv (cfunc_adv core) (cnv_adv s_adv iadv) s_core))\"\n  | \"cfunc_usr attach_core = (\\<lambda>((s_adv, s_usr), s_core) iusr. \n      map_spmf \n        (\\<lambda>((ousr, s_usr'), s_core'). (ousr, ((s_adv, s_usr'), s_core'))) \n        (exec_gpv (cfunc_usr core) (cnv_usr s_usr iusr) s_core))\""], ["", "end"], ["", "lemma \n  attach_core_id_oracle_adv: \"cfunc_adv (attach_core 1\\<^sub>I cnv core) = \n    (\\<lambda>(s_cnv, s_core) q. map_spmf (\\<lambda>(out, s_core'). (out, s_cnv, s_core')) (cfunc_adv core s_core q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfunc_adv (attach_core 1\\<^sub>I cnv core) =\n    (\\<lambda>(s_cnv, s_core) q.\n        map_spmf (\\<lambda>(out, s_core'). (out, s_cnv, s_core'))\n         (cfunc_adv core s_core q))", "by(simp add: id_oracle_def split_def map_spmf_conv_bind_spmf)"], ["", "lemma \n  attach_core_id_oracle_usr: \"cfunc_usr (attach_core cnv 1\\<^sub>I core) = \n    (\\<lambda>(s_cnv, s_core) q. map_spmf (\\<lambda>(out, s_core'). (out, s_cnv, s_core')) (cfunc_usr core s_core q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfunc_usr (attach_core cnv 1\\<^sub>I core) =\n    (\\<lambda>(s_cnv, s_core) q.\n        map_spmf (\\<lambda>(out, s_core'). (out, s_cnv, s_core'))\n         (cfunc_usr core s_core q))", "by(simp add: id_oracle_def split_def map_spmf_conv_bind_spmf)"], ["", "context\n  fixes\n    rest1 :: \"('s_rest1, 'event1, 'iadv_rest1, 'iusr_rest1, 'oadv_rest1, 'ousr_rest1, 'more1) rest_scheme\" and\n    rest2 :: \"('s_rest2, 'event2, 'iadv_rest2, 'iusr_rest2, 'oadv_rest2, 'ousr_rest2, 'more2) rest_scheme\"\nbegin"], ["", "primcorec parallel_rest :: \"\n    ('s_rest1 \\<times> 's_rest2, 'event1 + 'event2, 'iadv_rest1 + 'iadv_rest2, 'iusr_rest1 + 'iusr_rest2, \n     'oadv_rest1 + 'oadv_rest2, 'ousr_rest1 + 'ousr_rest2, 'more1 \\<times> 'more2) rest_scheme\" \n  where\n    \"rinit parallel_rest = (rinit rest1, rinit rest2)\"\n  | \"rfunc_adv parallel_rest = parallel_eoracle (rfunc_adv rest1) (rfunc_adv rest2)\"\n  | \"rfunc_usr parallel_rest = parallel_eoracle (rfunc_usr rest1) (rfunc_usr rest2)\""], ["", "end"], ["", "lemma WT_parallel_rest [WT_intro]:\n  \"WT_rest (\\<I>_adv1 \\<oplus>\\<^sub>\\<I> \\<I>_adv2) (\\<I>_usr1 \\<oplus>\\<^sub>\\<I> \\<I>_usr2) (pred_prod I1 I2) (parallel_rest rest1 rest2)\"\n  if \"WT_rest \\<I>_adv1 \\<I>_usr1 I1 rest1\"\n  and \"WT_rest \\<I>_adv2 \\<I>_usr2 I2 rest2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. WT_rest (\\<I>_adv1 \\<oplus>\\<^sub>\\<I> \\<I>_adv2)\n     (\\<I>_usr1 \\<oplus>\\<^sub>\\<I> \\<I>_usr2) (pred_prod I1 I2)\n     (parallel_rest rest1 rest2)", "by(rule WT_rest.intros)\n    (auto 4 3 simp add: parallel_eoracle_def simp add: that[THEN WT_restD_rinit] dest: that[THEN WT_restD_rfunc_adv] that[THEN WT_restD_rfunc_usr])"], ["", "context\n  fixes\n    cnv_adv :: \"'s_adv \\<Rightarrow> 'iadv \\<Rightarrow> ('oadv \\<times> 's_adv, 'iadv_rest, 'oadv_rest) gpv\" and\n    cnv_usr :: \"'s_usr \\<Rightarrow> 'iusr \\<Rightarrow> ('ousr \\<times> 's_usr, 'iusr_rest, 'ousr_rest) gpv\" and\n    f_init :: \"'more \\<Rightarrow> 'more'\" and\n    rest :: \"('s_rest, 'event, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest, 'more) rest_scheme\"\nbegin"], ["", "primcorec \n  attach_rest :: \"\n    (('s_adv \\<times> 's_usr) \\<times> 's_rest, 'event, 'iadv, 'iusr, 'oadv, 'ousr, 'more') rest_scheme\"\n  where\n    \"rinit attach_rest = f_init (rinit rest)\"\n  | \"rfunc_adv attach_rest = (\\<lambda>((s_adv, s_usr), s_rest) iadv.\n      let orc_of = \\<lambda>orc (s, es) q. map_spmf (\\<lambda> ((out, e), s'). (out, s', es @ e)) (orc s q) in\n      let eorc_of = \\<lambda>((oadv, s_adv'), (s_rest', es)). ((oadv, es), ((s_adv', s_usr), s_rest')) in\n      map_spmf eorc_of (exec_gpv (orc_of (rfunc_adv rest)) (cnv_adv s_adv iadv) (s_rest, [])))\"\n  | \"rfunc_usr attach_rest = (\\<lambda>((s_adv, s_usr), s_rest) iusr. \n      let orc_of = \\<lambda>orc (s, es) q. map_spmf (\\<lambda> ((out, e), s'). (out, s', es @ e)) (orc s q) in\n      let eorc_of = \\<lambda>((ousr, s_usr'), (s_rest', es)). ((ousr, es), ((s_adv, s_usr'), s_rest')) in\n      map_spmf eorc_of (exec_gpv (orc_of (rfunc_usr rest)) (cnv_usr s_usr iusr) (s_rest, [])))\""], ["", "end"], ["", "lemma \n  attach_rest_id_oracle_adv: \"rfunc_adv (attach_rest 1\\<^sub>I cnv f_init rest) = \n    (\\<lambda>(s_cnv, s_core) q. map_spmf (\\<lambda>(out, s_core'). (out, s_cnv, s_core')) (rfunc_adv rest s_core q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rfunc_adv (attach_rest 1\\<^sub>I cnv f_init rest) =\n    (\\<lambda>(s_cnv, s_core) q.\n        map_spmf (\\<lambda>(out, s_core'). (out, s_cnv, s_core'))\n         (rfunc_adv rest s_core q))", "by(simp add: id_oracle_def split_def map_spmf_conv_bind_spmf fun_eq_iff)"], ["", "lemma\n  attach_rest_id_oracle_usr: \"rfunc_usr (attach_rest cnv 1\\<^sub>I f_init rest) = \n    (\\<lambda>(s_cnv, s_core) q. map_spmf (\\<lambda>(out, s_core'). (out, s_cnv, s_core')) (rfunc_usr rest s_core q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rfunc_usr (attach_rest cnv 1\\<^sub>I f_init rest) =\n    (\\<lambda>(s_cnv, s_core) q.\n        map_spmf (\\<lambda>(out, s_core'). (out, s_cnv, s_core'))\n         (rfunc_usr rest s_core q))", "by(simp add: id_oracle_def split_def map_spmf_conv_bind_spmf)"], ["", "section \\<open>Traces\\<close>"], ["", "type_synonym ('event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) trace_core =\n  \"('event + 'iadv_core \\<times> 'oadv_core + 'iusr_core \\<times> 'ousr_core) list \n  \\<Rightarrow> ('event \\<Rightarrow> real)\n  \\<times> ('iadv_core \\<Rightarrow> 'oadv_core spmf) \n  \\<times> ('iusr_core \\<Rightarrow> 'ousr_core spmf)\""], ["", "context \n  fixes core :: \"('s_core, 'event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\"\nbegin"], ["", "primrec trace_core' :: \"'s_core spmf \\<Rightarrow> ('event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) trace_core\" where\n  \"trace_core' S [] = \n   (\\<lambda>e. weight_spmf' (bind_spmf S (\\<lambda>s. cpoke core s e)),\n    \\<lambda>ia. bind_spmf S (\\<lambda>s. map_spmf fst (cfunc_adv core s ia)),\n    \\<lambda>iu. bind_spmf S (\\<lambda>s. map_spmf fst (cfunc_usr core s iu)))\"\n| \"trace_core' S (obs # tr) = (case obs of\n     Inl e \\<Rightarrow> trace_core' (mk_lossless (bind_spmf S (\\<lambda>s. cpoke core s e))) tr\n   | Inr (Inl (ia, oa)) \\<Rightarrow> trace_core' (cond_spmf_fst (bind_spmf S (\\<lambda>s. cfunc_adv core s ia)) oa) tr\n   | Inr (Inr (iu, ou)) \\<Rightarrow> trace_core' (cond_spmf_fst (bind_spmf S (\\<lambda>s. cfunc_usr core s iu)) ou) tr\n   )\""], ["", "end"], ["", "declare trace_core'.simps [simp del]"], ["", "case_of_simps trace_core'_unfold: trace_core'.simps[unfolded weight_spmf'_def]"], ["", "simps_of_case trace_core'_simps [simp]: trace_core'_unfold"], ["", "context includes lifting_syntax begin"], ["", "lemma trace_core'_parametric [transfer_rule]:\n  \"(rel_core' S E IA IU (=) (=) ===>\n      rel_spmf S ===>\n      list_all2 (rel_sum E (rel_sum (rel_prod IA (=)) (rel_prod IU (=)))) ===>\n      rel_prod (E ===> (=)) (rel_prod (IA ===> (=)) (IU ===> (=))))\n      trace_core' trace_core'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_core' S E IA IU (=) (=) ===>\n     rel_spmf S ===>\n     list_all2\n      (rel_sum E (rel_sum (rel_prod IA (=)) (rel_prod IU (=)))) ===>\n     rel_prod (E ===> (=)) (rel_prod (IA ===> (=)) (IU ===> (=))))\n     trace_core' trace_core'", "unfolding trace_core'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_core' S E IA IU (=) (=) ===>\n     rel_spmf S ===>\n     list_all2\n      (rel_sum E (rel_sum (rel_prod IA (=)) (rel_prod IU (=)))) ===>\n     rel_prod (E ===> (=)) (rel_prod (IA ===> (=)) (IU ===> (=))))\n     (\\<lambda>core uu uua.\n         rec_list\n          (\\<lambda>S.\n              (\\<lambda>e.\n                  weight_spmf' (S \\<bind> (\\<lambda>s. cpoke core s e)),\n               \\<lambda>ia.\n                  S \\<bind>\n                  (\\<lambda>s. map_spmf fst (cfunc_adv core s ia)),\n               \\<lambda>iu.\n                  S \\<bind>\n                  (\\<lambda>s. map_spmf fst (cfunc_usr core s iu))))\n          (\\<lambda>obs tr tra S.\n              case obs of\n              Inl e \\<Rightarrow>\n                tra (mk_lossless (S \\<bind> (\\<lambda>s. cpoke core s e)))\n              | Inr (Inl (ia, oa)) \\<Rightarrow>\n                  tra (cond_spmf_fst\n                        (S \\<bind> (\\<lambda>s. cfunc_adv core s ia)) oa)\n              | Inr (Inr (iu, ou)) \\<Rightarrow>\n                  tra (cond_spmf_fst\n                        (S \\<bind> (\\<lambda>s. cfunc_usr core s iu)) ou))\n          uua uu)\n     (\\<lambda>core uu uua.\n         rec_list\n          (\\<lambda>S.\n              (\\<lambda>e.\n                  weight_spmf' (S \\<bind> (\\<lambda>s. cpoke core s e)),\n               \\<lambda>ia.\n                  S \\<bind>\n                  (\\<lambda>s. map_spmf fst (cfunc_adv core s ia)),\n               \\<lambda>iu.\n                  S \\<bind>\n                  (\\<lambda>s. map_spmf fst (cfunc_usr core s iu))))\n          (\\<lambda>obs tr tra S.\n              case obs of\n              Inl e \\<Rightarrow>\n                tra (mk_lossless (S \\<bind> (\\<lambda>s. cpoke core s e)))\n              | Inr (Inl (ia, oa)) \\<Rightarrow>\n                  tra (cond_spmf_fst\n                        (S \\<bind> (\\<lambda>s. cfunc_adv core s ia)) oa)\n              | Inr (Inr (iu, ou)) \\<Rightarrow>\n                  tra (cond_spmf_fst\n                        (S \\<bind> (\\<lambda>s. cfunc_usr core s iu)) ou))\n          uua uu)", "by transfer_prover"], ["", "definition trace_core_eq \n  :: \"('s_core, 'event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\n  \\<Rightarrow> ('s_core', 'event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\n  \\<Rightarrow> 'event set \\<Rightarrow> 'iadv_core set \\<Rightarrow> 'iusr_core set\n  \\<Rightarrow> 's_core spmf \\<Rightarrow> 's_core' spmf \\<Rightarrow> bool\" where\n  \"trace_core_eq core1 core2 E IA IU p q \\<longleftrightarrow>\n  (\\<forall>tr. set tr \\<subseteq> E <+> (IA \\<times> UNIV) <+> (IU \\<times> UNIV) \\<longrightarrow> \n   rel_prod (eq_onp (\\<lambda>e. e \\<in> E) ===> (=)) (rel_prod (eq_onp (\\<lambda>ia. ia \\<in> IA) ===> (=)) (eq_onp (\\<lambda>iu. iu \\<in> IU) ===> (=)))\n     (trace_core' core1 p tr) (trace_core' core2 q tr))\""], ["", "end"], ["", "lemma trace_core_eqD:\n  assumes \"trace_core_eq core1 core2 E IA IU p q\"\n    and \"set tr \\<subseteq> E <+> (IA \\<times> UNIV) <+> (IU \\<times> UNIV)\"\n  shows trace_core_eqD_cpoke: \n      \"e \\<in> E \\<Longrightarrow> fst (trace_core' core1 p tr) e = fst (trace_core' core2 q tr) e\"\n    and trace_core_eqD_cfunc_adv: \n      \"ia \\<in> IA \\<Longrightarrow> fst (snd (trace_core' core1 p tr)) ia = fst (snd (trace_core' core2 q tr)) ia\"\n    and trace_core_eqD_cfunc_usr:\n      \"iu \\<in> IU \\<Longrightarrow> snd (snd (trace_core' core1 p tr)) iu = snd (snd (trace_core' core2 q tr)) iu\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (e \\<in> E \\<Longrightarrow>\n     fst (trace_core' core1 p tr) e = fst (trace_core' core2 q tr) e) &&&\n    (ia \\<in> IA \\<Longrightarrow>\n     fst (snd (trace_core' core1 p tr)) ia =\n     fst (snd (trace_core' core2 q tr)) ia) &&&\n    (iu \\<in> IU \\<Longrightarrow>\n     snd (snd (trace_core' core1 p tr)) iu =\n     snd (snd (trace_core' core2 q tr)) iu)", "using assms"], ["proof (prove)\nusing this:\n  trace_core_eq core1 core2 E IA IU p q\n  set tr \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\n\ngoal (1 subgoal):\n 1. (e \\<in> E \\<Longrightarrow>\n     fst (trace_core' core1 p tr) e = fst (trace_core' core2 q tr) e) &&&\n    (ia \\<in> IA \\<Longrightarrow>\n     fst (snd (trace_core' core1 p tr)) ia =\n     fst (snd (trace_core' core2 q tr)) ia) &&&\n    (iu \\<in> IU \\<Longrightarrow>\n     snd (snd (trace_core' core1 p tr)) iu =\n     snd (snd (trace_core' core2 q tr)) iu)", "by(auto simp add: trace_core_eq_def rel_fun_def eq_onp_def rel_prod_sel)"], ["", "lemma trace_core_eqI:\n  assumes \"\\<And>tr e. \\<lbrakk> set tr \\<subseteq> E <+> (IA \\<times> UNIV) <+> (IU \\<times> UNIV); e \\<in> E \\<rbrakk> \n     \\<Longrightarrow> fst (trace_core' core1 p tr) e = fst (trace_core' core2 q tr) e\"\n    and \"\\<And>tr ia. \\<lbrakk> set tr \\<subseteq> E <+> (IA \\<times> UNIV) <+> (IU \\<times> UNIV); ia \\<in> IA \\<rbrakk>\n     \\<Longrightarrow> fst (snd (trace_core' core1 p tr)) ia = fst (snd (trace_core' core2 q tr)) ia\"\n    and \"\\<And>tr iu. \\<lbrakk> set tr \\<subseteq> E <+> (IA \\<times> UNIV) <+> (IU \\<times> UNIV); iu \\<in> IU \\<rbrakk>\n     \\<Longrightarrow> snd (snd (trace_core' core1 p tr)) iu = snd (snd (trace_core' core2 q tr)) iu\"\n  shows \"trace_core_eq core1 core2 E IA IU p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_core_eq core1 core2 E IA IU p q", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?tr \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV;\n   ?e \\<in> E\\<rbrakk>\n  \\<Longrightarrow> fst (trace_core' core1 p ?tr) ?e =\n                    fst (trace_core' core2 q ?tr) ?e\n  \\<lbrakk>set ?tr \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV;\n   ?ia \\<in> IA\\<rbrakk>\n  \\<Longrightarrow> fst (snd (trace_core' core1 p ?tr)) ?ia =\n                    fst (snd (trace_core' core2 q ?tr)) ?ia\n  \\<lbrakk>set ?tr \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV;\n   ?iu \\<in> IU\\<rbrakk>\n  \\<Longrightarrow> snd (snd (trace_core' core1 p ?tr)) ?iu =\n                    snd (snd (trace_core' core2 q ?tr)) ?iu\n\ngoal (1 subgoal):\n 1. trace_core_eq core1 core2 E IA IU p q", "by(auto simp add: trace_core_eq_def rel_fun_def eq_onp_def rel_prod_sel)"], ["", "lemma trace_core_return_pmf_None [simp]:\n  \"trace_core' core (return_pmf None) tr = (\\<lambda>_. 0, \\<lambda>_. return_pmf None, \\<lambda>_. return_pmf None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_core' core (return_pmf None) tr =\n    (\\<lambda>_. 0, \\<lambda>_. return_pmf None,\n     \\<lambda>_. return_pmf None)", "by(induction tr)(simp_all add: trace_core'.simps split: sum.split)"], ["", "lemma rel_core'_into_trace_core_eq: \"trace_core_eq core core' E IA IU p q\" \n  if \"rel_core' S (eq_onp (\\<lambda>e. e \\<in> E)) (eq_onp (\\<lambda>ia. ia \\<in> IA)) (eq_onp (\\<lambda>iu. iu \\<in> IU)) (=) (=) core core'\"\n     \"rel_spmf S p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_core_eq core core' E IA IU p q", "using trace_core'_parametric[THEN rel_funD, THEN rel_funD, OF that]"], ["proof (prove)\nusing this:\n  rel_fun\n   (list_all2\n     (rel_sum (eq_onp (\\<lambda>e. e \\<in> E))\n       (rel_sum (rel_prod (eq_onp (\\<lambda>ia. ia \\<in> IA)) (=))\n         (rel_prod (eq_onp (\\<lambda>iu. iu \\<in> IU)) (=)))))\n   (rel_prod (rel_fun (eq_onp (\\<lambda>e. e \\<in> E)) (=))\n     (rel_prod (rel_fun (eq_onp (\\<lambda>ia. ia \\<in> IA)) (=))\n       (rel_fun (eq_onp (\\<lambda>iu. iu \\<in> IU)) (=))))\n   (trace_core' core p) (trace_core' core' q)\n\ngoal (1 subgoal):\n 1. trace_core_eq core core' E IA IU p q", "unfolding trace_core_eq_def"], ["proof (prove)\nusing this:\n  rel_fun\n   (list_all2\n     (rel_sum (eq_onp (\\<lambda>e. e \\<in> E))\n       (rel_sum (rel_prod (eq_onp (\\<lambda>ia. ia \\<in> IA)) (=))\n         (rel_prod (eq_onp (\\<lambda>iu. iu \\<in> IU)) (=)))))\n   (rel_prod (rel_fun (eq_onp (\\<lambda>e. e \\<in> E)) (=))\n     (rel_prod (rel_fun (eq_onp (\\<lambda>ia. ia \\<in> IA)) (=))\n       (rel_fun (eq_onp (\\<lambda>iu. iu \\<in> IU)) (=))))\n   (trace_core' core p) (trace_core' core' q)\n\ngoal (1 subgoal):\n 1. \\<forall>tr.\n       set tr\n       \\<subseteq> E <+>\n                   IA \\<times> UNIV <+> IU \\<times> UNIV \\<longrightarrow>\n       rel_prod (rel_fun (eq_onp (\\<lambda>e. e \\<in> E)) (=))\n        (rel_prod (rel_fun (eq_onp (\\<lambda>ia. ia \\<in> IA)) (=))\n          (rel_fun (eq_onp (\\<lambda>iu. iu \\<in> IU)) (=)))\n        (trace_core' core p tr) (trace_core' core' q tr)", "apply(intro strip)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tr.\n       \\<lbrakk>rel_fun\n                 (list_all2\n                   (rel_sum (eq_onp (\\<lambda>e. e \\<in> E))\n                     (rel_sum\n                       (rel_prod (eq_onp (\\<lambda>ia. ia \\<in> IA)) (=))\n                       (rel_prod (eq_onp (\\<lambda>iu. iu \\<in> IU)) (=)))))\n                 (rel_prod (rel_fun (eq_onp (\\<lambda>e. e \\<in> E)) (=))\n                   (rel_prod\n                     (rel_fun (eq_onp (\\<lambda>ia. ia \\<in> IA)) (=))\n                     (rel_fun (eq_onp (\\<lambda>iu. iu \\<in> IU)) (=))))\n                 (trace_core' core p) (trace_core' core' q);\n        set tr\n        \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> rel_prod\n                          (rel_fun (eq_onp (\\<lambda>e. e \\<in> E)) (=))\n                          (rel_prod\n                            (rel_fun (eq_onp (\\<lambda>ia. ia \\<in> IA))\n                              (=))\n                            (rel_fun (eq_onp (\\<lambda>iu. iu \\<in> IU))\n                              (=)))\n                          (trace_core' core p tr) (trace_core' core' q tr)", "subgoal for tr"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel_fun\n              (list_all2\n                (rel_sum (eq_onp (\\<lambda>e. e \\<in> E))\n                  (rel_sum\n                    (rel_prod (eq_onp (\\<lambda>ia. ia \\<in> IA)) (=))\n                    (rel_prod (eq_onp (\\<lambda>iu. iu \\<in> IU)) (=)))))\n              (rel_prod (rel_fun (eq_onp (\\<lambda>e. e \\<in> E)) (=))\n                (rel_prod (rel_fun (eq_onp (\\<lambda>ia. ia \\<in> IA)) (=))\n                  (rel_fun (eq_onp (\\<lambda>iu. iu \\<in> IU)) (=))))\n              (trace_core' core p) (trace_core' core' q);\n     set tr \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\\<rbrakk>\n    \\<Longrightarrow> rel_prod\n                       (rel_fun (eq_onp (\\<lambda>e. e \\<in> E)) (=))\n                       (rel_prod\n                         (rel_fun (eq_onp (\\<lambda>ia. ia \\<in> IA)) (=))\n                         (rel_fun (eq_onp (\\<lambda>iu. iu \\<in> IU)) (=)))\n                       (trace_core' core p tr) (trace_core' core' q tr)", "apply(simp add: eq_onp_True[symmetric] prod.rel_eq_onp sum.rel_eq_onp list.rel_eq_onp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel_fun\n              (eq_onp\n                (list_all\n                  (pred_sum (\\<lambda>e. e \\<in> E)\n                    (pred_sum\n                      (pred_prod (\\<lambda>ia. ia \\<in> IA)\n                        (\\<lambda>_. True))\n                      (pred_prod (\\<lambda>iu. iu \\<in> IU)\n                        (\\<lambda>_. True))))))\n              (rel_prod\n                (rel_fun (eq_onp (\\<lambda>e. e \\<in> E))\n                  (eq_onp (\\<lambda>_. True)))\n                (rel_prod\n                  (rel_fun (eq_onp (\\<lambda>ia. ia \\<in> IA))\n                    (eq_onp (\\<lambda>_. True)))\n                  (rel_fun (eq_onp (\\<lambda>iu. iu \\<in> IU))\n                    (eq_onp (\\<lambda>_. True)))))\n              (trace_core' core p) (trace_core' core' q);\n     set tr \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\\<rbrakk>\n    \\<Longrightarrow> rel_prod\n                       (rel_fun (eq_onp (\\<lambda>e. e \\<in> E))\n                         (eq_onp (\\<lambda>_. True)))\n                       (rel_prod\n                         (rel_fun (eq_onp (\\<lambda>ia. ia \\<in> IA))\n                           (eq_onp (\\<lambda>_. True)))\n                         (rel_fun (eq_onp (\\<lambda>iu. iu \\<in> IU))\n                           (eq_onp (\\<lambda>_. True))))\n                       (trace_core' core p tr) (trace_core' core' q tr)", "apply(auto 4 3 simp add: eq_onp_def list_all_iff dest: rel_funD[where x=tr and y=tr])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma trace_core_eq_simI:\n  fixes core1 :: \"('s_core, 'event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\"\n    and core2 :: \"('s_core', 'event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\"\n    and S :: \"'s_core spmf \\<Rightarrow> 's_core' spmf \\<Rightarrow> bool\"\n  assumes start: \"S p q\"\n    and step_cpoke: \"\\<And>p q e. \\<lbrakk> S p q; e \\<in> E \\<rbrakk> \\<Longrightarrow> \n      weight_spmf (bind_spmf p (\\<lambda>s. cpoke core1 s e)) = weight_spmf (bind_spmf q (\\<lambda>s. cpoke core2 s e))\"\n    and sim_cpoke: \"\\<And>p q e. \\<lbrakk> S p q; e \\<in> E \\<rbrakk> \\<Longrightarrow> \n      S (mk_lossless (bind_spmf p (\\<lambda>s. cpoke core1 s e))) (mk_lossless (bind_spmf q (\\<lambda>s. cpoke core2 s e)))\"\n    and step_cfunc_adv: \"\\<And>p q ia. \\<lbrakk> S p q; ia \\<in> IA \\<rbrakk> \\<Longrightarrow> \n      bind_spmf p (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ia)) = bind_spmf q (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\"\n    and sim_cfunc_adv: \"\\<And>p q ia s1 s2 s1' s2' oa. \\<lbrakk> S p q; ia \\<in> IA; \n      s1 \\<in> set_spmf p; s2 \\<in> set_spmf q; (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia); (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia) \\<rbrakk>\n      \\<Longrightarrow> S (cond_spmf_fst (bind_spmf p (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa) (cond_spmf_fst (bind_spmf q (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa)\"\n    and step_cfunc_usr: \"\\<And>p q iu. \\<lbrakk> S p q; iu \\<in> IU \\<rbrakk> \\<Longrightarrow> \n      bind_spmf p (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 iu)) = bind_spmf q (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\"\n    and sim_cfunc_usr: \"\\<And>p q iu s1 s2 s1' s2' ou. \\<lbrakk> S p q; iu \\<in> IU; \n      s1 \\<in> set_spmf p; s2 \\<in> set_spmf q; (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu); (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu) \\<rbrakk>\n      \\<Longrightarrow> S (cond_spmf_fst (bind_spmf p (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou) (cond_spmf_fst (bind_spmf q (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou)\"\n  shows \"trace_core_eq core1 core2 E IA IU p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_core_eq core1 core2 E IA IU p q", "proof(rule trace_core_eqI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>tr e.\n       \\<lbrakk>set tr\n                \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        e \\<in> E\\<rbrakk>\n       \\<Longrightarrow> fst (trace_core' core1 p tr) e =\n                         fst (trace_core' core2 q tr) e\n 2. \\<And>tr ia.\n       \\<lbrakk>set tr\n                \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> fst (snd (trace_core' core1 p tr)) ia =\n                         fst (snd (trace_core' core2 q tr)) ia\n 3. \\<And>tr iu.\n       \\<lbrakk>set tr\n                \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> snd (snd (trace_core' core1 p tr)) iu =\n                         snd (snd (trace_core' core2 q tr)) iu", "fix tr :: \" ('event + 'iadv_core \\<times> 'oadv_core + 'iusr_core \\<times> 'ousr_core) list\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>tr e.\n       \\<lbrakk>set tr\n                \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        e \\<in> E\\<rbrakk>\n       \\<Longrightarrow> fst (trace_core' core1 p tr) e =\n                         fst (trace_core' core2 q tr) e\n 2. \\<And>tr ia.\n       \\<lbrakk>set tr\n                \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> fst (snd (trace_core' core1 p tr)) ia =\n                         fst (snd (trace_core' core2 q tr)) ia\n 3. \\<And>tr iu.\n       \\<lbrakk>set tr\n                \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> snd (snd (trace_core' core1 p tr)) iu =\n                         snd (snd (trace_core' core2 q tr)) iu", "assume \"set tr \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\""], ["proof (state)\nthis:\n  set tr \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\n\ngoal (3 subgoals):\n 1. \\<And>tr e.\n       \\<lbrakk>set tr\n                \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        e \\<in> E\\<rbrakk>\n       \\<Longrightarrow> fst (trace_core' core1 p tr) e =\n                         fst (trace_core' core2 q tr) e\n 2. \\<And>tr ia.\n       \\<lbrakk>set tr\n                \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> fst (snd (trace_core' core1 p tr)) ia =\n                         fst (snd (trace_core' core2 q tr)) ia\n 3. \\<And>tr iu.\n       \\<lbrakk>set tr\n                \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> snd (snd (trace_core' core1 p tr)) iu =\n                         snd (snd (trace_core' core2 q tr)) iu", "then"], ["proof (chain)\npicking this:\n  set tr \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV", "have \"(\\<forall>e\\<in>E. fst (trace_core' core1 p tr) e = fst (trace_core' core2 q tr) e) \\<and>\n     (\\<forall>ia\\<in>IA. fst (snd (trace_core' core1 p tr)) ia = fst (snd (trace_core' core2 q tr)) ia) \\<and>\n     (\\<forall>iu\\<in>IU. snd (snd (trace_core' core1 p tr)) iu = snd (snd (trace_core' core2 q tr)) iu)\""], ["proof (prove)\nusing this:\n  set tr \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\n\ngoal (1 subgoal):\n 1. (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p tr) e =\n        fst (trace_core' core2 q tr) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p tr)) ia =\n        fst (snd (trace_core' core2 q tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p tr)) iu =\n        snd (snd (trace_core' core2 q tr)) iu)", "using start"], ["proof (prove)\nusing this:\n  set tr \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\n  S p q\n\ngoal (1 subgoal):\n 1. (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p tr) e =\n        fst (trace_core' core2 q tr) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p tr)) ia =\n        fst (snd (trace_core' core2 q tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p tr)) iu =\n        snd (snd (trace_core' core2 q tr)) iu)", "proof(induction tr arbitrary: p q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p q.\n       \\<lbrakk>set []\n                \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        S p q\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p []) e =\n                             fst (trace_core' core2 q []) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p [])) ia =\n                             fst (snd (trace_core' core2 q [])) ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p [])) iu =\n                             snd (snd (trace_core' core2 q [])) iu)\n 2. \\<And>a tr p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>set tr\n                            \\<subseteq> E <+>\n  IA \\<times> UNIV <+> IU \\<times> UNIV;\n                    S p q\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>e\\<in>E.\n   fst (trace_core' core1 p tr) e = fst (trace_core' core2 q tr) e) \\<and>\n                                     (\\<forall>ia\\<in>IA.\n   fst (snd (trace_core' core1 p tr)) ia =\n   fst (snd (trace_core' core2 q tr)) ia) \\<and>\n                                     (\\<forall>iu\\<in>IU.\n   snd (snd (trace_core' core1 p tr)) iu =\n   snd (snd (trace_core' core2 q tr)) iu);\n        set (a # tr)\n        \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        S p q\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)", "case Nil"], ["proof (state)\nthis:\n  set [] \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\n  S p q\n\ngoal (2 subgoals):\n 1. \\<And>p q.\n       \\<lbrakk>set []\n                \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        S p q\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p []) e =\n                             fst (trace_core' core2 q []) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p [])) ia =\n                             fst (snd (trace_core' core2 q [])) ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p [])) iu =\n                             snd (snd (trace_core' core2 q [])) iu)\n 2. \\<And>a tr p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>set tr\n                            \\<subseteq> E <+>\n  IA \\<times> UNIV <+> IU \\<times> UNIV;\n                    S p q\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>e\\<in>E.\n   fst (trace_core' core1 p tr) e = fst (trace_core' core2 q tr) e) \\<and>\n                                     (\\<forall>ia\\<in>IA.\n   fst (snd (trace_core' core1 p tr)) ia =\n   fst (snd (trace_core' core2 q tr)) ia) \\<and>\n                                     (\\<forall>iu\\<in>IU.\n   snd (snd (trace_core' core1 p tr)) iu =\n   snd (snd (trace_core' core2 q tr)) iu);\n        set (a # tr)\n        \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        S p q\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)", "then"], ["proof (chain)\npicking this:\n  set [] \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\n  S p q", "show ?case"], ["proof (prove)\nusing this:\n  set [] \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\n  S p q\n\ngoal (1 subgoal):\n 1. (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p []) e =\n        fst (trace_core' core2 q []) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p [])) ia =\n        fst (snd (trace_core' core2 q [])) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p [])) iu =\n        snd (snd (trace_core' core2 q [])) iu)", "by(simp add: step_cpoke step_cfunc_adv step_cfunc_usr)"], ["proof (state)\nthis:\n  (\\<forall>e\\<in>E.\n      fst (trace_core' core1 p []) e =\n      fst (trace_core' core2 q []) e) \\<and>\n  (\\<forall>ia\\<in>IA.\n      fst (snd (trace_core' core1 p [])) ia =\n      fst (snd (trace_core' core2 q [])) ia) \\<and>\n  (\\<forall>iu\\<in>IU.\n      snd (snd (trace_core' core1 p [])) iu =\n      snd (snd (trace_core' core2 q [])) iu)\n\ngoal (1 subgoal):\n 1. \\<And>a tr p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>set tr\n                            \\<subseteq> E <+>\n  IA \\<times> UNIV <+> IU \\<times> UNIV;\n                    S p q\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>e\\<in>E.\n   fst (trace_core' core1 p tr) e = fst (trace_core' core2 q tr) e) \\<and>\n                                     (\\<forall>ia\\<in>IA.\n   fst (snd (trace_core' core1 p tr)) ia =\n   fst (snd (trace_core' core2 q tr)) ia) \\<and>\n                                     (\\<forall>iu\\<in>IU.\n   snd (snd (trace_core' core1 p tr)) iu =\n   snd (snd (trace_core' core2 q tr)) iu);\n        set (a # tr)\n        \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        S p q\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a tr p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>set tr\n                            \\<subseteq> E <+>\n  IA \\<times> UNIV <+> IU \\<times> UNIV;\n                    S p q\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>e\\<in>E.\n   fst (trace_core' core1 p tr) e = fst (trace_core' core2 q tr) e) \\<and>\n                                     (\\<forall>ia\\<in>IA.\n   fst (snd (trace_core' core1 p tr)) ia =\n   fst (snd (trace_core' core2 q tr)) ia) \\<and>\n                                     (\\<forall>iu\\<in>IU.\n   snd (snd (trace_core' core1 p tr)) iu =\n   snd (snd (trace_core' core2 q tr)) iu);\n        set (a # tr)\n        \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        S p q\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)", "case (Cons a tr)"], ["proof (state)\nthis:\n  \\<lbrakk>set tr \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV;\n   S ?p ?q\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>e\\<in>E.\n                        fst (trace_core' core1 ?p tr) e =\n                        fst (trace_core' core2 ?q tr) e) \\<and>\n                    (\\<forall>ia\\<in>IA.\n                        fst (snd (trace_core' core1 ?p tr)) ia =\n                        fst (snd (trace_core' core2 ?q tr)) ia) \\<and>\n                    (\\<forall>iu\\<in>IU.\n                        snd (snd (trace_core' core1 ?p tr)) iu =\n                        snd (snd (trace_core' core2 ?q tr)) iu)\n  set (a # tr) \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\n  S p q\n\ngoal (1 subgoal):\n 1. \\<And>a tr p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>set tr\n                            \\<subseteq> E <+>\n  IA \\<times> UNIV <+> IU \\<times> UNIV;\n                    S p q\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>e\\<in>E.\n   fst (trace_core' core1 p tr) e = fst (trace_core' core2 q tr) e) \\<and>\n                                     (\\<forall>ia\\<in>IA.\n   fst (snd (trace_core' core1 p tr)) ia =\n   fst (snd (trace_core' core2 q tr)) ia) \\<and>\n                                     (\\<forall>iu\\<in>IU.\n   snd (snd (trace_core' core1 p tr)) iu =\n   snd (snd (trace_core' core2 q tr)) iu);\n        set (a # tr)\n        \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        S p q\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)", "from Cons.prems(1)"], ["proof (chain)\npicking this:\n  set (a # tr) \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV", "have tr: \"set tr \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\""], ["proof (prove)\nusing this:\n  set (a # tr) \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\n\ngoal (1 subgoal):\n 1. set tr \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV", "by simp"], ["proof (state)\nthis:\n  set tr \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>a tr p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>set tr\n                            \\<subseteq> E <+>\n  IA \\<times> UNIV <+> IU \\<times> UNIV;\n                    S p q\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>e\\<in>E.\n   fst (trace_core' core1 p tr) e = fst (trace_core' core2 q tr) e) \\<and>\n                                     (\\<forall>ia\\<in>IA.\n   fst (snd (trace_core' core1 p tr)) ia =\n   fst (snd (trace_core' core2 q tr)) ia) \\<and>\n                                     (\\<forall>iu\\<in>IU.\n   snd (snd (trace_core' core1 p tr)) iu =\n   snd (snd (trace_core' core2 q tr)) iu);\n        set (a # tr)\n        \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        S p q\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)", "from Cons.prems(1)"], ["proof (chain)\npicking this:\n  set (a # tr) \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV", "consider (cpoke) e where \"a = Inl e\" \"e \\<in> E\"\n      | (cfunc_adv) ia oa where \"a = Inr (Inl (ia, oa))\" \"ia \\<in> IA\"\n      | (cfunc_usr) iu ou where \"a = Inr (Inr (iu, ou))\" \"iu \\<in> IU\""], ["proof (prove)\nusing this:\n  set (a # tr) \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>a = Inl e; e \\<in> E\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>ia oa.\n        \\<lbrakk>a = Inr (Inl (ia, oa)); ia \\<in> IA\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>iu ou.\n        \\<lbrakk>a = Inr (Inr (iu, ou)); iu \\<in> IU\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>e.\n              \\<lbrakk>a = Inl e; e \\<in> E\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>ia oa.\n      \\<lbrakk>a = Inr (Inl (ia, oa)); ia \\<in> IA\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>iu ou.\n      \\<lbrakk>a = Inr (Inr (iu, ou)); iu \\<in> IU\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>a tr p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>set tr\n                            \\<subseteq> E <+>\n  IA \\<times> UNIV <+> IU \\<times> UNIV;\n                    S p q\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>e\\<in>E.\n   fst (trace_core' core1 p tr) e = fst (trace_core' core2 q tr) e) \\<and>\n                                     (\\<forall>ia\\<in>IA.\n   fst (snd (trace_core' core1 p tr)) ia =\n   fst (snd (trace_core' core2 q tr)) ia) \\<and>\n                                     (\\<forall>iu\\<in>IU.\n   snd (snd (trace_core' core1 p tr)) iu =\n   snd (snd (trace_core' core2 q tr)) iu);\n        set (a # tr)\n        \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        S p q\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>e.\n              \\<lbrakk>a = Inl e; e \\<in> E\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>ia oa.\n      \\<lbrakk>a = Inr (Inl (ia, oa)); ia \\<in> IA\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>iu ou.\n      \\<lbrakk>a = Inr (Inr (iu, ou)); iu \\<in> IU\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>e.\n              \\<lbrakk>a = Inl e; e \\<in> E\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>ia oa.\n      \\<lbrakk>a = Inr (Inl (ia, oa)); ia \\<in> IA\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>iu ou.\n      \\<lbrakk>a = Inr (Inr (iu, ou)); iu \\<in> IU\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>a = Inl e; e \\<in> E\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)\n 2. \\<And>ia oa.\n       \\<lbrakk>a = Inr (Inl (ia, oa)); ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)\n 3. \\<And>iu ou.\n       \\<lbrakk>a = Inr (Inr (iu, ou)); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)", "case cpoke"], ["proof (state)\nthis:\n  a = Inl e\n  e \\<in> E\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>a = Inl e; e \\<in> E\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)\n 2. \\<And>ia oa.\n       \\<lbrakk>a = Inr (Inl (ia, oa)); ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)\n 3. \\<And>iu ou.\n       \\<lbrakk>a = Inr (Inr (iu, ou)); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)", "then"], ["proof (chain)\npicking this:\n  a = Inl e\n  e \\<in> E", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Inl e\n  e \\<in> E\n\ngoal (1 subgoal):\n 1. (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "using tr Cons.prems(2)"], ["proof (prove)\nusing this:\n  a = Inl e\n  e \\<in> E\n  set tr \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\n  S p q\n\ngoal (1 subgoal):\n 1. (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "by(auto simp add: sim_cpoke intro!: Cons.IH)"], ["proof (state)\nthis:\n  (\\<forall>e\\<in>E.\n      fst (trace_core' core1 p (a # tr)) e =\n      fst (trace_core' core2 q (a # tr)) e) \\<and>\n  (\\<forall>ia\\<in>IA.\n      fst (snd (trace_core' core1 p (a # tr))) ia =\n      fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n  (\\<forall>iu\\<in>IU.\n      snd (snd (trace_core' core1 p (a # tr))) iu =\n      snd (snd (trace_core' core2 q (a # tr))) iu)\n\ngoal (2 subgoals):\n 1. \\<And>ia oa.\n       \\<lbrakk>a = Inr (Inl (ia, oa)); ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)\n 2. \\<And>iu ou.\n       \\<lbrakk>a = Inr (Inr (iu, ou)); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia oa.\n       \\<lbrakk>a = Inr (Inl (ia, oa)); ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)\n 2. \\<And>iu ou.\n       \\<lbrakk>a = Inr (Inr (iu, ou)); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)", "case cfunc_adv"], ["proof (state)\nthis:\n  a = Inr (Inl (ia, oa))\n  ia \\<in> IA\n\ngoal (2 subgoals):\n 1. \\<And>ia oa.\n       \\<lbrakk>a = Inr (Inl (ia, oa)); ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)\n 2. \\<And>iu ou.\n       \\<lbrakk>a = Inr (Inr (iu, ou)); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)", "let ?p = \"bind_spmf p (\\<lambda>s1. cfunc_adv core1 s1 ia)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia oa.\n       \\<lbrakk>a = Inr (Inl (ia, oa)); ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)\n 2. \\<And>iu ou.\n       \\<lbrakk>a = Inr (Inr (iu, ou)); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)", "let ?q = \"bind_spmf q (\\<lambda>s2. cfunc_adv core2 s2 ia)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia oa.\n       \\<lbrakk>a = Inr (Inl (ia, oa)); ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)\n 2. \\<And>iu ou.\n       \\<lbrakk>a = Inr (Inr (iu, ou)); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "proof(cases \"oa \\<in> fst ` set_spmf ?p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. oa \\<in> fst `\n             set_spmf\n              (p \\<bind>\n               (\\<lambda>s1. cfunc_adv core1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)\n 2. oa \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. cfunc_adv core1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "case True"], ["proof (state)\nthis:\n  oa \\<in> fst ` set_spmf (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n\ngoal (2 subgoals):\n 1. oa \\<in> fst `\n             set_spmf\n              (p \\<bind>\n               (\\<lambda>s1. cfunc_adv core1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)\n 2. oa \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. cfunc_adv core1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "with step_cfunc_adv[OF Cons.prems(2) cfunc_adv(2), THEN arg_cong[where f=set_spmf]]"], ["proof (chain)\npicking this:\n  set_spmf (p \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ia))) =\n  set_spmf (q \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia)))\n  oa \\<in> fst ` set_spmf (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))", "have \"oa \\<in> fst ` set_spmf ?q\""], ["proof (prove)\nusing this:\n  set_spmf (p \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ia))) =\n  set_spmf (q \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia)))\n  oa \\<in> fst ` set_spmf (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n\ngoal (1 subgoal):\n 1. oa \\<in> fst ` set_spmf (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))", "unfolding set_map_spmf[symmetric]"], ["proof (prove)\nusing this:\n  set_spmf (p \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ia))) =\n  set_spmf (q \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia)))\n  oa \\<in> set_spmf\n            (map_spmf fst (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)))\n\ngoal (1 subgoal):\n 1. oa \\<in> set_spmf\n              (map_spmf fst\n                (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)))", "by(simp only: map_bind_spmf o_def)"], ["proof (state)\nthis:\n  oa \\<in> fst ` set_spmf (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n\ngoal (2 subgoals):\n 1. oa \\<in> fst `\n             set_spmf\n              (p \\<bind>\n               (\\<lambda>s1. cfunc_adv core1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)\n 2. oa \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. cfunc_adv core1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "then"], ["proof (chain)\npicking this:\n  oa \\<in> fst ` set_spmf (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))", "show ?thesis"], ["proof (prove)\nusing this:\n  oa \\<in> fst ` set_spmf (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n\ngoal (1 subgoal):\n 1. (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "using True Cons.prems cfunc_adv"], ["proof (prove)\nusing this:\n  oa \\<in> fst ` set_spmf (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n  oa \\<in> fst ` set_spmf (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n  set (a # tr) \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\n  S p q\n  a = Inr (Inl (ia, oa))\n  ia \\<in> IA\n\ngoal (1 subgoal):\n 1. (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "by(clarsimp)(rule Cons.IH; blast intro: sim_cfunc_adv)"], ["proof (state)\nthis:\n  (\\<forall>e\\<in>E.\n      fst (trace_core' core1 p (a # tr)) e =\n      fst (trace_core' core2 q (a # tr)) e) \\<and>\n  (\\<forall>ia\\<in>IA.\n      fst (snd (trace_core' core1 p (a # tr))) ia =\n      fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n  (\\<forall>iu\\<in>IU.\n      snd (snd (trace_core' core1 p (a # tr))) iu =\n      snd (snd (trace_core' core2 q (a # tr))) iu)\n\ngoal (1 subgoal):\n 1. oa \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. cfunc_adv core1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. oa \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. cfunc_adv core1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "case False"], ["proof (state)\nthis:\n  oa \\<notin> fst `\n              set_spmf (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n\ngoal (1 subgoal):\n 1. oa \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. cfunc_adv core1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "hence \"cond_spmf_fst ?p oa = return_pmf None\""], ["proof (prove)\nusing this:\n  oa \\<notin> fst `\n              set_spmf (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa =\n    return_pmf None", "by simp"], ["proof (state)\nthis:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa =\n  return_pmf None\n\ngoal (1 subgoal):\n 1. oa \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. cfunc_adv core1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "moreover"], ["proof (state)\nthis:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa =\n  return_pmf None\n\ngoal (1 subgoal):\n 1. oa \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. cfunc_adv core1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "from step_cfunc_adv[OF Cons.prems(2) cfunc_adv(2), THEN arg_cong[where f=set_spmf]] False"], ["proof (chain)\npicking this:\n  set_spmf (p \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ia))) =\n  set_spmf (q \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia)))\n  oa \\<notin> fst `\n              set_spmf (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))", "have oa': \"oa \\<notin> fst ` set_spmf ?q\""], ["proof (prove)\nusing this:\n  set_spmf (p \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ia))) =\n  set_spmf (q \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia)))\n  oa \\<notin> fst `\n              set_spmf (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n\ngoal (1 subgoal):\n 1. oa \\<notin> fst `\n                set_spmf (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))", "unfolding set_map_spmf[symmetric]"], ["proof (prove)\nusing this:\n  set_spmf (p \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ia))) =\n  set_spmf (q \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia)))\n  oa \\<notin> set_spmf\n               (map_spmf fst\n                 (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)))\n\ngoal (1 subgoal):\n 1. oa \\<notin> set_spmf\n                 (map_spmf fst\n                   (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)))", "by(simp only: map_bind_spmf o_def) simp"], ["proof (state)\nthis:\n  oa \\<notin> fst `\n              set_spmf (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n\ngoal (1 subgoal):\n 1. oa \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. cfunc_adv core1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "hence \"cond_spmf_fst ?q oa = return_pmf None\""], ["proof (prove)\nusing this:\n  oa \\<notin> fst `\n              set_spmf (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa =\n    return_pmf None", "by simp"], ["proof (state)\nthis:\n  cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa =\n  return_pmf None\n\ngoal (1 subgoal):\n 1. oa \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. cfunc_adv core1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "ultimately"], ["proof (chain)\npicking this:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa =\n  return_pmf None\n  cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa =\n  return_pmf None", "show ?thesis"], ["proof (prove)\nusing this:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa =\n  return_pmf None\n  cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa =\n  return_pmf None\n\ngoal (1 subgoal):\n 1. (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "using cfunc_adv"], ["proof (prove)\nusing this:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa =\n  return_pmf None\n  cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa =\n  return_pmf None\n  a = Inr (Inl (ia, oa))\n  ia \\<in> IA\n\ngoal (1 subgoal):\n 1. (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "by(simp del: cond_spmf_fst_eq_return_None)"], ["proof (state)\nthis:\n  (\\<forall>e\\<in>E.\n      fst (trace_core' core1 p (a # tr)) e =\n      fst (trace_core' core2 q (a # tr)) e) \\<and>\n  (\\<forall>ia\\<in>IA.\n      fst (snd (trace_core' core1 p (a # tr))) ia =\n      fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n  (\\<forall>iu\\<in>IU.\n      snd (snd (trace_core' core1 p (a # tr))) iu =\n      snd (snd (trace_core' core2 q (a # tr))) iu)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>e\\<in>E.\n      fst (trace_core' core1 p (a # tr)) e =\n      fst (trace_core' core2 q (a # tr)) e) \\<and>\n  (\\<forall>ia\\<in>IA.\n      fst (snd (trace_core' core1 p (a # tr))) ia =\n      fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n  (\\<forall>iu\\<in>IU.\n      snd (snd (trace_core' core1 p (a # tr))) iu =\n      snd (snd (trace_core' core2 q (a # tr))) iu)\n\ngoal (1 subgoal):\n 1. \\<And>iu ou.\n       \\<lbrakk>a = Inr (Inr (iu, ou)); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>iu ou.\n       \\<lbrakk>a = Inr (Inr (iu, ou)); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)", "case cfunc_usr"], ["proof (state)\nthis:\n  a = Inr (Inr (iu, ou))\n  iu \\<in> IU\n\ngoal (1 subgoal):\n 1. \\<And>iu ou.\n       \\<lbrakk>a = Inr (Inr (iu, ou)); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)", "let ?p = \"bind_spmf p (\\<lambda>s1. cfunc_usr core1 s1 iu)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>iu ou.\n       \\<lbrakk>a = Inr (Inr (iu, ou)); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)", "let ?q = \"bind_spmf q (\\<lambda>s2. cfunc_usr core2 s2 iu)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>iu ou.\n       \\<lbrakk>a = Inr (Inr (iu, ou)); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>e\\<in>E.\n                             fst (trace_core' core1 p (a # tr)) e =\n                             fst (trace_core' core2 q (a # tr)) e) \\<and>\n                         (\\<forall>ia\\<in>IA.\n                             fst (snd (trace_core' core1 p (a # tr))) ia =\n                             fst (snd (trace_core' core2 q (a # tr)))\n                              ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (snd (trace_core' core1 p (a # tr))) iu =\n                             snd (snd (trace_core' core2 q (a # tr))) iu)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "proof(cases \"ou \\<in> fst ` set_spmf ?p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ou \\<in> fst `\n             set_spmf\n              (p \\<bind>\n               (\\<lambda>s1. cfunc_usr core1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)\n 2. ou \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. cfunc_usr core1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "case True"], ["proof (state)\nthis:\n  ou \\<in> fst ` set_spmf (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n\ngoal (2 subgoals):\n 1. ou \\<in> fst `\n             set_spmf\n              (p \\<bind>\n               (\\<lambda>s1. cfunc_usr core1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)\n 2. ou \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. cfunc_usr core1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "with step_cfunc_usr[OF Cons.prems(2) cfunc_usr(2), THEN arg_cong[where f=set_spmf]]"], ["proof (chain)\npicking this:\n  set_spmf (p \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 iu))) =\n  set_spmf (q \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu)))\n  ou \\<in> fst ` set_spmf (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))", "have \"ou \\<in> fst ` set_spmf ?q\""], ["proof (prove)\nusing this:\n  set_spmf (p \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 iu))) =\n  set_spmf (q \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu)))\n  ou \\<in> fst ` set_spmf (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n\ngoal (1 subgoal):\n 1. ou \\<in> fst ` set_spmf (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))", "unfolding set_map_spmf[symmetric]"], ["proof (prove)\nusing this:\n  set_spmf (p \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 iu))) =\n  set_spmf (q \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu)))\n  ou \\<in> set_spmf\n            (map_spmf fst (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)))\n\ngoal (1 subgoal):\n 1. ou \\<in> set_spmf\n              (map_spmf fst\n                (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)))", "by(simp only: map_bind_spmf o_def)"], ["proof (state)\nthis:\n  ou \\<in> fst ` set_spmf (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n\ngoal (2 subgoals):\n 1. ou \\<in> fst `\n             set_spmf\n              (p \\<bind>\n               (\\<lambda>s1. cfunc_usr core1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)\n 2. ou \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. cfunc_usr core1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "then"], ["proof (chain)\npicking this:\n  ou \\<in> fst ` set_spmf (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))", "show ?thesis"], ["proof (prove)\nusing this:\n  ou \\<in> fst ` set_spmf (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n\ngoal (1 subgoal):\n 1. (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "using True Cons.prems cfunc_usr"], ["proof (prove)\nusing this:\n  ou \\<in> fst ` set_spmf (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n  ou \\<in> fst ` set_spmf (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n  set (a # tr) \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\n  S p q\n  a = Inr (Inr (iu, ou))\n  iu \\<in> IU\n\ngoal (1 subgoal):\n 1. (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "by(clarsimp)(rule Cons.IH; blast intro: sim_cfunc_usr)"], ["proof (state)\nthis:\n  (\\<forall>e\\<in>E.\n      fst (trace_core' core1 p (a # tr)) e =\n      fst (trace_core' core2 q (a # tr)) e) \\<and>\n  (\\<forall>ia\\<in>IA.\n      fst (snd (trace_core' core1 p (a # tr))) ia =\n      fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n  (\\<forall>iu\\<in>IU.\n      snd (snd (trace_core' core1 p (a # tr))) iu =\n      snd (snd (trace_core' core2 q (a # tr))) iu)\n\ngoal (1 subgoal):\n 1. ou \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. cfunc_usr core1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ou \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. cfunc_usr core1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "case False"], ["proof (state)\nthis:\n  ou \\<notin> fst `\n              set_spmf (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n\ngoal (1 subgoal):\n 1. ou \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. cfunc_usr core1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "hence \"cond_spmf_fst ?p ou = return_pmf None\""], ["proof (prove)\nusing this:\n  ou \\<notin> fst `\n              set_spmf (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou =\n    return_pmf None", "by simp"], ["proof (state)\nthis:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou =\n  return_pmf None\n\ngoal (1 subgoal):\n 1. ou \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. cfunc_usr core1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "moreover"], ["proof (state)\nthis:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou =\n  return_pmf None\n\ngoal (1 subgoal):\n 1. ou \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. cfunc_usr core1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "from step_cfunc_usr[OF Cons.prems(2) cfunc_usr(2), THEN arg_cong[where f=set_spmf]] False"], ["proof (chain)\npicking this:\n  set_spmf (p \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 iu))) =\n  set_spmf (q \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu)))\n  ou \\<notin> fst `\n              set_spmf (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))", "have oa': \"ou \\<notin> fst ` set_spmf ?q\""], ["proof (prove)\nusing this:\n  set_spmf (p \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 iu))) =\n  set_spmf (q \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu)))\n  ou \\<notin> fst `\n              set_spmf (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n\ngoal (1 subgoal):\n 1. ou \\<notin> fst `\n                set_spmf (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))", "unfolding set_map_spmf[symmetric]"], ["proof (prove)\nusing this:\n  set_spmf (p \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 iu))) =\n  set_spmf (q \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu)))\n  ou \\<notin> set_spmf\n               (map_spmf fst\n                 (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)))\n\ngoal (1 subgoal):\n 1. ou \\<notin> set_spmf\n                 (map_spmf fst\n                   (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)))", "by(simp only: map_bind_spmf o_def) simp"], ["proof (state)\nthis:\n  ou \\<notin> fst `\n              set_spmf (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n\ngoal (1 subgoal):\n 1. ou \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. cfunc_usr core1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "hence \"cond_spmf_fst ?q ou = return_pmf None\""], ["proof (prove)\nusing this:\n  ou \\<notin> fst `\n              set_spmf (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou =\n    return_pmf None", "by simp"], ["proof (state)\nthis:\n  cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou =\n  return_pmf None\n\ngoal (1 subgoal):\n 1. ou \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. cfunc_usr core1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "ultimately"], ["proof (chain)\npicking this:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou =\n  return_pmf None\n  cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou =\n  return_pmf None", "show ?thesis"], ["proof (prove)\nusing this:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou =\n  return_pmf None\n  cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou =\n  return_pmf None\n\ngoal (1 subgoal):\n 1. (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "using cfunc_usr"], ["proof (prove)\nusing this:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou =\n  return_pmf None\n  cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou =\n  return_pmf None\n  a = Inr (Inr (iu, ou))\n  iu \\<in> IU\n\ngoal (1 subgoal):\n 1. (\\<forall>e\\<in>E.\n        fst (trace_core' core1 p (a # tr)) e =\n        fst (trace_core' core2 q (a # tr)) e) \\<and>\n    (\\<forall>ia\\<in>IA.\n        fst (snd (trace_core' core1 p (a # tr))) ia =\n        fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (snd (trace_core' core1 p (a # tr))) iu =\n        snd (snd (trace_core' core2 q (a # tr))) iu)", "by(simp del: cond_spmf_fst_eq_return_None)"], ["proof (state)\nthis:\n  (\\<forall>e\\<in>E.\n      fst (trace_core' core1 p (a # tr)) e =\n      fst (trace_core' core2 q (a # tr)) e) \\<and>\n  (\\<forall>ia\\<in>IA.\n      fst (snd (trace_core' core1 p (a # tr))) ia =\n      fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n  (\\<forall>iu\\<in>IU.\n      snd (snd (trace_core' core1 p (a # tr))) iu =\n      snd (snd (trace_core' core2 q (a # tr))) iu)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>e\\<in>E.\n      fst (trace_core' core1 p (a # tr)) e =\n      fst (trace_core' core2 q (a # tr)) e) \\<and>\n  (\\<forall>ia\\<in>IA.\n      fst (snd (trace_core' core1 p (a # tr))) ia =\n      fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n  (\\<forall>iu\\<in>IU.\n      snd (snd (trace_core' core1 p (a # tr))) iu =\n      snd (snd (trace_core' core2 q (a # tr))) iu)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>e\\<in>E.\n      fst (trace_core' core1 p (a # tr)) e =\n      fst (trace_core' core2 q (a # tr)) e) \\<and>\n  (\\<forall>ia\\<in>IA.\n      fst (snd (trace_core' core1 p (a # tr))) ia =\n      fst (snd (trace_core' core2 q (a # tr))) ia) \\<and>\n  (\\<forall>iu\\<in>IU.\n      snd (snd (trace_core' core1 p (a # tr))) iu =\n      snd (snd (trace_core' core2 q (a # tr))) iu)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>e\\<in>E.\n      fst (trace_core' core1 p tr) e =\n      fst (trace_core' core2 q tr) e) \\<and>\n  (\\<forall>ia\\<in>IA.\n      fst (snd (trace_core' core1 p tr)) ia =\n      fst (snd (trace_core' core2 q tr)) ia) \\<and>\n  (\\<forall>iu\\<in>IU.\n      snd (snd (trace_core' core1 p tr)) iu =\n      snd (snd (trace_core' core2 q tr)) iu)\n\ngoal (3 subgoals):\n 1. \\<And>tr e.\n       \\<lbrakk>set tr\n                \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        e \\<in> E\\<rbrakk>\n       \\<Longrightarrow> fst (trace_core' core1 p tr) e =\n                         fst (trace_core' core2 q tr) e\n 2. \\<And>tr ia.\n       \\<lbrakk>set tr\n                \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> fst (snd (trace_core' core1 p tr)) ia =\n                         fst (snd (trace_core' core2 q tr)) ia\n 3. \\<And>tr iu.\n       \\<lbrakk>set tr\n                \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> snd (snd (trace_core' core1 p tr)) iu =\n                         snd (snd (trace_core' core2 q tr)) iu", "then"], ["proof (chain)\npicking this:\n  (\\<forall>e\\<in>E.\n      fst (trace_core' core1 p tr) e =\n      fst (trace_core' core2 q tr) e) \\<and>\n  (\\<forall>ia\\<in>IA.\n      fst (snd (trace_core' core1 p tr)) ia =\n      fst (snd (trace_core' core2 q tr)) ia) \\<and>\n  (\\<forall>iu\\<in>IU.\n      snd (snd (trace_core' core1 p tr)) iu =\n      snd (snd (trace_core' core2 q tr)) iu)", "show \"e \\<in> E \\<Longrightarrow> fst (trace_core' core1 p tr) e = fst (trace_core' core2 q tr) e\"\n    and \"ia \\<in> IA \\<Longrightarrow> fst (snd (trace_core' core1 p tr)) ia = fst (snd (trace_core' core2 q tr)) ia\"\n    and \"iu \\<in> IU \\<Longrightarrow> snd (snd (trace_core' core1 p tr)) iu = snd (snd (trace_core' core2 q tr)) iu\"\n    for e ia iu"], ["proof (prove)\nusing this:\n  (\\<forall>e\\<in>E.\n      fst (trace_core' core1 p tr) e =\n      fst (trace_core' core2 q tr) e) \\<and>\n  (\\<forall>ia\\<in>IA.\n      fst (snd (trace_core' core1 p tr)) ia =\n      fst (snd (trace_core' core2 q tr)) ia) \\<and>\n  (\\<forall>iu\\<in>IU.\n      snd (snd (trace_core' core1 p tr)) iu =\n      snd (snd (trace_core' core2 q tr)) iu)\n\ngoal (1 subgoal):\n 1. (e \\<in> E \\<Longrightarrow>\n     fst (trace_core' core1 p tr) e = fst (trace_core' core2 q tr) e) &&&\n    (ia \\<in> IA \\<Longrightarrow>\n     fst (snd (trace_core' core1 p tr)) ia =\n     fst (snd (trace_core' core2 q tr)) ia) &&&\n    (iu \\<in> IU \\<Longrightarrow>\n     snd (snd (trace_core' core1 p tr)) iu =\n     snd (snd (trace_core' core2 q tr)) iu)", "by blast+"], ["proof (state)\nthis:\n  ?e \\<in> E \\<Longrightarrow>\n  fst (trace_core' core1 p tr) ?e = fst (trace_core' core2 q tr) ?e\n  ?ia \\<in> IA \\<Longrightarrow>\n  fst (snd (trace_core' core1 p tr)) ?ia =\n  fst (snd (trace_core' core2 q tr)) ?ia\n  ?iu \\<in> IU \\<Longrightarrow>\n  snd (snd (trace_core' core1 p tr)) ?iu =\n  snd (snd (trace_core' core2 q tr)) ?iu\n\ngoal:\nNo subgoals!", "qed"], ["", "context \n  fixes core :: \"('s_core, 'event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\"\nbegin"], ["", "fun trace_core_aux \n  :: \"'s_core spmf \\<Rightarrow> ('event + 'iadv_core \\<times> 'oadv_core + 'iusr_core \\<times> 'ousr_core) list \\<Rightarrow> 's_core spmf\" where\n  \"trace_core_aux p [] = p\"\n| \"trace_core_aux p (Inl e # tr) = trace_core_aux (mk_lossless (bind_spmf p (\\<lambda>s. cpoke core s e))) tr\"\n| \"trace_core_aux p (Inr (Inl (ia, oa)) # tr) = trace_core_aux (cond_spmf_fst (bind_spmf p (\\<lambda>s. cfunc_adv core s ia)) oa) tr\"\n| \"trace_core_aux p (Inr (Inr (iu, ou)) # tr) = trace_core_aux (cond_spmf_fst (bind_spmf p (\\<lambda>s. cfunc_usr core s iu)) ou) tr\""], ["", "end"], ["", "lemma trace_core_conv_trace_core_aux:\n  \"trace_core' core p tr = \n   (\\<lambda>e. weight_spmf (bind_spmf (trace_core_aux core p tr) (\\<lambda>s. cpoke core s e)),\n    \\<lambda>ia. bind_spmf (trace_core_aux core p tr) (\\<lambda>s. map_spmf fst (cfunc_adv core s ia)),\n    \\<lambda>iu. bind_spmf (trace_core_aux core p tr) (\\<lambda>s. map_spmf fst (cfunc_usr core s iu)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_core' core p tr =\n    (\\<lambda>e.\n        weight_spmf\n         (trace_core_aux core p tr \\<bind> (\\<lambda>s. cpoke core s e)),\n     \\<lambda>ia.\n        trace_core_aux core p tr \\<bind>\n        (\\<lambda>s. map_spmf fst (cfunc_adv core s ia)),\n     \\<lambda>iu.\n        trace_core_aux core p tr \\<bind>\n        (\\<lambda>s. map_spmf fst (cfunc_usr core s iu)))", "by(induction p tr rule: trace_core_aux.induct) simp_all"], ["", "lemma trace_core_aux_append:\n  \"trace_core_aux core p (tr @ tr') = trace_core_aux core (trace_core_aux core p tr) tr'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_core_aux core p (tr @ tr') =\n    trace_core_aux core (trace_core_aux core p tr) tr'", "by(induction p tr rule: trace_core_aux.induct) auto"], ["", "inductive trace_core_closure \n  :: \"('s_core, 'event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\n  \\<Rightarrow> ('s_core', 'event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\n  \\<Rightarrow> 'event set \\<Rightarrow> 'iadv_core set \\<Rightarrow> 'iusr_core set\n  \\<Rightarrow> 's_core spmf \\<Rightarrow> 's_core' spmf \\<Rightarrow> 's_core spmf \\<Rightarrow> 's_core' spmf \\<Rightarrow> bool\"\n  for core1 core2 E IA IU p q where\n  \"trace_core_closure core1 core2 E IA IU p q (trace_core_aux core1 p tr) (trace_core_aux core2 q tr)\"\n  if \"set tr \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\""], ["", "lemma trace_core_closure_start: \"trace_core_closure core1 core2 E IA IU p q p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_core_closure core1 core2 E IA IU p q p q", "by(simp add: trace_core_closure.simps exI[where x=\"[]\"])"], ["", "lemma trace_core_closure_step:\n  assumes \"trace_core_eq core1 core2 E IA IU p q\"\n    and \"trace_core_closure core1 core2 E IA IU p q p' q'\"\n  shows trace_core_closure_step_cpoke:\n    \"e \\<in> E \\<Longrightarrow> weight_spmf (bind_spmf p' (\\<lambda>s. cpoke core1 s e)) = weight_spmf (bind_spmf q' (\\<lambda>s. cpoke core2 s e))\"\n    (is \"PROP ?thesis1\")\n    and trace_core_closure_step_cfunc_adv: \n    \"ia \\<in> IA \\<Longrightarrow> bind_spmf p' (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ia)) = bind_spmf q' (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\"\n    (is \"PROP ?thesis2\")\n    and trace_core_closure_step_cfunc_usr:\n    \"iu \\<in> IU \\<Longrightarrow> bind_spmf p' (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 iu)) = bind_spmf q' (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\"\n    (is \"PROP ?thesis3\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (e \\<in> E \\<Longrightarrow>\n     weight_spmf (p' \\<bind> (\\<lambda>s. cpoke core1 s e)) =\n     weight_spmf (q' \\<bind> (\\<lambda>s. cpoke core2 s e))) &&&\n    (ia \\<in> IA \\<Longrightarrow>\n     p' \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ia)) =\n     q' \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))) &&&\n    (iu \\<in> IU \\<Longrightarrow>\n     p' \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 iu)) =\n     q' \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu)))", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. e \\<in> E \\<Longrightarrow>\n    weight_spmf (p' \\<bind> (\\<lambda>s. cpoke core1 s e)) =\n    weight_spmf (q' \\<bind> (\\<lambda>s. cpoke core2 s e))\n 2. ia \\<in> IA \\<Longrightarrow>\n    p' \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ia)) =\n    q' \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\n 3. iu \\<in> IU \\<Longrightarrow>\n    p' \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 iu)) =\n    q' \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))", "from assms(2)"], ["proof (chain)\npicking this:\n  trace_core_closure core1 core2 E IA IU p q p' q'", "obtain tr where p: \"p' = trace_core_aux core1 p tr\"\n    and q: \"q' = trace_core_aux core2 q tr\"\n    and tr: \"set tr \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\""], ["proof (prove)\nusing this:\n  trace_core_closure core1 core2 E IA IU p q p' q'\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        \\<lbrakk>p' = trace_core_aux core1 p tr;\n         q' = trace_core_aux core2 q tr;\n         set tr\n         \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  p' = trace_core_aux core1 p tr\n  q' = trace_core_aux core2 q tr\n  set tr \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\n\ngoal (3 subgoals):\n 1. e \\<in> E \\<Longrightarrow>\n    weight_spmf (p' \\<bind> (\\<lambda>s. cpoke core1 s e)) =\n    weight_spmf (q' \\<bind> (\\<lambda>s. cpoke core2 s e))\n 2. ia \\<in> IA \\<Longrightarrow>\n    p' \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ia)) =\n    q' \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\n 3. iu \\<in> IU \\<Longrightarrow>\n    p' \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 iu)) =\n    q' \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))", "from trace_core_eqD[OF assms(1) tr] p q"], ["proof (chain)\npicking this:\n  ?e \\<in> E \\<Longrightarrow>\n  fst (trace_core' core1 p tr) ?e = fst (trace_core' core2 q tr) ?e\n  ?ia \\<in> IA \\<Longrightarrow>\n  fst (snd (trace_core' core1 p tr)) ?ia =\n  fst (snd (trace_core' core2 q tr)) ?ia\n  ?iu \\<in> IU \\<Longrightarrow>\n  snd (snd (trace_core' core1 p tr)) ?iu =\n  snd (snd (trace_core' core2 q tr)) ?iu\n  p' = trace_core_aux core1 p tr\n  q' = trace_core_aux core2 q tr", "show \"PROP ?thesis1\" and \"PROP ?thesis2\" \"PROP ?thesis3\""], ["proof (prove)\nusing this:\n  ?e \\<in> E \\<Longrightarrow>\n  fst (trace_core' core1 p tr) ?e = fst (trace_core' core2 q tr) ?e\n  ?ia \\<in> IA \\<Longrightarrow>\n  fst (snd (trace_core' core1 p tr)) ?ia =\n  fst (snd (trace_core' core2 q tr)) ?ia\n  ?iu \\<in> IU \\<Longrightarrow>\n  snd (snd (trace_core' core1 p tr)) ?iu =\n  snd (snd (trace_core' core2 q tr)) ?iu\n  p' = trace_core_aux core1 p tr\n  q' = trace_core_aux core2 q tr\n\ngoal (1 subgoal):\n 1. (e \\<in> E \\<Longrightarrow>\n     weight_spmf (p' \\<bind> (\\<lambda>s. cpoke core1 s e)) =\n     weight_spmf (q' \\<bind> (\\<lambda>s. cpoke core2 s e))) &&&\n    (ia \\<in> IA \\<Longrightarrow>\n     p' \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ia)) =\n     q' \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))) &&&\n    (iu \\<in> IU \\<Longrightarrow>\n     p' \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 iu)) =\n     q' \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu)))", "by(simp_all add: trace_core_conv_trace_core_aux)"], ["proof (state)\nthis:\n  e \\<in> E \\<Longrightarrow>\n  weight_spmf (p' \\<bind> (\\<lambda>s. cpoke core1 s e)) =\n  weight_spmf (q' \\<bind> (\\<lambda>s. cpoke core2 s e))\n  ia \\<in> IA \\<Longrightarrow>\n  p' \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ia)) =\n  q' \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\n  iu \\<in> IU \\<Longrightarrow>\n  p' \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 iu)) =\n  q' \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_core_closure_sim:\n  fixes core1 core2 E IA IU p q\n  defines \"S \\<equiv> trace_core_closure core1 core2 E IA IU p q\"\n  assumes \"S p' q'\"\n  shows trace_core_closure_sim_cpoke:\n    \"e \\<in> E \\<Longrightarrow> S (mk_lossless (bind_spmf p' (\\<lambda>s. cpoke core1 s e))) (mk_lossless (bind_spmf q' (\\<lambda>s. cpoke core2 s e)))\"\n    (is \"PROP ?thesis1\")\n    and trace_core_closure_sim_cfunc_adv: \"ia \\<in> IA \n    \\<Longrightarrow> S (cond_spmf_fst (bind_spmf p' (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa) \n          (cond_spmf_fst (bind_spmf q' (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa)\"\n    (is \"PROP ?thesis2\")\n    and trace_core_closure_sim_cfunc_usr: \"iu \\<in> IU \n    \\<Longrightarrow> S (cond_spmf_fst (bind_spmf p' (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou)\n          (cond_spmf_fst (bind_spmf q' (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou)\"\n    (is \"PROP ?thesis3\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (e \\<in> E \\<Longrightarrow>\n     S (mk_lossless (p' \\<bind> (\\<lambda>s. cpoke core1 s e)))\n      (mk_lossless (q' \\<bind> (\\<lambda>s. cpoke core2 s e)))) &&&\n    (ia \\<in> IA \\<Longrightarrow>\n     S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa)\n      (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n        oa)) &&&\n    (iu \\<in> IU \\<Longrightarrow>\n     S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou)\n      (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou))", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. e \\<in> E \\<Longrightarrow>\n    S (mk_lossless (p' \\<bind> (\\<lambda>s. cpoke core1 s e)))\n     (mk_lossless (q' \\<bind> (\\<lambda>s. cpoke core2 s e)))\n 2. ia \\<in> IA \\<Longrightarrow>\n    S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa)\n     (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa)\n 3. iu \\<in> IU \\<Longrightarrow>\n    S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou)\n     (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou)", "from assms(2)"], ["proof (chain)\npicking this:\n  S p' q'", "obtain tr where p: \"p' = trace_core_aux core1 p tr\"\n    and q: \"q' = trace_core_aux core2 q tr\"\n    and tr: \"set tr \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\""], ["proof (prove)\nusing this:\n  S p' q'\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        \\<lbrakk>p' = trace_core_aux core1 p tr;\n         q' = trace_core_aux core2 q tr;\n         set tr\n         \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding S_def"], ["proof (prove)\nusing this:\n  trace_core_closure core1 core2 E IA IU p q p' q'\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        \\<lbrakk>p' = trace_core_aux core1 p tr;\n         q' = trace_core_aux core2 q tr;\n         set tr\n         \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  p' = trace_core_aux core1 p tr\n  q' = trace_core_aux core2 q tr\n  set tr \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\n\ngoal (3 subgoals):\n 1. e \\<in> E \\<Longrightarrow>\n    S (mk_lossless (p' \\<bind> (\\<lambda>s. cpoke core1 s e)))\n     (mk_lossless (q' \\<bind> (\\<lambda>s. cpoke core2 s e)))\n 2. ia \\<in> IA \\<Longrightarrow>\n    S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa)\n     (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa)\n 3. iu \\<in> IU \\<Longrightarrow>\n    S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou)\n     (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou)", "show \"PROP ?thesis1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> E \\<Longrightarrow>\n    S (mk_lossless (p' \\<bind> (\\<lambda>s. cpoke core1 s e)))\n     (mk_lossless (q' \\<bind> (\\<lambda>s. cpoke core2 s e)))", "using p q tr"], ["proof (prove)\nusing this:\n  p' = trace_core_aux core1 p tr\n  q' = trace_core_aux core2 q tr\n  set tr \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\n\ngoal (1 subgoal):\n 1. e \\<in> E \\<Longrightarrow>\n    S (mk_lossless (p' \\<bind> (\\<lambda>s. cpoke core1 s e)))\n     (mk_lossless (q' \\<bind> (\\<lambda>s. cpoke core2 s e)))", "by(auto simp add: S_def trace_core_closure.simps trace_core_aux_append intro!: exI[where x=\"tr @ [Inl _]\"])"], ["proof (state)\nthis:\n  e \\<in> E \\<Longrightarrow>\n  S (mk_lossless (p' \\<bind> (\\<lambda>s. cpoke core1 s e)))\n   (mk_lossless (q' \\<bind> (\\<lambda>s. cpoke core2 s e)))\n\ngoal (2 subgoals):\n 1. ia \\<in> IA \\<Longrightarrow>\n    S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa)\n     (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa)\n 2. iu \\<in> IU \\<Longrightarrow>\n    S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou)\n     (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou)", "show \"PROP ?thesis2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia \\<in> IA \\<Longrightarrow>\n    S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa)\n     (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa)", "using p q tr"], ["proof (prove)\nusing this:\n  p' = trace_core_aux core1 p tr\n  q' = trace_core_aux core2 q tr\n  set tr \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\n\ngoal (1 subgoal):\n 1. ia \\<in> IA \\<Longrightarrow>\n    S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa)\n     (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa)", "by(auto simp add: S_def trace_core_closure.simps trace_core_aux_append intro!: exI[where x=\"tr @ [Inr (Inl (_, _))]\"])"], ["proof (state)\nthis:\n  ia \\<in> IA \\<Longrightarrow>\n  S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa)\n   (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa)\n\ngoal (1 subgoal):\n 1. iu \\<in> IU \\<Longrightarrow>\n    S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou)\n     (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou)", "show \"PROP ?thesis3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iu \\<in> IU \\<Longrightarrow>\n    S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou)\n     (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou)", "using p q tr"], ["proof (prove)\nusing this:\n  p' = trace_core_aux core1 p tr\n  q' = trace_core_aux core2 q tr\n  set tr \\<subseteq> E <+> IA \\<times> UNIV <+> IU \\<times> UNIV\n\ngoal (1 subgoal):\n 1. iu \\<in> IU \\<Longrightarrow>\n    S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou)\n     (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou)", "by(auto simp add: S_def trace_core_closure.simps trace_core_aux_append intro!: exI[where x=\"tr @ [Inr (Inr (_, _))]\"])"], ["proof (state)\nthis:\n  iu \\<in> IU \\<Longrightarrow>\n  S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou)\n   (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou)\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition trace_core_eq_complete:\n  assumes \"trace_core_eq core1 core2 E IA IU p q\"\n  obtains S\n  where \"S p q\"\n    and \"\\<And>p q e. \\<lbrakk> S p q; e \\<in> E \\<rbrakk> \\<Longrightarrow> \n      weight_spmf (bind_spmf p (\\<lambda>s. cpoke core1 s e)) = weight_spmf (bind_spmf q (\\<lambda>s. cpoke core2 s e))\"\n    and \"\\<And>p q e. \\<lbrakk> S p q; e \\<in> E \\<rbrakk> \\<Longrightarrow> \n      S (mk_lossless (bind_spmf p (\\<lambda>s. cpoke core1 s e))) (mk_lossless (bind_spmf q (\\<lambda>s. cpoke core2 s e)))\"\n    and \"\\<And>p q ia. \\<lbrakk> S p q; ia \\<in> IA \\<rbrakk> \\<Longrightarrow> \n      bind_spmf p (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ia)) = bind_spmf q (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\"\n    and \"\\<And>p q ia oa. \\<lbrakk> S p q; ia \\<in> IA \\<rbrakk>\n      \\<Longrightarrow> S (cond_spmf_fst (bind_spmf p (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa) (cond_spmf_fst (bind_spmf q (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa)\"\n    and \"\\<And>p q iu. \\<lbrakk> S p q; iu \\<in> IU \\<rbrakk> \\<Longrightarrow> \n      bind_spmf p (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 iu)) = bind_spmf q (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\"\n    and \"\\<And>p q iu ou. \\<lbrakk> S p q; iu \\<in> IU \\<rbrakk>\n      \\<Longrightarrow> S (cond_spmf_fst (bind_spmf p (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou) (cond_spmf_fst (bind_spmf q (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>S p q;\n         \\<And>p q e.\n            \\<lbrakk>S p q; e \\<in> E\\<rbrakk>\n            \\<Longrightarrow> weight_spmf\n                               (p \\<bind> (\\<lambda>s. cpoke core1 s e)) =\n                              weight_spmf\n                               (q \\<bind> (\\<lambda>s. cpoke core2 s e));\n         \\<And>p q e.\n            \\<lbrakk>S p q; e \\<in> E\\<rbrakk>\n            \\<Longrightarrow> S (mk_lossless\n                                  (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n                               (mk_lossless\n                                 (q \\<bind> (\\<lambda>s. cpoke core2 s e)));\n         \\<And>p q ia.\n            \\<lbrakk>S p q; ia \\<in> IA\\<rbrakk>\n            \\<Longrightarrow> p \\<bind>\n                              (\\<lambda>s1.\n                                  map_spmf fst (cfunc_adv core1 s1 ia)) =\n                              q \\<bind>\n                              (\\<lambda>s2.\n                                  map_spmf fst (cfunc_adv core2 s2 ia));\n         \\<And>p q ia oa.\n            \\<lbrakk>S p q; ia \\<in> IA\\<rbrakk>\n            \\<Longrightarrow> S (cond_spmf_fst\n                                  (p \\<bind>\n                                   (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                                  oa)\n                               (cond_spmf_fst\n                                 (q \\<bind>\n                                  (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                                 oa);\n         \\<And>p q iu.\n            \\<lbrakk>S p q; iu \\<in> IU\\<rbrakk>\n            \\<Longrightarrow> p \\<bind>\n                              (\\<lambda>s1.\n                                  map_spmf fst (cfunc_usr core1 s1 iu)) =\n                              q \\<bind>\n                              (\\<lambda>s2.\n                                  map_spmf fst (cfunc_usr core2 s2 iu));\n         \\<And>p q iu ou.\n            \\<lbrakk>S p q; iu \\<in> IU\\<rbrakk>\n            \\<Longrightarrow> S (cond_spmf_fst\n                                  (p \\<bind>\n                                   (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                                  ou)\n                               (cond_spmf_fst\n                                 (q \\<bind>\n                                  (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                                 ou)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>S p q;\n         \\<And>p q e.\n            \\<lbrakk>S p q; e \\<in> E\\<rbrakk>\n            \\<Longrightarrow> weight_spmf\n                               (p \\<bind> (\\<lambda>s. cpoke core1 s e)) =\n                              weight_spmf\n                               (q \\<bind> (\\<lambda>s. cpoke core2 s e));\n         \\<And>p q e.\n            \\<lbrakk>S p q; e \\<in> E\\<rbrakk>\n            \\<Longrightarrow> S (mk_lossless\n                                  (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n                               (mk_lossless\n                                 (q \\<bind> (\\<lambda>s. cpoke core2 s e)));\n         \\<And>p q ia.\n            \\<lbrakk>S p q; ia \\<in> IA\\<rbrakk>\n            \\<Longrightarrow> p \\<bind>\n                              (\\<lambda>s1.\n                                  map_spmf fst (cfunc_adv core1 s1 ia)) =\n                              q \\<bind>\n                              (\\<lambda>s2.\n                                  map_spmf fst (cfunc_adv core2 s2 ia));\n         \\<And>p q ia oa.\n            \\<lbrakk>S p q; ia \\<in> IA\\<rbrakk>\n            \\<Longrightarrow> S (cond_spmf_fst\n                                  (p \\<bind>\n                                   (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                                  oa)\n                               (cond_spmf_fst\n                                 (q \\<bind>\n                                  (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                                 oa);\n         \\<And>p q iu.\n            \\<lbrakk>S p q; iu \\<in> IU\\<rbrakk>\n            \\<Longrightarrow> p \\<bind>\n                              (\\<lambda>s1.\n                                  map_spmf fst (cfunc_usr core1 s1 iu)) =\n                              q \\<bind>\n                              (\\<lambda>s2.\n                                  map_spmf fst (cfunc_usr core2 s2 iu));\n         \\<And>p q iu ou.\n            \\<lbrakk>S p q; iu \\<in> IU\\<rbrakk>\n            \\<Longrightarrow> S (cond_spmf_fst\n                                  (p \\<bind>\n                                   (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                                  ou)\n                               (cond_spmf_fst\n                                 (q \\<bind>\n                                  (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                                 ou)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "by(rule that[where S=\"trace_core_closure core1 core2 E IA IU p q\"])\n      (auto intro: trace_core_closure_start trace_core_closure_step[OF assms] trace_core_closure_sim (* trace_core_closure_weight[OF assms] *))"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "type_synonym ('event, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest) trace_rest =\n  \"('iadv_rest \\<times> 'oadv_rest \\<times> 'event list + 'iusr_rest \\<times> 'ousr_rest \\<times> 'event list) list\n  \\<Rightarrow> ('iadv_rest \\<Rightarrow> ('oadv_rest \\<times> 'event list) spmf) \n  \\<times> ('iusr_rest \\<Rightarrow> ('ousr_rest \\<times> 'event list) spmf)\""], ["", "context\n  fixes rest :: \"('s_rest, 'event, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest, 'more) rest_scheme\"\nbegin"], ["", "primrec trace_rest' :: \"'s_rest spmf \\<Rightarrow> ('event, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest) trace_rest\" where\n  \"trace_rest' S [] =\n  (\\<lambda>ia. bind_spmf S (\\<lambda>s. map_spmf fst (rfunc_adv rest s ia)),\n   \\<lambda>iu. bind_spmf S (\\<lambda>s. map_spmf fst (rfunc_usr rest s iu)))\"\n| \"trace_rest' S (obs # tr) = (case obs of\n     Inl (ia, oa) \\<Rightarrow> trace_rest' (cond_spmf_fst (bind_spmf S (\\<lambda>s. rfunc_adv rest s ia)) oa) tr\n   | Inr (iu, ou) \\<Rightarrow> trace_rest' (cond_spmf_fst (bind_spmf S (\\<lambda>s. rfunc_usr rest s iu)) ou) tr)\""], ["", "end"], ["", "declare trace_rest'.simps [simp del]"], ["", "case_of_simps trace_rest'_unfold: trace_rest'.simps"], ["", "simps_of_case trace_rest'_simps [simp]: trace_rest'_unfold"], ["", "context includes lifting_syntax begin"], ["", "lemma trace_rest'_parametric [transfer_rule]:\n  \"(rel_rest' S (=) IA IU (=) (=) M ===> rel_spmf S ===>\n      list_all2 (rel_sum (rel_prod IA (=)) (rel_prod IU (=))) ===>\n      rel_prod (IA ===> (=)) (IU ===> (=)))\n      trace_rest' trace_rest'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_rest' S (=) IA IU (=) (=) M ===>\n     rel_spmf S ===>\n     list_all2 (rel_sum (rel_prod IA (=)) (rel_prod IU (=))) ===>\n     rel_prod (IA ===> (=)) (IU ===> (=)))\n     trace_rest' trace_rest'", "unfolding trace_rest'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_rest' S (=) IA IU (=) (=) M ===>\n     rel_spmf S ===>\n     list_all2 (rel_sum (rel_prod IA (=)) (rel_prod IU (=))) ===>\n     rel_prod (IA ===> (=)) (IU ===> (=)))\n     (\\<lambda>rest uu uua.\n         rec_list\n          (\\<lambda>S.\n              (\\<lambda>ia.\n                  S \\<bind>\n                  (\\<lambda>s. map_spmf fst (rfunc_adv rest s ia)),\n               \\<lambda>iu.\n                  S \\<bind>\n                  (\\<lambda>s. map_spmf fst (rfunc_usr rest s iu))))\n          (\\<lambda>obs tr tra S.\n              case obs of\n              Inl (ia, oa) \\<Rightarrow>\n                tra (cond_spmf_fst\n                      (S \\<bind> (\\<lambda>s. rfunc_adv rest s ia)) oa)\n              | Inr (iu, ou) \\<Rightarrow>\n                  tra (cond_spmf_fst\n                        (S \\<bind> (\\<lambda>s. rfunc_usr rest s iu)) ou))\n          uua uu)\n     (\\<lambda>rest uu uua.\n         rec_list\n          (\\<lambda>S.\n              (\\<lambda>ia.\n                  S \\<bind>\n                  (\\<lambda>s. map_spmf fst (rfunc_adv rest s ia)),\n               \\<lambda>iu.\n                  S \\<bind>\n                  (\\<lambda>s. map_spmf fst (rfunc_usr rest s iu))))\n          (\\<lambda>obs tr tra S.\n              case obs of\n              Inl (ia, oa) \\<Rightarrow>\n                tra (cond_spmf_fst\n                      (S \\<bind> (\\<lambda>s. rfunc_adv rest s ia)) oa)\n              | Inr (iu, ou) \\<Rightarrow>\n                  tra (cond_spmf_fst\n                        (S \\<bind> (\\<lambda>s. rfunc_usr rest s iu)) ou))\n          uua uu)", "by transfer_prover"], ["", "definition trace_rest_eq\n  :: \"('s_rest, 'event, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest, 'more1) rest_scheme\n  \\<Rightarrow> ('s_rest', 'event, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest, 'more2) rest_scheme\n  \\<Rightarrow> 'iadv_rest set \\<Rightarrow> 'iusr_rest set\n  \\<Rightarrow> 's_rest spmf \\<Rightarrow> 's_rest' spmf \\<Rightarrow> bool\" where\n  \"trace_rest_eq rest1 rest2 IA IU p q \\<longleftrightarrow>\n  (\\<forall>tr. set tr \\<subseteq> (IA \\<times> UNIV) <+> (IU \\<times> UNIV) \\<longrightarrow>\n   rel_prod (eq_onp (\\<lambda>ia. ia \\<in> IA) ===> (=)) (eq_onp (\\<lambda>iu. iu \\<in> IU) ===> (=))\n     (trace_rest' rest1 p tr) (trace_rest' rest2 q tr))\""], ["", "end"], ["", "lemma trace_rest_eqD:\n  assumes \"trace_rest_eq rest1 rest2 IA IU p q\"\n    and \"set tr \\<subseteq> (IA \\<times> UNIV) <+> (IU \\<times> UNIV)\"\n  shows trace_rest_eqD_rfunc_adv:\n     \"ia \\<in> IA \\<Longrightarrow> fst (trace_rest' rest1 p tr) ia = fst (trace_rest' rest2 q tr) ia\"\n    and trace_rest_eqD_rfunc_usr:\n     \"iu \\<in> IU \\<Longrightarrow> snd (trace_rest' rest1 p tr) iu = snd (trace_rest' rest2 q tr) iu\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ia \\<in> IA \\<Longrightarrow>\n     fst (trace_rest' rest1 p tr) ia = fst (trace_rest' rest2 q tr) ia) &&&\n    (iu \\<in> IU \\<Longrightarrow>\n     snd (trace_rest' rest1 p tr) iu = snd (trace_rest' rest2 q tr) iu)", "using assms"], ["proof (prove)\nusing this:\n  trace_rest_eq rest1 rest2 IA IU p q\n  set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\n\ngoal (1 subgoal):\n 1. (ia \\<in> IA \\<Longrightarrow>\n     fst (trace_rest' rest1 p tr) ia = fst (trace_rest' rest2 q tr) ia) &&&\n    (iu \\<in> IU \\<Longrightarrow>\n     snd (trace_rest' rest1 p tr) iu = snd (trace_rest' rest2 q tr) iu)", "by(auto simp add: trace_rest_eq_def rel_fun_def rel_prod_sel eq_onp_def)"], ["", "lemma trace_rest_eqI:\n  assumes \"\\<And>tr ia. \\<lbrakk> set tr \\<subseteq> (IA \\<times> UNIV) <+> (IU \\<times> UNIV); ia \\<in> IA \\<rbrakk>\n     \\<Longrightarrow> fst (trace_rest' rest1 p tr) ia = fst (trace_rest' rest2 q tr) ia\"\n    and \"\\<And>tr iu. \\<lbrakk> set tr \\<subseteq> (IA \\<times> UNIV) <+> (IU \\<times> UNIV); iu \\<in> IU \\<rbrakk>\n      \\<Longrightarrow> snd (trace_rest' rest1 p tr) iu = snd (trace_rest' rest2 q tr) iu\"\n  shows \"trace_rest_eq rest1 rest2 IA IU p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_rest_eq rest1 rest2 IA IU p q", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV;\n   ?ia \\<in> IA\\<rbrakk>\n  \\<Longrightarrow> fst (trace_rest' rest1 p ?tr) ?ia =\n                    fst (trace_rest' rest2 q ?tr) ?ia\n  \\<lbrakk>set ?tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV;\n   ?iu \\<in> IU\\<rbrakk>\n  \\<Longrightarrow> snd (trace_rest' rest1 p ?tr) ?iu =\n                    snd (trace_rest' rest2 q ?tr) ?iu\n\ngoal (1 subgoal):\n 1. trace_rest_eq rest1 rest2 IA IU p q", "by(auto simp add: trace_rest_eq_def rel_fun_def eq_onp_def rel_prod_sel)"], ["", "lemma trace_rest_return_pmf_None [simp]:\n  \"trace_rest' rest (return_pmf None) tr = (\\<lambda>_. return_pmf None, \\<lambda>_. return_pmf None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_rest' rest (return_pmf None) tr =\n    (\\<lambda>_. return_pmf None, \\<lambda>_. return_pmf None)", "by(induction tr)(simp_all add: trace_rest'.simps split: sum.split)"], ["", "lemma rel_rest'_into_trace_rest_eq: \"trace_rest_eq rest rest' IA IU p q\" \n  if \"rel_rest' S (=) (eq_onp (\\<lambda>ia. ia \\<in> IA)) (eq_onp (\\<lambda>iu. iu \\<in> IU)) (=) (=) M rest rest'\"\n     \"rel_spmf S p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_rest_eq rest rest' IA IU p q", "using trace_rest'_parametric[THEN rel_funD, THEN rel_funD, OF that]"], ["proof (prove)\nusing this:\n  rel_fun\n   (list_all2\n     (rel_sum (rel_prod (eq_onp (\\<lambda>ia. ia \\<in> IA)) (=))\n       (rel_prod (eq_onp (\\<lambda>iu. iu \\<in> IU)) (=))))\n   (rel_prod (rel_fun (eq_onp (\\<lambda>ia. ia \\<in> IA)) (=))\n     (rel_fun (eq_onp (\\<lambda>iu. iu \\<in> IU)) (=)))\n   (trace_rest' rest p) (trace_rest' rest' q)\n\ngoal (1 subgoal):\n 1. trace_rest_eq rest rest' IA IU p q", "unfolding trace_rest_eq_def"], ["proof (prove)\nusing this:\n  rel_fun\n   (list_all2\n     (rel_sum (rel_prod (eq_onp (\\<lambda>ia. ia \\<in> IA)) (=))\n       (rel_prod (eq_onp (\\<lambda>iu. iu \\<in> IU)) (=))))\n   (rel_prod (rel_fun (eq_onp (\\<lambda>ia. ia \\<in> IA)) (=))\n     (rel_fun (eq_onp (\\<lambda>iu. iu \\<in> IU)) (=)))\n   (trace_rest' rest p) (trace_rest' rest' q)\n\ngoal (1 subgoal):\n 1. \\<forall>tr.\n       set tr\n       \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV \\<longrightarrow>\n       rel_prod (rel_fun (eq_onp (\\<lambda>ia. ia \\<in> IA)) (=))\n        (rel_fun (eq_onp (\\<lambda>iu. iu \\<in> IU)) (=))\n        (trace_rest' rest p tr) (trace_rest' rest' q tr)", "apply(intro strip)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tr.\n       \\<lbrakk>rel_fun\n                 (list_all2\n                   (rel_sum\n                     (rel_prod (eq_onp (\\<lambda>ia. ia \\<in> IA)) (=))\n                     (rel_prod (eq_onp (\\<lambda>iu. iu \\<in> IU)) (=))))\n                 (rel_prod (rel_fun (eq_onp (\\<lambda>ia. ia \\<in> IA)) (=))\n                   (rel_fun (eq_onp (\\<lambda>iu. iu \\<in> IU)) (=)))\n                 (trace_rest' rest p) (trace_rest' rest' q);\n        set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> rel_prod\n                          (rel_fun (eq_onp (\\<lambda>ia. ia \\<in> IA)) (=))\n                          (rel_fun (eq_onp (\\<lambda>iu. iu \\<in> IU)) (=))\n                          (trace_rest' rest p tr) (trace_rest' rest' q tr)", "subgoal for tr"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel_fun\n              (list_all2\n                (rel_sum (rel_prod (eq_onp (\\<lambda>ia. ia \\<in> IA)) (=))\n                  (rel_prod (eq_onp (\\<lambda>iu. iu \\<in> IU)) (=))))\n              (rel_prod (rel_fun (eq_onp (\\<lambda>ia. ia \\<in> IA)) (=))\n                (rel_fun (eq_onp (\\<lambda>iu. iu \\<in> IU)) (=)))\n              (trace_rest' rest p) (trace_rest' rest' q);\n     set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\\<rbrakk>\n    \\<Longrightarrow> rel_prod\n                       (rel_fun (eq_onp (\\<lambda>ia. ia \\<in> IA)) (=))\n                       (rel_fun (eq_onp (\\<lambda>iu. iu \\<in> IU)) (=))\n                       (trace_rest' rest p tr) (trace_rest' rest' q tr)", "apply(simp add: eq_onp_True[symmetric] prod.rel_eq_onp sum.rel_eq_onp list.rel_eq_onp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel_fun\n              (eq_onp\n                (list_all\n                  (pred_sum\n                    (pred_prod (\\<lambda>ia. ia \\<in> IA)\n                      (\\<lambda>_. True))\n                    (pred_prod (\\<lambda>iu. iu \\<in> IU)\n                      (\\<lambda>_. True)))))\n              (rel_prod\n                (rel_fun (eq_onp (\\<lambda>ia. ia \\<in> IA))\n                  (eq_onp (\\<lambda>_. True)))\n                (rel_fun (eq_onp (\\<lambda>iu. iu \\<in> IU))\n                  (eq_onp (\\<lambda>_. True))))\n              (trace_rest' rest p) (trace_rest' rest' q);\n     set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\\<rbrakk>\n    \\<Longrightarrow> rel_prod\n                       (rel_fun (eq_onp (\\<lambda>ia. ia \\<in> IA))\n                         (eq_onp (\\<lambda>_. True)))\n                       (rel_fun (eq_onp (\\<lambda>iu. iu \\<in> IU))\n                         (eq_onp (\\<lambda>_. True)))\n                       (trace_rest' rest p tr) (trace_rest' rest' q tr)", "apply(auto 4 3 simp add: eq_onp_def list_all_iff dest: rel_funD[where x=tr and y=tr])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma trace_rest_eq_simI:\n  fixes rest1 :: \"('s_rest, 'event, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest, 'more) rest_scheme\"\n    and rest2 :: \"('s_rest', 'event, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest, 'more) rest_scheme\"\n    and S :: \"'s_rest spmf \\<Rightarrow> 's_rest' spmf \\<Rightarrow> bool\"\n  assumes start: \"S p q\"\n    and step_rfunc_adv: \"\\<And>p q ia. \\<lbrakk> S p q; ia \\<in> IA \\<rbrakk> \\<Longrightarrow> \n      bind_spmf p (\\<lambda>s1. map_spmf fst (rfunc_adv rest1 s1 ia)) = bind_spmf q (\\<lambda>s2. map_spmf fst (rfunc_adv rest2 s2 ia))\"\n    and sim_rfunc_adv: \"\\<And>p q ia s1 s2 s1' s2' oa. \\<lbrakk> S p q; ia \\<in> IA; \n      s1 \\<in> set_spmf p; s2 \\<in> set_spmf q; (oa, s1') \\<in> set_spmf (rfunc_adv rest1 s1 ia); (oa, s2') \\<in> set_spmf (rfunc_adv rest2 s2 ia) \\<rbrakk>\n      \\<Longrightarrow> S (cond_spmf_fst (bind_spmf p (\\<lambda>s1. rfunc_adv rest1 s1 ia)) oa) (cond_spmf_fst (bind_spmf q (\\<lambda>s2. rfunc_adv rest2 s2 ia)) oa)\"\n    and step_rfunc_usr: \"\\<And>p q iu. \\<lbrakk> S p q; iu \\<in> IU \\<rbrakk> \\<Longrightarrow> \n      bind_spmf p (\\<lambda>s1. map_spmf fst (rfunc_usr rest1 s1 iu)) = bind_spmf q (\\<lambda>s2. map_spmf fst (rfunc_usr rest2 s2 iu))\"\n    and sim_rfunc_usr: \"\\<And>p q iu s1 s2 s1' s2' ou. \\<lbrakk> S p q; iu \\<in> IU; \n      s1 \\<in> set_spmf p; s2 \\<in> set_spmf q; (ou, s1') \\<in> set_spmf (rfunc_usr rest1 s1 iu); (ou, s2') \\<in> set_spmf (rfunc_usr rest2 s2 iu) \\<rbrakk>\n      \\<Longrightarrow> S (cond_spmf_fst (bind_spmf p (\\<lambda>s1. rfunc_usr rest1 s1 iu)) ou) (cond_spmf_fst (bind_spmf q (\\<lambda>s2. rfunc_usr rest2 s2 iu)) ou)\"\n  shows \"trace_rest_eq rest1 rest2 IA IU p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_rest_eq rest1 rest2 IA IU p q", "proof(rule trace_rest_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>tr ia.\n       \\<lbrakk>set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> fst (trace_rest' rest1 p tr) ia =\n                         fst (trace_rest' rest2 q tr) ia\n 2. \\<And>tr iu.\n       \\<lbrakk>set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> snd (trace_rest' rest1 p tr) iu =\n                         snd (trace_rest' rest2 q tr) iu", "fix tr :: \"('iadv_rest \\<times> 'oadv_rest \\<times> 'event list + 'iusr_rest \\<times> 'ousr_rest \\<times> 'event list) list\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>tr ia.\n       \\<lbrakk>set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> fst (trace_rest' rest1 p tr) ia =\n                         fst (trace_rest' rest2 q tr) ia\n 2. \\<And>tr iu.\n       \\<lbrakk>set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> snd (trace_rest' rest1 p tr) iu =\n                         snd (trace_rest' rest2 q tr) iu", "assume \"set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\""], ["proof (state)\nthis:\n  set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\n\ngoal (2 subgoals):\n 1. \\<And>tr ia.\n       \\<lbrakk>set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> fst (trace_rest' rest1 p tr) ia =\n                         fst (trace_rest' rest2 q tr) ia\n 2. \\<And>tr iu.\n       \\<lbrakk>set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> snd (trace_rest' rest1 p tr) iu =\n                         snd (trace_rest' rest2 q tr) iu", "then"], ["proof (chain)\npicking this:\n  set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV", "have \"(\\<forall>ia\\<in>IA. fst (trace_rest' rest1 p tr) ia = fst (trace_rest' rest2 q tr) ia) \\<and>\n       (\\<forall>iu\\<in>IU. snd (trace_rest' rest1 p tr) iu = snd (trace_rest' rest2 q tr) iu)\""], ["proof (prove)\nusing this:\n  set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\n\ngoal (1 subgoal):\n 1. (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p tr) ia =\n        fst (trace_rest' rest2 q tr) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p tr) iu = snd (trace_rest' rest2 q tr) iu)", "using start"], ["proof (prove)\nusing this:\n  set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\n  S p q\n\ngoal (1 subgoal):\n 1. (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p tr) ia =\n        fst (trace_rest' rest2 q tr) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p tr) iu = snd (trace_rest' rest2 q tr) iu)", "proof(induction tr arbitrary: p q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p q.\n       \\<lbrakk>set [] \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        S p q\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n                             fst (trace_rest' rest1 p []) ia =\n                             fst (trace_rest' rest2 q []) ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (trace_rest' rest1 p []) iu =\n                             snd (trace_rest' rest2 q []) iu)\n 2. \\<And>a tr p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>set tr\n                            \\<subseteq> IA \\<times> UNIV <+>\n  IU \\<times> UNIV;\n                    S p q\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n   fst (trace_rest' rest1 p tr) ia = fst (trace_rest' rest2 q tr) ia) \\<and>\n                                     (\\<forall>iu\\<in>IU.\n   snd (trace_rest' rest1 p tr) iu = snd (trace_rest' rest2 q tr) iu);\n        set (a # tr) \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        S p q\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n                             fst (trace_rest' rest1 p (a # tr)) ia =\n                             fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (trace_rest' rest1 p (a # tr)) iu =\n                             snd (trace_rest' rest2 q (a # tr)) iu)", "case Nil"], ["proof (state)\nthis:\n  set [] \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\n  S p q\n\ngoal (2 subgoals):\n 1. \\<And>p q.\n       \\<lbrakk>set [] \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        S p q\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n                             fst (trace_rest' rest1 p []) ia =\n                             fst (trace_rest' rest2 q []) ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (trace_rest' rest1 p []) iu =\n                             snd (trace_rest' rest2 q []) iu)\n 2. \\<And>a tr p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>set tr\n                            \\<subseteq> IA \\<times> UNIV <+>\n  IU \\<times> UNIV;\n                    S p q\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n   fst (trace_rest' rest1 p tr) ia = fst (trace_rest' rest2 q tr) ia) \\<and>\n                                     (\\<forall>iu\\<in>IU.\n   snd (trace_rest' rest1 p tr) iu = snd (trace_rest' rest2 q tr) iu);\n        set (a # tr) \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        S p q\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n                             fst (trace_rest' rest1 p (a # tr)) ia =\n                             fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (trace_rest' rest1 p (a # tr)) iu =\n                             snd (trace_rest' rest2 q (a # tr)) iu)", "then"], ["proof (chain)\npicking this:\n  set [] \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\n  S p q", "show ?case"], ["proof (prove)\nusing this:\n  set [] \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\n  S p q\n\ngoal (1 subgoal):\n 1. (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p []) ia =\n        fst (trace_rest' rest2 q []) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p []) iu = snd (trace_rest' rest2 q []) iu)", "by(simp add: step_rfunc_adv step_rfunc_usr)"], ["proof (state)\nthis:\n  (\\<forall>ia\\<in>IA.\n      fst (trace_rest' rest1 p []) ia =\n      fst (trace_rest' rest2 q []) ia) \\<and>\n  (\\<forall>iu\\<in>IU.\n      snd (trace_rest' rest1 p []) iu = snd (trace_rest' rest2 q []) iu)\n\ngoal (1 subgoal):\n 1. \\<And>a tr p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>set tr\n                            \\<subseteq> IA \\<times> UNIV <+>\n  IU \\<times> UNIV;\n                    S p q\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n   fst (trace_rest' rest1 p tr) ia = fst (trace_rest' rest2 q tr) ia) \\<and>\n                                     (\\<forall>iu\\<in>IU.\n   snd (trace_rest' rest1 p tr) iu = snd (trace_rest' rest2 q tr) iu);\n        set (a # tr) \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        S p q\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n                             fst (trace_rest' rest1 p (a # tr)) ia =\n                             fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (trace_rest' rest1 p (a # tr)) iu =\n                             snd (trace_rest' rest2 q (a # tr)) iu)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a tr p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>set tr\n                            \\<subseteq> IA \\<times> UNIV <+>\n  IU \\<times> UNIV;\n                    S p q\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n   fst (trace_rest' rest1 p tr) ia = fst (trace_rest' rest2 q tr) ia) \\<and>\n                                     (\\<forall>iu\\<in>IU.\n   snd (trace_rest' rest1 p tr) iu = snd (trace_rest' rest2 q tr) iu);\n        set (a # tr) \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        S p q\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n                             fst (trace_rest' rest1 p (a # tr)) ia =\n                             fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (trace_rest' rest1 p (a # tr)) iu =\n                             snd (trace_rest' rest2 q (a # tr)) iu)", "case (Cons a tr)"], ["proof (state)\nthis:\n  \\<lbrakk>set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV;\n   S ?p ?q\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n                        fst (trace_rest' rest1 ?p tr) ia =\n                        fst (trace_rest' rest2 ?q tr) ia) \\<and>\n                    (\\<forall>iu\\<in>IU.\n                        snd (trace_rest' rest1 ?p tr) iu =\n                        snd (trace_rest' rest2 ?q tr) iu)\n  set (a # tr) \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\n  S p q\n\ngoal (1 subgoal):\n 1. \\<And>a tr p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>set tr\n                            \\<subseteq> IA \\<times> UNIV <+>\n  IU \\<times> UNIV;\n                    S p q\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n   fst (trace_rest' rest1 p tr) ia = fst (trace_rest' rest2 q tr) ia) \\<and>\n                                     (\\<forall>iu\\<in>IU.\n   snd (trace_rest' rest1 p tr) iu = snd (trace_rest' rest2 q tr) iu);\n        set (a # tr) \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        S p q\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n                             fst (trace_rest' rest1 p (a # tr)) ia =\n                             fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (trace_rest' rest1 p (a # tr)) iu =\n                             snd (trace_rest' rest2 q (a # tr)) iu)", "from Cons.prems(1)"], ["proof (chain)\npicking this:\n  set (a # tr) \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV", "have tr: \"set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\""], ["proof (prove)\nusing this:\n  set (a # tr) \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\n\ngoal (1 subgoal):\n 1. set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV", "by simp"], ["proof (state)\nthis:\n  set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>a tr p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>set tr\n                            \\<subseteq> IA \\<times> UNIV <+>\n  IU \\<times> UNIV;\n                    S p q\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n   fst (trace_rest' rest1 p tr) ia = fst (trace_rest' rest2 q tr) ia) \\<and>\n                                     (\\<forall>iu\\<in>IU.\n   snd (trace_rest' rest1 p tr) iu = snd (trace_rest' rest2 q tr) iu);\n        set (a # tr) \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        S p q\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n                             fst (trace_rest' rest1 p (a # tr)) ia =\n                             fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (trace_rest' rest1 p (a # tr)) iu =\n                             snd (trace_rest' rest2 q (a # tr)) iu)", "from Cons.prems(1)"], ["proof (chain)\npicking this:\n  set (a # tr) \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV", "consider (rfunc_adv) ia oa where \"a = Inl (ia, oa)\" \"ia \\<in> IA\"\n      | (rfunc_usr) iu ou where \"a = Inr (iu, ou)\" \"iu \\<in> IU\""], ["proof (prove)\nusing this:\n  set (a # tr) \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ia oa.\n                \\<lbrakk>a = Inl (ia, oa); ia \\<in> IA\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>iu ou.\n        \\<lbrakk>a = Inr (iu, ou); iu \\<in> IU\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>ia oa.\n              \\<lbrakk>a = Inl (ia, oa); ia \\<in> IA\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>iu ou.\n      \\<lbrakk>a = Inr (iu, ou); iu \\<in> IU\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>a tr p q.\n       \\<lbrakk>\\<And>p q.\n                   \\<lbrakk>set tr\n                            \\<subseteq> IA \\<times> UNIV <+>\n  IU \\<times> UNIV;\n                    S p q\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n   fst (trace_rest' rest1 p tr) ia = fst (trace_rest' rest2 q tr) ia) \\<and>\n                                     (\\<forall>iu\\<in>IU.\n   snd (trace_rest' rest1 p tr) iu = snd (trace_rest' rest2 q tr) iu);\n        set (a # tr) \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        S p q\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n                             fst (trace_rest' rest1 p (a # tr)) ia =\n                             fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (trace_rest' rest1 p (a # tr)) iu =\n                             snd (trace_rest' rest2 q (a # tr)) iu)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>ia oa.\n              \\<lbrakk>a = Inl (ia, oa); ia \\<in> IA\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>iu ou.\n      \\<lbrakk>a = Inr (iu, ou); iu \\<in> IU\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>ia oa.\n              \\<lbrakk>a = Inl (ia, oa); ia \\<in> IA\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>iu ou.\n      \\<lbrakk>a = Inr (iu, ou); iu \\<in> IU\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia oa.\n       \\<lbrakk>a = Inl (ia, oa); ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n                             fst (trace_rest' rest1 p (a # tr)) ia =\n                             fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (trace_rest' rest1 p (a # tr)) iu =\n                             snd (trace_rest' rest2 q (a # tr)) iu)\n 2. \\<And>iu ou.\n       \\<lbrakk>a = Inr (iu, ou); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n                             fst (trace_rest' rest1 p (a # tr)) ia =\n                             fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (trace_rest' rest1 p (a # tr)) iu =\n                             snd (trace_rest' rest2 q (a # tr)) iu)", "case rfunc_adv"], ["proof (state)\nthis:\n  a = Inl (ia, oa)\n  ia \\<in> IA\n\ngoal (2 subgoals):\n 1. \\<And>ia oa.\n       \\<lbrakk>a = Inl (ia, oa); ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n                             fst (trace_rest' rest1 p (a # tr)) ia =\n                             fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (trace_rest' rest1 p (a # tr)) iu =\n                             snd (trace_rest' rest2 q (a # tr)) iu)\n 2. \\<And>iu ou.\n       \\<lbrakk>a = Inr (iu, ou); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n                             fst (trace_rest' rest1 p (a # tr)) ia =\n                             fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (trace_rest' rest1 p (a # tr)) iu =\n                             snd (trace_rest' rest2 q (a # tr)) iu)", "let ?p = \"bind_spmf p (\\<lambda>s1. rfunc_adv rest1 s1 ia)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia oa.\n       \\<lbrakk>a = Inl (ia, oa); ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n                             fst (trace_rest' rest1 p (a # tr)) ia =\n                             fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (trace_rest' rest1 p (a # tr)) iu =\n                             snd (trace_rest' rest2 q (a # tr)) iu)\n 2. \\<And>iu ou.\n       \\<lbrakk>a = Inr (iu, ou); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n                             fst (trace_rest' rest1 p (a # tr)) ia =\n                             fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (trace_rest' rest1 p (a # tr)) iu =\n                             snd (trace_rest' rest2 q (a # tr)) iu)", "let ?q = \"bind_spmf q (\\<lambda>s2. rfunc_adv rest2 s2 ia)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia oa.\n       \\<lbrakk>a = Inl (ia, oa); ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n                             fst (trace_rest' rest1 p (a # tr)) ia =\n                             fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (trace_rest' rest1 p (a # tr)) iu =\n                             snd (trace_rest' rest2 q (a # tr)) iu)\n 2. \\<And>iu ou.\n       \\<lbrakk>a = Inr (iu, ou); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n                             fst (trace_rest' rest1 p (a # tr)) ia =\n                             fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (trace_rest' rest1 p (a # tr)) iu =\n                             snd (trace_rest' rest2 q (a # tr)) iu)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "proof(cases \"oa \\<in> fst ` set_spmf ?p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. oa \\<in> fst `\n             set_spmf\n              (p \\<bind>\n               (\\<lambda>s1. rfunc_adv rest1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)\n 2. oa \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. rfunc_adv rest1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "case True"], ["proof (state)\nthis:\n  oa \\<in> fst ` set_spmf (p \\<bind> (\\<lambda>s1. rfunc_adv rest1 s1 ia))\n\ngoal (2 subgoals):\n 1. oa \\<in> fst `\n             set_spmf\n              (p \\<bind>\n               (\\<lambda>s1. rfunc_adv rest1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)\n 2. oa \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. rfunc_adv rest1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "with step_rfunc_adv[OF Cons.prems(2) rfunc_adv(2), THEN arg_cong[where f=set_spmf]]"], ["proof (chain)\npicking this:\n  set_spmf (p \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_adv rest1 s1 ia))) =\n  set_spmf (q \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_adv rest2 s2 ia)))\n  oa \\<in> fst ` set_spmf (p \\<bind> (\\<lambda>s1. rfunc_adv rest1 s1 ia))", "have \"oa \\<in> fst ` set_spmf ?q\""], ["proof (prove)\nusing this:\n  set_spmf (p \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_adv rest1 s1 ia))) =\n  set_spmf (q \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_adv rest2 s2 ia)))\n  oa \\<in> fst ` set_spmf (p \\<bind> (\\<lambda>s1. rfunc_adv rest1 s1 ia))\n\ngoal (1 subgoal):\n 1. oa \\<in> fst ` set_spmf (q \\<bind> (\\<lambda>s2. rfunc_adv rest2 s2 ia))", "unfolding set_map_spmf[symmetric]"], ["proof (prove)\nusing this:\n  set_spmf (p \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_adv rest1 s1 ia))) =\n  set_spmf (q \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_adv rest2 s2 ia)))\n  oa \\<in> set_spmf\n            (map_spmf fst (p \\<bind> (\\<lambda>s1. rfunc_adv rest1 s1 ia)))\n\ngoal (1 subgoal):\n 1. oa \\<in> set_spmf\n              (map_spmf fst\n                (q \\<bind> (\\<lambda>s2. rfunc_adv rest2 s2 ia)))", "by(simp only: map_bind_spmf o_def)"], ["proof (state)\nthis:\n  oa \\<in> fst ` set_spmf (q \\<bind> (\\<lambda>s2. rfunc_adv rest2 s2 ia))\n\ngoal (2 subgoals):\n 1. oa \\<in> fst `\n             set_spmf\n              (p \\<bind>\n               (\\<lambda>s1. rfunc_adv rest1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)\n 2. oa \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. rfunc_adv rest1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "then"], ["proof (chain)\npicking this:\n  oa \\<in> fst ` set_spmf (q \\<bind> (\\<lambda>s2. rfunc_adv rest2 s2 ia))", "show ?thesis"], ["proof (prove)\nusing this:\n  oa \\<in> fst ` set_spmf (q \\<bind> (\\<lambda>s2. rfunc_adv rest2 s2 ia))\n\ngoal (1 subgoal):\n 1. (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "using True Cons.prems rfunc_adv"], ["proof (prove)\nusing this:\n  oa \\<in> fst ` set_spmf (q \\<bind> (\\<lambda>s2. rfunc_adv rest2 s2 ia))\n  oa \\<in> fst ` set_spmf (p \\<bind> (\\<lambda>s1. rfunc_adv rest1 s1 ia))\n  set (a # tr) \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\n  S p q\n  a = Inl (ia, oa)\n  ia \\<in> IA\n\ngoal (1 subgoal):\n 1. (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "by(clarsimp)(rule Cons.IH; blast intro: sim_rfunc_adv)"], ["proof (state)\nthis:\n  (\\<forall>ia\\<in>IA.\n      fst (trace_rest' rest1 p (a # tr)) ia =\n      fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n  (\\<forall>iu\\<in>IU.\n      snd (trace_rest' rest1 p (a # tr)) iu =\n      snd (trace_rest' rest2 q (a # tr)) iu)\n\ngoal (1 subgoal):\n 1. oa \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. rfunc_adv rest1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. oa \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. rfunc_adv rest1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "case False"], ["proof (state)\nthis:\n  oa \\<notin> fst `\n              set_spmf (p \\<bind> (\\<lambda>s1. rfunc_adv rest1 s1 ia))\n\ngoal (1 subgoal):\n 1. oa \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. rfunc_adv rest1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "hence \"cond_spmf_fst ?p oa = return_pmf None\""], ["proof (prove)\nusing this:\n  oa \\<notin> fst `\n              set_spmf (p \\<bind> (\\<lambda>s1. rfunc_adv rest1 s1 ia))\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (p \\<bind> (\\<lambda>s1. rfunc_adv rest1 s1 ia)) oa =\n    return_pmf None", "by simp"], ["proof (state)\nthis:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s1. rfunc_adv rest1 s1 ia)) oa =\n  return_pmf None\n\ngoal (1 subgoal):\n 1. oa \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. rfunc_adv rest1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "moreover"], ["proof (state)\nthis:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s1. rfunc_adv rest1 s1 ia)) oa =\n  return_pmf None\n\ngoal (1 subgoal):\n 1. oa \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. rfunc_adv rest1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "from step_rfunc_adv[OF Cons.prems(2) rfunc_adv(2), THEN arg_cong[where f=set_spmf]] False"], ["proof (chain)\npicking this:\n  set_spmf (p \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_adv rest1 s1 ia))) =\n  set_spmf (q \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_adv rest2 s2 ia)))\n  oa \\<notin> fst `\n              set_spmf (p \\<bind> (\\<lambda>s1. rfunc_adv rest1 s1 ia))", "have oa': \"oa \\<notin> fst ` set_spmf ?q\""], ["proof (prove)\nusing this:\n  set_spmf (p \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_adv rest1 s1 ia))) =\n  set_spmf (q \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_adv rest2 s2 ia)))\n  oa \\<notin> fst `\n              set_spmf (p \\<bind> (\\<lambda>s1. rfunc_adv rest1 s1 ia))\n\ngoal (1 subgoal):\n 1. oa \\<notin> fst `\n                set_spmf (q \\<bind> (\\<lambda>s2. rfunc_adv rest2 s2 ia))", "unfolding set_map_spmf[symmetric]"], ["proof (prove)\nusing this:\n  set_spmf (p \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_adv rest1 s1 ia))) =\n  set_spmf (q \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_adv rest2 s2 ia)))\n  oa \\<notin> set_spmf\n               (map_spmf fst\n                 (p \\<bind> (\\<lambda>s1. rfunc_adv rest1 s1 ia)))\n\ngoal (1 subgoal):\n 1. oa \\<notin> set_spmf\n                 (map_spmf fst\n                   (q \\<bind> (\\<lambda>s2. rfunc_adv rest2 s2 ia)))", "by(simp only: map_bind_spmf o_def) simp"], ["proof (state)\nthis:\n  oa \\<notin> fst `\n              set_spmf (q \\<bind> (\\<lambda>s2. rfunc_adv rest2 s2 ia))\n\ngoal (1 subgoal):\n 1. oa \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. rfunc_adv rest1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "hence \"cond_spmf_fst ?q oa = return_pmf None\""], ["proof (prove)\nusing this:\n  oa \\<notin> fst `\n              set_spmf (q \\<bind> (\\<lambda>s2. rfunc_adv rest2 s2 ia))\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (q \\<bind> (\\<lambda>s2. rfunc_adv rest2 s2 ia)) oa =\n    return_pmf None", "by simp"], ["proof (state)\nthis:\n  cond_spmf_fst (q \\<bind> (\\<lambda>s2. rfunc_adv rest2 s2 ia)) oa =\n  return_pmf None\n\ngoal (1 subgoal):\n 1. oa \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. rfunc_adv rest1 s1 ia)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "ultimately"], ["proof (chain)\npicking this:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s1. rfunc_adv rest1 s1 ia)) oa =\n  return_pmf None\n  cond_spmf_fst (q \\<bind> (\\<lambda>s2. rfunc_adv rest2 s2 ia)) oa =\n  return_pmf None", "show ?thesis"], ["proof (prove)\nusing this:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s1. rfunc_adv rest1 s1 ia)) oa =\n  return_pmf None\n  cond_spmf_fst (q \\<bind> (\\<lambda>s2. rfunc_adv rest2 s2 ia)) oa =\n  return_pmf None\n\ngoal (1 subgoal):\n 1. (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "using rfunc_adv"], ["proof (prove)\nusing this:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s1. rfunc_adv rest1 s1 ia)) oa =\n  return_pmf None\n  cond_spmf_fst (q \\<bind> (\\<lambda>s2. rfunc_adv rest2 s2 ia)) oa =\n  return_pmf None\n  a = Inl (ia, oa)\n  ia \\<in> IA\n\ngoal (1 subgoal):\n 1. (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "by(simp del: cond_spmf_fst_eq_return_None)"], ["proof (state)\nthis:\n  (\\<forall>ia\\<in>IA.\n      fst (trace_rest' rest1 p (a # tr)) ia =\n      fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n  (\\<forall>iu\\<in>IU.\n      snd (trace_rest' rest1 p (a # tr)) iu =\n      snd (trace_rest' rest2 q (a # tr)) iu)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>ia\\<in>IA.\n      fst (trace_rest' rest1 p (a # tr)) ia =\n      fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n  (\\<forall>iu\\<in>IU.\n      snd (trace_rest' rest1 p (a # tr)) iu =\n      snd (trace_rest' rest2 q (a # tr)) iu)\n\ngoal (1 subgoal):\n 1. \\<And>iu ou.\n       \\<lbrakk>a = Inr (iu, ou); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n                             fst (trace_rest' rest1 p (a # tr)) ia =\n                             fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (trace_rest' rest1 p (a # tr)) iu =\n                             snd (trace_rest' rest2 q (a # tr)) iu)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>iu ou.\n       \\<lbrakk>a = Inr (iu, ou); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n                             fst (trace_rest' rest1 p (a # tr)) ia =\n                             fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (trace_rest' rest1 p (a # tr)) iu =\n                             snd (trace_rest' rest2 q (a # tr)) iu)", "case rfunc_usr"], ["proof (state)\nthis:\n  a = Inr (iu, ou)\n  iu \\<in> IU\n\ngoal (1 subgoal):\n 1. \\<And>iu ou.\n       \\<lbrakk>a = Inr (iu, ou); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n                             fst (trace_rest' rest1 p (a # tr)) ia =\n                             fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (trace_rest' rest1 p (a # tr)) iu =\n                             snd (trace_rest' rest2 q (a # tr)) iu)", "let ?p = \"bind_spmf p (\\<lambda>s1. rfunc_usr rest1 s1 iu)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>iu ou.\n       \\<lbrakk>a = Inr (iu, ou); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n                             fst (trace_rest' rest1 p (a # tr)) ia =\n                             fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (trace_rest' rest1 p (a # tr)) iu =\n                             snd (trace_rest' rest2 q (a # tr)) iu)", "let ?q = \"bind_spmf q (\\<lambda>s2. rfunc_usr rest2 s2 iu)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>iu ou.\n       \\<lbrakk>a = Inr (iu, ou); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>ia\\<in>IA.\n                             fst (trace_rest' rest1 p (a # tr)) ia =\n                             fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n                         (\\<forall>iu\\<in>IU.\n                             snd (trace_rest' rest1 p (a # tr)) iu =\n                             snd (trace_rest' rest2 q (a # tr)) iu)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "proof(cases \"ou \\<in> fst ` set_spmf ?p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ou \\<in> fst `\n             set_spmf\n              (p \\<bind>\n               (\\<lambda>s1. rfunc_usr rest1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)\n 2. ou \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. rfunc_usr rest1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "case True"], ["proof (state)\nthis:\n  ou \\<in> fst ` set_spmf (p \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 iu))\n\ngoal (2 subgoals):\n 1. ou \\<in> fst `\n             set_spmf\n              (p \\<bind>\n               (\\<lambda>s1. rfunc_usr rest1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)\n 2. ou \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. rfunc_usr rest1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "with step_rfunc_usr[OF Cons.prems(2) rfunc_usr(2), THEN arg_cong[where f=set_spmf]]"], ["proof (chain)\npicking this:\n  set_spmf (p \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_usr rest1 s1 iu))) =\n  set_spmf (q \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_usr rest2 s2 iu)))\n  ou \\<in> fst ` set_spmf (p \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 iu))", "have \"ou \\<in> fst ` set_spmf ?q\""], ["proof (prove)\nusing this:\n  set_spmf (p \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_usr rest1 s1 iu))) =\n  set_spmf (q \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_usr rest2 s2 iu)))\n  ou \\<in> fst ` set_spmf (p \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 iu))\n\ngoal (1 subgoal):\n 1. ou \\<in> fst ` set_spmf (q \\<bind> (\\<lambda>s2. rfunc_usr rest2 s2 iu))", "unfolding set_map_spmf[symmetric]"], ["proof (prove)\nusing this:\n  set_spmf (p \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_usr rest1 s1 iu))) =\n  set_spmf (q \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_usr rest2 s2 iu)))\n  ou \\<in> set_spmf\n            (map_spmf fst (p \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 iu)))\n\ngoal (1 subgoal):\n 1. ou \\<in> set_spmf\n              (map_spmf fst\n                (q \\<bind> (\\<lambda>s2. rfunc_usr rest2 s2 iu)))", "by(simp only: map_bind_spmf o_def)"], ["proof (state)\nthis:\n  ou \\<in> fst ` set_spmf (q \\<bind> (\\<lambda>s2. rfunc_usr rest2 s2 iu))\n\ngoal (2 subgoals):\n 1. ou \\<in> fst `\n             set_spmf\n              (p \\<bind>\n               (\\<lambda>s1. rfunc_usr rest1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)\n 2. ou \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. rfunc_usr rest1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "then"], ["proof (chain)\npicking this:\n  ou \\<in> fst ` set_spmf (q \\<bind> (\\<lambda>s2. rfunc_usr rest2 s2 iu))", "show ?thesis"], ["proof (prove)\nusing this:\n  ou \\<in> fst ` set_spmf (q \\<bind> (\\<lambda>s2. rfunc_usr rest2 s2 iu))\n\ngoal (1 subgoal):\n 1. (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "using True Cons.prems rfunc_usr"], ["proof (prove)\nusing this:\n  ou \\<in> fst ` set_spmf (q \\<bind> (\\<lambda>s2. rfunc_usr rest2 s2 iu))\n  ou \\<in> fst ` set_spmf (p \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 iu))\n  set (a # tr) \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\n  S p q\n  a = Inr (iu, ou)\n  iu \\<in> IU\n\ngoal (1 subgoal):\n 1. (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "by(clarsimp)(rule Cons.IH; blast intro: sim_rfunc_usr)"], ["proof (state)\nthis:\n  (\\<forall>ia\\<in>IA.\n      fst (trace_rest' rest1 p (a # tr)) ia =\n      fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n  (\\<forall>iu\\<in>IU.\n      snd (trace_rest' rest1 p (a # tr)) iu =\n      snd (trace_rest' rest2 q (a # tr)) iu)\n\ngoal (1 subgoal):\n 1. ou \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. rfunc_usr rest1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ou \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. rfunc_usr rest1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "case False"], ["proof (state)\nthis:\n  ou \\<notin> fst `\n              set_spmf (p \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 iu))\n\ngoal (1 subgoal):\n 1. ou \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. rfunc_usr rest1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "hence \"cond_spmf_fst ?p ou = return_pmf None\""], ["proof (prove)\nusing this:\n  ou \\<notin> fst `\n              set_spmf (p \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 iu))\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (p \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 iu)) ou =\n    return_pmf None", "by simp"], ["proof (state)\nthis:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 iu)) ou =\n  return_pmf None\n\ngoal (1 subgoal):\n 1. ou \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. rfunc_usr rest1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "moreover"], ["proof (state)\nthis:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 iu)) ou =\n  return_pmf None\n\ngoal (1 subgoal):\n 1. ou \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. rfunc_usr rest1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "from step_rfunc_usr[OF Cons.prems(2) rfunc_usr(2), THEN arg_cong[where f=set_spmf]] False"], ["proof (chain)\npicking this:\n  set_spmf (p \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_usr rest1 s1 iu))) =\n  set_spmf (q \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_usr rest2 s2 iu)))\n  ou \\<notin> fst `\n              set_spmf (p \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 iu))", "have oa': \"ou \\<notin> fst ` set_spmf ?q\""], ["proof (prove)\nusing this:\n  set_spmf (p \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_usr rest1 s1 iu))) =\n  set_spmf (q \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_usr rest2 s2 iu)))\n  ou \\<notin> fst `\n              set_spmf (p \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 iu))\n\ngoal (1 subgoal):\n 1. ou \\<notin> fst `\n                set_spmf (q \\<bind> (\\<lambda>s2. rfunc_usr rest2 s2 iu))", "unfolding set_map_spmf[symmetric]"], ["proof (prove)\nusing this:\n  set_spmf (p \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_usr rest1 s1 iu))) =\n  set_spmf (q \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_usr rest2 s2 iu)))\n  ou \\<notin> set_spmf\n               (map_spmf fst\n                 (p \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 iu)))\n\ngoal (1 subgoal):\n 1. ou \\<notin> set_spmf\n                 (map_spmf fst\n                   (q \\<bind> (\\<lambda>s2. rfunc_usr rest2 s2 iu)))", "by(simp only: map_bind_spmf o_def) simp"], ["proof (state)\nthis:\n  ou \\<notin> fst `\n              set_spmf (q \\<bind> (\\<lambda>s2. rfunc_usr rest2 s2 iu))\n\ngoal (1 subgoal):\n 1. ou \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. rfunc_usr rest1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "hence \"cond_spmf_fst ?q ou = return_pmf None\""], ["proof (prove)\nusing this:\n  ou \\<notin> fst `\n              set_spmf (q \\<bind> (\\<lambda>s2. rfunc_usr rest2 s2 iu))\n\ngoal (1 subgoal):\n 1. cond_spmf_fst (q \\<bind> (\\<lambda>s2. rfunc_usr rest2 s2 iu)) ou =\n    return_pmf None", "by simp"], ["proof (state)\nthis:\n  cond_spmf_fst (q \\<bind> (\\<lambda>s2. rfunc_usr rest2 s2 iu)) ou =\n  return_pmf None\n\ngoal (1 subgoal):\n 1. ou \\<notin> fst `\n                set_spmf\n                 (p \\<bind>\n                  (\\<lambda>s1. rfunc_usr rest1 s1 iu)) \\<Longrightarrow>\n    (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "ultimately"], ["proof (chain)\npicking this:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 iu)) ou =\n  return_pmf None\n  cond_spmf_fst (q \\<bind> (\\<lambda>s2. rfunc_usr rest2 s2 iu)) ou =\n  return_pmf None", "show ?thesis"], ["proof (prove)\nusing this:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 iu)) ou =\n  return_pmf None\n  cond_spmf_fst (q \\<bind> (\\<lambda>s2. rfunc_usr rest2 s2 iu)) ou =\n  return_pmf None\n\ngoal (1 subgoal):\n 1. (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "using rfunc_usr"], ["proof (prove)\nusing this:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 iu)) ou =\n  return_pmf None\n  cond_spmf_fst (q \\<bind> (\\<lambda>s2. rfunc_usr rest2 s2 iu)) ou =\n  return_pmf None\n  a = Inr (iu, ou)\n  iu \\<in> IU\n\ngoal (1 subgoal):\n 1. (\\<forall>ia\\<in>IA.\n        fst (trace_rest' rest1 p (a # tr)) ia =\n        fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n    (\\<forall>iu\\<in>IU.\n        snd (trace_rest' rest1 p (a # tr)) iu =\n        snd (trace_rest' rest2 q (a # tr)) iu)", "by(simp del: cond_spmf_fst_eq_return_None)"], ["proof (state)\nthis:\n  (\\<forall>ia\\<in>IA.\n      fst (trace_rest' rest1 p (a # tr)) ia =\n      fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n  (\\<forall>iu\\<in>IU.\n      snd (trace_rest' rest1 p (a # tr)) iu =\n      snd (trace_rest' rest2 q (a # tr)) iu)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>ia\\<in>IA.\n      fst (trace_rest' rest1 p (a # tr)) ia =\n      fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n  (\\<forall>iu\\<in>IU.\n      snd (trace_rest' rest1 p (a # tr)) iu =\n      snd (trace_rest' rest2 q (a # tr)) iu)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>ia\\<in>IA.\n      fst (trace_rest' rest1 p (a # tr)) ia =\n      fst (trace_rest' rest2 q (a # tr)) ia) \\<and>\n  (\\<forall>iu\\<in>IU.\n      snd (trace_rest' rest1 p (a # tr)) iu =\n      snd (trace_rest' rest2 q (a # tr)) iu)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>ia\\<in>IA.\n      fst (trace_rest' rest1 p tr) ia =\n      fst (trace_rest' rest2 q tr) ia) \\<and>\n  (\\<forall>iu\\<in>IU.\n      snd (trace_rest' rest1 p tr) iu = snd (trace_rest' rest2 q tr) iu)\n\ngoal (2 subgoals):\n 1. \\<And>tr ia.\n       \\<lbrakk>set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> fst (trace_rest' rest1 p tr) ia =\n                         fst (trace_rest' rest2 q tr) ia\n 2. \\<And>tr iu.\n       \\<lbrakk>set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV;\n        iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> snd (trace_rest' rest1 p tr) iu =\n                         snd (trace_rest' rest2 q tr) iu", "then"], ["proof (chain)\npicking this:\n  (\\<forall>ia\\<in>IA.\n      fst (trace_rest' rest1 p tr) ia =\n      fst (trace_rest' rest2 q tr) ia) \\<and>\n  (\\<forall>iu\\<in>IU.\n      snd (trace_rest' rest1 p tr) iu = snd (trace_rest' rest2 q tr) iu)", "show \"ia \\<in> IA \\<Longrightarrow> fst (trace_rest' rest1 p tr) ia = fst (trace_rest' rest2 q tr) ia\"\n    and \"iu \\<in> IU \\<Longrightarrow> snd (trace_rest' rest1 p tr) iu = snd (trace_rest' rest2 q tr) iu\"\n    for ia iu"], ["proof (prove)\nusing this:\n  (\\<forall>ia\\<in>IA.\n      fst (trace_rest' rest1 p tr) ia =\n      fst (trace_rest' rest2 q tr) ia) \\<and>\n  (\\<forall>iu\\<in>IU.\n      snd (trace_rest' rest1 p tr) iu = snd (trace_rest' rest2 q tr) iu)\n\ngoal (1 subgoal):\n 1. (ia \\<in> IA \\<Longrightarrow>\n     fst (trace_rest' rest1 p tr) ia = fst (trace_rest' rest2 q tr) ia) &&&\n    (iu \\<in> IU \\<Longrightarrow>\n     snd (trace_rest' rest1 p tr) iu = snd (trace_rest' rest2 q tr) iu)", "by blast+"], ["proof (state)\nthis:\n  ?ia \\<in> IA \\<Longrightarrow>\n  fst (trace_rest' rest1 p tr) ?ia = fst (trace_rest' rest2 q tr) ?ia\n  ?iu \\<in> IU \\<Longrightarrow>\n  snd (trace_rest' rest1 p tr) ?iu = snd (trace_rest' rest2 q tr) ?iu\n\ngoal:\nNo subgoals!", "qed"], ["", "context \n  fixes rest :: \"('s_rest, 'event, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest, 'more) rest_scheme\"\nbegin"], ["", "fun trace_rest_aux \n  :: \"'s_rest spmf \\<Rightarrow> ('iadv_rest \\<times> 'oadv_rest \\<times> 'event list + 'iusr_rest \\<times> 'ousr_rest \\<times> 'event list) list \\<Rightarrow> 's_rest spmf\" where\n  \"trace_rest_aux p [] = p\"\n| \"trace_rest_aux p (Inl (ia, oaes) # tr) = trace_rest_aux (cond_spmf_fst (bind_spmf p (\\<lambda>s. rfunc_adv rest s ia)) oaes) tr\"\n| \"trace_rest_aux p (Inr (iu, oues) # tr) = trace_rest_aux (cond_spmf_fst (bind_spmf p (\\<lambda>s. rfunc_usr rest s iu)) oues) tr\""], ["", "end"], ["", "lemma trace_rest_conv_trace_rest_aux:\n  \"trace_rest' rest p tr = \n   (\\<lambda>ia. bind_spmf (trace_rest_aux rest p tr) (\\<lambda>s. map_spmf fst (rfunc_adv rest s ia)),\n    \\<lambda>iu. bind_spmf (trace_rest_aux rest p tr) (\\<lambda>s. map_spmf fst (rfunc_usr rest s iu)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_rest' rest p tr =\n    (\\<lambda>ia.\n        trace_rest_aux rest p tr \\<bind>\n        (\\<lambda>s. map_spmf fst (rfunc_adv rest s ia)),\n     \\<lambda>iu.\n        trace_rest_aux rest p tr \\<bind>\n        (\\<lambda>s. map_spmf fst (rfunc_usr rest s iu)))", "by(induction p tr rule: trace_rest_aux.induct) simp_all"], ["", "lemma trace_rest_aux_append:\n  \"trace_rest_aux rest p (tr @ tr') = trace_rest_aux rest (trace_rest_aux rest p tr) tr'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_rest_aux rest p (tr @ tr') =\n    trace_rest_aux rest (trace_rest_aux rest p tr) tr'", "by(induction p tr rule: trace_rest_aux.induct) auto"], ["", "inductive trace_rest_closure \n  :: \"('s_rest, 'event, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest, 'more) rest_scheme\n  \\<Rightarrow> ('s_rest', 'event, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest, 'more') rest_scheme\n  \\<Rightarrow> 'iadv_rest set \\<Rightarrow> 'iusr_rest set\n  \\<Rightarrow> 's_rest spmf \\<Rightarrow> 's_rest' spmf \\<Rightarrow> 's_rest spmf \\<Rightarrow> 's_rest' spmf \\<Rightarrow> bool\"\n  for rest1 rest2 IA IU p q where\n  \"trace_rest_closure rest1 rest2 IA IU p q (trace_rest_aux rest1 p tr) (trace_rest_aux rest2 q tr)\"\n  if \"set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\""], ["", "lemma trace_rest_closure_start: \"trace_rest_closure rest1 rest2 IA IU p q p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_rest_closure rest1 rest2 IA IU p q p q", "by(simp add: trace_rest_closure.simps exI[where x=\"[]\"])"], ["", "lemma trace_rest_closure_step:\n  assumes \"trace_rest_eq rest1 rest2 IA IU p q\"\n    and \"trace_rest_closure rest1 rest2 IA IU p q p' q'\"\n  shows trace_rest_closure_step_rfunc_adv: \n    \"ia \\<in> IA \\<Longrightarrow> bind_spmf p' (\\<lambda>s1. map_spmf fst (rfunc_adv rest1 s1 ia)) = bind_spmf q' (\\<lambda>s2. map_spmf fst (rfunc_adv rest2 s2 ia))\"\n    (is \"PROP ?thesis1\")\n    and trace_rest_closure_step_rfunc_usr:\n    \"iu \\<in> IU \\<Longrightarrow> bind_spmf p' (\\<lambda>s1. map_spmf fst (rfunc_usr rest1 s1 iu)) = bind_spmf q' (\\<lambda>s2. map_spmf fst (rfunc_usr rest2 s2 iu))\"\n    (is \"PROP ?thesis2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ia \\<in> IA \\<Longrightarrow>\n     p' \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_adv rest1 s1 ia)) =\n     q' \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_adv rest2 s2 ia))) &&&\n    (iu \\<in> IU \\<Longrightarrow>\n     p' \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_usr rest1 s1 iu)) =\n     q' \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_usr rest2 s2 iu)))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. ia \\<in> IA \\<Longrightarrow>\n    p' \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_adv rest1 s1 ia)) =\n    q' \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_adv rest2 s2 ia))\n 2. iu \\<in> IU \\<Longrightarrow>\n    p' \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_usr rest1 s1 iu)) =\n    q' \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_usr rest2 s2 iu))", "from assms(2)"], ["proof (chain)\npicking this:\n  trace_rest_closure rest1 rest2 IA IU p q p' q'", "obtain tr where p: \"p' = trace_rest_aux rest1 p tr\"\n    and q: \"q' = trace_rest_aux rest2 q tr\"\n    and tr: \"set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\""], ["proof (prove)\nusing this:\n  trace_rest_closure rest1 rest2 IA IU p q p' q'\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        \\<lbrakk>p' = trace_rest_aux rest1 p tr;\n         q' = trace_rest_aux rest2 q tr;\n         set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  p' = trace_rest_aux rest1 p tr\n  q' = trace_rest_aux rest2 q tr\n  set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\n\ngoal (2 subgoals):\n 1. ia \\<in> IA \\<Longrightarrow>\n    p' \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_adv rest1 s1 ia)) =\n    q' \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_adv rest2 s2 ia))\n 2. iu \\<in> IU \\<Longrightarrow>\n    p' \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_usr rest1 s1 iu)) =\n    q' \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_usr rest2 s2 iu))", "from trace_rest_eqD[OF assms(1) tr] p q"], ["proof (chain)\npicking this:\n  ?ia \\<in> IA \\<Longrightarrow>\n  fst (trace_rest' rest1 p tr) ?ia = fst (trace_rest' rest2 q tr) ?ia\n  ?iu \\<in> IU \\<Longrightarrow>\n  snd (trace_rest' rest1 p tr) ?iu = snd (trace_rest' rest2 q tr) ?iu\n  p' = trace_rest_aux rest1 p tr\n  q' = trace_rest_aux rest2 q tr", "show \"PROP ?thesis1\" and \"PROP ?thesis2\""], ["proof (prove)\nusing this:\n  ?ia \\<in> IA \\<Longrightarrow>\n  fst (trace_rest' rest1 p tr) ?ia = fst (trace_rest' rest2 q tr) ?ia\n  ?iu \\<in> IU \\<Longrightarrow>\n  snd (trace_rest' rest1 p tr) ?iu = snd (trace_rest' rest2 q tr) ?iu\n  p' = trace_rest_aux rest1 p tr\n  q' = trace_rest_aux rest2 q tr\n\ngoal (1 subgoal):\n 1. (ia \\<in> IA \\<Longrightarrow>\n     p' \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_adv rest1 s1 ia)) =\n     q' \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_adv rest2 s2 ia))) &&&\n    (iu \\<in> IU \\<Longrightarrow>\n     p' \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_usr rest1 s1 iu)) =\n     q' \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_usr rest2 s2 iu)))", "by(simp_all add: trace_rest_conv_trace_rest_aux)"], ["proof (state)\nthis:\n  ia \\<in> IA \\<Longrightarrow>\n  p' \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_adv rest1 s1 ia)) =\n  q' \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_adv rest2 s2 ia))\n  iu \\<in> IU \\<Longrightarrow>\n  p' \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_usr rest1 s1 iu)) =\n  q' \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_usr rest2 s2 iu))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_rest_closure_sim:\n  fixes rest1 rest2 IA IU p q\n  defines \"S \\<equiv> trace_rest_closure rest1 rest2 IA IU p q\"\n  assumes \"S p' q'\"\n  shows trace_rest_closure_sim_rfunc_adv: \"ia \\<in> IA \n    \\<Longrightarrow> S (cond_spmf_fst (bind_spmf p' (\\<lambda>s1. rfunc_adv rest1 s1 ia)) oa) \n          (cond_spmf_fst (bind_spmf q' (\\<lambda>s2. rfunc_adv rest2 s2 ia)) oa)\"\n    (is \"PROP ?thesis1\")\n    and trace_rest_closure_sim_rfunc_usr: \"iu \\<in> IU \n    \\<Longrightarrow> S (cond_spmf_fst (bind_spmf p' (\\<lambda>s1. rfunc_usr rest1 s1 iu)) ou)\n          (cond_spmf_fst (bind_spmf q' (\\<lambda>s2. rfunc_usr rest2 s2 iu)) ou)\"\n    (is \"PROP ?thesis2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ia \\<in> IA \\<Longrightarrow>\n     S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. rfunc_adv rest1 s1 ia)) oa)\n      (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. rfunc_adv rest2 s2 ia))\n        oa)) &&&\n    (iu \\<in> IU \\<Longrightarrow>\n     S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 iu)) ou)\n      (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. rfunc_usr rest2 s2 iu)) ou))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. ia \\<in> IA \\<Longrightarrow>\n    S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. rfunc_adv rest1 s1 ia)) oa)\n     (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. rfunc_adv rest2 s2 ia)) oa)\n 2. iu \\<in> IU \\<Longrightarrow>\n    S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 iu)) ou)\n     (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. rfunc_usr rest2 s2 iu)) ou)", "from assms(2)"], ["proof (chain)\npicking this:\n  S p' q'", "obtain tr where p: \"p' = trace_rest_aux rest1 p tr\"\n    and q: \"q' = trace_rest_aux rest2 q tr\"\n    and tr: \"set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\""], ["proof (prove)\nusing this:\n  S p' q'\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        \\<lbrakk>p' = trace_rest_aux rest1 p tr;\n         q' = trace_rest_aux rest2 q tr;\n         set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding S_def"], ["proof (prove)\nusing this:\n  trace_rest_closure rest1 rest2 IA IU p q p' q'\n\ngoal (1 subgoal):\n 1. (\\<And>tr.\n        \\<lbrakk>p' = trace_rest_aux rest1 p tr;\n         q' = trace_rest_aux rest2 q tr;\n         set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  p' = trace_rest_aux rest1 p tr\n  q' = trace_rest_aux rest2 q tr\n  set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\n\ngoal (2 subgoals):\n 1. ia \\<in> IA \\<Longrightarrow>\n    S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. rfunc_adv rest1 s1 ia)) oa)\n     (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. rfunc_adv rest2 s2 ia)) oa)\n 2. iu \\<in> IU \\<Longrightarrow>\n    S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 iu)) ou)\n     (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. rfunc_usr rest2 s2 iu)) ou)", "show \"PROP ?thesis1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ia \\<in> IA \\<Longrightarrow>\n    S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. rfunc_adv rest1 s1 ia)) oa)\n     (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. rfunc_adv rest2 s2 ia)) oa)", "using p q tr"], ["proof (prove)\nusing this:\n  p' = trace_rest_aux rest1 p tr\n  q' = trace_rest_aux rest2 q tr\n  set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\n\ngoal (1 subgoal):\n 1. ia \\<in> IA \\<Longrightarrow>\n    S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. rfunc_adv rest1 s1 ia)) oa)\n     (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. rfunc_adv rest2 s2 ia)) oa)", "by(auto simp add: S_def trace_rest_closure.simps trace_rest_aux_append intro!: exI[where x=\"tr @ [Inl (_, _)]\"])"], ["proof (state)\nthis:\n  ia \\<in> IA \\<Longrightarrow>\n  S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. rfunc_adv rest1 s1 ia)) oa)\n   (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. rfunc_adv rest2 s2 ia)) oa)\n\ngoal (1 subgoal):\n 1. iu \\<in> IU \\<Longrightarrow>\n    S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 iu)) ou)\n     (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. rfunc_usr rest2 s2 iu)) ou)", "show \"PROP ?thesis2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iu \\<in> IU \\<Longrightarrow>\n    S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 iu)) ou)\n     (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. rfunc_usr rest2 s2 iu)) ou)", "using p q tr"], ["proof (prove)\nusing this:\n  p' = trace_rest_aux rest1 p tr\n  q' = trace_rest_aux rest2 q tr\n  set tr \\<subseteq> IA \\<times> UNIV <+> IU \\<times> UNIV\n\ngoal (1 subgoal):\n 1. iu \\<in> IU \\<Longrightarrow>\n    S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 iu)) ou)\n     (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. rfunc_usr rest2 s2 iu)) ou)", "by(auto simp add: S_def trace_rest_closure.simps trace_rest_aux_append intro!: exI[where x=\"tr @ [Inr (_, _)]\"])"], ["proof (state)\nthis:\n  iu \\<in> IU \\<Longrightarrow>\n  S (cond_spmf_fst (p' \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 iu)) ou)\n   (cond_spmf_fst (q' \\<bind> (\\<lambda>s2. rfunc_usr rest2 s2 iu)) ou)\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition trace_rest_eq_complete:\n  assumes \"trace_rest_eq rest1 rest2 IA IU p q\"\n  obtains S\n  where \"S p q\"\n    and \"\\<And>p q ia. \\<lbrakk> S p q; ia \\<in> IA \\<rbrakk> \\<Longrightarrow> \n      bind_spmf p (\\<lambda>s1. map_spmf fst (rfunc_adv rest1 s1 ia)) = bind_spmf q (\\<lambda>s2. map_spmf fst (rfunc_adv rest2 s2 ia))\"\n    and \"\\<And>p q ia oa. \\<lbrakk> S p q; ia \\<in> IA \\<rbrakk>\n      \\<Longrightarrow> S (cond_spmf_fst (bind_spmf p (\\<lambda>s1. rfunc_adv rest1 s1 ia)) oa) (cond_spmf_fst (bind_spmf q (\\<lambda>s2. rfunc_adv rest2 s2 ia)) oa)\"\n    and \"\\<And>p q iu. \\<lbrakk> S p q; iu \\<in> IU \\<rbrakk> \\<Longrightarrow> \n      bind_spmf p (\\<lambda>s1. map_spmf fst (rfunc_usr rest1 s1 iu)) = bind_spmf q (\\<lambda>s2. map_spmf fst (rfunc_usr rest2 s2 iu))\"\n    and \"\\<And>p q iu ou. \\<lbrakk> S p q; iu \\<in> IU \\<rbrakk>\n      \\<Longrightarrow> S (cond_spmf_fst (bind_spmf p (\\<lambda>s1. rfunc_usr rest1 s1 iu)) ou) (cond_spmf_fst (bind_spmf q (\\<lambda>s2. rfunc_usr rest2 s2 iu)) ou)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>S p q;\n         \\<And>p q ia.\n            \\<lbrakk>S p q; ia \\<in> IA\\<rbrakk>\n            \\<Longrightarrow> p \\<bind>\n                              (\\<lambda>s1.\n                                  map_spmf fst (rfunc_adv rest1 s1 ia)) =\n                              q \\<bind>\n                              (\\<lambda>s2.\n                                  map_spmf fst (rfunc_adv rest2 s2 ia));\n         \\<And>p q ia oa.\n            \\<lbrakk>S p q; ia \\<in> IA\\<rbrakk>\n            \\<Longrightarrow> S (cond_spmf_fst\n                                  (p \\<bind>\n                                   (\\<lambda>s1. rfunc_adv rest1 s1 ia))\n                                  oa)\n                               (cond_spmf_fst\n                                 (q \\<bind>\n                                  (\\<lambda>s2. rfunc_adv rest2 s2 ia))\n                                 oa);\n         \\<And>p q iu.\n            \\<lbrakk>S p q; iu \\<in> IU\\<rbrakk>\n            \\<Longrightarrow> p \\<bind>\n                              (\\<lambda>s1.\n                                  map_spmf fst (rfunc_usr rest1 s1 iu)) =\n                              q \\<bind>\n                              (\\<lambda>s2.\n                                  map_spmf fst (rfunc_usr rest2 s2 iu));\n         \\<And>p q iu ou.\n            \\<lbrakk>S p q; iu \\<in> IU\\<rbrakk>\n            \\<Longrightarrow> S (cond_spmf_fst\n                                  (p \\<bind>\n                                   (\\<lambda>s1. rfunc_usr rest1 s1 iu))\n                                  ou)\n                               (cond_spmf_fst\n                                 (q \\<bind>\n                                  (\\<lambda>s2. rfunc_usr rest2 s2 iu))\n                                 ou)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>S p q;\n         \\<And>p q ia.\n            \\<lbrakk>S p q; ia \\<in> IA\\<rbrakk>\n            \\<Longrightarrow> p \\<bind>\n                              (\\<lambda>s1.\n                                  map_spmf fst (rfunc_adv rest1 s1 ia)) =\n                              q \\<bind>\n                              (\\<lambda>s2.\n                                  map_spmf fst (rfunc_adv rest2 s2 ia));\n         \\<And>p q ia oa.\n            \\<lbrakk>S p q; ia \\<in> IA\\<rbrakk>\n            \\<Longrightarrow> S (cond_spmf_fst\n                                  (p \\<bind>\n                                   (\\<lambda>s1. rfunc_adv rest1 s1 ia))\n                                  oa)\n                               (cond_spmf_fst\n                                 (q \\<bind>\n                                  (\\<lambda>s2. rfunc_adv rest2 s2 ia))\n                                 oa);\n         \\<And>p q iu.\n            \\<lbrakk>S p q; iu \\<in> IU\\<rbrakk>\n            \\<Longrightarrow> p \\<bind>\n                              (\\<lambda>s1.\n                                  map_spmf fst (rfunc_usr rest1 s1 iu)) =\n                              q \\<bind>\n                              (\\<lambda>s2.\n                                  map_spmf fst (rfunc_usr rest2 s2 iu));\n         \\<And>p q iu ou.\n            \\<lbrakk>S p q; iu \\<in> IU\\<rbrakk>\n            \\<Longrightarrow> S (cond_spmf_fst\n                                  (p \\<bind>\n                                   (\\<lambda>s1. rfunc_usr rest1 s1 iu))\n                                  ou)\n                               (cond_spmf_fst\n                                 (q \\<bind>\n                                  (\\<lambda>s2. rfunc_usr rest2 s2 iu))\n                                 ou)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "by(rule that[where S=\"trace_rest_closure rest1 rest2 IA IU p q\"])\n      (auto intro: trace_rest_closure_start trace_rest_closure_step[OF assms] trace_rest_closure_sim (* trace_rest_closure_weight[OF assms] *))"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "definition callee_of_core\n  :: \"('s_core, 'event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\n    \\<Rightarrow> ('s_core, 'event + 'iadv_core + 'iusr_core, unit + 'oadv_core + 'ousr_core) oracle'\" where\n  \"callee_of_core core =\n   map_fun id (map_fun id (map_spmf (Pair ()))) (cpoke core) \\<oplus>\\<^sub>O cfunc_adv core \\<oplus>\\<^sub>O cfunc_usr core\""], ["", "lemma callee_of_core_simps [simp]:\n  \"callee_of_core core s (Inl e) = map_spmf (Pair (Inl ())) (cpoke core s e)\"\n  \"callee_of_core core s (Inr (Inl iadv_core)) = map_spmf (apfst (Inr \\<circ> Inl)) (cfunc_adv core s iadv_core)\"\n  \"callee_of_core core s (Inr (Inr iusr_core)) = map_spmf (apfst (Inr \\<circ> Inr)) (cfunc_usr core s iusr_core)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_of_core core s (Inl e) =\n    map_spmf (Pair (Inl ())) (cpoke core s e) &&&\n    callee_of_core core s (Inr (Inl iadv_core)) =\n    map_spmf (apfst (Inr \\<circ> Inl)) (cfunc_adv core s iadv_core) &&&\n    callee_of_core core s (Inr (Inr iusr_core)) =\n    map_spmf (apfst (Inr \\<circ> Inr)) (cfunc_usr core s iusr_core)", "by(simp_all add: callee_of_core_def spmf.map_comp o_def apfst_def prod.map_comp id_def)"], ["", "lemma WT_callee_of_core [WT_intro]:\n  assumes WT: \"WT_core \\<I>_adv \\<I>_usr I core\"\n     and I: \"I s\"\n   shows \"\\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_adv \\<oplus>\\<^sub>\\<I> \\<I>_usr) \\<turnstile>c callee_of_core core s \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>_full \\<oplus>\\<^sub>\\<I>\n    (\\<I>_adv \\<oplus>\\<^sub>\\<I> \\<I>_usr) \\<turnstile>c\n    callee_of_core core s \\<surd>", "apply(rule WT_calleeI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>call ret sa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                        (\\<I>_adv \\<oplus>\\<^sub>\\<I> \\<I>_usr));\n        (ret, sa) \\<in> set_spmf (callee_of_core core s call)\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                 (\\<I>_adv \\<oplus>\\<^sub>\\<I> \\<I>_usr))\n                                call", "subgoal for x y s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> outs_\\<I>\n                      (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                       (\\<I>_adv \\<oplus>\\<^sub>\\<I> \\<I>_usr));\n     (y, s') \\<in> set_spmf (callee_of_core core s x)\\<rbrakk>\n    \\<Longrightarrow> y \\<in> responses_\\<I>\n                               (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                (\\<I>_adv \\<oplus>\\<^sub>\\<I> \\<I>_usr))\n                               x", "using I WT_coreD[OF WT]"], ["proof (prove)\nusing this:\n  I s\n  \\<lbrakk>?s' \\<in> set_spmf (cpoke core ?s ?e); I ?s\\<rbrakk>\n  \\<Longrightarrow> I ?s'\n  \\<lbrakk>(?y, ?s') \\<in> set_spmf (cfunc_adv core ?s ?x);\n   ?x \\<in> outs_\\<I> \\<I>_adv; I ?s\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> responses_\\<I> \\<I>_adv ?x \\<and> I ?s'\n  \\<lbrakk>(?y, ?s') \\<in> set_spmf (cfunc_usr core ?s ?x);\n   ?x \\<in> outs_\\<I> \\<I>_usr; I ?s\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> responses_\\<I> \\<I>_usr ?x \\<and> I ?s'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> outs_\\<I>\n                      (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                       (\\<I>_adv \\<oplus>\\<^sub>\\<I> \\<I>_usr));\n     (y, s') \\<in> set_spmf (callee_of_core core s x)\\<rbrakk>\n    \\<Longrightarrow> y \\<in> responses_\\<I>\n                               (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                                (\\<I>_adv \\<oplus>\\<^sub>\\<I> \\<I>_usr))\n                               x", "by(auto simp add: callee_of_core_def plus_oracle_def split!: sum.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma WT_core_callee_invariant_on [WT_intro]:\n  assumes WT: \"WT_core \\<I>_adv \\<I>_usr I core\"\n  shows \"callee_invariant_on (callee_of_core core) I (\\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_adv \\<oplus>\\<^sub>\\<I> \\<I>_usr))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on (callee_of_core core) I\n     (\\<I>_full \\<oplus>\\<^sub>\\<I> (\\<I>_adv \\<oplus>\\<^sub>\\<I> \\<I>_usr))", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s x y s'.\n       \\<lbrakk>(y, s') \\<in> set_spmf (callee_of_core core s x); I s;\n        x \\<in> outs_\\<I>\n                 (\\<I>_full \\<oplus>\\<^sub>\\<I>\n                  (\\<I>_adv \\<oplus>\\<^sub>\\<I> \\<I>_usr))\\<rbrakk>\n       \\<Longrightarrow> I s'\n 2. \\<And>s.\n       I s \\<Longrightarrow>\n       \\<I>_full \\<oplus>\\<^sub>\\<I>\n       (\\<I>_adv \\<oplus>\\<^sub>\\<I> \\<I>_usr) \\<turnstile>c\n       callee_of_core core s \\<surd>", "subgoal for s x y s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(y, s') \\<in> set_spmf (callee_of_core core s x); I s;\n     x \\<in> outs_\\<I>\n              (\\<I>_full \\<oplus>\\<^sub>\\<I>\n               (\\<I>_adv \\<oplus>\\<^sub>\\<I> \\<I>_usr))\\<rbrakk>\n    \\<Longrightarrow> I s'", "by(auto simp add: callee_of_core_def plus_oracle_def split!: sum.splits dest: WT_coreD[OF assms])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       I s \\<Longrightarrow>\n       \\<I>_full \\<oplus>\\<^sub>\\<I>\n       (\\<I>_adv \\<oplus>\\<^sub>\\<I> \\<I>_usr) \\<turnstile>c\n       callee_of_core core s \\<surd>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. I s_ \\<Longrightarrow>\n    \\<I>_full \\<oplus>\\<^sub>\\<I>\n    (\\<I>_adv \\<oplus>\\<^sub>\\<I> \\<I>_usr) \\<turnstile>c\n    callee_of_core core s_ \\<surd>", "by(rule WT_callee_of_core[OF WT])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition callee_of_rest\n  :: \"('s_rest, 'event, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest, 'more) rest_scheme\n    \\<Rightarrow> ('s_rest, 'iadv_rest + 'iusr_rest, 'oadv_rest \\<times> 'event list + 'ousr_rest \\<times> 'event list) oracle'\" where\n  \"callee_of_rest rest = rfunc_adv rest \\<oplus>\\<^sub>O rfunc_usr rest\""], ["", "lemma callee_of_rest_simps [simp]:\n  \"callee_of_rest rest s (Inl iadv_rest) = map_spmf (apfst Inl) (rfunc_adv rest s iadv_rest)\"\n  \"callee_of_rest rest s (Inr iusr_rest) = map_spmf (apfst Inr) (rfunc_usr rest s iusr_rest)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_of_rest rest s (Inl iadv_rest) =\n    map_spmf (apfst Inl) (rfunc_adv rest s iadv_rest) &&&\n    callee_of_rest rest s (Inr iusr_rest) =\n    map_spmf (apfst Inr) (rfunc_usr rest s iusr_rest)", "by(simp_all add: callee_of_rest_def)"], ["", "lemma WT_callee_of_rest [WT_intro]:\n  assumes WT: \"WT_rest \\<I>_adv \\<I>_usr I rest\"\n    and I: \"I s\"\n  shows \"e\\<I> \\<I>_adv \\<oplus>\\<^sub>\\<I> e\\<I> \\<I>_usr \\<turnstile>c callee_of_rest rest s \\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e\\<I> \\<I>_adv \\<oplus>\\<^sub>\\<I> e\\<I> \\<I>_usr \\<turnstile>c\n    callee_of_rest rest s \\<surd>", "apply(rule WT_calleeI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>call ret sa.\n       \\<lbrakk>call\n                \\<in> outs_\\<I>\n                       (e\\<I> \\<I>_adv \\<oplus>\\<^sub>\\<I> e\\<I> \\<I>_usr);\n        (ret, sa) \\<in> set_spmf (callee_of_rest rest s call)\\<rbrakk>\n       \\<Longrightarrow> ret\n                         \\<in> responses_\\<I>\n                                (e\\<I> \\<I>_adv \\<oplus>\\<^sub>\\<I>\n                                 e\\<I> \\<I>_usr)\n                                call", "subgoal for x y s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> outs_\\<I>\n                      (e\\<I> \\<I>_adv \\<oplus>\\<^sub>\\<I> e\\<I> \\<I>_usr);\n     (y, s') \\<in> set_spmf (callee_of_rest rest s x)\\<rbrakk>\n    \\<Longrightarrow> y \\<in> responses_\\<I>\n                               (e\\<I> \\<I>_adv \\<oplus>\\<^sub>\\<I>\n                                e\\<I> \\<I>_usr)\n                               x", "using I WT_restD[OF WT]"], ["proof (prove)\nusing this:\n  I s\n  \\<lbrakk>((?y, ?es), ?s') \\<in> set_spmf (rfunc_adv rest ?s ?x);\n   ?x \\<in> outs_\\<I> \\<I>_adv; I ?s\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> responses_\\<I> \\<I>_adv ?x \\<and> I ?s'\n  \\<lbrakk>((?y, ?es), ?s') \\<in> set_spmf (rfunc_usr rest ?s ?x);\n   ?x \\<in> outs_\\<I> \\<I>_usr; I ?s\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> responses_\\<I> \\<I>_usr ?x \\<and> I ?s'\n  I (rinit rest)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> outs_\\<I>\n                      (e\\<I> \\<I>_adv \\<oplus>\\<^sub>\\<I> e\\<I> \\<I>_usr);\n     (y, s') \\<in> set_spmf (callee_of_rest rest s x)\\<rbrakk>\n    \\<Longrightarrow> y \\<in> responses_\\<I>\n                               (e\\<I> \\<I>_adv \\<oplus>\\<^sub>\\<I>\n                                e\\<I> \\<I>_usr)\n                               x", "by(auto simp add: callee_of_core_def plus_oracle_def split!: sum.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fun fuse_callee \n  :: \"('iadv_core + 'iadv_rest) + ('iusr_core + 'iusr_rest) \\<Rightarrow>\n      (('oadv_core + 'oadv_rest) + ('ousr_core + 'ousr_rest),\n       ('event + 'iadv_core + 'iusr_core) + ('iadv_rest + 'iusr_rest),\n       (unit + 'oadv_core + 'ousr_core) + ('oadv_rest \\<times> 'event list + 'ousr_rest \\<times> 'event list)) gpv\"\n  where\n  \"fuse_callee (Inl (Inl iadv_core)) = Pause (Inl (Inr (Inl iadv_core))) (\\<lambda>x. case x of\n       Inl (Inr (Inl oadv_core)) \\<Rightarrow> Done (Inl (Inl oadv_core))\n     | _ \\<Rightarrow> Fail)\"\n| \"fuse_callee (Inl (Inr iadv_rest)) = Pause (Inr (Inl iadv_rest)) (\\<lambda>x. case x of\n       Inr (Inl (oadv_rest, es)) \\<Rightarrow> bind_gpv (pauses (map (Inl \\<circ> Inl) es)) (\\<lambda>_. Done (Inl (Inr oadv_rest)))\n     | _ \\<Rightarrow> Fail)\"\n| \"fuse_callee (Inr (Inl iusr_core)) = Pause (Inl (Inr (Inr iusr_core))) (\\<lambda>x. case x of\n       Inl (Inr (Inr oadv_core)) \\<Rightarrow> Done (Inr (Inl oadv_core)))\"\n| \"fuse_callee (Inr (Inr iusr_rest)) = Pause (Inr (Inr iusr_rest)) (\\<lambda>x. case x of\n       Inr (Inr (ousr_rest, es)) \\<Rightarrow> bind_gpv (pauses (map (Inl \\<circ> Inl) es)) (\\<lambda>_. Done (Inr (Inr ousr_rest))))\""], ["", "case_of_simps fuse_callee_case: fuse_callee.simps"], ["", "(* parametric_constant fuse_callee_parametric [transfer_rule]: fuse_callee_case *)"], ["", "definition fuse_converter \n  :: \"(('iadv_core + 'iadv_rest) + ('iusr_core + 'iusr_rest), \n       ('oadv_core + 'oadv_rest) + ('ousr_core + 'ousr_rest),\n       ('event + 'iadv_core + 'iusr_core) + ('iadv_rest + 'iusr_rest),\n       (unit + 'oadv_core + 'ousr_core) + ('oadv_rest \\<times> 'event list + 'ousr_rest \\<times> 'event list)) converter\"\n  where\n  \"fuse_converter = converter_of_callee (stateless_callee fuse_callee) ()\""], ["", "lemma fuse_converter:\n  \"resource_of_oracle (fused_resource.fuse core rest) (s_core, s_rest) = \n  fuse_converter \\<rhd> (resource_of_oracle (callee_of_core core) s_core \\<parallel> resource_of_oracle (callee_of_rest rest) s_rest)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RES (fused_resource.fuse core rest) (s_core, s_rest) =\n    fuse_converter \\<rhd>\n    RES (callee_of_core core) s_core \\<parallel>\n    RES (callee_of_rest rest) s_rest", "unfolding fuse_converter_def resource_of_parallel_oracle[symmetric] attach_CNV_RES attach_stateless_callee resource_of_oracle_extend_state_oracle"], ["proof (prove)\ngoal (1 subgoal):\n 1. RES (fused_resource.fuse core rest) (s_core, s_rest) =\n    RES (\\<lambda>s q.\n            exec_gpv\n             (callee_of_core core \\<ddagger>\\<^sub>O callee_of_rest rest)\n             (fuse_callee q) s)\n     (s_core, s_rest)", "proof(rule arg_cong2[where f=resource_of_oracle]; clarsimp simp add: fun_eq_iff)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       fused_resource.fuse core rest (a, b) x =\n       exec_gpv (callee_of_core core \\<ddagger>\\<^sub>O callee_of_rest rest)\n        (fuse_callee x) (a, b)", "interpret fused_resource core core_init for core_init"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       fuse rest (a, b) x =\n       exec_gpv (callee_of_core core \\<ddagger>\\<^sub>O callee_of_rest rest)\n        (fuse_callee x) (a, b)", "have \"foldl_spmf (map_fun id (map_fun (Inl \\<circ> Inl) id) (map_fun id (map_fun id (map_spmf snd)) (callee_of_core core \\<ddagger>\\<^sub>O callee_of_rest rest))) (return_spmf (s_core, s_rest)) xs\n     = map_spmf (\\<lambda>s_core. (s_core, s_rest)) (foldl_spmf (cpoke core) (return_spmf s_core) xs)\" for s_core s_rest xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl_spmf\n     (map_fun id (map_fun (Inl \\<circ> Inl) id)\n       (map_fun id (map_fun id (map_spmf snd))\n         (callee_of_core core \\<ddagger>\\<^sub>O callee_of_rest rest)))\n     (return_spmf (s_core, s_rest)) xs =\n    map_spmf (\\<lambda>s_core. (s_core, s_rest))\n     (foldl_spmf (cpoke core) (return_spmf s_core) xs)", "by(induction xs arbitrary: s_core)\n      (simp_all add: spmf.map_comp foldl_spmf_Cons' map_bind_spmf bind_map_spmf o_def del: foldl_spmf_Cons)"], ["proof (state)\nthis:\n  foldl_spmf\n   (map_fun id (map_fun (Inl \\<circ> Inl) id)\n     (map_fun id (map_fun id (map_spmf snd))\n       (callee_of_core core \\<ddagger>\\<^sub>O callee_of_rest rest)))\n   (return_spmf (?s_core1, ?s_rest1)) ?xs1 =\n  map_spmf (\\<lambda>s_core. (s_core, ?s_rest1))\n   (foldl_spmf (cpoke core) (return_spmf ?s_core1) ?xs1)\n\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       fuse rest (a, b) x =\n       exec_gpv (callee_of_core core \\<ddagger>\\<^sub>O callee_of_rest rest)\n        (fuse_callee x) (a, b)", "then"], ["proof (chain)\npicking this:\n  foldl_spmf\n   (map_fun id (map_fun (Inl \\<circ> Inl) id)\n     (map_fun id (map_fun id (map_spmf snd))\n       (callee_of_core core \\<ddagger>\\<^sub>O callee_of_rest rest)))\n   (return_spmf (?s_core1, ?s_rest1)) ?xs1 =\n  map_spmf (\\<lambda>s_core. (s_core, ?s_rest1))\n   (foldl_spmf (cpoke core) (return_spmf ?s_core1) ?xs1)", "show \"fuse rest (s_core, s_rest) q = exec_gpv (callee_of_core core \\<ddagger>\\<^sub>O callee_of_rest rest) (fuse_callee q) (s_core, s_rest)\"\n    for s_core s_rest q"], ["proof (prove)\nusing this:\n  foldl_spmf\n   (map_fun id (map_fun (Inl \\<circ> Inl) id)\n     (map_fun id (map_fun id (map_spmf snd))\n       (callee_of_core core \\<ddagger>\\<^sub>O callee_of_rest rest)))\n   (return_spmf (?s_core1, ?s_rest1)) ?xs1 =\n  map_spmf (\\<lambda>s_core. (s_core, ?s_rest1))\n   (foldl_spmf (cpoke core) (return_spmf ?s_core1) ?xs1)\n\ngoal (1 subgoal):\n 1. fuse rest (s_core, s_rest) q =\n    exec_gpv (callee_of_core core \\<ddagger>\\<^sub>O callee_of_rest rest)\n     (fuse_callee q) (s_core, s_rest)", "by(cases q rule: fuse_callee.cases; clarsimp simp add: map_bind_spmf bind_map_spmf exec_gpv_bind exec_gpv_pauses intro!: bind_spmf_cong[OF refl]; simp add: map_spmf_conv_bind_spmf[symmetric])"], ["proof (state)\nthis:\n  fuse rest (?s_core1, ?s_rest1) ?q1 =\n  exec_gpv (callee_of_core core \\<ddagger>\\<^sub>O callee_of_rest rest)\n   (fuse_callee ?q1) (?s_core1, ?s_rest1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_eq_callee_of_coreI:\n  \"trace_callee_eq (callee_of_core core1) (callee_of_core core2) (E <+> IA <+> IU) p q\"\n  if \"trace_core_eq core1 core2 E IA IU p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee_eq (callee_of_core core1) (callee_of_core core2)\n     (E <+> IA <+> IU) p q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace_callee_eq (callee_of_core core1) (callee_of_core core2)\n     (E <+> IA <+> IU) p q", "from that"], ["proof (chain)\npicking this:\n  trace_core_eq core1 core2 E IA IU p q", "obtain S_core \n    where core_start: \"S_core p q\"\n      and step_cpoke: \"\\<And>p q e. S_core p q \\<Longrightarrow> e \\<in> E\n        \\<Longrightarrow> weight_spmf (bind_spmf p (\\<lambda>s. cpoke core1 s e)) = weight_spmf (bind_spmf q (\\<lambda>s. cpoke core2 s e))\"\n      and sim_cpoke: \"\\<And>p q e. S_core p q \\<Longrightarrow> e \\<in> E \n       \\<Longrightarrow> S_core (mk_lossless (bind_spmf p (\\<lambda>s. cpoke core1 s e))) (mk_lossless (bind_spmf q (\\<lambda>s. cpoke core2 s e)))\"\n      and step_cfunc_adv: \"\\<And>p q ia. \\<lbrakk> S_core p q; ia \\<in> IA \\<rbrakk>\n       \\<Longrightarrow> bind_spmf p (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ia)) = bind_spmf q (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\"\n      and sim_cfunc_adv: \"\\<And>p q ia oa. \\<lbrakk> S_core p q; ia \\<in> IA \\<rbrakk> \\<Longrightarrow>\n        S_core (cond_spmf_fst (bind_spmf p (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa)\n               (cond_spmf_fst (bind_spmf q (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa)\"\n      and step_cfunc_usr: \"\\<And>p q iu. \\<lbrakk> S_core p q; iu \\<in> IU \\<rbrakk>\n        \\<Longrightarrow> bind_spmf p (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 iu)) = bind_spmf q (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\"\n      and sim_cfunc_usr: \"\\<And>p q iu ou. \\<lbrakk> S_core p q; iu \\<in> IU \\<rbrakk> \\<Longrightarrow>\n        S_core (cond_spmf_fst (bind_spmf p (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou)\n               (cond_spmf_fst (bind_spmf q (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou)\""], ["proof (prove)\nusing this:\n  trace_core_eq core1 core2 E IA IU p q\n\ngoal (1 subgoal):\n 1. (\\<And>S_core.\n        \\<lbrakk>S_core p q;\n         \\<And>p q e.\n            \\<lbrakk>S_core p q; e \\<in> E\\<rbrakk>\n            \\<Longrightarrow> weight_spmf\n                               (p \\<bind> (\\<lambda>s. cpoke core1 s e)) =\n                              weight_spmf\n                               (q \\<bind> (\\<lambda>s. cpoke core2 s e));\n         \\<And>p q e.\n            \\<lbrakk>S_core p q; e \\<in> E\\<rbrakk>\n            \\<Longrightarrow> S_core\n                               (mk_lossless\n                                 (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n                               (mk_lossless\n                                 (q \\<bind> (\\<lambda>s. cpoke core2 s e)));\n         \\<And>p q ia.\n            \\<lbrakk>S_core p q; ia \\<in> IA\\<rbrakk>\n            \\<Longrightarrow> p \\<bind>\n                              (\\<lambda>s1.\n                                  map_spmf fst (cfunc_adv core1 s1 ia)) =\n                              q \\<bind>\n                              (\\<lambda>s2.\n                                  map_spmf fst (cfunc_adv core2 s2 ia));\n         \\<And>p q ia oa.\n            \\<lbrakk>S_core p q; ia \\<in> IA\\<rbrakk>\n            \\<Longrightarrow> S_core\n                               (cond_spmf_fst\n                                 (p \\<bind>\n                                  (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                                 oa)\n                               (cond_spmf_fst\n                                 (q \\<bind>\n                                  (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                                 oa);\n         \\<And>p q iu.\n            \\<lbrakk>S_core p q; iu \\<in> IU\\<rbrakk>\n            \\<Longrightarrow> p \\<bind>\n                              (\\<lambda>s1.\n                                  map_spmf fst (cfunc_usr core1 s1 iu)) =\n                              q \\<bind>\n                              (\\<lambda>s2.\n                                  map_spmf fst (cfunc_usr core2 s2 iu));\n         \\<And>p q iu ou.\n            \\<lbrakk>S_core p q; iu \\<in> IU\\<rbrakk>\n            \\<Longrightarrow> S_core\n                               (cond_spmf_fst\n                                 (p \\<bind>\n                                  (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                                 ou)\n                               (cond_spmf_fst\n                                 (q \\<bind>\n                                  (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                                 ou)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule trace_core_eq_complete) blast"], ["proof (state)\nthis:\n  S_core p q\n  \\<lbrakk>S_core ?p ?q; ?e \\<in> E\\<rbrakk>\n  \\<Longrightarrow> weight_spmf\n                     (?p \\<bind> (\\<lambda>s. cpoke core1 s ?e)) =\n                    weight_spmf (?q \\<bind> (\\<lambda>s. cpoke core2 s ?e))\n  \\<lbrakk>S_core ?p ?q; ?e \\<in> E\\<rbrakk>\n  \\<Longrightarrow> S_core\n                     (mk_lossless\n                       (?p \\<bind> (\\<lambda>s. cpoke core1 s ?e)))\n                     (mk_lossless\n                       (?q \\<bind> (\\<lambda>s. cpoke core2 s ?e)))\n  \\<lbrakk>S_core ?p ?q; ?ia \\<in> IA\\<rbrakk>\n  \\<Longrightarrow> ?p \\<bind>\n                    (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ?ia)) =\n                    ?q \\<bind>\n                    (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ?ia))\n  \\<lbrakk>S_core ?p ?q; ?ia \\<in> IA\\<rbrakk>\n  \\<Longrightarrow> S_core\n                     (cond_spmf_fst\n                       (?p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ?ia))\n                       ?oa)\n                     (cond_spmf_fst\n                       (?q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ?ia))\n                       ?oa)\n  \\<lbrakk>S_core ?p ?q; ?iu \\<in> IU\\<rbrakk>\n  \\<Longrightarrow> ?p \\<bind>\n                    (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 ?iu)) =\n                    ?q \\<bind>\n                    (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 ?iu))\n  \\<lbrakk>S_core ?p ?q; ?iu \\<in> IU\\<rbrakk>\n  \\<Longrightarrow> S_core\n                     (cond_spmf_fst\n                       (?p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 ?iu))\n                       ?ou)\n                     (cond_spmf_fst\n                       (?q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 ?iu))\n                       ?ou)\n\ngoal (1 subgoal):\n 1. trace_callee_eq (callee_of_core core1) (callee_of_core core2)\n     (E <+> IA <+> IU) p q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee_eq (callee_of_core core1) (callee_of_core core2)\n     (E <+> IA <+> IU) p q", "using core_start"], ["proof (prove)\nusing this:\n  S_core p q\n\ngoal (1 subgoal):\n 1. trace_callee_eq (callee_of_core core1) (callee_of_core core2)\n     (E <+> IA <+> IU) p q", "proof(coinduct rule: trace'_eqI_sim[consumes 1, case_names step sim])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p q a.\n       \\<lbrakk>S_core p q; a \\<in> E <+> IA <+> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core2 s a))\n 2. \\<And>p q a res b s'.\n       \\<lbrakk>S_core p q; a \\<in> E <+> IA <+> IU; res \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee_of_core core2 res a)\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_core core1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_core core2 s a))\n                            b)", "case (step p q a)"], ["proof (state)\nthis:\n  S_core p q\n  a \\<in> E <+> IA <+> IU\n\ngoal (2 subgoals):\n 1. \\<And>p q a.\n       \\<lbrakk>S_core p q; a \\<in> E <+> IA <+> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core2 s a))\n 2. \\<And>p q a res b s'.\n       \\<lbrakk>S_core p q; a \\<in> E <+> IA <+> IU; res \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee_of_core core2 res a)\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_core core1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_core core2 s a))\n                            b)", "then"], ["proof (chain)\npicking this:\n  S_core p q\n  a \\<in> E <+> IA <+> IU", "consider (cpoke) e where \"a = Inl e\" \"e \\<in> E\"\n      | (cfunc_adv) ia where \"a = Inr (Inl ia)\" \"ia \\<in> IA\"\n      | (cfunc_usr) iu where \"a = Inr (Inr iu)\" \"iu \\<in> IU\""], ["proof (prove)\nusing this:\n  S_core p q\n  a \\<in> E <+> IA <+> IU\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>a = Inl e; e \\<in> E\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>ia.\n        \\<lbrakk>a = Inr (Inl ia); ia \\<in> IA\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>iu.\n        \\<lbrakk>a = Inr (Inr iu); iu \\<in> IU\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>e.\n              \\<lbrakk>a = Inl e; e \\<in> E\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>ia.\n      \\<lbrakk>a = Inr (Inl ia); ia \\<in> IA\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>iu.\n      \\<lbrakk>a = Inr (Inr iu); iu \\<in> IU\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. \\<And>p q a.\n       \\<lbrakk>S_core p q; a \\<in> E <+> IA <+> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core2 s a))\n 2. \\<And>p q a res b s'.\n       \\<lbrakk>S_core p q; a \\<in> E <+> IA <+> IU; res \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee_of_core core2 res a)\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_core core1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_core core2 s a))\n                            b)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>e.\n              \\<lbrakk>a = Inl e; e \\<in> E\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>ia.\n      \\<lbrakk>a = Inr (Inl ia); ia \\<in> IA\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>iu.\n      \\<lbrakk>a = Inr (Inr iu); iu \\<in> IU\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>e.\n              \\<lbrakk>a = Inl e; e \\<in> E\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>ia.\n      \\<lbrakk>a = Inr (Inl ia); ia \\<in> IA\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>iu.\n      \\<lbrakk>a = Inr (Inr iu); iu \\<in> IU\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. p \\<bind> (\\<lambda>s. map_spmf fst (callee_of_core core1 s a)) =\n    q \\<bind> (\\<lambda>s. map_spmf fst (callee_of_core core2 s a))", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>a = Inl e; e \\<in> E\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core2 s a))\n 2. \\<And>ia.\n       \\<lbrakk>a = Inr (Inl ia); ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core2 s a))\n 3. \\<And>iu.\n       \\<lbrakk>a = Inr (Inr iu); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core2 s a))", "case cpoke"], ["proof (state)\nthis:\n  a = Inl e\n  e \\<in> E\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>a = Inl e; e \\<in> E\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core2 s a))\n 2. \\<And>ia.\n       \\<lbrakk>a = Inr (Inl ia); ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core2 s a))\n 3. \\<And>iu.\n       \\<lbrakk>a = Inr (Inr iu); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core2 s a))", "with step_cpoke[OF step(1), of e]"], ["proof (chain)\npicking this:\n  e \\<in> E \\<Longrightarrow>\n  weight_spmf (p \\<bind> (\\<lambda>s. cpoke core1 s e)) =\n  weight_spmf (q \\<bind> (\\<lambda>s. cpoke core2 s e))\n  a = Inl e\n  e \\<in> E", "show ?thesis"], ["proof (prove)\nusing this:\n  e \\<in> E \\<Longrightarrow>\n  weight_spmf (p \\<bind> (\\<lambda>s. cpoke core1 s e)) =\n  weight_spmf (q \\<bind> (\\<lambda>s. cpoke core2 s e))\n  a = Inl e\n  e \\<in> E\n\ngoal (1 subgoal):\n 1. p \\<bind> (\\<lambda>s. map_spmf fst (callee_of_core core1 s a)) =\n    q \\<bind> (\\<lambda>s. map_spmf fst (callee_of_core core2 s a))", "by(simp add: spmf.map_comp o_def map_spmf_const weight_bind_spmf)\n          (auto intro!: spmf_eqI simp add: spmf_bind spmf_scale_spmf max_def min_absorb2 weight_spmf_le_1)"], ["proof (state)\nthis:\n  p \\<bind> (\\<lambda>s. map_spmf fst (callee_of_core core1 s a)) =\n  q \\<bind> (\\<lambda>s. map_spmf fst (callee_of_core core2 s a))\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       \\<lbrakk>a = Inr (Inl ia); ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core2 s a))\n 2. \\<And>iu.\n       \\<lbrakk>a = Inr (Inr iu); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core2 s a))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia.\n       \\<lbrakk>a = Inr (Inl ia); ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core2 s a))\n 2. \\<And>iu.\n       \\<lbrakk>a = Inr (Inr iu); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core2 s a))", "case cfunc_adv"], ["proof (state)\nthis:\n  a = Inr (Inl ia)\n  ia \\<in> IA\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       \\<lbrakk>a = Inr (Inl ia); ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core2 s a))\n 2. \\<And>iu.\n       \\<lbrakk>a = Inr (Inr iu); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core2 s a))", "with step_cfunc_adv[OF step(1) cfunc_adv(2)]"], ["proof (chain)\npicking this:\n  p \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ia)) =\n  q \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\n  a = Inr (Inl ia)\n  ia \\<in> IA", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ia)) =\n  q \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\n  a = Inr (Inl ia)\n  ia \\<in> IA\n\ngoal (1 subgoal):\n 1. p \\<bind> (\\<lambda>s. map_spmf fst (callee_of_core core1 s a)) =\n    q \\<bind> (\\<lambda>s. map_spmf fst (callee_of_core core2 s a))", "by(simp add: spmf.map_comp)(simp add: spmf.map_comp[symmetric] map_bind_spmf[unfolded o_def, symmetric])"], ["proof (state)\nthis:\n  p \\<bind> (\\<lambda>s. map_spmf fst (callee_of_core core1 s a)) =\n  q \\<bind> (\\<lambda>s. map_spmf fst (callee_of_core core2 s a))\n\ngoal (1 subgoal):\n 1. \\<And>iu.\n       \\<lbrakk>a = Inr (Inr iu); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core2 s a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>iu.\n       \\<lbrakk>a = Inr (Inr iu); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core2 s a))", "case cfunc_usr"], ["proof (state)\nthis:\n  a = Inr (Inr iu)\n  iu \\<in> IU\n\ngoal (1 subgoal):\n 1. \\<And>iu.\n       \\<lbrakk>a = Inr (Inr iu); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_core core2 s a))", "with step_cfunc_usr[OF step(1) cfunc_usr(2)]"], ["proof (chain)\npicking this:\n  p \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 iu)) =\n  q \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\n  a = Inr (Inr iu)\n  iu \\<in> IU", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 iu)) =\n  q \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\n  a = Inr (Inr iu)\n  iu \\<in> IU\n\ngoal (1 subgoal):\n 1. p \\<bind> (\\<lambda>s. map_spmf fst (callee_of_core core1 s a)) =\n    q \\<bind> (\\<lambda>s. map_spmf fst (callee_of_core core2 s a))", "by(simp add: spmf.map_comp)(simp add: spmf.map_comp[symmetric] map_bind_spmf[unfolded o_def, symmetric])"], ["proof (state)\nthis:\n  p \\<bind> (\\<lambda>s. map_spmf fst (callee_of_core core1 s a)) =\n  q \\<bind> (\\<lambda>s. map_spmf fst (callee_of_core core2 s a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<bind> (\\<lambda>s. map_spmf fst (callee_of_core core1 s a)) =\n  q \\<bind> (\\<lambda>s. map_spmf fst (callee_of_core core2 s a))\n\ngoal (1 subgoal):\n 1. \\<And>p q a res b s'.\n       \\<lbrakk>S_core p q; a \\<in> E <+> IA <+> IU; res \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee_of_core core2 res a)\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_core core1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_core core2 s a))\n                            b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q a res b s'.\n       \\<lbrakk>S_core p q; a \\<in> E <+> IA <+> IU; res \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee_of_core core2 res a)\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_core core1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_core core2 s a))\n                            b)", "case (sim p q a res b s')"], ["proof (state)\nthis:\n  S_core p q\n  a \\<in> E <+> IA <+> IU\n  res \\<in> set_spmf q\n  (b, s') \\<in> set_spmf (callee_of_core core2 res a)\n\ngoal (1 subgoal):\n 1. \\<And>p q a res b s'.\n       \\<lbrakk>S_core p q; a \\<in> E <+> IA <+> IU; res \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee_of_core core2 res a)\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_core core1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_core core2 s a))\n                            b)", "then"], ["proof (chain)\npicking this:\n  S_core p q\n  a \\<in> E <+> IA <+> IU\n  res \\<in> set_spmf q\n  (b, s') \\<in> set_spmf (callee_of_core core2 res a)", "consider (cpoke) e where \"a = Inl e\" \"e \\<in> E\"\n      | (cfunc_adv) ia where \"a = Inr (Inl ia)\" \"ia \\<in> IA\"\n      | (cfunc_usr) iu where \"a = Inr (Inr iu)\" \"iu \\<in> IU\""], ["proof (prove)\nusing this:\n  S_core p q\n  a \\<in> E <+> IA <+> IU\n  res \\<in> set_spmf q\n  (b, s') \\<in> set_spmf (callee_of_core core2 res a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>e.\n                \\<lbrakk>a = Inl e; e \\<in> E\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>ia.\n        \\<lbrakk>a = Inr (Inl ia); ia \\<in> IA\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>iu.\n        \\<lbrakk>a = Inr (Inr iu); iu \\<in> IU\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>e.\n              \\<lbrakk>a = Inl e; e \\<in> E\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>ia.\n      \\<lbrakk>a = Inr (Inl ia); ia \\<in> IA\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>iu.\n      \\<lbrakk>a = Inr (Inr iu); iu \\<in> IU\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>p q a res b s'.\n       \\<lbrakk>S_core p q; a \\<in> E <+> IA <+> IU; res \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee_of_core core2 res a)\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_core core1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_core core2 s a))\n                            b)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>e.\n              \\<lbrakk>a = Inl e; e \\<in> E\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>ia.\n      \\<lbrakk>a = Inr (Inl ia); ia \\<in> IA\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>iu.\n      \\<lbrakk>a = Inr (Inr iu); iu \\<in> IU\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>e.\n              \\<lbrakk>a = Inl e; e \\<in> E\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>ia.\n      \\<lbrakk>a = Inr (Inl ia); ia \\<in> IA\\<rbrakk>\n      \\<Longrightarrow> ?thesis;\n   \\<And>iu.\n      \\<lbrakk>a = Inr (Inr iu); iu \\<in> IU\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. S_core\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee_of_core core1 s a)) b)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee_of_core core2 s a)) b)", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>a = Inl e; e \\<in> E\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_core core1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_core core2 s a))\n                            b)\n 2. \\<And>ia.\n       \\<lbrakk>a = Inr (Inl ia); ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_core core1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_core core2 s a))\n                            b)\n 3. \\<And>iu.\n       \\<lbrakk>a = Inr (Inr iu); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_core core1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_core core2 s a))\n                            b)", "case cpoke"], ["proof (state)\nthis:\n  a = Inl e\n  e \\<in> E\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>a = Inl e; e \\<in> E\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_core core1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_core core2 s a))\n                            b)\n 2. \\<And>ia.\n       \\<lbrakk>a = Inr (Inl ia); ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_core core1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_core core2 s a))\n                            b)\n 3. \\<And>iu.\n       \\<lbrakk>a = Inr (Inr iu); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_core core1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_core core2 s a))\n                            b)", "with sim_cpoke[OF sim(1) , of e] sim"], ["proof (chain)\npicking this:\n  e \\<in> E \\<Longrightarrow>\n  S_core (mk_lossless (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n   (mk_lossless (q \\<bind> (\\<lambda>s. cpoke core2 s e)))\n  S_core p q\n  a \\<in> E <+> IA <+> IU\n  res \\<in> set_spmf q\n  (b, s') \\<in> set_spmf (callee_of_core core2 res a)\n  a = Inl e\n  e \\<in> E", "show ?thesis"], ["proof (prove)\nusing this:\n  e \\<in> E \\<Longrightarrow>\n  S_core (mk_lossless (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n   (mk_lossless (q \\<bind> (\\<lambda>s. cpoke core2 s e)))\n  S_core p q\n  a \\<in> E <+> IA <+> IU\n  res \\<in> set_spmf q\n  (b, s') \\<in> set_spmf (callee_of_core core2 res a)\n  a = Inl e\n  e \\<in> E\n\ngoal (1 subgoal):\n 1. S_core\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee_of_core core1 s a)) b)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee_of_core core2 s a)) b)", "by(clarsimp simp add: map_bind_spmf[unfolded o_def, symmetric])"], ["proof (state)\nthis:\n  S_core\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee_of_core core1 s a)) b)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee_of_core core2 s a)) b)\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       \\<lbrakk>a = Inr (Inl ia); ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_core core1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_core core2 s a))\n                            b)\n 2. \\<And>iu.\n       \\<lbrakk>a = Inr (Inr iu); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_core core1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_core core2 s a))\n                            b)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia.\n       \\<lbrakk>a = Inr (Inl ia); ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_core core1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_core core2 s a))\n                            b)\n 2. \\<And>iu.\n       \\<lbrakk>a = Inr (Inr iu); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_core core1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_core core2 s a))\n                            b)", "case cfunc_adv"], ["proof (state)\nthis:\n  a = Inr (Inl ia)\n  ia \\<in> IA\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       \\<lbrakk>a = Inr (Inl ia); ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_core core1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_core core2 s a))\n                            b)\n 2. \\<And>iu.\n       \\<lbrakk>a = Inr (Inr iu); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_core core1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_core core2 s a))\n                            b)", "with sim_cfunc_adv[OF sim(1) cfunc_adv(2)] sim"], ["proof (chain)\npicking this:\n  S_core\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) ?oa)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)) ?oa)\n  S_core p q\n  a \\<in> E <+> IA <+> IU\n  res \\<in> set_spmf q\n  (b, s') \\<in> set_spmf (callee_of_core core2 res a)\n  a = Inr (Inl ia)\n  ia \\<in> IA", "show ?thesis"], ["proof (prove)\nusing this:\n  S_core\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) ?oa)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)) ?oa)\n  S_core p q\n  a \\<in> E <+> IA <+> IU\n  res \\<in> set_spmf q\n  (b, s') \\<in> set_spmf (callee_of_core core2 res a)\n  a = Inr (Inl ia)\n  ia \\<in> IA\n\ngoal (1 subgoal):\n 1. S_core\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee_of_core core1 s a)) b)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee_of_core core2 s a)) b)", "apply(clarsimp simp add: map_bind_spmf[unfolded o_def, symmetric] apfst_def map_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>\\<And>oa.\n                   S_core\n                    (cond_spmf_fst\n                      (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa)\n                    (cond_spmf_fst\n                      (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa);\n        S_core p q; res \\<in> set_spmf q; a = Inr (Inl ia); ia \\<in> IA;\n        (aa, s') \\<in> set_spmf (cfunc_adv core2 res ia);\n        b = Inr (Inl aa)\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (cond_spmf_fst\n                            (map_spmf (\\<lambda>(x, y). (Inr (Inl x), y))\n                              (p \\<bind>\n                               (\\<lambda>s. cfunc_adv core1 s ia)))\n                            (Inr (Inl aa)))\n                          (cond_spmf_fst\n                            (map_spmf (\\<lambda>(x, y). (Inr (Inl x), y))\n                              (q \\<bind>\n                               (\\<lambda>s. cfunc_adv core2 s ia)))\n                            (Inr (Inl aa)))", "apply(subst (1 2) cond_spmf_fst_map_prod_inj)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>\\<And>oa.\n                   S_core\n                    (cond_spmf_fst\n                      (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa)\n                    (cond_spmf_fst\n                      (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa);\n        S_core p q; res \\<in> set_spmf q; a = Inr (Inl ia); ia \\<in> IA;\n        (aa, s') \\<in> set_spmf (cfunc_adv core2 res ia);\n        b = Inr (Inl aa)\\<rbrakk>\n       \\<Longrightarrow> inj (\\<lambda>x. Inr (Inl x))\n 2. \\<And>aa.\n       \\<lbrakk>\\<And>oa.\n                   S_core\n                    (cond_spmf_fst\n                      (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa)\n                    (cond_spmf_fst\n                      (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa);\n        S_core p q; res \\<in> set_spmf q; a = Inr (Inl ia); ia \\<in> IA;\n        (aa, s') \\<in> set_spmf (cfunc_adv core2 res ia);\n        b = Inr (Inl aa)\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (map_spmf (\\<lambda>y. y)\n                            (cond_spmf_fst\n                              (p \\<bind> (\\<lambda>s. cfunc_adv core1 s ia))\n                              aa))\n                          (map_spmf (\\<lambda>y. y)\n                            (cond_spmf_fst\n                              (q \\<bind> (\\<lambda>s. cfunc_adv core2 s ia))\n                              aa))", "apply(simp_all add: o_def[symmetric] inj_compose del: o_apply)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  S_core\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee_of_core core1 s a)) b)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee_of_core core2 s a)) b)\n\ngoal (1 subgoal):\n 1. \\<And>iu.\n       \\<lbrakk>a = Inr (Inr iu); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_core core1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_core core2 s a))\n                            b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>iu.\n       \\<lbrakk>a = Inr (Inr iu); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_core core1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_core core2 s a))\n                            b)", "case cfunc_usr"], ["proof (state)\nthis:\n  a = Inr (Inr iu)\n  iu \\<in> IU\n\ngoal (1 subgoal):\n 1. \\<And>iu.\n       \\<lbrakk>a = Inr (Inr iu); iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_core core1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_core core2 s a))\n                            b)", "with sim_cfunc_usr[OF sim(1) cfunc_usr(2)] sim"], ["proof (chain)\npicking this:\n  S_core\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ?ou)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ?ou)\n  S_core p q\n  a \\<in> E <+> IA <+> IU\n  res \\<in> set_spmf q\n  (b, s') \\<in> set_spmf (callee_of_core core2 res a)\n  a = Inr (Inr iu)\n  iu \\<in> IU", "show ?thesis"], ["proof (prove)\nusing this:\n  S_core\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ?ou)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ?ou)\n  S_core p q\n  a \\<in> E <+> IA <+> IU\n  res \\<in> set_spmf q\n  (b, s') \\<in> set_spmf (callee_of_core core2 res a)\n  a = Inr (Inr iu)\n  iu \\<in> IU\n\ngoal (1 subgoal):\n 1. S_core\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee_of_core core1 s a)) b)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee_of_core core2 s a)) b)", "apply(clarsimp simp add: map_bind_spmf[unfolded o_def, symmetric] apfst_def map_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>\\<And>ou.\n                   S_core\n                    (cond_spmf_fst\n                      (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou)\n                    (cond_spmf_fst\n                      (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou);\n        S_core p q; res \\<in> set_spmf q; a = Inr (Inr iu); iu \\<in> IU;\n        (aa, s') \\<in> set_spmf (cfunc_usr core2 res iu);\n        b = Inr (Inr aa)\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (cond_spmf_fst\n                            (map_spmf (\\<lambda>(x, y). (Inr (Inr x), y))\n                              (p \\<bind>\n                               (\\<lambda>s. cfunc_usr core1 s iu)))\n                            (Inr (Inr aa)))\n                          (cond_spmf_fst\n                            (map_spmf (\\<lambda>(x, y). (Inr (Inr x), y))\n                              (q \\<bind>\n                               (\\<lambda>s. cfunc_usr core2 s iu)))\n                            (Inr (Inr aa)))", "apply(subst (1 2) cond_spmf_fst_map_prod_inj)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa.\n       \\<lbrakk>\\<And>ou.\n                   S_core\n                    (cond_spmf_fst\n                      (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou)\n                    (cond_spmf_fst\n                      (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou);\n        S_core p q; res \\<in> set_spmf q; a = Inr (Inr iu); iu \\<in> IU;\n        (aa, s') \\<in> set_spmf (cfunc_usr core2 res iu);\n        b = Inr (Inr aa)\\<rbrakk>\n       \\<Longrightarrow> inj (\\<lambda>x. Inr (Inr x))\n 2. \\<And>aa.\n       \\<lbrakk>\\<And>ou.\n                   S_core\n                    (cond_spmf_fst\n                      (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou)\n                    (cond_spmf_fst\n                      (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou);\n        S_core p q; res \\<in> set_spmf q; a = Inr (Inr iu); iu \\<in> IU;\n        (aa, s') \\<in> set_spmf (cfunc_usr core2 res iu);\n        b = Inr (Inr aa)\\<rbrakk>\n       \\<Longrightarrow> S_core\n                          (map_spmf (\\<lambda>y. y)\n                            (cond_spmf_fst\n                              (p \\<bind> (\\<lambda>s. cfunc_usr core1 s iu))\n                              aa))\n                          (map_spmf (\\<lambda>y. y)\n                            (cond_spmf_fst\n                              (q \\<bind> (\\<lambda>s. cfunc_usr core2 s iu))\n                              aa))", "apply(simp_all add: o_def[symmetric] inj_compose del: o_apply)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  S_core\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee_of_core core1 s a)) b)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee_of_core core2 s a)) b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S_core\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee_of_core core1 s a)) b)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee_of_core core2 s a)) b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trace_callee_eq (callee_of_core core1) (callee_of_core core2)\n   (E <+> IA <+> IU) p q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_eq_callee_of_restI:\n  \"trace_callee_eq (callee_of_rest rest1) (callee_of_rest rest2) (IA <+> IU) p q\"\n  if \"trace_rest_eq rest1 rest2 IA IU p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee_eq (callee_of_rest rest1) (callee_of_rest rest2)\n     (IA <+> IU) p q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace_callee_eq (callee_of_rest rest1) (callee_of_rest rest2)\n     (IA <+> IU) p q", "from that"], ["proof (chain)\npicking this:\n  trace_rest_eq rest1 rest2 IA IU p q", "obtain S_rest \n    where rest_start: \"S_rest p q\"\n      and step_rfunc_adv: \"\\<And>p q ia. \\<lbrakk> S_rest p q; ia \\<in> IA \\<rbrakk>\n       \\<Longrightarrow> bind_spmf p (\\<lambda>s1. map_spmf fst (rfunc_adv rest1 s1 ia)) = bind_spmf q (\\<lambda>s2. map_spmf fst (rfunc_adv rest2 s2 ia))\"\n      and sim_rfunc_adv: \"\\<And>p q ia oa. \\<lbrakk> S_rest p q; ia \\<in> IA \\<rbrakk> \\<Longrightarrow>\n        S_rest (cond_spmf_fst (bind_spmf p (\\<lambda>s1. rfunc_adv rest1 s1 ia)) oa)\n               (cond_spmf_fst (bind_spmf q (\\<lambda>s2. rfunc_adv rest2 s2 ia)) oa)\"\n      and step_rfunc_usr: \"\\<And>p q iu. \\<lbrakk> S_rest p q; iu \\<in> IU \\<rbrakk>\n        \\<Longrightarrow> bind_spmf p (\\<lambda>s1. map_spmf fst (rfunc_usr rest1 s1 iu)) = bind_spmf q (\\<lambda>s2. map_spmf fst (rfunc_usr rest2 s2 iu))\"\n      and sim_rfunc_usr: \"\\<And>p q iu ou. \\<lbrakk> S_rest p q; iu \\<in> IU \\<rbrakk> \\<Longrightarrow>\n        S_rest (cond_spmf_fst (bind_spmf p (\\<lambda>s1. rfunc_usr rest1 s1 iu)) ou)\n               (cond_spmf_fst (bind_spmf q (\\<lambda>s2. rfunc_usr rest2 s2 iu)) ou)\""], ["proof (prove)\nusing this:\n  trace_rest_eq rest1 rest2 IA IU p q\n\ngoal (1 subgoal):\n 1. (\\<And>S_rest.\n        \\<lbrakk>S_rest p q;\n         \\<And>p q ia.\n            \\<lbrakk>S_rest p q; ia \\<in> IA\\<rbrakk>\n            \\<Longrightarrow> p \\<bind>\n                              (\\<lambda>s1.\n                                  map_spmf fst (rfunc_adv rest1 s1 ia)) =\n                              q \\<bind>\n                              (\\<lambda>s2.\n                                  map_spmf fst (rfunc_adv rest2 s2 ia));\n         \\<And>p q ia oa.\n            \\<lbrakk>S_rest p q; ia \\<in> IA\\<rbrakk>\n            \\<Longrightarrow> S_rest\n                               (cond_spmf_fst\n                                 (p \\<bind>\n                                  (\\<lambda>s1. rfunc_adv rest1 s1 ia))\n                                 oa)\n                               (cond_spmf_fst\n                                 (q \\<bind>\n                                  (\\<lambda>s2. rfunc_adv rest2 s2 ia))\n                                 oa);\n         \\<And>p q iu.\n            \\<lbrakk>S_rest p q; iu \\<in> IU\\<rbrakk>\n            \\<Longrightarrow> p \\<bind>\n                              (\\<lambda>s1.\n                                  map_spmf fst (rfunc_usr rest1 s1 iu)) =\n                              q \\<bind>\n                              (\\<lambda>s2.\n                                  map_spmf fst (rfunc_usr rest2 s2 iu));\n         \\<And>p q iu ou.\n            \\<lbrakk>S_rest p q; iu \\<in> IU\\<rbrakk>\n            \\<Longrightarrow> S_rest\n                               (cond_spmf_fst\n                                 (p \\<bind>\n                                  (\\<lambda>s1. rfunc_usr rest1 s1 iu))\n                                 ou)\n                               (cond_spmf_fst\n                                 (q \\<bind>\n                                  (\\<lambda>s2. rfunc_usr rest2 s2 iu))\n                                 ou)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule trace_rest_eq_complete) blast"], ["proof (state)\nthis:\n  S_rest p q\n  \\<lbrakk>S_rest ?p ?q; ?ia \\<in> IA\\<rbrakk>\n  \\<Longrightarrow> ?p \\<bind>\n                    (\\<lambda>s1. map_spmf fst (rfunc_adv rest1 s1 ?ia)) =\n                    ?q \\<bind>\n                    (\\<lambda>s2. map_spmf fst (rfunc_adv rest2 s2 ?ia))\n  \\<lbrakk>S_rest ?p ?q; ?ia \\<in> IA\\<rbrakk>\n  \\<Longrightarrow> S_rest\n                     (cond_spmf_fst\n                       (?p \\<bind> (\\<lambda>s1. rfunc_adv rest1 s1 ?ia))\n                       ?oa)\n                     (cond_spmf_fst\n                       (?q \\<bind> (\\<lambda>s2. rfunc_adv rest2 s2 ?ia))\n                       ?oa)\n  \\<lbrakk>S_rest ?p ?q; ?iu \\<in> IU\\<rbrakk>\n  \\<Longrightarrow> ?p \\<bind>\n                    (\\<lambda>s1. map_spmf fst (rfunc_usr rest1 s1 ?iu)) =\n                    ?q \\<bind>\n                    (\\<lambda>s2. map_spmf fst (rfunc_usr rest2 s2 ?iu))\n  \\<lbrakk>S_rest ?p ?q; ?iu \\<in> IU\\<rbrakk>\n  \\<Longrightarrow> S_rest\n                     (cond_spmf_fst\n                       (?p \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 ?iu))\n                       ?ou)\n                     (cond_spmf_fst\n                       (?q \\<bind> (\\<lambda>s2. rfunc_usr rest2 s2 ?iu))\n                       ?ou)\n\ngoal (1 subgoal):\n 1. trace_callee_eq (callee_of_rest rest1) (callee_of_rest rest2)\n     (IA <+> IU) p q", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee_eq (callee_of_rest rest1) (callee_of_rest rest2)\n     (IA <+> IU) p q", "using rest_start"], ["proof (prove)\nusing this:\n  S_rest p q\n\ngoal (1 subgoal):\n 1. trace_callee_eq (callee_of_rest rest1) (callee_of_rest rest2)\n     (IA <+> IU) p q", "proof(coinduct rule: trace'_eqI_sim[consumes 1, case_names step sim])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p q a.\n       \\<lbrakk>S_rest p q; a \\<in> IA <+> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_rest rest1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_rest rest2 s a))\n 2. \\<And>p q a res b s'.\n       \\<lbrakk>S_rest p q; a \\<in> IA <+> IU; res \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee_of_rest rest2 res a)\\<rbrakk>\n       \\<Longrightarrow> S_rest\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_rest rest1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_rest rest2 s a))\n                            b)", "case (step p q a)"], ["proof (state)\nthis:\n  S_rest p q\n  a \\<in> IA <+> IU\n\ngoal (2 subgoals):\n 1. \\<And>p q a.\n       \\<lbrakk>S_rest p q; a \\<in> IA <+> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_rest rest1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_rest rest2 s a))\n 2. \\<And>p q a res b s'.\n       \\<lbrakk>S_rest p q; a \\<in> IA <+> IU; res \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee_of_rest rest2 res a)\\<rbrakk>\n       \\<Longrightarrow> S_rest\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_rest rest1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_rest rest2 s a))\n                            b)", "then"], ["proof (chain)\npicking this:\n  S_rest p q\n  a \\<in> IA <+> IU", "consider (rfunc_adv) ia where \"a = Inl ia\" \"ia \\<in> IA\"\n      | (rfunc_usr) iu where \"a = Inr iu\" \"iu \\<in> IU\""], ["proof (prove)\nusing this:\n  S_rest p q\n  a \\<in> IA <+> IU\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ia.\n                \\<lbrakk>a = Inl ia; ia \\<in> IA\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>iu.\n        \\<lbrakk>a = Inr iu; iu \\<in> IU\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>ia.\n              \\<lbrakk>a = Inl ia; ia \\<in> IA\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>iu.\n      \\<lbrakk>a = Inr iu; iu \\<in> IU\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. \\<And>p q a.\n       \\<lbrakk>S_rest p q; a \\<in> IA <+> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_rest rest1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_rest rest2 s a))\n 2. \\<And>p q a res b s'.\n       \\<lbrakk>S_rest p q; a \\<in> IA <+> IU; res \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee_of_rest rest2 res a)\\<rbrakk>\n       \\<Longrightarrow> S_rest\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_rest rest1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_rest rest2 s a))\n                            b)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>ia.\n              \\<lbrakk>a = Inl ia; ia \\<in> IA\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>iu.\n      \\<lbrakk>a = Inr iu; iu \\<in> IU\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>ia.\n              \\<lbrakk>a = Inl ia; ia \\<in> IA\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>iu.\n      \\<lbrakk>a = Inr iu; iu \\<in> IU\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. p \\<bind> (\\<lambda>s. map_spmf fst (callee_of_rest rest1 s a)) =\n    q \\<bind> (\\<lambda>s. map_spmf fst (callee_of_rest rest2 s a))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia.\n       \\<lbrakk>a = Inl ia; ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_rest rest1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_rest rest2 s a))\n 2. \\<And>iu.\n       \\<lbrakk>a = Inr iu; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_rest rest1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_rest rest2 s a))", "case rfunc_adv"], ["proof (state)\nthis:\n  a = Inl ia\n  ia \\<in> IA\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       \\<lbrakk>a = Inl ia; ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_rest rest1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_rest rest2 s a))\n 2. \\<And>iu.\n       \\<lbrakk>a = Inr iu; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_rest rest1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_rest rest2 s a))", "with step_rfunc_adv[OF step(1) rfunc_adv(2)]"], ["proof (chain)\npicking this:\n  p \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_adv rest1 s1 ia)) =\n  q \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_adv rest2 s2 ia))\n  a = Inl ia\n  ia \\<in> IA", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_adv rest1 s1 ia)) =\n  q \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_adv rest2 s2 ia))\n  a = Inl ia\n  ia \\<in> IA\n\ngoal (1 subgoal):\n 1. p \\<bind> (\\<lambda>s. map_spmf fst (callee_of_rest rest1 s a)) =\n    q \\<bind> (\\<lambda>s. map_spmf fst (callee_of_rest rest2 s a))", "by(simp add: spmf.map_comp)(simp add: spmf.map_comp[symmetric] map_bind_spmf[unfolded o_def, symmetric])"], ["proof (state)\nthis:\n  p \\<bind> (\\<lambda>s. map_spmf fst (callee_of_rest rest1 s a)) =\n  q \\<bind> (\\<lambda>s. map_spmf fst (callee_of_rest rest2 s a))\n\ngoal (1 subgoal):\n 1. \\<And>iu.\n       \\<lbrakk>a = Inr iu; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_rest rest1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_rest rest2 s a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>iu.\n       \\<lbrakk>a = Inr iu; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_rest rest1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_rest rest2 s a))", "case rfunc_usr"], ["proof (state)\nthis:\n  a = Inr iu\n  iu \\<in> IU\n\ngoal (1 subgoal):\n 1. \\<And>iu.\n       \\<lbrakk>a = Inr iu; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_rest rest1 s a)) =\n                         q \\<bind>\n                         (\\<lambda>s.\n                             map_spmf fst (callee_of_rest rest2 s a))", "with step_rfunc_usr[OF step(1) rfunc_usr(2)]"], ["proof (chain)\npicking this:\n  p \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_usr rest1 s1 iu)) =\n  q \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_usr rest2 s2 iu))\n  a = Inr iu\n  iu \\<in> IU", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<bind> (\\<lambda>s1. map_spmf fst (rfunc_usr rest1 s1 iu)) =\n  q \\<bind> (\\<lambda>s2. map_spmf fst (rfunc_usr rest2 s2 iu))\n  a = Inr iu\n  iu \\<in> IU\n\ngoal (1 subgoal):\n 1. p \\<bind> (\\<lambda>s. map_spmf fst (callee_of_rest rest1 s a)) =\n    q \\<bind> (\\<lambda>s. map_spmf fst (callee_of_rest rest2 s a))", "by(simp add: spmf.map_comp)(simp add: spmf.map_comp[symmetric] map_bind_spmf[unfolded o_def, symmetric])"], ["proof (state)\nthis:\n  p \\<bind> (\\<lambda>s. map_spmf fst (callee_of_rest rest1 s a)) =\n  q \\<bind> (\\<lambda>s. map_spmf fst (callee_of_rest rest2 s a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<bind> (\\<lambda>s. map_spmf fst (callee_of_rest rest1 s a)) =\n  q \\<bind> (\\<lambda>s. map_spmf fst (callee_of_rest rest2 s a))\n\ngoal (1 subgoal):\n 1. \\<And>p q a res b s'.\n       \\<lbrakk>S_rest p q; a \\<in> IA <+> IU; res \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee_of_rest rest2 res a)\\<rbrakk>\n       \\<Longrightarrow> S_rest\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_rest rest1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_rest rest2 s a))\n                            b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q a res b s'.\n       \\<lbrakk>S_rest p q; a \\<in> IA <+> IU; res \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee_of_rest rest2 res a)\\<rbrakk>\n       \\<Longrightarrow> S_rest\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_rest rest1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_rest rest2 s a))\n                            b)", "case (sim p q a res b s')"], ["proof (state)\nthis:\n  S_rest p q\n  a \\<in> IA <+> IU\n  res \\<in> set_spmf q\n  (b, s') \\<in> set_spmf (callee_of_rest rest2 res a)\n\ngoal (1 subgoal):\n 1. \\<And>p q a res b s'.\n       \\<lbrakk>S_rest p q; a \\<in> IA <+> IU; res \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee_of_rest rest2 res a)\\<rbrakk>\n       \\<Longrightarrow> S_rest\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_rest rest1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_rest rest2 s a))\n                            b)", "then"], ["proof (chain)\npicking this:\n  S_rest p q\n  a \\<in> IA <+> IU\n  res \\<in> set_spmf q\n  (b, s') \\<in> set_spmf (callee_of_rest rest2 res a)", "consider (rfunc_adv) ia where \"a = Inl ia\" \"ia \\<in> IA\"\n      | (rfunc_usr) iu where \"a = Inr iu\" \"iu \\<in> IU\""], ["proof (prove)\nusing this:\n  S_rest p q\n  a \\<in> IA <+> IU\n  res \\<in> set_spmf q\n  (b, s') \\<in> set_spmf (callee_of_rest rest2 res a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ia.\n                \\<lbrakk>a = Inl ia; ia \\<in> IA\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>iu.\n        \\<lbrakk>a = Inr iu; iu \\<in> IU\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>ia.\n              \\<lbrakk>a = Inl ia; ia \\<in> IA\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>iu.\n      \\<lbrakk>a = Inr iu; iu \\<in> IU\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>p q a res b s'.\n       \\<lbrakk>S_rest p q; a \\<in> IA <+> IU; res \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee_of_rest rest2 res a)\\<rbrakk>\n       \\<Longrightarrow> S_rest\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_rest rest1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_rest rest2 s a))\n                            b)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>ia.\n              \\<lbrakk>a = Inl ia; ia \\<in> IA\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>iu.\n      \\<lbrakk>a = Inr iu; iu \\<in> IU\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>ia.\n              \\<lbrakk>a = Inl ia; ia \\<in> IA\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>iu.\n      \\<lbrakk>a = Inr iu; iu \\<in> IU\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. S_rest\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee_of_rest rest1 s a)) b)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee_of_rest rest2 s a)) b)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ia.\n       \\<lbrakk>a = Inl ia; ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> S_rest\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_rest rest1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_rest rest2 s a))\n                            b)\n 2. \\<And>iu.\n       \\<lbrakk>a = Inr iu; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> S_rest\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_rest rest1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_rest rest2 s a))\n                            b)", "case rfunc_adv"], ["proof (state)\nthis:\n  a = Inl ia\n  ia \\<in> IA\n\ngoal (2 subgoals):\n 1. \\<And>ia.\n       \\<lbrakk>a = Inl ia; ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> S_rest\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_rest rest1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_rest rest2 s a))\n                            b)\n 2. \\<And>iu.\n       \\<lbrakk>a = Inr iu; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> S_rest\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_rest rest1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_rest rest2 s a))\n                            b)", "with sim_rfunc_adv[OF sim(1) rfunc_adv(2)] sim"], ["proof (chain)\npicking this:\n  S_rest\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s1. rfunc_adv rest1 s1 ia)) ?oa)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s2. rfunc_adv rest2 s2 ia)) ?oa)\n  S_rest p q\n  a \\<in> IA <+> IU\n  res \\<in> set_spmf q\n  (b, s') \\<in> set_spmf (callee_of_rest rest2 res a)\n  a = Inl ia\n  ia \\<in> IA", "show ?thesis"], ["proof (prove)\nusing this:\n  S_rest\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s1. rfunc_adv rest1 s1 ia)) ?oa)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s2. rfunc_adv rest2 s2 ia)) ?oa)\n  S_rest p q\n  a \\<in> IA <+> IU\n  res \\<in> set_spmf q\n  (b, s') \\<in> set_spmf (callee_of_rest rest2 res a)\n  a = Inl ia\n  ia \\<in> IA\n\ngoal (1 subgoal):\n 1. S_rest\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee_of_rest rest1 s a)) b)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee_of_rest rest2 s a)) b)", "by(clarsimp simp add: map_bind_spmf[unfolded o_def, symmetric] apfst_def map_prod_def)\n          (subst (1 2) cond_spmf_fst_map_prod_inj; simp)"], ["proof (state)\nthis:\n  S_rest\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee_of_rest rest1 s a)) b)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee_of_rest rest2 s a)) b)\n\ngoal (1 subgoal):\n 1. \\<And>iu.\n       \\<lbrakk>a = Inr iu; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> S_rest\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_rest rest1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_rest rest2 s a))\n                            b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>iu.\n       \\<lbrakk>a = Inr iu; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> S_rest\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_rest rest1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_rest rest2 s a))\n                            b)", "case rfunc_usr"], ["proof (state)\nthis:\n  a = Inr iu\n  iu \\<in> IU\n\ngoal (1 subgoal):\n 1. \\<And>iu.\n       \\<lbrakk>a = Inr iu; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> S_rest\n                          (cond_spmf_fst\n                            (p \\<bind>\n                             (\\<lambda>s. callee_of_rest rest1 s a))\n                            b)\n                          (cond_spmf_fst\n                            (q \\<bind>\n                             (\\<lambda>s. callee_of_rest rest2 s a))\n                            b)", "with sim_rfunc_usr[OF sim(1) rfunc_usr(2)] sim"], ["proof (chain)\npicking this:\n  S_rest\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 iu)) ?ou)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s2. rfunc_usr rest2 s2 iu)) ?ou)\n  S_rest p q\n  a \\<in> IA <+> IU\n  res \\<in> set_spmf q\n  (b, s') \\<in> set_spmf (callee_of_rest rest2 res a)\n  a = Inr iu\n  iu \\<in> IU", "show ?thesis"], ["proof (prove)\nusing this:\n  S_rest\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s1. rfunc_usr rest1 s1 iu)) ?ou)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s2. rfunc_usr rest2 s2 iu)) ?ou)\n  S_rest p q\n  a \\<in> IA <+> IU\n  res \\<in> set_spmf q\n  (b, s') \\<in> set_spmf (callee_of_rest rest2 res a)\n  a = Inr iu\n  iu \\<in> IU\n\ngoal (1 subgoal):\n 1. S_rest\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee_of_rest rest1 s a)) b)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee_of_rest rest2 s a)) b)", "by(clarsimp simp add: map_bind_spmf[unfolded o_def, symmetric] apfst_def map_prod_def)\n          (subst (1 2) cond_spmf_fst_map_prod_inj; simp)"], ["proof (state)\nthis:\n  S_rest\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee_of_rest rest1 s a)) b)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee_of_rest rest2 s a)) b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S_rest\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee_of_rest rest1 s a)) b)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee_of_rest rest2 s a)) b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trace_callee_eq (callee_of_rest rest1) (callee_of_rest rest2) (IA <+> IU)\n   p q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_callee_resource_of_oracle:\n  \"trace_callee run_resource (map_spmf (resource_of_oracle callee) p) = trace_callee callee p\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee run_resource (map_spmf (RES callee) p) =\n    trace_callee callee p", "proof(intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       trace_callee run_resource (map_spmf (RES callee) p) x xa =\n       trace_callee callee p x xa", "show \"?lhs tr x = ?rhs tr x\" for tr x"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee run_resource (map_spmf (RES callee) p) tr x =\n    trace_callee callee p tr x", "proof(induction tr arbitrary: p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       trace_callee run_resource (map_spmf (RES callee) p) [] x =\n       trace_callee callee p [] x\n 2. \\<And>a tr p.\n       (\\<And>p.\n           trace_callee run_resource (map_spmf (RES callee) p) tr x =\n           trace_callee callee p tr x) \\<Longrightarrow>\n       trace_callee run_resource (map_spmf (RES callee) p) (a # tr) x =\n       trace_callee callee p (a # tr) x", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>p.\n       trace_callee run_resource (map_spmf (RES callee) p) [] x =\n       trace_callee callee p [] x\n 2. \\<And>a tr p.\n       (\\<And>p.\n           trace_callee run_resource (map_spmf (RES callee) p) tr x =\n           trace_callee callee p tr x) \\<Longrightarrow>\n       trace_callee run_resource (map_spmf (RES callee) p) (a # tr) x =\n       trace_callee callee p (a # tr) x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee run_resource (map_spmf (RES callee) p) [] x =\n    trace_callee callee p [] x", "by(simp add: bind_map_spmf o_def spmf.map_comp)"], ["proof (state)\nthis:\n  trace_callee run_resource (map_spmf (RES callee) p) [] x =\n  trace_callee callee p [] x\n\ngoal (1 subgoal):\n 1. \\<And>a tr p.\n       (\\<And>p.\n           trace_callee run_resource (map_spmf (RES callee) p) tr x =\n           trace_callee callee p tr x) \\<Longrightarrow>\n       trace_callee run_resource (map_spmf (RES callee) p) (a # tr) x =\n       trace_callee callee p (a # tr) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a tr p.\n       (\\<And>p.\n           trace_callee run_resource (map_spmf (RES callee) p) tr x =\n           trace_callee callee p tr x) \\<Longrightarrow>\n       trace_callee run_resource (map_spmf (RES callee) p) (a # tr) x =\n       trace_callee callee p (a # tr) x", "case (Cons a tr)"], ["proof (state)\nthis:\n  trace_callee run_resource (map_spmf (RES callee) ?p) tr x =\n  trace_callee callee ?p tr x\n\ngoal (1 subgoal):\n 1. \\<And>a tr p.\n       (\\<And>p.\n           trace_callee run_resource (map_spmf (RES callee) p) tr x =\n           trace_callee callee p tr x) \\<Longrightarrow>\n       trace_callee run_resource (map_spmf (RES callee) p) (a # tr) x =\n       trace_callee callee p (a # tr) x", "obtain y z where a [simp]: \"a = (y, z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y z. a = (y, z) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases a)"], ["proof (state)\nthis:\n  a = (y, z)\n\ngoal (1 subgoal):\n 1. \\<And>a tr p.\n       (\\<And>p.\n           trace_callee run_resource (map_spmf (RES callee) p) tr x =\n           trace_callee callee p tr x) \\<Longrightarrow>\n       trace_callee run_resource (map_spmf (RES callee) p) (a # tr) x =\n       trace_callee callee p (a # tr) x", "have \"trace_callee run_resource (map_spmf (RES callee) p) (a # tr) x =\n      trace_callee run_resource (cond_spmf_fst (map_spmf (\\<lambda>(x, y). (x, RES callee y)) (p \\<bind> (\\<lambda>x. (callee x y)))) z) tr x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee run_resource (map_spmf (RES callee) p) (a # tr) x =\n    trace_callee run_resource\n     (cond_spmf_fst\n       (map_spmf (\\<lambda>(x, y). (x, RES callee y))\n         (p \\<bind> (\\<lambda>x. callee x y)))\n       z)\n     tr x", "by(clarsimp simp add: bind_map_spmf o_def map_prod_def map_bind_spmf)"], ["proof (state)\nthis:\n  trace_callee run_resource (map_spmf (RES callee) p) (a # tr) x =\n  trace_callee run_resource\n   (cond_spmf_fst\n     (map_spmf (\\<lambda>(x, y). (x, RES callee y))\n       (p \\<bind> (\\<lambda>x. callee x y)))\n     z)\n   tr x\n\ngoal (1 subgoal):\n 1. \\<And>a tr p.\n       (\\<And>p.\n           trace_callee run_resource (map_spmf (RES callee) p) tr x =\n           trace_callee callee p tr x) \\<Longrightarrow>\n       trace_callee run_resource (map_spmf (RES callee) p) (a # tr) x =\n       trace_callee callee p (a # tr) x", "also"], ["proof (state)\nthis:\n  trace_callee run_resource (map_spmf (RES callee) p) (a # tr) x =\n  trace_callee run_resource\n   (cond_spmf_fst\n     (map_spmf (\\<lambda>(x, y). (x, RES callee y))\n       (p \\<bind> (\\<lambda>x. callee x y)))\n     z)\n   tr x\n\ngoal (1 subgoal):\n 1. \\<And>a tr p.\n       (\\<And>p.\n           trace_callee run_resource (map_spmf (RES callee) p) tr x =\n           trace_callee callee p tr x) \\<Longrightarrow>\n       trace_callee run_resource (map_spmf (RES callee) p) (a # tr) x =\n       trace_callee callee p (a # tr) x", "have \"\\<dots> = trace_callee run_resource (map_spmf (RES callee) (cond_spmf_fst (p \\<bind> (\\<lambda>x. (callee x y))) z)) tr x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee run_resource\n     (cond_spmf_fst\n       (map_spmf (\\<lambda>(x, y). (x, RES callee y))\n         (p \\<bind> (\\<lambda>x. callee x y)))\n       z)\n     tr x =\n    trace_callee run_resource\n     (map_spmf (RES callee)\n       (cond_spmf_fst (p \\<bind> (\\<lambda>x. callee x y)) z))\n     tr x", "by(subst cond_spmf_fst_map_prod_inj) simp_all"], ["proof (state)\nthis:\n  trace_callee run_resource\n   (cond_spmf_fst\n     (map_spmf (\\<lambda>(x, y). (x, RES callee y))\n       (p \\<bind> (\\<lambda>x. callee x y)))\n     z)\n   tr x =\n  trace_callee run_resource\n   (map_spmf (RES callee)\n     (cond_spmf_fst (p \\<bind> (\\<lambda>x. callee x y)) z))\n   tr x\n\ngoal (1 subgoal):\n 1. \\<And>a tr p.\n       (\\<And>p.\n           trace_callee run_resource (map_spmf (RES callee) p) tr x =\n           trace_callee callee p tr x) \\<Longrightarrow>\n       trace_callee run_resource (map_spmf (RES callee) p) (a # tr) x =\n       trace_callee callee p (a # tr) x", "finally"], ["proof (chain)\npicking this:\n  trace_callee run_resource (map_spmf (RES callee) p) (a # tr) x =\n  trace_callee run_resource\n   (map_spmf (RES callee)\n     (cond_spmf_fst (p \\<bind> (\\<lambda>x. callee x y)) z))\n   tr x", "show ?case"], ["proof (prove)\nusing this:\n  trace_callee run_resource (map_spmf (RES callee) p) (a # tr) x =\n  trace_callee run_resource\n   (map_spmf (RES callee)\n     (cond_spmf_fst (p \\<bind> (\\<lambda>x. callee x y)) z))\n   tr x\n\ngoal (1 subgoal):\n 1. trace_callee run_resource (map_spmf (RES callee) p) (a # tr) x =\n    trace_callee callee p (a # tr) x", "using Cons.IH"], ["proof (prove)\nusing this:\n  trace_callee run_resource (map_spmf (RES callee) p) (a # tr) x =\n  trace_callee run_resource\n   (map_spmf (RES callee)\n     (cond_spmf_fst (p \\<bind> (\\<lambda>x. callee x y)) z))\n   tr x\n  trace_callee run_resource (map_spmf (RES callee) ?p) tr x =\n  trace_callee callee ?p tr x\n\ngoal (1 subgoal):\n 1. trace_callee run_resource (map_spmf (RES callee) p) (a # tr) x =\n    trace_callee callee p (a # tr) x", "by simp"], ["proof (state)\nthis:\n  trace_callee run_resource (map_spmf (RES callee) p) (a # tr) x =\n  trace_callee callee p (a # tr) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trace_callee run_resource (map_spmf (RES callee) p) ?tr ?x =\n  trace_callee callee p ?tr ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_callee_resource_of_oracle':\n  \"trace_callee run_resource (return_spmf (resource_of_oracle callee s)) = trace_callee callee (return_spmf s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee run_resource (return_spmf (RES callee s)) =\n    trace_callee callee (return_spmf s)", "using trace_callee_resource_of_oracle[where p=\"return_spmf s\"]"], ["proof (prove)\nusing this:\n  trace_callee run_resource (map_spmf (RES ?callee) (return_spmf s)) =\n  trace_callee ?callee (return_spmf s)\n\ngoal (1 subgoal):\n 1. trace_callee run_resource (return_spmf (RES callee s)) =\n    trace_callee callee (return_spmf s)", "by simp"], ["", "lemma trace_eq_resource_of_oracle:\n  \"trace_eq A (map_spmf (resource_of_oracle callee1) p) (map_spmf (resource_of_oracle callee2) q) =\n   trace_callee_eq callee1 callee2 A p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_eq A (map_spmf (RES callee1) p) (map_spmf (RES callee2) q) =\n    trace_callee_eq callee1 callee2 A p q", "unfolding trace_callee_eq_def trace_callee_resource_of_oracle"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>xs.\n        set xs \\<subseteq> A \\<times> UNIV \\<longrightarrow>\n        (\\<forall>x\\<in>A.\n            trace_callee callee1 p xs x = trace_callee callee2 q xs x)) =\n    (\\<forall>xs.\n        set xs \\<subseteq> A \\<times> UNIV \\<longrightarrow>\n        (\\<forall>x\\<in>A.\n            trace_callee callee1 p xs x = trace_callee callee2 q xs x))", "by(rule refl)"], ["", "lemma WT_fuse_converter [WT_intro]:\n  \"(\\<I>AC \\<oplus>\\<^sub>\\<I> map_\\<I> id fst \\<I>AR) \\<oplus>\\<^sub>\\<I> (\\<I>UC \\<oplus>\\<^sub>\\<I> map_\\<I> id fst \\<I>UR), (\\<I>E \\<oplus>\\<^sub>\\<I> (\\<I>AC \\<oplus>\\<^sub>\\<I> \\<I>UC)) \\<oplus>\\<^sub>\\<I> (\\<I>AR \\<oplus>\\<^sub>\\<I> \\<I>UR) \\<turnstile>\\<^sub>C fuse_converter \\<surd>\"\n  if \"\\<forall>x. \\<forall>(y, es)\\<in>responses_\\<I> \\<I>AR x. set es \\<subseteq> outs_\\<I> \\<I>E\" \"\\<forall>x. \\<forall>(y, es)\\<in>responses_\\<I> \\<I>UR x. set es \\<subseteq> outs_\\<I> \\<I>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<I>AC \\<oplus>\\<^sub>\\<I> map_\\<I> id fst \\<I>AR) \\<oplus>\\<^sub>\\<I>\n    (\\<I>UC \\<oplus>\\<^sub>\\<I> map_\\<I> id fst \\<I>UR),\n    (\\<I>E \\<oplus>\\<^sub>\\<I>\n     (\\<I>AC \\<oplus>\\<^sub>\\<I> \\<I>UC)) \\<oplus>\\<^sub>\\<I>\n    (\\<I>AR \\<oplus>\\<^sub>\\<I> \\<I>UR) \\<turnstile>\\<^sub>C\n    fuse_converter \\<surd>", "unfolding fuse_converter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<I>AC \\<oplus>\\<^sub>\\<I> map_\\<I> id fst \\<I>AR) \\<oplus>\\<^sub>\\<I>\n    (\\<I>UC \\<oplus>\\<^sub>\\<I> map_\\<I> id fst \\<I>UR),\n    (\\<I>E \\<oplus>\\<^sub>\\<I>\n     (\\<I>AC \\<oplus>\\<^sub>\\<I> \\<I>UC)) \\<oplus>\\<^sub>\\<I>\n    (\\<I>AR \\<oplus>\\<^sub>\\<I> \\<I>UR) \\<turnstile>\\<^sub>C\n    CNV (stateless_callee fuse_callee) () \\<surd>", "using that"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     \\<forall>(y, es)\\<in>responses_\\<I> \\<I>AR x.\n        set es \\<subseteq> outs_\\<I> \\<I>E\n  \\<forall>x.\n     \\<forall>(y, es)\\<in>responses_\\<I> \\<I>UR x.\n        set es \\<subseteq> outs_\\<I> \\<I>E\n\ngoal (1 subgoal):\n 1. (\\<I>AC \\<oplus>\\<^sub>\\<I> map_\\<I> id fst \\<I>AR) \\<oplus>\\<^sub>\\<I>\n    (\\<I>UC \\<oplus>\\<^sub>\\<I> map_\\<I> id fst \\<I>UR),\n    (\\<I>E \\<oplus>\\<^sub>\\<I>\n     (\\<I>AC \\<oplus>\\<^sub>\\<I> \\<I>UC)) \\<oplus>\\<^sub>\\<I>\n    (\\<I>AR \\<oplus>\\<^sub>\\<I> \\<I>UR) \\<turnstile>\\<^sub>C\n    CNV (stateless_callee fuse_callee) () \\<surd>", "by(intro WT_converter_of_callee)\n    (fastforce simp add: stateless_callee_def image_image intro: rev_image_eqI intro!: WT_gpv_pauses split: if_split_asm)+"], ["", "theorem fuse_trace_eq:\n  fixes core1 :: \"('s_core, 'event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\"\n    and core2 :: \"('s_core', 'event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\"\n    and rest1 :: \"('s_rest, 'event, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest, 'more1) rest_scheme\"\n    and rest2 :: \"('s_rest', 'event, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest, 'more2) rest_scheme\"\n  assumes core: \"trace_core_eq core1 core2 (outs_\\<I> \\<I>E) (outs_\\<I> \\<I>CA) (outs_\\<I> \\<I>CU) (return_spmf s_core) (return_spmf s_core')\"\n    and rest: \"trace_rest_eq rest1 rest2 (outs_\\<I> \\<I>RA) (outs_\\<I> \\<I>RU) (return_spmf s_rest) (return_spmf s_rest')\"\n    and IC1: \"callee_invariant_on (callee_of_core core1) IC1 (\\<I>E \\<oplus>\\<^sub>\\<I> (\\<I>CA \\<oplus>\\<^sub>\\<I> \\<I>CU))\" \"IC1 s_core\"\n    and IC2: \"callee_invariant_on (callee_of_core core2) IC2 (\\<I>E \\<oplus>\\<^sub>\\<I> (\\<I>CA \\<oplus>\\<^sub>\\<I> \\<I>CU))\" \"IC2 s_core'\"\n    and IR1: \"callee_invariant_on (callee_of_rest rest1) IR1 (\\<I>RA \\<oplus>\\<^sub>\\<I> \\<I>RU)\" \"IR1 s_rest\"\n    and IR2: \"callee_invariant_on (callee_of_rest rest2) IR2 (\\<I>RA \\<oplus>\\<^sub>\\<I> \\<I>RU)\" \"IR2 s_rest'\"\n    and E1 [WT_intro]: \"\\<forall>x. \\<forall>(y, es)\\<in>responses_\\<I> \\<I>RA x. set es \\<subseteq> outs_\\<I> \\<I>E\"\n    and E2 [WT_intro]: \"\\<forall>x. \\<forall>(y, es)\\<in>responses_\\<I> \\<I>RU x. set es \\<subseteq> outs_\\<I> \\<I>E\"\n  shows \"trace_callee_eq (fused_resource.fuse core1 rest1) (fused_resource.fuse core2 rest2)\n    ((outs_\\<I> \\<I>CA <+> outs_\\<I> \\<I>RA) <+> (outs_\\<I> \\<I>CU <+> outs_\\<I> \\<I>RU)) (return_spmf (s_core, s_rest)) (return_spmf (s_core', s_rest'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((outs_\\<I> \\<I>CA <+> outs_\\<I> \\<I>RA) <+>\n     outs_\\<I> \\<I>CU <+> outs_\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n    fused_resource.fuse core1 rest1((s_core, s_rest)) \\<approx>\n    fused_resource.fuse core2 rest2((s_core', s_rest'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((outs_\\<I> \\<I>CA <+> outs_\\<I> \\<I>RA) <+>\n     outs_\\<I> \\<I>CU <+> outs_\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n    fused_resource.fuse core1 rest1((s_core, s_rest)) \\<approx>\n    fused_resource.fuse core2 rest2((s_core', s_rest'))", "let ?\\<I>C = \"\\<I>E \\<oplus>\\<^sub>\\<I> (\\<I>CA \\<oplus>\\<^sub>\\<I> \\<I>CU)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((outs_\\<I> \\<I>CA <+> outs_\\<I> \\<I>RA) <+>\n     outs_\\<I> \\<I>CU <+> outs_\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n    fused_resource.fuse core1 rest1((s_core, s_rest)) \\<approx>\n    fused_resource.fuse core2 rest2((s_core', s_rest'))", "let ?\\<I>R = \"\\<I>RA \\<oplus>\\<^sub>\\<I> \\<I>RU\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((outs_\\<I> \\<I>CA <+> outs_\\<I> \\<I>RA) <+>\n     outs_\\<I> \\<I>CU <+> outs_\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n    fused_resource.fuse core1 rest1((s_core, s_rest)) \\<approx>\n    fused_resource.fuse core2 rest2((s_core', s_rest'))", "let ?\\<I>' = \"?\\<I>C \\<oplus>\\<^sub>\\<I> ?\\<I>R\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((outs_\\<I> \\<I>CA <+> outs_\\<I> \\<I>RA) <+>\n     outs_\\<I> \\<I>CU <+> outs_\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n    fused_resource.fuse core1 rest1((s_core, s_rest)) \\<approx>\n    fused_resource.fuse core2 rest2((s_core', s_rest'))", "let ?\\<I> = \"(\\<I>CA \\<oplus>\\<^sub>\\<I> map_\\<I> id fst \\<I>RA) \\<oplus>\\<^sub>\\<I> (\\<I>CU \\<oplus>\\<^sub>\\<I> map_\\<I> id fst \\<I>RU)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((outs_\\<I> \\<I>CA <+> outs_\\<I> \\<I>RA) <+>\n     outs_\\<I> \\<I>CU <+> outs_\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n    fused_resource.fuse core1 rest1((s_core, s_rest)) \\<approx>\n    fused_resource.fuse core2 rest2((s_core', s_rest'))", "interpret fuse1: fused_resource core1 s1 for s1"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. ((outs_\\<I> \\<I>CA <+> outs_\\<I> \\<I>RA) <+>\n     outs_\\<I> \\<I>CU <+> outs_\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n    fuse1.fuse rest1((s_core, s_rest)) \\<approx>\n    fused_resource.fuse core2 rest2((s_core', s_rest'))", "interpret fuse2: fused_resource core2 s2 for s2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. ((outs_\\<I> \\<I>CA <+> outs_\\<I> \\<I>RA) <+>\n     outs_\\<I> \\<I>CU <+> outs_\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n    fuse1.fuse rest1((s_core, s_rest)) \\<approx>\n    fuse2.fuse rest2((s_core', s_rest'))", "interpret IC1: callee_invariant_on \"callee_of_core core1\" IC1 ?\\<I>C"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on (callee_of_core core1) IC1\n     (\\<I>E \\<oplus>\\<^sub>\\<I> (\\<I>CA \\<oplus>\\<^sub>\\<I> \\<I>CU))", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. ((outs_\\<I> \\<I>CA <+> outs_\\<I> \\<I>RA) <+>\n     outs_\\<I> \\<I>CU <+> outs_\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n    fuse1.fuse rest1((s_core, s_rest)) \\<approx>\n    fuse2.fuse rest2((s_core', s_rest'))", "interpret IC2: callee_invariant_on \"callee_of_core core2\" IC2 ?\\<I>C"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on (callee_of_core core2) IC2\n     (\\<I>E \\<oplus>\\<^sub>\\<I> (\\<I>CA \\<oplus>\\<^sub>\\<I> \\<I>CU))", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. ((outs_\\<I> \\<I>CA <+> outs_\\<I> \\<I>RA) <+>\n     outs_\\<I> \\<I>CU <+> outs_\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n    fuse1.fuse rest1((s_core, s_rest)) \\<approx>\n    fuse2.fuse rest2((s_core', s_rest'))", "interpret IR1: callee_invariant_on \"callee_of_rest rest1\" IR1 ?\\<I>R"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on (callee_of_rest rest1) IR1\n     (\\<I>RA \\<oplus>\\<^sub>\\<I> \\<I>RU)", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. ((outs_\\<I> \\<I>CA <+> outs_\\<I> \\<I>RA) <+>\n     outs_\\<I> \\<I>CU <+> outs_\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n    fuse1.fuse rest1((s_core, s_rest)) \\<approx>\n    fuse2.fuse rest2((s_core', s_rest'))", "interpret IR2: callee_invariant_on \"callee_of_rest rest2\" IR2 ?\\<I>R"], ["proof (prove)\ngoal (1 subgoal):\n 1. callee_invariant_on (callee_of_rest rest2) IR2\n     (\\<I>RA \\<oplus>\\<^sub>\\<I> \\<I>RU)", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. ((outs_\\<I> \\<I>CA <+> outs_\\<I> \\<I>RA) <+>\n     outs_\\<I> \\<I>CU <+> outs_\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n    fuse1.fuse rest1((s_core, s_rest)) \\<approx>\n    fuse2.fuse rest2((s_core', s_rest'))", "from core"], ["proof (chain)\npicking this:\n  trace_core_eq core1 core2 (outs_\\<I> \\<I>E) (outs_\\<I> \\<I>CA)\n   (outs_\\<I> \\<I>CU) (return_spmf s_core) (return_spmf s_core')", "have \"outs_\\<I> ?\\<I>C \\<turnstile>\\<^sub>C callee_of_core core1(s_core) \\<approx> callee_of_core core2(s_core')\""], ["proof (prove)\nusing this:\n  trace_core_eq core1 core2 (outs_\\<I> \\<I>E) (outs_\\<I> \\<I>CA)\n   (outs_\\<I> \\<I>CU) (return_spmf s_core) (return_spmf s_core')\n\ngoal (1 subgoal):\n 1. outs_\\<I>\n     (\\<I>E \\<oplus>\\<^sub>\\<I>\n      (\\<I>CA \\<oplus>\\<^sub>\\<I> \\<I>CU)) \\<turnstile>\\<^sub>C\n    callee_of_core core1(s_core) \\<approx> callee_of_core core2(s_core')", "by(simp add: trace_eq_callee_of_coreI)"], ["proof (state)\nthis:\n  outs_\\<I>\n   (\\<I>E \\<oplus>\\<^sub>\\<I>\n    (\\<I>CA \\<oplus>\\<^sub>\\<I> \\<I>CU)) \\<turnstile>\\<^sub>C\n  callee_of_core core1(s_core) \\<approx> callee_of_core core2(s_core')\n\ngoal (1 subgoal):\n 1. ((outs_\\<I> \\<I>CA <+> outs_\\<I> \\<I>RA) <+>\n     outs_\\<I> \\<I>CU <+> outs_\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n    fuse1.fuse rest1((s_core, s_rest)) \\<approx>\n    fuse2.fuse rest2((s_core', s_rest'))", "hence \"outs_\\<I> ?\\<I>C \\<turnstile>\\<^sub>R RES (callee_of_core core1) s_core \\<approx> RES (callee_of_core core2) s_core'\""], ["proof (prove)\nusing this:\n  outs_\\<I>\n   (\\<I>E \\<oplus>\\<^sub>\\<I>\n    (\\<I>CA \\<oplus>\\<^sub>\\<I> \\<I>CU)) \\<turnstile>\\<^sub>C\n  callee_of_core core1(s_core) \\<approx> callee_of_core core2(s_core')\n\ngoal (1 subgoal):\n 1. outs_\\<I>\n     (\\<I>E \\<oplus>\\<^sub>\\<I>\n      (\\<I>CA \\<oplus>\\<^sub>\\<I> \\<I>CU)) \\<turnstile>\\<^sub>R\n    RES (callee_of_core core1) s_core\n    \\<approx> RES (callee_of_core core2) s_core'", "by simp"], ["proof (state)\nthis:\n  outs_\\<I>\n   (\\<I>E \\<oplus>\\<^sub>\\<I>\n    (\\<I>CA \\<oplus>\\<^sub>\\<I> \\<I>CU)) \\<turnstile>\\<^sub>R\n  RES (callee_of_core core1) s_core\n  \\<approx> RES (callee_of_core core2) s_core'\n\ngoal (1 subgoal):\n 1. ((outs_\\<I> \\<I>CA <+> outs_\\<I> \\<I>RA) <+>\n     outs_\\<I> \\<I>CU <+> outs_\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n    fuse1.fuse rest1((s_core, s_rest)) \\<approx>\n    fuse2.fuse rest2((s_core', s_rest'))", "moreover"], ["proof (state)\nthis:\n  outs_\\<I>\n   (\\<I>E \\<oplus>\\<^sub>\\<I>\n    (\\<I>CA \\<oplus>\\<^sub>\\<I> \\<I>CU)) \\<turnstile>\\<^sub>R\n  RES (callee_of_core core1) s_core\n  \\<approx> RES (callee_of_core core2) s_core'\n\ngoal (1 subgoal):\n 1. ((outs_\\<I> \\<I>CA <+> outs_\\<I> \\<I>RA) <+>\n     outs_\\<I> \\<I>CU <+> outs_\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n    fuse1.fuse rest1((s_core, s_rest)) \\<approx>\n    fuse2.fuse rest2((s_core', s_rest'))", "have \"outs_\\<I> ?\\<I>R \\<turnstile>\\<^sub>C callee_of_rest rest1(s_rest) \\<approx> callee_of_rest rest2(s_rest')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outs_\\<I> (\\<I>RA \\<oplus>\\<^sub>\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n    callee_of_rest rest1(s_rest) \\<approx> callee_of_rest rest2(s_rest')", "using rest"], ["proof (prove)\nusing this:\n  trace_rest_eq rest1 rest2 (outs_\\<I> \\<I>RA) (outs_\\<I> \\<I>RU)\n   (return_spmf s_rest) (return_spmf s_rest')\n\ngoal (1 subgoal):\n 1. outs_\\<I> (\\<I>RA \\<oplus>\\<^sub>\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n    callee_of_rest rest1(s_rest) \\<approx> callee_of_rest rest2(s_rest')", "by(simp add: trace_eq_callee_of_restI)"], ["proof (state)\nthis:\n  outs_\\<I> (\\<I>RA \\<oplus>\\<^sub>\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n  callee_of_rest rest1(s_rest) \\<approx> callee_of_rest rest2(s_rest')\n\ngoal (1 subgoal):\n 1. ((outs_\\<I> \\<I>CA <+> outs_\\<I> \\<I>RA) <+>\n     outs_\\<I> \\<I>CU <+> outs_\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n    fuse1.fuse rest1((s_core, s_rest)) \\<approx>\n    fuse2.fuse rest2((s_core', s_rest'))", "hence \"outs_\\<I> ?\\<I>R \\<turnstile>\\<^sub>R RES (callee_of_rest rest1) s_rest \\<approx> RES (callee_of_rest rest2) s_rest'\""], ["proof (prove)\nusing this:\n  outs_\\<I> (\\<I>RA \\<oplus>\\<^sub>\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n  callee_of_rest rest1(s_rest) \\<approx> callee_of_rest rest2(s_rest')\n\ngoal (1 subgoal):\n 1. outs_\\<I> (\\<I>RA \\<oplus>\\<^sub>\\<I> \\<I>RU) \\<turnstile>\\<^sub>R\n    RES (callee_of_rest rest1) s_rest\n    \\<approx> RES (callee_of_rest rest2) s_rest'", "by simp"], ["proof (state)\nthis:\n  outs_\\<I> (\\<I>RA \\<oplus>\\<^sub>\\<I> \\<I>RU) \\<turnstile>\\<^sub>R\n  RES (callee_of_rest rest1) s_rest\n  \\<approx> RES (callee_of_rest rest2) s_rest'\n\ngoal (1 subgoal):\n 1. ((outs_\\<I> \\<I>CA <+> outs_\\<I> \\<I>RA) <+>\n     outs_\\<I> \\<I>CU <+> outs_\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n    fuse1.fuse rest1((s_core, s_rest)) \\<approx>\n    fuse2.fuse rest2((s_core', s_rest'))", "ultimately"], ["proof (chain)\npicking this:\n  outs_\\<I>\n   (\\<I>E \\<oplus>\\<^sub>\\<I>\n    (\\<I>CA \\<oplus>\\<^sub>\\<I> \\<I>CU)) \\<turnstile>\\<^sub>R\n  RES (callee_of_core core1) s_core\n  \\<approx> RES (callee_of_core core2) s_core'\n  outs_\\<I> (\\<I>RA \\<oplus>\\<^sub>\\<I> \\<I>RU) \\<turnstile>\\<^sub>R\n  RES (callee_of_rest rest1) s_rest\n  \\<approx> RES (callee_of_rest rest2) s_rest'", "have \"outs_\\<I> ?\\<I>' \\<turnstile>\\<^sub>R\n    RES (callee_of_core core1) s_core \\<parallel> RES (callee_of_rest rest1) s_rest \\<approx>\n    RES (callee_of_core core2) s_core' \\<parallel> RES (callee_of_rest rest2) s_rest'\""], ["proof (prove)\nusing this:\n  outs_\\<I>\n   (\\<I>E \\<oplus>\\<^sub>\\<I>\n    (\\<I>CA \\<oplus>\\<^sub>\\<I> \\<I>CU)) \\<turnstile>\\<^sub>R\n  RES (callee_of_core core1) s_core\n  \\<approx> RES (callee_of_core core2) s_core'\n  outs_\\<I> (\\<I>RA \\<oplus>\\<^sub>\\<I> \\<I>RU) \\<turnstile>\\<^sub>R\n  RES (callee_of_rest rest1) s_rest\n  \\<approx> RES (callee_of_rest rest2) s_rest'\n\ngoal (1 subgoal):\n 1. outs_\\<I>\n     ((\\<I>E \\<oplus>\\<^sub>\\<I>\n       (\\<I>CA \\<oplus>\\<^sub>\\<I> \\<I>CU)) \\<oplus>\\<^sub>\\<I>\n      (\\<I>RA \\<oplus>\\<^sub>\\<I> \\<I>RU)) \\<turnstile>\\<^sub>R\n    RES (callee_of_core core1) s_core \\<parallel>\n    RES (callee_of_rest rest1) s_rest\n    \\<approx> RES (callee_of_core core2) s_core' \\<parallel>\n              RES (callee_of_rest rest2) s_rest'", "by(simp add: trace_eq'_parallel_resource)"], ["proof (state)\nthis:\n  outs_\\<I>\n   ((\\<I>E \\<oplus>\\<^sub>\\<I>\n     (\\<I>CA \\<oplus>\\<^sub>\\<I> \\<I>CU)) \\<oplus>\\<^sub>\\<I>\n    (\\<I>RA \\<oplus>\\<^sub>\\<I> \\<I>RU)) \\<turnstile>\\<^sub>R\n  RES (callee_of_core core1) s_core \\<parallel>\n  RES (callee_of_rest rest1) s_rest\n  \\<approx> RES (callee_of_core core2) s_core' \\<parallel>\n            RES (callee_of_rest rest2) s_rest'\n\ngoal (1 subgoal):\n 1. ((outs_\\<I> \\<I>CA <+> outs_\\<I> \\<I>RA) <+>\n     outs_\\<I> \\<I>CU <+> outs_\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n    fuse1.fuse rest1((s_core, s_rest)) \\<approx>\n    fuse2.fuse rest2((s_core', s_rest'))", "hence \"outs_\\<I> ?\\<I> \\<turnstile>\\<^sub>R fuse_converter \\<rhd> (RES (callee_of_core core1) s_core \\<parallel> RES (callee_of_rest rest1) s_rest) \\<approx>\n                      fuse_converter \\<rhd> (RES (callee_of_core core2) s_core' \\<parallel> RES (callee_of_rest rest2) s_rest')\""], ["proof (prove)\nusing this:\n  outs_\\<I>\n   ((\\<I>E \\<oplus>\\<^sub>\\<I>\n     (\\<I>CA \\<oplus>\\<^sub>\\<I> \\<I>CU)) \\<oplus>\\<^sub>\\<I>\n    (\\<I>RA \\<oplus>\\<^sub>\\<I> \\<I>RU)) \\<turnstile>\\<^sub>R\n  RES (callee_of_core core1) s_core \\<parallel>\n  RES (callee_of_rest rest1) s_rest\n  \\<approx> RES (callee_of_core core2) s_core' \\<parallel>\n            RES (callee_of_rest rest2) s_rest'\n\ngoal (1 subgoal):\n 1. outs_\\<I>\n     ((\\<I>CA \\<oplus>\\<^sub>\\<I>\n       map_\\<I> id fst \\<I>RA) \\<oplus>\\<^sub>\\<I>\n      (\\<I>CU \\<oplus>\\<^sub>\\<I>\n       map_\\<I> id fst \\<I>RU)) \\<turnstile>\\<^sub>R\n    fuse_converter \\<rhd>\n    RES (callee_of_core core1) s_core \\<parallel>\n    RES (callee_of_rest rest1) s_rest\n    \\<approx> fuse_converter \\<rhd>\n              RES (callee_of_core core2) s_core' \\<parallel>\n              RES (callee_of_rest rest2) s_rest'", "by(rule attach_trace_eq')(intro WT_intro IC1.WT_resource_of_oracle IC1 IC2.WT_resource_of_oracle IC2 IR1.WT_resource_of_oracle IR1 IR2.WT_resource_of_oracle IR2)+"], ["proof (state)\nthis:\n  outs_\\<I>\n   ((\\<I>CA \\<oplus>\\<^sub>\\<I> map_\\<I> id fst \\<I>RA) \\<oplus>\\<^sub>\\<I>\n    (\\<I>CU \\<oplus>\\<^sub>\\<I>\n     map_\\<I> id fst \\<I>RU)) \\<turnstile>\\<^sub>R\n  fuse_converter \\<rhd>\n  RES (callee_of_core core1) s_core \\<parallel>\n  RES (callee_of_rest rest1) s_rest\n  \\<approx> fuse_converter \\<rhd>\n            RES (callee_of_core core2) s_core' \\<parallel>\n            RES (callee_of_rest rest2) s_rest'\n\ngoal (1 subgoal):\n 1. ((outs_\\<I> \\<I>CA <+> outs_\\<I> \\<I>RA) <+>\n     outs_\\<I> \\<I>CU <+> outs_\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n    fuse1.fuse rest1((s_core, s_rest)) \\<approx>\n    fuse2.fuse rest2((s_core', s_rest'))", "hence \"trace_eq' (outs_\\<I> ?\\<I>) (resource_of_oracle (fuse1.fuse rest1) (s_core, s_rest)) (resource_of_oracle (fuse2.fuse rest2) (s_core', s_rest'))\""], ["proof (prove)\nusing this:\n  outs_\\<I>\n   ((\\<I>CA \\<oplus>\\<^sub>\\<I> map_\\<I> id fst \\<I>RA) \\<oplus>\\<^sub>\\<I>\n    (\\<I>CU \\<oplus>\\<^sub>\\<I>\n     map_\\<I> id fst \\<I>RU)) \\<turnstile>\\<^sub>R\n  fuse_converter \\<rhd>\n  RES (callee_of_core core1) s_core \\<parallel>\n  RES (callee_of_rest rest1) s_rest\n  \\<approx> fuse_converter \\<rhd>\n            RES (callee_of_core core2) s_core' \\<parallel>\n            RES (callee_of_rest rest2) s_rest'\n\ngoal (1 subgoal):\n 1. outs_\\<I>\n     ((\\<I>CA \\<oplus>\\<^sub>\\<I>\n       map_\\<I> id fst \\<I>RA) \\<oplus>\\<^sub>\\<I>\n      (\\<I>CU \\<oplus>\\<^sub>\\<I>\n       map_\\<I> id fst \\<I>RU)) \\<turnstile>\\<^sub>R\n    RES (fuse1.fuse rest1) (s_core, s_rest)\n    \\<approx> RES (fuse2.fuse rest2) (s_core', s_rest')", "unfolding fuse_converter"], ["proof (prove)\nusing this:\n  outs_\\<I>\n   ((\\<I>CA \\<oplus>\\<^sub>\\<I> map_\\<I> id fst \\<I>RA) \\<oplus>\\<^sub>\\<I>\n    (\\<I>CU \\<oplus>\\<^sub>\\<I>\n     map_\\<I> id fst \\<I>RU)) \\<turnstile>\\<^sub>R\n  fuse_converter \\<rhd>\n  RES (callee_of_core core1) s_core \\<parallel>\n  RES (callee_of_rest rest1) s_rest\n  \\<approx> fuse_converter \\<rhd>\n            RES (callee_of_core core2) s_core' \\<parallel>\n            RES (callee_of_rest rest2) s_rest'\n\ngoal (1 subgoal):\n 1. outs_\\<I>\n     ((\\<I>CA \\<oplus>\\<^sub>\\<I>\n       map_\\<I> id fst \\<I>RA) \\<oplus>\\<^sub>\\<I>\n      (\\<I>CU \\<oplus>\\<^sub>\\<I>\n       map_\\<I> id fst \\<I>RU)) \\<turnstile>\\<^sub>R\n    fuse_converter \\<rhd>\n    RES (callee_of_core core1) s_core \\<parallel>\n    RES (callee_of_rest rest1) s_rest\n    \\<approx> fuse_converter \\<rhd>\n              RES (callee_of_core core2) s_core' \\<parallel>\n              RES (callee_of_rest rest2) s_rest'", "by simp"], ["proof (state)\nthis:\n  outs_\\<I>\n   ((\\<I>CA \\<oplus>\\<^sub>\\<I> map_\\<I> id fst \\<I>RA) \\<oplus>\\<^sub>\\<I>\n    (\\<I>CU \\<oplus>\\<^sub>\\<I>\n     map_\\<I> id fst \\<I>RU)) \\<turnstile>\\<^sub>R\n  RES (fuse1.fuse rest1) (s_core, s_rest)\n  \\<approx> RES (fuse2.fuse rest2) (s_core', s_rest')\n\ngoal (1 subgoal):\n 1. ((outs_\\<I> \\<I>CA <+> outs_\\<I> \\<I>RA) <+>\n     outs_\\<I> \\<I>CU <+> outs_\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n    fuse1.fuse rest1((s_core, s_rest)) \\<approx>\n    fuse2.fuse rest2((s_core', s_rest'))", "then"], ["proof (chain)\npicking this:\n  outs_\\<I>\n   ((\\<I>CA \\<oplus>\\<^sub>\\<I> map_\\<I> id fst \\<I>RA) \\<oplus>\\<^sub>\\<I>\n    (\\<I>CU \\<oplus>\\<^sub>\\<I>\n     map_\\<I> id fst \\<I>RU)) \\<turnstile>\\<^sub>R\n  RES (fuse1.fuse rest1) (s_core, s_rest)\n  \\<approx> RES (fuse2.fuse rest2) (s_core', s_rest')", "show ?thesis"], ["proof (prove)\nusing this:\n  outs_\\<I>\n   ((\\<I>CA \\<oplus>\\<^sub>\\<I> map_\\<I> id fst \\<I>RA) \\<oplus>\\<^sub>\\<I>\n    (\\<I>CU \\<oplus>\\<^sub>\\<I>\n     map_\\<I> id fst \\<I>RU)) \\<turnstile>\\<^sub>R\n  RES (fuse1.fuse rest1) (s_core, s_rest)\n  \\<approx> RES (fuse2.fuse rest2) (s_core', s_rest')\n\ngoal (1 subgoal):\n 1. ((outs_\\<I> \\<I>CA <+> outs_\\<I> \\<I>RA) <+>\n     outs_\\<I> \\<I>CU <+> outs_\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n    fuse1.fuse rest1((s_core, s_rest)) \\<approx>\n    fuse2.fuse rest2((s_core', s_rest'))", "by simp"], ["proof (state)\nthis:\n  ((outs_\\<I> \\<I>CA <+> outs_\\<I> \\<I>RA) <+>\n   outs_\\<I> \\<I>CU <+> outs_\\<I> \\<I>RU) \\<turnstile>\\<^sub>C\n  fuse1.fuse rest1((s_core, s_rest)) \\<approx>\n  fuse2.fuse rest2((s_core', s_rest'))\n\ngoal:\nNo subgoals!", "qed"], ["", "inductive trace_eq_simcl :: \"('s1 spmf \\<Rightarrow> 's2 spmf \\<Rightarrow> bool) \\<Rightarrow> 's1 spmf \\<Rightarrow> 's2 spmf \\<Rightarrow> bool\"\n  for S where\n  base: \"trace_eq_simcl S p q\" if \"S p q\" for p q\n| bind_nat: \"trace_eq_simcl S (bind_spmf p f) (bind_spmf p g)\" \nif \"\\<And>x :: nat. x \\<in> set_spmf p \\<Longrightarrow> S (f x) (g x)\""], ["", "lemma trace_eq_simcl_bindI [intro?]: \"trace_eq_simcl S (bind_spmf p f) (bind_spmf p g)\"\n  if \"\\<And>x. x \\<in> set_spmf p \\<Longrightarrow> S (f x) (g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_eq_simcl S (p \\<bind> f) (p \\<bind> g)", "by(subst (1 2) bind_spmf_to_nat_on[symmetric])(auto intro!: trace_eq_simcl.bind_nat simp add: that)"], ["", "lemma trace_eq_simcl_bind: \"trace_eq_simcl S (bind_spmf p f) (bind_spmf p g)\"\n  if *: \"\\<And>x :: 'a. x \\<in> set_spmf p \\<Longrightarrow> trace_eq_simcl S (f x) (g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_eq_simcl S (p \\<bind> f) (p \\<bind> g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace_eq_simcl S (p \\<bind> f) (p \\<bind> g)", "obtain P :: \"'a \\<Rightarrow> nat spmf\" and F G where\n    **: \"\\<And>x. x \\<in> set_spmf p \\<Longrightarrow> f x = bind_spmf (P x) (F x) \\<and> g x = bind_spmf (P x) (G x) \\<and> (\\<forall>y\\<in>set_spmf (P x). S (F x y) (G x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P F G.\n        (\\<And>x.\n            x \\<in> set_spmf p \\<Longrightarrow>\n            f x = P x \\<bind> F x \\<and>\n            g x = P x \\<bind> G x \\<and>\n            (\\<forall>y\\<in>set_spmf (P x).\n                S (F x y) (G x y))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply(atomize_elim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>P F G.\n       \\<forall>x.\n          x \\<in> set_spmf p \\<longrightarrow>\n          f x = P x \\<bind> F x \\<and>\n          g x = P x \\<bind> G x \\<and>\n          (\\<forall>y\\<in>set_spmf (P x). S (F x y) (G x y))", "apply(subst choice_iff[symmetric])+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>y ya yb.\n          x \\<in> set_spmf p \\<longrightarrow>\n          f x = y \\<bind> ya \\<and>\n          g x = y \\<bind> yb \\<and>\n          (\\<forall>y\\<in>set_spmf y. S (ya y) (yb y))", "apply(fastforce dest!: * elim!: trace_eq_simcl.cases intro: exI[where x=\"return_spmf _\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?x \\<in> set_spmf p \\<Longrightarrow>\n  f ?x = P ?x \\<bind> F ?x \\<and>\n  g ?x = P ?x \\<bind> G ?x \\<and>\n  (\\<forall>y\\<in>set_spmf (P ?x). S (F ?x y) (G ?x y))\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S (p \\<bind> f) (p \\<bind> g)", "have \"bind_spmf p f = bind_spmf (bind_spmf p (\\<lambda>x. map_spmf (Pair x) (P x))) (\\<lambda>(x, y). F x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bind> f =\n    p \\<bind> (\\<lambda>x. map_spmf (Pair x) (P x)) \\<bind>\n    (\\<lambda>(x, y). F x y)", "by(simp add: bind_map_spmf o_def ** cong: bind_spmf_cong)"], ["proof (state)\nthis:\n  p \\<bind> f =\n  p \\<bind> (\\<lambda>x. map_spmf (Pair x) (P x)) \\<bind>\n  (\\<lambda>(x, y). F x y)\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S (p \\<bind> f) (p \\<bind> g)", "moreover"], ["proof (state)\nthis:\n  p \\<bind> f =\n  p \\<bind> (\\<lambda>x. map_spmf (Pair x) (P x)) \\<bind>\n  (\\<lambda>(x, y). F x y)\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S (p \\<bind> f) (p \\<bind> g)", "have \"bind_spmf p g = bind_spmf (bind_spmf p (\\<lambda>x. map_spmf (Pair x) (P x))) (\\<lambda>(x, y). G x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bind> g =\n    p \\<bind> (\\<lambda>x. map_spmf (Pair x) (P x)) \\<bind>\n    (\\<lambda>(x, y). G x y)", "by(simp add: bind_map_spmf o_def ** cong: bind_spmf_cong)"], ["proof (state)\nthis:\n  p \\<bind> g =\n  p \\<bind> (\\<lambda>x. map_spmf (Pair x) (P x)) \\<bind>\n  (\\<lambda>(x, y). G x y)\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S (p \\<bind> f) (p \\<bind> g)", "ultimately"], ["proof (chain)\npicking this:\n  p \\<bind> f =\n  p \\<bind> (\\<lambda>x. map_spmf (Pair x) (P x)) \\<bind>\n  (\\<lambda>(x, y). F x y)\n  p \\<bind> g =\n  p \\<bind> (\\<lambda>x. map_spmf (Pair x) (P x)) \\<bind>\n  (\\<lambda>(x, y). G x y)", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<bind> f =\n  p \\<bind> (\\<lambda>x. map_spmf (Pair x) (P x)) \\<bind>\n  (\\<lambda>(x, y). F x y)\n  p \\<bind> g =\n  p \\<bind> (\\<lambda>x. map_spmf (Pair x) (P x)) \\<bind>\n  (\\<lambda>(x, y). G x y)\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S (p \\<bind> f) (p \\<bind> g)", "by(simp only:)(rule trace_eq_simcl_bindI; clarsimp simp add: **)"], ["proof (state)\nthis:\n  trace_eq_simcl S (p \\<bind> f) (p \\<bind> g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_eq_simcl_bind1_scale: \"trace_eq_simcl S (bind_spmf p f) (scale_spmf (weight_spmf p) q)\"\n  if \"\\<forall>x\\<in>set_spmf p. trace_eq_simcl S (f x) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_eq_simcl S (p \\<bind> f) (scale_spmf (weight_spmf p) q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace_eq_simcl S (p \\<bind> f) (scale_spmf (weight_spmf p) q)", "have \"trace_eq_simcl S (bind_spmf p f) (bind_spmf p (\\<lambda>_. q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_eq_simcl S (p \\<bind> f) (p \\<bind> (\\<lambda>_. q))", "by(rule trace_eq_simcl_bind)(simp add: that)"], ["proof (state)\nthis:\n  trace_eq_simcl S (p \\<bind> f) (p \\<bind> (\\<lambda>_. q))\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S (p \\<bind> f) (scale_spmf (weight_spmf p) q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  trace_eq_simcl S (p \\<bind> f) (p \\<bind> (\\<lambda>_. q))\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S (p \\<bind> f) (scale_spmf (weight_spmf p) q)", "by(simp add: bind_spmf_const)"], ["proof (state)\nthis:\n  trace_eq_simcl S (p \\<bind> f) (scale_spmf (weight_spmf p) q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_eq_simcl_bind1: \"trace_eq_simcl S (bind_spmf p f) q\"\n  if \"\\<forall>x\\<in>set_spmf p. trace_eq_simcl S (f x) q\" \"lossless_spmf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_eq_simcl S (p \\<bind> f) q", "using trace_eq_simcl_bind1_scale[OF that(1)] that(2)"], ["proof (prove)\nusing this:\n  trace_eq_simcl S (p \\<bind> f) (scale_spmf (weight_spmf p) q)\n  lossless_spmf p\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S (p \\<bind> f) q", "by(simp add: lossless_weight_spmfD)"], ["", "lemma trace_eq_simcl_bind2_scale: \"trace_eq_simcl S (scale_spmf (weight_spmf q) p) (bind_spmf q f)\"\n  if \"\\<forall>x\\<in>set_spmf q. trace_eq_simcl S p (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_eq_simcl S (scale_spmf (weight_spmf q) p) (q \\<bind> f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace_eq_simcl S (scale_spmf (weight_spmf q) p) (q \\<bind> f)", "have \"trace_eq_simcl S (bind_spmf q (\\<lambda>_. p)) (bind_spmf q f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_eq_simcl S (q \\<bind> (\\<lambda>_. p)) (q \\<bind> f)", "by(rule trace_eq_simcl_bind)(simp add: that)"], ["proof (state)\nthis:\n  trace_eq_simcl S (q \\<bind> (\\<lambda>_. p)) (q \\<bind> f)\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S (scale_spmf (weight_spmf q) p) (q \\<bind> f)", "thus ?thesis"], ["proof (prove)\nusing this:\n  trace_eq_simcl S (q \\<bind> (\\<lambda>_. p)) (q \\<bind> f)\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S (scale_spmf (weight_spmf q) p) (q \\<bind> f)", "by(simp add: bind_spmf_const)"], ["proof (state)\nthis:\n  trace_eq_simcl S (scale_spmf (weight_spmf q) p) (q \\<bind> f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_eq_simcl_bind2: \"trace_eq_simcl S p (bind_spmf q f)\"\n  if \"\\<forall>x\\<in>set_spmf q. trace_eq_simcl S p (f x)\" \"lossless_spmf q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_eq_simcl S p (q \\<bind> f)", "using trace_eq_simcl_bind2_scale[OF that(1)] that(2)"], ["proof (prove)\nusing this:\n  trace_eq_simcl S (scale_spmf (weight_spmf q) p) (q \\<bind> f)\n  lossless_spmf q\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S p (q \\<bind> f)", "by(simp add: lossless_weight_spmfD)"], ["", "lemma trace_eq_simcl_return_pmf_None [simp, intro!]: \"trace_eq_simcl S (return_pmf None) (return_pmf None)\" \n  for S :: \"'s1 spmf \\<Rightarrow> 's2 spmf \\<Rightarrow> bool\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_eq_simcl S (return_pmf None) (return_pmf None)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace_eq_simcl S (return_pmf None) (return_pmf None)", "have \"trace_eq_simcl S (bind_spmf (return_pmf None) (undefined :: nat \\<Rightarrow> 's1 spmf)) (bind_spmf (return_pmf None) (undefined :: nat \\<Rightarrow> 's2 spmf))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_eq_simcl S (return_pmf None \\<bind> undefined)\n     (return_pmf None \\<bind> undefined)", "by(rule trace_eq_simcl_bindI) simp"], ["proof (state)\nthis:\n  trace_eq_simcl S (return_pmf None \\<bind> undefined)\n   (return_pmf None \\<bind> undefined)\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S (return_pmf None) (return_pmf None)", "then"], ["proof (chain)\npicking this:\n  trace_eq_simcl S (return_pmf None \\<bind> undefined)\n   (return_pmf None \\<bind> undefined)", "show ?thesis"], ["proof (prove)\nusing this:\n  trace_eq_simcl S (return_pmf None \\<bind> undefined)\n   (return_pmf None \\<bind> undefined)\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S (return_pmf None) (return_pmf None)", "by simp"], ["proof (state)\nthis:\n  trace_eq_simcl S (return_pmf None) (return_pmf None)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_eq_simcl_map: \"trace_eq_simcl S (map_spmf f p) (map_spmf g p)\"\n  if \"\\<forall>x\\<in>set_spmf p. S (return_spmf (f x)) (return_spmf (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_eq_simcl S (map_spmf f p) (map_spmf g p)", "unfolding map_spmf_conv_bind_spmf"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_eq_simcl S (p \\<bind> (\\<lambda>x. return_spmf (f x)))\n     (p \\<bind> (\\<lambda>x. return_spmf (g x)))", "by(rule trace_eq_simcl_bindI)(simp add: that)"], ["", "lemma trace_eq_simcl_map1: \"trace_eq_simcl S (map_spmf f p) q\"\n  if \"\\<forall>x\\<in>set_spmf p. trace_eq_simcl S (return_spmf (f x)) q\" \"lossless_spmf p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_eq_simcl S (map_spmf f p) q", "unfolding map_spmf_conv_bind_spmf"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_eq_simcl S (p \\<bind> (\\<lambda>x. return_spmf (f x))) q", "by(rule trace_eq_simcl_bind1)(simp_all add: that)"], ["", "lemma trace_eq_simcl_map2: \"trace_eq_simcl S p (map_spmf f q)\"\n  if \"\\<forall>x\\<in>set_spmf q. trace_eq_simcl S p (return_spmf (f x))\" \"lossless_spmf q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_eq_simcl S p (map_spmf f q)", "unfolding map_spmf_conv_bind_spmf"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_eq_simcl S p (q \\<bind> (\\<lambda>x. return_spmf (f x)))", "by(rule trace_eq_simcl_bind2)(simp_all add: that)"], ["", "lemma trace_eq_simcl_return_spmf [simp]: \"trace_eq_simcl S (return_spmf x) (return_spmf y) \\<longleftrightarrow> S (return_spmf x) (return_spmf y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_eq_simcl S (return_spmf x) (return_spmf y) =\n    S (return_spmf x) (return_spmf y)", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. trace_eq_simcl S (return_spmf x) (return_spmf y) \\<Longrightarrow>\n    S (return_spmf x) (return_spmf y)\n 2. S (return_spmf x) (return_spmf y) \\<Longrightarrow>\n    trace_eq_simcl S (return_spmf x) (return_spmf y)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_eq_simcl S (return_spmf x) (return_spmf y) \\<Longrightarrow>\n    S (return_spmf x) (return_spmf y)", "by(erule trace_eq_simcl.cases; clarsimp dest!: sym[where s=\"return_spmf _\"])(auto 4 4 simp add: bind_eq_return_spmf dest!: lossless_spmfD_set_spmf_nonempty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. S (return_spmf x) (return_spmf y) \\<Longrightarrow>\n    trace_eq_simcl S (return_spmf x) (return_spmf y)", "by(simp add: trace_eq_simcl.base)"], ["", "lemma trace_eq_simcl_callee:\n  fixes callee1 :: \"('a, 'b, 's1) callee\" and callee2 :: \"('a, 'b, 's2) callee\"\n  assumes step: \"\\<And>p q a. \\<lbrakk> S p q; a \\<in> A \\<rbrakk> \\<Longrightarrow>\n      bind_spmf p (\\<lambda>s. map_spmf fst (callee1 s a)) = bind_spmf q (\\<lambda>s. map_spmf fst (callee2 s a))\"\n    and sim: \"\\<And>p q a res b s'. \\<lbrakk> S p q; a \\<in> A; res \\<in> set_spmf q; (b, s') \\<in> set_spmf (callee2 res a) \\<rbrakk>\n      \\<Longrightarrow> trace_eq_simcl S (cond_spmf_fst (bind_spmf p (\\<lambda>s. callee1 s a)) b)\n            (cond_spmf_fst (bind_spmf q (\\<lambda>s. callee2 s a)) b)\"\n    and start: \"trace_eq_simcl S p q\" and a: \"a \\<in> A\"\n  shows trace_eq_simcl_callee_step: \"bind_spmf p (\\<lambda>s. map_spmf fst (callee1 s a)) = bind_spmf q (\\<lambda>s. map_spmf fst (callee2 s a))\" (is \"?step\")\n    and trace_eq_simcl_callee_sim: \"\\<And>res b s'. \\<lbrakk> res \\<in> set_spmf q; (b, s') \\<in> set_spmf (callee2 res a) \\<rbrakk>\n      \\<Longrightarrow> trace_eq_simcl S (cond_spmf_fst (bind_spmf p (\\<lambda>s. callee1 s a)) b)\n                            (cond_spmf_fst (bind_spmf q (\\<lambda>s. callee2 s a)) b)\" (is \"\\<And>res b s'. \\<lbrakk> ?res res; ?b res b s' \\<rbrakk> \\<Longrightarrow> ?sim res b s'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bind> (\\<lambda>s. map_spmf fst (callee1 s a)) =\n    q \\<bind> (\\<lambda>s. map_spmf fst (callee2 s a)) &&&\n    (\\<And>res b s'.\n        \\<lbrakk>res \\<in> set_spmf q;\n         (b, s') \\<in> set_spmf (callee2 res a)\\<rbrakk>\n        \\<Longrightarrow> trace_eq_simcl S\n                           (cond_spmf_fst\n                             (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                           (cond_spmf_fst\n                             (q \\<bind> (\\<lambda>s. callee2 s a)) b))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<bind> (\\<lambda>s. map_spmf fst (callee1 s a)) =\n    q \\<bind> (\\<lambda>s. map_spmf fst (callee2 s a))\n 2. \\<And>res b s'.\n       \\<lbrakk>res \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee2 res a)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "show eq: ?step"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bind> (\\<lambda>s. map_spmf fst (callee1 s a)) =\n    q \\<bind> (\\<lambda>s. map_spmf fst (callee2 s a))", "using start a"], ["proof (prove)\nusing this:\n  trace_eq_simcl S p q\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. p \\<bind> (\\<lambda>s. map_spmf fst (callee1 s a)) =\n    q \\<bind> (\\<lambda>s. map_spmf fst (callee2 s a))", "by cases(auto intro!: bind_spmf_cong intro: step)"], ["proof (state)\nthis:\n  p \\<bind> (\\<lambda>s. map_spmf fst (callee1 s a)) =\n  q \\<bind> (\\<lambda>s. map_spmf fst (callee2 s a))\n\ngoal (1 subgoal):\n 1. \\<And>res b s'.\n       \\<lbrakk>res \\<in> set_spmf q;\n        (b, s') \\<in> set_spmf (callee2 res a)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "show \"?sim res b s'\" if \"?res res\" \"?b res b s'\" for res b s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_eq_simcl S (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "using start"], ["proof (prove)\nusing this:\n  trace_eq_simcl S p q\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. S p q \\<Longrightarrow>\n    trace_eq_simcl S (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s a)) b)\n 2. \\<And>pa f g.\n       \\<lbrakk>p = pa \\<bind> f; q = pa \\<bind> g;\n        \\<And>x.\n           x \\<in> set_spmf pa \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "case base"], ["proof (state)\nthis:\n  S p q\n\ngoal (2 subgoals):\n 1. S p q \\<Longrightarrow>\n    trace_eq_simcl S (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s a)) b)\n 2. \\<And>pa f g.\n       \\<lbrakk>p = pa \\<bind> f; q = pa \\<bind> g;\n        \\<And>x.\n           x \\<in> set_spmf pa \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "then"], ["proof (chain)\npicking this:\n  S p q", "show ?thesis"], ["proof (prove)\nusing this:\n  S p q\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "using a that"], ["proof (prove)\nusing this:\n  S p q\n  a \\<in> A\n  res \\<in> set_spmf q\n  (b, s') \\<in> set_spmf (callee2 res a)\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "by(rule sim)"], ["proof (state)\nthis:\n  trace_eq_simcl S (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s a)) b)\n\ngoal (1 subgoal):\n 1. \\<And>pa f g.\n       \\<lbrakk>p = pa \\<bind> f; q = pa \\<bind> g;\n        \\<And>x.\n           x \\<in> set_spmf pa \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pa f g.\n       \\<lbrakk>p = pa \\<bind> f; q = pa \\<bind> g;\n        \\<And>x.\n           x \\<in> set_spmf pa \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "case (bind_nat X f g)"], ["proof (state)\nthis:\n  p = X \\<bind> f\n  q = X \\<bind> g\n  ?x \\<in> set_spmf X \\<Longrightarrow> S (f ?x) (g ?x)\n\ngoal (1 subgoal):\n 1. \\<And>pa f g.\n       \\<lbrakk>p = pa \\<bind> f; q = pa \\<bind> g;\n        \\<And>x.\n           x \\<in> set_spmf pa \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "let ?Y = \"cond_bind_spmf_fst X (\\<lambda>y. map_spmf fst (bind_spmf (f y) (\\<lambda>s. callee1 s a))) b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pa f g.\n       \\<lbrakk>p = pa \\<bind> f; q = pa \\<bind> g;\n        \\<And>x.\n           x \\<in> set_spmf pa \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "let ?Y' = \"cond_bind_spmf_fst X (\\<lambda>y. map_spmf fst (bind_spmf (g y) (\\<lambda>s. callee2 s a))) b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>pa f g.\n       \\<lbrakk>p = pa \\<bind> f; q = pa \\<bind> g;\n        \\<And>x.\n           x \\<in> set_spmf pa \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "have \"cond_spmf_fst (bind_spmf p (\\<lambda>s. callee1 s a)) b = bind_spmf ?Y (\\<lambda>x. cond_spmf_fst (bind_spmf (f x) (\\<lambda>s. callee1 s a)) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s a)) b =\n    cond_bind_spmf_fst X\n     (\\<lambda>y. map_spmf fst (f y \\<bind> (\\<lambda>s. callee1 s a)))\n     b \\<bind>\n    (\\<lambda>x. cond_spmf_fst (f x \\<bind> (\\<lambda>s. callee1 s a)) b)", "unfolding bind_nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf_fst (X \\<bind> f \\<bind> (\\<lambda>s. callee1 s a)) b =\n    cond_bind_spmf_fst X\n     (\\<lambda>y. map_spmf fst (f y \\<bind> (\\<lambda>s. callee1 s a)))\n     b \\<bind>\n    (\\<lambda>x. cond_spmf_fst (f x \\<bind> (\\<lambda>s. callee1 s a)) b)", "by(simp add: cond_spmf_fst_bind o_def)"], ["proof (state)\nthis:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s a)) b =\n  cond_bind_spmf_fst X\n   (\\<lambda>y. map_spmf fst (f y \\<bind> (\\<lambda>s. callee1 s a)))\n   b \\<bind>\n  (\\<lambda>x. cond_spmf_fst (f x \\<bind> (\\<lambda>s. callee1 s a)) b)\n\ngoal (1 subgoal):\n 1. \\<And>pa f g.\n       \\<lbrakk>p = pa \\<bind> f; q = pa \\<bind> g;\n        \\<And>x.\n           x \\<in> set_spmf pa \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "moreover"], ["proof (state)\nthis:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s a)) b =\n  cond_bind_spmf_fst X\n   (\\<lambda>y. map_spmf fst (f y \\<bind> (\\<lambda>s. callee1 s a)))\n   b \\<bind>\n  (\\<lambda>x. cond_spmf_fst (f x \\<bind> (\\<lambda>s. callee1 s a)) b)\n\ngoal (1 subgoal):\n 1. \\<And>pa f g.\n       \\<lbrakk>p = pa \\<bind> f; q = pa \\<bind> g;\n        \\<And>x.\n           x \\<in> set_spmf pa \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "have \"cond_spmf_fst (bind_spmf q (\\<lambda>s. callee2 s a)) b = bind_spmf ?Y' (\\<lambda>x. cond_spmf_fst (bind_spmf (g x) (\\<lambda>s. callee2 s a)) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s a)) b =\n    cond_bind_spmf_fst X\n     (\\<lambda>y. map_spmf fst (g y \\<bind> (\\<lambda>s. callee2 s a)))\n     b \\<bind>\n    (\\<lambda>x. cond_spmf_fst (g x \\<bind> (\\<lambda>s. callee2 s a)) b)", "unfolding bind_nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_spmf_fst (X \\<bind> g \\<bind> (\\<lambda>s. callee2 s a)) b =\n    cond_bind_spmf_fst X\n     (\\<lambda>y. map_spmf fst (g y \\<bind> (\\<lambda>s. callee2 s a)))\n     b \\<bind>\n    (\\<lambda>x. cond_spmf_fst (g x \\<bind> (\\<lambda>s. callee2 s a)) b)", "by(simp add: cond_spmf_fst_bind o_def)"], ["proof (state)\nthis:\n  cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s a)) b =\n  cond_bind_spmf_fst X\n   (\\<lambda>y. map_spmf fst (g y \\<bind> (\\<lambda>s. callee2 s a)))\n   b \\<bind>\n  (\\<lambda>x. cond_spmf_fst (g x \\<bind> (\\<lambda>s. callee2 s a)) b)\n\ngoal (1 subgoal):\n 1. \\<And>pa f g.\n       \\<lbrakk>p = pa \\<bind> f; q = pa \\<bind> g;\n        \\<And>x.\n           x \\<in> set_spmf pa \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "moreover"], ["proof (state)\nthis:\n  cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s a)) b =\n  cond_bind_spmf_fst X\n   (\\<lambda>y. map_spmf fst (g y \\<bind> (\\<lambda>s. callee2 s a)))\n   b \\<bind>\n  (\\<lambda>x. cond_spmf_fst (g x \\<bind> (\\<lambda>s. callee2 s a)) b)\n\ngoal (1 subgoal):\n 1. \\<And>pa f g.\n       \\<lbrakk>p = pa \\<bind> f; q = pa \\<bind> g;\n        \\<And>x.\n           x \\<in> set_spmf pa \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "have \"?Y = ?Y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_bind_spmf_fst X\n     (\\<lambda>y. map_spmf fst (f y \\<bind> (\\<lambda>s. callee1 s a))) b =\n    cond_bind_spmf_fst X\n     (\\<lambda>y. map_spmf fst (g y \\<bind> (\\<lambda>s. callee2 s a))) b", "using bind_nat eq"], ["proof (prove)\nusing this:\n  p = X \\<bind> f\n  q = X \\<bind> g\n  ?x \\<in> set_spmf X \\<Longrightarrow> S (f ?x) (g ?x)\n  p \\<bind> (\\<lambda>s. map_spmf fst (callee1 s a)) =\n  q \\<bind> (\\<lambda>s. map_spmf fst (callee2 s a))\n\ngoal (1 subgoal):\n 1. cond_bind_spmf_fst X\n     (\\<lambda>y. map_spmf fst (f y \\<bind> (\\<lambda>s. callee1 s a))) b =\n    cond_bind_spmf_fst X\n     (\\<lambda>y. map_spmf fst (g y \\<bind> (\\<lambda>s. callee2 s a))) b", "by(intro spmf_eqI)(fastforce simp add: map_bind_spmf o_def spmf_eq_0_set_spmf dest: step[OF _ a])"], ["proof (state)\nthis:\n  cond_bind_spmf_fst X\n   (\\<lambda>y. map_spmf fst (f y \\<bind> (\\<lambda>s. callee1 s a))) b =\n  cond_bind_spmf_fst X\n   (\\<lambda>y. map_spmf fst (g y \\<bind> (\\<lambda>s. callee2 s a))) b\n\ngoal (1 subgoal):\n 1. \\<And>pa f g.\n       \\<lbrakk>p = pa \\<bind> f; q = pa \\<bind> g;\n        \\<And>x.\n           x \\<in> set_spmf pa \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "ultimately"], ["proof (chain)\npicking this:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s a)) b =\n  cond_bind_spmf_fst X\n   (\\<lambda>y. map_spmf fst (f y \\<bind> (\\<lambda>s. callee1 s a)))\n   b \\<bind>\n  (\\<lambda>x. cond_spmf_fst (f x \\<bind> (\\<lambda>s. callee1 s a)) b)\n  cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s a)) b =\n  cond_bind_spmf_fst X\n   (\\<lambda>y. map_spmf fst (g y \\<bind> (\\<lambda>s. callee2 s a)))\n   b \\<bind>\n  (\\<lambda>x. cond_spmf_fst (g x \\<bind> (\\<lambda>s. callee2 s a)) b)\n  cond_bind_spmf_fst X\n   (\\<lambda>y. map_spmf fst (f y \\<bind> (\\<lambda>s. callee1 s a))) b =\n  cond_bind_spmf_fst X\n   (\\<lambda>y. map_spmf fst (g y \\<bind> (\\<lambda>s. callee2 s a))) b", "show \"trace_eq_simcl S (cond_spmf_fst (bind_spmf p (\\<lambda>s. callee1 s a)) b)\n        (cond_spmf_fst (bind_spmf q (\\<lambda>s. callee2 s a)) b)\""], ["proof (prove)\nusing this:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s a)) b =\n  cond_bind_spmf_fst X\n   (\\<lambda>y. map_spmf fst (f y \\<bind> (\\<lambda>s. callee1 s a)))\n   b \\<bind>\n  (\\<lambda>x. cond_spmf_fst (f x \\<bind> (\\<lambda>s. callee1 s a)) b)\n  cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s a)) b =\n  cond_bind_spmf_fst X\n   (\\<lambda>y. map_spmf fst (g y \\<bind> (\\<lambda>s. callee2 s a)))\n   b \\<bind>\n  (\\<lambda>x. cond_spmf_fst (g x \\<bind> (\\<lambda>s. callee2 s a)) b)\n  cond_bind_spmf_fst X\n   (\\<lambda>y. map_spmf fst (f y \\<bind> (\\<lambda>s. callee1 s a))) b =\n  cond_bind_spmf_fst X\n   (\\<lambda>y. map_spmf fst (g y \\<bind> (\\<lambda>s. callee2 s a))) b\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "using bind_nat a"], ["proof (prove)\nusing this:\n  cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s a)) b =\n  cond_bind_spmf_fst X\n   (\\<lambda>y. map_spmf fst (f y \\<bind> (\\<lambda>s. callee1 s a)))\n   b \\<bind>\n  (\\<lambda>x. cond_spmf_fst (f x \\<bind> (\\<lambda>s. callee1 s a)) b)\n  cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s a)) b =\n  cond_bind_spmf_fst X\n   (\\<lambda>y. map_spmf fst (g y \\<bind> (\\<lambda>s. callee2 s a)))\n   b \\<bind>\n  (\\<lambda>x. cond_spmf_fst (g x \\<bind> (\\<lambda>s. callee2 s a)) b)\n  cond_bind_spmf_fst X\n   (\\<lambda>y. map_spmf fst (f y \\<bind> (\\<lambda>s. callee1 s a))) b =\n  cond_bind_spmf_fst X\n   (\\<lambda>y. map_spmf fst (g y \\<bind> (\\<lambda>s. callee2 s a))) b\n  p = X \\<bind> f\n  q = X \\<bind> g\n  ?x \\<in> set_spmf X \\<Longrightarrow> S (f ?x) (g ?x)\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s a)) b)", "by(simp)(rule trace_eq_simcl_bind; auto intro!: sim simp add: bind_UNION)"], ["proof (state)\nthis:\n  trace_eq_simcl S (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s a)) b)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s a)) b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?res \\<in> set_spmf q;\n   (?b, ?s') \\<in> set_spmf (callee2 ?res a)\\<rbrakk>\n  \\<Longrightarrow> trace_eq_simcl S\n                     (cond_spmf_fst (p \\<bind> (\\<lambda>s. callee1 s a))\n                       ?b)\n                     (cond_spmf_fst (q \\<bind> (\\<lambda>s. callee2 s a))\n                       ?b)\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition trace'_eqI_sim_upto:\n  fixes callee1 :: \"('a, 'b, 's1) callee\" and callee2 :: \"('a, 'b, 's2) callee\"\n  assumes start: \"S p q\"\n    and step: \"\\<And>p q a. \\<lbrakk> S p q; a \\<in> A \\<rbrakk> \\<Longrightarrow>\n      bind_spmf p (\\<lambda>s. map_spmf fst (callee1 s a)) = bind_spmf q (\\<lambda>s. map_spmf fst (callee2 s a))\"\n    and sim: \"\\<And>p q a res b s'. \\<lbrakk> S p q; a \\<in> A; res \\<in> set_spmf q; (b, s') \\<in> set_spmf (callee2 res a) \\<rbrakk>\n      \\<Longrightarrow> trace_eq_simcl S (cond_spmf_fst (bind_spmf p (\\<lambda>s. callee1 s a)) b)\n            (cond_spmf_fst (bind_spmf q (\\<lambda>s. callee2 s a)) b)\"\n  shows \"trace_callee_eq callee1 callee2 A p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_callee_eq callee1 callee2 A p q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace_callee_eq callee1 callee2 A p q", "let ?S = \"trace_eq_simcl S\""], ["proof (state)\ngoal (1 subgoal):\n 1. trace_callee_eq callee1 callee2 A p q", "from start"], ["proof (chain)\npicking this:\n  S p q", "have \"?S p q\""], ["proof (prove)\nusing this:\n  S p q\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S p q", "by(rule trace_eq_simcl.base)"], ["proof (state)\nthis:\n  trace_eq_simcl S p q\n\ngoal (1 subgoal):\n 1. trace_callee_eq callee1 callee2 A p q", "then"], ["proof (chain)\npicking this:\n  trace_eq_simcl S p q", "show ?thesis"], ["proof (prove)\nusing this:\n  trace_eq_simcl S p q\n\ngoal (1 subgoal):\n 1. trace_callee_eq callee1 callee2 A p q", "by(rule trace'_eqI_sim)(rule trace_eq_simcl_callee[OF step sim]; assumption)+"], ["proof (state)\nthis:\n  trace_callee_eq callee1 callee2 A p q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_core_eq_simI_upto:\n  fixes core1 :: \"('s_core, 'event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\"\n    and core2 :: \"('s_core', 'event, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\"\n    and S :: \"'s_core spmf \\<Rightarrow> 's_core' spmf \\<Rightarrow> bool\"\n  assumes start: \"S p q\"\n    and step_cpoke: \"\\<And>p q e. \\<lbrakk> S p q; e \\<in> E \\<rbrakk> \\<Longrightarrow> \n      weight_spmf (bind_spmf p (\\<lambda>s. cpoke core1 s e)) = weight_spmf (bind_spmf q (\\<lambda>s. cpoke core2 s e))\"\n    and sim_cpoke: \"\\<And>p q e. \\<lbrakk> S p q; e \\<in> E \\<rbrakk> \\<Longrightarrow> \n      trace_eq_simcl S (mk_lossless (bind_spmf p (\\<lambda>s. cpoke core1 s e))) (mk_lossless (bind_spmf q (\\<lambda>s. cpoke core2 s e)))\"\n    and step_cfunc_adv: \"\\<And>p q ia. \\<lbrakk> S p q; ia \\<in> IA \\<rbrakk> \\<Longrightarrow> \n      bind_spmf p (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ia)) = bind_spmf q (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\"\n    and sim_cfunc_adv: \"\\<And>p q ia s1 s2 s1' s2' oa. \\<lbrakk> S p q; ia \\<in> IA; \n      s1 \\<in> set_spmf p; s2 \\<in> set_spmf q; (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia); (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia) \\<rbrakk>\n      \\<Longrightarrow> trace_eq_simcl S (cond_spmf_fst (bind_spmf p (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa) (cond_spmf_fst (bind_spmf q (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa)\"\n    and step_cfunc_usr: \"\\<And>p q iu. \\<lbrakk> S p q; iu \\<in> IU \\<rbrakk> \\<Longrightarrow> \n      bind_spmf p (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 iu)) = bind_spmf q (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\"\n    and sim_cfunc_usr: \"\\<And>p q iu s1 s2 s1' s2' ou. \\<lbrakk> S p q; iu \\<in> IU; \n      s1 \\<in> set_spmf p; s2 \\<in> set_spmf q; (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu); (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu) \\<rbrakk>\n      \\<Longrightarrow> trace_eq_simcl S (cond_spmf_fst (bind_spmf p (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou) (cond_spmf_fst (bind_spmf q (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou)\"\n  shows \"trace_core_eq core1 core2 E IA IU p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_core_eq core1 core2 E IA IU p q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trace_core_eq core1 core2 E IA IU p q", "let ?S = \"trace_eq_simcl S\""], ["proof (state)\ngoal (1 subgoal):\n 1. trace_core_eq core1 core2 E IA IU p q", "from start"], ["proof (chain)\npicking this:\n  S p q", "have \"?S p q\""], ["proof (prove)\nusing this:\n  S p q\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S p q", "by(rule trace_eq_simcl.base)"], ["proof (state)\nthis:\n  trace_eq_simcl S p q\n\ngoal (1 subgoal):\n 1. trace_core_eq core1 core2 E IA IU p q", "then"], ["proof (chain)\npicking this:\n  trace_eq_simcl S p q", "show ?thesis"], ["proof (prove)\nusing this:\n  trace_eq_simcl S p q\n\ngoal (1 subgoal):\n 1. trace_core_eq core1 core2 E IA IU p q", "proof(rule trace_core_eq_simI, goal_cases Step_cpoke Sim_cpoke Step_cfunc_adv Sim_cfunc_adv Step_cfunc_usr Sim_cfunc_usr)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>p q e.\n       \\<lbrakk>trace_eq_simcl S p q; e \\<in> E\\<rbrakk>\n       \\<Longrightarrow> weight_spmf\n                          (p \\<bind> (\\<lambda>s. cpoke core1 s e)) =\n                         weight_spmf\n                          (q \\<bind> (\\<lambda>s. cpoke core2 s e))\n 2. \\<And>p q e.\n       \\<lbrakk>trace_eq_simcl S p q; e \\<in> E\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (mk_lossless\n                            (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n                          (mk_lossless\n                            (q \\<bind> (\\<lambda>s. cpoke core2 s e)))\n 3. \\<And>p q ia.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_adv core1 s1 ia)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\n 4. \\<And>p q ia s1 s2 s1' s2' oa.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)\n 5. \\<And>p q iu.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_usr core1 s1 iu)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\n 6. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "{"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>p q e.\n       \\<lbrakk>trace_eq_simcl S p q; e \\<in> E\\<rbrakk>\n       \\<Longrightarrow> weight_spmf\n                          (p \\<bind> (\\<lambda>s. cpoke core1 s e)) =\n                         weight_spmf\n                          (q \\<bind> (\\<lambda>s. cpoke core2 s e))\n 2. \\<And>p q e.\n       \\<lbrakk>trace_eq_simcl S p q; e \\<in> E\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (mk_lossless\n                            (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n                          (mk_lossless\n                            (q \\<bind> (\\<lambda>s. cpoke core2 s e)))\n 3. \\<And>p q ia.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_adv core1 s1 ia)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\n 4. \\<And>p q ia s1 s2 s1' s2' oa.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)\n 5. \\<And>p q iu.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_usr core1 s1 iu)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\n 6. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "case (Step_cpoke p q e)"], ["proof (state)\nthis:\n  trace_eq_simcl S p q\n  e \\<in> E\n\ngoal (6 subgoals):\n 1. \\<And>p q e.\n       \\<lbrakk>trace_eq_simcl S p q; e \\<in> E\\<rbrakk>\n       \\<Longrightarrow> weight_spmf\n                          (p \\<bind> (\\<lambda>s. cpoke core1 s e)) =\n                         weight_spmf\n                          (q \\<bind> (\\<lambda>s. cpoke core2 s e))\n 2. \\<And>p q e.\n       \\<lbrakk>trace_eq_simcl S p q; e \\<in> E\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (mk_lossless\n                            (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n                          (mk_lossless\n                            (q \\<bind> (\\<lambda>s. cpoke core2 s e)))\n 3. \\<And>p q ia.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_adv core1 s1 ia)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\n 4. \\<And>p q ia s1 s2 s1' s2' oa.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)\n 5. \\<And>p q iu.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_usr core1 s1 iu)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\n 6. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "then"], ["proof (chain)\npicking this:\n  trace_eq_simcl S p q\n  e \\<in> E", "show ?case"], ["proof (prove)\nusing this:\n  trace_eq_simcl S p q\n  e \\<in> E\n\ngoal (1 subgoal):\n 1. weight_spmf (p \\<bind> (\\<lambda>s. cpoke core1 s e)) =\n    weight_spmf (q \\<bind> (\\<lambda>s. cpoke core2 s e))", "using step_cpoke"], ["proof (prove)\nusing this:\n  trace_eq_simcl S p q\n  e \\<in> E\n  \\<lbrakk>S ?p ?q; ?e \\<in> E\\<rbrakk>\n  \\<Longrightarrow> weight_spmf\n                     (?p \\<bind> (\\<lambda>s. cpoke core1 s ?e)) =\n                    weight_spmf (?q \\<bind> (\\<lambda>s. cpoke core2 s ?e))\n\ngoal (1 subgoal):\n 1. weight_spmf (p \\<bind> (\\<lambda>s. cpoke core1 s e)) =\n    weight_spmf (q \\<bind> (\\<lambda>s. cpoke core2 s e))", "by cases(auto simp add: weight_bind_spmf o_def intro!: Bochner_Integration.integral_cong_AE)"], ["proof (state)\nthis:\n  weight_spmf (p \\<bind> (\\<lambda>s. cpoke core1 s e)) =\n  weight_spmf (q \\<bind> (\\<lambda>s. cpoke core2 s e))\n\ngoal (5 subgoals):\n 1. \\<And>p q e.\n       \\<lbrakk>trace_eq_simcl S p q; e \\<in> E\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (mk_lossless\n                            (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n                          (mk_lossless\n                            (q \\<bind> (\\<lambda>s. cpoke core2 s e)))\n 2. \\<And>p q ia.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_adv core1 s1 ia)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\n 3. \\<And>p q ia s1 s2 s1' s2' oa.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)\n 4. \\<And>p q iu.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_usr core1 s1 iu)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\n 5. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>trace_eq_simcl S ?pa2 ?qa2; ?e2 \\<in> E\\<rbrakk>\n  \\<Longrightarrow> weight_spmf\n                     (?pa2 \\<bind> (\\<lambda>s. cpoke core1 s ?e2)) =\n                    weight_spmf\n                     (?qa2 \\<bind> (\\<lambda>s. cpoke core2 s ?e2))\n\ngoal (5 subgoals):\n 1. \\<And>p q e.\n       \\<lbrakk>trace_eq_simcl S p q; e \\<in> E\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (mk_lossless\n                            (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n                          (mk_lossless\n                            (q \\<bind> (\\<lambda>s. cpoke core2 s e)))\n 2. \\<And>p q ia.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_adv core1 s1 ia)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\n 3. \\<And>p q ia s1 s2 s1' s2' oa.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)\n 4. \\<And>p q iu.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_usr core1 s1 iu)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\n 5. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "note eq = this"], ["proof (state)\nthis:\n  \\<lbrakk>trace_eq_simcl S ?pa2 ?qa2; ?e2 \\<in> E\\<rbrakk>\n  \\<Longrightarrow> weight_spmf\n                     (?pa2 \\<bind> (\\<lambda>s. cpoke core1 s ?e2)) =\n                    weight_spmf\n                     (?qa2 \\<bind> (\\<lambda>s. cpoke core2 s ?e2))\n\ngoal (5 subgoals):\n 1. \\<And>p q e.\n       \\<lbrakk>trace_eq_simcl S p q; e \\<in> E\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (mk_lossless\n                            (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n                          (mk_lossless\n                            (q \\<bind> (\\<lambda>s. cpoke core2 s e)))\n 2. \\<And>p q ia.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_adv core1 s1 ia)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\n 3. \\<And>p q ia s1 s2 s1' s2' oa.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)\n 4. \\<And>p q iu.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_usr core1 s1 iu)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\n 5. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "case (Sim_cpoke p q e)"], ["proof (state)\nthis:\n  trace_eq_simcl S p q\n  e \\<in> E\n\ngoal (5 subgoals):\n 1. \\<And>p q e.\n       \\<lbrakk>trace_eq_simcl S p q; e \\<in> E\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (mk_lossless\n                            (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n                          (mk_lossless\n                            (q \\<bind> (\\<lambda>s. cpoke core2 s e)))\n 2. \\<And>p q ia.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_adv core1 s1 ia)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\n 3. \\<And>p q ia s1 s2 s1' s2' oa.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)\n 4. \\<And>p q iu.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_usr core1 s1 iu)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\n 5. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "then"], ["proof (chain)\npicking this:\n  trace_eq_simcl S p q\n  e \\<in> E", "show ?case"], ["proof (prove)\nusing this:\n  trace_eq_simcl S p q\n  e \\<in> E\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S (mk_lossless (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n     (mk_lossless (q \\<bind> (\\<lambda>s. cpoke core2 s e)))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>e \\<in> E; S p q\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (mk_lossless\n                         (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n                       (mk_lossless\n                         (q \\<bind> (\\<lambda>s. cpoke core2 s e)))\n 2. \\<And>p f g.\n       \\<lbrakk>e \\<in> E; p = p \\<bind> f; q = p \\<bind> g;\n        \\<And>x. x \\<in> set_spmf p \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (mk_lossless\n                            (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n                          (mk_lossless\n                            (q \\<bind> (\\<lambda>s. cpoke core2 s e)))", "case base"], ["proof (state)\nthis:\n  S p q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>e \\<in> E; S p q\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (mk_lossless\n                         (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n                       (mk_lossless\n                         (q \\<bind> (\\<lambda>s. cpoke core2 s e)))\n 2. \\<And>p f g.\n       \\<lbrakk>e \\<in> E; p = p \\<bind> f; q = p \\<bind> g;\n        \\<And>x. x \\<in> set_spmf p \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (mk_lossless\n                            (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n                          (mk_lossless\n                            (q \\<bind> (\\<lambda>s. cpoke core2 s e)))", "then"], ["proof (chain)\npicking this:\n  S p q", "show ?thesis"], ["proof (prove)\nusing this:\n  S p q\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S (mk_lossless (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n     (mk_lossless (q \\<bind> (\\<lambda>s. cpoke core2 s e)))", "using Sim_cpoke(2)"], ["proof (prove)\nusing this:\n  S p q\n  e \\<in> E\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S (mk_lossless (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n     (mk_lossless (q \\<bind> (\\<lambda>s. cpoke core2 s e)))", "by(rule sim_cpoke)"], ["proof (state)\nthis:\n  trace_eq_simcl S (mk_lossless (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n   (mk_lossless (q \\<bind> (\\<lambda>s. cpoke core2 s e)))\n\ngoal (1 subgoal):\n 1. \\<And>p f g.\n       \\<lbrakk>e \\<in> E; p = p \\<bind> f; q = p \\<bind> g;\n        \\<And>x. x \\<in> set_spmf p \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (mk_lossless\n                            (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n                          (mk_lossless\n                            (q \\<bind> (\\<lambda>s. cpoke core2 s e)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p f g.\n       \\<lbrakk>e \\<in> E; p = p \\<bind> f; q = p \\<bind> g;\n        \\<And>x. x \\<in> set_spmf p \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (mk_lossless\n                            (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n                          (mk_lossless\n                            (q \\<bind> (\\<lambda>s. cpoke core2 s e)))", "case (bind_nat X f g)"], ["proof (state)\nthis:\n  p = X \\<bind> f\n  q = X \\<bind> g\n  ?x \\<in> set_spmf X \\<Longrightarrow> S (f ?x) (g ?x)\n\ngoal (1 subgoal):\n 1. \\<And>p f g.\n       \\<lbrakk>e \\<in> E; p = p \\<bind> f; q = p \\<bind> g;\n        \\<And>x. x \\<in> set_spmf p \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (mk_lossless\n                            (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n                          (mk_lossless\n                            (q \\<bind> (\\<lambda>s. cpoke core2 s e)))", "then"], ["proof (chain)\npicking this:\n  p = X \\<bind> f\n  q = X \\<bind> g\n  ?x \\<in> set_spmf X \\<Longrightarrow> S (f ?x) (g ?x)", "have \"cond_bind_spmf X (\\<lambda>y. f y \\<bind> (\\<lambda>s. cpoke core1 s e)) UNIV = cond_bind_spmf X (\\<lambda>y. g y \\<bind> (\\<lambda>s. cpoke core2 s e)) UNIV\""], ["proof (prove)\nusing this:\n  p = X \\<bind> f\n  q = X \\<bind> g\n  ?x \\<in> set_spmf X \\<Longrightarrow> S (f ?x) (g ?x)\n\ngoal (1 subgoal):\n 1. cond_bind_spmf X (\\<lambda>y. f y \\<bind> (\\<lambda>s. cpoke core1 s e))\n     UNIV =\n    cond_bind_spmf X (\\<lambda>y. g y \\<bind> (\\<lambda>s. cpoke core2 s e))\n     UNIV", "using eq[OF Sim_cpoke] step_cpoke Sim_cpoke"], ["proof (prove)\nusing this:\n  p = X \\<bind> f\n  q = X \\<bind> g\n  ?x \\<in> set_spmf X \\<Longrightarrow> S (f ?x) (g ?x)\n  weight_spmf (p \\<bind> (\\<lambda>s. cpoke core1 s e)) =\n  weight_spmf (q \\<bind> (\\<lambda>s. cpoke core2 s e))\n  \\<lbrakk>S ?p ?q; ?e \\<in> E\\<rbrakk>\n  \\<Longrightarrow> weight_spmf\n                     (?p \\<bind> (\\<lambda>s. cpoke core1 s ?e)) =\n                    weight_spmf (?q \\<bind> (\\<lambda>s. cpoke core2 s ?e))\n  trace_eq_simcl S p q\n  e \\<in> E\n\ngoal (1 subgoal):\n 1. cond_bind_spmf X (\\<lambda>y. f y \\<bind> (\\<lambda>s. cpoke core1 s e))\n     UNIV =\n    cond_bind_spmf X (\\<lambda>y. g y \\<bind> (\\<lambda>s. cpoke core2 s e))\n     UNIV", "by(intro spmf_eqI)(simp add: weight_spmf_def measure_spmf_zero_iff bind_UNION spmf_eq_0_set_spmf)"], ["proof (state)\nthis:\n  cond_bind_spmf X (\\<lambda>y. f y \\<bind> (\\<lambda>s. cpoke core1 s e))\n   UNIV =\n  cond_bind_spmf X (\\<lambda>y. g y \\<bind> (\\<lambda>s. cpoke core2 s e))\n   UNIV\n\ngoal (1 subgoal):\n 1. \\<And>p f g.\n       \\<lbrakk>e \\<in> E; p = p \\<bind> f; q = p \\<bind> g;\n        \\<And>x. x \\<in> set_spmf p \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (mk_lossless\n                            (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n                          (mk_lossless\n                            (q \\<bind> (\\<lambda>s. cpoke core2 s e)))", "then"], ["proof (chain)\npicking this:\n  cond_bind_spmf X (\\<lambda>y. f y \\<bind> (\\<lambda>s. cpoke core1 s e))\n   UNIV =\n  cond_bind_spmf X (\\<lambda>y. g y \\<bind> (\\<lambda>s. cpoke core2 s e))\n   UNIV", "show ?thesis"], ["proof (prove)\nusing this:\n  cond_bind_spmf X (\\<lambda>y. f y \\<bind> (\\<lambda>s. cpoke core1 s e))\n   UNIV =\n  cond_bind_spmf X (\\<lambda>y. g y \\<bind> (\\<lambda>s. cpoke core2 s e))\n   UNIV\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S (mk_lossless (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n     (mk_lossless (q \\<bind> (\\<lambda>s. cpoke core2 s e)))", "using bind_nat Sim_cpoke sim_cpoke"], ["proof (prove)\nusing this:\n  cond_bind_spmf X (\\<lambda>y. f y \\<bind> (\\<lambda>s. cpoke core1 s e))\n   UNIV =\n  cond_bind_spmf X (\\<lambda>y. g y \\<bind> (\\<lambda>s. cpoke core2 s e))\n   UNIV\n  p = X \\<bind> f\n  q = X \\<bind> g\n  ?x \\<in> set_spmf X \\<Longrightarrow> S (f ?x) (g ?x)\n  trace_eq_simcl S p q\n  e \\<in> E\n  \\<lbrakk>S ?p ?q; ?e \\<in> E\\<rbrakk>\n  \\<Longrightarrow> trace_eq_simcl S\n                     (mk_lossless\n                       (?p \\<bind> (\\<lambda>s. cpoke core1 s ?e)))\n                     (mk_lossless\n                       (?q \\<bind> (\\<lambda>s. cpoke core2 s ?e)))\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S (mk_lossless (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n     (mk_lossless (q \\<bind> (\\<lambda>s. cpoke core2 s e)))", "by(auto simp add: cond_bind_spmf cond_spmf_UNIV[symmetric] simp del: cond_spmf_UNIV intro: trace_eq_simcl_bind)"], ["proof (state)\nthis:\n  trace_eq_simcl S (mk_lossless (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n   (mk_lossless (q \\<bind> (\\<lambda>s. cpoke core2 s e)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trace_eq_simcl S (mk_lossless (p \\<bind> (\\<lambda>s. cpoke core1 s e)))\n   (mk_lossless (q \\<bind> (\\<lambda>s. cpoke core2 s e)))\n\ngoal (4 subgoals):\n 1. \\<And>p q ia.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_adv core1 s1 ia)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\n 2. \\<And>p q ia s1 s2 s1' s2' oa.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)\n 3. \\<And>p q iu.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_usr core1 s1 iu)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\n 4. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>p q ia.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_adv core1 s1 ia)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\n 2. \\<And>p q ia s1 s2 s1' s2' oa.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)\n 3. \\<And>p q iu.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_usr core1 s1 iu)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\n 4. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "{"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>p q ia.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_adv core1 s1 ia)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\n 2. \\<And>p q ia s1 s2 s1' s2' oa.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)\n 3. \\<And>p q iu.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_usr core1 s1 iu)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\n 4. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "case (Step_cfunc_adv p q ia)"], ["proof (state)\nthis:\n  trace_eq_simcl S p q\n  ia \\<in> IA\n\ngoal (4 subgoals):\n 1. \\<And>p q ia.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_adv core1 s1 ia)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\n 2. \\<And>p q ia s1 s2 s1' s2' oa.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)\n 3. \\<And>p q iu.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_usr core1 s1 iu)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\n 4. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "then"], ["proof (chain)\npicking this:\n  trace_eq_simcl S p q\n  ia \\<in> IA", "show ?case"], ["proof (prove)\nusing this:\n  trace_eq_simcl S p q\n  ia \\<in> IA\n\ngoal (1 subgoal):\n 1. p \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ia)) =\n    q \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))", "using step_cfunc_adv"], ["proof (prove)\nusing this:\n  trace_eq_simcl S p q\n  ia \\<in> IA\n  \\<lbrakk>S ?p ?q; ?ia \\<in> IA\\<rbrakk>\n  \\<Longrightarrow> ?p \\<bind>\n                    (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ?ia)) =\n                    ?q \\<bind>\n                    (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ?ia))\n\ngoal (1 subgoal):\n 1. p \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ia)) =\n    q \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))", "by cases(auto intro!: bind_spmf_cong)"], ["proof (state)\nthis:\n  p \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ia)) =\n  q \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\n\ngoal (3 subgoals):\n 1. \\<And>p q ia s1 s2 s1' s2' oa.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)\n 2. \\<And>p q iu.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_usr core1 s1 iu)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\n 3. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>trace_eq_simcl S ?pa2 ?qa2; ?ia2 \\<in> IA\\<rbrakk>\n  \\<Longrightarrow> ?pa2 \\<bind>\n                    (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ?ia2)) =\n                    ?qa2 \\<bind>\n                    (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ?ia2))\n\ngoal (3 subgoals):\n 1. \\<And>p q ia s1 s2 s1' s2' oa.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)\n 2. \\<And>p q iu.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_usr core1 s1 iu)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\n 3. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "note eq = this"], ["proof (state)\nthis:\n  \\<lbrakk>trace_eq_simcl S ?pa2 ?qa2; ?ia2 \\<in> IA\\<rbrakk>\n  \\<Longrightarrow> ?pa2 \\<bind>\n                    (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ?ia2)) =\n                    ?qa2 \\<bind>\n                    (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ?ia2))\n\ngoal (3 subgoals):\n 1. \\<And>p q ia s1 s2 s1' s2' oa.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)\n 2. \\<And>p q iu.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_usr core1 s1 iu)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\n 3. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "case (Sim_cfunc_adv p q ia s1 s2 s1' s2' oa)"], ["proof (state)\nthis:\n  trace_eq_simcl S p q\n  ia \\<in> IA\n  s1 \\<in> set_spmf p\n  s2 \\<in> set_spmf q\n  (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia)\n  (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia)\n\ngoal (3 subgoals):\n 1. \\<And>p q ia s1 s2 s1' s2' oa.\n       \\<lbrakk>trace_eq_simcl S p q; ia \\<in> IA; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)\n 2. \\<And>p q iu.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_usr core1 s1 iu)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\n 3. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "then"], ["proof (chain)\npicking this:\n  trace_eq_simcl S p q\n  ia \\<in> IA\n  s1 \\<in> set_spmf p\n  s2 \\<in> set_spmf q\n  (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia)\n  (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia)", "show ?case"], ["proof (prove)\nusing this:\n  trace_eq_simcl S p q\n  ia \\<in> IA\n  s1 \\<in> set_spmf p\n  s2 \\<in> set_spmf q\n  (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia)\n  (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia)\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ia \\<in> IA; s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n     (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia);\n     (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia); S p q\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                         oa)\n                       (cond_spmf_fst\n                         (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                         oa)\n 2. \\<And>p f g.\n       \\<lbrakk>ia \\<in> IA; s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia); p = p \\<bind> f;\n        q = p \\<bind> g;\n        \\<And>x. x \\<in> set_spmf p \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)", "case base"], ["proof (state)\nthis:\n  S p q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ia \\<in> IA; s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n     (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia);\n     (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia); S p q\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                         oa)\n                       (cond_spmf_fst\n                         (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                         oa)\n 2. \\<And>p f g.\n       \\<lbrakk>ia \\<in> IA; s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia); p = p \\<bind> f;\n        q = p \\<bind> g;\n        \\<And>x. x \\<in> set_spmf p \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)", "then"], ["proof (chain)\npicking this:\n  S p q", "show ?thesis"], ["proof (prove)\nusing this:\n  S p q\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa)", "using Sim_cfunc_adv(2-)"], ["proof (prove)\nusing this:\n  S p q\n  ia \\<in> IA\n  s1 \\<in> set_spmf p\n  s2 \\<in> set_spmf q\n  (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia)\n  (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia)\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa)", "by(rule sim_cfunc_adv)"], ["proof (state)\nthis:\n  trace_eq_simcl S\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa)\n\ngoal (1 subgoal):\n 1. \\<And>p f g.\n       \\<lbrakk>ia \\<in> IA; s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia); p = p \\<bind> f;\n        q = p \\<bind> g;\n        \\<And>x. x \\<in> set_spmf p \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p f g.\n       \\<lbrakk>ia \\<in> IA; s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia); p = p \\<bind> f;\n        q = p \\<bind> g;\n        \\<And>x. x \\<in> set_spmf p \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)", "case (bind_nat X f g)"], ["proof (state)\nthis:\n  p = X \\<bind> f\n  q = X \\<bind> g\n  ?x \\<in> set_spmf X \\<Longrightarrow> S (f ?x) (g ?x)\n\ngoal (1 subgoal):\n 1. \\<And>p f g.\n       \\<lbrakk>ia \\<in> IA; s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia); p = p \\<bind> f;\n        q = p \\<bind> g;\n        \\<And>x. x \\<in> set_spmf p \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)", "then"], ["proof (chain)\npicking this:\n  p = X \\<bind> f\n  q = X \\<bind> g\n  ?x \\<in> set_spmf X \\<Longrightarrow> S (f ?x) (g ?x)", "have \"cond_bind_spmf_fst X (\\<lambda>y. map_spmf fst (f y \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))) oa =\n            cond_bind_spmf_fst X (\\<lambda>y. map_spmf fst (g y \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))) oa\""], ["proof (prove)\nusing this:\n  p = X \\<bind> f\n  q = X \\<bind> g\n  ?x \\<in> set_spmf X \\<Longrightarrow> S (f ?x) (g ?x)\n\ngoal (1 subgoal):\n 1. cond_bind_spmf_fst X\n     (\\<lambda>y.\n         map_spmf fst (f y \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)))\n     oa =\n    cond_bind_spmf_fst X\n     (\\<lambda>y.\n         map_spmf fst (g y \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)))\n     oa", "using eq[OF Sim_cfunc_adv(1,2)]"], ["proof (prove)\nusing this:\n  p = X \\<bind> f\n  q = X \\<bind> g\n  ?x \\<in> set_spmf X \\<Longrightarrow> S (f ?x) (g ?x)\n  p \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_adv core1 s1 ia)) =\n  q \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia))\n\ngoal (1 subgoal):\n 1. cond_bind_spmf_fst X\n     (\\<lambda>y.\n         map_spmf fst (f y \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)))\n     oa =\n    cond_bind_spmf_fst X\n     (\\<lambda>y.\n         map_spmf fst (g y \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)))\n     oa", "by(intro spmf_eqI)(fastforce simp add: map_bind_spmf o_def spmf_eq_0_set_spmf dest: step_cfunc_adv[OF _ Sim_cfunc_adv(2)])"], ["proof (state)\nthis:\n  cond_bind_spmf_fst X\n   (\\<lambda>y.\n       map_spmf fst (f y \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)))\n   oa =\n  cond_bind_spmf_fst X\n   (\\<lambda>y.\n       map_spmf fst (g y \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)))\n   oa\n\ngoal (1 subgoal):\n 1. \\<And>p f g.\n       \\<lbrakk>ia \\<in> IA; s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n        (oa, s1') \\<in> set_spmf (cfunc_adv core1 s1 ia);\n        (oa, s2') \\<in> set_spmf (cfunc_adv core2 s2 ia); p = p \\<bind> f;\n        q = p \\<bind> g;\n        \\<And>x. x \\<in> set_spmf p \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)", "then"], ["proof (chain)\npicking this:\n  cond_bind_spmf_fst X\n   (\\<lambda>y.\n       map_spmf fst (f y \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)))\n   oa =\n  cond_bind_spmf_fst X\n   (\\<lambda>y.\n       map_spmf fst (g y \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)))\n   oa", "show ?thesis"], ["proof (prove)\nusing this:\n  cond_bind_spmf_fst X\n   (\\<lambda>y.\n       map_spmf fst (f y \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)))\n   oa =\n  cond_bind_spmf_fst X\n   (\\<lambda>y.\n       map_spmf fst (g y \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)))\n   oa\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa)", "using bind_nat(3-) Sim_cfunc_adv(1-2)"], ["proof (prove)\nusing this:\n  cond_bind_spmf_fst X\n   (\\<lambda>y.\n       map_spmf fst (f y \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)))\n   oa =\n  cond_bind_spmf_fst X\n   (\\<lambda>y.\n       map_spmf fst (g y \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)))\n   oa\n  ?x \\<in> set_spmf X \\<Longrightarrow> S (f ?x) (g ?x)\n  trace_eq_simcl S p q\n  ia \\<in> IA\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa)", "unfolding bind_nat(1,2) bind_spmf_assoc"], ["proof (prove)\nusing this:\n  cond_bind_spmf_fst X\n   (\\<lambda>y.\n       map_spmf fst (f y \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)))\n   oa =\n  cond_bind_spmf_fst X\n   (\\<lambda>y.\n       map_spmf fst (g y \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)))\n   oa\n  ?x \\<in> set_spmf X \\<Longrightarrow> S (f ?x) (g ?x)\n  trace_eq_simcl S (X \\<bind> f) (X \\<bind> g)\n  ia \\<in> IA\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S\n     (cond_spmf_fst\n       (X \\<bind>\n        (\\<lambda>y. f y \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)))\n       oa)\n     (cond_spmf_fst\n       (X \\<bind>\n        (\\<lambda>y. g y \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)))\n       oa)", "apply(subst (1 2) cond_spmf_fst_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cond_bind_spmf_fst X\n              (\\<lambda>y.\n                  map_spmf fst\n                   (f y \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)))\n              oa =\n             cond_bind_spmf_fst X\n              (\\<lambda>y.\n                  map_spmf fst\n                   (g y \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)))\n              oa;\n     \\<And>x. x \\<in> set_spmf X \\<Longrightarrow> S (f x) (g x);\n     trace_eq_simcl S (X \\<bind> f) (X \\<bind> g); ia \\<in> IA\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_bind_spmf_fst X\n                         (map_spmf fst \\<circ>\n                          (\\<lambda>y.\n                              f y \\<bind>\n                              (\\<lambda>s1. cfunc_adv core1 s1 ia)))\n                         oa \\<bind>\n                        (\\<lambda>y.\n                            cond_spmf_fst\n                             (f y \\<bind>\n                              (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                             oa))\n                       (cond_bind_spmf_fst X\n                         (map_spmf fst \\<circ>\n                          (\\<lambda>y.\n                              g y \\<bind>\n                              (\\<lambda>s2. cfunc_adv core2 s2 ia)))\n                         oa \\<bind>\n                        (\\<lambda>y.\n                            cond_spmf_fst\n                             (g y \\<bind>\n                              (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                             oa))", "apply(simp add: o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cond_bind_spmf_fst X\n              (\\<lambda>y.\n                  map_spmf fst\n                   (f y \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)))\n              oa =\n             cond_bind_spmf_fst X\n              (\\<lambda>y.\n                  map_spmf fst\n                   (g y \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)))\n              oa;\n     \\<And>x. x \\<in> set_spmf X \\<Longrightarrow> S (f x) (g x);\n     trace_eq_simcl S (X \\<bind> f) (X \\<bind> g); ia \\<in> IA\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_bind_spmf_fst X\n                         (\\<lambda>x.\n                             map_spmf fst\n                              (g x \\<bind>\n                               (\\<lambda>s2. cfunc_adv core2 s2 ia)))\n                         oa \\<bind>\n                        (\\<lambda>y.\n                            cond_spmf_fst\n                             (f y \\<bind>\n                              (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                             oa))\n                       (cond_bind_spmf_fst X\n                         (\\<lambda>x.\n                             map_spmf fst\n                              (g x \\<bind>\n                               (\\<lambda>s2. cfunc_adv core2 s2 ia)))\n                         oa \\<bind>\n                        (\\<lambda>y.\n                            cond_spmf_fst\n                             (g y \\<bind>\n                              (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                             oa))", "apply(rule trace_eq_simcl_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (f y \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)))\n                 oa =\n                cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (g y \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)))\n                 oa;\n        \\<And>x. x \\<in> set_spmf X \\<Longrightarrow> S (f x) (g x);\n        trace_eq_simcl S (X \\<bind> f) (X \\<bind> g); ia \\<in> IA;\n        x \\<in> set_spmf\n                 (cond_bind_spmf_fst X\n                   (\\<lambda>x.\n                       map_spmf fst\n                        (g x \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)))\n                   oa)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (f x \\<bind>\n                             (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (g x \\<bind>\n                             (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x b xa.\n       \\<lbrakk>cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (f y \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)))\n                 oa =\n                cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (g y \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)))\n                 oa;\n        \\<And>x. x \\<in> set_spmf X \\<Longrightarrow> S (f x) (g x);\n        trace_eq_simcl S (X \\<bind> f) (X \\<bind> g); ia \\<in> IA;\n        x \\<in> set_spmf X; xa \\<in> set_spmf (g x);\n        (oa, b) \\<in> set_spmf (cfunc_adv core2 xa ia)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (f x \\<bind>\n                             (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (g x \\<bind>\n                             (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)", "apply(frule step_cfunc_adv[OF bind_nat(3) Sim_cfunc_adv(2), THEN arg_cong[where f=\"set_spmf\"], THEN equalityD2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x b xa.\n       \\<lbrakk>cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (f y \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)))\n                 oa =\n                cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (g y \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)))\n                 oa;\n        \\<And>x. x \\<in> set_spmf X \\<Longrightarrow> S (f x) (g x);\n        trace_eq_simcl S (X \\<bind> f) (X \\<bind> g); ia \\<in> IA;\n        x \\<in> set_spmf X; xa \\<in> set_spmf (g x);\n        (oa, b) \\<in> set_spmf (cfunc_adv core2 xa ia);\n        set_spmf\n         (g x \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_adv core2 s2 ia)))\n        \\<subseteq> set_spmf\n                     (f x \\<bind>\n                      (\\<lambda>s1.\n                          map_spmf fst (cfunc_adv core1 s1 ia)))\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (f x \\<bind>\n                             (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (g x \\<bind>\n                             (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)", "apply(clarsimp simp add: o_def bind_UNION)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x b xa.\n       \\<lbrakk>cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (f y \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)))\n                 oa =\n                cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (g y \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)))\n                 oa;\n        \\<And>x. x \\<in> set_spmf X \\<Longrightarrow> S (f x) (g x);\n        trace_eq_simcl S (X \\<bind> f) (X \\<bind> g); ia \\<in> IA;\n        x \\<in> set_spmf X; xa \\<in> set_spmf (g x);\n        (oa, b) \\<in> set_spmf (cfunc_adv core2 xa ia);\n        (\\<Union>x\\<in>set_spmf (g x).\n            fst ` set_spmf (cfunc_adv core2 x ia))\n        \\<subseteq> (\\<Union>x\\<in>set_spmf (f x).\n                        fst ` set_spmf (cfunc_adv core1 x ia))\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (f x \\<bind>\n                             (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (g x \\<bind>\n                             (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)", "apply(drule subsetD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x b xa.\n       \\<lbrakk>cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (f y \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)))\n                 oa =\n                cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (g y \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)))\n                 oa;\n        \\<And>x. x \\<in> set_spmf X \\<Longrightarrow> S (f x) (g x);\n        trace_eq_simcl S (X \\<bind> f) (X \\<bind> g); ia \\<in> IA;\n        x \\<in> set_spmf X; xa \\<in> set_spmf (g x);\n        (oa, b) \\<in> set_spmf (cfunc_adv core2 xa ia)\\<rbrakk>\n       \\<Longrightarrow> ?c26 x b xa\n                         \\<in> (\\<Union>x\\<in>set_spmf (g x).\n                                   fst ` set_spmf (cfunc_adv core2 x ia))\n 2. \\<And>x b xa.\n       \\<lbrakk>cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (f y \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)))\n                 oa =\n                cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (g y \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)))\n                 oa;\n        \\<And>x. x \\<in> set_spmf X \\<Longrightarrow> S (f x) (g x);\n        trace_eq_simcl S (X \\<bind> f) (X \\<bind> g); ia \\<in> IA;\n        x \\<in> set_spmf X; xa \\<in> set_spmf (g x);\n        (oa, b) \\<in> set_spmf (cfunc_adv core2 xa ia);\n        ?c26 x b xa\n        \\<in> (\\<Union>x\\<in>set_spmf (f x).\n                  fst ` set_spmf (cfunc_adv core1 x ia))\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (f x \\<bind>\n                             (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (g x \\<bind>\n                             (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x b xa.\n       \\<lbrakk>cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (f y \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)))\n                 oa =\n                cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (g y \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)))\n                 oa;\n        \\<And>x. x \\<in> set_spmf X \\<Longrightarrow> S (f x) (g x);\n        trace_eq_simcl S (X \\<bind> f) (X \\<bind> g); ia \\<in> IA;\n        x \\<in> set_spmf X; xa \\<in> set_spmf (g x);\n        (oa, b) \\<in> set_spmf (cfunc_adv core2 xa ia);\n        fst (oa, b)\n        \\<in> (\\<Union>x\\<in>set_spmf (f x).\n                  fst ` set_spmf (cfunc_adv core1 x ia))\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (f x \\<bind>\n                             (\\<lambda>s1. cfunc_adv core1 s1 ia))\n                            oa)\n                          (cond_spmf_fst\n                            (g x \\<bind>\n                             (\\<lambda>s2. cfunc_adv core2 s2 ia))\n                            oa)", "apply(auto intro: sim_cfunc_adv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  trace_eq_simcl S\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trace_eq_simcl S\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_adv core1 s1 ia)) oa)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_adv core2 s2 ia)) oa)\n\ngoal (2 subgoals):\n 1. \\<And>p q iu.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_usr core1 s1 iu)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\n 2. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p q iu.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_usr core1 s1 iu)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\n 2. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p q iu.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_usr core1 s1 iu)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\n 2. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "case (Step_cfunc_usr p q iu)"], ["proof (state)\nthis:\n  trace_eq_simcl S p q\n  iu \\<in> IU\n\ngoal (2 subgoals):\n 1. \\<And>p q iu.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU\\<rbrakk>\n       \\<Longrightarrow> p \\<bind>\n                         (\\<lambda>s1.\n                             map_spmf fst (cfunc_usr core1 s1 iu)) =\n                         q \\<bind>\n                         (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\n 2. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "then"], ["proof (chain)\npicking this:\n  trace_eq_simcl S p q\n  iu \\<in> IU", "show ?case"], ["proof (prove)\nusing this:\n  trace_eq_simcl S p q\n  iu \\<in> IU\n\ngoal (1 subgoal):\n 1. p \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 iu)) =\n    q \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))", "using step_cfunc_usr"], ["proof (prove)\nusing this:\n  trace_eq_simcl S p q\n  iu \\<in> IU\n  \\<lbrakk>S ?p ?q; ?iu \\<in> IU\\<rbrakk>\n  \\<Longrightarrow> ?p \\<bind>\n                    (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 ?iu)) =\n                    ?q \\<bind>\n                    (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 ?iu))\n\ngoal (1 subgoal):\n 1. p \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 iu)) =\n    q \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))", "by cases(auto intro!: bind_spmf_cong)"], ["proof (state)\nthis:\n  p \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 iu)) =\n  q \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\n\ngoal (1 subgoal):\n 1. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>trace_eq_simcl S ?pa2 ?qa2; ?iu2 \\<in> IU\\<rbrakk>\n  \\<Longrightarrow> ?pa2 \\<bind>\n                    (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 ?iu2)) =\n                    ?qa2 \\<bind>\n                    (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 ?iu2))\n\ngoal (1 subgoal):\n 1. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "note eq = this"], ["proof (state)\nthis:\n  \\<lbrakk>trace_eq_simcl S ?pa2 ?qa2; ?iu2 \\<in> IU\\<rbrakk>\n  \\<Longrightarrow> ?pa2 \\<bind>\n                    (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 ?iu2)) =\n                    ?qa2 \\<bind>\n                    (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 ?iu2))\n\ngoal (1 subgoal):\n 1. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "case (Sim_cfunc_usr p q iu s1 s2 s1' s2' ou)"], ["proof (state)\nthis:\n  trace_eq_simcl S p q\n  iu \\<in> IU\n  s1 \\<in> set_spmf p\n  s2 \\<in> set_spmf q\n  (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu)\n  (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\n\ngoal (1 subgoal):\n 1. \\<And>p q iu s1 s2 s1' s2' ou.\n       \\<lbrakk>trace_eq_simcl S p q; iu \\<in> IU; s1 \\<in> set_spmf p;\n        s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "then"], ["proof (chain)\npicking this:\n  trace_eq_simcl S p q\n  iu \\<in> IU\n  s1 \\<in> set_spmf p\n  s2 \\<in> set_spmf q\n  (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu)\n  (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)", "show ?case"], ["proof (prove)\nusing this:\n  trace_eq_simcl S p q\n  iu \\<in> IU\n  s1 \\<in> set_spmf p\n  s2 \\<in> set_spmf q\n  (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu)\n  (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>iu \\<in> IU; s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n     (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n     (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu); S p q\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                         ou)\n                       (cond_spmf_fst\n                         (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                         ou)\n 2. \\<And>p f g.\n       \\<lbrakk>iu \\<in> IU; s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu); p = p \\<bind> f;\n        q = p \\<bind> g;\n        \\<And>x. x \\<in> set_spmf p \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "case base"], ["proof (state)\nthis:\n  S p q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>iu \\<in> IU; s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n     (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n     (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu); S p q\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_spmf_fst\n                         (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                         ou)\n                       (cond_spmf_fst\n                         (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                         ou)\n 2. \\<And>p f g.\n       \\<lbrakk>iu \\<in> IU; s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu); p = p \\<bind> f;\n        q = p \\<bind> g;\n        \\<And>x. x \\<in> set_spmf p \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "then"], ["proof (chain)\npicking this:\n  S p q", "show ?thesis"], ["proof (prove)\nusing this:\n  S p q\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou)", "using Sim_cfunc_usr(2-)"], ["proof (prove)\nusing this:\n  S p q\n  iu \\<in> IU\n  s1 \\<in> set_spmf p\n  s2 \\<in> set_spmf q\n  (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu)\n  (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu)\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou)", "by(rule sim_cfunc_usr)"], ["proof (state)\nthis:\n  trace_eq_simcl S\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou)\n\ngoal (1 subgoal):\n 1. \\<And>p f g.\n       \\<lbrakk>iu \\<in> IU; s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu); p = p \\<bind> f;\n        q = p \\<bind> g;\n        \\<And>x. x \\<in> set_spmf p \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p f g.\n       \\<lbrakk>iu \\<in> IU; s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu); p = p \\<bind> f;\n        q = p \\<bind> g;\n        \\<And>x. x \\<in> set_spmf p \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "case (bind_nat X f g)"], ["proof (state)\nthis:\n  p = X \\<bind> f\n  q = X \\<bind> g\n  ?x \\<in> set_spmf X \\<Longrightarrow> S (f ?x) (g ?x)\n\ngoal (1 subgoal):\n 1. \\<And>p f g.\n       \\<lbrakk>iu \\<in> IU; s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu); p = p \\<bind> f;\n        q = p \\<bind> g;\n        \\<And>x. x \\<in> set_spmf p \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "then"], ["proof (chain)\npicking this:\n  p = X \\<bind> f\n  q = X \\<bind> g\n  ?x \\<in> set_spmf X \\<Longrightarrow> S (f ?x) (g ?x)", "have \"cond_bind_spmf_fst X (\\<lambda>y. map_spmf fst (f y \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))) ou =\n            cond_bind_spmf_fst X (\\<lambda>y. map_spmf fst (g y \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))) ou\""], ["proof (prove)\nusing this:\n  p = X \\<bind> f\n  q = X \\<bind> g\n  ?x \\<in> set_spmf X \\<Longrightarrow> S (f ?x) (g ?x)\n\ngoal (1 subgoal):\n 1. cond_bind_spmf_fst X\n     (\\<lambda>y.\n         map_spmf fst (f y \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)))\n     ou =\n    cond_bind_spmf_fst X\n     (\\<lambda>y.\n         map_spmf fst (g y \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)))\n     ou", "using eq[OF Sim_cfunc_usr(1,2)]"], ["proof (prove)\nusing this:\n  p = X \\<bind> f\n  q = X \\<bind> g\n  ?x \\<in> set_spmf X \\<Longrightarrow> S (f ?x) (g ?x)\n  p \\<bind> (\\<lambda>s1. map_spmf fst (cfunc_usr core1 s1 iu)) =\n  q \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu))\n\ngoal (1 subgoal):\n 1. cond_bind_spmf_fst X\n     (\\<lambda>y.\n         map_spmf fst (f y \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)))\n     ou =\n    cond_bind_spmf_fst X\n     (\\<lambda>y.\n         map_spmf fst (g y \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)))\n     ou", "by(intro spmf_eqI)(fastforce simp add: map_bind_spmf o_def spmf_eq_0_set_spmf dest: step_cfunc_usr[OF _ Sim_cfunc_usr(2)])"], ["proof (state)\nthis:\n  cond_bind_spmf_fst X\n   (\\<lambda>y.\n       map_spmf fst (f y \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)))\n   ou =\n  cond_bind_spmf_fst X\n   (\\<lambda>y.\n       map_spmf fst (g y \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)))\n   ou\n\ngoal (1 subgoal):\n 1. \\<And>p f g.\n       \\<lbrakk>iu \\<in> IU; s1 \\<in> set_spmf p; s2 \\<in> set_spmf q;\n        (ou, s1') \\<in> set_spmf (cfunc_usr core1 s1 iu);\n        (ou, s2') \\<in> set_spmf (cfunc_usr core2 s2 iu); p = p \\<bind> f;\n        q = p \\<bind> g;\n        \\<And>x. x \\<in> set_spmf p \\<Longrightarrow> S (f x) (g x)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "then"], ["proof (chain)\npicking this:\n  cond_bind_spmf_fst X\n   (\\<lambda>y.\n       map_spmf fst (f y \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)))\n   ou =\n  cond_bind_spmf_fst X\n   (\\<lambda>y.\n       map_spmf fst (g y \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)))\n   ou", "show ?thesis"], ["proof (prove)\nusing this:\n  cond_bind_spmf_fst X\n   (\\<lambda>y.\n       map_spmf fst (f y \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)))\n   ou =\n  cond_bind_spmf_fst X\n   (\\<lambda>y.\n       map_spmf fst (g y \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)))\n   ou\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou)", "using bind_nat(3-) Sim_cfunc_usr(1-2)"], ["proof (prove)\nusing this:\n  cond_bind_spmf_fst X\n   (\\<lambda>y.\n       map_spmf fst (f y \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)))\n   ou =\n  cond_bind_spmf_fst X\n   (\\<lambda>y.\n       map_spmf fst (g y \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)))\n   ou\n  ?x \\<in> set_spmf X \\<Longrightarrow> S (f ?x) (g ?x)\n  trace_eq_simcl S p q\n  iu \\<in> IU\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S\n     (cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou)\n     (cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou)", "unfolding bind_nat(1,2) bind_spmf_assoc"], ["proof (prove)\nusing this:\n  cond_bind_spmf_fst X\n   (\\<lambda>y.\n       map_spmf fst (f y \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)))\n   ou =\n  cond_bind_spmf_fst X\n   (\\<lambda>y.\n       map_spmf fst (g y \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)))\n   ou\n  ?x \\<in> set_spmf X \\<Longrightarrow> S (f ?x) (g ?x)\n  trace_eq_simcl S (X \\<bind> f) (X \\<bind> g)\n  iu \\<in> IU\n\ngoal (1 subgoal):\n 1. trace_eq_simcl S\n     (cond_spmf_fst\n       (X \\<bind>\n        (\\<lambda>y. f y \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)))\n       ou)\n     (cond_spmf_fst\n       (X \\<bind>\n        (\\<lambda>y. g y \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)))\n       ou)", "apply(subst (1 2) cond_spmf_fst_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cond_bind_spmf_fst X\n              (\\<lambda>y.\n                  map_spmf fst\n                   (f y \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)))\n              ou =\n             cond_bind_spmf_fst X\n              (\\<lambda>y.\n                  map_spmf fst\n                   (g y \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)))\n              ou;\n     \\<And>x. x \\<in> set_spmf X \\<Longrightarrow> S (f x) (g x);\n     trace_eq_simcl S (X \\<bind> f) (X \\<bind> g); iu \\<in> IU\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_bind_spmf_fst X\n                         (map_spmf fst \\<circ>\n                          (\\<lambda>y.\n                              f y \\<bind>\n                              (\\<lambda>s1. cfunc_usr core1 s1 iu)))\n                         ou \\<bind>\n                        (\\<lambda>y.\n                            cond_spmf_fst\n                             (f y \\<bind>\n                              (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                             ou))\n                       (cond_bind_spmf_fst X\n                         (map_spmf fst \\<circ>\n                          (\\<lambda>y.\n                              g y \\<bind>\n                              (\\<lambda>s2. cfunc_usr core2 s2 iu)))\n                         ou \\<bind>\n                        (\\<lambda>y.\n                            cond_spmf_fst\n                             (g y \\<bind>\n                              (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                             ou))", "apply(simp add: o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cond_bind_spmf_fst X\n              (\\<lambda>y.\n                  map_spmf fst\n                   (f y \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)))\n              ou =\n             cond_bind_spmf_fst X\n              (\\<lambda>y.\n                  map_spmf fst\n                   (g y \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)))\n              ou;\n     \\<And>x. x \\<in> set_spmf X \\<Longrightarrow> S (f x) (g x);\n     trace_eq_simcl S (X \\<bind> f) (X \\<bind> g); iu \\<in> IU\\<rbrakk>\n    \\<Longrightarrow> trace_eq_simcl S\n                       (cond_bind_spmf_fst X\n                         (\\<lambda>x.\n                             map_spmf fst\n                              (g x \\<bind>\n                               (\\<lambda>s2. cfunc_usr core2 s2 iu)))\n                         ou \\<bind>\n                        (\\<lambda>y.\n                            cond_spmf_fst\n                             (f y \\<bind>\n                              (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                             ou))\n                       (cond_bind_spmf_fst X\n                         (\\<lambda>x.\n                             map_spmf fst\n                              (g x \\<bind>\n                               (\\<lambda>s2. cfunc_usr core2 s2 iu)))\n                         ou \\<bind>\n                        (\\<lambda>y.\n                            cond_spmf_fst\n                             (g y \\<bind>\n                              (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                             ou))", "apply(rule trace_eq_simcl_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (f y \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)))\n                 ou =\n                cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (g y \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)))\n                 ou;\n        \\<And>x. x \\<in> set_spmf X \\<Longrightarrow> S (f x) (g x);\n        trace_eq_simcl S (X \\<bind> f) (X \\<bind> g); iu \\<in> IU;\n        x \\<in> set_spmf\n                 (cond_bind_spmf_fst X\n                   (\\<lambda>x.\n                       map_spmf fst\n                        (g x \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)))\n                   ou)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (f x \\<bind>\n                             (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (g x \\<bind>\n                             (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x b xa.\n       \\<lbrakk>cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (f y \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)))\n                 ou =\n                cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (g y \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)))\n                 ou;\n        \\<And>x. x \\<in> set_spmf X \\<Longrightarrow> S (f x) (g x);\n        trace_eq_simcl S (X \\<bind> f) (X \\<bind> g); iu \\<in> IU;\n        x \\<in> set_spmf X; xa \\<in> set_spmf (g x);\n        (ou, b) \\<in> set_spmf (cfunc_usr core2 xa iu)\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (f x \\<bind>\n                             (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (g x \\<bind>\n                             (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "apply(frule step_cfunc_usr[OF bind_nat(3) Sim_cfunc_usr(2), THEN arg_cong[where f=\"set_spmf\"], THEN equalityD2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x b xa.\n       \\<lbrakk>cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (f y \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)))\n                 ou =\n                cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (g y \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)))\n                 ou;\n        \\<And>x. x \\<in> set_spmf X \\<Longrightarrow> S (f x) (g x);\n        trace_eq_simcl S (X \\<bind> f) (X \\<bind> g); iu \\<in> IU;\n        x \\<in> set_spmf X; xa \\<in> set_spmf (g x);\n        (ou, b) \\<in> set_spmf (cfunc_usr core2 xa iu);\n        set_spmf\n         (g x \\<bind> (\\<lambda>s2. map_spmf fst (cfunc_usr core2 s2 iu)))\n        \\<subseteq> set_spmf\n                     (f x \\<bind>\n                      (\\<lambda>s1.\n                          map_spmf fst (cfunc_usr core1 s1 iu)))\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (f x \\<bind>\n                             (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (g x \\<bind>\n                             (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "apply(clarsimp simp add: o_def bind_UNION)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x b xa.\n       \\<lbrakk>cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (f y \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)))\n                 ou =\n                cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (g y \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)))\n                 ou;\n        \\<And>x. x \\<in> set_spmf X \\<Longrightarrow> S (f x) (g x);\n        trace_eq_simcl S (X \\<bind> f) (X \\<bind> g); iu \\<in> IU;\n        x \\<in> set_spmf X; xa \\<in> set_spmf (g x);\n        (ou, b) \\<in> set_spmf (cfunc_usr core2 xa iu);\n        (\\<Union>x\\<in>set_spmf (g x).\n            fst ` set_spmf (cfunc_usr core2 x iu))\n        \\<subseteq> (\\<Union>x\\<in>set_spmf (f x).\n                        fst ` set_spmf (cfunc_usr core1 x iu))\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (f x \\<bind>\n                             (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (g x \\<bind>\n                             (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "apply(drule subsetD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x b xa.\n       \\<lbrakk>cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (f y \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)))\n                 ou =\n                cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (g y \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)))\n                 ou;\n        \\<And>x. x \\<in> set_spmf X \\<Longrightarrow> S (f x) (g x);\n        trace_eq_simcl S (X \\<bind> f) (X \\<bind> g); iu \\<in> IU;\n        x \\<in> set_spmf X; xa \\<in> set_spmf (g x);\n        (ou, b) \\<in> set_spmf (cfunc_usr core2 xa iu)\\<rbrakk>\n       \\<Longrightarrow> ?c26 x b xa\n                         \\<in> (\\<Union>x\\<in>set_spmf (g x).\n                                   fst ` set_spmf (cfunc_usr core2 x iu))\n 2. \\<And>x b xa.\n       \\<lbrakk>cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (f y \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)))\n                 ou =\n                cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (g y \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)))\n                 ou;\n        \\<And>x. x \\<in> set_spmf X \\<Longrightarrow> S (f x) (g x);\n        trace_eq_simcl S (X \\<bind> f) (X \\<bind> g); iu \\<in> IU;\n        x \\<in> set_spmf X; xa \\<in> set_spmf (g x);\n        (ou, b) \\<in> set_spmf (cfunc_usr core2 xa iu);\n        ?c26 x b xa\n        \\<in> (\\<Union>x\\<in>set_spmf (f x).\n                  fst ` set_spmf (cfunc_usr core1 x iu))\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (f x \\<bind>\n                             (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (g x \\<bind>\n                             (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x b xa.\n       \\<lbrakk>cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (f y \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)))\n                 ou =\n                cond_bind_spmf_fst X\n                 (\\<lambda>y.\n                     map_spmf fst\n                      (g y \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)))\n                 ou;\n        \\<And>x. x \\<in> set_spmf X \\<Longrightarrow> S (f x) (g x);\n        trace_eq_simcl S (X \\<bind> f) (X \\<bind> g); iu \\<in> IU;\n        x \\<in> set_spmf X; xa \\<in> set_spmf (g x);\n        (ou, b) \\<in> set_spmf (cfunc_usr core2 xa iu);\n        fst (ou, b)\n        \\<in> (\\<Union>x\\<in>set_spmf (f x).\n                  fst ` set_spmf (cfunc_usr core1 x iu))\\<rbrakk>\n       \\<Longrightarrow> trace_eq_simcl S\n                          (cond_spmf_fst\n                            (f x \\<bind>\n                             (\\<lambda>s1. cfunc_usr core1 s1 iu))\n                            ou)\n                          (cond_spmf_fst\n                            (g x \\<bind>\n                             (\\<lambda>s2. cfunc_usr core2 s2 iu))\n                            ou)", "apply(auto intro: sim_cfunc_usr)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  trace_eq_simcl S\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trace_eq_simcl S\n   (cond_spmf_fst (p \\<bind> (\\<lambda>s1. cfunc_usr core1 s1 iu)) ou)\n   (cond_spmf_fst (q \\<bind> (\\<lambda>s2. cfunc_usr core2 s2 iu)) ou)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trace_core_eq core1 core2 E IA IU p q\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  fixes core :: \"('s_core, 'event1 + 'event2, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\"\n    and rest :: \"('s_rest, 'event2, 'iadv_rest, 'iusr_rest, 'oadv_rest, 'ousr_rest, 'more) rest_scheme\" \nbegin"], ["", "primcorec core_with_rest :: \n  \"('s_core \\<times> 's_rest, 'event1, 'iadv_core + 'iadv_rest, 'iusr_core + 'iusr_rest, 'oadv_core + 'oadv_rest, 'ousr_core + 'ousr_rest) core\" \n  where\n    \"cpoke core_with_rest = (\\<lambda>(s_core, s_rest) e. map_spmf (\\<lambda>s_core'. (s_core', s_rest)) (cpoke core s_core (Inl e)))\"\n  | \"cfunc_adv core_with_rest = (\\<lambda>(s_core, s_rest) iadv. case iadv of\n       Inl iadv_core \\<Rightarrow> map_spmf (\\<lambda>(oadv_core, s_core'). (Inl oadv_core, (s_core', s_rest))) (cfunc_adv core s_core iadv_core)\n     | Inr iadv_rest \\<Rightarrow> \n       bind_spmf (rfunc_adv rest s_rest iadv_rest) (\\<lambda>((oadv_rest, es), s_rest'). \n         map_spmf (\\<lambda>s_core'. (Inr oadv_rest, (s_core', s_rest'))) (foldl_spmf (cpoke core) (return_spmf s_core) (map Inr es))))\"\n  | \"cfunc_usr core_with_rest = (\\<lambda>(s_core, s_rest) iusr. case iusr of\n       Inl iusr_core \\<Rightarrow> map_spmf (\\<lambda>(ousr_core, s_core'). (Inl ousr_core, (s_core', s_rest))) (cfunc_usr core s_core iusr_core)\n     | Inr iusr_rest \\<Rightarrow>\n       bind_spmf (rfunc_usr rest s_rest iusr_rest) (\\<lambda>((ousr_rest, es), s_rest').\n         map_spmf (\\<lambda>s_core'. (Inr ousr_rest, (s_core', s_rest'))) (foldl_spmf (cpoke core) (return_spmf s_core) (map Inr es))))\""], ["", "end"], ["", "lemma fuse_core_with_rest:\n  fixes core :: \"('s_core, 'event1 + 'event2, 'iadv_core, 'iusr_core, 'oadv_core, 'ousr_core) core\"\n    and rest1 :: \"('s_rest1, 'event1, 'iadv_rest1, 'iusr_rest1, 'oadv_rest1, 'ousr_rest1, 'more1) rest_scheme\"\n    and rest2 :: \"('s_rest2, 'event2, 'iadv_rest2, 'iusr_rest2, 'oadv_rest2, 'ousr_rest2, 'more2) rest_scheme\"\n  shows\n  \"fused_resource.fuse core (parallel_rest rest1 rest2) (s_core, (s_rest1, s_rest2)) = \n   map_fun (map_sum (lsumr \\<circ> map_sum id swap_sum) (lsumr \\<circ> map_sum id swap_sum)) (map_spmf (map_prod (map_sum (map_sum id swap_sum \\<circ> rsuml) (map_sum id swap_sum \\<circ> rsuml)) (map_prod id prod.swap \\<circ> rprodl)))\n   (fused_resource.fuse (core_with_rest core rest2) rest1 ((s_core, s_rest2), s_rest1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fused_resource.fuse core (parallel_rest rest1 rest2)\n     (s_core, s_rest1, s_rest2) =\n    map_fun\n     (map_sum (lsumr \\<circ> map_sum id swap_sum)\n       (lsumr \\<circ> map_sum id swap_sum))\n     (map_spmf\n       (map_prod\n         (map_sum (map_sum id swap_sum \\<circ> rsuml)\n           (map_sum id swap_sum \\<circ> rsuml))\n         (map_prod id prod.swap \\<circ> rprodl)))\n     (fused_resource.fuse (core_with_rest core rest2) rest1\n       ((s_core, s_rest2), s_rest1))", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       fused_resource.fuse core (parallel_rest rest1 rest2)\n        (s_core, s_rest1, s_rest2) x =\n       map_fun\n        (map_sum (lsumr \\<circ> map_sum id swap_sum)\n          (lsumr \\<circ> map_sum id swap_sum))\n        (map_spmf\n          (map_prod\n            (map_sum (map_sum id swap_sum \\<circ> rsuml)\n              (map_sum id swap_sum \\<circ> rsuml))\n            (map_prod id prod.swap \\<circ> rprodl)))\n        (fused_resource.fuse (core_with_rest core rest2) rest1\n          ((s_core, s_rest2), s_rest1))\n        x", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. fused_resource.fuse core (parallel_rest rest1 rest2)\n     (s_core, s_rest1, s_rest2) x =\n    map_fun\n     (map_sum (lsumr \\<circ> map_sum id swap_sum)\n       (lsumr \\<circ> map_sum id swap_sum))\n     (map_spmf\n       (map_prod\n         (map_sum (map_sum id swap_sum \\<circ> rsuml)\n           (map_sum id swap_sum \\<circ> rsuml))\n         (map_prod id prod.swap \\<circ> rprodl)))\n     (fused_resource.fuse (core_with_rest core rest2) rest1\n       ((s_core, s_rest2), s_rest1))\n     x", "apply(cases \"(parallel_rest rest1 rest2, (s_core, (s_rest1, s_rest2)), x)\" rule: fused_resource.fuse.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>rest state iadv_core.\n       (parallel_rest rest1 rest2, (s_core, s_rest1, s_rest2), x) =\n       (rest, state, Inl (Inl iadv_core)) \\<Longrightarrow>\n       fused_resource.fuse core (parallel_rest rest1 rest2)\n        (s_core, s_rest1, s_rest2) x =\n       map_fun\n        (map_sum (lsumr \\<circ> map_sum id swap_sum)\n          (lsumr \\<circ> map_sum id swap_sum))\n        (map_spmf\n          (map_prod\n            (map_sum (map_sum id swap_sum \\<circ> rsuml)\n              (map_sum id swap_sum \\<circ> rsuml))\n            (map_prod id prod.swap \\<circ> rprodl)))\n        (fused_resource.fuse (core_with_rest core rest2) rest1\n          ((s_core, s_rest2), s_rest1))\n        x\n 2. \\<And>rest state iadv_rest.\n       (parallel_rest rest1 rest2, (s_core, s_rest1, s_rest2), x) =\n       (rest, state, Inl (Inr iadv_rest)) \\<Longrightarrow>\n       fused_resource.fuse core (parallel_rest rest1 rest2)\n        (s_core, s_rest1, s_rest2) x =\n       map_fun\n        (map_sum (lsumr \\<circ> map_sum id swap_sum)\n          (lsumr \\<circ> map_sum id swap_sum))\n        (map_spmf\n          (map_prod\n            (map_sum (map_sum id swap_sum \\<circ> rsuml)\n              (map_sum id swap_sum \\<circ> rsuml))\n            (map_prod id prod.swap \\<circ> rprodl)))\n        (fused_resource.fuse (core_with_rest core rest2) rest1\n          ((s_core, s_rest2), s_rest1))\n        x\n 3. \\<And>rest state iusr_core.\n       (parallel_rest rest1 rest2, (s_core, s_rest1, s_rest2), x) =\n       (rest, state, Inr (Inl iusr_core)) \\<Longrightarrow>\n       fused_resource.fuse core (parallel_rest rest1 rest2)\n        (s_core, s_rest1, s_rest2) x =\n       map_fun\n        (map_sum (lsumr \\<circ> map_sum id swap_sum)\n          (lsumr \\<circ> map_sum id swap_sum))\n        (map_spmf\n          (map_prod\n            (map_sum (map_sum id swap_sum \\<circ> rsuml)\n              (map_sum id swap_sum \\<circ> rsuml))\n            (map_prod id prod.swap \\<circ> rprodl)))\n        (fused_resource.fuse (core_with_rest core rest2) rest1\n          ((s_core, s_rest2), s_rest1))\n        x\n 4. \\<And>rest state iusr_rest.\n       (parallel_rest rest1 rest2, (s_core, s_rest1, s_rest2), x) =\n       (rest, state, Inr (Inr iusr_rest)) \\<Longrightarrow>\n       fused_resource.fuse core (parallel_rest rest1 rest2)\n        (s_core, s_rest1, s_rest2) x =\n       map_fun\n        (map_sum (lsumr \\<circ> map_sum id swap_sum)\n          (lsumr \\<circ> map_sum id swap_sum))\n        (map_spmf\n          (map_prod\n            (map_sum (map_sum id swap_sum \\<circ> rsuml)\n              (map_sum id swap_sum \\<circ> rsuml))\n            (map_prod id prod.swap \\<circ> rprodl)))\n        (fused_resource.fuse (core_with_rest core rest2) rest1\n          ((s_core, s_rest2), s_rest1))\n        x", "apply(auto simp add: fused_resource.fuse.simps map_bind_spmf bind_map_spmf map_prod_def split_def o_def parallel_eoracle_def parallel_oracle_def split!: sum.split intro!: bind_spmf_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 a b ba.\n       \\<lbrakk>x = Inl (Inr (Inl x1));\n        ((a, b), ba) \\<in> set_spmf (rfunc_adv rest1 s_rest1 x1)\\<rbrakk>\n       \\<Longrightarrow> foldl_spmf\n                          (map_fun id (map_fun Inl id) (cpoke core))\n                          (return_spmf s_core) b \\<bind>\n                         (\\<lambda>s_notify.\n                             return_spmf\n                              (Inl (Inr (Inl a)), s_notify, ba, s_rest2)) =\n                         foldl_spmf\n                          (\\<lambda>p e.\n                              map_spmf (\\<lambda>s_core'. (s_core', snd p))\n                               (cpoke core (fst p) (Inl e)))\n                          (return_spmf (s_core, s_rest2)) b \\<bind>\n                         (\\<lambda>x.\n                             return_spmf\n                              (Inl (Inr (Inl a)), fst (rprodl (x, ba)),\n                               prod.swap (snd (rprodl (x, ba)))))\n 2. \\<And>x1 a b ba.\n       \\<lbrakk>x = Inr (Inr (Inl x1));\n        ((a, b), ba) \\<in> set_spmf (rfunc_usr rest1 s_rest1 x1)\\<rbrakk>\n       \\<Longrightarrow> foldl_spmf\n                          (map_fun id (map_fun Inl id) (cpoke core))\n                          (return_spmf s_core) b \\<bind>\n                         (\\<lambda>s_notify.\n                             return_spmf\n                              (Inr (Inr (Inl a)), s_notify, ba, s_rest2)) =\n                         foldl_spmf\n                          (\\<lambda>p e.\n                              map_spmf (\\<lambda>s_core'. (s_core', snd p))\n                               (cpoke core (fst p) (Inl e)))\n                          (return_spmf (s_core, s_rest2)) b \\<bind>\n                         (\\<lambda>x.\n                             return_spmf\n                              (Inr (Inr (Inl a)), fst (rprodl (x, ba)),\n                               prod.swap (snd (rprodl (x, ba)))))", "apply(subst foldl_spmf_pair_left[simplified split_def]; simp add: map_fun_def o_def bind_map_spmf)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}