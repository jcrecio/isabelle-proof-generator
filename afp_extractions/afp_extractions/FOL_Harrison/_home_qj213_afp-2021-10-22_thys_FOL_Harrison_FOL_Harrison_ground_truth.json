{"file_name": "/home/qj213/afp-2021-10-22/thys/FOL_Harrison/FOL_Harrison.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/FOL_Harrison", "problem_names": ["lemma map':\n  \"\\<not> occurs_in x t \\<Longrightarrow> semantics_term e f t = semantics_term (e(x := v)) f t\"\n  \"\\<not> occurs_in_list x l \\<Longrightarrow> semantics_list e f l = semantics_list (e(x := v)) f l\"", "lemma map:\n  \"\\<not> free_in x p \\<Longrightarrow> semantics e f g p \\<longleftrightarrow> semantics (e(x := v)) f g p\"", "lemma length2_equiv:\n  \"length2 l \\<longleftrightarrow> [hd l, hd (tl l)] = l\"", "lemma equal_length_sym:\n  \"equal_length l l' \\<Longrightarrow> equal_length l' l\"", "lemma equal_length2:\n  \"equal_length l l' \\<Longrightarrow> length2 l \\<longleftrightarrow> length2 l'\"", "lemma imp_chain_equiv:\n  \"semantics e f g (foldr Imp l p) \\<longleftrightarrow> (\\<forall>q \\<in> set l. semantics e f g q) \\<longrightarrow> semantics e f g p\"", "lemma imp_chain_zip_eq:\n  \"equal_length l l' \\<Longrightarrow>\n      semantics e f g (foldr Imp (zip_eq l l') p) \\<longleftrightarrow>\n      semantics_list e f l = semantics_list e f l' \\<longrightarrow> semantics e f g p\"", "lemma funcong:\n  \"equal_length l l' \\<Longrightarrow>\n      semantics e f g (foldr Imp (zip_eq l l') (Atom (Rl (STR ''='') [Fn i l, Fn i l'])))\"", "lemma predcong:\n  \"equal_length l l' \\<Longrightarrow>\n      semantics e f g (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))\"", "theorem soundness:\n  \"\\<turnstile> p \\<Longrightarrow> semantics e f g p\""], "translations": [["", "lemma map':\n  \"\\<not> occurs_in x t \\<Longrightarrow> semantics_term e f t = semantics_term (e(x := v)) f t\"\n  \"\\<not> occurs_in_list x l \\<Longrightarrow> semantics_list e f l = semantics_list (e(x := v)) f l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> occurs_in x t \\<Longrightarrow>\n     semantics_term e f t = semantics_term (e(x := v)) f t) &&&\n    (\\<not> occurs_in_list x l \\<Longrightarrow>\n     semantics_list e f l = semantics_list (e(x := v)) f l)", "by (induct t and l rule: semantics_term.induct semantics_list.induct) simp_all"], ["", "lemma map:\n  \"\\<not> free_in x p \\<Longrightarrow> semantics e f g p \\<longleftrightarrow> semantics (e(x := v)) f g p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> free_in x p \\<Longrightarrow>\n    semantics e f g p = semantics (e(x := v)) f g p", "proof (induct p arbitrary: e)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>e.\n       \\<not> free_in x Truth \\<Longrightarrow>\n       semantics e f g Truth = semantics (e(x := v)) f g Truth\n 2. \\<And>e.\n       \\<not> free_in x Falsity \\<Longrightarrow>\n       semantics e f g Falsity = semantics (e(x := v)) f g Falsity\n 3. \\<And>xa e.\n       \\<not> free_in x (Atom xa) \\<Longrightarrow>\n       semantics e f g (Atom xa) = semantics (e(x := v)) f g (Atom xa)\n 4. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Imp p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Imp p1 p2) =\n                         semantics (e(x := v)) f g (Imp p1 p2)\n 5. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Iff p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Iff p1 p2) =\n                         semantics (e(x := v)) f g (Iff p1 p2)\n 6. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (And p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (And p1 p2) =\n                         semantics (e(x := v)) f g (And p1 p2)\n 7. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 8. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 9. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 10. \\<And>x1 p e.\n        \\<lbrakk>\\<And>e.\n                    \\<not> free_in x p \\<Longrightarrow>\n                    semantics e f g p = semantics (e(x := v)) f g p;\n         \\<not> free_in x (Forall x1 p)\\<rbrakk>\n        \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                          semantics (e(x := v)) f g (Forall x1 p)", "fix e"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>e.\n       \\<not> free_in x Truth \\<Longrightarrow>\n       semantics e f g Truth = semantics (e(x := v)) f g Truth\n 2. \\<And>e.\n       \\<not> free_in x Falsity \\<Longrightarrow>\n       semantics e f g Falsity = semantics (e(x := v)) f g Falsity\n 3. \\<And>xa e.\n       \\<not> free_in x (Atom xa) \\<Longrightarrow>\n       semantics e f g (Atom xa) = semantics (e(x := v)) f g (Atom xa)\n 4. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Imp p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Imp p1 p2) =\n                         semantics (e(x := v)) f g (Imp p1 p2)\n 5. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Iff p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Iff p1 p2) =\n                         semantics (e(x := v)) f g (Iff p1 p2)\n 6. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (And p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (And p1 p2) =\n                         semantics (e(x := v)) f g (And p1 p2)\n 7. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 8. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 9. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 10. \\<And>x1 p e.\n        \\<lbrakk>\\<And>e.\n                    \\<not> free_in x p \\<Longrightarrow>\n                    semantics e f g p = semantics (e(x := v)) f g p;\n         \\<not> free_in x (Forall x1 p)\\<rbrakk>\n        \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                          semantics (e(x := v)) f g (Forall x1 p)", "show \"\\<not> free_in x Truth \\<Longrightarrow> semantics e f g Truth \\<longleftrightarrow> semantics (e(x := v)) f g Truth\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> free_in x Truth \\<Longrightarrow>\n    semantics e f g Truth = semantics (e(x := v)) f g Truth", "by simp"], ["proof (state)\nthis:\n  \\<not> free_in x Truth \\<Longrightarrow>\n  semantics e f g Truth = semantics (e(x := v)) f g Truth\n\ngoal (9 subgoals):\n 1. \\<And>e.\n       \\<not> free_in x Falsity \\<Longrightarrow>\n       semantics e f g Falsity = semantics (e(x := v)) f g Falsity\n 2. \\<And>xa e.\n       \\<not> free_in x (Atom xa) \\<Longrightarrow>\n       semantics e f g (Atom xa) = semantics (e(x := v)) f g (Atom xa)\n 3. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Imp p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Imp p1 p2) =\n                         semantics (e(x := v)) f g (Imp p1 p2)\n 4. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Iff p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Iff p1 p2) =\n                         semantics (e(x := v)) f g (Iff p1 p2)\n 5. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (And p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (And p1 p2) =\n                         semantics (e(x := v)) f g (And p1 p2)\n 6. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 7. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 8. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 9. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>e.\n       \\<not> free_in x Falsity \\<Longrightarrow>\n       semantics e f g Falsity = semantics (e(x := v)) f g Falsity\n 2. \\<And>xa e.\n       \\<not> free_in x (Atom xa) \\<Longrightarrow>\n       semantics e f g (Atom xa) = semantics (e(x := v)) f g (Atom xa)\n 3. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Imp p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Imp p1 p2) =\n                         semantics (e(x := v)) f g (Imp p1 p2)\n 4. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Iff p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Iff p1 p2) =\n                         semantics (e(x := v)) f g (Iff p1 p2)\n 5. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (And p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (And p1 p2) =\n                         semantics (e(x := v)) f g (And p1 p2)\n 6. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 7. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 8. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 9. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "fix e"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>e.\n       \\<not> free_in x Falsity \\<Longrightarrow>\n       semantics e f g Falsity = semantics (e(x := v)) f g Falsity\n 2. \\<And>xa e.\n       \\<not> free_in x (Atom xa) \\<Longrightarrow>\n       semantics e f g (Atom xa) = semantics (e(x := v)) f g (Atom xa)\n 3. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Imp p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Imp p1 p2) =\n                         semantics (e(x := v)) f g (Imp p1 p2)\n 4. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Iff p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Iff p1 p2) =\n                         semantics (e(x := v)) f g (Iff p1 p2)\n 5. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (And p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (And p1 p2) =\n                         semantics (e(x := v)) f g (And p1 p2)\n 6. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 7. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 8. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 9. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "show \"\\<not> free_in x Falsity \\<Longrightarrow> semantics e f g Falsity \\<longleftrightarrow> semantics (e(x := v)) f g Falsity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> free_in x Falsity \\<Longrightarrow>\n    semantics e f g Falsity = semantics (e(x := v)) f g Falsity", "by simp"], ["proof (state)\nthis:\n  \\<not> free_in x Falsity \\<Longrightarrow>\n  semantics e f g Falsity = semantics (e(x := v)) f g Falsity\n\ngoal (8 subgoals):\n 1. \\<And>xa e.\n       \\<not> free_in x (Atom xa) \\<Longrightarrow>\n       semantics e f g (Atom xa) = semantics (e(x := v)) f g (Atom xa)\n 2. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Imp p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Imp p1 p2) =\n                         semantics (e(x := v)) f g (Imp p1 p2)\n 3. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Iff p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Iff p1 p2) =\n                         semantics (e(x := v)) f g (Iff p1 p2)\n 4. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (And p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (And p1 p2) =\n                         semantics (e(x := v)) f g (And p1 p2)\n 5. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 6. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 7. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 8. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>xa e.\n       \\<not> free_in x (Atom xa) \\<Longrightarrow>\n       semantics e f g (Atom xa) = semantics (e(x := v)) f g (Atom xa)\n 2. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Imp p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Imp p1 p2) =\n                         semantics (e(x := v)) f g (Imp p1 p2)\n 3. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Iff p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Iff p1 p2) =\n                         semantics (e(x := v)) f g (Iff p1 p2)\n 4. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (And p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (And p1 p2) =\n                         semantics (e(x := v)) f g (And p1 p2)\n 5. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 6. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 7. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 8. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "fix a e"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>xa e.\n       \\<not> free_in x (Atom xa) \\<Longrightarrow>\n       semantics e f g (Atom xa) = semantics (e(x := v)) f g (Atom xa)\n 2. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Imp p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Imp p1 p2) =\n                         semantics (e(x := v)) f g (Imp p1 p2)\n 3. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Iff p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Iff p1 p2) =\n                         semantics (e(x := v)) f g (Iff p1 p2)\n 4. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (And p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (And p1 p2) =\n                         semantics (e(x := v)) f g (And p1 p2)\n 5. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 6. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 7. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 8. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "show \"\\<not> free_in x (Atom a) \\<Longrightarrow> semantics e f g (Atom a) \\<longleftrightarrow> semantics (e(x := v)) f g (Atom a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> free_in x (Atom a) \\<Longrightarrow>\n    semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)", "proof (cases a)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<not> free_in x (Atom a); a = Rl x1 x2\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Atom a) =\n                         semantics (e(x := v)) f g (Atom a)", "fix i l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<not> free_in x (Atom a); a = Rl x1 x2\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Atom a) =\n                         semantics (e(x := v)) f g (Atom a)", "show \"\\<not> free_in x (Atom a) \\<Longrightarrow> a = Rl i l \\<Longrightarrow>\n        semantics e f g (Atom a) \\<longleftrightarrow> semantics (e(x := v)) f g (Atom a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> free_in x (Atom a); a = Rl i l\\<rbrakk>\n    \\<Longrightarrow> semantics e f g (Atom a) =\n                      semantics (e(x := v)) f g (Atom a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> free_in x (Atom a); a = Rl i l\\<rbrakk>\n    \\<Longrightarrow> semantics e f g (Atom a) =\n                      semantics (e(x := v)) f g (Atom a)", "assume assm: \"\\<not> free_in x (Atom a)\" \"a = Rl i l\""], ["proof (state)\nthis:\n  \\<not> free_in x (Atom a)\n  a = Rl i l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> free_in x (Atom a); a = Rl i l\\<rbrakk>\n    \\<Longrightarrow> semantics e f g (Atom a) =\n                      semantics (e(x := v)) f g (Atom a)", "then"], ["proof (chain)\npicking this:\n  \\<not> free_in x (Atom a)\n  a = Rl i l", "have fresh: \"\\<not> occurs_in_list x l\""], ["proof (prove)\nusing this:\n  \\<not> free_in x (Atom a)\n  a = Rl i l\n\ngoal (1 subgoal):\n 1. \\<not> occurs_in_list x l", "by simp"], ["proof (state)\nthis:\n  \\<not> occurs_in_list x l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> free_in x (Atom a); a = Rl i l\\<rbrakk>\n    \\<Longrightarrow> semantics e f g (Atom a) =\n                      semantics (e(x := v)) f g (Atom a)", "show \"semantics e f g (Atom a) \\<longleftrightarrow> semantics (e(x := v)) f g (Atom a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)\n 2. \\<not> ?P \\<Longrightarrow>\n    semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)", "assume eq: \"i = STR ''='' \\<and> length2 l\""], ["proof (state)\nthis:\n  i = STR ''='' \\<and> length2 l\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)\n 2. \\<not> ?P \\<Longrightarrow>\n    semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)", "then"], ["proof (chain)\npicking this:\n  i = STR ''='' \\<and> length2 l", "have \"semantics e f g (Atom (Rl i l)) \\<longleftrightarrow>\n            semantics_term e f (hd l) = semantics_term e f (hd (tl l))\""], ["proof (prove)\nusing this:\n  i = STR ''='' \\<and> length2 l\n\ngoal (1 subgoal):\n 1. semantics e f g (Atom (Rl i l)) =\n    (semantics_term e f (hd l) = semantics_term e f (hd (tl l)))", "by simp"], ["proof (state)\nthis:\n  semantics e f g (Atom (Rl i l)) =\n  (semantics_term e f (hd l) = semantics_term e f (hd (tl l)))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)\n 2. \\<not> ?P \\<Longrightarrow>\n    semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)", "also"], ["proof (state)\nthis:\n  semantics e f g (Atom (Rl i l)) =\n  (semantics_term e f (hd l) = semantics_term e f (hd (tl l)))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)\n 2. \\<not> ?P \\<Longrightarrow>\n    semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)", "have \"... \\<longleftrightarrow>\n            semantics_term (e(x := v)) f (hd l) = semantics_term (e(x := v)) f (hd (tl l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (semantics_term e f (hd l) = semantics_term e f (hd (tl l))) =\n    (semantics_term (e(x := v)) f (hd l) =\n     semantics_term (e(x := v)) f (hd (tl l)))", "using map'(1) fresh occurs_in_list.simps(2) eq list.case_eq_if list.collapse"], ["proof (prove)\nusing this:\n  \\<not> occurs_in ?x ?t \\<Longrightarrow>\n  semantics_term ?e ?f ?t = semantics_term (?e(?x := ?v)) ?f ?t\n  \\<not> occurs_in_list x l\n  occurs_in_list ?i (?h # ?t) = (occurs_in ?i ?h \\<or> occurs_in_list ?i ?t)\n  i = STR ''='' \\<and> length2 l\n  (case ?list of [] \\<Rightarrow> ?f1.0 | x # xa \\<Rightarrow> ?f2.0 x xa) =\n  (if ?list = [] then ?f1.0 else ?f2.0 (hd ?list) (tl ?list))\n  ?list \\<noteq> [] \\<Longrightarrow> hd ?list # tl ?list = ?list\n\ngoal (1 subgoal):\n 1. (semantics_term e f (hd l) = semantics_term e f (hd (tl l))) =\n    (semantics_term (e(x := v)) f (hd l) =\n     semantics_term (e(x := v)) f (hd (tl l)))", "unfolding length2_def"], ["proof (prove)\nusing this:\n  \\<not> occurs_in ?x ?t \\<Longrightarrow>\n  semantics_term ?e ?f ?t = semantics_term (?e(?x := ?v)) ?f ?t\n  \\<not> occurs_in_list x l\n  occurs_in_list ?i (?h # ?t) = (occurs_in ?i ?h \\<or> occurs_in_list ?i ?t)\n  i = STR ''='' \\<and>\n  (case l of [] \\<Rightarrow> False | [x] \\<Rightarrow> False\n   | [x, xa] \\<Rightarrow> True | x # xa # ab # list \\<Rightarrow> False)\n  (case ?list of [] \\<Rightarrow> ?f1.0 | x # xa \\<Rightarrow> ?f2.0 x xa) =\n  (if ?list = [] then ?f1.0 else ?f2.0 (hd ?list) (tl ?list))\n  ?list \\<noteq> [] \\<Longrightarrow> hd ?list # tl ?list = ?list\n\ngoal (1 subgoal):\n 1. (semantics_term e f (hd l) = semantics_term e f (hd (tl l))) =\n    (semantics_term (e(x := v)) f (hd l) =\n     semantics_term (e(x := v)) f (hd (tl l)))", "by metis"], ["proof (state)\nthis:\n  (semantics_term e f (hd l) = semantics_term e f (hd (tl l))) =\n  (semantics_term (e(x := v)) f (hd l) =\n   semantics_term (e(x := v)) f (hd (tl l)))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)\n 2. \\<not> ?P \\<Longrightarrow>\n    semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)", "finally"], ["proof (chain)\npicking this:\n  semantics e f g (Atom (Rl i l)) =\n  (semantics_term (e(x := v)) f (hd l) =\n   semantics_term (e(x := v)) f (hd (tl l)))", "show ?thesis"], ["proof (prove)\nusing this:\n  semantics e f g (Atom (Rl i l)) =\n  (semantics_term (e(x := v)) f (hd l) =\n   semantics_term (e(x := v)) f (hd (tl l)))\n\ngoal (1 subgoal):\n 1. semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)", "using eq assm(2)"], ["proof (prove)\nusing this:\n  semantics e f g (Atom (Rl i l)) =\n  (semantics_term (e(x := v)) f (hd l) =\n   semantics_term (e(x := v)) f (hd (tl l)))\n  i = STR ''='' \\<and> length2 l\n  a = Rl i l\n\ngoal (1 subgoal):\n 1. semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)", "by simp"], ["proof (state)\nthis:\n  semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)\n\ngoal (1 subgoal):\n 1. \\<not> (i = STR ''='' \\<and> length2 l) \\<Longrightarrow>\n    semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (i = STR ''='' \\<and> length2 l) \\<Longrightarrow>\n    semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)", "assume not_eq: \"\\<not> (i = STR ''='' \\<and> length2 l)\""], ["proof (state)\nthis:\n  \\<not> (i = STR ''='' \\<and> length2 l)\n\ngoal (1 subgoal):\n 1. \\<not> (i = STR ''='' \\<and> length2 l) \\<Longrightarrow>\n    semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)", "then"], ["proof (chain)\npicking this:\n  \\<not> (i = STR ''='' \\<and> length2 l)", "have \"semantics e f g (Atom (Rl i l)) \\<longleftrightarrow> g i (semantics_list e f l)\""], ["proof (prove)\nusing this:\n  \\<not> (i = STR ''='' \\<and> length2 l)\n\ngoal (1 subgoal):\n 1. semantics e f g (Atom (Rl i l)) = g i (semantics_list e f l)", "by simp iprover"], ["proof (state)\nthis:\n  semantics e f g (Atom (Rl i l)) = g i (semantics_list e f l)\n\ngoal (1 subgoal):\n 1. \\<not> (i = STR ''='' \\<and> length2 l) \\<Longrightarrow>\n    semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)", "also"], ["proof (state)\nthis:\n  semantics e f g (Atom (Rl i l)) = g i (semantics_list e f l)\n\ngoal (1 subgoal):\n 1. \\<not> (i = STR ''='' \\<and> length2 l) \\<Longrightarrow>\n    semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)", "have \"... \\<longleftrightarrow> g i (semantics_list (e(x := v)) f l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g i (semantics_list e f l) = g i (semantics_list (e(x := v)) f l)", "using map'(2) fresh"], ["proof (prove)\nusing this:\n  \\<not> occurs_in_list ?x ?l \\<Longrightarrow>\n  semantics_list ?e ?f ?l = semantics_list (?e(?x := ?v)) ?f ?l\n  \\<not> occurs_in_list x l\n\ngoal (1 subgoal):\n 1. g i (semantics_list e f l) = g i (semantics_list (e(x := v)) f l)", "by metis"], ["proof (state)\nthis:\n  g i (semantics_list e f l) = g i (semantics_list (e(x := v)) f l)\n\ngoal (1 subgoal):\n 1. \\<not> (i = STR ''='' \\<and> length2 l) \\<Longrightarrow>\n    semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)", "finally"], ["proof (chain)\npicking this:\n  semantics e f g (Atom (Rl i l)) = g i (semantics_list (e(x := v)) f l)", "show ?thesis"], ["proof (prove)\nusing this:\n  semantics e f g (Atom (Rl i l)) = g i (semantics_list (e(x := v)) f l)\n\ngoal (1 subgoal):\n 1. semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)", "using not_eq assm(2)"], ["proof (prove)\nusing this:\n  semantics e f g (Atom (Rl i l)) = g i (semantics_list (e(x := v)) f l)\n  \\<not> (i = STR ''='' \\<and> length2 l)\n  a = Rl i l\n\ngoal (1 subgoal):\n 1. semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)", "by simp iprover"], ["proof (state)\nthis:\n  semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> free_in x (Atom a); a = Rl i l\\<rbrakk>\n  \\<Longrightarrow> semantics e f g (Atom a) =\n                    semantics (e(x := v)) f g (Atom a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> free_in x (Atom a) \\<Longrightarrow>\n  semantics e f g (Atom a) = semantics (e(x := v)) f g (Atom a)\n\ngoal (7 subgoals):\n 1. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Imp p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Imp p1 p2) =\n                         semantics (e(x := v)) f g (Imp p1 p2)\n 2. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Iff p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Iff p1 p2) =\n                         semantics (e(x := v)) f g (Iff p1 p2)\n 3. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (And p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (And p1 p2) =\n                         semantics (e(x := v)) f g (And p1 p2)\n 4. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 5. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 6. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 7. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Imp p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Imp p1 p2) =\n                         semantics (e(x := v)) f g (Imp p1 p2)\n 2. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Iff p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Iff p1 p2) =\n                         semantics (e(x := v)) f g (Iff p1 p2)\n 3. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (And p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (And p1 p2) =\n                         semantics (e(x := v)) f g (And p1 p2)\n 4. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 5. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 6. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 7. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "fix p1 p2 e"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Imp p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Imp p1 p2) =\n                         semantics (e(x := v)) f g (Imp p1 p2)\n 2. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Iff p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Iff p1 p2) =\n                         semantics (e(x := v)) f g (Iff p1 p2)\n 3. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (And p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (And p1 p2) =\n                         semantics (e(x := v)) f g (And p1 p2)\n 4. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 5. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 6. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 7. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "assume assm1: \"\\<not> free_in x p1 \\<Longrightarrow> semantics e f g p1 \\<longleftrightarrow> semantics (e(x := v)) f g p1\" for e"], ["proof (state)\nthis:\n  \\<not> free_in x p1 \\<Longrightarrow>\n  semantics ?e f g p1 = semantics (?e(x := v)) f g p1\n\ngoal (7 subgoals):\n 1. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Imp p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Imp p1 p2) =\n                         semantics (e(x := v)) f g (Imp p1 p2)\n 2. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Iff p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Iff p1 p2) =\n                         semantics (e(x := v)) f g (Iff p1 p2)\n 3. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (And p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (And p1 p2) =\n                         semantics (e(x := v)) f g (And p1 p2)\n 4. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 5. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 6. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 7. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "assume assm2: \"\\<not> free_in x p2 \\<Longrightarrow> semantics e f g p2 \\<longleftrightarrow> semantics (e(x := v)) f g p2\" for e"], ["proof (state)\nthis:\n  \\<not> free_in x p2 \\<Longrightarrow>\n  semantics ?e f g p2 = semantics (?e(x := v)) f g p2\n\ngoal (7 subgoals):\n 1. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Imp p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Imp p1 p2) =\n                         semantics (e(x := v)) f g (Imp p1 p2)\n 2. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Iff p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Iff p1 p2) =\n                         semantics (e(x := v)) f g (Iff p1 p2)\n 3. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (And p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (And p1 p2) =\n                         semantics (e(x := v)) f g (And p1 p2)\n 4. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 5. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 6. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 7. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "show \"\\<not> free_in x (Imp p1 p2) \\<Longrightarrow>\n      semantics e f g (Imp p1 p2) \\<longleftrightarrow> semantics (e(x := v)) f g (Imp p1 p2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> free_in x (Imp p1 p2) \\<Longrightarrow>\n    semantics e f g (Imp p1 p2) = semantics (e(x := v)) f g (Imp p1 p2)", "using assm1 assm2"], ["proof (prove)\nusing this:\n  \\<not> free_in x p1 \\<Longrightarrow>\n  semantics ?e f g p1 = semantics (?e(x := v)) f g p1\n  \\<not> free_in x p2 \\<Longrightarrow>\n  semantics ?e f g p2 = semantics (?e(x := v)) f g p2\n\ngoal (1 subgoal):\n 1. \\<not> free_in x (Imp p1 p2) \\<Longrightarrow>\n    semantics e f g (Imp p1 p2) = semantics (e(x := v)) f g (Imp p1 p2)", "by simp"], ["proof (state)\nthis:\n  \\<not> free_in x (Imp p1 p2) \\<Longrightarrow>\n  semantics e f g (Imp p1 p2) = semantics (e(x := v)) f g (Imp p1 p2)\n\ngoal (6 subgoals):\n 1. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Iff p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Iff p1 p2) =\n                         semantics (e(x := v)) f g (Iff p1 p2)\n 2. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (And p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (And p1 p2) =\n                         semantics (e(x := v)) f g (And p1 p2)\n 3. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 4. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 5. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 6. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Iff p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Iff p1 p2) =\n                         semantics (e(x := v)) f g (Iff p1 p2)\n 2. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (And p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (And p1 p2) =\n                         semantics (e(x := v)) f g (And p1 p2)\n 3. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 4. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 5. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 6. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "fix p1 p2 e"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Iff p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Iff p1 p2) =\n                         semantics (e(x := v)) f g (Iff p1 p2)\n 2. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (And p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (And p1 p2) =\n                         semantics (e(x := v)) f g (And p1 p2)\n 3. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 4. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 5. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 6. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "assume assm1: \"\\<not> free_in x p1 \\<Longrightarrow> semantics e f g p1 \\<longleftrightarrow> semantics (e(x := v)) f g p1\" for e"], ["proof (state)\nthis:\n  \\<not> free_in x p1 \\<Longrightarrow>\n  semantics ?e f g p1 = semantics (?e(x := v)) f g p1\n\ngoal (6 subgoals):\n 1. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Iff p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Iff p1 p2) =\n                         semantics (e(x := v)) f g (Iff p1 p2)\n 2. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (And p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (And p1 p2) =\n                         semantics (e(x := v)) f g (And p1 p2)\n 3. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 4. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 5. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 6. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "assume assm2: \"\\<not> free_in x p2 \\<Longrightarrow> semantics e f g p2 \\<longleftrightarrow> semantics (e(x := v)) f g p2\" for e"], ["proof (state)\nthis:\n  \\<not> free_in x p2 \\<Longrightarrow>\n  semantics ?e f g p2 = semantics (?e(x := v)) f g p2\n\ngoal (6 subgoals):\n 1. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Iff p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Iff p1 p2) =\n                         semantics (e(x := v)) f g (Iff p1 p2)\n 2. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (And p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (And p1 p2) =\n                         semantics (e(x := v)) f g (And p1 p2)\n 3. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 4. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 5. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 6. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "show \"\\<not> free_in x (Iff p1 p2) \\<Longrightarrow>\n      semantics e f g (Iff p1 p2) \\<longleftrightarrow> semantics (e(x := v)) f g (Iff p1 p2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> free_in x (Iff p1 p2) \\<Longrightarrow>\n    semantics e f g (Iff p1 p2) = semantics (e(x := v)) f g (Iff p1 p2)", "using assm1 assm2"], ["proof (prove)\nusing this:\n  \\<not> free_in x p1 \\<Longrightarrow>\n  semantics ?e f g p1 = semantics (?e(x := v)) f g p1\n  \\<not> free_in x p2 \\<Longrightarrow>\n  semantics ?e f g p2 = semantics (?e(x := v)) f g p2\n\ngoal (1 subgoal):\n 1. \\<not> free_in x (Iff p1 p2) \\<Longrightarrow>\n    semantics e f g (Iff p1 p2) = semantics (e(x := v)) f g (Iff p1 p2)", "by simp"], ["proof (state)\nthis:\n  \\<not> free_in x (Iff p1 p2) \\<Longrightarrow>\n  semantics e f g (Iff p1 p2) = semantics (e(x := v)) f g (Iff p1 p2)\n\ngoal (5 subgoals):\n 1. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (And p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (And p1 p2) =\n                         semantics (e(x := v)) f g (And p1 p2)\n 2. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 3. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 4. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 5. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (And p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (And p1 p2) =\n                         semantics (e(x := v)) f g (And p1 p2)\n 2. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 3. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 4. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 5. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "fix p1 p2 e"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (And p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (And p1 p2) =\n                         semantics (e(x := v)) f g (And p1 p2)\n 2. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 3. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 4. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 5. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "assume assm1: \"\\<not> free_in x p1 \\<Longrightarrow> semantics e f g p1 \\<longleftrightarrow> semantics (e(x := v)) f g p1\" for e"], ["proof (state)\nthis:\n  \\<not> free_in x p1 \\<Longrightarrow>\n  semantics ?e f g p1 = semantics (?e(x := v)) f g p1\n\ngoal (5 subgoals):\n 1. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (And p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (And p1 p2) =\n                         semantics (e(x := v)) f g (And p1 p2)\n 2. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 3. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 4. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 5. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "assume assm2: \"\\<not> free_in x p2 \\<Longrightarrow> semantics e f g p2 \\<longleftrightarrow> semantics (e(x := v)) f g p2\" for e"], ["proof (state)\nthis:\n  \\<not> free_in x p2 \\<Longrightarrow>\n  semantics ?e f g p2 = semantics (?e(x := v)) f g p2\n\ngoal (5 subgoals):\n 1. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (And p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (And p1 p2) =\n                         semantics (e(x := v)) f g (And p1 p2)\n 2. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 3. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 4. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 5. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "show \"\\<not> free_in x (And p1 p2) \\<Longrightarrow>\n      semantics e f g (And p1 p2) \\<longleftrightarrow> semantics (e(x := v)) f g (And p1 p2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> free_in x (And p1 p2) \\<Longrightarrow>\n    semantics e f g (And p1 p2) = semantics (e(x := v)) f g (And p1 p2)", "using assm1 assm2"], ["proof (prove)\nusing this:\n  \\<not> free_in x p1 \\<Longrightarrow>\n  semantics ?e f g p1 = semantics (?e(x := v)) f g p1\n  \\<not> free_in x p2 \\<Longrightarrow>\n  semantics ?e f g p2 = semantics (?e(x := v)) f g p2\n\ngoal (1 subgoal):\n 1. \\<not> free_in x (And p1 p2) \\<Longrightarrow>\n    semantics e f g (And p1 p2) = semantics (e(x := v)) f g (And p1 p2)", "by simp"], ["proof (state)\nthis:\n  \\<not> free_in x (And p1 p2) \\<Longrightarrow>\n  semantics e f g (And p1 p2) = semantics (e(x := v)) f g (And p1 p2)\n\ngoal (4 subgoals):\n 1. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 2. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 3. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 4. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 2. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 3. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 4. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "fix p1 p2 e"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 2. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 3. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 4. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "assume assm1: \"\\<not> free_in x p1 \\<Longrightarrow> semantics e f g p1 \\<longleftrightarrow> semantics (e(x := v)) f g p1\" for e"], ["proof (state)\nthis:\n  \\<not> free_in x p1 \\<Longrightarrow>\n  semantics ?e f g p1 = semantics (?e(x := v)) f g p1\n\ngoal (4 subgoals):\n 1. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 2. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 3. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 4. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "assume assm2: \"\\<not> free_in x p2 \\<Longrightarrow> semantics e f g p2 \\<longleftrightarrow> semantics (e(x := v)) f g p2\" for e"], ["proof (state)\nthis:\n  \\<not> free_in x p2 \\<Longrightarrow>\n  semantics ?e f g p2 = semantics (?e(x := v)) f g p2\n\ngoal (4 subgoals):\n 1. \\<And>p1 p2 e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p1 \\<Longrightarrow>\n                   semantics e f g p1 = semantics (e(x := v)) f g p1;\n        \\<And>e.\n           \\<not> free_in x p2 \\<Longrightarrow>\n           semantics e f g p2 = semantics (e(x := v)) f g p2;\n        \\<not> free_in x (Or p1 p2)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Or p1 p2) =\n                         semantics (e(x := v)) f g (Or p1 p2)\n 2. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 3. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 4. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "show \"\\<not> free_in x (Or p1 p2) \\<Longrightarrow>\n      semantics e f g (Or p1 p2) \\<longleftrightarrow> semantics (e(x := v)) f g (Or p1 p2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> free_in x (Or p1 p2) \\<Longrightarrow>\n    semantics e f g (Or p1 p2) = semantics (e(x := v)) f g (Or p1 p2)", "using assm1 assm2"], ["proof (prove)\nusing this:\n  \\<not> free_in x p1 \\<Longrightarrow>\n  semantics ?e f g p1 = semantics (?e(x := v)) f g p1\n  \\<not> free_in x p2 \\<Longrightarrow>\n  semantics ?e f g p2 = semantics (?e(x := v)) f g p2\n\ngoal (1 subgoal):\n 1. \\<not> free_in x (Or p1 p2) \\<Longrightarrow>\n    semantics e f g (Or p1 p2) = semantics (e(x := v)) f g (Or p1 p2)", "by simp"], ["proof (state)\nthis:\n  \\<not> free_in x (Or p1 p2) \\<Longrightarrow>\n  semantics e f g (Or p1 p2) = semantics (e(x := v)) f g (Or p1 p2)\n\ngoal (3 subgoals):\n 1. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 2. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 3. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 2. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 3. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "fix p e"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 2. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 3. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "assume \"\\<not> free_in x p \\<Longrightarrow> semantics e f g p \\<longleftrightarrow> semantics (e(x := v)) f g p\" for e"], ["proof (state)\nthis:\n  \\<not> free_in x p \\<Longrightarrow>\n  semantics ?e f g p = semantics (?e(x := v)) f g p\n\ngoal (3 subgoals):\n 1. \\<And>p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (fm.Not p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (fm.Not p) =\n                         semantics (e(x := v)) f g (fm.Not p)\n 2. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 3. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "then"], ["proof (chain)\npicking this:\n  \\<not> free_in x p \\<Longrightarrow>\n  semantics ?e f g p = semantics (?e(x := v)) f g p", "show \"\\<not> free_in x (Not p) \\<Longrightarrow> semantics e f g (Not p) \\<longleftrightarrow> semantics (e(x := v)) f g (Not p)\""], ["proof (prove)\nusing this:\n  \\<not> free_in x p \\<Longrightarrow>\n  semantics ?e f g p = semantics (?e(x := v)) f g p\n\ngoal (1 subgoal):\n 1. \\<not> free_in x (fm.Not p) \\<Longrightarrow>\n    semantics e f g (fm.Not p) = semantics (e(x := v)) f g (fm.Not p)", "by simp"], ["proof (state)\nthis:\n  \\<not> free_in x (fm.Not p) \\<Longrightarrow>\n  semantics e f g (fm.Not p) = semantics (e(x := v)) f g (fm.Not p)\n\ngoal (2 subgoals):\n 1. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 2. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 2. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "fix x1 p e"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 2. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "assume \"\\<not> free_in x p \\<Longrightarrow> semantics e f g p \\<longleftrightarrow> semantics (e(x := v)) f g p\" for e"], ["proof (state)\nthis:\n  \\<not> free_in x p \\<Longrightarrow>\n  semantics ?e f g p = semantics (?e(x := v)) f g p\n\ngoal (2 subgoals):\n 1. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Exists x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Exists x1 p) =\n                         semantics (e(x := v)) f g (Exists x1 p)\n 2. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "then"], ["proof (chain)\npicking this:\n  \\<not> free_in x p \\<Longrightarrow>\n  semantics ?e f g p = semantics (?e(x := v)) f g p", "show \"\\<not> free_in x (Exists x1 p) \\<Longrightarrow>\n      semantics e f g (Exists x1 p) \\<longleftrightarrow> semantics (e(x := v)) f g (Exists x1 p)\""], ["proof (prove)\nusing this:\n  \\<not> free_in x p \\<Longrightarrow>\n  semantics ?e f g p = semantics (?e(x := v)) f g p\n\ngoal (1 subgoal):\n 1. \\<not> free_in x (Exists x1 p) \\<Longrightarrow>\n    semantics e f g (Exists x1 p) = semantics (e(x := v)) f g (Exists x1 p)", "by simp (metis fun_upd_twist fun_upd_upd)"], ["proof (state)\nthis:\n  \\<not> free_in x (Exists x1 p) \\<Longrightarrow>\n  semantics e f g (Exists x1 p) = semantics (e(x := v)) f g (Exists x1 p)\n\ngoal (1 subgoal):\n 1. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "fix x1 p e"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "assume \"\\<not> free_in x p \\<Longrightarrow> semantics e f g p \\<longleftrightarrow> semantics (e(x := v)) f g p\" for e"], ["proof (state)\nthis:\n  \\<not> free_in x p \\<Longrightarrow>\n  semantics ?e f g p = semantics (?e(x := v)) f g p\n\ngoal (1 subgoal):\n 1. \\<And>x1 p e.\n       \\<lbrakk>\\<And>e.\n                   \\<not> free_in x p \\<Longrightarrow>\n                   semantics e f g p = semantics (e(x := v)) f g p;\n        \\<not> free_in x (Forall x1 p)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (Forall x1 p) =\n                         semantics (e(x := v)) f g (Forall x1 p)", "then"], ["proof (chain)\npicking this:\n  \\<not> free_in x p \\<Longrightarrow>\n  semantics ?e f g p = semantics (?e(x := v)) f g p", "show \"\\<not> free_in x (Forall x1 p) \\<Longrightarrow>\n      semantics e f g (Forall x1 p) \\<longleftrightarrow> semantics (e(x := v)) f g (Forall x1 p)\""], ["proof (prove)\nusing this:\n  \\<not> free_in x p \\<Longrightarrow>\n  semantics ?e f g p = semantics (?e(x := v)) f g p\n\ngoal (1 subgoal):\n 1. \\<not> free_in x (Forall x1 p) \\<Longrightarrow>\n    semantics e f g (Forall x1 p) = semantics (e(x := v)) f g (Forall x1 p)", "by simp (metis fun_upd_twist fun_upd_upd)"], ["proof (state)\nthis:\n  \\<not> free_in x (Forall x1 p) \\<Longrightarrow>\n  semantics e f g (Forall x1 p) = semantics (e(x := v)) f g (Forall x1 p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length2_equiv:\n  \"length2 l \\<longleftrightarrow> [hd l, hd (tl l)] = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length2 l = ([hd l, hd (tl l)] = l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length2 l = ([hd l, hd (tl l)] = l)", "have \"length2 l \\<Longrightarrow> [hd l, hd (tl l)] = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length2 l \\<Longrightarrow> [hd l, hd (tl l)] = l", "unfolding length2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case l of [] \\<Rightarrow> False | [x] \\<Rightarrow> False\n    | [x, xa] \\<Rightarrow> True\n    | x # xa # ab # list \\<Rightarrow> False \\<Longrightarrow>\n    [hd l, hd (tl l)] = l", "using list.case_eq_if list.exhaust_sel"], ["proof (prove)\nusing this:\n  (case ?list of [] \\<Rightarrow> ?f1.0 | x # xa \\<Rightarrow> ?f2.0 x xa) =\n  (if ?list = [] then ?f1.0 else ?f2.0 (hd ?list) (tl ?list))\n  \\<lbrakk>?list = [] \\<Longrightarrow> ?P;\n   ?list = hd ?list # tl ?list \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. case l of [] \\<Rightarrow> False | [x] \\<Rightarrow> False\n    | [x, xa] \\<Rightarrow> True\n    | x # xa # ab # list \\<Rightarrow> False \\<Longrightarrow>\n    [hd l, hd (tl l)] = l", "by metis"], ["proof (state)\nthis:\n  length2 l \\<Longrightarrow> [hd l, hd (tl l)] = l\n\ngoal (1 subgoal):\n 1. length2 l = ([hd l, hd (tl l)] = l)", "then"], ["proof (chain)\npicking this:\n  length2 l \\<Longrightarrow> [hd l, hd (tl l)] = l", "show ?thesis"], ["proof (prove)\nusing this:\n  length2 l \\<Longrightarrow> [hd l, hd (tl l)] = l\n\ngoal (1 subgoal):\n 1. length2 l = ([hd l, hd (tl l)] = l)", "unfolding length2_def"], ["proof (prove)\nusing this:\n  case l of [] \\<Rightarrow> False | [x] \\<Rightarrow> False\n  | [x, xa] \\<Rightarrow> True\n  | x # xa # ab # list \\<Rightarrow> False \\<Longrightarrow>\n  [hd l, hd (tl l)] = l\n\ngoal (1 subgoal):\n 1. (case l of [] \\<Rightarrow> False | [x] \\<Rightarrow> False\n     | [x, xa] \\<Rightarrow> True\n     | x # xa # ab # list \\<Rightarrow> False) =\n    ([hd l, hd (tl l)] = l)", "using list.case list.case_eq_if"], ["proof (prove)\nusing this:\n  case l of [] \\<Rightarrow> False | [x] \\<Rightarrow> False\n  | [x, xa] \\<Rightarrow> True\n  | x # xa # ab # list \\<Rightarrow> False \\<Longrightarrow>\n  [hd l, hd (tl l)] = l\n  (case [] of [] \\<Rightarrow> ?f1.0 | x # xa \\<Rightarrow> ?f2.0 x xa) =\n  ?f1.0\n  (case ?x21.0 # ?x22.0 of [] \\<Rightarrow> ?f1.0\n   | x # xa \\<Rightarrow> ?f2.0 x xa) =\n  ?f2.0 ?x21.0 ?x22.0\n  (case ?list of [] \\<Rightarrow> ?f1.0 | x # xa \\<Rightarrow> ?f2.0 x xa) =\n  (if ?list = [] then ?f1.0 else ?f2.0 (hd ?list) (tl ?list))\n\ngoal (1 subgoal):\n 1. (case l of [] \\<Rightarrow> False | [x] \\<Rightarrow> False\n     | [x, xa] \\<Rightarrow> True\n     | x # xa # ab # list \\<Rightarrow> False) =\n    ([hd l, hd (tl l)] = l)", "by metis"], ["proof (state)\nthis:\n  length2 l = ([hd l, hd (tl l)] = l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma equal_length_sym:\n  \"equal_length l l' \\<Longrightarrow> equal_length l' l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_length l l' \\<Longrightarrow> equal_length l' l", "proof (induct l' arbitrary: l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l. equal_length l [] \\<Longrightarrow> equal_length [] l\n 2. \\<And>a l' l.\n       \\<lbrakk>\\<And>l.\n                   equal_length l l' \\<Longrightarrow> equal_length l' l;\n        equal_length l (a # l')\\<rbrakk>\n       \\<Longrightarrow> equal_length (a # l') l", "fix l"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l. equal_length l [] \\<Longrightarrow> equal_length [] l\n 2. \\<And>a l' l.\n       \\<lbrakk>\\<And>l.\n                   equal_length l l' \\<Longrightarrow> equal_length l' l;\n        equal_length l (a # l')\\<rbrakk>\n       \\<Longrightarrow> equal_length (a # l') l", "assume \"equal_length l []\""], ["proof (state)\nthis:\n  equal_length l []\n\ngoal (2 subgoals):\n 1. \\<And>l. equal_length l [] \\<Longrightarrow> equal_length [] l\n 2. \\<And>a l' l.\n       \\<lbrakk>\\<And>l.\n                   equal_length l l' \\<Longrightarrow> equal_length l' l;\n        equal_length l (a # l')\\<rbrakk>\n       \\<Longrightarrow> equal_length (a # l') l", "then"], ["proof (chain)\npicking this:\n  equal_length l []", "show \"equal_length [] l\""], ["proof (prove)\nusing this:\n  equal_length l []\n\ngoal (1 subgoal):\n 1. equal_length [] l", "using equal_length.simps list.case_eq_if"], ["proof (prove)\nusing this:\n  equal_length l []\n  equal_length ?l [] =\n  (case ?l of [] \\<Rightarrow> True | x # xa \\<Rightarrow> False)\n  equal_length ?l (?uu # ?r') =\n  (case ?l of [] \\<Rightarrow> False\n   | x # l' \\<Rightarrow> equal_length l' ?r')\n  (case ?list of [] \\<Rightarrow> ?f1.0 | x # xa \\<Rightarrow> ?f2.0 x xa) =\n  (if ?list = [] then ?f1.0 else ?f2.0 (hd ?list) (tl ?list))\n\ngoal (1 subgoal):\n 1. equal_length [] l", "by metis"], ["proof (state)\nthis:\n  equal_length [] l\n\ngoal (1 subgoal):\n 1. \\<And>a l' l.\n       \\<lbrakk>\\<And>l.\n                   equal_length l l' \\<Longrightarrow> equal_length l' l;\n        equal_length l (a # l')\\<rbrakk>\n       \\<Longrightarrow> equal_length (a # l') l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l' l.\n       \\<lbrakk>\\<And>l.\n                   equal_length l l' \\<Longrightarrow> equal_length l' l;\n        equal_length l (a # l')\\<rbrakk>\n       \\<Longrightarrow> equal_length (a # l') l", "fix l l' a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l' l.\n       \\<lbrakk>\\<And>l.\n                   equal_length l l' \\<Longrightarrow> equal_length l' l;\n        equal_length l (a # l')\\<rbrakk>\n       \\<Longrightarrow> equal_length (a # l') l", "assume sym: \"equal_length l l' \\<Longrightarrow> equal_length l' l\" for l"], ["proof (state)\nthis:\n  equal_length ?l l' \\<Longrightarrow> equal_length l' ?l\n\ngoal (1 subgoal):\n 1. \\<And>a l' l.\n       \\<lbrakk>\\<And>l.\n                   equal_length l l' \\<Longrightarrow> equal_length l' l;\n        equal_length l (a # l')\\<rbrakk>\n       \\<Longrightarrow> equal_length (a # l') l", "assume \"equal_length l (a # l')\""], ["proof (state)\nthis:\n  equal_length l (a # l')\n\ngoal (1 subgoal):\n 1. \\<And>a l' l.\n       \\<lbrakk>\\<And>l.\n                   equal_length l l' \\<Longrightarrow> equal_length l' l;\n        equal_length l (a # l')\\<rbrakk>\n       \\<Longrightarrow> equal_length (a # l') l", "then"], ["proof (chain)\npicking this:\n  equal_length l (a # l')", "show \"equal_length (a # l') l\""], ["proof (prove)\nusing this:\n  equal_length l (a # l')\n\ngoal (1 subgoal):\n 1. equal_length (a # l') l", "using equal_length.simps list.case_eq_if list.collapse list.inject sym"], ["proof (prove)\nusing this:\n  equal_length l (a # l')\n  equal_length ?l [] =\n  (case ?l of [] \\<Rightarrow> True | x # xa \\<Rightarrow> False)\n  equal_length ?l (?uu # ?r') =\n  (case ?l of [] \\<Rightarrow> False\n   | x # l' \\<Rightarrow> equal_length l' ?r')\n  (case ?list of [] \\<Rightarrow> ?f1.0 | x # xa \\<Rightarrow> ?f2.0 x xa) =\n  (if ?list = [] then ?f1.0 else ?f2.0 (hd ?list) (tl ?list))\n  ?list \\<noteq> [] \\<Longrightarrow> hd ?list # tl ?list = ?list\n  (?x21.0 # ?x22.0 = ?y21.0 # ?y22.0) =\n  (?x21.0 = ?y21.0 \\<and> ?x22.0 = ?y22.0)\n  equal_length ?l l' \\<Longrightarrow> equal_length l' ?l\n\ngoal (1 subgoal):\n 1. equal_length (a # l') l", "by metis"], ["proof (state)\nthis:\n  equal_length (a # l') l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma equal_length2:\n  \"equal_length l l' \\<Longrightarrow> length2 l \\<longleftrightarrow> length2 l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_length l l' \\<Longrightarrow> length2 l = length2 l'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. equal_length l l' \\<Longrightarrow> length2 l = length2 l'", "assume assm: \"equal_length l l'\""], ["proof (state)\nthis:\n  equal_length l l'\n\ngoal (1 subgoal):\n 1. equal_length l l' \\<Longrightarrow> length2 l = length2 l'", "have \"equal_length l [t, t'] \\<Longrightarrow> length2 l\" for t t'"], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_length l [t, t'] \\<Longrightarrow> length2 l", "unfolding length2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_length l [t, t'] \\<Longrightarrow>\n    case l of [] \\<Rightarrow> False | [x] \\<Rightarrow> False\n    | [x, xa] \\<Rightarrow> True | x # xa # ab # list \\<Rightarrow> False", "using equal_length.simps list.case_eq_if"], ["proof (prove)\nusing this:\n  equal_length ?l [] =\n  (case ?l of [] \\<Rightarrow> True | x # xa \\<Rightarrow> False)\n  equal_length ?l (?uu # ?r') =\n  (case ?l of [] \\<Rightarrow> False\n   | x # l' \\<Rightarrow> equal_length l' ?r')\n  (case ?list of [] \\<Rightarrow> ?f1.0 | x # xa \\<Rightarrow> ?f2.0 x xa) =\n  (if ?list = [] then ?f1.0 else ?f2.0 (hd ?list) (tl ?list))\n\ngoal (1 subgoal):\n 1. equal_length l [t, t'] \\<Longrightarrow>\n    case l of [] \\<Rightarrow> False | [x] \\<Rightarrow> False\n    | [x, xa] \\<Rightarrow> True | x # xa # ab # list \\<Rightarrow> False", "by metis"], ["proof (state)\nthis:\n  equal_length l [?t, ?t'] \\<Longrightarrow> length2 l\n\ngoal (1 subgoal):\n 1. equal_length l l' \\<Longrightarrow> length2 l = length2 l'", "moreover"], ["proof (state)\nthis:\n  equal_length l [?t, ?t'] \\<Longrightarrow> length2 l\n\ngoal (1 subgoal):\n 1. equal_length l l' \\<Longrightarrow> length2 l = length2 l'", "have \"equal_length [t, t'] l' \\<Longrightarrow> length2 l'\" for t t'"], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_length [t, t'] l' \\<Longrightarrow> length2 l'", "unfolding length2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_length [t, t'] l' \\<Longrightarrow>\n    case l' of [] \\<Rightarrow> False | [x] \\<Rightarrow> False\n    | [x, xa] \\<Rightarrow> True | x # xa # ab # list \\<Rightarrow> False", "using equal_length.simps list.case_eq_if equal_length_sym"], ["proof (prove)\nusing this:\n  equal_length ?l [] =\n  (case ?l of [] \\<Rightarrow> True | x # xa \\<Rightarrow> False)\n  equal_length ?l (?uu # ?r') =\n  (case ?l of [] \\<Rightarrow> False\n   | x # l' \\<Rightarrow> equal_length l' ?r')\n  (case ?list of [] \\<Rightarrow> ?f1.0 | x # xa \\<Rightarrow> ?f2.0 x xa) =\n  (if ?list = [] then ?f1.0 else ?f2.0 (hd ?list) (tl ?list))\n  equal_length ?l ?l' \\<Longrightarrow> equal_length ?l' ?l\n\ngoal (1 subgoal):\n 1. equal_length [t, t'] l' \\<Longrightarrow>\n    case l' of [] \\<Rightarrow> False | [x] \\<Rightarrow> False\n    | [x, xa] \\<Rightarrow> True | x # xa # ab # list \\<Rightarrow> False", "by metis"], ["proof (state)\nthis:\n  equal_length [?t, ?t'] l' \\<Longrightarrow> length2 l'\n\ngoal (1 subgoal):\n 1. equal_length l l' \\<Longrightarrow> length2 l = length2 l'", "ultimately"], ["proof (chain)\npicking this:\n  equal_length l [?t, ?t'] \\<Longrightarrow> length2 l\n  equal_length [?t, ?t'] l' \\<Longrightarrow> length2 l'", "show ?thesis"], ["proof (prove)\nusing this:\n  equal_length l [?t, ?t'] \\<Longrightarrow> length2 l\n  equal_length [?t, ?t'] l' \\<Longrightarrow> length2 l'\n\ngoal (1 subgoal):\n 1. length2 l = length2 l'", "using assm length2_equiv"], ["proof (prove)\nusing this:\n  equal_length l [?t, ?t'] \\<Longrightarrow> length2 l\n  equal_length [?t, ?t'] l' \\<Longrightarrow> length2 l'\n  equal_length l l'\n  length2 ?l = ([hd ?l, hd (tl ?l)] = ?l)\n\ngoal (1 subgoal):\n 1. length2 l = length2 l'", "by metis"], ["proof (state)\nthis:\n  length2 l = length2 l'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma imp_chain_equiv:\n  \"semantics e f g (foldr Imp l p) \\<longleftrightarrow> (\\<forall>q \\<in> set l. semantics e f g q) \\<longrightarrow> semantics e f g p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (foldr Imp l p) =\n    ((\\<forall>q\\<in>set l. semantics e f g q) \\<longrightarrow>\n     semantics e f g p)", "using imp_conjL"], ["proof (prove)\nusing this:\n  (?P \\<and> ?Q \\<longrightarrow> ?R) =\n  (?P \\<longrightarrow> ?Q \\<longrightarrow> ?R)\n\ngoal (1 subgoal):\n 1. semantics e f g (foldr Imp l p) =\n    ((\\<forall>q\\<in>set l. semantics e f g q) \\<longrightarrow>\n     semantics e f g p)", "by (induct l) simp_all"], ["", "lemma imp_chain_zip_eq:\n  \"equal_length l l' \\<Longrightarrow>\n      semantics e f g (foldr Imp (zip_eq l l') p) \\<longleftrightarrow>\n      semantics_list e f l = semantics_list e f l' \\<longrightarrow> semantics e f g p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_length l l' \\<Longrightarrow>\n    semantics e f g (foldr Imp (zip_eq l l') p) =\n    (semantics_list e f l = semantics_list e f l' \\<longrightarrow>\n     semantics e f g p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. equal_length l l' \\<Longrightarrow>\n    semantics e f g (foldr Imp (zip_eq l l') p) =\n    (semantics_list e f l = semantics_list e f l' \\<longrightarrow>\n     semantics e f g p)", "assume \"equal_length l l'\""], ["proof (state)\nthis:\n  equal_length l l'\n\ngoal (1 subgoal):\n 1. equal_length l l' \\<Longrightarrow>\n    semantics e f g (foldr Imp (zip_eq l l') p) =\n    (semantics_list e f l = semantics_list e f l' \\<longrightarrow>\n     semantics e f g p)", "then"], ["proof (chain)\npicking this:\n  equal_length l l'", "have \"(\\<forall>q \\<in> set (zip_eq l l'). semantics e f g q) \\<longleftrightarrow>\n      semantics_list e f l = semantics_list e f l'\""], ["proof (prove)\nusing this:\n  equal_length l l'\n\ngoal (1 subgoal):\n 1. (\\<forall>q\\<in>set (zip_eq l l'). semantics e f g q) =\n    (semantics_list e f l = semantics_list e f l')", "unfolding zip_eq_def"], ["proof (prove)\nusing this:\n  equal_length l l'\n\ngoal (1 subgoal):\n 1. (\\<forall>q\\<in>set (map2 (\\<lambda>t t'. Atom (Rl STR ''='' [t, t'])) l\n                          l').\n        semantics e f g q) =\n    (semantics_list e f l = semantics_list e f l')", "using length2_def"], ["proof (prove)\nusing this:\n  equal_length l l'\n  length2 ?l \\<equiv>\n  case ?l of [] \\<Rightarrow> False | [x] \\<Rightarrow> False\n  | [x, xa] \\<Rightarrow> True | x # xa # ab # list \\<Rightarrow> False\n\ngoal (1 subgoal):\n 1. (\\<forall>q\\<in>set (map2 (\\<lambda>t t'. Atom (Rl STR ''='' [t, t'])) l\n                          l').\n        semantics e f g q) =\n    (semantics_list e f l = semantics_list e f l')", "by (induct l l' rule: list_induct2') simp_all"], ["proof (state)\nthis:\n  (\\<forall>q\\<in>set (zip_eq l l'). semantics e f g q) =\n  (semantics_list e f l = semantics_list e f l')\n\ngoal (1 subgoal):\n 1. equal_length l l' \\<Longrightarrow>\n    semantics e f g (foldr Imp (zip_eq l l') p) =\n    (semantics_list e f l = semantics_list e f l' \\<longrightarrow>\n     semantics e f g p)", "then"], ["proof (chain)\npicking this:\n  (\\<forall>q\\<in>set (zip_eq l l'). semantics e f g q) =\n  (semantics_list e f l = semantics_list e f l')", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<forall>q\\<in>set (zip_eq l l'). semantics e f g q) =\n  (semantics_list e f l = semantics_list e f l')\n\ngoal (1 subgoal):\n 1. semantics e f g (foldr Imp (zip_eq l l') p) =\n    (semantics_list e f l = semantics_list e f l' \\<longrightarrow>\n     semantics e f g p)", "using imp_chain_equiv"], ["proof (prove)\nusing this:\n  (\\<forall>q\\<in>set (zip_eq l l'). semantics e f g q) =\n  (semantics_list e f l = semantics_list e f l')\n  semantics ?e ?f ?g (foldr Imp ?l ?p) =\n  ((\\<forall>q\\<in>set ?l. semantics ?e ?f ?g q) \\<longrightarrow>\n   semantics ?e ?f ?g ?p)\n\ngoal (1 subgoal):\n 1. semantics e f g (foldr Imp (zip_eq l l') p) =\n    (semantics_list e f l = semantics_list e f l' \\<longrightarrow>\n     semantics e f g p)", "by iprover"], ["proof (state)\nthis:\n  semantics e f g (foldr Imp (zip_eq l l') p) =\n  (semantics_list e f l = semantics_list e f l' \\<longrightarrow>\n   semantics e f g p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma funcong:\n  \"equal_length l l' \\<Longrightarrow>\n      semantics e f g (foldr Imp (zip_eq l l') (Atom (Rl (STR ''='') [Fn i l, Fn i l'])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_length l l' \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Atom (Rl STR ''='' [Fn i l, Fn i l'])))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. equal_length l l' \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Atom (Rl STR ''='' [Fn i l, Fn i l'])))", "assume assm: \"equal_length l l'\""], ["proof (state)\nthis:\n  equal_length l l'\n\ngoal (1 subgoal):\n 1. equal_length l l' \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Atom (Rl STR ''='' [Fn i l, Fn i l'])))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g\n     (foldr Imp (zip_eq l l') (Atom (Rl STR ''='' [Fn i l, Fn i l'])))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Atom (Rl STR ''='' [Fn i l, Fn i l'])))\n 2. \\<not> ?P \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Atom (Rl STR ''='' [Fn i l, Fn i l'])))", "assume \"semantics_list e f l = semantics_list e f l'\""], ["proof (state)\nthis:\n  semantics_list e f l = semantics_list e f l'\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Atom (Rl STR ''='' [Fn i l, Fn i l'])))\n 2. \\<not> ?P \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Atom (Rl STR ''='' [Fn i l, Fn i l'])))", "then"], ["proof (chain)\npicking this:\n  semantics_list e f l = semantics_list e f l'", "have \"semantics e f g (Atom (Rl (STR ''='') [Fn i l, Fn i l']))\""], ["proof (prove)\nusing this:\n  semantics_list e f l = semantics_list e f l'\n\ngoal (1 subgoal):\n 1. semantics e f g (Atom (Rl STR ''='' [Fn i l, Fn i l']))", "using length2_def"], ["proof (prove)\nusing this:\n  semantics_list e f l = semantics_list e f l'\n  length2 ?l \\<equiv>\n  case ?l of [] \\<Rightarrow> False | [x] \\<Rightarrow> False\n  | [x, xa] \\<Rightarrow> True | x # xa # ab # list \\<Rightarrow> False\n\ngoal (1 subgoal):\n 1. semantics e f g (Atom (Rl STR ''='' [Fn i l, Fn i l']))", "by simp"], ["proof (state)\nthis:\n  semantics e f g (Atom (Rl STR ''='' [Fn i l, Fn i l']))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Atom (Rl STR ''='' [Fn i l, Fn i l'])))\n 2. \\<not> ?P \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Atom (Rl STR ''='' [Fn i l, Fn i l'])))", "then"], ["proof (chain)\npicking this:\n  semantics e f g (Atom (Rl STR ''='' [Fn i l, Fn i l']))", "show ?thesis"], ["proof (prove)\nusing this:\n  semantics e f g (Atom (Rl STR ''='' [Fn i l, Fn i l']))\n\ngoal (1 subgoal):\n 1. semantics e f g\n     (foldr Imp (zip_eq l l') (Atom (Rl STR ''='' [Fn i l, Fn i l'])))", "using imp_chain_equiv"], ["proof (prove)\nusing this:\n  semantics e f g (Atom (Rl STR ''='' [Fn i l, Fn i l']))\n  semantics ?e ?f ?g (foldr Imp ?l ?p) =\n  ((\\<forall>q\\<in>set ?l. semantics ?e ?f ?g q) \\<longrightarrow>\n   semantics ?e ?f ?g ?p)\n\ngoal (1 subgoal):\n 1. semantics e f g\n     (foldr Imp (zip_eq l l') (Atom (Rl STR ''='' [Fn i l, Fn i l'])))", "by iprover"], ["proof (state)\nthis:\n  semantics e f g\n   (foldr Imp (zip_eq l l') (Atom (Rl STR ''='' [Fn i l, Fn i l'])))\n\ngoal (1 subgoal):\n 1. semantics_list e f l \\<noteq> semantics_list e f l' \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Atom (Rl STR ''='' [Fn i l, Fn i l'])))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. semantics_list e f l \\<noteq> semantics_list e f l' \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Atom (Rl STR ''='' [Fn i l, Fn i l'])))", "assume \"semantics_list e f l \\<noteq> semantics_list e f l'\""], ["proof (state)\nthis:\n  semantics_list e f l \\<noteq> semantics_list e f l'\n\ngoal (1 subgoal):\n 1. semantics_list e f l \\<noteq> semantics_list e f l' \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Atom (Rl STR ''='' [Fn i l, Fn i l'])))", "then"], ["proof (chain)\npicking this:\n  semantics_list e f l \\<noteq> semantics_list e f l'", "show ?thesis"], ["proof (prove)\nusing this:\n  semantics_list e f l \\<noteq> semantics_list e f l'\n\ngoal (1 subgoal):\n 1. semantics e f g\n     (foldr Imp (zip_eq l l') (Atom (Rl STR ''='' [Fn i l, Fn i l'])))", "using assm imp_chain_zip_eq"], ["proof (prove)\nusing this:\n  semantics_list e f l \\<noteq> semantics_list e f l'\n  equal_length l l'\n  equal_length ?l ?l' \\<Longrightarrow>\n  semantics ?e ?f ?g (foldr Imp (zip_eq ?l ?l') ?p) =\n  (semantics_list ?e ?f ?l = semantics_list ?e ?f ?l' \\<longrightarrow>\n   semantics ?e ?f ?g ?p)\n\ngoal (1 subgoal):\n 1. semantics e f g\n     (foldr Imp (zip_eq l l') (Atom (Rl STR ''='' [Fn i l, Fn i l'])))", "by iprover"], ["proof (state)\nthis:\n  semantics e f g\n   (foldr Imp (zip_eq l l') (Atom (Rl STR ''='' [Fn i l, Fn i l'])))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  semantics e f g\n   (foldr Imp (zip_eq l l') (Atom (Rl STR ''='' [Fn i l, Fn i l'])))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma predcong:\n  \"equal_length l l' \\<Longrightarrow>\n      semantics e f g (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_length l l' \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. equal_length l l' \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "assume assm: \"equal_length l l'\""], ["proof (state)\nthis:\n  equal_length l l'\n\ngoal (1 subgoal):\n 1. equal_length l l' \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))\n 2. \\<not> ?P \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "assume eq: \"i = STR ''='' \\<and> length2 l \\<and> length2 l'\""], ["proof (state)\nthis:\n  i = STR ''='' \\<and> length2 l \\<and> length2 l'\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))\n 2. \\<not> ?P \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))\n 2. \\<not> ?P \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "assume \"semantics_list e f l = semantics_list e f l'\""], ["proof (state)\nthis:\n  semantics_list e f l = semantics_list e f l'\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))\n 2. \\<not> ?P \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "then"], ["proof (chain)\npicking this:\n  semantics_list e f l = semantics_list e f l'", "have \"semantics_list e f [hd l, hd (tl l)] = semantics_list e f [hd l', hd (tl l')]\""], ["proof (prove)\nusing this:\n  semantics_list e f l = semantics_list e f l'\n\ngoal (1 subgoal):\n 1. semantics_list e f [hd l, hd (tl l)] =\n    semantics_list e f [hd l', hd (tl l')]", "using eq length2_equiv"], ["proof (prove)\nusing this:\n  semantics_list e f l = semantics_list e f l'\n  i = STR ''='' \\<and> length2 l \\<and> length2 l'\n  length2 ?l = ([hd ?l, hd (tl ?l)] = ?l)\n\ngoal (1 subgoal):\n 1. semantics_list e f [hd l, hd (tl l)] =\n    semantics_list e f [hd l', hd (tl l')]", "by simp"], ["proof (state)\nthis:\n  semantics_list e f [hd l, hd (tl l)] =\n  semantics_list e f [hd l', hd (tl l')]\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))\n 2. \\<not> ?P \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "then"], ["proof (chain)\npicking this:\n  semantics_list e f [hd l, hd (tl l)] =\n  semantics_list e f [hd l', hd (tl l')]", "have \"semantics e f g (Imp (Atom (Rl (STR ''='') l)) (Atom (Rl (STR ''='') l')))\""], ["proof (prove)\nusing this:\n  semantics_list e f [hd l, hd (tl l)] =\n  semantics_list e f [hd l', hd (tl l')]\n\ngoal (1 subgoal):\n 1. semantics e f g (Imp (Atom (Rl STR ''='' l)) (Atom (Rl STR ''='' l')))", "using eq"], ["proof (prove)\nusing this:\n  semantics_list e f [hd l, hd (tl l)] =\n  semantics_list e f [hd l', hd (tl l')]\n  i = STR ''='' \\<and> length2 l \\<and> length2 l'\n\ngoal (1 subgoal):\n 1. semantics e f g (Imp (Atom (Rl STR ''='' l)) (Atom (Rl STR ''='' l')))", "by simp"], ["proof (state)\nthis:\n  semantics e f g (Imp (Atom (Rl STR ''='' l)) (Atom (Rl STR ''='' l')))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))\n 2. \\<not> ?P \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "then"], ["proof (chain)\npicking this:\n  semantics e f g (Imp (Atom (Rl STR ''='' l)) (Atom (Rl STR ''='' l')))", "show ?thesis"], ["proof (prove)\nusing this:\n  semantics e f g (Imp (Atom (Rl STR ''='' l)) (Atom (Rl STR ''='' l')))\n\ngoal (1 subgoal):\n 1. semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "using eq imp_chain_equiv"], ["proof (prove)\nusing this:\n  semantics e f g (Imp (Atom (Rl STR ''='' l)) (Atom (Rl STR ''='' l')))\n  i = STR ''='' \\<and> length2 l \\<and> length2 l'\n  semantics ?e ?f ?g (foldr Imp ?l ?p) =\n  ((\\<forall>q\\<in>set ?l. semantics ?e ?f ?g q) \\<longrightarrow>\n   semantics ?e ?f ?g ?p)\n\ngoal (1 subgoal):\n 1. semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "by iprover"], ["proof (state)\nthis:\n  semantics e f g\n   (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))\n\ngoal (1 subgoal):\n 1. semantics_list e f l \\<noteq> semantics_list e f l' \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. semantics_list e f l \\<noteq> semantics_list e f l' \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "assume \"semantics_list e f l \\<noteq> semantics_list e f l'\""], ["proof (state)\nthis:\n  semantics_list e f l \\<noteq> semantics_list e f l'\n\ngoal (1 subgoal):\n 1. semantics_list e f l \\<noteq> semantics_list e f l' \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "then"], ["proof (chain)\npicking this:\n  semantics_list e f l \\<noteq> semantics_list e f l'", "show ?thesis"], ["proof (prove)\nusing this:\n  semantics_list e f l \\<noteq> semantics_list e f l'\n\ngoal (1 subgoal):\n 1. semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "using assm imp_chain_zip_eq"], ["proof (prove)\nusing this:\n  semantics_list e f l \\<noteq> semantics_list e f l'\n  equal_length l l'\n  equal_length ?l ?l' \\<Longrightarrow>\n  semantics ?e ?f ?g (foldr Imp (zip_eq ?l ?l') ?p) =\n  (semantics_list ?e ?f ?l = semantics_list ?e ?f ?l' \\<longrightarrow>\n   semantics ?e ?f ?g ?p)\n\ngoal (1 subgoal):\n 1. semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "by iprover"], ["proof (state)\nthis:\n  semantics e f g\n   (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  semantics e f g\n   (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))\n\ngoal (1 subgoal):\n 1. \\<not> (i = STR ''='' \\<and>\n            length2 l \\<and> length2 l') \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (i = STR ''='' \\<and>\n            length2 l \\<and> length2 l') \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "assume not_eq: \"\\<not> (i = STR ''='' \\<and> length2 l \\<and> length2 l')\""], ["proof (state)\nthis:\n  \\<not> (i = STR ''='' \\<and> length2 l \\<and> length2 l')\n\ngoal (1 subgoal):\n 1. \\<not> (i = STR ''='' \\<and>\n            length2 l \\<and> length2 l') \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))\n 2. \\<not> ?P \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "assume \"semantics_list e f l = semantics_list e f l'\""], ["proof (state)\nthis:\n  semantics_list e f l = semantics_list e f l'\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))\n 2. \\<not> ?P \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "then"], ["proof (chain)\npicking this:\n  semantics_list e f l = semantics_list e f l'", "have \"semantics e f g (Imp (Atom (Rl i l)) (Atom (Rl i l')))\""], ["proof (prove)\nusing this:\n  semantics_list e f l = semantics_list e f l'\n\ngoal (1 subgoal):\n 1. semantics e f g (Imp (Atom (Rl i l)) (Atom (Rl i l')))", "using assm not_eq equal_length2"], ["proof (prove)\nusing this:\n  semantics_list e f l = semantics_list e f l'\n  equal_length l l'\n  \\<not> (i = STR ''='' \\<and> length2 l \\<and> length2 l')\n  equal_length ?l ?l' \\<Longrightarrow> length2 ?l = length2 ?l'\n\ngoal (1 subgoal):\n 1. semantics e f g (Imp (Atom (Rl i l)) (Atom (Rl i l')))", "by simp iprover"], ["proof (state)\nthis:\n  semantics e f g (Imp (Atom (Rl i l)) (Atom (Rl i l')))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))\n 2. \\<not> ?P \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "then"], ["proof (chain)\npicking this:\n  semantics e f g (Imp (Atom (Rl i l)) (Atom (Rl i l')))", "show ?thesis"], ["proof (prove)\nusing this:\n  semantics e f g (Imp (Atom (Rl i l)) (Atom (Rl i l')))\n\ngoal (1 subgoal):\n 1. semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "using imp_chain_equiv"], ["proof (prove)\nusing this:\n  semantics e f g (Imp (Atom (Rl i l)) (Atom (Rl i l')))\n  semantics ?e ?f ?g (foldr Imp ?l ?p) =\n  ((\\<forall>q\\<in>set ?l. semantics ?e ?f ?g q) \\<longrightarrow>\n   semantics ?e ?f ?g ?p)\n\ngoal (1 subgoal):\n 1. semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "by iprover"], ["proof (state)\nthis:\n  semantics e f g\n   (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))\n\ngoal (1 subgoal):\n 1. semantics_list e f l \\<noteq> semantics_list e f l' \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. semantics_list e f l \\<noteq> semantics_list e f l' \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "assume \"semantics_list e f l \\<noteq> semantics_list e f l'\""], ["proof (state)\nthis:\n  semantics_list e f l \\<noteq> semantics_list e f l'\n\ngoal (1 subgoal):\n 1. semantics_list e f l \\<noteq> semantics_list e f l' \\<Longrightarrow>\n    semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "then"], ["proof (chain)\npicking this:\n  semantics_list e f l \\<noteq> semantics_list e f l'", "show ?thesis"], ["proof (prove)\nusing this:\n  semantics_list e f l \\<noteq> semantics_list e f l'\n\ngoal (1 subgoal):\n 1. semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "using assm imp_chain_zip_eq"], ["proof (prove)\nusing this:\n  semantics_list e f l \\<noteq> semantics_list e f l'\n  equal_length l l'\n  equal_length ?l ?l' \\<Longrightarrow>\n  semantics ?e ?f ?g (foldr Imp (zip_eq ?l ?l') ?p) =\n  (semantics_list ?e ?f ?l = semantics_list ?e ?f ?l' \\<longrightarrow>\n   semantics ?e ?f ?g ?p)\n\ngoal (1 subgoal):\n 1. semantics e f g\n     (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))", "by iprover"], ["proof (state)\nthis:\n  semantics e f g\n   (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  semantics e f g\n   (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  semantics e f g\n   (foldr Imp (zip_eq l l') (Imp (Atom (Rl i l)) (Atom (Rl i l'))))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem soundness:\n  \"\\<turnstile> p \\<Longrightarrow> semantics e f g p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile> p \\<Longrightarrow> semantics e f g p", "proof (induct arbitrary: e rule: OK.induct)"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>s s' e.\n       \\<lbrakk>\\<turnstile> concl s; \\<And>e. semantics e f g (concl s);\n        \\<turnstile> concl s'; \\<And>e. semantics e f g (concl s')\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (concl (modusponens s s'))\n 2. \\<And>s uu_ e.\n       \\<lbrakk>\\<turnstile> concl s;\n        \\<And>e. semantics e f g (concl s)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (concl (gen uu_ s))\n 3. \\<And>uv_ uw_ e. semantics e f g (concl (axiom_addimp uv_ uw_))\n 4. \\<And>ux_ uy_ uz_ e.\n       semantics e f g (concl (axiom_distribimp ux_ uy_ uz_))\n 5. \\<And>va_ e. semantics e f g (concl (axiom_doubleneg va_))\n 6. \\<And>vb_ vc_ vd_ e. semantics e f g (concl (axiom_allimp vb_ vc_ vd_))\n 7. \\<And>ve_ vf_ e. semantics e f g (concl (axiom_impall ve_ vf_))\n 8. \\<And>vg_ vh_ e. semantics e f g (concl (axiom_existseq vg_ vh_))\n 9. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 10. \\<And>vj_ vk_ vl_ e.\n        semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\nA total of 19 subgoals...", "fix e s s'"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>s s' e.\n       \\<lbrakk>\\<turnstile> concl s; \\<And>e. semantics e f g (concl s);\n        \\<turnstile> concl s'; \\<And>e. semantics e f g (concl s')\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (concl (modusponens s s'))\n 2. \\<And>s uu_ e.\n       \\<lbrakk>\\<turnstile> concl s;\n        \\<And>e. semantics e f g (concl s)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (concl (gen uu_ s))\n 3. \\<And>uv_ uw_ e. semantics e f g (concl (axiom_addimp uv_ uw_))\n 4. \\<And>ux_ uy_ uz_ e.\n       semantics e f g (concl (axiom_distribimp ux_ uy_ uz_))\n 5. \\<And>va_ e. semantics e f g (concl (axiom_doubleneg va_))\n 6. \\<And>vb_ vc_ vd_ e. semantics e f g (concl (axiom_allimp vb_ vc_ vd_))\n 7. \\<And>ve_ vf_ e. semantics e f g (concl (axiom_impall ve_ vf_))\n 8. \\<And>vg_ vh_ e. semantics e f g (concl (axiom_existseq vg_ vh_))\n 9. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 10. \\<And>vj_ vk_ vl_ e.\n        semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\nA total of 19 subgoals...", "assume \"semantics e f g (concl s)\" \"semantics e f g (concl s')\" for e"], ["proof (state)\nthis:\n  semantics ?e f g (concl s)\n  semantics ?e f g (concl s')\n\ngoal (19 subgoals):\n 1. \\<And>s s' e.\n       \\<lbrakk>\\<turnstile> concl s; \\<And>e. semantics e f g (concl s);\n        \\<turnstile> concl s'; \\<And>e. semantics e f g (concl s')\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (concl (modusponens s s'))\n 2. \\<And>s uu_ e.\n       \\<lbrakk>\\<turnstile> concl s;\n        \\<And>e. semantics e f g (concl s)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (concl (gen uu_ s))\n 3. \\<And>uv_ uw_ e. semantics e f g (concl (axiom_addimp uv_ uw_))\n 4. \\<And>ux_ uy_ uz_ e.\n       semantics e f g (concl (axiom_distribimp ux_ uy_ uz_))\n 5. \\<And>va_ e. semantics e f g (concl (axiom_doubleneg va_))\n 6. \\<And>vb_ vc_ vd_ e. semantics e f g (concl (axiom_allimp vb_ vc_ vd_))\n 7. \\<And>ve_ vf_ e. semantics e f g (concl (axiom_impall ve_ vf_))\n 8. \\<And>vg_ vh_ e. semantics e f g (concl (axiom_existseq vg_ vh_))\n 9. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 10. \\<And>vj_ vk_ vl_ e.\n        semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\nA total of 19 subgoals...", "then"], ["proof (chain)\npicking this:\n  semantics ?e f g (concl s)\n  semantics ?e f g (concl s')", "show \"semantics e f g (concl (modusponens s s'))\""], ["proof (prove)\nusing this:\n  semantics ?e f g (concl s)\n  semantics ?e f g (concl s')\n\ngoal (1 subgoal):\n 1. semantics e f g (concl (modusponens s s'))", "unfolding modusponens_def"], ["proof (prove)\nusing this:\n  semantics ?e f g (concl s)\n  semantics ?e f g (concl s')\n\ngoal (1 subgoal):\n 1. semantics e f g\n     (concl\n       (case concl s of\n        Imp p q \\<Rightarrow>\n          let p' = concl s' in if fol_equal p p' then Thm q else Thm Truth\n        | _ \\<Rightarrow> Thm Truth))", "proof (cases s)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>e. semantics e f g (concl s);\n        \\<And>e. semantics e f g (concl s'); s = Thm x\\<rbrakk>\n       \\<Longrightarrow> semantics e f g\n                          (concl\n                            (case concl s of\n                             Imp p q \\<Rightarrow>\n                               let p' = concl s'\n                               in if fol_equal p p' then Thm q\n                                  else Thm Truth\n                             | _ \\<Rightarrow> Thm Truth))", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>e. semantics e f g (concl s);\n        \\<And>e. semantics e f g (concl s'); s = Thm x\\<rbrakk>\n       \\<Longrightarrow> semantics e f g\n                          (concl\n                            (case concl s of\n                             Imp p q \\<Rightarrow>\n                               let p' = concl s'\n                               in if fol_equal p p' then Thm q\n                                  else Thm Truth\n                             | _ \\<Rightarrow> Thm Truth))", "assume \"semantics e f g (concl s)\" \"semantics e f g (concl s')\" \"s = Thm r\" for e"], ["proof (state)\nthis:\n  semantics ?e f g (concl s)\n  semantics ?e f g (concl s')\n  s = Thm r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>e. semantics e f g (concl s);\n        \\<And>e. semantics e f g (concl s'); s = Thm x\\<rbrakk>\n       \\<Longrightarrow> semantics e f g\n                          (concl\n                            (case concl s of\n                             Imp p q \\<Rightarrow>\n                               let p' = concl s'\n                               in if fol_equal p p' then Thm q\n                                  else Thm Truth\n                             | _ \\<Rightarrow> Thm Truth))", "then"], ["proof (chain)\npicking this:\n  semantics ?e f g (concl s)\n  semantics ?e f g (concl s')\n  s = Thm r", "show \"semantics e f g (concl (case (concl s) of Imp p q \\<Rightarrow>\n        let p' = concl s' in if fol_equal p p' then Thm q else fail_thm | _ \\<Rightarrow> fail_thm))\""], ["proof (prove)\nusing this:\n  semantics ?e f g (concl s)\n  semantics ?e f g (concl s')\n  s = Thm r\n\ngoal (1 subgoal):\n 1. semantics e f g\n     (concl\n       (case concl s of\n        Imp p q \\<Rightarrow>\n          let p' = concl s' in if fol_equal p p' then Thm q else Thm Truth\n        | _ \\<Rightarrow> Thm Truth))", "unfolding fol_equal_def"], ["proof (prove)\nusing this:\n  semantics ?e f g (concl s)\n  semantics ?e f g (concl s')\n  s = Thm r\n\ngoal (1 subgoal):\n 1. semantics e f g\n     (concl\n       (case concl s of\n        Imp p q \\<Rightarrow>\n          let p' = concl s' in if p = p' then Thm q else Thm Truth\n        | _ \\<Rightarrow> Thm Truth))", "by (cases r) simp_all"], ["proof (state)\nthis:\n  semantics e f g\n   (concl\n     (case concl s of\n      Imp p q \\<Rightarrow>\n        let p' = concl s' in if fol_equal p p' then Thm q else Thm Truth\n      | _ \\<Rightarrow> Thm Truth))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  semantics e f g (concl (modusponens s s'))\n\ngoal (18 subgoals):\n 1. \\<And>s uu_ e.\n       \\<lbrakk>\\<turnstile> concl s;\n        \\<And>e. semantics e f g (concl s)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (concl (gen uu_ s))\n 2. \\<And>uv_ uw_ e. semantics e f g (concl (axiom_addimp uv_ uw_))\n 3. \\<And>ux_ uy_ uz_ e.\n       semantics e f g (concl (axiom_distribimp ux_ uy_ uz_))\n 4. \\<And>va_ e. semantics e f g (concl (axiom_doubleneg va_))\n 5. \\<And>vb_ vc_ vd_ e. semantics e f g (concl (axiom_allimp vb_ vc_ vd_))\n 6. \\<And>ve_ vf_ e. semantics e f g (concl (axiom_impall ve_ vf_))\n 7. \\<And>vg_ vh_ e. semantics e f g (concl (axiom_existseq vg_ vh_))\n 8. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 9. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 10. \\<And>vm_ vn_ vo_ e.\n        semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>s uu_ e.\n       \\<lbrakk>\\<turnstile> concl s;\n        \\<And>e. semantics e f g (concl s)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (concl (gen uu_ s))\n 2. \\<And>uv_ uw_ e. semantics e f g (concl (axiom_addimp uv_ uw_))\n 3. \\<And>ux_ uy_ uz_ e.\n       semantics e f g (concl (axiom_distribimp ux_ uy_ uz_))\n 4. \\<And>va_ e. semantics e f g (concl (axiom_doubleneg va_))\n 5. \\<And>vb_ vc_ vd_ e. semantics e f g (concl (axiom_allimp vb_ vc_ vd_))\n 6. \\<And>ve_ vf_ e. semantics e f g (concl (axiom_impall ve_ vf_))\n 7. \\<And>vg_ vh_ e. semantics e f g (concl (axiom_existseq vg_ vh_))\n 8. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 9. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 10. \\<And>vm_ vn_ vo_ e.\n        semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\nA total of 18 subgoals...", "fix e x s"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>s uu_ e.\n       \\<lbrakk>\\<turnstile> concl s;\n        \\<And>e. semantics e f g (concl s)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (concl (gen uu_ s))\n 2. \\<And>uv_ uw_ e. semantics e f g (concl (axiom_addimp uv_ uw_))\n 3. \\<And>ux_ uy_ uz_ e.\n       semantics e f g (concl (axiom_distribimp ux_ uy_ uz_))\n 4. \\<And>va_ e. semantics e f g (concl (axiom_doubleneg va_))\n 5. \\<And>vb_ vc_ vd_ e. semantics e f g (concl (axiom_allimp vb_ vc_ vd_))\n 6. \\<And>ve_ vf_ e. semantics e f g (concl (axiom_impall ve_ vf_))\n 7. \\<And>vg_ vh_ e. semantics e f g (concl (axiom_existseq vg_ vh_))\n 8. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 9. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 10. \\<And>vm_ vn_ vo_ e.\n        semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\nA total of 18 subgoals...", "assume \"semantics e f g (concl s)\" for e"], ["proof (state)\nthis:\n  semantics ?e f g (concl s)\n\ngoal (18 subgoals):\n 1. \\<And>s uu_ e.\n       \\<lbrakk>\\<turnstile> concl s;\n        \\<And>e. semantics e f g (concl s)\\<rbrakk>\n       \\<Longrightarrow> semantics e f g (concl (gen uu_ s))\n 2. \\<And>uv_ uw_ e. semantics e f g (concl (axiom_addimp uv_ uw_))\n 3. \\<And>ux_ uy_ uz_ e.\n       semantics e f g (concl (axiom_distribimp ux_ uy_ uz_))\n 4. \\<And>va_ e. semantics e f g (concl (axiom_doubleneg va_))\n 5. \\<And>vb_ vc_ vd_ e. semantics e f g (concl (axiom_allimp vb_ vc_ vd_))\n 6. \\<And>ve_ vf_ e. semantics e f g (concl (axiom_impall ve_ vf_))\n 7. \\<And>vg_ vh_ e. semantics e f g (concl (axiom_existseq vg_ vh_))\n 8. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 9. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 10. \\<And>vm_ vn_ vo_ e.\n        semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\nA total of 18 subgoals...", "then"], ["proof (chain)\npicking this:\n  semantics ?e f g (concl s)", "show \"semantics e f g (concl (gen x s))\""], ["proof (prove)\nusing this:\n  semantics ?e f g (concl s)\n\ngoal (1 subgoal):\n 1. semantics e f g (concl (gen x s))", "unfolding gen_def"], ["proof (prove)\nusing this:\n  semantics ?e f g (concl s)\n\ngoal (1 subgoal):\n 1. semantics e f g (concl (Thm (Forall x (concl s))))", "by simp"], ["proof (state)\nthis:\n  semantics e f g (concl (gen x s))\n\ngoal (17 subgoals):\n 1. \\<And>uv_ uw_ e. semantics e f g (concl (axiom_addimp uv_ uw_))\n 2. \\<And>ux_ uy_ uz_ e.\n       semantics e f g (concl (axiom_distribimp ux_ uy_ uz_))\n 3. \\<And>va_ e. semantics e f g (concl (axiom_doubleneg va_))\n 4. \\<And>vb_ vc_ vd_ e. semantics e f g (concl (axiom_allimp vb_ vc_ vd_))\n 5. \\<And>ve_ vf_ e. semantics e f g (concl (axiom_impall ve_ vf_))\n 6. \\<And>vg_ vh_ e. semantics e f g (concl (axiom_existseq vg_ vh_))\n 7. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 8. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 9. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 10. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>uv_ uw_ e. semantics e f g (concl (axiom_addimp uv_ uw_))\n 2. \\<And>ux_ uy_ uz_ e.\n       semantics e f g (concl (axiom_distribimp ux_ uy_ uz_))\n 3. \\<And>va_ e. semantics e f g (concl (axiom_doubleneg va_))\n 4. \\<And>vb_ vc_ vd_ e. semantics e f g (concl (axiom_allimp vb_ vc_ vd_))\n 5. \\<And>ve_ vf_ e. semantics e f g (concl (axiom_impall ve_ vf_))\n 6. \\<And>vg_ vh_ e. semantics e f g (concl (axiom_existseq vg_ vh_))\n 7. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 8. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 9. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 10. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\nA total of 17 subgoals...", "fix e p q"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>uv_ uw_ e. semantics e f g (concl (axiom_addimp uv_ uw_))\n 2. \\<And>ux_ uy_ uz_ e.\n       semantics e f g (concl (axiom_distribimp ux_ uy_ uz_))\n 3. \\<And>va_ e. semantics e f g (concl (axiom_doubleneg va_))\n 4. \\<And>vb_ vc_ vd_ e. semantics e f g (concl (axiom_allimp vb_ vc_ vd_))\n 5. \\<And>ve_ vf_ e. semantics e f g (concl (axiom_impall ve_ vf_))\n 6. \\<And>vg_ vh_ e. semantics e f g (concl (axiom_existseq vg_ vh_))\n 7. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 8. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 9. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 10. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\nA total of 17 subgoals...", "show \"semantics e f g (concl (axiom_addimp p q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (concl (axiom_addimp p q))", "unfolding axiom_addimp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (concl (Thm (Imp p (Imp q p))))", "by simp"], ["proof (state)\nthis:\n  semantics e f g (concl (axiom_addimp p q))\n\ngoal (16 subgoals):\n 1. \\<And>ux_ uy_ uz_ e.\n       semantics e f g (concl (axiom_distribimp ux_ uy_ uz_))\n 2. \\<And>va_ e. semantics e f g (concl (axiom_doubleneg va_))\n 3. \\<And>vb_ vc_ vd_ e. semantics e f g (concl (axiom_allimp vb_ vc_ vd_))\n 4. \\<And>ve_ vf_ e. semantics e f g (concl (axiom_impall ve_ vf_))\n 5. \\<And>vg_ vh_ e. semantics e f g (concl (axiom_existseq vg_ vh_))\n 6. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 7. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 8. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 9. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 10. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>ux_ uy_ uz_ e.\n       semantics e f g (concl (axiom_distribimp ux_ uy_ uz_))\n 2. \\<And>va_ e. semantics e f g (concl (axiom_doubleneg va_))\n 3. \\<And>vb_ vc_ vd_ e. semantics e f g (concl (axiom_allimp vb_ vc_ vd_))\n 4. \\<And>ve_ vf_ e. semantics e f g (concl (axiom_impall ve_ vf_))\n 5. \\<And>vg_ vh_ e. semantics e f g (concl (axiom_existseq vg_ vh_))\n 6. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 7. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 8. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 9. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 10. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\nA total of 16 subgoals...", "fix e p q r"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>ux_ uy_ uz_ e.\n       semantics e f g (concl (axiom_distribimp ux_ uy_ uz_))\n 2. \\<And>va_ e. semantics e f g (concl (axiom_doubleneg va_))\n 3. \\<And>vb_ vc_ vd_ e. semantics e f g (concl (axiom_allimp vb_ vc_ vd_))\n 4. \\<And>ve_ vf_ e. semantics e f g (concl (axiom_impall ve_ vf_))\n 5. \\<And>vg_ vh_ e. semantics e f g (concl (axiom_existseq vg_ vh_))\n 6. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 7. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 8. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 9. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 10. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\nA total of 16 subgoals...", "show \"semantics e f g (concl (axiom_distribimp p q r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (concl (axiom_distribimp p q r))", "unfolding axiom_distribimp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g\n     (concl (Thm (Imp (Imp p (Imp q r)) (Imp (Imp p q) (Imp p r)))))", "by simp"], ["proof (state)\nthis:\n  semantics e f g (concl (axiom_distribimp p q r))\n\ngoal (15 subgoals):\n 1. \\<And>va_ e. semantics e f g (concl (axiom_doubleneg va_))\n 2. \\<And>vb_ vc_ vd_ e. semantics e f g (concl (axiom_allimp vb_ vc_ vd_))\n 3. \\<And>ve_ vf_ e. semantics e f g (concl (axiom_impall ve_ vf_))\n 4. \\<And>vg_ vh_ e. semantics e f g (concl (axiom_existseq vg_ vh_))\n 5. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 6. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 7. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 8. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 9. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 10. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>va_ e. semantics e f g (concl (axiom_doubleneg va_))\n 2. \\<And>vb_ vc_ vd_ e. semantics e f g (concl (axiom_allimp vb_ vc_ vd_))\n 3. \\<And>ve_ vf_ e. semantics e f g (concl (axiom_impall ve_ vf_))\n 4. \\<And>vg_ vh_ e. semantics e f g (concl (axiom_existseq vg_ vh_))\n 5. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 6. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 7. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 8. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 9. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 10. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\nA total of 15 subgoals...", "fix e g p"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>va_ e. semantics e f g (concl (axiom_doubleneg va_))\n 2. \\<And>vb_ vc_ vd_ e. semantics e f g (concl (axiom_allimp vb_ vc_ vd_))\n 3. \\<And>ve_ vf_ e. semantics e f g (concl (axiom_impall ve_ vf_))\n 4. \\<And>vg_ vh_ e. semantics e f g (concl (axiom_existseq vg_ vh_))\n 5. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 6. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 7. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 8. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 9. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 10. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\nA total of 15 subgoals...", "show \"semantics e f g (concl (axiom_doubleneg p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (concl (axiom_doubleneg p))", "unfolding axiom_doubleneg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (concl (Thm (Imp (Imp (Imp p Falsity) Falsity) p)))", "by simp"], ["proof (state)\nthis:\n  semantics e f g (concl (axiom_doubleneg p))\n\ngoal (14 subgoals):\n 1. \\<And>vb_ vc_ vd_ e. semantics e f g (concl (axiom_allimp vb_ vc_ vd_))\n 2. \\<And>ve_ vf_ e. semantics e f g (concl (axiom_impall ve_ vf_))\n 3. \\<And>vg_ vh_ e. semantics e f g (concl (axiom_existseq vg_ vh_))\n 4. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 5. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 6. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 7. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 8. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 9. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 10. \\<And>e. semantics e f g (concl axiom_true)\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>vb_ vc_ vd_ e. semantics e f g (concl (axiom_allimp vb_ vc_ vd_))\n 2. \\<And>ve_ vf_ e. semantics e f g (concl (axiom_impall ve_ vf_))\n 3. \\<And>vg_ vh_ e. semantics e f g (concl (axiom_existseq vg_ vh_))\n 4. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 5. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 6. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 7. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 8. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 9. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 10. \\<And>e. semantics e f g (concl axiom_true)\nA total of 14 subgoals...", "fix e x p q"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>vb_ vc_ vd_ e. semantics e f g (concl (axiom_allimp vb_ vc_ vd_))\n 2. \\<And>ve_ vf_ e. semantics e f g (concl (axiom_impall ve_ vf_))\n 3. \\<And>vg_ vh_ e. semantics e f g (concl (axiom_existseq vg_ vh_))\n 4. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 5. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 6. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 7. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 8. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 9. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 10. \\<And>e. semantics e f g (concl axiom_true)\nA total of 14 subgoals...", "show \"semantics e f g (concl (axiom_allimp x p q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (concl (axiom_allimp x p q))", "unfolding axiom_allimp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g\n     (concl\n       (Thm (Imp (Forall x (Imp p q)) (Imp (Forall x p) (Forall x q)))))", "by simp"], ["proof (state)\nthis:\n  semantics e f g (concl (axiom_allimp x p q))\n\ngoal (13 subgoals):\n 1. \\<And>ve_ vf_ e. semantics e f g (concl (axiom_impall ve_ vf_))\n 2. \\<And>vg_ vh_ e. semantics e f g (concl (axiom_existseq vg_ vh_))\n 3. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 4. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 5. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 6. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 7. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 8. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 9. \\<And>e. semantics e f g (concl axiom_true)\n 10. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>ve_ vf_ e. semantics e f g (concl (axiom_impall ve_ vf_))\n 2. \\<And>vg_ vh_ e. semantics e f g (concl (axiom_existseq vg_ vh_))\n 3. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 4. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 5. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 6. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 7. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 8. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 9. \\<And>e. semantics e f g (concl axiom_true)\n 10. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\nA total of 13 subgoals...", "fix e x p"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>ve_ vf_ e. semantics e f g (concl (axiom_impall ve_ vf_))\n 2. \\<And>vg_ vh_ e. semantics e f g (concl (axiom_existseq vg_ vh_))\n 3. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 4. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 5. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 6. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 7. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 8. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 9. \\<And>e. semantics e f g (concl axiom_true)\n 10. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\nA total of 13 subgoals...", "show \"semantics e f g (concl (axiom_impall x p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (concl (axiom_impall x p))", "unfolding axiom_impall_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g\n     (concl\n       (if \\<not> free_in x p then Thm (Imp p (Forall x p)) else Thm Truth))", "using map"], ["proof (prove)\nusing this:\n  \\<not> free_in ?x ?p \\<Longrightarrow>\n  semantics ?e ?f ?g ?p = semantics (?e(?x := ?v)) ?f ?g ?p\n\ngoal (1 subgoal):\n 1. semantics e f g\n     (concl\n       (if \\<not> free_in x p then Thm (Imp p (Forall x p)) else Thm Truth))", "by simp iprover"], ["proof (state)\nthis:\n  semantics e f g (concl (axiom_impall x p))\n\ngoal (12 subgoals):\n 1. \\<And>vg_ vh_ e. semantics e f g (concl (axiom_existseq vg_ vh_))\n 2. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 3. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 4. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 5. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 6. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 7. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 8. \\<And>e. semantics e f g (concl axiom_true)\n 9. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 10. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>vg_ vh_ e. semantics e f g (concl (axiom_existseq vg_ vh_))\n 2. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 3. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 4. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 5. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 6. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 7. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 8. \\<And>e. semantics e f g (concl axiom_true)\n 9. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 10. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\nA total of 12 subgoals...", "fix e x t"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>vg_ vh_ e. semantics e f g (concl (axiom_existseq vg_ vh_))\n 2. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 3. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 4. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 5. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 6. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 7. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 8. \\<And>e. semantics e f g (concl axiom_true)\n 9. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 10. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\nA total of 12 subgoals...", "show \"semantics e f g (concl (axiom_existseq x t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (concl (axiom_existseq x t))", "unfolding axiom_existseq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g\n     (concl\n       (if \\<not> occurs_in x t\n        then Thm (Exists x (Atom (Rl STR ''='' [Var x, t])))\n        else Thm Truth))", "using map'(1) length2_def"], ["proof (prove)\nusing this:\n  \\<not> occurs_in ?x ?t \\<Longrightarrow>\n  semantics_term ?e ?f ?t = semantics_term (?e(?x := ?v)) ?f ?t\n  length2 ?l \\<equiv>\n  case ?l of [] \\<Rightarrow> False | [x] \\<Rightarrow> False\n  | [x, xa] \\<Rightarrow> True | x # xa # ab # list \\<Rightarrow> False\n\ngoal (1 subgoal):\n 1. semantics e f g\n     (concl\n       (if \\<not> occurs_in x t\n        then Thm (Exists x (Atom (Rl STR ''='' [Var x, t])))\n        else Thm Truth))", "by simp iprover"], ["proof (state)\nthis:\n  semantics e f g (concl (axiom_existseq x t))\n\ngoal (11 subgoals):\n 1. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 2. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 3. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 4. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 5. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 6. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 7. \\<And>e. semantics e f g (concl axiom_true)\n 8. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 9. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 10. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 2. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 3. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 4. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 5. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 6. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 7. \\<And>e. semantics e f g (concl axiom_true)\n 8. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 9. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 10. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\nA total of 11 subgoals...", "fix e t"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>vi_ e. semantics e f g (concl (axiom_eqrefl vi_))\n 2. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 3. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 4. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 5. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 6. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 7. \\<And>e. semantics e f g (concl axiom_true)\n 8. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 9. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 10. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\nA total of 11 subgoals...", "show \"semantics e f g (concl (axiom_eqrefl t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (concl (axiom_eqrefl t))", "unfolding axiom_eqrefl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (concl (Thm (Atom (Rl STR ''='' [t, t]))))", "using length2_def"], ["proof (prove)\nusing this:\n  length2 ?l \\<equiv>\n  case ?l of [] \\<Rightarrow> False | [x] \\<Rightarrow> False\n  | [x, xa] \\<Rightarrow> True | x # xa # ab # list \\<Rightarrow> False\n\ngoal (1 subgoal):\n 1. semantics e f g (concl (Thm (Atom (Rl STR ''='' [t, t]))))", "by simp"], ["proof (state)\nthis:\n  semantics e f g (concl (axiom_eqrefl t))\n\ngoal (10 subgoals):\n 1. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 2. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 3. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 4. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 5. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 6. \\<And>e. semantics e f g (concl axiom_true)\n 7. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 8. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 9. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 10. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 2. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 3. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 4. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 5. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 6. \\<And>e. semantics e f g (concl axiom_true)\n 7. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 8. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 9. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 10. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "fix e i l l'"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>vj_ vk_ vl_ e. semantics e f g (concl (axiom_funcong vj_ vk_ vl_))\n 2. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 3. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 4. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 5. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 6. \\<And>e. semantics e f g (concl axiom_true)\n 7. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 8. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 9. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 10. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "show \"semantics e f g (concl (axiom_funcong i l l'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (concl (axiom_funcong i l l'))", "unfolding axiom_funcong_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g\n     (concl\n       (if equal_length l l'\n        then Thm (foldr Imp (zip_eq l l')\n                   (Atom (Rl STR ''='' [Fn i l, Fn i l'])))\n        else Thm Truth))", "using funcong"], ["proof (prove)\nusing this:\n  equal_length ?l ?l' \\<Longrightarrow>\n  semantics ?e ?f ?g\n   (foldr Imp (zip_eq ?l ?l') (Atom (Rl STR ''='' [Fn ?i ?l, Fn ?i ?l'])))\n\ngoal (1 subgoal):\n 1. semantics e f g\n     (concl\n       (if equal_length l l'\n        then Thm (foldr Imp (zip_eq l l')\n                   (Atom (Rl STR ''='' [Fn i l, Fn i l'])))\n        else Thm Truth))", "by simp standard"], ["proof (state)\nthis:\n  semantics e f g (concl (axiom_funcong i l l'))\n\ngoal (9 subgoals):\n 1. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 2. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 3. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 4. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 5. \\<And>e. semantics e f g (concl axiom_true)\n 6. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 7. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 8. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 9. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 2. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 3. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 4. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 5. \\<And>e. semantics e f g (concl axiom_true)\n 6. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 7. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 8. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 9. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "fix e i l l'"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>vm_ vn_ vo_ e.\n       semantics e f g (concl (axiom_predcong vm_ vn_ vo_))\n 2. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 3. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 4. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 5. \\<And>e. semantics e f g (concl axiom_true)\n 6. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 7. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 8. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 9. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "show \"semantics e f g (concl (axiom_predcong i l l'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (concl (axiom_predcong i l l'))", "unfolding axiom_predcong_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g\n     (concl\n       (if equal_length l l'\n        then Thm (foldr Imp (zip_eq l l')\n                   (Imp (Atom (Rl i l)) (Atom (Rl i l'))))\n        else Thm Truth))", "using predcong"], ["proof (prove)\nusing this:\n  equal_length ?l ?l' \\<Longrightarrow>\n  semantics ?e ?f ?g\n   (foldr Imp (zip_eq ?l ?l') (Imp (Atom (Rl ?i ?l)) (Atom (Rl ?i ?l'))))\n\ngoal (1 subgoal):\n 1. semantics e f g\n     (concl\n       (if equal_length l l'\n        then Thm (foldr Imp (zip_eq l l')\n                   (Imp (Atom (Rl i l)) (Atom (Rl i l'))))\n        else Thm Truth))", "by simp standard"], ["proof (state)\nthis:\n  semantics e f g (concl (axiom_predcong i l l'))\n\ngoal (8 subgoals):\n 1. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 2. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 3. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 4. \\<And>e. semantics e f g (concl axiom_true)\n 5. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 6. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 7. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 8. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 2. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 3. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 4. \\<And>e. semantics e f g (concl axiom_true)\n 5. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 6. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 7. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 8. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "fix e p q"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>vp_ vq_ e. semantics e f g (concl (axiom_iffimp1 vp_ vq_))\n 2. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 3. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 4. \\<And>e. semantics e f g (concl axiom_true)\n 5. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 6. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 7. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 8. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "show \"semantics e f g (concl (axiom_iffimp1 p q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (concl (axiom_iffimp1 p q))", "unfolding axiom_iffimp1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (concl (Thm (Imp (Iff p q) (Imp p q))))", "by simp"], ["proof (state)\nthis:\n  semantics e f g (concl (axiom_iffimp1 p q))\n\ngoal (7 subgoals):\n 1. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 2. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 3. \\<And>e. semantics e f g (concl axiom_true)\n 4. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 5. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 6. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 7. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 2. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 3. \\<And>e. semantics e f g (concl axiom_true)\n 4. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 5. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 6. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 7. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "fix e p q"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>vr_ vs_ e. semantics e f g (concl (axiom_iffimp2 vr_ vs_))\n 2. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 3. \\<And>e. semantics e f g (concl axiom_true)\n 4. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 5. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 6. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 7. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "show \"semantics e f g (concl (axiom_iffimp2 p q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (concl (axiom_iffimp2 p q))", "unfolding axiom_iffimp2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (concl (Thm (Imp (Iff p q) (Imp q p))))", "by simp"], ["proof (state)\nthis:\n  semantics e f g (concl (axiom_iffimp2 p q))\n\ngoal (6 subgoals):\n 1. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 2. \\<And>e. semantics e f g (concl axiom_true)\n 3. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 4. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 5. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 6. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 2. \\<And>e. semantics e f g (concl axiom_true)\n 3. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 4. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 5. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 6. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "fix e p q"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>vt_ vu_ e. semantics e f g (concl (axiom_impiff vt_ vu_))\n 2. \\<And>e. semantics e f g (concl axiom_true)\n 3. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 4. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 5. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 6. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "show \"semantics e f g (concl (axiom_impiff p q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (concl (axiom_impiff p q))", "unfolding axiom_impiff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (concl (Thm (Imp (Imp p q) (Imp (Imp q p) (Iff p q)))))", "by (simp add: iffI)"], ["proof (state)\nthis:\n  semantics e f g (concl (axiom_impiff p q))\n\ngoal (5 subgoals):\n 1. \\<And>e. semantics e f g (concl axiom_true)\n 2. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 3. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 4. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 5. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e. semantics e f g (concl axiom_true)\n 2. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 3. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 4. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 5. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "fix e"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>e. semantics e f g (concl axiom_true)\n 2. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 3. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 4. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 5. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "show \"semantics e f g (concl (axiom_true))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (concl axiom_true)", "unfolding axiom_true_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (concl (Thm (Iff Truth (Imp Falsity Falsity))))", "by simp"], ["proof (state)\nthis:\n  semantics e f g (concl axiom_true)\n\ngoal (4 subgoals):\n 1. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 2. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 3. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 4. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 2. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 3. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 4. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "fix e p"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>vv_ e. semantics e f g (concl (axiom_not vv_))\n 2. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 3. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 4. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "show \"semantics e f g (concl (axiom_not p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (concl (axiom_not p))", "unfolding axiom_not_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (concl (Thm (Iff (fm.Not p) (Imp p Falsity))))", "by simp"], ["proof (state)\nthis:\n  semantics e f g (concl (axiom_not p))\n\ngoal (3 subgoals):\n 1. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 2. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 3. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 2. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 3. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "fix e p q"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>vw_ vx_ e. semantics e f g (concl (axiom_and vw_ vx_))\n 2. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 3. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "show \"semantics e f g (concl (axiom_and p q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (concl (axiom_and p q))", "unfolding axiom_and_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g\n     (concl (Thm (Iff (And p q) (Imp (Imp p (Imp q Falsity)) Falsity))))", "by simp"], ["proof (state)\nthis:\n  semantics e f g (concl (axiom_and p q))\n\ngoal (2 subgoals):\n 1. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 2. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 2. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "fix e p q"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vy_ vz_ e. semantics e f g (concl (axiom_or vy_ vz_))\n 2. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "show \"semantics e f g (concl (axiom_or p q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (concl (axiom_or p q))", "unfolding axiom_or_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g\n     (concl (Thm (Iff (Or p q) (fm.Not (And (fm.Not p) (fm.Not q))))))", "by simp"], ["proof (state)\nthis:\n  semantics e f g (concl (axiom_or p q))\n\ngoal (1 subgoal):\n 1. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "fix e x p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>wa_ wb_ e. semantics e f g (concl (axiom_exists wa_ wb_))", "show \"semantics e f g (concl (axiom_exists x p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g (concl (axiom_exists x p))", "unfolding axiom_exists_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics e f g\n     (concl (Thm (Iff (Exists x p) (fm.Not (Forall x (fm.Not p))))))", "by simp"], ["proof (state)\nthis:\n  semantics e f g (concl (axiom_exists x p))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary \"\\<not> (\\<turnstile> Falsity)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<turnstile> Falsity)", "using soundness"], ["proof (prove)\nusing this:\n  \\<turnstile> ?p \\<Longrightarrow> semantics ?e ?f ?g ?p\n\ngoal (1 subgoal):\n 1. \\<not> (\\<turnstile> Falsity)", "by fastforce"], ["", "section \\<open>ML Code Reflection\\<close>"], ["", "code_reflect\n  Proven\ndatatypes\n  fm = Falsity | Truth | Atom | Imp | Iff | And | Or | Not | Exists | Forall\nand\n  tm = Var | Fn\nand\n  fol = Rl\nfunctions\n  modusponens gen axiom_addimp axiom_distribimp axiom_doubleneg axiom_allimp axiom_impall\n  axiom_existseq axiom_eqrefl axiom_funcong axiom_predcong axiom_iffimp1 axiom_iffimp2\n  axiom_impiff axiom_true axiom_not axiom_and axiom_or axiom_exists concl"], ["", "ML \\<open>open Proven\\<close>"], ["", "ML \\<open>val print = writeln (* Should not add newline but only used for testing (see XXX label) *)\\<close>"], ["", "ML \\<open>\"format_simple.sml\";\n\nfun set_margin _ = ();\n\nfun print_string x = print x;\n\nfun open_box _ = ();\n\nfun close_box () = ();\n\nfun print_space () = print \" \";\n\nfun print_break _ _ = ();\n\nfun open_hbox () = ();\n\nfun print_flush () = ();\n\nfun print_newline () = print \"\\n\";\n\nfun print_int n = print (Int.toString n);\n\nfun open_hvbox _ = ();\n\n\\<close>"], ["", "ML \\<open>\"lib.sml\";\n\n(* ========================================================================= *)\n(* Misc library functions to set up a nice environment.                      *)\n(* ========================================================================= *)\n\nfun str_ord s1 s2 =\n    case String.compare(s1,s2) of\n      EQUAL => 0    | GREATER => 1    | LESS  => ~1;\n\nfun sip_ord (f1,a1) (f2,a2) =\n    case str_ord f1 f2 of\n      0 => if a1>a2 then 1 else ~1\n    | n => n\n;\n\ninfix 6 lxor\ninfix 6 land\n\nfun to_int_fun f = fn a => fn b => Word.toIntX (f ((Word.fromInt a),(Word.fromInt b) ) );\n\nfun a lxor b = to_int_fun Word.xorb a b;\nfun a land b = to_int_fun Word.andb a b;\n\nfun list_hash elem_hash l=\n  let fun hash_code sval l =\n        case l of\n         [] => sval\n        | e::l' =>\n          let val e_hash = Word.fromInt (elem_hash e) in\n          hash_code (Word.+(Word.*(sval,0wx31),(e_hash))) l'\n          end\n  in\n  Word.toIntX(hash_code 0wx0 l)\n  end\n;\n\nfun str_hash str = list_hash Char.ord (String.explode str);\n\nfun fst (x,_) = x;\nfun snd (_,y) = y;\n\n(* ========================================================================= *)\n(* Misc library functions to set up a nice environment.                      *)\n(* ========================================================================= *)\n\nfun identity x = x;\n\n(* ------------------------------------------------------------------------- *)\n(* A useful idiom for \"non contradictory\" etc.                               *)\n(* ------------------------------------------------------------------------- *)\n\nfun non p x = not(p x);\n\n(* ------------------------------------------------------------------------- *)\n(* Kind of assertion checking.                                               *)\n(* ------------------------------------------------------------------------- *)\n\nfun check p x = if p(x) then x else raise Fail \"check\";\n\n(* ------------------------------------------------------------------------- *)\n(* Repetition of a function.                                                 *)\n(* ------------------------------------------------------------------------- *)\n\nfun funpow n f x =\n    if n < 1 then x\n    else funpow (n - 1) f (f x);\n\nfun can f x = (f x; true) handle Fail _ => false;\n\nfun repeat f x = repeat f (f x) handle Fail _ => x;\n\n(* ------------------------------------------------------------------------- *)\n(* Handy list operations.                                                    *)\n(* ------------------------------------------------------------------------- *)\n\ninfix 6 --\nfun m -- n = if m > n then [] else m::((m + 1) -- n);\n\nfun map2 f l1 l2 =\n  case (l1,l2) of\n    ([],[]) => []\n  | ((h1::t1),(h2::t2)) => let val h = f h1 h2 in h::(map2 f t1 t2) end\n  | _ => raise Fail \"map2: length mismatch\";\n\nfun itlist f l b = List.foldr (fn (x,y) => f x y) b l;\n\nfun end_itlist f l =\n  case l of\n        []     => raise Fail \"end_itlist\"\n      | [x]    => x\n      | (h::t) => f h (end_itlist f t);\n\nfun itlist2 f l1 l2 b =\n  case (l1,l2) of\n    ([],[]) => b\n  | (h1::t1,h2::t2) => f h1 h2 (itlist2 f t1 t2 b)\n  | _ => raise Fail \"itlist2\";\n\nfun zip l1 l2 =\n  case (l1,l2) of\n        ([],[]) => []\n      | (h1::t1,h2::t2) => (h1,h2)::(zip t1 t2)\n      | _ => raise Fail \"zip\";\n\nfun chop_list n l =\n  if n = 0 then ([],l) else\n  let val (m,l') = chop_list (n-1) (tl l) in ((hd l)::m,l') end\n  handle Fail _ => raise Fail \"chop_list\";\n\nfun index x =\n  let fun ind n l =\n    case l of\n      [] => raise Fail \"index\"\n    | (h::t) => if x = h then n else ind (n + 1) t\n  in\n    ind 0\n  end;\n\nfun unzip l =\n  case l of\n    [] => ([],[])\n  | (x,y)::t =>\n      let val (xs,ys) = unzip t in (x::xs,y::ys) end;\n\n(* ------------------------------------------------------------------------- *)\n(* Association lists.                                                        *)\n(* ------------------------------------------------------------------------- *)\n\nfun assoc a l =\n  case l of\n    (x,y)::t => if x = a then y else assoc a t\n  | [] => raise Fail \"find\";\n\n(* ------------------------------------------------------------------------- *)\n(* Merging of sorted lists (maintaining repetitions).                        *)\n(* ------------------------------------------------------------------------- *)\n\nfun merge ord l1 l2 =\n  case l1 of\n    [] => l2\n  | h1::t1 => case l2 of\n                [] => l1\n              | h2::t2 => if ord h1 h2 then h1::(merge ord t1 l2)\n                          else h2::(merge ord l1 t2);\n\n(* ------------------------------------------------------------------------- *)\n(* Bottom-up mergesort.                                                      *)\n(* ------------------------------------------------------------------------- *)\n\nfun sort ord =\n  let fun mergepairs l1 l2 =\n    case (l1,l2) of\n        ([s],[]) => s\n      | (l,[]) => mergepairs [] l\n      | (l,[s1]) => mergepairs (s1::l) []\n      | (l,(s1::s2::ss)) => mergepairs ((merge ord s1 s2)::l) ss in\n  fn l => if l = [] then [] else mergepairs [] (List.map (fn x => [x]) l)\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* Common measure predicates to use with \"sort\".                             *)\n(* ------------------------------------------------------------------------- *)\n\nfun increasing f x y = (f x) < (f y);\n\nfun decreasing f x y = (f x) > (f y) ;\n\n(* ------------------------------------------------------------------------- *)\n(* Eliminate repetitions of adjacent elements, with and without counting.    *)\n(* ------------------------------------------------------------------------- *)\n\nfun uniq l =\n    case l of\n      x :: (t as y :: ys ) =>\n        let val t' = uniq t in\n            if x = y then t'\n            else\n                x :: t'\n        end\n    | _ => l;\n\nfun tryfind f l =\n  case l of\n      [] => raise Fail \"tryfind\"\n    | (h::t) =>\n      ((f h) handle Fail _ => tryfind f t);\n\n(* ------------------------------------------------------------------------- *)\n(* Set operations on ordered lists.                                          *)\n(* ------------------------------------------------------------------------- *)\n\nfun setify ord l=\n  let fun canonical lis =\n     case lis of\n       x::(rest as y::_) => ord x y < 0 andalso canonical rest\n     | _ => true in\n  if canonical l then l\n  else uniq (sort (fn x => fn y => ord x y <= 0) l)\n  end;\n\nfun union ord s1 s2=\n  let fun union l1 l2 =\n    case (l1,l2) of\n        ([],l2) => l2\n      | (l1,[]) => l1\n      | ((l1 as h1::t1),(l2 as h2::t2)) =>\n          if h1 = h2 then h1::(union t1 t2)\n          else if ord h1 h2 = ~1 then h1::(union t1 l2)\n          else h2::(union l1 t2) in\n  union (setify ord s1) (setify ord s2)\n  end;\n\n fun union_str s1 s2 = union str_ord s1 s2;\n fun union_sip p1 p2 = union sip_ord p1 p2;\n\nfun subtract ord s1 s2=\n  let fun subtract l1 l2 =\n    case (l1,l2) of\n        ([],l2) => []\n      | (l1,[]) => l1\n      | ((l1 as h1::t1),(l2 as h2::t2)) =>\n          if h1 = h2 then subtract t1 t2\n          else if ord h1 h2 = ~1 then h1::(subtract t1 l2)\n          else subtract l1 t2 in\n  subtract (setify ord s1) (setify ord s2)\n  end;\n\nfun subtract_str s1 s2 = subtract str_ord s1 s2;\n\nfun insert ord x s = union ord [x] s;\n\nfun insert_str x s = insert str_ord x s;\n\n(* ------------------------------------------------------------------------- *)\n(* Union of a family of sets.                                                *)\n(* ------------------------------------------------------------------------- *)\n\nfun unions ord s =\n   let fun concat a b = a @ b in\n   setify ord (itlist concat s [])\n   end;\n\nfun unions_str s = unions str_ord s;\n\n(* ------------------------------------------------------------------------- *)\n(* List membership. This does *not* assume the list is a set.                *)\n(* ------------------------------------------------------------------------- *)\n\nfun mem x lis =\n    case lis of\n      [] => false\n    | hd :: tl => hd = x orelse mem x tl;\n\n(* ------------------------------------------------------------------------- *)\n(* Timing; useful for documentation but not logically necessary.             *)\n(* ------------------------------------------------------------------------- *)\n\nfun time f x =\n    let val timer = Timer.startRealTimer()\n        val result = f x\n        val time = Timer.checkRealTimer timer\n    in (\n    (* XXX print_string (\"CPU time (user): \" ^ (Real.toString (Time.toReal time)));\n    print_newline(); *)\n    result\n    ) end;\n\n(* ------------------------------------------------------------------------- *)\n(* Polymorphic finite partial functions via Patricia trees.                  *)\n(*                                                                           *)\n(* The point of this strange representation is that it is canonical (equal   *)\n(* functions have the same encoding) yet reasonably efficient on average.    *)\n(*                                                                           *)\n(* Idea due to Diego Olivier Fernandez Pons (OCaml list, 2003/11/10).        *)\n(* ------------------------------------------------------------------------- *)\n\ndatatype ('a,'b)func =\n   Empty\n | Leaf of int * ('a*'b)list\n | Branch of int * int * ('a,'b)func * ('a,'b)func;\n\n(* ------------------------------------------------------------------------- *)\n(* Undefined function.                                                       *)\n(* ------------------------------------------------------------------------- *)\n\nval undefined = Empty;\n\n(* ------------------------------------------------------------------------- *)\n(* In case of equality comparison worries, better use this.                  *)\n(* ------------------------------------------------------------------------- *)\n\nfun is_undefined f =\n  case f of\n    Empty => true\n  | _ => false;\n\n(* ------------------------------------------------------------------------- *)\n(* Operation analogous to \"map\" for lists.                                   *)\n(* ------------------------------------------------------------------------- *)\n\nlocal\n  fun map_list f l =\n        case l of\n          [] => []\n        | (x,y)::t => (x,f(y))::(map_list f t)\nin\n  fun mapf f t =\n        case t of\n          Empty => Empty\n        | Leaf(h,l) => Leaf(h,map_list f l)\n        | Branch(p,b,l,r) => Branch(p,b,mapf f l,mapf f r)\nend;\n\n(* ------------------------------------------------------------------------- *)\n(* Application.                                                              *)\n(* ------------------------------------------------------------------------- *)\n\nfun applyd ord hash f d x=\n  let fun apply_listd l d x =\n        case l of\n          (a,b)::t => if x = a then b else if ord x a > 0 then apply_listd t d x else d x\n        | [] => d x\n      val k = hash x\n      fun look t =\n        case t of\n          Leaf(h,l) =>\n            if (h = k) then\n              apply_listd l d x\n            else d x\n        | Branch(p,b,l,r) =>\n            if ((k lxor p) land (b - 1)) = 0 then\n              look (if k land b = 0 then l else r)\n            else d x\n        | _ => d x\n  in\n  look f\n  end\n;\n\nfun apply ord hash f = applyd ord hash f (fn x => raise Fail \"apply\");\n\nfun apply_str f = apply str_ord str_hash f;\n\nfun tryapplyd ord hash f a d = applyd ord hash f (fn x => d) a;\n\nfun tryapplyd_str f a d = tryapplyd str_ord str_hash f a d;\n\nfun tryapplyl ord hash f x = tryapplyd ord hash f x [];\n\nfun defined ord hash f x = (apply ord hash f x; true) handle Fail _ => false;\n\nfun defined_str f x = defined str_ord str_hash f x;\n\n(* ------------------------------------------------------------------------- *)\n(* Undefinition.                                                             *)\n(* ------------------------------------------------------------------------- *)\n\nlocal\n  fun undefine_list ord x l =\n    case l of\n      (ab as (a,b))::t =>\n          let val c = ord x a in\n          if c = 0 then\n            t\n          else if c < 0 then\n            l\n          else\n            let val t' = undefine_list ord x t in\n            ab::t'\n            end\n          end\n    | [] => []\nin\n  fun undefine ord hash x =\n    let val k = hash x\n        fun und t =\n          case t of\n            Leaf(h,l) =>\n              if h=k then (\n                let val l' = undefine_list ord x l in\n                if l' = l then t\n                else if l' = [] then Empty\n                else Leaf(h,l')\n                end\n              ) else t\n          | Branch(p,b,l,r) =>\n              if k land (b - 1) = p then (\n                if k land b = 0 then\n                  let val l' = und l in\n                  if l' = l then t\n                  else (case l' of Empty => r | _ => Branch(p,b,l',r))\n                  end\n                else\n                  let val r' = und r in\n                  if r' = r then t\n                  else (case r' of Empty => l | _ => Branch(p,b,l,r'))\n                  end\n              ) else t\n          | _ => t\n    in\n    und\n    end\nend;\n\nfun undefine_str x t = undefine str_ord str_hash x t\n\n(* ------------------------------------------------------------------------- *)\n(* Redefinition and combination.                                             *)\n(* ------------------------------------------------------------------------- *)\n\ninfix 6 |->\n\nlocal\n  fun newbranch p1 t1 p2 t2 =\n        let val zp = p1 lxor p2\n            val b = zp land (~zp)\n            val p = p1 land (b - 1) in\n        if p1 land b = 0 then Branch(p,b,t1,t2)\n        else Branch(p,b,t2,t1)\n        end\n  fun define_list ord (xy as (x,y)) l =\n        case l of\n          (ab as (a,b))::t =>\n              let val c = ord x a in\n              if c = 0 then xy::t\n              else if c < 0 then xy::l\n              else ab::(define_list ord xy t)\n              end\n        | [] => [xy]\n  fun combine_list ord op' z l1 l2 =\n        case (l1,l2) of\n          ([],_) => l2\n        | (_,[]) => l1\n        | ((xy1 as (x1,y1))::t1,(xy2 as (x2,y2))::t2) =>\n              let val c = ord x1 x2 in\n              if c < 0 then\n                xy1::(combine_list ord op' z t1 l2)\n              else if c > 0 then\n                xy2::(combine_list ord op' z l1 t2)\n              else\n                let val y = op' y1 y2\n                    val l = combine_list ord op' z t1 t2 in\n                if z(y) then l else (x1,y)::l\n                end\n              end\n  in\n  fun (x |-> y) t ord hash =\n        let val k = hash x\n            fun upd t =\n              case t of\n                Empty => Leaf (k,[(x,y)])\n              | Leaf(h,l) =>\n                   if h = k then Leaf(h,define_list ord (x,y) l)\n                   else newbranch h t k (Leaf(k,[(x,y)]))\n              | Branch(p,b,l,r) =>\n                  if k land (b - 1) <> p then newbranch p t k (Leaf(k,[(x,y)]))\n                  else if k land b = 0 then Branch(p,b,upd l,r)\n                  else Branch(p,b,l,upd r) in\n        upd t\n        end\n  fun combine ord op' z t1 t2 =\n        case (t1,t2) of\n          (Empty,_) => t2\n        | (_,Empty) => t1\n        | (Leaf(h1,l1),Leaf(h2,l2)) =>\n              if h1 = h2 then\n                let val l = combine_list ord op' z l1 l2 in\n                if l = [] then Empty else Leaf(h1,l)\n                end\n              else newbranch h1 t1 h2 t2\n        | ((lf as Leaf(k,lis)),(br as Branch(p,b,l,r))) =>\n              if k land (b - 1) = p then\n                if k land b = 0 then\n                  (case combine ord op' z lf l of\n                     Empty => r | l' => Branch(p,b,l',r))\n                else\n                  (case combine ord op' z lf r of\n                     Empty => l | r' => Branch(p,b,l,r'))\n              else\n                newbranch k lf p br\n        | ((br as Branch(p,b,l,r)),(lf as Leaf(k,lis))) =>\n              if k land (b - 1) = p then\n                if k land b = 0 then\n                  (case combine ord op' z l lf of\n                    Empty => r | l' => Branch(p,b,l',r))\n                else\n                  (case combine ord op' z r lf of\n                     Empty => l | r' => Branch(p,b,l,r'))\n              else\n                newbranch p br k lf\n        | (Branch(p1,b1,l1,r1),Branch(p2,b2,l2,r2)) =>\n              if b1 < b2 then\n                if p2 land (b1 - 1) <> p1 then newbranch p1 t1 p2 t2\n                else if p2 land b1 = 0 then\n                  (case combine ord op' z l1 t2 of\n                     Empty => r1 | l => Branch(p1,b1,l,r1))\n                else\n                  (case combine ord op' z r1 t2 of\n                     Empty => l1 | r => Branch(p1,b1,l1,r))\n              else if b2 < b1 then\n                if p1 land (b2 - 1) <> p2 then newbranch p1 t1 p2 t2\n                else if p1 land b2 = 0 then\n                  (case combine ord op' z t1 l2 of\n                     Empty => r2 | l => Branch(p2,b2,l,r2))\n                else\n                  (case combine ord op' z t1 r2 of\n                     Empty => l2 | r => Branch(p2,b2,l2,r))\n              else if p1 = p2 then\n               (case (combine ord op' z l1 l2,combine ord op' z r1 r2) of\n                  (Empty,r) => r | (l,Empty) => l | (l,r) => Branch(p1,b1,l,r))\n              else\n                newbranch p1 t1 p2 t2\nend ;\n\ninfix 6 |--> (* For strings *)\n\nfun (x |--> y) t = (x |-> y) t str_ord str_hash;\n\n(* ------------------------------------------------------------------------- *)\n(* Special case of point function.                                           *)\n(* ------------------------------------------------------------------------- *)\n\ninfix 6 |=>\n\nfun x |=> y = (x |-> y) undefined;\n\ninfix 6 |==> (* For strings *)\n\nfun x |==> y = (x |=> y) str_ord str_hash;\n\n\\<close>"], ["", "ML \\<open>\"intro.sml\";\n\n(* ========================================================================= *)\n(* Simple algebraic expression example from the introductory chapter.        *)\n(* ========================================================================= *)\n\n(* ------------------------------------------------------------------------- *)\n(* Lexical analysis.                                                         *)\n(* ------------------------------------------------------------------------- *)\n\nfun matches s =\n    let val chars = String.explode s in\n    fn c => mem c chars\n    end;\n\nval space = matches \" \\t\\n\\r\";\nval punctuation = matches \"()[]{},\";\nval symbolic = matches \"~`!@#$%^&*-+=|\\\\:;<>.?/\";\nval numeric = matches \"0123456789\";\nval alphanumeric = matches\n  \"abcdefghijklmnopqrstuvwxyz_'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n\nfun lexwhile prop inp =\n  if inp <> [] andalso prop (List.hd inp) then\n     let val (tok,rest) = lexwhile prop (List.tl inp) in\n     ((str (List.hd inp))^tok,rest)\n     end\n  else\n     (\"\",inp);\n\nfun lex inp =\n  case snd(lexwhile space inp) of\n    [] => []\n  | c::cs => let val prop = if alphanumeric(c) then alphanumeric\n                        else if symbolic(c) then symbolic\n                        else fn c => false\n                 val (toktl,rest) = lexwhile prop cs in\n             ((str c)^toktl)::lex rest\n             end;\n\n(* ------------------------------------------------------------------------- *)\n(* Generic function to impose lexing and exhaustion checking on a parser.    *)\n(* ------------------------------------------------------------------------- *)\n\nfun make_parser pfn s =\n  let val (expr,rest) = pfn (lex(String.explode s)) in\n  if rest = [] then expr else raise Fail \"Unparsed input\"\n  end;\n\n\\<close>"], ["", "ML \\<open>\"formulas.sml\";\n\n(* ========================================================================= *)\n(* Polymorphic type of formulas with parser and printer.                     *)\n(* ========================================================================= *)\n\nfun fm_ord at_ord fm1 fm2 =\n    case (fm1,fm2) of\n      (Falsity,Falsity) => 0\n    | (Falsity,_) =>  1\n    | (_,Falsity) => ~1\n\n    | (Truth,Truth) => 0\n    | (Truth,_)  =>  1\n    | (_,Truth)  => ~1\n\n    | (Atom a, Atom b) => at_ord a b\n    | (Atom(_),_) => 1\n    | (_,Atom(_)) => ~1\n\n    | (Not a,Not b) => fm_ord at_ord a b\n    | (Not(_),_) => 1\n    | (_,Not(_)) => ~1\n\n    | (And(a1,a2),And(b1,b2)) => fm_pair_ord at_ord (a1,a2) (b1,b2)\n    | (And(_,_),_) =>  1\n    | (_,And(_,_)) => ~1\n\n    | (Or(a1,a2),Or(b1,b2)) => fm_pair_ord at_ord (a1,a2) (b1,b2)\n    | (Or(_,_),_) =>  1\n    | (_,Or(_,_)) => ~1\n\n    | (Imp(a1,a2),Imp(b1,b2)) => fm_pair_ord at_ord (a1,a2) (b1,b2)\n    | (Imp(_,_),_) =>  1\n    | (_,Imp(_,_)) => ~1\n\n    | (Iff(a1,a2),Iff(b1,b2)) => fm_pair_ord at_ord (a1,a2) (b1,b2)\n    | (Iff(_,_),_) =>  1\n    | (_,Iff(_,_)) => ~1\n\n    | (Forall(x1,a),Forall(x2,b)) => fm_quant_ord at_ord (x1,a) (x2,b)\n    | (Forall (_,_), _) => 1\n    | (_, Forall (_,_)) => ~1\n\n    | (Exists(x1,a),Exists(x2,b)) => fm_quant_ord at_ord (x1,a) (x2,b)\nand fm_pair_ord at_ord (a1,a2) (b1,b2) =\n    case fm_ord at_ord a1 b1 of\n     0 => fm_ord at_ord a2 b2\n    |n => n\nand fm_quant_ord at_ord (x1,a) (x2,b) =\n    case str_ord x1 x2 of\n     0 => fm_ord at_ord a b\n    |n => n\n;\n\n(* ------------------------------------------------------------------------- *)\n(* General parsing of iterated infixes.                                      *)\n(* ------------------------------------------------------------------------- *)\n\nfun parse_ginfix opsym opupdate sof subparser inp =\n  let val (e1,inp1) = subparser inp in\n  if inp1 <> [] andalso List.hd inp1 = opsym then\n     parse_ginfix opsym opupdate (opupdate sof e1) subparser (List.tl inp1)\n  else (sof e1,inp1)\n  end;\n\nfun parse_left_infix opsym opcon =\n  parse_ginfix opsym (fn f => fn e1 => fn e2 => opcon(f e1,e2)) (fn x => x);\n\nfun parse_right_infix opsym opcon =\n  parse_ginfix opsym (fn f => fn e1 => fn e2 => f(opcon(e1,e2))) (fn x => x);\n\nfun parse_list opsym =\n  parse_ginfix opsym (fn f => fn e1 => fn e2 => (f e1)@[e2]) (fn x => [x]);\n\n(* ------------------------------------------------------------------------- *)\n(* Other general parsing combinators.                                        *)\n(* ------------------------------------------------------------------------- *)\n\nfun papply f (ast,rest) = (f ast,rest);\n\nfun nextin inp tok = inp <> [] andalso List.hd inp = tok;\n\nfun parse_bracketed subparser cbra inp =\n  let val(ast,rest) = subparser inp in\n  if nextin rest cbra then (ast,List.tl rest)\n  else raise Fail \"Closing bracket expected\"\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* Parsing of formulas, parametrized by atom parser \"pfn\".                   *)\n(* ------------------------------------------------------------------------- *)\n\nfun parse_atomic_formula (ifn,afn) vs inp =\n  case inp of\n    [] => raise Fail \"formula expected\"\n  | \"false\"::rest => (Falsity,rest)\n  | \"true\"::rest => (Truth,rest)\n  | \"(\"::rest => ( (ifn vs inp) handle Fail _ =>\n                  parse_bracketed (parse_formula (ifn,afn) vs) \")\" rest)\n  | \"~\"::rest => papply (fn p => Not p)\n                        (parse_atomic_formula (ifn,afn) vs rest)\n  | \"forall\"::x::rest =>\n        parse_quant (ifn,afn) (x::vs) (fn (x,p) => Forall(x,p)) x rest\n  | \"exists\"::x::rest =>\n        parse_quant (ifn,afn) (x::vs) (fn (x,p) => Exists(x,p)) x rest\n  | _ => afn vs inp\n\nand parse_quant (ifn,afn) vs qcon x inp =\n   case inp of\n     [] => raise Fail \"Body of quantified term expected\"\n   | y::rest =>\n        papply (fn fm => qcon(x,fm))\n               (if y = \".\" then parse_formula (ifn,afn) vs rest\n                else parse_quant (ifn,afn) (y::vs) qcon y rest)\n\nand parse_formula (ifn,afn) vs inp =\n   parse_right_infix \"<=>\" (fn (p,q) => Iff(p,q))\n     (parse_right_infix \"==>\" (fn (p,q) => Imp(p,q))\n         (parse_right_infix \"\\\\/\" (fn (p,q) => Or(p,q))\n             (parse_right_infix \"/\\\\\" (fn (p,q) => And(p,q))\n                  (parse_atomic_formula (ifn,afn) vs)))) inp;\n\n(* ------------------------------------------------------------------------- *)\n(* Printing of formulas, parametrized by atom printer.                       *)\n(* ------------------------------------------------------------------------- *)\n\nfun bracket p n f x y = (\n    (if p then print_string \"(\" else ());\n    open_box n; f x y; close_box();\n    (if p then print_string \")\" else ())\n);\n\nfun strip_quant fm =\n    case fm of\n      Forall (x, (Forall (y, p))) =>\n        let val (xs, q) = strip_quant (Forall (y, p)) in\n        ((x :: xs), q)\n        end\n    | Exists (x, (Exists (y, p))) =>\n        let val (xs, q) = strip_quant (Exists (y, p)) in\n        ((x :: xs), q)\n        end\n    | Forall (x, p) =>\n        ([x],p)\n    | Exists (x, p) =>\n        ([x],p)\n    | _ =>\n        ([], fm);\n\nfun print_formula_aux pfn =\n    let fun print_formula pr fm =\n        case fm of\n          Falsity =>\n            print_string \"false\"\n        | Truth =>\n            print_string \"true\"\n        | Atom pargs =>\n            pfn pr pargs\n        | Not p =>\n            bracket (pr > 10) 1 (print_prefix 10) \"~\" p\n        | And (p, q) =>\n            bracket (pr > 8) 0 (print_infix 8 \"/\\\\\") p q\n        | Or (p, q) =>\n            bracket (pr > 6) 0 (print_infix 6 \"\\\\/\") p q\n        | Imp (p, q) =>\n            bracket (pr > 4) 0 (print_infix 4 \"==>\") p q\n        | Iff (p, q) =>\n            bracket (pr > 2) 0 (print_infix 2 \"<=>\") p q\n        | Forall (x, p) =>\n            bracket (pr > 0) 2 print_qnt \"forall\" (strip_quant fm)\n        | Exists (x, p) =>\n            bracket (pr > 0) 2 print_qnt \"exists\" (strip_quant fm)\n\n    and print_qnt qname (bvs, bod) = (\n        print_string qname;\n        List.app (fn v => (print_string \" \"; print_string v)) bvs;\n        print_string \".\"; print_space(); open_box 0;\n        print_formula 0 bod;\n        close_box()\n    )\n\n    and print_prefix newpr sym p = (\n        print_string sym ; print_formula (newpr + 1) p\n    )\n\n    and print_infix newpr sym p q = (\n        print_formula (newpr + 1) p ;\n        print_string (\" \"^sym); print_space();\n        print_formula newpr q\n    ) in\n    print_formula 0\n    end\n    ;\n\nfun print_formula pfn fm = (print_formula_aux pfn fm; print_flush ());\n\nfun print_qformula_aux pfn fm = (\n  open_box 0; print_string \"<!\";\n  open_box 0; print_formula_aux pfn fm; close_box();\n  print_string \"!>\"; close_box()\n);\n\nfun print_qformula pfn fm = (print_qformula_aux pfn fm; print_flush ());\n\nfun mk_and p q = And (p, q)\n\nfun mk_or p q = Or (p, q)\n\nfun mk_imp p q = Imp (p, q)\n\nfun mk_iff p q = Iff (p, q)\n\nfun mk_forall x p = Forall (x, p)\n\nfun mk_exists x p = Exists (x, p)\n\n(* ------------------------------------------------------------------------- *)\n(* Destructors.                                                              *)\n(* ------------------------------------------------------------------------- *)\n\nfun dest_iff fm =\n  case fm of Iff(p,q) => (p,q) | _ => raise Fail \"dest_iff\";\n\nfun dest_and fm =\n  case fm of And(p,q) => (p,q) | _ => raise Fail \"dest_and\";\n\nfun conjuncts fm =\n  case fm of And(p,q) => conjuncts p @ conjuncts q | _ => [fm];\n\nfun dest_or fm =\n  case fm of Or(p,q) => (p,q) | _ => raise Fail \"dest_or\";\n\nfun disjuncts fm =\n  case fm of Or(p,q) => disjuncts p @ disjuncts q | _ => [fm];\n\nfun dest_imp fm =\n  case fm of Imp(p,q) => (p,q) | _ => raise Fail \"dest_imp\";\n\nfun antecedent fm = fst (dest_imp fm);\nfun consequent fm = snd (dest_imp fm);\n\n(* ------------------------------------------------------------------------- *)\n(* Apply a function to the atoms, otherwise keeping structure.               *)\n(* ------------------------------------------------------------------------- *)\n\nfun onatoms f fm =\n  case fm of\n    Atom a => f a\n  | Not(p) => Not(onatoms f p)\n  | And(p,q) => And(onatoms f p,onatoms f q)\n  | Or(p,q) => Or(onatoms f p,onatoms f q)\n  | Imp(p,q) => Imp(onatoms f p,onatoms f q)\n  | Iff(p,q) => Iff(onatoms f p,onatoms f q)\n  | Forall(x,p) => Forall(x,onatoms f p)\n  | Exists(x,p) => Exists(x,onatoms f p)\n  | _ => fm;\n\n(* ------------------------------------------------------------------------- *)\n(* Formula analog of list iterator \"itlist\".                                 *)\n(* ------------------------------------------------------------------------- *)\n\nfun overatoms f fm b =\n  case fm of\n    Atom(a) => f a b\n  | Not(p) => overatoms f p b\n  | And(p,q) => overatoms f p (overatoms f q b)\n  | Or(p,q)  => overatoms f p (overatoms f q b)\n  | Imp(p,q) => overatoms f p (overatoms f q b)\n  | Iff(p,q) => overatoms f p (overatoms f q b)\n  | Forall(x,p) => overatoms f p b\n  | Exists(x,p) => overatoms f p b\n  | _ => b;\n\n(* ------------------------------------------------------------------------- *)\n(* Special case of a union of the results of a function over the atoms.      *)\n(* ------------------------------------------------------------------------- *)\n\nfun atom_union ord f fm = setify ord (overatoms (fn h => fn t => f(h)@t) fm []);\n\nfun atom_union_sip f fm = atom_union sip_ord f fm;\n\n\\<close>"], ["", "ML \\<open>\"prop.sml\";\n\n(* ========================================================================= *)\n(* Basic stuff for propositional logic: datatype, parsing and printing.      *)\n(* ========================================================================= *)\n\n(* ------------------------------------------------------------------------- *)\n(* Disjunctive normal form (DNF) via truth tables.                           *)\n(* ------------------------------------------------------------------------- *)\n\nfun list_conj l = if l = [] then Truth else end_itlist mk_and l;\n\n\\<close>"], ["", "ML \\<open>\"fol.sml\";\n\n(* ========================================================================= *)\n(* Basic stuff for first order logic.                                        *)\n(* ========================================================================= *)\n\n(* ------------------------------------------------------------------------- *)\n(* Terms.                                                                    *)\n(* ------------------------------------------------------------------------- *)\n\nfun t_ord t1 t2 =\n    case (t1,t2) of\n      (Var x1, Var x2 ) => str_ord x1 x2\n    | (Var _, _) => 1\n    | (_, Var _) => ~1\n    | (Fn(f1,tl1),Fn(f2,tl2)) =>\n       case str_ord f1 f2 of\n         0 => tl_ord tl1 tl2\n        |n => n\nand tl_ord tl1 tl2 =\n    case (tl1,tl2) of\n      ([],[]) => 0\n    | ([],_) => 1\n    | (_,[]) => ~1\n    | (t1::tl1',t2::tl2') =>\n        case t_ord t1 t2 of\n         0 => tl_ord tl1' tl2'\n       | n => n\n;\n\nfun t_hash t =\n    case t of\n      Var x => str_hash x\n    | Fn (f,tl) => Word.toIntX(Word.+(Word.*(0wx31,Word.fromInt(str_hash f)),\n                                      Word.fromInt(list_hash t_hash tl)))\n;\n\ninfix 6 |---> (* For terms *)\n\nfun (x |---> y) t = (x |-> y) t t_ord t_hash;\n\ninfix 6 |===> (* For terms *)\nfun x |===> y = (x |=> y) t_ord t_hash;\n\nfun apply_t f = apply t_ord t_hash f;\n\n(* ------------------------------------------------------------------------- *)\n(* Abbreviation for FOL formula.                                             *)\n(* ------------------------------------------------------------------------- *)\n\nfun fol_ord (r1 as Rl(s1,tl1)) (r2 as Rl(s2,tl2)) =\n    case str_ord s1 s2 of\n      0 => tl_ord tl1 tl2\n    | n => n\n;\n\nfun folfm_ord fm1 fm2 = fm_ord fol_ord fm1 fm2;\n\nfun union_folfm s1 s2 = union folfm_ord s1 s2;\n\nfun ftp_ord (fm1,t1) (fm2,t2) =\n    case folfm_ord fm1 fm2 of\n      0 => t_ord t1 t2\n    | n => n;\n\nfun setify_ftp s = setify ftp_ord s;\n\n(* ------------------------------------------------------------------------- *)\n(* Special case of applying a subfunction to the top *terms*.                *)\n(* ------------------------------------------------------------------------- *)\n\nfun onformula f = onatoms(fn (Rl(p,a)) => Atom(Rl(p,List.map f a)));\n\n(* ------------------------------------------------------------------------- *)\n(* Parsing of terms.                                                         *)\n(* ------------------------------------------------------------------------- *)\n\nfun is_const_name s = List.all numeric (String.explode s) orelse s = \"nil\";\n\nfun parse_atomic_term vs inp =\n  case inp of\n    [] => raise Fail \"term expected\"\n  | \"(\"::rest => parse_bracketed (parse_term vs) \")\" rest\n  | \"-\"::rest => papply (fn t => Fn(\"-\",[t])) (parse_atomic_term vs rest)\n  | f::\"(\"::\")\"::rest => (Fn(f,[]),rest)\n  | f::\"(\"::rest =>\n      papply (fn args => Fn(f,args))\n             (parse_bracketed (parse_list \",\" (parse_term vs)) \")\" rest)\n  | a::rest =>\n      ((if is_const_name a andalso not(mem a vs) then Fn(a,[]) else Var a),rest)\n\nand parse_term vs inp =\n  parse_right_infix \"::\" (fn (e1,e2) => Fn(\"::\",[e1,e2]))\n    (parse_right_infix \"+\" (fn (e1,e2) => Fn(\"+\",[e1,e2]))\n       (parse_left_infix \"-\" (fn (e1,e2) => Fn(\"-\",[e1,e2]))\n          (parse_right_infix \"*\" (fn (e1,e2) => Fn(\"*\",[e1,e2]))\n             (parse_left_infix \"/\" (fn (e1,e2) => Fn(\"/\",[e1,e2]))\n                (parse_left_infix \"^\" (fn (e1,e2) => Fn(\"^\",[e1,e2]))\n                   (parse_atomic_term vs)))))) inp;\n\nval parset = make_parser (parse_term []);\n\n(* ------------------------------------------------------------------------- *)\n(* Parsing of formulas.                                                      *)\n(* ------------------------------------------------------------------------- *)\n\nfun parse_infix_atom vs inp =\n  let val (tm,rest) = parse_term vs inp in\n  if List.exists (nextin rest) [\"=\", \"<\", \"<=\", \">\", \">=\"] then\n        papply (fn tm' => Atom(Rl(List.hd rest,[tm,tm'])))\n               (parse_term vs (List.tl rest))\n  else raise Fail \"\"\n  end;\n\nfun parse_atom vs inp =\n  (parse_infix_atom vs inp) handle Fail _ =>\n  case inp of\n    p::\"(\"::\")\"::rest => (Atom(Rl(p,[])),rest)\n  | p::\"(\"::rest =>\n      papply (fn args => Atom(Rl(p,args)))\n             (parse_bracketed (parse_list \",\" (parse_term vs)) \")\" rest)\n  | p::rest =>\n      if p <> \"(\" then (Atom(Rl(p,[])),rest)\n      else raise Fail \"parse_atom\"\n  | _ => raise Fail \"parse_atom\";\n\nval parse = make_parser\n  (parse_formula (parse_infix_atom,parse_atom) []);\n\n(* ------------------------------------------------------------------------- *)\n(* Set up parsing of quotations.                                             *)\n(* ------------------------------------------------------------------------- *)\n\nval default_parser = parse;\ndatatype default_parser_end = !>;\nfun <! s !> = default_parser s;\n\nval secondary_parser = parset;\ndatatype secondary_parser_end = |!>;\nfun <!| s |!> = secondary_parser s;\n\n(* ------------------------------------------------------------------------- *)\n(* Printing of terms.                                                        *)\n(* ------------------------------------------------------------------------- *)\n\nfun print_term_aux prec fm =\n  case fm of\n    Var x => print_string x\n  | Fn(\"^\",[tm1,tm2]) => print_infix_term_aux true prec 24 \"^\" tm1 tm2\n  | Fn(\"/\",[tm1,tm2]) => print_infix_term_aux true prec 22 \" /\" tm1 tm2\n  | Fn(\"*\",[tm1,tm2]) => print_infix_term_aux false prec 20 \" *\" tm1 tm2\n  | Fn(\"-\",[tm1,tm2]) => print_infix_term_aux true prec 18 \" -\" tm1 tm2\n  | Fn(\"+\",[tm1,tm2]) => print_infix_term_aux false prec 16 \" +\" tm1 tm2\n  | Fn(\"::\",[tm1,tm2]) => print_infix_term_aux false prec 14 \"::\" tm1 tm2\n  | Fn(f,args) => print_fargs_aux f args\n\nand print_fargs_aux f args = (\n  print_string f;\n  if args = [] then () else\n   (print_string \"(\";\n    open_box 0;\n    print_term_aux 0 (List.hd args); print_break 0 0;\n    List.app (fn t => (print_string \",\"; print_break 0 0 ; print_term_aux 0 t))\n            (List.tl args);\n    close_box ();\n    print_string \")\")\n)\n\nand print_infix_term_aux isleft oldprec newprec sym p q = (\n  if oldprec > newprec then (print_string \"(\"; open_box 0) else ();\n  print_term_aux (if isleft then newprec else newprec+1) p;\n  print_string sym;\n  print_break (if String.substring (sym, 0, 1) = \" \" then 1 else 0) 0;\n  print_term_aux (if isleft then newprec+1 else newprec) q;\n  if oldprec > newprec then (close_box (); print_string \")\") else ()\n);\n\nfun print_term prec fm = (print_term_aux prec fm; print_flush ())\nand print_fargs f args = (print_fargs_aux f args; print_flush ())\nand print_infix_term isleft oldprec newprec sym p q = (print_infix_term_aux isleft oldprec newprec sym p q; print_flush ());\n\nfun printert_aux tm = (\n  open_box 0; print_string \"<!|\";\n  open_box 0; print_term_aux 0 tm; close_box();\n  print_string \"|!>\"; close_box()\n);\n\nfun printert tm = (printert_aux tm; print_flush ());\n\n(* ------------------------------------------------------------------------- *)\n(* Printing of formulas.                                                     *)\n(* ------------------------------------------------------------------------- *)\n\nfun print_atom_aux prec (Rl (p, args)) =\n    if mem p [\"=\", \"<\", \"<=\", \">\", \">=\"] andalso List.length args = 2 then\n        print_infix_term_aux false 12 12 (\" \" ^ p) (List.nth (args, 0)) (List.nth (args, 1))\n    else\n        print_fargs_aux p args;\n\nfun print_atom prec rpa = (print_atom_aux prec rpa; print_flush ());\n\nval print_fol_formula_aux = print_qformula_aux print_atom_aux;\n\nfun print_fol_formula f = (print_fol_formula_aux f; print_flush ());\n\n(* ------------------------------------------------------------------------- *)\n(* Free variables in terms and formulas.                                     *)\n(* ------------------------------------------------------------------------- *)\n\nfun fvt tm =\n    case tm of\n      Var x => [x]\n    | Fn (f, args) =>\n        unions_str (List.map fvt args)\n;\n\nfun var fm =\n    case fm of\n      Falsity => []\n    | Truth => []\n    | Atom (Rl (p, args)) =>\n        unions str_ord (List.map fvt args)\n    | Not p => var p\n    | And (p, q) => union_str (var p) (var q)\n    | Or  (p, q) => union_str (var p) (var q)\n    | Imp (p, q) => union_str (var p) (var q)\n    | Iff (p, q) => union_str (var p) (var q)\n    | Forall (x, p) => insert_str x (var p)\n    | Exists (x, p) => insert_str x (var p)\n;\n\nfun fv fm =\n    case fm of\n      Falsity => []\n    | Truth => []\n    | Atom (Rl (p, args)) =>\n        unions_str (List.map fvt args)\n    | Not p => fv p\n    | And (p, q) => union_str (fv p) (fv q)\n    | Or  (p, q) => union_str (fv p) (fv q)\n    | Imp (p, q) => union_str (fv p) (fv q)\n    | Iff (p, q) => union_str (fv p) (fv q)\n    | Forall (x, p) => subtract_str (fv p) [x]\n    | Exists (x, p) => subtract_str (fv p) [x]\n;\n\n(* ------------------------------------------------------------------------- *)\n(* Substitution within terms.                                                *)\n(* ------------------------------------------------------------------------- *)\n\nfun tsubst sfn tm =\n  case tm of\n    Var x => tryapplyd_str sfn x tm\n  | Fn(f,args) => Fn(f,List.map (tsubst sfn) args);\n\nfun variant x vars =\n  if mem x vars then variant (x^\"'\") vars else x;\n\n(* ------------------------------------------------------------------------- *)\n(* Substitution in formulas, with variable renaming.                         *)\n(* ------------------------------------------------------------------------- *)\n\nfun subst subfn fm =\n    case fm of\n      Falsity => Falsity\n    | Truth => Truth\n    | Atom (Rl (p, args)) =>\n        Atom (Rl (p, List.map (tsubst subfn) args))\n    | Not p =>\n        Not (subst subfn p)\n    | And (p, q) =>\n        And (subst subfn p, subst subfn q)\n    | Or (p, q) =>\n        Or  (subst subfn p, subst subfn q)\n    | Imp (p, q) =>\n        Imp (subst subfn p, subst subfn q)\n    | Iff (p, q) =>\n        Iff (subst subfn p, subst subfn q)\n    | Forall (x, p) =>\n        substq subfn mk_forall x p\n    | Exists (x, p) =>\n        substq subfn mk_exists x p\nand substq subfn quant x p =\n    let val x' =\n        if List.exists (fn y => mem x (fvt (tryapplyd_str subfn y (Var y))))\n                       (subtract_str (fv p) [x]) then\n            variant x (fv (subst (undefine_str x subfn) p))\n        else x\n    in\n    quant x' (subst ((x |--> Var x') subfn) p)\n    end\n;\n\n\\<close>"], ["", "ML \\<open>\"skolem.sml\";\n\n(* ========================================================================= *)\n(* Prenex and Skolem normal forms.                                           *)\n(* ========================================================================= *)\n\n(* ------------------------------------------------------------------------- *)\n(* Get the functions in a term and formula.                                  *)\n(* ------------------------------------------------------------------------- *)\n\nfun funcs tm =\n  case tm of\n    Var x => []\n  | Fn(f,args) => itlist (union_sip o funcs) args [(f,List.length args)];\n\nfun functions fm =\n  atom_union_sip (fn (Rl(p,a)) => itlist (union_sip o funcs) a []) fm;\n\n\\<close>"], ["", "ML \\<open>\"unif.sml\";\n\n(* ========================================================================= *)\n(* Unification for first order terms.                                        *)\n(* ========================================================================= *)\n\nfun istriv env x t =\n  case t of\n    Var y => y = x orelse defined_str env y andalso istriv env x (apply_str env y)\n  | Fn(f,args) => List.exists (istriv env x) args andalso raise Fail \"cyclic\";\n\n(* ------------------------------------------------------------------------- *)\n(* Main unification procedure                                                *)\n(* ------------------------------------------------------------------------- *)\n\nfun unify env eqs =\n  case eqs of\n    [] => env\n  | (Fn(f,fargs),Fn(g,gargs))::oth =>\n        if f = g andalso length fargs = length gargs\n        then unify env (zip fargs gargs @ oth)\n        else raise Fail \"impossible unification\"\n  | (Var x,t)::oth =>\n        if defined_str env x then unify env ((apply_str env x,t)::oth)\n        else unify (if istriv env x t then env else (x|-->t) env) oth\n  | (t,Var x)::oth =>\n        if defined_str env x then unify env ((apply_str env x,t)::oth)\n        else unify (if istriv env x t then env else (x|-->t) env) oth;\n\n(* ------------------------------------------------------------------------- *)\n(* Solve to obtain a single instantiation.                                   *)\n(* ------------------------------------------------------------------------- *)\n\nfun solve env =\n  let val env' = mapf (tsubst env) env in\n  if env' = env then env else solve env'\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* Unification reaching a final solved form (often this isn't needed).       *)\n(* ------------------------------------------------------------------------- *)\n\nfun fullunify eqs = solve (unify undefined eqs);\n\nfun unify_and_apply eqs =\n  let val i = fullunify eqs\n      fun apply (t1,t2) = (tsubst i t1,tsubst i t2) in\n  map apply eqs\n  end;\n\n\\<close>"], ["", "ML \\<open>\"tableaux.sml\";\n\n(* ========================================================================= *)\n(* Tableaux, seen as an optimized version of a Prawitz-like procedure.       *)\n(* ========================================================================= *)\n\nfun deepen f n =\n  ((* XXX print_string \"Searching with depth limit \";\n      print_int n; print_newline(); *) f n\n  )\n  handle Fail _ => deepen f (n + 1);\n\n\\<close>"], ["", "ML \\<open>\"resolution.sml\";\n\n(* ========================================================================= *)\n(* Resolution.                                                               *)\n(* ========================================================================= *)\n\n(* ------------------------------------------------------------------------- *)\n(* Matching of terms and literals.                                           *)\n(* ------------------------------------------------------------------------- *)\n\nfun term_match env eqs =\n    case eqs of\n      [] => env\n    | (Fn (f, fa), Fn(g, ga)) :: oth =>\n        if (f = g andalso List.length fa = List.length ga) then\n        term_match env (zip fa ga @ oth)\n        else raise Fail \"term_match\"\n    | (Var x, t) :: oth =>\n        if not (defined_str env x) then\n            term_match ((x |--> t) env) oth\n        else if apply_str env x = t then\n            term_match env oth\n        else\n            raise Fail \"term_match\"\n    | _ =>\n        raise Fail \"term_match\";\n\n\\<close>"], ["", "ML \\<open>\"equal.sml\";\n\n(* ========================================================================= *)\n(* First order logic with equality.                                          *)\n(* ========================================================================= *)\n\nfun mk_eq s t = Atom(Rl(\"=\",[s,t]));\n\nfun dest_eq fm =\n  case fm of\n    Atom(Rl(\"=\",[s,t])) => (s,t)\n  | _ => raise Fail \"dest_eq: not an equation\";\n\nfun lhs eq = fst (dest_eq eq) and rhs eq = snd (dest_eq eq);\n\n\\<close>"], ["", "ML \\<open>\"order.sml\";\n\n(* ========================================================================= *)\n(* Term orderings.                                                           *)\n(* ========================================================================= *)\n\nfun termsize tm =\n  case tm of\n    Var x => 1\n  | Fn(f,args) => itlist (fn t => fn n => termsize t + n) args 1;\n\n\\<close>"], ["", "ML \\<open>\"eqelim.sml\";\n\n(* ========================================================================= *)\n(* Equality elimination including Brand transformation and relatives.        *)\n(* ========================================================================= *)\n\n(* ------------------------------------------------------------------------- *)\n(* Replacement (substitution for non-variable) in term and literal.          *)\n(* ------------------------------------------------------------------------- *)\n\nfun replacet rfn tm =\n  apply_t rfn tm\n  handle Fail _ =>\n  case tm of\n    Fn(f,args) => Fn(f,List.map (replacet rfn) args)\n  | _ => tm;\n\n\\<close>"], ["", "ML \\<open>\"lcf.sml\";\n\nfun print_thm_aux th = (\n    open_box 0;\n    print_string \"|-\"; print_space();\n    open_box 0; print_formula_aux print_atom_aux (concl th); close_box();\n    close_box()\n)\n\nfun print_thm th = (print_thm_aux th; print_flush ())\n\n\\<close>"], ["", "ML \\<open>\"lcfprop.sml\";\n\n(* ========================================================================= *)\n(* Propositional reasoning by derived rules atop the LCF core.               *)\n(* ========================================================================= *)\n\n(* ------------------------------------------------------------------------- *)\n(* |- p ==> p                                                                *)\n(* ------------------------------------------------------------------------- *)\n\nfun imp_refl p =\n  modusponens (modusponens (axiom_distribimp p (Imp(p,p)) p)\n                           (axiom_addimp p (Imp(p,p))))\n              (axiom_addimp p p);\n\n(* ------------------------------------------------------------------------- *)\n(*                 |- p ==> p ==> q                                          *)\n(*               -------------------- imp_unduplicate                        *)\n(*                 |- p ==> q                                                *)\n(* ------------------------------------------------------------------------- *)\n\nfun imp_unduplicate th =\n  let val (p,pq) = dest_imp(concl th)\n      val q = consequent pq in\n  modusponens (modusponens (axiom_distribimp p p q) th) (imp_refl p)\n  end ;\n\n(* ------------------------------------------------------------------------- *)\n(* Some handy syntax operations.                                             *)\n(* ------------------------------------------------------------------------- *)\n\nfun negatef fm =\n  case fm of\n    Imp(p,Falsity) => p\n  | p => Imp(p,Falsity);\n\nfun negativef fm =\n  case fm of\n    Imp(p,Falsity) => true\n  | _ => false;\n\n(* ------------------------------------------------------------------------- *)\n(*                           |- q                                            *)\n(*         ------------------------------------------------ add_assum (p)    *)\n(*                         |- p ==> q                                        *)\n(* ------------------------------------------------------------------------- *)\n\nfun add_assum p th = modusponens (axiom_addimp (concl th) p) th;\n\n(* ------------------------------------------------------------------------- *)\n(*                   |- q ==> r                                              *)\n(*         --------------------------------------- imp_add_assum p           *)\n(*           |- (p ==> q) ==> (p ==> r)                                      *)\n(* ------------------------------------------------------------------------- *)\n\nfun imp_add_assum p th =\n  let val (q,r) = dest_imp(concl th) in\n  modusponens (axiom_distribimp p q r) (add_assum p th)\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(*            |- p ==> q              |- q ==> r                             *)\n(*         ----------------------------------------- imp_trans               *)\n(*                 |- p ==> r                                                *)\n(* ------------------------------------------------------------------------- *)\n\nfun imp_trans th1 th2 =\n  let val p = antecedent(concl th1) in\n  modusponens (imp_add_assum p th2) th1\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(*                 |- p ==> r                                                *)\n(*         -------------------------- imp_insert q                           *)\n(*              |- p ==> q ==> r                                             *)\n(* ------------------------------------------------------------------------- *)\n\nfun imp_insert q th =\n  let val (p,r) = dest_imp(concl th) in\n  imp_trans th (axiom_addimp r q)\n  end ;\n\n(* ------------------------------------------------------------------------- *)\n(*                 |- p ==> q ==> r                                          *)\n(*              ---------------------- imp_swap                              *)\n(*                 |- q ==> p ==> r                                          *)\n(* ------------------------------------------------------------------------- *)\n\nfun imp_swap th =\n  let val (p,qr) = dest_imp(concl th)\n      val (q,r) = dest_imp qr in\n  imp_trans (axiom_addimp q p)\n            (modusponens (axiom_distribimp p q r) th)\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* |- (q ==> r) ==> (p ==> q) ==> (p ==> r)                                  *)\n(* ------------------------------------------------------------------------- *)\n\nfun imp_trans_th p q r =\n   imp_trans (axiom_addimp (Imp(q,r)) p)\n             (axiom_distribimp p q r);\n\n(* ------------------------------------------------------------------------- *)\n(*                 |- p ==> q                                                *)\n(*         ------------------------------- imp_add_concl r                   *)\n(*          |- (q ==> r) ==> (p ==> r)                                       *)\n(* ------------------------------------------------------------------------- *)\n\nfun imp_add_concl r th =\n  let val (p,q) = dest_imp(concl th) in\n  modusponens (imp_swap(imp_trans_th p q r)) th\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* |- (p ==> q ==> r) ==> (q ==> p ==> r)                                    *)\n(* ------------------------------------------------------------------------- *)\n\nfun imp_swap_th p q r =\n  imp_trans (axiom_distribimp p q r)\n            (imp_add_concl (Imp(p,r)) (axiom_addimp q p));\n\n(* ------------------------------------------------------------------------- *)\n(*  |- (p ==> q ==> r) ==> (s ==> t ==> u)                                   *)\n(* -----------------------------------------                                 *)\n(*  |- (q ==> p ==> r) ==> (t ==> s ==> u)                                   *)\n(* ------------------------------------------------------------------------- *)\n\nfun imp_swap2 th =\n  case concl th of\n    Imp(Imp(p,Imp(q,r)),Imp(s,Imp(t,u))) =>\n        imp_trans (imp_swap_th q p r) (imp_trans th (imp_swap_th s t u))\n  | _ => raise Fail \"imp_swap2\";\n\n(* ------------------------------------------------------------------------- *)\n(* If |- p ==> q ==> r and |- p ==> q then |- p ==> r.                       *)\n(* ------------------------------------------------------------------------- *)\n\nfun right_mp ith th =\n  imp_unduplicate(imp_trans th (imp_swap ith));\n\n(* ------------------------------------------------------------------------- *)\n(*                 |- p <=> q                                                *)\n(*                ------------ iff_imp1                                      *)\n(*                 |- p ==> q                                                *)\n(* ------------------------------------------------------------------------- *)\n\nfun iff_imp1 th =\n  let val (p,q) = dest_iff(concl th) in\n  modusponens (axiom_iffimp1 p q) th\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(*                 |- p <=> q                                                *)\n(*                ------------ iff_imp2                                      *)\n(*                 |- q ==> p                                                *)\n(* ------------------------------------------------------------------------- *)\n\nfun iff_imp2 th =\n  let val (p,q) = dest_iff(concl th) in\n  modusponens (axiom_iffimp2 p q) th\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(*         |- p ==> q      |- q ==> p                                        *)\n(*        ---------------------------- imp_antisym                           *)\n(*              |- p <=> q                                                   *)\n(* ------------------------------------------------------------------------- *)\n\nfun imp_antisym th1 th2 =\n  let val (p,q) = dest_imp(concl th1) in\n  modusponens (modusponens (axiom_impiff p q) th1) th2\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(*         |- p ==> (q ==> false) ==> false                                  *)\n(*       ----------------------------------- right_doubleneg                 *)\n(*               |- p ==> q                                                  *)\n(* ------------------------------------------------------------------------- *)\n\nfun right_doubleneg th =\n  case concl th of\n    Imp(_,Imp(Imp(p,Falsity),Falsity)) => imp_trans th (axiom_doubleneg p)\n  | _ => raise Fail \"right_doubleneg\";\n\n(* ------------------------------------------------------------------------- *)\n(*                                                                           *)\n(*         ------------------------------------------- ex_falso (p)          *)\n(*                 |- false ==> p                                            *)\n(* ------------------------------------------------------------------------- *)\n\nfun ex_falso p = right_doubleneg(axiom_addimp Falsity (Imp(p,Falsity)));\n\n(* ------------------------------------------------------------------------- *)\n(*  |- p ==> q ==> r        |- r ==> s                                       *)\n(* ------------------------------------ imp_trans2                           *)\n(*      |- p ==> q ==> s                                                     *)\n(* ------------------------------------------------------------------------- *)\n\nfun imp_trans2 th1 th2 =\n  let val Imp(p,Imp(q,r)) = concl th1\n      val Imp(r',s) = concl th2\n      val th = imp_add_assum p (modusponens (imp_trans_th q r s) th2) in\n  modusponens th th1\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(*         |- p ==> q1   ...   |- p ==> qn   |- q1 ==> ... ==> qn ==> r      *)\n(*        --------------------------------------------------------------     *)\n(*                             |- p ==> r                                    *)\n(* ------------------------------------------------------------------------- *)\n\nfun imp_trans_chain ths th =\n  itlist (fn a => fn b => imp_unduplicate (imp_trans a (imp_swap b)))\n    (List.rev(List.tl ths)) (imp_trans (List.hd ths) th);\n\n(* ------------------------------------------------------------------------- *)\n(* |- (q ==> false) ==> p ==> (p ==> q) ==> false                            *)\n(* ------------------------------------------------------------------------- *)\n\nfun imp_truefalse p q =\n  imp_trans (imp_trans_th p q Falsity) (imp_swap_th (Imp(p,q)) p Falsity);\n\n(* ------------------------------------------------------------------------- *)\n(*  |- (p' ==> p) ==> (q ==> q') ==> (p ==> q) ==> (p' ==> q')               *)\n(* ------------------------------------------------------------------------- *)\n\nfun imp_mono_th p p' q q' =\n  let val th1 = imp_trans_th (Imp(p,q)) (Imp(p',q)) (Imp(p',q'))\n      val th2 = imp_trans_th p' q q'\n      val th3 = imp_swap(imp_trans_th p' p q) in\n  imp_trans th3 (imp_swap(imp_trans th2 th1))\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* |- true                                                                   *)\n(* ------------------------------------------------------------------------- *)\n\nval truth = modusponens (iff_imp2 axiom_true) (imp_refl Falsity);\n\n(* ------------------------------------------------------------------------- *)\n(*         |- p ==> q                                                        *)\n(*      ----------------- contrapos                                          *)\n(*         |- ~q ==> ~p                                                      *)\n(* ------------------------------------------------------------------------- *)\n\nfun contrapos th =\n  let val (p,q) = dest_imp(concl th) in\n  imp_trans (imp_trans (iff_imp1(axiom_not q)) (imp_add_concl Falsity th))\n            (iff_imp2(axiom_not p))\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* |- p /\\ q ==> p                                                           *)\n(* ------------------------------------------------------------------------- *)\n\nfun and_left p q =\n  let val th1 = imp_add_assum p (axiom_addimp Falsity q)\n      val th2 = right_doubleneg(imp_add_concl Falsity th1) in\n  imp_trans (iff_imp1(axiom_and p q)) th2\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* |- p /\\ q ==> q                                                           *)\n(* ------------------------------------------------------------------------- *)\n\nfun and_right p q =\n  let val th1 = axiom_addimp (Imp(q,Falsity)) p\n      val th2 = right_doubleneg(imp_add_concl Falsity th1) in\n  imp_trans (iff_imp1(axiom_and p q)) th2\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* |- p1 /\\ ... /\\ pn ==> pi for each 1 <= i <= n (input term right assoc)   *)\n(* ------------------------------------------------------------------------- *)\n\nfun conjths fm =\n  let val (p,q) = dest_and fm in\n      (and_left p q)::List.map (imp_trans (and_right p q)) (conjths q)\n  end handle Fail _ => [imp_refl fm];\n\n(* ------------------------------------------------------------------------- *)\n(* |- p ==> q ==> p /\\ q                                                     *)\n(* ------------------------------------------------------------------------- *)\n\nfun and_pair p q =\n  let val th1 = iff_imp2(axiom_and p q)\n      val th2 = imp_swap_th (Imp(p,Imp(q,Falsity))) q Falsity\n      val th3 = imp_add_assum p (imp_trans2 th2 th1) in\n  modusponens th3 (imp_swap (imp_refl (Imp(p,Imp(q,Falsity)))))\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* If |- p /\\ q ==> r then |- p ==> q ==> r                                  *)\n(* ------------------------------------------------------------------------- *)\n\nfun shunt th =\n  let val (p,q) = dest_and(antecedent(concl th)) in\n  modusponens (itlist imp_add_assum [p,q] th) (and_pair p q)\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* If |- p ==> q ==> r then |- p /\\ q ==> r                                  *)\n(* ------------------------------------------------------------------------- *)\n\nfun unshunt th =\n  let val (p,qr) = dest_imp(concl th)\n      val (q,r) = dest_imp qr in\n  imp_trans_chain [and_left p q, and_right p q] th\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* Produce |- (p <=> q) <=> (p ==> q) /\\ (q ==> p)                           *)\n(* ------------------------------------------------------------------------- *)\n\nfun iff_def p q = (* Not in the book *)\n  let val th1 = and_pair (Imp(p,q)) (Imp(q,p))\n      val th2 = imp_trans_chain [axiom_iffimp1 p q, axiom_iffimp2 p q] th1 in\n  imp_antisym th2 (unshunt (axiom_impiff p q))\n  end;\n\nfun iff_def p q =\n  let val th = and_pair (Imp(p,q)) (Imp(q,p))\n      val thl = [axiom_iffimp1 p q, axiom_iffimp2 p q] in\n  imp_antisym (imp_trans_chain thl th) (unshunt (axiom_impiff p q))\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* Produce \"expansion\" theorem for defined connectives.                      *)\n(* ------------------------------------------------------------------------- *)\n\nfun expand_connective fm =\n  case fm of\n    Truth => axiom_true\n  | Not p => axiom_not p\n  | And(p,q) => axiom_and p q\n  | Or(p,q) => axiom_or p q\n  | Iff(p,q) => iff_def p q\n  | Exists(x,p) => axiom_exists x p\n  | _ => raise Fail \"expand_connective\";\n\nfun eliminate_connective fm =\n  if not(negativef fm) then iff_imp1(expand_connective fm)\n  else imp_add_concl Falsity (iff_imp2(expand_connective(negatef fm)));\n\n(* ------------------------------------------------------------------------- *)\n(*                                                                           *)\n(*   ------------------------------------------------- imp_false_conseqs     *)\n(*      [|- ((p ==> q) ==> false) ==> (q ==> false);                         *)\n(*       |- ((p ==> q) ==> false) ==> p]                                     *)\n(* ------------------------------------------------------------------------- *)\n\nfun imp_false_conseqs p q =\n [right_doubleneg(imp_add_concl Falsity (imp_add_assum p (ex_falso q))),\n  imp_add_concl Falsity (imp_insert p (imp_refl q))];\n\n(* ------------------------------------------------------------------------- *)\n(*         |- p ==> (q ==> false) ==> r                                      *)\n(*        ------------------------------------ imp_false_rule                *)\n(*             |- ((p ==> q) ==> false) ==> r                                *)\n(* ------------------------------------------------------------------------- *)\n\nfun imp_false_rule th =\n  let val (p,r) = dest_imp (concl th) in\n  imp_trans_chain (imp_false_conseqs p (funpow 2 antecedent r)) th\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(*         |- (p ==> false) ==> r          |- q ==> r                        *)\n(*       ---------------------------------------------- imp_true_rule        *)\n(*                      |- (p ==> q) ==> r                                   *)\n(* ------------------------------------------------------------------------- *)\n\nfun imp_true_rule th1 th2 =\n  let val p = funpow 2 antecedent (concl th1)\n      val q = antecedent(concl th2)\n      val th3 = right_doubleneg(imp_add_concl Falsity th1)\n      val th4 = imp_add_concl Falsity th2\n      val th5 = imp_swap(imp_truefalse p q)\n      val th6 = imp_add_concl Falsity (imp_trans_chain [th3, th4] th5)\n      val th7 = imp_swap(imp_refl(Imp(Imp(p,q),Falsity))) in\n  right_doubleneg(imp_trans th7 th6)\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(*                                 *                                         *)\n(*                 -------------------------------------- imp_contr          *)\n(*                        |- p ==> -p ==> q                                  *)\n(* ------------------------------------------------------------------------- *)\n\nfun imp_contr p q =\n  if negativef p then imp_add_assum (negatef p) (ex_falso q)\n  else imp_swap (imp_add_assum p (ex_falso q));\n\n(* ------------------------------------------------------------------------- *)\n(*                                                                           *)\n(* --------------------------------------------- imp_front (this antecedent) *)\n(*  |- (p0 ==> p1 ==> ... ==> pn ==> q)                                      *)\n(*     ==> pn ==> p0 ==> p1 ==> .. p(n-1) ==> q                              *)\n(* ------------------------------------------------------------------------- *)\n\nfun imp_front_th n fm =\n  if n = 0 then imp_refl fm else\n  let val (p,qr) = dest_imp fm\n      val th1 = imp_add_assum p (imp_front_th (n - 1) qr)\n      val (q',r') = dest_imp(funpow 2 consequent(concl th1)) in\n  imp_trans th1 (imp_swap_th p q' r')\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(*           |- p0 ==> p1 ==> ... ==> pn ==> q                               *)\n(*         ------------------------------------------ imp_front n            *)\n(*           |- pn ==> p0 ==> p1 ==> .. p(n-1) ==> q                         *)\n(* ------------------------------------------------------------------------- *)\n\nfun imp_front n th = modusponens (imp_front_th n (concl th)) th;\n\n(* ------------------------------------------------------------------------- *)\n(* Propositional tableaux procedure.                                         *)\n(* ------------------------------------------------------------------------- *)\n\nfun is_false Falsity = true\n  | is_false _ = false;\n\nfun is_true (Imp(p,q)) = (p = q)\n  | is_true _ = false;\n\nfun is_conj (Imp(Imp(p,q),Falsity)) = true\n  | is_conj _ = false\n\nfun dest_conj fm =\n    case fm of\n      (Imp(Imp(p,q),Falsity)) => (p,q)\n    | _ => raise Fail \"dest_conj\"\n\nfun is_disj (Imp(p,q)) = (q <> Falsity)\n  | is_disj _ = false\n\nfun dest_disj fm = dest_imp fm;\n\nfun is_prop_lit p =\n  case p of\n     Atom(_) => true\n   | Forall(_,_) => true\n   | Imp(Atom(_),Falsity) => true\n   | Imp(Forall(_),Falsity) => true\n   | _ => false ;\n\nfun lcfptab fms lits =\n    case fms of\n      []     => raise Fail \"lcfptab: no contradiction\"\n    | fm::fl =>\n        if is_false fm then (\n            ex_falso (itlist mk_imp (fl @ lits) Falsity)\n        ) else if is_true fm then (\n            add_assum fm (lcfptab fl lits)\n        ) else if is_conj fm then (\n            let val (p,q)=dest_conj fm in\n            imp_false_rule(lcfptab (p::Imp(q,Falsity)::fl) lits)\n            end\n        ) else if is_disj fm then (\n            let val (p,q)=dest_disj fm in\n            imp_true_rule (lcfptab (Imp(p,Falsity)::fl) lits) (lcfptab (q::fl) lits)\n            end\n        ) else if is_prop_lit fm then (\n            if mem (negatef fm) lits then\n              let val (l1,l2) = chop_list (index (negatef fm) lits) lits\n                  val th = imp_contr fm (itlist mk_imp (List.tl l2) Falsity ) in\n              itlist imp_insert (fl @ l1) th\n              end\n            else imp_front (List.length fl) (lcfptab fl (fm::lits))\n        ) else ( (* is nonprimitive *)\n           let val th = eliminate_connective fm in\n           imp_trans th (lcfptab (consequent(concl th)::fl) lits)\n           end\n        )\n;\n\n(* ------------------------------------------------------------------------- *)\n(* In particular, this gives a tautology prover.                             *)\n(* ------------------------------------------------------------------------- *)\n\nfun lcftaut p =\n  modusponens (axiom_doubleneg p) (lcfptab [negatef p] []);\n\n\\<close>"], ["", "ML \\<open>\"folderived.sml\";\n\n(* ========================================================================= *)\n(* First-order derived rules in the LCF setup.                               *)\n(* ========================================================================= *)\n\n(* ------------------------------------------------------------------------- *)\n(*                         ******                                            *)\n(*         ------------------------------------------ eq_sym                 *)\n(*                      |- s = t ==> t = s                                   *)\n(* ------------------------------------------------------------------------- *)\n\nfun eq_sym s t =\n  let val rth = axiom_eqrefl s in\n  funpow 2 (fn th => (modusponens (imp_swap th) rth))\n           (axiom_predcong \"=\" [s, s] [t, s])\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* |- s = t ==> t = u ==> s = u.                                             *)\n(* ------------------------------------------------------------------------- *)\n\nfun eq_trans s t u =\n  let val th1 = axiom_predcong \"=\" [t, u] [s, u]\n      val th2 = modusponens (imp_swap th1) (axiom_eqrefl u) in\n  imp_trans (eq_sym s t) th2\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(*         ---------------------------- icongruence                          *)\n(*          |- s = t ==> tm[s] = tm[t]                                       *)\n(* ------------------------------------------------------------------------- *)\n\nfun icongruence s t stm ttm =\n  if stm = ttm then add_assum (mk_eq s t) (axiom_eqrefl stm)\n  else if stm = s andalso ttm = t then imp_refl (mk_eq s t) else\n  case (stm,ttm) of\n   (Fn(fs,sa),Fn(ft,ta)) =>\n        if fs = ft andalso length sa = length ta then\n            let val ths = map2 (icongruence s t) sa ta\n                val ts = List.map (consequent o concl) ths in\n            imp_trans_chain ths (axiom_funcong fs (List.map lhs ts) (List.map rhs ts))\n            end\n        else raise Fail \"icongruence: not congruent\"\n  | _ => raise Fail \"icongruence: not congruent\";\n\n(* ------------------------------------------------------------------------- *)\n(* |- (forall x. p ==> q(x)) ==> p ==> (forall x. q(x))                      *)\n(* ------------------------------------------------------------------------- *)\n\nfun gen_right_th x p q =\n  imp_swap(imp_trans (axiom_impall x p) (imp_swap(axiom_allimp x p q)));\n\n(* ------------------------------------------------------------------------- *)\n(*                       |- p ==> q                                          *)\n(*         ------------------------------------- genimp \"x\"                  *)\n(*           |- (forall x. p) ==> (forall x. q)                              *)\n(* ------------------------------------------------------------------------- *)\n\nfun genimp x th =\n  let val (p,q) = dest_imp(concl th) in\n  modusponens (axiom_allimp x p q) (gen x th)\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* If |- p ==> q[x] then |- p ==> forall x. q[x]                             *)\n(* ------------------------------------------------------------------------- *)\n\nfun gen_right x th =\n  let val (p,q) = dest_imp(concl th) in\n  modusponens (gen_right_th x p q) (gen x th)\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* |- (forall x. p(x) ==> q) ==> (exists x. p(x)) ==> q                      *)\n(* ------------------------------------------------------------------------- *)\n\nfun exists_left_th x p q =\n  let val  p' = Imp(p,Falsity)\n      val  q' = Imp(q,Falsity)\n      val th1 = genimp x (imp_swap(imp_trans_th p q Falsity))\n      val th2 = imp_trans th1 (gen_right_th x q' p')\n      val th3 = imp_swap(imp_trans_th q' (Forall(x,p')) Falsity)\n      val th4 = imp_trans2 (imp_trans th2 th3) (axiom_doubleneg q)\n      val th5 = imp_add_concl Falsity (genimp x (iff_imp2 (axiom_not p)))\n      val th6 = imp_trans (iff_imp1 (axiom_not (Forall(x,Not p)))) th5\n      val th7 = imp_trans (iff_imp1(axiom_exists x p)) th6 in\n  imp_swap(imp_trans th7 (imp_swap th4))\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* If |- p(x) ==> q then |- (exists x. p(x)) ==> q                           *)\n(* ------------------------------------------------------------------------- *)\n\nfun exists_left x th =\n  let val (p,q) = dest_imp(concl th) in\n  modusponens (exists_left_th x p q) (gen x th)\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(*    |- x = t ==> p ==> q    [x not in t and not free in q]                 *)\n(*  --------------------------------------------------------------- subspec  *)\n(*                 |- (forall x. p) ==> q                                    *)\n(* ------------------------------------------------------------------------- *)\n\nfun subspec th =\n  case concl th of\n    Imp(e as Atom(Rl(\"=\",[Var x,t])),Imp(p,q)) =>\n        let val th1 = imp_trans (genimp x (imp_swap th))\n                            (exists_left_th x e q) in\n        modusponens (imp_swap th1) (axiom_existseq x t)\n        end\n  | _ => raise Fail \"subspec: wrong sort of theorem\";\n\n(* ------------------------------------------------------------------------- *)\n(*    |- x = y ==> p[x] ==> q[y]  [x not in FV(q); y not in FV(p) or x == y] *)\n(*  --------------------------------------------------------- subalpha       *)\n(*                 |- (forall x. p) ==> (forall y. q)                        *)\n(* ------------------------------------------------------------------------- *)\n\nfun subalpha th =\n   case concl th of\n    Imp(Atom(Rl(\"=\",[Var x,Var y])),Imp(p,q)) =>\n        if x = y then genimp x (modusponens th (axiom_eqrefl(Var x)))\n        else gen_right y (subspec th)\n  | _ => raise Fail \"subalpha: wrong sort of theorem\";\n\n(* ------------------------------------------------------------------------- *)\n(*         ---------------------------------- isubst                         *)\n(*            |- s = t ==> p[s] ==> p[t]                                     *)\n(* ------------------------------------------------------------------------- *)\n\nfun isubst s t sfm tfm =\n  if sfm = tfm then add_assum (mk_eq s t) (imp_refl tfm) else\n  case (sfm,tfm) of\n    (Atom(Rl(p,sa)),Atom(Rl(p',ta))) =>\n        if p = p' andalso List.length sa = List.length ta then\n            let val ths = map2 (icongruence s t) sa ta\n                val (ls,rs) = unzip (List.map (dest_eq o consequent o concl) ths) in\n            imp_trans_chain ths (axiom_predcong p ls rs)\n            end\n        else\n            raise Fail \"isubst\"\n  | (Imp(sp,sq),Imp(tp,tq)) =>\n        let val th1 = imp_trans (eq_sym s t) (isubst t s tp sp)\n            val th2 = isubst s t sq tq in\n        imp_trans_chain [th1, th2] (imp_mono_th sp tp sq tq)\n        end\n  | (Forall(x,p),Forall(y,q)) =>\n        if x = y then\n          imp_trans (gen_right x (isubst s t p q)) (axiom_allimp x p q)\n        else\n          let val z = Var(variant x (unions_str [fv p, fv q, fvt s, fvt t]))\n              val th1 = isubst (Var x) z p (subst (x |==> z) p)\n              val th2 = isubst z (Var y) (subst (y |==> z) q) q\n              val th3 = subalpha th1\n              val th4 = subalpha th2\n              val th5 = isubst s t (consequent(concl th3))\n                               (antecedent(concl th4)) in\n          imp_swap (imp_trans2 (imp_trans th3 (imp_swap th5)) th4)\n          end\n  | _ =>\n        let val sth = iff_imp1(expand_connective sfm)\n            val tth = iff_imp2(expand_connective tfm)\n            val th1 = isubst s t (consequent(concl sth))\n                             (antecedent(concl tth)) in\n        imp_swap(imp_trans sth (imp_swap(imp_trans2 th1 tth)))\n        end;\n\n(* ------------------------------------------------------------------------- *)\n(*                                                                           *)\n(* -------------------------------------------- alpha \"z\" <!forall x. p[x]!> *)\n(*   |- (forall x. p[x]) ==> (forall z. p'[z])                               *)\n(*                                                                           *)\n(* [Restriction that z is not free in the initial p[x].]                     *)\n(* ------------------------------------------------------------------------- *)\n\nfun alpha z fm =\n  case fm of\n    Forall(x,p) => let val p' = subst (x |==> Var z) p in\n                   subalpha(isubst (Var x) (Var z) p p')\n                   end\n  | _ => raise Fail \"alpha: not a universal formula\";\n\n(* ------------------------------------------------------------------------- *)\n(*                                                                           *)\n(* -------------------------------- ispec t <!forall x. p[x]!>               *)\n(*   |- (forall x. p[x]) ==> p'[t]                                           *)\n(* ------------------------------------------------------------------------- *)\n\nfun ispec t fm =\n  case fm of\n    Forall(x,p) =>\n      if mem x (fvt t) then\n        let val th = alpha (variant x (union_str (fvt t) (var p))) fm in\n        imp_trans th (ispec t (consequent(concl th)))\n        end\n      else subspec(isubst (Var x) t p (subst (x |==> t) p))\n  | _ => raise Fail \"ispec: non-universal formula\";\n\n(* ------------------------------------------------------------------------- *)\n(* Specialization rule.                                                      *)\n(* ------------------------------------------------------------------------- *)\n\nfun spec t th = modusponens (ispec t (concl th)) th;\n\n\\<close>"], ["", "ML \\<open>\"lcffol.sml\";\n\n(* ========================================================================= *)\n(* First order tableau procedure using LCF setup.                            *)\n(* ========================================================================= *)\n\n(* ------------------------------------------------------------------------- *)\n(* Unification of complementary literals.                                    *)\n(* ------------------------------------------------------------------------- *)\n\nfun unify_complementsf env =\n  fn (Atom(Rl(p1,a1)),Imp(Atom(Rl(p2,a2)),Falsity)) => unify env [(Fn(p1,a1),Fn(p2,a2))]\n   | (Imp(Atom(Rl(p1,a1)),Falsity),Atom(Rl(p2,a2))) => unify env [(Fn(p1,a1),Fn(p2,a2))]\n   | _ => raise Fail \"unify_complementsf\";\n\n(* ------------------------------------------------------------------------- *)\n(*    |- (q ==> f) ==> ... ==> (q ==> p) ==> r                               *)\n(* --------------------------------------------- use_laterimp <!q ==> p!>    *)\n(*    |- (p ==> f) ==> ... ==> (q ==> p) ==> r                               *)\n(* ------------------------------------------------------------------------- *)\n\nfun use_laterimp i fm =\n  case fm of\n    Imp(_,Imp(i',_)) =>\n      ( case (fm,i'=i) of\n          (Imp(Imp(q',s),Imp(i' as Imp(q,p),r)),true) =>\n             let val th1 = axiom_distribimp i (Imp(Imp(q,s),r)) (Imp(Imp(p,s),r))\n                 val th2 = imp_swap(imp_trans_th q p s)\n                 val th3 = imp_swap(imp_trans_th (Imp(p,s)) (Imp(q,s)) r) in\n             imp_swap2(modusponens th1 (imp_trans th2 th3))\n             end\n        | (Imp(qs,Imp(a,b)),_) =>\n             imp_swap2(imp_add_assum a (use_laterimp i (Imp(qs,b))))\n      )\n;\n\n(* ------------------------------------------------------------------------- *)\n(* The \"closure\" inference rules.                                            *)\n(* ------------------------------------------------------------------------- *)\n\nfun imp_false_rule' th es = imp_false_rule(th es);\n\nfun imp_true_rule' th1 th2 es = imp_true_rule (th1 es) (th2 es);\n\nfun imp_front' n thp es = imp_front n (thp es);\n\nfun add_assum' fm thp (es as(e,s)) =\n  add_assum (onformula e fm) (thp es);\n\nfun eliminate_connective' fm thp (es as(e,s)) =\n  imp_trans (eliminate_connective (onformula e fm)) (thp es);\n\nfun spec' y fm n thp (e,s) =\n  let val th = imp_swap(imp_front n (thp(e,s))) in\n  imp_unduplicate(imp_trans (ispec (e y) (onformula e fm)) th)\n  end;\n\nfun ex_falso' fms (e,s) =\n  ex_falso (itlist (mk_imp o onformula e) fms s);\n\nfun complits' (p::fl,lits) i (e,s) =\n  let val (l1,p'::l2) = chop_list i lits in\n  itlist (imp_insert o onformula e) (fl @ l1)\n         (imp_contr (onformula e p)\n                    (itlist (mk_imp o onformula e) l2 s))\n  end;\n\nfun deskol' (skh:fol fm) thp (e,s) =\n  let val th = thp (e,s) in\n  modusponens (use_laterimp (onformula e skh) (concl th)) th\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* Main refutation function.                                                 *)\n(* ------------------------------------------------------------------------- *)\n\nfun is_lit (Atom(_)) = true\n  | is_lit (Imp(Atom(_),Falsity)) = true\n  | is_lit _ = false;\n\nfun is_uni (Forall(_,_)) = true\n  | is_uni _ = false;\n\nfun dest_uni (Forall(x,p)) = (x,p);\n\nfun is_exi (Imp(Forall(_,_),Falsity)) = true\n  | is_exi _ = false;\n\nfun dest_exi (Imp(yp as Forall(y,p),Falsity)) = (y,p,yp);\n\nfun lcftab skofun (fms,lits,n) cont (esk as (env,sks,k)) =\n    if n < 0 then raise Fail \"lcftab: no proof\" else\n    case fms of\n      []     => raise Fail \"lcftab: No contradiction\"\n    | fm::fl =>\n        if is_false fm then (\n            cont (ex_falso' (fl @ lits)) esk\n        ) else if is_true fm then (\n            lcftab skofun (fl,lits,n) (cont o add_assum' fm) esk\n        ) else if is_conj fm then (\n            let val (p,q)=dest_conj fm in\n            lcftab skofun (p::Imp(q,Falsity)::fl,lits,n) (cont o imp_false_rule') esk\n            end\n        ) else if is_disj fm then (\n            let val (p,q)=dest_disj fm in\n            lcftab skofun (Imp(p,Falsity)::fl,lits,n) (fn th => lcftab skofun (q::fl,lits,n)\n                                                                (cont o imp_true_rule' th)) esk\n            end\n        ) else if is_lit fm then (\n            (tryfind (fn p' => (\n                let val env' = unify_complementsf env (fm, p') in\n                cont (complits' (fms, lits) (index p' lits)) (env', sks, k)\n                end)) lits)\n            handle Fail _ => (\n                lcftab skofun (fl,fm::lits,n) (cont o imp_front' (List.length fl)) esk\n            )\n        ) else if is_uni fm then (\n            let val (x,p) = dest_uni fm\n                val y = Var(\"X_\"^(Int.toString k)) in\n            lcftab skofun ((subst (x |==> y) p)::fl@[fm],lits,n-1)\n                    (cont o spec' y fm (List.length fms)) (env,sks,k+1)\n            end\n        ) else if is_exi fm then (\n            let val (y,p,yp) = dest_exi fm\n                val fx = skofun yp\n                val p' = subst(y |==> fx) p\n                val skh = Imp(p',Forall(y,p))\n                val sks' = (Forall(y,p),fx)::sks in\n            lcftab skofun (Imp(p',Falsity)::fl,lits,n) (cont o deskol' skh) (env,sks',k)\n            end\n        ) else ( (* is nonprimitive *)\n           let val fm' = consequent(concl(eliminate_connective fm)) in\n           lcftab skofun (fm'::fl,lits,n) (cont o eliminate_connective' fm) esk\n           end\n        )\n;\n\n(* ------------------------------------------------------------------------- *)\n(* Identify quantified subformulas; true = exists, false = forall. This is   *)\n(* taking into account the effective parity.                                 *)\n(* ------------------------------------------------------------------------- *)\n\nfun quantforms e fm =\n  case fm of\n    Not(p) => quantforms (not e) p\n  | And(p,q) => union_folfm (quantforms e p) (quantforms e q)\n  | Or(p,q)  => union_folfm (quantforms e p) (quantforms e q)\n  | Imp(p,q) => quantforms e (Or(Not p,q))\n  | Iff(p,q) => quantforms e (Or(And(p,q),And(Not p,Not q)))\n  | Exists(x,p) => if e then fm::(quantforms e p) else quantforms e p\n  | Forall(x,p) => if e then quantforms e p else fm::(quantforms e p)\n  | _ => [];\n\n(* ------------------------------------------------------------------------- *)\n(* Now create some Skolem functions.                                         *)\n(* ------------------------------------------------------------------------- *)\n\nfun skolemfuns fm =\n  let val fns = List.map (fn pr => fst pr) (functions fm)\n      val skts = List.map (fn Exists(x,p) => Forall(x,Not p) | p => p)\n                 (quantforms true fm)\n      fun skofun i (ap as Forall(y,p)) =\n            let val vars = List.map (fn v => Var v) (fv ap) in\n            (ap,Fn(variant(\"f\"^\"_\"^Int.toString i) fns,vars))\n            end\n  in\n  map2 skofun (1--length skts) skts\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* Matching.                                                                 *)\n(* ------------------------------------------------------------------------- *)\n\nfun form_match (fp as (f1,f2)) env =\n  case fp of\n    (Falsity,Falsity) => env\n  | (Truth,Truth)     => env\n  | (Atom(Rl(p,pa)),Atom(Rl(q,qa))) => term_match env [(Fn(p,pa),Fn(q,qa))]\n  | (Not(p1),Not(p2)) => form_match (p1,p2) env\n  | (And(p1,q1),And(p2,q2)) => form_match (p1,p2) (form_match (q1,q2) env)\n  | (Or(p1,q1),Or(p2,q2))   => form_match (p1,p2) (form_match (q1,q2) env)\n  | (Imp(p1,q1),Imp(p2,q2)) => form_match (p1,p2) (form_match (q1,q2) env)\n  | (Iff(p1,q1),Iff(p2,q2)) => form_match (p1,p2) (form_match (q1,q2) env)\n  | (Forall(x1,p1),Forall(x2,p2)) =>\n        if (x1=x2) then\n          let val z = variant x1 (union_str (fv p1) (fv p2))\n              val inst_fn = subst (x1 |==> Var z) in\n          undefine_str z (form_match (inst_fn p1,inst_fn p2) env)\n          end\n        else\n          raise Fail \"form_match\"\n  | (Exists(x1,p1),Exists(x2,p2)) =>\n        if (x1=x2) then\n          let val z = variant x1 (union_str (fv p1) (fv p2))\n              val inst_fn = subst (x1 |==> Var z) in\n          undefine_str z (form_match (inst_fn p1,inst_fn p2) env)\n          end\n        else\n          raise Fail \"form_match\"\n  | _ => raise Fail \"form_match\";\n\n(* ------------------------------------------------------------------------- *)\n(* With the current approach to picking Skolem functions.                    *)\n(* ------------------------------------------------------------------------- *)\n\nfun lcfrefute fm n cont =\n  let val sl = skolemfuns fm\n      fun find_skolem fm =\n           tryfind(fn (f,t) => tsubst(form_match (f,fm) undefined) t) sl\n  in\n  lcftab find_skolem ([fm],[],n) cont (undefined,[],0)\n  end;\n\nfun mk_skol (Forall(y,p),fx) q =\n  Imp(Imp(subst (y |==> fx) p,Forall(y,p)),q);\n\nfun simpcont thp (env,sks,k) =\n  let val ifn = tsubst(solve env) in\n  thp(ifn,onformula ifn (itlist mk_skol sks Falsity))\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(*         |- (p(v) ==> forall x. p(x)) ==> q                                *)\n(*       -------------------------------------- elim_skolemvar               *)\n(*                   |- q                                                    *)\n(* ------------------------------------------------------------------------- *)\n\nfun elim_skolemvar th =\n  case concl th of\n    Imp(Imp(pv,(apx as Forall(x,px))),q) =>\n        let val [th1,th2] = List.map (imp_trans(imp_add_concl Falsity th))\n                            (imp_false_conseqs pv apx)\n            val v = hd(subtract_str (fv pv) (fv apx) @ [x])\n            val th3 = gen_right v th1\n            val th4 = imp_trans th3 (alpha x (consequent(concl th3))) in\n        modusponens (axiom_doubleneg q) (right_mp th2 th4)\n        end\n  | _ => raise Fail \"elim_skolemvar\";\n\n(* ------------------------------------------------------------------------- *)\n(* Top continuation with careful sorting and variable replacement.           *)\n(* Also need to delete post-instantiation duplicates! This shows up more     *)\n(* often now that we have adequate sharing.                                  *)\n(* ------------------------------------------------------------------------- *)\n\nfun deskolcont thp (env,sks,k) =\n  let val ifn = tsubst(solve env)\n      val isk = setify_ftp(List.map (fn (p,t) => (onformula ifn p,ifn t)) sks)\n      val ssk = sort (decreasing (termsize o snd)) isk\n      val vs  = List.map (fn i => Var(\"Y_\"^Int.toString i)) (1--List.length ssk)\n      val vfn = replacet(itlist2 (fn (p,t) => fn v => t |---> v) ssk vs undefined)\n      val th  = thp(vfn o ifn,onformula vfn (itlist mk_skol ssk Falsity)) in\n  repeat (elim_skolemvar o imp_swap) th\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* Overall first-order prover.                                               *)\n(* ------------------------------------------------------------------------- *)\n\nfun lcffol fm =\n  let val fvs = fv fm\n      val fm' = Imp(itlist mk_forall fvs fm,Falsity)\n      val th1 = deepen (fn n => lcfrefute fm' n deskolcont) 0\n      val th2 = modusponens (axiom_doubleneg (negatef fm')) th1 in\n  itlist (fn v => spec(Var v)) (rev fvs) th2\n  end;\n\n\\<close>"], ["", "ML \\<open>\"tactics.sml\";\n\n(* ========================================================================= *)\n(* Goals, LCF-like tactics and Mizar-like proofs.                            *)\n(* ========================================================================= *)\n\ndatatype goals =\n  Goals of ((string * fol fm) list * fol fm)list *\n           (thm list -> thm);\n\n(* ------------------------------------------------------------------------- *)\n(* Printer for goals (just shows first goal plus total number).              *)\n(* ------------------------------------------------------------------------- *)\n\nval print_goal_aux =\n    let fun print_hyp (l, fm) = (\n        open_hbox();\n        print_string (l^\":\");\n        print_space ();\n        print_formula_aux print_atom_aux fm;\n        print_newline();\n        close_box()\n    ) in\n    fn (Goals (gls, jfn)) =>\n        case gls of\n          [] =>\n            print_string \"No subgoals\"\n        | (asl, w) :: ogls =>(\n            print_newline ();\n            if ogls = [] then\n                print_string \"1 subgoal:\"\n            else (\n                print_int (List.length gls);\n                print_string \" subgoals starting with\"\n            )\n            ;\n            print_newline();\n            List.app print_hyp (List.rev asl);\n            print_string \"---> \";\n            open_hvbox 0; print_formula_aux print_atom_aux w; close_box();\n            print_newline ()\n          )\n    end;\n\nfun print_goal g = (print_goal_aux g; print_flush ());\n\n(* ------------------------------------------------------------------------- *)\n(* Setting up goals and terminating them in a theorem.                       *)\n(* ------------------------------------------------------------------------- *)\n\nfun set_goal p =\n  let fun chk th = if concl th = p then th else raise Fail \"wrong theorem\" in\n  Goals([([],p)],fn [th] => chk(modusponens th truth))\n  end;\n\nfun extract_thm gls =\n  case gls of\n    Goals([],jfn) => jfn []\n  | _ => raise Fail \"extract_thm: unsolved goals\";\n\nfun tac_proof g prf = extract_thm(itlist (fn f => f) (List.rev prf) g);\n\nfun prove p prf = tac_proof (set_goal p) prf;\n\n(* ------------------------------------------------------------------------- *)\n(* Conjunction introduction tactic.                                          *)\n(* ------------------------------------------------------------------------- *)\n\nfun conj_intro_tac (Goals((asl,And(p,q))::gls,jfn)) =\n  let fun jfn' (thp::thq::ths) =\n    jfn(imp_trans_chain [thp, thq] (and_pair p q)::ths) in\n  Goals((asl,p)::(asl,q)::gls,jfn')\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* Handy idiom for tactic that does not split subgoals.                      *)\n(* ------------------------------------------------------------------------- *)\n\nfun jmodify jfn tfn (th::oths) = jfn(tfn th :: oths);\n\n(* ------------------------------------------------------------------------- *)\n(* Version of gen_right with a bound variable change.                        *)\n(* ------------------------------------------------------------------------- *)\n\nfun gen_right_alpha y x th =\n  let val th1 = gen_right y th in\n  imp_trans th1 (alpha x (consequent(concl th1)))\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* Universal introduction.                                                   *)\n(* ------------------------------------------------------------------------- *)\n\nfun forall_intro_tac y (Goals((asl,(fm as Forall(x,p)))::gls,jfn)) =\n  if mem y (fv fm) orelse List.exists (mem y o fv o snd) asl\n  then raise Fail \"fix: variable already free in goal\" else\n  Goals((asl,subst(x |==> Var y) p)::gls,\n        jmodify jfn (gen_right_alpha y x));\n\n(* ------------------------------------------------------------------------- *)\n(* Another inference rule: |- P[t] ==> exists x. P[x]                        *)\n(* ------------------------------------------------------------------------- *)\n\nfun right_exists x t p =\n  let val th = contrapos(ispec t (Forall(x,Not p)))\n      val Not(Not p') = antecedent(concl th) in\n  end_itlist imp_trans\n   [imp_contr p' Falsity, imp_add_concl Falsity (iff_imp1 (axiom_not p')),\n    iff_imp2(axiom_not (Not p')), th, iff_imp2(axiom_exists x p)]\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* Existential introduction.                                                 *)\n(* ------------------------------------------------------------------------- *)\n\nfun exists_intro_tac t (Goals((asl,Exists(x,p))::gls,jfn)) =\n  Goals((asl,subst(x |==> t) p)::gls,\n        jmodify jfn (fn th => imp_trans th (right_exists x t p))) ;\n\n(* ------------------------------------------------------------------------- *)\n(* Implication introduction tactic.                                          *)\n(* ------------------------------------------------------------------------- *)\n\nfun imp_intro_tac s (Goals((asl,Imp(p,q))::gls,jfn)) =\n  let val jmod = if asl = [] then add_assum Truth else imp_swap o shunt in\n  Goals(((s,p)::asl,q)::gls,jmodify jfn jmod)\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* Append contextual hypothesis to unconditional theorem.                    *)\n(* ------------------------------------------------------------------------- *)\n\nfun assumptate (Goals((asl,w)::gls,jfn)) th =\n  add_assum (list_conj (map snd asl)) th;\n\n(* ------------------------------------------------------------------------- *)\n(* Get the first assumption (quicker than head of assumps result).           *)\n(* ------------------------------------------------------------------------- *)\n\nfun firstassum asl =\n  let val p = snd(hd asl)\n      val q = list_conj(List.map snd (List.tl asl)) in\n  if tl asl = [] then imp_refl p else and_left p q\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* Import \"external\" theorem.                                                *)\n(* ------------------------------------------------------------------------- *)\n\nfun using ths p g =\n  let val ths' = map (fn th => itlist gen (fv(concl th)) th) ths in\n  List.map (assumptate g) ths'\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* Turn assumptions p1,...,pn into theorems |- p1 /\\ ... /\\ pn ==> pi        *)\n(* ------------------------------------------------------------------------- *)\n\nfun assumps asl =\n  case asl of\n    [] => []\n  | [(l,p)] => [(l,imp_refl p)]\n  | (l,p)::lps =>\n        let val ths = assumps lps\n            val q = antecedent(concl(snd(List.hd ths)))\n            val rth = and_right p q in\n        (l,and_left p q)::List.map (fn (l,th) => (l,imp_trans rth th)) ths\n        end;\n\n(* ------------------------------------------------------------------------- *)\n(* Produce canonical theorem from list of theorems or assumption labels.     *)\n(* ------------------------------------------------------------------------- *)\n\nfun by hyps p (Goals((asl,w)::gls,jfn)) =\n  let val ths = assumps asl in\n  List.map (fn s => assoc s ths) hyps\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* Main automatic justification step.                                        *)\n(* ------------------------------------------------------------------------- *)\n\nlocal\n  fun singleton [_] = true\n    | singleton _ = false\nin\n  fun justify byfn hyps p g =\n    let val ths = byfn hyps p g in\n    if singleton ths andalso consequent(concl (List.hd ths)) = p then (\n      List.hd ths\n    ) else (\n      let val th = lcffol(itlist (mk_imp o consequent o concl) ths p) in\n      case ths of\n        [] => assumptate g th\n      | _  => imp_trans_chain ths th\n      end\n    )\n    end\nend;\n\n(* ------------------------------------------------------------------------- *)\n(* Nested subproof.                                                          *)\n(* ------------------------------------------------------------------------- *)\n\nfun proof tacs p (Goals((asl,w)::gls,jfn)) =\n  [tac_proof (Goals([(asl,p)],fn [th] => th)) tacs];\n\n(* ------------------------------------------------------------------------- *)\n(* Trivial justification, producing no hypotheses.                           *)\n(* ------------------------------------------------------------------------- *)\n\nfun at once p gl = [];\nval once = [];\n\n(* ------------------------------------------------------------------------- *)\n(* Hence an automated terminal tactic.                                       *)\n(* ------------------------------------------------------------------------- *)\n\nfun auto_tac byfn hyps (g as Goals((asl,w)::gls,jfn)) =\n  let val th = justify byfn hyps w g in\n  Goals(gls,fn ths => jfn(th::ths))\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* A \"lemma\" tactic.                                                         *)\n(* ------------------------------------------------------------------------- *)\n\nfun lemma_tac s p byfn hyps (g as Goals((asl,w)::gls,jfn)) =\n  let val tr = imp_trans(justify byfn hyps p g)\n      val mfn = if asl = [] then tr else imp_unduplicate o tr o shunt in\n  Goals(((s,p)::asl,w)::gls,jmodify jfn mfn)\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* Elimination tactic for existential quantification.                        *)\n(* ------------------------------------------------------------------------- *)\n\nfun exists_elim_tac l fm byfn hyps (g as Goals((asl,w)::gls,jfn)) =\n  let val Exists(x,p) = fm in\n  if List.exists (mem x o fv) (w::List.map snd asl)\n  then raise Fail \"exists_elim_tac: variable free in assumptions\" else\n  let val th = justify byfn hyps (Exists(x,p)) g\n      fun jfn' pth = imp_unduplicate(imp_trans th (exists_left x (shunt pth)))\n  in\n  Goals(((l,p)::asl,w)::gls,jmodify jfn jfn')\n  end end;\n\n(* ------------------------------------------------------------------------- *)\n(* If |- p ==> r and |- q ==> r then |- p \\/ q ==> r                         *)\n(* ------------------------------------------------------------------------- *)\n\nfun ante_disj th1 th2 =\n  let val (p,r) = dest_imp(concl th1)\n      val (q,s) = dest_imp(concl th2)\n      val ths = map contrapos [th1, th2]\n      val th3 = imp_trans_chain ths (and_pair (Not p) (Not q))\n      val th4 = contrapos(imp_trans (iff_imp2(axiom_not r)) th3)\n      val th5 = imp_trans (iff_imp1(axiom_or p q)) th4 in\n  right_doubleneg(imp_trans th5 (iff_imp1(axiom_not(Imp(r,Falsity)))))\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* Elimination tactic for disjunction.                                       *)\n(* ------------------------------------------------------------------------- *)\n\nfun disj_elim_tac l fm byfn hyps (g as Goals((asl,w)::gls,jfn) ) =\n  let val th = justify byfn hyps fm g\n      val Or(p,q) = fm\n      fun jfn' (pth::qth::ths) =\n         let val th1 = imp_trans th (ante_disj (shunt pth) (shunt qth)) in\n         jfn(imp_unduplicate th1::ths)\n         end\n  in\n  Goals(((l,p)::asl,w)::((l,q)::asl,w)::gls,jfn')\n  end;\n\n(* ------------------------------------------------------------------------- *)\n(* Declarative proof.                                                        *)\n(* ------------------------------------------------------------------------- *)\n\nfun multishunt i th =\n  let val th1 = imp_swap(funpow i (imp_swap o shunt) th) in\n  imp_swap(funpow (i-1) (unshunt o imp_front 2) th1)\n  end;\n\nfun assume lps (Goals((asl,Imp(p,q))::gls,jfn)) =\n  if end_itlist mk_and (map snd lps) <> p then raise Fail \"assume\" else\n  let fun jfn' th =\n    if asl = [] then add_assum Truth th else multishunt (length lps) th in\n  Goals((lps@asl,q)::gls,jmodify jfn jfn')\n  end;\n\nfun note (l,p) = lemma_tac l p;\n\nfun have p = note(\"\",p);\n\nfun so tac arg byfn =\n  tac arg (fn hyps => fn p => fn (gl as Goals((asl,w)::_,_)) =>\n                     firstassum asl :: byfn hyps p gl);\n\nval fix = forall_intro_tac;\n\nfun consider (x,p) = exists_elim_tac \"\" (Exists(x,p));\n\nfun take tm gls = exists_intro_tac tm gls;\n\nfun cases fm byfn hyps g = disj_elim_tac \"\" fm byfn hyps g;\n\n(* ------------------------------------------------------------------------- *)\n(* Thesis modification.                                                      *)\n(* ------------------------------------------------------------------------- *)\n\nfun conclude p byfn hyps (gl as Goals((asl,w)::gls,jfn)) =\n  let val th = justify byfn hyps p gl in\n  if p = w then Goals((asl,Truth)::gls,jmodify jfn (fn _ => th)) else\n  let val (p',q) = dest_and w in\n  if p' <> p then raise Fail \"conclude: bad conclusion\" else\n  let fun mfn th' = imp_trans_chain [th, th'] (and_pair p q) in\n  Goals((asl,q)::gls,jmodify jfn mfn)\n  end end end;\n\n(* ------------------------------------------------------------------------- *)\n(* A useful shorthand for solving the whole goal.                            *)\n(* ------------------------------------------------------------------------- *)\n\nfun our thesis byfn hyps (gl as Goals((asl,w)::gls,jfn)) =\n  conclude w byfn hyps gl;\nval thesis = \"\";\n\n(* ------------------------------------------------------------------------- *)\n(* Termination.                                                              *)\n(* ------------------------------------------------------------------------- *)\n\nfun qed (gl as Goals((asl,w)::gls,jfn)) =\n  if w = Truth then Goals(gls,fn ths => jfn(assumptate gl truth :: ths))\n  else raise Fail \"qed: non-trivial goal\";\n\n(* ------------------------------------------------------------------------- *)\n(* A simple example.                                                         *)\n(* ------------------------------------------------------------------------- *)\n\nval ewd954 = prove\n (<!(\"(forall x y. x <= y <=> x * y = x) /\\\\ \" ^\n   \"(forall x y. f(x * y) = f(x) * f(y)) \" ^\n   \"==> forall x y. x <= y ==> f(x) <= f(y)\")!>)\n [note(\"eq_sym\",<!\"forall x y. x = y ==> y = x\"!>)\n    using [eq_sym (<!|\"x\"|!>) (<!|\"y\"|!>)],\n  note(\"eq_trans\",<!\"forall x y z. x = y /\\\\ y = z ==> x = z\"!>)\n    using [eq_trans (<!|\"x\"|!>) (<!|\"y\"|!>) (<!|\"z\"|!>)],\n  note(\"eq_cong\",<!\"forall x y. x = y ==> f(x) = f(y)\"!>)\n    using [axiom_funcong \"f\" [(<!|\"x\"|!>)] [(<!|\"y\"|!>)]],\n  assume [(\"le\",<!\"forall x y. x <= y <=> x * y = x\"!>),\n          (\"hom\",<!\"forall x y. f(x * y) = f(x) * f(y)\"!>)],\n  fix \"x\", fix \"y\",\n  assume [(\"xy\",<!\"x <= y\"!>)],\n  so have (<!\"x * y = x\"!>) by [\"le\"],\n  so have (<!\"f(x * y) = f(x)\"!>) by [\"eq_cong\"],\n  so have (<!\"f(x) = f(x * y)\"!>) by [\"eq_sym\"],\n  so have (<!\"f(x) = f(x) * f(y)\"!>) by [\"eq_trans\", \"hom\"],\n  so have (<!\"f(x) * f(y) = f(x)\"!>) by [\"eq_sym\"],\n  so conclude (<!\"f(x) <= f(y)\"!>) by [\"le\"],\n  qed];\n\n(* ------------------------------------------------------------------------- *)\n(* More examples not in the main text.                                       *)\n(* ------------------------------------------------------------------------- *)\n\nprove\n (<!(\"(exists x. p(x)) ==> (forall x. p(x) ==> p(f(x))) \" ^\n   \"==> exists y. p(f(f(f(f(y)))))\")!>)\n  [assume [(\"A\",<!\"exists x. p(x)\"!>)],\n   assume [(\"B\",<!\"forall x. p(x) ==> p(f(x))\"!>)],\n   note (\"C\",<!\"forall x. p(x) ==> p(f(f(f(f(x)))))\"!>)\n   proof\n    [have (<!\"forall x. p(x) ==> p(f(f(x)))\"!>) by [\"B\"],\n     so conclude (<!\"forall x. p(x) ==> p(f(f(f(f(x)))))\"!>) at once,\n     qed],\n   consider (\"a\",<!\"p(a)\"!>) by [\"A\"],\n   take (<!|\"a\"|!>),\n   so conclude (<!\"p(f(f(f(f(a)))))\"!>) by [\"C\"],\n   qed];\n\n(* ------------------------------------------------------------------------- *)\n(* Alternative formulation with lemma construct.                             *)\n(* ------------------------------------------------------------------------- *)\n\nlet fun lemma (s,p) (gl as Goals((asl,w)::gls,jfn)) =\n  Goals((asl,p)::((s,p)::asl,w)::gls,\n        fn (thp::thw::oths) =>\n            jfn(imp_unduplicate(imp_trans thp (shunt thw)) :: oths)) in\nprove\n (<!(\"(exists x. p(x)) ==> (forall x. p(x) ==> p(f(x))) \" ^\n   \"==> exists y. p(f(f(f(f(y)))))\")!>)\n  [assume [(\"A\",<!\"exists x. p(x)\"!>)],\n   assume [(\"B\",<!\"forall x. p(x) ==> p(f(x))\"!>)],\n   lemma (\"C\",<!\"forall x. p(x) ==> p(f(f(f(f(x)))))\"!>),\n     have (<!\"forall x. p(x) ==> p(f(f(x)))\"!>) by [\"B\"],\n     so conclude (<!\"forall x. p(x) ==> p(f(f(f(f(x)))))\"!>) at once,\n     qed,\n   consider (\"a\",<!\"p(a)\"!>) by [\"A\"],\n   take (<!|\"a\"|!>),\n   so conclude (<!\"p(f(f(f(f(a)))))\"!>) by [\"C\"],\n   qed]\nend;\n\n(* ------------------------------------------------------------------------- *)\n(* Examples.                                                                 *)\n(* ------------------------------------------------------------------------- *)\n\nprove (<!(\"p(a) ==> (forall x. p(x) ==> p(f(x))) \" ^\n        \"==> exists y. p(y) /\\\\ p(f(y))\")!>)\n      [our thesis at once,\n       qed];\n\nprove\n (<!(\"(exists x. p(x)) ==> (forall x. p(x) ==> p(f(x))) \" ^\n   \"==> exists y. p(f(f(f(f(y)))))\")!>)\n  [assume [(\"A\",<!\"exists x. p(x)\"!>)],\n   assume [(\"B\",<!\"forall x. p(x) ==> p(f(x))\"!>)],\n   note (\"C\",<!\"forall x. p(x) ==> p(f(f(f(f(x)))))\"!>) proof\n    [have (<!\"forall x. p(x) ==> p(f(f(x)))\"!>) by [\"B\"],\n     so our thesis at once,\n     qed],\n   consider (\"a\",<!\"p(a)\"!>) by [\"A\"],\n   take (<!|\"a\"|!>),\n   so our thesis by [\"C\"],\n   qed];\n\nprove (<!(\"forall a. p(a) ==> (forall x. p(x) ==> p(f(x))) \" ^\n                  \"==> exists y. p(y) /\\\\ p(f(y))\")!>)\n      [fix \"c\",\n       assume [(\"A\",<!\"p(c)\"!>)],\n       assume [(\"B\",<!\"forall x. p(x) ==> p(f(x))\"!>)],\n       take (<!|\"c\"|!>),\n       conclude (<!\"p(c)\"!>) by [\"A\"],\n       note (\"C\",<!\"p(c) ==> p(f(c))\"!>) by [\"B\"],\n       so our thesis by [\"C\", \"A\"],\n       qed];\n\nprove (<!(\"p(c) ==> (forall x. p(x) ==> p(f(x))) \" ^\n                  \"==> exists y. p(y) /\\\\ p(f(y))\")!>)\n      [assume [(\"A\",<!\"p(c)\"!>)],\n       assume [(\"B\",<!\"forall x. p(x) ==> p(f(x))\"!>)],\n       take (<!|\"c\"|!>),\n       conclude (<!\"p(c)\"!>) by [\"A\"],\n       our thesis by [\"A\", \"B\"],\n       qed];\n\nprove (<!(\"forall a. p(a) ==> (forall x. p(x) ==> p(f(x))) \" ^\n                  \"==> exists y. p(y) /\\\\ p(f(y))\")!>)\n      [fix \"c\",\n       assume [(\"A\",<!\"p(c)\"!>)],\n       assume [(\"B\",<!\"forall x. p(x) ==> p(f(x))\"!>)],\n       take (<!|\"c\"|!>),\n       conclude (<!\"p(c)\"!>) by [\"A\"],\n       note (\"C\",<!\"p(c) ==> p(f(c))\"!>) by [\"B\"],\n       our thesis by [\"C\", \"A\"],\n       qed];\n\nprove (<!(\"forall a. p(a) ==> (forall x. p(x) ==> p(f(x))) \" ^\n                  \"==> exists y. p(y) /\\\\ p(f(y))\")!>)\n      [fix \"c\",\n       assume [(\"A\",<!\"p(c)\"!>)],\n       assume [(\"B\",<!\"forall x. p(x) ==> p(f(x))\"!>)],\n       take (<!|\"c\"|!>),\n       note (\"D\",<!\"p(c)\"!>) by [\"A\"],\n       note (\"C\",<!\"p(c) ==> p(f(c))\"!>) by [\"B\"],\n       our thesis by [\"C\", \"A\", \"D\"],\n       qed];\n\nprove (<!\"(p(a) \\\\/ p(b)) ==> q ==> exists y. p(y)\"!>)\n  [assume [(\"A\",<!\"p(a) \\\\/ p(b)\"!>)],\n   assume [(\"\",<!\"q\"!>)],\n   cases (<!\"p(a) \\\\/ p(b)\"!>) by [\"A\"],\n     take (<!|\"a\"|!>),\n     so our thesis at once,\n     qed,\n\n     take (<!|\"b\"|!>),\n     so our thesis at once,\n     qed];\n\nprove\n  (<!\"(p(a) \\\\/ p(b)) /\\\\ (forall x. p(x) ==> p(f(x))) ==> exists y. p(f(y))\"!>)\n  [assume [(\"base\",<!\"p(a) \\\\/ p(b)\"!>),\n           (\"Step\",<!\"forall x. p(x) ==> p(f(x))\"!>)],\n   cases (<!\"p(a) \\\\/ p(b)\"!>) by [\"base\"],\n     so note(\"A\",<!\"p(a)\"!>) at once,\n     note (\"X\",<!\"p(a) ==> p(f(a))\"!>) by [\"Step\"],\n     take (<!|\"a\"|!>),\n     our thesis by [\"A\", \"X\"],\n     qed,\n\n     take (<!|\"b\"|!>),\n     so our thesis by [\"Step\"],\n     qed];\n\nprove\n (<!\"(exists x. p(x)) ==> (forall x. p(x) ==> p(f(x))) ==> exists y. p(f(y))\"!>)\n  [assume [(\"A\",<!\"exists x. p(x)\"!>)],\n   assume [(\"B\",<!\"forall x. p(x) ==> p(f(x))\"!>)],\n   consider (\"a\",<!\"p(a)\"!>) by [\"A\"],\n   so note (\"concl\",<!\"p(f(a))\"!>) by [\"B\"],\n   take (<!|\"a\"|!>),\n   our thesis by [\"concl\"],\n   qed];\n\nprove (<!(\"(forall x. p(x) ==> q(x)) ==> (forall x. q(x) ==> p(x)) \" ^\n       \"==> (p(a) <=> q(a))\")!>)\n  [assume [(\"A\",<!\"forall x. p(x) ==> q(x)\"!>)],\n   assume [(\"B\",<!\"forall x. q(x) ==> p(x)\"!>)],\n   note (\"von\",<!\"p(a) ==> q(a)\"!>) by [\"A\"],\n   note (\"bis\",<!\"q(a) ==> p(a)\"!>) by [\"B\"],\n   our thesis by [\"von\", \"bis\"],\n   qed];\n\n\\<close>"], ["", "section \\<open>Main Examples\\<close>"], ["", "ML_val \\<open>(* Hoare's Exercise ewd1062_1 & ewd1062_2 (Harrison has only a proof with tactics) *)\n\nprove\n  (<!(\"(forall x. x <= x) /\\\\ \" ^\n      \"(forall x y z. x <= y /\\\\ y <= z ==> x <= z) /\\\\ \" ^\n      \"(forall x y. f(x) <= y <=> x <= g(y)) \" ^\n      \"==> (forall x y. x <= y ==> f(x) <= f(y)) /\\\\ \" ^\n          \"(forall x y. x <= y ==> g(x) <= g(y))\")!>)\n  [\n    assume [(\"A\", <!(\"(forall x. x <= x) /\\\\ \" ^\n             \"(forall x y z. x <= y /\\\\ y <= z ==> x <= z) /\\\\ \" ^\n             \"(forall x y. f(x) <= y <=> x <= g(y))\")!>)],\n    conclude (<!(\"(forall x y. x <= y ==> f(x) <= f(y)) /\\\\ \" ^\n                 \"(forall x y. x <= y ==> g(x) <= g(y))\")!>) proof\n    [\n      conclude (<!\"(forall x y. x <= y ==> f(x) <= f(y))\"!>) by [\"A\"],\n      conclude (<!\"(forall x y. x <= y ==> g(x) <= g(y))\"!>) by [\"A\"],\n      qed\n    ],\n    qed\n  ]\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p43 (Harrison has it in a comment but the proof seems not to finish) *)\n\nprove\n  (<!\"(forall x y. Q(x,y) <=> forall z. P(z,x) <=> P(z,y)) ==> forall x y. Q(x,y) <=> Q(y,x)\"!>)\n  [\n    assume [(\"A\", <!\"forall x y. Q(x,y) <=> forall z. P(z,x) <=> P(z,y)\"!>)],\n    conclude (<!\"forall x y. Q(x,y) <=> Q(y,x)\"!>) proof\n    [\n      fix \"x\", fix \"y\",\n      conclude (<!\"Q(x,y) <=> Q(y,x)\"!>) proof\n      [\n        have (<!\"(Q(x,y) ==> Q(y,x)) /\\\\ (Q(y,x) ==> Q(x,y))\"!>) proof\n        [\n          conclude (<!\"Q(x,y) ==> Q(y,x)\"!>) proof\n          [\n            assume [(\"\", <!\"Q(x,y)\"!>)],\n            so have (<!\"forall z. P(z,x) <=> P(z,y)\"!>) by [\"A\"],\n            so have (<!\"forall z. P(z,y) <=> P(z,x)\"!>) at once,\n            so conclude (<!\"Q(y,x)\"!>) by [\"A\"],\n            qed\n          ],\n          conclude (<!\"Q(y,x) ==> Q(x,y)\"!>) proof\n          [\n            assume [(\"\", <!\"Q(y,x)\"!>)],\n            so have (<!\"forall z. P(z,y) <=> P(z,x)\"!>) by [\"A\"],\n            so have (<!\"forall z. P(z,x) <=> P(z,y)\"!>) at once,\n            so conclude (<!\"Q(x,y)\"!>) by [\"A\"],\n            qed\n          ],\n          qed\n        ],\n        so our thesis at once,\n        qed\n      ],\n      qed\n    ],\n    qed\n  ]\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p46 (Harrison does not have it) *)\n\n  prove\n    (<!(\"(forall x. P(x) /\\\\ (forall y. P(y) /\\\\ H(y,x) ==> G(y)) ==> G(x)) /\\\\ \" ^\n          \"((exists x. P(x) /\\\\ ~G(x)) ==> \" ^\n            \"(exists x. P(x) /\\\\ ~G(x) /\\\\ (forall y. P(y) /\\\\ ~G(y) ==> J(x,y)))) /\\\\ \" ^\n          \"(forall x y. P(x) /\\\\ P(y) /\\\\ H(x,y) ==> ~J(y,x)) ==> \" ^\n          \"(forall x. P(x) ==> G(x))\")!>)\n    [\n      assume [(\"A\", <!(\"(forall x. P(x) /\\\\ (forall y. P(y) /\\\\ H(y,x) ==> G(y)) ==> G(x)) /\\\\ \" ^\n          \"((exists x. P(x) /\\\\ ~G(x)) ==> \" ^\n            \"(exists x. P(x) /\\\\ ~G(x) /\\\\ (forall y. P(y) /\\\\ ~G(y) ==> J(x,y)))) /\\\\ \" ^\n          \"(forall x y. P(x) /\\\\ P(y) /\\\\ H(x,y) ==> ~J(y,x))\")!>)],\n      conclude (<!\"(forall x. P(x) ==> G(x))\"!>) proof\n      [\n        fix \"x\",\n        conclude (<!\"P(x) ==> G(x)\"!>) proof\n        [\n          assume [(\"B\", <!\"P(x)\"!>)],\n          conclude (<!\"G(x)\"!>) by [\"B\",\"A\"], qed\n        ], qed\n      ], qed\n    ]\n\n\\<close>"], ["", "section \\<open>Other Examples\\<close>"], ["", "(* For Pelletier's Problem 34 aka Andrews's Challenge *)"], ["", "ML \\<open>\n\nfun by_mp (ab, a) p (Goals((asl,_)::_,_)) =\n  let\n    val ths = assumps asl\n    val th = right_mp (assoc ab ths) (assoc a ths)\n    handle Fail _ => raise Fail \"by_mp: unapplicable assumptions\"\n  in\n  if consequent (concl th) = p then [th] else raise Fail \"by_mp: wrong conclusion\"\n  end\n  | by_mp _ _ _ = raise Fail \"Match by_mp\"\n;\n\n\\<close>"], ["", "(* Function auto as a basic declarative proof *)"], ["", "ML \\<open>fun auto s = prove (<!s!>) [our thesis at once, qed]\\<close>"], ["", "ML_val \\<open>auto \"A ==> A\"\\<close>"], ["", "ML_val \\<open>auto \"exists x. D(x) ==> forall x. D(x)\"\\<close>"], ["", "ML_val \\<open>auto \"(forall x. ~R(x) ==> R(f(x))) ==> exists x. R(x) /\\\\ R(f(f(x)))\"\\<close>"], ["", "ML_val \\<open>(* Harrison p58 (as mentioned in the errata it is not Pelletier p58) *)\n\nauto \"forall x. exists v w. forall y z. P(x) /\\\\ Q(y) ==> (P(v) \\\\/ R(w)) /\\\\ (R(z) ==> Q(v))\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p1 *)\n\nauto \"p ==> q <=> ~q ==> ~p\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p2 *)\n\nauto \"~ ~p <=> p\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p3 *)\n\nauto \"~(p ==> q) ==> q ==> p\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p4 *)\n\nauto \"~p ==> q <=> ~q ==> p\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p5 *)\n\nauto \"(p \\\\/ q ==> p \\\\/ r) ==> p \\\\/ (q ==> r)\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p6 *)\n\nauto \"p \\\\/ ~p\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p7 *)\n\nauto \"p \\\\/ ~ ~ ~p\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p8 *)\n\nauto \"((p ==> q) ==> p) ==> p\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p9 *)\n\nauto \"(p \\\\/ q) /\\\\ (~p \\\\/ q) /\\\\ (p \\\\/ ~q) ==> ~(~q \\\\/ ~q)\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p10 *)\n\nauto \"(q ==> r) /\\\\ (r ==> p /\\\\ q) /\\\\ (p ==> q /\\\\ r) ==> (p <=> q)\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p11 *)\n\nauto \"p <=> p\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p12 *)\n\nauto \"((p <=> q) <=> r) <=> (p <=> (q <=> r))\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p13 *)\n\nauto \"p \\\\/ q /\\\\ r <=> (p \\\\/ q) /\\\\ (p \\\\/ r)\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p14 *)\n\nauto \"(p <=> q) <=> (q \\\\/ ~p) /\\\\ (~q \\\\/ p)\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p15 *)\n\nauto \"p ==> q <=> ~p \\\\/ q\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p16 *)\n\nauto \"(p ==> q) \\\\/ (q ==> p)\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p17 *)\n\nauto \"p /\\\\ (q ==> r) ==> s <=> (~p \\\\/ q \\\\/ s) /\\\\ (~p \\\\/ ~r \\\\/ s)\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p18 *)\n\nauto \"exists y. forall x. P(y) ==> P(x)\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p19 *)\n\nauto \"exists x. forall y z. (P(y) ==> Q(z)) ==> P(x) ==> Q(x)\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p20 *)\n\nauto (\"(forall x y. exists z. forall w. P(x) /\\\\ Q(y) ==> R(z) /\\\\ U(w)) \" ^\n      \"==> (exists x y. P(x) /\\\\ Q(y)) ==> (exists z. R(z))\")\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p21 *)\n\nauto \"(exists x. P ==> Q(x)) /\\\\ (exists x. Q(x) ==> P) ==> (exists x. P <=> Q(x))\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p22 *)\n\nauto \"(forall x. P <=> Q(x)) ==> (P <=> (forall x. Q(x)))\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p23 *)\n\nauto \"(forall x. P \\\\/ Q(x)) <=> P \\\\/ (forall x. Q(x))\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p24 *)\n\nauto (\"~(exists x. U(x) /\\\\ Q(x)) /\\\\ \" ^\n      \"(forall x. P(x) ==> Q(x) \\\\/ R(x)) /\\\\ \" ^\n      \"~(exists x. P(x) ==> (exists x. Q(x))) /\\\\ \" ^\n      \"(forall x. Q(x) /\\\\ R(x) ==> U(x)) \" ^\n      \"==> (exists x. P(x) /\\\\ R(x))\")\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p25 *)\n\nauto (\"(exists x. P(x)) /\\\\ \" ^\n      \"(forall x. U(x) ==> ~G(x) /\\\\ R(x)) /\\\\ \" ^\n      \"(forall x. P(x) ==> G(x) /\\\\ U(x)) /\\\\ \" ^\n      \"((forall x. P(x) ==> Q(x)) \\\\/ (exists x. Q(x) /\\\\ P(x))) \" ^\n      \"==> (exists x. Q(x) /\\\\ P(x))\")\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p26 *)\n\nauto (\"((exists x. P(x)) <=> (exists x. Q(x))) /\\\\ \" ^\n      \"(forall x y. P(x) /\\\\ Q(y) ==> (R(x) <=> U(y))) \" ^\n      \"==> ((forall x. P(x) ==> R(x)) <=> (forall x. Q(x) ==> U(x)))\")\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p27 *)\n\nauto (\"(exists x. P(x) /\\\\ ~Q(x)) /\\\\ \" ^\n      \"(forall x. P(x) ==> R(x)) /\\\\ \" ^\n      \"(forall x. U(x) /\\\\ V(x) ==> P(x)) /\\\\ \" ^\n      \"(exists x. R(x) /\\\\ ~Q(x)) \" ^\n      \"==> (forall x. V(x) ==> ~R(x)) ==> (forall x. U(x) ==> ~V(x))\")\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p28 *)\n\nauto (\"(forall x. P(x) ==> (forall x. Q(x))) /\\\\ \" ^\n      \"((forall x. Q(x) \\\\/ R(x)) ==> (exists x. Q(x) /\\\\ R(x))) /\\\\ \" ^\n      \"((exists x. R(x)) ==> (forall x. L(x) ==> M(x))) \" ^\n      \"==> (forall x. P(x) /\\\\ L(x) ==> M(x))\")\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p29 *)\n\nauto (\"(exists x. P(x)) /\\\\ (exists x. G(x)) ==> \" ^\n      \"((forall x. P(x) ==> H(x)) /\\\\ (forall x. G(x) ==> J(x)) \" ^\n      \"<=> (forall x y. P(x) /\\\\ G(y) ==> H(x) /\\\\ J(y)))\")\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p30 *)\n\nauto (\"(forall x. P(x) \\\\/ G(x) ==> ~H(x)) /\\\\ \" ^\n      \"(forall x. (G(x) ==> ~U(x)) ==> P(x) /\\\\ H(x)) \" ^\n      \"==> (forall x. U(x))\")\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p31 *)\n\nauto (\"~(exists x. P(x) /\\\\ (G(x) \\\\/ H(x))) /\\\\ \" ^\n      \"(exists x. Q(x) /\\\\ P(x)) /\\\\ \" ^\n      \"(forall x. ~H(x) ==> J(x)) \" ^\n      \"==> (exists x. Q(x) /\\\\ J(x))\")\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p32 *)\n\nauto (\"(forall x. P(x) /\\\\ (G(x) \\\\/ H(x)) ==> Q(x)) /\\\\ \" ^\n      \"(forall x. Q(x) /\\\\ H(x) ==> J(x)) /\\\\ \" ^\n      \"(forall x. R(x) ==> H(x)) \" ^\n      \"==> (forall x. P(x) /\\\\ R(x) ==> J(x))\")\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p33 *)\n\nauto (\"(forall x. P(a) /\\\\ (P(x) ==> P(b)) ==> P(c)) \" ^\n      \"<=> (forall x. P(a) ==> P(x) \\\\/ P(c)) /\\\\ (P(a) ==> P(b) ==> P(c))\")\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p34 *)\n\nprove\n(<!(\"((exists x. forall y. P(x) <=> P(y)) <=> ((exists x. Q(x)) <=> (forall y. Q(y)))) <=>\"\n^   \"((exists x. forall y. Q(x) <=> Q(y)) <=> ((exists x. P(x)) <=> (forall y. P(y))))\")!>)\n[\n\n  note (\"directions\",\n  <!(\"(((exists x. forall y. P(x) <=> P(y)) <=> ((exists x. Q(x)) <=> (forall y. Q(y)))) ==>\"\n^    \"((exists x. forall y. Q(x) <=> Q(y)) <=> ((exists x. P(x)) <=> (forall y. P(y))))) /\\\\\"\n^    \"(((exists x. forall y. Q(x) <=> Q(y)) <=> ((exists x. P(x)) <=> (forall y. P(y)))) ==>\"\n^    \"((exists x. forall y. P(x) <=> P(y)) <=> ((exists x. Q(x)) <=> (forall y. Q(y)))))\")!>)\n  proof\n  [\n    conclude\n    (<!(\"((exists x. forall y. P(x) <=> P(y)) <=> ((exists x. Q(x)) <=> (forall y. Q(y)))) ==>\"\n^       \"((exists x. forall y. Q(x) <=> Q(y)) <=> ((exists x. P(x)) <=> (forall y. P(y))))\")!>)\n    proof\n    [\n      assume [(\"A\",\n      <!\"(exists x. forall y. P(x) <=> P(y)) <=> ((exists x. Q(x)) <=> (forall y. Q(y)))\"!>)],\n\n      note (\"ant\",\n      <!(\"((exists x. forall y. Q(x) <=> Q(y)) ==> ((exists x. P(x)) <=> (forall y. P(y)))) /\\\\\"\n^        \"(((exists x. P(x)) <=> (forall y. P(y))) ==> ((exists x. forall y. Q(x) <=> Q(y))))\")!>)\n      proof\n      [\n\n        conclude\n        (<!\"(exists x. forall y. Q(x) <=> Q(y)) ==> ((exists x. P(x)) <=> (forall y. P(y)))\"!>)\n        proof\n        [\n          assume [(\"\", <!\"exists x. forall y. Q(x) <=> Q(y)\"!>)],\n          so have (<!\"(exists x. Q(x)) <=> (forall y. Q(y))\"!>) at once,\n          so have (<!\"exists x. forall y. P(x) <=> P(y)\"!>) by [\"A\"],\n          so our thesis at once,\n          qed\n        ],\n\n        conclude\n        (<!\"((exists x. P(x)) <=> (forall y. P(y))) ==> (exists x. forall y. Q(x) <=> Q(y))\"!>)\n        proof\n        [\n          note (\"imp\",\n          <!(\"((exists x. forall y. P(x) <=> P(y)) <=> ((exists x. Q(x)) <=> (forall y. Q(y)))) ==>\"\n^            \"((exists x. forall y. P(x) <=> P(y)) ==> ((exists x. Q(x)) <=> (forall y. Q(y))))\")!>)\n          using [axiom_iffimp1\n            (<!\"exists x. forall y. P(x) <=> P(y)\"!>)\n            (<!\"(exists x. Q(x)) <=> (forall y. Q(y))\"!>)],\n          note (\"A1\",\n           <!\"(exists x. forall y. P(x) <=> P(y)) ==> ((exists x. Q(x)) <=> (forall y. Q(y)))\"!>)\n          by_mp (\"imp\", \"A\"),\n\n          assume [(\"\", <!\"((exists x. P(x)) <=> (forall y. P(y)))\"!>)],\n          so have (<!\"(exists x. forall y. P(x) <=> P(y))\"!>) at once,\n          so have (<!\"((exists x. Q(x)) <=> (forall y. Q(y)))\"!>) by [\"A1\"],\n          so our thesis at once,\n          qed\n        ],\n        qed\n      ],\n\n      note (\"imp\",\n      <!(\"((exists x. forall y. Q(x) <=> Q(y)) ==> ((exists x. P(x)) <=> (forall y. P(y)))) /\\\\\"\n^        \"(((exists x. P(x)) <=> (forall y. P(y))) ==> ((exists x. forall y. Q(x) <=> Q(y)))) ==>\"\n^        \"((exists x. forall y. Q(x) <=> Q(y)) <=> ((exists x. P(x)) <=> (forall y. P(y))))\")!>)\n      using [unshunt (axiom_impiff\n        (<!\"exists x. forall y. Q(x) <=> Q(y)\"!>)\n        (<!\"(exists x. P(x)) <=> (forall y. P(y))\"!>))],\n\n      our thesis by_mp (\"imp\", \"ant\"),\n      qed\n    ],\n\n    conclude\n    (<!(\"((exists x. forall y. Q(x) <=> Q(y)) <=> ((exists x. P(x)) <=> (forall y. P(y)))) ==>\"\n^       \"((exists x. forall y. P(x) <=> P(y)) <=> ((exists x. Q(x)) <=> (forall y. Q(y))))\")!>)\n    proof\n    [\n      assume [(\"A\",\n       <!\"(exists x. forall y. Q(x) <=> Q(y)) <=> ((exists x. P(x)) <=> (forall y. P(y)))\"!>)],\n\n      note (\"ant\",\n      <!(\"((exists x. forall y. P(x) <=> P(y)) ==> ((exists x. Q(x)) <=> (forall y. Q(y)))) /\\\\\"\n^        \"(((exists x. Q(x)) <=> (forall y. Q(y))) ==> (exists x. forall y. P(x) <=> P(y)))\")!>)\n      proof\n      [\n\n        conclude\n        (<!\"(exists x. forall y. P(x) <=> P(y)) ==> ((exists x. Q(x)) <=> (forall y. Q(y)))\"!>)\n        proof\n        [\n          assume [(\"\", <!\"exists x. forall y. P(x) <=> P(y)\"!>)],\n          so have (<!\"(exists x. P(x)) <=> (forall y. P(y))\"!>) at once,\n          so have (<!\"exists x. forall y. Q(x) <=> Q(y)\"!>) by [\"A\"],\n          so our thesis at once,\n          qed\n        ],\n\n        conclude\n        (<!\"((exists x. Q(x)) <=> (forall y. Q(y))) ==> (exists x. forall y. P(x) <=> P(y))\"!>)\n        proof\n        [\n          note (\"imp\",\n          <!(\"((exists x. forall y. Q(x) <=> Q(y)) <=> ((exists x. P(x)) <=> (forall y. P(y)))) ==>\"\n^            \"((exists x. forall y. Q(x) <=> Q(y)) ==> ((exists x. P(x)) <=> (forall y. P(y))))\")!>)\n          using [axiom_iffimp1\n            (<!\"exists x. forall y. Q(x) <=> Q(y)\"!>)\n            (<!\"(exists x. P(x)) <=> (forall y. P(y))\"!>)],\n          note (\"A1\",\n          <!\"(exists x. forall y. Q(x) <=> Q(y)) ==> ((exists x. P(x)) <=> (forall y. P(y)))\"!>)\n          by_mp (\"imp\", \"A\"),\n\n          assume [(\"\", <!\"(exists x. Q(x)) <=> (forall y. Q(y))\"!>)],\n          so have (<!\"(exists x. forall y. Q(x) <=> Q(y))\"!>) at once,\n          so have (<!\"((exists x. P(x)) <=> (forall y. P(y)))\"!>) by [\"A1\"],\n          so our thesis at once,\n          qed\n        ],\n        qed\n      ],\n\n      note (\"imp\",\n      <!(\"((exists x. forall y. P(x) <=> P(y)) ==> ((exists x. Q(x)) <=> (forall y. Q(y)))) /\\\\\"\n^        \"(((exists x. Q(x)) <=> (forall y. Q(y))) ==> (exists x. forall y. P(x) <=> P(y))) ==>\"\n^        \"((exists x. forall y. P(x) <=> P(y)) <=> ((exists x. Q(x)) <=> (forall y. Q(y))))\")!>)\n      using [unshunt (axiom_impiff\n        (<!\"exists x. forall y. P(x) <=> P(y)\"!>)\n        (<!\"(exists x. Q(x)) <=> (forall y. Q(y))\"!>))],\n\n      our thesis by_mp (\"imp\", \"ant\"),\n      qed\n    ],\n    qed\n  ],\n\n  note (\"impiff\",\n  <!((\"(((exists x. forall y. P(x) <=> P(y)) <=> ((exists x. Q(x)) <=> (forall y. Q(y)))) ==>\"\n^     \"((exists x. forall y. Q(x) <=> Q(y)) <=> ((exists x. P(x)) <=> (forall y. P(y))))) /\\\\\"\n^     \"(((exists x. forall y. Q(x) <=> Q(y)) <=> ((exists x. P(x)) <=> (forall y. P(y)))) ==>\"\n^     \"((exists x. forall y. P(x) <=> P(y)) <=> ((exists x. Q(x)) <=> (forall y. Q(y))))) ==>\"\n^     \"(((exists x. forall y. P(x) <=> P(y)) <=> ((exists x. Q(x)) <=> (forall y. Q(y)))) <=>\"\n^     \"((exists x. forall y. Q(x) <=> Q(y)) <=> ((exists x. P(x)) <=> (forall y. P(y)))))\"))!>)\n  using [unshunt (axiom_impiff\n    (<!(\"(exists x. forall y. P(x) <=> P(y)) <=> ((exists x. Q(x)) <=> (forall y. Q(y)))\")!>)\n    (<!(\"(exists x. forall y. Q(x) <=> Q(y)) <=> ((exists x. P(x)) <=> (forall y. P(y)))\")!>))],\n\n  our thesis by_mp (\"impiff\", \"directions\"),\n  qed\n]\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p35 *)\n\nauto \"exists x y. P(x,y) ==> (forall x y. P(x,y))\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p36 *)\n\nauto (\"(forall x. exists y. P(x,y)) /\\\\ \" ^\n      \"(forall x. exists y. G(x,y)) /\\\\ \" ^\n      \"(forall x y. P(x,y) \\\\/ G(x,y) ==> (forall z. P(y,z) \\\\/ G(y,z) ==> H(x,z))) \" ^\n      \"==> (forall x. exists y. H(x,y))\")\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p37 *)\n\nauto (\"(forall z. \" ^\n        \"exists w. forall x. exists y. (P(x,z) ==> P(y,w)) /\\\\ P(y,z) /\\\\ \" ^\n        \"(P(y,w) ==> (exists u. Q(u,w)))) /\\\\ \" ^\n      \"(forall x z. ~P(x,z) ==> (exists y. Q(y,z))) /\\\\ \" ^\n      \"((exists x y. Q(x,y)) ==> (forall x. R(x,x))) \" ^\n      \"==> (forall x. exists y. R(x,y))\")\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p38 *)\n\nauto (\"(forall x. \" ^\n        \"P(a) /\\\\ (P(x) ==> (exists y. P(y) /\\\\ R(x,y))) ==> \" ^\n        \"(exists z w. P(z) /\\\\ R(x,w) /\\\\ R(w,z))) <=> \" ^\n      \"(forall x. \" ^\n        \"(~P(a) \\\\/ P(x) \\\\/ (exists z w. P(z) /\\\\ R(x,w) /\\\\ R(w,z))) /\\\\ \" ^\n        \"(~P(a) \\\\/ ~(exists y. P(y) /\\\\ R(x,y)) \\\\/ \" ^\n        \"(exists z w. P(z) /\\\\ R(x,w) /\\\\ R(w,z))))\")\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p39 *)\n\nauto \"~(exists x. forall y. P(y,x) <=> ~P(y,y))\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p40 *)\n\nauto (\"(exists y. forall x. P(x,y) <=> P(x,x)) \" ^\n      \"==> ~(forall x. exists y. forall z. P(z,y) <=> ~P(z,x))\")\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p41 *)\n\nauto (\"(forall z. exists y. forall x. P(x,y) <=> P(x,z) /\\\\ ~P(x,x)) \" ^\n      \"==> ~(exists z. forall x. P(x,z))\")\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p42 *)\n\nauto \"~(exists y. forall x. P(x,y) <=> ~(exists z. P(x,z) /\\\\ P(z,x)))\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p44 *)\n\nauto (\"(forall x. P(x) ==> (exists y. G(y) /\\\\ H(x,y)) /\\\\ \" ^\n      \"(exists y. G(y) /\\\\ ~H(x,y))) /\\\\ \" ^\n      \"(exists x. J(x) /\\\\ (forall y. G(y) ==> H(x,y))) ==> \" ^\n      \"(exists x. J(x) /\\\\ ~P(x))\")\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p45 *)\n\nauto (\"(forall x. \" ^\n        \"P(x) /\\\\ (forall y. G(y) /\\\\ H(x,y) ==> J(x,y)) ==> \" ^\n             \"(forall y. G(y) /\\\\ H(x,y) ==> R(y))) /\\\\ \" ^\n      \"~(exists y. L(y) /\\\\ R(y)) /\\\\ \" ^\n      \"(exists x. P(x) /\\\\ (forall y. H(x,y) ==> \" ^\n        \"L(y)) /\\\\ (forall y. G(y) /\\\\ H(x,y) ==> J(x,y))) ==> \" ^\n      \"(exists x. P(x) /\\\\ ~(exists y. G(y) /\\\\ H(x,y)))\")\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p55 *)\n\nauto (\"lives(agatha) /\\\\ lives(butler) /\\\\ lives(charles) /\\\\ \" ^\n      \"(killed(agatha,agatha) \\\\/ killed(butler,agatha) \\\\/ \" ^\n       \"killed(charles,agatha)) /\\\\ \" ^\n      \"(forall x y. killed(x,y) ==> hates(x,y) /\\\\ ~richer(x,y)) /\\\\ \" ^\n      \"(forall x. hates(agatha,x) ==> ~hates(charles,x)) /\\\\ \" ^\n      \"(hates(agatha,agatha) /\\\\ hates(agatha,charles)) /\\\\ \" ^\n      \"(forall x. lives(x) /\\\\ ~richer(x,agatha) ==> hates(butler,x)) /\\\\ \" ^\n      \"(forall x. hates(agatha,x) ==> hates(butler,x)) /\\\\ \" ^\n      \"(forall x. ~hates(x,agatha) \\\\/ ~hates(x,butler) \\\\/ ~hates(x,charles)) \" ^\n      \"==> killed(agatha,agatha) /\\\\ \" ^\n             \"~killed(butler,agatha) /\\\\ \" ^\n             \"~killed(charles,agatha)\")\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p57 *)\n\nauto (\"P(f(a,b),f(b,c)) /\\\\ \" ^\n      \"P(f(b,c),f(a,c)) /\\\\ \" ^\n      \"(forall x y z. P(x,y) /\\\\ P(y,z) ==> P(x,z)) \" ^\n      \"==> P(f(a,b),f(a,c))\")\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p59 *)\n\nauto \"(forall x. P(x) <=> ~P(f(x))) ==> (exists x. P(x) /\\\\ ~P(f(x)))\"\n\n\\<close>"], ["", "ML_val \\<open>(* Pelletier p60 *)\n\nauto \"forall x. P(x,f(x)) <=> exists y. (forall z. P(z,y) ==> P(z,f(x))) /\\\\ P(x,y)\"\n\n\\<close>"], ["", "ML_val \\<open>(* gilmore_3 *)\n\nauto (\"exists x. forall y z. \" ^\n              \"((F(y,z) ==> (G(y) ==> H(x))) ==> F(x,x)) /\\\\ \" ^\n              \"((F(z,x) ==> G(x)) ==> H(z)) /\\\\ \" ^\n              \"F(x,y) \" ^\n              \"==> F(z,z)\")\n\n\\<close>"], ["", "ML_val \\<open>(* gilmore_4 *)\n\nauto (\"exists x y. forall z. \" ^\n              \"(F(x,y) ==> F(y,z) /\\\\ F(z,z)) /\\\\ \" ^\n              \"(F(x,y) /\\\\ G(x,y) ==> G(x,z) /\\\\ G(z,z))\")\n\n\\<close>"], ["", "ML_val \\<open>(* gilmore_5 *)\n\nauto (\"(forall x. exists y. F(x,y) \\\\/ F(y,x)) /\\\\ \" ^\n      \"(forall x y. F(y,x) ==> F(y,y)) \" ^\n      \"==> exists z. F(z,z)\")\n\n\\<close>"], ["", "ML_val \\<open>(* gilmore_6 *)\n\nauto (\"forall x. exists y. \" ^\n              \"(exists u. forall v. F(u,x) ==> G(v,u) /\\\\ G(u,x)) \" ^\n              \"==> (exists u. forall v. F(u,y) ==> G(v,u) /\\\\ G(u,y)) \\\\/ \" ^\n                        \"(forall u v. exists w. G(v,u) \\\\/ H(w,y,u) ==> G(u,w))\")\n\n\\<close>"], ["", "ML_val \\<open>(* gilmore_7 *)\n\nauto (\"(forall x. K(x) ==> exists y. L(y) /\\\\ (F(x,y) ==> G(x,y))) /\\\\ \" ^\n      \"(exists z. K(z) /\\\\ forall u. L(u) ==> F(z,u)) \" ^\n      \"==> exists v w. K(v) /\\\\ L(w) /\\\\ G(v,w)\")\n\n\\<close>"], ["", "ML_val \\<open>(* gilmore_8 *)\n\nauto (\"exists x. forall y z. \" ^\n              \"((F(y,z) ==> (G(y) ==> (forall u. exists v. H(u,v,x)))) ==> F(x,x)) /\\\\ \" ^\n              \"((F(z,x) ==> G(x)) ==> (forall u. exists v. H(u,v,z))) /\\\\ \" ^\n              \"F(x,y) \" ^\n              \"==> F(z,z)\")\n\n\\<close>"], ["", "ML_val \\<open>(* gilmore_9 *)\n\nauto (\"forall x. exists y. forall z. \" ^\n              \"((forall u. exists v. F(y,u,v) /\\\\ G(y,u) /\\\\ ~H(y,x)) \" ^\n                   \"==> (forall u. exists v. F(x,u,v) /\\\\ G(z,u) /\\\\ ~H(x,z)) \" ^\n                   \"==> (forall u. exists v. F(x,u,v) /\\\\ G(y,u) /\\\\ ~H(x,y))) /\\\\ \" ^\n              \"((forall u. exists v. F(x,u,v) /\\\\ G(y,u) /\\\\ ~H(x,y)) \" ^\n                  \"==> ~(forall u. exists v. F(x,u,v) /\\\\ G(z,u) /\\\\ ~H(x,z)) \" ^\n                  \"==> (forall u. exists v. F(y,u,v) /\\\\ G(y,u) /\\\\ ~H(y,x)) /\\\\ \" ^\n                         \"(forall u. exists v. F(z,u,v) /\\\\ G(y,u) /\\\\ ~H(z,y)))\")\n\n\\<close>"], ["", "ML_val \\<open>(* davis_putnam_example *)\n\nauto (\"exists x. exists y. forall z. \" ^\n      \"(F(x,y) ==> (F(y,z) /\\\\ F(z,z))) /\\\\ \" ^\n      \"((F(x,y) /\\\\ G(x,y)) ==> (G(x,z) /\\\\ G(z,z)))\")\n\n\\<close>"], ["", "ML_val \\<open>(* ewd1062_1 *)\n\nauto (\"(forall x. x <= x) /\\\\ \" ^\n      \"(forall x y z. x <= y /\\\\ y <= z ==> x <= z) /\\\\ \" ^\n      \"(forall x y. f(x) <= y <=> x <= g(y)) \" ^\n      \"==> (forall x y. x <= y ==> f(x) <= f(y))\")\n\n\\<close>"], ["", "ML_val \\<open>(* ewd1062_2 *)\n\nauto (\"(forall x. x <= x) /\\\\ \" ^\n      \"(forall x y z. x <= y /\\\\ y <= z ==> x <= z) /\\\\ \" ^\n      \"(forall x y. f(x) <= y <=> x <= g(y)) \" ^\n      \"==> (forall x y. x <= y ==> g(x) <= g(y))\")\n\n\\<close>"], ["", "(*\n\nNon-terminating examples\n\nML_val {* (* ewd1062 *)\n\nauto (\"(forall x. x <= x) /\\\\ \" ^\n      \"(forall x y z. x <= y /\\\\ y <= z ==> x <= z) /\\\\ \" ^\n      \"(forall x y. f(x) <= y <=> x <= g(y)) \" ^\n      \"==> (forall x y. x <= y ==> f(x) <= f(y)) /\\\\ \" ^\n          \"(forall x y. x <= y ==> g(x) <= g(y))\")\n\n*}\n\nML_val {* (* Pelletier p34 / page 178 Andrews's challenge *)\n\nauto (\"((exists x. forall y. P(x) <=> P(y)) <=> \" ^\n    \"((exists x. Q(x)) <=> (forall y. Q(y)))) <=> \" ^\n   \"((exists x. forall y. Q(x) <=> Q(y)) <=> \" ^\n    \"((exists x. P(x)) <=> (forall y. P(y))))\")\n\n*}\n\nML_val {* (* Pelletier p43 *)\n\nauto \"(forall x y. Q(x,y) <=> forall z. P(z,x) <=> P(z,y)) ==> forall x y. Q(x,y) <=> Q(y,x)\"\n\n*}\n\nML_val {* (* Pelletier p46 *)\n\nauto (\"(forall x. P(x) /\\\\ (forall y. P(y) /\\\\ H(y,x) ==> G(y)) ==> G(x)) /\\\\ \" ^\n        \"((exists x. P(x) /\\\\ ~G(x)) ==> \" ^\n          \"(exists x. P(x) /\\\\ ~G(x) /\\\\ (forall y. P(y) /\\\\ ~G(y) ==> J(x,y)))) /\\\\ \" ^\n        \"(forall x y. P(x) /\\\\ P(y) /\\\\ H(x,y) ==> ~J(y,x)) ==> \" ^\n        \"(forall x. P(x) ==> G(x))\")\n\n*}\n\nML_val {* (* Pelletier p56 *)\n\nauto (\"(forall x. (exists y. P(y) /\\\\ x = f(y)) ==> P(x)) <=> (forall x. P(x) ==> P(f(x)))\")\n\n*}\n\nML_val {* (* Correct Pelletier p58 *)\n\nauto \"(forall x y. f(x) = g(y)) ==> (forall x y. f(f(x)) = f(g(y)))\"\n\n*}\n\nML_val {* (* gilmore_1 *)\n\nauto (\"exists x. forall y z. \" ^\n        \"((F(y) ==> G(y)) <=> F(x)) /\\\\ \" ^\n        \"((F(y) ==> H(y)) <=> G(x)) /\\\\ \" ^\n        \"(((F(y) ==> G(y)) ==> H(y)) <=> H(x)) \" ^\n          \"==> F(z) /\\\\ G(z) /\\\\ H(z)\")\n\n*}\n\nML_val {* (* gilmore_2 has a counterexample *)\n\nauto (\"exists x y. forall z. (F(x,z) <=> F(z,y)) /\\\\ (F(z,y) <=> F(z,z)) /\\\\ (F(x,y) <=> F(y,x)) \" ^\n      \"==> (F(x,y) <=> F(x,z))\")\n\n*}\n\n*)"], ["", "end"]]}