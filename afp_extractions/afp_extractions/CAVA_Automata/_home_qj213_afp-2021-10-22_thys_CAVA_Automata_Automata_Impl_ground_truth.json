{"file_name": "/home/qj213/afp-2021-10-22/thys/CAVA_Automata/Automata_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CAVA_Automata", "problem_names": ["lemma igbg_type[autoref_itype]:\n  \"igbg_num_acc ::\\<^sub>i i_igbg Ie Iv \\<rightarrow>\\<^sub>i i_nat\"\n  \"igbg_acc ::\\<^sub>i i_igbg Ie Iv \\<rightarrow>\\<^sub>i Iv \\<rightarrow>\\<^sub>i \\<langle>i_nat\\<rangle>\\<^sub>ii_set\"\n  \"igb_graph_rec_ext\n    ::\\<^sub>i i_nat \\<rightarrow>\\<^sub>i (Iv \\<rightarrow>\\<^sub>i \\<langle>i_nat\\<rangle>\\<^sub>ii_set) \\<rightarrow>\\<^sub>i Ie \\<rightarrow>\\<^sub>i \\<langle>Ie,Iv\\<rangle>\\<^sub>ii_igbg_eext\"", "lemma gen_igbg_impl_rel_eext_def: \n  \"\\<langle>Rm,Racc\\<rangle>gen_igbg_impl_rel_eext = { (\n  \\<lparr> igbgi_num_acc = num_acci, igbgi_acc = acci, \\<dots>=mi \\<rparr>, \n  \\<lparr> igbg_num_acc = num_acc, igbg_acc = acc, \\<dots>=m \\<rparr>) \n  | num_acci acci mi num_acc acc m. \n    (num_acci,num_acc)\\<in>nat_rel \n  \\<and> (acci,acc)\\<in>Racc\n  \\<and> (mi,m)\\<in>Rm\n  }\"", "lemma gen_igbg_impl_rel_sv[relator_props]: \n  \"\\<lbrakk>single_valued Racc; single_valued Rm\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Racc\\<rangle>gen_igbg_impl_rel_eext)\"", "lemma gen_igbg_refine:\n  fixes Rv Re Rv0 Racc\n  assumes \"TERM (Rv,Re,Rv0)\"\n  assumes \"TERM (Racc)\"\n  shows\n  \"(igbgi_num_acc,igbg_num_acc) \n    \\<in> \\<langle>Rv,Re,Rv0\\<rangle>gen_igbg_impl_rel_ext Rm Racc \\<rightarrow> nat_rel\"\n  \"(igbgi_acc,igbg_acc) \n    \\<in> \\<langle>Rv,Re,Rv0\\<rangle>gen_igbg_impl_rel_ext Rm Racc \\<rightarrow> Racc\"\n  \"(gen_igbg_impl_ext, igb_graph_rec_ext) \n    \\<in> nat_rel \\<rightarrow> Racc \\<rightarrow> Rm \\<rightarrow> \\<langle>Rm,Racc\\<rangle>gen_igbg_impl_rel_eext\"", "lemma igbg_impl_rel_eext_def: \n  \"\\<langle>Rm,Rv\\<rangle>igbg_impl_rel_eext \\<equiv> \\<langle>Rm, Rv \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>gen_igbg_impl_rel_eext\"", "lemmas [autoref_rel_intf] = REL_INTFI[of igbg_impl_rel_eext i_igbg_eext]", "lemma [relator_props, simp]: \n  \"\\<lbrakk>Range Rv = UNIV; single_valued Rm\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rv\\<rangle>igbg_impl_rel_eext)\"", "lemma g_tag: \"TERM (\\<langle>Rv\\<rangle>fun_set_rel,\\<langle>Rv\\<rangle>slg_rel,\\<langle>Rv\\<rangle>list_set_rel)\"", "lemma frgv_tag: \"TERM (\\<langle>Rv\\<rangle>list_set_rel,\\<langle>Rv\\<rangle>slg_rel,\\<langle>Rv\\<rangle>list_set_rel)\"", "lemma igbg_bs_tag: \"TERM (Rv \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel)\"", "lemmas [autoref_rules] = gen_igbg_refine[\n  OF frgv_tag[of Rv] igbg_bs_tag[of Rv], \n  folded frgv_impl_rel_ext_def igbg_impl_rel_eext_def]", "lemmas [autoref_rules] = gen_igbg_refine[\n  OF g_tag[of Rv] igbg_bs_tag[of Rv], \n  folded g_impl_rel_ext_def igbg_impl_rel_eext_def]", "lemma igba_type[autoref_itype]:\n  \"igba_L ::\\<^sub>i i_igba Ie Iv Il \\<rightarrow>\\<^sub>i (Iv \\<rightarrow>\\<^sub>i Il \\<rightarrow>\\<^sub>i i_bool)\"\n  \"igba_rec_ext ::\\<^sub>i (Iv \\<rightarrow>\\<^sub>i Il \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i Ie \\<rightarrow>\\<^sub>i \\<langle>Ie,Iv,Il\\<rangle>\\<^sub>ii_igba_eext\"", "lemma gen_igba_impl_rel_eext_def: \n  \"\\<langle>Rm,Rl\\<rangle>gen_igba_impl_rel_eext = { (\n  \\<lparr> igbai_L = Li, \\<dots>=mi \\<rparr>, \n  \\<lparr> igba_L = L, \\<dots>=m \\<rparr>) \n  | Li mi L m. \n    (Li,L)\\<in>Rl\n  \\<and> (mi,m)\\<in>Rm\n  }\"", "lemma gen_igba_impl_rel_sv[relator_props]: \n  \"\\<lbrakk>single_valued Rl; single_valued Rm\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rl\\<rangle>gen_igba_impl_rel_eext)\"", "lemma gen_igba_refine:\n  fixes Rv Re Rv0 Racc Rl\n  assumes \"TERM (Rv,Re,Rv0)\"\n  assumes \"TERM (Racc)\"\n  assumes \"TERM (Rl)\"\n  shows\n  \"(igbai_L,igba_L) \n    \\<in> \\<langle>Rv,Re,Rv0\\<rangle>gen_igba_impl_rel_ext Rm Rl Racc \\<rightarrow> Rl\"\n  \"(gen_igba_impl_ext, igba_rec_ext) \n    \\<in> Rl \\<rightarrow> Rm \\<rightarrow> \\<langle>Rm,Rl\\<rangle>gen_igba_impl_rel_eext\"", "lemma igba_impl_rel_eext_def: \n  \"\\<langle>Rm,Rv,Rl\\<rangle>igba_impl_rel_eext \\<equiv> \\<langle>Rm, Rv \\<rightarrow> Rl \\<rightarrow> bool_rel\\<rangle>gen_igba_impl_rel_eext\"", "lemmas [autoref_rel_intf] = REL_INTFI[of igba_impl_rel_eext i_igba_eext]", "lemma [relator_props, simp]: \n  \"\\<lbrakk>Range Rv = UNIV; single_valued Rm; Range Rl = UNIV\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rv,Rl\\<rangle>igba_impl_rel_eext)\"", "lemma igba_f_tag: \"TERM (Rv \\<rightarrow> Rl \\<rightarrow> bool_rel)\"", "lemmas [autoref_rules] = gen_igba_refine[\n  OF frgv_tag[of Rv] igbg_bs_tag[of Rv] igba_f_tag[of Rv Rl], \n  folded frgv_impl_rel_ext_def igbg_impl_rel_eext_def igba_impl_rel_eext_def]", "lemmas [autoref_rules] = gen_igba_refine[\n  OF g_tag[of Rv] igbg_bs_tag[of Rv] igba_f_tag[of Rv Rl], \n  folded g_impl_rel_ext_def igbg_impl_rel_eext_def igba_impl_rel_eext_def]", "lemma gbg_type[autoref_itype]:\n  \"gbg_F ::\\<^sub>i i_gbg Ie Iv \\<rightarrow>\\<^sub>i \\<langle>\\<langle>Iv\\<rangle>\\<^sub>ii_set\\<rangle>\\<^sub>ii_set\"\n  \"gb_graph_rec_ext ::\\<^sub>i \\<langle>\\<langle>Iv\\<rangle>\\<^sub>ii_set\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i Ie \\<rightarrow>\\<^sub>i \\<langle>Ie,Iv\\<rangle>\\<^sub>ii_gbg_eext\"", "lemma gen_gbg_impl_rel_eext_def: \n  \"\\<langle>Rm,Rf\\<rangle>gen_gbg_impl_rel_eext = { (\n  \\<lparr> gbgi_F = Fi, \\<dots>=mi \\<rparr>, \n  \\<lparr> gbg_F = F, \\<dots>=m \\<rparr>) \n  | Fi mi F m. \n    (Fi,F)\\<in>Rf\n  \\<and> (mi,m)\\<in>Rm\n  }\"", "lemma gen_gbg_impl_rel_sv[relator_props]: \n  \"\\<lbrakk>single_valued Rm; single_valued Rf\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rf\\<rangle>gen_gbg_impl_rel_eext)\"", "lemma gen_gbg_refine:\n  fixes Rv Re Rv0 Rf\n  assumes \"TERM (Rv,Re,Rv0)\"\n  assumes \"TERM (Rf)\"\n  shows\n  \"(gbgi_F,gbg_F) \n    \\<in> \\<langle>Rv,Re,Rv0\\<rangle>gen_gbg_impl_rel_ext Rm Rf \\<rightarrow> Rf\"\n  \"(gen_gbg_impl_ext, gb_graph_rec_ext) \n    \\<in> Rf \\<rightarrow> Rm \\<rightarrow> \\<langle>Rm,Rf\\<rangle>gen_gbg_impl_rel_eext\"", "lemma gbg_impl_rel_eext_def: \n  \"\\<langle>Rm,Rv\\<rangle>gbg_impl_rel_eext \n    \\<equiv> \\<langle>Rm, \\<langle>\\<langle>Rv\\<rangle>list_set_rel\\<rangle>list_set_rel\\<rangle>gen_gbg_impl_rel_eext\"", "lemmas [autoref_rel_intf] = REL_INTFI[of gbg_impl_rel_eext i_gbg_eext]", "lemma [relator_props, simp]: \n  \"\\<lbrakk>single_valued Rm; single_valued Rv\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rv\\<rangle>gbg_impl_rel_eext)\"", "lemma gbg_ls_tag: \"TERM (\\<langle>\\<langle>Rv\\<rangle>list_set_rel\\<rangle>list_set_rel)\"", "lemmas [autoref_rules] = gen_gbg_refine[\n  OF frgv_tag[of Rv] gbg_ls_tag[of Rv], \n  folded frgv_impl_rel_ext_def gbg_impl_rel_eext_def]", "lemmas [autoref_rules] = gen_gbg_refine[\n  OF g_tag[of Rv] gbg_ls_tag[of Rv], \n  folded g_impl_rel_ext_def gbg_impl_rel_eext_def]", "lemma gba_type[autoref_itype]:\n  \"gba_L ::\\<^sub>i i_gba Ie Iv Il \\<rightarrow>\\<^sub>i (Iv \\<rightarrow>\\<^sub>i Il \\<rightarrow>\\<^sub>i i_bool)\"\n  \"gba_rec_ext ::\\<^sub>i (Iv \\<rightarrow>\\<^sub>i Il \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i Ie \\<rightarrow>\\<^sub>i \\<langle>Ie,Iv,Il\\<rangle>\\<^sub>ii_gba_eext\"", "lemma gen_gba_impl_rel_eext_def: \n  \"\\<langle>Rm,Rl\\<rangle>gen_gba_impl_rel_eext = { (\n  \\<lparr> gbai_L = Li, \\<dots>=mi \\<rparr>, \n  \\<lparr> gba_L = L, \\<dots>=m \\<rparr>) \n  | Li mi L m. \n    (Li,L)\\<in>Rl\n  \\<and> (mi,m)\\<in>Rm\n  }\"", "lemma gen_gba_impl_rel_sv[relator_props]: \n  \"\\<lbrakk>single_valued Rl; single_valued Rm\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rl\\<rangle>gen_gba_impl_rel_eext)\"", "lemma gen_gba_refine:\n  fixes Rv Re Rv0 Racc Rl\n  assumes \"TERM (Rv,Re,Rv0)\"\n  assumes \"TERM (Racc)\"\n  assumes \"TERM (Rl)\"\n  shows\n  \"(gbai_L,gba_L) \n    \\<in> \\<langle>Rv,Re,Rv0\\<rangle>gen_gba_impl_rel_ext Rm Rl Racc \\<rightarrow> Rl\"\n  \"(gen_gba_impl_ext, gba_rec_ext) \n    \\<in> Rl \\<rightarrow> Rm \\<rightarrow> \\<langle>Rm,Rl\\<rangle>gen_gba_impl_rel_eext\"", "lemma gba_impl_rel_eext_def: \n  \"\\<langle>Rm,Rv,Rl\\<rangle>gba_impl_rel_eext \\<equiv> \\<langle>Rm, Rv \\<rightarrow> Rl \\<rightarrow> bool_rel\\<rangle>gen_gba_impl_rel_eext\"", "lemmas [autoref_rel_intf] = REL_INTFI[of gba_impl_rel_eext i_gba_eext]", "lemma [relator_props, simp]: \n  \"\\<lbrakk>Range Rv = UNIV; single_valued Rm; Range Rl = UNIV\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rv,Rl\\<rangle>gba_impl_rel_eext)\"", "lemma gba_f_tag: \"TERM (Rv \\<rightarrow> Rl \\<rightarrow> bool_rel)\"", "lemmas [autoref_rules] = gen_gba_refine[\n  OF frgv_tag[of Rv] gbg_ls_tag[of Rv] gba_f_tag[of Rv Rl], \n  folded frgv_impl_rel_ext_def gbg_impl_rel_eext_def gba_impl_rel_eext_def]", "lemmas [autoref_rules] = gen_gba_refine[\n  OF g_tag[of Rv] gbg_ls_tag[of Rv] gba_f_tag[of Rv Rl], \n  folded g_impl_rel_ext_def gbg_impl_rel_eext_def gba_impl_rel_eext_def]", "lemma bg_type[autoref_itype]:\n  \"bg_F ::\\<^sub>i i_bg Ie Iv \\<rightarrow>\\<^sub>i \\<langle>Iv\\<rangle>\\<^sub>ii_set\"\n  \"gb_graph_rec_ext ::\\<^sub>i \\<langle>\\<langle>Iv\\<rangle>\\<^sub>ii_set\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i Ie \\<rightarrow>\\<^sub>i \\<langle>Ie,Iv\\<rangle>\\<^sub>ii_bg_eext\"", "lemma gen_bg_impl_rel_eext_def: \n  \"\\<langle>Rm,Rf\\<rangle>gen_bg_impl_rel_eext = { (\n  \\<lparr> bgi_F = Fi, \\<dots>=mi \\<rparr>, \n  \\<lparr> bg_F = F, \\<dots>=m \\<rparr>) \n  | Fi mi F m. \n    (Fi,F)\\<in>Rf\n  \\<and> (mi,m)\\<in>Rm\n  }\"", "lemma gen_bg_impl_rel_sv[relator_props]: \n  \"\\<lbrakk>single_valued Rm; single_valued Rf\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rf\\<rangle>gen_bg_impl_rel_eext)\"", "lemma gen_bg_refine:\n  fixes Rv Re Rv0 Rf\n  assumes \"TERM (Rv,Re,Rv0)\"\n  assumes \"TERM (Rf)\"\n  shows\n  \"(bgi_F,bg_F) \n    \\<in> \\<langle>Rv,Re,Rv0\\<rangle>gen_bg_impl_rel_ext Rm Rf \\<rightarrow> Rf\"\n  \"(gen_bg_impl_ext, b_graph_rec_ext) \n    \\<in> Rf \\<rightarrow> Rm \\<rightarrow> \\<langle>Rm,Rf\\<rangle>gen_bg_impl_rel_eext\"", "lemma bg_impl_rel_eext_def: \n  \"\\<langle>Rm,Rv\\<rangle>bg_impl_rel_eext \n    \\<equiv> \\<langle>Rm, \\<langle>Rv\\<rangle>fun_set_rel\\<rangle>gen_bg_impl_rel_eext\"", "lemmas [autoref_rel_intf] = REL_INTFI[of bg_impl_rel_eext i_bg_eext]", "lemma [relator_props, simp]: \n  \"\\<lbrakk>single_valued Rm; single_valued Rv; Range Rv = UNIV\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rv\\<rangle>bg_impl_rel_eext)\"", "lemma bg_fs_tag: \"TERM (\\<langle>Rv\\<rangle>fun_set_rel)\"", "lemmas [autoref_rules] = gen_bg_refine[\n  OF frgv_tag[of Rv] bg_fs_tag[of Rv], \n  folded frgv_impl_rel_ext_def bg_impl_rel_eext_def]", "lemmas [autoref_rules] = gen_bg_refine[\n  OF g_tag[of Rv] bg_fs_tag[of Rv], \n  folded g_impl_rel_ext_def bg_impl_rel_eext_def]", "lemma sa_type[autoref_itype]:\n  \"sa_L ::\\<^sub>i i_sa Ie Iv Il \\<rightarrow>\\<^sub>i Iv \\<rightarrow>\\<^sub>i Il\"\n  \"sa_rec_ext ::\\<^sub>i (Iv \\<rightarrow>\\<^sub>i Il) \\<rightarrow>\\<^sub>i Ie \\<rightarrow>\\<^sub>i \\<langle>Ie,Iv,Il\\<rangle>\\<^sub>ii_sa_eext\"", "lemma gen_sa_impl_rel_eext_def: \n  \"\\<langle>Rm,Rl\\<rangle>gen_sa_impl_rel_eext = { (\n  \\<lparr> sai_L = Li, \\<dots>=mi \\<rparr>, \n  \\<lparr> sa_L = L, \\<dots>=m \\<rparr>) \n  | Li mi L m. \n    (Li,L)\\<in>Rl\n  \\<and> (mi,m)\\<in>Rm\n  }\"", "lemma gen_sa_impl_rel_sv[relator_props]: \n  \"\\<lbrakk>single_valued Rm; single_valued Rf\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rf\\<rangle>gen_sa_impl_rel_eext)\"", "lemma gen_sa_refine:\n  fixes Rv Re Rv0\n  assumes \"TERM (Rv,Re,Rv0)\"\n  assumes \"TERM (Rl)\"\n  shows\n  \"(sai_L,sa_L) \n    \\<in> \\<langle>Rv,Re,Rv0\\<rangle>gen_sa_impl_rel_ext Rm Rl \\<rightarrow> Rl\"\n  \"(gen_sa_impl_ext, sa_rec_ext) \n    \\<in> Rl \\<rightarrow> Rm \\<rightarrow> \\<langle>Rm,Rl\\<rangle>gen_sa_impl_rel_eext\"", "lemma sa_impl_rel_eext_def: \n  \"\\<langle>Rm,Rv,Rl\\<rangle>sa_impl_rel_eext \n    \\<equiv> \\<langle>Rm, Rv\\<rightarrow>Rl\\<rangle>gen_sa_impl_rel_eext\"", "lemmas [autoref_rel_intf] = REL_INTFI[of sa_impl_rel_eext i_sa_eext]", "lemma [relator_props, simp]: \n  \"\\<lbrakk>single_valued Rm; single_valued Rl; Range Rv = UNIV\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rv,Rl\\<rangle>sa_impl_rel_eext)\"", "lemma sa_f_tag: \"TERM (Rv\\<rightarrow>Rl)\"", "lemmas [autoref_rules] = gen_sa_refine[\n  OF frgv_tag[of Rv] sa_f_tag[of Rv], \n  folded frgv_impl_rel_ext_def sa_impl_rel_eext_def]", "lemmas [autoref_rules] = gen_sa_refine[\n  OF g_tag[of Rv] sa_f_tag[of Rv], \n  folded g_impl_rel_ext_def sa_impl_rel_eext_def]", "lemmas [autoref_rules] = \n  gbg_to_idx_ext_impl.refine[ \n  OF SIDE_GEN_ALGO_D SIDE_GEN_ALGO_D]", "lemmas [refine_transfer] = gbg_to_idx_ext_code.refine", "lemma [autoref_op_pat]: \"gba_to_idx_ext ecnv \\<equiv> OP gba_to_idx_ext $ ecnv\"", "lemmas [autoref_rules] = \n  gba_to_idx_ext_impl.refine[OF SIDE_GEN_ALGO_D SIDE_GEN_ALGO_D]", "lemmas [refine_transfer] = gba_to_idx_ext_code.refine", "lemma degen_impl_aux_alt: \"degeneralize_ext ecnv = (\n      if num_acc = 0 then \\<lparr>\n        g_V = Collect (\\<lambda>(q,x). x=0 \\<and> q\\<in>V),\n        g_E= E_of_succ (\\<lambda>(q,x). if x=0 then (\\<lambda>q'. (q',0))`succ_of_E E q else {}),\n        g_V0 = (\\<lambda>q'. (q',0))`V0, \n        bg_F = Collect (\\<lambda>(q,x). x=0 \\<and> q\\<in>V),\n        \\<dots> = ecnv G\n      \\<rparr>\n      else \\<lparr>\n        g_V = Collect (\\<lambda>(q,x). x<num_acc \\<and> q\\<in>V),\n        g_E = E_of_succ (\\<lambda>(q,i). \n          if i<num_acc then\n            let\n              i' = if i \\<in> acc q then (i + 1) mod num_acc else i\n            in (\\<lambda>q'. (q',i'))`succ_of_E E q\n          else {}\n        ),\n        g_V0 = (\\<lambda>q'. (q',0))`V0,\n        bg_F = Collect (\\<lambda>(q,x). x=0 \\<and> 0\\<in>acc q),\n        \\<dots> = ecnv G\n      \\<rparr>)\"", "lemma [autoref_op_pat]: \n  \"igb_graph.degeneralize_ext \\<equiv> \\<lambda>G ecnv. op_igb_graph_degeneralize_ext ecnv G\"", "lemma [autoref_rules]:\n  fixes Re\n  assumes \"SIDE_PRECOND (igb_graph G)\"\n  assumes CNVR: \"(ecnvi,ecnv) \\<in> (igbg_impl_rel_ext Re Rv \\<rightarrow> Re')\"\n  assumes GR: \"(Gi,G)\\<in>igbg_impl_rel_ext Re Rv\"\n  shows \"(degeneralize_ext_impl Gi ecnvi, \n    (OP op_igb_graph_degeneralize_ext \n       ::: (igbg_impl_rel_ext Re Rv \\<rightarrow> Re') \\<rightarrow> igbg_impl_rel_ext Re Rv \n        \\<rightarrow> bg_impl_rel_ext Re' (Rv \\<times>\\<^sub>r nat_rel) )$ecnv$G ) \n  \\<in> bg_impl_rel_ext Re' (Rv \\<times>\\<^sub>r nat_rel)\"", "lemma prod_impl_aux_alt:\n  \"prod = (\\<lparr>\n    g_V = Collect (\\<lambda>(q,s). q \\<in> igba.V \\<and> s \\<in> sa.V),\n    g_E = E_of_succ (\\<lambda>(q,s). \n      if igba.L q (sa.L s) then     \n        succ_of_E (igba.E) q \\<times> succ_of_E sa.E s\n      else\n        {}\n    ),\n    g_V0 = igba.V0 \\<times> sa.V0,\n    igbg_num_acc = igba.num_acc,\n    igbg_acc = \\<lambda>(q,s). if s\\<in>sa.V then igba.acc q else {}\n  \\<rparr>)\"", "lemma [autoref_op_pat]: \n  \"igba_sys_prod_precond.prod \\<equiv> op_igba_sys_prod\"", "lemma [autoref_rules]:\n  fixes Re\n  assumes \"SIDE_PRECOND (igba G)\"\n  assumes \"SIDE_PRECOND (sa S)\"\n  assumes GR: \"(Gi,G)\\<in>igba_impl_rel_ext unit_rel Rq Rl\"\n  assumes SR: \"(Si,S)\\<in>sa_impl_rel_ext unit_rel Rs Rl\"\n  shows \"(igba_sys_prod_impl Gi Si, \n    (OP op_igba_sys_prod \n       :::  igba_impl_rel_ext unit_rel Rq Rl\n        \\<rightarrow> sa_impl_rel_ext unit_rel Rs Rl\n        \\<rightarrow> igbg_impl_rel_ext unit_rel (Rq \\<times>\\<^sub>r Rs) )$G$S ) \n  \\<in> igbg_impl_rel_ext unit_rel (Rq \\<times>\\<^sub>r Rs)\""], "translations": [["", "lemma igbg_type[autoref_itype]:\n  \"igbg_num_acc ::\\<^sub>i i_igbg Ie Iv \\<rightarrow>\\<^sub>i i_nat\"\n  \"igbg_acc ::\\<^sub>i i_igbg Ie Iv \\<rightarrow>\\<^sub>i Iv \\<rightarrow>\\<^sub>i \\<langle>i_nat\\<rangle>\\<^sub>ii_set\"\n  \"igb_graph_rec_ext\n    ::\\<^sub>i i_nat \\<rightarrow>\\<^sub>i (Iv \\<rightarrow>\\<^sub>i \\<langle>i_nat\\<rangle>\\<^sub>ii_set) \\<rightarrow>\\<^sub>i Ie \\<rightarrow>\\<^sub>i \\<langle>Ie,Iv\\<rangle>\\<^sub>ii_igbg_eext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igbg_num_acc ::\\<^sub>i i_igbg Ie Iv \\<rightarrow>\\<^sub>i i_nat &&&\n    igbg_acc ::\\<^sub>i\n    i_igbg Ie Iv \\<rightarrow>\\<^sub>i\n    Iv \\<rightarrow>\\<^sub>i \\<langle>i_nat\\<rangle>\\<^sub>ii_set &&&\n    igb_graph_rec_ext ::\\<^sub>i\n    i_nat \\<rightarrow>\\<^sub>i\n    (Iv \\<rightarrow>\\<^sub>i\n     \\<langle>i_nat\\<rangle>\\<^sub>ii_set) \\<rightarrow>\\<^sub>i\n    Ie \\<rightarrow>\\<^sub>i \\<langle>Ie, Iv\\<rangle>\\<^sub>ii_igbg_eext", "by simp_all"], ["", "end"], ["", "record ('vi,'ei,'v0i,'acci) gen_igbg_impl = \"('vi,'ei,'v0i) gen_g_impl\" +\n  igbgi_num_acc :: nat\n  igbgi_acc :: 'acci"], ["", "definition gen_igbg_impl_rel_eext_def_internal: \n  \"gen_igbg_impl_rel_eext Rm Racc \\<equiv> { (\n  \\<lparr> igbgi_num_acc = num_acci, igbgi_acc = acci, \\<dots>=mi \\<rparr>, \n  \\<lparr> igbg_num_acc = num_acc, igbg_acc = acc, \\<dots>=m \\<rparr>) \n  | num_acci acci mi num_acc acc m. \n    (num_acci,num_acc)\\<in>nat_rel \n  \\<and> (acci,acc)\\<in>Racc\n  \\<and> (mi,m)\\<in>Rm\n  }\""], ["", "lemma gen_igbg_impl_rel_eext_def: \n  \"\\<langle>Rm,Racc\\<rangle>gen_igbg_impl_rel_eext = { (\n  \\<lparr> igbgi_num_acc = num_acci, igbgi_acc = acci, \\<dots>=mi \\<rparr>, \n  \\<lparr> igbg_num_acc = num_acc, igbg_acc = acc, \\<dots>=m \\<rparr>) \n  | num_acci acci mi num_acc acc m. \n    (num_acci,num_acc)\\<in>nat_rel \n  \\<and> (acci,acc)\\<in>Racc\n  \\<and> (mi,m)\\<in>Rm\n  }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Rm, Racc\\<rangle>gen_igbg_impl_rel_eext =\n    {(\\<lparr>igbgi_num_acc = num_acci, igbgi_acc = acci,\n         \\<dots> = mi\\<rparr>,\n      \\<lparr>igbg_num_acc = num_acc, igbg_acc = acc, \\<dots> = m\\<rparr>) |\n     num_acci acci mi num_acc acc m.\n     (num_acci, num_acc) \\<in> nat_rel \\<and>\n     (acci, acc) \\<in> Racc \\<and> (mi, m) \\<in> Rm}", "unfolding gen_igbg_impl_rel_eext_def_internal relAPP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(\\<lparr>igbgi_num_acc = num_acci, igbgi_acc = acci,\n         \\<dots> = mi\\<rparr>,\n      \\<lparr>igbg_num_acc = num_acc, igbg_acc = acc, \\<dots> = m\\<rparr>) |\n     num_acci acci mi num_acc acc m.\n     (num_acci, num_acc) \\<in> nat_rel \\<and>\n     (acci, acc) \\<in> Racc \\<and> (mi, m) \\<in> Rm} =\n    {(\\<lparr>igbgi_num_acc = num_acci, igbgi_acc = acci,\n         \\<dots> = mi\\<rparr>,\n      \\<lparr>igbg_num_acc = num_acc, igbg_acc = acc, \\<dots> = m\\<rparr>) |\n     num_acci acci mi num_acc acc m.\n     (num_acci, num_acc) \\<in> nat_rel \\<and>\n     (acci, acc) \\<in> Racc \\<and> (mi, m) \\<in> Rm}", "by simp"], ["", "lemma gen_igbg_impl_rel_sv[relator_props]: \n  \"\\<lbrakk>single_valued Racc; single_valued Rm\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Racc\\<rangle>gen_igbg_impl_rel_eext)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Racc; single_valued Rm\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (\\<langle>Rm, Racc\\<rangle>gen_igbg_impl_rel_eext)", "unfolding gen_igbg_impl_rel_eext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Racc; single_valued Rm\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       {(\\<lparr>igbgi_num_acc = num_acci, igbgi_acc = acci,\n                            \\<dots> = mi\\<rparr>,\n                         \\<lparr>igbg_num_acc = num_acc, igbg_acc = acc,\n                            \\<dots> = m\\<rparr>) |\n                        num_acci acci mi num_acc acc m.\n                        (num_acci, num_acc) \\<in> nat_rel \\<and>\n                        (acci, acc) \\<in> Racc \\<and> (mi, m) \\<in> Rm}", "apply (rule single_valuedI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>single_valued Racc; single_valued Rm;\n        (x, y)\n        \\<in> {(\\<lparr>igbgi_num_acc = num_acci, igbgi_acc = acci,\n                   \\<dots> = mi\\<rparr>,\n                \\<lparr>igbg_num_acc = num_acc, igbg_acc = acc,\n                   \\<dots> = m\\<rparr>) |\n               num_acci acci mi num_acc acc m.\n               (num_acci, num_acc) \\<in> nat_rel \\<and>\n               (acci, acc) \\<in> Racc \\<and> (mi, m) \\<in> Rm};\n        (x, z)\n        \\<in> {(\\<lparr>igbgi_num_acc = num_acci, igbgi_acc = acci,\n                   \\<dots> = mi\\<rparr>,\n                \\<lparr>igbg_num_acc = num_acc, igbg_acc = acc,\n                   \\<dots> = m\\<rparr>) |\n               num_acci acci mi num_acc acc m.\n               (num_acci, num_acc) \\<in> nat_rel \\<and>\n               (acci, acc) \\<in> Racc \\<and> (mi, m) \\<in> Rm}\\<rbrakk>\n       \\<Longrightarrow> y = z", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>accia mia acc m acca ma.\n       \\<lbrakk>single_valued Racc; single_valued Rm;\n        (accia, acc) \\<in> Racc; (mia, m) \\<in> Rm;\n        (accia, acca) \\<in> Racc; (mia, ma) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> acc = acca \\<and> m = ma", "apply (intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>accia mia acc m acca ma.\n       \\<lbrakk>single_valued Racc; single_valued Rm;\n        (accia, acc) \\<in> Racc; (mia, m) \\<in> Rm;\n        (accia, acca) \\<in> Racc; (mia, ma) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> acc = acca\n 2. \\<And>accia mia acc m acca ma.\n       \\<lbrakk>single_valued Racc; single_valued Rm;\n        (accia, acc) \\<in> Racc; (mia, m) \\<in> Rm;\n        (accia, acca) \\<in> Racc; (mia, ma) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> m = ma", "apply (rule single_valuedD[rotated], assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>accia mia acc m acca ma.\n       \\<lbrakk>single_valued Racc; single_valued Rm;\n        (accia, acc) \\<in> Racc; (mia, m) \\<in> Rm;\n        (accia, acca) \\<in> Racc; (mia, ma) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> m = ma", "apply (rule single_valuedD[rotated], assumption+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "abbreviation gen_igbg_impl_rel_ext \n  :: \"_ \\<Rightarrow> _ \\<Rightarrow> _ \\<Rightarrow> _ \\<Rightarrow> _ \\<Rightarrow> (_\\<times>(_,_)igb_graph_rec_scheme) set\"\n  where \"gen_igbg_impl_rel_ext Rm Racc \n  \\<equiv> \\<langle>\\<langle>Rm,Racc\\<rangle>gen_igbg_impl_rel_eext\\<rangle>gen_g_impl_rel_ext \""], ["", "lemma gen_igbg_refine:\n  fixes Rv Re Rv0 Racc\n  assumes \"TERM (Rv,Re,Rv0)\"\n  assumes \"TERM (Racc)\"\n  shows\n  \"(igbgi_num_acc,igbg_num_acc) \n    \\<in> \\<langle>Rv,Re,Rv0\\<rangle>gen_igbg_impl_rel_ext Rm Racc \\<rightarrow> nat_rel\"\n  \"(igbgi_acc,igbg_acc) \n    \\<in> \\<langle>Rv,Re,Rv0\\<rangle>gen_igbg_impl_rel_ext Rm Racc \\<rightarrow> Racc\"\n  \"(gen_igbg_impl_ext, igb_graph_rec_ext) \n    \\<in> nat_rel \\<rightarrow> Racc \\<rightarrow> Rm \\<rightarrow> \\<langle>Rm,Racc\\<rangle>gen_igbg_impl_rel_eext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (igbgi_num_acc, igbg_num_acc)\n    \\<in> \\<langle>Rv, Re,\n          Rv0\\<rangle>gen_igbg_impl_rel_ext Rm Racc \\<rightarrow>\n          nat_rel &&&\n    (igbgi_acc, igbg_acc)\n    \\<in> \\<langle>Rv, Re,\n          Rv0\\<rangle>gen_igbg_impl_rel_ext Rm Racc \\<rightarrow> Racc &&&\n    (gen_igbg_impl_ext, igb_graph_rec_ext)\n    \\<in> nat_rel \\<rightarrow>\n          Racc \\<rightarrow>\n          Rm \\<rightarrow> \\<langle>Rm, Racc\\<rangle>gen_igbg_impl_rel_eext", "unfolding gen_igbg_impl_rel_eext_def gen_g_impl_rel_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (igbgi_num_acc, igbg_num_acc)\n    \\<in> {(\\<lparr>gi_V = Vi, gi_E = Ei, gi_V0 = V0i, \\<dots> = mi\\<rparr>,\n            \\<lparr>g_V = V, g_E = E, g_V0 = V0, \\<dots> = m\\<rparr>) |\n           Vi Ei V0i mi V E V0 m.\n           (Vi, V) \\<in> Rv \\<and>\n           (Ei, E) \\<in> Re \\<and>\n           (V0i, V0) \\<in> Rv0 \\<and>\n           (mi, m)\n           \\<in> {(\\<lparr>igbgi_num_acc = num_acci, igbgi_acc = acci,\n                      \\<dots> = mi\\<rparr>,\n                   \\<lparr>igbg_num_acc = num_acc, igbg_acc = acc,\n                      \\<dots> = m\\<rparr>) |\n                  num_acci acci mi num_acc acc m.\n                  (num_acci, num_acc) \\<in> nat_rel \\<and>\n                  (acci, acc) \\<in> Racc \\<and>\n                  (mi, m) \\<in> Rm}} \\<rightarrow>\n          nat_rel &&&\n    (igbgi_acc, igbg_acc)\n    \\<in> {(\\<lparr>gi_V = Vi, gi_E = Ei, gi_V0 = V0i, \\<dots> = mi\\<rparr>,\n            \\<lparr>g_V = V, g_E = E, g_V0 = V0, \\<dots> = m\\<rparr>) |\n           Vi Ei V0i mi V E V0 m.\n           (Vi, V) \\<in> Rv \\<and>\n           (Ei, E) \\<in> Re \\<and>\n           (V0i, V0) \\<in> Rv0 \\<and>\n           (mi, m)\n           \\<in> {(\\<lparr>igbgi_num_acc = num_acci, igbgi_acc = acci,\n                      \\<dots> = mi\\<rparr>,\n                   \\<lparr>igbg_num_acc = num_acc, igbg_acc = acc,\n                      \\<dots> = m\\<rparr>) |\n                  num_acci acci mi num_acc acc m.\n                  (num_acci, num_acc) \\<in> nat_rel \\<and>\n                  (acci, acc) \\<in> Racc \\<and>\n                  (mi, m) \\<in> Rm}} \\<rightarrow>\n          Racc &&&\n    (gen_igbg_impl_ext, igb_graph_rec_ext)\n    \\<in> nat_rel \\<rightarrow>\n          Racc \\<rightarrow>\n          Rm \\<rightarrow>\n          {(\\<lparr>igbgi_num_acc = num_acci, igbgi_acc = acci,\n               \\<dots> = mi\\<rparr>,\n            \\<lparr>igbg_num_acc = num_acc, igbg_acc = acc,\n               \\<dots> = m\\<rparr>) |\n           num_acci acci mi num_acc acc m.\n           (num_acci, num_acc) \\<in> nat_rel \\<and>\n           (acci, acc) \\<in> Racc \\<and> (mi, m) \\<in> Rm}", "by auto"], ["", "subsubsection \\<open>Implementation with bit-set\\<close>"], ["", "definition igbg_impl_rel_eext_internal_def: \n  \"igbg_impl_rel_eext Rm Rv \\<equiv> \\<langle>Rm, Rv \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>gen_igbg_impl_rel_eext\""], ["", "lemma igbg_impl_rel_eext_def: \n  \"\\<langle>Rm,Rv\\<rangle>igbg_impl_rel_eext \\<equiv> \\<langle>Rm, Rv \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>gen_igbg_impl_rel_eext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Rm, Rv\\<rangle>igbg_impl_rel_eext \\<equiv> \\<langle>Rm,\n    Rv \\<rightarrow>\n    \\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>gen_igbg_impl_rel_eext", "unfolding igbg_impl_rel_eext_internal_def relAPP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_igbg_impl_rel_eext Rm (fun_rel Rv (bs_set_rel nat_rel)) \\<equiv>\n    gen_igbg_impl_rel_eext Rm (fun_rel Rv (bs_set_rel nat_rel))", "by simp"], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of igbg_impl_rel_eext i_igbg_eext]"], ["", "lemma [relator_props, simp]: \n  \"\\<lbrakk>Range Rv = UNIV; single_valued Rm\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rv\\<rangle>igbg_impl_rel_eext)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Range Rv = UNIV; single_valued Rm\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (\\<langle>Rm, Rv\\<rangle>igbg_impl_rel_eext)", "unfolding igbg_impl_rel_eext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Range Rv = UNIV; single_valued Rm\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (\\<langle>Rm,\n                        Rv \\<rightarrow>\n                        \\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>gen_igbg_impl_rel_eext)", "by tagged_solver"], ["", "lemma g_tag: \"TERM (\\<langle>Rv\\<rangle>fun_set_rel,\\<langle>Rv\\<rangle>slg_rel,\\<langle>Rv\\<rangle>list_set_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TERM (\\<langle>Rv\\<rangle>fun_set_rel, \\<langle>Rv\\<rangle>slg_rel,\n          \\<langle>Rv\\<rangle>list_set_rel)", "."], ["", "lemma frgv_tag: \"TERM (\\<langle>Rv\\<rangle>list_set_rel,\\<langle>Rv\\<rangle>slg_rel,\\<langle>Rv\\<rangle>list_set_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TERM (\\<langle>Rv\\<rangle>list_set_rel, \\<langle>Rv\\<rangle>slg_rel,\n          \\<langle>Rv\\<rangle>list_set_rel)", "."], ["", "lemma igbg_bs_tag: \"TERM (Rv \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TERM Rv \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel", "."], ["", "abbreviation \"igbgv_impl_rel_ext Rm Rv \n  \\<equiv> \\<langle>\\<langle>Rm, Rv\\<rangle>igbg_impl_rel_eext, Rv\\<rangle>frgv_impl_rel_ext\""], ["", "abbreviation \"igbg_impl_rel_ext Rm Rv \n  \\<equiv> \\<langle>\\<langle>Rm, Rv\\<rangle>igbg_impl_rel_eext, Rv\\<rangle>g_impl_rel_ext\""], ["", "type_synonym ('v,'m) igbgv_impl_scheme = \n  \"('v, \\<lparr> igbgi_num_acc::nat, igbgi_acc::'v\\<Rightarrow>integer, \\<dots>::'m  \\<rparr>) \n    frgv_impl_scheme\""], ["", "type_synonym ('v,'m) igbg_impl_scheme = \n  \"('v, \\<lparr> igbgi_num_acc::nat, igbgi_acc::'v\\<Rightarrow>integer, \\<dots>::'m  \\<rparr>) \n    g_impl_scheme\""], ["", "context fixes Rv :: \"('vi\\<times>'v) set\" begin"], ["", "lemmas [autoref_rules] = gen_igbg_refine[\n  OF frgv_tag[of Rv] igbg_bs_tag[of Rv], \n  folded frgv_impl_rel_ext_def igbg_impl_rel_eext_def]"], ["", "lemmas [autoref_rules] = gen_igbg_refine[\n  OF g_tag[of Rv] igbg_bs_tag[of Rv], \n  folded g_impl_rel_ext_def igbg_impl_rel_eext_def]"], ["", "end"], ["", "schematic_goal \"(?c::?'c, \n    \\<lambda>G x. if igbg_num_acc G = 0 \\<and> 1\\<in>igbg_acc G x then (g_E G `` {x}) else {} \n  )\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>G x.\n        if igbg_num_acc G = 0 \\<and> 1 \\<in> igbg_acc G x then g_E G `` {x}\n        else {})\n    \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal \"(?c, \n  \\<lambda>V0 E num_acc acc. \n    \\<lparr> g_V = UNIV, g_E = E, g_V0 = V0, igbg_num_acc = num_acc, igbg_acc = acc \\<rparr>\n  )\\<in>\\<langle>R\\<rangle>list_set_rel \\<rightarrow> \\<langle>R\\<rangle>slg_rel \\<rightarrow> nat_rel \\<rightarrow> (R \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel) \n    \\<rightarrow> igbg_impl_rel_ext unit_rel R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>V0 E num_acc acc.\n        \\<lparr>g_V = UNIV, g_E = E, g_V0 = V0, igbg_num_acc = num_acc,\n           igbg_acc = acc\\<rparr>)\n    \\<in> \\<langle>R\\<rangle>list_set_rel \\<rightarrow>\n          \\<langle>R\\<rangle>slg_rel \\<rightarrow>\n          nat_rel \\<rightarrow>\n          (R \\<rightarrow>\n           \\<langle>nat_rel\\<rangle>bs_set_rel) \\<rightarrow>\n          igbg_impl_rel_ext unit_rel R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal \"(?c, \n  \\<lambda>V0 E num_acc acc. \n    \\<lparr> g_V = {}, g_E = E, g_V0 = V0, igbg_num_acc = num_acc, igbg_acc = acc \\<rparr>\n  )\\<in>\\<langle>R\\<rangle>list_set_rel \\<rightarrow> \\<langle>R\\<rangle>slg_rel \\<rightarrow> nat_rel \\<rightarrow> (R \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel) \n    \\<rightarrow> igbgv_impl_rel_ext unit_rel R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>V0 E num_acc acc.\n        \\<lparr>g_V = {}, g_E = E, g_V0 = V0, igbg_num_acc = num_acc,\n           igbg_acc = acc\\<rparr>)\n    \\<in> \\<langle>R\\<rangle>list_set_rel \\<rightarrow>\n          \\<langle>R\\<rangle>slg_rel \\<rightarrow>\n          nat_rel \\<rightarrow>\n          (R \\<rightarrow>\n           \\<langle>nat_rel\\<rangle>bs_set_rel) \\<rightarrow>\n          igbgv_impl_rel_ext unit_rel R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Indexed Generalized Buchi Automata\\<close>"], ["", "consts\n  i_igba_eext :: \"interface \\<Rightarrow> interface \\<Rightarrow> interface \\<Rightarrow> interface\""], ["", "abbreviation \"i_igba Ie Iv Il \n  \\<equiv> \\<langle>\\<langle>\\<langle>Ie,Iv,Il\\<rangle>\\<^sub>ii_igba_eext,Iv\\<rangle>\\<^sub>ii_igbg_eext,Iv\\<rangle>\\<^sub>ii_g_ext\""], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma igba_type[autoref_itype]:\n  \"igba_L ::\\<^sub>i i_igba Ie Iv Il \\<rightarrow>\\<^sub>i (Iv \\<rightarrow>\\<^sub>i Il \\<rightarrow>\\<^sub>i i_bool)\"\n  \"igba_rec_ext ::\\<^sub>i (Iv \\<rightarrow>\\<^sub>i Il \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i Ie \\<rightarrow>\\<^sub>i \\<langle>Ie,Iv,Il\\<rangle>\\<^sub>ii_igba_eext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igba_L ::\\<^sub>i\n    i_igba Ie Iv Il \\<rightarrow>\\<^sub>i\n    Iv \\<rightarrow>\\<^sub>i Il \\<rightarrow>\\<^sub>i i_bool &&&\n    igba_rec_ext ::\\<^sub>i\n    (Iv \\<rightarrow>\\<^sub>i\n     Il \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i\n    Ie \\<rightarrow>\\<^sub>i \\<langle>Ie, Iv, Il\\<rangle>\\<^sub>ii_igba_eext", "by simp_all"], ["", "end"], ["", "record ('vi,'ei,'v0i,'acci,'Li) gen_igba_impl = \n  \"('vi,'ei,'v0i,'acci)gen_igbg_impl\" +\n  igbai_L :: \"'Li\""], ["", "definition gen_igba_impl_rel_eext_def_internal: \n  \"gen_igba_impl_rel_eext Rm Rl  \\<equiv> { (\n  \\<lparr> igbai_L = Li, \\<dots>=mi \\<rparr>, \n  \\<lparr> igba_L = L, \\<dots>=m \\<rparr>) \n  | Li mi L m. \n    (Li,L)\\<in>Rl\n  \\<and> (mi,m)\\<in>Rm\n  }\""], ["", "lemma gen_igba_impl_rel_eext_def: \n  \"\\<langle>Rm,Rl\\<rangle>gen_igba_impl_rel_eext = { (\n  \\<lparr> igbai_L = Li, \\<dots>=mi \\<rparr>, \n  \\<lparr> igba_L = L, \\<dots>=m \\<rparr>) \n  | Li mi L m. \n    (Li,L)\\<in>Rl\n  \\<and> (mi,m)\\<in>Rm\n  }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Rm, Rl\\<rangle>gen_igba_impl_rel_eext =\n    {(\\<lparr>igbai_L = Li, \\<dots> = mi\\<rparr>,\n      \\<lparr>igba_L = L, \\<dots> = m\\<rparr>) |\n     Li mi L m. (Li, L) \\<in> Rl \\<and> (mi, m) \\<in> Rm}", "unfolding gen_igba_impl_rel_eext_def_internal relAPP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(\\<lparr>igbai_L = Li, \\<dots> = mi\\<rparr>,\n      \\<lparr>igba_L = L, \\<dots> = m\\<rparr>) |\n     Li mi L m. (Li, L) \\<in> Rl \\<and> (mi, m) \\<in> Rm} =\n    {(\\<lparr>igbai_L = Li, \\<dots> = mi\\<rparr>,\n      \\<lparr>igba_L = L, \\<dots> = m\\<rparr>) |\n     Li mi L m. (Li, L) \\<in> Rl \\<and> (mi, m) \\<in> Rm}", "by simp"], ["", "lemma gen_igba_impl_rel_sv[relator_props]: \n  \"\\<lbrakk>single_valued Rl; single_valued Rm\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rl\\<rangle>gen_igba_impl_rel_eext)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rl; single_valued Rm\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (\\<langle>Rm, Rl\\<rangle>gen_igba_impl_rel_eext)", "unfolding gen_igba_impl_rel_eext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rl; single_valued Rm\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       {(\\<lparr>igbai_L = Li, \\<dots> = mi\\<rparr>,\n                         \\<lparr>igba_L = L, \\<dots> = m\\<rparr>) |\n                        Li mi L m. (Li, L) \\<in> Rl \\<and> (mi, m) \\<in> Rm}", "apply (rule single_valuedI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>single_valued Rl; single_valued Rm;\n        (x, y)\n        \\<in> {(\\<lparr>igbai_L = Li, \\<dots> = mi\\<rparr>,\n                \\<lparr>igba_L = L, \\<dots> = m\\<rparr>) |\n               Li mi L m. (Li, L) \\<in> Rl \\<and> (mi, m) \\<in> Rm};\n        (x, z)\n        \\<in> {(\\<lparr>igbai_L = Li, \\<dots> = mi\\<rparr>,\n                \\<lparr>igba_L = L, \\<dots> = m\\<rparr>) |\n               Li mi L m. (Li, L) \\<in> Rl \\<and> (mi, m) \\<in> Rm}\\<rbrakk>\n       \\<Longrightarrow> y = z", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Lia mia L m La ma.\n       \\<lbrakk>single_valued Rl; single_valued Rm; (Lia, L) \\<in> Rl;\n        (mia, m) \\<in> Rm; (Lia, La) \\<in> Rl; (mia, ma) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> L = La \\<and> m = ma", "apply (intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lia mia L m La ma.\n       \\<lbrakk>single_valued Rl; single_valued Rm; (Lia, L) \\<in> Rl;\n        (mia, m) \\<in> Rm; (Lia, La) \\<in> Rl; (mia, ma) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> L = La\n 2. \\<And>Lia mia L m La ma.\n       \\<lbrakk>single_valued Rl; single_valued Rm; (Lia, L) \\<in> Rl;\n        (mia, m) \\<in> Rm; (Lia, La) \\<in> Rl; (mia, ma) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> m = ma", "apply (rule single_valuedD[rotated], assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Lia mia L m La ma.\n       \\<lbrakk>single_valued Rl; single_valued Rm; (Lia, L) \\<in> Rl;\n        (mia, m) \\<in> Rm; (Lia, La) \\<in> Rl; (mia, ma) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> m = ma", "apply (rule single_valuedD[rotated], assumption+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "abbreviation gen_igba_impl_rel_ext \n  :: \"_ \\<Rightarrow> _ \\<Rightarrow> _ \\<Rightarrow> _ \\<Rightarrow> _ \\<Rightarrow> _ \\<Rightarrow> (_ \\<times> ('a,'b,'c) igba_rec_scheme) set\"\n  where \"gen_igba_impl_rel_ext Rm Rl \n    \\<equiv> gen_igbg_impl_rel_ext (\\<langle>Rm,Rl\\<rangle>gen_igba_impl_rel_eext)\""], ["", "lemma gen_igba_refine:\n  fixes Rv Re Rv0 Racc Rl\n  assumes \"TERM (Rv,Re,Rv0)\"\n  assumes \"TERM (Racc)\"\n  assumes \"TERM (Rl)\"\n  shows\n  \"(igbai_L,igba_L) \n    \\<in> \\<langle>Rv,Re,Rv0\\<rangle>gen_igba_impl_rel_ext Rm Rl Racc \\<rightarrow> Rl\"\n  \"(gen_igba_impl_ext, igba_rec_ext) \n    \\<in> Rl \\<rightarrow> Rm \\<rightarrow> \\<langle>Rm,Rl\\<rangle>gen_igba_impl_rel_eext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (igbai_L, igba_L)\n    \\<in> \\<langle>Rv, Re,\n          Rv0\\<rangle>gen_igba_impl_rel_ext Rm Rl Racc \\<rightarrow> Rl &&&\n    (gen_igba_impl_ext, igba_rec_ext)\n    \\<in> Rl \\<rightarrow>\n          Rm \\<rightarrow> \\<langle>Rm, Rl\\<rangle>gen_igba_impl_rel_eext", "unfolding gen_igba_impl_rel_eext_def gen_igbg_impl_rel_eext_def\n    gen_g_impl_rel_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (igbai_L, igba_L)\n    \\<in> {(\\<lparr>gi_V = Vi, gi_E = Ei, gi_V0 = V0i, \\<dots> = mi\\<rparr>,\n            \\<lparr>g_V = V, g_E = E, g_V0 = V0, \\<dots> = m\\<rparr>) |\n           Vi Ei V0i mi V E V0 m.\n           (Vi, V) \\<in> Rv \\<and>\n           (Ei, E) \\<in> Re \\<and>\n           (V0i, V0) \\<in> Rv0 \\<and>\n           (mi, m)\n           \\<in> {(\\<lparr>igbgi_num_acc = num_acci, igbgi_acc = acci,\n                      \\<dots> = mi\\<rparr>,\n                   \\<lparr>igbg_num_acc = num_acc, igbg_acc = acc,\n                      \\<dots> = m\\<rparr>) |\n                  num_acci acci mi num_acc acc m.\n                  (num_acci, num_acc) \\<in> nat_rel \\<and>\n                  (acci, acc) \\<in> Racc \\<and>\n                  (mi, m)\n                  \\<in> {(\\<lparr>igbai_L = Li, \\<dots> = mi\\<rparr>,\n                          \\<lparr>igba_L = L, \\<dots> = m\\<rparr>) |\n                         Li mi L m.\n                         (Li, L) \\<in> Rl \\<and>\n                         (mi, m) \\<in> Rm}}} \\<rightarrow>\n          Rl &&&\n    (gen_igba_impl_ext, igba_rec_ext)\n    \\<in> Rl \\<rightarrow>\n          Rm \\<rightarrow>\n          {(\\<lparr>igbai_L = Li, \\<dots> = mi\\<rparr>,\n            \\<lparr>igba_L = L, \\<dots> = m\\<rparr>) |\n           Li mi L m. (Li, L) \\<in> Rl \\<and> (mi, m) \\<in> Rm}", "by auto"], ["", "subsubsection \\<open>Implementation as function\\<close>"], ["", "definition igba_impl_rel_eext_internal_def: \n  \"igba_impl_rel_eext Rm Rv Rl \\<equiv> \\<langle>Rm, Rv \\<rightarrow> Rl \\<rightarrow> bool_rel\\<rangle>gen_igba_impl_rel_eext\""], ["", "lemma igba_impl_rel_eext_def: \n  \"\\<langle>Rm,Rv,Rl\\<rangle>igba_impl_rel_eext \\<equiv> \\<langle>Rm, Rv \\<rightarrow> Rl \\<rightarrow> bool_rel\\<rangle>gen_igba_impl_rel_eext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Rm, Rv, Rl\\<rangle>igba_impl_rel_eext \\<equiv> \\<langle>Rm,\n    Rv \\<rightarrow>\n    Rl \\<rightarrow> bool_rel\\<rangle>gen_igba_impl_rel_eext", "unfolding igba_impl_rel_eext_internal_def relAPP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_igba_impl_rel_eext Rm (fun_rel Rv (fun_rel Rl bool_rel)) \\<equiv>\n    gen_igba_impl_rel_eext Rm (fun_rel Rv (fun_rel Rl bool_rel))", "by simp"], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of igba_impl_rel_eext i_igba_eext]"], ["", "lemma [relator_props, simp]: \n  \"\\<lbrakk>Range Rv = UNIV; single_valued Rm; Range Rl = UNIV\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rv,Rl\\<rangle>igba_impl_rel_eext)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Range Rv = UNIV; single_valued Rm; Range Rl = UNIV\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (\\<langle>Rm, Rv, Rl\\<rangle>igba_impl_rel_eext)", "unfolding igba_impl_rel_eext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Range Rv = UNIV; single_valued Rm; Range Rl = UNIV\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (\\<langle>Rm,\n                        Rv \\<rightarrow>\n                        Rl \\<rightarrow>\n                        bool_rel\\<rangle>gen_igba_impl_rel_eext)", "by tagged_solver"], ["", "lemma igba_f_tag: \"TERM (Rv \\<rightarrow> Rl \\<rightarrow> bool_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TERM Rv \\<rightarrow> Rl \\<rightarrow> bool_rel", "."], ["", "abbreviation \"igbav_impl_rel_ext Rm Rv Rl\n  \\<equiv> igbgv_impl_rel_ext (\\<langle>Rm, Rv, Rl\\<rangle>igba_impl_rel_eext) Rv\""], ["", "abbreviation \"igba_impl_rel_ext Rm Rv Rl \n  \\<equiv> igbg_impl_rel_ext (\\<langle>Rm, Rv, Rl\\<rangle>igba_impl_rel_eext) Rv\""], ["", "type_synonym ('v,'l,'m) igbav_impl_scheme = \n  \"('v, \\<lparr> igbai_L :: 'v \\<Rightarrow> 'l \\<Rightarrow> bool , \\<dots>::'m  \\<rparr>) \n    igbgv_impl_scheme\""], ["", "type_synonym ('v,'l,'m) igba_impl_scheme = \n  \"('v, \\<lparr> igbai_L :: 'v \\<Rightarrow> 'l \\<Rightarrow> bool , \\<dots>::'m  \\<rparr>) \n    igbg_impl_scheme\""], ["", "context \n  fixes Rv :: \"('vi\\<times>'v) set\" \n  fixes Rl :: \"('Li\\<times>'l) set\"\nbegin"], ["", "lemmas [autoref_rules] = gen_igba_refine[\n  OF frgv_tag[of Rv] igbg_bs_tag[of Rv] igba_f_tag[of Rv Rl], \n  folded frgv_impl_rel_ext_def igbg_impl_rel_eext_def igba_impl_rel_eext_def]"], ["", "lemmas [autoref_rules] = gen_igba_refine[\n  OF g_tag[of Rv] igbg_bs_tag[of Rv] igba_f_tag[of Rv Rl], \n  folded g_impl_rel_ext_def igbg_impl_rel_eext_def igba_impl_rel_eext_def]"], ["", "end"], ["", "thm autoref_itype"], ["", "schematic_goal \n  \"(?c::?'c, \\<lambda>G x l. if igba_L G x l then (g_E G `` {x}) else {} )\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, \\<lambda>G x l. if igba_L G x l then g_E G `` {x} else {}) \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal \n  notes [autoref_tyrel] = TYRELI[of \"Id :: ('a\\<times>'a) set\"]\n  shows \"(?c::?'c, \\<lambda>E (V0::'a set) num_acc acc L. \n  \\<lparr> g_V = UNIV, g_E = E, g_V0 = V0, \n    igbg_num_acc = num_acc, igbg_acc = acc, igba_L = L \\<rparr>\n  )\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>E V0 num_acc acc L.\n        \\<lparr>g_V = UNIV, g_E = E, g_V0 = V0, igbg_num_acc = num_acc,\n           igbg_acc = acc, igba_L = L\\<rparr>)\n    \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal \n  notes [autoref_tyrel] = TYRELI[of \"Id :: ('a\\<times>'a) set\"]\n  shows \"(?c::?'c, \\<lambda>E (V0::'a set) num_acc acc L. \n  \\<lparr> g_V = V0, g_E = E, g_V0 = V0, \n    igbg_num_acc = num_acc, igbg_acc = acc, igba_L = L \\<rparr>\n  )\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>E V0 num_acc acc L.\n        \\<lparr>g_V = V0, g_E = E, g_V0 = V0, igbg_num_acc = num_acc,\n           igbg_acc = acc, igba_L = L\\<rparr>)\n    \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Generalized Buchi Graphs\\<close>"], ["", "consts\n  i_gbg_eext :: \"interface \\<Rightarrow> interface \\<Rightarrow> interface\""], ["", "abbreviation \"i_gbg Ie Iv \\<equiv> \\<langle>\\<langle>Ie,Iv\\<rangle>\\<^sub>ii_gbg_eext,Iv\\<rangle>\\<^sub>ii_g_ext\""], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma gbg_type[autoref_itype]:\n  \"gbg_F ::\\<^sub>i i_gbg Ie Iv \\<rightarrow>\\<^sub>i \\<langle>\\<langle>Iv\\<rangle>\\<^sub>ii_set\\<rangle>\\<^sub>ii_set\"\n  \"gb_graph_rec_ext ::\\<^sub>i \\<langle>\\<langle>Iv\\<rangle>\\<^sub>ii_set\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i Ie \\<rightarrow>\\<^sub>i \\<langle>Ie,Iv\\<rangle>\\<^sub>ii_gbg_eext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gbg_F ::\\<^sub>i\n    i_gbg Ie Iv \\<rightarrow>\\<^sub>i\n    \\<langle>\\<langle>Iv\\<rangle>\\<^sub>ii_set\\<rangle>\\<^sub>ii_set &&&\n    gb_graph_rec_ext ::\\<^sub>i\n    \\<langle>\\<langle>Iv\\<rangle>\\<^sub>ii_set\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n    Ie \\<rightarrow>\\<^sub>i \\<langle>Ie, Iv\\<rangle>\\<^sub>ii_gbg_eext", "by simp_all"], ["", "end"], ["", "record ('vi,'ei,'v0i,'fi) gen_gbg_impl = \"('vi,'ei,'v0i) gen_g_impl\" +\n  gbgi_F :: 'fi"], ["", "definition gen_gbg_impl_rel_eext_def_internal: \n  \"gen_gbg_impl_rel_eext Rm Rf \\<equiv> { (\n  \\<lparr> gbgi_F = Fi, \\<dots>=mi \\<rparr>, \n  \\<lparr> gbg_F = F, \\<dots>=m \\<rparr>) \n  | Fi mi F m. \n    (Fi,F)\\<in>Rf\n  \\<and> (mi,m)\\<in>Rm\n  }\""], ["", "lemma gen_gbg_impl_rel_eext_def: \n  \"\\<langle>Rm,Rf\\<rangle>gen_gbg_impl_rel_eext = { (\n  \\<lparr> gbgi_F = Fi, \\<dots>=mi \\<rparr>, \n  \\<lparr> gbg_F = F, \\<dots>=m \\<rparr>) \n  | Fi mi F m. \n    (Fi,F)\\<in>Rf\n  \\<and> (mi,m)\\<in>Rm\n  }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Rm, Rf\\<rangle>gen_gbg_impl_rel_eext =\n    {(\\<lparr>gbgi_F = Fi, \\<dots> = mi\\<rparr>,\n      \\<lparr>gbg_F = F, \\<dots> = m\\<rparr>) |\n     Fi mi F m. (Fi, F) \\<in> Rf \\<and> (mi, m) \\<in> Rm}", "unfolding gen_gbg_impl_rel_eext_def_internal relAPP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(\\<lparr>gbgi_F = Fi, \\<dots> = mi\\<rparr>,\n      \\<lparr>gbg_F = F, \\<dots> = m\\<rparr>) |\n     Fi mi F m. (Fi, F) \\<in> Rf \\<and> (mi, m) \\<in> Rm} =\n    {(\\<lparr>gbgi_F = Fi, \\<dots> = mi\\<rparr>,\n      \\<lparr>gbg_F = F, \\<dots> = m\\<rparr>) |\n     Fi mi F m. (Fi, F) \\<in> Rf \\<and> (mi, m) \\<in> Rm}", "by simp"], ["", "lemma gen_gbg_impl_rel_sv[relator_props]: \n  \"\\<lbrakk>single_valued Rm; single_valued Rf\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rf\\<rangle>gen_gbg_impl_rel_eext)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rm; single_valued Rf\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (\\<langle>Rm, Rf\\<rangle>gen_gbg_impl_rel_eext)", "unfolding gen_gbg_impl_rel_eext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rm; single_valued Rf\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       {(\\<lparr>gbgi_F = Fi, \\<dots> = mi\\<rparr>,\n                         \\<lparr>gbg_F = F, \\<dots> = m\\<rparr>) |\n                        Fi mi F m. (Fi, F) \\<in> Rf \\<and> (mi, m) \\<in> Rm}", "apply (rule single_valuedI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>single_valued Rm; single_valued Rf;\n        (x, y)\n        \\<in> {(\\<lparr>gbgi_F = Fi, \\<dots> = mi\\<rparr>,\n                \\<lparr>gbg_F = F, \\<dots> = m\\<rparr>) |\n               Fi mi F m. (Fi, F) \\<in> Rf \\<and> (mi, m) \\<in> Rm};\n        (x, z)\n        \\<in> {(\\<lparr>gbgi_F = Fi, \\<dots> = mi\\<rparr>,\n                \\<lparr>gbg_F = F, \\<dots> = m\\<rparr>) |\n               Fi mi F m. (Fi, F) \\<in> Rf \\<and> (mi, m) \\<in> Rm}\\<rbrakk>\n       \\<Longrightarrow> y = z", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Fia mia F m Fa ma.\n       \\<lbrakk>single_valued Rm; single_valued Rf; (Fia, F) \\<in> Rf;\n        (mia, m) \\<in> Rm; (Fia, Fa) \\<in> Rf; (mia, ma) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> F = Fa \\<and> m = ma", "apply (intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Fia mia F m Fa ma.\n       \\<lbrakk>single_valued Rm; single_valued Rf; (Fia, F) \\<in> Rf;\n        (mia, m) \\<in> Rm; (Fia, Fa) \\<in> Rf; (mia, ma) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> F = Fa\n 2. \\<And>Fia mia F m Fa ma.\n       \\<lbrakk>single_valued Rm; single_valued Rf; (Fia, F) \\<in> Rf;\n        (mia, m) \\<in> Rm; (Fia, Fa) \\<in> Rf; (mia, ma) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> m = ma", "apply (rule single_valuedD[rotated], assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Fia mia F m Fa ma.\n       \\<lbrakk>single_valued Rm; single_valued Rf; (Fia, F) \\<in> Rf;\n        (mia, m) \\<in> Rm; (Fia, Fa) \\<in> Rf; (mia, ma) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> m = ma", "apply (rule single_valuedD[rotated], assumption+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "abbreviation gen_gbg_impl_rel_ext \n  :: \"_ \\<Rightarrow> _ \\<Rightarrow> _ \\<Rightarrow> _ \\<Rightarrow> _ \\<Rightarrow> (_ \\<times> ('q,_) gb_graph_rec_scheme) set\"\n  where \"gen_gbg_impl_rel_ext Rm Rf \n  \\<equiv> \\<langle>\\<langle>Rm,Rf\\<rangle>gen_gbg_impl_rel_eext\\<rangle>gen_g_impl_rel_ext\""], ["", "lemma gen_gbg_refine:\n  fixes Rv Re Rv0 Rf\n  assumes \"TERM (Rv,Re,Rv0)\"\n  assumes \"TERM (Rf)\"\n  shows\n  \"(gbgi_F,gbg_F) \n    \\<in> \\<langle>Rv,Re,Rv0\\<rangle>gen_gbg_impl_rel_ext Rm Rf \\<rightarrow> Rf\"\n  \"(gen_gbg_impl_ext, gb_graph_rec_ext) \n    \\<in> Rf \\<rightarrow> Rm \\<rightarrow> \\<langle>Rm,Rf\\<rangle>gen_gbg_impl_rel_eext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gbgi_F, gbg_F)\n    \\<in> \\<langle>Rv, Re,\n          Rv0\\<rangle>gen_gbg_impl_rel_ext Rm Rf \\<rightarrow> Rf &&&\n    (gen_gbg_impl_ext, gb_graph_rec_ext)\n    \\<in> Rf \\<rightarrow>\n          Rm \\<rightarrow> \\<langle>Rm, Rf\\<rangle>gen_gbg_impl_rel_eext", "unfolding gen_gbg_impl_rel_eext_def gen_g_impl_rel_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (gbgi_F, gbg_F)\n    \\<in> {(\\<lparr>gi_V = Vi, gi_E = Ei, gi_V0 = V0i, \\<dots> = mi\\<rparr>,\n            \\<lparr>g_V = V, g_E = E, g_V0 = V0, \\<dots> = m\\<rparr>) |\n           Vi Ei V0i mi V E V0 m.\n           (Vi, V) \\<in> Rv \\<and>\n           (Ei, E) \\<in> Re \\<and>\n           (V0i, V0) \\<in> Rv0 \\<and>\n           (mi, m)\n           \\<in> {(\\<lparr>gbgi_F = Fi, \\<dots> = mi\\<rparr>,\n                   \\<lparr>gbg_F = F, \\<dots> = m\\<rparr>) |\n                  Fi mi F m.\n                  (Fi, F) \\<in> Rf \\<and> (mi, m) \\<in> Rm}} \\<rightarrow>\n          Rf &&&\n    (gen_gbg_impl_ext, gb_graph_rec_ext)\n    \\<in> Rf \\<rightarrow>\n          Rm \\<rightarrow>\n          {(\\<lparr>gbgi_F = Fi, \\<dots> = mi\\<rparr>,\n            \\<lparr>gbg_F = F, \\<dots> = m\\<rparr>) |\n           Fi mi F m. (Fi, F) \\<in> Rf \\<and> (mi, m) \\<in> Rm}", "by auto"], ["", "subsubsection \\<open>Implementation with list of lists\\<close>"], ["", "definition gbg_impl_rel_eext_internal_def: \n  \"gbg_impl_rel_eext Rm Rv \n  \\<equiv> \\<langle>Rm, \\<langle>\\<langle>Rv\\<rangle>list_set_rel\\<rangle>list_set_rel\\<rangle>gen_gbg_impl_rel_eext\""], ["", "lemma gbg_impl_rel_eext_def: \n  \"\\<langle>Rm,Rv\\<rangle>gbg_impl_rel_eext \n    \\<equiv> \\<langle>Rm, \\<langle>\\<langle>Rv\\<rangle>list_set_rel\\<rangle>list_set_rel\\<rangle>gen_gbg_impl_rel_eext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Rm, Rv\\<rangle>gbg_impl_rel_eext \\<equiv> \\<langle>Rm,\n    \\<langle>\\<langle>Rv\\<rangle>list_set_rel\\<rangle>list_set_rel\\<rangle>gen_gbg_impl_rel_eext", "unfolding gbg_impl_rel_eext_internal_def relAPP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_gbg_impl_rel_eext Rm (list_set_rel (list_set_rel Rv)) \\<equiv>\n    gen_gbg_impl_rel_eext Rm (list_set_rel (list_set_rel Rv))", "by simp"], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of gbg_impl_rel_eext i_gbg_eext]"], ["", "lemma [relator_props, simp]: \n  \"\\<lbrakk>single_valued Rm; single_valued Rv\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rv\\<rangle>gbg_impl_rel_eext)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rm; single_valued Rv\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (\\<langle>Rm, Rv\\<rangle>gbg_impl_rel_eext)", "unfolding gbg_impl_rel_eext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rm; single_valued Rv\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (\\<langle>Rm,\n                        \\<langle>\\<langle>Rv\\<rangle>list_set_rel\\<rangle>list_set_rel\\<rangle>gen_gbg_impl_rel_eext)", "by tagged_solver"], ["", "lemma gbg_ls_tag: \"TERM (\\<langle>\\<langle>Rv\\<rangle>list_set_rel\\<rangle>list_set_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TERM \\<langle>\\<langle>Rv\\<rangle>list_set_rel\\<rangle>list_set_rel", "."], ["", "abbreviation \"gbgv_impl_rel_ext Rm Rv \n  \\<equiv> \\<langle>\\<langle>Rm, Rv\\<rangle>gbg_impl_rel_eext, Rv\\<rangle>frgv_impl_rel_ext\""], ["", "abbreviation \"gbg_impl_rel_ext Rm Rv \n  \\<equiv> \\<langle>\\<langle>Rm, Rv\\<rangle>gbg_impl_rel_eext, Rv\\<rangle>g_impl_rel_ext\""], ["", "context fixes Rv :: \"('vi\\<times>'v) set\" begin"], ["", "lemmas [autoref_rules] = gen_gbg_refine[\n  OF frgv_tag[of Rv] gbg_ls_tag[of Rv], \n  folded frgv_impl_rel_ext_def gbg_impl_rel_eext_def]"], ["", "lemmas [autoref_rules] = gen_gbg_refine[\n  OF g_tag[of Rv] gbg_ls_tag[of Rv], \n  folded g_impl_rel_ext_def gbg_impl_rel_eext_def]"], ["", "end"], ["", "schematic_goal \"(?c::?'c, \n    \\<lambda>G x. if gbg_F G = {} then (g_E G `` {x}) else {} \n  )\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, \\<lambda>G x. if gbg_F G = {} then g_E G `` {x} else {}) \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal \n  notes [autoref_tyrel] = TYRELI[of \"Id :: ('a\\<times>'a) set\"]\n  shows \"(?c::?'c, \\<lambda>E (V0::'a set) F. \n    \\<lparr> g_V = {}, g_E = E, g_V0 = V0, gbg_F = F \\<rparr>)\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>E V0 F.\n        \\<lparr>g_V = {}, g_E = E, g_V0 = V0, gbg_F = F\\<rparr>)\n    \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal \n  notes [autoref_tyrel] = TYRELI[of \"Id :: ('a\\<times>'a) set\"]\n  shows \"(?c::?'c, \\<lambda>E (V0::'a set) F. \n    \\<lparr> g_V = UNIV, g_E = E, g_V0 = V0, gbg_F = insert {} F \\<rparr>)\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>E V0 F.\n        \\<lparr>g_V = UNIV, g_E = E, g_V0 = V0, gbg_F = insert {} F\\<rparr>)\n    \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal \"(?c::?'c, it_to_sorted_list (\\<lambda>_ _. True) {1,2::nat} )\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, it_to_sorted_list (\\<lambda>_ _. True) {1, 2}) \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>GBAs\\<close>"], ["", "consts\n  i_gba_eext :: \"interface \\<Rightarrow> interface \\<Rightarrow> interface \\<Rightarrow> interface\""], ["", "abbreviation \"i_gba Ie Iv Il \n  \\<equiv> \\<langle>\\<langle>\\<langle>Ie,Iv,Il\\<rangle>\\<^sub>ii_gba_eext,Iv\\<rangle>\\<^sub>ii_gbg_eext,Iv\\<rangle>\\<^sub>ii_g_ext\""], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma gba_type[autoref_itype]:\n  \"gba_L ::\\<^sub>i i_gba Ie Iv Il \\<rightarrow>\\<^sub>i (Iv \\<rightarrow>\\<^sub>i Il \\<rightarrow>\\<^sub>i i_bool)\"\n  \"gba_rec_ext ::\\<^sub>i (Iv \\<rightarrow>\\<^sub>i Il \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i Ie \\<rightarrow>\\<^sub>i \\<langle>Ie,Iv,Il\\<rangle>\\<^sub>ii_gba_eext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gba_L ::\\<^sub>i\n    i_gba Ie Iv Il \\<rightarrow>\\<^sub>i\n    Iv \\<rightarrow>\\<^sub>i Il \\<rightarrow>\\<^sub>i i_bool &&&\n    gba_rec_ext ::\\<^sub>i\n    (Iv \\<rightarrow>\\<^sub>i\n     Il \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i\n    Ie \\<rightarrow>\\<^sub>i \\<langle>Ie, Iv, Il\\<rangle>\\<^sub>ii_gba_eext", "by simp_all"], ["", "end"], ["", "record ('vi,'ei,'v0i,'acci,'Li) gen_gba_impl = \n  \"('vi,'ei,'v0i,'acci)gen_gbg_impl\" +\n  gbai_L :: \"'Li\""], ["", "definition gen_gba_impl_rel_eext_def_internal: \n  \"gen_gba_impl_rel_eext Rm Rl  \\<equiv> { (\n  \\<lparr> gbai_L = Li, \\<dots>=mi \\<rparr>, \n  \\<lparr> gba_L = L, \\<dots>=m \\<rparr>) \n  | Li mi L m. \n    (Li,L)\\<in>Rl\n  \\<and> (mi,m)\\<in>Rm\n  }\""], ["", "lemma gen_gba_impl_rel_eext_def: \n  \"\\<langle>Rm,Rl\\<rangle>gen_gba_impl_rel_eext = { (\n  \\<lparr> gbai_L = Li, \\<dots>=mi \\<rparr>, \n  \\<lparr> gba_L = L, \\<dots>=m \\<rparr>) \n  | Li mi L m. \n    (Li,L)\\<in>Rl\n  \\<and> (mi,m)\\<in>Rm\n  }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Rm, Rl\\<rangle>gen_gba_impl_rel_eext =\n    {(\\<lparr>gbai_L = Li, \\<dots> = mi\\<rparr>,\n      \\<lparr>gba_L = L, \\<dots> = m\\<rparr>) |\n     Li mi L m. (Li, L) \\<in> Rl \\<and> (mi, m) \\<in> Rm}", "unfolding gen_gba_impl_rel_eext_def_internal relAPP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(\\<lparr>gbai_L = Li, \\<dots> = mi\\<rparr>,\n      \\<lparr>gba_L = L, \\<dots> = m\\<rparr>) |\n     Li mi L m. (Li, L) \\<in> Rl \\<and> (mi, m) \\<in> Rm} =\n    {(\\<lparr>gbai_L = Li, \\<dots> = mi\\<rparr>,\n      \\<lparr>gba_L = L, \\<dots> = m\\<rparr>) |\n     Li mi L m. (Li, L) \\<in> Rl \\<and> (mi, m) \\<in> Rm}", "by simp"], ["", "lemma gen_gba_impl_rel_sv[relator_props]: \n  \"\\<lbrakk>single_valued Rl; single_valued Rm\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rl\\<rangle>gen_gba_impl_rel_eext)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rl; single_valued Rm\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (\\<langle>Rm, Rl\\<rangle>gen_gba_impl_rel_eext)", "unfolding gen_gba_impl_rel_eext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rl; single_valued Rm\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       {(\\<lparr>gbai_L = Li, \\<dots> = mi\\<rparr>,\n                         \\<lparr>gba_L = L, \\<dots> = m\\<rparr>) |\n                        Li mi L m. (Li, L) \\<in> Rl \\<and> (mi, m) \\<in> Rm}", "apply (rule single_valuedI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>single_valued Rl; single_valued Rm;\n        (x, y)\n        \\<in> {(\\<lparr>gbai_L = Li, \\<dots> = mi\\<rparr>,\n                \\<lparr>gba_L = L, \\<dots> = m\\<rparr>) |\n               Li mi L m. (Li, L) \\<in> Rl \\<and> (mi, m) \\<in> Rm};\n        (x, z)\n        \\<in> {(\\<lparr>gbai_L = Li, \\<dots> = mi\\<rparr>,\n                \\<lparr>gba_L = L, \\<dots> = m\\<rparr>) |\n               Li mi L m. (Li, L) \\<in> Rl \\<and> (mi, m) \\<in> Rm}\\<rbrakk>\n       \\<Longrightarrow> y = z", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Lia mia L m La ma.\n       \\<lbrakk>single_valued Rl; single_valued Rm; (Lia, L) \\<in> Rl;\n        (mia, m) \\<in> Rm; (Lia, La) \\<in> Rl; (mia, ma) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> L = La \\<and> m = ma", "apply (intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lia mia L m La ma.\n       \\<lbrakk>single_valued Rl; single_valued Rm; (Lia, L) \\<in> Rl;\n        (mia, m) \\<in> Rm; (Lia, La) \\<in> Rl; (mia, ma) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> L = La\n 2. \\<And>Lia mia L m La ma.\n       \\<lbrakk>single_valued Rl; single_valued Rm; (Lia, L) \\<in> Rl;\n        (mia, m) \\<in> Rm; (Lia, La) \\<in> Rl; (mia, ma) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> m = ma", "apply (rule single_valuedD[rotated], assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Lia mia L m La ma.\n       \\<lbrakk>single_valued Rl; single_valued Rm; (Lia, L) \\<in> Rl;\n        (mia, m) \\<in> Rm; (Lia, La) \\<in> Rl; (mia, ma) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> m = ma", "apply (rule single_valuedD[rotated], assumption+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "abbreviation gen_gba_impl_rel_ext \n  :: \"_ \\<Rightarrow> _ \\<Rightarrow> _ \\<Rightarrow> _ \\<Rightarrow> _ \\<Rightarrow> _ \\<Rightarrow> (_ \\<times> ('a,'b,'c) gba_rec_scheme) set\"\n  where \"gen_gba_impl_rel_ext Rm Rl \n    \\<equiv> gen_gbg_impl_rel_ext (\\<langle>Rm,Rl\\<rangle>gen_gba_impl_rel_eext)\""], ["", "lemma gen_gba_refine:\n  fixes Rv Re Rv0 Racc Rl\n  assumes \"TERM (Rv,Re,Rv0)\"\n  assumes \"TERM (Racc)\"\n  assumes \"TERM (Rl)\"\n  shows\n  \"(gbai_L,gba_L) \n    \\<in> \\<langle>Rv,Re,Rv0\\<rangle>gen_gba_impl_rel_ext Rm Rl Racc \\<rightarrow> Rl\"\n  \"(gen_gba_impl_ext, gba_rec_ext) \n    \\<in> Rl \\<rightarrow> Rm \\<rightarrow> \\<langle>Rm,Rl\\<rangle>gen_gba_impl_rel_eext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gbai_L, gba_L)\n    \\<in> \\<langle>Rv, Re,\n          Rv0\\<rangle>gen_gba_impl_rel_ext Rm Rl Racc \\<rightarrow> Rl &&&\n    (gen_gba_impl_ext, gba_rec_ext)\n    \\<in> Rl \\<rightarrow>\n          Rm \\<rightarrow> \\<langle>Rm, Rl\\<rangle>gen_gba_impl_rel_eext", "unfolding gen_gba_impl_rel_eext_def gen_gbg_impl_rel_eext_def\n    gen_g_impl_rel_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (gbai_L, gba_L)\n    \\<in> {(\\<lparr>gi_V = Vi, gi_E = Ei, gi_V0 = V0i, \\<dots> = mi\\<rparr>,\n            \\<lparr>g_V = V, g_E = E, g_V0 = V0, \\<dots> = m\\<rparr>) |\n           Vi Ei V0i mi V E V0 m.\n           (Vi, V) \\<in> Rv \\<and>\n           (Ei, E) \\<in> Re \\<and>\n           (V0i, V0) \\<in> Rv0 \\<and>\n           (mi, m)\n           \\<in> {(\\<lparr>gbgi_F = Fi, \\<dots> = mi\\<rparr>,\n                   \\<lparr>gbg_F = F, \\<dots> = m\\<rparr>) |\n                  Fi mi F m.\n                  (Fi, F) \\<in> Racc \\<and>\n                  (mi, m)\n                  \\<in> {(\\<lparr>gbai_L = Li, \\<dots> = mi\\<rparr>,\n                          \\<lparr>gba_L = L, \\<dots> = m\\<rparr>) |\n                         Li mi L m.\n                         (Li, L) \\<in> Rl \\<and>\n                         (mi, m) \\<in> Rm}}} \\<rightarrow>\n          Rl &&&\n    (gen_gba_impl_ext, gba_rec_ext)\n    \\<in> Rl \\<rightarrow>\n          Rm \\<rightarrow>\n          {(\\<lparr>gbai_L = Li, \\<dots> = mi\\<rparr>,\n            \\<lparr>gba_L = L, \\<dots> = m\\<rparr>) |\n           Li mi L m. (Li, L) \\<in> Rl \\<and> (mi, m) \\<in> Rm}", "by auto"], ["", "subsubsection \\<open>Implementation as function\\<close>"], ["", "definition gba_impl_rel_eext_internal_def: \n  \"gba_impl_rel_eext Rm Rv Rl \\<equiv> \\<langle>Rm, Rv \\<rightarrow> Rl \\<rightarrow> bool_rel\\<rangle>gen_gba_impl_rel_eext\""], ["", "lemma gba_impl_rel_eext_def: \n  \"\\<langle>Rm,Rv,Rl\\<rangle>gba_impl_rel_eext \\<equiv> \\<langle>Rm, Rv \\<rightarrow> Rl \\<rightarrow> bool_rel\\<rangle>gen_gba_impl_rel_eext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Rm, Rv, Rl\\<rangle>gba_impl_rel_eext \\<equiv> \\<langle>Rm,\n    Rv \\<rightarrow> Rl \\<rightarrow> bool_rel\\<rangle>gen_gba_impl_rel_eext", "unfolding gba_impl_rel_eext_internal_def relAPP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_gba_impl_rel_eext Rm (fun_rel Rv (fun_rel Rl bool_rel)) \\<equiv>\n    gen_gba_impl_rel_eext Rm (fun_rel Rv (fun_rel Rl bool_rel))", "by simp"], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of gba_impl_rel_eext i_gba_eext]"], ["", "lemma [relator_props, simp]: \n  \"\\<lbrakk>Range Rv = UNIV; single_valued Rm; Range Rl = UNIV\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rv,Rl\\<rangle>gba_impl_rel_eext)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Range Rv = UNIV; single_valued Rm; Range Rl = UNIV\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (\\<langle>Rm, Rv, Rl\\<rangle>gba_impl_rel_eext)", "unfolding gba_impl_rel_eext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Range Rv = UNIV; single_valued Rm; Range Rl = UNIV\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (\\<langle>Rm,\n                        Rv \\<rightarrow>\n                        Rl \\<rightarrow>\n                        bool_rel\\<rangle>gen_gba_impl_rel_eext)", "by tagged_solver"], ["", "lemma gba_f_tag: \"TERM (Rv \\<rightarrow> Rl \\<rightarrow> bool_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TERM Rv \\<rightarrow> Rl \\<rightarrow> bool_rel", "."], ["", "abbreviation \"gbav_impl_rel_ext Rm Rv Rl\n  \\<equiv> gbgv_impl_rel_ext (\\<langle>Rm, Rv, Rl\\<rangle>gba_impl_rel_eext) Rv\""], ["", "abbreviation \"gba_impl_rel_ext Rm Rv Rl \n  \\<equiv> gbg_impl_rel_ext (\\<langle>Rm, Rv, Rl\\<rangle>gba_impl_rel_eext) Rv\""], ["", "context \n  fixes Rv :: \"('vi\\<times>'v) set\" \n  fixes Rl :: \"('Li\\<times>'l) set\"\nbegin"], ["", "lemmas [autoref_rules] = gen_gba_refine[\n  OF frgv_tag[of Rv] gbg_ls_tag[of Rv] gba_f_tag[of Rv Rl], \n  folded frgv_impl_rel_ext_def gbg_impl_rel_eext_def gba_impl_rel_eext_def]"], ["", "lemmas [autoref_rules] = gen_gba_refine[\n  OF g_tag[of Rv] gbg_ls_tag[of Rv] gba_f_tag[of Rv Rl], \n  folded g_impl_rel_ext_def gbg_impl_rel_eext_def gba_impl_rel_eext_def]"], ["", "end"], ["", "thm autoref_itype"], ["", "schematic_goal \n  \"(?c::?'c, \\<lambda>G x l. if gba_L G x l then (g_E G `` {x}) else {} )\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, \\<lambda>G x l. if gba_L G x l then g_E G `` {x} else {}) \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal \n  notes [autoref_tyrel] = TYRELI[of \"Id :: ('a\\<times>'a) set\"]\n  shows \"(?c::?'c, \\<lambda>E (V0::'a set) F L. \n  \\<lparr> g_V = UNIV, g_E = E, g_V0 = V0, \n    gbg_F = F, gba_L = L \\<rparr>\n  )\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>E V0 F L.\n        \\<lparr>g_V = UNIV, g_E = E, g_V0 = V0, gbg_F = F,\n           gba_L = L\\<rparr>)\n    \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal \n  notes [autoref_tyrel] = TYRELI[of \"Id :: ('a\\<times>'a) set\"]\n  shows \"(?c::?'c, \\<lambda>E (V0::'a set) F L. \n  \\<lparr> g_V = V0, g_E = E, g_V0 = V0, \n    gbg_F = F, gba_L = L \\<rparr>\n  )\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>E V0 F L.\n        \\<lparr>g_V = V0, g_E = E, g_V0 = V0, gbg_F = F, gba_L = L\\<rparr>)\n    \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Buchi Graphs\\<close>"], ["", "consts\n  i_bg_eext :: \"interface \\<Rightarrow> interface \\<Rightarrow> interface\""], ["", "abbreviation \"i_bg Ie Iv \\<equiv> \\<langle>\\<langle>Ie,Iv\\<rangle>\\<^sub>ii_bg_eext,Iv\\<rangle>\\<^sub>ii_g_ext\""], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma bg_type[autoref_itype]:\n  \"bg_F ::\\<^sub>i i_bg Ie Iv \\<rightarrow>\\<^sub>i \\<langle>Iv\\<rangle>\\<^sub>ii_set\"\n  \"gb_graph_rec_ext ::\\<^sub>i \\<langle>\\<langle>Iv\\<rangle>\\<^sub>ii_set\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i Ie \\<rightarrow>\\<^sub>i \\<langle>Ie,Iv\\<rangle>\\<^sub>ii_bg_eext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bg_F ::\\<^sub>i\n    i_bg Ie Iv \\<rightarrow>\\<^sub>i \\<langle>Iv\\<rangle>\\<^sub>ii_set &&&\n    gb_graph_rec_ext ::\\<^sub>i\n    \\<langle>\\<langle>Iv\\<rangle>\\<^sub>ii_set\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n    Ie \\<rightarrow>\\<^sub>i \\<langle>Ie, Iv\\<rangle>\\<^sub>ii_bg_eext", "by simp_all"], ["", "end"], ["", "record ('vi,'ei,'v0i,'fi) gen_bg_impl = \"('vi,'ei,'v0i) gen_g_impl\" +\n  bgi_F :: 'fi"], ["", "definition gen_bg_impl_rel_eext_def_internal: \n  \"gen_bg_impl_rel_eext Rm Rf \\<equiv> { (\n  \\<lparr> bgi_F = Fi, \\<dots>=mi \\<rparr>, \n  \\<lparr> bg_F = F, \\<dots>=m \\<rparr>) \n  | Fi mi F m. \n    (Fi,F)\\<in>Rf\n  \\<and> (mi,m)\\<in>Rm\n  }\""], ["", "lemma gen_bg_impl_rel_eext_def: \n  \"\\<langle>Rm,Rf\\<rangle>gen_bg_impl_rel_eext = { (\n  \\<lparr> bgi_F = Fi, \\<dots>=mi \\<rparr>, \n  \\<lparr> bg_F = F, \\<dots>=m \\<rparr>) \n  | Fi mi F m. \n    (Fi,F)\\<in>Rf\n  \\<and> (mi,m)\\<in>Rm\n  }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Rm, Rf\\<rangle>gen_bg_impl_rel_eext =\n    {(\\<lparr>bgi_F = Fi, \\<dots> = mi\\<rparr>,\n      \\<lparr>bg_F = F, \\<dots> = m\\<rparr>) |\n     Fi mi F m. (Fi, F) \\<in> Rf \\<and> (mi, m) \\<in> Rm}", "unfolding gen_bg_impl_rel_eext_def_internal relAPP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(\\<lparr>bgi_F = Fi, \\<dots> = mi\\<rparr>,\n      \\<lparr>bg_F = F, \\<dots> = m\\<rparr>) |\n     Fi mi F m. (Fi, F) \\<in> Rf \\<and> (mi, m) \\<in> Rm} =\n    {(\\<lparr>bgi_F = Fi, \\<dots> = mi\\<rparr>,\n      \\<lparr>bg_F = F, \\<dots> = m\\<rparr>) |\n     Fi mi F m. (Fi, F) \\<in> Rf \\<and> (mi, m) \\<in> Rm}", "by simp"], ["", "lemma gen_bg_impl_rel_sv[relator_props]: \n  \"\\<lbrakk>single_valued Rm; single_valued Rf\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rf\\<rangle>gen_bg_impl_rel_eext)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rm; single_valued Rf\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (\\<langle>Rm, Rf\\<rangle>gen_bg_impl_rel_eext)", "unfolding gen_bg_impl_rel_eext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rm; single_valued Rf\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       {(\\<lparr>bgi_F = Fi, \\<dots> = mi\\<rparr>,\n                         \\<lparr>bg_F = F, \\<dots> = m\\<rparr>) |\n                        Fi mi F m. (Fi, F) \\<in> Rf \\<and> (mi, m) \\<in> Rm}", "apply (rule single_valuedI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>single_valued Rm; single_valued Rf;\n        (x, y)\n        \\<in> {(\\<lparr>bgi_F = Fi, \\<dots> = mi\\<rparr>,\n                \\<lparr>bg_F = F, \\<dots> = m\\<rparr>) |\n               Fi mi F m. (Fi, F) \\<in> Rf \\<and> (mi, m) \\<in> Rm};\n        (x, z)\n        \\<in> {(\\<lparr>bgi_F = Fi, \\<dots> = mi\\<rparr>,\n                \\<lparr>bg_F = F, \\<dots> = m\\<rparr>) |\n               Fi mi F m. (Fi, F) \\<in> Rf \\<and> (mi, m) \\<in> Rm}\\<rbrakk>\n       \\<Longrightarrow> y = z", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Fia mia F m Fa ma.\n       \\<lbrakk>single_valued Rm; single_valued Rf; (Fia, F) \\<in> Rf;\n        (mia, m) \\<in> Rm; (Fia, Fa) \\<in> Rf; (mia, ma) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> F = Fa \\<and> m = ma", "apply (intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Fia mia F m Fa ma.\n       \\<lbrakk>single_valued Rm; single_valued Rf; (Fia, F) \\<in> Rf;\n        (mia, m) \\<in> Rm; (Fia, Fa) \\<in> Rf; (mia, ma) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> F = Fa\n 2. \\<And>Fia mia F m Fa ma.\n       \\<lbrakk>single_valued Rm; single_valued Rf; (Fia, F) \\<in> Rf;\n        (mia, m) \\<in> Rm; (Fia, Fa) \\<in> Rf; (mia, ma) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> m = ma", "apply (rule single_valuedD[rotated], assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Fia mia F m Fa ma.\n       \\<lbrakk>single_valued Rm; single_valued Rf; (Fia, F) \\<in> Rf;\n        (mia, m) \\<in> Rm; (Fia, Fa) \\<in> Rf; (mia, ma) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> m = ma", "apply (rule single_valuedD[rotated], assumption+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "abbreviation gen_bg_impl_rel_ext \n  :: \"_ \\<Rightarrow> _ \\<Rightarrow> _ \\<Rightarrow> _ \\<Rightarrow> _ \\<Rightarrow> (_ \\<times> ('q,_) b_graph_rec_scheme) set\"\n  where \"gen_bg_impl_rel_ext Rm Rf \n  \\<equiv> \\<langle>\\<langle>Rm,Rf\\<rangle>gen_bg_impl_rel_eext\\<rangle>gen_g_impl_rel_ext\""], ["", "lemma gen_bg_refine:\n  fixes Rv Re Rv0 Rf\n  assumes \"TERM (Rv,Re,Rv0)\"\n  assumes \"TERM (Rf)\"\n  shows\n  \"(bgi_F,bg_F) \n    \\<in> \\<langle>Rv,Re,Rv0\\<rangle>gen_bg_impl_rel_ext Rm Rf \\<rightarrow> Rf\"\n  \"(gen_bg_impl_ext, b_graph_rec_ext) \n    \\<in> Rf \\<rightarrow> Rm \\<rightarrow> \\<langle>Rm,Rf\\<rangle>gen_bg_impl_rel_eext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bgi_F, bg_F)\n    \\<in> \\<langle>Rv, Re,\n          Rv0\\<rangle>gen_bg_impl_rel_ext Rm Rf \\<rightarrow> Rf &&&\n    (gen_bg_impl_ext, b_graph_rec_ext)\n    \\<in> Rf \\<rightarrow>\n          Rm \\<rightarrow> \\<langle>Rm, Rf\\<rangle>gen_bg_impl_rel_eext", "unfolding gen_bg_impl_rel_eext_def gen_g_impl_rel_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (bgi_F, bg_F)\n    \\<in> {(\\<lparr>gi_V = Vi, gi_E = Ei, gi_V0 = V0i, \\<dots> = mi\\<rparr>,\n            \\<lparr>g_V = V, g_E = E, g_V0 = V0, \\<dots> = m\\<rparr>) |\n           Vi Ei V0i mi V E V0 m.\n           (Vi, V) \\<in> Rv \\<and>\n           (Ei, E) \\<in> Re \\<and>\n           (V0i, V0) \\<in> Rv0 \\<and>\n           (mi, m)\n           \\<in> {(\\<lparr>bgi_F = Fi, \\<dots> = mi\\<rparr>,\n                   \\<lparr>bg_F = F, \\<dots> = m\\<rparr>) |\n                  Fi mi F m.\n                  (Fi, F) \\<in> Rf \\<and> (mi, m) \\<in> Rm}} \\<rightarrow>\n          Rf &&&\n    (gen_bg_impl_ext, b_graph_rec_ext)\n    \\<in> Rf \\<rightarrow>\n          Rm \\<rightarrow>\n          {(\\<lparr>bgi_F = Fi, \\<dots> = mi\\<rparr>,\n            \\<lparr>bg_F = F, \\<dots> = m\\<rparr>) |\n           Fi mi F m. (Fi, F) \\<in> Rf \\<and> (mi, m) \\<in> Rm}", "by auto"], ["", "subsubsection \\<open>Implementation with Characteristic Functions\\<close>"], ["", "definition bg_impl_rel_eext_internal_def: \n  \"bg_impl_rel_eext Rm Rv \n  \\<equiv> \\<langle>Rm, \\<langle>Rv\\<rangle>fun_set_rel\\<rangle>gen_bg_impl_rel_eext\""], ["", "lemma bg_impl_rel_eext_def: \n  \"\\<langle>Rm,Rv\\<rangle>bg_impl_rel_eext \n    \\<equiv> \\<langle>Rm, \\<langle>Rv\\<rangle>fun_set_rel\\<rangle>gen_bg_impl_rel_eext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Rm, Rv\\<rangle>bg_impl_rel_eext \\<equiv> \\<langle>Rm,\n    \\<langle>Rv\\<rangle>fun_set_rel\\<rangle>gen_bg_impl_rel_eext", "unfolding bg_impl_rel_eext_internal_def relAPP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_bg_impl_rel_eext Rm (fun_set_rel Rv) \\<equiv>\n    gen_bg_impl_rel_eext Rm (fun_set_rel Rv)", "by simp"], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of bg_impl_rel_eext i_bg_eext]"], ["", "lemma [relator_props, simp]: \n  \"\\<lbrakk>single_valued Rm; single_valued Rv; Range Rv = UNIV\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rv\\<rangle>bg_impl_rel_eext)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rm; single_valued Rv; Range Rv = UNIV\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (\\<langle>Rm, Rv\\<rangle>bg_impl_rel_eext)", "unfolding bg_impl_rel_eext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rm; single_valued Rv; Range Rv = UNIV\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (\\<langle>Rm,\n                        \\<langle>Rv\\<rangle>fun_set_rel\\<rangle>gen_bg_impl_rel_eext)", "by tagged_solver"], ["", "lemma bg_fs_tag: \"TERM (\\<langle>Rv\\<rangle>fun_set_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TERM \\<langle>Rv\\<rangle>fun_set_rel", "."], ["", "abbreviation \"bgv_impl_rel_ext Rm Rv \n  \\<equiv> \\<langle>\\<langle>Rm, Rv\\<rangle>bg_impl_rel_eext, Rv\\<rangle>frgv_impl_rel_ext\""], ["", "abbreviation \"bg_impl_rel_ext Rm Rv \n  \\<equiv> \\<langle>\\<langle>Rm, Rv\\<rangle>bg_impl_rel_eext, Rv\\<rangle>g_impl_rel_ext\""], ["", "context fixes Rv :: \"('vi\\<times>'v) set\" begin"], ["", "lemmas [autoref_rules] = gen_bg_refine[\n  OF frgv_tag[of Rv] bg_fs_tag[of Rv], \n  folded frgv_impl_rel_ext_def bg_impl_rel_eext_def]"], ["", "lemmas [autoref_rules] = gen_bg_refine[\n  OF g_tag[of Rv] bg_fs_tag[of Rv], \n  folded g_impl_rel_ext_def bg_impl_rel_eext_def]"], ["", "end"], ["", "schematic_goal \"(?c::?'c, \n    \\<lambda>G x. if x \\<in> bg_F G then (g_E G `` {x}) else {} \n  )\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, \\<lambda>G x. if x \\<in> bg_F G then g_E G `` {x} else {}) \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal \n  notes [autoref_tyrel] = TYRELI[of \"Id :: ('a\\<times>'a) set\"]\n  shows \"(?c::?'c, \\<lambda>E (V0::'a set) F. \n    \\<lparr> g_V = {}, g_E = E, g_V0 = V0, bg_F = F \\<rparr>)\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>E V0 F.\n        \\<lparr>g_V = {}, g_E = E, g_V0 = V0, bg_F = F\\<rparr>)\n    \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal \n  notes [autoref_tyrel] = TYRELI[of \"Id :: ('a\\<times>'a) set\"]\n  shows \"(?c::?'c, \\<lambda>E (V0::'a set) F. \n    \\<lparr> g_V = UNIV, g_E = E, g_V0 = V0, bg_F = F \\<rparr>)\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>E V0 F.\n        \\<lparr>g_V = UNIV, g_E = E, g_V0 = V0, bg_F = F\\<rparr>)\n    \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>System Automata\\<close>"], ["", "consts\n  i_sa_eext :: \"interface \\<Rightarrow> interface \\<Rightarrow> interface \\<Rightarrow> interface\""], ["", "abbreviation \"i_sa Ie Iv Il \\<equiv> \\<langle>\\<langle>Ie,Iv,Il\\<rangle>\\<^sub>ii_sa_eext,Iv\\<rangle>\\<^sub>ii_g_ext\""], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "term sa_L"], ["", "lemma sa_type[autoref_itype]:\n  \"sa_L ::\\<^sub>i i_sa Ie Iv Il \\<rightarrow>\\<^sub>i Iv \\<rightarrow>\\<^sub>i Il\"\n  \"sa_rec_ext ::\\<^sub>i (Iv \\<rightarrow>\\<^sub>i Il) \\<rightarrow>\\<^sub>i Ie \\<rightarrow>\\<^sub>i \\<langle>Ie,Iv,Il\\<rangle>\\<^sub>ii_sa_eext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sa_L ::\\<^sub>i\n    i_sa Ie Iv Il \\<rightarrow>\\<^sub>i Iv \\<rightarrow>\\<^sub>i Il &&&\n    sa_rec_ext ::\\<^sub>i\n    (Iv \\<rightarrow>\\<^sub>i Il) \\<rightarrow>\\<^sub>i\n    Ie \\<rightarrow>\\<^sub>i \\<langle>Ie, Iv, Il\\<rangle>\\<^sub>ii_sa_eext", "by simp_all"], ["", "end"], ["", "record ('vi,'ei,'v0i,'li) gen_sa_impl = \"('vi,'ei,'v0i) gen_g_impl\" +\n  sai_L :: 'li"], ["", "definition gen_sa_impl_rel_eext_def_internal: \n  \"gen_sa_impl_rel_eext Rm Rl \\<equiv> { (\n  \\<lparr> sai_L = Li, \\<dots>=mi \\<rparr>, \n  \\<lparr> sa_L = L, \\<dots>=m \\<rparr>) \n  | Li mi L m. \n    (Li,L)\\<in>Rl\n  \\<and> (mi,m)\\<in>Rm\n  }\""], ["", "lemma gen_sa_impl_rel_eext_def: \n  \"\\<langle>Rm,Rl\\<rangle>gen_sa_impl_rel_eext = { (\n  \\<lparr> sai_L = Li, \\<dots>=mi \\<rparr>, \n  \\<lparr> sa_L = L, \\<dots>=m \\<rparr>) \n  | Li mi L m. \n    (Li,L)\\<in>Rl\n  \\<and> (mi,m)\\<in>Rm\n  }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Rm, Rl\\<rangle>gen_sa_impl_rel_eext =\n    {(\\<lparr>sai_L = Li, \\<dots> = mi\\<rparr>,\n      \\<lparr>sa_L = L, \\<dots> = m\\<rparr>) |\n     Li mi L m. (Li, L) \\<in> Rl \\<and> (mi, m) \\<in> Rm}", "unfolding gen_sa_impl_rel_eext_def_internal relAPP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(\\<lparr>sai_L = Li, \\<dots> = mi\\<rparr>,\n      \\<lparr>sa_L = L, \\<dots> = m\\<rparr>) |\n     Li mi L m. (Li, L) \\<in> Rl \\<and> (mi, m) \\<in> Rm} =\n    {(\\<lparr>sai_L = Li, \\<dots> = mi\\<rparr>,\n      \\<lparr>sa_L = L, \\<dots> = m\\<rparr>) |\n     Li mi L m. (Li, L) \\<in> Rl \\<and> (mi, m) \\<in> Rm}", "by simp"], ["", "lemma gen_sa_impl_rel_sv[relator_props]: \n  \"\\<lbrakk>single_valued Rm; single_valued Rf\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rf\\<rangle>gen_sa_impl_rel_eext)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rm; single_valued Rf\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (\\<langle>Rm, Rf\\<rangle>gen_sa_impl_rel_eext)", "unfolding gen_sa_impl_rel_eext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rm; single_valued Rf\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       {(\\<lparr>sai_L = Li, \\<dots> = mi\\<rparr>,\n                         \\<lparr>sa_L = L, \\<dots> = m\\<rparr>) |\n                        Li mi L m. (Li, L) \\<in> Rf \\<and> (mi, m) \\<in> Rm}", "apply (rule single_valuedI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>single_valued Rm; single_valued Rf;\n        (x, y)\n        \\<in> {(\\<lparr>sai_L = Li, \\<dots> = mi\\<rparr>,\n                \\<lparr>sa_L = L, \\<dots> = m\\<rparr>) |\n               Li mi L m. (Li, L) \\<in> Rf \\<and> (mi, m) \\<in> Rm};\n        (x, z)\n        \\<in> {(\\<lparr>sai_L = Li, \\<dots> = mi\\<rparr>,\n                \\<lparr>sa_L = L, \\<dots> = m\\<rparr>) |\n               Li mi L m. (Li, L) \\<in> Rf \\<and> (mi, m) \\<in> Rm}\\<rbrakk>\n       \\<Longrightarrow> y = z", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Lia mia L m La ma.\n       \\<lbrakk>single_valued Rm; single_valued Rf; (Lia, L) \\<in> Rf;\n        (mia, m) \\<in> Rm; (Lia, La) \\<in> Rf; (mia, ma) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> L = La \\<and> m = ma", "apply (intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Lia mia L m La ma.\n       \\<lbrakk>single_valued Rm; single_valued Rf; (Lia, L) \\<in> Rf;\n        (mia, m) \\<in> Rm; (Lia, La) \\<in> Rf; (mia, ma) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> L = La\n 2. \\<And>Lia mia L m La ma.\n       \\<lbrakk>single_valued Rm; single_valued Rf; (Lia, L) \\<in> Rf;\n        (mia, m) \\<in> Rm; (Lia, La) \\<in> Rf; (mia, ma) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> m = ma", "apply (rule single_valuedD[rotated], assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Lia mia L m La ma.\n       \\<lbrakk>single_valued Rm; single_valued Rf; (Lia, L) \\<in> Rf;\n        (mia, m) \\<in> Rm; (Lia, La) \\<in> Rf; (mia, ma) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> m = ma", "apply (rule single_valuedD[rotated], assumption+)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "abbreviation gen_sa_impl_rel_ext \n  :: \"_ \\<Rightarrow> _ \\<Rightarrow> _ \\<Rightarrow> _ \\<Rightarrow> _ \\<Rightarrow> (_ \\<times> ('q,'l,_) sa_rec_scheme) set\"\n  where \"gen_sa_impl_rel_ext Rm Rf \n  \\<equiv> \\<langle>\\<langle>Rm,Rf\\<rangle>gen_sa_impl_rel_eext\\<rangle>gen_g_impl_rel_ext\""], ["", "lemma gen_sa_refine:\n  fixes Rv Re Rv0\n  assumes \"TERM (Rv,Re,Rv0)\"\n  assumes \"TERM (Rl)\"\n  shows\n  \"(sai_L,sa_L) \n    \\<in> \\<langle>Rv,Re,Rv0\\<rangle>gen_sa_impl_rel_ext Rm Rl \\<rightarrow> Rl\"\n  \"(gen_sa_impl_ext, sa_rec_ext) \n    \\<in> Rl \\<rightarrow> Rm \\<rightarrow> \\<langle>Rm,Rl\\<rangle>gen_sa_impl_rel_eext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sai_L, sa_L)\n    \\<in> \\<langle>Rv, Re,\n          Rv0\\<rangle>gen_sa_impl_rel_ext Rm Rl \\<rightarrow> Rl &&&\n    (gen_sa_impl_ext, sa_rec_ext)\n    \\<in> Rl \\<rightarrow>\n          Rm \\<rightarrow> \\<langle>Rm, Rl\\<rangle>gen_sa_impl_rel_eext", "unfolding gen_sa_impl_rel_eext_def gen_g_impl_rel_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sai_L, sa_L)\n    \\<in> {(\\<lparr>gi_V = Vi, gi_E = Ei, gi_V0 = V0i, \\<dots> = mi\\<rparr>,\n            \\<lparr>g_V = V, g_E = E, g_V0 = V0, \\<dots> = m\\<rparr>) |\n           Vi Ei V0i mi V E V0 m.\n           (Vi, V) \\<in> Rv \\<and>\n           (Ei, E) \\<in> Re \\<and>\n           (V0i, V0) \\<in> Rv0 \\<and>\n           (mi, m)\n           \\<in> {(\\<lparr>sai_L = Li, \\<dots> = mi\\<rparr>,\n                   \\<lparr>sa_L = L, \\<dots> = m\\<rparr>) |\n                  Li mi L m.\n                  (Li, L) \\<in> Rl \\<and> (mi, m) \\<in> Rm}} \\<rightarrow>\n          Rl &&&\n    (gen_sa_impl_ext, sa_rec_ext)\n    \\<in> Rl \\<rightarrow>\n          Rm \\<rightarrow>\n          {(\\<lparr>sai_L = Li, \\<dots> = mi\\<rparr>,\n            \\<lparr>sa_L = L, \\<dots> = m\\<rparr>) |\n           Li mi L m. (Li, L) \\<in> Rl \\<and> (mi, m) \\<in> Rm}", "by auto"], ["", "subsubsection \\<open>Implementation with Function\\<close>"], ["", "definition sa_impl_rel_eext_internal_def: \n  \"sa_impl_rel_eext Rm Rv Rl\n  \\<equiv> \\<langle>Rm, Rv\\<rightarrow>Rl\\<rangle>gen_sa_impl_rel_eext\""], ["", "lemma sa_impl_rel_eext_def: \n  \"\\<langle>Rm,Rv,Rl\\<rangle>sa_impl_rel_eext \n    \\<equiv> \\<langle>Rm, Rv\\<rightarrow>Rl\\<rangle>gen_sa_impl_rel_eext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Rm, Rv, Rl\\<rangle>sa_impl_rel_eext \\<equiv> \\<langle>Rm,\n    Rv \\<rightarrow> Rl\\<rangle>gen_sa_impl_rel_eext", "unfolding sa_impl_rel_eext_internal_def relAPP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_sa_impl_rel_eext Rm (fun_rel Rv Rl) \\<equiv>\n    gen_sa_impl_rel_eext Rm (fun_rel Rv Rl)", "by simp"], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of sa_impl_rel_eext i_sa_eext]"], ["", "lemma [relator_props, simp]: \n  \"\\<lbrakk>single_valued Rm; single_valued Rl; Range Rv = UNIV\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rv,Rl\\<rangle>sa_impl_rel_eext)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rm; single_valued Rl; Range Rv = UNIV\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (\\<langle>Rm, Rv, Rl\\<rangle>sa_impl_rel_eext)", "unfolding sa_impl_rel_eext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rm; single_valued Rl; Range Rv = UNIV\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (\\<langle>Rm,\n                        Rv \\<rightarrow> Rl\\<rangle>gen_sa_impl_rel_eext)", "by tagged_solver"], ["", "lemma sa_f_tag: \"TERM (Rv\\<rightarrow>Rl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. TERM Rv \\<rightarrow> Rl", "."], ["", "abbreviation \"sav_impl_rel_ext Rm Rv Rl \n  \\<equiv> \\<langle>\\<langle>Rm, Rv, Rl\\<rangle>sa_impl_rel_eext, Rv\\<rangle>frgv_impl_rel_ext\""], ["", "abbreviation \"sa_impl_rel_ext Rm Rv Rl \n  \\<equiv> \\<langle>\\<langle>Rm, Rv, Rl\\<rangle>sa_impl_rel_eext, Rv\\<rangle>g_impl_rel_ext\""], ["", "type_synonym ('v,'l,'m) sav_impl_scheme = \n  \"('v, \\<lparr> sai_L :: 'v \\<Rightarrow> 'l , \\<dots>::'m  \\<rparr>) frgv_impl_scheme\""], ["", "type_synonym ('v,'l,'m) sa_impl_scheme = \n  \"('v, \\<lparr> sai_L :: 'v \\<Rightarrow> 'l , \\<dots>::'m  \\<rparr>) g_impl_scheme\""], ["", "context fixes Rv :: \"('vi\\<times>'v) set\" begin"], ["", "lemmas [autoref_rules] = gen_sa_refine[\n  OF frgv_tag[of Rv] sa_f_tag[of Rv], \n  folded frgv_impl_rel_ext_def sa_impl_rel_eext_def]"], ["", "lemmas [autoref_rules] = gen_sa_refine[\n  OF g_tag[of Rv] sa_f_tag[of Rv], \n  folded g_impl_rel_ext_def sa_impl_rel_eext_def]"], ["", "end"], ["", "schematic_goal \"(?c::?'c, \n    \\<lambda>G x l. if sa_L G x = l then (g_E G `` {x}) else {} \n  )\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, \\<lambda>G x l. if sa_L G x = l then g_E G `` {x} else {}) \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal \n  notes [autoref_tyrel] = TYRELI[of \"Id :: ('a\\<times>'a) set\"]\n  shows \"(?c::?'c, \\<lambda>E (V0::'a set) L. \n    \\<lparr> g_V = {}, g_E = E, g_V0 = V0, sa_L = L \\<rparr>)\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>E V0 L.\n        \\<lparr>g_V = {}, g_E = E, g_V0 = V0, sa_L = L\\<rparr>)\n    \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal \n  notes [autoref_tyrel] = TYRELI[of \"Id :: ('a\\<times>'a) set\"]\n  shows \"(?c::?'c, \\<lambda>E (V0::'a set) L. \n    \\<lparr> g_V = UNIV, g_E = E, g_V0 = V0, sa_L = L \\<rparr>)\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>E V0 L.\n        \\<lparr>g_V = UNIV, g_E = E, g_V0 = V0, sa_L = L\\<rparr>)\n    \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Index Conversion\\<close>"], ["", "schematic_goal gbg_to_idx_ext_impl_aux:\n  fixes Re and Rv :: \"('qi \\<times> 'q) set\"\n  assumes [autoref_ga_rules]: \"is_bounded_hashcode Rv eq bhc\"\n  assumes [autoref_ga_rules]: \"is_valid_def_hm_size TYPE('qi) (def_size)\"\n  shows \"(?c, gbg_to_idx_ext :: _ \\<Rightarrow> ('q, _) gb_graph_rec_scheme \\<Rightarrow> _)\n   \\<in> (gbgv_impl_rel_ext Re Rv \\<rightarrow> Ri) \n    \\<rightarrow> gbgv_impl_rel_ext Re Rv \n    \\<rightarrow> \\<langle>igbgv_impl_rel_ext Ri Rv\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, gbg_to_idx_ext)\n    \\<in> (gbgv_impl_rel_ext Re Rv \\<rightarrow> Ri) \\<rightarrow>\n          gbgv_impl_rel_ext Re Rv \\<rightarrow>\n          \\<langle>igbgv_impl_rel_ext Ri Rv\\<rangle>nres_rel", "unfolding gbg_to_idx_ext_def[abs_def] F_to_idx_impl_def mk_acc_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>ecnv A.\n        SPEC\n         (\\<lambda>Flist. distinct Flist \\<and> set Flist = gbg_F A) \\<bind>\n        (\\<lambda>Flist.\n            let num_acc = length Flist\n            in (let acc = Map.empty\n                in nfoldli Flist (\\<lambda>_. True)\n                    (\\<lambda>A (i, acc).\n                        FOREACH\\<^bsup>\\<lambda>it acc'.\n    acc' =\n    (\\<lambda>v.\n        if v \\<in> A - it then Some (insert i (the_default {} (acc v)))\n        else acc v)\\<^esup>\n                         A (\\<lambda>v acc.\n                               RETURN\n                                (acc(v \\<mapsto>\n                                 insert i (the_default {} (acc v)))))\n                         acc \\<bind>\n                        (\\<lambda>acc. RETURN (Suc i, acc)))\n                    (0, acc) \\<bind>\n                   (\\<lambda>(uu_, acc).\n                       RETURN (\\<lambda>x. the_default {} (acc x)))) \\<bind>\n               (\\<lambda>acc. RETURN (num_acc, acc))) \\<bind>\n        (\\<lambda>(num_acc, acc).\n            RETURN\n             \\<lparr>g_V = g_V A, g_E = g_E A, g_V0 = g_V0 A,\n                igbg_num_acc = num_acc, igbg_acc = acc,\n                \\<dots> = ecnv A\\<rparr>))\n    \\<in> (gbgv_impl_rel_ext Re Rv \\<rightarrow> Ri) \\<rightarrow>\n          gbgv_impl_rel_ext Re Rv \\<rightarrow>\n          \\<langle>igbgv_impl_rel_ext Ri Rv\\<rangle>nres_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>ecnv A.\n        SPEC\n         (\\<lambda>Flist. distinct Flist \\<and> set Flist = gbg_F A) \\<bind>\n        (\\<lambda>Flist.\n            let num_acc = length Flist\n            in (let acc = Map.empty\n                in nfoldli Flist (\\<lambda>_. True)\n                    (\\<lambda>A (i, acc).\n                        FOREACH\\<^bsup>\\<lambda>it acc'.\n    acc' =\n    (\\<lambda>v.\n        if v \\<in> A - it then Some (insert i (the_default {} (acc v)))\n        else acc v)\\<^esup>\n                         A (\\<lambda>v acc.\n                               RETURN\n                                (acc(v \\<mapsto>\n                                 insert i (the_default {} (acc v)))))\n                         acc \\<bind>\n                        (\\<lambda>acc. RETURN (Suc i, acc)))\n                    (0, acc) \\<bind>\n                   (\\<lambda>(uu_, acc).\n                       RETURN (\\<lambda>x. the_default {} (acc x)))) \\<bind>\n               (\\<lambda>acc. RETURN (num_acc, acc))) \\<bind>\n        (\\<lambda>(num_acc, acc).\n            RETURN\n             \\<lparr>g_V = g_V A, g_E = g_E A, g_V0 = g_V0 A,\n                igbg_num_acc = num_acc, igbg_acc = acc,\n                \\<dots> = ecnv A\\<rparr>))\n    \\<in> (gbgv_impl_rel_ext Re Rv \\<rightarrow> Ri) \\<rightarrow>\n          gbgv_impl_rel_ext Re Rv \\<rightarrow>\n          \\<langle>igbgv_impl_rel_ext Ri Rv\\<rangle>nres_rel", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition gbg_to_idx_ext_impl \n  for eq bhc def_size uses gbg_to_idx_ext_impl_aux"], ["", "lemmas [autoref_rules] = \n  gbg_to_idx_ext_impl.refine[ \n  OF SIDE_GEN_ALGO_D SIDE_GEN_ALGO_D]"], ["", "schematic_goal gbg_to_idx_ext_code_aux: \n  \"RETURN ?c \\<le> gbg_to_idx_ext_impl eq bhc def_size ecnv G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c \\<le> gbg_to_idx_ext_impl eq bhc def_size ecnv G", "unfolding gbg_to_idx_ext_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> RETURN (id (gbgi_F G)) \\<bind>\n          (\\<lambda>xb.\n              let y' = length xb\n              in (let y'a = Impl_Array_Hash_Map.ahm_empty def_size\n                  in nfoldli xb (\\<lambda>xc. True)\n                      (\\<lambda>xc (xd, xe).\n                          LIST_FOREACH' (RETURN (id xc)) (\\<lambda>xf. True)\n                           (\\<lambda>xf xg.\n                               RETURN\n                                (Impl_Array_Hash_Map.ahm_update eq bhc xf\n                                  (bs_insert xd\n                                    (the_default (bs_empty ())\n(Impl_Array_Hash_Map.ahm_lookup eq bhc xf xg)))\n                                  xg))\n                           xe \\<bind>\n                          (\\<lambda>xf. RETURN (Suc xd, xf)))\n                      (0, y'a) \\<bind>\n                     (\\<lambda>(xc, xd).\n                         RETURN\n                          (\\<lambda>xe.\n                              the_default (bs_empty ())\n                               (Impl_Array_Hash_Map.ahm_lookup eq bhc xe\n                                 xd)))) \\<bind>\n                 (\\<lambda>xc. RETURN (y', xc))) \\<bind>\n          (\\<lambda>(xb, xc).\n              RETURN\n               \\<lparr>gi_V = gi_V G, gi_E = gi_E G, gi_V0 = gi_V0 G,\n                  igbgi_num_acc = xb, igbgi_acc = xc,\n                  \\<dots> = ecnv G\\<rparr>)", "by (refine_transfer)"], ["", "concrete_definition gbg_to_idx_ext_code \n  for eq bhc ecnv G uses gbg_to_idx_ext_code_aux"], ["", "lemmas [refine_transfer] = gbg_to_idx_ext_code.refine"], ["", "term ahm_rel"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma [autoref_op_pat]: \"gba_to_idx_ext ecnv \\<equiv> OP gba_to_idx_ext $ ecnv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gba_to_idx_ext ecnv \\<equiv> OP gba_to_idx_ext $ ecnv", "by simp"], ["", "end"], ["", "schematic_goal gba_to_idx_ext_impl_aux:\n  fixes Re and Rv :: \"('qi \\<times> 'q) set\"\n  assumes [autoref_ga_rules]: \"is_bounded_hashcode Rv eq bhc\"\n  assumes [autoref_ga_rules]: \"is_valid_def_hm_size TYPE('qi) (def_size)\"\n  shows \"(?c, gba_to_idx_ext :: _ \\<Rightarrow> ('q, 'l, _) gba_rec_scheme \\<Rightarrow> _)\n   \\<in> (gbav_impl_rel_ext Re Rv Rl\\<rightarrow>Ri) \n    \\<rightarrow> gbav_impl_rel_ext Re Rv Rl \n    \\<rightarrow> \\<langle>igbav_impl_rel_ext Ri Rv Rl\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, gba_to_idx_ext)\n    \\<in> (gbav_impl_rel_ext Re Rv Rl \\<rightarrow> Ri) \\<rightarrow>\n          gbav_impl_rel_ext Re Rv Rl \\<rightarrow>\n          \\<langle>igbav_impl_rel_ext Ri Rv Rl\\<rangle>nres_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, gba_to_idx_ext)\n    \\<in> (gbav_impl_rel_ext Re Rv Rl \\<rightarrow> Ri) \\<rightarrow>\n          gbav_impl_rel_ext Re Rv Rl \\<rightarrow>\n          \\<langle>igbav_impl_rel_ext Ri Rv Rl\\<rangle>nres_rel", "unfolding ti_Lcnv_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>ecnv.\n        gbg_to_idx_ext\n         (\\<lambda>A. \\<lparr>igba_L = gba_L A, \\<dots> = ecnv A\\<rparr>))\n    \\<in> (gbav_impl_rel_ext Re Rv Rl \\<rightarrow> Ri) \\<rightarrow>\n          gbav_impl_rel_ext Re Rv Rl \\<rightarrow>\n          \\<langle>igbav_impl_rel_ext Ri Rv Rl\\<rangle>nres_rel", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition gba_to_idx_ext_impl for eq bhc uses gba_to_idx_ext_impl_aux"], ["", "lemmas [autoref_rules] = \n  gba_to_idx_ext_impl.refine[OF SIDE_GEN_ALGO_D SIDE_GEN_ALGO_D]"], ["", "schematic_goal gba_to_idx_ext_code_aux: \n  \"RETURN ?c \\<le> gba_to_idx_ext_impl eq bhc def_size ecnv G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c \\<le> gba_to_idx_ext_impl eq bhc def_size ecnv G", "unfolding gba_to_idx_ext_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> gbg_to_idx_ext_impl bhc def_size eq\n           (\\<lambda>xa.\n               \\<lparr>igbai_L = gbai_L xa, \\<dots> = ecnv xa\\<rparr>)\n           G", "by (refine_transfer)"], ["", "concrete_definition gba_to_idx_ext_code for ecnv G uses gba_to_idx_ext_code_aux"], ["", "lemmas [refine_transfer] = gba_to_idx_ext_code.refine"], ["", "subsection \\<open>Degeneralization\\<close>"], ["", "context igb_graph begin"], ["", "lemma degen_impl_aux_alt: \"degeneralize_ext ecnv = (\n      if num_acc = 0 then \\<lparr>\n        g_V = Collect (\\<lambda>(q,x). x=0 \\<and> q\\<in>V),\n        g_E= E_of_succ (\\<lambda>(q,x). if x=0 then (\\<lambda>q'. (q',0))`succ_of_E E q else {}),\n        g_V0 = (\\<lambda>q'. (q',0))`V0, \n        bg_F = Collect (\\<lambda>(q,x). x=0 \\<and> q\\<in>V),\n        \\<dots> = ecnv G\n      \\<rparr>\n      else \\<lparr>\n        g_V = Collect (\\<lambda>(q,x). x<num_acc \\<and> q\\<in>V),\n        g_E = E_of_succ (\\<lambda>(q,i). \n          if i<num_acc then\n            let\n              i' = if i \\<in> acc q then (i + 1) mod num_acc else i\n            in (\\<lambda>q'. (q',i'))`succ_of_E E q\n          else {}\n        ),\n        g_V0 = (\\<lambda>q'. (q',0))`V0,\n        bg_F = Collect (\\<lambda>(q,x). x=0 \\<and> 0\\<in>acc q),\n        \\<dots> = ecnv G\n      \\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degeneralize_ext ecnv =\n    (if num_acc = 0\n     then \\<lparr>g_V = {(q, x). x = 0 \\<and> q \\<in> V},\n             g_E =\n               E_of_succ\n                (\\<lambda>(q, x).\n                    if x = 0 then (\\<lambda>q'. (q', 0)) ` succ_of_E E q\n                    else {}),\n             g_V0 = (\\<lambda>q'. (q', 0)) ` V0,\n             bg_F = {(q, x). x = 0 \\<and> q \\<in> V},\n             \\<dots> = ecnv G\\<rparr>\n     else \\<lparr>g_V = {(q, x). x < num_acc \\<and> q \\<in> V},\n             g_E =\n               E_of_succ\n                (\\<lambda>(q, i).\n                    if i < num_acc\n                    then let i' = if i \\<in> acc q then (i + 1) mod num_acc\n                                  else i\n                         in (\\<lambda>q'. (q', i')) ` succ_of_E E q\n                    else {}),\n             g_V0 = (\\<lambda>q'. (q', 0)) ` V0,\n             bg_F = {(q, x). x = 0 \\<and> 0 \\<in> acc q},\n             \\<dots> = ecnv G\\<rparr>)", "unfolding degeneralize_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if num_acc = 0\n     then \\<lparr>g_V = V \\<times> {0},\n             g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n             g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n             \\<dots> = ecnv G\\<rparr>\n     else \\<lparr>g_V = V \\<times> {0..<num_acc},\n             g_E =\n               {((q, i), q', i') |i i' q q'.\n                i < num_acc \\<and>\n                (q, q') \\<in> E \\<and>\n                i' = (if i \\<in> acc q then (i + 1) mod num_acc else i)},\n             g_V0 = V0 \\<times> {0}, bg_F = {(q, 0) |q. 0 \\<in> acc q},\n             \\<dots> = ecnv G\\<rparr>) =\n    (if num_acc = 0\n     then \\<lparr>g_V = {(q, x). x = 0 \\<and> q \\<in> V},\n             g_E =\n               E_of_succ\n                (\\<lambda>(q, x).\n                    if x = 0 then (\\<lambda>q'. (q', 0)) ` succ_of_E E q\n                    else {}),\n             g_V0 = (\\<lambda>q'. (q', 0)) ` V0,\n             bg_F = {(q, x). x = 0 \\<and> q \\<in> V},\n             \\<dots> = ecnv G\\<rparr>\n     else \\<lparr>g_V = {(q, x). x < num_acc \\<and> q \\<in> V},\n             g_E =\n               E_of_succ\n                (\\<lambda>(q, i).\n                    if i < num_acc\n                    then let i' = if i \\<in> acc q then (i + 1) mod num_acc\n                                  else i\n                         in (\\<lambda>q'. (q', i')) ` succ_of_E E q\n                    else {}),\n             g_V0 = (\\<lambda>q'. (q', 0)) ` V0,\n             bg_F = {(q, x). x = 0 \\<and> 0 \\<in> acc q},\n             \\<dots> = ecnv G\\<rparr>)", "apply (cases \"num_acc = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. num_acc = 0 \\<Longrightarrow>\n    (if num_acc = 0\n     then \\<lparr>g_V = V \\<times> {0},\n             g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n             g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n             \\<dots> = ecnv G\\<rparr>\n     else \\<lparr>g_V = V \\<times> {0..<num_acc},\n             g_E =\n               {((q, i), q', i') |i i' q q'.\n                i < num_acc \\<and>\n                (q, q') \\<in> E \\<and>\n                i' = (if i \\<in> acc q then (i + 1) mod num_acc else i)},\n             g_V0 = V0 \\<times> {0}, bg_F = {(q, 0) |q. 0 \\<in> acc q},\n             \\<dots> = ecnv G\\<rparr>) =\n    (if num_acc = 0\n     then \\<lparr>g_V = {(q, x). x = 0 \\<and> q \\<in> V},\n             g_E =\n               E_of_succ\n                (\\<lambda>(q, x).\n                    if x = 0 then (\\<lambda>q'. (q', 0)) ` succ_of_E E q\n                    else {}),\n             g_V0 = (\\<lambda>q'. (q', 0)) ` V0,\n             bg_F = {(q, x). x = 0 \\<and> q \\<in> V},\n             \\<dots> = ecnv G\\<rparr>\n     else \\<lparr>g_V = {(q, x). x < num_acc \\<and> q \\<in> V},\n             g_E =\n               E_of_succ\n                (\\<lambda>(q, i).\n                    if i < num_acc\n                    then let i' = if i \\<in> acc q then (i + 1) mod num_acc\n                                  else i\n                         in (\\<lambda>q'. (q', i')) ` succ_of_E E q\n                    else {}),\n             g_V0 = (\\<lambda>q'. (q', 0)) ` V0,\n             bg_F = {(q, x). x = 0 \\<and> 0 \\<in> acc q},\n             \\<dots> = ecnv G\\<rparr>)\n 2. num_acc \\<noteq> 0 \\<Longrightarrow>\n    (if num_acc = 0\n     then \\<lparr>g_V = V \\<times> {0},\n             g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n             g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n             \\<dots> = ecnv G\\<rparr>\n     else \\<lparr>g_V = V \\<times> {0..<num_acc},\n             g_E =\n               {((q, i), q', i') |i i' q q'.\n                i < num_acc \\<and>\n                (q, q') \\<in> E \\<and>\n                i' = (if i \\<in> acc q then (i + 1) mod num_acc else i)},\n             g_V0 = V0 \\<times> {0}, bg_F = {(q, 0) |q. 0 \\<in> acc q},\n             \\<dots> = ecnv G\\<rparr>) =\n    (if num_acc = 0\n     then \\<lparr>g_V = {(q, x). x = 0 \\<and> q \\<in> V},\n             g_E =\n               E_of_succ\n                (\\<lambda>(q, x).\n                    if x = 0 then (\\<lambda>q'. (q', 0)) ` succ_of_E E q\n                    else {}),\n             g_V0 = (\\<lambda>q'. (q', 0)) ` V0,\n             bg_F = {(q, x). x = 0 \\<and> q \\<in> V},\n             \\<dots> = ecnv G\\<rparr>\n     else \\<lparr>g_V = {(q, x). x < num_acc \\<and> q \\<in> V},\n             g_E =\n               E_of_succ\n                (\\<lambda>(q, i).\n                    if i < num_acc\n                    then let i' = if i \\<in> acc q then (i + 1) mod num_acc\n                                  else i\n                         in (\\<lambda>q'. (q', i')) ` succ_of_E E q\n                    else {}),\n             g_V0 = (\\<lambda>q'. (q', 0)) ` V0,\n             bg_F = {(q, x). x = 0 \\<and> 0 \\<in> acc q},\n             \\<dots> = ecnv G\\<rparr>)", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. num_acc = 0 \\<Longrightarrow>\n    V \\<times> {0} = {(q, x). x = 0 \\<and> q \\<in> V} \\<and>\n    {((q, 0), q', 0) |q q'. (q, q') \\<in> E} =\n    E_of_succ\n     (\\<lambda>(q, x).\n         if x = 0 then (\\<lambda>q'. (q', 0)) ` succ_of_E E q\n         else {}) \\<and>\n    V0 \\<times> {0} = (\\<lambda>q'. (q', 0)) ` V0 \\<and>\n    V \\<times> {0} = {(q, x). x = 0 \\<and> q \\<in> V}\n 2. 0 < num_acc \\<Longrightarrow>\n    V \\<times> {0..<num_acc} = {(q, x). x < num_acc \\<and> q \\<in> V} \\<and>\n    {uu_.\n     \\<exists>i q.\n        (i \\<in> acc q \\<longrightarrow>\n         (\\<exists>q'.\n             uu_ = ((q, i), q', Suc i mod num_acc) \\<and>\n             (q, q') \\<in> E)) \\<and>\n        (i \\<notin> acc q \\<longrightarrow>\n         (\\<exists>q'.\n             uu_ = ((q, i), q', i) \\<and>\n             i < num_acc \\<and> (q, q') \\<in> E))} =\n    E_of_succ\n     (\\<lambda>(q, i).\n         if i < num_acc\n         then let i' = if i \\<in> acc q then (i + 1) mod num_acc else i\n              in (\\<lambda>q'. (q', i')) ` succ_of_E E q\n         else {}) \\<and>\n    V0 \\<times> {0} = (\\<lambda>q'. (q', 0)) ` V0 \\<and>\n    {(q, 0) |q. 0 \\<in> acc q} = {(q, x). x = 0 \\<and> 0 \\<in> acc q}", "apply (auto simp: E_of_succ_def succ_of_E_def split: if_split_asm) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < num_acc \\<Longrightarrow>\n    V \\<times> {0..<num_acc} = {(q, x). x < num_acc \\<and> q \\<in> V} \\<and>\n    {uu_.\n     \\<exists>i q.\n        (i \\<in> acc q \\<longrightarrow>\n         (\\<exists>q'.\n             uu_ = ((q, i), q', Suc i mod num_acc) \\<and>\n             (q, q') \\<in> E)) \\<and>\n        (i \\<notin> acc q \\<longrightarrow>\n         (\\<exists>q'.\n             uu_ = ((q, i), q', i) \\<and>\n             i < num_acc \\<and> (q, q') \\<in> E))} =\n    E_of_succ\n     (\\<lambda>(q, i).\n         if i < num_acc\n         then let i' = if i \\<in> acc q then (i + 1) mod num_acc else i\n              in (\\<lambda>q'. (q', i')) ` succ_of_E E q\n         else {}) \\<and>\n    V0 \\<times> {0} = (\\<lambda>q'. (q', 0)) ` V0 \\<and>\n    {(q, 0) |q. 0 \\<in> acc q} = {(q, x). x = 0 \\<and> 0 \\<in> acc q}", "apply (fastforce simp: E_of_succ_def succ_of_E_def split: if_split_asm) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal degeneralize_ext_impl_aux:\n  fixes Re Rv\n  assumes [autoref_rules]: \"(Gi,G) \\<in> igbg_impl_rel_ext Re Rv\"\n  shows \"(?c, degeneralize_ext) \n  \\<in> (igbg_impl_rel_ext Re Rv \\<rightarrow> Re') \\<rightarrow> bg_impl_rel_ext Re' (Rv \\<times>\\<^sub>r nat_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, degeneralize_ext)\n    \\<in> (igbg_impl_rel_ext Re Rv \\<rightarrow> Re') \\<rightarrow>\n          bg_impl_rel_ext Re' (Rv \\<times>\\<^sub>r nat_rel)", "unfolding degen_impl_aux_alt[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>ecnv.\n        if num_acc = 0\n        then \\<lparr>g_V = {(q, x). x = 0 \\<and> q \\<in> V},\n                g_E =\n                  E_of_succ\n                   (\\<lambda>(q, x).\n                       if x = 0 then (\\<lambda>q'. (q', 0)) ` succ_of_E E q\n                       else {}),\n                g_V0 = (\\<lambda>q'. (q', 0)) ` V0,\n                bg_F = {(q, x). x = 0 \\<and> q \\<in> V},\n                \\<dots> = ecnv G\\<rparr>\n        else \\<lparr>g_V = {(q, x). x < num_acc \\<and> q \\<in> V},\n                g_E =\n                  E_of_succ\n                   (\\<lambda>(q, i).\n                       if i < num_acc\n                       then let i' = if i \\<in> acc q\n                                     then (i + 1) mod num_acc else i\n                            in (\\<lambda>q'. (q', i')) ` succ_of_E E q\n                       else {}),\n                g_V0 = (\\<lambda>q'. (q', 0)) ` V0,\n                bg_F = {(q, x). x = 0 \\<and> 0 \\<in> acc q},\n                \\<dots> = ecnv G\\<rparr>)\n    \\<in> (igbg_impl_rel_ext Re Rv \\<rightarrow> Re') \\<rightarrow>\n          bg_impl_rel_ext Re' (Rv \\<times>\\<^sub>r nat_rel)", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>ecnv.\n        if num_acc = 0\n        then \\<lparr>g_V = {(q, x). x = 0 \\<and> q \\<in> V},\n                g_E =\n                  E_of_succ\n                   (\\<lambda>(q, x).\n                       if x = 0 then (\\<lambda>q'. (q', 0)) ` succ_of_E E q\n                       else {}),\n                g_V0 = (\\<lambda>q'. (q', 0)) ` V0,\n                bg_F = {(q, x). x = 0 \\<and> q \\<in> V},\n                \\<dots> = ecnv G\\<rparr>\n        else \\<lparr>g_V = {(q, x). x < num_acc \\<and> q \\<in> V},\n                g_E =\n                  E_of_succ\n                   (\\<lambda>(q, i).\n                       if i < num_acc\n                       then let i' = if i \\<in> acc q\n                                     then (i + 1) mod num_acc else i\n                            in (\\<lambda>q'. (q', i')) ` succ_of_E E q\n                       else {}),\n                g_V0 = (\\<lambda>q'. (q', 0)) ` V0,\n                bg_F = {(q, x). x = 0 \\<and> 0 \\<in> acc q},\n                \\<dots> = ecnv G\\<rparr>)\n    \\<in> (igbg_impl_rel_ext Re Rv \\<rightarrow> Re') \\<rightarrow>\n          bg_impl_rel_ext Re' (Rv \\<times>\\<^sub>r nat_rel)", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "definition [simp]: \n  \"op_igb_graph_degeneralize_ext ecnv G \\<equiv> igb_graph.degeneralize_ext G ecnv\""], ["", "lemma [autoref_op_pat]: \n  \"igb_graph.degeneralize_ext \\<equiv> \\<lambda>G ecnv. op_igb_graph_degeneralize_ext ecnv G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igb_graph.degeneralize_ext \\<equiv>\n    \\<lambda>G ecnv. op_igb_graph_degeneralize_ext ecnv G", "by simp"], ["", "thm igb_graph.degeneralize_ext_impl_aux[param_fo]"], ["", "concrete_definition degeneralize_ext_impl\n  uses igb_graph.degeneralize_ext_impl_aux[param_fo]"], ["", "thm degeneralize_ext_impl.refine"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma [autoref_rules]:\n  fixes Re\n  assumes \"SIDE_PRECOND (igb_graph G)\"\n  assumes CNVR: \"(ecnvi,ecnv) \\<in> (igbg_impl_rel_ext Re Rv \\<rightarrow> Re')\"\n  assumes GR: \"(Gi,G)\\<in>igbg_impl_rel_ext Re Rv\"\n  shows \"(degeneralize_ext_impl Gi ecnvi, \n    (OP op_igb_graph_degeneralize_ext \n       ::: (igbg_impl_rel_ext Re Rv \\<rightarrow> Re') \\<rightarrow> igbg_impl_rel_ext Re Rv \n        \\<rightarrow> bg_impl_rel_ext Re' (Rv \\<times>\\<^sub>r nat_rel) )$ecnv$G ) \n  \\<in> bg_impl_rel_ext Re' (Rv \\<times>\\<^sub>r nat_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (degeneralize_ext_impl Gi ecnvi,\n     (OP op_igb_graph_degeneralize_ext :::\n      (igbg_impl_rel_ext Re Rv \\<rightarrow> Re') \\<rightarrow>\n      igbg_impl_rel_ext Re Rv \\<rightarrow>\n      bg_impl_rel_ext Re' (Rv \\<times>\\<^sub>r nat_rel)) $\n     ecnv $\n     G)\n    \\<in> bg_impl_rel_ext Re' (Rv \\<times>\\<^sub>r nat_rel)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (degeneralize_ext_impl Gi ecnvi,\n     (OP op_igb_graph_degeneralize_ext :::\n      (igbg_impl_rel_ext Re Rv \\<rightarrow> Re') \\<rightarrow>\n      igbg_impl_rel_ext Re Rv \\<rightarrow>\n      bg_impl_rel_ext Re' (Rv \\<times>\\<^sub>r nat_rel)) $\n     ecnv $\n     G)\n    \\<in> bg_impl_rel_ext Re' (Rv \\<times>\\<^sub>r nat_rel)", "from assms"], ["proof (chain)\npicking this:\n  SIDE_PRECOND (igb_graph G)\n  (ecnvi, ecnv) \\<in> igbg_impl_rel_ext Re Rv \\<rightarrow> Re'\n  (Gi, G) \\<in> igbg_impl_rel_ext Re Rv", "have A: \"igb_graph G\""], ["proof (prove)\nusing this:\n  SIDE_PRECOND (igb_graph G)\n  (ecnvi, ecnv) \\<in> igbg_impl_rel_ext Re Rv \\<rightarrow> Re'\n  (Gi, G) \\<in> igbg_impl_rel_ext Re Rv\n\ngoal (1 subgoal):\n 1. igb_graph G", "by simp"], ["proof (state)\nthis:\n  igb_graph G\n\ngoal (1 subgoal):\n 1. (degeneralize_ext_impl Gi ecnvi,\n     (OP op_igb_graph_degeneralize_ext :::\n      (igbg_impl_rel_ext Re Rv \\<rightarrow> Re') \\<rightarrow>\n      igbg_impl_rel_ext Re Rv \\<rightarrow>\n      bg_impl_rel_ext Re' (Rv \\<times>\\<^sub>r nat_rel)) $\n     ecnv $\n     G)\n    \\<in> bg_impl_rel_ext Re' (Rv \\<times>\\<^sub>r nat_rel)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (degeneralize_ext_impl Gi ecnvi,\n     (OP op_igb_graph_degeneralize_ext :::\n      (igbg_impl_rel_ext Re Rv \\<rightarrow> Re') \\<rightarrow>\n      igbg_impl_rel_ext Re Rv \\<rightarrow>\n      bg_impl_rel_ext Re' (Rv \\<times>\\<^sub>r nat_rel)) $\n     ecnv $\n     G)\n    \\<in> bg_impl_rel_ext Re' (Rv \\<times>\\<^sub>r nat_rel)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (degeneralize_ext_impl Gi ecnvi, igb_graph.degeneralize_ext G ecnv)\n    \\<in> bg_impl_rel_ext Re' (Rv \\<times>\\<^sub>r nat_rel)", "using degeneralize_ext_impl.refine[OF A GR CNVR]"], ["proof (prove)\nusing this:\n  (degeneralize_ext_impl Gi ecnvi, igb_graph.degeneralize_ext G ecnv)\n  \\<in> bg_impl_rel_ext Re' (Rv \\<times>\\<^sub>r nat_rel)\n\ngoal (1 subgoal):\n 1. (degeneralize_ext_impl Gi ecnvi, igb_graph.degeneralize_ext G ecnv)\n    \\<in> bg_impl_rel_ext Re' (Rv \\<times>\\<^sub>r nat_rel)", "."], ["proof (state)\nthis:\n  (degeneralize_ext_impl Gi ecnvi,\n   (OP op_igb_graph_degeneralize_ext :::\n    (igbg_impl_rel_ext Re Rv \\<rightarrow> Re') \\<rightarrow>\n    igbg_impl_rel_ext Re Rv \\<rightarrow>\n    bg_impl_rel_ext Re' (Rv \\<times>\\<^sub>r nat_rel)) $\n   ecnv $\n   G)\n  \\<in> bg_impl_rel_ext Re' (Rv \\<times>\\<^sub>r nat_rel)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "thm autoref_itype(1)"], ["", "schematic_goal\n  assumes [simp]: \"igb_graph G\"\n  assumes [autoref_rules]: \"(Gi,G)\\<in>igbg_impl_rel_ext unit_rel nat_rel\"\n  shows \"(?c::?'c, igb_graph.degeneralize_ext G (\\<lambda>_. ())) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, igb_graph.degeneralize_ext G (\\<lambda>_. ())) \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Product Construction\\<close>"], ["", "context igba_sys_prod_precond begin"], ["", "lemma prod_impl_aux_alt:\n  \"prod = (\\<lparr>\n    g_V = Collect (\\<lambda>(q,s). q \\<in> igba.V \\<and> s \\<in> sa.V),\n    g_E = E_of_succ (\\<lambda>(q,s). \n      if igba.L q (sa.L s) then     \n        succ_of_E (igba.E) q \\<times> succ_of_E sa.E s\n      else\n        {}\n    ),\n    g_V0 = igba.V0 \\<times> sa.V0,\n    igbg_num_acc = igba.num_acc,\n    igbg_acc = \\<lambda>(q,s). if s\\<in>sa.V then igba.acc q else {}\n  \\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.prod =\n    \\<lparr>g_V = {(q, s). q \\<in> igba.V \\<and> s \\<in> sa.V},\n       g_E =\n         E_of_succ\n          (\\<lambda>(q, s).\n              if local.igba.L q (local.sa.L s)\n              then succ_of_E igba.E q \\<times> succ_of_E sa.E s else {}),\n       g_V0 = igba.V0 \\<times> sa.V0, igbg_num_acc = igba.num_acc,\n       igbg_acc =\n         \\<lambda>(q, s). if s \\<in> sa.V then igba.acc q else {}\\<rparr>", "unfolding prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>g_V = igba.V \\<times> sa.V,\n       g_E =\n         {((q, s), q', s').\n          local.igba.L q (local.sa.L s) \\<and>\n          (q, q') \\<in> igba.E \\<and> (s, s') \\<in> sa.E},\n       g_V0 = igba.V0 \\<times> sa.V0, igbg_num_acc = igba.num_acc,\n       igbg_acc =\n         \\<lambda>(q, s). if s \\<in> sa.V then igba.acc q else {}\\<rparr> =\n    \\<lparr>g_V = {(q, s). q \\<in> igba.V \\<and> s \\<in> sa.V},\n       g_E =\n         E_of_succ\n          (\\<lambda>(q, s).\n              if local.igba.L q (local.sa.L s)\n              then succ_of_E igba.E q \\<times> succ_of_E sa.E s else {}),\n       g_V0 = igba.V0 \\<times> sa.V0, igbg_num_acc = igba.num_acc,\n       igbg_acc =\n         \\<lambda>(q, s). if s \\<in> sa.V then igba.acc q else {}\\<rparr>", "apply (auto simp: succ_of_E_def E_of_succ_def split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal prod_impl_aux:\n  fixes Re\n  (*assumes [autoref_rules]: \"(eqq,(=)) \\<in> Rq \\<rightarrow> Rq \\<rightarrow> bool_rel\"\n  assumes [autoref_rules]: \"(eqs,(=)) \\<in> Rs \\<rightarrow> Rs \\<rightarrow> bool_rel\"*)\n  assumes [autoref_rules]: \"(Gi,G) \\<in> igba_impl_rel_ext Re Rq Rl\"\n  assumes [autoref_rules]: \"(Si,S) \\<in> sa_impl_rel_ext Re2 Rs Rl\"\n  shows \"(?c, prod) \\<in> igbg_impl_rel_ext unit_rel (Rq \\<times>\\<^sub>r Rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, local.prod)\n    \\<in> igbg_impl_rel_ext unit_rel (Rq \\<times>\\<^sub>r Rs)", "unfolding prod_impl_aux_alt[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lparr>g_V = {(q, s). q \\<in> igba.V \\<and> s \\<in> sa.V},\n        g_E =\n          E_of_succ\n           (\\<lambda>(q, s).\n               if local.igba.L q (local.sa.L s)\n               then succ_of_E igba.E q \\<times> succ_of_E sa.E s else {}),\n        g_V0 = igba.V0 \\<times> sa.V0, igbg_num_acc = igba.num_acc,\n        igbg_acc =\n          \\<lambda>(q, s). if s \\<in> sa.V then igba.acc q else {}\\<rparr>)\n    \\<in> igbg_impl_rel_ext unit_rel (Rq \\<times>\\<^sub>r Rs)", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "definition [simp]: \"op_igba_sys_prod \\<equiv> igba_sys_prod_precond.prod\""], ["", "lemma [autoref_op_pat]: \n  \"igba_sys_prod_precond.prod \\<equiv> op_igba_sys_prod\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igba_sys_prod_precond.prod \\<equiv> op_igba_sys_prod", "by simp"], ["", "thm igba_sys_prod_precond.prod_impl_aux[param_fo]"], ["", "concrete_definition igba_sys_prod_impl\n  uses igba_sys_prod_precond.prod_impl_aux[param_fo]"], ["", "thm igba_sys_prod_impl.refine"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma [autoref_rules]:\n  fixes Re\n  assumes \"SIDE_PRECOND (igba G)\"\n  assumes \"SIDE_PRECOND (sa S)\"\n  assumes GR: \"(Gi,G)\\<in>igba_impl_rel_ext unit_rel Rq Rl\"\n  assumes SR: \"(Si,S)\\<in>sa_impl_rel_ext unit_rel Rs Rl\"\n  shows \"(igba_sys_prod_impl Gi Si, \n    (OP op_igba_sys_prod \n       :::  igba_impl_rel_ext unit_rel Rq Rl\n        \\<rightarrow> sa_impl_rel_ext unit_rel Rs Rl\n        \\<rightarrow> igbg_impl_rel_ext unit_rel (Rq \\<times>\\<^sub>r Rs) )$G$S ) \n  \\<in> igbg_impl_rel_ext unit_rel (Rq \\<times>\\<^sub>r Rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (igba_sys_prod_impl Gi Si,\n     (OP op_igba_sys_prod :::\n      igba_impl_rel_ext unit_rel Rq Rl \\<rightarrow>\n      sa_impl_rel_ext unit_rel Rs Rl \\<rightarrow>\n      igbg_impl_rel_ext unit_rel (Rq \\<times>\\<^sub>r Rs)) $\n     G $\n     S)\n    \\<in> igbg_impl_rel_ext unit_rel (Rq \\<times>\\<^sub>r Rs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (igba_sys_prod_impl Gi Si,\n     (OP op_igba_sys_prod :::\n      igba_impl_rel_ext unit_rel Rq Rl \\<rightarrow>\n      sa_impl_rel_ext unit_rel Rs Rl \\<rightarrow>\n      igbg_impl_rel_ext unit_rel (Rq \\<times>\\<^sub>r Rs)) $\n     G $\n     S)\n    \\<in> igbg_impl_rel_ext unit_rel (Rq \\<times>\\<^sub>r Rs)", "from assms"], ["proof (chain)\npicking this:\n  SIDE_PRECOND (igba G)\n  SIDE_PRECOND (sa S)\n  (Gi, G) \\<in> igba_impl_rel_ext unit_rel Rq Rl\n  (Si, S) \\<in> sa_impl_rel_ext unit_rel Rs Rl", "interpret igba: igba G + sa: sa S"], ["proof (prove)\nusing this:\n  SIDE_PRECOND (igba G)\n  SIDE_PRECOND (sa S)\n  (Gi, G) \\<in> igba_impl_rel_ext unit_rel Rq Rl\n  (Si, S) \\<in> sa_impl_rel_ext unit_rel Rs Rl\n\ngoal (1 subgoal):\n 1. igba G &&& sa S", "by simp_all"], ["proof (state)\ngoal (1 subgoal):\n 1. (igba_sys_prod_impl Gi Si,\n     (OP op_igba_sys_prod :::\n      igba_impl_rel_ext unit_rel Rq Rl \\<rightarrow>\n      sa_impl_rel_ext unit_rel Rs Rl \\<rightarrow>\n      igbg_impl_rel_ext unit_rel (Rq \\<times>\\<^sub>r Rs)) $\n     G $\n     S)\n    \\<in> igbg_impl_rel_ext unit_rel (Rq \\<times>\\<^sub>r Rs)", "have A: \"igba_sys_prod_precond G S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igba_sys_prod_precond G S", "by unfold_locales"], ["proof (state)\nthis:\n  igba_sys_prod_precond G S\n\ngoal (1 subgoal):\n 1. (igba_sys_prod_impl Gi Si,\n     (OP op_igba_sys_prod :::\n      igba_impl_rel_ext unit_rel Rq Rl \\<rightarrow>\n      sa_impl_rel_ext unit_rel Rs Rl \\<rightarrow>\n      igbg_impl_rel_ext unit_rel (Rq \\<times>\\<^sub>r Rs)) $\n     G $\n     S)\n    \\<in> igbg_impl_rel_ext unit_rel (Rq \\<times>\\<^sub>r Rs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (igba_sys_prod_impl Gi Si,\n     (OP op_igba_sys_prod :::\n      igba_impl_rel_ext unit_rel Rq Rl \\<rightarrow>\n      sa_impl_rel_ext unit_rel Rs Rl \\<rightarrow>\n      igbg_impl_rel_ext unit_rel (Rq \\<times>\\<^sub>r Rs)) $\n     G $\n     S)\n    \\<in> igbg_impl_rel_ext unit_rel (Rq \\<times>\\<^sub>r Rs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (igba_sys_prod_impl Gi Si, igba_sys_prod_precond.prod G S)\n    \\<in> igbg_impl_rel_ext unit_rel (Rq \\<times>\\<^sub>r Rs)", "using igba_sys_prod_impl.refine[OF A GR SR]"], ["proof (prove)\nusing this:\n  (igba_sys_prod_impl Gi Si, igba_sys_prod_precond.prod G S)\n  \\<in> igbg_impl_rel_ext unit_rel (Rq \\<times>\\<^sub>r Rs)\n\ngoal (1 subgoal):\n 1. (igba_sys_prod_impl Gi Si, igba_sys_prod_precond.prod G S)\n    \\<in> igbg_impl_rel_ext unit_rel (Rq \\<times>\\<^sub>r Rs)", "."], ["proof (state)\nthis:\n  (igba_sys_prod_impl Gi Si,\n   (OP op_igba_sys_prod :::\n    igba_impl_rel_ext unit_rel Rq Rl \\<rightarrow>\n    sa_impl_rel_ext unit_rel Rs Rl \\<rightarrow>\n    igbg_impl_rel_ext unit_rel (Rq \\<times>\\<^sub>r Rs)) $\n   G $\n   S)\n  \\<in> igbg_impl_rel_ext unit_rel (Rq \\<times>\\<^sub>r Rs)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "schematic_goal\n  assumes [simp]: \"igba G\" \"sa S\"\n  assumes [autoref_rules]: \"(Gi,G)\\<in>igba_impl_rel_ext unit_rel Rq Rl\"\n  assumes [autoref_rules]: \"(Si,S)\\<in>sa_impl_rel_ext unit_rel Rs Rl\"\n  shows \"(?c::?'c,igba_sys_prod_precond.prod G S)\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, igba_sys_prod_precond.prod G S) \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}