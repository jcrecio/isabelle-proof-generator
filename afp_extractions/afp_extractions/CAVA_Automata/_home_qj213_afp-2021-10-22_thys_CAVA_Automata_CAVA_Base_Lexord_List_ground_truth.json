{"file_name": "/home/qj213/afp-2021-10-22/thys/CAVA_Automata/CAVA_Base/Lexord_List.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CAVA_Automata", "problem_names": ["lemma lexlist_ext:\n  \"Lex xs = Lex ys \\<Longrightarrow> xs = ys\"", "lemma Lex_unlex [simp, code abstype]:\n  \"Lex (unlex lxs) = lxs\"", "lemma unlex_lexlist [simp, code abstract]:\n  \"unlex (lexlist xs) = xs\"", "lemma not_less_Nil [simp]: \"\\<not> list_less x []\"", "lemma Nil_less_Cons [simp]: \"list_less [] (a # x)\"", "lemma Cons_less_Cons [simp]: \"list_less (a # x) (b # y) \\<longleftrightarrow> a < b \\<or> a = b \\<and> list_less x y\"", "lemma le_Nil [simp]: \"list_le x [] \\<longleftrightarrow> x = []\"", "lemma Nil_le_Cons [simp]: \"list_le [] x\"", "lemma Cons_le_Cons [simp]: \"list_le (a # x) (b # y) \\<longleftrightarrow> a < b \\<or> a = b \\<and> list_le x y\"", "lemma less_list_code [code]:\n  \"list_less xs [] \\<longleftrightarrow> False\"\n  \"list_less [] (x # xs) \\<longleftrightarrow> True\"\n  \"list_less (x # xs) (y # ys) \\<longleftrightarrow> x < y \\<or> x = y \\<and> list_less xs ys\"", "lemma less_eq_list_code [code]:\n  \"list_le (x # xs) [] \\<longleftrightarrow> False\"\n  \"list_le [] xs \\<longleftrightarrow> True\"\n  \"list_le (x # xs) (y # ys) \\<longleftrightarrow> x < y \\<or> x = y \\<and> list_le xs ys\"", "lemmas lexlist_ord_defs = lexlist_le_def lexlist_less_def list_le_def list_less_def"], "translations": [["", "lemma lexlist_ext:\n  \"Lex xs = Lex ys \\<Longrightarrow> xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lex xs = Lex ys \\<Longrightarrow> xs = ys", "by (auto simp: Lex_inject)"], ["", "lemma Lex_unlex [simp, code abstype]:\n  \"Lex (unlex lxs) = lxs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lex (unlex lxs) = lxs", "by (fact unlex_inverse)"], ["", "lemma unlex_lexlist [simp, code abstract]:\n  \"unlex (lexlist xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unlex (lexlist xs) = xs", "by (metis lexlist_ext unlex_inverse lexlist_def)"], ["", "definition list_less :: \"'a :: ord list \\<Rightarrow> 'a list \\<Rightarrow> bool\" where \n  \"list_less xs ys \\<longleftrightarrow> (xs, ys) \\<in> lexord {(u, v). u < v}\""], ["", "definition list_le where\n  \"list_le xs ys \\<longleftrightarrow> list_less xs ys \\<or> xs = ys\""], ["", "lemma not_less_Nil [simp]: \"\\<not> list_less x []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> list_less x []", "by (simp add: list_less_def)"], ["", "lemma Nil_less_Cons [simp]: \"list_less [] (a # x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_less [] (a # x)", "by (simp add: list_less_def)"], ["", "lemma Cons_less_Cons [simp]: \"list_less (a # x) (b # y) \\<longleftrightarrow> a < b \\<or> a = b \\<and> list_less x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_less (a # x) (b # y) = (a < b \\<or> a = b \\<and> list_less x y)", "by (simp add: list_less_def)"], ["", "lemma le_Nil [simp]: \"list_le x [] \\<longleftrightarrow> x = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_le x [] = (x = [])", "unfolding list_le_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_less x [] \\<or> x = []) = (x = [])", "by (cases x) auto"], ["", "lemma Nil_le_Cons [simp]: \"list_le [] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_le [] x", "unfolding list_le_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_less [] x \\<or> [] = x", "by (cases x) auto"], ["", "lemma Cons_le_Cons [simp]: \"list_le (a # x) (b # y) \\<longleftrightarrow> a < b \\<or> a = b \\<and> list_le x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_le (a # x) (b # y) = (a < b \\<or> a = b \\<and> list_le x y)", "unfolding list_le_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_less (a # x) (b # y) \\<or> a # x = b # y) =\n    (a < b \\<or> a = b \\<and> (list_less x y \\<or> x = y))", "by auto"], ["", "lemma less_list_code [code]:\n  \"list_less xs [] \\<longleftrightarrow> False\"\n  \"list_less [] (x # xs) \\<longleftrightarrow> True\"\n  \"list_less (x # xs) (y # ys) \\<longleftrightarrow> x < y \\<or> x = y \\<and> list_less xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_less xs [] = False &&&\n    list_less [] (x # xs) = True &&&\n    list_less (x # xs) (y # ys) = (x < y \\<or> x = y \\<and> list_less xs ys)", "by simp_all"], ["", "lemma less_eq_list_code [code]:\n  \"list_le (x # xs) [] \\<longleftrightarrow> False\"\n  \"list_le [] xs \\<longleftrightarrow> True\"\n  \"list_le (x # xs) (y # ys) \\<longleftrightarrow> x < y \\<or> x = y \\<and> list_le xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_le (x # xs) [] = False &&&\n    list_le [] xs = True &&&\n    list_le (x # xs) (y # ys) = (x < y \\<or> x = y \\<and> list_le xs ys)", "by simp_all"], ["", "instantiation  lexlist :: (ord) ord\nbegin"], ["", "definition\n  lexlist_less_def: \"xs < ys \\<longleftrightarrow> list_less (unlex xs) (unlex ys)\""], ["", "definition\n  lexlist_le_def: \"(xs :: _ lexlist) \\<le> ys \\<longleftrightarrow> list_le (unlex xs) (unlex ys)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a lexlist, ord_class)", ".."], ["", "lemmas lexlist_ord_defs = lexlist_le_def lexlist_less_def list_le_def list_less_def"], ["", "end"], ["", "instance lexlist :: (order) order"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a lexlist, order_class)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "fix xs :: \"'a lexlist\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "show \"xs \\<le> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<le> xs", "by (simp add: lexlist_le_def list_le_def)"], ["proof (state)\nthis:\n  xs \\<le> xs\n\ngoal (3 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "fix xs ys zs :: \"'a lexlist\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "assume \"xs \\<le> ys\" and \"ys \\<le> zs\""], ["proof (state)\nthis:\n  xs \\<le> ys\n  ys \\<le> zs\n\ngoal (3 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  xs \\<le> ys\n  ys \\<le> zs", "show \"xs \\<le> zs\""], ["proof (prove)\nusing this:\n  xs \\<le> ys\n  ys \\<le> zs\n\ngoal (1 subgoal):\n 1. xs \\<le> zs", "apply (auto simp add: lexlist_ord_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unlex xs \\<noteq> unlex zs;\n     (unlex xs, unlex ys) \\<in> lexord {(u, v). u < v};\n     (unlex ys, unlex zs) \\<in> lexord {(u, v). u < v}\\<rbrakk>\n    \\<Longrightarrow> (unlex xs, unlex zs) \\<in> lexord {(u, v). u < v}", "apply (rule lexord_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>unlex xs \\<noteq> unlex zs;\n     (unlex xs, unlex ys) \\<in> lexord {(u, v). u < v};\n     (unlex ys, unlex zs) \\<in> lexord {(u, v). u < v}\\<rbrakk>\n    \\<Longrightarrow> (unlex xs, ?y12) \\<in> lexord {(u, v). u < v}\n 2. \\<lbrakk>unlex xs \\<noteq> unlex zs;\n     (unlex xs, unlex ys) \\<in> lexord {(u, v). u < v};\n     (unlex ys, unlex zs) \\<in> lexord {(u, v). u < v}\\<rbrakk>\n    \\<Longrightarrow> (?y12, unlex zs) \\<in> lexord {(u, v). u < v}\n 3. \\<lbrakk>unlex xs \\<noteq> unlex zs;\n     (unlex xs, unlex ys) \\<in> lexord {(u, v). u < v};\n     (unlex ys, unlex zs) \\<in> lexord {(u, v). u < v}\\<rbrakk>\n    \\<Longrightarrow> trans {(u, v). u < v}", "apply (auto intro: transI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  xs \\<le> zs\n\ngoal (2 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "fix xs ys :: \"'a lexlist\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "assume \"xs \\<le> ys\" and \"ys \\<le> xs\""], ["proof (state)\nthis:\n  xs \\<le> ys\n  ys \\<le> xs\n\ngoal (2 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  xs \\<le> ys\n  ys \\<le> xs", "show \"xs = ys\""], ["proof (prove)\nusing this:\n  xs \\<le> ys\n  ys \\<le> xs\n\ngoal (1 subgoal):\n 1. xs = ys", "apply (auto simp add: lexlist_ord_defs)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>(unlex xs, unlex ys) \\<in> lexord {(u, v). u < v};\n     (unlex ys, unlex xs) \\<in> lexord {(u, v). u < v}\\<rbrakk>\n    \\<Longrightarrow> xs = ys\n 2. \\<lbrakk>(unlex xs, unlex xs) \\<in> lexord {(u, v). u < v};\n     unlex ys = unlex xs\\<rbrakk>\n    \\<Longrightarrow> xs = ys\n 3. \\<lbrakk>unlex xs = unlex ys;\n     (unlex ys, unlex ys) \\<in> lexord {(u, v). u < v}\\<rbrakk>\n    \\<Longrightarrow> xs = ys\n 4. unlex ys = unlex xs \\<Longrightarrow> xs = ys", "apply (rule lexord_irreflexive [THEN notE])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>(unlex xs, unlex ys) \\<in> lexord {(u, v). u < v};\n     (unlex ys, unlex xs) \\<in> lexord {(u, v). u < v}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x. (x, x) \\<notin> ?r6\n 2. \\<lbrakk>(unlex xs, unlex ys) \\<in> lexord {(u, v). u < v};\n     (unlex ys, unlex xs) \\<in> lexord {(u, v). u < v}\\<rbrakk>\n    \\<Longrightarrow> (?xs6, ?xs6) \\<in> lexord ?r6\n 3. \\<lbrakk>(unlex xs, unlex xs) \\<in> lexord {(u, v). u < v};\n     unlex ys = unlex xs\\<rbrakk>\n    \\<Longrightarrow> xs = ys\n 4. \\<lbrakk>unlex xs = unlex ys;\n     (unlex ys, unlex ys) \\<in> lexord {(u, v). u < v}\\<rbrakk>\n    \\<Longrightarrow> xs = ys\n 5. unlex ys = unlex xs \\<Longrightarrow> xs = ys", "defer"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>(unlex xs, unlex ys) \\<in> lexord {(u, v). u < v};\n     (unlex ys, unlex xs) \\<in> lexord {(u, v). u < v}\\<rbrakk>\n    \\<Longrightarrow> (?xs6, ?xs6) \\<in> lexord ?r6\n 2. \\<lbrakk>(unlex xs, unlex xs) \\<in> lexord {(u, v). u < v};\n     unlex ys = unlex xs\\<rbrakk>\n    \\<Longrightarrow> xs = ys\n 3. \\<lbrakk>unlex xs = unlex ys;\n     (unlex ys, unlex ys) \\<in> lexord {(u, v). u < v}\\<rbrakk>\n    \\<Longrightarrow> xs = ys\n 4. unlex ys = unlex xs \\<Longrightarrow> xs = ys\n 5. \\<lbrakk>(unlex xs, unlex ys) \\<in> lexord {(u, v). u < v};\n     (unlex ys, unlex xs) \\<in> lexord {(u, v). u < v}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x. (x, x) \\<notin> ?r6", "apply (rule lexord_trans)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>(unlex xs, unlex ys) \\<in> lexord {(u, v). u < v};\n     (unlex ys, unlex xs) \\<in> lexord {(u, v). u < v}\\<rbrakk>\n    \\<Longrightarrow> (?xs6, ?y9) \\<in> lexord ?r6\n 2. \\<lbrakk>(unlex xs, unlex ys) \\<in> lexord {(u, v). u < v};\n     (unlex ys, unlex xs) \\<in> lexord {(u, v). u < v}\\<rbrakk>\n    \\<Longrightarrow> (?y9, ?xs6) \\<in> lexord ?r6\n 3. \\<lbrakk>(unlex xs, unlex ys) \\<in> lexord {(u, v). u < v};\n     (unlex ys, unlex xs) \\<in> lexord {(u, v). u < v}\\<rbrakk>\n    \\<Longrightarrow> trans ?r6\n 4. \\<lbrakk>(unlex xs, unlex xs) \\<in> lexord {(u, v). u < v};\n     unlex ys = unlex xs\\<rbrakk>\n    \\<Longrightarrow> xs = ys\n 5. \\<lbrakk>unlex xs = unlex ys;\n     (unlex ys, unlex ys) \\<in> lexord {(u, v). u < v}\\<rbrakk>\n    \\<Longrightarrow> xs = ys\n 6. unlex ys = unlex xs \\<Longrightarrow> xs = ys\n 7. \\<lbrakk>(unlex xs, unlex ys) \\<in> lexord {(u, v). u < v};\n     (unlex ys, unlex xs) \\<in> lexord {(u, v). u < v}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x. (x, x) \\<notin> ?r6", "apply (auto intro: transI simp: unlex_inject)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  xs = ys\n\ngoal (1 subgoal):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)", "fix xs ys :: \"'a lexlist\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)", "show \"xs < ys \\<longleftrightarrow> xs \\<le> ys \\<and> \\<not> ys \\<le> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs < ys) = (xs \\<le> ys \\<and> \\<not> ys \\<le> xs)", "apply (auto simp add: lexlist_ord_defs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(unlex xs, unlex ys) \\<in> lexord {(u, v). u < v};\n     (unlex ys, unlex xs) \\<in> lexord {(x, y). x < y}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>(unlex xs, unlex xs) \\<in> lexord {(u, v). u < v};\n     unlex ys = unlex xs\\<rbrakk>\n    \\<Longrightarrow> False", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(unlex xs, unlex xs) \\<in> lexord {(u, v). u < v};\n     unlex ys = unlex xs\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>(unlex xs, unlex ys) \\<in> lexord {(u, v). u < v};\n     (unlex ys, unlex xs) \\<in> lexord {(x, y). x < y}\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule lexord_irreflexive [THEN notE])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(unlex xs, unlex xs) \\<in> lexord {(u, v). u < v};\n     unlex ys = unlex xs\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x. (x, x) \\<notin> ?r12\n 2. \\<lbrakk>(unlex xs, unlex xs) \\<in> lexord {(u, v). u < v};\n     unlex ys = unlex xs\\<rbrakk>\n    \\<Longrightarrow> (?xs12, ?xs12) \\<in> lexord ?r12\n 3. \\<lbrakk>(unlex xs, unlex ys) \\<in> lexord {(u, v). u < v};\n     (unlex ys, unlex xs) \\<in> lexord {(x, y). x < y}\\<rbrakk>\n    \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(unlex xs, unlex ys) \\<in> lexord {(u, v). u < v};\n     (unlex ys, unlex xs) \\<in> lexord {(x, y). x < y}\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule lexord_irreflexive [THEN notE])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(unlex xs, unlex ys) \\<in> lexord {(u, v). u < v};\n     (unlex ys, unlex xs) \\<in> lexord {(x, y). x < y}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x. (x, x) \\<notin> ?r16\n 2. \\<lbrakk>(unlex xs, unlex ys) \\<in> lexord {(u, v). u < v};\n     (unlex ys, unlex xs) \\<in> lexord {(x, y). x < y}\\<rbrakk>\n    \\<Longrightarrow> (?xs16, ?xs16) \\<in> lexord ?r16", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(unlex xs, unlex ys) \\<in> lexord {(u, v). u < v};\n     (unlex ys, unlex xs) \\<in> lexord {(x, y). x < y}\\<rbrakk>\n    \\<Longrightarrow> (?xs16, ?xs16) \\<in> lexord ?r16\n 2. \\<lbrakk>(unlex xs, unlex ys) \\<in> lexord {(u, v). u < v};\n     (unlex ys, unlex xs) \\<in> lexord {(x, y). x < y}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x. (x, x) \\<notin> ?r16", "apply (rule lexord_trans)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>(unlex xs, unlex ys) \\<in> lexord {(u, v). u < v};\n     (unlex ys, unlex xs) \\<in> lexord {(x, y). x < y}\\<rbrakk>\n    \\<Longrightarrow> (?xs16, ?y19) \\<in> lexord ?r16\n 2. \\<lbrakk>(unlex xs, unlex ys) \\<in> lexord {(u, v). u < v};\n     (unlex ys, unlex xs) \\<in> lexord {(x, y). x < y}\\<rbrakk>\n    \\<Longrightarrow> (?y19, ?xs16) \\<in> lexord ?r16\n 3. \\<lbrakk>(unlex xs, unlex ys) \\<in> lexord {(u, v). u < v};\n     (unlex ys, unlex xs) \\<in> lexord {(x, y). x < y}\\<rbrakk>\n    \\<Longrightarrow> trans ?r16\n 4. \\<lbrakk>(unlex xs, unlex ys) \\<in> lexord {(u, v). u < v};\n     (unlex ys, unlex xs) \\<in> lexord {(x, y). x < y}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x. (x, x) \\<notin> ?r16", "apply (auto intro: transI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (xs < ys) = (xs \\<le> ys \\<and> \\<not> ys \\<le> xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance lexlist :: (linorder) linorder"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a lexlist, linorder_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "fix xs ys :: \"'a lexlist\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "have \"(unlex xs, unlex ys) \\<in> lexord {(u, v). u < v} \\<or> unlex xs = unlex ys \\<or> (unlex ys, unlex xs) \\<in> lexord {(u, v). u < v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (unlex xs, unlex ys) \\<in> lexord {(u, v). u < v} \\<or>\n    unlex xs = unlex ys \\<or>\n    (unlex ys, unlex xs) \\<in> lexord {(u, v). u < v}", "by (rule lexord_linear) auto"], ["proof (state)\nthis:\n  (unlex xs, unlex ys) \\<in> lexord {(u, v). u < v} \\<or>\n  unlex xs = unlex ys \\<or>\n  (unlex ys, unlex xs) \\<in> lexord {(u, v). u < v}\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "then"], ["proof (chain)\npicking this:\n  (unlex xs, unlex ys) \\<in> lexord {(u, v). u < v} \\<or>\n  unlex xs = unlex ys \\<or>\n  (unlex ys, unlex xs) \\<in> lexord {(u, v). u < v}", "show \"xs \\<le> ys \\<or> ys \\<le> xs\""], ["proof (prove)\nusing this:\n  (unlex xs, unlex ys) \\<in> lexord {(u, v). u < v} \\<or>\n  unlex xs = unlex ys \\<or>\n  (unlex ys, unlex xs) \\<in> lexord {(u, v). u < v}\n\ngoal (1 subgoal):\n 1. xs \\<le> ys \\<or> ys \\<le> xs", "by (auto simp add: lexlist_ord_defs unlex_inject)"], ["proof (state)\nthis:\n  xs \\<le> ys \\<or> ys \\<le> xs\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}