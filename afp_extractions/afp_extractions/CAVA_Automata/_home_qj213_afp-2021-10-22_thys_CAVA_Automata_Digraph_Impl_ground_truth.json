{"file_name": "/home/qj213/afp-2021-10-22/thys/CAVA_Automata/Digraph_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CAVA_Automata", "problem_names": ["lemma slg_rel_def: \"\\<langle>R\\<rangle>slg_rel = \n  (R \\<rightarrow> \\<langle>R\\<rangle>list_set_rel) O br (\\<lambda>succs. {(u,v). v\\<in>succs u}) (\\<lambda>_. True)\"", "lemma slg_rel_sv[relator_props]: \n  \"\\<lbrakk>single_valued R; Range R = UNIV\\<rbrakk> \\<Longrightarrow> single_valued (\\<langle>R\\<rangle>slg_rel)\"", "lemmas [autoref_rel_intf] = REL_INTFI[of slg_rel i_slg]", "lemma [autoref_itype]: \"op_slg_succs ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\"", "lemma [autoref_op_pat]: \"E``{v} \\<equiv> op_slg_succs$E$v\"", "lemma refine_slg_succs[autoref_rules_raw]: \n  \"(\\<lambda>succs v. succs v,op_slg_succs)\\<in>\\<langle>R\\<rangle>slg_rel\\<rightarrow>R\\<rightarrow>\\<langle>R\\<rangle>list_set_rel\"", "lemma E_of_succ_of_E[simp]: \"E_of_succ (succ_of_E E) = E\"", "lemma succ_of_E_of_succ[simp]: \"succ_of_E (E_of_succ E) = E\"", "lemma [autoref_itype]: \"E_of_succ ::\\<^sub>i (I \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set) \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg\"", "lemma [autoref_itype]: \"succ_of_E ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\"", "lemma E_of_succ_refine[autoref_rules]:\n  \"(\\<lambda>x. x, E_of_succ) \\<in> (R \\<rightarrow> \\<langle>R\\<rangle>list_set_rel) \\<rightarrow> \\<langle>R\\<rangle>slg_rel\"\n  \"(\\<lambda>x. x, succ_of_E) \\<in> \\<langle>R\\<rangle>slg_rel \\<rightarrow> (R \\<rightarrow> \\<langle>R\\<rangle>list_set_rel)\"", "lemma [autoref_op_pat]: \n  \"E \\<inter> (Vl \\<times> Vr) \\<equiv> op_graph_restrict Vl Vr E\"\n  \"E \\<inter> (Vl \\<times> UNIV) \\<equiv> op_graph_restrict_left Vl E\"\n  \"E \\<inter> (UNIV \\<times> Vr) \\<equiv> op_graph_restrict_right Vr E\"", "lemma graph_restrict_aimpl: \"op_graph_restrict Vl Vr E = \n  E_of_succ (\\<lambda>v. if v\\<in>Vl then {x \\<in> E``{v}. x\\<in>Vr} else {})\"", "lemma graph_restrict_left_aimpl: \"op_graph_restrict_left Vl E = \n  E_of_succ (\\<lambda>v. if v\\<in>Vl then E``{v} else {})\"", "lemma graph_restrict_right_aimpl: \"op_graph_restrict_right Vr E = \n  E_of_succ (\\<lambda>v. {x \\<in> E``{v}. x\\<in>Vr})\"", "lemma [autoref_itype]:\n    \"op_graph_restrict ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg\"\n    \"op_graph_restrict_right ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg\"\n    \"op_graph_restrict_left ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg\"", "lemmas [autoref_rules_raw] = \n  graph_restrict_impl.refine[OF GEN_OP_D GEN_OP_D]\n  graph_restrict_left_impl.refine[OF GEN_OP_D]\n  graph_restrict_right_impl.refine[OF GEN_OP_D]", "lemma graph_minus_aimpl: \n  fixes E1 E2 :: \"'a rel\"\n  shows \"E1-E2 = E_of_succ (\\<lambda>x. E1``{x} - E2``{x})\"", "lemmas [autoref_rules] = graph_minus_impl_aux[OF GEN_OP_D]", "lemma graph_minus_set_aimpl: \n  fixes E1 E2 :: \"'a rel\"\n  shows \"E1-E2 = E_of_succ (\\<lambda>u. {v\\<in>E1``{u}. (u,v)\\<notin>E2})\"", "lemmas [autoref_rules (overloaded)] = graph_minus_set_impl_aux[OF GEN_OP_D GEN_OP_D]", "lemma g_type[autoref_itype]:\n  \"g_V ::\\<^sub>i \\<langle>Ie,I\\<rangle>\\<^sub>ii_g_ext \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\"\n  \"g_E ::\\<^sub>i \\<langle>Ie,I\\<rangle>\\<^sub>ii_g_ext \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg\"\n  \"g_V0 ::\\<^sub>i \\<langle>Ie,I\\<rangle>\\<^sub>ii_g_ext \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\"\n  \"graph_rec_ext\n    ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i iE \\<rightarrow>\\<^sub>i \\<langle>Ie,I\\<rangle>\\<^sub>ii_g_ext\"", "lemma gen_g_impl_rel_ext_def: \"\\<And>Rm Rv Re Rv0. \\<langle>Rm,Rv,Re,Rv0\\<rangle>gen_g_impl_rel_ext\n  \\<equiv> { (gen_g_impl_ext Vi Ei V0i mi, graph_rec_ext V E V0 m) \n      | Vi Ei V0i mi V E V0 m. \n        (Vi,V)\\<in>Rv \\<and> (Ei,E)\\<in>Re \\<and> (V0i,V0)\\<in>Rv0 \\<and> (mi,m)\\<in>Rm\n    }\"", "lemma gen_g_impl_rel_sv[relator_props]: \n  \"\\<And>Rm Rv Re Rv0. \\<lbrakk>single_valued Rv; single_valued Re; single_valued Rv0; single_valued Rm \\<rbrakk> \\<Longrightarrow> \n  single_valued (\\<langle>Rm,Rv,Re,Rv0\\<rangle>gen_g_impl_rel_ext)\"", "lemma gen_g_refine:\n  \"\\<And>Rm Rv Re Rv0. (gi_V,g_V) \\<in> \\<langle>Rm,Rv,Re,Rv0\\<rangle>gen_g_impl_rel_ext \\<rightarrow> Rv\"\n  \"\\<And>Rm Rv Re Rv0. (gi_E,g_E) \\<in> \\<langle>Rm,Rv,Re,Rv0\\<rangle>gen_g_impl_rel_ext \\<rightarrow> Re\"\n  \"\\<And>Rm Rv Re Rv0. (gi_V0,g_V0) \\<in> \\<langle>Rm,Rv,Re,Rv0\\<rangle>gen_g_impl_rel_ext \\<rightarrow> Rv0\"\n  \"\\<And>Rm Rv Re Rv0. (gen_g_impl_ext, graph_rec_ext) \n    \\<in> Rv \\<rightarrow> Re \\<rightarrow> Rv0 \\<rightarrow> Rm \\<rightarrow> \\<langle>Rm,Rv,Re,Rv0\\<rangle>gen_g_impl_rel_ext\"", "lemma frgv_impl_rel_ext_def: \"\\<langle>Rm,Rv\\<rangle>frgv_impl_rel_ext\n  \\<equiv> \\<langle>Rm,\\<langle>Rv\\<rangle>list_set_rel,\\<langle>Rv\\<rangle>slg_rel,\\<langle>Rv\\<rangle>list_set_rel\\<rangle>gen_g_impl_rel_ext\"", "lemma [autoref_rel_intf]: \"REL_INTF frgv_impl_rel_ext i_g_ext\"", "lemma [relator_props, simp]: \n  \"\\<lbrakk>single_valued Rv; Range Rv = UNIV; single_valued Rm\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rv\\<rangle>frgv_impl_rel_ext)\"", "lemmas [param, autoref_rules] = gen_g_refine[where \n  Rv = \"\\<langle>Rv\\<rangle>list_set_rel\" and Re = \"\\<langle>Rv\\<rangle>slg_rel\" and ?Rv0.0 = \"\\<langle>Rv\\<rangle>list_set_rel\"\n  for Rv, folded frgv_impl_rel_ext_def]", "lemma g_impl_rel_ext_def: \"\\<langle>Rm,Rv\\<rangle>g_impl_rel_ext\n  \\<equiv> \\<langle>Rm,\\<langle>Rv\\<rangle>fun_set_rel,\\<langle>Rv\\<rangle>slg_rel,\\<langle>Rv\\<rangle>list_set_rel\\<rangle>gen_g_impl_rel_ext\"", "lemma [autoref_rel_intf]: \"REL_INTF g_impl_rel_ext i_g_ext\"", "lemma [relator_props, simp]: \n  \"\\<lbrakk>single_valued Rv; Range Rv = UNIV; single_valued Rm\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rv\\<rangle>g_impl_rel_ext)\"", "lemmas [param, autoref_rules] = gen_g_refine[where \n  Rv = \"\\<langle>Rv\\<rangle>fun_set_rel\" \n  and Re = \"\\<langle>Rv\\<rangle>slg_rel\" \n  and ?Rv0.0 = \"\\<langle>Rv\\<rangle>list_set_rel\" \n  for Rv, folded g_impl_rel_ext_def]", "lemma [autoref_rules]: \"(gi_V_update, g_V_update) \\<in> (\\<langle>Rv\\<rangle>fun_set_rel \\<rightarrow> \\<langle>Rv\\<rangle>fun_set_rel) \\<rightarrow>\n  \\<langle>Rm, Rv\\<rangle>g_impl_rel_ext \\<rightarrow> \\<langle>Rm, Rv\\<rangle>g_impl_rel_ext\"", "lemma [autoref_rules]: \"(gi_E_update, g_E_update) \\<in> (\\<langle>Rv\\<rangle>slg_rel \\<rightarrow> \\<langle>Rv\\<rangle>slg_rel) \\<rightarrow>\n  \\<langle>Rm, Rv\\<rangle>g_impl_rel_ext \\<rightarrow> \\<langle>Rm, Rv\\<rangle>g_impl_rel_ext\"", "lemma [autoref_rules]: \"(gi_V0_update, g_V0_update) \\<in> (\\<langle>Rv\\<rangle>list_set_rel \\<rightarrow> \\<langle>Rv\\<rangle>list_set_rel) \\<rightarrow>\n  \\<langle>Rm, Rv\\<rangle>g_impl_rel_ext \\<rightarrow> \\<langle>Rm, Rv\\<rangle>g_impl_rel_ext\"", "lemma [autoref_hom]: \n  \"CONSTRAINT graph_rec_ext (\\<langle>Rv\\<rangle>Rvs \\<rightarrow> \\<langle>Rv\\<rangle>Res \\<rightarrow> \\<langle>Rv\\<rangle>Rv0s \\<rightarrow> Rm \\<rightarrow> \\<langle>Rm,Rv\\<rangle>Rg)\"", "lemma the_inv_into_map_None[simp]:\n  \"the_inv_into_map V f x = None \\<longleftrightarrow> x \\<notin> f`V\"", "lemma the_inv_into_map_Some':\n  \"the_inv_into_map V f x = Some y \\<longleftrightarrow> x \\<in> f`V \\<and> y=the_inv_into V f x\"", "lemma the_inv_into_map_Some[simp]:\n  \"inj_on f V \\<Longrightarrow> the_inv_into_map V f x = Some y \\<longleftrightarrow> y\\<in>V \\<and> x=f y\"", "lemma the_inv_into_map_impl_correct:\n  assumes [simp]: \"finite V\"\n  assumes INJ: \"inj_on f V\"\n  shows \"the_inv_into_map_impl V f \\<le> SPEC (\\<lambda>r. r = the_inv_into_map V f)\"", "lemma autoref_the_inv_into_map[autoref_rules]:\n  fixes Rv' :: \"('vti \\<times> 'vt) set\"\n  assumes \"SIDE_GEN_ALGO (is_bounded_hashcode Rv' eq bhc)\"\n  assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('vti) def_size)\"\n  assumes INJ: \"SIDE_PRECOND (inj_on f V)\"\n  assumes V: \"(Vi,V)\\<in>\\<langle>Rv\\<rangle>list_set_rel\"\n  assumes F: \"(fi,f)\\<in>Rv\\<rightarrow>Rv'\"\n  shows \"(the_inv_into_map_code eq bhc def_size Vi fi, \n    (OP the_inv_into_map \n      ::: \\<langle>Rv\\<rangle>list_set_rel \\<rightarrow> (Rv\\<rightarrow>Rv') \\<rightarrow> \\<langle>Rv', Rv\\<rangle>Impl_Array_Hash_Map.ahm_rel bhc)\n    $V$f) \\<in> \\<langle>Rv', Rv\\<rangle>Impl_Array_Hash_Map.ahm_rel bhc\"", "lemma fi_map_alt: \"fi_map = the_inv_into_map V f\"", "lemma fi_map_Some: \"(fi_map u = Some v) \\<longleftrightarrow> u\\<in>f`V \\<and> fi u = v\"", "lemma fi_map_None: \"(fi_map u = None) \\<longleftrightarrow> u\\<notin>f`V\"", "lemma rename_E_aimpl_alt: \"rename_E f E = E_of_succ (\\<lambda>v. case fi_map v of\n    Some u \\<Rightarrow> f ` (succ_of_E E u) | None \\<Rightarrow> {})\"", "lemma frv_rename_ext_aimpl_alt: \n    assumes ECNV: \"ecnv' fi_map G \\<le> SPEC (\\<lambda>r. r = ecnv G)\"\n    shows \"fr_rename_ext_aimpl ecnv' f G \n      \\<le> SPEC (\\<lambda>r. r = fr_rename_ext ecnv f G)\"", "lemma succ_of_list_correct_aux: \n  \"(succ_of_list l, set l) \\<in> br (\\<lambda>succs. {(u,v). v\\<in>succs u}) (\\<lambda>_. True)\"", "lemma succ_of_list_impl_correct: \"(succ_of_list_impl,set) \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>slg_rel\""], "translations": [["", "lemma slg_rel_def: \"\\<langle>R\\<rangle>slg_rel = \n  (R \\<rightarrow> \\<langle>R\\<rangle>list_set_rel) O br (\\<lambda>succs. {(u,v). v\\<in>succs u}) (\\<lambda>_. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>R\\<rangle>slg_rel =\n    (R \\<rightarrow> \\<langle>R\\<rangle>list_set_rel) O\n    br (\\<lambda>succs. {(u, v). v \\<in> succs u}) (\\<lambda>_. True)", "unfolding slg_rel_def_internal relAPP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_rel R (list_set_rel R) O\n    br (\\<lambda>succs. {(u, v). v \\<in> succs u}) (\\<lambda>_. True) =\n    fun_rel R (list_set_rel R) O\n    br (\\<lambda>succs. {(u, v). v \\<in> succs u}) (\\<lambda>_. True)", "by simp"], ["", "lemma slg_rel_sv[relator_props]: \n  \"\\<lbrakk>single_valued R; Range R = UNIV\\<rbrakk> \\<Longrightarrow> single_valued (\\<langle>R\\<rangle>slg_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued R; Range R = UNIV\\<rbrakk>\n    \\<Longrightarrow> single_valued (\\<langle>R\\<rangle>slg_rel)", "unfolding slg_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued R; Range R = UNIV\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       ((R \\<rightarrow> \\<langle>R\\<rangle>list_set_rel) O\n                        br (\\<lambda>succs. {(u, v). v \\<in> succs u})\n                         (\\<lambda>_. True))", "by (tagged_solver)"], ["", "consts i_slg :: \"interface \\<Rightarrow> interface\""], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of slg_rel i_slg]"], ["", "definition [simp]: \"op_slg_succs E v \\<equiv> E``{v}\""], ["", "lemma [autoref_itype]: \"op_slg_succs ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_slg_succs ::\\<^sub>i\n    \\<langle>I\\<rangle>\\<^sub>ii_slg \\<rightarrow>\\<^sub>i\n    I \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set", "by simp"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma [autoref_op_pat]: \"E``{v} \\<equiv> op_slg_succs$E$v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E `` {v} \\<equiv> op_slg_succs $ E $ v", "by simp"], ["", "end"], ["", "lemma refine_slg_succs[autoref_rules_raw]: \n  \"(\\<lambda>succs v. succs v,op_slg_succs)\\<in>\\<langle>R\\<rangle>slg_rel\\<rightarrow>R\\<rightarrow>\\<langle>R\\<rangle>list_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>succs. succs, op_slg_succs)\n    \\<in> \\<langle>R\\<rangle>slg_rel \\<rightarrow>\n          R \\<rightarrow> \\<langle>R\\<rangle>list_set_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>slg_rel;\n        (aa, a'a) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (a aa, op_slg_succs a' a'a)\n                         \\<in> \\<langle>R\\<rangle>list_set_rel", "apply (auto simp add: slg_rel_def br_def dest: fun_relD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"E_of_succ succ \\<equiv> { (u,v). v\\<in>succ u }\""], ["", "definition \"succ_of_E E \\<equiv> (\\<lambda>u. {v . (u,v)\\<in>E})\""], ["", "lemma E_of_succ_of_E[simp]: \"E_of_succ (succ_of_E E) = E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E_of_succ (succ_of_E E) = E", "unfolding E_of_succ_def succ_of_E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(u, v). v \\<in> {v. (u, v) \\<in> E}} = E", "by auto"], ["", "lemma succ_of_E_of_succ[simp]: \"succ_of_E (E_of_succ E) = E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ_of_E (E_of_succ E) = E", "unfolding E_of_succ_def succ_of_E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>u. {v. (u, v) \\<in> {(u, v). v \\<in> E u}}) = E", "by auto"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma [autoref_itype]: \"E_of_succ ::\\<^sub>i (I \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set) \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E_of_succ ::\\<^sub>i\n    (I \\<rightarrow>\\<^sub>i\n     \\<langle>I\\<rangle>\\<^sub>ii_set) \\<rightarrow>\\<^sub>i\n    \\<langle>I\\<rangle>\\<^sub>ii_slg", "by simp"], ["", "lemma [autoref_itype]: \"succ_of_E ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ_of_E ::\\<^sub>i\n    \\<langle>I\\<rangle>\\<^sub>ii_slg \\<rightarrow>\\<^sub>i\n    I \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set", "by simp"], ["", "end"], ["", "lemma E_of_succ_refine[autoref_rules]:\n  \"(\\<lambda>x. x, E_of_succ) \\<in> (R \\<rightarrow> \\<langle>R\\<rangle>list_set_rel) \\<rightarrow> \\<langle>R\\<rangle>slg_rel\"\n  \"(\\<lambda>x. x, succ_of_E) \\<in> \\<langle>R\\<rangle>slg_rel \\<rightarrow> (R \\<rightarrow> \\<langle>R\\<rangle>list_set_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x, E_of_succ)\n    \\<in> (R \\<rightarrow> \\<langle>R\\<rangle>list_set_rel) \\<rightarrow>\n          \\<langle>R\\<rangle>slg_rel &&&\n    (\\<lambda>x. x, succ_of_E)\n    \\<in> \\<langle>R\\<rangle>slg_rel \\<rightarrow>\n          R \\<rightarrow> \\<langle>R\\<rangle>list_set_rel", "unfolding E_of_succ_def[abs_def] succ_of_E_def[abs_def] slg_rel_def br_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x, \\<lambda>succ. {(u, v). v \\<in> succ u})\n    \\<in> (R \\<rightarrow> \\<langle>R\\<rangle>list_set_rel) \\<rightarrow>\n          (R \\<rightarrow> \\<langle>R\\<rangle>list_set_rel) O\n          {(c, a). a = {(u, v). v \\<in> c u} \\<and> True} &&&\n    (\\<lambda>x. x, \\<lambda>E u. {v. (u, v) \\<in> E})\n    \\<in> (R \\<rightarrow> \\<langle>R\\<rangle>list_set_rel) O\n          {(c, a). a = {(u, v). v \\<in> c u} \\<and> True} \\<rightarrow>\n          R \\<rightarrow> \\<langle>R\\<rangle>list_set_rel", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x, \\<lambda>E u. {v. (u, v) \\<in> E})\n    \\<in> (R \\<rightarrow> \\<langle>R\\<rangle>list_set_rel) O\n          {(c, a). a = {(u, v). v \\<in> c u} \\<and> True} \\<rightarrow>\n          R \\<rightarrow> \\<langle>R\\<rangle>list_set_rel", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa a'a x y.\n       \\<lbrakk>(aa, a'a) \\<in> R;\n        (x, y)\n        \\<in> R \\<rightarrow> \\<langle>R\\<rangle>list_set_rel\\<rbrakk>\n       \\<Longrightarrow> (x aa, y a'a) \\<in> \\<langle>R\\<rangle>list_set_rel", "apply (blast dest: fun_relD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Restricting Edges\\<close>"], ["", "definition op_graph_restrict :: \"'v set \\<Rightarrow> 'v set \\<Rightarrow> ('v \\<times> 'v) set \\<Rightarrow> ('v \\<times> 'v) set\"\n  where [simp]: \"op_graph_restrict Vl Vr E \\<equiv> E \\<inter> Vl \\<times> Vr\""], ["", "definition op_graph_restrict_left :: \"'v set \\<Rightarrow> ('v \\<times> 'v) set \\<Rightarrow> ('v \\<times> 'v) set\"\n  where [simp]: \"op_graph_restrict_left Vl E \\<equiv> E \\<inter> Vl \\<times> UNIV\""], ["", "definition op_graph_restrict_right :: \"'v set \\<Rightarrow> ('v \\<times> 'v) set \\<Rightarrow> ('v \\<times> 'v) set\"\n  where [simp]: \"op_graph_restrict_right Vr E \\<equiv> E \\<inter> UNIV \\<times> Vr\""], ["", "lemma [autoref_op_pat]: \n  \"E \\<inter> (Vl \\<times> Vr) \\<equiv> op_graph_restrict Vl Vr E\"\n  \"E \\<inter> (Vl \\<times> UNIV) \\<equiv> op_graph_restrict_left Vl E\"\n  \"E \\<inter> (UNIV \\<times> Vr) \\<equiv> op_graph_restrict_right Vr E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (E \\<inter> Vl \\<times> Vr \\<equiv> op_graph_restrict Vl Vr E) &&&\n    (E \\<inter> Vl \\<times> UNIV \\<equiv> op_graph_restrict_left Vl E) &&&\n    E \\<inter> UNIV \\<times> Vr \\<equiv> op_graph_restrict_right Vr E", "by simp_all"], ["", "lemma graph_restrict_aimpl: \"op_graph_restrict Vl Vr E = \n  E_of_succ (\\<lambda>v. if v\\<in>Vl then {x \\<in> E``{v}. x\\<in>Vr} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_graph_restrict Vl Vr E =\n    E_of_succ\n     (\\<lambda>v. if v \\<in> Vl then {x \\<in> E `` {v}. x \\<in> Vr} else {})", "by (auto simp: E_of_succ_def succ_of_E_def split: if_split_asm)"], ["", "lemma graph_restrict_left_aimpl: \"op_graph_restrict_left Vl E = \n  E_of_succ (\\<lambda>v. if v\\<in>Vl then E``{v} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_graph_restrict_left Vl E =\n    E_of_succ (\\<lambda>v. if v \\<in> Vl then E `` {v} else {})", "by (auto simp: E_of_succ_def succ_of_E_def split: if_split_asm)"], ["", "lemma graph_restrict_right_aimpl: \"op_graph_restrict_right Vr E = \n  E_of_succ (\\<lambda>v. {x \\<in> E``{v}. x\\<in>Vr})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_graph_restrict_right Vr E =\n    E_of_succ (\\<lambda>v. {x \\<in> E `` {v}. x \\<in> Vr})", "by (auto simp: E_of_succ_def succ_of_E_def split: if_split_asm)"], ["", "schematic_goal graph_restrict_impl_aux:\n  fixes Rsl Rsr\n  notes [autoref_rel_intf] = REL_INTFI[of Rsl i_set] REL_INTFI[of Rsr i_set]\n  assumes [autoref_rules]: \"(meml, (\\<in>)) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>Rsl \\<rightarrow> bool_rel\"\n  assumes [autoref_rules]: \"(memr, (\\<in>)) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>Rsr \\<rightarrow> bool_rel\"\n  shows \"(?c, op_graph_restrict) \\<in> \\<langle>R\\<rangle>Rsl \\<rightarrow> \\<langle>R\\<rangle>Rsr \\<rightarrow> \\<langle>R\\<rangle>slg_rel \\<rightarrow> \\<langle>R\\<rangle>slg_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, op_graph_restrict)\n    \\<in> \\<langle>R\\<rangle>Rsl \\<rightarrow>\n          \\<langle>R\\<rangle>Rsr \\<rightarrow>\n          \\<langle>R\\<rangle>slg_rel \\<rightarrow>\n          \\<langle>R\\<rangle>slg_rel", "unfolding graph_restrict_aimpl[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>Vl Vr E.\n        E_of_succ\n         (\\<lambda>v.\n             if v \\<in> Vl then {x \\<in> E `` {v}. x \\<in> Vr} else {}))\n    \\<in> \\<langle>R\\<rangle>Rsl \\<rightarrow>\n          \\<langle>R\\<rangle>Rsr \\<rightarrow>\n          \\<langle>R\\<rangle>slg_rel \\<rightarrow>\n          \\<langle>R\\<rangle>slg_rel", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal graph_restrict_left_impl_aux:\n  fixes Rsl Rsr\n  notes [autoref_rel_intf] = REL_INTFI[of Rsl i_set] REL_INTFI[of Rsr i_set]\n  assumes [autoref_rules]: \"(meml, (\\<in>)) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>Rsl \\<rightarrow> bool_rel\"\n  shows \"(?c, op_graph_restrict_left) \\<in> \\<langle>R\\<rangle>Rsl \\<rightarrow> \\<langle>R\\<rangle>slg_rel \\<rightarrow> \\<langle>R\\<rangle>slg_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, op_graph_restrict_left)\n    \\<in> \\<langle>R\\<rangle>Rsl \\<rightarrow>\n          \\<langle>R\\<rangle>slg_rel \\<rightarrow>\n          \\<langle>R\\<rangle>slg_rel", "unfolding graph_restrict_left_aimpl[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>Vl E.\n        E_of_succ (\\<lambda>v. if v \\<in> Vl then E `` {v} else {}))\n    \\<in> \\<langle>R\\<rangle>Rsl \\<rightarrow>\n          \\<langle>R\\<rangle>slg_rel \\<rightarrow>\n          \\<langle>R\\<rangle>slg_rel", "apply (autoref (keep_goal, trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal graph_restrict_right_impl_aux:\n  fixes Rsl Rsr\n  notes [autoref_rel_intf] = REL_INTFI[of Rsl i_set] REL_INTFI[of Rsr i_set]\n  assumes [autoref_rules]: \"(memr, (\\<in>)) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>Rsr \\<rightarrow> bool_rel\"\n  shows \"(?c, op_graph_restrict_right) \\<in> \\<langle>R\\<rangle>Rsr \\<rightarrow> \\<langle>R\\<rangle>slg_rel \\<rightarrow> \\<langle>R\\<rangle>slg_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, op_graph_restrict_right)\n    \\<in> \\<langle>R\\<rangle>Rsr \\<rightarrow>\n          \\<langle>R\\<rangle>slg_rel \\<rightarrow>\n          \\<langle>R\\<rangle>slg_rel", "unfolding graph_restrict_right_aimpl[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>Vr E. E_of_succ (\\<lambda>v. {x \\<in> E `` {v}. x \\<in> Vr}))\n    \\<in> \\<langle>R\\<rangle>Rsr \\<rightarrow>\n          \\<langle>R\\<rangle>slg_rel \\<rightarrow>\n          \\<langle>R\\<rangle>slg_rel", "apply (autoref (keep_goal, trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition graph_restrict_impl uses graph_restrict_impl_aux"], ["", "concrete_definition graph_restrict_left_impl uses graph_restrict_left_impl_aux"], ["", "concrete_definition graph_restrict_right_impl uses graph_restrict_right_impl_aux"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma [autoref_itype]:\n    \"op_graph_restrict ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg\"\n    \"op_graph_restrict_right ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg\"\n    \"op_graph_restrict_left ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_graph_restrict ::\\<^sub>i\n    \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n    \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n    \\<langle>I\\<rangle>\\<^sub>ii_slg \\<rightarrow>\\<^sub>i\n    \\<langle>I\\<rangle>\\<^sub>ii_slg &&&\n    op_graph_restrict_right ::\\<^sub>i\n    \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n    \\<langle>I\\<rangle>\\<^sub>ii_slg \\<rightarrow>\\<^sub>i\n    \\<langle>I\\<rangle>\\<^sub>ii_slg &&&\n    op_graph_restrict_left ::\\<^sub>i\n    \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n    \\<langle>I\\<rangle>\\<^sub>ii_slg \\<rightarrow>\\<^sub>i\n    \\<langle>I\\<rangle>\\<^sub>ii_slg", "by auto"], ["", "end"], ["", "lemmas [autoref_rules_raw] = \n  graph_restrict_impl.refine[OF GEN_OP_D GEN_OP_D]\n  graph_restrict_left_impl.refine[OF GEN_OP_D]\n  graph_restrict_right_impl.refine[OF GEN_OP_D]"], ["", "schematic_goal \"(?c::?'c, \\<lambda>(E::nat digraph) x. E``{x}) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, \\<lambda>E x. E `` {x}) \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma graph_minus_aimpl: \n  fixes E1 E2 :: \"'a rel\"\n  shows \"E1-E2 = E_of_succ (\\<lambda>x. E1``{x} - E2``{x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E1 - E2 = E_of_succ (\\<lambda>x. E1 `` {x} - E2 `` {x})", "by (auto simp: E_of_succ_def)"], ["", "schematic_goal graph_minus_impl_aux:\n  fixes R :: \"('vi\\<times>'v) set\"\n  assumes [autoref_rules]: \"(eq,(=))\\<in>R\\<rightarrow>R\\<rightarrow>bool_rel\"\n  shows \"(?c, (-)) \\<in> \\<langle>R\\<rangle>slg_rel \\<rightarrow> \\<langle>R\\<rangle>slg_rel \\<rightarrow> \\<langle>R\\<rangle>slg_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, (-))\n    \\<in> \\<langle>R\\<rangle>slg_rel \\<rightarrow>\n          \\<langle>R\\<rangle>slg_rel \\<rightarrow>\n          \\<langle>R\\<rangle>slg_rel", "apply (subst graph_minus_aimpl[abs_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, \\<lambda>E1 E2. E_of_succ (\\<lambda>x. E1 `` {x} - E2 `` {x}))\n    \\<in> \\<langle>R\\<rangle>slg_rel \\<rightarrow>\n          \\<langle>R\\<rangle>slg_rel \\<rightarrow>\n          \\<langle>R\\<rangle>slg_rel", "apply (autoref (keep_goal,trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas [autoref_rules] = graph_minus_impl_aux[OF GEN_OP_D]"], ["", "lemma graph_minus_set_aimpl: \n  fixes E1 E2 :: \"'a rel\"\n  shows \"E1-E2 = E_of_succ (\\<lambda>u. {v\\<in>E1``{u}. (u,v)\\<notin>E2})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E1 - E2 =\n    E_of_succ (\\<lambda>u. {v \\<in> E1 `` {u}. (u, v) \\<notin> E2})", "by (auto simp: E_of_succ_def)"], ["", "schematic_goal graph_minus_set_impl_aux:\n  fixes R :: \"('vi\\<times>'v) set\"\n  assumes [autoref_rules]: \"(eq,(=))\\<in>R\\<rightarrow>R\\<rightarrow>bool_rel\"\n  assumes [autoref_rules]: \"(mem,(\\<in>)) \\<in> R \\<times>\\<^sub>r R \\<rightarrow> \\<langle>R \\<times>\\<^sub>r R\\<rangle>Rs \\<rightarrow> bool_rel\"\n  shows \"(?c, (-)) \\<in> \\<langle>R\\<rangle>slg_rel \\<rightarrow> \\<langle>R\\<times>\\<^sub>rR\\<rangle>Rs \\<rightarrow> \\<langle>R\\<rangle>slg_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, (-))\n    \\<in> \\<langle>R\\<rangle>slg_rel \\<rightarrow>\n          \\<langle>R \\<times>\\<^sub>r R\\<rangle>Rs \\<rightarrow>\n          \\<langle>R\\<rangle>slg_rel", "apply (subst graph_minus_set_aimpl[abs_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>E1 E2.\n        E_of_succ (\\<lambda>u. {v \\<in> E1 `` {u}. (u, v) \\<notin> E2}))\n    \\<in> \\<langle>R\\<rangle>slg_rel \\<rightarrow>\n          \\<langle>R \\<times>\\<^sub>r R\\<rangle>Rs \\<rightarrow>\n          \\<langle>R\\<rangle>slg_rel", "apply (autoref (keep_goal,trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas [autoref_rules (overloaded)] = graph_minus_set_impl_aux[OF GEN_OP_D GEN_OP_D]"], ["", "subsection \\<open>Rooted Graphs\\<close>"], ["", "subsubsection \\<open>Operation Identification Setup\\<close>"], ["", "consts\n  i_g_ext :: \"interface \\<Rightarrow> interface \\<Rightarrow> interface\""], ["", "abbreviation \"i_frg \\<equiv> \\<langle>i_unit\\<rangle>\\<^sub>ii_g_ext\""], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma g_type[autoref_itype]:\n  \"g_V ::\\<^sub>i \\<langle>Ie,I\\<rangle>\\<^sub>ii_g_ext \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\"\n  \"g_E ::\\<^sub>i \\<langle>Ie,I\\<rangle>\\<^sub>ii_g_ext \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg\"\n  \"g_V0 ::\\<^sub>i \\<langle>Ie,I\\<rangle>\\<^sub>ii_g_ext \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\"\n  \"graph_rec_ext\n    ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i iE \\<rightarrow>\\<^sub>i \\<langle>Ie,I\\<rangle>\\<^sub>ii_g_ext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g_V ::\\<^sub>i\n     \\<langle>Ie, I\\<rangle>\\<^sub>ii_g_ext \\<rightarrow>\\<^sub>i\n     \\<langle>I\\<rangle>\\<^sub>ii_set &&&\n     g_E ::\\<^sub>i\n     \\<langle>Ie, I\\<rangle>\\<^sub>ii_g_ext \\<rightarrow>\\<^sub>i\n     \\<langle>I\\<rangle>\\<^sub>ii_slg) &&&\n    g_V0 ::\\<^sub>i\n    \\<langle>Ie, I\\<rangle>\\<^sub>ii_g_ext \\<rightarrow>\\<^sub>i\n    \\<langle>I\\<rangle>\\<^sub>ii_set &&&\n    graph_rec_ext ::\\<^sub>i\n    \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n    \\<langle>I\\<rangle>\\<^sub>ii_slg \\<rightarrow>\\<^sub>i\n    \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n    iE \\<rightarrow>\\<^sub>i \\<langle>Ie, I\\<rangle>\\<^sub>ii_g_ext", "by simp_all"], ["", "end"], ["", "subsubsection \\<open>Generic Implementation\\<close>"], ["", "record ('vi,'ei,'v0i) gen_g_impl =\n  gi_V :: 'vi\n  gi_E :: 'ei\n  gi_V0 :: 'v0i"], ["", "definition gen_g_impl_rel_ext_internal_def: \"\\<And> Rm Rv Re Rv0. gen_g_impl_rel_ext Rm Rv Re Rv0\n  \\<equiv> { (gen_g_impl_ext Vi Ei V0i mi, graph_rec_ext V E V0 m) \n      | Vi Ei V0i mi V E V0 m. \n        (Vi,V)\\<in>Rv \\<and> (Ei,E)\\<in>Re \\<and> (V0i,V0)\\<in>Rv0 \\<and> (mi,m)\\<in>Rm\n    }\""], ["", "lemma gen_g_impl_rel_ext_def: \"\\<And>Rm Rv Re Rv0. \\<langle>Rm,Rv,Re,Rv0\\<rangle>gen_g_impl_rel_ext\n  \\<equiv> { (gen_g_impl_ext Vi Ei V0i mi, graph_rec_ext V E V0 m) \n      | Vi Ei V0i mi V E V0 m. \n        (Vi,V)\\<in>Rv \\<and> (Ei,E)\\<in>Re \\<and> (V0i,V0)\\<in>Rv0 \\<and> (mi,m)\\<in>Rm\n    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Rm Rv Re Rv0.\n       \\<langle>Rm, Rv, Re, Rv0\\<rangle>gen_g_impl_rel_ext \\<equiv>\n       {(\\<lparr>gi_V = Vi, gi_E = Ei, gi_V0 = V0i, \\<dots> = mi\\<rparr>,\n         \\<lparr>g_V = V, g_E = E, g_V0 = V0, \\<dots> = m\\<rparr>) |\n        Vi Ei V0i mi V E V0 m.\n        (Vi, V) \\<in> Rv \\<and>\n        (Ei, E) \\<in> Re \\<and> (V0i, V0) \\<in> Rv0 \\<and> (mi, m) \\<in> Rm}", "unfolding gen_g_impl_rel_ext_internal_def relAPP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Rm Rv Re Rv0.\n       {(\\<lparr>gi_V = Vi, gi_E = Ei, gi_V0 = V0i, \\<dots> = mi\\<rparr>,\n         \\<lparr>g_V = V, g_E = E, g_V0 = V0, \\<dots> = m\\<rparr>) |\n        Vi Ei V0i mi V E V0 m.\n        (Vi, V) \\<in> Rv \\<and>\n        (Ei, E) \\<in> Re \\<and>\n        (V0i, V0) \\<in> Rv0 \\<and> (mi, m) \\<in> Rm} \\<equiv>\n       {(\\<lparr>gi_V = Vi, gi_E = Ei, gi_V0 = V0i, \\<dots> = mi\\<rparr>,\n         \\<lparr>g_V = V, g_E = E, g_V0 = V0, \\<dots> = m\\<rparr>) |\n        Vi Ei V0i mi V E V0 m.\n        (Vi, V) \\<in> Rv \\<and>\n        (Ei, E) \\<in> Re \\<and> (V0i, V0) \\<in> Rv0 \\<and> (mi, m) \\<in> Rm}", "by simp"], ["", "lemma gen_g_impl_rel_sv[relator_props]: \n  \"\\<And>Rm Rv Re Rv0. \\<lbrakk>single_valued Rv; single_valued Re; single_valued Rv0; single_valued Rm \\<rbrakk> \\<Longrightarrow> \n  single_valued (\\<langle>Rm,Rv,Re,Rv0\\<rangle>gen_g_impl_rel_ext)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Rm Rv Re Rv0.\n       \\<lbrakk>single_valued Rv; single_valued Re; single_valued Rv0;\n        single_valued Rm\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (\\<langle>Rm, Rv, Re,\n                           Rv0\\<rangle>gen_g_impl_rel_ext)", "unfolding gen_g_impl_rel_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Rm Rv Re Rv0.\n       \\<lbrakk>single_valued Rv; single_valued Re; single_valued Rv0;\n        single_valued Rm\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          {(\\<lparr>gi_V = Vi, gi_E = Ei, gi_V0 = V0i,\n                               \\<dots> = mi\\<rparr>,\n                            \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                               \\<dots> = m\\<rparr>) |\n                           Vi Ei V0i mi V E V0 m.\n                           (Vi, V) \\<in> Rv \\<and>\n                           (Ei, E) \\<in> Re \\<and>\n                           (V0i, V0) \\<in> Rv0 \\<and> (mi, m) \\<in> Rm}", "apply (auto \n    intro!: single_valuedI \n    dest: single_valuedD slg_rel_sv list_set_rel_sv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gen_g_refine:\n  \"\\<And>Rm Rv Re Rv0. (gi_V,g_V) \\<in> \\<langle>Rm,Rv,Re,Rv0\\<rangle>gen_g_impl_rel_ext \\<rightarrow> Rv\"\n  \"\\<And>Rm Rv Re Rv0. (gi_E,g_E) \\<in> \\<langle>Rm,Rv,Re,Rv0\\<rangle>gen_g_impl_rel_ext \\<rightarrow> Re\"\n  \"\\<And>Rm Rv Re Rv0. (gi_V0,g_V0) \\<in> \\<langle>Rm,Rv,Re,Rv0\\<rangle>gen_g_impl_rel_ext \\<rightarrow> Rv0\"\n  \"\\<And>Rm Rv Re Rv0. (gen_g_impl_ext, graph_rec_ext) \n    \\<in> Rv \\<rightarrow> Re \\<rightarrow> Rv0 \\<rightarrow> Rm \\<rightarrow> \\<langle>Rm,Rv,Re,Rv0\\<rangle>gen_g_impl_rel_ext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>Rm Rv Re Rv0.\n         (gi_V, g_V)\n         \\<in> \\<langle>Rm, Rv, Re,\n               Rv0\\<rangle>gen_g_impl_rel_ext \\<rightarrow> Rv) &&&\n     (\\<And>Rm Rv Re Rv0.\n         (gi_E, g_E)\n         \\<in> \\<langle>Rm, Rv, Re,\n               Rv0\\<rangle>gen_g_impl_rel_ext \\<rightarrow> Re)) &&&\n    (\\<And>Rm Rv Re Rv0.\n        (gi_V0, g_V0)\n        \\<in> \\<langle>Rm, Rv, Re,\n              Rv0\\<rangle>gen_g_impl_rel_ext \\<rightarrow> Rv0) &&&\n    (\\<And>Rm Rv Re Rv0.\n        (gen_g_impl_ext, graph_rec_ext)\n        \\<in> Rv \\<rightarrow>\n              Re \\<rightarrow>\n              Rv0 \\<rightarrow>\n              Rm \\<rightarrow> \\<langle>Rm, Rv, Re,\n              Rv0\\<rangle>gen_g_impl_rel_ext)", "unfolding gen_g_impl_rel_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>Rm Rv Re Rv0.\n         (gi_V, g_V)\n         \\<in> {(\\<lparr>gi_V = Vi, gi_E = Ei, gi_V0 = V0i,\n                    \\<dots> = mi\\<rparr>,\n                 \\<lparr>g_V = V, g_E = E, g_V0 = V0, \\<dots> = m\\<rparr>) |\n                Vi Ei V0i mi V E V0 m.\n                (Vi, V) \\<in> Rv \\<and>\n                (Ei, E) \\<in> Re \\<and>\n                (V0i, V0) \\<in> Rv0 \\<and> (mi, m) \\<in> Rm} \\<rightarrow>\n               Rv) &&&\n     (\\<And>Rm Rv Re Rv0.\n         (gi_E, g_E)\n         \\<in> {(\\<lparr>gi_V = Vi, gi_E = Ei, gi_V0 = V0i,\n                    \\<dots> = mi\\<rparr>,\n                 \\<lparr>g_V = V, g_E = E, g_V0 = V0, \\<dots> = m\\<rparr>) |\n                Vi Ei V0i mi V E V0 m.\n                (Vi, V) \\<in> Rv \\<and>\n                (Ei, E) \\<in> Re \\<and>\n                (V0i, V0) \\<in> Rv0 \\<and> (mi, m) \\<in> Rm} \\<rightarrow>\n               Re)) &&&\n    (\\<And>Rm Rv Re Rv0.\n        (gi_V0, g_V0)\n        \\<in> {(\\<lparr>gi_V = Vi, gi_E = Ei, gi_V0 = V0i,\n                   \\<dots> = mi\\<rparr>,\n                \\<lparr>g_V = V, g_E = E, g_V0 = V0, \\<dots> = m\\<rparr>) |\n               Vi Ei V0i mi V E V0 m.\n               (Vi, V) \\<in> Rv \\<and>\n               (Ei, E) \\<in> Re \\<and>\n               (V0i, V0) \\<in> Rv0 \\<and> (mi, m) \\<in> Rm} \\<rightarrow>\n              Rv0) &&&\n    (\\<And>Rm Rv Re Rv0.\n        (gen_g_impl_ext, graph_rec_ext)\n        \\<in> Rv \\<rightarrow>\n              Re \\<rightarrow>\n              Rv0 \\<rightarrow>\n              Rm \\<rightarrow>\n              {(\\<lparr>gi_V = Vi, gi_E = Ei, gi_V0 = V0i,\n                   \\<dots> = mi\\<rparr>,\n                \\<lparr>g_V = V, g_E = E, g_V0 = V0, \\<dots> = m\\<rparr>) |\n               Vi Ei V0i mi V E V0 m.\n               (Vi, V) \\<in> Rv \\<and>\n               (Ei, E) \\<in> Re \\<and>\n               (V0i, V0) \\<in> Rv0 \\<and> (mi, m) \\<in> Rm})", "by auto"], ["", "subsubsection \\<open>Implementation with list-set for Nodes\\<close>"], ["", "type_synonym ('v,'m) frgv_impl_scheme = \n  \"('v list, 'v \\<Rightarrow> 'v list, 'v list, 'm) gen_g_impl_scheme\""], ["", "definition frgv_impl_rel_ext_internal_def: \n  \"frgv_impl_rel_ext Rm Rv \n  \\<equiv> \\<langle>Rm,\\<langle>Rv\\<rangle>list_set_rel,\\<langle>Rv\\<rangle>slg_rel,\\<langle>Rv\\<rangle>list_set_rel\\<rangle>gen_g_impl_rel_ext\""], ["", "lemma frgv_impl_rel_ext_def: \"\\<langle>Rm,Rv\\<rangle>frgv_impl_rel_ext\n  \\<equiv> \\<langle>Rm,\\<langle>Rv\\<rangle>list_set_rel,\\<langle>Rv\\<rangle>slg_rel,\\<langle>Rv\\<rangle>list_set_rel\\<rangle>gen_g_impl_rel_ext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Rm, Rv\\<rangle>frgv_impl_rel_ext \\<equiv> \\<langle>Rm,\n    \\<langle>Rv\\<rangle>list_set_rel, \\<langle>Rv\\<rangle>slg_rel,\n    \\<langle>Rv\\<rangle>list_set_rel\\<rangle>gen_g_impl_rel_ext", "unfolding frgv_impl_rel_ext_internal_def relAPP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_g_impl_rel_ext Rm (list_set_rel Rv) (slg_rel Rv)\n     (list_set_rel Rv) \\<equiv>\n    gen_g_impl_rel_ext Rm (list_set_rel Rv) (slg_rel Rv) (list_set_rel Rv)", "by simp"], ["", "lemma [autoref_rel_intf]: \"REL_INTF frgv_impl_rel_ext i_g_ext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REL_INTF frgv_impl_rel_ext i_g_ext", "by (rule REL_INTFI)"], ["", "lemma [relator_props, simp]: \n  \"\\<lbrakk>single_valued Rv; Range Rv = UNIV; single_valued Rm\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rv\\<rangle>frgv_impl_rel_ext)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rv; Range Rv = UNIV; single_valued Rm\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (\\<langle>Rm, Rv\\<rangle>frgv_impl_rel_ext)", "unfolding frgv_impl_rel_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rv; Range Rv = UNIV; single_valued Rm\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (\\<langle>Rm, \\<langle>Rv\\<rangle>list_set_rel,\n                        \\<langle>Rv\\<rangle>slg_rel,\n                        \\<langle>Rv\\<rangle>list_set_rel\\<rangle>gen_g_impl_rel_ext)", "by tagged_solver"], ["", "lemmas [param, autoref_rules] = gen_g_refine[where \n  Rv = \"\\<langle>Rv\\<rangle>list_set_rel\" and Re = \"\\<langle>Rv\\<rangle>slg_rel\" and ?Rv0.0 = \"\\<langle>Rv\\<rangle>list_set_rel\"\n  for Rv, folded frgv_impl_rel_ext_def]"], ["", "subsubsection \\<open>Implementation with Cfun for Nodes\\<close>"], ["", "text \\<open>This implementation allows for the universal node set.\\<close>"], ["", "type_synonym ('v,'m) g_impl_scheme = \n  \"('v \\<Rightarrow> bool, 'v \\<Rightarrow> 'v list, 'v list, 'm) gen_g_impl_scheme\""], ["", "definition g_impl_rel_ext_internal_def: \n  \"g_impl_rel_ext Rm Rv \n  \\<equiv> \\<langle>Rm,\\<langle>Rv\\<rangle>fun_set_rel,\\<langle>Rv\\<rangle>slg_rel,\\<langle>Rv\\<rangle>list_set_rel\\<rangle>gen_g_impl_rel_ext\""], ["", "lemma g_impl_rel_ext_def: \"\\<langle>Rm,Rv\\<rangle>g_impl_rel_ext\n  \\<equiv> \\<langle>Rm,\\<langle>Rv\\<rangle>fun_set_rel,\\<langle>Rv\\<rangle>slg_rel,\\<langle>Rv\\<rangle>list_set_rel\\<rangle>gen_g_impl_rel_ext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Rm, Rv\\<rangle>g_impl_rel_ext \\<equiv> \\<langle>Rm,\n    \\<langle>Rv\\<rangle>fun_set_rel, \\<langle>Rv\\<rangle>slg_rel,\n    \\<langle>Rv\\<rangle>list_set_rel\\<rangle>gen_g_impl_rel_ext", "unfolding g_impl_rel_ext_internal_def relAPP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_g_impl_rel_ext Rm (fun_set_rel Rv) (slg_rel Rv)\n     (list_set_rel Rv) \\<equiv>\n    gen_g_impl_rel_ext Rm (fun_set_rel Rv) (slg_rel Rv) (list_set_rel Rv)", "by simp"], ["", "lemma [autoref_rel_intf]: \"REL_INTF g_impl_rel_ext i_g_ext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REL_INTF g_impl_rel_ext i_g_ext", "by (rule REL_INTFI)"], ["", "lemma [relator_props, simp]: \n  \"\\<lbrakk>single_valued Rv; Range Rv = UNIV; single_valued Rm\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rv\\<rangle>g_impl_rel_ext)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rv; Range Rv = UNIV; single_valued Rm\\<rbrakk>\n    \\<Longrightarrow> single_valued (\\<langle>Rm, Rv\\<rangle>g_impl_rel_ext)", "unfolding g_impl_rel_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rv; Range Rv = UNIV; single_valued Rm\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (\\<langle>Rm, \\<langle>Rv\\<rangle>fun_set_rel,\n                        \\<langle>Rv\\<rangle>slg_rel,\n                        \\<langle>Rv\\<rangle>list_set_rel\\<rangle>gen_g_impl_rel_ext)", "by tagged_solver"], ["", "lemmas [param, autoref_rules] = gen_g_refine[where \n  Rv = \"\\<langle>Rv\\<rangle>fun_set_rel\" \n  and Re = \"\\<langle>Rv\\<rangle>slg_rel\" \n  and ?Rv0.0 = \"\\<langle>Rv\\<rangle>list_set_rel\" \n  for Rv, folded g_impl_rel_ext_def]"], ["", "lemma [autoref_rules]: \"(gi_V_update, g_V_update) \\<in> (\\<langle>Rv\\<rangle>fun_set_rel \\<rightarrow> \\<langle>Rv\\<rangle>fun_set_rel) \\<rightarrow>\n  \\<langle>Rm, Rv\\<rangle>g_impl_rel_ext \\<rightarrow> \\<langle>Rm, Rv\\<rangle>g_impl_rel_ext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gi_V_update, g_V_update)\n    \\<in> (\\<langle>Rv\\<rangle>fun_set_rel \\<rightarrow>\n           \\<langle>Rv\\<rangle>fun_set_rel) \\<rightarrow>\n          \\<langle>Rm, Rv\\<rangle>g_impl_rel_ext \\<rightarrow> \\<langle>Rm,\n          Rv\\<rangle>g_impl_rel_ext", "unfolding g_impl_rel_ext_def gen_g_impl_rel_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (gi_V_update, g_V_update)\n    \\<in> (\\<langle>Rv\\<rangle>fun_set_rel \\<rightarrow>\n           \\<langle>Rv\\<rangle>fun_set_rel) \\<rightarrow>\n          {(\\<lparr>gi_V = Vi, gi_E = Ei, gi_V0 = V0i, \\<dots> = mi\\<rparr>,\n            \\<lparr>g_V = V, g_E = E, g_V0 = V0, \\<dots> = m\\<rparr>) |\n           Vi Ei V0i mi V E V0 m.\n           (Vi, V) \\<in> \\<langle>Rv\\<rangle>fun_set_rel \\<and>\n           (Ei, E) \\<in> \\<langle>Rv\\<rangle>slg_rel \\<and>\n           (V0i, V0) \\<in> \\<langle>Rv\\<rangle>list_set_rel \\<and>\n           (mi, m) \\<in> Rm} \\<rightarrow>\n          {(\\<lparr>gi_V = Vi, gi_E = Ei, gi_V0 = V0i, \\<dots> = mi\\<rparr>,\n            \\<lparr>g_V = V, g_E = E, g_V0 = V0, \\<dots> = m\\<rparr>) |\n           Vi Ei V0i mi V E V0 m.\n           (Vi, V) \\<in> \\<langle>Rv\\<rangle>fun_set_rel \\<and>\n           (Ei, E) \\<in> \\<langle>Rv\\<rangle>slg_rel \\<and>\n           (V0i, V0) \\<in> \\<langle>Rv\\<rangle>list_set_rel \\<and>\n           (mi, m) \\<in> Rm}", "by (auto, metis (full_types) tagged_fun_relD_both)"], ["", "lemma [autoref_rules]: \"(gi_E_update, g_E_update) \\<in> (\\<langle>Rv\\<rangle>slg_rel \\<rightarrow> \\<langle>Rv\\<rangle>slg_rel) \\<rightarrow>\n  \\<langle>Rm, Rv\\<rangle>g_impl_rel_ext \\<rightarrow> \\<langle>Rm, Rv\\<rangle>g_impl_rel_ext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gi_E_update, g_E_update)\n    \\<in> (\\<langle>Rv\\<rangle>slg_rel \\<rightarrow>\n           \\<langle>Rv\\<rangle>slg_rel) \\<rightarrow>\n          \\<langle>Rm, Rv\\<rangle>g_impl_rel_ext \\<rightarrow> \\<langle>Rm,\n          Rv\\<rangle>g_impl_rel_ext", "unfolding g_impl_rel_ext_def gen_g_impl_rel_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (gi_E_update, g_E_update)\n    \\<in> (\\<langle>Rv\\<rangle>slg_rel \\<rightarrow>\n           \\<langle>Rv\\<rangle>slg_rel) \\<rightarrow>\n          {(\\<lparr>gi_V = Vi, gi_E = Ei, gi_V0 = V0i, \\<dots> = mi\\<rparr>,\n            \\<lparr>g_V = V, g_E = E, g_V0 = V0, \\<dots> = m\\<rparr>) |\n           Vi Ei V0i mi V E V0 m.\n           (Vi, V) \\<in> \\<langle>Rv\\<rangle>fun_set_rel \\<and>\n           (Ei, E) \\<in> \\<langle>Rv\\<rangle>slg_rel \\<and>\n           (V0i, V0) \\<in> \\<langle>Rv\\<rangle>list_set_rel \\<and>\n           (mi, m) \\<in> Rm} \\<rightarrow>\n          {(\\<lparr>gi_V = Vi, gi_E = Ei, gi_V0 = V0i, \\<dots> = mi\\<rparr>,\n            \\<lparr>g_V = V, g_E = E, g_V0 = V0, \\<dots> = m\\<rparr>) |\n           Vi Ei V0i mi V E V0 m.\n           (Vi, V) \\<in> \\<langle>Rv\\<rangle>fun_set_rel \\<and>\n           (Ei, E) \\<in> \\<langle>Rv\\<rangle>slg_rel \\<and>\n           (V0i, V0) \\<in> \\<langle>Rv\\<rangle>list_set_rel \\<and>\n           (mi, m) \\<in> Rm}", "by (auto, metis (full_types) tagged_fun_relD_both)"], ["", "lemma [autoref_rules]: \"(gi_V0_update, g_V0_update) \\<in> (\\<langle>Rv\\<rangle>list_set_rel \\<rightarrow> \\<langle>Rv\\<rangle>list_set_rel) \\<rightarrow>\n  \\<langle>Rm, Rv\\<rangle>g_impl_rel_ext \\<rightarrow> \\<langle>Rm, Rv\\<rangle>g_impl_rel_ext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gi_V0_update, g_V0_update)\n    \\<in> (\\<langle>Rv\\<rangle>list_set_rel \\<rightarrow>\n           \\<langle>Rv\\<rangle>list_set_rel) \\<rightarrow>\n          \\<langle>Rm, Rv\\<rangle>g_impl_rel_ext \\<rightarrow> \\<langle>Rm,\n          Rv\\<rangle>g_impl_rel_ext", "unfolding g_impl_rel_ext_def gen_g_impl_rel_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (gi_V0_update, g_V0_update)\n    \\<in> (\\<langle>Rv\\<rangle>list_set_rel \\<rightarrow>\n           \\<langle>Rv\\<rangle>list_set_rel) \\<rightarrow>\n          {(\\<lparr>gi_V = Vi, gi_E = Ei, gi_V0 = V0i, \\<dots> = mi\\<rparr>,\n            \\<lparr>g_V = V, g_E = E, g_V0 = V0, \\<dots> = m\\<rparr>) |\n           Vi Ei V0i mi V E V0 m.\n           (Vi, V) \\<in> \\<langle>Rv\\<rangle>fun_set_rel \\<and>\n           (Ei, E) \\<in> \\<langle>Rv\\<rangle>slg_rel \\<and>\n           (V0i, V0) \\<in> \\<langle>Rv\\<rangle>list_set_rel \\<and>\n           (mi, m) \\<in> Rm} \\<rightarrow>\n          {(\\<lparr>gi_V = Vi, gi_E = Ei, gi_V0 = V0i, \\<dots> = mi\\<rparr>,\n            \\<lparr>g_V = V, g_E = E, g_V0 = V0, \\<dots> = m\\<rparr>) |\n           Vi Ei V0i mi V E V0 m.\n           (Vi, V) \\<in> \\<langle>Rv\\<rangle>fun_set_rel \\<and>\n           (Ei, E) \\<in> \\<langle>Rv\\<rangle>slg_rel \\<and>\n           (V0i, V0) \\<in> \\<langle>Rv\\<rangle>list_set_rel \\<and>\n           (mi, m) \\<in> Rm}", "by (auto, metis (full_types) tagged_fun_relD_both)"], ["", "(* HACK: The homgeneity rule heuristics erronously creates a homogeneity rule that\n    equalizes Rv and Rv0, out of the frv-implementation, which happens to be the\n    first. This declaration counters the undesired effects caused by this. *)"], ["", "lemma [autoref_hom]: \n  \"CONSTRAINT graph_rec_ext (\\<langle>Rv\\<rangle>Rvs \\<rightarrow> \\<langle>Rv\\<rangle>Res \\<rightarrow> \\<langle>Rv\\<rangle>Rv0s \\<rightarrow> Rm \\<rightarrow> \\<langle>Rm,Rv\\<rangle>Rg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT graph_rec_ext\n     (\\<langle>Rv\\<rangle>Rvs \\<rightarrow>\n      \\<langle>Rv\\<rangle>Res \\<rightarrow>\n      \\<langle>Rv\\<rangle>Rv0s \\<rightarrow>\n      Rm \\<rightarrow> \\<langle>Rm, Rv\\<rangle>Rg)", "by simp"], ["", "schematic_goal \"(?c::?'c, \\<lambda>G x. g_E G `` {x})\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, \\<lambda>G x. g_E G `` {x}) \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal \"(?c,\\<lambda>V0 E.\n   \\<lparr> g_V = UNIV, g_E = E, g_V0 = V0 \\<rparr>  )\n  \\<in>\\<langle>R\\<rangle>list_set_rel \\<rightarrow> \\<langle>R\\<rangle>slg_rel \\<rightarrow> \\<langle>unit_rel,R\\<rangle>g_impl_rel_ext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, \\<lambda>V0 E. \\<lparr>g_V = UNIV, g_E = E, g_V0 = V0\\<rparr>)\n    \\<in> \\<langle>R\\<rangle>list_set_rel \\<rightarrow>\n          \\<langle>R\\<rangle>slg_rel \\<rightarrow> \\<langle>unit_rel,\n          R\\<rangle>g_impl_rel_ext", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal \"(?c,\\<lambda>V V0 E.\n   \\<lparr> g_V = V, g_E = E, g_V0 = V0 \\<rparr>  )\n  \\<in>\\<langle>R\\<rangle>list_set_rel \\<rightarrow> \\<langle>R\\<rangle>list_set_rel \\<rightarrow> \\<langle>R\\<rangle>slg_rel \\<rightarrow> \\<langle>unit_rel,R\\<rangle>frgv_impl_rel_ext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, \\<lambda>V V0 E. \\<lparr>g_V = V, g_E = E, g_V0 = V0\\<rparr>)\n    \\<in> \\<langle>R\\<rangle>list_set_rel \\<rightarrow>\n          \\<langle>R\\<rangle>list_set_rel \\<rightarrow>\n          \\<langle>R\\<rangle>slg_rel \\<rightarrow> \\<langle>unit_rel,\n          R\\<rangle>frgv_impl_rel_ext", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Renaming\\<close>"], ["", "definition \"the_inv_into_map V f x \n  = (if x \\<in> f`V then Some (the_inv_into V f x) else None)\""], ["", "lemma the_inv_into_map_None[simp]:\n  \"the_inv_into_map V f x = None \\<longleftrightarrow> x \\<notin> f`V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (the_inv_into_map V f x = None) = (x \\<notin> f ` V)", "unfolding the_inv_into_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if x \\<in> f ` V then Some (the_inv_into V f x) else None) = None) =\n    (x \\<notin> f ` V)", "by auto"], ["", "lemma the_inv_into_map_Some':\n  \"the_inv_into_map V f x = Some y \\<longleftrightarrow> x \\<in> f`V \\<and> y=the_inv_into V f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (the_inv_into_map V f x = Some y) =\n    (x \\<in> f ` V \\<and> y = the_inv_into V f x)", "unfolding the_inv_into_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if x \\<in> f ` V then Some (the_inv_into V f x) else None) = Some y) =\n    (x \\<in> f ` V \\<and> y = the_inv_into V f x)", "by auto"], ["", "lemma the_inv_into_map_Some[simp]:\n  \"inj_on f V \\<Longrightarrow> the_inv_into_map V f x = Some y \\<longleftrightarrow> y\\<in>V \\<and> x=f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f V \\<Longrightarrow>\n    (the_inv_into_map V f x = Some y) = (y \\<in> V \\<and> x = f y)", "by (auto simp: the_inv_into_map_Some' the_inv_into_f_f)"], ["", "definition \"the_inv_into_map_impl V f = \n  FOREACH V (\\<lambda>x m. RETURN (m(f x \\<mapsto> x))) Map.empty\""], ["", "lemma the_inv_into_map_impl_correct:\n  assumes [simp]: \"finite V\"\n  assumes INJ: \"inj_on f V\"\n  shows \"the_inv_into_map_impl V f \\<le> SPEC (\\<lambda>r. r = the_inv_into_map V f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_inv_into_map_impl V f\n    \\<le> SPEC (\\<lambda>r. r = the_inv_into_map V f)", "unfolding the_inv_into_map_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH V (\\<lambda>x m. RETURN (m(f x \\<mapsto> x))) Map.empty\n    \\<le> SPEC (\\<lambda>r. r = the_inv_into_map V f)", "apply (refine_rcg \n    FOREACH_rule[where I=\"\\<lambda>it m. m=the_inv_into_map (V - it) f\"]\n    refine_vcg\n  )"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite V\n 2. Map.empty = the_inv_into_map (V - V) f\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> V;\n        \\<sigma> = the_inv_into_map (V - it) f\\<rbrakk>\n       \\<Longrightarrow> \\<sigma>(f x \\<mapsto> x) =\n                         the_inv_into_map (V - (it - {x})) f\n 4. \\<And>\\<sigma>.\n       \\<sigma> = the_inv_into_map (V - {}) f \\<Longrightarrow>\n       \\<sigma> = the_inv_into_map V f", "apply (vc_solve \n    simp: the_inv_into_map_def[abs_def] it_step_insert_iff \n    intro!: ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x it xa.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> (xa = f x \\<longrightarrow>\n                          x =\n                          the_inv_into (insert x (V - it)) f (f x) \\<and>\n                          (f x \\<in> f ` (V - it) \\<longrightarrow>\n                           x =\n                           the_inv_into (insert x (V - it)) f (f x))) \\<and>\n                         (xa \\<noteq> f x \\<longrightarrow>\n                          xa \\<in> f ` (V - it) \\<longrightarrow>\n                          the_inv_into (V - it) f xa =\n                          the_inv_into (insert x (V - it)) f xa)", "apply (intro allI impI conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it xa.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> V; xa = f x\\<rbrakk>\n       \\<Longrightarrow> x = the_inv_into (insert x (V - it)) f (f x)\n 2. \\<And>x it xa.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> V; xa = f x;\n        f x \\<in> f ` (V - it)\\<rbrakk>\n       \\<Longrightarrow> x = the_inv_into (insert x (V - it)) f (f x)\n 3. \\<And>x it xa.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> V; xa \\<noteq> f x;\n        xa \\<in> f ` (V - it)\\<rbrakk>\n       \\<Longrightarrow> the_inv_into (V - it) f xa =\n                         the_inv_into (insert x (V - it)) f xa", "apply (subst the_inv_into_f_f[OF subset_inj_on[OF INJ]], auto) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it xa.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> V; xa = f x;\n        f x \\<in> f ` (V - it)\\<rbrakk>\n       \\<Longrightarrow> x = the_inv_into (insert x (V - it)) f (f x)\n 2. \\<And>x it xa.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> V; xa \\<noteq> f x;\n        xa \\<in> f ` (V - it)\\<rbrakk>\n       \\<Longrightarrow> the_inv_into (V - it) f xa =\n                         the_inv_into (insert x (V - it)) f xa", "apply (subst the_inv_into_f_f[OF subset_inj_on[OF INJ]], auto) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x it xa.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> V; xa \\<noteq> f x;\n        xa \\<in> f ` (V - it)\\<rbrakk>\n       \\<Longrightarrow> the_inv_into (V - it) f xa =\n                         the_inv_into (insert x (V - it)) f xa", "apply safe []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x it xa xb.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> V; f xb \\<noteq> f x; xb \\<in> V;\n        xb \\<notin> it\\<rbrakk>\n       \\<Longrightarrow> the_inv_into (V - it) f (f xb) =\n                         the_inv_into (insert x (V - it)) f (f xb)", "apply (subst the_inv_into_f_f[OF subset_inj_on[OF INJ]], (auto) [2])+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x it xa xb.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> V; f xb \\<noteq> f x; xb \\<in> V;\n        xb \\<notin> it\\<rbrakk>\n       \\<Longrightarrow> xb = xb", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal the_inv_into_map_code_aux:\n  fixes Rv' :: \"('vti \\<times> 'vt) set\"\n  assumes [autoref_ga_rules]: \"is_bounded_hashcode Rv' eq bhc\"\n  assumes [autoref_ga_rules]: \"is_valid_def_hm_size TYPE('vti) (def_size)\"\n  assumes [autoref_rules]: \"(Vi,V)\\<in>\\<langle>Rv\\<rangle>list_set_rel\"\n  assumes [autoref_rules]: \"(fi,f)\\<in>Rv\\<rightarrow>Rv'\"\n  shows \"(RETURN ?c, the_inv_into_map_impl V f) \\<in> \\<langle>\\<langle>Rv',Rv\\<rangle>ahm_rel bhc\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN ?c, the_inv_into_map_impl V f) \\<in> \\<langle>\\<langle>Rv',\n    Rv\\<rangle>Impl_Array_Hash_Map.ahm_rel bhc\\<rangle>nres_rel", "unfolding the_inv_into_map_impl_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN ?c,\n     FOREACH V (\\<lambda>x m. RETURN (m(f x \\<mapsto> x))) Map.empty)\n    \\<in> \\<langle>\\<langle>Rv',\n    Rv\\<rangle>Impl_Array_Hash_Map.ahm_rel bhc\\<rangle>nres_rel", "apply (autoref_monadic (plain))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition the_inv_into_map_code uses the_inv_into_map_code_aux"], ["", "export_code the_inv_into_map_code checking SML"], ["", "thm the_inv_into_map_code.refine"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma autoref_the_inv_into_map[autoref_rules]:\n  fixes Rv' :: \"('vti \\<times> 'vt) set\"\n  assumes \"SIDE_GEN_ALGO (is_bounded_hashcode Rv' eq bhc)\"\n  assumes \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('vti) def_size)\"\n  assumes INJ: \"SIDE_PRECOND (inj_on f V)\"\n  assumes V: \"(Vi,V)\\<in>\\<langle>Rv\\<rangle>list_set_rel\"\n  assumes F: \"(fi,f)\\<in>Rv\\<rightarrow>Rv'\"\n  shows \"(the_inv_into_map_code eq bhc def_size Vi fi, \n    (OP the_inv_into_map \n      ::: \\<langle>Rv\\<rangle>list_set_rel \\<rightarrow> (Rv\\<rightarrow>Rv') \\<rightarrow> \\<langle>Rv', Rv\\<rangle>Impl_Array_Hash_Map.ahm_rel bhc)\n    $V$f) \\<in> \\<langle>Rv', Rv\\<rangle>Impl_Array_Hash_Map.ahm_rel bhc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (the_inv_into_map_code eq bhc def_size Vi fi,\n     (OP the_inv_into_map :::\n      \\<langle>Rv\\<rangle>list_set_rel \\<rightarrow>\n      (Rv \\<rightarrow> Rv') \\<rightarrow> \\<langle>Rv',\n      Rv\\<rangle>Impl_Array_Hash_Map.ahm_rel bhc) $\n     V $\n     f)\n    \\<in> \\<langle>Rv', Rv\\<rangle>Impl_Array_Hash_Map.ahm_rel bhc", "proof simp"], ["proof (state)\ngoal (1 subgoal):\n 1. (the_inv_into_map_code eq bhc def_size Vi fi, the_inv_into_map V f)\n    \\<in> \\<langle>Rv', Rv\\<rangle>Impl_Array_Hash_Map.ahm_rel bhc", "from V"], ["proof (chain)\npicking this:\n  (Vi, V) \\<in> \\<langle>Rv\\<rangle>list_set_rel", "have FIN: \"finite V\""], ["proof (prove)\nusing this:\n  (Vi, V) \\<in> \\<langle>Rv\\<rangle>list_set_rel\n\ngoal (1 subgoal):\n 1. finite V", "using list_set_rel_range"], ["proof (prove)\nusing this:\n  (Vi, V) \\<in> \\<langle>Rv\\<rangle>list_set_rel\n  Range (\\<langle>?R\\<rangle>list_set_rel) =\n  {S. finite S \\<and> S \\<subseteq> Range ?R}\n\ngoal (1 subgoal):\n 1. finite V", "by auto"], ["proof (state)\nthis:\n  finite V\n\ngoal (1 subgoal):\n 1. (the_inv_into_map_code eq bhc def_size Vi fi, the_inv_into_map V f)\n    \\<in> \\<langle>Rv', Rv\\<rangle>Impl_Array_Hash_Map.ahm_rel bhc", "note the_inv_into_map_code.refine[\n    OF assms(1-2,4-5)[unfolded autoref_tag_defs], THEN nres_relD \n  ]"], ["proof (state)\nthis:\n  RETURN (the_inv_into_map_code eq bhc def_size Vi fi)\n  \\<le> \\<Down> (\\<langle>Rv', Rv\\<rangle>Impl_Array_Hash_Map.ahm_rel bhc)\n         (the_inv_into_map_impl V f)\n\ngoal (1 subgoal):\n 1. (the_inv_into_map_code eq bhc def_size Vi fi, the_inv_into_map V f)\n    \\<in> \\<langle>Rv', Rv\\<rangle>Impl_Array_Hash_Map.ahm_rel bhc", "also"], ["proof (state)\nthis:\n  RETURN (the_inv_into_map_code eq bhc def_size Vi fi)\n  \\<le> \\<Down> (\\<langle>Rv', Rv\\<rangle>Impl_Array_Hash_Map.ahm_rel bhc)\n         (the_inv_into_map_impl V f)\n\ngoal (1 subgoal):\n 1. (the_inv_into_map_code eq bhc def_size Vi fi, the_inv_into_map V f)\n    \\<in> \\<langle>Rv', Rv\\<rangle>Impl_Array_Hash_Map.ahm_rel bhc", "note the_inv_into_map_impl_correct[OF FIN INJ[unfolded autoref_tag_defs]]"], ["proof (state)\nthis:\n  the_inv_into_map_impl V f\n  \\<le> SPEC (\\<lambda>r. r = the_inv_into_map V f)\n\ngoal (1 subgoal):\n 1. (the_inv_into_map_code eq bhc def_size Vi fi, the_inv_into_map V f)\n    \\<in> \\<langle>Rv', Rv\\<rangle>Impl_Array_Hash_Map.ahm_rel bhc", "finally"], ["proof (chain)\npicking this:\n  RETURN (the_inv_into_map_code eq bhc def_size Vi fi)\n  \\<le> \\<Down> (\\<langle>Rv', Rv\\<rangle>Impl_Array_Hash_Map.ahm_rel bhc)\n         (SPEC (\\<lambda>r. r = the_inv_into_map V f))", "show \"(the_inv_into_map_code eq bhc def_size Vi fi, the_inv_into_map V f)\n    \\<in> \\<langle>Rv', Rv\\<rangle>Impl_Array_Hash_Map.ahm_rel bhc\""], ["proof (prove)\nusing this:\n  RETURN (the_inv_into_map_code eq bhc def_size Vi fi)\n  \\<le> \\<Down> (\\<langle>Rv', Rv\\<rangle>Impl_Array_Hash_Map.ahm_rel bhc)\n         (SPEC (\\<lambda>r. r = the_inv_into_map V f))\n\ngoal (1 subgoal):\n 1. (the_inv_into_map_code eq bhc def_size Vi fi, the_inv_into_map V f)\n    \\<in> \\<langle>Rv', Rv\\<rangle>Impl_Array_Hash_Map.ahm_rel bhc", "by (simp add: refine_pw_simps pw_le_iff)"], ["proof (state)\nthis:\n  (the_inv_into_map_code eq bhc def_size Vi fi, the_inv_into_map V f)\n  \\<in> \\<langle>Rv', Rv\\<rangle>Impl_Array_Hash_Map.ahm_rel bhc\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "schematic_goal \"(?c::?'c, do { \n  let s = {1,2,3::nat}; \n  \\<^cancel>\\<open>ASSERT (inj_on Suc s);\\<close>\n  RETURN (the_inv_into_map s Suc) }) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, let s = {1, 2, 3} in RETURN (the_inv_into_map s Suc)) \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"fr_rename_ext_aimpl ecnv f G \\<equiv> do {\n    ASSERT (inj_on f (g_V G));\n    ASSERT (inj_on f (g_V0 G));\n    let fi_map = the_inv_into_map (g_V G) f;\n    e \\<leftarrow> ecnv fi_map G;\n    RETURN \\<lparr>\n      g_V = f`(g_V G),\n      g_E = (E_of_succ (\\<lambda>v. case fi_map v of\n          Some u \\<Rightarrow> f ` (succ_of_E (g_E G) u) | None \\<Rightarrow> {})),\n      g_V0 = (f`g_V0 G),\n      \\<dots> = e\n    \\<rparr>\n  }\""], ["", "context g_rename_precond begin"], ["", "definition \"fi_map x = (if x \\<in> f`V then Some (fi x) else None)\""], ["", "lemma fi_map_alt: \"fi_map = the_inv_into_map V f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fi_map = the_inv_into_map V f", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. fi_map x = the_inv_into_map V f x", "unfolding fi_map_def the_inv_into_map_def fi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (if x \\<in> f ` V then Some (the_inv_into V f x) else None) =\n       (if x \\<in> f ` V then Some (the_inv_into V f x) else None)", "by simp"], ["", "lemma fi_map_Some: \"(fi_map u = Some v) \\<longleftrightarrow> u\\<in>f`V \\<and> fi u = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fi_map u = Some v) = (u \\<in> f ` V \\<and> fi u = v)", "unfolding fi_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if u \\<in> f ` V then Some (fi u) else None) = Some v) =\n    (u \\<in> f ` V \\<and> fi u = v)", "by (auto split: if_split_asm)"], ["", "lemma fi_map_None: \"(fi_map u = None) \\<longleftrightarrow> u\\<notin>f`V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fi_map u = None) = (u \\<notin> f ` V)", "unfolding fi_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if u \\<in> f ` V then Some (fi u) else None) = None) =\n    (u \\<notin> f ` V)", "by (auto split: if_split_asm)"], ["", "lemma rename_E_aimpl_alt: \"rename_E f E = E_of_succ (\\<lambda>v. case fi_map v of\n    Some u \\<Rightarrow> f ` (succ_of_E E u) | None \\<Rightarrow> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rename_E f E =\n    E_of_succ\n     (\\<lambda>v.\n         case fi_map v of None \\<Rightarrow> {}\n         | Some u \\<Rightarrow> f ` succ_of_E E u)", "unfolding E_of_succ_def succ_of_E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rename_E f E =\n    {(u, v).\n     v \\<in> (case fi_map u of None \\<Rightarrow> {}\n              | Some u \\<Rightarrow> f ` {v. (u, v) \\<in> E})}", "using E_ss"], ["proof (prove)\nusing this:\n  E \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. rename_E f E =\n    {(u, v).\n     v \\<in> (case fi_map u of None \\<Rightarrow> {}\n              | Some u \\<Rightarrow> f ` {v. (u, v) \\<in> E})}", "by (force \n      simp: fi_f f_fi fi_map_Some fi_map_None \n      split: if_split_asm option.splits)"], ["", "lemma frv_rename_ext_aimpl_alt: \n    assumes ECNV: \"ecnv' fi_map G \\<le> SPEC (\\<lambda>r. r = ecnv G)\"\n    shows \"fr_rename_ext_aimpl ecnv' f G \n      \\<le> SPEC (\\<lambda>r. r = fr_rename_ext ecnv f G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fr_rename_ext_aimpl ecnv' f G \\<le> SPEC (\\<lambda>r. r = G')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fr_rename_ext_aimpl ecnv' f G \\<le> SPEC (\\<lambda>r. r = G')", "(*have [simp]: \"\\<lparr> g_E =\n             E_of_succ\n              (\\<lambda>v. case the_inv_into_map V f v of None \\<Rightarrow> {}\n                 | Some u \\<Rightarrow> f ` succ_of_E (g_E G) u),\n            g_V0 = f ` g_V0 G, \\<dots> = ecnv Gv\\<rparr>\n      = frv_G (frv_rename_ext ecnv f Gv)\"\n      unfolding frv_rename_ext_def \n      by (auto simp: rename_E_aimpl_alt fi_map_alt)\n\n    have [simp]: \"\\<lparr>frv_V = f ` V, frv_G = frv_G Gv'\\<rparr> = Gv'\"\n      unfolding frv_rename_ext_def\n      by simp*)"], ["proof (state)\ngoal (1 subgoal):\n 1. fr_rename_ext_aimpl ecnv' f G \\<le> SPEC (\\<lambda>r. r = G')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fr_rename_ext_aimpl ecnv' f G \\<le> SPEC (\\<lambda>r. r = G')", "unfolding fr_rename_ext_def fr_rename_ext_aimpl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (inj_on f V) \\<bind>\n    (\\<lambda>_.\n        ASSERT (inj_on f V0) \\<bind>\n        (\\<lambda>_.\n            let fi_map = the_inv_into_map V f\n            in ecnv' fi_map G \\<bind>\n               (\\<lambda>e.\n                   RETURN\n                    \\<lparr>g_V = f ` V,\n                       g_E =\n                         E_of_succ\n                          (\\<lambda>v.\n                              case fi_map v of None \\<Rightarrow> {}\n                              | Some u \\<Rightarrow> f ` succ_of_E E u),\n                       g_V0 = f ` V0, \\<dots> = e\\<rparr>)))\n    \\<le> SPEC\n           (\\<lambda>r.\n               r =\n               \\<lparr>g_V = f ` V, g_E = rename_E f E, g_V0 = f ` V0,\n                  \\<dots> = ecnv G\\<rparr>)", "apply (refine_rcg \n        order_trans[OF ECNV[unfolded fi_map_alt]] \n        refine_vcg)"], ["proof (prove)\ngoal (3 subgoals):\n 1. inj_on f V\n 2. inj_on f V \\<Longrightarrow> inj_on f V0\n 3. \\<And>x.\n       \\<lbrakk>inj_on f V; inj_on f V0; x = ecnv G\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>g_V = f ` V,\n                            g_E =\n                              E_of_succ\n                               (\\<lambda>v.\n                                   case the_inv_into_map V f v of\n                                   None \\<Rightarrow> {}\n                                   | Some u \\<Rightarrow>\n f ` succ_of_E E u),\n                            g_V0 = f ` V0, \\<dots> = x\\<rparr> =\n                         \\<lparr>g_V = f ` V, g_E = rename_E f E,\n                            g_V0 = f ` V0, \\<dots> = ecnv G\\<rparr>", "using subset_inj_on[OF _ V0_ss]"], ["proof (prove)\nusing this:\n  inj_on ?f V \\<Longrightarrow> inj_on ?f V0\n\ngoal (3 subgoals):\n 1. inj_on f V\n 2. inj_on f V \\<Longrightarrow> inj_on f V0\n 3. \\<And>x.\n       \\<lbrakk>inj_on f V; inj_on f V0; x = ecnv G\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>g_V = f ` V,\n                            g_E =\n                              E_of_succ\n                               (\\<lambda>v.\n                                   case the_inv_into_map V f v of\n                                   None \\<Rightarrow> {}\n                                   | Some u \\<Rightarrow>\n f ` succ_of_E E u),\n                            g_V0 = f ` V0, \\<dots> = x\\<rparr> =\n                         \\<lparr>g_V = f ` V, g_E = rename_E f E,\n                            g_V0 = f ` V0, \\<dots> = ecnv G\\<rparr>", "apply (auto intro: INJ simp: rename_E_aimpl_alt fi_map_alt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fr_rename_ext_aimpl ecnv' f G \\<le> SPEC (\\<lambda>r. r = G')\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "term frv_rename_ext_aimpl"], ["", "schematic_goal fr_rename_ext_impl_aux:\n  fixes Re and Rv' :: \"('vti \\<times> 'vt) set\"\n  assumes [autoref_rules]: \"(eq, (=)) \\<in> Rv' \\<rightarrow> Rv' \\<rightarrow> bool_rel\"\n  assumes [autoref_ga_rules]: \"is_bounded_hashcode Rv' eq bhc\"\n  assumes [autoref_ga_rules]: \"is_valid_def_hm_size TYPE('vti) def_size\"\n  shows \"(?c,fr_rename_ext_aimpl) \\<in> \n    ((\\<langle>Rv',Rv\\<rangle>ahm_rel bhc) \\<rightarrow> \\<langle>Re,Rv\\<rangle>frgv_impl_rel_ext \\<rightarrow> \\<langle>Re'\\<rangle>nres_rel) \\<rightarrow>   \n    (Rv\\<rightarrow>Rv') \\<rightarrow>\n    \\<langle>Re,Rv\\<rangle>frgv_impl_rel_ext \\<rightarrow> \n    \\<langle>\\<langle>Re',Rv'\\<rangle>frgv_impl_rel_ext\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, fr_rename_ext_aimpl)\n    \\<in> (\\<langle>Rv',\n           Rv\\<rangle>Impl_Array_Hash_Map.ahm_rel bhc \\<rightarrow>\n           \\<langle>Re, Rv\\<rangle>frgv_impl_rel_ext \\<rightarrow>\n           \\<langle>Re'\\<rangle>nres_rel) \\<rightarrow>\n          (Rv \\<rightarrow> Rv') \\<rightarrow>\n          \\<langle>Re, Rv\\<rangle>frgv_impl_rel_ext \\<rightarrow>\n          \\<langle>\\<langle>Re',\n          Rv'\\<rangle>frgv_impl_rel_ext\\<rangle>nres_rel", "unfolding fr_rename_ext_aimpl_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>ecnv f G.\n        ASSERT (inj_on f (g_V G)) \\<bind>\n        (\\<lambda>_.\n            ASSERT (inj_on f (g_V0 G)) \\<bind>\n            (\\<lambda>_.\n                let fi_map = the_inv_into_map (g_V G) f\n                in ecnv fi_map G \\<bind>\n                   (\\<lambda>e.\n                       RETURN\n                        \\<lparr>g_V = f ` g_V G,\n                           g_E =\n                             E_of_succ\n                              (\\<lambda>v.\n                                  case fi_map v of None \\<Rightarrow> {}\n                                  | Some u \\<Rightarrow>\nf ` succ_of_E (g_E G) u),\n                           g_V0 = f ` g_V0 G, \\<dots> = e\\<rparr>))))\n    \\<in> (\\<langle>Rv',\n           Rv\\<rangle>Impl_Array_Hash_Map.ahm_rel bhc \\<rightarrow>\n           \\<langle>Re, Rv\\<rangle>frgv_impl_rel_ext \\<rightarrow>\n           \\<langle>Re'\\<rangle>nres_rel) \\<rightarrow>\n          (Rv \\<rightarrow> Rv') \\<rightarrow>\n          \\<langle>Re, Rv\\<rangle>frgv_impl_rel_ext \\<rightarrow>\n          \\<langle>\\<langle>Re',\n          Rv'\\<rangle>frgv_impl_rel_ext\\<rangle>nres_rel", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition fr_rename_ext_impl uses fr_rename_ext_impl_aux"], ["", "thm fr_rename_ext_impl.refine[OF GEN_OP_D SIDE_GEN_ALGO_D SIDE_GEN_ALGO_D]"], ["", "subsection \\<open>Graphs from Lists\\<close>"], ["", "definition succ_of_list :: \"(nat\\<times>nat) list \\<Rightarrow> nat \\<Rightarrow> nat set\"\n  where\n  \"succ_of_list l \\<equiv> let\n    m = fold (\\<lambda>(u,v) g. \n          case g u of \n            None \\<Rightarrow> g(u\\<mapsto>{v})\n          | Some s \\<Rightarrow> g(u\\<mapsto>insert v s)\n        ) l Map.empty\n  in\n    (\\<lambda>u. case m u of None \\<Rightarrow> {} | Some s \\<Rightarrow> s)\""], ["", "lemma succ_of_list_correct_aux: \n  \"(succ_of_list l, set l) \\<in> br (\\<lambda>succs. {(u,v). v\\<in>succs u}) (\\<lambda>_. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (succ_of_list l, set l)\n    \\<in> br (\\<lambda>succs. {(u, v). v \\<in> succs u}) (\\<lambda>_. True)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (succ_of_list l, set l)\n    \\<in> br (\\<lambda>succs. {(u, v). v \\<in> succs u}) (\\<lambda>_. True)", "term the_default"], ["proof (state)\ngoal (1 subgoal):\n 1. (succ_of_list l, set l)\n    \\<in> br (\\<lambda>succs. {(u, v). v \\<in> succs u}) (\\<lambda>_. True)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (succ_of_list l, set l)\n    \\<in> br (\\<lambda>succs. {(u, v). v \\<in> succs u}) (\\<lambda>_. True)", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. (succ_of_list l, set l)\n    \\<in> br (\\<lambda>succs. {(u, v). v \\<in> succs u}) (\\<lambda>_. True)", "have \"fold (\\<lambda>(u,v) g. \n            case g u of \n              None \\<Rightarrow> g(u\\<mapsto>{v})\n            | Some s \\<Rightarrow> g(u\\<mapsto>insert v s)\n          ) l m \n      = (\\<lambda>u. let s=set l `` {u} in \n          if s={} then m u else Some (the_default {} (m u) \\<union> s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>(u, v) g.\n         case g u of None \\<Rightarrow> g(u \\<mapsto> {v})\n         | Some s \\<Rightarrow> g(u \\<mapsto> insert v s))\n     l m =\n    (\\<lambda>u.\n        let s = set l `` {u}\n        in if s = {} then m u else Some (the_default {} (m u) \\<union> s))", "apply (induction l arbitrary: m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       fold\n        (\\<lambda>(u, v) g.\n            case g u of None \\<Rightarrow> g(u \\<mapsto> {v})\n            | Some s \\<Rightarrow> g(u \\<mapsto> insert v s))\n        [] m =\n       (\\<lambda>u.\n           let s = set [] `` {u}\n           in if s = {} then m u\n              else Some (the_default {} (m u) \\<union> s))\n 2. \\<And>a l m.\n       (\\<And>m.\n           fold\n            (\\<lambda>(u, v) g.\n                case g u of None \\<Rightarrow> g(u \\<mapsto> {v})\n                | Some s \\<Rightarrow> g(u \\<mapsto> insert v s))\n            l m =\n           (\\<lambda>u.\n               let s = set l `` {u}\n               in if s = {} then m u\n                  else Some\n                        (the_default {} (m u) \\<union>\n                         s))) \\<Longrightarrow>\n       fold\n        (\\<lambda>(u, v) g.\n            case g u of None \\<Rightarrow> g(u \\<mapsto> {v})\n            | Some s \\<Rightarrow> g(u \\<mapsto> insert v s))\n        (a # l) m =\n       (\\<lambda>u.\n           let s = set (a # l) `` {u}\n           in if s = {} then m u\n              else Some (the_default {} (m u) \\<union> s))", "apply (auto \n        split: option.split if_split \n        simp: Let_def Image_def\n        intro!: ext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>(u, v) g.\n       case g u of None \\<Rightarrow> g(u \\<mapsto> {v})\n       | Some s \\<Rightarrow> g(u \\<mapsto> insert v s))\n   l m =\n  (\\<lambda>u.\n      let s = set l `` {u}\n      in if s = {} then m u else Some (the_default {} (m u) \\<union> s))\n\ngoal (1 subgoal):\n 1. (succ_of_list l, set l)\n    \\<in> br (\\<lambda>succs. {(u, v). v \\<in> succs u}) (\\<lambda>_. True)", "}"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>(u, v) g.\n       case g u of None \\<Rightarrow> g(u \\<mapsto> {v})\n       | Some s \\<Rightarrow> g(u \\<mapsto> insert v s))\n   l ?m2 =\n  (\\<lambda>u.\n      let s = set l `` {u}\n      in if s = {} then ?m2 u else Some (the_default {} (?m2 u) \\<union> s))\n\ngoal (1 subgoal):\n 1. (succ_of_list l, set l)\n    \\<in> br (\\<lambda>succs. {(u, v). v \\<in> succs u}) (\\<lambda>_. True)", "note aux=this"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>(u, v) g.\n       case g u of None \\<Rightarrow> g(u \\<mapsto> {v})\n       | Some s \\<Rightarrow> g(u \\<mapsto> insert v s))\n   l ?m2 =\n  (\\<lambda>u.\n      let s = set l `` {u}\n      in if s = {} then ?m2 u else Some (the_default {} (?m2 u) \\<union> s))\n\ngoal (1 subgoal):\n 1. (succ_of_list l, set l)\n    \\<in> br (\\<lambda>succs. {(u, v). v \\<in> succs u}) (\\<lambda>_. True)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (succ_of_list l, set l)\n    \\<in> br (\\<lambda>succs. {(u, v). v \\<in> succs u}) (\\<lambda>_. True)", "unfolding succ_of_list_def aux"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let m = \\<lambda>u.\n                let s = set l `` {u}\n                in if s = {} then None\n                   else Some (the_default {} None \\<union> s)\n     in (\\<lambda>u.\n            case m u of None \\<Rightarrow> {} | Some s \\<Rightarrow> s),\n     set l)\n    \\<in> br (\\<lambda>succs. {(u, v). v \\<in> succs u}) (\\<lambda>_. True)", "by (auto simp: br_def Let_def split: option.splits if_split_asm)"], ["proof (state)\nthis:\n  (succ_of_list l, set l)\n  \\<in> br (\\<lambda>succs. {(u, v). v \\<in> succs u}) (\\<lambda>_. True)\n\ngoal:\nNo subgoals!", "qed"], ["", "schematic_goal succ_of_list_impl:\n  notes [autoref_tyrel] = \n    ty_REL[where 'a=\"nat\\<rightharpoonup>nat set\" and R=\"\\<langle>nat_rel,R\\<rangle>iam_map_rel\" for R]\n    ty_REL[where 'a=\"nat set\" and R=\"\\<langle>nat_rel\\<rangle>list_set_rel\"]\n\n  shows \"(?f::?'c,succ_of_list) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f, succ_of_list) \\<in> ?R", "unfolding succ_of_list_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f,\n     \\<lambda>l.\n        let m = fold\n                 (\\<lambda>(u, v) g.\n                     case g u of None \\<Rightarrow> g(u \\<mapsto> {v})\n                     | Some s \\<Rightarrow> g(u \\<mapsto> insert v s))\n                 l Map.empty\n        in (\\<lambda>u.\n               case m u of None \\<Rightarrow> {} | Some s \\<Rightarrow> s))\n    \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition succ_of_list_impl uses succ_of_list_impl"], ["", "export_code succ_of_list_impl in SML"], ["", "lemma succ_of_list_impl_correct: \"(succ_of_list_impl,set) \\<in> Id \\<rightarrow> \\<langle>Id\\<rangle>slg_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (succ_of_list_impl, set)\n    \\<in> Id \\<rightarrow> \\<langle>nat_rel\\<rangle>slg_rel", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> Id \\<Longrightarrow>\n       (succ_of_list_impl a, set a') \\<in> \\<langle>nat_rel\\<rangle>slg_rel", "unfolding slg_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> Id \\<Longrightarrow>\n       (succ_of_list_impl a, set a')\n       \\<in> (nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel) O\n             br (\\<lambda>succs. {(u, v). v \\<in> succs u})\n              (\\<lambda>_. True)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a'.\n       (a, a') \\<in> Id \\<Longrightarrow>\n       (succ_of_list_impl a, ?b2 a a')\n       \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel\n 2. \\<And>a a'.\n       (a, a') \\<in> Id \\<Longrightarrow>\n       (?b2 a a', set a')\n       \\<in> br (\\<lambda>succs. {(u, v). v \\<in> succs u})\n              (\\<lambda>_. True)", "apply (rule succ_of_list_impl.refine[THEN fun_relD])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a'.\n       (a, a') \\<in> Id \\<Longrightarrow>\n       (a, ?x'5 a a')\n       \\<in> \\<langle>nat_rel \\<times>\\<^sub>r nat_rel\\<rangle>list_rel\n 2. \\<And>a a'.\n       (a, a') \\<in> Id \\<Longrightarrow>\n       (succ_of_list (?x'5 a a'), set a')\n       \\<in> br (\\<lambda>succs. {(u, v). v \\<in> succs u})\n              (\\<lambda>_. True)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> Id \\<Longrightarrow>\n       (succ_of_list a', set a')\n       \\<in> br (\\<lambda>succs. {(u, v). v \\<in> succs u})\n              (\\<lambda>_. True)", "apply (rule succ_of_list_correct_aux)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}