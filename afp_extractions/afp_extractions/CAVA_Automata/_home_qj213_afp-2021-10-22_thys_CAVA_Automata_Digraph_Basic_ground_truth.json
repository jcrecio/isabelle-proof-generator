{"file_name": "/home/qj213/afp-2021-10-22/thys/CAVA_Automata/Digraph_Basic.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CAVA_Automata", "problem_names": ["lemma path1: \"(u,v)\\<in>E \\<Longrightarrow> path E u [u] v\"", "lemma path_empty_conv[simp]:\n  \"path E u [] v \\<longleftrightarrow> u=v\"", "lemma path_no_edges[simp]: \"path {} u p v \\<longleftrightarrow> (u=v \\<and> p=[])\"", "lemma path_conc: \n  assumes P1: \"path E u la v\" \n  assumes P2: \"path E v lb w\"\n  shows \"path E u (la@lb) w\"", "lemma path_append:\n  \"\\<lbrakk> path E u l v; (v,w)\\<in>E \\<rbrakk> \\<Longrightarrow> path E u (l@[v]) w\"", "lemma path_unconc:\n  assumes \"path E u (la@lb) w\"\n  obtains v where \"path E u la v\" and \"path E v lb w\"", "lemma path_conc_conv: \n  \"path E u (la@lb) w \\<longleftrightarrow> (\\<exists>v. path E u la v \\<and> path E v lb w)\"", "lemma (in -) path_append_conv: \"path E u (p@[v]) w \\<longleftrightarrow> (path E u p v \\<and> (v,w)\\<in>E)\"", "lemmas path_simps = path_empty_conv path_cons_conv path_conc_conv", "lemmas path_trans[trans] = path_prepend path_conc path_append", "lemma path_from_edges: \"\\<lbrakk>(u,v)\\<in>E; (v,w)\\<in>E\\<rbrakk> \\<Longrightarrow> path E u [u] v\"", "lemma path_edge_cases[case_names no_use split]: \n  assumes \"path (insert (u,v) E) w p x\"\n  obtains \n    \"path E w p x\" \n  | p1 p2 where \"path E w p1 u\" \"path (insert (u,v) E) v p2 x\"", "lemma path_edge_rev_cases[case_names no_use split]: \n  assumes \"path (insert (u,v) E) w p x\"\n  obtains \n    \"path E w p x\" \n  | p1 p2 where \"path (insert (u,v) E) w p1 u\" \"path E v p2 x\"", "lemma path_mono: \n  assumes S: \"E\\<subseteq>E'\" \n  assumes P: \"path E u p v\" \n  shows \"path E' u p v\"", "lemma path_is_rtrancl: \n  assumes \"path E u l v\"\n  shows \"(u,v)\\<in>E\\<^sup>*\"", "lemma rtrancl_is_path:\n  assumes \"(u,v)\\<in>E\\<^sup>*\"\n  obtains l where \"path E u l v\"", "lemma path_is_trancl: \n  assumes \"path E u l v\"\n  and \"l\\<noteq>[]\"\n  shows \"(u,v)\\<in>E\\<^sup>+\"", "lemma trancl_is_path:\n  assumes \"(u,v)\\<in>E\\<^sup>+\"\n  obtains l where \"l\\<noteq>[]\" and \"path E u l v\"", "lemma path_nth_conv: \"path E u p v \\<longleftrightarrow> (let p'=p@[v] in\n  u=p'!0 \\<and>\n  (\\<forall>i<length p' - 1. (p'!i,p'!Suc i)\\<in>E))\"", "lemma path_mapI:\n  assumes \"path E u p v\"\n  shows \"path (pairself f ` E) (f u) (map f p) (f v)\"", "lemma path_restrict: \n  assumes \"path E u p v\" \n  shows \"path (E \\<inter> set p \\<times> insert v (set (tl p))) u p v\"", "lemma path_restrict_closed:\n  assumes CLOSED: \"E``D \\<subseteq> D\"\n  assumes I: \"v\\<in>D\" and P: \"path E v p v'\"\n  shows \"path (E\\<inter>D\\<times>D) v p v'\"", "lemma path_set_induct:\n  assumes \"path E u p v\" and \"u\\<in>I\" and \"E``I \\<subseteq> I\"\n  shows \"set p \\<subseteq> I\"", "lemma path_nodes_reachable: \"path E u p v \\<Longrightarrow> insert v (set p) \\<subseteq> E\\<^sup>*``{u}\"", "lemma path_nodes_edges: \"path E u p v \\<Longrightarrow> set p \\<subseteq> fst`E\"", "lemma path_tl_nodes_edges: \n  assumes \"path E u p v\"\n  shows \"set (tl p) \\<subseteq> fst`E \\<inter> snd`E\"", "lemma path_loop_shift: \n  assumes P: \"path E u p u\"\n  assumes S: \"v\\<in>set p\"\n  obtains p' where \"set p' = set p\" \"path E v p' v\"", "lemma path_hd:\n  assumes \"p \\<noteq> []\" \"path E v p w\"\n  shows \"hd p = v\"", "lemma path_last_is_edge:\n  assumes \"path E x p y\"\n  and \"p \\<noteq> []\"\n  shows \"(last p, y) \\<in> E\"", "lemma path_member_reach_end:\n  assumes P: \"path E x p y\"\n  and v: \"v \\<in> set p\"\n  shows \"(v,y) \\<in> E\\<^sup>+\"", "lemma path_tl_induct[consumes 2, case_names single step]:\n  assumes P: \"path E x p y\"\n  and NE: \"x \\<noteq> y\"\n  and S: \"\\<And>u. (x,u) \\<in> E \\<Longrightarrow> P x u\"\n  and ST: \"\\<And>u v. \\<lbrakk>(x,u) \\<in> E\\<^sup>+; (u,v) \\<in> E; P x u\\<rbrakk> \\<Longrightarrow> P x v\"\n  shows \"P x y \\<and> (\\<forall> v \\<in> set (tl p). P x v)\"", "lemma path_restrict_tl: \n  \"\\<lbrakk> u\\<notin>R; path (E \\<inter> UNIV \\<times> -R) u p v \\<rbrakk> \\<Longrightarrow> path (rel_restrict E R) u p v\"", "lemma path1_restr_conv: \"path (E\\<inter>UNIV \\<times> -R) u (x#xs) v \n  \\<longleftrightarrow> (\\<exists>w. w\\<notin>R \\<and> x=u \\<and> (u,w)\\<in>E \\<and> path (rel_restrict E R) w xs v)\"", "lemma dropWhileNot_path:\n  assumes \"p \\<noteq> []\"\n  and \"path E w p x\"\n  and \"v \\<in> set p\"\n  and \"dropWhile ((\\<noteq>) v) p = c\"\n  shows \"path E v c x\"", "lemma takeWhileNot_path:\n  assumes \"p \\<noteq> []\"\n  and \"path E w p x\"\n  and \"v \\<in> set p\"\n  and \"takeWhile ((\\<noteq>) v) p = c\"\n  shows \"path E w c v\"", "lemma ipath_conc_conv: \n  \"ipath E (u \\<frown> v) \\<longleftrightarrow> (\\<exists>a. path E a u (v 0) \\<and> ipath E v)\"", "lemma ipath_iter_conv:\n  assumes \"p\\<noteq>[]\"\n  shows \"ipath E (p\\<^sup>\\<omega>) \\<longleftrightarrow> (path E (hd p) p (hd p))\"", "lemma ipath_to_rtrancl:\n  assumes R: \"ipath E r\"\n  assumes I: \"i1\\<le>i2\"\n  shows \"(r i1,r i2)\\<in>E\\<^sup>*\"", "lemma ipath_to_trancl:\n  assumes R: \"ipath E r\"\n  assumes I: \"i1<i2\"\n  shows \"(r i1,r i2)\\<in>E\\<^sup>+\"", "lemma run_limit_two_connectedI:\n  assumes A: \"ipath E r\" \n  assumes B: \"a \\<in> limit r\" \"b\\<in>limit r\"\n  shows \"(a,b)\\<in>E\\<^sup>+\"", "lemma ipath_subpath:\n  assumes P: \"ipath E r\"\n  assumes LE: \"l\\<le>u\"\n  shows \"path E (r l) (map r [l..<u]) (r u)\"", "lemma ipath_restrict_eq: \"ipath (E \\<inter> (E\\<^sup>*``{r 0} \\<times> E\\<^sup>*``{r 0})) r \\<longleftrightarrow> ipath E r\"", "lemma ipath_restrict: \"ipath E r \\<Longrightarrow> ipath (E \\<inter> (E\\<^sup>*``{r 0} \\<times> E\\<^sup>*``{r 0})) r\"", "lemma ipathI[intro?]: \"\\<lbrakk>\\<And>i. (r i, r (Suc i)) \\<in> E\\<rbrakk> \\<Longrightarrow> ipath E r\"", "lemma ipathD: \"ipath E r \\<Longrightarrow> (r i, r (Suc i)) \\<in> E\"", "lemma ipath_in_Domain: \"ipath E r \\<Longrightarrow> r i \\<in> Domain E\"", "lemma ipath_in_Range: \"\\<lbrakk>ipath E r; i\\<noteq>0\\<rbrakk> \\<Longrightarrow> r i \\<in> Range E\"", "lemma ipath_suffix: \"ipath E r \\<Longrightarrow> ipath E (suffix i r)\"", "lemma scc_non_empty[simp]: \"\\<not>is_scc E {}\"", "lemma scc_non_empty'[simp]: \"is_scc E U \\<Longrightarrow> U\\<noteq>{}\"", "lemma is_scc_closed: \n  assumes SCC: \"is_scc E U\"\n  assumes MEM: \"x\\<in>U\"\n  assumes P: \"(x,y)\\<in>E\\<^sup>*\" \"(y,x)\\<in>E\\<^sup>*\"\n  shows \"y\\<in>U\"", "lemma is_scc_connected:\n  assumes SCC: \"is_scc E U\"\n  assumes MEM: \"x\\<in>U\" \"y\\<in>U\"\n  shows \"(x,y)\\<in>E\\<^sup>*\"", "lemma mconn_pointwise:\n   \"mconn E = {(u,v). (u,v)\\<in>E\\<^sup>* \\<and> (v,u)\\<in>E\\<^sup>*}\"", "lemma mconn_refl[simp]: \"Id\\<subseteq>mconn E\"", "lemma mconn_sym: \"mconn E = (mconn E)\\<inverse>\"", "lemma mconn_trans: \"mconn E O mconn E = mconn E\"", "lemma mconn_refl': \"refl (mconn E)\"", "lemma mconn_sym': \"sym (mconn E)\"", "lemma mconn_trans': \"trans (mconn E)\"", "lemma mconn_equiv: \"equiv UNIV (mconn E)\"", "lemma is_scc_mconn_eqclasses: \"is_scc E U \\<longleftrightarrow> U \\<in> UNIV // mconn E\"\n  \\<comment> \\<open>The strongly connected components are the equivalence classes of the \n    mutually-connected relation on nodes\\<close>", "lemma \"is_scc E U \\<longleftrightarrow> U \\<in> UNIV // (E\\<^sup>* \\<inter> (E\\<inverse>)\\<^sup>*)\"", "lemma find_outside_node:\n  assumes \"(u,v)\\<in>E\\<^sup>*\"\n  assumes \"(u,v)\\<notin>(E\\<inter>U\\<times>U)\\<^sup>*\"\n  assumes \"u\\<in>U\" \"v\\<in>U\"\n  shows \"\\<exists>u'. u'\\<notin>U \\<and> (u,u')\\<in>E\\<^sup>* \\<and> (u',v)\\<in>E\\<^sup>*\"", "lemma is_scc_restrict1:\n  assumes SCC: \"is_scc E U\"\n  shows \"U\\<times>U\\<subseteq>(E\\<inter>U\\<times>U)\\<^sup>*\"", "lemma is_scc_restrict2:\n  assumes SCC: \"is_scc E U\"\n  assumes \"V\\<supset>U\"\n  shows \"\\<not> (V\\<times>V\\<subseteq>(E\\<inter>V\\<times>V)\\<^sup>*)\"", "lemma is_scc_restrict3: \n  assumes SCC: \"is_scc E U\"\n  shows \"((E\\<^sup>*``((E\\<^sup>*``U) - U)) \\<inter> U = {})\"", "lemma is_scc_alt_restrict_path:\n  \"is_scc E U \\<longleftrightarrow> U\\<noteq>{} \\<and>\n    (U\\<times>U \\<subseteq> (E\\<inter>U\\<times>U)\\<^sup>*) \\<and> ((E\\<^sup>*``((E\\<^sup>*``U) - U)) \\<inter> U = {})\"", "lemma is_scc_pointwise:\n  \"is_scc E U \\<longleftrightarrow> \n    U\\<noteq>{}\n  \\<and> (\\<forall>u\\<in>U. \\<forall>v\\<in>U. (u,v)\\<in>(E\\<inter>U\\<times>U)\\<^sup>*) \n  \\<and> (\\<forall>u\\<in>U. \\<forall>v. (v\\<notin>U \\<and> (u,v)\\<in>E\\<^sup>*) \\<longrightarrow> (\\<forall>u'\\<in>U. (v,u')\\<notin>E\\<^sup>*))\"\n  \\<comment> \\<open>Alternative, pointwise characterization\\<close>", "lemma is_scc_unique:\n  assumes SCC: \"is_scc E scc\" \"is_scc E scc'\"\n  and v: \"v \\<in> scc\" \"v \\<in> scc'\"\n  shows \"scc = scc'\"", "lemma is_scc_ex1:\n  \"\\<exists>!scc. is_scc E scc \\<and> v \\<in> scc\"", "lemma is_scc_ex:\n  \"\\<exists>scc. is_scc E scc \\<and> v \\<in> scc\"", "lemma is_scc_connected':\n  \"\\<lbrakk>is_scc E scc; x \\<in> scc; y \\<in> scc\\<rbrakk> \\<Longrightarrow> (x,y)\\<in>(Restr E scc)\\<^sup>*\"", "lemma scc_of_is_scc[simp]:\n  \"is_scc E (scc_of E v)\"", "lemma node_in_scc_of_node[simp]:\n  \"v \\<in> scc_of E v\"", "lemma scc_of_unique:\n  assumes \"w \\<in> scc_of E v\"\n  shows \"scc_of E v = scc_of E w\""], "translations": [["", "lemma path1: \"(u,v)\\<in>E \\<Longrightarrow> path E u [u] v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> E \\<Longrightarrow> path E u [u] v", "by (auto intro: path.intros)"], ["", "lemma path_empty_conv[simp]:\n  \"path E u [] v \\<longleftrightarrow> u=v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path E u [] v = (u = v)", "by (auto intro: path0 elim: path.cases)"], ["", "inductive_cases path_uncons: \"path E u (u'#l) w\""], ["", "inductive_simps path_cons_conv: \"path E u (u'#l) w\""], ["", "lemma path_no_edges[simp]: \"path {} u p v \\<longleftrightarrow> (u=v \\<and> p=[])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path {} u p v = (u = v \\<and> p = [])", "by (cases p) (auto simp: path_cons_conv)"], ["", "lemma path_conc: \n  assumes P1: \"path E u la v\" \n  assumes P2: \"path E v lb w\"\n  shows \"path E u (la@lb) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path E u (la @ lb) w", "using P1 P2"], ["proof (prove)\nusing this:\n  path E u la v\n  path E v lb w\n\ngoal (1 subgoal):\n 1. path E u (la @ lb) w", "apply induct"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u. path E u lb w \\<Longrightarrow> path E u ([] @ lb) w\n 2. \\<And>u v l wa.\n       \\<lbrakk>(u, v) \\<in> E; path E v l wa;\n        path E wa lb w \\<Longrightarrow> path E v (l @ lb) w;\n        path E wa lb w\\<rbrakk>\n       \\<Longrightarrow> path E u ((u # l) @ lb) w", "by (auto intro: path.intros)"], ["", "lemma path_append:\n  \"\\<lbrakk> path E u l v; (v,w)\\<in>E \\<rbrakk> \\<Longrightarrow> path E u (l@[v]) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path E u l v; (v, w) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> path E u (l @ [v]) w", "using path_conc[OF _ path1]"], ["proof (prove)\nusing this:\n  \\<lbrakk>path ?E ?u ?la ?v; (?v, ?w) \\<in> ?E\\<rbrakk>\n  \\<Longrightarrow> path ?E ?u (?la @ [?v]) ?w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path E u l v; (v, w) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> path E u (l @ [v]) w", "."], ["", "lemma path_unconc:\n  assumes \"path E u (la@lb) w\"\n  obtains v where \"path E u la v\" and \"path E v lb w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>path E u la v; path E v lb w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  path E u (la @ lb) w\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>path E u la v; path E v lb w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thm path.induct"], ["proof (prove)\nusing this:\n  path E u (la @ lb) w\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>path E u la v; path E v lb w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (induct u \"la@lb\" w arbitrary: la lb rule: path.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u la lb.\n       \\<lbrakk>[] = la @ lb;\n        \\<And>v.\n           \\<lbrakk>path E u la v; path E v lb u\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>u v l w la lb.\n       \\<lbrakk>(u, v) \\<in> E; path E v l w;\n        \\<And>la lb.\n           \\<lbrakk>l = la @ lb;\n            \\<And>va.\n               \\<lbrakk>path E v la va; path E va lb w\\<rbrakk>\n               \\<Longrightarrow> thesis\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        u # l = la @ lb;\n        \\<And>v.\n           \\<lbrakk>path E u la v; path E v lb w\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (auto intro: path.intros elim!: list_Cons_eq_append_cases)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma path_conc_conv: \n  \"path E u (la@lb) w \\<longleftrightarrow> (\\<exists>v. path E u la v \\<and> path E v lb w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path E u (la @ lb) w = (\\<exists>v. path E u la v \\<and> path E v lb w)", "by (auto intro: path_conc elim: path_unconc)"], ["", "lemma (in -) path_append_conv: \"path E u (p@[v]) w \\<longleftrightarrow> (path E u p v \\<and> (v,w)\\<in>E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path E u (p @ [v]) w = (path E u p v \\<and> (v, w) \\<in> E)", "by (simp add: path_cons_conv path_conc_conv)"], ["", "lemmas path_simps = path_empty_conv path_cons_conv path_conc_conv"], ["", "lemmas path_trans[trans] = path_prepend path_conc path_append"], ["", "lemma path_from_edges: \"\\<lbrakk>(u,v)\\<in>E; (v,w)\\<in>E\\<rbrakk> \\<Longrightarrow> path E u [u] v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, v) \\<in> E; (v, w) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> path E u [u] v", "by (auto simp: path_simps)"], ["", "lemma path_edge_cases[case_names no_use split]: \n  assumes \"path (insert (u,v) E) w p x\"\n  obtains \n    \"path E w p x\" \n  | p1 p2 where \"path E w p1 u\" \"path (insert (u,v) E) v p2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path E w p x \\<Longrightarrow> thesis;\n     \\<And>p1 p2.\n        \\<lbrakk>path E w p1 u; path (insert (u, v) E) v p2 x\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  path (insert (u, v) E) w p x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path E w p x \\<Longrightarrow> thesis;\n     \\<And>p1 p2.\n        \\<lbrakk>path E w p1 u; path (insert (u, v) E) v p2 x\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply induction"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ua.\n       \\<lbrakk>path E ua [] ua \\<Longrightarrow> thesis;\n        \\<And>p1 p2.\n           \\<lbrakk>path E ua p1 u; path (insert (u, v) E) v p2 ua\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>ua va l w.\n       \\<lbrakk>(ua, va) \\<in> insert (u, v) E;\n        path (insert (u, v) E) va l w;\n        \\<lbrakk>path E va l w \\<Longrightarrow> thesis;\n         \\<And>p1 p2.\n            \\<lbrakk>path E va p1 u; path (insert (u, v) E) v p2 w\\<rbrakk>\n            \\<Longrightarrow> thesis\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        path E ua (ua # l) w \\<Longrightarrow> thesis;\n        \\<And>p1 p2.\n           \\<lbrakk>path E ua p1 u; path (insert (u, v) E) v p2 w\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ua va l w.\n       \\<lbrakk>(ua, va) \\<in> insert (u, v) E;\n        path (insert (u, v) E) va l w;\n        \\<lbrakk>path E va l w \\<Longrightarrow> thesis;\n         \\<And>p1 p2.\n            \\<lbrakk>path E va p1 u; path (insert (u, v) E) v p2 w\\<rbrakk>\n            \\<Longrightarrow> thesis\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        path E ua (ua # l) w \\<Longrightarrow> thesis;\n        \\<And>p1 p2.\n           \\<lbrakk>path E ua p1 u; path (insert (u, v) E) v p2 w\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ua va l w.\n       \\<lbrakk>ua = u \\<and> va = v \\<or> (ua, va) \\<in> E;\n        path (insert (u, v) E) va l w;\n        \\<lbrakk>path E va l w \\<Longrightarrow> thesis;\n         \\<And>p1 p2.\n            \\<lbrakk>path E va p1 u; path (insert (u, v) E) v p2 w\\<rbrakk>\n            \\<Longrightarrow> thesis\\<rbrakk>\n        \\<Longrightarrow> thesis;\n        path E ua (ua # l) w \\<Longrightarrow> thesis;\n        \\<And>p1 p2.\n           \\<lbrakk>path E ua p1 u; path (insert (u, v) E) v p2 w\\<rbrakk>\n           \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (metis path_simps path_cons_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma path_edge_rev_cases[case_names no_use split]: \n  assumes \"path (insert (u,v) E) w p x\"\n  obtains \n    \"path E w p x\" \n  | p1 p2 where \"path (insert (u,v) E) w p1 u\" \"path E v p2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path E w p x \\<Longrightarrow> thesis;\n     \\<And>p1 p2.\n        \\<lbrakk>path (insert (u, v) E) w p1 u; path E v p2 x\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  path (insert (u, v) E) w p x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path E w p x \\<Longrightarrow> thesis;\n     \\<And>p1 p2.\n        \\<lbrakk>path (insert (u, v) E) w p1 u; path E v p2 x\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (induction p arbitrary: x rule: rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>path E w [] x \\<Longrightarrow> thesis;\n        \\<And>p1 p2.\n           \\<lbrakk>path (insert (u, v) E) w p1 u; path E v p2 x\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        path (insert (u, v) E) w [] x\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>x xs xa.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>path E w xs x \\<Longrightarrow> thesis;\n                    \\<And>p1 p2.\n                       \\<lbrakk>path (insert (u, v) E) w p1 u;\n                        path E v p2 x\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n                    path (insert (u, v) E) w xs x\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        path E w (xs @ [x]) xa \\<Longrightarrow> thesis;\n        \\<And>p1 p2.\n           \\<lbrakk>path (insert (u, v) E) w p1 u; path E v p2 xa\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        path (insert (u, v) E) w (xs @ [x]) xa\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs xa.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>path E w xs x \\<Longrightarrow> thesis;\n                    \\<And>p1 p2.\n                       \\<lbrakk>path (insert (u, v) E) w p1 u;\n                        path E v p2 x\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n                    path (insert (u, v) E) w xs x\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        path E w (xs @ [x]) xa \\<Longrightarrow> thesis;\n        \\<And>p1 p2.\n           \\<lbrakk>path (insert (u, v) E) w p1 u; path E v p2 xa\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        path (insert (u, v) E) w (xs @ [x]) xa\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (clarsimp simp: path_cons_conv path_conc_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs xa.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>path E w xs x \\<Longrightarrow> thesis;\n                    \\<And>p1 p2.\n                       \\<lbrakk>path (insert (u, v) E) w p1 u;\n                        path E v p2 x\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n                    path (insert (u, v) E) w xs x\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        path E w xs x \\<and> (x, xa) \\<in> E \\<Longrightarrow> thesis;\n        \\<And>p1 p2.\n           \\<lbrakk>path (insert (u, v) E) w p1 u; path E v p2 xa\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        path (insert (u, v) E) w xs x;\n        x = u \\<and> xa = v \\<or> (x, xa) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (metis path_simps path_append_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma path_mono: \n  assumes S: \"E\\<subseteq>E'\" \n  assumes P: \"path E u p v\" \n  shows \"path E' u p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path E' u p v", "using P"], ["proof (prove)\nusing this:\n  path E u p v\n\ngoal (1 subgoal):\n 1. path E' u p v", "apply induction"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u. path E' u [] u\n 2. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> E; path E v l w; path E' v l w\\<rbrakk>\n       \\<Longrightarrow> path E' u (u # l) w", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> E; path E v l w; path E' v l w\\<rbrakk>\n       \\<Longrightarrow> path E' u (u # l) w", "using S"], ["proof (prove)\nusing this:\n  E \\<subseteq> E'\n\ngoal (1 subgoal):\n 1. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> E; path E v l w; path E' v l w\\<rbrakk>\n       \\<Longrightarrow> path E' u (u # l) w", "apply (auto simp: path_cons_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma path_is_rtrancl: \n  assumes \"path E u l v\"\n  shows \"(u,v)\\<in>E\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> E\\<^sup>*", "using assms"], ["proof (prove)\nusing this:\n  path E u l v\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> E\\<^sup>*", "by induct auto"], ["", "lemma rtrancl_is_path:\n  assumes \"(u,v)\\<in>E\\<^sup>*\"\n  obtains l where \"path E u l v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l. path E u l v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  (u, v) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>l. path E u l v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by induct (auto intro: path0 path_append)"], ["", "lemma path_is_trancl: \n  assumes \"path E u l v\"\n  and \"l\\<noteq>[]\"\n  shows \"(u,v)\\<in>E\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> E\\<^sup>+", "using assms"], ["proof (prove)\nusing this:\n  path E u l v\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> E\\<^sup>+", "apply induct"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u. [] \\<noteq> [] \\<Longrightarrow> (u, u) \\<in> E\\<^sup>+\n 2. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> E; path E v l w;\n        l \\<noteq> [] \\<Longrightarrow> (v, w) \\<in> E\\<^sup>+;\n        u # l \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (u, w) \\<in> E\\<^sup>+", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> E; path E v l w;\n        l \\<noteq> [] \\<Longrightarrow> (v, w) \\<in> E\\<^sup>+;\n        u # l \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (u, w) \\<in> E\\<^sup>+", "apply (case_tac l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> E; path E v l w;\n        l \\<noteq> [] \\<Longrightarrow> (v, w) \\<in> E\\<^sup>+;\n        u # l \\<noteq> []; l = []\\<rbrakk>\n       \\<Longrightarrow> (u, w) \\<in> E\\<^sup>+\n 2. \\<And>u v l w a list.\n       \\<lbrakk>(u, v) \\<in> E; path E v l w;\n        l \\<noteq> [] \\<Longrightarrow> (v, w) \\<in> E\\<^sup>+;\n        u # l \\<noteq> []; l = a # list\\<rbrakk>\n       \\<Longrightarrow> (u, w) \\<in> E\\<^sup>+", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma trancl_is_path:\n  assumes \"(u,v)\\<in>E\\<^sup>+\"\n  obtains l where \"l\\<noteq>[]\" and \"path E u l v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l \\<noteq> []; path E u l v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  (u, v) \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l \\<noteq> []; path E u l v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by induct (auto intro: path0 path_append)"], ["", "lemma path_nth_conv: \"path E u p v \\<longleftrightarrow> (let p'=p@[v] in\n  u=p'!0 \\<and>\n  (\\<forall>i<length p' - 1. (p'!i,p'!Suc i)\\<in>E))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path E u p v =\n    (let p' = p @ [v]\n     in u = p' ! 0 \\<and>\n        (\\<forall>i<length p' - 1. (p' ! i, p' ! Suc i) \\<in> E))", "apply (induct p arbitrary: v rule: rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       path E u [] v =\n       (let p' = [] @ [v]\n        in u = p' ! 0 \\<and>\n           (\\<forall>i<length p' - 1. (p' ! i, p' ! Suc i) \\<in> E))\n 2. \\<And>x xs v.\n       (\\<And>v.\n           path E u xs v =\n           (let p' = xs @ [v]\n            in u = p' ! 0 \\<and>\n               (\\<forall>i<length p' - 1.\n                   (p' ! i, p' ! Suc i) \\<in> E))) \\<Longrightarrow>\n       path E u (xs @ [x]) v =\n       (let p' = (xs @ [x]) @ [v]\n        in u = p' ! 0 \\<and>\n           (\\<forall>i<length p' - 1. (p' ! i, p' ! Suc i) \\<in> E))", "apply (auto simp: path_conc_conv path_cons_conv nth_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma path_mapI:\n  assumes \"path E u p v\"\n  shows \"path (pairself f ` E) (f u) (map f p) (f v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (pairself f ` E) (f u) (map f p) (f v)", "using assms"], ["proof (prove)\nusing this:\n  path E u p v\n\ngoal (1 subgoal):\n 1. path (pairself f ` E) (f u) (map f p) (f v)", "apply induction"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u. path (pairself f ` E) (f u) (map f []) (f u)\n 2. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> E; path E v l w;\n        path (pairself f ` E) (f v) (map f l) (f w)\\<rbrakk>\n       \\<Longrightarrow> path (pairself f ` E) (f u) (map f (u # l)) (f w)", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> E; path E v l w;\n        path (pairself f ` E) (f v) (map f l) (f w)\\<rbrakk>\n       \\<Longrightarrow> path (pairself f ` E) (f u) (map f (u # l)) (f w)", "apply (force simp: path_cons_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma path_restrict: \n  assumes \"path E u p v\" \n  shows \"path (E \\<inter> set p \\<times> insert v (set (tl p))) u p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (E \\<inter> set p \\<times> insert v (set (tl p))) u p v", "using assms"], ["proof (prove)\nusing this:\n  path E u p v\n\ngoal (1 subgoal):\n 1. path (E \\<inter> set p \\<times> insert v (set (tl p))) u p v", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u. path (E \\<inter> set [] \\<times> insert u (set (tl []))) u [] u\n 2. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> E; path E v l w;\n        path (E \\<inter> set l \\<times> insert w (set (tl l))) v l\n         w\\<rbrakk>\n       \\<Longrightarrow> path\n                          (E \\<inter>\n                           set (u # l) \\<times> insert w (set (tl (u # l))))\n                          u (u # l) w", "print_cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u. path (E \\<inter> set [] \\<times> insert u (set (tl []))) u [] u\n 2. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> E; path E v l w;\n        path (E \\<inter> set l \\<times> insert w (set (tl l))) v l\n         w\\<rbrakk>\n       \\<Longrightarrow> path\n                          (E \\<inter>\n                           set (u # l) \\<times> insert w (set (tl (u # l))))\n                          u (u # l) w", "case (path_prepend u v p w)"], ["proof (state)\nthis:\n  (u, v) \\<in> E\n  path E v p w\n  path (E \\<inter> set p \\<times> insert w (set (tl p))) v p w\n\ngoal (2 subgoals):\n 1. \\<And>u. path (E \\<inter> set [] \\<times> insert u (set (tl []))) u [] u\n 2. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> E; path E v l w;\n        path (E \\<inter> set l \\<times> insert w (set (tl l))) v l\n         w\\<rbrakk>\n       \\<Longrightarrow> path\n                          (E \\<inter>\n                           set (u # l) \\<times> insert w (set (tl (u # l))))\n                          u (u # l) w", "from path_prepend.IH"], ["proof (chain)\npicking this:\n  path (E \\<inter> set p \\<times> insert w (set (tl p))) v p w", "have \"path (E \\<inter> set (u#p) \\<times> insert w (set p)) v p w\""], ["proof (prove)\nusing this:\n  path (E \\<inter> set p \\<times> insert w (set (tl p))) v p w\n\ngoal (1 subgoal):\n 1. path (E \\<inter> set (u # p) \\<times> insert w (set p)) v p w", "apply (rule path_mono[rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<inter> set p \\<times> insert w (set (tl p))\n    \\<subseteq> E \\<inter> set (u # p) \\<times> insert w (set p)", "by (cases p) auto"], ["proof (state)\nthis:\n  path (E \\<inter> set (u # p) \\<times> insert w (set p)) v p w\n\ngoal (2 subgoals):\n 1. \\<And>u. path (E \\<inter> set [] \\<times> insert u (set (tl []))) u [] u\n 2. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> E; path E v l w;\n        path (E \\<inter> set l \\<times> insert w (set (tl l))) v l\n         w\\<rbrakk>\n       \\<Longrightarrow> path\n                          (E \\<inter>\n                           set (u # l) \\<times> insert w (set (tl (u # l))))\n                          u (u # l) w", "thus ?case"], ["proof (prove)\nusing this:\n  path (E \\<inter> set (u # p) \\<times> insert w (set p)) v p w\n\ngoal (1 subgoal):\n 1. path (E \\<inter> set (u # p) \\<times> insert w (set (tl (u # p)))) u\n     (u # p) w", "using \\<open>(u,v)\\<in>E\\<close>"], ["proof (prove)\nusing this:\n  path (E \\<inter> set (u # p) \\<times> insert w (set p)) v p w\n  (u, v) \\<in> E\n\ngoal (1 subgoal):\n 1. path (E \\<inter> set (u # p) \\<times> insert w (set (tl (u # p)))) u\n     (u # p) w", "by (cases p) (auto simp add: path_cons_conv)"], ["proof (state)\nthis:\n  path (E \\<inter> set (u # p) \\<times> insert w (set (tl (u # p)))) u\n   (u # p) w\n\ngoal (1 subgoal):\n 1. \\<And>u. path (E \\<inter> set [] \\<times> insert u (set (tl []))) u [] u", "qed auto"], ["", "lemma path_restrict_closed:\n  assumes CLOSED: \"E``D \\<subseteq> D\"\n  assumes I: \"v\\<in>D\" and P: \"path E v p v'\"\n  shows \"path (E\\<inter>D\\<times>D) v p v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (Restr E D) v p v'", "using P CLOSED I"], ["proof (prove)\nusing this:\n  path E v p v'\n  E `` D \\<subseteq> D\n  v \\<in> D\n\ngoal (1 subgoal):\n 1. path (Restr E D) v p v'", "by induction (auto simp: path_cons_conv)"], ["", "lemma path_set_induct:\n  assumes \"path E u p v\" and \"u\\<in>I\" and \"E``I \\<subseteq> I\"\n  shows \"set p \\<subseteq> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set p \\<subseteq> I", "using assms"], ["proof (prove)\nusing this:\n  path E u p v\n  u \\<in> I\n  E `` I \\<subseteq> I\n\ngoal (1 subgoal):\n 1. set p \\<subseteq> I", "by (induction rule: path.induct) auto"], ["", "lemma path_nodes_reachable: \"path E u p v \\<Longrightarrow> insert v (set p) \\<subseteq> E\\<^sup>*``{u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path E u p v \\<Longrightarrow>\n    insert v (set p) \\<subseteq> E\\<^sup>* `` {u}", "apply (auto simp: in_set_conv_decomp path_cons_conv path_conc_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. path E u p v \\<Longrightarrow> (u, v) \\<in> E\\<^sup>*\n 2. \\<And>x ys zs va.\n       \\<lbrakk>p = ys @ x # zs; path E u ys x; (x, va) \\<in> E;\n        path E va zs v\\<rbrakk>\n       \\<Longrightarrow> (u, x) \\<in> E\\<^sup>*", "apply (auto dest!: path_is_rtrancl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma path_nodes_edges: \"path E u p v \\<Longrightarrow> set p \\<subseteq> fst`E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path E u p v \\<Longrightarrow> set p \\<subseteq> fst ` E", "by (induction rule: path.induct) auto"], ["", "lemma path_tl_nodes_edges: \n  assumes \"path E u p v\"\n  shows \"set (tl p) \\<subseteq> fst`E \\<inter> snd`E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (tl p) \\<subseteq> fst ` E \\<inter> snd ` E", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (tl p) \\<subseteq> fst ` E \\<inter> snd ` E", "from path_nodes_edges[OF assms]"], ["proof (chain)\npicking this:\n  set p \\<subseteq> fst ` E", "have \"set (tl p) \\<subseteq> fst`E\""], ["proof (prove)\nusing this:\n  set p \\<subseteq> fst ` E\n\ngoal (1 subgoal):\n 1. set (tl p) \\<subseteq> fst ` E", "by (cases p) auto"], ["proof (state)\nthis:\n  set (tl p) \\<subseteq> fst ` E\n\ngoal (1 subgoal):\n 1. set (tl p) \\<subseteq> fst ` E \\<inter> snd ` E", "moreover"], ["proof (state)\nthis:\n  set (tl p) \\<subseteq> fst ` E\n\ngoal (1 subgoal):\n 1. set (tl p) \\<subseteq> fst ` E \\<inter> snd ` E", "have \"set (tl p) \\<subseteq> snd`E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (tl p) \\<subseteq> snd ` E", "using assms"], ["proof (prove)\nusing this:\n  path E u p v\n\ngoal (1 subgoal):\n 1. set (tl p) \\<subseteq> snd ` E", "apply (cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p = []; v = u\\<rbrakk>\n    \\<Longrightarrow> set (tl p) \\<subseteq> snd ` E\n 2. \\<And>va l.\n       \\<lbrakk>p = u # l; (u, va) \\<in> E; path E va l v\\<rbrakk>\n       \\<Longrightarrow> set (tl p) \\<subseteq> snd ` E", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>va l.\n       \\<lbrakk>p = u # l; (u, va) \\<in> E; path E va l v\\<rbrakk>\n       \\<Longrightarrow> set (tl p) \\<subseteq> snd ` E", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>va l.\n       \\<lbrakk>p = u # l; (u, va) \\<in> E; path E va l v\\<rbrakk>\n       \\<Longrightarrow> set l \\<subseteq> snd ` E", "apply (erule path_set_induct[where I = \"snd`E\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v l.\n       \\<lbrakk>p = u # l; (u, v) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> v \\<in> snd ` E\n 2. \\<And>v l.\n       \\<lbrakk>p = u # l; (u, v) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> E `` snd ` E \\<subseteq> snd ` E", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set (tl p) \\<subseteq> snd ` E\n\ngoal (1 subgoal):\n 1. set (tl p) \\<subseteq> fst ` E \\<inter> snd ` E", "ultimately"], ["proof (chain)\npicking this:\n  set (tl p) \\<subseteq> fst ` E\n  set (tl p) \\<subseteq> snd ` E", "show ?thesis"], ["proof (prove)\nusing this:\n  set (tl p) \\<subseteq> fst ` E\n  set (tl p) \\<subseteq> snd ` E\n\ngoal (1 subgoal):\n 1. set (tl p) \\<subseteq> fst ` E \\<inter> snd ` E", "by auto"], ["proof (state)\nthis:\n  set (tl p) \\<subseteq> fst ` E \\<inter> snd ` E\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_loop_shift: \n  assumes P: \"path E u p u\"\n  assumes S: \"v\\<in>set p\"\n  obtains p' where \"set p' = set p\" \"path E v p' v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>set p' = set p; path E v p' v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>set p' = set p; path E v p' v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from S"], ["proof (chain)\npicking this:\n  v \\<in> set p", "obtain p1 p2 where [simp]: \"p = p1@v#p2\""], ["proof (prove)\nusing this:\n  v \\<in> set p\n\ngoal (1 subgoal):\n 1. (\\<And>p1 p2.\n        p = p1 @ v # p2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_decomp)"], ["proof (state)\nthis:\n  p = p1 @ v # p2\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>set p' = set p; path E v p' v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from P"], ["proof (chain)\npicking this:\n  path E u p u", "obtain v' where A: \"path E u p1 v\" \"(v, v') \\<in> E\" \"path E v' p2 u\""], ["proof (prove)\nusing this:\n  path E u p u\n\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        \\<lbrakk>path E u p1 v; (v, v') \\<in> E; path E v' p2 u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: path_simps)"], ["proof (state)\nthis:\n  path E u p1 v\n  (v, v') \\<in> E\n  path E v' p2 u\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>set p' = set p; path E v p' v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"path E v (v#p2@p1) v\""], ["proof (prove)\nusing this:\n  path E u p1 v\n  (v, v') \\<in> E\n  path E v' p2 u\n\ngoal (1 subgoal):\n 1. path E v (v # p2 @ p1) v", "by (auto simp: path_simps)"], ["proof (state)\nthis:\n  path E v (v # p2 @ p1) v\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>set p' = set p; path E v p' v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  path E v (v # p2 @ p1) v\n\ngoal (1 subgoal):\n 1. thesis", "using that[of \"v#p2@p1\"]"], ["proof (prove)\nusing this:\n  path E v (v # p2 @ p1) v\n  \\<lbrakk>set (v # p2 @ p1) = set p; path E v (v # p2 @ p1) v\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_hd:\n  assumes \"p \\<noteq> []\" \"path E v p w\"\n  shows \"hd p = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd p = v", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  path E v p w\n\ngoal (1 subgoal):\n 1. hd p = v", "by (auto simp: path_cons_conv neq_Nil_conv)"], ["", "lemma path_last_is_edge:\n  assumes \"path E x p y\"\n  and \"p \\<noteq> []\"\n  shows \"(last p, y) \\<in> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (last p, y) \\<in> E", "using assms"], ["proof (prove)\nusing this:\n  path E x p y\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. (last p, y) \\<in> E", "by (auto simp: neq_Nil_rev_conv path_simps)"], ["", "lemma path_member_reach_end:\n  assumes P: \"path E x p y\"\n  and v: \"v \\<in> set p\"\n  shows \"(v,y) \\<in> E\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, y) \\<in> E\\<^sup>+", "using assms"], ["proof (prove)\nusing this:\n  path E x p y\n  v \\<in> set p\n\ngoal (1 subgoal):\n 1. (v, y) \\<in> E\\<^sup>+", "by (auto intro!: path_is_trancl simp: in_set_conv_decomp path_simps)"], ["", "lemma path_tl_induct[consumes 2, case_names single step]:\n  assumes P: \"path E x p y\"\n  and NE: \"x \\<noteq> y\"\n  and S: \"\\<And>u. (x,u) \\<in> E \\<Longrightarrow> P x u\"\n  and ST: \"\\<And>u v. \\<lbrakk>(x,u) \\<in> E\\<^sup>+; (u,v) \\<in> E; P x u\\<rbrakk> \\<Longrightarrow> P x v\"\n  shows \"P x y \\<and> (\\<forall> v \\<in> set (tl p). P x v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x y \\<and> (\\<forall>v\\<in>set (tl p). P x v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P x y \\<and> (\\<forall>v\\<in>set (tl p). P x v)", "from P NE"], ["proof (chain)\npicking this:\n  path E x p y\n  x \\<noteq> y", "have \"p \\<noteq> []\""], ["proof (prove)\nusing this:\n  path E x p y\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. p \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. P x y \\<and> (\\<forall>v\\<in>set (tl p). P x v)", "thus ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. P x y \\<and> (\\<forall>v\\<in>set (tl p). P x v)", "using P"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  path E x p y\n\ngoal (1 subgoal):\n 1. P x y \\<and> (\\<forall>v\\<in>set (tl p). P x v)", "proof (induction p arbitrary: y rule: rev_nonempty_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa y.\n       path E x [xa] y \\<Longrightarrow>\n       P x y \\<and> Ball (set (tl [xa])) (P x)\n 2. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           path E x xs y \\<Longrightarrow>\n           P x y \\<and> Ball (set (tl xs)) (P x);\n        path E x (xs @ [xa]) y\\<rbrakk>\n       \\<Longrightarrow> P x y \\<and> Ball (set (tl (xs @ [xa]))) (P x)", "case (single u)"], ["proof (state)\nthis:\n  path E x [u] y\n\ngoal (2 subgoals):\n 1. \\<And>xa y.\n       path E x [xa] y \\<Longrightarrow>\n       P x y \\<and> Ball (set (tl [xa])) (P x)\n 2. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           path E x xs y \\<Longrightarrow>\n           P x y \\<and> Ball (set (tl xs)) (P x);\n        path E x (xs @ [xa]) y\\<rbrakk>\n       \\<Longrightarrow> P x y \\<and> Ball (set (tl (xs @ [xa]))) (P x)", "hence \"(x,y) \\<in> E\""], ["proof (prove)\nusing this:\n  path E x [u] y\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> E", "by (simp add: path_cons_conv)"], ["proof (state)\nthis:\n  (x, y) \\<in> E\n\ngoal (2 subgoals):\n 1. \\<And>xa y.\n       path E x [xa] y \\<Longrightarrow>\n       P x y \\<and> Ball (set (tl [xa])) (P x)\n 2. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           path E x xs y \\<Longrightarrow>\n           P x y \\<and> Ball (set (tl xs)) (P x);\n        path E x (xs @ [xa]) y\\<rbrakk>\n       \\<Longrightarrow> P x y \\<and> Ball (set (tl (xs @ [xa]))) (P x)", "with S"], ["proof (chain)\npicking this:\n  (x, ?u) \\<in> E \\<Longrightarrow> P x ?u\n  (x, y) \\<in> E", "show ?case"], ["proof (prove)\nusing this:\n  (x, ?u) \\<in> E \\<Longrightarrow> P x ?u\n  (x, y) \\<in> E\n\ngoal (1 subgoal):\n 1. P x y \\<and> (\\<forall>a\\<in>set (tl [u]). P x a)", "by simp"], ["proof (state)\nthis:\n  P x y \\<and> (\\<forall>a\\<in>set (tl [u]). P x a)\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           path E x xs y \\<Longrightarrow>\n           P x y \\<and> Ball (set (tl xs)) (P x);\n        path E x (xs @ [xa]) y\\<rbrakk>\n       \\<Longrightarrow> P x y \\<and> Ball (set (tl (xs @ [xa]))) (P x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           path E x xs y \\<Longrightarrow>\n           P x y \\<and> Ball (set (tl xs)) (P x);\n        path E x (xs @ [xa]) y\\<rbrakk>\n       \\<Longrightarrow> P x y \\<and> Ball (set (tl (xs @ [xa]))) (P x)", "case (snoc u us)"], ["proof (state)\nthis:\n  us \\<noteq> []\n  path E x us ?y \\<Longrightarrow>\n  P x ?y \\<and> (\\<forall>a\\<in>set (tl us). P x a)\n  path E x (us @ [u]) y\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           path E x xs y \\<Longrightarrow>\n           P x y \\<and> Ball (set (tl xs)) (P x);\n        path E x (xs @ [xa]) y\\<rbrakk>\n       \\<Longrightarrow> P x y \\<and> Ball (set (tl (xs @ [xa]))) (P x)", "hence \"path E x us u\""], ["proof (prove)\nusing this:\n  us \\<noteq> []\n  path E x us ?y \\<Longrightarrow>\n  P x ?y \\<and> (\\<forall>a\\<in>set (tl us). P x a)\n  path E x (us @ [u]) y\n\ngoal (1 subgoal):\n 1. path E x us u", "by (simp add: path_append_conv)"], ["proof (state)\nthis:\n  path E x us u\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           path E x xs y \\<Longrightarrow>\n           P x y \\<and> Ball (set (tl xs)) (P x);\n        path E x (xs @ [xa]) y\\<rbrakk>\n       \\<Longrightarrow> P x y \\<and> Ball (set (tl (xs @ [xa]))) (P x)", "with snoc path_is_trancl"], ["proof (chain)\npicking this:\n  us \\<noteq> []\n  path E x us ?y \\<Longrightarrow>\n  P x ?y \\<and> (\\<forall>a\\<in>set (tl us). P x a)\n  path E x (us @ [u]) y\n  \\<lbrakk>path ?E ?u ?l ?v; ?l \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> ?E\\<^sup>+\n  path E x us u", "have \n      \"P x u\" \"(x,u) \\<in> E\\<^sup>+\" \"\\<forall>v \\<in> set (tl us). P x v\""], ["proof (prove)\nusing this:\n  us \\<noteq> []\n  path E x us ?y \\<Longrightarrow>\n  P x ?y \\<and> (\\<forall>a\\<in>set (tl us). P x a)\n  path E x (us @ [u]) y\n  \\<lbrakk>path ?E ?u ?l ?v; ?l \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> ?E\\<^sup>+\n  path E x us u\n\ngoal (1 subgoal):\n 1. P x u &&& (x, u) \\<in> E\\<^sup>+ &&& \\<forall>v\\<in>set (tl us). P x v", "by simp_all"], ["proof (state)\nthis:\n  P x u\n  (x, u) \\<in> E\\<^sup>+\n  \\<forall>v\\<in>set (tl us). P x v\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           path E x xs y \\<Longrightarrow>\n           P x y \\<and> Ball (set (tl xs)) (P x);\n        path E x (xs @ [xa]) y\\<rbrakk>\n       \\<Longrightarrow> P x y \\<and> Ball (set (tl (xs @ [xa]))) (P x)", "moreover"], ["proof (state)\nthis:\n  P x u\n  (x, u) \\<in> E\\<^sup>+\n  \\<forall>v\\<in>set (tl us). P x v\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           path E x xs y \\<Longrightarrow>\n           P x y \\<and> Ball (set (tl xs)) (P x);\n        path E x (xs @ [xa]) y\\<rbrakk>\n       \\<Longrightarrow> P x y \\<and> Ball (set (tl (xs @ [xa]))) (P x)", "with snoc"], ["proof (chain)\npicking this:\n  us \\<noteq> []\n  path E x us ?y \\<Longrightarrow>\n  P x ?y \\<and> (\\<forall>a\\<in>set (tl us). P x a)\n  path E x (us @ [u]) y\n  P x u\n  (x, u) \\<in> E\\<^sup>+\n  \\<forall>v\\<in>set (tl us). P x v", "have \"\\<forall>v \\<in> set (tl (us@[u])). P x v\""], ["proof (prove)\nusing this:\n  us \\<noteq> []\n  path E x us ?y \\<Longrightarrow>\n  P x ?y \\<and> (\\<forall>a\\<in>set (tl us). P x a)\n  path E x (us @ [u]) y\n  P x u\n  (x, u) \\<in> E\\<^sup>+\n  \\<forall>v\\<in>set (tl us). P x v\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set (tl (us @ [u])). P x v", "by simp"], ["proof (state)\nthis:\n  \\<forall>v\\<in>set (tl (us @ [u])). P x v\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           path E x xs y \\<Longrightarrow>\n           P x y \\<and> Ball (set (tl xs)) (P x);\n        path E x (xs @ [xa]) y\\<rbrakk>\n       \\<Longrightarrow> P x y \\<and> Ball (set (tl (xs @ [xa]))) (P x)", "moreover"], ["proof (state)\nthis:\n  \\<forall>v\\<in>set (tl (us @ [u])). P x v\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           path E x xs y \\<Longrightarrow>\n           P x y \\<and> Ball (set (tl xs)) (P x);\n        path E x (xs @ [xa]) y\\<rbrakk>\n       \\<Longrightarrow> P x y \\<and> Ball (set (tl (xs @ [xa]))) (P x)", "from snoc"], ["proof (chain)\npicking this:\n  us \\<noteq> []\n  path E x us ?y \\<Longrightarrow>\n  P x ?y \\<and> (\\<forall>a\\<in>set (tl us). P x a)\n  path E x (us @ [u]) y", "have \"(u,y) \\<in> E\""], ["proof (prove)\nusing this:\n  us \\<noteq> []\n  path E x us ?y \\<Longrightarrow>\n  P x ?y \\<and> (\\<forall>a\\<in>set (tl us). P x a)\n  path E x (us @ [u]) y\n\ngoal (1 subgoal):\n 1. (u, y) \\<in> E", "by (simp add: path_append_conv)"], ["proof (state)\nthis:\n  (u, y) \\<in> E\n\ngoal (1 subgoal):\n 1. \\<And>xa xs y.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>y.\n           path E x xs y \\<Longrightarrow>\n           P x y \\<and> Ball (set (tl xs)) (P x);\n        path E x (xs @ [xa]) y\\<rbrakk>\n       \\<Longrightarrow> P x y \\<and> Ball (set (tl (xs @ [xa]))) (P x)", "ultimately"], ["proof (chain)\npicking this:\n  P x u\n  (x, u) \\<in> E\\<^sup>+\n  \\<forall>v\\<in>set (tl us). P x v\n  \\<forall>v\\<in>set (tl (us @ [u])). P x v\n  (u, y) \\<in> E", "show ?case"], ["proof (prove)\nusing this:\n  P x u\n  (x, u) \\<in> E\\<^sup>+\n  \\<forall>v\\<in>set (tl us). P x v\n  \\<forall>v\\<in>set (tl (us @ [u])). P x v\n  (u, y) \\<in> E\n\ngoal (1 subgoal):\n 1. P x y \\<and> (\\<forall>a\\<in>set (tl (us @ [u])). P x a)", "by (auto intro: ST)"], ["proof (state)\nthis:\n  P x y \\<and> (\\<forall>a\\<in>set (tl (us @ [u])). P x a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P x y \\<and> (\\<forall>v\\<in>set (tl p). P x v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_restrict_tl: \n  \"\\<lbrakk> u\\<notin>R; path (E \\<inter> UNIV \\<times> -R) u p v \\<rbrakk> \\<Longrightarrow> path (rel_restrict E R) u p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<notin> R;\n     path (E \\<inter> UNIV \\<times> - R) u p v\\<rbrakk>\n    \\<Longrightarrow> path (rel_restrict E R) u p v", "apply (induction p arbitrary: u)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>u \\<notin> R;\n        path (E \\<inter> UNIV \\<times> - R) u [] v\\<rbrakk>\n       \\<Longrightarrow> path (rel_restrict E R) u [] v\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>u \\<notin> R;\n                    path (E \\<inter> UNIV \\<times> - R) u p v\\<rbrakk>\n                   \\<Longrightarrow> path (rel_restrict E R) u p v;\n        u \\<notin> R;\n        path (E \\<inter> UNIV \\<times> - R) u (a # p) v\\<rbrakk>\n       \\<Longrightarrow> path (rel_restrict E R) u (a # p) v", "apply (auto simp: path_simps rel_restrict_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma path1_restr_conv: \"path (E\\<inter>UNIV \\<times> -R) u (x#xs) v \n  \\<longleftrightarrow> (\\<exists>w. w\\<notin>R \\<and> x=u \\<and> (u,w)\\<in>E \\<and> path (rel_restrict E R) w xs v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (E \\<inter> UNIV \\<times> - R) u (x # xs) v =\n    (\\<exists>w.\n        w \\<notin> R \\<and>\n        x = u \\<and> (u, w) \\<in> E \\<and> path (rel_restrict E R) w xs v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. path (E \\<inter> UNIV \\<times> - R) u (x # xs) v =\n    (\\<exists>w.\n        w \\<notin> R \\<and>\n        x = u \\<and> (u, w) \\<in> E \\<and> path (rel_restrict E R) w xs v)", "have 1: \"rel_restrict E R \\<subseteq> E \\<inter> UNIV \\<times> - R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_restrict E R \\<subseteq> E \\<inter> UNIV \\<times> - R", "by (auto simp: rel_restrict_def)"], ["proof (state)\nthis:\n  rel_restrict E R \\<subseteq> E \\<inter> UNIV \\<times> - R\n\ngoal (1 subgoal):\n 1. path (E \\<inter> UNIV \\<times> - R) u (x # xs) v =\n    (\\<exists>w.\n        w \\<notin> R \\<and>\n        x = u \\<and> (u, w) \\<in> E \\<and> path (rel_restrict E R) w xs v)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. path (E \\<inter> UNIV \\<times> - R) u (x # xs) v =\n    (\\<exists>w.\n        w \\<notin> R \\<and>\n        x = u \\<and> (u, w) \\<in> E \\<and> path (rel_restrict E R) w xs v)", "by (auto simp: path_simps intro: path_restrict_tl path_mono[OF 1])"], ["proof (state)\nthis:\n  path (E \\<inter> UNIV \\<times> - R) u (x # xs) v =\n  (\\<exists>w.\n      w \\<notin> R \\<and>\n      x = u \\<and> (u, w) \\<in> E \\<and> path (rel_restrict E R) w xs v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dropWhileNot_path:\n  assumes \"p \\<noteq> []\"\n  and \"path E w p x\"\n  and \"v \\<in> set p\"\n  and \"dropWhile ((\\<noteq>) v) p = c\"\n  shows \"path E v c x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path E v c x", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  path E w p x\n  v \\<in> set p\n  dropWhile ((\\<noteq>) v) p = c\n\ngoal (1 subgoal):\n 1. path E v c x", "proof (induction arbitrary: w c rule: list_nonempty_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa w c.\n       \\<lbrakk>path E w [xa] x; v \\<in> set [xa];\n        dropWhile ((\\<noteq>) v) [xa] = c\\<rbrakk>\n       \\<Longrightarrow> path E v c x\n 2. \\<And>xa xs w c.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>w c.\n           \\<lbrakk>path E w xs x; v \\<in> set xs;\n            dropWhile ((\\<noteq>) v) xs = c\\<rbrakk>\n           \\<Longrightarrow> path E v c x;\n        path E w (xa # xs) x; v \\<in> set (xa # xs);\n        dropWhile ((\\<noteq>) v) (xa # xs) = c\\<rbrakk>\n       \\<Longrightarrow> path E v c x", "case (single p)"], ["proof (state)\nthis:\n  path E w [p] x\n  v \\<in> set [p]\n  dropWhile ((\\<noteq>) v) [p] = c\n\ngoal (2 subgoals):\n 1. \\<And>xa w c.\n       \\<lbrakk>path E w [xa] x; v \\<in> set [xa];\n        dropWhile ((\\<noteq>) v) [xa] = c\\<rbrakk>\n       \\<Longrightarrow> path E v c x\n 2. \\<And>xa xs w c.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>w c.\n           \\<lbrakk>path E w xs x; v \\<in> set xs;\n            dropWhile ((\\<noteq>) v) xs = c\\<rbrakk>\n           \\<Longrightarrow> path E v c x;\n        path E w (xa # xs) x; v \\<in> set (xa # xs);\n        dropWhile ((\\<noteq>) v) (xa # xs) = c\\<rbrakk>\n       \\<Longrightarrow> path E v c x", "thus ?case"], ["proof (prove)\nusing this:\n  path E w [p] x\n  v \\<in> set [p]\n  dropWhile ((\\<noteq>) v) [p] = c\n\ngoal (1 subgoal):\n 1. path E v c x", "by (auto simp add: path_simps)"], ["proof (state)\nthis:\n  path E v c x\n\ngoal (1 subgoal):\n 1. \\<And>xa xs w c.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>w c.\n           \\<lbrakk>path E w xs x; v \\<in> set xs;\n            dropWhile ((\\<noteq>) v) xs = c\\<rbrakk>\n           \\<Longrightarrow> path E v c x;\n        path E w (xa # xs) x; v \\<in> set (xa # xs);\n        dropWhile ((\\<noteq>) v) (xa # xs) = c\\<rbrakk>\n       \\<Longrightarrow> path E v c x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs w c.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>w c.\n           \\<lbrakk>path E w xs x; v \\<in> set xs;\n            dropWhile ((\\<noteq>) v) xs = c\\<rbrakk>\n           \\<Longrightarrow> path E v c x;\n        path E w (xa # xs) x; v \\<in> set (xa # xs);\n        dropWhile ((\\<noteq>) v) (xa # xs) = c\\<rbrakk>\n       \\<Longrightarrow> path E v c x", "case (cons p ps)"], ["proof (state)\nthis:\n  ps \\<noteq> []\n  \\<lbrakk>path E ?w ps x; v \\<in> set ps;\n   dropWhile ((\\<noteq>) v) ps = ?c\\<rbrakk>\n  \\<Longrightarrow> path E v ?c x\n  path E w (p # ps) x\n  v \\<in> set (p # ps)\n  dropWhile ((\\<noteq>) v) (p # ps) = c\n\ngoal (1 subgoal):\n 1. \\<And>xa xs w c.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>w c.\n           \\<lbrakk>path E w xs x; v \\<in> set xs;\n            dropWhile ((\\<noteq>) v) xs = c\\<rbrakk>\n           \\<Longrightarrow> path E v c x;\n        path E w (xa # xs) x; v \\<in> set (xa # xs);\n        dropWhile ((\\<noteq>) v) (xa # xs) = c\\<rbrakk>\n       \\<Longrightarrow> path E v c x", "hence [simp]: \"w = p\""], ["proof (prove)\nusing this:\n  ps \\<noteq> []\n  \\<lbrakk>path E ?w ps x; v \\<in> set ps;\n   dropWhile ((\\<noteq>) v) ps = ?c\\<rbrakk>\n  \\<Longrightarrow> path E v ?c x\n  path E w (p # ps) x\n  v \\<in> set (p # ps)\n  dropWhile ((\\<noteq>) v) (p # ps) = c\n\ngoal (1 subgoal):\n 1. w = p", "by (simp add: path_cons_conv)"], ["proof (state)\nthis:\n  w = p\n\ngoal (1 subgoal):\n 1. \\<And>xa xs w c.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>w c.\n           \\<lbrakk>path E w xs x; v \\<in> set xs;\n            dropWhile ((\\<noteq>) v) xs = c\\<rbrakk>\n           \\<Longrightarrow> path E v c x;\n        path E w (xa # xs) x; v \\<in> set (xa # xs);\n        dropWhile ((\\<noteq>) v) (xa # xs) = c\\<rbrakk>\n       \\<Longrightarrow> path E v c x", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. path E v c x", "proof (cases \"p=v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = v \\<Longrightarrow> path E v c x\n 2. p \\<noteq> v \\<Longrightarrow> path E v c x", "case True"], ["proof (state)\nthis:\n  p = v\n\ngoal (2 subgoals):\n 1. p = v \\<Longrightarrow> path E v c x\n 2. p \\<noteq> v \\<Longrightarrow> path E v c x", "with cons"], ["proof (chain)\npicking this:\n  ps \\<noteq> []\n  \\<lbrakk>path E ?w ps x; v \\<in> set ps;\n   dropWhile ((\\<noteq>) v) ps = ?c\\<rbrakk>\n  \\<Longrightarrow> path E v ?c x\n  path E w (p # ps) x\n  v \\<in> set (p # ps)\n  dropWhile ((\\<noteq>) v) (p # ps) = c\n  p = v", "show ?thesis"], ["proof (prove)\nusing this:\n  ps \\<noteq> []\n  \\<lbrakk>path E ?w ps x; v \\<in> set ps;\n   dropWhile ((\\<noteq>) v) ps = ?c\\<rbrakk>\n  \\<Longrightarrow> path E v ?c x\n  path E w (p # ps) x\n  v \\<in> set (p # ps)\n  dropWhile ((\\<noteq>) v) (p # ps) = c\n  p = v\n\ngoal (1 subgoal):\n 1. path E v c x", "by simp"], ["proof (state)\nthis:\n  path E v c x\n\ngoal (1 subgoal):\n 1. p \\<noteq> v \\<Longrightarrow> path E v c x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> v \\<Longrightarrow> path E v c x", "case False"], ["proof (state)\nthis:\n  p \\<noteq> v\n\ngoal (1 subgoal):\n 1. p \\<noteq> v \\<Longrightarrow> path E v c x", "with cons"], ["proof (chain)\npicking this:\n  ps \\<noteq> []\n  \\<lbrakk>path E ?w ps x; v \\<in> set ps;\n   dropWhile ((\\<noteq>) v) ps = ?c\\<rbrakk>\n  \\<Longrightarrow> path E v ?c x\n  path E w (p # ps) x\n  v \\<in> set (p # ps)\n  dropWhile ((\\<noteq>) v) (p # ps) = c\n  p \\<noteq> v", "have \"c = dropWhile ((\\<noteq>) v) ps\""], ["proof (prove)\nusing this:\n  ps \\<noteq> []\n  \\<lbrakk>path E ?w ps x; v \\<in> set ps;\n   dropWhile ((\\<noteq>) v) ps = ?c\\<rbrakk>\n  \\<Longrightarrow> path E v ?c x\n  path E w (p # ps) x\n  v \\<in> set (p # ps)\n  dropWhile ((\\<noteq>) v) (p # ps) = c\n  p \\<noteq> v\n\ngoal (1 subgoal):\n 1. c = dropWhile ((\\<noteq>) v) ps", "by simp"], ["proof (state)\nthis:\n  c = dropWhile ((\\<noteq>) v) ps\n\ngoal (1 subgoal):\n 1. p \\<noteq> v \\<Longrightarrow> path E v c x", "moreover"], ["proof (state)\nthis:\n  c = dropWhile ((\\<noteq>) v) ps\n\ngoal (1 subgoal):\n 1. p \\<noteq> v \\<Longrightarrow> path E v c x", "from cons.prems"], ["proof (chain)\npicking this:\n  path E w (p # ps) x\n  v \\<in> set (p # ps)\n  dropWhile ((\\<noteq>) v) (p # ps) = c", "obtain y where \"path E y ps x\""], ["proof (prove)\nusing this:\n  path E w (p # ps) x\n  v \\<in> set (p # ps)\n  dropWhile ((\\<noteq>) v) (p # ps) = c\n\ngoal (1 subgoal):\n 1. (\\<And>y. path E y ps x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using path_uncons"], ["proof (prove)\nusing this:\n  path E w (p # ps) x\n  v \\<in> set (p # ps)\n  dropWhile ((\\<noteq>) v) (p # ps) = c\n  \\<lbrakk>path ?E ?u (?u' # ?l) ?w;\n   \\<And>v.\n      \\<lbrakk>?u' = ?u; (?u, v) \\<in> ?E; path ?E v ?l ?w\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>y. path E y ps x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  path E y ps x\n\ngoal (1 subgoal):\n 1. p \\<noteq> v \\<Longrightarrow> path E v c x", "moreover"], ["proof (state)\nthis:\n  path E y ps x\n\ngoal (1 subgoal):\n 1. p \\<noteq> v \\<Longrightarrow> path E v c x", "from cons.prems False"], ["proof (chain)\npicking this:\n  path E w (p # ps) x\n  v \\<in> set (p # ps)\n  dropWhile ((\\<noteq>) v) (p # ps) = c\n  p \\<noteq> v", "have \"v \\<in> set ps\""], ["proof (prove)\nusing this:\n  path E w (p # ps) x\n  v \\<in> set (p # ps)\n  dropWhile ((\\<noteq>) v) (p # ps) = c\n  p \\<noteq> v\n\ngoal (1 subgoal):\n 1. v \\<in> set ps", "by simp"], ["proof (state)\nthis:\n  v \\<in> set ps\n\ngoal (1 subgoal):\n 1. p \\<noteq> v \\<Longrightarrow> path E v c x", "ultimately"], ["proof (chain)\npicking this:\n  c = dropWhile ((\\<noteq>) v) ps\n  path E y ps x\n  v \\<in> set ps", "show ?thesis"], ["proof (prove)\nusing this:\n  c = dropWhile ((\\<noteq>) v) ps\n  path E y ps x\n  v \\<in> set ps\n\ngoal (1 subgoal):\n 1. path E v c x", "using cons.IH"], ["proof (prove)\nusing this:\n  c = dropWhile ((\\<noteq>) v) ps\n  path E y ps x\n  v \\<in> set ps\n  \\<lbrakk>path E ?w ps x; v \\<in> set ps;\n   dropWhile ((\\<noteq>) v) ps = ?c\\<rbrakk>\n  \\<Longrightarrow> path E v ?c x\n\ngoal (1 subgoal):\n 1. path E v c x", "by metis"], ["proof (state)\nthis:\n  path E v c x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path E v c x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma takeWhileNot_path:\n  assumes \"p \\<noteq> []\"\n  and \"path E w p x\"\n  and \"v \\<in> set p\"\n  and \"takeWhile ((\\<noteq>) v) p = c\"\n  shows \"path E w c v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path E w c v", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  path E w p x\n  v \\<in> set p\n  takeWhile ((\\<noteq>) v) p = c\n\ngoal (1 subgoal):\n 1. path E w c v", "proof (induction arbitrary: w c rule: list_nonempty_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa w c.\n       \\<lbrakk>path E w [xa] x; v \\<in> set [xa];\n        takeWhile ((\\<noteq>) v) [xa] = c\\<rbrakk>\n       \\<Longrightarrow> path E w c v\n 2. \\<And>xa xs w c.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>w c.\n           \\<lbrakk>path E w xs x; v \\<in> set xs;\n            takeWhile ((\\<noteq>) v) xs = c\\<rbrakk>\n           \\<Longrightarrow> path E w c v;\n        path E w (xa # xs) x; v \\<in> set (xa # xs);\n        takeWhile ((\\<noteq>) v) (xa # xs) = c\\<rbrakk>\n       \\<Longrightarrow> path E w c v", "case (single p)"], ["proof (state)\nthis:\n  path E w [p] x\n  v \\<in> set [p]\n  takeWhile ((\\<noteq>) v) [p] = c\n\ngoal (2 subgoals):\n 1. \\<And>xa w c.\n       \\<lbrakk>path E w [xa] x; v \\<in> set [xa];\n        takeWhile ((\\<noteq>) v) [xa] = c\\<rbrakk>\n       \\<Longrightarrow> path E w c v\n 2. \\<And>xa xs w c.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>w c.\n           \\<lbrakk>path E w xs x; v \\<in> set xs;\n            takeWhile ((\\<noteq>) v) xs = c\\<rbrakk>\n           \\<Longrightarrow> path E w c v;\n        path E w (xa # xs) x; v \\<in> set (xa # xs);\n        takeWhile ((\\<noteq>) v) (xa # xs) = c\\<rbrakk>\n       \\<Longrightarrow> path E w c v", "thus ?case"], ["proof (prove)\nusing this:\n  path E w [p] x\n  v \\<in> set [p]\n  takeWhile ((\\<noteq>) v) [p] = c\n\ngoal (1 subgoal):\n 1. path E w c v", "by (auto simp add: path_simps)"], ["proof (state)\nthis:\n  path E w c v\n\ngoal (1 subgoal):\n 1. \\<And>xa xs w c.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>w c.\n           \\<lbrakk>path E w xs x; v \\<in> set xs;\n            takeWhile ((\\<noteq>) v) xs = c\\<rbrakk>\n           \\<Longrightarrow> path E w c v;\n        path E w (xa # xs) x; v \\<in> set (xa # xs);\n        takeWhile ((\\<noteq>) v) (xa # xs) = c\\<rbrakk>\n       \\<Longrightarrow> path E w c v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs w c.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>w c.\n           \\<lbrakk>path E w xs x; v \\<in> set xs;\n            takeWhile ((\\<noteq>) v) xs = c\\<rbrakk>\n           \\<Longrightarrow> path E w c v;\n        path E w (xa # xs) x; v \\<in> set (xa # xs);\n        takeWhile ((\\<noteq>) v) (xa # xs) = c\\<rbrakk>\n       \\<Longrightarrow> path E w c v", "case (cons p ps)"], ["proof (state)\nthis:\n  ps \\<noteq> []\n  \\<lbrakk>path E ?w ps x; v \\<in> set ps;\n   takeWhile ((\\<noteq>) v) ps = ?c\\<rbrakk>\n  \\<Longrightarrow> path E ?w ?c v\n  path E w (p # ps) x\n  v \\<in> set (p # ps)\n  takeWhile ((\\<noteq>) v) (p # ps) = c\n\ngoal (1 subgoal):\n 1. \\<And>xa xs w c.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>w c.\n           \\<lbrakk>path E w xs x; v \\<in> set xs;\n            takeWhile ((\\<noteq>) v) xs = c\\<rbrakk>\n           \\<Longrightarrow> path E w c v;\n        path E w (xa # xs) x; v \\<in> set (xa # xs);\n        takeWhile ((\\<noteq>) v) (xa # xs) = c\\<rbrakk>\n       \\<Longrightarrow> path E w c v", "hence [simp]: \"w = p\""], ["proof (prove)\nusing this:\n  ps \\<noteq> []\n  \\<lbrakk>path E ?w ps x; v \\<in> set ps;\n   takeWhile ((\\<noteq>) v) ps = ?c\\<rbrakk>\n  \\<Longrightarrow> path E ?w ?c v\n  path E w (p # ps) x\n  v \\<in> set (p # ps)\n  takeWhile ((\\<noteq>) v) (p # ps) = c\n\ngoal (1 subgoal):\n 1. w = p", "by (simp add: path_cons_conv)"], ["proof (state)\nthis:\n  w = p\n\ngoal (1 subgoal):\n 1. \\<And>xa xs w c.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>w c.\n           \\<lbrakk>path E w xs x; v \\<in> set xs;\n            takeWhile ((\\<noteq>) v) xs = c\\<rbrakk>\n           \\<Longrightarrow> path E w c v;\n        path E w (xa # xs) x; v \\<in> set (xa # xs);\n        takeWhile ((\\<noteq>) v) (xa # xs) = c\\<rbrakk>\n       \\<Longrightarrow> path E w c v", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. path E w c v", "proof (cases \"p=v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = v \\<Longrightarrow> path E w c v\n 2. p \\<noteq> v \\<Longrightarrow> path E w c v", "case True"], ["proof (state)\nthis:\n  p = v\n\ngoal (2 subgoals):\n 1. p = v \\<Longrightarrow> path E w c v\n 2. p \\<noteq> v \\<Longrightarrow> path E w c v", "with cons"], ["proof (chain)\npicking this:\n  ps \\<noteq> []\n  \\<lbrakk>path E ?w ps x; v \\<in> set ps;\n   takeWhile ((\\<noteq>) v) ps = ?c\\<rbrakk>\n  \\<Longrightarrow> path E ?w ?c v\n  path E w (p # ps) x\n  v \\<in> set (p # ps)\n  takeWhile ((\\<noteq>) v) (p # ps) = c\n  p = v", "show ?thesis"], ["proof (prove)\nusing this:\n  ps \\<noteq> []\n  \\<lbrakk>path E ?w ps x; v \\<in> set ps;\n   takeWhile ((\\<noteq>) v) ps = ?c\\<rbrakk>\n  \\<Longrightarrow> path E ?w ?c v\n  path E w (p # ps) x\n  v \\<in> set (p # ps)\n  takeWhile ((\\<noteq>) v) (p # ps) = c\n  p = v\n\ngoal (1 subgoal):\n 1. path E w c v", "by simp"], ["proof (state)\nthis:\n  path E w c v\n\ngoal (1 subgoal):\n 1. p \\<noteq> v \\<Longrightarrow> path E w c v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> v \\<Longrightarrow> path E w c v", "case False"], ["proof (state)\nthis:\n  p \\<noteq> v\n\ngoal (1 subgoal):\n 1. p \\<noteq> v \\<Longrightarrow> path E w c v", "with cons"], ["proof (chain)\npicking this:\n  ps \\<noteq> []\n  \\<lbrakk>path E ?w ps x; v \\<in> set ps;\n   takeWhile ((\\<noteq>) v) ps = ?c\\<rbrakk>\n  \\<Longrightarrow> path E ?w ?c v\n  path E w (p # ps) x\n  v \\<in> set (p # ps)\n  takeWhile ((\\<noteq>) v) (p # ps) = c\n  p \\<noteq> v", "obtain c' where \n      \"c' = takeWhile ((\\<noteq>) v) ps\" and \n      [simp]: \"c = p#c'\""], ["proof (prove)\nusing this:\n  ps \\<noteq> []\n  \\<lbrakk>path E ?w ps x; v \\<in> set ps;\n   takeWhile ((\\<noteq>) v) ps = ?c\\<rbrakk>\n  \\<Longrightarrow> path E ?w ?c v\n  path E w (p # ps) x\n  v \\<in> set (p # ps)\n  takeWhile ((\\<noteq>) v) (p # ps) = c\n  p \\<noteq> v\n\ngoal (1 subgoal):\n 1. (\\<And>c'.\n        \\<lbrakk>c' = takeWhile ((\\<noteq>) v) ps; c = p # c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp_all"], ["proof (state)\nthis:\n  c' = takeWhile ((\\<noteq>) v) ps\n  c = p # c'\n\ngoal (1 subgoal):\n 1. p \\<noteq> v \\<Longrightarrow> path E w c v", "moreover"], ["proof (state)\nthis:\n  c' = takeWhile ((\\<noteq>) v) ps\n  c = p # c'\n\ngoal (1 subgoal):\n 1. p \\<noteq> v \\<Longrightarrow> path E w c v", "from cons.prems"], ["proof (chain)\npicking this:\n  path E w (p # ps) x\n  v \\<in> set (p # ps)\n  takeWhile ((\\<noteq>) v) (p # ps) = c", "obtain y where \n      \"path E y ps x\" and \"(w,y) \\<in> E\""], ["proof (prove)\nusing this:\n  path E w (p # ps) x\n  v \\<in> set (p # ps)\n  takeWhile ((\\<noteq>) v) (p # ps) = c\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>path E y ps x; (w, y) \\<in> E\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using path_uncons"], ["proof (prove)\nusing this:\n  path E w (p # ps) x\n  v \\<in> set (p # ps)\n  takeWhile ((\\<noteq>) v) (p # ps) = c\n  \\<lbrakk>path ?E ?u (?u' # ?l) ?w;\n   \\<And>v.\n      \\<lbrakk>?u' = ?u; (?u, v) \\<in> ?E; path ?E v ?l ?w\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>path E y ps x; (w, y) \\<in> E\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis+"], ["proof (state)\nthis:\n  path E y ps x\n  (w, y) \\<in> E\n\ngoal (1 subgoal):\n 1. p \\<noteq> v \\<Longrightarrow> path E w c v", "moreover"], ["proof (state)\nthis:\n  path E y ps x\n  (w, y) \\<in> E\n\ngoal (1 subgoal):\n 1. p \\<noteq> v \\<Longrightarrow> path E w c v", "from cons.prems False"], ["proof (chain)\npicking this:\n  path E w (p # ps) x\n  v \\<in> set (p # ps)\n  takeWhile ((\\<noteq>) v) (p # ps) = c\n  p \\<noteq> v", "have \"v \\<in> set ps\""], ["proof (prove)\nusing this:\n  path E w (p # ps) x\n  v \\<in> set (p # ps)\n  takeWhile ((\\<noteq>) v) (p # ps) = c\n  p \\<noteq> v\n\ngoal (1 subgoal):\n 1. v \\<in> set ps", "by simp"], ["proof (state)\nthis:\n  v \\<in> set ps\n\ngoal (1 subgoal):\n 1. p \\<noteq> v \\<Longrightarrow> path E w c v", "ultimately"], ["proof (chain)\npicking this:\n  c' = takeWhile ((\\<noteq>) v) ps\n  c = p # c'\n  path E y ps x\n  (w, y) \\<in> E\n  v \\<in> set ps", "have \"path E y c' v\""], ["proof (prove)\nusing this:\n  c' = takeWhile ((\\<noteq>) v) ps\n  c = p # c'\n  path E y ps x\n  (w, y) \\<in> E\n  v \\<in> set ps\n\ngoal (1 subgoal):\n 1. path E y c' v", "using cons.IH"], ["proof (prove)\nusing this:\n  c' = takeWhile ((\\<noteq>) v) ps\n  c = p # c'\n  path E y ps x\n  (w, y) \\<in> E\n  v \\<in> set ps\n  \\<lbrakk>path E ?w ps x; v \\<in> set ps;\n   takeWhile ((\\<noteq>) v) ps = ?c\\<rbrakk>\n  \\<Longrightarrow> path E ?w ?c v\n\ngoal (1 subgoal):\n 1. path E y c' v", "by metis"], ["proof (state)\nthis:\n  path E y c' v\n\ngoal (1 subgoal):\n 1. p \\<noteq> v \\<Longrightarrow> path E w c v", "with \\<open>(w,y) \\<in> E\\<close>"], ["proof (chain)\npicking this:\n  (w, y) \\<in> E\n  path E y c' v", "show ?thesis"], ["proof (prove)\nusing this:\n  (w, y) \\<in> E\n  path E y c' v\n\ngoal (1 subgoal):\n 1. path E w c v", "by (auto simp add: path_cons_conv)"], ["proof (state)\nthis:\n  path E w c v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path E w c v\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Infinite Paths\\<close>"], ["", "definition ipath :: \"'q digraph \\<Rightarrow> 'q word \\<Rightarrow> bool\"\n  \\<comment> \\<open>Predicate for an infinite path in a digraph\\<close>\n  where \"ipath E r \\<equiv> \\<forall>i. (r i, r (Suc i))\\<in>E\""], ["", "lemma ipath_conc_conv: \n  \"ipath E (u \\<frown> v) \\<longleftrightarrow> (\\<exists>a. path E a u (v 0) \\<and> ipath E v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipath E (u \\<frown> v) = (\\<exists>a. path E a u (v 0) \\<and> ipath E v)", "apply (auto simp: conc_def ipath_def path_nth_conv nth_append)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<forall>i.\n          (i < length u \\<longrightarrow>\n           (Suc i < length u \\<longrightarrow>\n            (u ! i, u ! Suc i) \\<in> E) \\<and>\n           (\\<not> Suc i < length u \\<longrightarrow>\n            (u ! i, v 0) \\<in> E)) \\<and>\n          (\\<not> i < length u \\<longrightarrow>\n           (v (i - length u), v (Suc i - length u))\n           \\<in> E) \\<Longrightarrow>\n       (v i, v (Suc i)) \\<in> E\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   (Suc i < length u \\<longrightarrow>\n                    (u ! i, u ! Suc i) \\<in> E) \\<and>\n                   (\\<not> Suc i < length u \\<longrightarrow>\n                    i < length u \\<longrightarrow> (u ! i, v 0) \\<in> E);\n        \\<forall>i. (v i, v (Suc i)) \\<in> E; \\<not> i < length u\\<rbrakk>\n       \\<Longrightarrow> (v (i - length u), v (Suc i - length u)) \\<in> E", "apply (metis add_Suc_right diff_add_inverse not_add_less1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   (Suc i < length u \\<longrightarrow>\n                    (u ! i, u ! Suc i) \\<in> E) \\<and>\n                   (\\<not> Suc i < length u \\<longrightarrow>\n                    i < length u \\<longrightarrow> (u ! i, v 0) \\<in> E);\n        \\<forall>i. (v i, v (Suc i)) \\<in> E; \\<not> i < length u\\<rbrakk>\n       \\<Longrightarrow> (v (i - length u), v (Suc i - length u)) \\<in> E", "by (metis Suc_diff_Suc diff_Suc_Suc not_less_eq)"], ["", "lemma ipath_iter_conv:\n  assumes \"p\\<noteq>[]\"\n  shows \"ipath E (p\\<^sup>\\<omega>) \\<longleftrightarrow> (path E (hd p) p (hd p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipath E p\\<^sup>\\<omega> = path E (hd p) p (hd p)", "proof (cases p)"], ["proof (state)\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    ipath E p\\<^sup>\\<omega> = path E (hd p) p (hd p)\n 2. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       ipath E p\\<^sup>\\<omega> = path E (hd p) p (hd p)", "case Nil"], ["proof (state)\nthis:\n  p = []\n\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    ipath E p\\<^sup>\\<omega> = path E (hd p) p (hd p)\n 2. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       ipath E p\\<^sup>\\<omega> = path E (hd p) p (hd p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = []\n\ngoal (1 subgoal):\n 1. ipath E p\\<^sup>\\<omega> = path E (hd p) p (hd p)", "using assms"], ["proof (prove)\nusing this:\n  p = []\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. ipath E p\\<^sup>\\<omega> = path E (hd p) p (hd p)", "by simp"], ["proof (state)\nthis:\n  ipath E p\\<^sup>\\<omega> = path E (hd p) p (hd p)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       ipath E p\\<^sup>\\<omega> = path E (hd p) p (hd p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       ipath E p\\<^sup>\\<omega> = path E (hd p) p (hd p)", "case (Cons u p')"], ["proof (state)\nthis:\n  p = u # p'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       ipath E p\\<^sup>\\<omega> = path E (hd p) p (hd p)", "hence PLEN: \"length p > 0\""], ["proof (prove)\nusing this:\n  p = u # p'\n\ngoal (1 subgoal):\n 1. 0 < length p", "by simp"], ["proof (state)\nthis:\n  0 < length p\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       ipath E p\\<^sup>\\<omega> = path E (hd p) p (hd p)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipath E p\\<^sup>\\<omega> = path E (hd p) p (hd p)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ipath E p\\<^sup>\\<omega> \\<Longrightarrow> path E (hd p) p (hd p)\n 2. path E (hd p) p (hd p) \\<Longrightarrow> ipath E p\\<^sup>\\<omega>", "assume \"ipath E (iter (p))\""], ["proof (state)\nthis:\n  ipath E p\\<^sup>\\<omega>\n\ngoal (2 subgoals):\n 1. ipath E p\\<^sup>\\<omega> \\<Longrightarrow> path E (hd p) p (hd p)\n 2. path E (hd p) p (hd p) \\<Longrightarrow> ipath E p\\<^sup>\\<omega>", "hence \"\\<forall>i. (iter (p) i, iter (p) (Suc i)) \\<in> E\""], ["proof (prove)\nusing this:\n  ipath E p\\<^sup>\\<omega>\n\ngoal (1 subgoal):\n 1. \\<forall>i. (p\\<^sup>\\<omega> i, p\\<^sup>\\<omega> (Suc i)) \\<in> E", "unfolding ipath_def"], ["proof (prove)\nusing this:\n  \\<forall>i. (p\\<^sup>\\<omega> i, p\\<^sup>\\<omega> (Suc i)) \\<in> E\n\ngoal (1 subgoal):\n 1. \\<forall>i. (p\\<^sup>\\<omega> i, p\\<^sup>\\<omega> (Suc i)) \\<in> E", "by simp"], ["proof (state)\nthis:\n  \\<forall>i. (p\\<^sup>\\<omega> i, p\\<^sup>\\<omega> (Suc i)) \\<in> E\n\ngoal (2 subgoals):\n 1. ipath E p\\<^sup>\\<omega> \\<Longrightarrow> path E (hd p) p (hd p)\n 2. path E (hd p) p (hd p) \\<Longrightarrow> ipath E p\\<^sup>\\<omega>", "hence \"(\\<forall>i<length p. (p!i,(p@[hd p])!Suc i)\\<in>E)\""], ["proof (prove)\nusing this:\n  \\<forall>i. (p\\<^sup>\\<omega> i, p\\<^sup>\\<omega> (Suc i)) \\<in> E\n\ngoal (1 subgoal):\n 1. \\<forall>i<length p. (p ! i, (p @ [hd p]) ! Suc i) \\<in> E", "apply (simp add: assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (p ! (i mod length p), p ! (Suc i mod length p))\n       \\<in> E \\<Longrightarrow>\n    \\<forall>i<length p. (p ! i, (p @ [hd p]) ! Suc i) \\<in> E", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   (p ! (i mod length p), p ! (Suc i mod length p)) \\<in> E;\n        i < length p\\<rbrakk>\n       \\<Longrightarrow> (p ! i, (p @ [hd p]) ! Suc i) \\<in> E", "apply (drule_tac x=i in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length p;\n        (p ! (i mod length p), p ! (Suc i mod length p)) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> (p ! i, (p @ [hd p]) ! Suc i) \\<in> E", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length p;\n        (p ! i, p ! (Suc i mod length p)) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> (p ! i, (p @ [hd p]) ! Suc i) \\<in> E", "apply (case_tac \"Suc i = length p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i < length p; (p ! i, p ! (Suc i mod length p)) \\<in> E;\n        Suc i = length p\\<rbrakk>\n       \\<Longrightarrow> (p ! i, (p @ [hd p]) ! Suc i) \\<in> E\n 2. \\<And>i.\n       \\<lbrakk>i < length p; (p ! i, p ! (Suc i mod length p)) \\<in> E;\n        Suc i \\<noteq> length p\\<rbrakk>\n       \\<Longrightarrow> (p ! i, (p @ [hd p]) ! Suc i) \\<in> E", "apply (simp add: Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length p; (p ! i, p ! (Suc i mod length p)) \\<in> E;\n        Suc i \\<noteq> length p\\<rbrakk>\n       \\<Longrightarrow> (p ! i, (p @ [hd p]) ! Suc i) \\<in> E", "apply (simp add: nth_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>i<length p. (p ! i, (p @ [hd p]) ! Suc i) \\<in> E\n\ngoal (2 subgoals):\n 1. ipath E p\\<^sup>\\<omega> \\<Longrightarrow> path E (hd p) p (hd p)\n 2. path E (hd p) p (hd p) \\<Longrightarrow> ipath E p\\<^sup>\\<omega>", "thus \"path E (hd p) p (hd p)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length p. (p ! i, (p @ [hd p]) ! Suc i) \\<in> E\n\ngoal (1 subgoal):\n 1. path E (hd p) p (hd p)", "by (auto simp: path_nth_conv Cons nth_append nth_Cons')"], ["proof (state)\nthis:\n  path E (hd p) p (hd p)\n\ngoal (1 subgoal):\n 1. path E (hd p) p (hd p) \\<Longrightarrow> ipath E p\\<^sup>\\<omega>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. path E (hd p) p (hd p) \\<Longrightarrow> ipath E p\\<^sup>\\<omega>", "assume \"path E (hd p) p (hd p)\""], ["proof (state)\nthis:\n  path E (hd p) p (hd p)\n\ngoal (1 subgoal):\n 1. path E (hd p) p (hd p) \\<Longrightarrow> ipath E p\\<^sup>\\<omega>", "thus \"ipath E (iter p)\""], ["proof (prove)\nusing this:\n  path E (hd p) p (hd p)\n\ngoal (1 subgoal):\n 1. ipath E p\\<^sup>\\<omega>", "apply (auto simp: path_nth_conv ipath_def assms Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>hd p = p ! 0;\n        \\<forall>i<length p. (p ! i, (p @ [p ! 0]) ! Suc i) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> (p ! (i mod length p), p ! (Suc i mod length p))\n                         \\<in> E", "apply (drule_tac x=\"i mod length p\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>hd p = p ! 0;\n        i mod length p < length p \\<longrightarrow>\n        (p ! (i mod length p), (p @ [p ! 0]) ! Suc (i mod length p))\n        \\<in> E\\<rbrakk>\n       \\<Longrightarrow> (p ! (i mod length p), p ! (Suc i mod length p))\n                         \\<in> E", "apply (auto simp: nth_append assms split: if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>hd p = p ! 0; Suc (i mod length p) < length p;\n        (p ! (i mod length p), p ! Suc (i mod length p)) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> (p ! (i mod length p), p ! (Suc i mod length p))\n                         \\<in> E\n 2. \\<And>i.\n       \\<lbrakk>hd p = p ! 0; \\<not> Suc (i mod length p) < length p;\n        (p ! (i mod length p), [p ! 0] ! (Suc (i mod length p) - length p))\n        \\<in> E\\<rbrakk>\n       \\<Longrightarrow> (p ! (i mod length p), p ! (Suc i mod length p))\n                         \\<in> E", "apply (metis less_not_refl mod_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>hd p = p ! 0; \\<not> Suc (i mod length p) < length p;\n        (p ! (i mod length p), [p ! 0] ! (Suc (i mod length p) - length p))\n        \\<in> E\\<rbrakk>\n       \\<Longrightarrow> (p ! (i mod length p), p ! (Suc i mod length p))\n                         \\<in> E", "by (metis PLEN diff_self_eq_0 mod_Suc nth_Cons_0 mod_less_divisor)"], ["proof (state)\nthis:\n  ipath E p\\<^sup>\\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipath E p\\<^sup>\\<omega> = path E (hd p) p (hd p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipath_to_rtrancl:\n  assumes R: \"ipath E r\"\n  assumes I: \"i1\\<le>i2\"\n  shows \"(r i1,r i2)\\<in>E\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r i1, r i2) \\<in> E\\<^sup>*", "using I"], ["proof (prove)\nusing this:\n  i1 \\<le> i2\n\ngoal (1 subgoal):\n 1. (r i1, r i2) \\<in> E\\<^sup>*", "proof (induction i2)"], ["proof (state)\ngoal (2 subgoals):\n 1. i1 \\<le> 0 \\<Longrightarrow> (r i1, r 0) \\<in> E\\<^sup>*\n 2. \\<And>i2.\n       \\<lbrakk>i1 \\<le> i2 \\<Longrightarrow> (r i1, r i2) \\<in> E\\<^sup>*;\n        i1 \\<le> Suc i2\\<rbrakk>\n       \\<Longrightarrow> (r i1, r (Suc i2)) \\<in> E\\<^sup>*", "case (Suc i2)"], ["proof (state)\nthis:\n  i1 \\<le> i2 \\<Longrightarrow> (r i1, r i2) \\<in> E\\<^sup>*\n  i1 \\<le> Suc i2\n\ngoal (2 subgoals):\n 1. i1 \\<le> 0 \\<Longrightarrow> (r i1, r 0) \\<in> E\\<^sup>*\n 2. \\<And>i2.\n       \\<lbrakk>i1 \\<le> i2 \\<Longrightarrow> (r i1, r i2) \\<in> E\\<^sup>*;\n        i1 \\<le> Suc i2\\<rbrakk>\n       \\<Longrightarrow> (r i1, r (Suc i2)) \\<in> E\\<^sup>*", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (r i1, r (Suc i2)) \\<in> E\\<^sup>*", "proof (cases \"i1=Suc i2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i1 = Suc i2 \\<Longrightarrow> (r i1, r (Suc i2)) \\<in> E\\<^sup>*\n 2. i1 \\<noteq> Suc i2 \\<Longrightarrow> (r i1, r (Suc i2)) \\<in> E\\<^sup>*", "assume \"i1\\<noteq>Suc i2\""], ["proof (state)\nthis:\n  i1 \\<noteq> Suc i2\n\ngoal (2 subgoals):\n 1. i1 = Suc i2 \\<Longrightarrow> (r i1, r (Suc i2)) \\<in> E\\<^sup>*\n 2. i1 \\<noteq> Suc i2 \\<Longrightarrow> (r i1, r (Suc i2)) \\<in> E\\<^sup>*", "with Suc"], ["proof (chain)\npicking this:\n  i1 \\<le> i2 \\<Longrightarrow> (r i1, r i2) \\<in> E\\<^sup>*\n  i1 \\<le> Suc i2\n  i1 \\<noteq> Suc i2", "have \"(r i1,r i2)\\<in>E\\<^sup>*\""], ["proof (prove)\nusing this:\n  i1 \\<le> i2 \\<Longrightarrow> (r i1, r i2) \\<in> E\\<^sup>*\n  i1 \\<le> Suc i2\n  i1 \\<noteq> Suc i2\n\ngoal (1 subgoal):\n 1. (r i1, r i2) \\<in> E\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (r i1, r i2) \\<in> E\\<^sup>*\n\ngoal (2 subgoals):\n 1. i1 = Suc i2 \\<Longrightarrow> (r i1, r (Suc i2)) \\<in> E\\<^sup>*\n 2. i1 \\<noteq> Suc i2 \\<Longrightarrow> (r i1, r (Suc i2)) \\<in> E\\<^sup>*", "also"], ["proof (state)\nthis:\n  (r i1, r i2) \\<in> E\\<^sup>*\n\ngoal (2 subgoals):\n 1. i1 = Suc i2 \\<Longrightarrow> (r i1, r (Suc i2)) \\<in> E\\<^sup>*\n 2. i1 \\<noteq> Suc i2 \\<Longrightarrow> (r i1, r (Suc i2)) \\<in> E\\<^sup>*", "from R"], ["proof (chain)\npicking this:\n  ipath E r", "have \"(r i2,r (Suc i2))\\<in>E\""], ["proof (prove)\nusing this:\n  ipath E r\n\ngoal (1 subgoal):\n 1. (r i2, r (Suc i2)) \\<in> E", "unfolding ipath_def"], ["proof (prove)\nusing this:\n  \\<forall>i. (r i, r (Suc i)) \\<in> E\n\ngoal (1 subgoal):\n 1. (r i2, r (Suc i2)) \\<in> E", "by auto"], ["proof (state)\nthis:\n  (r i2, r (Suc i2)) \\<in> E\n\ngoal (2 subgoals):\n 1. i1 = Suc i2 \\<Longrightarrow> (r i1, r (Suc i2)) \\<in> E\\<^sup>*\n 2. i1 \\<noteq> Suc i2 \\<Longrightarrow> (r i1, r (Suc i2)) \\<in> E\\<^sup>*", "finally"], ["proof (chain)\npicking this:\n  (r i1, r (Suc i2)) \\<in> E\\<^sup>*", "show ?thesis"], ["proof (prove)\nusing this:\n  (r i1, r (Suc i2)) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. (r i1, r (Suc i2)) \\<in> E\\<^sup>*", "."], ["proof (state)\nthis:\n  (r i1, r (Suc i2)) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. i1 = Suc i2 \\<Longrightarrow> (r i1, r (Suc i2)) \\<in> E\\<^sup>*", "qed simp"], ["proof (state)\nthis:\n  (r i1, r (Suc i2)) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. i1 \\<le> 0 \\<Longrightarrow> (r i1, r 0) \\<in> E\\<^sup>*", "qed simp"], ["", "lemma ipath_to_trancl:\n  assumes R: \"ipath E r\"\n  assumes I: \"i1<i2\"\n  shows \"(r i1,r i2)\\<in>E\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r i1, r i2) \\<in> E\\<^sup>+", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (r i1, r i2) \\<in> E\\<^sup>+", "from R"], ["proof (chain)\npicking this:\n  ipath E r", "have \"(r i1,r (Suc i1))\\<in>E\""], ["proof (prove)\nusing this:\n  ipath E r\n\ngoal (1 subgoal):\n 1. (r i1, r (Suc i1)) \\<in> E", "by (auto simp: ipath_def)"], ["proof (state)\nthis:\n  (r i1, r (Suc i1)) \\<in> E\n\ngoal (1 subgoal):\n 1. (r i1, r i2) \\<in> E\\<^sup>+", "also"], ["proof (state)\nthis:\n  (r i1, r (Suc i1)) \\<in> E\n\ngoal (1 subgoal):\n 1. (r i1, r i2) \\<in> E\\<^sup>+", "have \"(r (Suc i1),r i2)\\<in>E\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r (Suc i1), r i2) \\<in> E\\<^sup>*", "using ipath_to_rtrancl[OF R,of \"Suc i1\" i2] I"], ["proof (prove)\nusing this:\n  Suc i1 \\<le> i2 \\<Longrightarrow> (r (Suc i1), r i2) \\<in> E\\<^sup>*\n  i1 < i2\n\ngoal (1 subgoal):\n 1. (r (Suc i1), r i2) \\<in> E\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (r (Suc i1), r i2) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. (r i1, r i2) \\<in> E\\<^sup>+", "finally (rtrancl_into_trancl2)"], ["proof (chain)\npicking this:\n  (r i1, r i2) \\<in> E\\<^sup>+", "show ?thesis"], ["proof (prove)\nusing this:\n  (r i1, r i2) \\<in> E\\<^sup>+\n\ngoal (1 subgoal):\n 1. (r i1, r i2) \\<in> E\\<^sup>+", "."], ["proof (state)\nthis:\n  (r i1, r i2) \\<in> E\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma run_limit_two_connectedI:\n  assumes A: \"ipath E r\" \n  assumes B: \"a \\<in> limit r\" \"b\\<in>limit r\"\n  shows \"(a,b)\\<in>E\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> E\\<^sup>+", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (a, b) \\<in> E\\<^sup>+", "from B"], ["proof (chain)\npicking this:\n  a \\<in> limit r\n  b \\<in> limit r", "have \"{a,b} \\<subseteq> limit r\""], ["proof (prove)\nusing this:\n  a \\<in> limit r\n  b \\<in> limit r\n\ngoal (1 subgoal):\n 1. {a, b} \\<subseteq> limit r", "by simp"], ["proof (state)\nthis:\n  {a, b} \\<subseteq> limit r\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> E\\<^sup>+", "with A"], ["proof (chain)\npicking this:\n  ipath E r\n  {a, b} \\<subseteq> limit r", "show ?thesis"], ["proof (prove)\nusing this:\n  ipath E r\n  {a, b} \\<subseteq> limit r\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> E\\<^sup>+", "by (metis ipath_to_trancl two_in_limit_iff)"], ["proof (state)\nthis:\n  (a, b) \\<in> E\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipath_subpath:\n  assumes P: \"ipath E r\"\n  assumes LE: \"l\\<le>u\"\n  shows \"path E (r l) (map r [l..<u]) (r u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path E (r l) (map r [l..<u]) (r u)", "using LE"], ["proof (prove)\nusing this:\n  l \\<le> u\n\ngoal (1 subgoal):\n 1. path E (r l) (map r [l..<u]) (r u)", "proof (induction \"u-l\" arbitrary: u l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u l.\n       \\<lbrakk>0 = u - l; l \\<le> u\\<rbrakk>\n       \\<Longrightarrow> path E (r l) (map r [l..<u]) (r u)\n 2. \\<And>x u l.\n       \\<lbrakk>\\<And>u l.\n                   \\<lbrakk>x = u - l; l \\<le> u\\<rbrakk>\n                   \\<Longrightarrow> path E (r l) (map r [l..<u]) (r u);\n        Suc x = u - l; l \\<le> u\\<rbrakk>\n       \\<Longrightarrow> path E (r l) (map r [l..<u]) (r u)", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>n = ?u - ?l; ?l \\<le> ?u\\<rbrakk>\n  \\<Longrightarrow> path E (r ?l) (map r [?l..<?u]) (r ?u)\n  Suc n = u - l\n  l \\<le> u\n\ngoal (2 subgoals):\n 1. \\<And>u l.\n       \\<lbrakk>0 = u - l; l \\<le> u\\<rbrakk>\n       \\<Longrightarrow> path E (r l) (map r [l..<u]) (r u)\n 2. \\<And>x u l.\n       \\<lbrakk>\\<And>u l.\n                   \\<lbrakk>x = u - l; l \\<le> u\\<rbrakk>\n                   \\<Longrightarrow> path E (r l) (map r [l..<u]) (r u);\n        Suc x = u - l; l \\<le> u\\<rbrakk>\n       \\<Longrightarrow> path E (r l) (map r [l..<u]) (r u)", "note IH=Suc.hyps(1)"], ["proof (state)\nthis:\n  \\<lbrakk>n = ?u - ?l; ?l \\<le> ?u\\<rbrakk>\n  \\<Longrightarrow> path E (r ?l) (map r [?l..<?u]) (r ?u)\n\ngoal (2 subgoals):\n 1. \\<And>u l.\n       \\<lbrakk>0 = u - l; l \\<le> u\\<rbrakk>\n       \\<Longrightarrow> path E (r l) (map r [l..<u]) (r u)\n 2. \\<And>x u l.\n       \\<lbrakk>\\<And>u l.\n                   \\<lbrakk>x = u - l; l \\<le> u\\<rbrakk>\n                   \\<Longrightarrow> path E (r l) (map r [l..<u]) (r u);\n        Suc x = u - l; l \\<le> u\\<rbrakk>\n       \\<Longrightarrow> path E (r l) (map r [l..<u]) (r u)", "from \\<open>Suc n = u-l\\<close> \\<open>l\\<le>u\\<close>"], ["proof (chain)\npicking this:\n  Suc n = u - l\n  l \\<le> u", "obtain u' where [simp]: \"u=Suc u'\" \n    and A: \"n=u'-l\" \"l \\<le> u'\""], ["proof (prove)\nusing this:\n  Suc n = u - l\n  l \\<le> u\n\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        \\<lbrakk>u = Suc u'; n = u' - l; l \\<le> u'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases u) auto"], ["proof (state)\nthis:\n  u = Suc u'\n  n = u' - l\n  l \\<le> u'\n\ngoal (2 subgoals):\n 1. \\<And>u l.\n       \\<lbrakk>0 = u - l; l \\<le> u\\<rbrakk>\n       \\<Longrightarrow> path E (r l) (map r [l..<u]) (r u)\n 2. \\<And>x u l.\n       \\<lbrakk>\\<And>u l.\n                   \\<lbrakk>x = u - l; l \\<le> u\\<rbrakk>\n                   \\<Longrightarrow> path E (r l) (map r [l..<u]) (r u);\n        Suc x = u - l; l \\<le> u\\<rbrakk>\n       \\<Longrightarrow> path E (r l) (map r [l..<u]) (r u)", "note IH[OF A]"], ["proof (state)\nthis:\n  path E (r l) (map r [l..<u']) (r u')\n\ngoal (2 subgoals):\n 1. \\<And>u l.\n       \\<lbrakk>0 = u - l; l \\<le> u\\<rbrakk>\n       \\<Longrightarrow> path E (r l) (map r [l..<u]) (r u)\n 2. \\<And>x u l.\n       \\<lbrakk>\\<And>u l.\n                   \\<lbrakk>x = u - l; l \\<le> u\\<rbrakk>\n                   \\<Longrightarrow> path E (r l) (map r [l..<u]) (r u);\n        Suc x = u - l; l \\<le> u\\<rbrakk>\n       \\<Longrightarrow> path E (r l) (map r [l..<u]) (r u)", "also"], ["proof (state)\nthis:\n  path E (r l) (map r [l..<u']) (r u')\n\ngoal (2 subgoals):\n 1. \\<And>u l.\n       \\<lbrakk>0 = u - l; l \\<le> u\\<rbrakk>\n       \\<Longrightarrow> path E (r l) (map r [l..<u]) (r u)\n 2. \\<And>x u l.\n       \\<lbrakk>\\<And>u l.\n                   \\<lbrakk>x = u - l; l \\<le> u\\<rbrakk>\n                   \\<Longrightarrow> path E (r l) (map r [l..<u]) (r u);\n        Suc x = u - l; l \\<le> u\\<rbrakk>\n       \\<Longrightarrow> path E (r l) (map r [l..<u]) (r u)", "from P"], ["proof (chain)\npicking this:\n  ipath E r", "have \"(r u',r u)\\<in>E\""], ["proof (prove)\nusing this:\n  ipath E r\n\ngoal (1 subgoal):\n 1. (r u', r u) \\<in> E", "by (auto simp: ipath_def)"], ["proof (state)\nthis:\n  (r u', r u) \\<in> E\n\ngoal (2 subgoals):\n 1. \\<And>u l.\n       \\<lbrakk>0 = u - l; l \\<le> u\\<rbrakk>\n       \\<Longrightarrow> path E (r l) (map r [l..<u]) (r u)\n 2. \\<And>x u l.\n       \\<lbrakk>\\<And>u l.\n                   \\<lbrakk>x = u - l; l \\<le> u\\<rbrakk>\n                   \\<Longrightarrow> path E (r l) (map r [l..<u]) (r u);\n        Suc x = u - l; l \\<le> u\\<rbrakk>\n       \\<Longrightarrow> path E (r l) (map r [l..<u]) (r u)", "finally"], ["proof (chain)\npicking this:\n  path E (r l) (map r [l..<u'] @ [r u']) (r u)", "show ?case"], ["proof (prove)\nusing this:\n  path E (r l) (map r [l..<u'] @ [r u']) (r u)\n\ngoal (1 subgoal):\n 1. path E (r l) (map r [l..<u]) (r u)", "using \\<open>l \\<le> u'\\<close>"], ["proof (prove)\nusing this:\n  path E (r l) (map r [l..<u'] @ [r u']) (r u)\n  l \\<le> u'\n\ngoal (1 subgoal):\n 1. path E (r l) (map r [l..<u]) (r u)", "by (simp add: upt_Suc_append)"], ["proof (state)\nthis:\n  path E (r l) (map r [l..<u]) (r u)\n\ngoal (1 subgoal):\n 1. \\<And>u l.\n       \\<lbrakk>0 = u - l; l \\<le> u\\<rbrakk>\n       \\<Longrightarrow> path E (r l) (map r [l..<u]) (r u)", "qed auto"], ["", "lemma ipath_restrict_eq: \"ipath (E \\<inter> (E\\<^sup>*``{r 0} \\<times> E\\<^sup>*``{r 0})) r \\<longleftrightarrow> ipath E r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipath (Restr E (E\\<^sup>* `` {r 0})) r = ipath E r", "unfolding ipath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i. (r i, r (Suc i)) \\<in> Restr E (E\\<^sup>* `` {r 0})) =\n    (\\<forall>i. (r i, r (Suc i)) \\<in> E)", "by (auto simp: relpow_fun_conv rtrancl_power)"], ["", "lemma ipath_restrict: \"ipath E r \\<Longrightarrow> ipath (E \\<inter> (E\\<^sup>*``{r 0} \\<times> E\\<^sup>*``{r 0})) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipath E r \\<Longrightarrow> ipath (Restr E (E\\<^sup>* `` {r 0})) r", "by (simp add: ipath_restrict_eq)"], ["", "lemma ipathI[intro?]: \"\\<lbrakk>\\<And>i. (r i, r (Suc i)) \\<in> E\\<rbrakk> \\<Longrightarrow> ipath E r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. (r i, r (Suc i)) \\<in> E) \\<Longrightarrow> ipath E r", "unfolding ipath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. (r i, r (Suc i)) \\<in> E) \\<Longrightarrow>\n    \\<forall>i. (r i, r (Suc i)) \\<in> E", "by auto"], ["", "lemma ipathD: \"ipath E r \\<Longrightarrow> (r i, r (Suc i)) \\<in> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipath E r \\<Longrightarrow> (r i, r (Suc i)) \\<in> E", "unfolding ipath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. (r i, r (Suc i)) \\<in> E \\<Longrightarrow>\n    (r i, r (Suc i)) \\<in> E", "by auto"], ["", "lemma ipath_in_Domain: \"ipath E r \\<Longrightarrow> r i \\<in> Domain E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipath E r \\<Longrightarrow> r i \\<in> Domain E", "unfolding ipath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. (r i, r (Suc i)) \\<in> E \\<Longrightarrow>\n    r i \\<in> Domain E", "by auto"], ["", "lemma ipath_in_Range: \"\\<lbrakk>ipath E r; i\\<noteq>0\\<rbrakk> \\<Longrightarrow> r i \\<in> Range E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ipath E r; i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> r i \\<in> Range E", "unfolding ipath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i. (r i, r (Suc i)) \\<in> E; i \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> r i \\<in> Range E", "by (cases i) auto"], ["", "lemma ipath_suffix: \"ipath E r \\<Longrightarrow> ipath E (suffix i r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipath E r \\<Longrightarrow> ipath E (suffix i r)", "unfolding suffix_def ipath_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. (r i, r (Suc i)) \\<in> E \\<Longrightarrow>\n    \\<forall>ia. (r (i + ia), r (i + Suc ia)) \\<in> E", "by auto"], ["", "subsection \\<open>Strongly Connected Components\\<close>"], ["", "text \\<open>A strongly connected component is a maximal mutually connected set \n  of nodes\\<close>"], ["", "definition is_scc :: \"'q digraph \\<Rightarrow> 'q set \\<Rightarrow> bool\"\n  where \"is_scc E U \\<longleftrightarrow> U\\<times>U\\<subseteq>E\\<^sup>* \\<and> (\\<forall>V. V\\<supset>U \\<longrightarrow> \\<not> (V\\<times>V\\<subseteq>E\\<^sup>*))\""], ["", "lemma scc_non_empty[simp]: \"\\<not>is_scc E {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_scc E {}", "unfolding is_scc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> ({} \\<times> {} \\<subseteq> E\\<^sup>* \\<and>\n            (\\<forall>V.\n                {} \\<subset> V \\<longrightarrow>\n                \\<not> V \\<times> V \\<subseteq> E\\<^sup>*))", "by auto"], ["", "lemma scc_non_empty'[simp]: \"is_scc E U \\<Longrightarrow> U\\<noteq>{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_scc E U \\<Longrightarrow> U \\<noteq> {}", "unfolding is_scc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<times> U \\<subseteq> E\\<^sup>* \\<and>\n    (\\<forall>V.\n        U \\<subset> V \\<longrightarrow>\n        \\<not> V \\<times> V \\<subseteq> E\\<^sup>*) \\<Longrightarrow>\n    U \\<noteq> {}", "by auto"], ["", "lemma is_scc_closed: \n  assumes SCC: \"is_scc E U\"\n  assumes MEM: \"x\\<in>U\"\n  assumes P: \"(x,y)\\<in>E\\<^sup>*\" \"(y,x)\\<in>E\\<^sup>*\"\n  shows \"y\\<in>U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> U", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<in> U", "from SCC MEM P"], ["proof (chain)\npicking this:\n  is_scc E U\n  x \\<in> U\n  (x, y) \\<in> E\\<^sup>*\n  (y, x) \\<in> E\\<^sup>*", "have \"insert y U \\<times> insert y U \\<subseteq> E\\<^sup>*\""], ["proof (prove)\nusing this:\n  is_scc E U\n  x \\<in> U\n  (x, y) \\<in> E\\<^sup>*\n  (y, x) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. insert y U \\<times> insert y U \\<subseteq> E\\<^sup>*", "unfolding is_scc_def"], ["proof (prove)\nusing this:\n  U \\<times> U \\<subseteq> E\\<^sup>* \\<and>\n  (\\<forall>V.\n      U \\<subset> V \\<longrightarrow>\n      \\<not> V \\<times> V \\<subseteq> E\\<^sup>*)\n  x \\<in> U\n  (x, y) \\<in> E\\<^sup>*\n  (y, x) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. insert y U \\<times> insert y U \\<subseteq> E\\<^sup>*", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> U; (x, y) \\<in> E\\<^sup>*; (y, x) \\<in> E\\<^sup>*;\n     U \\<times> U \\<subseteq> E\\<^sup>*;\n     \\<forall>V.\n        U \\<subset> V \\<longrightarrow>\n        \\<not> V \\<times> V \\<subseteq> E\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> U \\<times> insert y U \\<subseteq> E\\<^sup>* \\<and>\n                      insert y U \\<times> U \\<subseteq> E\\<^sup>*", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> U; (x, y) \\<in> E\\<^sup>*; (y, x) \\<in> E\\<^sup>*;\n     U \\<times> U \\<subseteq> E\\<^sup>*;\n     \\<forall>V.\n        U \\<subset> V \\<longrightarrow>\n        \\<not> V \\<times> V \\<subseteq> E\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> U \\<times> insert y U \\<subseteq> E\\<^sup>*\n 2. \\<lbrakk>x \\<in> U; (x, y) \\<in> E\\<^sup>*; (y, x) \\<in> E\\<^sup>*;\n     U \\<times> U \\<subseteq> E\\<^sup>*;\n     \\<forall>V.\n        U \\<subset> V \\<longrightarrow>\n        \\<not> V \\<times> V \\<subseteq> E\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> insert y U \\<times> U \\<subseteq> E\\<^sup>*", "apply clarsimp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>x \\<in> U; (x, y) \\<in> E\\<^sup>*; (y, x) \\<in> E\\<^sup>*;\n        U \\<times> U \\<subseteq> E\\<^sup>*;\n        \\<forall>V.\n           U \\<subset> V \\<longrightarrow>\n           \\<not> V \\<times> V \\<subseteq> E\\<^sup>*;\n        a \\<in> U; b = y \\<or> b \\<in> U\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> E\\<^sup>*\n 2. \\<And>a b.\n       \\<lbrakk>x \\<in> U; (x, y) \\<in> E\\<^sup>*; (y, x) \\<in> E\\<^sup>*;\n        U \\<times> U \\<subseteq> E\\<^sup>*;\n        \\<forall>V.\n           U \\<subset> V \\<longrightarrow>\n           \\<not> V \\<times> V \\<subseteq> E\\<^sup>*;\n        a = y \\<or> a \\<in> U; b \\<in> U\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> E\\<^sup>*", "apply (erule disjE1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>x \\<in> U; (x, y) \\<in> E\\<^sup>*; (y, x) \\<in> E\\<^sup>*;\n        U \\<times> U \\<subseteq> E\\<^sup>*;\n        \\<forall>V.\n           U \\<subset> V \\<longrightarrow>\n           \\<not> V \\<times> V \\<subseteq> E\\<^sup>*;\n        a \\<in> U; b = y\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> E\\<^sup>*\n 2. \\<And>a b.\n       \\<lbrakk>x \\<in> U; (x, y) \\<in> E\\<^sup>*; (y, x) \\<in> E\\<^sup>*;\n        U \\<times> U \\<subseteq> E\\<^sup>*;\n        \\<forall>V.\n           U \\<subset> V \\<longrightarrow>\n           \\<not> V \\<times> V \\<subseteq> E\\<^sup>*;\n        a \\<in> U; b \\<noteq> y; b \\<in> U\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> E\\<^sup>*\n 3. \\<And>a b.\n       \\<lbrakk>x \\<in> U; (x, y) \\<in> E\\<^sup>*; (y, x) \\<in> E\\<^sup>*;\n        U \\<times> U \\<subseteq> E\\<^sup>*;\n        \\<forall>V.\n           U \\<subset> V \\<longrightarrow>\n           \\<not> V \\<times> V \\<subseteq> E\\<^sup>*;\n        a = y \\<or> a \\<in> U; b \\<in> U\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> E\\<^sup>*", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>x \\<in> U; (x, y) \\<in> E\\<^sup>*; (y, x) \\<in> E\\<^sup>*;\n        U \\<times> U \\<subseteq> E\\<^sup>*;\n        \\<forall>V.\n           U \\<subset> V \\<longrightarrow>\n           \\<not> V \\<times> V \\<subseteq> E\\<^sup>*;\n        a \\<in> U\\<rbrakk>\n       \\<Longrightarrow> (a, y) \\<in> E\\<^sup>*\n 2. \\<And>a b.\n       \\<lbrakk>x \\<in> U; (x, y) \\<in> E\\<^sup>*; (y, x) \\<in> E\\<^sup>*;\n        U \\<times> U \\<subseteq> E\\<^sup>*;\n        \\<forall>V.\n           U \\<subset> V \\<longrightarrow>\n           \\<not> V \\<times> V \\<subseteq> E\\<^sup>*;\n        a \\<in> U; b \\<noteq> y; b \\<in> U\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> E\\<^sup>*\n 3. \\<And>a b.\n       \\<lbrakk>x \\<in> U; (x, y) \\<in> E\\<^sup>*; (y, x) \\<in> E\\<^sup>*;\n        U \\<times> U \\<subseteq> E\\<^sup>*;\n        \\<forall>V.\n           U \\<subset> V \\<longrightarrow>\n           \\<not> V \\<times> V \\<subseteq> E\\<^sup>*;\n        a = y \\<or> a \\<in> U; b \\<in> U\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> E\\<^sup>*", "apply (metis in_mono mem_Sigma_iff rtrancl_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>x \\<in> U; (x, y) \\<in> E\\<^sup>*; (y, x) \\<in> E\\<^sup>*;\n        U \\<times> U \\<subseteq> E\\<^sup>*;\n        \\<forall>V.\n           U \\<subset> V \\<longrightarrow>\n           \\<not> V \\<times> V \\<subseteq> E\\<^sup>*;\n        a \\<in> U; b \\<noteq> y; b \\<in> U\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> E\\<^sup>*\n 2. \\<And>a b.\n       \\<lbrakk>x \\<in> U; (x, y) \\<in> E\\<^sup>*; (y, x) \\<in> E\\<^sup>*;\n        U \\<times> U \\<subseteq> E\\<^sup>*;\n        \\<forall>V.\n           U \\<subset> V \\<longrightarrow>\n           \\<not> V \\<times> V \\<subseteq> E\\<^sup>*;\n        a = y \\<or> a \\<in> U; b \\<in> U\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> E\\<^sup>*", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>x \\<in> U; (x, y) \\<in> E\\<^sup>*; (y, x) \\<in> E\\<^sup>*;\n        U \\<times> U \\<subseteq> E\\<^sup>*;\n        \\<forall>V.\n           U \\<subset> V \\<longrightarrow>\n           \\<not> V \\<times> V \\<subseteq> E\\<^sup>*;\n        a = y \\<or> a \\<in> U; b \\<in> U\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> E\\<^sup>*", "apply (erule disjE1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>x \\<in> U; (x, y) \\<in> E\\<^sup>*; (y, x) \\<in> E\\<^sup>*;\n        U \\<times> U \\<subseteq> E\\<^sup>*;\n        \\<forall>V.\n           U \\<subset> V \\<longrightarrow>\n           \\<not> V \\<times> V \\<subseteq> E\\<^sup>*;\n        b \\<in> U; a = y\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> E\\<^sup>*\n 2. \\<And>a b.\n       \\<lbrakk>x \\<in> U; (x, y) \\<in> E\\<^sup>*; (y, x) \\<in> E\\<^sup>*;\n        U \\<times> U \\<subseteq> E\\<^sup>*;\n        \\<forall>V.\n           U \\<subset> V \\<longrightarrow>\n           \\<not> V \\<times> V \\<subseteq> E\\<^sup>*;\n        b \\<in> U; a \\<noteq> y; a \\<in> U\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> E\\<^sup>*", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>x \\<in> U; (x, y) \\<in> E\\<^sup>*; (y, x) \\<in> E\\<^sup>*;\n        U \\<times> U \\<subseteq> E\\<^sup>*;\n        \\<forall>V.\n           U \\<subset> V \\<longrightarrow>\n           \\<not> V \\<times> V \\<subseteq> E\\<^sup>*;\n        b \\<in> U\\<rbrakk>\n       \\<Longrightarrow> (y, b) \\<in> E\\<^sup>*\n 2. \\<And>a b.\n       \\<lbrakk>x \\<in> U; (x, y) \\<in> E\\<^sup>*; (y, x) \\<in> E\\<^sup>*;\n        U \\<times> U \\<subseteq> E\\<^sup>*;\n        \\<forall>V.\n           U \\<subset> V \\<longrightarrow>\n           \\<not> V \\<times> V \\<subseteq> E\\<^sup>*;\n        b \\<in> U; a \\<noteq> y; a \\<in> U\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> E\\<^sup>*", "apply (metis in_mono mem_Sigma_iff rtrancl_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>x \\<in> U; (x, y) \\<in> E\\<^sup>*; (y, x) \\<in> E\\<^sup>*;\n        U \\<times> U \\<subseteq> E\\<^sup>*;\n        \\<forall>V.\n           U \\<subset> V \\<longrightarrow>\n           \\<not> V \\<times> V \\<subseteq> E\\<^sup>*;\n        b \\<in> U; a \\<noteq> y; a \\<in> U\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> E\\<^sup>*", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  insert y U \\<times> insert y U \\<subseteq> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. y \\<in> U", "with SCC"], ["proof (chain)\npicking this:\n  is_scc E U\n  insert y U \\<times> insert y U \\<subseteq> E\\<^sup>*", "show ?thesis"], ["proof (prove)\nusing this:\n  is_scc E U\n  insert y U \\<times> insert y U \\<subseteq> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. y \\<in> U", "unfolding is_scc_def"], ["proof (prove)\nusing this:\n  U \\<times> U \\<subseteq> E\\<^sup>* \\<and>\n  (\\<forall>V.\n      U \\<subset> V \\<longrightarrow>\n      \\<not> V \\<times> V \\<subseteq> E\\<^sup>*)\n  insert y U \\<times> insert y U \\<subseteq> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. y \\<in> U", "by blast"], ["proof (state)\nthis:\n  y \\<in> U\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_scc_connected:\n  assumes SCC: \"is_scc E U\"\n  assumes MEM: \"x\\<in>U\" \"y\\<in>U\"\n  shows \"(x,y)\\<in>E\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> E\\<^sup>*", "using assms"], ["proof (prove)\nusing this:\n  is_scc E U\n  x \\<in> U\n  y \\<in> U\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> E\\<^sup>*", "unfolding is_scc_def"], ["proof (prove)\nusing this:\n  U \\<times> U \\<subseteq> E\\<^sup>* \\<and>\n  (\\<forall>V.\n      U \\<subset> V \\<longrightarrow>\n      \\<not> V \\<times> V \\<subseteq> E\\<^sup>*)\n  x \\<in> U\n  y \\<in> U\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> E\\<^sup>*", "by auto"], ["", "text \\<open>In the following, we play around with alternative characterizations, and\n  prove them all equivalent .\\<close>"], ["", "text \\<open>A common characterization is to define an equivalence relation \n  ,,mutually connected'' on nodes, and characterize the SCCs as its \n  equivalence classes:\\<close>"], ["", "definition mconn :: \"('a\\<times>'a) set \\<Rightarrow> ('a \\<times> 'a) set\"\n  \\<comment> \\<open>Mutually connected relation on nodes\\<close>\n  where \"mconn E = E\\<^sup>* \\<inter> (E\\<inverse>)\\<^sup>*\""], ["", "lemma mconn_pointwise:\n   \"mconn E = {(u,v). (u,v)\\<in>E\\<^sup>* \\<and> (v,u)\\<in>E\\<^sup>*}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mconn E = {(u, v). (u, v) \\<in> E\\<^sup>* \\<and> (v, u) \\<in> E\\<^sup>*}", "by (auto simp add: mconn_def rtrancl_converse)"], ["", "text \\<open>\\<open>mconn\\<close> is an equivalence relation:\\<close>"], ["", "lemma mconn_refl[simp]: \"Id\\<subseteq>mconn E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Id \\<subseteq> mconn E", "by (auto simp add: mconn_def)"], ["", "lemma mconn_sym: \"mconn E = (mconn E)\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mconn E = (mconn E)\\<inverse>", "by (auto simp add: mconn_pointwise)"], ["", "lemma mconn_trans: \"mconn E O mconn E = mconn E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mconn E O mconn E = mconn E", "by (auto simp add: mconn_def)"], ["", "lemma mconn_refl': \"refl (mconn E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refl (mconn E)", "by (auto intro: refl_onI simp: mconn_pointwise)"], ["", "lemma mconn_sym': \"sym (mconn E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym (mconn E)", "by (auto intro: symI simp: mconn_pointwise)"], ["", "lemma mconn_trans': \"trans (mconn E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans (mconn E)", "by (metis mconn_def trans_Int trans_rtrancl)"], ["", "lemma mconn_equiv: \"equiv UNIV (mconn E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv UNIV (mconn E)", "using mconn_refl' mconn_sym' mconn_trans'"], ["proof (prove)\nusing this:\n  refl (mconn ?E)\n  sym (mconn ?E)\n  trans (mconn ?E)\n\ngoal (1 subgoal):\n 1. equiv UNIV (mconn E)", "by (rule equivI)"], ["", "lemma is_scc_mconn_eqclasses: \"is_scc E U \\<longleftrightarrow> U \\<in> UNIV // mconn E\"\n  \\<comment> \\<open>The strongly connected components are the equivalence classes of the \n    mutually-connected relation on nodes\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_scc E U = (U \\<in> UNIV // mconn E)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. is_scc E U \\<Longrightarrow> U \\<in> UNIV // mconn E\n 2. U \\<in> UNIV // mconn E \\<Longrightarrow> is_scc E U", "assume A: \"is_scc E U\""], ["proof (state)\nthis:\n  is_scc E U\n\ngoal (2 subgoals):\n 1. is_scc E U \\<Longrightarrow> U \\<in> UNIV // mconn E\n 2. U \\<in> UNIV // mconn E \\<Longrightarrow> is_scc E U", "then"], ["proof (chain)\npicking this:\n  is_scc E U", "obtain x where \"x\\<in>U\""], ["proof (prove)\nusing this:\n  is_scc E U\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> U \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding is_scc_def"], ["proof (prove)\nusing this:\n  U \\<times> U \\<subseteq> E\\<^sup>* \\<and>\n  (\\<forall>V.\n      U \\<subset> V \\<longrightarrow>\n      \\<not> V \\<times> V \\<subseteq> E\\<^sup>*)\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> U \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> U\n\ngoal (2 subgoals):\n 1. is_scc E U \\<Longrightarrow> U \\<in> UNIV // mconn E\n 2. U \\<in> UNIV // mconn E \\<Longrightarrow> is_scc E U", "hence \"U = mconn E `` {x}\""], ["proof (prove)\nusing this:\n  x \\<in> U\n\ngoal (1 subgoal):\n 1. U = mconn E `` {x}", "using A"], ["proof (prove)\nusing this:\n  x \\<in> U\n  is_scc E U\n\ngoal (1 subgoal):\n 1. U = mconn E `` {x}", "unfolding mconn_pointwise is_scc_def"], ["proof (prove)\nusing this:\n  x \\<in> U\n  U \\<times> U \\<subseteq> E\\<^sup>* \\<and>\n  (\\<forall>V.\n      U \\<subset> V \\<longrightarrow>\n      \\<not> V \\<times> V \\<subseteq> E\\<^sup>*)\n\ngoal (1 subgoal):\n 1. U =\n    {(u, v). (u, v) \\<in> E\\<^sup>* \\<and> (v, u) \\<in> E\\<^sup>*} `` {x}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> U; U \\<times> U \\<subseteq> E\\<^sup>*;\n     \\<forall>V.\n        U \\<subset> V \\<longrightarrow>\n        \\<not> V \\<times> V \\<subseteq> E\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> U =\n                      {v. (x, v) \\<in> E\\<^sup>* \\<and>\n                          (v, x) \\<in> E\\<^sup>*}", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> U; U \\<times> U \\<subseteq> E\\<^sup>*;\n     \\<forall>V.\n        U \\<subset> V \\<longrightarrow>\n        \\<not> V \\<times> V \\<subseteq> E\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> U \\<subseteq> {v. (x, v) \\<in> E\\<^sup>* \\<and>\n  (v, x) \\<in> E\\<^sup>*}\n 2. \\<lbrakk>x \\<in> U; U \\<times> U \\<subseteq> E\\<^sup>*;\n     \\<forall>V.\n        U \\<subset> V \\<longrightarrow>\n        \\<not> V \\<times> V \\<subseteq> E\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> {v. (x, v) \\<in> E\\<^sup>* \\<and>\n                          (v, x) \\<in> E\\<^sup>*}\n                      \\<subseteq> U", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> U; U \\<times> U \\<subseteq> E\\<^sup>*;\n     \\<forall>V.\n        U \\<subset> V \\<longrightarrow>\n        \\<not> V \\<times> V \\<subseteq> E\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> {v. (x, v) \\<in> E\\<^sup>* \\<and>\n                          (v, x) \\<in> E\\<^sup>*}\n                      \\<subseteq> U", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<in> U; U \\<times> U \\<subseteq> E\\<^sup>*;\n        \\<forall>V.\n           U \\<subset> V \\<longrightarrow>\n           \\<not> V \\<times> V \\<subseteq> E\\<^sup>*;\n        (x, xa) \\<in> E\\<^sup>*; (xa, x) \\<in> E\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> U", "by (metis A is_scc_closed)"], ["proof (state)\nthis:\n  U = mconn E `` {x}\n\ngoal (2 subgoals):\n 1. is_scc E U \\<Longrightarrow> U \\<in> UNIV // mconn E\n 2. U \\<in> UNIV // mconn E \\<Longrightarrow> is_scc E U", "thus \"U \\<in> UNIV // mconn E\""], ["proof (prove)\nusing this:\n  U = mconn E `` {x}\n\ngoal (1 subgoal):\n 1. U \\<in> UNIV // mconn E", "by (auto simp: quotient_def)"], ["proof (state)\nthis:\n  U \\<in> UNIV // mconn E\n\ngoal (1 subgoal):\n 1. U \\<in> UNIV // mconn E \\<Longrightarrow> is_scc E U", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. U \\<in> UNIV // mconn E \\<Longrightarrow> is_scc E U", "assume \"U \\<in> UNIV // mconn E\""], ["proof (state)\nthis:\n  U \\<in> UNIV // mconn E\n\ngoal (1 subgoal):\n 1. U \\<in> UNIV // mconn E \\<Longrightarrow> is_scc E U", "thus \"is_scc E U\""], ["proof (prove)\nusing this:\n  U \\<in> UNIV // mconn E\n\ngoal (1 subgoal):\n 1. is_scc E U", "by (auto simp: is_scc_def mconn_pointwise quotient_def)"], ["proof (state)\nthis:\n  is_scc E U\n\ngoal:\nNo subgoals!", "qed"], ["", "(* For presentation in the paper *)"], ["", "lemma \"is_scc E U \\<longleftrightarrow> U \\<in> UNIV // (E\\<^sup>* \\<inter> (E\\<inverse>)\\<^sup>*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_scc E U =\n    (U \\<in> UNIV // (E\\<^sup>* \\<inter> (E\\<inverse>)\\<^sup>*))", "unfolding is_scc_mconn_eqclasses mconn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (U \\<in> UNIV // (E\\<^sup>* \\<inter> (E\\<inverse>)\\<^sup>*)) =\n    (U \\<in> UNIV // (E\\<^sup>* \\<inter> (E\\<inverse>)\\<^sup>*))", "by simp"], ["", "text \\<open>We can also restrict the notion of \"reachability\" to nodes\n  inside the SCC\n\\<close>"], ["", "lemma find_outside_node:\n  assumes \"(u,v)\\<in>E\\<^sup>*\"\n  assumes \"(u,v)\\<notin>(E\\<inter>U\\<times>U)\\<^sup>*\"\n  assumes \"u\\<in>U\" \"v\\<in>U\"\n  shows \"\\<exists>u'. u'\\<notin>U \\<and> (u,u')\\<in>E\\<^sup>* \\<and> (u',v)\\<in>E\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u'.\n       u' \\<notin> U \\<and>\n       (u, u') \\<in> E\\<^sup>* \\<and> (u', v) \\<in> E\\<^sup>*", "using assms"], ["proof (prove)\nusing this:\n  (u, v) \\<in> E\\<^sup>*\n  (u, v) \\<notin> (Restr E U)\\<^sup>*\n  u \\<in> U\n  v \\<in> U\n\ngoal (1 subgoal):\n 1. \\<exists>u'.\n       u' \\<notin> U \\<and>\n       (u, u') \\<in> E\\<^sup>* \\<and> (u', v) \\<in> E\\<^sup>*", "apply (induction)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(u, u) \\<notin> (Restr E U)\\<^sup>*; u \\<in> U;\n     u \\<in> U\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u'.\n                         u' \\<notin> U \\<and>\n                         (u, u') \\<in> E\\<^sup>* \\<and>\n                         (u', u) \\<in> E\\<^sup>*\n 2. \\<And>y z.\n       \\<lbrakk>(u, y) \\<in> E\\<^sup>*; (y, z) \\<in> E;\n        \\<lbrakk>(u, y) \\<notin> (Restr E U)\\<^sup>*; u \\<in> U;\n         y \\<in> U\\<rbrakk>\n        \\<Longrightarrow> \\<exists>u'.\n                             u' \\<notin> U \\<and>\n                             (u, u') \\<in> E\\<^sup>* \\<and>\n                             (u', y) \\<in> E\\<^sup>*;\n        (u, z) \\<notin> (Restr E U)\\<^sup>*; u \\<in> U; z \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            u' \\<notin> U \\<and>\n                            (u, u') \\<in> E\\<^sup>* \\<and>\n                            (u', z) \\<in> E\\<^sup>*", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(u, y) \\<in> E\\<^sup>*; (y, z) \\<in> E;\n        \\<lbrakk>(u, y) \\<notin> (Restr E U)\\<^sup>*; u \\<in> U;\n         y \\<in> U\\<rbrakk>\n        \\<Longrightarrow> \\<exists>u'.\n                             u' \\<notin> U \\<and>\n                             (u, u') \\<in> E\\<^sup>* \\<and>\n                             (u', y) \\<in> E\\<^sup>*;\n        (u, z) \\<notin> (Restr E U)\\<^sup>*; u \\<in> U; z \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            u' \\<notin> U \\<and>\n                            (u, u') \\<in> E\\<^sup>* \\<and>\n                            (u', z) \\<in> E\\<^sup>*", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(u, y) \\<in> E\\<^sup>*; (y, z) \\<in> E;\n        \\<lbrakk>(u, y) \\<notin> (Restr E U)\\<^sup>*; y \\<in> U\\<rbrakk>\n        \\<Longrightarrow> \\<exists>u'.\n                             u' \\<notin> U \\<and>\n                             (u, u') \\<in> E\\<^sup>* \\<and>\n                             (u', y) \\<in> E\\<^sup>*;\n        (u, z) \\<notin> (Restr E U)\\<^sup>*; u \\<in> U; z \\<in> U\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u'.\n                            u' \\<notin> U \\<and>\n                            (u, u') \\<in> E\\<^sup>* \\<and>\n                            (u', z) \\<in> E\\<^sup>*", "by (metis IntI mem_Sigma_iff rtrancl.simps)"], ["", "lemma is_scc_restrict1:\n  assumes SCC: \"is_scc E U\"\n  shows \"U\\<times>U\\<subseteq>(E\\<inter>U\\<times>U)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<times> U \\<subseteq> (Restr E U)\\<^sup>*", "using assms"], ["proof (prove)\nusing this:\n  is_scc E U\n\ngoal (1 subgoal):\n 1. U \\<times> U \\<subseteq> (Restr E U)\\<^sup>*", "unfolding is_scc_def"], ["proof (prove)\nusing this:\n  U \\<times> U \\<subseteq> E\\<^sup>* \\<and>\n  (\\<forall>V.\n      U \\<subset> V \\<longrightarrow>\n      \\<not> V \\<times> V \\<subseteq> E\\<^sup>*)\n\ngoal (1 subgoal):\n 1. U \\<times> U \\<subseteq> (Restr E U)\\<^sup>*", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>U \\<times> U \\<subseteq> E\\<^sup>*;\n        \\<forall>V.\n           U \\<subset> V \\<longrightarrow>\n           \\<not> V \\<times> V \\<subseteq> E\\<^sup>*;\n        a \\<in> U; b \\<in> U\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> (Restr E U)\\<^sup>*", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>U \\<times> U \\<subseteq> E\\<^sup>*;\n        \\<forall>V.\n           U \\<subset> V \\<longrightarrow>\n           \\<not> V \\<times> V \\<subseteq> E\\<^sup>*;\n        a \\<in> U; b \\<in> U; (a, b) \\<notin> (Restr E U)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule (2) find_outside_node[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>U \\<times> U \\<subseteq> E\\<^sup>*;\n        \\<forall>V.\n           U \\<subset> V \\<longrightarrow>\n           \\<not> V \\<times> V \\<subseteq> E\\<^sup>*;\n        a \\<in> U; b \\<in> U\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> E\\<^sup>*\n 2. \\<And>a b.\n       \\<lbrakk>U \\<times> U \\<subseteq> E\\<^sup>*;\n        \\<forall>V.\n           U \\<subset> V \\<longrightarrow>\n           \\<not> V \\<times> V \\<subseteq> E\\<^sup>*;\n        a \\<in> U; b \\<in> U;\n        \\<exists>u'.\n           u' \\<notin> U \\<and>\n           (a, u') \\<in> E\\<^sup>* \\<and> (u', b) \\<in> E\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>U \\<times> U \\<subseteq> E\\<^sup>*;\n        \\<forall>V.\n           U \\<subset> V \\<longrightarrow>\n           \\<not> V \\<times> V \\<subseteq> E\\<^sup>*;\n        a \\<in> U; b \\<in> U;\n        \\<exists>u'.\n           u' \\<notin> U \\<and>\n           (a, u') \\<in> E\\<^sup>* \\<and> (u', b) \\<in> E\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis is_scc_closed[OF SCC] mem_Sigma_iff rtrancl_trans subsetD)"], ["", "lemma is_scc_restrict2:\n  assumes SCC: \"is_scc E U\"\n  assumes \"V\\<supset>U\"\n  shows \"\\<not> (V\\<times>V\\<subseteq>(E\\<inter>V\\<times>V)\\<^sup>*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> V \\<times> V \\<subseteq> (Restr E V)\\<^sup>*", "using assms"], ["proof (prove)\nusing this:\n  is_scc E U\n  U \\<subset> V\n\ngoal (1 subgoal):\n 1. \\<not> V \\<times> V \\<subseteq> (Restr E V)\\<^sup>*", "unfolding is_scc_def"], ["proof (prove)\nusing this:\n  U \\<times> U \\<subseteq> E\\<^sup>* \\<and>\n  (\\<forall>V.\n      U \\<subset> V \\<longrightarrow>\n      \\<not> V \\<times> V \\<subseteq> E\\<^sup>*)\n  U \\<subset> V\n\ngoal (1 subgoal):\n 1. \\<not> V \\<times> V \\<subseteq> (Restr E V)\\<^sup>*", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>U \\<subseteq> V; x \\<in> V;\n        U \\<times> U \\<subseteq> E\\<^sup>*;\n        \\<forall>V.\n           U \\<subset> V \\<longrightarrow>\n           \\<not> V \\<times> V \\<subseteq> E\\<^sup>*;\n        x \\<notin> U; V \\<times> V \\<subseteq> (Restr E V)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> False", "using rtrancl_mono[of \"E \\<inter> V \\<times> V\" \"E\"]"], ["proof (prove)\nusing this:\n  Restr E V \\<subseteq> E \\<Longrightarrow>\n  (Restr E V)\\<^sup>* \\<subseteq> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>U \\<subseteq> V; x \\<in> V;\n        U \\<times> U \\<subseteq> E\\<^sup>*;\n        \\<forall>V.\n           U \\<subset> V \\<longrightarrow>\n           \\<not> V \\<times> V \\<subseteq> E\\<^sup>*;\n        x \\<notin> U; V \\<times> V \\<subseteq> (Restr E V)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> False", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>U \\<subseteq> V; x \\<in> V;\n        U \\<times> U \\<subseteq> E\\<^sup>*;\n        \\<forall>V.\n           U \\<subset> V \\<longrightarrow>\n           \\<not> V \\<times> V \\<subseteq> E\\<^sup>*;\n        x \\<notin> U; V \\<times> V \\<subseteq> (Restr E V)\\<^sup>*;\n        (Restr E V)\\<^sup>* \\<subseteq> E\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> False", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_scc_restrict3: \n  assumes SCC: \"is_scc E U\"\n  shows \"((E\\<^sup>*``((E\\<^sup>*``U) - U)) \\<inter> U = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E\\<^sup>* `` (E\\<^sup>* `` U - U) \\<inter> U = {}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x \\<in> U; (xa, x) \\<in> E\\<^sup>*; xa \\<notin> U;\n        (xb, xa) \\<in> E\\<^sup>*; xb \\<in> U\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis assms is_scc_closed is_scc_connected rtrancl_trans)"], ["", "lemma is_scc_alt_restrict_path:\n  \"is_scc E U \\<longleftrightarrow> U\\<noteq>{} \\<and>\n    (U\\<times>U \\<subseteq> (E\\<inter>U\\<times>U)\\<^sup>*) \\<and> ((E\\<^sup>*``((E\\<^sup>*``U) - U)) \\<inter> U = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_scc E U =\n    (U \\<noteq> {} \\<and>\n     U \\<times> U \\<subseteq> (Restr E U)\\<^sup>* \\<and>\n     E\\<^sup>* `` (E\\<^sup>* `` U - U) \\<inter> U = {})", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_scc E U \\<Longrightarrow>\n    U \\<noteq> {} \\<and>\n    U \\<times> U \\<subseteq> (Restr E U)\\<^sup>* \\<and>\n    E\\<^sup>* `` (E\\<^sup>* `` U - U) \\<inter> U = {}\n 2. U \\<noteq> {} \\<and>\n    U \\<times> U \\<subseteq> (Restr E U)\\<^sup>* \\<and>\n    E\\<^sup>* `` (E\\<^sup>* `` U - U) \\<inter> U = {} \\<Longrightarrow>\n    is_scc E U", "apply (intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. is_scc E U \\<Longrightarrow> U \\<noteq> {}\n 2. is_scc E U \\<Longrightarrow>\n    U \\<times> U \\<subseteq> (Restr E U)\\<^sup>*\n 3. is_scc E U \\<Longrightarrow>\n    E\\<^sup>* `` (E\\<^sup>* `` U - U) \\<inter> U = {}\n 4. U \\<noteq> {} \\<and>\n    U \\<times> U \\<subseteq> (Restr E U)\\<^sup>* \\<and>\n    E\\<^sup>* `` (E\\<^sup>* `` U - U) \\<inter> U = {} \\<Longrightarrow>\n    is_scc E U", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. is_scc E U \\<Longrightarrow>\n    U \\<times> U \\<subseteq> (Restr E U)\\<^sup>*\n 2. is_scc E U \\<Longrightarrow>\n    E\\<^sup>* `` (E\\<^sup>* `` U - U) \\<inter> U = {}\n 3. U \\<noteq> {} \\<and>\n    U \\<times> U \\<subseteq> (Restr E U)\\<^sup>* \\<and>\n    E\\<^sup>* `` (E\\<^sup>* `` U - U) \\<inter> U = {} \\<Longrightarrow>\n    is_scc E U", "apply (blast dest: is_scc_restrict1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_scc E U \\<Longrightarrow>\n    E\\<^sup>* `` (E\\<^sup>* `` U - U) \\<inter> U = {}\n 2. U \\<noteq> {} \\<and>\n    U \\<times> U \\<subseteq> (Restr E U)\\<^sup>* \\<and>\n    E\\<^sup>* `` (E\\<^sup>* `` U - U) \\<inter> U = {} \\<Longrightarrow>\n    is_scc E U", "apply (blast dest: is_scc_restrict3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<noteq> {} \\<and>\n    U \\<times> U \\<subseteq> (Restr E U)\\<^sup>* \\<and>\n    E\\<^sup>* `` (E\\<^sup>* `` U - U) \\<inter> U = {} \\<Longrightarrow>\n    is_scc E U", "unfolding is_scc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<noteq> {} \\<and>\n    U \\<times> U \\<subseteq> (Restr E U)\\<^sup>* \\<and>\n    E\\<^sup>* `` (E\\<^sup>* `` U - U) \\<inter> U = {} \\<Longrightarrow>\n    U \\<times> U \\<subseteq> E\\<^sup>* \\<and>\n    (\\<forall>V.\n        U \\<subset> V \\<longrightarrow>\n        \\<not> V \\<times> V \\<subseteq> E\\<^sup>*)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. U \\<noteq> {} \\<and>\n    U \\<times> U \\<subseteq> (Restr E U)\\<^sup>* \\<and>\n    E\\<^sup>* `` (E\\<^sup>* `` U - U) \\<inter> U = {} \\<Longrightarrow>\n    U \\<times> U \\<subseteq> E\\<^sup>*\n 2. U \\<noteq> {} \\<and>\n    U \\<times> U \\<subseteq> (Restr E U)\\<^sup>* \\<and>\n    E\\<^sup>* `` (E\\<^sup>* `` U - U) \\<inter> U = {} \\<Longrightarrow>\n    \\<forall>V.\n       U \\<subset> V \\<longrightarrow>\n       \\<not> V \\<times> V \\<subseteq> E\\<^sup>*", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>U \\<noteq> {}; a \\<in> U; b \\<in> U;\n        U \\<times> U \\<subseteq> (Restr E U)\\<^sup>*;\n        E\\<^sup>* `` (E\\<^sup>* `` U - U) \\<inter> U = {}\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> E\\<^sup>*\n 2. U \\<noteq> {} \\<and>\n    U \\<times> U \\<subseteq> (Restr E U)\\<^sup>* \\<and>\n    E\\<^sup>* `` (E\\<^sup>* `` U - U) \\<inter> U = {} \\<Longrightarrow>\n    \\<forall>V.\n       U \\<subset> V \\<longrightarrow>\n       \\<not> V \\<times> V \\<subseteq> E\\<^sup>*", "apply (metis (full_types) Int_lower1 in_mono mem_Sigma_iff rtrancl_mono_mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<noteq> {} \\<and>\n    U \\<times> U \\<subseteq> (Restr E U)\\<^sup>* \\<and>\n    E\\<^sup>* `` (E\\<^sup>* `` U - U) \\<inter> U = {} \\<Longrightarrow>\n    \\<forall>V.\n       U \\<subset> V \\<longrightarrow>\n       \\<not> V \\<times> V \\<subseteq> E\\<^sup>*", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_scc_pointwise:\n  \"is_scc E U \\<longleftrightarrow> \n    U\\<noteq>{}\n  \\<and> (\\<forall>u\\<in>U. \\<forall>v\\<in>U. (u,v)\\<in>(E\\<inter>U\\<times>U)\\<^sup>*) \n  \\<and> (\\<forall>u\\<in>U. \\<forall>v. (v\\<notin>U \\<and> (u,v)\\<in>E\\<^sup>*) \\<longrightarrow> (\\<forall>u'\\<in>U. (v,u')\\<notin>E\\<^sup>*))\"\n  \\<comment> \\<open>Alternative, pointwise characterization\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_scc E U =\n    (U \\<noteq> {} \\<and>\n     (\\<forall>u\\<in>U.\n         \\<forall>v\\<in>U. (u, v) \\<in> (Restr E U)\\<^sup>*) \\<and>\n     (\\<forall>u\\<in>U.\n         \\<forall>v.\n            v \\<notin> U \\<and> (u, v) \\<in> E\\<^sup>* \\<longrightarrow>\n            (\\<forall>u'\\<in>U. (v, u') \\<notin> E\\<^sup>*)))", "unfolding is_scc_alt_restrict_path"], ["proof (prove)\ngoal (1 subgoal):\n 1. (U \\<noteq> {} \\<and>\n     U \\<times> U \\<subseteq> (Restr E U)\\<^sup>* \\<and>\n     E\\<^sup>* `` (E\\<^sup>* `` U - U) \\<inter> U = {}) =\n    (U \\<noteq> {} \\<and>\n     (\\<forall>u\\<in>U.\n         \\<forall>v\\<in>U. (u, v) \\<in> (Restr E U)\\<^sup>*) \\<and>\n     (\\<forall>u\\<in>U.\n         \\<forall>v.\n            v \\<notin> U \\<and> (u, v) \\<in> E\\<^sup>* \\<longrightarrow>\n            (\\<forall>u'\\<in>U. (v, u') \\<notin> E\\<^sup>*)))", "by blast"], ["", "lemma is_scc_unique:\n  assumes SCC: \"is_scc E scc\" \"is_scc E scc'\"\n  and v: \"v \\<in> scc\" \"v \\<in> scc'\"\n  shows \"scc = scc'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scc = scc'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. scc = scc'", "from SCC"], ["proof (chain)\npicking this:\n  is_scc E scc\n  is_scc E scc'", "have \"scc = scc' \\<or> scc \\<inter> scc' = {}\""], ["proof (prove)\nusing this:\n  is_scc E scc\n  is_scc E scc'\n\ngoal (1 subgoal):\n 1. scc = scc' \\<or> scc \\<inter> scc' = {}", "using quotient_disj[OF mconn_equiv]"], ["proof (prove)\nusing this:\n  is_scc E scc\n  is_scc E scc'\n  \\<lbrakk>?X \\<in> UNIV // mconn ?E1; ?Y \\<in> UNIV // mconn ?E1\\<rbrakk>\n  \\<Longrightarrow> ?X = ?Y \\<or> ?X \\<inter> ?Y = {}\n\ngoal (1 subgoal):\n 1. scc = scc' \\<or> scc \\<inter> scc' = {}", "by (simp add: is_scc_mconn_eqclasses)"], ["proof (state)\nthis:\n  scc = scc' \\<or> scc \\<inter> scc' = {}\n\ngoal (1 subgoal):\n 1. scc = scc'", "with v"], ["proof (chain)\npicking this:\n  v \\<in> scc\n  v \\<in> scc'\n  scc = scc' \\<or> scc \\<inter> scc' = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> scc\n  v \\<in> scc'\n  scc = scc' \\<or> scc \\<inter> scc' = {}\n\ngoal (1 subgoal):\n 1. scc = scc'", "by auto"], ["proof (state)\nthis:\n  scc = scc'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_scc_ex1:\n  \"\\<exists>!scc. is_scc E scc \\<and> v \\<in> scc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!scc. is_scc E scc \\<and> v \\<in> scc", "proof (rule ex1I, rule conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. is_scc E ?a\n 2. v \\<in> ?a\n 3. \\<And>scc. is_scc E scc \\<and> v \\<in> scc \\<Longrightarrow> scc = ?a", "let ?scc = \"mconn E `` {v}\""], ["proof (state)\ngoal (3 subgoals):\n 1. is_scc E ?a\n 2. v \\<in> ?a\n 3. \\<And>scc. is_scc E scc \\<and> v \\<in> scc \\<Longrightarrow> scc = ?a", "have \"?scc \\<in> UNIV // mconn E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mconn E `` {v} \\<in> UNIV // mconn E", "by (auto intro: quotientI)"], ["proof (state)\nthis:\n  mconn E `` {v} \\<in> UNIV // mconn E\n\ngoal (3 subgoals):\n 1. is_scc E ?a\n 2. v \\<in> ?a\n 3. \\<And>scc. is_scc E scc \\<and> v \\<in> scc \\<Longrightarrow> scc = ?a", "thus \"is_scc E ?scc\""], ["proof (prove)\nusing this:\n  mconn E `` {v} \\<in> UNIV // mconn E\n\ngoal (1 subgoal):\n 1. is_scc E (mconn E `` {v})", "by (simp add: is_scc_mconn_eqclasses)"], ["proof (state)\nthis:\n  is_scc E (mconn E `` {v})\n\ngoal (2 subgoals):\n 1. v \\<in> mconn E `` {v}\n 2. \\<And>scc.\n       is_scc E scc \\<and> v \\<in> scc \\<Longrightarrow>\n       scc = mconn E `` {v}", "moreover"], ["proof (state)\nthis:\n  is_scc E (mconn E `` {v})\n\ngoal (2 subgoals):\n 1. v \\<in> mconn E `` {v}\n 2. \\<And>scc.\n       is_scc E scc \\<and> v \\<in> scc \\<Longrightarrow>\n       scc = mconn E `` {v}", "show \"v \\<in> ?scc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> mconn E `` {v}", "by (blast intro: refl_onD[OF mconn_refl'])"], ["proof (state)\nthis:\n  v \\<in> mconn E `` {v}\n\ngoal (1 subgoal):\n 1. \\<And>scc.\n       is_scc E scc \\<and> v \\<in> scc \\<Longrightarrow>\n       scc = mconn E `` {v}", "ultimately"], ["proof (chain)\npicking this:\n  is_scc E (mconn E `` {v})\n  v \\<in> mconn E `` {v}", "show \"\\<And>scc. is_scc E scc \\<and> v \\<in> scc \\<Longrightarrow> scc = ?scc\""], ["proof (prove)\nusing this:\n  is_scc E (mconn E `` {v})\n  v \\<in> mconn E `` {v}\n\ngoal (1 subgoal):\n 1. \\<And>scc.\n       is_scc E scc \\<and> v \\<in> scc \\<Longrightarrow>\n       scc = mconn E `` {v}", "by (metis is_scc_unique)"], ["proof (state)\nthis:\n  is_scc E ?scc \\<and> v \\<in> ?scc \\<Longrightarrow> ?scc = mconn E `` {v}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_scc_ex:\n  \"\\<exists>scc. is_scc E scc \\<and> v \\<in> scc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>scc. is_scc E scc \\<and> v \\<in> scc", "by (metis is_scc_ex1)"], ["", "lemma is_scc_connected':\n  \"\\<lbrakk>is_scc E scc; x \\<in> scc; y \\<in> scc\\<rbrakk> \\<Longrightarrow> (x,y)\\<in>(Restr E scc)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_scc E scc; x \\<in> scc; y \\<in> scc\\<rbrakk>\n    \\<Longrightarrow> (x, y) \\<in> (Restr E scc)\\<^sup>*", "unfolding is_scc_pointwise"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>scc \\<noteq> {} \\<and>\n             (\\<forall>u\\<in>scc.\n                 \\<forall>v\\<in>scc.\n                    (u, v) \\<in> (Restr E scc)\\<^sup>*) \\<and>\n             (\\<forall>u\\<in>scc.\n                 \\<forall>v.\n                    v \\<notin> scc \\<and>\n                    (u, v) \\<in> E\\<^sup>* \\<longrightarrow>\n                    (\\<forall>u'\\<in>scc. (v, u') \\<notin> E\\<^sup>*));\n     x \\<in> scc; y \\<in> scc\\<rbrakk>\n    \\<Longrightarrow> (x, y) \\<in> (Restr E scc)\\<^sup>*", "by blast"], ["", "definition scc_of :: \"('v\\<times>'v) set \\<Rightarrow> 'v \\<Rightarrow> 'v set\"\n  where\n  \"scc_of E v = (THE scc. is_scc E scc \\<and> v \\<in> scc)\""], ["", "lemma scc_of_is_scc[simp]:\n  \"is_scc E (scc_of E v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_scc E (scc_of E v)", "using is_scc_ex1[of E v]"], ["proof (prove)\nusing this:\n  \\<exists>!scc. is_scc E scc \\<and> v \\<in> scc\n\ngoal (1 subgoal):\n 1. is_scc E (scc_of E v)", "by (auto dest!: theI' simp: scc_of_def)"], ["", "lemma node_in_scc_of_node[simp]:\n  \"v \\<in> scc_of E v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> scc_of E v", "using is_scc_ex1[of E v]"], ["proof (prove)\nusing this:\n  \\<exists>!scc. is_scc E scc \\<and> v \\<in> scc\n\ngoal (1 subgoal):\n 1. v \\<in> scc_of E v", "by (auto dest!: theI' simp: scc_of_def)"], ["", "lemma scc_of_unique:\n  assumes \"w \\<in> scc_of E v\"\n  shows \"scc_of E v = scc_of E w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scc_of E v = scc_of E w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. scc_of E v = scc_of E w", "have \"is_scc E (scc_of E v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_scc E (scc_of E v)", "by simp"], ["proof (state)\nthis:\n  is_scc E (scc_of E v)\n\ngoal (1 subgoal):\n 1. scc_of E v = scc_of E w", "moreover"], ["proof (state)\nthis:\n  is_scc E (scc_of E v)\n\ngoal (1 subgoal):\n 1. scc_of E v = scc_of E w", "note assms"], ["proof (state)\nthis:\n  w \\<in> scc_of E v\n\ngoal (1 subgoal):\n 1. scc_of E v = scc_of E w", "moreover"], ["proof (state)\nthis:\n  w \\<in> scc_of E v\n\ngoal (1 subgoal):\n 1. scc_of E v = scc_of E w", "have \"is_scc E (scc_of E w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_scc E (scc_of E w)", "by simp"], ["proof (state)\nthis:\n  is_scc E (scc_of E w)\n\ngoal (1 subgoal):\n 1. scc_of E v = scc_of E w", "moreover"], ["proof (state)\nthis:\n  is_scc E (scc_of E w)\n\ngoal (1 subgoal):\n 1. scc_of E v = scc_of E w", "have \"w \\<in> scc_of E w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> scc_of E w", "by simp"], ["proof (state)\nthis:\n  w \\<in> scc_of E w\n\ngoal (1 subgoal):\n 1. scc_of E v = scc_of E w", "ultimately"], ["proof (chain)\npicking this:\n  is_scc E (scc_of E v)\n  w \\<in> scc_of E v\n  is_scc E (scc_of E w)\n  w \\<in> scc_of E w", "show ?thesis"], ["proof (prove)\nusing this:\n  is_scc E (scc_of E v)\n  w \\<in> scc_of E v\n  is_scc E (scc_of E w)\n  w \\<in> scc_of E w\n\ngoal (1 subgoal):\n 1. scc_of E v = scc_of E w", "using is_scc_unique"], ["proof (prove)\nusing this:\n  is_scc E (scc_of E v)\n  w \\<in> scc_of E v\n  is_scc E (scc_of E w)\n  w \\<in> scc_of E w\n  \\<lbrakk>is_scc ?E ?scc; is_scc ?E ?scc'; ?v \\<in> ?scc;\n   ?v \\<in> ?scc'\\<rbrakk>\n  \\<Longrightarrow> ?scc = ?scc'\n\ngoal (1 subgoal):\n 1. scc_of E v = scc_of E w", "by metis"], ["proof (state)\nthis:\n  scc_of E v = scc_of E w\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}