{"file_name": "/home/qj213/afp-2021-10-22/thys/CAVA_Automata/Automata.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/CAVA_Automata", "problem_names": ["lemma is_gb_graph: \"gb_graph G\"", "lemma \"is_acc_run r \\<equiv> is_run r \\<and> (\\<forall>A\\<in>F. \\<exists>\\<^sub>\\<infinity>i. r i \\<in> A)\"", "lemma acc_run_run: \"is_acc_run r \\<Longrightarrow> is_run r\"", "lemmas acc_run_reachable = run_reachable[OF acc_run_run]", "lemma acc_eq_limit: \n    assumes FIN: \"finite (range r)\"  \n    shows \"is_acc r \\<longleftrightarrow> (\\<forall>A\\<in>F. limit r \\<inter> A \\<noteq> {})\"", "lemma is_acc_run_limit_alt:\n    assumes \"finite (E\\<^sup>* `` V0)\"\n    shows \"is_acc_run r \\<longleftrightarrow> is_run r \\<and> (\\<forall>A\\<in>F. limit r \\<inter> A \\<noteq> {})\"", "lemma is_acc_suffix[simp]: \"is_acc (suffix i r) \\<longleftrightarrow> is_acc r\"", "lemma finite_V_Fe:\n    assumes \"finite V\" \"A \\<in> F\"\n    shows \"finite A\"", "lemma G'_gb_fields: \"gbg_F G' = { f`A | A. A\\<in>F }\"", "lemma acc_sim1: \"is_acc r \\<Longrightarrow> G'.is_acc (f o r)\"", "lemma acc_sim2: \n    assumes \"G'.is_acc r\" shows \"is_acc (fi o r)\"", "lemma acc_run_sim1: \"is_acc_run r \\<Longrightarrow> G'.is_acc_run (f o r)\"", "lemma acc_run_sim2: \"G'.is_acc_run r \\<Longrightarrow> is_acc_run (fi o r)\"", "lemma is_gba: \"gba G\"", "lemma acceptI[intro?]: \"\\<lbrakk>is_acc_run r; \\<And>i. L (r i) (w i)\\<rbrakk> \\<Longrightarrow> accept w\"", "lemma langI[intro?]: \"accept w \\<Longrightarrow> w\\<in>lang\"", "lemma G'_gba_fields: \"gba_L G' = (\\<lambda>q l. \n    if q\\<in>f`V then L (fi q) l else False)\"", "lemma L_sim1: \"\\<lbrakk>range r \\<subseteq> V; L (r i) l\\<rbrakk> \\<Longrightarrow> G'.L (f (r i)) l\"", "lemma L_sim2: \"\\<lbrakk> range r \\<subseteq> f`V; G'.L (r i) l \\<rbrakk> \\<Longrightarrow> L (fi (r i)) l\"", "lemma accept_eq[simp]: \"G'.accept = accept\"", "lemma lang_eq[simp]: \"G'.lang = lang\"", "lemma finite_G'_V:\n    assumes \"finite V\"\n    shows \"finite G'.V\"", "lemma gba_rename_correct:\n  fixes G :: \"('v,'l,'m) gba_rec_scheme\"\n  assumes \"gba G\" \n  assumes INJ: \"inj_on f (g_V G)\" \n  defines \"G' \\<equiv> gba_rename f G\"\n  shows \"gba G'\"\n  and \"finite (g_V G) \\<Longrightarrow> finite (g_V G')\"\n  and \"gba.accept G' = gba.accept G\"\n  and \"gba.lang G' = gba.lang G\"", "lemma is_b_graph: \"b_graph G\"", "lemma to_gbg_alt:\n    \"gbg.V T m = V\"\n    \"gbg.E T m = E\"\n    \"gbg.V0 T m = V0\"\n    \"gbg.F T m = (if F=UNIV then {} else {F})\"\n    \"gbg.is_run T m = is_run\"\n    \"gbg.is_acc T m = is_acc\"\n    \"gbg.is_acc_run T m = is_acc_run\"", "lemma is_ba: \"ba G\"", "lemma ba_acc_simps[simp]: \"gba.L T m = L\"", "lemma to_gba_alt_accept: \n    \"gba.accept T m = accept\"", "lemma to_gba_alt_lang: \n    \"gba.lang T m = lang\"", "lemmas to_gba_alt = to_gbg_alt to_gba_alt_accept to_gba_alt_lang", "lemma is_igb_graph: \"igb_graph G\"", "lemma acc_boundI[simp, intro]: \"x\\<in>acc q \\<Longrightarrow> x<num_acc\"", "lemma to_gbg_alt1: \n    \"gbg.E T m = E\"\n    \"gbg.V0 T m = V0\"\n    \"gbg.F T m = F\"", "lemma F_fin[simp,intro!]: \"finite F\"", "lemma is_run_gbg: \n    \"gbg.is_run T m = is_run\"", "lemma is_acc_gbg: \n    \"gbg.is_acc T m = is_acc\"", "lemma is_acc_run_gbg: \n    \"gbg.is_acc_run T m = is_acc_run\"", "lemmas to_gbg_alt = to_gbg_alt1 is_run_gbg is_acc_gbg is_acc_run_gbg", "lemma acc_limit_alt: \n    assumes FIN: \"finite (range r)\"\n    shows \"is_acc r \\<longleftrightarrow> (\\<forall>n<num_acc. limit r \\<inter> accn n \\<noteq> {})\"", "lemma acc_limit_alt': \n    \"finite (range r) \\<Longrightarrow> is_acc r \\<longleftrightarrow> (\\<Union>(acc ` limit r) = {0..<num_acc})\"", "lemma is_igba: \"igba G\"", "lemma to_gba_alt_L:\n    \"gba.L T m = L\"", "lemma accept_gba_alt: \"gba.accept T m = accept\"", "lemma lang_gba_alt: \"gba.lang T m = lang\"", "lemmas to_gba_alt = to_gbg_alt to_gba_alt_L accept_gba_alt lang_gba_alt", "lemma F_to_idx_correct:\n  shows \"F_to_idx F \\<le> SPEC (\\<lambda>(num_acc,acc). F = { {q. i\\<in>acc q} | i. i<num_acc } \n    \\<and> \\<Union>(range acc) \\<subseteq> {0..<num_acc})\"", "lemma mk_acc_impl_correct: \n  assumes F: \"(Flist',Flist)\\<in>Id\"\n  assumes FIN: \"\\<forall>A\\<in>set Flist. finite A\"\n  shows \"mk_acc_impl Flist' \\<le> \\<Down>Id (RETURN (\\<lambda>v. {i . i<length Flist \\<and> v\\<in>Flist!i}))\"", "lemma F_to_idx_refine: \n  assumes FIN: \"\\<forall>A\\<in>F. finite A\"\n  shows \"F_to_idx_impl F \\<le> \\<Down>Id (F_to_idx F)\"", "lemma (in gb_graph) gbg_to_idx_ext_correct:\n  assumes [simp, intro]: \"\\<And> A. A \\<in> F \\<Longrightarrow> finite A\"\n  shows \"gbg_to_idx_ext ecnv G \\<le> SPEC (\\<lambda>G'. \n    igb_graph.is_acc_run G' = is_acc_run \n  \\<and> g_V G' = V\n  \\<and> g_E G' = E\n  \\<and> g_V0 G' = V0\n  \\<and> igb_graph_rec.more G' = ecnv G\n  \\<and> igb_graph G'\n)\"", "lemma (in gba) gba_to_idx_ext_correct:\n  assumes [simp, intro]: \"\\<And> A. A \\<in> F \\<Longrightarrow> finite A\"\n  shows \"gba_to_idx_ext ecnv G \\<le> \n    SPEC (\\<lambda>G'.\n    igba.accept G' = accept \n  \\<and> g_V G' = V\n  \\<and> g_E G' = E\n  \\<and> g_V0 G' = V0\n  \\<and> igba_rec.more G' = ecnv G\n  \\<and> igba G')\"", "lemma degen_more[simp]: \"b_graph_rec.more (degeneralize_ext ecnv) = ecnv G\"", "lemma degen_invar: \"b_graph (degeneralize_ext ecnv)\"", "lemma degen_finite_reachable:\n    assumes [simp, intro]: \"finite (E\\<^sup>* `` V0)\"\n    shows \"finite ((g_E (degeneralize_ext ecnv))\\<^sup>* `` g_V0 (degeneralize_ext ecnv))\"", "lemma degen_is_run_sound: \n    \"degen.is_run T m r \\<Longrightarrow> is_run (fst o r)\"", "lemma degen_path_sound: \n    assumes \"path (degen.E T m) u p v\" \n    shows \"path E (fst u) (map fst p) (fst v)\"", "lemma degen_V0_sound: \n    assumes \"u \\<in> degen.V0 T m\" \n    shows \"fst u \\<in> V0\"", "lemma degen_visit_acc:\n    assumes \"path (degen.E T m) (q,n) p (q',n')\"\n    assumes \"n\\<noteq>n'\"\n    shows \"\\<exists>qa. (qa,n)\\<in>set p \\<and> n\\<in>acc qa\"", "lemma degen_run_complete0:\n    assumes [simp]: \"num_acc = 0\"\n    assumes R: \"is_run r\"\n    shows \"degen.is_run T m (\\<lambda>i. (r i,0))\"", "lemma degen_acc_run_complete0:\n    assumes [simp]: \"num_acc = 0\"\n    assumes R: \"is_acc_run r\"\n    shows \"degen.is_acc_run T m (\\<lambda>i. (r i,0))\"", "lemma degen_run_complete:\n    assumes [simp]: \"num_acc \\<noteq> 0\"\n    assumes R: \"is_run r\"\n    shows \"\\<exists>r'. degen.is_run T m r' \\<and> r = fst o r'\"", "lemma degen_run_bound:\n    assumes [simp]: \"num_acc \\<noteq> 0\"\n    assumes R: \"degen.is_run T m r\"\n    shows \"snd (r i) < num_acc\"", "lemma degen_acc_run_complete_aux1: \n    assumes NN0[simp]: \"num_acc \\<noteq> 0\"\n    assumes R: \"degen.is_run T m r\"\n    assumes EXJ: \"\\<exists>j\\<ge>i. n \\<in> acc (fst (r j))\"\n    assumes RI: \"r i = (q,n)\"\n    shows \"\\<exists>j\\<ge>i. \\<exists>q'. r j = (q',n) \\<and> n \\<in> acc q'\"", "lemma degen_acc_run_complete_aux1': \n    assumes NN0[simp]: \"num_acc \\<noteq> 0\"\n    assumes R: \"degen.is_run T m r\"\n    assumes ACC: \"\\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (fst (r i))\"\n    assumes RI: \"r i = (q,n)\"\n    shows \"\\<exists>j\\<ge>i. \\<exists>q'. r j = (q',n) \\<and> n \\<in> acc q'\"", "lemma degen_acc_run_complete_aux2:\n    assumes NN0[simp]: \"num_acc \\<noteq> 0\"\n    assumes R: \"degen.is_run T m r\"\n    assumes ACC: \"\\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (fst (r i))\"\n    assumes RI: \"r i = (q,n)\" and OFS: \"ofs<num_acc\"\n    shows \"\\<exists>j\\<ge>i. \\<exists>q'. \n      r j = (q',(n + ofs) mod num_acc) \\<and> (n + ofs) mod num_acc \\<in> acc q'\"", "lemma degen_acc_run_complete:\n    assumes AR: \"is_acc_run r\"\n    obtains r' \n    where \"degen.is_acc_run T m r'\" and \"r = fst o r'\"", "lemma degen_run_find_change:\n    assumes NN0[simp]: \"num_acc \\<noteq> 0\"\n    assumes R: \"degen.is_run T m r\"\n    assumes A: \"i\\<le>j\" \"r i = (q,n)\" \"r j = (q',n')\" \"n\\<noteq>n'\"\n    obtains k qk where \"i\\<le>k\" \"k<j\" \"r k = (qk,n)\" \"n \\<in> acc qk\"", "lemma degen_run_find_acc_aux:\n    assumes NN0[simp]: \"num_acc \\<noteq> 0\"\n    assumes AR: \"degen.is_acc_run T m r\"\n    assumes A: \"r i = (q,0)\" \"0 \\<in> acc q\" \"n<num_acc\"\n    shows \"\\<exists>j qj. i\\<le>j \\<and> r j = (qj,n) \\<and> n \\<in> acc qj\"", "lemma degen_acc_run_sound:\n    assumes A: \"degen.is_acc_run T m r\"\n    shows \"is_acc_run (fst o r)\"", "lemma degen_acc_run_iff:\n    \"is_acc_run r \\<longleftrightarrow> (\\<exists>r'. fst o r' = r \\<and> degen.is_acc_run T m r')\"", "lemma acceptI[intro?]: \"\\<lbrakk>is_run r; w = L o r\\<rbrakk> \\<Longrightarrow> accept w\"", "lemma langI[intro?]: \"accept w \\<Longrightarrow> w\\<in>lang\"", "lemma prod_invar: \"igb_graph prod\"", "lemma prod_finite_reachable:\n    assumes \"finite (igba.E\\<^sup>* `` igba.V0)\" \"finite (sa.E\\<^sup>* `` sa.V0)\"\n    shows \"finite ((g_E prod)\\<^sup>* `` g_V0 prod)\"", "lemma prod_fields:\n    \"prod.V = igba.V \\<times> sa.V\"\n    \"prod.E = { ((q,s),(q',s')). \n      igba.L q (sa.L s) \\<and> (q,q') \\<in> igba.E \\<and> (s,s') \\<in> sa.E }\"\n    \"prod.V0 = igba.V0 \\<times> sa.V0\"\n    \"prod.num_acc = igba.num_acc\"\n    \"prod.acc = (\\<lambda>(q,s). if s\\<in>sa.V then igba.acc q else {} )\"", "lemma prod_run: \"prod.is_run r \\<longleftrightarrow> \n      igba.is_run (fst o r) \n    \\<and> sa.is_run (snd o r)\n    \\<and> (\\<forall>i. igba.L (fst (r i)) (sa.L (snd (r i))))\" (is \"?L=?R\")", "lemma prod_acc:\n    assumes A: \"range (snd o r) \\<subseteq> sa.V\"\n    shows \"prod.is_acc r \\<longleftrightarrow> igba.is_acc (fst o r)\"", "lemma gsp_correct1: \n    assumes A: \"prod.is_acc_run r\"\n    shows \"sa.is_run (snd o r) \\<and> (sa.L o snd o r \\<in> igba.lang)\"", "lemma gsp_correct2: \n    assumes A: \"sa.is_run r\" \"sa.L o r \\<in> igba.lang\"\n    shows \"\\<exists>r'. r = snd o r' \\<and> prod.is_acc_run r'\""], "translations": [["", "lemma is_gb_graph: \"gb_graph G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gb_graph G", "by unfold_locales"], ["", "definition \n    is_acc :: \"'Q word \\<Rightarrow> bool\" where \"is_acc r \\<equiv> (\\<forall>A\\<in>F. \\<exists>\\<^sub>\\<infinity>i. r i \\<in> A)\""], ["", "definition \"is_acc_run r \\<equiv> is_run r \\<and> is_acc r\""], ["", "(* For presentation in paper *)"], ["", "lemma \"is_acc_run r \\<equiv> is_run r \\<and> (\\<forall>A\\<in>F. \\<exists>\\<^sub>\\<infinity>i. r i \\<in> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_acc_run r \\<equiv>\n    is_run r \\<and>\n    (\\<forall>A\\<in>F. \\<exists>\\<^sub>\\<infinity>i. r i \\<in> A)", "unfolding is_acc_run_def is_acc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_run r \\<and>\n    (\\<forall>A\\<in>F. \\<exists>\\<^sub>\\<infinity>i. r i \\<in> A) \\<equiv>\n    is_run r \\<and>\n    (\\<forall>A\\<in>F. \\<exists>\\<^sub>\\<infinity>i. r i \\<in> A)", "."], ["", "lemma acc_run_run: \"is_acc_run r \\<Longrightarrow> is_run r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_acc_run r \\<Longrightarrow> is_run r", "unfolding is_acc_run_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_run r \\<and> is_acc r \\<Longrightarrow> is_run r", "by simp"], ["", "lemmas acc_run_reachable = run_reachable[OF acc_run_run]"], ["", "lemma acc_eq_limit: \n    assumes FIN: \"finite (range r)\"  \n    shows \"is_acc r \\<longleftrightarrow> (\\<forall>A\\<in>F. limit r \\<inter> A \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_acc r = (\\<forall>A\\<in>F. limit r \\<inter> A \\<noteq> {})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. is_acc r \\<Longrightarrow>\n    \\<forall>A\\<in>F. limit r \\<inter> A \\<noteq> {}\n 2. \\<forall>A\\<in>F. limit r \\<inter> A \\<noteq> {} \\<Longrightarrow>\n    is_acc r", "assume \"\\<forall>A\\<in>F. limit r \\<inter> A \\<noteq> {}\""], ["proof (state)\nthis:\n  \\<forall>A\\<in>F. limit r \\<inter> A \\<noteq> {}\n\ngoal (2 subgoals):\n 1. is_acc r \\<Longrightarrow>\n    \\<forall>A\\<in>F. limit r \\<inter> A \\<noteq> {}\n 2. \\<forall>A\\<in>F. limit r \\<inter> A \\<noteq> {} \\<Longrightarrow>\n    is_acc r", "thus \"is_acc r\""], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>F. limit r \\<inter> A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. is_acc r", "unfolding is_acc_def"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>F. limit r \\<inter> A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>F. \\<exists>\\<^sub>\\<infinity>i. r i \\<in> A", "by (metis limit_inter_INF)"], ["proof (state)\nthis:\n  is_acc r\n\ngoal (1 subgoal):\n 1. is_acc r \\<Longrightarrow>\n    \\<forall>A\\<in>F. limit r \\<inter> A \\<noteq> {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. is_acc r \\<Longrightarrow>\n    \\<forall>A\\<in>F. limit r \\<inter> A \\<noteq> {}", "from FIN"], ["proof (chain)\npicking this:\n  finite (range r)", "have FIN': \"\\<And>A. finite (A \\<inter> range r)\""], ["proof (prove)\nusing this:\n  finite (range r)\n\ngoal (1 subgoal):\n 1. \\<And>A. finite (A \\<inter> range r)", "by simp"], ["proof (state)\nthis:\n  finite (?A \\<inter> range r)\n\ngoal (1 subgoal):\n 1. is_acc r \\<Longrightarrow>\n    \\<forall>A\\<in>F. limit r \\<inter> A \\<noteq> {}", "assume \"is_acc r\""], ["proof (state)\nthis:\n  is_acc r\n\ngoal (1 subgoal):\n 1. is_acc r \\<Longrightarrow>\n    \\<forall>A\\<in>F. limit r \\<inter> A \\<noteq> {}", "hence AUX: \"\\<forall>A\\<in>F. \\<exists>\\<^sub>\\<infinity>i. r i \\<in> (A \\<inter> range r)\""], ["proof (prove)\nusing this:\n  is_acc r\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>F.\n       \\<exists>\\<^sub>\\<infinity>i. r i \\<in> A \\<inter> range r", "unfolding is_acc_def"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>F. \\<exists>\\<^sub>\\<infinity>i. r i \\<in> A\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>F.\n       \\<exists>\\<^sub>\\<infinity>i. r i \\<in> A \\<inter> range r", "by auto"], ["proof (state)\nthis:\n  \\<forall>A\\<in>F.\n     \\<exists>\\<^sub>\\<infinity>i. r i \\<in> A \\<inter> range r\n\ngoal (1 subgoal):\n 1. is_acc r \\<Longrightarrow>\n    \\<forall>A\\<in>F. limit r \\<inter> A \\<noteq> {}", "have \"\\<forall>A\\<in>F. limit r \\<inter> (A \\<inter> range r) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>F. limit r \\<inter> (A \\<inter> range r) \\<noteq> {}", "apply (rule ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> F \\<Longrightarrow>\n       limit r \\<inter> (A \\<inter> range r) \\<noteq> {}", "apply (drule bspec[OF AUX])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       \\<exists>\\<^sub>\\<infinity>i.\n          r i \\<in> A \\<inter> range r \\<Longrightarrow>\n       limit r \\<inter> (A \\<inter> range r) \\<noteq> {}", "apply (subst (asm) fin_ex_inf_eq_limit[OF FIN'])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       limit r \\<inter> (A \\<inter> range r) \\<noteq> {} \\<Longrightarrow>\n       limit r \\<inter> (A \\<inter> range r) \\<noteq> {}", "."], ["proof (state)\nthis:\n  \\<forall>A\\<in>F. limit r \\<inter> (A \\<inter> range r) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. is_acc r \\<Longrightarrow>\n    \\<forall>A\\<in>F. limit r \\<inter> A \\<noteq> {}", "thus \"\\<forall>A\\<in>F. limit r \\<inter> A \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>F. limit r \\<inter> (A \\<inter> range r) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>F. limit r \\<inter> A \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  \\<forall>A\\<in>F. limit r \\<inter> A \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_acc_run_limit_alt:\n    assumes \"finite (E\\<^sup>* `` V0)\"\n    shows \"is_acc_run r \\<longleftrightarrow> is_run r \\<and> (\\<forall>A\\<in>F. limit r \\<inter> A \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_acc_run r =\n    (is_run r \\<and> (\\<forall>A\\<in>F. limit r \\<inter> A \\<noteq> {}))", "using assms acc_eq_limit[symmetric]"], ["proof (prove)\nusing this:\n  finite reachable\n  finite (range ?r) \\<Longrightarrow>\n  (\\<forall>A\\<in>F. limit ?r \\<inter> A \\<noteq> {}) = is_acc ?r\n\ngoal (1 subgoal):\n 1. is_acc_run r =\n    (is_run r \\<and> (\\<forall>A\\<in>F. limit r \\<inter> A \\<noteq> {}))", "unfolding is_acc_run_def"], ["proof (prove)\nusing this:\n  finite reachable\n  finite (range ?r) \\<Longrightarrow>\n  (\\<forall>A\\<in>F. limit ?r \\<inter> A \\<noteq> {}) = is_acc ?r\n\ngoal (1 subgoal):\n 1. (is_run r \\<and> is_acc r) =\n    (is_run r \\<and> (\\<forall>A\\<in>F. limit r \\<inter> A \\<noteq> {}))", "by (auto dest: run_reachable finite_subset)"], ["", "lemma is_acc_suffix[simp]: \"is_acc (suffix i r) \\<longleftrightarrow> is_acc r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_acc (suffix i r) = is_acc r", "unfolding is_acc_def suffix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>A\\<in>F. \\<exists>\\<^sub>\\<infinity>ia. r (i + ia) \\<in> A) =\n    (\\<forall>A\\<in>F. \\<exists>\\<^sub>\\<infinity>i. r i \\<in> A)", "apply (clarsimp simp: INFM_nat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>A\\<in>F. \\<forall>m. \\<exists>ia>m. r (i + ia) \\<in> A) =\n    (\\<forall>A\\<in>F. \\<forall>m. \\<exists>i>m. r i \\<in> A)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>A\\<in>F.\n       \\<forall>m. \\<exists>ia>m. r (i + ia) \\<in> A \\<Longrightarrow>\n    \\<forall>A\\<in>F. \\<forall>m. \\<exists>i>m. r i \\<in> A\n 2. \\<forall>A\\<in>F.\n       \\<forall>m. \\<exists>i>m. r i \\<in> A \\<Longrightarrow>\n    \\<forall>A\\<in>F. \\<forall>m. \\<exists>ia>m. r (i + ia) \\<in> A", "apply (metis trans_less_add2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>F.\n       \\<forall>m. \\<exists>i>m. r i \\<in> A \\<Longrightarrow>\n    \\<forall>A\\<in>F. \\<forall>m. \\<exists>ia>m. r (i + ia) \\<in> A", "by (metis add_lessD1 less_imp_add_positive nat_add_left_cancel_less)"], ["", "lemma finite_V_Fe:\n    assumes \"finite V\" \"A \\<in> F\"\n    shows \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A", "using assms"], ["proof (prove)\nusing this:\n  finite V\n  A \\<in> F\n\ngoal (1 subgoal):\n 1. finite A", "by (metis Pow_iff infinite_super rev_subsetD F_ss)"], ["", "end"], ["", "definition \"gb_rename_ecnv ecnv f G \\<equiv> \\<lparr>\n  gbg_F = { f`A | A. A\\<in>gbg_F G }, \\<dots> = ecnv G\n\\<rparr>\""], ["", "abbreviation \"gb_rename_ext ecnv f \\<equiv> fr_rename_ext (gb_rename_ecnv ecnv f) f\""], ["", "locale gb_rename_precond =\n  gb_graph G +\n  g_rename_precond G f \"gb_rename_ecnv ecnv f\"\n  for G :: \"('u,'more) gb_graph_rec_scheme\"\n  and f :: \"'u \\<Rightarrow> 'v\" and ecnv\nbegin"], ["", "lemma G'_gb_fields: \"gbg_F G' = { f`A | A. A\\<in>F }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gbg_F G' = {f ` A |A. A \\<in> F}", "unfolding gb_rename_ecnv_def fr_rename_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gbg_F\n     \\<lparr>g_V = f ` V, g_E = rename_E f E, g_V0 = f ` V0,\n        gbg_F = {f ` A |A. A \\<in> F}, \\<dots> = ecnv G\\<rparr> =\n    {f ` A |A. A \\<in> F}", "by simp"], ["", "sublocale G': gb_graph G'"], ["proof (prove)\ngoal (1 subgoal):\n 1. gb_graph G'", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite (gbg_F G')\n 2. gbg_F G' \\<subseteq> Pow G'.V", "apply (simp_all add: G'_fields G'_gb_fields)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {f ` A |A. A \\<in> F} \\<subseteq> Pow (f ` V)", "using F_ss"], ["proof (prove)\nusing this:\n  F \\<subseteq> Pow V\n\ngoal (1 subgoal):\n 1. {f ` A |A. A \\<in> F} \\<subseteq> Pow (f ` V)", "by auto"], ["", "lemma acc_sim1: \"is_acc r \\<Longrightarrow> G'.is_acc (f o r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_acc r \\<Longrightarrow> G'.is_acc (f \\<circ> r)", "unfolding is_acc_def G'.is_acc_def G'_gb_fields"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>F.\n       \\<exists>\\<^sub>\\<infinity>i. r i \\<in> A \\<Longrightarrow>\n    \\<forall>A\\<in>{f ` A |A. A \\<in> F}.\n       \\<exists>\\<^sub>\\<infinity>i. (f \\<circ> r) i \\<in> A", "by (fastforce intro: imageI simp: INFM_nat)"], ["", "lemma acc_sim2: \n    assumes \"G'.is_acc r\" shows \"is_acc (fi o r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_acc (fi \\<circ> r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_acc (fi \\<circ> r)", "from assms"], ["proof (chain)\npicking this:\n  G'.is_acc r", "have 1: \"\\<And>A m. A \\<in> gbg_F G \\<Longrightarrow> \\<exists>i>m. r i \\<in> f`A\""], ["proof (prove)\nusing this:\n  G'.is_acc r\n\ngoal (1 subgoal):\n 1. \\<And>A m. A \\<in> F \\<Longrightarrow> \\<exists>i>m. r i \\<in> f ` A", "unfolding G'.is_acc_def G'_gb_fields"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>{f ` A |A. A \\<in> F}.\n     \\<exists>\\<^sub>\\<infinity>i. r i \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>A m. A \\<in> F \\<Longrightarrow> \\<exists>i>m. r i \\<in> f ` A", "by (auto simp: INFM_nat)"], ["proof (state)\nthis:\n  ?A \\<in> F \\<Longrightarrow> \\<exists>i>?m. r i \\<in> f ` ?A\n\ngoal (1 subgoal):\n 1. is_acc (fi \\<circ> r)", "{"], ["proof (state)\nthis:\n  ?A \\<in> F \\<Longrightarrow> \\<exists>i>?m. r i \\<in> f ` ?A\n\ngoal (1 subgoal):\n 1. is_acc (fi \\<circ> r)", "fix A m"], ["proof (state)\ngoal (1 subgoal):\n 1. is_acc (fi \\<circ> r)", "assume 2: \"A \\<in> gbg_F G\""], ["proof (state)\nthis:\n  A \\<in> F\n\ngoal (1 subgoal):\n 1. is_acc (fi \\<circ> r)", "from 1[OF this, of m]"], ["proof (chain)\npicking this:\n  \\<exists>i>m. r i \\<in> f ` A", "have \"\\<exists>i>m. fi (r i) \\<in> A\""], ["proof (prove)\nusing this:\n  \\<exists>i>m. r i \\<in> f ` A\n\ngoal (1 subgoal):\n 1. \\<exists>i>m. fi (r i) \\<in> A", "using F_ss"], ["proof (prove)\nusing this:\n  \\<exists>i>m. r i \\<in> f ` A\n  F \\<subseteq> Pow V\n\ngoal (1 subgoal):\n 1. \\<exists>i>m. fi (r i) \\<in> A", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>F \\<subseteq> Pow V; m < i; r i = f x; x \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i>m. fi (r i) \\<in> A", "by (metis Pow_iff 2 fi_f in_mono)"], ["proof (state)\nthis:\n  \\<exists>i>m. fi (r i) \\<in> A\n\ngoal (1 subgoal):\n 1. is_acc (fi \\<circ> r)", "}"], ["proof (state)\nthis:\n  ?A2 \\<in> F \\<Longrightarrow> \\<exists>i>?m2. fi (r i) \\<in> ?A2\n\ngoal (1 subgoal):\n 1. is_acc (fi \\<circ> r)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?A2 \\<in> F \\<Longrightarrow> \\<exists>i>?m2. fi (r i) \\<in> ?A2\n\ngoal (1 subgoal):\n 1. is_acc (fi \\<circ> r)", "unfolding is_acc_def"], ["proof (prove)\nusing this:\n  ?A2 \\<in> F \\<Longrightarrow> \\<exists>i>?m2. fi (r i) \\<in> ?A2\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>F. \\<exists>\\<^sub>\\<infinity>i. (fi \\<circ> r) i \\<in> A", "by (auto simp: INFM_nat)"], ["proof (state)\nthis:\n  is_acc (fi \\<circ> r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma acc_run_sim1: \"is_acc_run r \\<Longrightarrow> G'.is_acc_run (f o r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_acc_run r \\<Longrightarrow> G'.is_acc_run (f \\<circ> r)", "using acc_sim1 run_sim1"], ["proof (prove)\nusing this:\n  is_acc ?r \\<Longrightarrow> G'.is_acc (f \\<circ> ?r)\n  is_run ?r \\<Longrightarrow> G'.is_run (f \\<circ> ?r)\n\ngoal (1 subgoal):\n 1. is_acc_run r \\<Longrightarrow> G'.is_acc_run (f \\<circ> r)", "unfolding G'.is_acc_run_def is_acc_run_def"], ["proof (prove)\nusing this:\n  is_acc ?r \\<Longrightarrow> G'.is_acc (f \\<circ> ?r)\n  is_run ?r \\<Longrightarrow> G'.is_run (f \\<circ> ?r)\n\ngoal (1 subgoal):\n 1. is_run r \\<and> is_acc r \\<Longrightarrow>\n    G'.is_run (f \\<circ> r) \\<and> G'.is_acc (f \\<circ> r)", "by auto"], ["", "lemma acc_run_sim2: \"G'.is_acc_run r \\<Longrightarrow> is_acc_run (fi o r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G'.is_acc_run r \\<Longrightarrow> is_acc_run (fi \\<circ> r)", "using acc_sim2 run_sim2"], ["proof (prove)\nusing this:\n  G'.is_acc ?r \\<Longrightarrow> is_acc (fi \\<circ> ?r)\n  G'.is_run ?r \\<Longrightarrow> is_run (fi \\<circ> ?r)\n\ngoal (1 subgoal):\n 1. G'.is_acc_run r \\<Longrightarrow> is_acc_run (fi \\<circ> r)", "unfolding G'.is_acc_run_def is_acc_run_def"], ["proof (prove)\nusing this:\n  G'.is_acc ?r \\<Longrightarrow> is_acc (fi \\<circ> ?r)\n  G'.is_run ?r \\<Longrightarrow> is_run (fi \\<circ> ?r)\n\ngoal (1 subgoal):\n 1. G'.is_run r \\<and> G'.is_acc r \\<Longrightarrow>\n    is_run (fi \\<circ> r) \\<and> is_acc (fi \\<circ> r)", "by auto"], ["", "end"], ["", "subsection \"Generalized Buchi Automata\""], ["", "text \\<open>\n  A GBA is obtained from a GBG by adding a labeling function, that associates\n  each state with a set of labels. A word is accepted if there is an\n  accepting run that can be labeld with this word.\n\\<close>"], ["", "record ('Q,'L) gba_rec = \"'Q gb_graph_rec\" +\n  gba_L :: \"'Q \\<Rightarrow> 'L \\<Rightarrow> bool\""], ["", "locale gba =\n  gb_graph G\n  for G :: \"('Q,'L,'more) gba_rec_scheme\" +\n  assumes L_ss: \"gba_L G q l \\<Longrightarrow> q \\<in> V\"\nbegin"], ["", "abbreviation \"L \\<equiv> gba_L G\""], ["", "lemma is_gba: \"gba G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gba G", "by unfold_locales"], ["", "definition \"accept w \\<equiv> \\<exists>r. is_acc_run r \\<and> (\\<forall>i. L (r i) (w i))\""], ["", "lemma acceptI[intro?]: \"\\<lbrakk>is_acc_run r; \\<And>i. L (r i) (w i)\\<rbrakk> \\<Longrightarrow> accept w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_acc_run r; \\<And>i. L (r i) (w i)\\<rbrakk>\n    \\<Longrightarrow> accept w", "by (auto simp: accept_def)"], ["", "definition \"lang \\<equiv> Collect (accept)\""], ["", "lemma langI[intro?]: \"accept w \\<Longrightarrow> w\\<in>lang\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accept w \\<Longrightarrow> w \\<in> lang", "by (auto simp: lang_def)"], ["", "end"], ["", "definition \"gba_rename_ecnv ecnv f G \\<equiv> \\<lparr>\n  gba_L = \\<lambda>q l. \n    if q\\<in>f`g_V G then \n      gba_L G (the_inv_into (g_V G) f q) l\n    else\n      False, \n  \\<dots> = ecnv G\n\\<rparr>\""], ["", "abbreviation \"gba_rename_ext ecnv f \\<equiv> gb_rename_ext (gba_rename_ecnv ecnv f) f\""], ["", "locale gba_rename_precond =  \n  gb_rename_precond G f \"gba_rename_ecnv ecnv f\" + gba G\n  for G :: \"('u,'L,'more) gba_rec_scheme\"\n  and f :: \"'u \\<Rightarrow> 'v\" and ecnv\nbegin"], ["", "lemma G'_gba_fields: \"gba_L G' = (\\<lambda>q l. \n    if q\\<in>f`V then L (fi q) l else False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gba_L G' = (\\<lambda>q l. if q \\<in> f ` V then L (fi q) l else False)", "unfolding gb_rename_ecnv_def gba_rename_ecnv_def fr_rename_ext_def fi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. gba_L\n     \\<lparr>g_V = f ` V, g_E = rename_E f E, g_V0 = f ` V0,\n        gbg_F = {f ` A |A. A \\<in> F},\n        gba_L =\n          \\<lambda>q l.\n             if q \\<in> f ` V then L (the_inv_into V f q) l else False,\n        \\<dots> = ecnv G\\<rparr> =\n    (\\<lambda>q l.\n        if q \\<in> f ` V then L (the_inv_into V f q) l else False)", "by simp"], ["", "sublocale G': gba G'"], ["proof (prove)\ngoal (1 subgoal):\n 1. gba G'", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q l. gba_L G' q l \\<Longrightarrow> q \\<in> G'.V", "apply (auto simp add: G'_gba_fields G'_fields split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma L_sim1: \"\\<lbrakk>range r \\<subseteq> V; L (r i) l\\<rbrakk> \\<Longrightarrow> G'.L (f (r i)) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>range r \\<subseteq> V; L (r i) l\\<rbrakk>\n    \\<Longrightarrow> G'.L (f (r i)) l", "by (auto simp: G'_gba_fields fi_def[symmetric] fi_f \n      dest: inj_onD[OF INJ]\n      dest!: rev_subsetD[OF rangeI[of _ i]])"], ["", "lemma L_sim2: \"\\<lbrakk> range r \\<subseteq> f`V; G'.L (r i) l \\<rbrakk> \\<Longrightarrow> L (fi (r i)) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>range r \\<subseteq> f ` V; G'.L (r i) l\\<rbrakk>\n    \\<Longrightarrow> L (fi (r i)) l", "by (auto\n      simp: G'_gba_fields fi_def[symmetric] f_fi\n      dest!: rev_subsetD[OF rangeI[of _ i]])"], ["", "lemma accept_eq[simp]: \"G'.accept = accept\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G'.accept = accept", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. G'.accept x = accept x", "unfolding accept_def G'.accept_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<exists>r. G'.is_acc_run r \\<and> (\\<forall>i. G'.L (r i) (x i))) =\n       (\\<exists>r. is_acc_run r \\<and> (\\<forall>i. L (r i) (x i)))", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x r.\n       \\<lbrakk>G'.is_acc_run r; \\<forall>i. G'.L (r i) (x i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            is_acc_run r \\<and> (\\<forall>i. L (r i) (x i))\n 2. \\<And>x r.\n       \\<lbrakk>is_acc_run r; \\<forall>i. L (r i) (x i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            G'.is_acc_run r \\<and>\n                            (\\<forall>i. G'.L (r i) (x i))", "fix w r"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x r.\n       \\<lbrakk>G'.is_acc_run r; \\<forall>i. G'.L (r i) (x i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            is_acc_run r \\<and> (\\<forall>i. L (r i) (x i))\n 2. \\<And>x r.\n       \\<lbrakk>is_acc_run r; \\<forall>i. L (r i) (x i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            G'.is_acc_run r \\<and>\n                            (\\<forall>i. G'.L (r i) (x i))", "assume R: \"G'.is_acc_run r\""], ["proof (state)\nthis:\n  G'.is_acc_run r\n\ngoal (2 subgoals):\n 1. \\<And>x r.\n       \\<lbrakk>G'.is_acc_run r; \\<forall>i. G'.L (r i) (x i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            is_acc_run r \\<and> (\\<forall>i. L (r i) (x i))\n 2. \\<And>x r.\n       \\<lbrakk>is_acc_run r; \\<forall>i. L (r i) (x i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            G'.is_acc_run r \\<and>\n                            (\\<forall>i. G'.L (r i) (x i))", "assume L: \"\\<forall>i. G'.L (r i) (w i)\""], ["proof (state)\nthis:\n  \\<forall>i. G'.L (r i) (w i)\n\ngoal (2 subgoals):\n 1. \\<And>x r.\n       \\<lbrakk>G'.is_acc_run r; \\<forall>i. G'.L (r i) (x i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            is_acc_run r \\<and> (\\<forall>i. L (r i) (x i))\n 2. \\<And>x r.\n       \\<lbrakk>is_acc_run r; \\<forall>i. L (r i) (x i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            G'.is_acc_run r \\<and>\n                            (\\<forall>i. G'.L (r i) (x i))", "from R"], ["proof (chain)\npicking this:\n  G'.is_acc_run r", "have RAN: \"range r \\<subseteq> f`V\""], ["proof (prove)\nusing this:\n  G'.is_acc_run r\n\ngoal (1 subgoal):\n 1. range r \\<subseteq> f ` V", "using G'.run_reachable[OF G'.acc_run_run[OF R]] G'.reachable_V"], ["proof (prove)\nusing this:\n  G'.is_acc_run r\n  range r \\<subseteq> G'.reachable\n  G'.reachable \\<subseteq> G'.V\n\ngoal (1 subgoal):\n 1. range r \\<subseteq> f ` V", "unfolding G'_fields"], ["proof (prove)\nusing this:\n  G'.is_acc_run r\n  range r \\<subseteq> (rename_E f E)\\<^sup>* `` f ` V0\n  (rename_E f E)\\<^sup>* `` f ` V0 \\<subseteq> f ` V\n\ngoal (1 subgoal):\n 1. range r \\<subseteq> f ` V", "by simp"], ["proof (state)\nthis:\n  range r \\<subseteq> f ` V\n\ngoal (2 subgoals):\n 1. \\<And>x r.\n       \\<lbrakk>G'.is_acc_run r; \\<forall>i. G'.L (r i) (x i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            is_acc_run r \\<and> (\\<forall>i. L (r i) (x i))\n 2. \\<And>x r.\n       \\<lbrakk>is_acc_run r; \\<forall>i. L (r i) (x i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            G'.is_acc_run r \\<and>\n                            (\\<forall>i. G'.L (r i) (x i))", "from L"], ["proof (chain)\npicking this:\n  \\<forall>i. G'.L (r i) (w i)", "show \"\\<exists>r. is_acc_run r \\<and> (\\<forall>i. L (r i) (w i))\""], ["proof (prove)\nusing this:\n  \\<forall>i. G'.L (r i) (w i)\n\ngoal (1 subgoal):\n 1. \\<exists>r. is_acc_run r \\<and> (\\<forall>i. L (r i) (w i))", "using acc_run_sim2[OF R] L_sim2[OF RAN]"], ["proof (prove)\nusing this:\n  \\<forall>i. G'.L (r i) (w i)\n  is_acc_run (fi \\<circ> r)\n  G'.L (r ?i) ?l \\<Longrightarrow> L (fi (r ?i)) ?l\n\ngoal (1 subgoal):\n 1. \\<exists>r. is_acc_run r \\<and> (\\<forall>i. L (r i) (w i))", "by auto"], ["proof (state)\nthis:\n  \\<exists>r. is_acc_run r \\<and> (\\<forall>i. L (r i) (w i))\n\ngoal (1 subgoal):\n 1. \\<And>x r.\n       \\<lbrakk>is_acc_run r; \\<forall>i. L (r i) (x i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            G'.is_acc_run r \\<and>\n                            (\\<forall>i. G'.L (r i) (x i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x r.\n       \\<lbrakk>is_acc_run r; \\<forall>i. L (r i) (x i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            G'.is_acc_run r \\<and>\n                            (\\<forall>i. G'.L (r i) (x i))", "fix w r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x r.\n       \\<lbrakk>is_acc_run r; \\<forall>i. L (r i) (x i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            G'.is_acc_run r \\<and>\n                            (\\<forall>i. G'.L (r i) (x i))", "assume R: \"is_acc_run r\""], ["proof (state)\nthis:\n  is_acc_run r\n\ngoal (1 subgoal):\n 1. \\<And>x r.\n       \\<lbrakk>is_acc_run r; \\<forall>i. L (r i) (x i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            G'.is_acc_run r \\<and>\n                            (\\<forall>i. G'.L (r i) (x i))", "assume L: \"\\<forall>i. L (r i) (w i)\""], ["proof (state)\nthis:\n  \\<forall>i. L (r i) (w i)\n\ngoal (1 subgoal):\n 1. \\<And>x r.\n       \\<lbrakk>is_acc_run r; \\<forall>i. L (r i) (x i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            G'.is_acc_run r \\<and>\n                            (\\<forall>i. G'.L (r i) (x i))", "from R"], ["proof (chain)\npicking this:\n  is_acc_run r", "have RAN: \"range r \\<subseteq> V\""], ["proof (prove)\nusing this:\n  is_acc_run r\n\ngoal (1 subgoal):\n 1. range r \\<subseteq> V", "using run_reachable[OF acc_run_run[OF R]] reachable_V"], ["proof (prove)\nusing this:\n  is_acc_run r\n  range r \\<subseteq> reachable\n  reachable \\<subseteq> V\n\ngoal (1 subgoal):\n 1. range r \\<subseteq> V", "by simp"], ["proof (state)\nthis:\n  range r \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<And>x r.\n       \\<lbrakk>is_acc_run r; \\<forall>i. L (r i) (x i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            G'.is_acc_run r \\<and>\n                            (\\<forall>i. G'.L (r i) (x i))", "from L"], ["proof (chain)\npicking this:\n  \\<forall>i. L (r i) (w i)", "show \"\\<exists>r. \n        G'.is_acc_run r \n      \\<and> (\\<forall>i. G'.L (r i) (w i))\""], ["proof (prove)\nusing this:\n  \\<forall>i. L (r i) (w i)\n\ngoal (1 subgoal):\n 1. \\<exists>r. G'.is_acc_run r \\<and> (\\<forall>i. G'.L (r i) (w i))", "using acc_run_sim1[OF R] L_sim1[OF RAN]"], ["proof (prove)\nusing this:\n  \\<forall>i. L (r i) (w i)\n  G'.is_acc_run (f \\<circ> r)\n  L (r ?i) ?l \\<Longrightarrow> G'.L (f (r ?i)) ?l\n\ngoal (1 subgoal):\n 1. \\<exists>r. G'.is_acc_run r \\<and> (\\<forall>i. G'.L (r i) (w i))", "by auto"], ["proof (state)\nthis:\n  \\<exists>r. G'.is_acc_run r \\<and> (\\<forall>i. G'.L (r i) (w i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lang_eq[simp]: \"G'.lang = lang\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G'.lang = lang", "unfolding G'.lang_def lang_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect G'.accept = Collect accept", "by simp"], ["", "lemma finite_G'_V:\n    assumes \"finite V\"\n    shows \"finite G'.V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite G'.V", "using assms"], ["proof (prove)\nusing this:\n  finite V\n\ngoal (1 subgoal):\n 1. finite G'.V", "by (auto simp add: G'_gba_fields G'_fields split: if_split_asm)"], ["", "end"], ["", "abbreviation \"gba_rename \\<equiv> gba_rename_ext (\\<lambda>_. ())\""], ["", "lemma gba_rename_correct:\n  fixes G :: \"('v,'l,'m) gba_rec_scheme\"\n  assumes \"gba G\" \n  assumes INJ: \"inj_on f (g_V G)\" \n  defines \"G' \\<equiv> gba_rename f G\"\n  shows \"gba G'\"\n  and \"finite (g_V G) \\<Longrightarrow> finite (g_V G')\"\n  and \"gba.accept G' = gba.accept G\"\n  and \"gba.lang G' = gba.lang G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gba G' &&& (finite (g_V G) \\<Longrightarrow> finite (g_V G'))) &&&\n    gba.accept G' = gba.accept G &&& gba.lang G' = gba.lang G", "unfolding G'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (gba (gba_rename f G) &&&\n     (finite (g_V G) \\<Longrightarrow> finite (g_V (gba_rename f G)))) &&&\n    gba.accept (gba_rename f G) = gba.accept G &&&\n    gba.lang (gba_rename f G) = gba.lang G", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. gba (gba_rename f G)\n 2. finite (g_V G) \\<Longrightarrow> finite (g_V (gba_rename f G))\n 3. gba.accept (gba_rename f G) = gba.accept G\n 4. gba.lang (gba_rename f G) = gba.lang G", "let ?G' = \"gba_rename f G\""], ["proof (state)\ngoal (4 subgoals):\n 1. gba (gba_rename f G)\n 2. finite (g_V G) \\<Longrightarrow> finite (g_V (gba_rename f G))\n 3. gba.accept (gba_rename f G) = gba.accept G\n 4. gba.lang (gba_rename f G) = gba.lang G", "interpret gba G"], ["proof (prove)\ngoal (1 subgoal):\n 1. gba G", "by fact"], ["proof (state)\ngoal (4 subgoals):\n 1. gba (gba_rename f G)\n 2. finite V \\<Longrightarrow> finite (g_V (gba_rename f G))\n 3. gba.accept (gba_rename f G) = accept\n 4. gba.lang (gba_rename f G) = lang", "from INJ"], ["proof (chain)\npicking this:\n  inj_on f V", "interpret gba_rename_precond G f \"\\<lambda>_. ()\""], ["proof (prove)\nusing this:\n  inj_on f V\n\ngoal (1 subgoal):\n 1. gba_rename_precond G f", "by unfold_locales simp_all"], ["proof (state)\ngoal (4 subgoals):\n 1. gba G'\n 2. finite V \\<Longrightarrow> finite G'.V\n 3. G'.accept = accept\n 4. G'.lang = lang", "show \"gba ?G'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gba G'", "by (rule G'.is_gba)"], ["proof (state)\nthis:\n  gba G'\n\ngoal (3 subgoals):\n 1. finite V \\<Longrightarrow> finite G'.V\n 2. G'.accept = accept\n 3. G'.lang = lang", "show \"finite (g_V G) \\<Longrightarrow> finite (g_V ?G')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite V \\<Longrightarrow> finite G'.V", "by (fact finite_G'_V)"], ["proof (state)\nthis:\n  finite V \\<Longrightarrow> finite G'.V\n\ngoal (2 subgoals):\n 1. G'.accept = accept\n 2. G'.lang = lang", "show \"G'.accept = accept\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G'.accept = accept", "by simp"], ["proof (state)\nthis:\n  G'.accept = accept\n\ngoal (1 subgoal):\n 1. G'.lang = lang", "show \"G'.lang = lang\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G'.lang = lang", "by simp"], ["proof (state)\nthis:\n  G'.lang = lang\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Buchi Graphs\""], ["", "text \\<open>A Buchi graph has exactly one acceptance class\\<close>"], ["", "record 'Q b_graph_rec = \"'Q graph_rec\" +\n  bg_F :: \"'Q set\""], ["", "locale b_graph =\n  graph G \n  for G :: \"('Q,'more) b_graph_rec_scheme\"\n  +\n  assumes F_ss: \"bg_F G \\<subseteq> V\"\nbegin"], ["", "abbreviation F where \"F \\<equiv> bg_F G\""], ["", "lemma is_b_graph: \"b_graph G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b_graph G", "by unfold_locales"], ["", "definition \"to_gbg_ext m \n    \\<equiv> \\<lparr> g_V = V, \n        g_E=E, \n        g_V0=V0, \n        gbg_F = if F=UNIV then {} else {F}, \n        \\<dots> = m \\<rparr>\""], ["", "abbreviation \"to_gbg \\<equiv> to_gbg_ext ()\""], ["", "sublocale gbg: gb_graph \"to_gbg_ext m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gb_graph (to_gbg_ext m)", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. g_V0 (to_gbg_ext m) \\<subseteq> g_V (to_gbg_ext m)\n 2. g_E (to_gbg_ext m)\n    \\<subseteq> g_V (to_gbg_ext m) \\<times> g_V (to_gbg_ext m)\n 3. finite (gbg_F (to_gbg_ext m))\n 4. gbg_F (to_gbg_ext m) \\<subseteq> Pow (g_V (to_gbg_ext m))", "using V0_ss E_ss F_ss"], ["proof (prove)\nusing this:\n  V0 \\<subseteq> V\n  E \\<subseteq> V \\<times> V\n  F \\<subseteq> V\n\ngoal (4 subgoals):\n 1. g_V0 (to_gbg_ext m) \\<subseteq> g_V (to_gbg_ext m)\n 2. g_E (to_gbg_ext m)\n    \\<subseteq> g_V (to_gbg_ext m) \\<times> g_V (to_gbg_ext m)\n 3. finite (gbg_F (to_gbg_ext m))\n 4. gbg_F (to_gbg_ext m) \\<subseteq> Pow (g_V (to_gbg_ext m))", "apply (auto simp: to_gbg_ext_def split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition is_acc :: \"'Q word \\<Rightarrow> bool\" where \"is_acc r \\<equiv> (\\<exists>\\<^sub>\\<infinity>i. r i \\<in> F)\""], ["", "definition is_acc_run where \"is_acc_run r \\<equiv> is_run r \\<and> is_acc r\""], ["", "lemma to_gbg_alt:\n    \"gbg.V T m = V\"\n    \"gbg.E T m = E\"\n    \"gbg.V0 T m = V0\"\n    \"gbg.F T m = (if F=UNIV then {} else {F})\"\n    \"gbg.is_run T m = is_run\"\n    \"gbg.is_acc T m = is_acc\"\n    \"gbg.is_acc_run T m = is_acc_run\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g_V (to_gbg_ext m) = V &&&\n     g_E (to_gbg_ext m) = E &&& g_V0 (to_gbg_ext m) = V0) &&&\n    (gbg_F (to_gbg_ext m) = (if F = UNIV then {} else {F}) &&&\n     graph_defs.is_run (to_gbg_ext m) = is_run) &&&\n    gb_graph.is_acc (to_gbg_ext m) = is_acc &&&\n    gb_graph.is_acc_run (to_gbg_ext m) = is_acc_run", "unfolding is_run_def[abs_def] gbg.is_run_def[abs_def]\n      is_acc_def[abs_def] gbg.is_acc_def[abs_def]\n      is_acc_run_def[abs_def] gbg.is_acc_run_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (g_V (to_gbg_ext m) = V &&&\n     g_E (to_gbg_ext m) = E &&& g_V0 (to_gbg_ext m) = V0) &&&\n    (gbg_F (to_gbg_ext m) = (if F = UNIV then {} else {F}) &&&\n     (\\<lambda>r.\n         r 0 \\<in> g_V0 (to_gbg_ext m) \\<and>\n         ipath (g_E (to_gbg_ext m)) r) =\n     (\\<lambda>r. r 0 \\<in> V0 \\<and> ipath E r)) &&&\n    (\\<lambda>r.\n        \\<forall>A\\<in>gbg_F (to_gbg_ext m).\n           \\<exists>\\<^sub>\\<infinity>i. r i \\<in> A) =\n    (\\<lambda>r. \\<exists>\\<^sub>\\<infinity>i. r i \\<in> F) &&&\n    (\\<lambda>r.\n        (r 0 \\<in> g_V0 (to_gbg_ext m) \\<and>\n         ipath (g_E (to_gbg_ext m)) r) \\<and>\n        (\\<forall>A\\<in>gbg_F (to_gbg_ext m).\n            \\<exists>\\<^sub>\\<infinity>i. r i \\<in> A)) =\n    (\\<lambda>r.\n        (r 0 \\<in> V0 \\<and> ipath E r) \\<and>\n        (\\<exists>\\<^sub>\\<infinity>i. r i \\<in> F))", "by (auto simp: to_gbg_ext_def)"], ["", "end"], ["", "subsection \"Buchi Automata\""], ["", "text \\<open>Buchi automata are labeled Buchi graphs\\<close>"], ["", "record ('Q,'L) ba_rec = \"'Q b_graph_rec\" +\n  ba_L :: \"'Q \\<Rightarrow> 'L \\<Rightarrow> bool\""], ["", "locale ba =\n  bg?: b_graph G \n  for G :: \"('Q,'L,'more) ba_rec_scheme\"\n  +\n  assumes L_ss: \"ba_L G q l \\<Longrightarrow> q \\<in> V\"\nbegin"], ["", "abbreviation L where \"L == ba_L G\""], ["", "lemma is_ba: \"ba G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ba G", "by unfold_locales"], ["", "abbreviation \"to_gba_ext m \\<equiv> to_gbg_ext \\<lparr> gba_L = L, \\<dots>=m \\<rparr>\""], ["", "abbreviation \"to_gba \\<equiv> to_gba_ext ()\""], ["", "sublocale gba: gba \"to_gba_ext m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gba (to_gba_ext m)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q l.\n       gba_L (to_gba_ext m) q l \\<Longrightarrow> q \\<in> g_V (to_gba_ext m)", "unfolding to_gbg_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q l.\n       gba_L\n        \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n           gbg_F = if F = UNIV then {} else {F}, gba_L = L,\n           \\<dots> = m\\<rparr>\n        q l \\<Longrightarrow>\n       q \\<in> g_V \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                      gbg_F = if F = UNIV then {} else {F}, gba_L = L,\n                      \\<dots> = m\\<rparr>", "using L_ss"], ["proof (prove)\nusing this:\n  L ?q ?l \\<Longrightarrow> ?q \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>q l.\n       gba_L\n        \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n           gbg_F = if F = UNIV then {} else {F}, gba_L = L,\n           \\<dots> = m\\<rparr>\n        q l \\<Longrightarrow>\n       q \\<in> g_V \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                      gbg_F = if F = UNIV then {} else {F}, gba_L = L,\n                      \\<dots> = m\\<rparr>", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ba_acc_simps[simp]: \"gba.L T m = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gba_L (to_gba_ext m) = L", "by (simp add: to_gbg_ext_def)"], ["", "definition \"accept w \\<equiv> (\\<exists>r. is_acc_run r \\<and> (\\<forall>i. L (r i) (w i)))\""], ["", "definition \"lang \\<equiv> Collect accept\""], ["", "lemma to_gba_alt_accept: \n    \"gba.accept T m = accept\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Automata.gba.accept (to_gba_ext m) = accept", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. Automata.gba.accept (to_gba_ext m) x = accept x", "unfolding accept_def gba.accept_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<exists>r.\n           gb_graph.is_acc_run (to_gba_ext m) r \\<and>\n           (\\<forall>i. gba_L (to_gba_ext m) (r i) (x i))) =\n       (\\<exists>r. is_acc_run r \\<and> (\\<forall>i. L (r i) (x i)))", "apply (simp_all add: to_gbg_alt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma to_gba_alt_lang: \n    \"gba.lang T m = lang\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Automata.gba.lang (to_gba_ext m) = lang", "unfolding lang_def gba.lang_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect (Automata.gba.accept (to_gba_ext m)) = Collect accept", "apply (simp_all add: to_gba_alt_accept)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas to_gba_alt = to_gbg_alt to_gba_alt_accept to_gba_alt_lang"], ["", "end"], ["", "subsection \"Indexed acceptance classes\""], ["", "record 'Q igb_graph_rec = \"'Q graph_rec\" +\n  igbg_num_acc :: nat\n  igbg_acc :: \"'Q \\<Rightarrow> nat set\""], ["", "locale igb_graph = \n  graph G\n  for G :: \"('Q,'more) igb_graph_rec_scheme\"\n  +\n  assumes acc_bound: \"\\<Union>(range (igbg_acc G)) \\<subseteq> {0..<(igbg_num_acc G)}\"\n  assumes acc_ss: \"igbg_acc G q \\<noteq> {} \\<Longrightarrow> q\\<in>V\"\nbegin"], ["", "abbreviation num_acc where \"num_acc \\<equiv> igbg_num_acc G\""], ["", "abbreviation acc where \"acc \\<equiv> igbg_acc G\""], ["", "lemma is_igb_graph: \"igb_graph G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igb_graph G", "by unfold_locales"], ["", "lemma acc_boundI[simp, intro]: \"x\\<in>acc q \\<Longrightarrow> x<num_acc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> acc q \\<Longrightarrow> x < num_acc", "using acc_bound"], ["proof (prove)\nusing this:\n  \\<Union> (range acc) \\<subseteq> {0..<num_acc}\n\ngoal (1 subgoal):\n 1. x \\<in> acc q \\<Longrightarrow> x < num_acc", "by fastforce"], ["", "definition \"accn i \\<equiv> {q . i\\<in>acc q}\""], ["", "definition \"F \\<equiv> { accn i | i. i<num_acc }\""], ["", "definition \"to_gbg_ext m \n    \\<equiv> \\<lparr> g_V = V, g_E = E, g_V0 = V0, gbg_F = F, \\<dots>=m \\<rparr>\""], ["", "sublocale gbg: gb_graph \"to_gbg_ext m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gb_graph (to_gbg_ext m)", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. g_V0 (to_gbg_ext m) \\<subseteq> g_V (to_gbg_ext m)\n 2. g_E (to_gbg_ext m)\n    \\<subseteq> g_V (to_gbg_ext m) \\<times> g_V (to_gbg_ext m)\n 3. finite (gbg_F (to_gbg_ext m))\n 4. gbg_F (to_gbg_ext m) \\<subseteq> Pow (g_V (to_gbg_ext m))", "using V0_ss E_ss acc_ss"], ["proof (prove)\nusing this:\n  V0 \\<subseteq> V\n  E \\<subseteq> V \\<times> V\n  acc ?q \\<noteq> {} \\<Longrightarrow> ?q \\<in> V\n\ngoal (4 subgoals):\n 1. g_V0 (to_gbg_ext m) \\<subseteq> g_V (to_gbg_ext m)\n 2. g_E (to_gbg_ext m)\n    \\<subseteq> g_V (to_gbg_ext m) \\<times> g_V (to_gbg_ext m)\n 3. finite (gbg_F (to_gbg_ext m))\n 4. gbg_F (to_gbg_ext m) \\<subseteq> Pow (g_V (to_gbg_ext m))", "apply (auto simp: to_gbg_ext_def F_def accn_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma to_gbg_alt1: \n    \"gbg.E T m = E\"\n    \"gbg.V0 T m = V0\"\n    \"gbg.F T m = F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_E (to_gbg_ext m) = E &&&\n    g_V0 (to_gbg_ext m) = V0 &&& gbg_F (to_gbg_ext m) = F", "by (simp_all add: to_gbg_ext_def)"], ["", "lemma F_fin[simp,intro!]: \"finite F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite F", "unfolding F_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {accn i |i. i < num_acc}", "by auto"], ["", "definition is_acc :: \"'Q word \\<Rightarrow> bool\" \n    where \"is_acc r \\<equiv> (\\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (r i))\""], ["", "definition \"is_acc_run r \\<equiv> is_run r \\<and> is_acc r\""], ["", "lemma is_run_gbg: \n    \"gbg.is_run T m = is_run\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_defs.is_run (to_gbg_ext m) = is_run", "unfolding is_run_def[abs_def] is_acc_run_def[abs_def] \n      gbg.is_run_def[abs_def] gbg.is_acc_run_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>r.\n        r 0 \\<in> g_V0 (to_gbg_ext m) \\<and> ipath (g_E (to_gbg_ext m)) r) =\n    (\\<lambda>r. r 0 \\<in> V0 \\<and> ipath E r)", "by (simp_all add: to_gbg_ext_def)"], ["", "lemma is_acc_gbg: \n    \"gbg.is_acc T m = is_acc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gb_graph.is_acc (to_gbg_ext m) = is_acc", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. gb_graph.is_acc (to_gbg_ext m) x = is_acc x", "unfolding gbg.is_acc_def is_acc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<forall>A\\<in>gbg_F (to_gbg_ext m).\n           \\<exists>\\<^sub>\\<infinity>i. x i \\<in> A) =\n       (\\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (x i))", "apply (simp add: to_gbg_alt1 is_run_gbg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<forall>A\\<in>F. \\<exists>\\<^sub>\\<infinity>i. x i \\<in> A) =\n       (\\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (x i))", "unfolding F_def accn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<forall>A\\<in>{{q. i \\<in> acc q} |i. i < num_acc}.\n           \\<exists>\\<^sub>\\<infinity>i. x i \\<in> A) =\n       (\\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (x i))", "apply (blast intro: INFM_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_acc_run_gbg: \n    \"gbg.is_acc_run T m = is_acc_run\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gb_graph.is_acc_run (to_gbg_ext m) = is_acc_run", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. gb_graph.is_acc_run (to_gbg_ext m) x = is_acc_run x", "unfolding gbg.is_acc_run_def is_acc_run_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (graph_defs.is_run (to_gbg_ext m) x \\<and>\n        gb_graph.is_acc (to_gbg_ext m) x) =\n       (is_run x \\<and> is_acc x)", "by (simp_all add: to_gbg_alt1 is_run_gbg is_acc_gbg)"], ["", "lemmas to_gbg_alt = to_gbg_alt1 is_run_gbg is_acc_gbg is_acc_run_gbg"], ["", "lemma acc_limit_alt: \n    assumes FIN: \"finite (range r)\"\n    shows \"is_acc r \\<longleftrightarrow> (\\<forall>n<num_acc. limit r \\<inter> accn n \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_acc r = (\\<forall>n<num_acc. limit r \\<inter> accn n \\<noteq> {})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. is_acc r \\<Longrightarrow>\n    \\<forall>n<num_acc. limit r \\<inter> accn n \\<noteq> {}\n 2. \\<forall>n<num_acc.\n       limit r \\<inter> accn n \\<noteq> {} \\<Longrightarrow>\n    is_acc r", "assume \"\\<forall>n<num_acc. limit r \\<inter> accn n \\<noteq> {}\""], ["proof (state)\nthis:\n  \\<forall>n<num_acc. limit r \\<inter> accn n \\<noteq> {}\n\ngoal (2 subgoals):\n 1. is_acc r \\<Longrightarrow>\n    \\<forall>n<num_acc. limit r \\<inter> accn n \\<noteq> {}\n 2. \\<forall>n<num_acc.\n       limit r \\<inter> accn n \\<noteq> {} \\<Longrightarrow>\n    is_acc r", "thus \"is_acc r\""], ["proof (prove)\nusing this:\n  \\<forall>n<num_acc. limit r \\<inter> accn n \\<noteq> {}\n\ngoal (1 subgoal):\n 1. is_acc r", "unfolding is_acc_def accn_def"], ["proof (prove)\nusing this:\n  \\<forall>n<num_acc. limit r \\<inter> {q. n \\<in> acc q} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (r i)", "by (auto dest!: limit_inter_INF)"], ["proof (state)\nthis:\n  is_acc r\n\ngoal (1 subgoal):\n 1. is_acc r \\<Longrightarrow>\n    \\<forall>n<num_acc. limit r \\<inter> accn n \\<noteq> {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. is_acc r \\<Longrightarrow>\n    \\<forall>n<num_acc. limit r \\<inter> accn n \\<noteq> {}", "from FIN"], ["proof (chain)\npicking this:\n  finite (range r)", "have FIN': \"\\<And>A. finite (A \\<inter> range r)\""], ["proof (prove)\nusing this:\n  finite (range r)\n\ngoal (1 subgoal):\n 1. \\<And>A. finite (A \\<inter> range r)", "by simp"], ["proof (state)\nthis:\n  finite (?A1 \\<inter> range r)\n\ngoal (1 subgoal):\n 1. is_acc r \\<Longrightarrow>\n    \\<forall>n<num_acc. limit r \\<inter> accn n \\<noteq> {}", "assume \"is_acc r\""], ["proof (state)\nthis:\n  is_acc r\n\ngoal (1 subgoal):\n 1. is_acc r \\<Longrightarrow>\n    \\<forall>n<num_acc. limit r \\<inter> accn n \\<noteq> {}", "hence \"\\<forall>n<num_acc. limit r \\<inter> (accn n \\<inter> range r) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  is_acc r\n\ngoal (1 subgoal):\n 1. \\<forall>n<num_acc.\n       limit r \\<inter> (accn n \\<inter> range r) \\<noteq> {}", "unfolding is_acc_def accn_def"], ["proof (prove)\nusing this:\n  \\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (r i)\n\ngoal (1 subgoal):\n 1. \\<forall>n<num_acc.\n       limit r \\<inter> ({q. n \\<in> acc q} \\<inter> range r) \\<noteq> {}", "by (auto simp: fin_ex_inf_eq_limit[OF FIN', symmetric])"], ["proof (state)\nthis:\n  \\<forall>n<num_acc. limit r \\<inter> (accn n \\<inter> range r) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. is_acc r \\<Longrightarrow>\n    \\<forall>n<num_acc. limit r \\<inter> accn n \\<noteq> {}", "thus \"\\<forall>n<num_acc. limit r \\<inter> accn n \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<forall>n<num_acc. limit r \\<inter> (accn n \\<inter> range r) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>n<num_acc. limit r \\<inter> accn n \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  \\<forall>n<num_acc. limit r \\<inter> accn n \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma acc_limit_alt': \n    \"finite (range r) \\<Longrightarrow> is_acc r \\<longleftrightarrow> (\\<Union>(acc ` limit r) = {0..<num_acc})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (range r) \\<Longrightarrow>\n    is_acc r = (\\<Union> (acc ` limit r) = {0..<num_acc})", "unfolding acc_limit_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (range r) \\<Longrightarrow>\n    (\\<forall>n<num_acc. limit r \\<inter> accn n \\<noteq> {}) =\n    (\\<Union> (acc ` limit r) = {0..<num_acc})", "by (auto simp: accn_def)"], ["", "end"], ["", "record ('Q,'L) igba_rec = \"'Q igb_graph_rec\" +\n  igba_L :: \"'Q \\<Rightarrow> 'L \\<Rightarrow> bool\""], ["", "locale igba =\n  igbg?: igb_graph G\n  for G :: \"('Q,'L,'more) igba_rec_scheme\"\n  +\n  assumes L_ss: \"igba_L G q l \\<Longrightarrow> q \\<in> V\"\nbegin"], ["", "abbreviation L where \"L \\<equiv> igba_L G\""], ["", "lemma is_igba: \"igba G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igba G", "by unfold_locales"], ["", "abbreviation \"to_gba_ext m \\<equiv> to_gbg_ext \\<lparr> gba_L = igba_L G, \\<dots>=m \\<rparr>\""], ["", "sublocale gba: gba \"to_gba_ext m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gba (to_gba_ext m)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q l.\n       gba_L (to_gba_ext m) q l \\<Longrightarrow> q \\<in> g_V (to_gba_ext m)", "unfolding to_gbg_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q l.\n       gba_L\n        \\<lparr>g_V = V, g_E = E, g_V0 = V0, gbg_F = F, gba_L = L,\n           \\<dots> = m\\<rparr>\n        q l \\<Longrightarrow>\n       q \\<in> g_V \\<lparr>g_V = V, g_E = E, g_V0 = V0, gbg_F = F,\n                      gba_L = L, \\<dots> = m\\<rparr>", "using L_ss"], ["proof (prove)\nusing this:\n  L ?q ?l \\<Longrightarrow> ?q \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>q l.\n       gba_L\n        \\<lparr>g_V = V, g_E = E, g_V0 = V0, gbg_F = F, gba_L = L,\n           \\<dots> = m\\<rparr>\n        q l \\<Longrightarrow>\n       q \\<in> g_V \\<lparr>g_V = V, g_E = E, g_V0 = V0, gbg_F = F,\n                      gba_L = L, \\<dots> = m\\<rparr>", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma to_gba_alt_L:\n    \"gba.L T m = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gba_L (to_gba_ext m) = L", "by (auto simp: to_gbg_ext_def)"], ["", "definition \"accept w \\<equiv> \\<exists>r. is_acc_run r \\<and> (\\<forall>i. L (r i) (w i))\""], ["", "definition \"lang \\<equiv> Collect accept\""], ["", "lemma accept_gba_alt: \"gba.accept T m = accept\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Automata.gba.accept (to_gba_ext m) = accept", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. Automata.gba.accept (to_gba_ext m) x = accept x", "unfolding accept_def gba.accept_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<exists>r.\n           gb_graph.is_acc_run (to_gba_ext m) r \\<and>\n           (\\<forall>i. gba_L (to_gba_ext m) (r i) (x i))) =\n       (\\<exists>r. is_acc_run r \\<and> (\\<forall>i. L (r i) (x i)))", "apply (simp add: to_gbg_alt to_gba_alt_L)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lang_gba_alt: \"gba.lang T m = lang\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Automata.gba.lang (to_gba_ext m) = lang", "unfolding lang_def gba.lang_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect (Automata.gba.accept (to_gba_ext m)) = Collect accept", "apply (simp add: accept_gba_alt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas to_gba_alt = to_gbg_alt to_gba_alt_L accept_gba_alt lang_gba_alt"], ["", "end"], ["", "subsubsection \\<open>Indexing Conversion\\<close>"], ["", "definition F_to_idx :: \"'Q set set \\<Rightarrow> (nat \\<times> ('Q \\<Rightarrow> nat set)) nres\" where\n  \"F_to_idx F \\<equiv> do {\n    Flist \\<leftarrow> SPEC (\\<lambda>Flist. distinct Flist \\<and> set Flist = F);\n    let num_acc = length Flist;\n    let acc = (\\<lambda>v. {i . i<num_acc \\<and> v\\<in>Flist!i});\n    RETURN (num_acc,acc)\n  }\""], ["", "lemma F_to_idx_correct:\n  shows \"F_to_idx F \\<le> SPEC (\\<lambda>(num_acc,acc). F = { {q. i\\<in>acc q} | i. i<num_acc } \n    \\<and> \\<Union>(range acc) \\<subseteq> {0..<num_acc})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F_to_idx F\n    \\<le> SPEC\n           (\\<lambda>(num_acc, acc).\n               F = {{q. i \\<in> acc q} |i. i < num_acc} \\<and>\n               \\<Union> (range acc) \\<subseteq> {0..<num_acc})", "unfolding F_to_idx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC (\\<lambda>Flist. distinct Flist \\<and> set Flist = F) \\<bind>\n    (\\<lambda>Flist.\n        let num_acc = length Flist;\n            acc = \\<lambda>v. {i. i < num_acc \\<and> v \\<in> Flist ! i}\n        in RETURN (num_acc, acc))\n    \\<le> SPEC\n           (\\<lambda>(num_acc, acc).\n               F = {{q. i \\<in> acc q} |i. i < num_acc} \\<and>\n               \\<Union> (range acc) \\<subseteq> {0..<num_acc})", "apply (refine_rcg refine_vcg)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x1 x2.\n       \\<lbrakk>distinct x \\<and> set x = F;\n        (length x, \\<lambda>v. {i. i < length x \\<and> v \\<in> x ! i}) =\n        (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> F = {{q. i \\<in> x2 q} |i. i < x1}\n 2. \\<And>x x1 x2.\n       \\<lbrakk>distinct x \\<and> set x = F;\n        (length x, \\<lambda>v. {i. i < length x \\<and> v \\<in> x ! i}) =\n        (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (range x2) \\<subseteq> {0..<x1}", "apply (clarsimp dest!: sym[where t=F])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>distinct x; F = set x\\<rbrakk>\n       \\<Longrightarrow> set x =\n                         {{q. i < length x \\<and> q \\<in> x ! i} |i.\n                          i < length x}\n 2. \\<And>x x1 x2.\n       \\<lbrakk>distinct x \\<and> set x = F;\n        (length x, \\<lambda>v. {i. i < length x \\<and> v \\<in> x ! i}) =\n        (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (range x2) \\<subseteq> {0..<x1}", "apply (intro equalityI subsetI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>distinct x; F = set x; xa \\<in> set x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {{q. i < length x \\<and> q \\<in> x ! i} |\n                                   i. i < length x}\n 2. \\<And>x xa.\n       \\<lbrakk>distinct x; F = set x;\n        xa \\<in> {{q. i < length x \\<and> q \\<in> x ! i} |i.\n                  i < length x}\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> set x\n 3. \\<And>x x1 x2.\n       \\<lbrakk>distinct x \\<and> set x = F;\n        (length x, \\<lambda>v. {i. i < length x \\<and> v \\<in> x ! i}) =\n        (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (range x2) \\<subseteq> {0..<x1}", "apply (auto simp: in_set_conv_nth) [2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x1 x2.\n       \\<lbrakk>distinct x \\<and> set x = F;\n        (length x, \\<lambda>v. {i. i < length x \\<and> v \\<in> x ! i}) =\n        (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (range x2) \\<subseteq> {0..<x1}", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"mk_acc_impl Flist \\<equiv> do {\n  let acc = Map.empty;\n\n  (_,acc) \\<leftarrow> nfoldli Flist (\\<lambda>_. True) (\\<lambda>A (i,acc). do {\n    acc \\<leftarrow> FOREACHi (\\<lambda>it acc'. \n      acc' = (\\<lambda>v. \n        if v\\<in>A-it then \n          Some (insert i (the_default {} (acc v))) \n        else \n          acc v\n      )\n    ) \n      A (\\<lambda>v acc. RETURN (acc(v\\<mapsto>insert i (the_default {} (acc v))))) acc;\n    RETURN (Suc i,acc)\n  }) (0,acc);\n  RETURN (\\<lambda>x. the_default {} (acc x))\n}\""], ["", "lemma mk_acc_impl_correct: \n  assumes F: \"(Flist',Flist)\\<in>Id\"\n  assumes FIN: \"\\<forall>A\\<in>set Flist. finite A\"\n  shows \"mk_acc_impl Flist' \\<le> \\<Down>Id (RETURN (\\<lambda>v. {i . i<length Flist \\<and> v\\<in>Flist!i}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_acc_impl Flist'\n    \\<le> \\<Down> Id\n           (RETURN\n             (\\<lambda>v. {i. i < length Flist \\<and> v \\<in> Flist ! i}))", "using F"], ["proof (prove)\nusing this:\n  (Flist', Flist) \\<in> Id\n\ngoal (1 subgoal):\n 1. mk_acc_impl Flist'\n    \\<le> \\<Down> Id\n           (RETURN\n             (\\<lambda>v. {i. i < length Flist \\<and> v \\<in> Flist ! i}))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. Flist' = Flist \\<Longrightarrow>\n    mk_acc_impl Flist\n    \\<le> RETURN\n           (\\<lambda>v. {i. i < length Flist \\<and> v \\<in> Flist ! i})", "unfolding mk_acc_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Flist' = Flist \\<Longrightarrow>\n    (let acc = Map.empty\n     in nfoldli Flist (\\<lambda>_. True)\n         (\\<lambda>A (i, acc).\n             FOREACH\\<^bsup>\\<lambda>it acc'.\n                               acc' =\n                               (\\<lambda>v.\n                                   if v \\<in> A - it\n                                   then Some\n   (insert i (the_default {} (acc v)))\n                                   else acc v)\\<^esup>\n              A (\\<lambda>v acc.\n                    RETURN\n                     (acc(v \\<mapsto> insert i (the_default {} (acc v)))))\n              acc \\<bind>\n             (\\<lambda>acc. RETURN (Suc i, acc)))\n         (0, acc) \\<bind>\n        (\\<lambda>(uu_, acc). RETURN (\\<lambda>x. the_default {} (acc x))))\n    \\<le> RETURN\n           (\\<lambda>v. {i. i < length Flist \\<and> v \\<in> Flist ! i})", "apply (refine_rcg \n    nfoldli_rule[where \n      I=\"\\<lambda>l1 l2 (i,res). i=length l1 \n        \\<and> the_default {} o res = (\\<lambda>v. {j . j<i \\<and> v\\<in>Flist!j})\"\n    ]\n    refine_vcg \n  )"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>Flist' = Flist; (0, Map.empty) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 = length []\n 2. \\<And>x1 x2.\n       \\<lbrakk>Flist' = Flist; (0, Map.empty) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> the_default {} \\<circ> x2 =\n                         (\\<lambda>v. {j. j < x1 \\<and> v \\<in> Flist ! j})\n 3. \\<And>x l1 l2 \\<sigma> a b.\n       \\<lbrakk>Flist' = Flist; Flist = l1 @ x # l2;\n        case \\<sigma> of\n        (i, res) \\<Rightarrow>\n          i = length l1 \\<and>\n          the_default {} \\<circ> res =\n          (\\<lambda>v. {j. j < i \\<and> v \\<in> Flist ! j});\n        True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite x\n 4. \\<And>x l1 l2 \\<sigma> a b.\n       \\<lbrakk>Flist' = Flist; Flist = l1 @ x # l2;\n        case \\<sigma> of\n        (i, res) \\<Rightarrow>\n          i = length l1 \\<and>\n          the_default {} \\<circ> res =\n          (\\<lambda>v. {j. j < i \\<and> v \\<in> Flist ! j});\n        True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> b =\n                         (\\<lambda>v.\n                             if v \\<in> x - x\n                             then Some (insert a (the_default {} (b v)))\n                             else b v)\n 5. \\<And>x l1 l2 \\<sigma> a b xa it \\<sigma>'.\n       \\<lbrakk>Flist' = Flist; Flist = l1 @ x # l2;\n        case \\<sigma> of\n        (i, res) \\<Rightarrow>\n          i = length l1 \\<and>\n          the_default {} \\<circ> res =\n          (\\<lambda>v. {j. j < i \\<and> v \\<in> Flist ! j});\n        True; \\<sigma> = (a, b); xa \\<in> it; it \\<subseteq> x;\n        \\<sigma>' =\n        (\\<lambda>v.\n            if v \\<in> x - it then Some (insert a (the_default {} (b v)))\n            else b v)\\<rbrakk>\n       \\<Longrightarrow> \\<sigma>'(xa \\<mapsto>\n                         insert a (the_default {} (\\<sigma>' xa))) =\n                         (\\<lambda>v.\n                             if v \\<in> x - (it - {xa})\n                             then Some (insert a (the_default {} (b v)))\n                             else b v)\n 6. \\<And>x l1 l2 \\<sigma> a b \\<sigma>' x1 x2.\n       \\<lbrakk>Flist' = Flist; Flist = l1 @ x # l2;\n        case \\<sigma> of\n        (i, res) \\<Rightarrow>\n          i = length l1 \\<and>\n          the_default {} \\<circ> res =\n          (\\<lambda>v. {j. j < i \\<and> v \\<in> Flist ! j});\n        True; \\<sigma> = (a, b);\n        \\<sigma>' =\n        (\\<lambda>v.\n            if v \\<in> x - {} then Some (insert a (the_default {} (b v)))\n            else b v);\n        (Suc a, \\<sigma>') = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 = length (l1 @ [x])\n 7. \\<And>x l1 l2 \\<sigma> a b \\<sigma>' x1 x2.\n       \\<lbrakk>Flist' = Flist; Flist = l1 @ x # l2;\n        case \\<sigma> of\n        (i, res) \\<Rightarrow>\n          i = length l1 \\<and>\n          the_default {} \\<circ> res =\n          (\\<lambda>v. {j. j < i \\<and> v \\<in> Flist ! j});\n        True; \\<sigma> = (a, b);\n        \\<sigma>' =\n        (\\<lambda>v.\n            if v \\<in> x - {} then Some (insert a (the_default {} (b v)))\n            else b v);\n        (Suc a, \\<sigma>') = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> the_default {} \\<circ> x2 =\n                         (\\<lambda>v. {j. j < x1 \\<and> v \\<in> Flist ! j})\n 8. \\<And>l1 l2 \\<sigma> a b.\n       \\<lbrakk>Flist' = Flist; Flist = l1 @ l2;\n        case \\<sigma> of\n        (i, res) \\<Rightarrow>\n          i = length l1 \\<and>\n          the_default {} \\<circ> res =\n          (\\<lambda>v. {j. j < i \\<and> v \\<in> Flist ! j});\n        \\<not> True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>v.\n                             {i. i < length Flist \\<and>\n                                 v \\<in> Flist ! i}) =\n                         (\\<lambda>x. the_default {} (b x))\n 9. \\<And>\\<sigma> a b.\n       \\<lbrakk>Flist' = Flist;\n        case \\<sigma> of\n        (i, res) \\<Rightarrow>\n          i = length Flist \\<and>\n          the_default {} \\<circ> res =\n          (\\<lambda>v. {j. j < i \\<and> v \\<in> Flist ! j});\n        True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>v.\n                             {i. i < length Flist \\<and>\n                                 v \\<in> Flist ! i}) =\n                         (\\<lambda>x. the_default {} (b x))", "using FIN"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>set Flist. finite A\n\ngoal (9 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>Flist' = Flist; (0, Map.empty) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 = length []\n 2. \\<And>x1 x2.\n       \\<lbrakk>Flist' = Flist; (0, Map.empty) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> the_default {} \\<circ> x2 =\n                         (\\<lambda>v. {j. j < x1 \\<and> v \\<in> Flist ! j})\n 3. \\<And>x l1 l2 \\<sigma> a b.\n       \\<lbrakk>Flist' = Flist; Flist = l1 @ x # l2;\n        case \\<sigma> of\n        (i, res) \\<Rightarrow>\n          i = length l1 \\<and>\n          the_default {} \\<circ> res =\n          (\\<lambda>v. {j. j < i \\<and> v \\<in> Flist ! j});\n        True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite x\n 4. \\<And>x l1 l2 \\<sigma> a b.\n       \\<lbrakk>Flist' = Flist; Flist = l1 @ x # l2;\n        case \\<sigma> of\n        (i, res) \\<Rightarrow>\n          i = length l1 \\<and>\n          the_default {} \\<circ> res =\n          (\\<lambda>v. {j. j < i \\<and> v \\<in> Flist ! j});\n        True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> b =\n                         (\\<lambda>v.\n                             if v \\<in> x - x\n                             then Some (insert a (the_default {} (b v)))\n                             else b v)\n 5. \\<And>x l1 l2 \\<sigma> a b xa it \\<sigma>'.\n       \\<lbrakk>Flist' = Flist; Flist = l1 @ x # l2;\n        case \\<sigma> of\n        (i, res) \\<Rightarrow>\n          i = length l1 \\<and>\n          the_default {} \\<circ> res =\n          (\\<lambda>v. {j. j < i \\<and> v \\<in> Flist ! j});\n        True; \\<sigma> = (a, b); xa \\<in> it; it \\<subseteq> x;\n        \\<sigma>' =\n        (\\<lambda>v.\n            if v \\<in> x - it then Some (insert a (the_default {} (b v)))\n            else b v)\\<rbrakk>\n       \\<Longrightarrow> \\<sigma>'(xa \\<mapsto>\n                         insert a (the_default {} (\\<sigma>' xa))) =\n                         (\\<lambda>v.\n                             if v \\<in> x - (it - {xa})\n                             then Some (insert a (the_default {} (b v)))\n                             else b v)\n 6. \\<And>x l1 l2 \\<sigma> a b \\<sigma>' x1 x2.\n       \\<lbrakk>Flist' = Flist; Flist = l1 @ x # l2;\n        case \\<sigma> of\n        (i, res) \\<Rightarrow>\n          i = length l1 \\<and>\n          the_default {} \\<circ> res =\n          (\\<lambda>v. {j. j < i \\<and> v \\<in> Flist ! j});\n        True; \\<sigma> = (a, b);\n        \\<sigma>' =\n        (\\<lambda>v.\n            if v \\<in> x - {} then Some (insert a (the_default {} (b v)))\n            else b v);\n        (Suc a, \\<sigma>') = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 = length (l1 @ [x])\n 7. \\<And>x l1 l2 \\<sigma> a b \\<sigma>' x1 x2.\n       \\<lbrakk>Flist' = Flist; Flist = l1 @ x # l2;\n        case \\<sigma> of\n        (i, res) \\<Rightarrow>\n          i = length l1 \\<and>\n          the_default {} \\<circ> res =\n          (\\<lambda>v. {j. j < i \\<and> v \\<in> Flist ! j});\n        True; \\<sigma> = (a, b);\n        \\<sigma>' =\n        (\\<lambda>v.\n            if v \\<in> x - {} then Some (insert a (the_default {} (b v)))\n            else b v);\n        (Suc a, \\<sigma>') = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> the_default {} \\<circ> x2 =\n                         (\\<lambda>v. {j. j < x1 \\<and> v \\<in> Flist ! j})\n 8. \\<And>l1 l2 \\<sigma> a b.\n       \\<lbrakk>Flist' = Flist; Flist = l1 @ l2;\n        case \\<sigma> of\n        (i, res) \\<Rightarrow>\n          i = length l1 \\<and>\n          the_default {} \\<circ> res =\n          (\\<lambda>v. {j. j < i \\<and> v \\<in> Flist ! j});\n        \\<not> True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>v.\n                             {i. i < length Flist \\<and>\n                                 v \\<in> Flist ! i}) =\n                         (\\<lambda>x. the_default {} (b x))\n 9. \\<And>\\<sigma> a b.\n       \\<lbrakk>Flist' = Flist;\n        case \\<sigma> of\n        (i, res) \\<Rightarrow>\n          i = length Flist \\<and>\n          the_default {} \\<circ> res =\n          (\\<lambda>v. {j. j < i \\<and> v \\<in> Flist ! j});\n        True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>v.\n                             {i. i < length Flist \\<and>\n                                 v \\<in> Flist ! i}) =\n                         (\\<lambda>x. the_default {} (b x))", "apply (simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Flist' = Flist; x1 = 0;\n        \\<forall>x\\<in>set Flist. finite x\\<rbrakk>\n       \\<Longrightarrow> the_default {} \\<circ> Map.empty = (\\<lambda>v. {})\n 2. \\<And>x l1 l2 \\<sigma> b xa it \\<sigma>'.\n       \\<lbrakk>Flist' = l1 @ x # l2; Flist = l1 @ x # l2;\n        the_default {} \\<circ> b =\n        (\\<lambda>v. {j. j < length l1 \\<and> v \\<in> (l1 @ x # l2) ! j});\n        \\<sigma> = (length l1, b); xa \\<in> it; it \\<subseteq> x;\n        \\<sigma>' =\n        (\\<lambda>v.\n            if v \\<in> x \\<and> v \\<notin> it\n            then Some (insert (length l1) (the_default {} (b v))) else b v);\n        finite x \\<and>\n        (\\<forall>x\\<in>set l1 \\<union> set l2. finite x)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>v.\n                             if v \\<in> x \\<and> v \\<notin> it\n                             then Some\n                                   (insert (length l1)\n                                     (the_default {} (b v)))\n                             else b v)\n                         (xa \\<mapsto>\n                         insert (length l1) (the_default {} (b xa))) =\n                         (\\<lambda>v.\n                             if v \\<in> x \\<and>\n                                (v \\<in> it \\<longrightarrow> v = xa)\n                             then Some\n                                   (insert (length l1)\n                                     (the_default {} (b v)))\n                             else b v)\n 3. \\<And>x l1 l2 \\<sigma> b \\<sigma>' x1.\n       \\<lbrakk>Flist' = l1 @ x # l2; Flist = l1 @ x # l2;\n        the_default {} \\<circ> b =\n        (\\<lambda>v. {j. j < length l1 \\<and> v \\<in> (l1 @ x # l2) ! j});\n        \\<sigma> = (length l1, b);\n        \\<sigma>' =\n        (\\<lambda>v.\n            if v \\<in> x\n            then Some (insert (length l1) (the_default {} (b v))) else b v);\n        Suc (length l1) = x1;\n        finite x \\<and>\n        (\\<forall>x\\<in>set l1 \\<union> set l2. finite x)\\<rbrakk>\n       \\<Longrightarrow> the_default {} \\<circ>\n                         (\\<lambda>v.\n                             if v \\<in> x\n                             then Some\n                                   (insert (length l1)\n                                     (the_default {} (b v)))\n                             else b v) =\n                         (\\<lambda>v.\n                             {j. j < x1 \\<and> v \\<in> (l1 @ x # l2) ! j})\n 4. \\<And>\\<sigma> b.\n       \\<lbrakk>Flist' = Flist;\n        the_default {} \\<circ> b =\n        (\\<lambda>v. {j. j < length Flist \\<and> v \\<in> Flist ! j});\n        \\<sigma> = (length Flist, b);\n        \\<forall>x\\<in>set Flist. finite x\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>v.\n                             {i. i < length Flist \\<and>\n                                 v \\<in> Flist ! i}) =\n                         (\\<lambda>x. the_default {} (b x))", "apply (rule ext)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 v.\n       \\<lbrakk>Flist' = Flist; x1 = 0;\n        \\<forall>x\\<in>set Flist. finite x\\<rbrakk>\n       \\<Longrightarrow> (the_default {} \\<circ> Map.empty) v = {}\n 2. \\<And>x l1 l2 \\<sigma> b xa it \\<sigma>'.\n       \\<lbrakk>Flist' = l1 @ x # l2; Flist = l1 @ x # l2;\n        the_default {} \\<circ> b =\n        (\\<lambda>v. {j. j < length l1 \\<and> v \\<in> (l1 @ x # l2) ! j});\n        \\<sigma> = (length l1, b); xa \\<in> it; it \\<subseteq> x;\n        \\<sigma>' =\n        (\\<lambda>v.\n            if v \\<in> x \\<and> v \\<notin> it\n            then Some (insert (length l1) (the_default {} (b v))) else b v);\n        finite x \\<and>\n        (\\<forall>x\\<in>set l1 \\<union> set l2. finite x)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>v.\n                             if v \\<in> x \\<and> v \\<notin> it\n                             then Some\n                                   (insert (length l1)\n                                     (the_default {} (b v)))\n                             else b v)\n                         (xa \\<mapsto>\n                         insert (length l1) (the_default {} (b xa))) =\n                         (\\<lambda>v.\n                             if v \\<in> x \\<and>\n                                (v \\<in> it \\<longrightarrow> v = xa)\n                             then Some\n                                   (insert (length l1)\n                                     (the_default {} (b v)))\n                             else b v)\n 3. \\<And>x l1 l2 \\<sigma> b \\<sigma>' x1.\n       \\<lbrakk>Flist' = l1 @ x # l2; Flist = l1 @ x # l2;\n        the_default {} \\<circ> b =\n        (\\<lambda>v. {j. j < length l1 \\<and> v \\<in> (l1 @ x # l2) ! j});\n        \\<sigma> = (length l1, b);\n        \\<sigma>' =\n        (\\<lambda>v.\n            if v \\<in> x\n            then Some (insert (length l1) (the_default {} (b v))) else b v);\n        Suc (length l1) = x1;\n        finite x \\<and>\n        (\\<forall>x\\<in>set l1 \\<union> set l2. finite x)\\<rbrakk>\n       \\<Longrightarrow> the_default {} \\<circ>\n                         (\\<lambda>v.\n                             if v \\<in> x\n                             then Some\n                                   (insert (length l1)\n                                     (the_default {} (b v)))\n                             else b v) =\n                         (\\<lambda>v.\n                             {j. j < x1 \\<and> v \\<in> (l1 @ x # l2) ! j})\n 4. \\<And>\\<sigma> b.\n       \\<lbrakk>Flist' = Flist;\n        the_default {} \\<circ> b =\n        (\\<lambda>v. {j. j < length Flist \\<and> v \\<in> Flist ! j});\n        \\<sigma> = (length Flist, b);\n        \\<forall>x\\<in>set Flist. finite x\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>v.\n                             {i. i < length Flist \\<and>\n                                 v \\<in> Flist ! i}) =\n                         (\\<lambda>x. the_default {} (b x))", "apply auto []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x l1 l2 \\<sigma> b xa it \\<sigma>'.\n       \\<lbrakk>Flist' = l1 @ x # l2; Flist = l1 @ x # l2;\n        the_default {} \\<circ> b =\n        (\\<lambda>v. {j. j < length l1 \\<and> v \\<in> (l1 @ x # l2) ! j});\n        \\<sigma> = (length l1, b); xa \\<in> it; it \\<subseteq> x;\n        \\<sigma>' =\n        (\\<lambda>v.\n            if v \\<in> x \\<and> v \\<notin> it\n            then Some (insert (length l1) (the_default {} (b v))) else b v);\n        finite x \\<and>\n        (\\<forall>x\\<in>set l1 \\<union> set l2. finite x)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>v.\n                             if v \\<in> x \\<and> v \\<notin> it\n                             then Some\n                                   (insert (length l1)\n                                     (the_default {} (b v)))\n                             else b v)\n                         (xa \\<mapsto>\n                         insert (length l1) (the_default {} (b xa))) =\n                         (\\<lambda>v.\n                             if v \\<in> x \\<and>\n                                (v \\<in> it \\<longrightarrow> v = xa)\n                             then Some\n                                   (insert (length l1)\n                                     (the_default {} (b v)))\n                             else b v)\n 2. \\<And>x l1 l2 \\<sigma> b \\<sigma>' x1.\n       \\<lbrakk>Flist' = l1 @ x # l2; Flist = l1 @ x # l2;\n        the_default {} \\<circ> b =\n        (\\<lambda>v. {j. j < length l1 \\<and> v \\<in> (l1 @ x # l2) ! j});\n        \\<sigma> = (length l1, b);\n        \\<sigma>' =\n        (\\<lambda>v.\n            if v \\<in> x\n            then Some (insert (length l1) (the_default {} (b v))) else b v);\n        Suc (length l1) = x1;\n        finite x \\<and>\n        (\\<forall>x\\<in>set l1 \\<union> set l2. finite x)\\<rbrakk>\n       \\<Longrightarrow> the_default {} \\<circ>\n                         (\\<lambda>v.\n                             if v \\<in> x\n                             then Some\n                                   (insert (length l1)\n                                     (the_default {} (b v)))\n                             else b v) =\n                         (\\<lambda>v.\n                             {j. j < x1 \\<and> v \\<in> (l1 @ x # l2) ! j})\n 3. \\<And>\\<sigma> b.\n       \\<lbrakk>Flist' = Flist;\n        the_default {} \\<circ> b =\n        (\\<lambda>v. {j. j < length Flist \\<and> v \\<in> Flist ! j});\n        \\<sigma> = (length Flist, b);\n        \\<forall>x\\<in>set Flist. finite x\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>v.\n                             {i. i < length Flist \\<and>\n                                 v \\<in> Flist ! i}) =\n                         (\\<lambda>x. the_default {} (b x))", "apply (rule ext)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x l1 l2 \\<sigma> b xa it \\<sigma>' v.\n       \\<lbrakk>Flist' = l1 @ x # l2; Flist = l1 @ x # l2;\n        the_default {} \\<circ> b =\n        (\\<lambda>v. {j. j < length l1 \\<and> v \\<in> (l1 @ x # l2) ! j});\n        \\<sigma> = (length l1, b); xa \\<in> it; it \\<subseteq> x;\n        \\<sigma>' =\n        (\\<lambda>v.\n            if v \\<in> x \\<and> v \\<notin> it\n            then Some (insert (length l1) (the_default {} (b v))) else b v);\n        finite x \\<and>\n        (\\<forall>x\\<in>set l1 \\<union> set l2. finite x)\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>v.\n                              if v \\<in> x \\<and> v \\<notin> it\n                              then Some\n                                    (insert (length l1)\n(the_default {} (b v)))\n                              else b v)\n                          (xa \\<mapsto>\n                          insert (length l1) (the_default {} (b xa))))\n                          v =\n                         (if v \\<in> x \\<and>\n                             (v \\<in> it \\<longrightarrow> v = xa)\n                          then Some\n                                (insert (length l1) (the_default {} (b v)))\n                          else b v)\n 2. \\<And>x l1 l2 \\<sigma> b \\<sigma>' x1.\n       \\<lbrakk>Flist' = l1 @ x # l2; Flist = l1 @ x # l2;\n        the_default {} \\<circ> b =\n        (\\<lambda>v. {j. j < length l1 \\<and> v \\<in> (l1 @ x # l2) ! j});\n        \\<sigma> = (length l1, b);\n        \\<sigma>' =\n        (\\<lambda>v.\n            if v \\<in> x\n            then Some (insert (length l1) (the_default {} (b v))) else b v);\n        Suc (length l1) = x1;\n        finite x \\<and>\n        (\\<forall>x\\<in>set l1 \\<union> set l2. finite x)\\<rbrakk>\n       \\<Longrightarrow> the_default {} \\<circ>\n                         (\\<lambda>v.\n                             if v \\<in> x\n                             then Some\n                                   (insert (length l1)\n                                     (the_default {} (b v)))\n                             else b v) =\n                         (\\<lambda>v.\n                             {j. j < x1 \\<and> v \\<in> (l1 @ x # l2) ! j})\n 3. \\<And>\\<sigma> b.\n       \\<lbrakk>Flist' = Flist;\n        the_default {} \\<circ> b =\n        (\\<lambda>v. {j. j < length Flist \\<and> v \\<in> Flist ! j});\n        \\<sigma> = (length Flist, b);\n        \\<forall>x\\<in>set Flist. finite x\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>v.\n                             {i. i < length Flist \\<and>\n                                 v \\<in> Flist ! i}) =\n                         (\\<lambda>x. the_default {} (b x))", "apply (auto split: if_split_asm simp: nth_append nth_Cons') []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x l1 l2 \\<sigma> b \\<sigma>' x1.\n       \\<lbrakk>Flist' = l1 @ x # l2; Flist = l1 @ x # l2;\n        the_default {} \\<circ> b =\n        (\\<lambda>v. {j. j < length l1 \\<and> v \\<in> (l1 @ x # l2) ! j});\n        \\<sigma> = (length l1, b);\n        \\<sigma>' =\n        (\\<lambda>v.\n            if v \\<in> x\n            then Some (insert (length l1) (the_default {} (b v))) else b v);\n        Suc (length l1) = x1;\n        finite x \\<and>\n        (\\<forall>x\\<in>set l1 \\<union> set l2. finite x)\\<rbrakk>\n       \\<Longrightarrow> the_default {} \\<circ>\n                         (\\<lambda>v.\n                             if v \\<in> x\n                             then Some\n                                   (insert (length l1)\n                                     (the_default {} (b v)))\n                             else b v) =\n                         (\\<lambda>v.\n                             {j. j < x1 \\<and> v \\<in> (l1 @ x # l2) ! j})\n 2. \\<And>\\<sigma> b.\n       \\<lbrakk>Flist' = Flist;\n        the_default {} \\<circ> b =\n        (\\<lambda>v. {j. j < length Flist \\<and> v \\<in> Flist ! j});\n        \\<sigma> = (length Flist, b);\n        \\<forall>x\\<in>set Flist. finite x\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>v.\n                             {i. i < length Flist \\<and>\n                                 v \\<in> Flist ! i}) =\n                         (\\<lambda>x. the_default {} (b x))", "apply (rule ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x l1 l2 \\<sigma> b \\<sigma>' x1 v.\n       \\<lbrakk>Flist' = l1 @ x # l2; Flist = l1 @ x # l2;\n        the_default {} \\<circ> b =\n        (\\<lambda>v. {j. j < length l1 \\<and> v \\<in> (l1 @ x # l2) ! j});\n        \\<sigma> = (length l1, b);\n        \\<sigma>' =\n        (\\<lambda>v.\n            if v \\<in> x\n            then Some (insert (length l1) (the_default {} (b v))) else b v);\n        Suc (length l1) = x1;\n        finite x \\<and>\n        (\\<forall>x\\<in>set l1 \\<union> set l2. finite x)\\<rbrakk>\n       \\<Longrightarrow> (the_default {} \\<circ>\n                          (\\<lambda>v.\n                              if v \\<in> x\n                              then Some\n                                    (insert (length l1)\n(the_default {} (b v)))\n                              else b v))\n                          v =\n                         {j. j < x1 \\<and> v \\<in> (l1 @ x # l2) ! j}\n 2. \\<And>\\<sigma> b.\n       \\<lbrakk>Flist' = Flist;\n        the_default {} \\<circ> b =\n        (\\<lambda>v. {j. j < length Flist \\<and> v \\<in> Flist ! j});\n        \\<sigma> = (length Flist, b);\n        \\<forall>x\\<in>set Flist. finite x\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>v.\n                             {i. i < length Flist \\<and>\n                                 v \\<in> Flist ! i}) =\n                         (\\<lambda>x. the_default {} (b x))", "apply (auto split: if_split_asm simp: nth_append nth_Cons' \n    fun_comp_eq_conv) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> b.\n       \\<lbrakk>Flist' = Flist;\n        the_default {} \\<circ> b =\n        (\\<lambda>v. {j. j < length Flist \\<and> v \\<in> Flist ! j});\n        \\<sigma> = (length Flist, b);\n        \\<forall>x\\<in>set Flist. finite x\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>v.\n                             {i. i < length Flist \\<and>\n                                 v \\<in> Flist ! i}) =\n                         (\\<lambda>x. the_default {} (b x))", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> b v.\n       \\<lbrakk>Flist' = Flist;\n        the_default {} \\<circ> b =\n        (\\<lambda>v. {j. j < length Flist \\<and> v \\<in> Flist ! j});\n        \\<sigma> = (length Flist, b);\n        \\<forall>x\\<in>set Flist. finite x\\<rbrakk>\n       \\<Longrightarrow> {i. i < length Flist \\<and> v \\<in> Flist ! i} =\n                         the_default {} (b v)", "apply (auto simp: fun_comp_eq_conv) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition F_to_idx_impl :: \"'Q set set \\<Rightarrow> (nat \\<times> ('Q \\<Rightarrow> nat set)) nres\" where\n  \"F_to_idx_impl F \\<equiv> do {\n    Flist \\<leftarrow> SPEC (\\<lambda>Flist. distinct Flist \\<and> set Flist = F);\n    let num_acc = length Flist;\n    acc \\<leftarrow> mk_acc_impl Flist;\n    RETURN (num_acc,acc)\n  }\""], ["", "lemma F_to_idx_refine: \n  assumes FIN: \"\\<forall>A\\<in>F. finite A\"\n  shows \"F_to_idx_impl F \\<le> \\<Down>Id (F_to_idx F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F_to_idx_impl F \\<le> \\<Down> Id (F_to_idx F)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>F. finite A\n\ngoal (1 subgoal):\n 1. F_to_idx_impl F \\<le> \\<Down> Id (F_to_idx F)", "unfolding F_to_idx_impl_def F_to_idx_def"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>F. finite A\n\ngoal (1 subgoal):\n 1. SPEC (\\<lambda>Flist. distinct Flist \\<and> set Flist = F) \\<bind>\n    (\\<lambda>Flist.\n        let num_acc = length Flist\n        in mk_acc_impl Flist \\<bind> (\\<lambda>acc. RETURN (num_acc, acc)))\n    \\<le> \\<Down> Id\n           (SPEC\n             (\\<lambda>Flist. distinct Flist \\<and> set Flist = F) \\<bind>\n            (\\<lambda>Flist.\n                let num_acc = length Flist;\n                    acc =\n                      \\<lambda>v. {i. i < num_acc \\<and> v \\<in> Flist ! i}\n                in RETURN (num_acc, acc)))", "apply (refine_rcg bind_Let_refine2[OF mk_acc_impl_correct])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Flist Flista.\n       \\<lbrakk>\\<forall>A\\<in>F. finite A; (Flist, Flista) \\<in> Id;\n        Flist \\<in> {Flist. distinct Flist \\<and> set Flist = F};\n        Flista \\<in> {Flist. distinct Flist \\<and> set Flist = F}\\<rbrakk>\n       \\<Longrightarrow> \\<forall>A\\<in>set Flista. finite A\n 2. \\<And>Flist Flista acc.\n       \\<lbrakk>\\<forall>A\\<in>F. finite A; (Flist, Flista) \\<in> Id;\n        Flist \\<in> {Flist. distinct Flist \\<and> set Flist = F};\n        Flista \\<in> {Flist. distinct Flist \\<and> set Flist = F};\n        inres (mk_acc_impl Flist) acc;\n        (acc, \\<lambda>v. {i. i < length Flista \\<and> v \\<in> Flista ! i})\n        \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> ((length Flist, acc), length Flista,\n                          \\<lambda>v.\n                             {i. i < length Flista \\<and>\n                                 v \\<in> Flista ! i})\n                         \\<in> Id", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition gbg_to_idx_ext \n  :: \"_ \\<Rightarrow> ('a, 'more) gb_graph_rec_scheme \\<Rightarrow> ('a, 'more') igb_graph_rec_scheme nres\"\n  where \"gbg_to_idx_ext ecnv A = do {\n  (num_acc,acc) \\<leftarrow> F_to_idx_impl (gbg_F A); \n  RETURN \\<lparr> \n    g_V = g_V A,\n    g_E = g_E A, \n    g_V0=g_V0 A, \n    igbg_num_acc = num_acc, \n    igbg_acc = acc,\n    \\<dots> = ecnv A\n  \\<rparr>\n}\""], ["", "lemma (in gb_graph) gbg_to_idx_ext_correct:\n  assumes [simp, intro]: \"\\<And> A. A \\<in> F \\<Longrightarrow> finite A\"\n  shows \"gbg_to_idx_ext ecnv G \\<le> SPEC (\\<lambda>G'. \n    igb_graph.is_acc_run G' = is_acc_run \n  \\<and> g_V G' = V\n  \\<and> g_E G' = E\n  \\<and> g_V0 G' = V0\n  \\<and> igb_graph_rec.more G' = ecnv G\n  \\<and> igb_graph G'\n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "note F_to_idx_refine[of F]"], ["proof (state)\nthis:\n  \\<forall>A\\<in>F. finite A \\<Longrightarrow>\n  F_to_idx_impl F \\<le> \\<Down> Id (F_to_idx F)\n\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "also"], ["proof (state)\nthis:\n  \\<forall>A\\<in>F. finite A \\<Longrightarrow>\n  F_to_idx_impl F \\<le> \\<Down> Id (F_to_idx F)\n\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "note F_to_idx_correct"], ["proof (state)\nthis:\n  F_to_idx ?F\n  \\<le> SPEC\n         (\\<lambda>(num_acc, acc).\n             ?F = {{q. i \\<in> acc q} |i. i < num_acc} \\<and>\n             \\<Union> (range acc) \\<subseteq> {0..<num_acc})\n\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "finally"], ["proof (chain)\npicking this:\n  \\<forall>A\\<in>F. finite A \\<Longrightarrow>\n  F_to_idx_impl F\n  \\<le> SPEC\n         (\\<lambda>(num_acc, acc).\n             F = {{q. i \\<in> acc q} |i. i < num_acc} \\<and>\n             \\<Union> (range acc) \\<subseteq> {0..<num_acc})", "have R: \"F_to_idx_impl F\n    \\<le> SPEC (\\<lambda>(num_acc, acc). F = {{q. i \\<in> acc q} |i. i < num_acc}\n      \\<and> \\<Union>(range acc) \\<subseteq> {0..<num_acc})\""], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>F. finite A \\<Longrightarrow>\n  F_to_idx_impl F\n  \\<le> SPEC\n         (\\<lambda>(num_acc, acc).\n             F = {{q. i \\<in> acc q} |i. i < num_acc} \\<and>\n             \\<Union> (range acc) \\<subseteq> {0..<num_acc})\n\ngoal (1 subgoal):\n 1. F_to_idx_impl F\n    \\<le> SPEC\n           (\\<lambda>(num_acc, acc).\n               F = {{q. i \\<in> acc q} |i. i < num_acc} \\<and>\n               \\<Union> (range acc) \\<subseteq> {0..<num_acc})", "by simp"], ["proof (state)\nthis:\n  F_to_idx_impl F\n  \\<le> SPEC\n         (\\<lambda>(num_acc, acc).\n             F = {{q. i \\<in> acc q} |i. i < num_acc} \\<and>\n             \\<Union> (range acc) \\<subseteq> {0..<num_acc})\n\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "have eq_conjI: \"\\<And>a b c. (b\\<longleftrightarrow>c) \\<Longrightarrow> (a&b \\<longleftrightarrow> a&c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c. b = c \\<Longrightarrow> (a \\<and> b) = (a \\<and> c)", "by simp"], ["proof (state)\nthis:\n  ?b = ?c \\<Longrightarrow> (?a \\<and> ?b) = (?a \\<and> ?c)\n\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "{"], ["proof (state)\nthis:\n  ?b = ?c \\<Longrightarrow> (?a \\<and> ?b) = (?a \\<and> ?c)\n\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "fix acc :: \"'Q \\<Rightarrow> nat set\" and num_acc r"], ["proof (state)\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "have \"(\\<forall>A. (\\<exists>i. A = {q. i \\<in> acc q} \\<and> i < num_acc) \\<longrightarrow> (limit r \\<inter> A \\<noteq> {})) \n      \\<longleftrightarrow> (\\<forall>i<num_acc. \\<exists>q\\<in>limit r. i\\<in>acc q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>A.\n        (\\<exists>i.\n            A = {q. i \\<in> acc q} \\<and> i < num_acc) \\<longrightarrow>\n        limit r \\<inter> A \\<noteq> {}) =\n    (\\<forall>i<num_acc. \\<exists>q\\<in>limit r. i \\<in> acc q)", "by blast"], ["proof (state)\nthis:\n  (\\<forall>A.\n      (\\<exists>i.\n          A = {q. i \\<in> acc q} \\<and> i < num_acc) \\<longrightarrow>\n      limit r \\<inter> A \\<noteq> {}) =\n  (\\<forall>i<num_acc. \\<exists>q\\<in>limit r. i \\<in> acc q)\n\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "}"], ["proof (state)\nthis:\n  (\\<forall>A.\n      (\\<exists>i.\n          A = {q. i \\<in> ?acc2 q} \\<and> i < ?num_acc2) \\<longrightarrow>\n      limit ?r2 \\<inter> A \\<noteq> {}) =\n  (\\<forall>i<?num_acc2. \\<exists>q\\<in>limit ?r2. i \\<in> ?acc2 q)\n\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "note aux1=this"], ["proof (state)\nthis:\n  (\\<forall>A.\n      (\\<exists>i.\n          A = {q. i \\<in> ?acc2 q} \\<and> i < ?num_acc2) \\<longrightarrow>\n      limit ?r2 \\<inter> A \\<noteq> {}) =\n  (\\<forall>i<?num_acc2. \\<exists>q\\<in>limit ?r2. i \\<in> ?acc2 q)\n\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "{"], ["proof (state)\nthis:\n  (\\<forall>A.\n      (\\<exists>i.\n          A = {q. i \\<in> ?acc2 q} \\<and> i < ?num_acc2) \\<longrightarrow>\n      limit ?r2 \\<inter> A \\<noteq> {}) =\n  (\\<forall>i<?num_acc2. \\<exists>q\\<in>limit ?r2. i \\<in> ?acc2 q)\n\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "fix acc :: \"'Q \\<Rightarrow> nat set\" and num_acc i"], ["proof (state)\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "assume FE: \"F = {{q. i \\<in> acc q} |i. i < num_acc}\""], ["proof (state)\nthis:\n  F = {{q. i \\<in> acc q} |i. i < num_acc}\n\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "assume INR: \"(\\<Union>x. acc x) \\<subseteq> {0..<num_acc}\""], ["proof (state)\nthis:\n  \\<Union> (range acc) \\<subseteq> {0..<num_acc}\n\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "have \"finite {q. i \\<in> acc q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {q. i \\<in> acc q}", "proof (cases \"i<num_acc\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < num_acc \\<Longrightarrow> finite {q. i \\<in> acc q}\n 2. \\<not> i < num_acc \\<Longrightarrow> finite {q. i \\<in> acc q}", "case True"], ["proof (state)\nthis:\n  i < num_acc\n\ngoal (2 subgoals):\n 1. i < num_acc \\<Longrightarrow> finite {q. i \\<in> acc q}\n 2. \\<not> i < num_acc \\<Longrightarrow> finite {q. i \\<in> acc q}", "thus ?thesis"], ["proof (prove)\nusing this:\n  i < num_acc\n\ngoal (1 subgoal):\n 1. finite {q. i \\<in> acc q}", "using FE"], ["proof (prove)\nusing this:\n  i < num_acc\n  F = {{q. i \\<in> acc q} |i. i < num_acc}\n\ngoal (1 subgoal):\n 1. finite {q. i \\<in> acc q}", "by auto"], ["proof (state)\nthis:\n  finite {q. i \\<in> acc q}\n\ngoal (1 subgoal):\n 1. \\<not> i < num_acc \\<Longrightarrow> finite {q. i \\<in> acc q}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < num_acc \\<Longrightarrow> finite {q. i \\<in> acc q}", "case False"], ["proof (state)\nthis:\n  \\<not> i < num_acc\n\ngoal (1 subgoal):\n 1. \\<not> i < num_acc \\<Longrightarrow> finite {q. i \\<in> acc q}", "hence \"{q. i \\<in> acc q} = {}\""], ["proof (prove)\nusing this:\n  \\<not> i < num_acc\n\ngoal (1 subgoal):\n 1. {q. i \\<in> acc q} = {}", "using INR"], ["proof (prove)\nusing this:\n  \\<not> i < num_acc\n  \\<Union> (range acc) \\<subseteq> {0..<num_acc}\n\ngoal (1 subgoal):\n 1. {q. i \\<in> acc q} = {}", "by force"], ["proof (state)\nthis:\n  {q. i \\<in> acc q} = {}\n\ngoal (1 subgoal):\n 1. \\<not> i < num_acc \\<Longrightarrow> finite {q. i \\<in> acc q}", "thus ?thesis"], ["proof (prove)\nusing this:\n  {q. i \\<in> acc q} = {}\n\ngoal (1 subgoal):\n 1. finite {q. i \\<in> acc q}", "by simp"], ["proof (state)\nthis:\n  finite {q. i \\<in> acc q}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite {q. i \\<in> acc q}\n\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "}"], ["proof (state)\nthis:\n  \\<lbrakk>F = {{q. i \\<in> ?acc2 q} |i. i < ?num_acc2};\n   \\<Union> (range ?acc2) \\<subseteq> {0..<?num_acc2}\\<rbrakk>\n  \\<Longrightarrow> finite {q. ?i2 \\<in> ?acc2 q}\n\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "note aux2=this"], ["proof (state)\nthis:\n  \\<lbrakk>F = {{q. i \\<in> ?acc2 q} |i. i < ?num_acc2};\n   \\<Union> (range ?acc2) \\<subseteq> {0..<?num_acc2}\\<rbrakk>\n  \\<Longrightarrow> finite {q. ?i2 \\<in> ?acc2 q}\n\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "{"], ["proof (state)\nthis:\n  \\<lbrakk>F = {{q. i \\<in> ?acc2 q} |i. i < ?num_acc2};\n   \\<Union> (range ?acc2) \\<subseteq> {0..<?num_acc2}\\<rbrakk>\n  \\<Longrightarrow> finite {q. ?i2 \\<in> ?acc2 q}\n\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "fix acc :: \"'Q \\<Rightarrow> nat set\" and num_acc q"], ["proof (state)\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "assume FE: \"F = {{q. i \\<in> acc q} |i. i < num_acc}\"\n      and INR: \"(\\<Union>x. acc x) \\<subseteq> {0..<num_acc}\"\n      and \"acc q \\<noteq> {}\""], ["proof (state)\nthis:\n  F = {{q. i \\<in> acc q} |i. i < num_acc}\n  \\<Union> (range acc) \\<subseteq> {0..<num_acc}\n  acc q \\<noteq> {}\n\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "then"], ["proof (chain)\npicking this:\n  F = {{q. i \\<in> acc q} |i. i < num_acc}\n  \\<Union> (range acc) \\<subseteq> {0..<num_acc}\n  acc q \\<noteq> {}", "obtain i where \"i\\<in>acc q\""], ["proof (prove)\nusing this:\n  F = {{q. i \\<in> acc q} |i. i < num_acc}\n  \\<Union> (range acc) \\<subseteq> {0..<num_acc}\n  acc q \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>i. i \\<in> acc q \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i \\<in> acc q\n\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "moreover"], ["proof (state)\nthis:\n  i \\<in> acc q\n\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "with INR"], ["proof (chain)\npicking this:\n  \\<Union> (range acc) \\<subseteq> {0..<num_acc}\n  i \\<in> acc q", "have \"i<num_acc\""], ["proof (prove)\nusing this:\n  \\<Union> (range acc) \\<subseteq> {0..<num_acc}\n  i \\<in> acc q\n\ngoal (1 subgoal):\n 1. i < num_acc", "by force"], ["proof (state)\nthis:\n  i < num_acc\n\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "ultimately"], ["proof (chain)\npicking this:\n  i \\<in> acc q\n  i < num_acc", "have \"q\\<in>\\<Union>F\""], ["proof (prove)\nusing this:\n  i \\<in> acc q\n  i < num_acc\n\ngoal (1 subgoal):\n 1. q \\<in> \\<Union> F", "by (auto simp: FE)"], ["proof (state)\nthis:\n  q \\<in> \\<Union> F\n\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "with F_ss"], ["proof (chain)\npicking this:\n  F \\<subseteq> Pow V\n  q \\<in> \\<Union> F", "have \"q\\<in>V\""], ["proof (prove)\nusing this:\n  F \\<subseteq> Pow V\n  q \\<in> \\<Union> F\n\ngoal (1 subgoal):\n 1. q \\<in> V", "by auto"], ["proof (state)\nthis:\n  q \\<in> V\n\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "}"], ["proof (state)\nthis:\n  \\<lbrakk>F = {{q. i \\<in> ?acc2 q} |i. i < ?num_acc2};\n   \\<Union> (range ?acc2) \\<subseteq> {0..<?num_acc2};\n   ?acc2 ?q2 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?q2 \\<in> V\n\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "note aux3=this"], ["proof (state)\nthis:\n  \\<lbrakk>F = {{q. i \\<in> ?acc2 q} |i. i < ?num_acc2};\n   \\<Union> (range ?acc2) \\<subseteq> {0..<?num_acc2};\n   ?acc2 ?q2 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ?q2 \\<in> V\n\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. gbg_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "unfolding gbg_to_idx_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. F_to_idx_impl F \\<bind>\n    (\\<lambda>(num_acc, acc).\n        RETURN\n         \\<lparr>g_V = V, g_E = E, g_V0 = V0, igbg_num_acc = num_acc,\n            igbg_acc = acc, \\<dots> = ecnv G\\<rparr>)\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igb_graph.is_acc_run G' = is_acc_run \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and>\n               igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')", "apply (refine_rcg order_trans[OF R] refine_vcg)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x a b.\n       \\<lbrakk>case x of\n                (num_acc, acc) \\<Rightarrow>\n                  F = {{q. i \\<in> acc q} |i. i < num_acc} \\<and>\n                  \\<Union> (range acc) \\<subseteq> {0..<num_acc};\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> igb_graph.is_acc_run\n                          \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                             igbg_num_acc = a, igbg_acc = b,\n                             \\<dots> = ecnv G\\<rparr> =\n                         is_acc_run\n 2. \\<And>x a b.\n       \\<lbrakk>case x of\n                (num_acc, acc) \\<Rightarrow>\n                  F = {{q. i \\<in> acc q} |i. i < num_acc} \\<and>\n                  \\<Union> (range acc) \\<subseteq> {0..<num_acc};\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> g_V \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                                igbg_num_acc = a, igbg_acc = b,\n                                \\<dots> = ecnv G\\<rparr> =\n                         V\n 3. \\<And>x a b.\n       \\<lbrakk>case x of\n                (num_acc, acc) \\<Rightarrow>\n                  F = {{q. i \\<in> acc q} |i. i < num_acc} \\<and>\n                  \\<Union> (range acc) \\<subseteq> {0..<num_acc};\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> g_E \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                                igbg_num_acc = a, igbg_acc = b,\n                                \\<dots> = ecnv G\\<rparr> =\n                         E\n 4. \\<And>x a b.\n       \\<lbrakk>case x of\n                (num_acc, acc) \\<Rightarrow>\n                  F = {{q. i \\<in> acc q} |i. i < num_acc} \\<and>\n                  \\<Union> (range acc) \\<subseteq> {0..<num_acc};\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> g_V0\n                          \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                             igbg_num_acc = a, igbg_acc = b,\n                             \\<dots> = ecnv G\\<rparr> =\n                         V0\n 5. \\<And>x a b.\n       \\<lbrakk>case x of\n                (num_acc, acc) \\<Rightarrow>\n                  F = {{q. i \\<in> acc q} |i. i < num_acc} \\<and>\n                  \\<Union> (range acc) \\<subseteq> {0..<num_acc};\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> igb_graph_rec.more\n                          \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                             igbg_num_acc = a, igbg_acc = b,\n                             \\<dots> = ecnv G\\<rparr> =\n                         ecnv G\n 6. \\<And>x a b.\n       \\<lbrakk>case x of\n                (num_acc, acc) \\<Rightarrow>\n                  F = {{q. i \\<in> acc q} |i. i < num_acc} \\<and>\n                  \\<Union> (range acc) \\<subseteq> {0..<num_acc};\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> igb_graph\n                          \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                             igbg_num_acc = a, igbg_acc = b,\n                             \\<dots> = ecnv G\\<rparr>", "proof clarsimp_all"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>aa ba.\n       \\<lbrakk>F = {{q. i \\<in> ba q} |i. i < aa};\n        \\<Union> (range ba) \\<subseteq> {0..<aa}\\<rbrakk>\n       \\<Longrightarrow> igb_graph.is_acc_run\n                          \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                             igbg_num_acc = aa, igbg_acc = ba,\n                             \\<dots> = ecnv G\\<rparr> =\n                         is_acc_run\n 2. \\<And>aa ba.\n       \\<lbrakk>F = {{q. i \\<in> ba q} |i. i < aa};\n        \\<Union> (range ba) \\<subseteq> {0..<aa}\\<rbrakk>\n       \\<Longrightarrow> igb_graph\n                          \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                             igbg_num_acc = aa, igbg_acc = ba,\n                             \\<dots> = ecnv G\\<rparr>", "fix acc and num_acc :: nat"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>aa ba.\n       \\<lbrakk>F = {{q. i \\<in> ba q} |i. i < aa};\n        \\<Union> (range ba) \\<subseteq> {0..<aa}\\<rbrakk>\n       \\<Longrightarrow> igb_graph.is_acc_run\n                          \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                             igbg_num_acc = aa, igbg_acc = ba,\n                             \\<dots> = ecnv G\\<rparr> =\n                         is_acc_run\n 2. \\<And>aa ba.\n       \\<lbrakk>F = {{q. i \\<in> ba q} |i. i < aa};\n        \\<Union> (range ba) \\<subseteq> {0..<aa}\\<rbrakk>\n       \\<Longrightarrow> igb_graph\n                          \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                             igbg_num_acc = aa, igbg_acc = ba,\n                             \\<dots> = ecnv G\\<rparr>", "assume FE[simp]: \"F = {{q. i \\<in> acc q} |i. i < num_acc}\"\n      and BOUND: \"(\\<Union>x. acc x) \\<subseteq> {0..<num_acc}\""], ["proof (state)\nthis:\n  F = {{q. i \\<in> acc q} |i. i < num_acc}\n  \\<Union> (range acc) \\<subseteq> {0..<num_acc}\n\ngoal (2 subgoals):\n 1. \\<And>aa ba.\n       \\<lbrakk>F = {{q. i \\<in> ba q} |i. i < aa};\n        \\<Union> (range ba) \\<subseteq> {0..<aa}\\<rbrakk>\n       \\<Longrightarrow> igb_graph.is_acc_run\n                          \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                             igbg_num_acc = aa, igbg_acc = ba,\n                             \\<dots> = ecnv G\\<rparr> =\n                         is_acc_run\n 2. \\<And>aa ba.\n       \\<lbrakk>F = {{q. i \\<in> ba q} |i. i < aa};\n        \\<Union> (range ba) \\<subseteq> {0..<aa}\\<rbrakk>\n       \\<Longrightarrow> igb_graph\n                          \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                             igbg_num_acc = aa, igbg_acc = ba,\n                             \\<dots> = ecnv G\\<rparr>", "let ?G' = \"\\<lparr>\n      g_V = V, \n      g_E = E, \n      g_V0 = V0, \n      igbg_num_acc = num_acc, \n      igbg_acc = acc,\n      \\<dots> = ecnv G\\<rparr>\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>aa ba.\n       \\<lbrakk>F = {{q. i \\<in> ba q} |i. i < aa};\n        \\<Union> (range ba) \\<subseteq> {0..<aa}\\<rbrakk>\n       \\<Longrightarrow> igb_graph.is_acc_run\n                          \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                             igbg_num_acc = aa, igbg_acc = ba,\n                             \\<dots> = ecnv G\\<rparr> =\n                         is_acc_run\n 2. \\<And>aa ba.\n       \\<lbrakk>F = {{q. i \\<in> ba q} |i. i < aa};\n        \\<Union> (range ba) \\<subseteq> {0..<aa}\\<rbrakk>\n       \\<Longrightarrow> igb_graph\n                          \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                             igbg_num_acc = aa, igbg_acc = ba,\n                             \\<dots> = ecnv G\\<rparr>", "interpret G': igb_graph ?G'"], ["proof (prove)\ngoal (1 subgoal):\n 1. igb_graph\n     \\<lparr>g_V = V, g_E = E, g_V0 = V0, igbg_num_acc = num_acc,\n        igbg_acc = acc, \\<dots> = ecnv G\\<rparr>", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. g_V0\n     \\<lparr>g_V = V, g_E = E, g_V0 = V0, igbg_num_acc = num_acc,\n        igbg_acc = acc, \\<dots> = ecnv G\\<rparr>\n    \\<subseteq> g_V \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                       igbg_num_acc = num_acc, igbg_acc = acc,\n                       \\<dots> = ecnv G\\<rparr>\n 2. g_E \\<lparr>g_V = V, g_E = E, g_V0 = V0, igbg_num_acc = num_acc,\n           igbg_acc = acc, \\<dots> = ecnv G\\<rparr>\n    \\<subseteq> g_V \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                       igbg_num_acc = num_acc, igbg_acc = acc,\n                       \\<dots> = ecnv G\\<rparr> \\<times>\n                g_V \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                       igbg_num_acc = num_acc, igbg_acc = acc,\n                       \\<dots> = ecnv G\\<rparr>\n 3. \\<Union>\n     (range\n       (igbg_acc\n         \\<lparr>g_V = V, g_E = E, g_V0 = V0, igbg_num_acc = num_acc,\n            igbg_acc = acc, \\<dots> = ecnv G\\<rparr>))\n    \\<subseteq> {0..<igbg_num_acc\n                      \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                         igbg_num_acc = num_acc, igbg_acc = acc,\n                         \\<dots> = ecnv G\\<rparr>}\n 4. \\<And>q.\n       igbg_acc\n        \\<lparr>g_V = V, g_E = E, g_V0 = V0, igbg_num_acc = num_acc,\n           igbg_acc = acc, \\<dots> = ecnv G\\<rparr>\n        q \\<noteq>\n       {} \\<Longrightarrow>\n       q \\<in> g_V \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                      igbg_num_acc = num_acc, igbg_acc = acc,\n                      \\<dots> = ecnv G\\<rparr>", "using V0_ss E_ss"], ["proof (prove)\nusing this:\n  V0 \\<subseteq> V\n  E \\<subseteq> V \\<times> V\n\ngoal (4 subgoals):\n 1. g_V0\n     \\<lparr>g_V = V, g_E = E, g_V0 = V0, igbg_num_acc = num_acc,\n        igbg_acc = acc, \\<dots> = ecnv G\\<rparr>\n    \\<subseteq> g_V \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                       igbg_num_acc = num_acc, igbg_acc = acc,\n                       \\<dots> = ecnv G\\<rparr>\n 2. g_E \\<lparr>g_V = V, g_E = E, g_V0 = V0, igbg_num_acc = num_acc,\n           igbg_acc = acc, \\<dots> = ecnv G\\<rparr>\n    \\<subseteq> g_V \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                       igbg_num_acc = num_acc, igbg_acc = acc,\n                       \\<dots> = ecnv G\\<rparr> \\<times>\n                g_V \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                       igbg_num_acc = num_acc, igbg_acc = acc,\n                       \\<dots> = ecnv G\\<rparr>\n 3. \\<Union>\n     (range\n       (igbg_acc\n         \\<lparr>g_V = V, g_E = E, g_V0 = V0, igbg_num_acc = num_acc,\n            igbg_acc = acc, \\<dots> = ecnv G\\<rparr>))\n    \\<subseteq> {0..<igbg_num_acc\n                      \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                         igbg_num_acc = num_acc, igbg_acc = acc,\n                         \\<dots> = ecnv G\\<rparr>}\n 4. \\<And>q.\n       igbg_acc\n        \\<lparr>g_V = V, g_E = E, g_V0 = V0, igbg_num_acc = num_acc,\n           igbg_acc = acc, \\<dots> = ecnv G\\<rparr>\n        q \\<noteq>\n       {} \\<Longrightarrow>\n       q \\<in> g_V \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                      igbg_num_acc = num_acc, igbg_acc = acc,\n                      \\<dots> = ecnv G\\<rparr>", "apply (auto simp add: aux2 aux3 BOUND)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>aa ba.\n       \\<lbrakk>F = {{q. i \\<in> ba q} |i. i < aa};\n        \\<Union> (range ba) \\<subseteq> {0..<aa}\\<rbrakk>\n       \\<Longrightarrow> igb_graph.is_acc_run\n                          \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                             igbg_num_acc = aa, igbg_acc = ba,\n                             \\<dots> = ecnv G\\<rparr> =\n                         is_acc_run\n 2. \\<And>aa ba.\n       \\<lbrakk>F = {{q. i \\<in> ba q} |i. i < aa};\n        \\<Union> (range ba) \\<subseteq> {0..<aa}\\<rbrakk>\n       \\<Longrightarrow> igb_graph\n                          \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                             igbg_num_acc = aa, igbg_acc = ba,\n                             \\<dots> = ecnv G\\<rparr>", "show \"igb_graph ?G'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igb_graph\n     \\<lparr>g_V = V, g_E = E, g_V0 = V0, igbg_num_acc = num_acc,\n        igbg_acc = acc, \\<dots> = ecnv G\\<rparr>", "by unfold_locales"], ["proof (state)\nthis:\n  igb_graph\n   \\<lparr>g_V = V, g_E = E, g_V0 = V0, igbg_num_acc = num_acc,\n      igbg_acc = acc, \\<dots> = ecnv G\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>aa ba.\n       \\<lbrakk>F = {{q. i \\<in> ba q} |i. i < aa};\n        \\<Union> (range ba) \\<subseteq> {0..<aa}\\<rbrakk>\n       \\<Longrightarrow> igb_graph.is_acc_run\n                          \\<lparr>g_V = V, g_E = E, g_V0 = V0,\n                             igbg_num_acc = aa, igbg_acc = ba,\n                             \\<dots> = ecnv G\\<rparr> =\n                         is_acc_run", "show \"G'.is_acc_run = is_acc_run\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G'.is_acc_run = is_acc_run", "unfolding G'.is_acc_run_def[abs_def] is_acc_run_def[abs_def] \n        G'.is_run_def[abs_def] is_run_def[abs_def]\n        G'.is_acc_def[abs_def] is_acc_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>r.\n        (r 0 \\<in> G'.V0 \\<and> ipath G'.E r) \\<and>\n        (\\<forall>n<G'.num_acc.\n            \\<exists>\\<^sub>\\<infinity>i. n \\<in> G'.acc (r i))) =\n    (\\<lambda>r.\n        (r 0 \\<in> V0 \\<and> ipath E r) \\<and>\n        (\\<forall>A\\<in>F. \\<exists>\\<^sub>\\<infinity>i. r i \\<in> A))", "apply (clarsimp intro!: ext eq_conjI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r.\n       (\\<forall>n<num_acc.\n           \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (r i)) =\n       (\\<forall>A.\n           (\\<exists>i.\n               A = {q. i \\<in> acc q} \\<and> i < num_acc) \\<longrightarrow>\n           (\\<exists>\\<^sub>\\<infinity>i. r i \\<in> A))", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r n.\n       \\<lbrakk>\\<forall>A.\n                   (\\<exists>i.\n                       A = {q. i \\<in> acc q} \\<and>\n                       i < num_acc) \\<longrightarrow>\n                   (\\<exists>\\<^sub>\\<infinity>i. r i \\<in> A);\n        n < num_acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (r i)", "apply (metis (lifting, no_types) INFM_mono mem_Collect_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  G'.is_acc_run = is_acc_run\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gbg_to_idx_ext ecnv G\n  \\<le> SPEC\n         (\\<lambda>G'.\n             igb_graph.is_acc_run G' = is_acc_run \\<and>\n             g_V G' = V \\<and>\n             g_E G' = E \\<and>\n             g_V0 G' = V0 \\<and>\n             igb_graph_rec.more G' = ecnv G \\<and> igb_graph G')\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation gbg_to_idx :: \"('q,_) gb_graph_rec_scheme \\<Rightarrow> 'q igb_graph_rec nres\"\n  where \"gbg_to_idx \\<equiv> gbg_to_idx_ext (\\<lambda>_. ())\""], ["", "definition ti_Lcnv where \"ti_Lcnv ecnv A \\<equiv> \\<lparr> igba_L = gba_L A, \\<dots>=ecnv A \\<rparr>\""], ["", "abbreviation \"gba_to_idx_ext ecnv \\<equiv> gbg_to_idx_ext (ti_Lcnv ecnv)\""], ["", "abbreviation \"gba_to_idx \\<equiv> gba_to_idx_ext (\\<lambda>_. ())\""], ["", "lemma (in gba) gba_to_idx_ext_correct:\n  assumes [simp, intro]: \"\\<And> A. A \\<in> F \\<Longrightarrow> finite A\"\n  shows \"gba_to_idx_ext ecnv G \\<le> \n    SPEC (\\<lambda>G'.\n    igba.accept G' = accept \n  \\<and> g_V G' = V\n  \\<and> g_E G' = E\n  \\<and> g_V0 G' = V0\n  \\<and> igba_rec.more G' = ecnv G\n  \\<and> igba G')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gba_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igba.accept G' = accept \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and> igba_rec.more G' = ecnv G \\<and> igba G')", "apply (rule order_trans[OF gbg_to_idx_ext_correct])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A. A \\<in> F \\<Longrightarrow> finite A\n 2. SPEC\n     (\\<lambda>G'.\n         igb_graph.is_acc_run G' = is_acc_run \\<and>\n         g_V G' = V \\<and>\n         g_E G' = E \\<and>\n         g_V0 G' = V0 \\<and>\n         igb_graph_rec.more G' = ti_Lcnv ecnv G \\<and> igb_graph G')\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igba.accept G' = accept \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and> igba_rec.more G' = ecnv G \\<and> igba G')", "apply (rule, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC\n     (\\<lambda>G'.\n         igb_graph.is_acc_run G' = is_acc_run \\<and>\n         g_V G' = V \\<and>\n         g_E G' = E \\<and>\n         g_V0 G' = V0 \\<and>\n         igb_graph_rec.more G' = ti_Lcnv ecnv G \\<and> igb_graph G')\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igba.accept G' = accept \\<and>\n               g_V G' = V \\<and>\n               g_E G' = E \\<and>\n               g_V0 G' = V0 \\<and> igba_rec.more G' = ecnv G \\<and> igba G')", "apply (rule SPEC_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       igb_graph.is_acc_run x = is_acc_run \\<and>\n       g_V x = V \\<and>\n       g_E x = E \\<and>\n       g_V0 x = V0 \\<and>\n       igb_graph_rec.more x = ti_Lcnv ecnv G \\<and>\n       igb_graph x \\<Longrightarrow>\n       igba.accept x = accept \\<and>\n       g_V x = V \\<and>\n       g_E x = E \\<and>\n       g_V0 x = V0 \\<and> igba_rec.more x = ecnv G \\<and> igba x", "apply (elim conjE, intro conjI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> igba.accept x = accept\n 2. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> g_V x = V\n 3. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> g_E x = E\n 4. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> g_V0 x = V0\n 5. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> igba_rec.more x = ecnv G\n 6. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> igba x", "proof -"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> igba.accept x = accept\n 2. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> g_V x = V\n 3. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> g_E x = E\n 4. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> g_V0 x = V0\n 5. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> igba_rec.more x = ecnv G\n 6. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> igba x", "fix G'"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> igba.accept x = accept\n 2. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> g_V x = V\n 3. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> g_E x = E\n 4. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> g_V0 x = V0\n 5. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> igba_rec.more x = ecnv G\n 6. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> igba x", "assume \n    ARUN: \"igb_graph.is_acc_run G' = is_acc_run\"\n    and MORE: \"igb_graph_rec.more G' = ti_Lcnv ecnv G\" \n    and LOC: \"igb_graph G'\"\n    and FIELDS: \"g_V G' = V\" \"g_E G' = E\" \"g_V0 G' = V0\""], ["proof (state)\nthis:\n  igb_graph.is_acc_run G' = is_acc_run\n  igb_graph_rec.more G' = ti_Lcnv ecnv G\n  igb_graph G'\n  g_V G' = V\n  g_E G' = E\n  g_V0 G' = V0\n\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> igba.accept x = accept\n 2. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> g_V x = V\n 3. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> g_E x = E\n 4. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> g_V0 x = V0\n 5. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> igba_rec.more x = ecnv G\n 6. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> igba x", "from LOC"], ["proof (chain)\npicking this:\n  igb_graph G'", "interpret igb: igb_graph G'"], ["proof (prove)\nusing this:\n  igb_graph G'\n\ngoal (1 subgoal):\n 1. igb_graph G'", "."], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> igba.accept x = accept\n 2. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> g_V x = V\n 3. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> g_E x = E\n 4. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> g_V0 x = V0\n 5. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> igba_rec.more x = ecnv G\n 6. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> igba x", "interpret igb: igba G'"], ["proof (prove)\ngoal (1 subgoal):\n 1. igba G'", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q l. igba_L G' q l \\<Longrightarrow> q \\<in> igb.V", "using MORE FIELDS L_ss"], ["proof (prove)\nusing this:\n  igb_graph_rec.more G' = ti_Lcnv ecnv G\n  igb.V = V\n  igb.E = E\n  igb.V0 = V0\n  L ?q ?l \\<Longrightarrow> ?q \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>q l. igba_L G' q l \\<Longrightarrow> q \\<in> igb.V", "unfolding ti_Lcnv_def"], ["proof (prove)\nusing this:\n  igb_graph_rec.more G' = \\<lparr>igba_L = L, \\<dots> = ecnv G\\<rparr>\n  igb.V = V\n  igb.E = E\n  igb.V0 = V0\n  L ?q ?l \\<Longrightarrow> ?q \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>q l. igba_L G' q l \\<Longrightarrow> q \\<in> igb.V", "apply (cases G')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q l g_V g_E g_V0 igbg_num_acc igbg_acc igba_La morea.\n       \\<lbrakk>igba_L G' q l;\n        igb_graph_rec.more G' =\n        \\<lparr>igba_L = L, \\<dots> = ecnv G\\<rparr>;\n        igb.V = V; igb.E = E; igb.V0 = V0;\n        \\<And>q l. L q l \\<Longrightarrow> q \\<in> V;\n        G' =\n        \\<lparr>g_V = g_V, g_E = g_E, g_V0 = g_V0,\n           igbg_num_acc = igbg_num_acc, igbg_acc = igbg_acc,\n           igba_L = igba_La, \\<dots> = morea\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> q \\<in> igb.V", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> igba.accept x = accept\n 2. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> g_V x = V\n 3. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> g_E x = E\n 4. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> g_V0 x = V0\n 5. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> igba_rec.more x = ecnv G\n 6. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> igba x", "show \"igba.accept G' = accept\" and \"igba_rec.more G' = ecnv G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igb.accept = accept &&& igba_rec.more G' = ecnv G", "using ARUN MORE"], ["proof (prove)\nusing this:\n  igb.is_acc_run = is_acc_run\n  igb_graph_rec.more G' = ti_Lcnv ecnv G\n\ngoal (1 subgoal):\n 1. igb.accept = accept &&& igba_rec.more G' = ecnv G", "unfolding accept_def[abs_def] igb.accept_def[abs_def] ti_Lcnv_def"], ["proof (prove)\nusing this:\n  igb.is_acc_run = is_acc_run\n  igb_graph_rec.more G' = \\<lparr>igba_L = L, \\<dots> = ecnv G\\<rparr>\n\ngoal (1 subgoal):\n 1. (\\<lambda>w.\n        \\<exists>r.\n           igb.is_acc_run r \\<and> (\\<forall>i. igb.L (r i) (w i))) =\n    (\\<lambda>w.\n        \\<exists>r. is_acc_run r \\<and> (\\<forall>i. L (r i) (w i))) &&&\n    igba_rec.more G' = ecnv G", "apply (cases G', (auto) []) +"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  igb.accept = accept\n  igba_rec.more G' = ecnv G\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> g_V x = V\n 2. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> g_E x = E\n 3. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> g_V0 x = V0\n 4. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> igba x", "show \"igba G'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igba G'", "by unfold_locales"], ["proof (state)\nthis:\n  igba G'\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> g_V x = V\n 2. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> g_E x = E\n 3. \\<And>x.\n       \\<lbrakk>igb_graph.is_acc_run x = is_acc_run; g_V x = V; g_E x = E;\n        g_V0 x = V0; igb_graph_rec.more x = ti_Lcnv ecnv G;\n        igb_graph x\\<rbrakk>\n       \\<Longrightarrow> g_V0 x = V0", "qed"], ["", "corollary (in gba) gba_to_idx_ext_lang_correct:\n  assumes [simp, intro]: \"\\<And> A. A \\<in> F \\<Longrightarrow> finite A\"\n  shows \"gba_to_idx_ext ecnv G \\<le> \n    SPEC (\\<lambda>G'. igba.lang G' = lang \\<and> igba_rec.more G' = ecnv G \\<and> igba G')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gba_to_idx_ext ecnv G\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igba.lang G' = lang \\<and>\n               igba_rec.more G' = ecnv G \\<and> igba G')", "apply (rule order_trans[OF gba_to_idx_ext_correct])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A. A \\<in> F \\<Longrightarrow> finite A\n 2. SPEC\n     (\\<lambda>G'.\n         igba.accept G' = accept \\<and>\n         g_V G' = V \\<and>\n         g_E G' = E \\<and>\n         g_V0 G' = V0 \\<and> igba_rec.more G' = ecnv G \\<and> igba G')\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igba.lang G' = lang \\<and>\n               igba_rec.more G' = ecnv G \\<and> igba G')", "apply (rule, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC\n     (\\<lambda>G'.\n         igba.accept G' = accept \\<and>\n         g_V G' = V \\<and>\n         g_E G' = E \\<and>\n         g_V0 G' = V0 \\<and> igba_rec.more G' = ecnv G \\<and> igba G')\n    \\<le> SPEC\n           (\\<lambda>G'.\n               igba.lang G' = lang \\<and>\n               igba_rec.more G' = ecnv G \\<and> igba G')", "apply (rule SPEC_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       igba.accept x = accept \\<and>\n       g_V x = V \\<and>\n       g_E x = E \\<and>\n       g_V0 x = V0 \\<and>\n       igba_rec.more x = ecnv G \\<and> igba x \\<Longrightarrow>\n       igba.lang x = lang \\<and> igba_rec.more x = ecnv G \\<and> igba x", "unfolding lang_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       igba.accept x = accept \\<and>\n       g_V x = V \\<and>\n       g_E x = E \\<and>\n       g_V0 x = V0 \\<and>\n       igba_rec.more x = ecnv G \\<and> igba x \\<Longrightarrow>\n       igba.lang x = Collect accept \\<and>\n       igba_rec.more x = ecnv G \\<and> igba x", "apply (subst igba.lang_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       igba.accept x = accept \\<and>\n       g_V x = V \\<and>\n       g_E x = E \\<and>\n       g_V0 x = V0 \\<and>\n       igba_rec.more x = ecnv G \\<and> igba x \\<Longrightarrow>\n       igba x\n 2. \\<And>x.\n       igba.accept x = accept \\<and>\n       g_V x = V \\<and>\n       g_E x = E \\<and>\n       g_V0 x = V0 \\<and>\n       igba_rec.more x = ecnv G \\<and> igba x \\<Longrightarrow>\n       Collect (igba.accept x) = Collect accept \\<and>\n       igba_rec.more x = ecnv G \\<and> igba x", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Degeneralization\\<close>"], ["", "context igb_graph\nbegin"], ["", "definition degeneralize_ext :: \"_ \\<Rightarrow> ('Q \\<times> nat, _) b_graph_rec_scheme\" where\n    \"degeneralize_ext ecnv \\<equiv> \n      if num_acc = 0 then \\<lparr>\n        g_V = V \\<times> {0},\n        g_E = {((q,0),(q',0)) | q q'. (q,q')\\<in>E}, \n        g_V0 = V0\\<times>{0}, \n        bg_F = V \\<times> {0},\n        \\<dots> = ecnv G\n      \\<rparr>\n      else \\<lparr>\n        g_V = V \\<times> {0..<num_acc},\n        g_E = { ((q,i),(q',i')) | i i' q q'. \n            i<num_acc \n          \\<and> (q,q')\\<in>E \n          \\<and> i' = (if i\\<in>acc q then (i+1) mod num_acc else i) },\n        g_V0 = V0 \\<times> {0},\n        bg_F = {(q,0)| q. 0\\<in>acc q},\n        \\<dots> = ecnv G\n      \\<rparr>\""], ["", "abbreviation degeneralize where \"degeneralize \\<equiv> degeneralize_ext (\\<lambda>_. ())\""], ["", "lemma degen_more[simp]: \"b_graph_rec.more (degeneralize_ext ecnv) = ecnv G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b_graph_rec.more (degeneralize_ext ecnv) = ecnv G", "unfolding degeneralize_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. b_graph_rec.more\n     (if num_acc = 0\n      then \\<lparr>g_V = V \\<times> {0},\n              g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n              g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n              \\<dots> = ecnv G\\<rparr>\n      else \\<lparr>g_V = V \\<times> {0..<num_acc},\n              g_E =\n                {((q, i), q', i') |i i' q q'.\n                 i < num_acc \\<and>\n                 (q, q') \\<in> E \\<and>\n                 i' = (if i \\<in> acc q then (i + 1) mod num_acc else i)},\n              g_V0 = V0 \\<times> {0}, bg_F = {(q, 0) |q. 0 \\<in> acc q},\n              \\<dots> = ecnv G\\<rparr>) =\n    ecnv G", "by auto"], ["", "lemma degen_invar: \"b_graph (degeneralize_ext ecnv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b_graph (degeneralize_ext ecnv)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. g_V0 (degeneralize_ext ecnv) \\<subseteq> g_V (degeneralize_ext ecnv)\n 2. g_E (degeneralize_ext ecnv)\n    \\<subseteq> g_V (degeneralize_ext ecnv) \\<times>\n                g_V (degeneralize_ext ecnv)\n 3. bg_F (degeneralize_ext ecnv) \\<subseteq> g_V (degeneralize_ext ecnv)", "let ?G' = \"degeneralize_ext ecnv\""], ["proof (state)\ngoal (3 subgoals):\n 1. g_V0 (degeneralize_ext ecnv) \\<subseteq> g_V (degeneralize_ext ecnv)\n 2. g_E (degeneralize_ext ecnv)\n    \\<subseteq> g_V (degeneralize_ext ecnv) \\<times>\n                g_V (degeneralize_ext ecnv)\n 3. bg_F (degeneralize_ext ecnv) \\<subseteq> g_V (degeneralize_ext ecnv)", "show \"g_V0 ?G' \\<subseteq> g_V ?G'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_V0 (degeneralize_ext ecnv) \\<subseteq> g_V (degeneralize_ext ecnv)", "unfolding degeneralize_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. g_V0\n     (if num_acc = 0\n      then \\<lparr>g_V = V \\<times> {0},\n              g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n              g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n              \\<dots> = ecnv G\\<rparr>\n      else \\<lparr>g_V = V \\<times> {0..<num_acc},\n              g_E =\n                {((q, i), q', i') |i i' q q'.\n                 i < num_acc \\<and>\n                 (q, q') \\<in> E \\<and>\n                 i' = (if i \\<in> acc q then (i + 1) mod num_acc else i)},\n              g_V0 = V0 \\<times> {0}, bg_F = {(q, 0) |q. 0 \\<in> acc q},\n              \\<dots> = ecnv G\\<rparr>)\n    \\<subseteq> g_V (if num_acc = 0\n                     then \\<lparr>g_V = V \\<times> {0},\n                             g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                             g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                             \\<dots> = ecnv G\\<rparr>\n                     else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                             g_E =\n                               {((q, i), q', i') |i i' q q'.\n                                i < num_acc \\<and>\n                                (q, q') \\<in> E \\<and>\n                                i' =\n                                (if i \\<in> acc q then (i + 1) mod num_acc\n                                 else i)},\n                             g_V0 = V0 \\<times> {0},\n                             bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                             \\<dots> = ecnv G\\<rparr>)", "using V0_ss"], ["proof (prove)\nusing this:\n  V0 \\<subseteq> V\n\ngoal (1 subgoal):\n 1. g_V0\n     (if num_acc = 0\n      then \\<lparr>g_V = V \\<times> {0},\n              g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n              g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n              \\<dots> = ecnv G\\<rparr>\n      else \\<lparr>g_V = V \\<times> {0..<num_acc},\n              g_E =\n                {((q, i), q', i') |i i' q q'.\n                 i < num_acc \\<and>\n                 (q, q') \\<in> E \\<and>\n                 i' = (if i \\<in> acc q then (i + 1) mod num_acc else i)},\n              g_V0 = V0 \\<times> {0}, bg_F = {(q, 0) |q. 0 \\<in> acc q},\n              \\<dots> = ecnv G\\<rparr>)\n    \\<subseteq> g_V (if num_acc = 0\n                     then \\<lparr>g_V = V \\<times> {0},\n                             g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                             g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                             \\<dots> = ecnv G\\<rparr>\n                     else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                             g_E =\n                               {((q, i), q', i') |i i' q q'.\n                                i < num_acc \\<and>\n                                (q, q') \\<in> E \\<and>\n                                i' =\n                                (if i \\<in> acc q then (i + 1) mod num_acc\n                                 else i)},\n                             g_V0 = V0 \\<times> {0},\n                             bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                             \\<dots> = ecnv G\\<rparr>)", "by auto"], ["proof (state)\nthis:\n  g_V0 (degeneralize_ext ecnv) \\<subseteq> g_V (degeneralize_ext ecnv)\n\ngoal (2 subgoals):\n 1. g_E (degeneralize_ext ecnv)\n    \\<subseteq> g_V (degeneralize_ext ecnv) \\<times>\n                g_V (degeneralize_ext ecnv)\n 2. bg_F (degeneralize_ext ecnv) \\<subseteq> g_V (degeneralize_ext ecnv)", "show \"g_E ?G' \\<subseteq> g_V ?G' \\<times> g_V ?G'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_E (degeneralize_ext ecnv)\n    \\<subseteq> g_V (degeneralize_ext ecnv) \\<times>\n                g_V (degeneralize_ext ecnv)", "unfolding degeneralize_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. g_E (if num_acc = 0\n         then \\<lparr>g_V = V \\<times> {0},\n                 g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                 g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                 \\<dots> = ecnv G\\<rparr>\n         else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                 g_E =\n                   {((q, i), q', i') |i i' q q'.\n                    i < num_acc \\<and>\n                    (q, q') \\<in> E \\<and>\n                    i' =\n                    (if i \\<in> acc q then (i + 1) mod num_acc else i)},\n                 g_V0 = V0 \\<times> {0}, bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                 \\<dots> = ecnv G\\<rparr>)\n    \\<subseteq> g_V (if num_acc = 0\n                     then \\<lparr>g_V = V \\<times> {0},\n                             g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                             g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                             \\<dots> = ecnv G\\<rparr>\n                     else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                             g_E =\n                               {((q, i), q', i') |i i' q q'.\n                                i < num_acc \\<and>\n                                (q, q') \\<in> E \\<and>\n                                i' =\n                                (if i \\<in> acc q then (i + 1) mod num_acc\n                                 else i)},\n                             g_V0 = V0 \\<times> {0},\n                             bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                             \\<dots> = ecnv G\\<rparr>) \\<times>\n                g_V (if num_acc = 0\n                     then \\<lparr>g_V = V \\<times> {0},\n                             g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                             g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                             \\<dots> = ecnv G\\<rparr>\n                     else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                             g_E =\n                               {((q, i), q', i') |i i' q q'.\n                                i < num_acc \\<and>\n                                (q, q') \\<in> E \\<and>\n                                i' =\n                                (if i \\<in> acc q then (i + 1) mod num_acc\n                                 else i)},\n                             g_V0 = V0 \\<times> {0},\n                             bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                             \\<dots> = ecnv G\\<rparr>)", "using E_ss"], ["proof (prove)\nusing this:\n  E \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. g_E (if num_acc = 0\n         then \\<lparr>g_V = V \\<times> {0},\n                 g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                 g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                 \\<dots> = ecnv G\\<rparr>\n         else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                 g_E =\n                   {((q, i), q', i') |i i' q q'.\n                    i < num_acc \\<and>\n                    (q, q') \\<in> E \\<and>\n                    i' =\n                    (if i \\<in> acc q then (i + 1) mod num_acc else i)},\n                 g_V0 = V0 \\<times> {0}, bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                 \\<dots> = ecnv G\\<rparr>)\n    \\<subseteq> g_V (if num_acc = 0\n                     then \\<lparr>g_V = V \\<times> {0},\n                             g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                             g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                             \\<dots> = ecnv G\\<rparr>\n                     else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                             g_E =\n                               {((q, i), q', i') |i i' q q'.\n                                i < num_acc \\<and>\n                                (q, q') \\<in> E \\<and>\n                                i' =\n                                (if i \\<in> acc q then (i + 1) mod num_acc\n                                 else i)},\n                             g_V0 = V0 \\<times> {0},\n                             bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                             \\<dots> = ecnv G\\<rparr>) \\<times>\n                g_V (if num_acc = 0\n                     then \\<lparr>g_V = V \\<times> {0},\n                             g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                             g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                             \\<dots> = ecnv G\\<rparr>\n                     else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                             g_E =\n                               {((q, i), q', i') |i i' q q'.\n                                i < num_acc \\<and>\n                                (q, q') \\<in> E \\<and>\n                                i' =\n                                (if i \\<in> acc q then (i + 1) mod num_acc\n                                 else i)},\n                             g_V0 = V0 \\<times> {0},\n                             bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                             \\<dots> = ecnv G\\<rparr>)", "by auto"], ["proof (state)\nthis:\n  g_E (degeneralize_ext ecnv)\n  \\<subseteq> g_V (degeneralize_ext ecnv) \\<times>\n              g_V (degeneralize_ext ecnv)\n\ngoal (1 subgoal):\n 1. bg_F (degeneralize_ext ecnv) \\<subseteq> g_V (degeneralize_ext ecnv)", "show \"bg_F ?G' \\<subseteq> g_V ?G'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bg_F (degeneralize_ext ecnv) \\<subseteq> g_V (degeneralize_ext ecnv)", "unfolding degeneralize_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bg_F\n     (if num_acc = 0\n      then \\<lparr>g_V = V \\<times> {0},\n              g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n              g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n              \\<dots> = ecnv G\\<rparr>\n      else \\<lparr>g_V = V \\<times> {0..<num_acc},\n              g_E =\n                {((q, i), q', i') |i i' q q'.\n                 i < num_acc \\<and>\n                 (q, q') \\<in> E \\<and>\n                 i' = (if i \\<in> acc q then (i + 1) mod num_acc else i)},\n              g_V0 = V0 \\<times> {0}, bg_F = {(q, 0) |q. 0 \\<in> acc q},\n              \\<dots> = ecnv G\\<rparr>)\n    \\<subseteq> g_V (if num_acc = 0\n                     then \\<lparr>g_V = V \\<times> {0},\n                             g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                             g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                             \\<dots> = ecnv G\\<rparr>\n                     else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                             g_E =\n                               {((q, i), q', i') |i i' q q'.\n                                i < num_acc \\<and>\n                                (q, q') \\<in> E \\<and>\n                                i' =\n                                (if i \\<in> acc q then (i + 1) mod num_acc\n                                 else i)},\n                             g_V0 = V0 \\<times> {0},\n                             bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                             \\<dots> = ecnv G\\<rparr>)", "using acc_ss"], ["proof (prove)\nusing this:\n  acc ?q \\<noteq> {} \\<Longrightarrow> ?q \\<in> V\n\ngoal (1 subgoal):\n 1. bg_F\n     (if num_acc = 0\n      then \\<lparr>g_V = V \\<times> {0},\n              g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n              g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n              \\<dots> = ecnv G\\<rparr>\n      else \\<lparr>g_V = V \\<times> {0..<num_acc},\n              g_E =\n                {((q, i), q', i') |i i' q q'.\n                 i < num_acc \\<and>\n                 (q, q') \\<in> E \\<and>\n                 i' = (if i \\<in> acc q then (i + 1) mod num_acc else i)},\n              g_V0 = V0 \\<times> {0}, bg_F = {(q, 0) |q. 0 \\<in> acc q},\n              \\<dots> = ecnv G\\<rparr>)\n    \\<subseteq> g_V (if num_acc = 0\n                     then \\<lparr>g_V = V \\<times> {0},\n                             g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                             g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                             \\<dots> = ecnv G\\<rparr>\n                     else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                             g_E =\n                               {((q, i), q', i') |i i' q q'.\n                                i < num_acc \\<and>\n                                (q, q') \\<in> E \\<and>\n                                i' =\n                                (if i \\<in> acc q then (i + 1) mod num_acc\n                                 else i)},\n                             g_V0 = V0 \\<times> {0},\n                             bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                             \\<dots> = ecnv G\\<rparr>)", "by auto"], ["proof (state)\nthis:\n  bg_F (degeneralize_ext ecnv) \\<subseteq> g_V (degeneralize_ext ecnv)\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale degen: b_graph \"degeneralize_ext m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b_graph (degeneralize_ext m)", "using degen_invar"], ["proof (prove)\nusing this:\n  b_graph (degeneralize_ext ?ecnv)\n\ngoal (1 subgoal):\n 1. b_graph (degeneralize_ext m)", "."], ["", "lemma degen_finite_reachable:\n    assumes [simp, intro]: \"finite (E\\<^sup>* `` V0)\"\n    shows \"finite ((g_E (degeneralize_ext ecnv))\\<^sup>* `` g_V0 (degeneralize_ext ecnv))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ((g_E (degeneralize_ext ecnv))\\<^sup>* `` g_V0 (degeneralize_ext ecnv))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     ((g_E (degeneralize_ext ecnv))\\<^sup>* `` g_V0 (degeneralize_ext ecnv))", "let ?G' = \"degeneralize_ext ecnv\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     ((g_E (degeneralize_ext ecnv))\\<^sup>* `` g_V0 (degeneralize_ext ecnv))", "have \"((g_E ?G')\\<^sup>* `` g_V0 ?G')\n      \\<subseteq> E\\<^sup>*``V0 \\<times> {0..num_acc}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g_E (degeneralize_ext ecnv))\\<^sup>* `` g_V0 (degeneralize_ext ecnv)\n    \\<subseteq> reachable \\<times> {0..num_acc}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (g_E (degeneralize_ext ecnv))\\<^sup>* `` g_V0 (degeneralize_ext ecnv)\n    \\<subseteq> reachable \\<times> {0..num_acc}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (g_E (degeneralize_ext ecnv))\\<^sup>* `` g_V0 (degeneralize_ext ecnv)\n    \\<subseteq> reachable \\<times> {0..num_acc}", "fix q n q' n'"], ["proof (state)\ngoal (1 subgoal):\n 1. (g_E (degeneralize_ext ecnv))\\<^sup>* `` g_V0 (degeneralize_ext ecnv)\n    \\<subseteq> reachable \\<times> {0..num_acc}", "assume \"((q,n),(q',n'))\\<in>(g_E ?G')\\<^sup>*\" \n          and 0: \"(q,n)\\<in>g_V0 ?G'\""], ["proof (state)\nthis:\n  ((q, n), q', n') \\<in> (g_E (degeneralize_ext ecnv))\\<^sup>*\n  (q, n) \\<in> g_V0 (degeneralize_ext ecnv)\n\ngoal (1 subgoal):\n 1. (g_E (degeneralize_ext ecnv))\\<^sup>* `` g_V0 (degeneralize_ext ecnv)\n    \\<subseteq> reachable \\<times> {0..num_acc}", "hence G1: \"(q,q')\\<in>E\\<^sup>* \\<and> n'\\<le>num_acc\""], ["proof (prove)\nusing this:\n  ((q, n), q', n') \\<in> (g_E (degeneralize_ext ecnv))\\<^sup>*\n  (q, n) \\<in> g_V0 (degeneralize_ext ecnv)\n\ngoal (1 subgoal):\n 1. (q, q') \\<in> E\\<^sup>* \\<and> n' \\<le> num_acc", "apply (induction rule: rtrancl_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (q, n) \\<in> g_V0 (degeneralize_ext ecnv) \\<Longrightarrow>\n    (q, q) \\<in> E\\<^sup>* \\<and> n \\<le> num_acc\n 2. \\<And>a b aa ba.\n       \\<lbrakk>((q, n), a, b) \\<in> (g_E (degeneralize_ext ecnv))\\<^sup>*;\n        ((a, b), aa, ba) \\<in> g_E (degeneralize_ext ecnv);\n        (q, n) \\<in> g_V0 (degeneralize_ext ecnv) \\<Longrightarrow>\n        (q, a) \\<in> E\\<^sup>* \\<and> b \\<le> num_acc;\n        (q, n) \\<in> g_V0 (degeneralize_ext ecnv)\\<rbrakk>\n       \\<Longrightarrow> (q, aa) \\<in> E\\<^sup>* \\<and> ba \\<le> num_acc", "by (auto simp: degeneralize_ext_def split: if_split_asm)"], ["proof (state)\nthis:\n  (q, q') \\<in> E\\<^sup>* \\<and> n' \\<le> num_acc\n\ngoal (1 subgoal):\n 1. (g_E (degeneralize_ext ecnv))\\<^sup>* `` g_V0 (degeneralize_ext ecnv)\n    \\<subseteq> reachable \\<times> {0..num_acc}", "from 0"], ["proof (chain)\npicking this:\n  (q, n) \\<in> g_V0 (degeneralize_ext ecnv)", "have G2: \"q\\<in>V0 \\<and> n\\<le>num_acc\""], ["proof (prove)\nusing this:\n  (q, n) \\<in> g_V0 (degeneralize_ext ecnv)\n\ngoal (1 subgoal):\n 1. q \\<in> V0 \\<and> n \\<le> num_acc", "by (auto simp: degeneralize_ext_def split: if_split_asm)"], ["proof (state)\nthis:\n  q \\<in> V0 \\<and> n \\<le> num_acc\n\ngoal (1 subgoal):\n 1. (g_E (degeneralize_ext ecnv))\\<^sup>* `` g_V0 (degeneralize_ext ecnv)\n    \\<subseteq> reachable \\<times> {0..num_acc}", "note G1 G2"], ["proof (state)\nthis:\n  (q, q') \\<in> E\\<^sup>* \\<and> n' \\<le> num_acc\n  q \\<in> V0 \\<and> n \\<le> num_acc\n\ngoal (1 subgoal):\n 1. (g_E (degeneralize_ext ecnv))\\<^sup>* `` g_V0 (degeneralize_ext ecnv)\n    \\<subseteq> reachable \\<times> {0..num_acc}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>((?q4, ?n4), ?q'4, ?n'4)\n           \\<in> (g_E (degeneralize_ext ecnv))\\<^sup>*;\n   (?q4, ?n4) \\<in> g_V0 (degeneralize_ext ecnv)\\<rbrakk>\n  \\<Longrightarrow> (?q4, ?q'4) \\<in> E\\<^sup>* \\<and> ?n'4 \\<le> num_acc\n  \\<lbrakk>((?q4, ?n4), ?q'4, ?n'4)\n           \\<in> (g_E (degeneralize_ext ecnv))\\<^sup>*;\n   (?q4, ?n4) \\<in> g_V0 (degeneralize_ext ecnv)\\<rbrakk>\n  \\<Longrightarrow> ?q4 \\<in> V0 \\<and> ?n4 \\<le> num_acc\n\ngoal (1 subgoal):\n 1. (g_E (degeneralize_ext ecnv))\\<^sup>* `` g_V0 (degeneralize_ext ecnv)\n    \\<subseteq> reachable \\<times> {0..num_acc}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>((?q4, ?n4), ?q'4, ?n'4)\n           \\<in> (g_E (degeneralize_ext ecnv))\\<^sup>*;\n   (?q4, ?n4) \\<in> g_V0 (degeneralize_ext ecnv)\\<rbrakk>\n  \\<Longrightarrow> (?q4, ?q'4) \\<in> E\\<^sup>* \\<and> ?n'4 \\<le> num_acc\n  \\<lbrakk>((?q4, ?n4), ?q'4, ?n'4)\n           \\<in> (g_E (degeneralize_ext ecnv))\\<^sup>*;\n   (?q4, ?n4) \\<in> g_V0 (degeneralize_ext ecnv)\\<rbrakk>\n  \\<Longrightarrow> ?q4 \\<in> V0 \\<and> ?n4 \\<le> num_acc\n\ngoal (1 subgoal):\n 1. (g_E (degeneralize_ext ecnv))\\<^sup>* `` g_V0 (degeneralize_ext ecnv)\n    \\<subseteq> reachable \\<times> {0..num_acc}", "by fastforce"], ["proof (state)\nthis:\n  (g_E (degeneralize_ext ecnv))\\<^sup>* `` g_V0 (degeneralize_ext ecnv)\n  \\<subseteq> reachable \\<times> {0..num_acc}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (g_E (degeneralize_ext ecnv))\\<^sup>* `` g_V0 (degeneralize_ext ecnv)\n  \\<subseteq> reachable \\<times> {0..num_acc}\n\ngoal (1 subgoal):\n 1. finite\n     ((g_E (degeneralize_ext ecnv))\\<^sup>* `` g_V0 (degeneralize_ext ecnv))", "also"], ["proof (state)\nthis:\n  (g_E (degeneralize_ext ecnv))\\<^sup>* `` g_V0 (degeneralize_ext ecnv)\n  \\<subseteq> reachable \\<times> {0..num_acc}\n\ngoal (1 subgoal):\n 1. finite\n     ((g_E (degeneralize_ext ecnv))\\<^sup>* `` g_V0 (degeneralize_ext ecnv))", "have \"finite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (reachable \\<times> {0..num_acc})", "by auto"], ["proof (state)\nthis:\n  finite (reachable \\<times> {0..num_acc})\n\ngoal (1 subgoal):\n 1. finite\n     ((g_E (degeneralize_ext ecnv))\\<^sup>* `` g_V0 (degeneralize_ext ecnv))", "finally (finite_subset)"], ["proof (chain)\npicking this:\n  finite\n   ((g_E (degeneralize_ext ecnv))\\<^sup>* `` g_V0 (degeneralize_ext ecnv))", "show \"finite ((g_E ?G')\\<^sup>* `` g_V0 ?G')\""], ["proof (prove)\nusing this:\n  finite\n   ((g_E (degeneralize_ext ecnv))\\<^sup>* `` g_V0 (degeneralize_ext ecnv))\n\ngoal (1 subgoal):\n 1. finite\n     ((g_E (degeneralize_ext ecnv))\\<^sup>* `` g_V0 (degeneralize_ext ecnv))", "."], ["proof (state)\nthis:\n  finite\n   ((g_E (degeneralize_ext ecnv))\\<^sup>* `` g_V0 (degeneralize_ext ecnv))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degen_is_run_sound: \n    \"degen.is_run T m r \\<Longrightarrow> is_run (fst o r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_defs.is_run (degeneralize_ext m) r \\<Longrightarrow>\n    is_run (fst \\<circ> r)", "unfolding degen.is_run_def is_run_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. r 0 \\<in> g_V0 (degeneralize_ext m) \\<and>\n    ipath (g_E (degeneralize_ext m)) r \\<Longrightarrow>\n    (fst \\<circ> r) 0 \\<in> V0 \\<and> ipath E (fst \\<circ> r)", "unfolding degeneralize_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. r 0\n    \\<in> g_V0\n           (if num_acc = 0\n            then \\<lparr>g_V = V \\<times> {0},\n                    g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                    g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                    \\<dots> = m G\\<rparr>\n            else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                    g_E =\n                      {((q, i), q', i') |i i' q q'.\n                       i < num_acc \\<and>\n                       (q, q') \\<in> E \\<and>\n                       i' =\n                       (if i \\<in> acc q then (i + 1) mod num_acc else i)},\n                    g_V0 = V0 \\<times> {0},\n                    bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                    \\<dots> = m G\\<rparr>) \\<and>\n    ipath\n     (g_E (if num_acc = 0\n           then \\<lparr>g_V = V \\<times> {0},\n                   g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                   g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                   \\<dots> = m G\\<rparr>\n           else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                   g_E =\n                     {((q, i), q', i') |i i' q q'.\n                      i < num_acc \\<and>\n                      (q, q') \\<in> E \\<and>\n                      i' =\n                      (if i \\<in> acc q then (i + 1) mod num_acc else i)},\n                   g_V0 = V0 \\<times> {0},\n                   bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                   \\<dots> = m G\\<rparr>))\n     r \\<Longrightarrow>\n    (fst \\<circ> r) 0 \\<in> V0 \\<and> ipath E (fst \\<circ> r)", "apply (clarsimp split: if_split_asm simp: ipath_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>num_acc = 0;\n        \\<forall>i.\n           \\<exists>q.\n              r i = (q, 0) \\<and>\n              (\\<exists>q'. r (Suc i) = (q', 0) \\<and> (q, q') \\<in> E);\n        x \\<in> V0; r 0 = (x, 0)\\<rbrakk>\n       \\<Longrightarrow> (fst (r i), fst (r (Suc i))) \\<in> E\n 2. \\<And>x i.\n       \\<lbrakk>0 < num_acc;\n        \\<forall>i.\n           \\<exists>ia q.\n              (ia \\<in> acc q \\<longrightarrow>\n               r i = (q, ia) \\<and>\n               (\\<exists>q'.\n                   r (Suc i) = (q', Suc ia mod num_acc) \\<and>\n                   (q, q') \\<in> E)) \\<and>\n              (ia \\<in> acc q \\<or>\n               ia < num_acc \\<and>\n               r i = (q, ia) \\<and>\n               (\\<exists>q'. r (Suc i) = (q', ia) \\<and> (q, q') \\<in> E));\n        x \\<in> V0; r 0 = (x, 0)\\<rbrakk>\n       \\<Longrightarrow> (fst (r i), fst (r (Suc i))) \\<in> E", "apply (metis fst_conv)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma degen_path_sound: \n    assumes \"path (degen.E T m) u p v\" \n    shows \"path E (fst u) (map fst p) (fst v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path E (fst u) (map fst p) (fst v)", "using assms"], ["proof (prove)\nusing this:\n  path (g_E (degeneralize_ext m)) u p v\n\ngoal (1 subgoal):\n 1. path E (fst u) (map fst p) (fst v)", "by induction (auto simp: degeneralize_ext_def path_simps split: if_split_asm)"], ["", "lemma degen_V0_sound: \n    assumes \"u \\<in> degen.V0 T m\" \n    shows \"fst u \\<in> V0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst u \\<in> V0", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> g_V0 (degeneralize_ext m)\n\ngoal (1 subgoal):\n 1. fst u \\<in> V0", "by (auto simp: degeneralize_ext_def path_simps split: if_split_asm)"], ["", "lemma degen_visit_acc:\n    assumes \"path (degen.E T m) (q,n) p (q',n')\"\n    assumes \"n\\<noteq>n'\"\n    shows \"\\<exists>qa. (qa,n)\\<in>set p \\<and> n\\<in>acc qa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>qa. (qa, n) \\<in> set p \\<and> n \\<in> acc qa", "using assms"], ["proof (prove)\nusing this:\n  path (g_E (degeneralize_ext m)) (q, n) p (q', n')\n  n \\<noteq> n'\n\ngoal (1 subgoal):\n 1. \\<exists>qa. (qa, n) \\<in> set p \\<and> n \\<in> acc qa", "proof (induction _ \"(q,n)\" p \"(q',n')\" arbitrary: q rule: path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>n = n'; n \\<noteq> n'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>qa.\n                         (qa, n) \\<in> set [] \\<and> n \\<in> acc qa\n 2. \\<And>v l q.\n       \\<lbrakk>((q, n), v) \\<in> g_E (degeneralize_ext m);\n        path (g_E (degeneralize_ext m)) v l (q', n');\n        \\<And>q.\n           \\<lbrakk>v = (q, n); n \\<noteq> n'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>qa.\n                                (qa, n) \\<in> set l \\<and> n \\<in> acc qa;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>qa.\n                            (qa, n) \\<in> set ((q, n) # l) \\<and>\n                            n \\<in> acc qa", "case (path_prepend qnh p)"], ["proof (state)\nthis:\n  ((q, n), qnh) \\<in> g_E (degeneralize_ext m)\n  path (g_E (degeneralize_ext m)) qnh p (q', n')\n  \\<lbrakk>qnh = (?q2, n); n \\<noteq> n'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>qa. (qa, n) \\<in> set p \\<and> n \\<in> acc qa\n  n \\<noteq> n'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n = n'; n \\<noteq> n'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>qa.\n                         (qa, n) \\<in> set [] \\<and> n \\<in> acc qa\n 2. \\<And>v l q.\n       \\<lbrakk>((q, n), v) \\<in> g_E (degeneralize_ext m);\n        path (g_E (degeneralize_ext m)) v l (q', n');\n        \\<And>q.\n           \\<lbrakk>v = (q, n); n \\<noteq> n'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>qa.\n                                (qa, n) \\<in> set l \\<and> n \\<in> acc qa;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>qa.\n                            (qa, n) \\<in> set ((q, n) # l) \\<and>\n                            n \\<in> acc qa", "then"], ["proof (chain)\npicking this:\n  ((q, n), qnh) \\<in> g_E (degeneralize_ext m)\n  path (g_E (degeneralize_ext m)) qnh p (q', n')\n  \\<lbrakk>qnh = (?q2, n); n \\<noteq> n'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>qa. (qa, n) \\<in> set p \\<and> n \\<in> acc qa\n  n \\<noteq> n'", "obtain qh nh where [simp]: \"qnh=(qh,nh)\""], ["proof (prove)\nusing this:\n  ((q, n), qnh) \\<in> g_E (degeneralize_ext m)\n  path (g_E (degeneralize_ext m)) qnh p (q', n')\n  \\<lbrakk>qnh = (?q2, n); n \\<noteq> n'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>qa. (qa, n) \\<in> set p \\<and> n \\<in> acc qa\n  n \\<noteq> n'\n\ngoal (1 subgoal):\n 1. (\\<And>qh nh. qnh = (qh, nh) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases qnh)"], ["proof (state)\nthis:\n  qnh = (qh, nh)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n = n'; n \\<noteq> n'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>qa.\n                         (qa, n) \\<in> set [] \\<and> n \\<in> acc qa\n 2. \\<And>v l q.\n       \\<lbrakk>((q, n), v) \\<in> g_E (degeneralize_ext m);\n        path (g_E (degeneralize_ext m)) v l (q', n');\n        \\<And>q.\n           \\<lbrakk>v = (q, n); n \\<noteq> n'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>qa.\n                                (qa, n) \\<in> set l \\<and> n \\<in> acc qa;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>qa.\n                            (qa, n) \\<in> set ((q, n) # l) \\<and>\n                            n \\<in> acc qa", "from \\<open>((q,n),qnh) \\<in> degen.E T m\\<close>"], ["proof (chain)\npicking this:\n  ((q, n), qnh) \\<in> g_E (degeneralize_ext m)", "have \"nh=n \\<or> (nh=(n+1) mod num_acc \\<and> n\\<in>acc q)\""], ["proof (prove)\nusing this:\n  ((q, n), qnh) \\<in> g_E (degeneralize_ext m)\n\ngoal (1 subgoal):\n 1. nh = n \\<or> nh = (n + 1) mod num_acc \\<and> n \\<in> acc q", "by (auto simp: degeneralize_ext_def split: if_split_asm)"], ["proof (state)\nthis:\n  nh = n \\<or> nh = (n + 1) mod num_acc \\<and> n \\<in> acc q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n = n'; n \\<noteq> n'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>qa.\n                         (qa, n) \\<in> set [] \\<and> n \\<in> acc qa\n 2. \\<And>v l q.\n       \\<lbrakk>((q, n), v) \\<in> g_E (degeneralize_ext m);\n        path (g_E (degeneralize_ext m)) v l (q', n');\n        \\<And>q.\n           \\<lbrakk>v = (q, n); n \\<noteq> n'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>qa.\n                                (qa, n) \\<in> set l \\<and> n \\<in> acc qa;\n        n \\<noteq> n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>qa.\n                            (qa, n) \\<in> set ((q, n) # l) \\<and>\n                            n \\<in> acc qa", "thus ?case"], ["proof (prove)\nusing this:\n  nh = n \\<or> nh = (n + 1) mod num_acc \\<and> n \\<in> acc q\n\ngoal (1 subgoal):\n 1. \\<exists>qaa. (qaa, n) \\<in> set ((q, n) # p) \\<and> n \\<in> acc qaa", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. nh = n \\<Longrightarrow>\n    \\<exists>qaa. (qaa, n) \\<in> set ((q, n) # p) \\<and> n \\<in> acc qaa\n 2. nh = (n + 1) mod num_acc \\<and> n \\<in> acc q \\<Longrightarrow>\n    \\<exists>qaa. (qaa, n) \\<in> set ((q, n) # p) \\<and> n \\<in> acc qaa", "assume [simp]: \"nh=n\""], ["proof (state)\nthis:\n  nh = n\n\ngoal (2 subgoals):\n 1. nh = n \\<Longrightarrow>\n    \\<exists>qaa. (qaa, n) \\<in> set ((q, n) # p) \\<and> n \\<in> acc qaa\n 2. nh = (n + 1) mod num_acc \\<and> n \\<in> acc q \\<Longrightarrow>\n    \\<exists>qaa. (qaa, n) \\<in> set ((q, n) # p) \\<and> n \\<in> acc qaa", "from path_prepend"], ["proof (chain)\npicking this:\n  ((q, n), qnh) \\<in> g_E (degeneralize_ext m)\n  path (g_E (degeneralize_ext m)) qnh p (q', n')\n  \\<lbrakk>qnh = (?q2, n); n \\<noteq> n'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>qa. (qa, n) \\<in> set p \\<and> n \\<in> acc qa\n  n \\<noteq> n'", "obtain qa where \"(qa, n) \\<in> set p\" and \"n \\<in> acc qa\""], ["proof (prove)\nusing this:\n  ((q, n), qnh) \\<in> g_E (degeneralize_ext m)\n  path (g_E (degeneralize_ext m)) qnh p (q', n')\n  \\<lbrakk>qnh = (?q2, n); n \\<noteq> n'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>qa. (qa, n) \\<in> set p \\<and> n \\<in> acc qa\n  n \\<noteq> n'\n\ngoal (1 subgoal):\n 1. (\\<And>qa.\n        \\<lbrakk>(qa, n) \\<in> set p; n \\<in> acc qa\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (qa, n) \\<in> set p\n  n \\<in> acc qa\n\ngoal (2 subgoals):\n 1. nh = n \\<Longrightarrow>\n    \\<exists>qaa. (qaa, n) \\<in> set ((q, n) # p) \\<and> n \\<in> acc qaa\n 2. nh = (n + 1) mod num_acc \\<and> n \\<in> acc q \\<Longrightarrow>\n    \\<exists>qaa. (qaa, n) \\<in> set ((q, n) # p) \\<and> n \\<in> acc qaa", "thus ?case"], ["proof (prove)\nusing this:\n  (qa, n) \\<in> set p\n  n \\<in> acc qa\n\ngoal (1 subgoal):\n 1. \\<exists>qaa. (qaa, n) \\<in> set ((q, n) # p) \\<and> n \\<in> acc qaa", "by auto"], ["proof (state)\nthis:\n  \\<exists>qaa. (qaa, n) \\<in> set ((q, n) # p) \\<and> n \\<in> acc qaa\n\ngoal (1 subgoal):\n 1. nh = (n + 1) mod num_acc \\<and> n \\<in> acc q \\<Longrightarrow>\n    \\<exists>qaa. (qaa, n) \\<in> set ((q, n) # p) \\<and> n \\<in> acc qaa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nh = (n + 1) mod num_acc \\<and> n \\<in> acc q \\<Longrightarrow>\n    \\<exists>qaa. (qaa, n) \\<in> set ((q, n) # p) \\<and> n \\<in> acc qaa", "assume \"(nh=(n+1) mod num_acc \\<and> n\\<in>acc q)\""], ["proof (state)\nthis:\n  nh = (n + 1) mod num_acc \\<and> n \\<in> acc q\n\ngoal (1 subgoal):\n 1. nh = (n + 1) mod num_acc \\<and> n \\<in> acc q \\<Longrightarrow>\n    \\<exists>qaa. (qaa, n) \\<in> set ((q, n) # p) \\<and> n \\<in> acc qaa", "thus ?case"], ["proof (prove)\nusing this:\n  nh = (n + 1) mod num_acc \\<and> n \\<in> acc q\n\ngoal (1 subgoal):\n 1. \\<exists>qaa. (qaa, n) \\<in> set ((q, n) # p) \\<and> n \\<in> acc qaa", "by auto"], ["proof (state)\nthis:\n  \\<exists>qaa. (qaa, n) \\<in> set ((q, n) # p) \\<and> n \\<in> acc qaa\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>qaa. (qaa, n) \\<in> set ((q, n) # p) \\<and> n \\<in> acc qaa\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n = n'; n \\<noteq> n'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>qa.\n                         (qa, n) \\<in> set [] \\<and> n \\<in> acc qa", "qed simp"], ["", "lemma degen_run_complete0:\n    assumes [simp]: \"num_acc = 0\"\n    assumes R: \"is_run r\"\n    shows \"degen.is_run T m (\\<lambda>i. (r i,0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_defs.is_run (degeneralize_ext m) (\\<lambda>i. (r i, 0))", "using R"], ["proof (prove)\nusing this:\n  is_run r\n\ngoal (1 subgoal):\n 1. graph_defs.is_run (degeneralize_ext m) (\\<lambda>i. (r i, 0))", "unfolding degen.is_run_def is_run_def"], ["proof (prove)\nusing this:\n  r 0 \\<in> V0 \\<and> ipath E r\n\ngoal (1 subgoal):\n 1. (r 0, 0) \\<in> g_V0 (degeneralize_ext m) \\<and>\n    ipath (g_E (degeneralize_ext m)) (\\<lambda>i. (r i, 0))", "unfolding ipath_def degeneralize_ext_def"], ["proof (prove)\nusing this:\n  r 0 \\<in> V0 \\<and> (\\<forall>i. (r i, r (Suc i)) \\<in> E)\n\ngoal (1 subgoal):\n 1. (r 0, 0)\n    \\<in> g_V0\n           (if num_acc = 0\n            then \\<lparr>g_V = V \\<times> {0},\n                    g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                    g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                    \\<dots> = m G\\<rparr>\n            else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                    g_E =\n                      {((q, i), q', i') |i i' q q'.\n                       i < num_acc \\<and>\n                       (q, q') \\<in> E \\<and>\n                       i' =\n                       (if i \\<in> acc q then (i + 1) mod num_acc else i)},\n                    g_V0 = V0 \\<times> {0},\n                    bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                    \\<dots> = m G\\<rparr>) \\<and>\n    (\\<forall>i.\n        ((r i, 0), r (Suc i), 0)\n        \\<in> g_E (if num_acc = 0\n                   then \\<lparr>g_V = V \\<times> {0},\n                           g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                           g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                           \\<dots> = m G\\<rparr>\n                   else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                           g_E =\n                             {((q, i), q', i') |i i' q q'.\n                              i < num_acc \\<and>\n                              (q, q') \\<in> E \\<and>\n                              i' =\n                              (if i \\<in> acc q then (i + 1) mod num_acc\n                               else i)},\n                           g_V0 = V0 \\<times> {0},\n                           bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                           \\<dots> = m G\\<rparr>))", "by auto"], ["", "lemma degen_acc_run_complete0:\n    assumes [simp]: \"num_acc = 0\"\n    assumes R: \"is_acc_run r\"\n    shows \"degen.is_acc_run T m (\\<lambda>i. (r i,0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b_graph.is_acc_run (degeneralize_ext m) (\\<lambda>i. (r i, 0))", "using R"], ["proof (prove)\nusing this:\n  is_acc_run r\n\ngoal (1 subgoal):\n 1. b_graph.is_acc_run (degeneralize_ext m) (\\<lambda>i. (r i, 0))", "unfolding degen.is_acc_run_def is_acc_run_def is_acc_def degen.is_acc_def"], ["proof (prove)\nusing this:\n  is_run r \\<and>\n  (\\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (r i))\n\ngoal (1 subgoal):\n 1. graph_defs.is_run (degeneralize_ext m) (\\<lambda>i. (r i, 0)) \\<and>\n    (\\<exists>\\<^sub>\\<infinity>i. (r i, 0) \\<in> bg_F (degeneralize_ext m))", "apply (simp add: degen_run_complete0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_run r \\<Longrightarrow>\n    \\<exists>\\<^sub>\\<infinity>i. (r i, 0) \\<in> bg_F (degeneralize_ext m)", "unfolding degeneralize_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_run r \\<Longrightarrow>\n    \\<exists>\\<^sub>\\<infinity>i.\n       (r i, 0)\n       \\<in> bg_F\n              (if num_acc = 0\n               then \\<lparr>g_V = V \\<times> {0},\n                       g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                       g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                       \\<dots> = m G\\<rparr>\n               else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                       g_E =\n                         {((q, i), q', i') |i i' q q'.\n                          i < num_acc \\<and>\n                          (q, q') \\<in> E \\<and>\n                          i' =\n                          (if i \\<in> acc q then (i + 1) mod num_acc\n                           else i)},\n                       g_V0 = V0 \\<times> {0},\n                       bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                       \\<dots> = m G\\<rparr>)", "using run_reachable[of r] reachable_V"], ["proof (prove)\nusing this:\n  is_run r \\<Longrightarrow> range r \\<subseteq> reachable\n  reachable \\<subseteq> V\n\ngoal (1 subgoal):\n 1. is_run r \\<Longrightarrow>\n    \\<exists>\\<^sub>\\<infinity>i.\n       (r i, 0)\n       \\<in> bg_F\n              (if num_acc = 0\n               then \\<lparr>g_V = V \\<times> {0},\n                       g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                       g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                       \\<dots> = m G\\<rparr>\n               else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                       g_E =\n                         {((q, i), q', i') |i i' q q'.\n                          i < num_acc \\<and>\n                          (q, q') \\<in> E \\<and>\n                          i' =\n                          (if i \\<in> acc q then (i + 1) mod num_acc\n                           else i)},\n                       g_V0 = V0 \\<times> {0},\n                       bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                       \\<dots> = m G\\<rparr>)", "by (auto simp: INFM_nat)"], ["", "lemma degen_run_complete:\n    assumes [simp]: \"num_acc \\<noteq> 0\"\n    assumes R: \"is_run r\"\n    shows \"\\<exists>r'. degen.is_run T m r' \\<and> r = fst o r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r'.\n       graph_defs.is_run (degeneralize_ext m) r' \\<and> r = fst \\<circ> r'", "using R"], ["proof (prove)\nusing this:\n  is_run r\n\ngoal (1 subgoal):\n 1. \\<exists>r'.\n       graph_defs.is_run (degeneralize_ext m) r' \\<and> r = fst \\<circ> r'", "unfolding degen.is_run_def is_run_def ipath_def"], ["proof (prove)\nusing this:\n  r 0 \\<in> V0 \\<and> (\\<forall>i. (r i, r (Suc i)) \\<in> E)\n\ngoal (1 subgoal):\n 1. \\<exists>r'.\n       (r' 0 \\<in> g_V0 (degeneralize_ext m) \\<and>\n        (\\<forall>i.\n            (r' i, r' (Suc i)) \\<in> g_E (degeneralize_ext m))) \\<and>\n       r = fst \\<circ> r'", "apply (elim conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r 0 \\<in> V0; \\<forall>i. (r i, r (Suc i)) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r'.\n                         (r' 0 \\<in> g_V0 (degeneralize_ext m) \\<and>\n                          (\\<forall>i.\n                              (r' i, r' (Suc i))\n                              \\<in> g_E (degeneralize_ext m))) \\<and>\n                         r = fst \\<circ> r'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>r 0 \\<in> V0; \\<forall>i. (r i, r (Suc i)) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r'.\n                         (r' 0 \\<in> g_V0 (degeneralize_ext m) \\<and>\n                          (\\<forall>i.\n                              (r' i, r' (Suc i))\n                              \\<in> g_E (degeneralize_ext m))) \\<and>\n                         r = fst \\<circ> r'", "assume R0: \"r 0 \\<in> V0\" and RS: \"\\<forall>i. (r i, r (Suc i)) \\<in> E\""], ["proof (state)\nthis:\n  r 0 \\<in> V0\n  \\<forall>i. (r i, r (Suc i)) \\<in> E\n\ngoal (1 subgoal):\n 1. \\<lbrakk>r 0 \\<in> V0; \\<forall>i. (r i, r (Suc i)) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r'.\n                         (r' 0 \\<in> g_V0 (degeneralize_ext m) \\<and>\n                          (\\<forall>i.\n                              (r' i, r' (Suc i))\n                              \\<in> g_E (degeneralize_ext m))) \\<and>\n                         r = fst \\<circ> r'", "define r' where \"r' = rec_nat\n      (r 0,0) \n      (\\<lambda>i (q,n). (r (Suc i), if n \\<in> acc q then (n+1) mod num_acc else n))\""], ["proof (state)\nthis:\n  r' =\n  rec_nat (r 0, 0)\n   (\\<lambda>i (q, n).\n       (r (Suc i), if n \\<in> acc q then (n + 1) mod num_acc else n))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>r 0 \\<in> V0; \\<forall>i. (r i, r (Suc i)) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r'.\n                         (r' 0 \\<in> g_V0 (degeneralize_ext m) \\<and>\n                          (\\<forall>i.\n                              (r' i, r' (Suc i))\n                              \\<in> g_E (degeneralize_ext m))) \\<and>\n                         r = fst \\<circ> r'", "have [simp]:\n      \"r' 0 = (r 0,0)\"\n      \"\\<And>i. r' (Suc i) = (\n        let \n          (q,n)=r' i \n        in \n          (r (Suc i), if n \\<in> acc q then (n+1) mod num_acc else n)\n      )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r' 0 = (r 0, 0) &&&\n    (\\<And>i.\n        r' (Suc i) =\n        (let (q, n) = r' i\n         in (r (Suc i), if n \\<in> acc q then (n + 1) mod num_acc else n)))", "unfolding r'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_nat (r 0, 0)\n     (\\<lambda>i (q, n).\n         (r (Suc i), if n \\<in> acc q then (n + 1) mod num_acc else n))\n     0 =\n    (r 0, 0) &&&\n    (\\<And>i.\n        rec_nat (r 0, 0)\n         (\\<lambda>i (q, n).\n             (r (Suc i), if n \\<in> acc q then (n + 1) mod num_acc else n))\n         (Suc i) =\n        (let (q, n) =\n               rec_nat (r 0, 0)\n                (\\<lambda>i (q, n).\n                    (r (Suc i),\n                     if n \\<in> acc q then (n + 1) mod num_acc else n))\n                i\n         in (r (Suc i), if n \\<in> acc q then (n + 1) mod num_acc else n)))", "by auto"], ["proof (state)\nthis:\n  r' 0 = (r 0, 0)\n  r' (Suc ?i2) =\n  (let (q, n) = r' ?i2\n   in (r (Suc ?i2), if n \\<in> acc q then (n + 1) mod num_acc else n))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>r 0 \\<in> V0; \\<forall>i. (r i, r (Suc i)) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r'.\n                         (r' 0 \\<in> g_V0 (degeneralize_ext m) \\<and>\n                          (\\<forall>i.\n                              (r' i, r' (Suc i))\n                              \\<in> g_E (degeneralize_ext m))) \\<and>\n                         r = fst \\<circ> r'", "have R0': \"r' 0 \\<in> degen.V0 T m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r' 0 \\<in> g_V0 (degeneralize_ext m)", "using R0"], ["proof (prove)\nusing this:\n  r 0 \\<in> V0\n\ngoal (1 subgoal):\n 1. r' 0 \\<in> g_V0 (degeneralize_ext m)", "unfolding degeneralize_ext_def"], ["proof (prove)\nusing this:\n  r 0 \\<in> V0\n\ngoal (1 subgoal):\n 1. r' 0\n    \\<in> g_V0\n           (if num_acc = 0\n            then \\<lparr>g_V = V \\<times> {0},\n                    g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                    g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                    \\<dots> = m G\\<rparr>\n            else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                    g_E =\n                      {((q, i), q', i') |i i' q q'.\n                       i < num_acc \\<and>\n                       (q, q') \\<in> E \\<and>\n                       i' =\n                       (if i \\<in> acc q then (i + 1) mod num_acc else i)},\n                    g_V0 = V0 \\<times> {0},\n                    bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                    \\<dots> = m G\\<rparr>)", "by auto"], ["proof (state)\nthis:\n  r' 0 \\<in> g_V0 (degeneralize_ext m)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>r 0 \\<in> V0; \\<forall>i. (r i, r (Suc i)) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r'.\n                         (r' 0 \\<in> g_V0 (degeneralize_ext m) \\<and>\n                          (\\<forall>i.\n                              (r' i, r' (Suc i))\n                              \\<in> g_E (degeneralize_ext m))) \\<and>\n                         r = fst \\<circ> r'", "have MAP: \"r = fst o r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = fst \\<circ> r'", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. r x = (fst \\<circ> r') x", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. r x = (fst \\<circ> r') x", "show \"r i = (fst o r') i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r i = (fst \\<circ> r') i", "by (cases i) (auto simp: split: prod.split)"], ["proof (state)\nthis:\n  r i = (fst \\<circ> r') i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  r = fst \\<circ> r'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>r 0 \\<in> V0; \\<forall>i. (r i, r (Suc i)) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r'.\n                         (r' 0 \\<in> g_V0 (degeneralize_ext m) \\<and>\n                          (\\<forall>i.\n                              (r' i, r' (Suc i))\n                              \\<in> g_E (degeneralize_ext m))) \\<and>\n                         r = fst \\<circ> r'", "have [simp]: \"0<num_acc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < num_acc", "by (cases num_acc) auto"], ["proof (state)\nthis:\n  0 < num_acc\n\ngoal (1 subgoal):\n 1. \\<lbrakk>r 0 \\<in> V0; \\<forall>i. (r i, r (Suc i)) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r'.\n                         (r' 0 \\<in> g_V0 (degeneralize_ext m) \\<and>\n                          (\\<forall>i.\n                              (r' i, r' (Suc i))\n                              \\<in> g_E (degeneralize_ext m))) \\<and>\n                         r = fst \\<circ> r'", "have SND_LESS: \"\\<And>i. snd (r' i) < num_acc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. snd (r' i) < num_acc", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. snd (r' i) < num_acc", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. snd (r' i) < num_acc", "show \"snd (r' i) < num_acc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (r' i) < num_acc", "by (induction i) (auto split: prod.split)"], ["proof (state)\nthis:\n  snd (r' i) < num_acc\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  snd (r' ?i2) < num_acc\n\ngoal (1 subgoal):\n 1. \\<lbrakk>r 0 \\<in> V0; \\<forall>i. (r i, r (Suc i)) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r'.\n                         (r' 0 \\<in> g_V0 (degeneralize_ext m) \\<and>\n                          (\\<forall>i.\n                              (r' i, r' (Suc i))\n                              \\<in> g_E (degeneralize_ext m))) \\<and>\n                         r = fst \\<circ> r'", "have RS': \"\\<forall>i. (r' i, r' (Suc i)) \\<in> degen.E T m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. (r' i, r' (Suc i)) \\<in> g_E (degeneralize_ext m)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. (r' i, r' (Suc i)) \\<in> g_E (degeneralize_ext m)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. (r' i, r' (Suc i)) \\<in> g_E (degeneralize_ext m)", "obtain n where [simp]: \"r' i = (r i,n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. r' i = (r i, n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (cases i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>n. r' i = (r i, n) \\<Longrightarrow> thesis;\n     i = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>nat.\n       \\<lbrakk>\\<And>n. r' i = (r i, n) \\<Longrightarrow> thesis;\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>\\<And>n. r' i = (r i, n) \\<Longrightarrow> thesis;\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (force split: prod.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  r' i = (r i, n)\n\ngoal (1 subgoal):\n 1. \\<And>i. (r' i, r' (Suc i)) \\<in> g_E (degeneralize_ext m)", "from SND_LESS[of i]"], ["proof (chain)\npicking this:\n  snd (r' i) < num_acc", "have [simp]: \"n<num_acc\""], ["proof (prove)\nusing this:\n  snd (r' i) < num_acc\n\ngoal (1 subgoal):\n 1. n < num_acc", "by simp"], ["proof (state)\nthis:\n  n < num_acc\n\ngoal (1 subgoal):\n 1. \\<And>i. (r' i, r' (Suc i)) \\<in> g_E (degeneralize_ext m)", "show \"(r' i, r' (Suc i)) \\<in> degen.E T m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r' i, r' (Suc i)) \\<in> g_E (degeneralize_ext m)", "using RS"], ["proof (prove)\nusing this:\n  \\<forall>i. (r i, r (Suc i)) \\<in> E\n\ngoal (1 subgoal):\n 1. (r' i, r' (Suc i)) \\<in> g_E (degeneralize_ext m)", "by (auto simp: degeneralize_ext_def)"], ["proof (state)\nthis:\n  (r' i, r' (Suc i)) \\<in> g_E (degeneralize_ext m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i. (r' i, r' (Suc i)) \\<in> g_E (degeneralize_ext m)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>r 0 \\<in> V0; \\<forall>i. (r i, r (Suc i)) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r'.\n                         (r' 0 \\<in> g_V0 (degeneralize_ext m) \\<and>\n                          (\\<forall>i.\n                              (r' i, r' (Suc i))\n                              \\<in> g_E (degeneralize_ext m))) \\<and>\n                         r = fst \\<circ> r'", "from R0' RS' MAP"], ["proof (chain)\npicking this:\n  r' 0 \\<in> g_V0 (degeneralize_ext m)\n  \\<forall>i. (r' i, r' (Suc i)) \\<in> g_E (degeneralize_ext m)\n  r = fst \\<circ> r'", "show \n      \"\\<exists>r'. (r' 0 \\<in> degen.V0 T m\n      \\<and> (\\<forall>i. (r' i, r' (Suc i)) \\<in> degen.E T m)) \n      \\<and> r = fst \\<circ> r'\""], ["proof (prove)\nusing this:\n  r' 0 \\<in> g_V0 (degeneralize_ext m)\n  \\<forall>i. (r' i, r' (Suc i)) \\<in> g_E (degeneralize_ext m)\n  r = fst \\<circ> r'\n\ngoal (1 subgoal):\n 1. \\<exists>r'.\n       (r' 0 \\<in> g_V0 (degeneralize_ext m) \\<and>\n        (\\<forall>i.\n            (r' i, r' (Suc i)) \\<in> g_E (degeneralize_ext m))) \\<and>\n       r = fst \\<circ> r'", "by blast"], ["proof (state)\nthis:\n  \\<exists>r'.\n     (r' 0 \\<in> g_V0 (degeneralize_ext m) \\<and>\n      (\\<forall>i.\n          (r' i, r' (Suc i)) \\<in> g_E (degeneralize_ext m))) \\<and>\n     r = fst \\<circ> r'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degen_run_bound:\n    assumes [simp]: \"num_acc \\<noteq> 0\"\n    assumes R: \"degen.is_run T m r\"\n    shows \"snd (r i) < num_acc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (r i) < num_acc", "apply (induction i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. snd (r 0) < num_acc\n 2. \\<And>i. snd (r i) < num_acc \\<Longrightarrow> snd (r (Suc i)) < num_acc", "using R"], ["proof (prove)\nusing this:\n  graph_defs.is_run (degeneralize_ext m) r\n\ngoal (2 subgoals):\n 1. snd (r 0) < num_acc\n 2. \\<And>i. snd (r i) < num_acc \\<Longrightarrow> snd (r (Suc i)) < num_acc", "unfolding degen.is_run_def is_run_def"], ["proof (prove)\nusing this:\n  r 0 \\<in> g_V0 (degeneralize_ext m) \\<and>\n  ipath (g_E (degeneralize_ext m)) r\n\ngoal (2 subgoals):\n 1. snd (r 0) < num_acc\n 2. \\<And>i. snd (r i) < num_acc \\<Longrightarrow> snd (r (Suc i)) < num_acc", "unfolding degeneralize_ext_def ipath_def"], ["proof (prove)\nusing this:\n  r 0\n  \\<in> g_V0\n         (if num_acc = 0\n          then \\<lparr>g_V = V \\<times> {0},\n                  g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                  g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                  \\<dots> = m G\\<rparr>\n          else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                  g_E =\n                    {((q, i), q', i') |i i' q q'.\n                     i < num_acc \\<and>\n                     (q, q') \\<in> E \\<and>\n                     i' =\n                     (if i \\<in> acc q then (i + 1) mod num_acc else i)},\n                  g_V0 = V0 \\<times> {0}, bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                  \\<dots> = m G\\<rparr>) \\<and>\n  (\\<forall>i.\n      (r i, r (Suc i))\n      \\<in> g_E (if num_acc = 0\n                 then \\<lparr>g_V = V \\<times> {0},\n                         g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                         g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                         \\<dots> = m G\\<rparr>\n                 else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                         g_E =\n                           {((q, i), q', i') |i i' q q'.\n                            i < num_acc \\<and>\n                            (q, q') \\<in> E \\<and>\n                            i' =\n                            (if i \\<in> acc q then (i + 1) mod num_acc\n                             else i)},\n                         g_V0 = V0 \\<times> {0},\n                         bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                         \\<dots> = m G\\<rparr>))\n\ngoal (2 subgoals):\n 1. snd (r 0) < num_acc\n 2. \\<And>i. snd (r i) < num_acc \\<Longrightarrow> snd (r (Suc i)) < num_acc", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. r 0\n    \\<in> g_V0\n           (if num_acc = 0\n            then \\<lparr>g_V = V \\<times> {0},\n                    g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                    g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                    \\<dots> = m G\\<rparr>\n            else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                    g_E =\n                      {((q, i), q', i') |i i' q q'.\n                       i < num_acc \\<and>\n                       (q, q') \\<in> E \\<and>\n                       i' =\n                       (if i \\<in> acc q then (i + 1) mod num_acc else i)},\n                    g_V0 = V0 \\<times> {0},\n                    bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                    \\<dots> = m G\\<rparr>) \\<and>\n    (\\<forall>i.\n        (r i, r (Suc i))\n        \\<in> g_E (if num_acc = 0\n                   then \\<lparr>g_V = V \\<times> {0},\n                           g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                           g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                           \\<dots> = m G\\<rparr>\n                   else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                           g_E =\n                             {((q, i), q', i') |i i' q q'.\n                              i < num_acc \\<and>\n                              (q, q') \\<in> E \\<and>\n                              i' =\n                              (if i \\<in> acc q then (i + 1) mod num_acc\n                               else i)},\n                           g_V0 = V0 \\<times> {0},\n                           bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                           \\<dots> = m G\\<rparr>)) \\<Longrightarrow>\n    snd (r 0) < num_acc\n 2. \\<And>i.\n       \\<lbrakk>snd (r i) < num_acc;\n        r 0\n        \\<in> g_V0\n               (if num_acc = 0\n                then \\<lparr>g_V = V \\<times> {0},\n                        g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                        g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                        \\<dots> = m G\\<rparr>\n                else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                        g_E =\n                          {((q, i), q', i') |i i' q q'.\n                           i < num_acc \\<and>\n                           (q, q') \\<in> E \\<and>\n                           i' =\n                           (if i \\<in> acc q then (i + 1) mod num_acc\n                            else i)},\n                        g_V0 = V0 \\<times> {0},\n                        bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                        \\<dots> = m G\\<rparr>) \\<and>\n        (\\<forall>i.\n            (r i, r (Suc i))\n            \\<in> g_E (if num_acc = 0\n                       then \\<lparr>g_V = V \\<times> {0},\n                               g_E =\n                                 {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                               g_V0 = V0 \\<times> {0},\n                               bg_F = V \\<times> {0}, \\<dots> = m G\\<rparr>\n                       else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                               g_E =\n                                 {((q, i), q', i') |i i' q q'.\n                                  i < num_acc \\<and>\n                                  (q, q') \\<in> E \\<and>\n                                  i' =\n                                  (if i \\<in> acc q then (i + 1) mod num_acc\n                                   else i)},\n                               g_V0 = V0 \\<times> {0},\n                               bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                               \\<dots> = m G\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> snd (r (Suc i)) < num_acc", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>snd (r i) < num_acc;\n        r 0\n        \\<in> g_V0\n               (if num_acc = 0\n                then \\<lparr>g_V = V \\<times> {0},\n                        g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                        g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                        \\<dots> = m G\\<rparr>\n                else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                        g_E =\n                          {((q, i), q', i') |i i' q q'.\n                           i < num_acc \\<and>\n                           (q, q') \\<in> E \\<and>\n                           i' =\n                           (if i \\<in> acc q then (i + 1) mod num_acc\n                            else i)},\n                        g_V0 = V0 \\<times> {0},\n                        bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                        \\<dots> = m G\\<rparr>) \\<and>\n        (\\<forall>i.\n            (r i, r (Suc i))\n            \\<in> g_E (if num_acc = 0\n                       then \\<lparr>g_V = V \\<times> {0},\n                               g_E =\n                                 {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                               g_V0 = V0 \\<times> {0},\n                               bg_F = V \\<times> {0}, \\<dots> = m G\\<rparr>\n                       else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                               g_E =\n                                 {((q, i), q', i') |i i' q q'.\n                                  i < num_acc \\<and>\n                                  (q, q') \\<in> E \\<and>\n                                  i' =\n                                  (if i \\<in> acc q then (i + 1) mod num_acc\n                                   else i)},\n                               g_V0 = V0 \\<times> {0},\n                               bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                               \\<dots> = m G\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> snd (r (Suc i)) < num_acc", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>snd (r i) < num_acc;\n        \\<forall>i.\n           \\<exists>ia q.\n              r i = (q, ia) \\<and>\n              (\\<exists>q'.\n                  r (Suc i) =\n                  (q',\n                   if ia \\<in> acc q then (ia + 1) mod num_acc\n                   else ia) \\<and>\n                  ia < num_acc \\<and> (q, q') \\<in> E);\n        x \\<in> V0; r 0 = (x, 0)\\<rbrakk>\n       \\<Longrightarrow> snd (r (Suc i)) < num_acc", "by (metis snd_conv)"], ["", "lemma degen_acc_run_complete_aux1: \n    assumes NN0[simp]: \"num_acc \\<noteq> 0\"\n    assumes R: \"degen.is_run T m r\"\n    assumes EXJ: \"\\<exists>j\\<ge>i. n \\<in> acc (fst (r j))\"\n    assumes RI: \"r i = (q,n)\"\n    shows \"\\<exists>j\\<ge>i. \\<exists>q'. r j = (q',n) \\<and> n \\<in> acc q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. \\<exists>q'. r j = (q', n) \\<and> n \\<in> acc q'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. \\<exists>q'. r j = (q', n) \\<and> n \\<in> acc q'", "define j where \"j = (LEAST j. j\\<ge>i \\<and> n \\<in> acc (fst (r j)))\""], ["proof (state)\nthis:\n  j = (LEAST j. i \\<le> j \\<and> n \\<in> acc (fst (r j)))\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. \\<exists>q'. r j = (q', n) \\<and> n \\<in> acc q'", "from RI"], ["proof (chain)\npicking this:\n  r i = (q, n)", "have \"n<num_acc\""], ["proof (prove)\nusing this:\n  r i = (q, n)\n\ngoal (1 subgoal):\n 1. n < num_acc", "using degen_run_bound[OF NN0 R, of i]"], ["proof (prove)\nusing this:\n  r i = (q, n)\n  snd (r i) < num_acc\n\ngoal (1 subgoal):\n 1. n < num_acc", "by auto"], ["proof (state)\nthis:\n  n < num_acc\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. \\<exists>q'. r j = (q', n) \\<and> n \\<in> acc q'", "from EXJ"], ["proof (chain)\npicking this:\n  \\<exists>j\\<ge>i. n \\<in> acc (fst (r j))", "have \n      \"j\\<ge>i\" \n      \"n \\<in> acc (fst (r j))\" \n      \"\\<forall>k\\<ge>i. n \\<in> acc (fst (r k)) \\<longrightarrow> j\\<le>k\""], ["proof (prove)\nusing this:\n  \\<exists>j\\<ge>i. n \\<in> acc (fst (r j))\n\ngoal (1 subgoal):\n 1. i \\<le> j &&&\n    n \\<in> acc (fst (r j)) &&&\n    \\<forall>k\\<ge>i. n \\<in> acc (fst (r k)) \\<longrightarrow> j \\<le> k", "using LeastI_ex[OF EXJ]"], ["proof (prove)\nusing this:\n  \\<exists>j\\<ge>i. n \\<in> acc (fst (r j))\n  i \\<le> (LEAST j. i \\<le> j \\<and> n \\<in> acc (fst (r j))) \\<and>\n  n \\<in> acc (fst (r (LEAST j. i \\<le> j \\<and> n \\<in> acc (fst (r j)))))\n\ngoal (1 subgoal):\n 1. i \\<le> j &&&\n    n \\<in> acc (fst (r j)) &&&\n    \\<forall>k\\<ge>i. n \\<in> acc (fst (r k)) \\<longrightarrow> j \\<le> k", "unfolding j_def"], ["proof (prove)\nusing this:\n  \\<exists>j\\<ge>i. n \\<in> acc (fst (r j))\n  i \\<le> (LEAST j. i \\<le> j \\<and> n \\<in> acc (fst (r j))) \\<and>\n  n \\<in> acc (fst (r (LEAST j. i \\<le> j \\<and> n \\<in> acc (fst (r j)))))\n\ngoal (1 subgoal):\n 1. i \\<le> (LEAST j. i \\<le> j \\<and> n \\<in> acc (fst (r j))) &&&\n    n \\<in> acc (fst (r (LEAST j.\n                            i \\<le> j \\<and> n \\<in> acc (fst (r j))))) &&&\n    \\<forall>k\\<ge>i.\n       n \\<in> acc (fst (r k)) \\<longrightarrow>\n       (LEAST j. i \\<le> j \\<and> n \\<in> acc (fst (r j))) \\<le> k", "apply (auto) [2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k\\<ge>i.\n       n \\<in> acc (fst (r k)) \\<longrightarrow>\n       (LEAST j. i \\<le> j \\<and> n \\<in> acc (fst (r j))) \\<le> k", "apply (metis (lifting) Least_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  i \\<le> j\n  n \\<in> acc (fst (r j))\n  \\<forall>k\\<ge>i. n \\<in> acc (fst (r k)) \\<longrightarrow> j \\<le> k\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. \\<exists>q'. r j = (q', n) \\<and> n \\<in> acc q'", "hence \"\\<forall>k\\<ge>i. k<j \\<longrightarrow> n \\<notin> acc (fst (r k))\""], ["proof (prove)\nusing this:\n  i \\<le> j\n  n \\<in> acc (fst (r j))\n  \\<forall>k\\<ge>i. n \\<in> acc (fst (r k)) \\<longrightarrow> j \\<le> k\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<ge>i. k < j \\<longrightarrow> n \\<notin> acc (fst (r k))", "by auto"], ["proof (state)\nthis:\n  \\<forall>k\\<ge>i. k < j \\<longrightarrow> n \\<notin> acc (fst (r k))\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. \\<exists>q'. r j = (q', n) \\<and> n \\<in> acc q'", "have \"\\<forall>k. k\\<ge>i \\<and> k\\<le>j \\<longrightarrow> (snd (r k) = n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k. i \\<le> k \\<and> k \\<le> j \\<longrightarrow> snd (r k) = n", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>i \\<le> k; k \\<le> j\\<rbrakk>\n       \\<Longrightarrow> snd (r k) = n", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>i \\<le> k; k \\<le> j\\<rbrakk>\n       \\<Longrightarrow> snd (r k) = n", "assume \"i\\<le>k\" \"k\\<le>j\""], ["proof (state)\nthis:\n  i \\<le> k\n  k \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>i \\<le> k; k \\<le> j\\<rbrakk>\n       \\<Longrightarrow> snd (r k) = n", "thus \"snd (r k) = n\""], ["proof (prove)\nusing this:\n  i \\<le> k\n  k \\<le> j\n\ngoal (1 subgoal):\n 1. snd (r k) = n", "proof (induction k rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; i \\<le> y; y \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> snd (r y) = n;\n        i \\<le> x; x \\<le> j\\<rbrakk>\n       \\<Longrightarrow> snd (r x) = n", "case (less k)"], ["proof (state)\nthis:\n  \\<lbrakk>?y2 < k; i \\<le> ?y2; ?y2 \\<le> j\\<rbrakk>\n  \\<Longrightarrow> snd (r ?y2) = n\n  i \\<le> k\n  k \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; i \\<le> y; y \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> snd (r y) = n;\n        i \\<le> x; x \\<le> j\\<rbrakk>\n       \\<Longrightarrow> snd (r x) = n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (r k) = n", "proof (cases \"k=i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = i \\<Longrightarrow> snd (r k) = n\n 2. k \\<noteq> i \\<Longrightarrow> snd (r k) = n", "case True"], ["proof (state)\nthis:\n  k = i\n\ngoal (2 subgoals):\n 1. k = i \\<Longrightarrow> snd (r k) = n\n 2. k \\<noteq> i \\<Longrightarrow> snd (r k) = n", "thus ?thesis"], ["proof (prove)\nusing this:\n  k = i\n\ngoal (1 subgoal):\n 1. snd (r k) = n", "using RI"], ["proof (prove)\nusing this:\n  k = i\n  r i = (q, n)\n\ngoal (1 subgoal):\n 1. snd (r k) = n", "by simp"], ["proof (state)\nthis:\n  snd (r k) = n\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow> snd (r k) = n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow> snd (r k) = n", "case False"], ["proof (state)\nthis:\n  k \\<noteq> i\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow> snd (r k) = n", "with less.prems"], ["proof (chain)\npicking this:\n  i \\<le> k\n  k \\<le> j\n  k \\<noteq> i", "have \"k - 1 < k\" \"i \\<le> k - 1\" \"k - 1\\<le>j\""], ["proof (prove)\nusing this:\n  i \\<le> k\n  k \\<le> j\n  k \\<noteq> i\n\ngoal (1 subgoal):\n 1. k - 1 < k &&& i \\<le> k - 1 &&& k - 1 \\<le> j", "by auto"], ["proof (state)\nthis:\n  k - 1 < k\n  i \\<le> k - 1\n  k - 1 \\<le> j\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow> snd (r k) = n", "from less.IH[OF this]"], ["proof (chain)\npicking this:\n  snd (r (k - 1)) = n", "have \"snd (r (k - 1)) = n\""], ["proof (prove)\nusing this:\n  snd (r (k - 1)) = n\n\ngoal (1 subgoal):\n 1. snd (r (k - 1)) = n", "."], ["proof (state)\nthis:\n  snd (r (k - 1)) = n\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow> snd (r k) = n", "moreover"], ["proof (state)\nthis:\n  snd (r (k - 1)) = n\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow> snd (r k) = n", "from R"], ["proof (chain)\npicking this:\n  graph_defs.is_run (degeneralize_ext m) r", "have \n            \"(r (k - 1), r k) \\<in> degen.E T m\""], ["proof (prove)\nusing this:\n  graph_defs.is_run (degeneralize_ext m) r\n\ngoal (1 subgoal):\n 1. (r (k - 1), r k) \\<in> g_E (degeneralize_ext m)", "unfolding degen.is_run_def is_run_def ipath_def"], ["proof (prove)\nusing this:\n  r 0 \\<in> g_V0 (degeneralize_ext m) \\<and>\n  (\\<forall>i. (r i, r (Suc i)) \\<in> g_E (degeneralize_ext m))\n\ngoal (1 subgoal):\n 1. (r (k - 1), r k) \\<in> g_E (degeneralize_ext m)", "by clarsimp (metis One_nat_def Suc_diff_1 \\<open>k - 1 < k\\<close> \n              less_nat_zero_code neq0_conv)"], ["proof (state)\nthis:\n  (r (k - 1), r k) \\<in> g_E (degeneralize_ext m)\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow> snd (r k) = n", "moreover"], ["proof (state)\nthis:\n  (r (k - 1), r k) \\<in> g_E (degeneralize_ext m)\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow> snd (r k) = n", "have \"n \\<notin> acc (fst (r (k - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<notin> acc (fst (r (k - 1)))", "using \\<open>\\<forall>k\\<ge>i. k < j \\<longrightarrow> n \\<notin> acc (fst (r k))\\<close> \\<open>i \\<le> k - 1\\<close> \\<open>k - 1 < k\\<close> \n              dual_order.strict_trans1 less.prems(2)"], ["proof (prove)\nusing this:\n  \\<forall>k\\<ge>i. k < j \\<longrightarrow> n \\<notin> acc (fst (r k))\n  i \\<le> k - 1\n  k - 1 < k\n  \\<lbrakk>?b \\<le> ?a; ?c < ?b\\<rbrakk> \\<Longrightarrow> ?c < ?a\n  k \\<le> j\n\ngoal (1 subgoal):\n 1. n \\<notin> acc (fst (r (k - 1)))", "by blast"], ["proof (state)\nthis:\n  n \\<notin> acc (fst (r (k - 1)))\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow> snd (r k) = n", "ultimately"], ["proof (chain)\npicking this:\n  snd (r (k - 1)) = n\n  (r (k - 1), r k) \\<in> g_E (degeneralize_ext m)\n  n \\<notin> acc (fst (r (k - 1)))", "show ?thesis"], ["proof (prove)\nusing this:\n  snd (r (k - 1)) = n\n  (r (k - 1), r k) \\<in> g_E (degeneralize_ext m)\n  n \\<notin> acc (fst (r (k - 1)))\n\ngoal (1 subgoal):\n 1. snd (r k) = n", "by (auto simp: degeneralize_ext_def)"], ["proof (state)\nthis:\n  snd (r k) = n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  snd (r k) = n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  snd (r k) = n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>k. i \\<le> k \\<and> k \\<le> j \\<longrightarrow> snd (r k) = n\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. \\<exists>q'. r j = (q', n) \\<and> n \\<in> acc q'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>k. i \\<le> k \\<and> k \\<le> j \\<longrightarrow> snd (r k) = n\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. \\<exists>q'. r j = (q', n) \\<and> n \\<in> acc q'", "by (metis \\<open>i \\<le> j\\<close> \\<open>n \\<in> local.acc (fst (r j))\\<close> \n        order_refl surjective_pairing)"], ["proof (state)\nthis:\n  \\<exists>j\\<ge>i. \\<exists>q'. r j = (q', n) \\<and> n \\<in> acc q'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degen_acc_run_complete_aux1': \n    assumes NN0[simp]: \"num_acc \\<noteq> 0\"\n    assumes R: \"degen.is_run T m r\"\n    assumes ACC: \"\\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (fst (r i))\"\n    assumes RI: \"r i = (q,n)\"\n    shows \"\\<exists>j\\<ge>i. \\<exists>q'. r j = (q',n) \\<and> n \\<in> acc q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. \\<exists>q'. r j = (q', n) \\<and> n \\<in> acc q'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. \\<exists>q'. r j = (q', n) \\<and> n \\<in> acc q'", "from RI"], ["proof (chain)\npicking this:\n  r i = (q, n)", "have \"n<num_acc\""], ["proof (prove)\nusing this:\n  r i = (q, n)\n\ngoal (1 subgoal):\n 1. n < num_acc", "using degen_run_bound[OF NN0 R, of i]"], ["proof (prove)\nusing this:\n  r i = (q, n)\n  snd (r i) < num_acc\n\ngoal (1 subgoal):\n 1. n < num_acc", "by auto"], ["proof (state)\nthis:\n  n < num_acc\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. \\<exists>q'. r j = (q', n) \\<and> n \\<in> acc q'", "with ACC"], ["proof (chain)\npicking this:\n  \\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (fst (r i))\n  n < num_acc", "have EXJ: \"\\<exists>j\\<ge>i. n \\<in> acc (fst (r j))\""], ["proof (prove)\nusing this:\n  \\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (fst (r i))\n  n < num_acc\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. n \\<in> acc (fst (r j))", "unfolding INFM_nat_le"], ["proof (prove)\nusing this:\n  \\<forall>n<num_acc.\n     \\<forall>m. \\<exists>na\\<ge>m. n \\<in> acc (fst (r na))\n  n < num_acc\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. n \\<in> acc (fst (r j))", "by blast"], ["proof (state)\nthis:\n  \\<exists>j\\<ge>i. n \\<in> acc (fst (r j))\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. \\<exists>q'. r j = (q', n) \\<and> n \\<in> acc q'", "from degen_acc_run_complete_aux1[OF NN0 R EXJ RI]"], ["proof (chain)\npicking this:\n  \\<exists>j\\<ge>i. \\<exists>q'. r j = (q', n) \\<and> n \\<in> acc q'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>j\\<ge>i. \\<exists>q'. r j = (q', n) \\<and> n \\<in> acc q'\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. \\<exists>q'. r j = (q', n) \\<and> n \\<in> acc q'", "."], ["proof (state)\nthis:\n  \\<exists>j\\<ge>i. \\<exists>q'. r j = (q', n) \\<and> n \\<in> acc q'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degen_acc_run_complete_aux2:\n    assumes NN0[simp]: \"num_acc \\<noteq> 0\"\n    assumes R: \"degen.is_run T m r\"\n    assumes ACC: \"\\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (fst (r i))\"\n    assumes RI: \"r i = (q,n)\" and OFS: \"ofs<num_acc\"\n    shows \"\\<exists>j\\<ge>i. \\<exists>q'. \n      r j = (q',(n + ofs) mod num_acc) \\<and> (n + ofs) mod num_acc \\<in> acc q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i.\n       \\<exists>q'.\n          r j = (q', (n + ofs) mod num_acc) \\<and>\n          (n + ofs) mod num_acc \\<in> acc q'", "using RI OFS"], ["proof (prove)\nusing this:\n  r i = (q, n)\n  ofs < num_acc\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i.\n       \\<exists>q'.\n          r j = (q', (n + ofs) mod num_acc) \\<and>\n          (n + ofs) mod num_acc \\<in> acc q'", "proof (induction ofs arbitrary: q n i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q n i.\n       \\<lbrakk>r i = (q, n); 0 < num_acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<exists>q'.\n                               r j = (q', (n + 0) mod num_acc) \\<and>\n                               (n + 0) mod num_acc \\<in> acc q'\n 2. \\<And>ofs q n i.\n       \\<lbrakk>\\<And>q n i.\n                   \\<lbrakk>r i = (q, n); ofs < num_acc\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j\\<ge>i.\n  \\<exists>q'.\n     r j = (q', (n + ofs) mod num_acc) \\<and>\n     (n + ofs) mod num_acc \\<in> acc q';\n        r i = (q, n); Suc ofs < num_acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<exists>q'.\n                               r j = (q', (n + Suc ofs) mod num_acc) \\<and>\n                               (n + Suc ofs) mod num_acc \\<in> acc q'", "case 0"], ["proof (state)\nthis:\n  r i = (q, n)\n  0 < num_acc\n\ngoal (2 subgoals):\n 1. \\<And>q n i.\n       \\<lbrakk>r i = (q, n); 0 < num_acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<exists>q'.\n                               r j = (q', (n + 0) mod num_acc) \\<and>\n                               (n + 0) mod num_acc \\<in> acc q'\n 2. \\<And>ofs q n i.\n       \\<lbrakk>\\<And>q n i.\n                   \\<lbrakk>r i = (q, n); ofs < num_acc\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j\\<ge>i.\n  \\<exists>q'.\n     r j = (q', (n + ofs) mod num_acc) \\<and>\n     (n + ofs) mod num_acc \\<in> acc q';\n        r i = (q, n); Suc ofs < num_acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<exists>q'.\n                               r j = (q', (n + Suc ofs) mod num_acc) \\<and>\n                               (n + Suc ofs) mod num_acc \\<in> acc q'", "from degen_run_bound[OF NN0 R, of i] \\<open>r i = (q, n)\\<close>"], ["proof (chain)\npicking this:\n  snd (r i) < num_acc\n  r i = (q, n)", "have NLE: \"n<num_acc\""], ["proof (prove)\nusing this:\n  snd (r i) < num_acc\n  r i = (q, n)\n\ngoal (1 subgoal):\n 1. n < num_acc", "by simp"], ["proof (state)\nthis:\n  n < num_acc\n\ngoal (2 subgoals):\n 1. \\<And>q n i.\n       \\<lbrakk>r i = (q, n); 0 < num_acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<exists>q'.\n                               r j = (q', (n + 0) mod num_acc) \\<and>\n                               (n + 0) mod num_acc \\<in> acc q'\n 2. \\<And>ofs q n i.\n       \\<lbrakk>\\<And>q n i.\n                   \\<lbrakk>r i = (q, n); ofs < num_acc\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j\\<ge>i.\n  \\<exists>q'.\n     r j = (q', (n + ofs) mod num_acc) \\<and>\n     (n + ofs) mod num_acc \\<in> acc q';\n        r i = (q, n); Suc ofs < num_acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<exists>q'.\n                               r j = (q', (n + Suc ofs) mod num_acc) \\<and>\n                               (n + Suc ofs) mod num_acc \\<in> acc q'", "with degen_acc_run_complete_aux1'[OF NN0 R ACC \\<open>r i = (q, n)\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>j\\<ge>i. \\<exists>q'. r j = (q', n) \\<and> n \\<in> acc q'\n  n < num_acc", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>j\\<ge>i. \\<exists>q'. r j = (q', n) \\<and> n \\<in> acc q'\n  n < num_acc\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i.\n       \\<exists>q'.\n          r j = (q', (n + 0) mod num_acc) \\<and>\n          (n + 0) mod num_acc \\<in> acc q'", "by auto"], ["proof (state)\nthis:\n  \\<exists>j\\<ge>i.\n     \\<exists>q'.\n        r j = (q', (n + 0) mod num_acc) \\<and>\n        (n + 0) mod num_acc \\<in> acc q'\n\ngoal (1 subgoal):\n 1. \\<And>ofs q n i.\n       \\<lbrakk>\\<And>q n i.\n                   \\<lbrakk>r i = (q, n); ofs < num_acc\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j\\<ge>i.\n  \\<exists>q'.\n     r j = (q', (n + ofs) mod num_acc) \\<and>\n     (n + ofs) mod num_acc \\<in> acc q';\n        r i = (q, n); Suc ofs < num_acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<exists>q'.\n                               r j = (q', (n + Suc ofs) mod num_acc) \\<and>\n                               (n + Suc ofs) mod num_acc \\<in> acc q'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ofs q n i.\n       \\<lbrakk>\\<And>q n i.\n                   \\<lbrakk>r i = (q, n); ofs < num_acc\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j\\<ge>i.\n  \\<exists>q'.\n     r j = (q', (n + ofs) mod num_acc) \\<and>\n     (n + ofs) mod num_acc \\<in> acc q';\n        r i = (q, n); Suc ofs < num_acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<exists>q'.\n                               r j = (q', (n + Suc ofs) mod num_acc) \\<and>\n                               (n + Suc ofs) mod num_acc \\<in> acc q'", "case (Suc ofs)"], ["proof (state)\nthis:\n  \\<lbrakk>r ?i2 = (?q2, ?n2); ofs < num_acc\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j\\<ge>?i2.\n                       \\<exists>q'.\n                          r j = (q', (?n2 + ofs) mod num_acc) \\<and>\n                          (?n2 + ofs) mod num_acc \\<in> acc q'\n  r i = (q, n)\n  Suc ofs < num_acc\n\ngoal (1 subgoal):\n 1. \\<And>ofs q n i.\n       \\<lbrakk>\\<And>q n i.\n                   \\<lbrakk>r i = (q, n); ofs < num_acc\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j\\<ge>i.\n  \\<exists>q'.\n     r j = (q', (n + ofs) mod num_acc) \\<and>\n     (n + ofs) mod num_acc \\<in> acc q';\n        r i = (q, n); Suc ofs < num_acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<exists>q'.\n                               r j = (q', (n + Suc ofs) mod num_acc) \\<and>\n                               (n + Suc ofs) mod num_acc \\<in> acc q'", "from Suc.IH[OF Suc.prems(1)] Suc.prems(2)"], ["proof (chain)\npicking this:\n  ofs < num_acc \\<Longrightarrow>\n  \\<exists>j\\<ge>i.\n     \\<exists>q'.\n        r j = (q', (n + ofs) mod num_acc) \\<and>\n        (n + ofs) mod num_acc \\<in> acc q'\n  Suc ofs < num_acc", "obtain j q' where \"j\\<ge>i\" and RJ: \"r j = (q',(n+ofs) mod num_acc)\" \n      and A: \"(n+ofs) mod num_acc \\<in> acc q'\""], ["proof (prove)\nusing this:\n  ofs < num_acc \\<Longrightarrow>\n  \\<exists>j\\<ge>i.\n     \\<exists>q'.\n        r j = (q', (n + ofs) mod num_acc) \\<and>\n        (n + ofs) mod num_acc \\<in> acc q'\n  Suc ofs < num_acc\n\ngoal (1 subgoal):\n 1. (\\<And>j q'.\n        \\<lbrakk>i \\<le> j; r j = (q', (n + ofs) mod num_acc);\n         (n + ofs) mod num_acc \\<in> acc q'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i \\<le> j\n  r j = (q', (n + ofs) mod num_acc)\n  (n + ofs) mod num_acc \\<in> acc q'\n\ngoal (1 subgoal):\n 1. \\<And>ofs q n i.\n       \\<lbrakk>\\<And>q n i.\n                   \\<lbrakk>r i = (q, n); ofs < num_acc\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j\\<ge>i.\n  \\<exists>q'.\n     r j = (q', (n + ofs) mod num_acc) \\<and>\n     (n + ofs) mod num_acc \\<in> acc q';\n        r i = (q, n); Suc ofs < num_acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<exists>q'.\n                               r j = (q', (n + Suc ofs) mod num_acc) \\<and>\n                               (n + Suc ofs) mod num_acc \\<in> acc q'", "from R"], ["proof (chain)\npicking this:\n  graph_defs.is_run (degeneralize_ext m) r", "have \"(r j, r (Suc j)) \\<in> degen.E T m\""], ["proof (prove)\nusing this:\n  graph_defs.is_run (degeneralize_ext m) r\n\ngoal (1 subgoal):\n 1. (r j, r (Suc j)) \\<in> g_E (degeneralize_ext m)", "by (auto simp: degen.is_run_def is_run_def ipath_def)"], ["proof (state)\nthis:\n  (r j, r (Suc j)) \\<in> g_E (degeneralize_ext m)\n\ngoal (1 subgoal):\n 1. \\<And>ofs q n i.\n       \\<lbrakk>\\<And>q n i.\n                   \\<lbrakk>r i = (q, n); ofs < num_acc\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j\\<ge>i.\n  \\<exists>q'.\n     r j = (q', (n + ofs) mod num_acc) \\<and>\n     (n + ofs) mod num_acc \\<in> acc q';\n        r i = (q, n); Suc ofs < num_acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<exists>q'.\n                               r j = (q', (n + Suc ofs) mod num_acc) \\<and>\n                               (n + Suc ofs) mod num_acc \\<in> acc q'", "with RJ A"], ["proof (chain)\npicking this:\n  r j = (q', (n + ofs) mod num_acc)\n  (n + ofs) mod num_acc \\<in> acc q'\n  (r j, r (Suc j)) \\<in> g_E (degeneralize_ext m)", "obtain q2 where RSJ: \"r (Suc j) = (q2,(n+Suc ofs) mod num_acc)\""], ["proof (prove)\nusing this:\n  r j = (q', (n + ofs) mod num_acc)\n  (n + ofs) mod num_acc \\<in> acc q'\n  (r j, r (Suc j)) \\<in> g_E (degeneralize_ext m)\n\ngoal (1 subgoal):\n 1. (\\<And>q2.\n        r (Suc j) = (q2, (n + Suc ofs) mod num_acc) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: degeneralize_ext_def mod_simps)"], ["proof (state)\nthis:\n  r (Suc j) = (q2, (n + Suc ofs) mod num_acc)\n\ngoal (1 subgoal):\n 1. \\<And>ofs q n i.\n       \\<lbrakk>\\<And>q n i.\n                   \\<lbrakk>r i = (q, n); ofs < num_acc\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j\\<ge>i.\n  \\<exists>q'.\n     r j = (q', (n + ofs) mod num_acc) \\<and>\n     (n + ofs) mod num_acc \\<in> acc q';\n        r i = (q, n); Suc ofs < num_acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<exists>q'.\n                               r j = (q', (n + Suc ofs) mod num_acc) \\<and>\n                               (n + Suc ofs) mod num_acc \\<in> acc q'", "have aux: \"\\<And>j'. i\\<le>j \\<Longrightarrow> Suc j \\<le> j' \\<Longrightarrow> i\\<le>j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j'.\n       \\<lbrakk>i \\<le> j; Suc j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> i \\<le> j'", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<le> j; Suc j \\<le> ?j'2\\<rbrakk>\n  \\<Longrightarrow> i \\<le> ?j'2\n\ngoal (1 subgoal):\n 1. \\<And>ofs q n i.\n       \\<lbrakk>\\<And>q n i.\n                   \\<lbrakk>r i = (q, n); ofs < num_acc\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j\\<ge>i.\n  \\<exists>q'.\n     r j = (q', (n + ofs) mod num_acc) \\<and>\n     (n + ofs) mod num_acc \\<in> acc q';\n        r i = (q, n); Suc ofs < num_acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j\\<ge>i.\n                            \\<exists>q'.\n                               r j = (q', (n + Suc ofs) mod num_acc) \\<and>\n                               (n + Suc ofs) mod num_acc \\<in> acc q'", "from degen_acc_run_complete_aux1'[OF NN0 R ACC RSJ] \\<open>j\\<ge>i\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>ja\\<ge>Suc j.\n     \\<exists>q'.\n        r ja = (q', (n + Suc ofs) mod num_acc) \\<and>\n        (n + Suc ofs) mod num_acc \\<in> acc q'\n  i \\<le> j", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>ja\\<ge>Suc j.\n     \\<exists>q'.\n        r ja = (q', (n + Suc ofs) mod num_acc) \\<and>\n        (n + Suc ofs) mod num_acc \\<in> acc q'\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i.\n       \\<exists>q'.\n          r j = (q', (n + Suc ofs) mod num_acc) \\<and>\n          (n + Suc ofs) mod num_acc \\<in> acc q'", "by (auto dest: aux)"], ["proof (state)\nthis:\n  \\<exists>j\\<ge>i.\n     \\<exists>q'.\n        r j = (q', (n + Suc ofs) mod num_acc) \\<and>\n        (n + Suc ofs) mod num_acc \\<in> acc q'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degen_acc_run_complete:\n    assumes AR: \"is_acc_run r\"\n    obtains r' \n    where \"degen.is_acc_run T m r'\" and \"r = fst o r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r'.\n        \\<lbrakk>b_graph.is_acc_run (degeneralize_ext m) r';\n         r = fst \\<circ> r'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"num_acc = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>r'.\n                \\<lbrakk>b_graph.is_acc_run (degeneralize_ext m) r';\n                 r = fst \\<circ> r'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     num_acc = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>r'.\n                \\<lbrakk>b_graph.is_acc_run (degeneralize_ext m) r';\n                 r = fst \\<circ> r'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     num_acc \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  num_acc = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>r'.\n                \\<lbrakk>b_graph.is_acc_run (degeneralize_ext m) r';\n                 r = fst \\<circ> r'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     num_acc = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>r'.\n                \\<lbrakk>b_graph.is_acc_run (degeneralize_ext m) r';\n                 r = fst \\<circ> r'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     num_acc \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "with AR degen_acc_run_complete0"], ["proof (chain)\npicking this:\n  is_acc_run r\n  \\<lbrakk>num_acc = 0; is_acc_run ?r\\<rbrakk>\n  \\<Longrightarrow> b_graph.is_acc_run (degeneralize_ext ?m)\n                     (\\<lambda>i. (?r i, 0))\n  num_acc = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  is_acc_run r\n  \\<lbrakk>num_acc = 0; is_acc_run ?r\\<rbrakk>\n  \\<Longrightarrow> b_graph.is_acc_run (degeneralize_ext ?m)\n                     (\\<lambda>i. (?r i, 0))\n  num_acc = 0\n\ngoal (1 subgoal):\n 1. thesis", "by (auto intro!: that[of \"(\\<lambda>i. (r i, 0))\"])"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r'.\n                \\<lbrakk>b_graph.is_acc_run (degeneralize_ext m) r';\n                 r = fst \\<circ> r'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     num_acc \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r'.\n                \\<lbrakk>b_graph.is_acc_run (degeneralize_ext m) r';\n                 r = fst \\<circ> r'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     num_acc \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  num_acc \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r'.\n                \\<lbrakk>b_graph.is_acc_run (degeneralize_ext m) r';\n                 r = fst \\<circ> r'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     num_acc \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume NN0[simp]: \"num_acc \\<noteq> 0\""], ["proof (state)\nthis:\n  num_acc \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r'.\n                \\<lbrakk>b_graph.is_acc_run (degeneralize_ext m) r';\n                 r = fst \\<circ> r'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     num_acc \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "from AR"], ["proof (chain)\npicking this:\n  is_acc_run r", "have R: \"is_run r\" and ACC: \"\\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (r i)\""], ["proof (prove)\nusing this:\n  is_acc_run r\n\ngoal (1 subgoal):\n 1. is_run r &&&\n    \\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (r i)", "unfolding is_acc_run_def is_acc_def"], ["proof (prove)\nusing this:\n  is_run r \\<and>\n  (\\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (r i))\n\ngoal (1 subgoal):\n 1. is_run r &&&\n    \\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (r i)", "by auto"], ["proof (state)\nthis:\n  is_run r\n  \\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (r i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r'.\n                \\<lbrakk>b_graph.is_acc_run (degeneralize_ext m) r';\n                 r = fst \\<circ> r'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     num_acc \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "from degen_run_complete[OF NN0 R]"], ["proof (chain)\npicking this:\n  \\<exists>r'.\n     graph_defs.is_run (degeneralize_ext ?m) r' \\<and> r = fst \\<circ> r'", "obtain r' where \n      R': \"degen.is_run T m r'\" \n      and [simp]: \"r = fst \\<circ> r'\""], ["proof (prove)\nusing this:\n  \\<exists>r'.\n     graph_defs.is_run (degeneralize_ext ?m) r' \\<and> r = fst \\<circ> r'\n\ngoal (1 subgoal):\n 1. (\\<And>r'.\n        \\<lbrakk>graph_defs.is_run (degeneralize_ext m) r';\n         r = fst \\<circ> r'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  graph_defs.is_run (degeneralize_ext m) r'\n  r = fst \\<circ> r'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r'.\n                \\<lbrakk>b_graph.is_acc_run (degeneralize_ext m) r';\n                 r = fst \\<circ> r'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     num_acc \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "from ACC"], ["proof (chain)\npicking this:\n  \\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (r i)", "have ACC': \"\\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (fst (r' i))\""], ["proof (prove)\nusing this:\n  \\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (r i)\n\ngoal (1 subgoal):\n 1. \\<forall>n<num_acc.\n       \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (fst (r' i))", "by simp"], ["proof (state)\nthis:\n  \\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (fst (r' i))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r'.\n                \\<lbrakk>b_graph.is_acc_run (degeneralize_ext m) r';\n                 r = fst \\<circ> r'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     num_acc \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"\\<forall>i. \\<exists>j>i. r' j \\<in> degen.F T m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. \\<exists>j>i. r' j \\<in> bg_F (degeneralize_ext m)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. \\<exists>j>i. r' j \\<in> bg_F (degeneralize_ext m)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. \\<exists>j>i. r' j \\<in> bg_F (degeneralize_ext m)", "obtain q n where RI: \"r' (Suc i) = (q,n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q n.\n        r' (Suc i) = (q, n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"r' (Suc i)\")"], ["proof (state)\nthis:\n  r' (Suc i) = (q, n)\n\ngoal (1 subgoal):\n 1. \\<And>i. \\<exists>j>i. r' j \\<in> bg_F (degeneralize_ext m)", "have \"(n + (num_acc - n mod num_acc)) mod num_acc = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n + (num_acc - n mod num_acc)) mod num_acc = 0", "apply (rule dvd_imp_mod_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. num_acc dvd n + (num_acc - n mod num_acc)", "apply (metis (mono_tags, lifting) NN0 add_diff_inverse mod_0_imp_dvd\n          mod_add_left_eq mod_less_divisor mod_self nat_diff_split not_gr_zero zero_less_diff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (n + (num_acc - n mod num_acc)) mod num_acc = 0\n\ngoal (1 subgoal):\n 1. \\<And>i. \\<exists>j>i. r' j \\<in> bg_F (degeneralize_ext m)", "then"], ["proof (chain)\npicking this:\n  (n + (num_acc - n mod num_acc)) mod num_acc = 0", "obtain ofs where \n        OFS_LESS: \"ofs<num_acc\" \n        and [simp]: \"(n + ofs) mod num_acc = 0\""], ["proof (prove)\nusing this:\n  (n + (num_acc - n mod num_acc)) mod num_acc = 0\n\ngoal (1 subgoal):\n 1. (\\<And>ofs.\n        \\<lbrakk>ofs < num_acc; (n + ofs) mod num_acc = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis NN0 Nat.add_0_right diff_less neq0_conv)"], ["proof (state)\nthis:\n  ofs < num_acc\n  (n + ofs) mod num_acc = 0\n\ngoal (1 subgoal):\n 1. \\<And>i. \\<exists>j>i. r' j \\<in> bg_F (degeneralize_ext m)", "with degen_acc_run_complete_aux2[OF NN0 R' ACC' RI OFS_LESS]"], ["proof (chain)\npicking this:\n  \\<exists>j\\<ge>Suc i.\n     \\<exists>q'.\n        r' j = (q', (n + ofs) mod num_acc) \\<and>\n        (n + ofs) mod num_acc \\<in> acc q'\n  ofs < num_acc\n  (n + ofs) mod num_acc = 0", "obtain j q' where \n        \"j>i\" \"r' j = (q',0)\" and \"0\\<in>acc q'\""], ["proof (prove)\nusing this:\n  \\<exists>j\\<ge>Suc i.\n     \\<exists>q'.\n        r' j = (q', (n + ofs) mod num_acc) \\<and>\n        (n + ofs) mod num_acc \\<in> acc q'\n  ofs < num_acc\n  (n + ofs) mod num_acc = 0\n\ngoal (1 subgoal):\n 1. (\\<And>j q'.\n        \\<lbrakk>i < j; r' j = (q', 0); 0 \\<in> acc q'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: less_eq_Suc_le)"], ["proof (state)\nthis:\n  i < j\n  r' j = (q', 0)\n  0 \\<in> acc q'\n\ngoal (1 subgoal):\n 1. \\<And>i. \\<exists>j>i. r' j \\<in> bg_F (degeneralize_ext m)", "thus \"\\<exists>j>i. r' j \\<in> degen.F T m\""], ["proof (prove)\nusing this:\n  i < j\n  r' j = (q', 0)\n  0 \\<in> acc q'\n\ngoal (1 subgoal):\n 1. \\<exists>j>i. r' j \\<in> bg_F (degeneralize_ext m)", "by (auto simp: degeneralize_ext_def)"], ["proof (state)\nthis:\n  \\<exists>j>i. r' j \\<in> bg_F (degeneralize_ext m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i. \\<exists>j>i. r' j \\<in> bg_F (degeneralize_ext m)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r'.\n                \\<lbrakk>b_graph.is_acc_run (degeneralize_ext m) r';\n                 r = fst \\<circ> r'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     num_acc \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"\\<exists>\\<^sub>\\<infinity>i. r' i \\<in> degen.F T m\""], ["proof (prove)\nusing this:\n  \\<forall>i. \\<exists>j>i. r' j \\<in> bg_F (degeneralize_ext m)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<^sub>\\<infinity>i. r' i \\<in> bg_F (degeneralize_ext m)", "by (auto simp: INFM_nat)"], ["proof (state)\nthis:\n  \\<exists>\\<^sub>\\<infinity>i. r' i \\<in> bg_F (degeneralize_ext m)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r'.\n                \\<lbrakk>b_graph.is_acc_run (degeneralize_ext m) r';\n                 r = fst \\<circ> r'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     num_acc \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"degen.is_acc_run T m r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b_graph.is_acc_run (degeneralize_ext m) r'", "unfolding degen.is_acc_run_def degen.is_acc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_defs.is_run (degeneralize_ext m) r' \\<and>\n    (\\<exists>\\<^sub>\\<infinity>i. r' i \\<in> bg_F (degeneralize_ext m))", "by rule fact+"], ["proof (state)\nthis:\n  b_graph.is_acc_run (degeneralize_ext m) r'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>r'.\n                \\<lbrakk>b_graph.is_acc_run (degeneralize_ext m) r';\n                 r = fst \\<circ> r'\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     num_acc \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  b_graph.is_acc_run (degeneralize_ext m) r'\n\ngoal (1 subgoal):\n 1. thesis", "by (auto intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degen_run_find_change:\n    assumes NN0[simp]: \"num_acc \\<noteq> 0\"\n    assumes R: \"degen.is_run T m r\"\n    assumes A: \"i\\<le>j\" \"r i = (q,n)\" \"r j = (q',n')\" \"n\\<noteq>n'\"\n    obtains k qk where \"i\\<le>k\" \"k<j\" \"r k = (qk,n)\" \"n \\<in> acc qk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k qk.\n        \\<lbrakk>i \\<le> k; k < j; r k = (qk, n); n \\<in> acc qk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>k qk.\n        \\<lbrakk>i \\<le> k; k < j; r k = (qk, n); n \\<in> acc qk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from degen_run_bound[OF NN0 R] A"], ["proof (chain)\npicking this:\n  snd (r ?i) < num_acc\n  i \\<le> j\n  r i = (q, n)\n  r j = (q', n')\n  n \\<noteq> n'", "have \"n<num_acc\" \"n'<num_acc\""], ["proof (prove)\nusing this:\n  snd (r ?i) < num_acc\n  i \\<le> j\n  r i = (q, n)\n  r j = (q', n')\n  n \\<noteq> n'\n\ngoal (1 subgoal):\n 1. n < num_acc &&& n' < num_acc", "by (metis snd_conv)+"], ["proof (state)\nthis:\n  n < num_acc\n  n' < num_acc\n\ngoal (1 subgoal):\n 1. (\\<And>k qk.\n        \\<lbrakk>i \\<le> k; k < j; r k = (qk, n); n \\<in> acc qk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define k where \"k = (LEAST k. i<k \\<and> snd (r k) \\<noteq> n)\""], ["proof (state)\nthis:\n  k = (LEAST k. i < k \\<and> snd (r k) \\<noteq> n)\n\ngoal (1 subgoal):\n 1. (\\<And>k qk.\n        \\<lbrakk>i \\<le> k; k < j; r k = (qk, n); n \\<in> acc qk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"i<k\" \"snd (r k) \\<noteq> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < k &&& snd (r k) \\<noteq> n", "by (metis (lifting, mono_tags) LeastI_ex A k_def leD less_linear snd_conv)+"], ["proof (state)\nthis:\n  i < k\n  snd (r k) \\<noteq> n\n\ngoal (1 subgoal):\n 1. (\\<And>k qk.\n        \\<lbrakk>i \\<le> k; k < j; r k = (qk, n); n \\<in> acc qk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from Least_le[where P=\"\\<lambda>k. i<k \\<and> snd (r k) \\<noteq> n\", folded k_def]"], ["proof (chain)\npicking this:\n  i < ?k \\<and> snd (r ?k) \\<noteq> n \\<Longrightarrow> k \\<le> ?k", "have LEK_EQN: \"\\<forall>k'. i\\<le>k' \\<and> k'<k \\<longrightarrow> snd (r k') = n\""], ["proof (prove)\nusing this:\n  i < ?k \\<and> snd (r ?k) \\<noteq> n \\<Longrightarrow> k \\<le> ?k\n\ngoal (1 subgoal):\n 1. \\<forall>k'. i \\<le> k' \\<and> k' < k \\<longrightarrow> snd (r k') = n", "using \\<open>r i = (q,n)\\<close>"], ["proof (prove)\nusing this:\n  i < ?k \\<and> snd (r ?k) \\<noteq> n \\<Longrightarrow> k \\<le> ?k\n  r i = (q, n)\n\ngoal (1 subgoal):\n 1. \\<forall>k'. i \\<le> k' \\<and> k' < k \\<longrightarrow> snd (r k') = n", "by clarsimp (metis le_neq_implies_less not_le snd_conv)"], ["proof (state)\nthis:\n  \\<forall>k'. i \\<le> k' \\<and> k' < k \\<longrightarrow> snd (r k') = n\n\ngoal (1 subgoal):\n 1. (\\<And>k qk.\n        \\<lbrakk>i \\<le> k; k < j; r k = (qk, n); n \\<in> acc qk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence SND_RKMO: \"snd (r (k - 1)) = n\""], ["proof (prove)\nusing this:\n  \\<forall>k'. i \\<le> k' \\<and> k' < k \\<longrightarrow> snd (r k') = n\n\ngoal (1 subgoal):\n 1. snd (r (k - 1)) = n", "using \\<open>i<k\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>k'. i \\<le> k' \\<and> k' < k \\<longrightarrow> snd (r k') = n\n  i < k\n\ngoal (1 subgoal):\n 1. snd (r (k - 1)) = n", "by auto"], ["proof (state)\nthis:\n  snd (r (k - 1)) = n\n\ngoal (1 subgoal):\n 1. (\\<And>k qk.\n        \\<lbrakk>i \\<le> k; k < j; r k = (qk, n); n \\<in> acc qk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  snd (r (k - 1)) = n\n\ngoal (1 subgoal):\n 1. (\\<And>k qk.\n        \\<lbrakk>i \\<le> k; k < j; r k = (qk, n); n \\<in> acc qk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from R"], ["proof (chain)\npicking this:\n  graph_defs.is_run (degeneralize_ext m) r", "have \"(r (k - 1), r k) \\<in> degen.E T m\""], ["proof (prove)\nusing this:\n  graph_defs.is_run (degeneralize_ext m) r\n\ngoal (1 subgoal):\n 1. (r (k - 1), r k) \\<in> g_E (degeneralize_ext m)", "unfolding degen.is_run_def ipath_def"], ["proof (prove)\nusing this:\n  r 0 \\<in> g_V0 (degeneralize_ext m) \\<and>\n  (\\<forall>i. (r i, r (Suc i)) \\<in> g_E (degeneralize_ext m))\n\ngoal (1 subgoal):\n 1. (r (k - 1), r k) \\<in> g_E (degeneralize_ext m)", "using \\<open>i<k\\<close>"], ["proof (prove)\nusing this:\n  r 0 \\<in> g_V0 (degeneralize_ext m) \\<and>\n  (\\<forall>i. (r i, r (Suc i)) \\<in> g_E (degeneralize_ext m))\n  i < k\n\ngoal (1 subgoal):\n 1. (r (k - 1), r k) \\<in> g_E (degeneralize_ext m)", "by clarsimp (metis Suc_pred gr_implies_not0 neq0_conv)"], ["proof (state)\nthis:\n  (r (k - 1), r k) \\<in> g_E (degeneralize_ext m)\n\ngoal (1 subgoal):\n 1. (\\<And>k qk.\n        \\<lbrakk>i \\<le> k; k < j; r k = (qk, n); n \\<in> acc qk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  (r (k - 1), r k) \\<in> g_E (degeneralize_ext m)\n\ngoal (1 subgoal):\n 1. (\\<And>k qk.\n        \\<lbrakk>i \\<le> k; k < j; r k = (qk, n); n \\<in> acc qk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note \\<open>snd (r k) \\<noteq> n\\<close>"], ["proof (state)\nthis:\n  snd (r k) \\<noteq> n\n\ngoal (1 subgoal):\n 1. (\\<And>k qk.\n        \\<lbrakk>i \\<le> k; k < j; r k = (qk, n); n \\<in> acc qk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  snd (r (k - 1)) = n\n  (r (k - 1), r k) \\<in> g_E (degeneralize_ext m)\n  snd (r k) \\<noteq> n", "have \"n \\<in> acc (fst (r (k - 1)))\""], ["proof (prove)\nusing this:\n  snd (r (k - 1)) = n\n  (r (k - 1), r k) \\<in> g_E (degeneralize_ext m)\n  snd (r k) \\<noteq> n\n\ngoal (1 subgoal):\n 1. n \\<in> acc (fst (r (k - 1)))", "by (auto simp: degeneralize_ext_def split: if_split_asm)"], ["proof (state)\nthis:\n  n \\<in> acc (fst (r (k - 1)))\n\ngoal (1 subgoal):\n 1. (\\<And>k qk.\n        \\<lbrakk>i \\<le> k; k < j; r k = (qk, n); n \\<in> acc qk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  n \\<in> acc (fst (r (k - 1)))\n\ngoal (1 subgoal):\n 1. (\\<And>k qk.\n        \\<lbrakk>i \\<le> k; k < j; r k = (qk, n); n \\<in> acc qk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"k - 1 < j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k - 1 < j", "using A LEK_EQN"], ["proof (prove)\nusing this:\n  i \\<le> j\n  r i = (q, n)\n  r j = (q', n')\n  n \\<noteq> n'\n  \\<forall>k'. i \\<le> k' \\<and> k' < k \\<longrightarrow> snd (r k') = n\n\ngoal (1 subgoal):\n 1. k - 1 < j", "apply (rule_tac ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; r i = (q, n); r j = (q', n'); n \\<noteq> n';\n     \\<forall>k'. i \\<le> k' \\<and> k' < k \\<longrightarrow> snd (r k') = n;\n     \\<not> k - 1 < j\\<rbrakk>\n    \\<Longrightarrow> False", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j; r i = (q, n); r j = (q', n'); n \\<noteq> n';\n     \\<forall>k'. i \\<le> k' \\<and> k' < k \\<longrightarrow> snd (r k') = n;\n     \\<not> k - Suc 0 < j\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis One_nat_def \\<open>snd (r (k - 1)) = n\\<close> less_Suc_eq \n        less_imp_diff_less not_less_eq snd_conv)"], ["proof (state)\nthis:\n  k - 1 < j\n\ngoal (1 subgoal):\n 1. (\\<And>k qk.\n        \\<lbrakk>i \\<le> k; k < j; r k = (qk, n); n \\<in> acc qk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  n \\<in> acc (fst (r (k - 1)))\n  k - 1 < j", "show thesis"], ["proof (prove)\nusing this:\n  n \\<in> acc (fst (r (k - 1)))\n  k - 1 < j\n\ngoal (1 subgoal):\n 1. thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> acc (fst (r (k - 1))); k - 1 < j\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (rule that[of \"k - 1\" \"fst (r (k - 1))\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>n \\<in> acc (fst (r (k - 1))); k - 1 < j\\<rbrakk>\n    \\<Longrightarrow> i \\<le> k - 1\n 2. \\<lbrakk>n \\<in> acc (fst (r (k - 1))); k - 1 < j\\<rbrakk>\n    \\<Longrightarrow> k - 1 < j\n 3. \\<lbrakk>n \\<in> acc (fst (r (k - 1))); k - 1 < j\\<rbrakk>\n    \\<Longrightarrow> r (k - 1) = (fst (r (k - 1)), n)\n 4. \\<lbrakk>n \\<in> acc (fst (r (k - 1))); k - 1 < j\\<rbrakk>\n    \\<Longrightarrow> n \\<in> acc (fst (r (k - 1)))", "using \\<open>i<k\\<close> SND_RKMO"], ["proof (prove)\nusing this:\n  i < k\n  snd (r (k - 1)) = n\n\ngoal (4 subgoals):\n 1. \\<lbrakk>n \\<in> acc (fst (r (k - 1))); k - 1 < j\\<rbrakk>\n    \\<Longrightarrow> i \\<le> k - 1\n 2. \\<lbrakk>n \\<in> acc (fst (r (k - 1))); k - 1 < j\\<rbrakk>\n    \\<Longrightarrow> k - 1 < j\n 3. \\<lbrakk>n \\<in> acc (fst (r (k - 1))); k - 1 < j\\<rbrakk>\n    \\<Longrightarrow> r (k - 1) = (fst (r (k - 1)), n)\n 4. \\<lbrakk>n \\<in> acc (fst (r (k - 1))); k - 1 < j\\<rbrakk>\n    \\<Longrightarrow> n \\<in> acc (fst (r (k - 1)))", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degen_run_find_acc_aux:\n    assumes NN0[simp]: \"num_acc \\<noteq> 0\"\n    assumes AR: \"degen.is_acc_run T m r\"\n    assumes A: \"r i = (q,0)\" \"0 \\<in> acc q\" \"n<num_acc\"\n    shows \"\\<exists>j qj. i\\<le>j \\<and> r j = (qj,n) \\<and> n \\<in> acc qj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j qj. i \\<le> j \\<and> r j = (qj, n) \\<and> n \\<in> acc qj", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j qj. i \\<le> j \\<and> r j = (qj, n) \\<and> n \\<in> acc qj", "from AR"], ["proof (chain)\npicking this:\n  b_graph.is_acc_run (degeneralize_ext m) r", "have R: \"degen.is_run T m r\" \n      and ACC: \"\\<exists>\\<^sub>\\<infinity>i. r i \\<in> degen.F T m\""], ["proof (prove)\nusing this:\n  b_graph.is_acc_run (degeneralize_ext m) r\n\ngoal (1 subgoal):\n 1. graph_defs.is_run (degeneralize_ext m) r &&&\n    \\<exists>\\<^sub>\\<infinity>i. r i \\<in> bg_F (degeneralize_ext m)", "(*and ACC: \"limit r \\<inter> bg_F (degeneralize_ext ecnv) \\<noteq> {}\"*)"], ["proof (prove)\nusing this:\n  b_graph.is_acc_run (degeneralize_ext m) r\n\ngoal (1 subgoal):\n 1. graph_defs.is_run (degeneralize_ext m) r &&&\n    \\<exists>\\<^sub>\\<infinity>i. r i \\<in> bg_F (degeneralize_ext m)", "unfolding degen.is_acc_run_def degen.is_acc_def"], ["proof (prove)\nusing this:\n  graph_defs.is_run (degeneralize_ext m) r \\<and>\n  (\\<exists>\\<^sub>\\<infinity>i. r i \\<in> bg_F (degeneralize_ext m))\n\ngoal (1 subgoal):\n 1. graph_defs.is_run (degeneralize_ext m) r &&&\n    \\<exists>\\<^sub>\\<infinity>i. r i \\<in> bg_F (degeneralize_ext m)", "by auto"], ["proof (state)\nthis:\n  graph_defs.is_run (degeneralize_ext m) r\n  \\<exists>\\<^sub>\\<infinity>i. r i \\<in> bg_F (degeneralize_ext m)\n\ngoal (1 subgoal):\n 1. \\<exists>j qj. i \\<le> j \\<and> r j = (qj, n) \\<and> n \\<in> acc qj", "from ACC"], ["proof (chain)\npicking this:\n  \\<exists>\\<^sub>\\<infinity>i. r i \\<in> bg_F (degeneralize_ext m)", "have ACC': \"\\<forall>i. \\<exists>j>i. r j \\<in> degen.F T m\""], ["proof (prove)\nusing this:\n  \\<exists>\\<^sub>\\<infinity>i. r i \\<in> bg_F (degeneralize_ext m)\n\ngoal (1 subgoal):\n 1. \\<forall>i. \\<exists>j>i. r j \\<in> bg_F (degeneralize_ext m)", "by (auto simp: INFM_nat)"], ["proof (state)\nthis:\n  \\<forall>i. \\<exists>j>i. r j \\<in> bg_F (degeneralize_ext m)\n\ngoal (1 subgoal):\n 1. \\<exists>j qj. i \\<le> j \\<and> r j = (qj, n) \\<and> n \\<in> acc qj", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j qj. i \\<le> j \\<and> r j = (qj, n) \\<and> n \\<in> acc qj", "using \\<open>n<num_acc\\<close>"], ["proof (prove)\nusing this:\n  n < num_acc\n\ngoal (1 subgoal):\n 1. \\<exists>j qj. i \\<le> j \\<and> r j = (qj, n) \\<and> n \\<in> acc qj", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < num_acc \\<Longrightarrow>\n    \\<exists>j qj. i \\<le> j \\<and> r j = (qj, 0) \\<and> 0 \\<in> acc qj\n 2. \\<And>n.\n       \\<lbrakk>n < num_acc \\<Longrightarrow>\n                \\<exists>j qj.\n                   i \\<le> j \\<and> r j = (qj, n) \\<and> n \\<in> acc qj;\n        Suc n < num_acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j qj.\n                            i \\<le> j \\<and>\n                            r j = (qj, Suc n) \\<and> Suc n \\<in> acc qj", "case 0"], ["proof (state)\nthis:\n  0 < num_acc\n\ngoal (2 subgoals):\n 1. 0 < num_acc \\<Longrightarrow>\n    \\<exists>j qj. i \\<le> j \\<and> r j = (qj, 0) \\<and> 0 \\<in> acc qj\n 2. \\<And>n.\n       \\<lbrakk>n < num_acc \\<Longrightarrow>\n                \\<exists>j qj.\n                   i \\<le> j \\<and> r j = (qj, n) \\<and> n \\<in> acc qj;\n        Suc n < num_acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j qj.\n                            i \\<le> j \\<and>\n                            r j = (qj, Suc n) \\<and> Suc n \\<in> acc qj", "thus ?case"], ["proof (prove)\nusing this:\n  0 < num_acc\n\ngoal (1 subgoal):\n 1. \\<exists>j qj. i \\<le> j \\<and> r j = (qj, 0) \\<and> 0 \\<in> acc qj", "using A"], ["proof (prove)\nusing this:\n  0 < num_acc\n  r i = (q, 0)\n  0 \\<in> acc q\n  n < num_acc\n\ngoal (1 subgoal):\n 1. \\<exists>j qj. i \\<le> j \\<and> r j = (qj, 0) \\<and> 0 \\<in> acc qj", "by auto"], ["proof (state)\nthis:\n  \\<exists>j qj. i \\<le> j \\<and> r j = (qj, 0) \\<and> 0 \\<in> acc qj\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n < num_acc \\<Longrightarrow>\n                \\<exists>j qj.\n                   i \\<le> j \\<and> r j = (qj, n) \\<and> n \\<in> acc qj;\n        Suc n < num_acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j qj.\n                            i \\<le> j \\<and>\n                            r j = (qj, Suc n) \\<and> Suc n \\<in> acc qj", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n < num_acc \\<Longrightarrow>\n                \\<exists>j qj.\n                   i \\<le> j \\<and> r j = (qj, n) \\<and> n \\<in> acc qj;\n        Suc n < num_acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j qj.\n                            i \\<le> j \\<and>\n                            r j = (qj, Suc n) \\<and> Suc n \\<in> acc qj", "case (Suc n)"], ["proof (state)\nthis:\n  n < num_acc \\<Longrightarrow>\n  \\<exists>j qj. i \\<le> j \\<and> r j = (qj, n) \\<and> n \\<in> acc qj\n  Suc n < num_acc\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n < num_acc \\<Longrightarrow>\n                \\<exists>j qj.\n                   i \\<le> j \\<and> r j = (qj, n) \\<and> n \\<in> acc qj;\n        Suc n < num_acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j qj.\n                            i \\<le> j \\<and>\n                            r j = (qj, Suc n) \\<and> Suc n \\<in> acc qj", "then"], ["proof (chain)\npicking this:\n  n < num_acc \\<Longrightarrow>\n  \\<exists>j qj. i \\<le> j \\<and> r j = (qj, n) \\<and> n \\<in> acc qj\n  Suc n < num_acc", "obtain j qj where \"i\\<le>j\" \"r j = (qj,n)\" \"n\\<in>acc qj\""], ["proof (prove)\nusing this:\n  n < num_acc \\<Longrightarrow>\n  \\<exists>j qj. i \\<le> j \\<and> r j = (qj, n) \\<and> n \\<in> acc qj\n  Suc n < num_acc\n\ngoal (1 subgoal):\n 1. (\\<And>j qj.\n        \\<lbrakk>i \\<le> j; r j = (qj, n); n \\<in> acc qj\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i \\<le> j\n  r j = (qj, n)\n  n \\<in> acc qj\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n < num_acc \\<Longrightarrow>\n                \\<exists>j qj.\n                   i \\<le> j \\<and> r j = (qj, n) \\<and> n \\<in> acc qj;\n        Suc n < num_acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j qj.\n                            i \\<le> j \\<and>\n                            r j = (qj, Suc n) \\<and> Suc n \\<in> acc qj", "moreover"], ["proof (state)\nthis:\n  i \\<le> j\n  r j = (qj, n)\n  n \\<in> acc qj\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n < num_acc \\<Longrightarrow>\n                \\<exists>j qj.\n                   i \\<le> j \\<and> r j = (qj, n) \\<and> n \\<in> acc qj;\n        Suc n < num_acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j qj.\n                            i \\<le> j \\<and>\n                            r j = (qj, Suc n) \\<and> Suc n \\<in> acc qj", "from R"], ["proof (chain)\npicking this:\n  graph_defs.is_run (degeneralize_ext m) r", "have \"(r j, r (Suc j)) \\<in> degen.E T m\""], ["proof (prove)\nusing this:\n  graph_defs.is_run (degeneralize_ext m) r\n\ngoal (1 subgoal):\n 1. (r j, r (Suc j)) \\<in> g_E (degeneralize_ext m)", "unfolding degen.is_run_def ipath_def"], ["proof (prove)\nusing this:\n  r 0 \\<in> g_V0 (degeneralize_ext m) \\<and>\n  (\\<forall>i. (r i, r (Suc i)) \\<in> g_E (degeneralize_ext m))\n\ngoal (1 subgoal):\n 1. (r j, r (Suc j)) \\<in> g_E (degeneralize_ext m)", "by auto"], ["proof (state)\nthis:\n  (r j, r (Suc j)) \\<in> g_E (degeneralize_ext m)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n < num_acc \\<Longrightarrow>\n                \\<exists>j qj.\n                   i \\<le> j \\<and> r j = (qj, n) \\<and> n \\<in> acc qj;\n        Suc n < num_acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j qj.\n                            i \\<le> j \\<and>\n                            r j = (qj, Suc n) \\<and> Suc n \\<in> acc qj", "ultimately"], ["proof (chain)\npicking this:\n  i \\<le> j\n  r j = (qj, n)\n  n \\<in> acc qj\n  (r j, r (Suc j)) \\<in> g_E (degeneralize_ext m)", "obtain qsj where RSJ: \"r (Suc j) = (qsj,Suc n)\""], ["proof (prove)\nusing this:\n  i \\<le> j\n  r j = (qj, n)\n  n \\<in> acc qj\n  (r j, r (Suc j)) \\<in> g_E (degeneralize_ext m)\n\ngoal (1 subgoal):\n 1. (\\<And>qsj.\n        r (Suc j) = (qsj, Suc n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding degeneralize_ext_def"], ["proof (prove)\nusing this:\n  i \\<le> j\n  r j = (qj, n)\n  n \\<in> acc qj\n  (r j, r (Suc j))\n  \\<in> g_E (if num_acc = 0\n             then \\<lparr>g_V = V \\<times> {0},\n                     g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                     g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                     \\<dots> = m G\\<rparr>\n             else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                     g_E =\n                       {((q, i), q', i') |i i' q q'.\n                        i < num_acc \\<and>\n                        (q, q') \\<in> E \\<and>\n                        i' =\n                        (if i \\<in> acc q then (i + 1) mod num_acc else i)},\n                     g_V0 = V0 \\<times> {0},\n                     bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                     \\<dots> = m G\\<rparr>)\n\ngoal (1 subgoal):\n 1. (\\<And>qsj.\n        r (Suc j) = (qsj, Suc n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>Suc n<num_acc\\<close>"], ["proof (prove)\nusing this:\n  i \\<le> j\n  r j = (qj, n)\n  n \\<in> acc qj\n  (r j, r (Suc j))\n  \\<in> g_E (if num_acc = 0\n             then \\<lparr>g_V = V \\<times> {0},\n                     g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                     g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                     \\<dots> = m G\\<rparr>\n             else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                     g_E =\n                       {((q, i), q', i') |i i' q q'.\n                        i < num_acc \\<and>\n                        (q, q') \\<in> E \\<and>\n                        i' =\n                        (if i \\<in> acc q then (i + 1) mod num_acc else i)},\n                     g_V0 = V0 \\<times> {0},\n                     bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                     \\<dots> = m G\\<rparr>)\n  Suc n < num_acc\n\ngoal (1 subgoal):\n 1. (\\<And>qsj.\n        r (Suc j) = (qsj, Suc n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r (Suc j) = (qsj, Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n < num_acc \\<Longrightarrow>\n                \\<exists>j qj.\n                   i \\<le> j \\<and> r j = (qj, n) \\<and> n \\<in> acc qj;\n        Suc n < num_acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j qj.\n                            i \\<le> j \\<and>\n                            r j = (qj, Suc n) \\<and> Suc n \\<in> acc qj", "from ACC'"], ["proof (chain)\npicking this:\n  \\<forall>i. \\<exists>j>i. r j \\<in> bg_F (degeneralize_ext m)", "obtain k q0 where \"Suc j \\<le> k\" \"r k = (q0, 0)\""], ["proof (prove)\nusing this:\n  \\<forall>i. \\<exists>j>i. r j \\<in> bg_F (degeneralize_ext m)\n\ngoal (1 subgoal):\n 1. (\\<And>k q0.\n        \\<lbrakk>Suc j \\<le> k; r k = (q0, 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding degeneralize_ext_def"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     \\<exists>j>i.\n        r j\n        \\<in> bg_F\n               (if num_acc = 0\n                then \\<lparr>g_V = V \\<times> {0},\n                        g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                        g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                        \\<dots> = m G\\<rparr>\n                else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                        g_E =\n                          {((q, i), q', i') |i i' q q'.\n                           i < num_acc \\<and>\n                           (q, q') \\<in> E \\<and>\n                           i' =\n                           (if i \\<in> acc q then (i + 1) mod num_acc\n                            else i)},\n                        g_V0 = V0 \\<times> {0},\n                        bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                        \\<dots> = m G\\<rparr>)\n\ngoal (1 subgoal):\n 1. (\\<And>k q0.\n        \\<lbrakk>Suc j \\<le> k; r k = (q0, 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k q0.\n                \\<lbrakk>Suc j \\<le> k; r k = (q0, 0)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<forall>i.\n        \\<exists>j>i. \\<exists>q. r j = (q, 0) \\<and> 0 \\<in> acc q\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis less_imp_le_nat)"], ["proof (state)\nthis:\n  Suc j \\<le> k\n  r k = (q0, 0)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n < num_acc \\<Longrightarrow>\n                \\<exists>j qj.\n                   i \\<le> j \\<and> r j = (qj, n) \\<and> n \\<in> acc qj;\n        Suc n < num_acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j qj.\n                            i \\<le> j \\<and>\n                            r j = (qj, Suc n) \\<and> Suc n \\<in> acc qj", "from degen_run_find_change[OF NN0 R \\<open>Suc j \\<le> k\\<close> RSJ \\<open>r k = (q0, 0)\\<close>]"], ["proof (chain)\npicking this:\n  \\<lbrakk>Suc n \\<noteq> 0;\n   \\<And>ka qk.\n      \\<lbrakk>Suc j \\<le> ka; ka < k; r ka = (qk, Suc n);\n       Suc n \\<in> acc qk\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "obtain l ql where\n        \"Suc j \\<le> l\" \"l < k\" \"r l = (ql, Suc n)\" \"Suc n \\<in> acc ql\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Suc n \\<noteq> 0;\n   \\<And>ka qk.\n      \\<lbrakk>Suc j \\<le> ka; ka < k; r ka = (qk, Suc n);\n       Suc n \\<in> acc qk\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>l ql.\n        \\<lbrakk>Suc j \\<le> l; l < k; r l = (ql, Suc n);\n         Suc n \\<in> acc ql\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Suc j \\<le> l\n  l < k\n  r l = (ql, Suc n)\n  Suc n \\<in> acc ql\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n < num_acc \\<Longrightarrow>\n                \\<exists>j qj.\n                   i \\<le> j \\<and> r j = (qj, n) \\<and> n \\<in> acc qj;\n        Suc n < num_acc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j qj.\n                            i \\<le> j \\<and>\n                            r j = (qj, Suc n) \\<and> Suc n \\<in> acc qj", "thus ?case"], ["proof (prove)\nusing this:\n  Suc j \\<le> l\n  l < k\n  r l = (ql, Suc n)\n  Suc n \\<in> acc ql\n\ngoal (1 subgoal):\n 1. \\<exists>j qj.\n       i \\<le> j \\<and> r j = (qj, Suc n) \\<and> Suc n \\<in> acc qj", "using \\<open>i \\<le> j\\<close>"], ["proof (prove)\nusing this:\n  Suc j \\<le> l\n  l < k\n  r l = (ql, Suc n)\n  Suc n \\<in> acc ql\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. \\<exists>j qj.\n       i \\<le> j \\<and> r j = (qj, Suc n) \\<and> Suc n \\<in> acc qj", "by (intro exI[where x=l] exI[where x=ql]) auto"], ["proof (state)\nthis:\n  \\<exists>j qj.\n     i \\<le> j \\<and> r j = (qj, Suc n) \\<and> Suc n \\<in> acc qj\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j qj. i \\<le> j \\<and> r j = (qj, n) \\<and> n \\<in> acc qj\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degen_acc_run_sound:\n    assumes A: \"degen.is_acc_run T m r\"\n    shows \"is_acc_run (fst o r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_acc_run (fst \\<circ> r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_acc_run (fst \\<circ> r)", "from A"], ["proof (chain)\npicking this:\n  b_graph.is_acc_run (degeneralize_ext m) r", "have R: \"degen.is_run T m r\" \n      and ACC: \"\\<exists>\\<^sub>\\<infinity>i. r i \\<in> degen.F T m\""], ["proof (prove)\nusing this:\n  b_graph.is_acc_run (degeneralize_ext m) r\n\ngoal (1 subgoal):\n 1. graph_defs.is_run (degeneralize_ext m) r &&&\n    \\<exists>\\<^sub>\\<infinity>i. r i \\<in> bg_F (degeneralize_ext m)", "unfolding degen.is_acc_run_def degen.is_acc_def"], ["proof (prove)\nusing this:\n  graph_defs.is_run (degeneralize_ext m) r \\<and>\n  (\\<exists>\\<^sub>\\<infinity>i. r i \\<in> bg_F (degeneralize_ext m))\n\ngoal (1 subgoal):\n 1. graph_defs.is_run (degeneralize_ext m) r &&&\n    \\<exists>\\<^sub>\\<infinity>i. r i \\<in> bg_F (degeneralize_ext m)", "by auto"], ["proof (state)\nthis:\n  graph_defs.is_run (degeneralize_ext m) r\n  \\<exists>\\<^sub>\\<infinity>i. r i \\<in> bg_F (degeneralize_ext m)\n\ngoal (1 subgoal):\n 1. is_acc_run (fst \\<circ> r)", "from degen_is_run_sound[OF R]"], ["proof (chain)\npicking this:\n  is_run (fst \\<circ> r)", "have R': \"is_run (fst o r)\""], ["proof (prove)\nusing this:\n  is_run (fst \\<circ> r)\n\ngoal (1 subgoal):\n 1. is_run (fst \\<circ> r)", "."], ["proof (state)\nthis:\n  is_run (fst \\<circ> r)\n\ngoal (1 subgoal):\n 1. is_acc_run (fst \\<circ> r)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_acc_run (fst \\<circ> r)", "proof (cases \"num_acc = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. num_acc = 0 \\<Longrightarrow> is_acc_run (fst \\<circ> r)\n 2. num_acc \\<noteq> 0 \\<Longrightarrow> is_acc_run (fst \\<circ> r)", "case NN0[simp]: False"], ["proof (state)\nthis:\n  num_acc \\<noteq> 0\n\ngoal (2 subgoals):\n 1. num_acc = 0 \\<Longrightarrow> is_acc_run (fst \\<circ> r)\n 2. num_acc \\<noteq> 0 \\<Longrightarrow> is_acc_run (fst \\<circ> r)", "from ACC"], ["proof (chain)\npicking this:\n  \\<exists>\\<^sub>\\<infinity>i. r i \\<in> bg_F (degeneralize_ext m)", "have ACC': \"\\<forall>i. \\<exists>j>i. r j \\<in> degen.F T m\""], ["proof (prove)\nusing this:\n  \\<exists>\\<^sub>\\<infinity>i. r i \\<in> bg_F (degeneralize_ext m)\n\ngoal (1 subgoal):\n 1. \\<forall>i. \\<exists>j>i. r j \\<in> bg_F (degeneralize_ext m)", "by (auto simp: INFM_nat)"], ["proof (state)\nthis:\n  \\<forall>i. \\<exists>j>i. r j \\<in> bg_F (degeneralize_ext m)\n\ngoal (2 subgoals):\n 1. num_acc = 0 \\<Longrightarrow> is_acc_run (fst \\<circ> r)\n 2. num_acc \\<noteq> 0 \\<Longrightarrow> is_acc_run (fst \\<circ> r)", "have \"\\<forall>n<num_acc. \\<forall>i. \\<exists>j>i. n \\<in> acc (fst (r j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n<num_acc. \\<forall>i. \\<exists>j>i. n \\<in> acc (fst (r j))", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n i.\n       n < num_acc \\<Longrightarrow> \\<exists>j>i. n \\<in> acc (fst (r j))", "fix n i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n i.\n       n < num_acc \\<Longrightarrow> \\<exists>j>i. n \\<in> acc (fst (r j))", "obtain j qj where \"j>i\" and RJ: \"r j = (qj,0)\" and ACCJ: \"0 \\<in> acc (qj)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j qj.\n        \\<lbrakk>i < j; r j = (qj, 0); 0 \\<in> acc qj\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ACC'"], ["proof (prove)\nusing this:\n  \\<forall>i. \\<exists>j>i. r j \\<in> bg_F (degeneralize_ext m)\n\ngoal (1 subgoal):\n 1. (\\<And>j qj.\n        \\<lbrakk>i < j; r j = (qj, 0); 0 \\<in> acc qj\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding degeneralize_ext_def"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     \\<exists>j>i.\n        r j\n        \\<in> bg_F\n               (if num_acc = 0\n                then \\<lparr>g_V = V \\<times> {0},\n                        g_E = {((q, 0), q', 0) |q q'. (q, q') \\<in> E},\n                        g_V0 = V0 \\<times> {0}, bg_F = V \\<times> {0},\n                        \\<dots> = m G\\<rparr>\n                else \\<lparr>g_V = V \\<times> {0..<num_acc},\n                        g_E =\n                          {((q, i), q', i') |i i' q q'.\n                           i < num_acc \\<and>\n                           (q, q') \\<in> E \\<and>\n                           i' =\n                           (if i \\<in> acc q then (i + 1) mod num_acc\n                            else i)},\n                        g_V0 = V0 \\<times> {0},\n                        bg_F = {(q, 0) |q. 0 \\<in> acc q},\n                        \\<dots> = m G\\<rparr>)\n\ngoal (1 subgoal):\n 1. (\\<And>j qj.\n        \\<lbrakk>i < j; r j = (qj, 0); 0 \\<in> acc qj\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  i < j\n  r j = (qj, 0)\n  0 \\<in> acc qj\n\ngoal (1 subgoal):\n 1. \\<And>n i.\n       n < num_acc \\<Longrightarrow> \\<exists>j>i. n \\<in> acc (fst (r j))", "assume NLESS: \"n<num_acc\""], ["proof (state)\nthis:\n  n < num_acc\n\ngoal (1 subgoal):\n 1. \\<And>n i.\n       n < num_acc \\<Longrightarrow> \\<exists>j>i. n \\<in> acc (fst (r j))", "show \"\\<exists>j>i. n \\<in> acc (fst (r j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j>i. n \\<in> acc (fst (r j))", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> \\<exists>j>i. n \\<in> acc (fst (r j))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow> \\<exists>j>i. n \\<in> acc (fst (r j))", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> \\<exists>j>i. n \\<in> acc (fst (r j))\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow> \\<exists>j>i. n \\<in> acc (fst (r j))", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. \\<exists>j>i. n \\<in> acc (fst (r j))", "using \\<open>j>i\\<close> RJ ACCJ"], ["proof (prove)\nusing this:\n  n = 0\n  i < j\n  r j = (qj, 0)\n  0 \\<in> acc qj\n\ngoal (1 subgoal):\n 1. \\<exists>j>i. n \\<in> acc (fst (r j))", "by auto"], ["proof (state)\nthis:\n  \\<exists>j>i. n \\<in> acc (fst (r j))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow> \\<exists>j>i. n \\<in> acc (fst (r j))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow> \\<exists>j>i. n \\<in> acc (fst (r j))", "case [simp]: (Suc n')"], ["proof (state)\nthis:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow> \\<exists>j>i. n \\<in> acc (fst (r j))", "from degen_run_find_acc_aux[OF NN0 A RJ ACCJ NLESS]"], ["proof (chain)\npicking this:\n  \\<exists>ja qj. j \\<le> ja \\<and> r ja = (qj, n) \\<and> n \\<in> acc qj", "obtain k qk where\n            \"j\\<le>k\" \"r k = (qk,n)\" \"n \\<in> acc qk\""], ["proof (prove)\nusing this:\n  \\<exists>ja qj. j \\<le> ja \\<and> r ja = (qj, n) \\<and> n \\<in> acc qj\n\ngoal (1 subgoal):\n 1. (\\<And>k qk.\n        \\<lbrakk>j \\<le> k; r k = (qk, n); n \\<in> acc qk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j \\<le> k\n  r k = (qk, n)\n  n \\<in> acc qk\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow> \\<exists>j>i. n \\<in> acc (fst (r j))", "thus ?thesis"], ["proof (prove)\nusing this:\n  j \\<le> k\n  r k = (qk, n)\n  n \\<in> acc qk\n\ngoal (1 subgoal):\n 1. \\<exists>j>i. n \\<in> acc (fst (r j))", "by (metis \\<open>i < j\\<close> dual_order.strict_trans1 fst_conv)"], ["proof (state)\nthis:\n  \\<exists>j>i. n \\<in> acc (fst (r j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j>i. n \\<in> acc (fst (r j))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n<num_acc. \\<forall>i. \\<exists>j>i. n \\<in> acc (fst (r j))\n\ngoal (2 subgoals):\n 1. num_acc = 0 \\<Longrightarrow> is_acc_run (fst \\<circ> r)\n 2. num_acc \\<noteq> 0 \\<Longrightarrow> is_acc_run (fst \\<circ> r)", "hence \"\\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (fst (r i))\""], ["proof (prove)\nusing this:\n  \\<forall>n<num_acc. \\<forall>i. \\<exists>j>i. n \\<in> acc (fst (r j))\n\ngoal (1 subgoal):\n 1. \\<forall>n<num_acc.\n       \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (fst (r i))", "by (auto simp: INFM_nat)"], ["proof (state)\nthis:\n  \\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (fst (r i))\n\ngoal (2 subgoals):\n 1. num_acc = 0 \\<Longrightarrow> is_acc_run (fst \\<circ> r)\n 2. num_acc \\<noteq> 0 \\<Longrightarrow> is_acc_run (fst \\<circ> r)", "with R'"], ["proof (chain)\npicking this:\n  is_run (fst \\<circ> r)\n  \\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (fst (r i))", "show ?thesis"], ["proof (prove)\nusing this:\n  is_run (fst \\<circ> r)\n  \\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (fst (r i))\n\ngoal (1 subgoal):\n 1. is_acc_run (fst \\<circ> r)", "unfolding is_acc_run_def is_acc_def"], ["proof (prove)\nusing this:\n  is_run (fst \\<circ> r)\n  \\<forall>n<num_acc. \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc (fst (r i))\n\ngoal (1 subgoal):\n 1. is_run (fst \\<circ> r) \\<and>\n    (\\<forall>n<num_acc.\n        \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc ((fst \\<circ> r) i))", "by auto"], ["proof (state)\nthis:\n  is_acc_run (fst \\<circ> r)\n\ngoal (1 subgoal):\n 1. num_acc = 0 \\<Longrightarrow> is_acc_run (fst \\<circ> r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. num_acc = 0 \\<Longrightarrow> is_acc_run (fst \\<circ> r)", "case [simp]: True"], ["proof (state)\nthis:\n  num_acc = 0\n\ngoal (1 subgoal):\n 1. num_acc = 0 \\<Longrightarrow> is_acc_run (fst \\<circ> r)", "with R'"], ["proof (chain)\npicking this:\n  is_run (fst \\<circ> r)\n  num_acc = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  is_run (fst \\<circ> r)\n  num_acc = 0\n\ngoal (1 subgoal):\n 1. is_acc_run (fst \\<circ> r)", "unfolding is_acc_run_def is_acc_def"], ["proof (prove)\nusing this:\n  is_run (fst \\<circ> r)\n  num_acc = 0\n\ngoal (1 subgoal):\n 1. is_run (fst \\<circ> r) \\<and>\n    (\\<forall>n<num_acc.\n        \\<exists>\\<^sub>\\<infinity>i. n \\<in> acc ((fst \\<circ> r) i))", "by auto"], ["proof (state)\nthis:\n  is_acc_run (fst \\<circ> r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_acc_run (fst \\<circ> r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degen_acc_run_iff:\n    \"is_acc_run r \\<longleftrightarrow> (\\<exists>r'. fst o r' = r \\<and> degen.is_acc_run T m r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_acc_run r =\n    (\\<exists>r'.\n        fst \\<circ> r' = r \\<and>\n        b_graph.is_acc_run (degeneralize_ext m) r')", "using degen_acc_run_complete degen_acc_run_sound"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_acc_run ?r;\n   \\<And>r'.\n      \\<lbrakk>b_graph.is_acc_run (degeneralize_ext ?m) r';\n       ?r = fst \\<circ> r'\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  b_graph.is_acc_run (degeneralize_ext ?m) ?r \\<Longrightarrow>\n  is_acc_run (fst \\<circ> ?r)\n\ngoal (1 subgoal):\n 1. is_acc_run r =\n    (\\<exists>r'.\n        fst \\<circ> r' = r \\<and>\n        b_graph.is_acc_run (degeneralize_ext m) r')", "by blast"], ["", "end"], ["", "subsection \"System Automata\""], ["", "text \\<open>\n  System automata are (finite) rooted graphs with a labeling function. They are \n  used to describe the model (system) to be checked.\n\\<close>"], ["", "record ('Q,'L) sa_rec = \"'Q graph_rec\" +\n  sa_L :: \"'Q \\<Rightarrow> 'L\""], ["", "locale sa =\n  g?: graph G\n  for G :: \"('Q, 'L, 'more) sa_rec_scheme\"\nbegin"], ["", "abbreviation L where \"L \\<equiv> sa_L G\""], ["", "definition \"accept w \\<equiv> \\<exists>r. is_run r \\<and> w = L o r\""], ["", "lemma acceptI[intro?]: \"\\<lbrakk>is_run r; w = L o r\\<rbrakk> \\<Longrightarrow> accept w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_run r; w = L \\<circ> r\\<rbrakk> \\<Longrightarrow> accept w", "by (auto simp: accept_def)"], ["", "definition \"lang \\<equiv> Collect accept\""], ["", "lemma langI[intro?]: \"accept w \\<Longrightarrow> w\\<in>lang\""], ["proof (prove)\ngoal (1 subgoal):\n 1. accept w \\<Longrightarrow> w \\<in> lang", "by (auto simp: lang_def)"], ["", "end"], ["", "subsubsection \"Product Construction\""], ["", "text \\<open>\n  In this section we formalize the product construction between a GBA and a system\n  automaton. The result is a GBG and a projection function, such that projected \n  runs of the GBG correspond to words accepted by the GBA and the system.\n\\<close>"], ["", "locale igba_sys_prod_precond = igba: igba G + sa: sa S for\n  G :: \"('q,'l,'moreG) igba_rec_scheme\"\n  and S :: \"('s,'l,'moreS) sa_rec_scheme\"\nbegin"], ["", "definition \"prod \\<equiv> \\<lparr>\n    g_V = igba.V \\<times> sa.V,\n    g_E = { ((q,s),(q',s')). \n      igba.L q (sa.L s) \\<and> (q,q') \\<in> igba.E \\<and> (s,s') \\<in> sa.E },\n    g_V0 = igba.V0 \\<times> sa.V0,\n    igbg_num_acc = igba.num_acc,\n    igbg_acc = (\\<lambda>(q,s). if s\\<in>sa.V then igba.acc q else {} ) \\<rparr>\""], ["", "lemma prod_invar: \"igb_graph prod\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igb_graph prod", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. g_V0 prod \\<subseteq> g_V prod\n 2. g_E prod \\<subseteq> g_V prod \\<times> g_V prod\n 3. \\<Union> (range (igbg_acc prod)) \\<subseteq> {0..<igbg_num_acc prod}\n 4. \\<And>q. igbg_acc prod q \\<noteq> {} \\<Longrightarrow> q \\<in> g_V prod", "using igba.V0_ss sa.V0_ss"], ["proof (prove)\nusing this:\n  igba.V0 \\<subseteq> igba.V\n  sa.V0 \\<subseteq> sa.V\n\ngoal (4 subgoals):\n 1. g_V0 prod \\<subseteq> g_V prod\n 2. g_E prod \\<subseteq> g_V prod \\<times> g_V prod\n 3. \\<Union> (range (igbg_acc prod)) \\<subseteq> {0..<igbg_num_acc prod}\n 4. \\<And>q. igbg_acc prod q \\<noteq> {} \\<Longrightarrow> q \\<in> g_V prod", "apply (auto simp: prod_def) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. g_E prod \\<subseteq> g_V prod \\<times> g_V prod\n 2. \\<Union> (range (igbg_acc prod)) \\<subseteq> {0..<igbg_num_acc prod}\n 3. \\<And>q. igbg_acc prod q \\<noteq> {} \\<Longrightarrow> q \\<in> g_V prod", "using igba.E_ss sa.E_ss"], ["proof (prove)\nusing this:\n  igba.E \\<subseteq> igba.V \\<times> igba.V\n  sa.E \\<subseteq> sa.V \\<times> sa.V\n\ngoal (3 subgoals):\n 1. g_E prod \\<subseteq> g_V prod \\<times> g_V prod\n 2. \\<Union> (range (igbg_acc prod)) \\<subseteq> {0..<igbg_num_acc prod}\n 3. \\<And>q. igbg_acc prod q \\<noteq> {} \\<Longrightarrow> q \\<in> g_V prod", "apply (auto simp: prod_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Union> (range (igbg_acc prod)) \\<subseteq> {0..<igbg_num_acc prod}\n 2. \\<And>q. igbg_acc prod q \\<noteq> {} \\<Longrightarrow> q \\<in> g_V prod", "using igba.acc_bound"], ["proof (prove)\nusing this:\n  \\<Union> (range igba.acc) \\<subseteq> {0..<igba.num_acc}\n\ngoal (2 subgoals):\n 1. \\<Union> (range (igbg_acc prod)) \\<subseteq> {0..<igbg_num_acc prod}\n 2. \\<And>q. igbg_acc prod q \\<noteq> {} \\<Longrightarrow> q \\<in> g_V prod", "apply (auto simp: prod_def split: if_split_asm) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q. igbg_acc prod q \\<noteq> {} \\<Longrightarrow> q \\<in> g_V prod", "using igba.acc_ss"], ["proof (prove)\nusing this:\n  igba.acc ?q \\<noteq> {} \\<Longrightarrow> ?q \\<in> igba.V\n\ngoal (1 subgoal):\n 1. \\<And>q. igbg_acc prod q \\<noteq> {} \\<Longrightarrow> q \\<in> g_V prod", "apply (fastforce simp: prod_def split: if_split_asm) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sublocale prod: igb_graph prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. igb_graph prod", "using prod_invar"], ["proof (prove)\nusing this:\n  igb_graph prod\n\ngoal (1 subgoal):\n 1. igb_graph prod", "."], ["", "lemma prod_finite_reachable:\n    assumes \"finite (igba.E\\<^sup>* `` igba.V0)\" \"finite (sa.E\\<^sup>* `` sa.V0)\"\n    shows \"finite ((g_E prod)\\<^sup>* `` g_V0 prod)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite prod.reachable", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite prod.reachable", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. finite prod.reachable", "fix q s q' s'"], ["proof (state)\ngoal (1 subgoal):\n 1. finite prod.reachable", "assume \"((q,s),(q',s')) \\<in> (g_E prod)\\<^sup>*\""], ["proof (state)\nthis:\n  ((q, s), q', s') \\<in> prod.E\\<^sup>*\n\ngoal (1 subgoal):\n 1. finite prod.reachable", "hence \"(q,q') \\<in> (igba.E)\\<^sup>* \\<and> (s,s') \\<in> (sa.E)\\<^sup>*\""], ["proof (prove)\nusing this:\n  ((q, s), q', s') \\<in> prod.E\\<^sup>*\n\ngoal (1 subgoal):\n 1. (q, q') \\<in> igba.E\\<^sup>* \\<and> (s, s') \\<in> sa.E\\<^sup>*", "apply (induction rule: rtrancl_induct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (q, q) \\<in> igba.E\\<^sup>* \\<and> (s, s) \\<in> sa.E\\<^sup>*\n 2. \\<And>a b aa ba.\n       \\<lbrakk>((q, s), a, b) \\<in> prod.E\\<^sup>*;\n        ((a, b), aa, ba) \\<in> prod.E;\n        (q, a) \\<in> igba.E\\<^sup>* \\<and>\n        (s, b) \\<in> sa.E\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (q, aa) \\<in> igba.E\\<^sup>* \\<and>\n                         (s, ba) \\<in> sa.E\\<^sup>*", "apply (auto simp: prod_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (q, q') \\<in> igba.E\\<^sup>* \\<and> (s, s') \\<in> sa.E\\<^sup>*\n\ngoal (1 subgoal):\n 1. finite prod.reachable", "}"], ["proof (state)\nthis:\n  ((?q4, ?s4), ?q'4, ?s'4) \\<in> prod.E\\<^sup>* \\<Longrightarrow>\n  (?q4, ?q'4) \\<in> igba.E\\<^sup>* \\<and> (?s4, ?s'4) \\<in> sa.E\\<^sup>*\n\ngoal (1 subgoal):\n 1. finite prod.reachable", "note gsp_reach=this"], ["proof (state)\nthis:\n  ((?q4, ?s4), ?q'4, ?s'4) \\<in> prod.E\\<^sup>* \\<Longrightarrow>\n  (?q4, ?q'4) \\<in> igba.E\\<^sup>* \\<and> (?s4, ?s'4) \\<in> sa.E\\<^sup>*\n\ngoal (1 subgoal):\n 1. finite prod.reachable", "have [simp]: \"\\<And>q s. (q,s) \\<in> g_V0 prod \\<longleftrightarrow> q \\<in> igba.V0 \\<and> s \\<in> sa.V0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q s.\n       ((q, s) \\<in> prod.V0) = (q \\<in> igba.V0 \\<and> s \\<in> sa.V0)", "by (auto simp: prod_def)"], ["proof (state)\nthis:\n  ((?q2, ?s2) \\<in> prod.V0) = (?q2 \\<in> igba.V0 \\<and> ?s2 \\<in> sa.V0)\n\ngoal (1 subgoal):\n 1. finite prod.reachable", "have reachSS: \n      \"((g_E prod)\\<^sup>* `` g_V0 prod) \n      \\<subseteq> ((igba.E)\\<^sup>* `` igba.V0) \\<times> (sa.E\\<^sup>* `` sa.V0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod.reachable \\<subseteq> igba.reachable \\<times> sa.reachable", "by (auto dest: gsp_reach)"], ["proof (state)\nthis:\n  prod.reachable \\<subseteq> igba.reachable \\<times> sa.reachable\n\ngoal (1 subgoal):\n 1. finite prod.reachable", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite prod.reachable", "apply (rule finite_subset[OF reachSS])"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (igba.reachable \\<times> sa.reachable)", "using assms"], ["proof (prove)\nusing this:\n  finite igba.reachable\n  finite sa.reachable\n\ngoal (1 subgoal):\n 1. finite (igba.reachable \\<times> sa.reachable)", "by simp"], ["proof (state)\nthis:\n  finite prod.reachable\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prod_fields:\n    \"prod.V = igba.V \\<times> sa.V\"\n    \"prod.E = { ((q,s),(q',s')). \n      igba.L q (sa.L s) \\<and> (q,q') \\<in> igba.E \\<and> (s,s') \\<in> sa.E }\"\n    \"prod.V0 = igba.V0 \\<times> sa.V0\"\n    \"prod.num_acc = igba.num_acc\"\n    \"prod.acc = (\\<lambda>(q,s). if s\\<in>sa.V then igba.acc q else {} )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (prod.V = igba.V \\<times> sa.V &&&\n     prod.E =\n     {((q, s), q', s').\n      local.igba.L q (local.sa.L s) \\<and>\n      (q, q') \\<in> igba.E \\<and> (s, s') \\<in> sa.E}) &&&\n    prod.V0 = igba.V0 \\<times> sa.V0 &&&\n    prod.num_acc = igba.num_acc &&&\n    prod.acc = (\\<lambda>(q, s). if s \\<in> sa.V then igba.acc q else {})", "unfolding prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (g_V \\<lparr>g_V = igba.V \\<times> sa.V,\n            g_E =\n              {((q, s), q', s').\n               local.igba.L q (local.sa.L s) \\<and>\n               (q, q') \\<in> igba.E \\<and> (s, s') \\<in> sa.E},\n            g_V0 = igba.V0 \\<times> sa.V0, igbg_num_acc = igba.num_acc,\n            igbg_acc =\n              \\<lambda>(q, s).\n                 if s \\<in> sa.V then igba.acc q else {}\\<rparr> =\n     igba.V \\<times> sa.V &&&\n     g_E \\<lparr>g_V = igba.V \\<times> sa.V,\n            g_E =\n              {((q, s), q', s').\n               local.igba.L q (local.sa.L s) \\<and>\n               (q, q') \\<in> igba.E \\<and> (s, s') \\<in> sa.E},\n            g_V0 = igba.V0 \\<times> sa.V0, igbg_num_acc = igba.num_acc,\n            igbg_acc =\n              \\<lambda>(q, s).\n                 if s \\<in> sa.V then igba.acc q else {}\\<rparr> =\n     {((q, s), q', s').\n      local.igba.L q (local.sa.L s) \\<and>\n      (q, q') \\<in> igba.E \\<and> (s, s') \\<in> sa.E}) &&&\n    g_V0\n     \\<lparr>g_V = igba.V \\<times> sa.V,\n        g_E =\n          {((q, s), q', s').\n           local.igba.L q (local.sa.L s) \\<and>\n           (q, q') \\<in> igba.E \\<and> (s, s') \\<in> sa.E},\n        g_V0 = igba.V0 \\<times> sa.V0, igbg_num_acc = igba.num_acc,\n        igbg_acc =\n          \\<lambda>(q, s). if s \\<in> sa.V then igba.acc q else {}\\<rparr> =\n    igba.V0 \\<times> sa.V0 &&&\n    igbg_num_acc\n     \\<lparr>g_V = igba.V \\<times> sa.V,\n        g_E =\n          {((q, s), q', s').\n           local.igba.L q (local.sa.L s) \\<and>\n           (q, q') \\<in> igba.E \\<and> (s, s') \\<in> sa.E},\n        g_V0 = igba.V0 \\<times> sa.V0, igbg_num_acc = igba.num_acc,\n        igbg_acc =\n          \\<lambda>(q, s). if s \\<in> sa.V then igba.acc q else {}\\<rparr> =\n    igba.num_acc &&&\n    igbg_acc\n     \\<lparr>g_V = igba.V \\<times> sa.V,\n        g_E =\n          {((q, s), q', s').\n           local.igba.L q (local.sa.L s) \\<and>\n           (q, q') \\<in> igba.E \\<and> (s, s') \\<in> sa.E},\n        g_V0 = igba.V0 \\<times> sa.V0, igbg_num_acc = igba.num_acc,\n        igbg_acc =\n          \\<lambda>(q, s). if s \\<in> sa.V then igba.acc q else {}\\<rparr> =\n    (\\<lambda>(q, s). if s \\<in> sa.V then igba.acc q else {})", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma prod_run: \"prod.is_run r \\<longleftrightarrow> \n      igba.is_run (fst o r) \n    \\<and> sa.is_run (snd o r)\n    \\<and> (\\<forall>i. igba.L (fst (r i)) (sa.L (snd (r i))))\" (is \"?L=?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod.is_run r =\n    (igba.is_run (fst \\<circ> r) \\<and>\n     sa.is_run (snd \\<circ> r) \\<and>\n     (\\<forall>i. local.igba.L (fst (r i)) (local.sa.L (snd (r i)))))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. prod.is_run r \\<Longrightarrow>\n    igba.is_run (fst \\<circ> r) \\<and>\n    sa.is_run (snd \\<circ> r) \\<and>\n    (\\<forall>i. local.igba.L (fst (r i)) (local.sa.L (snd (r i))))\n 2. igba.is_run (fst \\<circ> r) \\<and>\n    sa.is_run (snd \\<circ> r) \\<and>\n    (\\<forall>i.\n        local.igba.L (fst (r i)) (local.sa.L (snd (r i)))) \\<Longrightarrow>\n    prod.is_run r", "unfolding igba.is_run_def sa.is_run_def prod.is_run_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. r 0 \\<in> prod.V0 \\<and> ipath prod.E r \\<Longrightarrow>\n    ((fst \\<circ> r) 0 \\<in> igba.V0 \\<and>\n     ipath igba.E (fst \\<circ> r)) \\<and>\n    ((snd \\<circ> r) 0 \\<in> sa.V0 \\<and> ipath sa.E (snd \\<circ> r)) \\<and>\n    (\\<forall>i. local.igba.L (fst (r i)) (local.sa.L (snd (r i))))\n 2. ((fst \\<circ> r) 0 \\<in> igba.V0 \\<and>\n     ipath igba.E (fst \\<circ> r)) \\<and>\n    ((snd \\<circ> r) 0 \\<in> sa.V0 \\<and> ipath sa.E (snd \\<circ> r)) \\<and>\n    (\\<forall>i.\n        local.igba.L (fst (r i)) (local.sa.L (snd (r i)))) \\<Longrightarrow>\n    r 0 \\<in> prod.V0 \\<and> ipath prod.E r", "unfolding prod_def ipath_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. r 0\n    \\<in> g_V0\n           \\<lparr>g_V = igba.V \\<times> sa.V,\n              g_E =\n                {((q, s), q', s').\n                 local.igba.L q (local.sa.L s) \\<and>\n                 (q, q') \\<in> igba.E \\<and> (s, s') \\<in> sa.E},\n              g_V0 = igba.V0 \\<times> sa.V0, igbg_num_acc = igba.num_acc,\n              igbg_acc =\n                \\<lambda>(q, s).\n                   if s \\<in> sa.V then igba.acc q else {}\\<rparr> \\<and>\n    (\\<forall>i.\n        (r i, r (Suc i))\n        \\<in> g_E \\<lparr>g_V = igba.V \\<times> sa.V,\n                     g_E =\n                       {((q, s), q', s').\n                        local.igba.L q (local.sa.L s) \\<and>\n                        (q, q') \\<in> igba.E \\<and> (s, s') \\<in> sa.E},\n                     g_V0 = igba.V0 \\<times> sa.V0,\n                     igbg_num_acc = igba.num_acc,\n                     igbg_acc =\n                       \\<lambda>(q, s).\n                          if s \\<in> sa.V then igba.acc q\n                          else {}\\<rparr>) \\<Longrightarrow>\n    ((fst \\<circ> r) 0 \\<in> igba.V0 \\<and>\n     (\\<forall>i.\n         ((fst \\<circ> r) i, (fst \\<circ> r) (Suc i)) \\<in> igba.E)) \\<and>\n    ((snd \\<circ> r) 0 \\<in> sa.V0 \\<and>\n     (\\<forall>i.\n         ((snd \\<circ> r) i, (snd \\<circ> r) (Suc i)) \\<in> sa.E)) \\<and>\n    (\\<forall>i. local.igba.L (fst (r i)) (local.sa.L (snd (r i))))\n 2. ((fst \\<circ> r) 0 \\<in> igba.V0 \\<and>\n     (\\<forall>i.\n         ((fst \\<circ> r) i, (fst \\<circ> r) (Suc i)) \\<in> igba.E)) \\<and>\n    ((snd \\<circ> r) 0 \\<in> sa.V0 \\<and>\n     (\\<forall>i.\n         ((snd \\<circ> r) i, (snd \\<circ> r) (Suc i)) \\<in> sa.E)) \\<and>\n    (\\<forall>i.\n        local.igba.L (fst (r i)) (local.sa.L (snd (r i)))) \\<Longrightarrow>\n    r 0\n    \\<in> g_V0\n           \\<lparr>g_V = igba.V \\<times> sa.V,\n              g_E =\n                {((q, s), q', s').\n                 local.igba.L q (local.sa.L s) \\<and>\n                 (q, q') \\<in> igba.E \\<and> (s, s') \\<in> sa.E},\n              g_V0 = igba.V0 \\<times> sa.V0, igbg_num_acc = igba.num_acc,\n              igbg_acc =\n                \\<lambda>(q, s).\n                   if s \\<in> sa.V then igba.acc q else {}\\<rparr> \\<and>\n    (\\<forall>i.\n        (r i, r (Suc i))\n        \\<in> g_E \\<lparr>g_V = igba.V \\<times> sa.V,\n                     g_E =\n                       {((q, s), q', s').\n                        local.igba.L q (local.sa.L s) \\<and>\n                        (q, q') \\<in> igba.E \\<and> (s, s') \\<in> sa.E},\n                     g_V0 = igba.V0 \\<times> sa.V0,\n                     igbg_num_acc = igba.num_acc,\n                     igbg_acc =\n                       \\<lambda>(q, s).\n                          if s \\<in> sa.V then igba.acc q else {}\\<rparr>)", "apply (auto split: prod.split_asm intro: in_prod_fst_sndI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y i.\n       \\<lbrakk>\\<forall>i x1 x2.\n                   r i = (x1, x2) \\<longrightarrow>\n                   (\\<forall>x1a x2a.\n                       r (Suc i) = (x1a, x2a) \\<longrightarrow>\n                       (x1, x1a) \\<in> igba.E \\<and>\n                       local.igba.L x1 (local.sa.L x2) \\<and>\n                       (x2, x2a) \\<in> sa.E);\n        x \\<in> igba.V0; y \\<in> sa.V0; r 0 = (x, y)\\<rbrakk>\n       \\<Longrightarrow> (fst (r i), fst (r (Suc i))) \\<in> igba.E\n 2. \\<And>x y i.\n       \\<lbrakk>\\<forall>i x1 x2.\n                   r i = (x1, x2) \\<longrightarrow>\n                   (\\<forall>x1a x2a.\n                       r (Suc i) = (x1a, x2a) \\<longrightarrow>\n                       (x1, x1a) \\<in> igba.E \\<and>\n                       local.igba.L x1 (local.sa.L x2) \\<and>\n                       (x2, x2a) \\<in> sa.E);\n        x \\<in> igba.V0; y \\<in> sa.V0; r 0 = (x, y)\\<rbrakk>\n       \\<Longrightarrow> (snd (r i), snd (r (Suc i))) \\<in> sa.E\n 3. \\<And>i q s.\n       \\<lbrakk>fst (r 0) \\<in> igba.V0;\n        \\<forall>i. (fst (r i), fst (r (Suc i))) \\<in> igba.E;\n        snd (r 0) \\<in> sa.V0;\n        \\<forall>i. (snd (r i), snd (r (Suc i))) \\<in> sa.E;\n        \\<forall>i. local.igba.L (fst (r i)) (local.sa.L (snd (r i)));\n        (q, s) = r i\\<rbrakk>\n       \\<Longrightarrow> local.igba.L q (local.sa.L s)\n 4. \\<And>i q s q' s'.\n       \\<lbrakk>fst (r 0) \\<in> igba.V0;\n        \\<forall>i. (fst (r i), fst (r (Suc i))) \\<in> igba.E;\n        snd (r 0) \\<in> sa.V0;\n        \\<forall>i. (snd (r i), snd (r (Suc i))) \\<in> sa.E;\n        \\<forall>i. local.igba.L (fst (r i)) (local.sa.L (snd (r i)));\n        (q, s) = r i; r (Suc i) = (q', s')\\<rbrakk>\n       \\<Longrightarrow> (q, q') \\<in> igba.E\n 5. \\<And>i q s q' s'.\n       \\<lbrakk>fst (r 0) \\<in> igba.V0;\n        \\<forall>i. (fst (r i), fst (r (Suc i))) \\<in> igba.E;\n        snd (r 0) \\<in> sa.V0;\n        \\<forall>i. (snd (r i), snd (r (Suc i))) \\<in> sa.E;\n        \\<forall>i. local.igba.L (fst (r i)) (local.sa.L (snd (r i)));\n        (q, s) = r i; r (Suc i) = (q', s')\\<rbrakk>\n       \\<Longrightarrow> (s, s') \\<in> sa.E", "apply (metis surjective_pairing)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y i.\n       \\<lbrakk>\\<forall>i x1 x2.\n                   r i = (x1, x2) \\<longrightarrow>\n                   (\\<forall>x1a x2a.\n                       r (Suc i) = (x1a, x2a) \\<longrightarrow>\n                       (x1, x1a) \\<in> igba.E \\<and>\n                       local.igba.L x1 (local.sa.L x2) \\<and>\n                       (x2, x2a) \\<in> sa.E);\n        x \\<in> igba.V0; y \\<in> sa.V0; r 0 = (x, y)\\<rbrakk>\n       \\<Longrightarrow> (snd (r i), snd (r (Suc i))) \\<in> sa.E\n 2. \\<And>i q s.\n       \\<lbrakk>fst (r 0) \\<in> igba.V0;\n        \\<forall>i. (fst (r i), fst (r (Suc i))) \\<in> igba.E;\n        snd (r 0) \\<in> sa.V0;\n        \\<forall>i. (snd (r i), snd (r (Suc i))) \\<in> sa.E;\n        \\<forall>i. local.igba.L (fst (r i)) (local.sa.L (snd (r i)));\n        (q, s) = r i\\<rbrakk>\n       \\<Longrightarrow> local.igba.L q (local.sa.L s)\n 3. \\<And>i q s q' s'.\n       \\<lbrakk>fst (r 0) \\<in> igba.V0;\n        \\<forall>i. (fst (r i), fst (r (Suc i))) \\<in> igba.E;\n        snd (r 0) \\<in> sa.V0;\n        \\<forall>i. (snd (r i), snd (r (Suc i))) \\<in> sa.E;\n        \\<forall>i. local.igba.L (fst (r i)) (local.sa.L (snd (r i)));\n        (q, s) = r i; r (Suc i) = (q', s')\\<rbrakk>\n       \\<Longrightarrow> (q, q') \\<in> igba.E\n 4. \\<And>i q s q' s'.\n       \\<lbrakk>fst (r 0) \\<in> igba.V0;\n        \\<forall>i. (fst (r i), fst (r (Suc i))) \\<in> igba.E;\n        snd (r 0) \\<in> sa.V0;\n        \\<forall>i. (snd (r i), snd (r (Suc i))) \\<in> sa.E;\n        \\<forall>i. local.igba.L (fst (r i)) (local.sa.L (snd (r i)));\n        (q, s) = r i; r (Suc i) = (q', s')\\<rbrakk>\n       \\<Longrightarrow> (s, s') \\<in> sa.E", "apply (metis surjective_pairing)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i q s.\n       \\<lbrakk>fst (r 0) \\<in> igba.V0;\n        \\<forall>i. (fst (r i), fst (r (Suc i))) \\<in> igba.E;\n        snd (r 0) \\<in> sa.V0;\n        \\<forall>i. (snd (r i), snd (r (Suc i))) \\<in> sa.E;\n        \\<forall>i. local.igba.L (fst (r i)) (local.sa.L (snd (r i)));\n        (q, s) = r i\\<rbrakk>\n       \\<Longrightarrow> local.igba.L q (local.sa.L s)\n 2. \\<And>i q s q' s'.\n       \\<lbrakk>fst (r 0) \\<in> igba.V0;\n        \\<forall>i. (fst (r i), fst (r (Suc i))) \\<in> igba.E;\n        snd (r 0) \\<in> sa.V0;\n        \\<forall>i. (snd (r i), snd (r (Suc i))) \\<in> sa.E;\n        \\<forall>i. local.igba.L (fst (r i)) (local.sa.L (snd (r i)));\n        (q, s) = r i; r (Suc i) = (q', s')\\<rbrakk>\n       \\<Longrightarrow> (q, q') \\<in> igba.E\n 3. \\<And>i q s q' s'.\n       \\<lbrakk>fst (r 0) \\<in> igba.V0;\n        \\<forall>i. (fst (r i), fst (r (Suc i))) \\<in> igba.E;\n        snd (r 0) \\<in> sa.V0;\n        \\<forall>i. (snd (r i), snd (r (Suc i))) \\<in> sa.E;\n        \\<forall>i. local.igba.L (fst (r i)) (local.sa.L (snd (r i)));\n        (q, s) = r i; r (Suc i) = (q', s')\\<rbrakk>\n       \\<Longrightarrow> (s, s') \\<in> sa.E", "apply (metis fst_conv snd_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i q s q' s'.\n       \\<lbrakk>fst (r 0) \\<in> igba.V0;\n        \\<forall>i. (fst (r i), fst (r (Suc i))) \\<in> igba.E;\n        snd (r 0) \\<in> sa.V0;\n        \\<forall>i. (snd (r i), snd (r (Suc i))) \\<in> sa.E;\n        \\<forall>i. local.igba.L (fst (r i)) (local.sa.L (snd (r i)));\n        (q, s) = r i; r (Suc i) = (q', s')\\<rbrakk>\n       \\<Longrightarrow> (q, q') \\<in> igba.E\n 2. \\<And>i q s q' s'.\n       \\<lbrakk>fst (r 0) \\<in> igba.V0;\n        \\<forall>i. (fst (r i), fst (r (Suc i))) \\<in> igba.E;\n        snd (r 0) \\<in> sa.V0;\n        \\<forall>i. (snd (r i), snd (r (Suc i))) \\<in> sa.E;\n        \\<forall>i. local.igba.L (fst (r i)) (local.sa.L (snd (r i)));\n        (q, s) = r i; r (Suc i) = (q', s')\\<rbrakk>\n       \\<Longrightarrow> (s, s') \\<in> sa.E", "apply (metis fst_conv snd_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i q s q' s'.\n       \\<lbrakk>fst (r 0) \\<in> igba.V0;\n        \\<forall>i. (fst (r i), fst (r (Suc i))) \\<in> igba.E;\n        snd (r 0) \\<in> sa.V0;\n        \\<forall>i. (snd (r i), snd (r (Suc i))) \\<in> sa.E;\n        \\<forall>i. local.igba.L (fst (r i)) (local.sa.L (snd (r i)));\n        (q, s) = r i; r (Suc i) = (q', s')\\<rbrakk>\n       \\<Longrightarrow> (s, s') \\<in> sa.E", "apply (metis fst_conv snd_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma prod_acc:\n    assumes A: \"range (snd o r) \\<subseteq> sa.V\"\n    shows \"prod.is_acc r \\<longleftrightarrow> igba.is_acc (fst o r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod.is_acc r = igba.is_acc (fst \\<circ> r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prod.is_acc r = igba.is_acc (fst \\<circ> r)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. prod.is_acc r = igba.is_acc (fst \\<circ> r)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. prod.is_acc r = igba.is_acc (fst \\<circ> r)", "from A"], ["proof (chain)\npicking this:\n  range (snd \\<circ> r) \\<subseteq> sa.V", "have \"prod.acc (r i) = igba.acc (fst (r i))\""], ["proof (prove)\nusing this:\n  range (snd \\<circ> r) \\<subseteq> sa.V\n\ngoal (1 subgoal):\n 1. prod.acc (r i) = igba.acc (fst (r i))", "unfolding prod_fields"], ["proof (prove)\nusing this:\n  range (snd \\<circ> r) \\<subseteq> sa.V\n\ngoal (1 subgoal):\n 1. (case r i of\n     (q, s) \\<Rightarrow> if s \\<in> sa.V then igba.acc q else {}) =\n    igba.acc (fst (r i))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa y.\n       \\<lbrakk>range (snd \\<circ> r) \\<subseteq> sa.V; r i = (xa, y);\n        x \\<in> (if y \\<in> sa.V then igba.acc xa else {})\\<rbrakk>\n       \\<Longrightarrow> x \\<in> igba.acc (fst (r i))\n 2. \\<And>x q s.\n       \\<lbrakk>range (snd \\<circ> r) \\<subseteq> sa.V;\n        x \\<in> igba.acc (fst (r i)); r i = (q, s)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (if s \\<in> sa.V then igba.acc q else {})", "apply (clarsimp_all split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x q s.\n       \\<lbrakk>range (\\<lambda>x. snd (r x)) \\<subseteq> sa.V;\n        x \\<in> igba.acc q; r i = (q, s)\\<rbrakk>\n       \\<Longrightarrow> s \\<in> sa.V", "by (metis UNIV_I comp_apply imageI snd_conv subsetD)"], ["proof (state)\nthis:\n  prod.acc (r i) = igba.acc (fst (r i))\n\ngoal (1 subgoal):\n 1. prod.is_acc r = igba.is_acc (fst \\<circ> r)", "}"], ["proof (state)\nthis:\n  prod.acc (r ?i4) = igba.acc (fst (r ?i4))\n\ngoal (1 subgoal):\n 1. prod.is_acc r = igba.is_acc (fst \\<circ> r)", "note [simp] = this"], ["proof (state)\nthis:\n  prod.acc (r ?i4) = igba.acc (fst (r ?i4))\n\ngoal (1 subgoal):\n 1. prod.is_acc r = igba.is_acc (fst \\<circ> r)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod.is_acc r = igba.is_acc (fst \\<circ> r)", "unfolding prod.is_acc_def igba.is_acc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>n<prod.num_acc.\n        \\<exists>\\<^sub>\\<infinity>i. n \\<in> prod.acc (r i)) =\n    (\\<forall>n<igba.num_acc.\n        \\<exists>\\<^sub>\\<infinity>i. n \\<in> igba.acc ((fst \\<circ> r) i))", "by (simp add: prod_fields(4))"], ["proof (state)\nthis:\n  prod.is_acc r = igba.is_acc (fst \\<circ> r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gsp_correct1: \n    assumes A: \"prod.is_acc_run r\"\n    shows \"sa.is_run (snd o r) \\<and> (sa.L o snd o r \\<in> igba.lang)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sa.is_run (snd \\<circ> r) \\<and>\n    local.sa.L \\<circ> snd \\<circ> r \\<in> local.igba.lang", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sa.is_run (snd \\<circ> r) \\<and>\n    local.sa.L \\<circ> snd \\<circ> r \\<in> local.igba.lang", "from A"], ["proof (chain)\npicking this:\n  prod.is_acc_run r", "have PR: \"prod.is_run r\" and PA: \"prod.is_acc r\""], ["proof (prove)\nusing this:\n  prod.is_acc_run r\n\ngoal (1 subgoal):\n 1. prod.is_run r &&& prod.is_acc r", "unfolding prod.is_acc_run_def"], ["proof (prove)\nusing this:\n  prod.is_run r \\<and> prod.is_acc r\n\ngoal (1 subgoal):\n 1. prod.is_run r &&& prod.is_acc r", "by auto"], ["proof (state)\nthis:\n  prod.is_run r\n  prod.is_acc r\n\ngoal (1 subgoal):\n 1. sa.is_run (snd \\<circ> r) \\<and>\n    local.sa.L \\<circ> snd \\<circ> r \\<in> local.igba.lang", "have PRR: \"range r \\<subseteq> prod.V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range r \\<subseteq> prod.V", "using prod.run_reachable prod.reachable_V PR"], ["proof (prove)\nusing this:\n  prod.is_run ?r \\<Longrightarrow> range ?r \\<subseteq> prod.reachable\n  prod.reachable \\<subseteq> prod.V\n  prod.is_run r\n\ngoal (1 subgoal):\n 1. range r \\<subseteq> prod.V", "by auto"], ["proof (state)\nthis:\n  range r \\<subseteq> prod.V\n\ngoal (1 subgoal):\n 1. sa.is_run (snd \\<circ> r) \\<and>\n    local.sa.L \\<circ> snd \\<circ> r \\<in> local.igba.lang", "have RSR: \"range (snd o r) \\<subseteq> sa.V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (snd \\<circ> r) \\<subseteq> sa.V", "using PRR"], ["proof (prove)\nusing this:\n  range r \\<subseteq> prod.V\n\ngoal (1 subgoal):\n 1. range (snd \\<circ> r) \\<subseteq> sa.V", "unfolding prod_fields"], ["proof (prove)\nusing this:\n  range r \\<subseteq> igba.V \\<times> sa.V\n\ngoal (1 subgoal):\n 1. range (snd \\<circ> r) \\<subseteq> sa.V", "by auto"], ["proof (state)\nthis:\n  range (snd \\<circ> r) \\<subseteq> sa.V\n\ngoal (1 subgoal):\n 1. sa.is_run (snd \\<circ> r) \\<and>\n    local.sa.L \\<circ> snd \\<circ> r \\<in> local.igba.lang", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sa.is_run (snd \\<circ> r) \\<and>\n    local.sa.L \\<circ> snd \\<circ> r \\<in> local.igba.lang", "using PR PA"], ["proof (prove)\nusing this:\n  prod.is_run r\n  prod.is_acc r\n\ngoal (1 subgoal):\n 1. sa.is_run (snd \\<circ> r) \\<and>\n    local.sa.L \\<circ> snd \\<circ> r \\<in> local.igba.lang", "unfolding igba.is_acc_run_def\n        igba.lang_def igba.accept_def[abs_def]"], ["proof (prove)\nusing this:\n  prod.is_run r\n  prod.is_acc r\n\ngoal (1 subgoal):\n 1. sa.is_run (snd \\<circ> r) \\<and>\n    local.sa.L \\<circ> snd \\<circ> r\n    \\<in> {w. \\<exists>r.\n                 (igba.is_run r \\<and> igba.is_acc r) \\<and>\n                 (\\<forall>i. local.igba.L (r i) (w i))}", "apply (auto simp: prod_run prod_acc[OF RSR])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sa.is_run (snd \\<circ> r) \\<and>\n  local.sa.L \\<circ> snd \\<circ> r \\<in> local.igba.lang\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gsp_correct2: \n    assumes A: \"sa.is_run r\" \"sa.L o r \\<in> igba.lang\"\n    shows \"\\<exists>r'. r = snd o r' \\<and> prod.is_acc_run r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r'. r = snd \\<circ> r' \\<and> prod.is_acc_run r'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r'. r = snd \\<circ> r' \\<and> prod.is_acc_run r'", "have [simp]: \"\\<And>r r'. fst o (\\<lambda>i. (r i, r' i)) = r\" \n      \"\\<And>r r'. snd o (\\<lambda>i. (r i, r' i)) = r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r r'. fst \\<circ> (\\<lambda>i. (r i, r' i)) = r) &&&\n    (\\<And>r r'. snd \\<circ> (\\<lambda>i. (r i, r' i)) = r')", "by auto"], ["proof (state)\nthis:\n  fst \\<circ> (\\<lambda>i. (?r2 i, ?r'2 i)) = ?r2\n  snd \\<circ> (\\<lambda>i. (?r2 i, ?r'2 i)) = ?r'2\n\ngoal (1 subgoal):\n 1. \\<exists>r'. r = snd \\<circ> r' \\<and> prod.is_acc_run r'", "from A"], ["proof (chain)\npicking this:\n  sa.is_run r\n  local.sa.L \\<circ> r \\<in> local.igba.lang", "show ?thesis"], ["proof (prove)\nusing this:\n  sa.is_run r\n  local.sa.L \\<circ> r \\<in> local.igba.lang\n\ngoal (1 subgoal):\n 1. \\<exists>r'. r = snd \\<circ> r' \\<and> prod.is_acc_run r'", "unfolding prod.is_acc_run_def \n        igba.lang_def igba.accept_def[abs_def] igba.is_acc_run_def"], ["proof (prove)\nusing this:\n  sa.is_run r\n  local.sa.L \\<circ> r\n  \\<in> {w. \\<exists>r.\n               (igba.is_run r \\<and> igba.is_acc r) \\<and>\n               (\\<forall>i. local.igba.L (r i) (w i))}\n\ngoal (1 subgoal):\n 1. \\<exists>r'.\n       r = snd \\<circ> r' \\<and> prod.is_run r' \\<and> prod.is_acc r'", "apply (clarsimp simp: prod_run)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ra.\n       \\<lbrakk>sa.is_run r; igba.is_run ra; igba.is_acc ra;\n        \\<forall>i. local.igba.L (ra i) (local.sa.L (r i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r'.\n                            r = snd \\<circ> r' \\<and>\n                            igba.is_run (fst \\<circ> r') \\<and>\n                            sa.is_run (snd \\<circ> r') \\<and>\n                            (\\<forall>i.\n                                local.igba.L (fst (r' i))\n                                 (local.sa.L (snd (r' i)))) \\<and>\n                            prod.is_acc r'", "apply (rename_tac ra)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ra.\n       \\<lbrakk>sa.is_run r; igba.is_run ra; igba.is_acc ra;\n        \\<forall>i. local.igba.L (ra i) (local.sa.L (r i))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r'.\n                            r = snd \\<circ> r' \\<and>\n                            igba.is_run (fst \\<circ> r') \\<and>\n                            sa.is_run (snd \\<circ> r') \\<and>\n                            (\\<forall>i.\n                                local.igba.L (fst (r' i))\n                                 (local.sa.L (snd (r' i)))) \\<and>\n                            prod.is_acc r'", "apply (rule_tac x=\"\\<lambda>i. (ra i, r i)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ra.\n       \\<lbrakk>sa.is_run r; igba.is_run ra; igba.is_acc ra;\n        \\<forall>i. local.igba.L (ra i) (local.sa.L (r i))\\<rbrakk>\n       \\<Longrightarrow> r = snd \\<circ> (\\<lambda>i. (ra i, r i)) \\<and>\n                         igba.is_run\n                          (fst \\<circ> (\\<lambda>i. (ra i, r i))) \\<and>\n                         sa.is_run\n                          (snd \\<circ> (\\<lambda>i. (ra i, r i))) \\<and>\n                         (\\<forall>i.\n                             local.igba.L (fst (ra i, r i))\n                              (local.sa.L (snd (ra i, r i)))) \\<and>\n                         prod.is_acc (\\<lambda>i. (ra i, r i))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ra.\n       \\<lbrakk>sa.is_run r; igba.is_run ra; igba.is_acc ra;\n        \\<forall>i. local.igba.L (ra i) (local.sa.L (r i))\\<rbrakk>\n       \\<Longrightarrow> prod.is_acc (\\<lambda>i. (ra i, r i))", "apply (subst prod_acc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ra.\n       \\<lbrakk>sa.is_run r; igba.is_run ra; igba.is_acc ra;\n        \\<forall>i. local.igba.L (ra i) (local.sa.L (r i))\\<rbrakk>\n       \\<Longrightarrow> range (snd \\<circ> (\\<lambda>i. (ra i, r i)))\n                         \\<subseteq> sa.V\n 2. \\<And>ra.\n       \\<lbrakk>sa.is_run r; igba.is_run ra; igba.is_acc ra;\n        \\<forall>i. local.igba.L (ra i) (local.sa.L (r i))\\<rbrakk>\n       \\<Longrightarrow> igba.is_acc (fst \\<circ> (\\<lambda>i. (ra i, r i)))", "using order_trans[OF sa.run_reachable sa.reachable_V]"], ["proof (prove)\nusing this:\n  sa.is_run ?r2 \\<Longrightarrow> range ?r2 \\<subseteq> sa.V\n\ngoal (2 subgoals):\n 1. \\<And>ra.\n       \\<lbrakk>sa.is_run r; igba.is_run ra; igba.is_acc ra;\n        \\<forall>i. local.igba.L (ra i) (local.sa.L (r i))\\<rbrakk>\n       \\<Longrightarrow> range (snd \\<circ> (\\<lambda>i. (ra i, r i)))\n                         \\<subseteq> sa.V\n 2. \\<And>ra.\n       \\<lbrakk>sa.is_run r; igba.is_run ra; igba.is_acc ra;\n        \\<forall>i. local.igba.L (ra i) (local.sa.L (r i))\\<rbrakk>\n       \\<Longrightarrow> igba.is_acc (fst \\<circ> (\\<lambda>i. (ra i, r i)))", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ra.\n       \\<lbrakk>sa.is_run r; igba.is_run ra; igba.is_acc ra;\n        \\<forall>i. local.igba.L (ra i) (local.sa.L (r i))\\<rbrakk>\n       \\<Longrightarrow> igba.is_acc (fst \\<circ> (\\<lambda>i. (ra i, r i)))", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>r'. r = snd \\<circ> r' \\<and> prod.is_acc_run r'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}