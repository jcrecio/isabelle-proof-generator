{"file_name": "/home/qj213/afp-2021-10-22/thys/RefinementReactive/Refinement.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/RefinementReactive", "problem_names": ["lemma demonic_demonic: \"[:r:] o [:r':] = [:r OO r':]\"", "lemma assert_demonic_comp: \"{.p.} o [:r:] o {.p'.} o [:r':] = \n      {.x . p x \\<and> (\\<forall> y . r x y \\<longrightarrow> p' y).} o [:r OO r':]\"", "lemma demonic_assert_comp: \"[:r:] o {.p.} = {.x.(\\<forall> y . r x y \\<longrightarrow> p y).} o [:r:]\"", "lemma assert_assert_comp: \"{.p::'a::lattice.} o {.p'.} = {.p \\<sqinter> p'.}\"", "lemma \"trs (\\<lambda> x y . x = y) q x = q x\"", "lemma assert_demonic_prop: \"{.p.} o [:r:] = {.p.} o [:(\\<lambda> x y . p x) \\<sqinter> r:]\"", "lemma relcompp_exists: \"relcompp r r' x y = (\\<exists> u . r x u \\<and> r' u y)\"", "lemma trs_trs: \"(trs r) o (trs r') = trs ((\\<lambda> s t. (\\<forall> s' . r s s' \\<longrightarrow> (inpt r' s'))) \\<sqinter> (r OO r'))\" (is \"?S = ?T\")", "lemma assert_demonic_refinement: \"({.p.} o [:r:] \\<le> {.p'.} o [:r':]) = (p \\<le> p' \\<and> (\\<forall> x . p x \\<longrightarrow> r' x \\<le> r x))\"", "lemma trs_refinement: \"(trs r \\<le> trs r') = ((\\<forall> x . inpt r x \\<longrightarrow> inpt r' x) \\<and> (\\<forall> x . inpt r x \\<longrightarrow> r' x \\<le> r x))\"", "lemma \"trs (\\<lambda> x y . x \\<ge> 0) \\<le> trs (\\<lambda> x y . x = y)\"", "lemma \"trs (\\<lambda> x y . x \\<ge> 0) q x = (if q = \\<top> then x \\<ge> 0 else False)\"", "lemma \"[:r:] \\<sqinter> [:r':] = [:r \\<squnion> r':]\"", "lemma spec_demonic_choice: \"({.p.} o [:r:]) \\<sqinter> ({.p'.} o [:r':]) = ({.p \\<sqinter> p'.} o [:r \\<squnion> r':])\"", "lemma trs_demonic_choice: \"trs r \\<sqinter> trs r' = trs ((\\<lambda> x y . inpt r x \\<and> inpt r' x) \\<sqinter> (r \\<squnion> r'))\"", "lemma \"p \\<sqinter> p' = \\<bottom> \\<Longrightarrow> ({.p.} o [:r:]) \\<squnion> ({.p'.} o [:r':]) = {.p \\<squnion> p'.} o [:(\\<lambda> x y . p x \\<longrightarrow> r x y) \\<sqinter> ((\\<lambda> x y . p' x \\<longrightarrow> r' x y)):]\"", "lemma [simp]: \"conjunctive S \\<Longrightarrow> sconjunctive S\"", "lemma [simp]: \"conjunctive \\<top>\"", "lemma conjuncive_demonic [simp]: \"conjunctive [:r:]\"", "lemma sconjunctive_assert [simp]: \"sconjunctive {.p.}\"", "lemma sconjunctive_simp: \"x \\<in> Q \\<Longrightarrow> sconjunctive S \\<Longrightarrow> S (Inf Q) = Inf (S ` Q)\"", "lemma sconjunctive_INF_simp: \"x \\<in> X \\<Longrightarrow> sconjunctive S \\<Longrightarrow> S (Inf (Q ` X)) = Inf (S ` (Q ` X))\"", "lemma demonic_comp [simp]: \"sconjunctive S \\<Longrightarrow> sconjunctive S' \\<Longrightarrow> sconjunctive (S o S')\"", "lemma [simp]:\"conjunctive S \\<Longrightarrow> S (Inf (Q ` X)) = (Inf ((S o Q) ` X))\"", "lemma conjunctive_simp: \"conjunctive S \\<Longrightarrow>  S (Inf Q) = Inf (S ` Q)\"", "lemma conjunctive_monotonic: \"sconjunctive S \\<Longrightarrow> mono S\"", "lemma \"grd [:r:] = inpt r\"", "lemma \"fail ({.p.} o [:r :: 'a \\<Rightarrow> 'b \\<Rightarrow> bool:]) = -p\"", "lemma \"mono (S::'a::boolean_algebra \\<Rightarrow> 'b::boolean_algebra) \\<Longrightarrow> (S = Fail) = (fail S = \\<top>)\"", "lemma [simp]: \"{.\\<top>::'a::bounded_lattice.} = Skip\"", "lemma [simp]:\"Skip o S = S\"", "lemma [simp]:\"S o Skip = S\"", "lemma [simp]: \"mono S \\<Longrightarrow> mono S' \\<Longrightarrow> mono (S o S')\"", "lemma [simp]: \"mono {.p::('a \\<Rightarrow> bool).}\"", "lemma [simp]: \"mono [:r::('a \\<Rightarrow> 'b \\<Rightarrow> bool):]\"", "lemma [simp]:\"{. \\<lambda> x . True .} = Skip\"", "lemma [simp]: \"\\<bottom> o S = \\<bottom>\"", "lemma [simp]: \"{.\\<bottom>::'a::boolean_algebra.}  = \\<bottom>\"", "lemma [simp]: \"\\<top> o S = \\<top>\"", "lemma left_comp: \"T o U = T' o U' \\<Longrightarrow> S o T o U = S o T' o U'\"", "lemma assert_demonic: \"{.p.} o [:r:] = {.p.} o [:\\<lambda> x y . p x \\<and> r x y:]\"", "lemma \"trs r \\<sqinter> trs r' = trs (\\<lambda> x y . inpt r x \\<and> inpt r' x \\<and> (r x y \\<or> r' x y))\"", "lemma fusion_spec: \"({.p.} \\<circ> [:r:]) \\<parallel> ({.p'.} \\<circ> [:r':]) = ({.p \\<sqinter> p'.} \\<circ> [:r \\<sqinter> r':])\"", "lemma fusion_assoc: \"S \\<parallel> (T \\<parallel> U) = (S \\<parallel> T) \\<parallel> U\"", "lemma \"P \\<le> Q \\<Longrightarrow> P' \\<le> Q' \\<Longrightarrow> P \\<parallel> P' \\<le> Q \\<parallel> Q'\"", "lemma \"conjunctive S \\<Longrightarrow> S \\<parallel> \\<top> = \\<top>\"", "lemma fusion_spec_local: \"a \\<in> init \\<Longrightarrow> ([:x \\<leadsto> u, y . u \\<in> init \\<and> x = y:] \\<circ> {.p.} \\<circ> [:r:]) \\<parallel> ({.p'.} \\<circ> [:r':]) \n      = [:x \\<leadsto> u, y . u \\<in> init \\<and> x = y:] \\<circ> {.u,x . p (u, x) \\<and> p' x.} \\<circ> [:u, x \\<leadsto> y . r (u, x) y \\<and> r' x y:]\" (is \"?p \\<Longrightarrow> ?S = ?T\")", "lemma fusion_spec_local_a: \"a \\<in> init \\<Longrightarrow> ([:x \\<leadsto> u, y . u \\<in> init \\<and> x = y:] \\<circ> {.p.} \\<circ> [:r:]) \\<parallel> [:r':] \n      = ([:x \\<leadsto> u, y . u \\<in> init \\<and> x = y:] \\<circ> {.p.} \\<circ> [:u, x \\<leadsto> y . r (u, x) y \\<and> r' x y:])\"", "lemma fusion_local_refinement:\n    \"a \\<in> init \\<Longrightarrow> (\\<And> x u y . u \\<in> init \\<Longrightarrow> p' x \\<Longrightarrow> r (u, x) y \\<Longrightarrow> r' x y) \\<Longrightarrow> \n      {.p'.} o (([:x \\<leadsto> u, y . u \\<in> init \\<and> x = y:] \\<circ> {.p.} \\<circ> [:r:]) \\<parallel> [:r':]) \\<le> [:x \\<leadsto> u, y . u \\<in> init \\<and> x = y:] \\<circ> {.p.} \\<circ> [:r:]\""], "translations": [["", "lemma demonic_demonic: \"[:r:] o [:r':] = [:r OO r':]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [: r :] \\<circ> [: r' :] = [: r OO r' :]", "by (simp add: fun_eq_iff le_fun_def demonic_def, auto)"], ["", "lemma assert_demonic_comp: \"{.p.} o [:r:] o {.p'.} o [:r':] = \n      {.x . p x \\<and> (\\<forall> y . r x y \\<longrightarrow> p' y).} o [:r OO r':]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {. p .} \\<circ> [: r :] \\<circ> {. p' .} \\<circ> [: r' :] =\n    {.x. p x \\<and> (\\<forall>y. r x y \\<longrightarrow> p' y).} \\<circ>\n    [: r OO r' :]", "by (auto simp add: fun_eq_iff le_fun_def assert_def demonic_def)"], ["", "lemma demonic_assert_comp: \"[:r:] o {.p.} = {.x.(\\<forall> y . r x y \\<longrightarrow> p y).} o [:r:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [: r :] \\<circ> {. p .} =\n    {.x. \\<forall>y. r x y \\<longrightarrow> p y.} \\<circ> [: r :]", "by (auto simp add: fun_eq_iff le_fun_def assert_def demonic_def)"], ["", "lemma assert_assert_comp: \"{.p::'a::lattice.} o {.p'.} = {.p \\<sqinter> p'.}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {. p .} \\<circ> {. p' .} = {. p \\<sqinter> p' .}", "by (simp add: fun_eq_iff le_fun_def assert_def demonic_def inf_assoc)"], ["", "definition \"inpt r x = (\\<exists> y . r x y)\""], ["", "definition \"trs r = {. inpt r.} o [:r:]\""], ["", "lemma \"trs (\\<lambda> x y . x = y) q x = q x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trs (=) q x = q x", "by (simp add: trs_def fun_eq_iff assert_def demonic_def inpt_def bot_fun_def le_fun_def)"], ["", "lemma assert_demonic_prop: \"{.p.} o [:r:] = {.p.} o [:(\\<lambda> x y . p x) \\<sqinter> r:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {. p .} \\<circ> [: r :] =\n    {. p .} \\<circ> [: (\\<lambda>x y. p x) \\<sqinter> r :]", "by (auto simp add: fun_eq_iff assert_def demonic_def)"], ["", "lemma relcompp_exists: \"relcompp r r' x y = (\\<exists> u . r x u \\<and> r' u y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r OO r') x y = (\\<exists>u. r x u \\<and> r' u y)", "by auto"], ["", "lemma trs_trs: \"(trs r) o (trs r') = trs ((\\<lambda> s t. (\\<forall> s' . r s s' \\<longrightarrow> (inpt r' s'))) \\<sqinter> (r OO r'))\" (is \"?S = ?T\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. trs r \\<circ> trs r' =\n    trs ((\\<lambda>s t.\n             \\<forall>s'. r s s' \\<longrightarrow> inpt r' s') \\<sqinter>\n         r OO r')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trs r \\<circ> trs r' =\n    trs ((\\<lambda>s t.\n             \\<forall>s'. r s s' \\<longrightarrow> inpt r' s') \\<sqinter>\n         r OO r')", "have [simp]: \"(\\<lambda>x. inpt r x \\<and> (\\<forall>y. r x y \\<longrightarrow> inpt r' y)) = inpt ((\\<lambda>s t. \\<forall>s'. r s s' \\<longrightarrow> inpt r' s') \\<sqinter> r OO r')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        inpt r x \\<and> (\\<forall>y. r x y \\<longrightarrow> inpt r' y)) =\n    inpt\n     ((\\<lambda>s t.\n          \\<forall>s'. r s s' \\<longrightarrow> inpt r' s') \\<sqinter>\n      r OO r')", "by (auto simp add: fun_eq_iff inpt_def relcompp_exists, blast)"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      inpt r x \\<and> (\\<forall>y. r x y \\<longrightarrow> inpt r' y)) =\n  inpt\n   ((\\<lambda>s t.\n        \\<forall>s'. r s s' \\<longrightarrow> inpt r' s') \\<sqinter>\n    r OO r')\n\ngoal (1 subgoal):\n 1. trs r \\<circ> trs r' =\n    trs ((\\<lambda>s t.\n             \\<forall>s'. r s s' \\<longrightarrow> inpt r' s') \\<sqinter>\n         r OO r')", "have [simp]: \"(\\<lambda>x y. inpt r x \\<and> (\\<forall>y. r x y \\<longrightarrow> inpt r' y)) \\<sqinter> r OO r' = (\\<lambda>s t. \\<forall>s'. r s s' \\<longrightarrow> inpt r' s') \\<sqinter> r OO r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x y.\n        inpt r x \\<and>\n        (\\<forall>y. r x y \\<longrightarrow> inpt r' y)) \\<sqinter>\n    r OO r' =\n    (\\<lambda>s t.\n        \\<forall>s'. r s s' \\<longrightarrow> inpt r' s') \\<sqinter>\n    r OO r'", "by (auto simp add: fun_eq_iff inpt_def)"], ["proof (state)\nthis:\n  (\\<lambda>x y.\n      inpt r x \\<and>\n      (\\<forall>y. r x y \\<longrightarrow> inpt r' y)) \\<sqinter>\n  r OO r' =\n  (\\<lambda>s t.\n      \\<forall>s'. r s s' \\<longrightarrow> inpt r' s') \\<sqinter>\n  r OO r'\n\ngoal (1 subgoal):\n 1. trs r \\<circ> trs r' =\n    trs ((\\<lambda>s t.\n             \\<forall>s'. r s s' \\<longrightarrow> inpt r' s') \\<sqinter>\n         r OO r')", "have \"?S = {. inpt r .} \\<circ> [: r :] \\<circ> {. inpt r' .} \\<circ> [: r' :]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trs r \\<circ> trs r' =\n    {. inpt r .} \\<circ> [: r :] \\<circ> {. inpt r' .} \\<circ> [: r' :]", "by (simp add: trs_def comp_assoc[symmetric])"], ["proof (state)\nthis:\n  trs r \\<circ> trs r' =\n  {. inpt r .} \\<circ> [: r :] \\<circ> {. inpt r' .} \\<circ> [: r' :]\n\ngoal (1 subgoal):\n 1. trs r \\<circ> trs r' =\n    trs ((\\<lambda>s t.\n             \\<forall>s'. r s s' \\<longrightarrow> inpt r' s') \\<sqinter>\n         r OO r')", "also"], ["proof (state)\nthis:\n  trs r \\<circ> trs r' =\n  {. inpt r .} \\<circ> [: r :] \\<circ> {. inpt r' .} \\<circ> [: r' :]\n\ngoal (1 subgoal):\n 1. trs r \\<circ> trs r' =\n    trs ((\\<lambda>s t.\n             \\<forall>s'. r s s' \\<longrightarrow> inpt r' s') \\<sqinter>\n         r OO r')", "have \"... = {. \\<lambda>x. inpt r x \\<and> (\\<forall>y. r x y \\<longrightarrow> inpt r' y) .} \\<circ> [: r OO r' :]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {. inpt r .} \\<circ> [: r :] \\<circ> {. inpt r' .} \\<circ> [: r' :] =\n    {. \\<lambda>x.\n          inpt r x \\<and>\n          (\\<forall>y. r x y \\<longrightarrow> inpt r' y) .} \\<circ>\n    [: r OO r' :]", "by (simp add: assert_demonic_comp)"], ["proof (state)\nthis:\n  {. inpt r .} \\<circ> [: r :] \\<circ> {. inpt r' .} \\<circ> [: r' :] =\n  {. \\<lambda>x.\n        inpt r x \\<and>\n        (\\<forall>y. r x y \\<longrightarrow> inpt r' y) .} \\<circ>\n  [: r OO r' :]\n\ngoal (1 subgoal):\n 1. trs r \\<circ> trs r' =\n    trs ((\\<lambda>s t.\n             \\<forall>s'. r s s' \\<longrightarrow> inpt r' s') \\<sqinter>\n         r OO r')", "also"], ["proof (state)\nthis:\n  {. inpt r .} \\<circ> [: r :] \\<circ> {. inpt r' .} \\<circ> [: r' :] =\n  {. \\<lambda>x.\n        inpt r x \\<and>\n        (\\<forall>y. r x y \\<longrightarrow> inpt r' y) .} \\<circ>\n  [: r OO r' :]\n\ngoal (1 subgoal):\n 1. trs r \\<circ> trs r' =\n    trs ((\\<lambda>s t.\n             \\<forall>s'. r s s' \\<longrightarrow> inpt r' s') \\<sqinter>\n         r OO r')", "have \"... =  {. \\<lambda>x. inpt r x \\<and> (\\<forall>y. r x y \\<longrightarrow> inpt r' y) .} o [:(\\<lambda> x y . inpt r x \\<and> (\\<forall>y. r x y \\<longrightarrow> inpt r' y))  \\<sqinter> (r OO r'):]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {. \\<lambda>x.\n          inpt r x \\<and>\n          (\\<forall>y. r x y \\<longrightarrow> inpt r' y) .} \\<circ>\n    [: r OO r' :] =\n    {. \\<lambda>x.\n          inpt r x \\<and>\n          (\\<forall>y. r x y \\<longrightarrow> inpt r' y) .} \\<circ>\n    [: (\\<lambda>x y.\n           inpt r x \\<and>\n           (\\<forall>y. r x y \\<longrightarrow> inpt r' y)) \\<sqinter>\n       r OO r' :]", "by (subst assert_demonic_prop, simp)"], ["proof (state)\nthis:\n  {. \\<lambda>x.\n        inpt r x \\<and>\n        (\\<forall>y. r x y \\<longrightarrow> inpt r' y) .} \\<circ>\n  [: r OO r' :] =\n  {. \\<lambda>x.\n        inpt r x \\<and>\n        (\\<forall>y. r x y \\<longrightarrow> inpt r' y) .} \\<circ>\n  [: (\\<lambda>x y.\n         inpt r x \\<and>\n         (\\<forall>y. r x y \\<longrightarrow> inpt r' y)) \\<sqinter>\n     r OO r' :]\n\ngoal (1 subgoal):\n 1. trs r \\<circ> trs r' =\n    trs ((\\<lambda>s t.\n             \\<forall>s'. r s s' \\<longrightarrow> inpt r' s') \\<sqinter>\n         r OO r')", "also"], ["proof (state)\nthis:\n  {. \\<lambda>x.\n        inpt r x \\<and>\n        (\\<forall>y. r x y \\<longrightarrow> inpt r' y) .} \\<circ>\n  [: r OO r' :] =\n  {. \\<lambda>x.\n        inpt r x \\<and>\n        (\\<forall>y. r x y \\<longrightarrow> inpt r' y) .} \\<circ>\n  [: (\\<lambda>x y.\n         inpt r x \\<and>\n         (\\<forall>y. r x y \\<longrightarrow> inpt r' y)) \\<sqinter>\n     r OO r' :]\n\ngoal (1 subgoal):\n 1. trs r \\<circ> trs r' =\n    trs ((\\<lambda>s t.\n             \\<forall>s'. r s s' \\<longrightarrow> inpt r' s') \\<sqinter>\n         r OO r')", "have \"... = ?T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {. \\<lambda>x.\n          inpt r x \\<and>\n          (\\<forall>y. r x y \\<longrightarrow> inpt r' y) .} \\<circ>\n    [: (\\<lambda>x y.\n           inpt r x \\<and>\n           (\\<forall>y. r x y \\<longrightarrow> inpt r' y)) \\<sqinter>\n       r OO r' :] =\n    trs ((\\<lambda>s t.\n             \\<forall>s'. r s s' \\<longrightarrow> inpt r' s') \\<sqinter>\n         r OO r')", "by (simp add: trs_def)"], ["proof (state)\nthis:\n  {. \\<lambda>x.\n        inpt r x \\<and>\n        (\\<forall>y. r x y \\<longrightarrow> inpt r' y) .} \\<circ>\n  [: (\\<lambda>x y.\n         inpt r x \\<and>\n         (\\<forall>y. r x y \\<longrightarrow> inpt r' y)) \\<sqinter>\n     r OO r' :] =\n  trs ((\\<lambda>s t.\n           \\<forall>s'. r s s' \\<longrightarrow> inpt r' s') \\<sqinter>\n       r OO r')\n\ngoal (1 subgoal):\n 1. trs r \\<circ> trs r' =\n    trs ((\\<lambda>s t.\n             \\<forall>s'. r s s' \\<longrightarrow> inpt r' s') \\<sqinter>\n         r OO r')", "finally"], ["proof (chain)\npicking this:\n  trs r \\<circ> trs r' =\n  trs ((\\<lambda>s t.\n           \\<forall>s'. r s s' \\<longrightarrow> inpt r' s') \\<sqinter>\n       r OO r')", "show ?thesis"], ["proof (prove)\nusing this:\n  trs r \\<circ> trs r' =\n  trs ((\\<lambda>s t.\n           \\<forall>s'. r s s' \\<longrightarrow> inpt r' s') \\<sqinter>\n       r OO r')\n\ngoal (1 subgoal):\n 1. trs r \\<circ> trs r' =\n    trs ((\\<lambda>s t.\n             \\<forall>s'. r s s' \\<longrightarrow> inpt r' s') \\<sqinter>\n         r OO r')", "by simp"], ["proof (state)\nthis:\n  trs r \\<circ> trs r' =\n  trs ((\\<lambda>s t.\n           \\<forall>s'. r s s' \\<longrightarrow> inpt r' s') \\<sqinter>\n       r OO r')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma assert_demonic_refinement: \"({.p.} o [:r:] \\<le> {.p'.} o [:r':]) = (p \\<le> p' \\<and> (\\<forall> x . p x \\<longrightarrow> r' x \\<le> r x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({. p .} \\<circ> [: r :] \\<le> {. p' .} \\<circ> [: r' :]) =\n    (p \\<le> p' \\<and> (\\<forall>x. p x \\<longrightarrow> r' x \\<le> r x))", "by  (auto simp add: le_fun_def assert_def demonic_def)"], ["", "lemma trs_refinement: \"(trs r \\<le> trs r') = ((\\<forall> x . inpt r x \\<longrightarrow> inpt r' x) \\<and> (\\<forall> x . inpt r x \\<longrightarrow> r' x \\<le> r x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (trs r \\<le> trs r') =\n    ((\\<forall>x. inpt r x \\<longrightarrow> inpt r' x) \\<and>\n     (\\<forall>x. inpt r x \\<longrightarrow> r' x \\<le> r x))", "by (simp add: trs_def assert_demonic_refinement, simp add: le_fun_def)"], ["", "lemma \"trs (\\<lambda> x y . x \\<ge> 0) \\<le> trs (\\<lambda> x y . x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trs (\\<lambda>x y. (0::'a) \\<le> x) \\<le> trs (=)", "by (simp add: trs_def le_fun_def assert_def demonic_def inpt_def)"], ["", "lemma \"trs (\\<lambda> x y . x \\<ge> 0) q x = (if q = \\<top> then x \\<ge> 0 else False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trs (\\<lambda>x y. (0::'a) \\<le> x) q x =\n    (if q = \\<top> then (0::'a) \\<le> x else False)", "by (auto simp add: trs_def fun_eq_iff assert_def demonic_def inpt_def bot_fun_def)"], ["", "lemma \"[:r:] \\<sqinter> [:r':] = [:r \\<squnion> r':]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [: r :] \\<sqinter> [: r' :] = [: r \\<squnion> r' :]", "by (simp add: fun_eq_iff demonic_def)"], ["", "lemma spec_demonic_choice: \"({.p.} o [:r:]) \\<sqinter> ({.p'.} o [:r':]) = ({.p \\<sqinter> p'.} o [:r \\<squnion> r':])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({. p .} \\<circ> [: r :]) \\<sqinter> ({. p' .} \\<circ> [: r' :]) =\n    {. p \\<sqinter> p' .} \\<circ> [: r \\<squnion> r' :]", "by (auto simp add: fun_eq_iff demonic_def assert_def)"], ["", "lemma trs_demonic_choice: \"trs r \\<sqinter> trs r' = trs ((\\<lambda> x y . inpt r x \\<and> inpt r' x) \\<sqinter> (r \\<squnion> r'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trs r \\<sqinter> trs r' =\n    trs ((\\<lambda>x y. inpt r x \\<and> inpt r' x) \\<sqinter>\n         (r \\<squnion> r'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trs r \\<sqinter> trs r' =\n    trs ((\\<lambda>x y. inpt r x \\<and> inpt r' x) \\<sqinter>\n         (r \\<squnion> r'))", "have [simp]: \"inpt ((\\<lambda>x y. inpt r x \\<and> inpt r' x) \\<sqinter> (r \\<squnion> r')) = inpt r \\<sqinter> inpt r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inpt\n     ((\\<lambda>x y. inpt r x \\<and> inpt r' x) \\<sqinter>\n      (r \\<squnion> r')) =\n    inpt r \\<sqinter> inpt r'", "by (auto simp add: fun_eq_iff inpt_def)"], ["proof (state)\nthis:\n  inpt\n   ((\\<lambda>x y. inpt r x \\<and> inpt r' x) \\<sqinter>\n    (r \\<squnion> r')) =\n  inpt r \\<sqinter> inpt r'\n\ngoal (1 subgoal):\n 1. trs r \\<sqinter> trs r' =\n    trs ((\\<lambda>x y. inpt r x \\<and> inpt r' x) \\<sqinter>\n         (r \\<squnion> r'))", "have \"trs r \\<sqinter> trs r' = {. inpt r \\<sqinter> inpt r' .} \\<circ> [: r \\<squnion> r' :]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trs r \\<sqinter> trs r' =\n    {. inpt r \\<sqinter> inpt r' .} \\<circ> [: r \\<squnion> r' :]", "by (simp add: trs_def spec_demonic_choice)"], ["proof (state)\nthis:\n  trs r \\<sqinter> trs r' =\n  {. inpt r \\<sqinter> inpt r' .} \\<circ> [: r \\<squnion> r' :]\n\ngoal (1 subgoal):\n 1. trs r \\<sqinter> trs r' =\n    trs ((\\<lambda>x y. inpt r x \\<and> inpt r' x) \\<sqinter>\n         (r \\<squnion> r'))", "also"], ["proof (state)\nthis:\n  trs r \\<sqinter> trs r' =\n  {. inpt r \\<sqinter> inpt r' .} \\<circ> [: r \\<squnion> r' :]\n\ngoal (1 subgoal):\n 1. trs r \\<sqinter> trs r' =\n    trs ((\\<lambda>x y. inpt r x \\<and> inpt r' x) \\<sqinter>\n         (r \\<squnion> r'))", "have \"... = {. inpt r \\<sqinter> inpt r' .} \\<circ> [: (\\<lambda> x y . inpt r x \\<and> inpt r' x) \\<sqinter> (r \\<squnion> r') :]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {. inpt r \\<sqinter> inpt r' .} \\<circ> [: r \\<squnion> r' :] =\n    {. inpt r \\<sqinter> inpt r' .} \\<circ>\n    [: (\\<lambda>x y. inpt r x \\<and> inpt r' x) \\<sqinter>\n       (r \\<squnion> r') :]", "by (subst assert_demonic_prop, simp)"], ["proof (state)\nthis:\n  {. inpt r \\<sqinter> inpt r' .} \\<circ> [: r \\<squnion> r' :] =\n  {. inpt r \\<sqinter> inpt r' .} \\<circ>\n  [: (\\<lambda>x y. inpt r x \\<and> inpt r' x) \\<sqinter>\n     (r \\<squnion> r') :]\n\ngoal (1 subgoal):\n 1. trs r \\<sqinter> trs r' =\n    trs ((\\<lambda>x y. inpt r x \\<and> inpt r' x) \\<sqinter>\n         (r \\<squnion> r'))", "also"], ["proof (state)\nthis:\n  {. inpt r \\<sqinter> inpt r' .} \\<circ> [: r \\<squnion> r' :] =\n  {. inpt r \\<sqinter> inpt r' .} \\<circ>\n  [: (\\<lambda>x y. inpt r x \\<and> inpt r' x) \\<sqinter>\n     (r \\<squnion> r') :]\n\ngoal (1 subgoal):\n 1. trs r \\<sqinter> trs r' =\n    trs ((\\<lambda>x y. inpt r x \\<and> inpt r' x) \\<sqinter>\n         (r \\<squnion> r'))", "have \"... = trs ((\\<lambda> x y . inpt r x \\<and> inpt r' x) \\<sqinter> (r \\<squnion> r'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {. inpt r \\<sqinter> inpt r' .} \\<circ>\n    [: (\\<lambda>x y. inpt r x \\<and> inpt r' x) \\<sqinter>\n       (r \\<squnion> r') :] =\n    trs ((\\<lambda>x y. inpt r x \\<and> inpt r' x) \\<sqinter>\n         (r \\<squnion> r'))", "by (simp add: trs_def)"], ["proof (state)\nthis:\n  {. inpt r \\<sqinter> inpt r' .} \\<circ>\n  [: (\\<lambda>x y. inpt r x \\<and> inpt r' x) \\<sqinter>\n     (r \\<squnion> r') :] =\n  trs ((\\<lambda>x y. inpt r x \\<and> inpt r' x) \\<sqinter>\n       (r \\<squnion> r'))\n\ngoal (1 subgoal):\n 1. trs r \\<sqinter> trs r' =\n    trs ((\\<lambda>x y. inpt r x \\<and> inpt r' x) \\<sqinter>\n         (r \\<squnion> r'))", "finally"], ["proof (chain)\npicking this:\n  trs r \\<sqinter> trs r' =\n  trs ((\\<lambda>x y. inpt r x \\<and> inpt r' x) \\<sqinter>\n       (r \\<squnion> r'))", "show ?thesis"], ["proof (prove)\nusing this:\n  trs r \\<sqinter> trs r' =\n  trs ((\\<lambda>x y. inpt r x \\<and> inpt r' x) \\<sqinter>\n       (r \\<squnion> r'))\n\ngoal (1 subgoal):\n 1. trs r \\<sqinter> trs r' =\n    trs ((\\<lambda>x y. inpt r x \\<and> inpt r' x) \\<sqinter>\n         (r \\<squnion> r'))", "by simp"], ["proof (state)\nthis:\n  trs r \\<sqinter> trs r' =\n  trs ((\\<lambda>x y. inpt r x \\<and> inpt r' x) \\<sqinter>\n       (r \\<squnion> r'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \"p \\<sqinter> p' = \\<bottom> \\<Longrightarrow> ({.p.} o [:r:]) \\<squnion> ({.p'.} o [:r':]) = {.p \\<squnion> p'.} o [:(\\<lambda> x y . p x \\<longrightarrow> r x y) \\<sqinter> ((\\<lambda> x y . p' x \\<longrightarrow> r' x y)):]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<sqinter> p' = \\<bottom> \\<Longrightarrow>\n    ({. p .} \\<circ> [: r :]) \\<squnion> ({. p' .} \\<circ> [: r' :]) =\n    {. p \\<squnion> p' .} \\<circ>\n    [: (\\<lambda>x y. p x \\<longrightarrow> r x y) \\<sqinter>\n       (\\<lambda>x y. p' x \\<longrightarrow> r' x y) :]", "by (simp add: fun_eq_iff assert_def demonic_def, auto)"], ["", "subsection\\<open>Conjunctive predicate transformers\\<close>"], ["", "definition \"conjunctive (S::'a::complete_lattice \\<Rightarrow> 'b::complete_lattice) = (\\<forall> Q . S (Inf Q) = Inf (S ` Q))\""], ["", "definition \"sconjunctive (S::'a::complete_lattice \\<Rightarrow> 'b::complete_lattice) = (\\<forall> Q . (\\<exists> x . x \\<in> Q) \\<longrightarrow> S (Inf Q) = Inf (S ` Q))\""], ["", "lemma [simp]: \"conjunctive S \\<Longrightarrow> sconjunctive S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjunctive S \\<Longrightarrow> sconjunctive S", "by (simp add: conjunctive_def sconjunctive_def)"], ["", "lemma [simp]: \"conjunctive \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjunctive \\<top>", "by (simp add: conjunctive_def)"], ["", "lemma conjuncive_demonic [simp]: \"conjunctive [:r:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjunctive [: r :]", "proof (auto simp add: conjunctive_def fun_eq_iff demonic_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q x xa.\n       \\<lbrakk>r x \\<le> Inf Q; xa \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> r x \\<le> xa\n 2. \\<And>Q x.\n       \\<forall>xa\\<in>Q. r x \\<le> xa \\<Longrightarrow> r x \\<le> Inf Q", "fix Q:: \"'a set\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q x xa.\n       \\<lbrakk>r x \\<le> Inf Q; xa \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> r x \\<le> xa\n 2. \\<And>Q x.\n       \\<forall>xa\\<in>Q. r x \\<le> xa \\<Longrightarrow> r x \\<le> Inf Q", "fix y::'a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q x xa.\n       \\<lbrakk>r x \\<le> Inf Q; xa \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> r x \\<le> xa\n 2. \\<And>Q x.\n       \\<forall>xa\\<in>Q. r x \\<le> xa \\<Longrightarrow> r x \\<le> Inf Q", "fix x :: 'b"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q x xa.\n       \\<lbrakk>r x \\<le> Inf Q; xa \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> r x \\<le> xa\n 2. \\<And>Q x.\n       \\<forall>xa\\<in>Q. r x \\<le> xa \\<Longrightarrow> r x \\<le> Inf Q", "assume A: \"y \\<in> Q\""], ["proof (state)\nthis:\n  y \\<in> Q\n\ngoal (2 subgoals):\n 1. \\<And>Q x xa.\n       \\<lbrakk>r x \\<le> Inf Q; xa \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> r x \\<le> xa\n 2. \\<And>Q x.\n       \\<forall>xa\\<in>Q. r x \\<le> xa \\<Longrightarrow> r x \\<le> Inf Q", "assume \"r x \\<le> Inf Q\""], ["proof (state)\nthis:\n  r x \\<le> Inf Q\n\ngoal (2 subgoals):\n 1. \\<And>Q x xa.\n       \\<lbrakk>r x \\<le> Inf Q; xa \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> r x \\<le> xa\n 2. \\<And>Q x.\n       \\<forall>xa\\<in>Q. r x \\<le> xa \\<Longrightarrow> r x \\<le> Inf Q", "also"], ["proof (state)\nthis:\n  r x \\<le> Inf Q\n\ngoal (2 subgoals):\n 1. \\<And>Q x xa.\n       \\<lbrakk>r x \\<le> Inf Q; xa \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> r x \\<le> xa\n 2. \\<And>Q x.\n       \\<forall>xa\\<in>Q. r x \\<le> xa \\<Longrightarrow> r x \\<le> Inf Q", "from A"], ["proof (chain)\npicking this:\n  y \\<in> Q", "have \"Inf Q \\<le> y\""], ["proof (prove)\nusing this:\n  y \\<in> Q\n\ngoal (1 subgoal):\n 1. Inf Q \\<le> y", "by (rule Inf_lower)"], ["proof (state)\nthis:\n  Inf Q \\<le> y\n\ngoal (2 subgoals):\n 1. \\<And>Q x xa.\n       \\<lbrakk>r x \\<le> Inf Q; xa \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> r x \\<le> xa\n 2. \\<And>Q x.\n       \\<forall>xa\\<in>Q. r x \\<le> xa \\<Longrightarrow> r x \\<le> Inf Q", "finally"], ["proof (chain)\npicking this:\n  r x \\<le> y", "show \"r x \\<le> y\""], ["proof (prove)\nusing this:\n  r x \\<le> y\n\ngoal (1 subgoal):\n 1. r x \\<le> y", "by simp"], ["proof (state)\nthis:\n  r x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       \\<forall>xa\\<in>Q. r x \\<le> xa \\<Longrightarrow> r x \\<le> Inf Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       \\<forall>xa\\<in>Q. r x \\<le> xa \\<Longrightarrow> r x \\<le> Inf Q", "fix Q:: \"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       \\<forall>xa\\<in>Q. r x \\<le> xa \\<Longrightarrow> r x \\<le> Inf Q", "fix x :: 'b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       \\<forall>xa\\<in>Q. r x \\<le> xa \\<Longrightarrow> r x \\<le> Inf Q", "assume A : \"\\<forall>y\\<in>Q. r x \\<le> y\""], ["proof (state)\nthis:\n  \\<forall>y\\<in>Q. r x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       \\<forall>xa\\<in>Q. r x \\<le> xa \\<Longrightarrow> r x \\<le> Inf Q", "show \"r x \\<le> Inf Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r x \\<le> Inf Q", "by (rule Inf_greatest, simp add: A)"], ["proof (state)\nthis:\n  r x \\<le> Inf Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sconjunctive_assert [simp]: \"sconjunctive {.p.}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sconjunctive {. p .}", "proof (auto simp add: sconjunctive_def assert_def image_def cong: INF_cong_simp, rule antisym, auto)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow>\n       p \\<sqinter> Inf Q \\<le> Inf ((\\<sqinter>) p ` Q)\n 2. \\<And>Q x. x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> p\n 3. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> Inf Q", "fix Q :: \"'a set\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow>\n       p \\<sqinter> Inf Q \\<le> Inf ((\\<sqinter>) p ` Q)\n 2. \\<And>Q x. x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> p\n 3. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> Inf Q", "have [simp]: \"\\<And> x . x \\<in> Q \\<Longrightarrow> Inf Q \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Q \\<Longrightarrow> Inf Q \\<le> x", "by (rule Inf_lower, simp)"], ["proof (state)\nthis:\n  ?x \\<in> Q \\<Longrightarrow> Inf Q \\<le> ?x\n\ngoal (3 subgoals):\n 1. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow>\n       p \\<sqinter> Inf Q \\<le> Inf ((\\<sqinter>) p ` Q)\n 2. \\<And>Q x. x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> p\n 3. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> Inf Q", "have A: \"\\<And> x . x \\<in> Q \\<Longrightarrow> p \\<sqinter> Inf Q \\<le> p \\<sqinter> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Q \\<Longrightarrow> p \\<sqinter> Inf Q \\<le> p \\<sqinter> x", "by (simp, rule_tac y = \"Inf Q\" in order_trans, simp_all)"], ["proof (state)\nthis:\n  ?x \\<in> Q \\<Longrightarrow> p \\<sqinter> Inf Q \\<le> p \\<sqinter> ?x\n\ngoal (3 subgoals):\n 1. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow>\n       p \\<sqinter> Inf Q \\<le> Inf ((\\<sqinter>) p ` Q)\n 2. \\<And>Q x. x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> p\n 3. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> Inf Q", "show \"p \\<sqinter> Inf Q \\<le> (INF x\\<in>Q. p \\<sqinter> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<sqinter> Inf Q \\<le> Inf ((\\<sqinter>) p ` Q)", "by (rule Inf_greatest, safe, rule A, simp)"], ["proof (state)\nthis:\n  p \\<sqinter> Inf Q \\<le> Inf ((\\<sqinter>) p ` Q)\n\ngoal (2 subgoals):\n 1. \\<And>Q x. x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> p\n 2. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> Inf Q", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q x. x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> p\n 2. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> Inf Q", "fix Q :: \"'a set\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q x. x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> p\n 2. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> Inf Q", "fix x :: 'a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q x. x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> p\n 2. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> Inf Q", "assume A: \"x \\<in> Q\""], ["proof (state)\nthis:\n  x \\<in> Q\n\ngoal (2 subgoals):\n 1. \\<And>Q x. x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> p\n 2. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> Inf Q", "have \"Inf {y. \\<exists>x\\<in>Q. y = p \\<sqinter> x} \\<le> p \\<sqinter> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {y. \\<exists>x\\<in>Q. y = p \\<sqinter> x} \\<le> p \\<sqinter> x", "by (rule Inf_lower, cut_tac A, auto)"], ["proof (state)\nthis:\n  Inf {y. \\<exists>x\\<in>Q. y = p \\<sqinter> x} \\<le> p \\<sqinter> x\n\ngoal (2 subgoals):\n 1. \\<And>Q x. x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> p\n 2. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> Inf Q", "also"], ["proof (state)\nthis:\n  Inf {y. \\<exists>x\\<in>Q. y = p \\<sqinter> x} \\<le> p \\<sqinter> x\n\ngoal (2 subgoals):\n 1. \\<And>Q x. x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> p\n 2. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> Inf Q", "have \"... \\<le> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<sqinter> x \\<le> p", "by simp"], ["proof (state)\nthis:\n  p \\<sqinter> x \\<le> p\n\ngoal (2 subgoals):\n 1. \\<And>Q x. x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> p\n 2. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> Inf Q", "finally"], ["proof (chain)\npicking this:\n  Inf {y. \\<exists>x\\<in>Q. y = p \\<sqinter> x} \\<le> p", "show \"(INF x\\<in>Q. p \\<sqinter> x) \\<le> p\""], ["proof (prove)\nusing this:\n  Inf {y. \\<exists>x\\<in>Q. y = p \\<sqinter> x} \\<le> p\n\ngoal (1 subgoal):\n 1. Inf ((\\<sqinter>) p ` Q) \\<le> p", "by (simp only: image_def)"], ["proof (state)\nthis:\n  Inf ((\\<sqinter>) p ` Q) \\<le> p\n\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> Inf Q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> Inf Q", "fix Q :: \"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> Inf Q", "show \"(INF x\\<in>Q. p \\<sqinter> x) \\<le> Inf Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf ((\\<sqinter>) p ` Q) \\<le> Inf Q", "proof (rule Inf_greatest)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> x", "fix x::'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> x", "assume A: \"x \\<in> Q\""], ["proof (state)\nthis:\n  x \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> x", "have \"Inf {y. \\<exists>x\\<in>Q. y = p \\<sqinter> x} \\<le> p \\<sqinter> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {y. \\<exists>x\\<in>Q. y = p \\<sqinter> x} \\<le> p \\<sqinter> x", "by (cut_tac A, rule Inf_lower, blast)"], ["proof (state)\nthis:\n  Inf {y. \\<exists>x\\<in>Q. y = p \\<sqinter> x} \\<le> p \\<sqinter> x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> x", "also"], ["proof (state)\nthis:\n  Inf {y. \\<exists>x\\<in>Q. y = p \\<sqinter> x} \\<le> p \\<sqinter> x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> x", "have \"... \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<sqinter> x \\<le> x", "by simp"], ["proof (state)\nthis:\n  p \\<sqinter> x \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Q \\<Longrightarrow> Inf ((\\<sqinter>) p ` Q) \\<le> x", "finally"], ["proof (chain)\npicking this:\n  Inf {y. \\<exists>x\\<in>Q. y = p \\<sqinter> x} \\<le> x", "show \"(INF x\\<in>Q. p \\<sqinter> x) \\<le> x\""], ["proof (prove)\nusing this:\n  Inf {y. \\<exists>x\\<in>Q. y = p \\<sqinter> x} \\<le> x\n\ngoal (1 subgoal):\n 1. Inf ((\\<sqinter>) p ` Q) \\<le> x", "by (simp only: image_def)"], ["proof (state)\nthis:\n  Inf ((\\<sqinter>) p ` Q) \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Inf ((\\<sqinter>) p ` Q) \\<le> Inf Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sconjunctive_simp: \"x \\<in> Q \\<Longrightarrow> sconjunctive S \\<Longrightarrow> S (Inf Q) = Inf (S ` Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> Q; sconjunctive S\\<rbrakk>\n    \\<Longrightarrow> S (Inf Q) = Inf (S ` Q)", "by (auto simp add: sconjunctive_def)"], ["", "lemma sconjunctive_INF_simp: \"x \\<in> X \\<Longrightarrow> sconjunctive S \\<Longrightarrow> S (Inf (Q ` X)) = Inf (S ` (Q ` X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> X; sconjunctive S\\<rbrakk>\n    \\<Longrightarrow> S (Inf (Q ` X)) = Inf (S ` Q ` X)", "by (cut_tac x = \"Q x\" and Q = \"Q ` X\" in sconjunctive_simp, auto)"], ["", "lemma demonic_comp [simp]: \"sconjunctive S \\<Longrightarrow> sconjunctive S' \\<Longrightarrow> sconjunctive (S o S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sconjunctive S; sconjunctive S'\\<rbrakk>\n    \\<Longrightarrow> sconjunctive (S \\<circ> S')", "proof (subst sconjunctive_def, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       \\<lbrakk>sconjunctive S; sconjunctive S'; x \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> (S \\<circ> S') (Inf Q) = Inf ((S \\<circ> S') ` Q)", "fix X :: \"'c set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       \\<lbrakk>sconjunctive S; sconjunctive S'; x \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> (S \\<circ> S') (Inf Q) = Inf ((S \\<circ> S') ` Q)", "fix a :: 'c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       \\<lbrakk>sconjunctive S; sconjunctive S'; x \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> (S \\<circ> S') (Inf Q) = Inf ((S \\<circ> S') ` Q)", "assume [simp]: \"sconjunctive S\""], ["proof (state)\nthis:\n  sconjunctive S\n\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       \\<lbrakk>sconjunctive S; sconjunctive S'; x \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> (S \\<circ> S') (Inf Q) = Inf ((S \\<circ> S') ` Q)", "assume [simp]: \"sconjunctive S'\""], ["proof (state)\nthis:\n  sconjunctive S'\n\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       \\<lbrakk>sconjunctive S; sconjunctive S'; x \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> (S \\<circ> S') (Inf Q) = Inf ((S \\<circ> S') ` Q)", "assume [simp]: \"a \\<in> X\""], ["proof (state)\nthis:\n  a \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       \\<lbrakk>sconjunctive S; sconjunctive S'; x \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> (S \\<circ> S') (Inf Q) = Inf ((S \\<circ> S') ` Q)", "have A: \"S' (Inf X) = Inf (S' ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S' (Inf X) = Inf (S' ` X)", "by (rule_tac x = a in sconjunctive_simp, auto)"], ["proof (state)\nthis:\n  S' (Inf X) = Inf (S' ` X)\n\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       \\<lbrakk>sconjunctive S; sconjunctive S'; x \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> (S \\<circ> S') (Inf Q) = Inf ((S \\<circ> S') ` Q)", "also"], ["proof (state)\nthis:\n  S' (Inf X) = Inf (S' ` X)\n\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       \\<lbrakk>sconjunctive S; sconjunctive S'; x \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> (S \\<circ> S') (Inf Q) = Inf ((S \\<circ> S') ` Q)", "have B: \"S (Inf (S' ` X)) = Inf (S ` (S' ` X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S (Inf (S' ` X)) = Inf (S ` S' ` X)", "by (rule_tac x = \"S' a\" in sconjunctive_simp, auto)"], ["proof (state)\nthis:\n  S (Inf (S' ` X)) = Inf (S ` S' ` X)\n\ngoal (1 subgoal):\n 1. \\<And>Q x.\n       \\<lbrakk>sconjunctive S; sconjunctive S'; x \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> (S \\<circ> S') (Inf Q) = Inf ((S \\<circ> S') ` Q)", "finally"], ["proof (chain)\npicking this:\n  S (S' (Inf X)) = Inf (S ` S' ` X)", "show \"(S o S') (Inf X) = Inf ((S \\<circ> S') ` X)\""], ["proof (prove)\nusing this:\n  S (S' (Inf X)) = Inf (S ` S' ` X)\n\ngoal (1 subgoal):\n 1. (S \\<circ> S') (Inf X) = Inf ((S \\<circ> S') ` X)", "by (simp add: image_comp)"], ["proof (state)\nthis:\n  (S \\<circ> S') (Inf X) = Inf ((S \\<circ> S') ` X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [simp]:\"conjunctive S \\<Longrightarrow> S (Inf (Q ` X)) = (Inf ((S o Q) ` X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjunctive S \\<Longrightarrow>\n    S (Inf (Q ` X)) = Inf ((S \\<circ> Q) ` X)", "by (metis INF_image conjunctive_def)"], ["", "lemma conjunctive_simp: \"conjunctive S \\<Longrightarrow>  S (Inf Q) = Inf (S ` Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjunctive S \\<Longrightarrow> S (Inf Q) = Inf (S ` Q)", "by (metis conjunctive_def)"], ["", "lemma conjunctive_monotonic: \"sconjunctive S \\<Longrightarrow> mono S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sconjunctive S \\<Longrightarrow> mono S", "proof (rule monoI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>sconjunctive S; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> S x \\<le> S y", "fix a b :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>sconjunctive S; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> S x \\<le> S y", "assume [simp]: \"a \\<le> b\""], ["proof (state)\nthis:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>sconjunctive S; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> S x \\<le> S y", "assume [simp]: \"sconjunctive S\""], ["proof (state)\nthis:\n  sconjunctive S\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>sconjunctive S; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> S x \\<le> S y", "have [simp]: \"a \\<sqinter> b = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sqinter> b = a", "by (rule antisym, auto)"], ["proof (state)\nthis:\n  a \\<sqinter> b = a\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>sconjunctive S; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> S x \\<le> S y", "have A: \"S a = S a \\<sqinter> S b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S a = S a \\<sqinter> S b", "by (cut_tac S = S and x = a and Q = \"{a, b}\" in sconjunctive_simp, auto)"], ["proof (state)\nthis:\n  S a = S a \\<sqinter> S b\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>sconjunctive S; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> S x \\<le> S y", "show \"S a \\<le> S b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S a \\<le> S b", "by (subst A, simp)"], ["proof (state)\nthis:\n  S a \\<le> S b\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"grd S = - S \\<bottom>\""], ["", "lemma \"grd [:r:] = inpt r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. grd [: r :] = inpt r", "by (simp add: fun_eq_iff grd_def demonic_def le_fun_def inpt_def)"], ["", "definition \"fail S = -(S \\<top>)\""], ["", "definition \"term S = (S \\<top>)\""], ["", "lemma \"fail ({.p.} o [:r :: 'a \\<Rightarrow> 'b \\<Rightarrow> bool:]) = -p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fail ({. p .} \\<circ> [: r :]) = - p", "by (simp add: fail_def fun_eq_iff assert_def demonic_def le_fun_def top_fun_def)"], ["", "definition \"Fail = \\<bottom>\""], ["", "lemma \"mono (S::'a::boolean_algebra \\<Rightarrow> 'b::boolean_algebra) \\<Longrightarrow> (S = Fail) = (fail S = \\<top>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono S \\<Longrightarrow> (S = Fail) = (fail S = \\<top>)", "proof auto"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>mono Fail; S = Fail\\<rbrakk>\n    \\<Longrightarrow> fail Fail = \\<top>\n 2. \\<lbrakk>mono S; fail S = \\<top>\\<rbrakk> \\<Longrightarrow> S = Fail", "show \"fail (Fail::'a \\<Rightarrow> 'b) = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fail Fail = \\<top>", "by (metis Fail_def bot_apply compl_bot_eq fail_def)"], ["proof (state)\nthis:\n  fail Fail = \\<top>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mono S; fail S = \\<top>\\<rbrakk> \\<Longrightarrow> S = Fail", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono S; fail S = \\<top>\\<rbrakk> \\<Longrightarrow> S = Fail", "assume A: \"mono S\""], ["proof (state)\nthis:\n  mono S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mono S; fail S = \\<top>\\<rbrakk> \\<Longrightarrow> S = Fail", "assume B: \"fail S = \\<top>\""], ["proof (state)\nthis:\n  fail S = \\<top>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mono S; fail S = \\<top>\\<rbrakk> \\<Longrightarrow> S = Fail", "show \"S = Fail\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S = Fail", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. S \\<le> Fail\n 2. Fail \\<le> S", "show \"S \\<le> Fail\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<le> Fail", "by (metis (hide_lams, no_types) A B bot.extremum_unique compl_le_compl_iff fail_def le_fun_def monoD top_greatest)"], ["proof (state)\nthis:\n  S \\<le> Fail\n\ngoal (1 subgoal):\n 1. Fail \\<le> S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Fail \\<le> S", "show \"Fail \\<le> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fail \\<le> S", "by (metis Fail_def bot.extremum)"], ["proof (state)\nthis:\n  Fail \\<le> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S = Fail\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"Skip = id\""], ["", "lemma [simp]: \"{.\\<top>::'a::bounded_lattice.} = Skip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {. \\<top> .} = Skip", "by (simp add: fun_eq_iff assert_def Skip_def)"], ["", "lemma [simp]:\"Skip o S = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Skip \\<circ> S = S", "by (simp add: fun_eq_iff assert_def Skip_def)"], ["", "lemma [simp]:\"S o Skip = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<circ> Skip = S", "by (simp add: fun_eq_iff assert_def Skip_def)"], ["", "lemma [simp]: \"mono S \\<Longrightarrow> mono S' \\<Longrightarrow> mono (S o S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono S; mono S'\\<rbrakk> \\<Longrightarrow> mono (S \\<circ> S')", "by (simp add: mono_def)"], ["", "lemma [simp]: \"mono {.p::('a \\<Rightarrow> bool).}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono {. p .}", "by (simp add: conjunctive_monotonic)"], ["", "lemma [simp]: \"mono [:r::('a \\<Rightarrow> 'b \\<Rightarrow> bool):]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono [: r :]", "by (simp add: conjunctive_monotonic)"], ["", "lemma [simp]:\"{. \\<lambda> x . True .} = Skip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {. \\<lambda>x. True .} = Skip", "by (simp add: fun_eq_iff assert_def Skip_def)"], ["", "lemma [simp]: \"\\<bottom> o S = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<circ> S = \\<bottom>", "by (simp add: fun_eq_iff)"], ["", "lemma [simp]: \"{.\\<bottom>::'a::boolean_algebra.}  = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {. \\<bottom> .} = \\<bottom>", "by (simp add: fun_eq_iff assert_def)"], ["", "lemma [simp]: \"\\<top> o S = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> \\<circ> S = \\<top>", "by (simp add: fun_eq_iff)"], ["", "lemma left_comp: \"T o U = T' o U' \\<Longrightarrow> S o T o U = S o T' o U'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T \\<circ> U = T' \\<circ> U' \\<Longrightarrow>\n    S \\<circ> T \\<circ> U = S \\<circ> T' \\<circ> U'", "by (simp add: comp_assoc)"], ["", "lemma assert_demonic: \"{.p.} o [:r:] = {.p.} o [:\\<lambda> x y . p x \\<and> r x y:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {. p .} \\<circ> [: r :] =\n    {. p .} \\<circ> [: \\<lambda>x y. p x \\<and> r x y :]", "by (auto simp add: fun_eq_iff assert_def demonic_def le_fun_def)"], ["", "lemma \"trs r \\<sqinter> trs r' = trs (\\<lambda> x y . inpt r x \\<and> inpt r' x \\<and> (r x y \\<or> r' x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trs r \\<sqinter> trs r' =\n    trs (\\<lambda>x y.\n            inpt r x \\<and> inpt r' x \\<and> (r x y \\<or> r' x y))", "by (auto simp add: fun_eq_iff trs_def assert_def demonic_def inpt_def)"], ["", "subsection\\<open>Fusion of predicate transformers\\<close>"], ["", "text\\<open>\n  In this section we define the fusion operator from \\cite{back:butler:1995}. The fusion\n  of two programs $S$ and $T$ is intuitively equivalent with the parallel execution of the two\n  programs. If $S$ and $T$ assign nondeterministically some value to some program variable\n  $x$, then the fusion of $S$ and $T$ will assign a value to $x$ which can be assigned by\n  both $S$ and $T$.\n\\<close>"], ["", "definition fusion :: \"(('a \\<Rightarrow> bool) \\<Rightarrow> ('b \\<Rightarrow> bool)) \\<Rightarrow> (('a \\<Rightarrow> bool) \\<Rightarrow> ('b \\<Rightarrow> bool)) \\<Rightarrow> (('a \\<Rightarrow> bool) \\<Rightarrow> ('b \\<Rightarrow> bool))\" (infixl \"\\<parallel>\" 70) where\n    \"(S \\<parallel> S') q x = (\\<exists> (p::'a\\<Rightarrow>bool) p' . p \\<sqinter> p' \\<le> q \\<and> S p x \\<and> S' p' x)\""], ["", "lemma fusion_spec: \"({.p.} \\<circ> [:r:]) \\<parallel> ({.p'.} \\<circ> [:r':]) = ({.p \\<sqinter> p'.} \\<circ> [:r \\<sqinter> r':])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({. p .} \\<circ> [: r :]) \\<parallel> ({. p' .} \\<circ> [: r' :]) =\n    {. p \\<sqinter> p' .} \\<circ> [: r \\<sqinter> r' :]", "by (auto simp add: fun_eq_iff fusion_def assert_def demonic_def le_fun_def)"], ["", "lemma fusion_assoc: \"S \\<parallel> (T \\<parallel> U) = (S \\<parallel> T) \\<parallel> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<parallel> (T \\<parallel> U) = S \\<parallel> T \\<parallel> U", "proof (rule antisym, auto simp add: fusion_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y p p' pa p'a.\n       \\<lbrakk>p \\<sqinter> p' \\<le> x; S p y; pa \\<sqinter> p'a \\<le> p';\n        T pa y; U p'a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p p'.\n                            p \\<sqinter> p' \\<le> x \\<and>\n                            (\\<exists>pa p'.\n                                pa \\<sqinter> p' \\<le> p \\<and>\n                                S pa y \\<and> T p' y) \\<and>\n                            U p' y\n 2. \\<And>x y p p' pa p'a.\n       \\<lbrakk>p \\<sqinter> p' \\<le> x; U p' y; pa \\<sqinter> p'a \\<le> p;\n        S pa y; T p'a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p p'.\n                            p \\<sqinter> p' \\<le> x \\<and>\n                            S p y \\<and>\n                            (\\<exists>p p'a.\n                                p \\<sqinter> p'a \\<le> p' \\<and>\n                                T p y \\<and> U p'a y)", "fix p p' q s s' :: \"'a \\<Rightarrow> bool\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y p p' pa p'a.\n       \\<lbrakk>p \\<sqinter> p' \\<le> x; S p y; pa \\<sqinter> p'a \\<le> p';\n        T pa y; U p'a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p p'.\n                            p \\<sqinter> p' \\<le> x \\<and>\n                            (\\<exists>pa p'.\n                                pa \\<sqinter> p' \\<le> p \\<and>\n                                S pa y \\<and> T p' y) \\<and>\n                            U p' y\n 2. \\<And>x y p p' pa p'a.\n       \\<lbrakk>p \\<sqinter> p' \\<le> x; U p' y; pa \\<sqinter> p'a \\<le> p;\n        S pa y; T p'a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p p'.\n                            p \\<sqinter> p' \\<le> x \\<and>\n                            S p y \\<and>\n                            (\\<exists>p p'a.\n                                p \\<sqinter> p'a \\<le> p' \\<and>\n                                T p y \\<and> U p'a y)", "fix a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y p p' pa p'a.\n       \\<lbrakk>p \\<sqinter> p' \\<le> x; S p y; pa \\<sqinter> p'a \\<le> p';\n        T pa y; U p'a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p p'.\n                            p \\<sqinter> p' \\<le> x \\<and>\n                            (\\<exists>pa p'.\n                                pa \\<sqinter> p' \\<le> p \\<and>\n                                S pa y \\<and> T p' y) \\<and>\n                            U p' y\n 2. \\<And>x y p p' pa p'a.\n       \\<lbrakk>p \\<sqinter> p' \\<le> x; U p' y; pa \\<sqinter> p'a \\<le> p;\n        S pa y; T p'a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p p'.\n                            p \\<sqinter> p' \\<le> x \\<and>\n                            S p y \\<and>\n                            (\\<exists>p p'a.\n                                p \\<sqinter> p'a \\<le> p' \\<and>\n                                T p y \\<and> U p'a y)", "assume A: \"p \\<sqinter> p' \\<le> q\" and B: \"s \\<sqinter> s' \\<le> p'\""], ["proof (state)\nthis:\n  p \\<sqinter> p' \\<le> q\n  s \\<sqinter> s' \\<le> p'\n\ngoal (2 subgoals):\n 1. \\<And>x y p p' pa p'a.\n       \\<lbrakk>p \\<sqinter> p' \\<le> x; S p y; pa \\<sqinter> p'a \\<le> p';\n        T pa y; U p'a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p p'.\n                            p \\<sqinter> p' \\<le> x \\<and>\n                            (\\<exists>pa p'.\n                                pa \\<sqinter> p' \\<le> p \\<and>\n                                S pa y \\<and> T p' y) \\<and>\n                            U p' y\n 2. \\<And>x y p p' pa p'a.\n       \\<lbrakk>p \\<sqinter> p' \\<le> x; U p' y; pa \\<sqinter> p'a \\<le> p;\n        S pa y; T p'a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p p'.\n                            p \\<sqinter> p' \\<le> x \\<and>\n                            S p y \\<and>\n                            (\\<exists>p p'a.\n                                p \\<sqinter> p'a \\<le> p' \\<and>\n                                T p y \\<and> U p'a y)", "assume C: \"S p a\" and D: \"T s a\" and E: \"U s' a\""], ["proof (state)\nthis:\n  S p a\n  T s a\n  U s' a\n\ngoal (2 subgoals):\n 1. \\<And>x y p p' pa p'a.\n       \\<lbrakk>p \\<sqinter> p' \\<le> x; S p y; pa \\<sqinter> p'a \\<le> p';\n        T pa y; U p'a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p p'.\n                            p \\<sqinter> p' \\<le> x \\<and>\n                            (\\<exists>pa p'.\n                                pa \\<sqinter> p' \\<le> p \\<and>\n                                S pa y \\<and> T p' y) \\<and>\n                            U p' y\n 2. \\<And>x y p p' pa p'a.\n       \\<lbrakk>p \\<sqinter> p' \\<le> x; U p' y; pa \\<sqinter> p'a \\<le> p;\n        S pa y; T p'a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p p'.\n                            p \\<sqinter> p' \\<le> x \\<and>\n                            S p y \\<and>\n                            (\\<exists>p p'a.\n                                p \\<sqinter> p'a \\<le> p' \\<and>\n                                T p y \\<and> U p'a y)", "from A and B"], ["proof (chain)\npicking this:\n  p \\<sqinter> p' \\<le> q\n  s \\<sqinter> s' \\<le> p'", "have F: \"(p \\<sqinter> s) \\<sqinter> s' \\<le> q\""], ["proof (prove)\nusing this:\n  p \\<sqinter> p' \\<le> q\n  s \\<sqinter> s' \\<le> p'\n\ngoal (1 subgoal):\n 1. p \\<sqinter> s \\<sqinter> s' \\<le> q", "by (simp add: le_fun_def)"], ["proof (state)\nthis:\n  p \\<sqinter> s \\<sqinter> s' \\<le> q\n\ngoal (2 subgoals):\n 1. \\<And>x y p p' pa p'a.\n       \\<lbrakk>p \\<sqinter> p' \\<le> x; S p y; pa \\<sqinter> p'a \\<le> p';\n        T pa y; U p'a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p p'.\n                            p \\<sqinter> p' \\<le> x \\<and>\n                            (\\<exists>pa p'.\n                                pa \\<sqinter> p' \\<le> p \\<and>\n                                S pa y \\<and> T p' y) \\<and>\n                            U p' y\n 2. \\<And>x y p p' pa p'a.\n       \\<lbrakk>p \\<sqinter> p' \\<le> x; U p' y; pa \\<sqinter> p'a \\<le> p;\n        S pa y; T p'a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p p'.\n                            p \\<sqinter> p' \\<le> x \\<and>\n                            S p y \\<and>\n                            (\\<exists>p p'a.\n                                p \\<sqinter> p'a \\<le> p' \\<and>\n                                T p y \\<and> U p'a y)", "have \"(\\<exists>v v'. v \\<sqinter> v' \\<le> (p \\<sqinter> s) \\<and> S v a \\<and> T v' a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v v'.\n       v \\<sqinter> v' \\<le> p \\<sqinter> s \\<and> S v a \\<and> T v' a", "by (metis C D order_refl)"], ["proof (state)\nthis:\n  \\<exists>v v'.\n     v \\<sqinter> v' \\<le> p \\<sqinter> s \\<and> S v a \\<and> T v' a\n\ngoal (2 subgoals):\n 1. \\<And>x y p p' pa p'a.\n       \\<lbrakk>p \\<sqinter> p' \\<le> x; S p y; pa \\<sqinter> p'a \\<le> p';\n        T pa y; U p'a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p p'.\n                            p \\<sqinter> p' \\<le> x \\<and>\n                            (\\<exists>pa p'.\n                                pa \\<sqinter> p' \\<le> p \\<and>\n                                S pa y \\<and> T p' y) \\<and>\n                            U p' y\n 2. \\<And>x y p p' pa p'a.\n       \\<lbrakk>p \\<sqinter> p' \\<le> x; U p' y; pa \\<sqinter> p'a \\<le> p;\n        S pa y; T p'a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p p'.\n                            p \\<sqinter> p' \\<le> x \\<and>\n                            S p y \\<and>\n                            (\\<exists>p p'a.\n                                p \\<sqinter> p'a \\<le> p' \\<and>\n                                T p y \\<and> U p'a y)", "show \"\\<exists>u u' . u \\<sqinter> u' \\<le> q \\<and> (\\<exists>v v'. v \\<sqinter> v' \\<le> u \\<and> S v a \\<and> T v' a) \\<and> U u' a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u u'.\n       u \\<sqinter> u' \\<le> q \\<and>\n       (\\<exists>v v'.\n           v \\<sqinter> v' \\<le> u \\<and> S v a \\<and> T v' a) \\<and>\n       U u' a", "by (metis F C D E order_refl)"], ["proof (state)\nthis:\n  \\<exists>u u'.\n     u \\<sqinter> u' \\<le> q \\<and>\n     (\\<exists>v v'.\n         v \\<sqinter> v' \\<le> u \\<and> S v a \\<and> T v' a) \\<and>\n     U u' a\n\ngoal (1 subgoal):\n 1. \\<And>x y p p' pa p'a.\n       \\<lbrakk>p \\<sqinter> p' \\<le> x; U p' y; pa \\<sqinter> p'a \\<le> p;\n        S pa y; T p'a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p p'.\n                            p \\<sqinter> p' \\<le> x \\<and>\n                            S p y \\<and>\n                            (\\<exists>p p'a.\n                                p \\<sqinter> p'a \\<le> p' \\<and>\n                                T p y \\<and> U p'a y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y p p' pa p'a.\n       \\<lbrakk>p \\<sqinter> p' \\<le> x; U p' y; pa \\<sqinter> p'a \\<le> p;\n        S pa y; T p'a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p p'.\n                            p \\<sqinter> p' \\<le> x \\<and>\n                            S p y \\<and>\n                            (\\<exists>p p'a.\n                                p \\<sqinter> p'a \\<le> p' \\<and>\n                                T p y \\<and> U p'a y)", "fix p p' q s s' :: \"'a \\<Rightarrow> bool\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y p p' pa p'a.\n       \\<lbrakk>p \\<sqinter> p' \\<le> x; U p' y; pa \\<sqinter> p'a \\<le> p;\n        S pa y; T p'a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p p'.\n                            p \\<sqinter> p' \\<le> x \\<and>\n                            S p y \\<and>\n                            (\\<exists>p p'a.\n                                p \\<sqinter> p'a \\<le> p' \\<and>\n                                T p y \\<and> U p'a y)", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y p p' pa p'a.\n       \\<lbrakk>p \\<sqinter> p' \\<le> x; U p' y; pa \\<sqinter> p'a \\<le> p;\n        S pa y; T p'a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p p'.\n                            p \\<sqinter> p' \\<le> x \\<and>\n                            S p y \\<and>\n                            (\\<exists>p p'a.\n                                p \\<sqinter> p'a \\<le> p' \\<and>\n                                T p y \\<and> U p'a y)", "assume A: \"p \\<sqinter> p' \\<le> q\" and B: \"s \\<sqinter> s' \\<le> p\""], ["proof (state)\nthis:\n  p \\<sqinter> p' \\<le> q\n  s \\<sqinter> s' \\<le> p\n\ngoal (1 subgoal):\n 1. \\<And>x y p p' pa p'a.\n       \\<lbrakk>p \\<sqinter> p' \\<le> x; U p' y; pa \\<sqinter> p'a \\<le> p;\n        S pa y; T p'a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p p'.\n                            p \\<sqinter> p' \\<le> x \\<and>\n                            S p y \\<and>\n                            (\\<exists>p p'a.\n                                p \\<sqinter> p'a \\<le> p' \\<and>\n                                T p y \\<and> U p'a y)", "assume C: \"S s a\" and D: \"T s' a\" and E: \"U p' a\""], ["proof (state)\nthis:\n  S s a\n  T s' a\n  U p' a\n\ngoal (1 subgoal):\n 1. \\<And>x y p p' pa p'a.\n       \\<lbrakk>p \\<sqinter> p' \\<le> x; U p' y; pa \\<sqinter> p'a \\<le> p;\n        S pa y; T p'a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p p'.\n                            p \\<sqinter> p' \\<le> x \\<and>\n                            S p y \\<and>\n                            (\\<exists>p p'a.\n                                p \\<sqinter> p'a \\<le> p' \\<and>\n                                T p y \\<and> U p'a y)", "from A and B"], ["proof (chain)\npicking this:\n  p \\<sqinter> p' \\<le> q\n  s \\<sqinter> s' \\<le> p", "have F: \"s \\<sqinter> (s' \\<sqinter> p')  \\<le> q\""], ["proof (prove)\nusing this:\n  p \\<sqinter> p' \\<le> q\n  s \\<sqinter> s' \\<le> p\n\ngoal (1 subgoal):\n 1. s \\<sqinter> (s' \\<sqinter> p') \\<le> q", "by (simp add: le_fun_def)"], ["proof (state)\nthis:\n  s \\<sqinter> (s' \\<sqinter> p') \\<le> q\n\ngoal (1 subgoal):\n 1. \\<And>x y p p' pa p'a.\n       \\<lbrakk>p \\<sqinter> p' \\<le> x; U p' y; pa \\<sqinter> p'a \\<le> p;\n        S pa y; T p'a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p p'.\n                            p \\<sqinter> p' \\<le> x \\<and>\n                            S p y \\<and>\n                            (\\<exists>p p'a.\n                                p \\<sqinter> p'a \\<le> p' \\<and>\n                                T p y \\<and> U p'a y)", "have \"(\\<exists>v v'. v \\<sqinter> v' \\<le> s' \\<sqinter> p' \\<and> T v a \\<and> U v' a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v v'.\n       v \\<sqinter> v' \\<le> s' \\<sqinter> p' \\<and> T v a \\<and> U v' a", "by (metis D E eq_iff)"], ["proof (state)\nthis:\n  \\<exists>v v'.\n     v \\<sqinter> v' \\<le> s' \\<sqinter> p' \\<and> T v a \\<and> U v' a\n\ngoal (1 subgoal):\n 1. \\<And>x y p p' pa p'a.\n       \\<lbrakk>p \\<sqinter> p' \\<le> x; U p' y; pa \\<sqinter> p'a \\<le> p;\n        S pa y; T p'a y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p p'.\n                            p \\<sqinter> p' \\<le> x \\<and>\n                            S p y \\<and>\n                            (\\<exists>p p'a.\n                                p \\<sqinter> p'a \\<le> p' \\<and>\n                                T p y \\<and> U p'a y)", "show \"\\<exists>u u'. u \\<sqinter> u' \\<le> q \\<and> S u a \\<and> (\\<exists>v v'. v \\<sqinter> v' \\<le> u' \\<and> T v a \\<and> U v' a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u u'.\n       u \\<sqinter> u' \\<le> q \\<and>\n       S u a \\<and>\n       (\\<exists>v v'. v \\<sqinter> v' \\<le> u' \\<and> T v a \\<and> U v' a)", "by (metis F C D E order_refl)"], ["proof (state)\nthis:\n  \\<exists>u u'.\n     u \\<sqinter> u' \\<le> q \\<and>\n     S u a \\<and>\n     (\\<exists>v v'. v \\<sqinter> v' \\<le> u' \\<and> T v a \\<and> U v' a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \"P \\<le> Q \\<Longrightarrow> P' \\<le> Q' \\<Longrightarrow> P \\<parallel> P' \\<le> Q \\<parallel> Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<le> Q; P' \\<le> Q'\\<rbrakk>\n    \\<Longrightarrow> P \\<parallel> P' \\<le> Q \\<parallel> Q'", "by (simp add: le_fun_def fusion_def, metis)"], ["", "lemma \"conjunctive S \\<Longrightarrow> S \\<parallel> \\<top> = \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjunctive S \\<Longrightarrow> S \\<parallel> \\<top> = \\<top>", "by (auto simp add: fun_eq_iff fusion_def le_fun_def conjunctive_def)"], ["", "lemma fusion_spec_local: \"a \\<in> init \\<Longrightarrow> ([:x \\<leadsto> u, y . u \\<in> init \\<and> x = y:] \\<circ> {.p.} \\<circ> [:r:]) \\<parallel> ({.p'.} \\<circ> [:r':]) \n      = [:x \\<leadsto> u, y . u \\<in> init \\<and> x = y:] \\<circ> {.u,x . p (u, x) \\<and> p' x.} \\<circ> [:u, x \\<leadsto> y . r (u, x) y \\<and> r' x y:]\" (is \"?p \\<Longrightarrow> ?S = ?T\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> init \\<Longrightarrow>\n    ([: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n     {. p .} \\<circ>\n     [: r :]) \\<parallel>\n    ({. p' .} \\<circ> [: r' :]) =\n    [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n    {.u, x. p (u, x) \\<and> p' x.} \\<circ>\n    [: (u, x) \\<leadsto> y . r (u, x) y \\<and> r' x y :]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> init \\<Longrightarrow>\n    ([: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n     {. p .} \\<circ>\n     [: r :]) \\<parallel>\n    ({. p' .} \\<circ> [: r' :]) =\n    [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n    {.u, x. p (u, x) \\<and> p' x.} \\<circ>\n    [: (u, x) \\<leadsto> y . r (u, x) y \\<and> r' x y :]", "assume \"?p\""], ["proof (state)\nthis:\n  a \\<in> init\n\ngoal (1 subgoal):\n 1. a \\<in> init \\<Longrightarrow>\n    ([: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n     {. p .} \\<circ>\n     [: r :]) \\<parallel>\n    ({. p' .} \\<circ> [: r' :]) =\n    [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n    {.u, x. p (u, x) \\<and> p' x.} \\<circ>\n    [: (u, x) \\<leadsto> y . r (u, x) y \\<and> r' x y :]", "from this"], ["proof (chain)\npicking this:\n  a \\<in> init", "have [simp]: \"(\\<lambda>x. \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x) \\<and> p' x) = (\\<lambda>x. \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x)) \\<sqinter> p'\""], ["proof (prove)\nusing this:\n  a \\<in> init\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x) \\<and> p' x) =\n    (\\<lambda>x.\n        \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x)) \\<sqinter>\n    p'", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x) \\<and> p' x) =\n  (\\<lambda>x.\n      \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x)) \\<sqinter>\n  p'\n\ngoal (1 subgoal):\n 1. a \\<in> init \\<Longrightarrow>\n    ([: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n     {. p .} \\<circ>\n     [: r :]) \\<parallel>\n    ({. p' .} \\<circ> [: r' :]) =\n    [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n    {.u, x. p (u, x) \\<and> p' x.} \\<circ>\n    [: (u, x) \\<leadsto> y . r (u, x) y \\<and> r' x y :]", "have [simp]: \"(\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO (\\<lambda>(u, x) y. r (u, x) y \\<and> r' x y) = (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO r \\<sqinter> r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO\n    (\\<lambda>(u, x) y. r (u, x) y \\<and> r' x y) =\n    (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO r \\<sqinter> r'", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO\n  (\\<lambda>(u, x) y. r (u, x) y \\<and> r' x y) =\n  (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO r \\<sqinter> r'\n\ngoal (1 subgoal):\n 1. a \\<in> init \\<Longrightarrow>\n    ([: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n     {. p .} \\<circ>\n     [: r :]) \\<parallel>\n    ({. p' .} \\<circ> [: r' :]) =\n    [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n    {.u, x. p (u, x) \\<and> p' x.} \\<circ>\n    [: (u, x) \\<leadsto> y . r (u, x) y \\<and> r' x y :]", "have \"?S = \n        ({. \\<lambda>x. \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x) .} \\<circ> [: \\<lambda>x (u, y). u \\<in> init \\<and> x = y :] \\<circ> [: r :]) \\<parallel> ({. p' .} \\<circ> [: r' :])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n     {. p .} \\<circ>\n     [: r :]) \\<parallel>\n    ({. p' .} \\<circ> [: r' :]) =\n    ({. \\<lambda>x.\n           \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x) .} \\<circ>\n     [: \\<lambda>x (u, y). u \\<in> init \\<and> x = y :] \\<circ>\n     [: r :]) \\<parallel>\n    ({. p' .} \\<circ> [: r' :])", "by (simp add: demonic_assert_comp)"], ["proof (state)\nthis:\n  ([: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n   {. p .} \\<circ>\n   [: r :]) \\<parallel>\n  ({. p' .} \\<circ> [: r' :]) =\n  ({. \\<lambda>x.\n         \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x) .} \\<circ>\n   [: \\<lambda>x (u, y). u \\<in> init \\<and> x = y :] \\<circ>\n   [: r :]) \\<parallel>\n  ({. p' .} \\<circ> [: r' :])\n\ngoal (1 subgoal):\n 1. a \\<in> init \\<Longrightarrow>\n    ([: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n     {. p .} \\<circ>\n     [: r :]) \\<parallel>\n    ({. p' .} \\<circ> [: r' :]) =\n    [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n    {.u, x. p (u, x) \\<and> p' x.} \\<circ>\n    [: (u, x) \\<leadsto> y . r (u, x) y \\<and> r' x y :]", "also"], ["proof (state)\nthis:\n  ([: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n   {. p .} \\<circ>\n   [: r :]) \\<parallel>\n  ({. p' .} \\<circ> [: r' :]) =\n  ({. \\<lambda>x.\n         \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x) .} \\<circ>\n   [: \\<lambda>x (u, y). u \\<in> init \\<and> x = y :] \\<circ>\n   [: r :]) \\<parallel>\n  ({. p' .} \\<circ> [: r' :])\n\ngoal (1 subgoal):\n 1. a \\<in> init \\<Longrightarrow>\n    ([: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n     {. p .} \\<circ>\n     [: r :]) \\<parallel>\n    ({. p' .} \\<circ> [: r' :]) =\n    [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n    {.u, x. p (u, x) \\<and> p' x.} \\<circ>\n    [: (u, x) \\<leadsto> y . r (u, x) y \\<and> r' x y :]", "have \"... =  {. (\\<lambda>x. \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x)) \\<sqinter> p' .} \\<circ> [: (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO r \\<sqinter> r' :]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({. \\<lambda>x.\n           \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x) .} \\<circ>\n     [: \\<lambda>x (u, y). u \\<in> init \\<and> x = y :] \\<circ>\n     [: r :]) \\<parallel>\n    ({. p' .} \\<circ> [: r' :]) =\n    {. (\\<lambda>x.\n           \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x)) \\<sqinter>\n       p' .} \\<circ>\n    [: (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO r \\<sqinter> r' :]", "by (simp add: comp_assoc demonic_demonic fusion_spec)"], ["proof (state)\nthis:\n  ({. \\<lambda>x.\n         \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x) .} \\<circ>\n   [: \\<lambda>x (u, y). u \\<in> init \\<and> x = y :] \\<circ>\n   [: r :]) \\<parallel>\n  ({. p' .} \\<circ> [: r' :]) =\n  {. (\\<lambda>x.\n         \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x)) \\<sqinter>\n     p' .} \\<circ>\n  [: (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO r \\<sqinter> r' :]\n\ngoal (1 subgoal):\n 1. a \\<in> init \\<Longrightarrow>\n    ([: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n     {. p .} \\<circ>\n     [: r :]) \\<parallel>\n    ({. p' .} \\<circ> [: r' :]) =\n    [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n    {.u, x. p (u, x) \\<and> p' x.} \\<circ>\n    [: (u, x) \\<leadsto> y . r (u, x) y \\<and> r' x y :]", "also"], ["proof (state)\nthis:\n  ({. \\<lambda>x.\n         \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x) .} \\<circ>\n   [: \\<lambda>x (u, y). u \\<in> init \\<and> x = y :] \\<circ>\n   [: r :]) \\<parallel>\n  ({. p' .} \\<circ> [: r' :]) =\n  {. (\\<lambda>x.\n         \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x)) \\<sqinter>\n     p' .} \\<circ>\n  [: (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO r \\<sqinter> r' :]\n\ngoal (1 subgoal):\n 1. a \\<in> init \\<Longrightarrow>\n    ([: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n     {. p .} \\<circ>\n     [: r :]) \\<parallel>\n    ({. p' .} \\<circ> [: r' :]) =\n    [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n    {.u, x. p (u, x) \\<and> p' x.} \\<circ>\n    [: (u, x) \\<leadsto> y . r (u, x) y \\<and> r' x y :]", "have \"... = ?T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {. (\\<lambda>x.\n           \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x)) \\<sqinter>\n       p' .} \\<circ>\n    [: (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO r \\<sqinter>\n       r' :] =\n    [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n    {.u, x. p (u, x) \\<and> p' x.} \\<circ>\n    [: (u, x) \\<leadsto> y . r (u, x) y \\<and> r' x y :]", "by (simp add: demonic_assert_comp comp_assoc demonic_demonic fusion_spec)"], ["proof (state)\nthis:\n  {. (\\<lambda>x.\n         \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x)) \\<sqinter>\n     p' .} \\<circ>\n  [: (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO r \\<sqinter> r' :] =\n  [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n  {.u, x. p (u, x) \\<and> p' x.} \\<circ>\n  [: (u, x) \\<leadsto> y . r (u, x) y \\<and> r' x y :]\n\ngoal (1 subgoal):\n 1. a \\<in> init \\<Longrightarrow>\n    ([: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n     {. p .} \\<circ>\n     [: r :]) \\<parallel>\n    ({. p' .} \\<circ> [: r' :]) =\n    [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n    {.u, x. p (u, x) \\<and> p' x.} \\<circ>\n    [: (u, x) \\<leadsto> y . r (u, x) y \\<and> r' x y :]", "finally"], ["proof (chain)\npicking this:\n  ([: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n   {. p .} \\<circ>\n   [: r :]) \\<parallel>\n  ({. p' .} \\<circ> [: r' :]) =\n  [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n  {.u, x. p (u, x) \\<and> p' x.} \\<circ>\n  [: (u, x) \\<leadsto> y . r (u, x) y \\<and> r' x y :]", "show ?thesis"], ["proof (prove)\nusing this:\n  ([: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n   {. p .} \\<circ>\n   [: r :]) \\<parallel>\n  ({. p' .} \\<circ> [: r' :]) =\n  [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n  {.u, x. p (u, x) \\<and> p' x.} \\<circ>\n  [: (u, x) \\<leadsto> y . r (u, x) y \\<and> r' x y :]\n\ngoal (1 subgoal):\n 1. ([: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n     {. p .} \\<circ>\n     [: r :]) \\<parallel>\n    ({. p' .} \\<circ> [: r' :]) =\n    [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n    {.u, x. p (u, x) \\<and> p' x.} \\<circ>\n    [: (u, x) \\<leadsto> y . r (u, x) y \\<and> r' x y :]", "by simp"], ["proof (state)\nthis:\n  ([: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n   {. p .} \\<circ>\n   [: r :]) \\<parallel>\n  ({. p' .} \\<circ> [: r' :]) =\n  [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n  {.u, x. p (u, x) \\<and> p' x.} \\<circ>\n  [: (u, x) \\<leadsto> y . r (u, x) y \\<and> r' x y :]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fusion_spec_local_a: \"a \\<in> init \\<Longrightarrow> ([:x \\<leadsto> u, y . u \\<in> init \\<and> x = y:] \\<circ> {.p.} \\<circ> [:r:]) \\<parallel> [:r':] \n      = ([:x \\<leadsto> u, y . u \\<in> init \\<and> x = y:] \\<circ> {.p.} \\<circ> [:u, x \\<leadsto> y . r (u, x) y \\<and> r' x y:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> init \\<Longrightarrow>\n    ([: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n     {. p .} \\<circ>\n     [: r :]) \\<parallel>\n    [: r' :] =\n    [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n    {. p .} \\<circ>\n    [: (u, x) \\<leadsto> y . r (u, x) y \\<and> r' x y :]", "by (cut_tac p' = \"\\<top>\" and init = init and p = p and r = r and r' = r' in fusion_spec_local, auto)"], ["", "lemma fusion_local_refinement:\n    \"a \\<in> init \\<Longrightarrow> (\\<And> x u y . u \\<in> init \\<Longrightarrow> p' x \\<Longrightarrow> r (u, x) y \\<Longrightarrow> r' x y) \\<Longrightarrow> \n      {.p'.} o (([:x \\<leadsto> u, y . u \\<in> init \\<and> x = y:] \\<circ> {.p.} \\<circ> [:r:]) \\<parallel> [:r':]) \\<le> [:x \\<leadsto> u, y . u \\<in> init \\<and> x = y:] \\<circ> {.p.} \\<circ> [:r:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> init;\n     \\<And>x u y.\n        \\<lbrakk>u \\<in> init; p' x; r (u, x) y\\<rbrakk>\n        \\<Longrightarrow> r' x y\\<rbrakk>\n    \\<Longrightarrow> {. p' .} \\<circ>\n                      ([: x \\<leadsto> (u,\n                       y) . u \\<in> init \\<and> x = y :] \\<circ>\n                       {. p .} \\<circ>\n                       [: r :]) \\<parallel>\n                      [: r' :]\n                      \\<le> [: x \\<leadsto> (u,\n                            y) . u \\<in> init \\<and> x = y :] \\<circ>\n                            {. p .} \\<circ>\n                            [: r :]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> init;\n     \\<And>x u y.\n        \\<lbrakk>u \\<in> init; p' x; r (u, x) y\\<rbrakk>\n        \\<Longrightarrow> r' x y\\<rbrakk>\n    \\<Longrightarrow> {. p' .} \\<circ>\n                      ([: x \\<leadsto> (u,\n                       y) . u \\<in> init \\<and> x = y :] \\<circ>\n                       {. p .} \\<circ>\n                       [: r :]) \\<parallel>\n                      [: r' :]\n                      \\<le> [: x \\<leadsto> (u,\n                            y) . u \\<in> init \\<and> x = y :] \\<circ>\n                            {. p .} \\<circ>\n                            [: r :]", "assume A: \"a \\<in> init\""], ["proof (state)\nthis:\n  a \\<in> init\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> init;\n     \\<And>x u y.\n        \\<lbrakk>u \\<in> init; p' x; r (u, x) y\\<rbrakk>\n        \\<Longrightarrow> r' x y\\<rbrakk>\n    \\<Longrightarrow> {. p' .} \\<circ>\n                      ([: x \\<leadsto> (u,\n                       y) . u \\<in> init \\<and> x = y :] \\<circ>\n                       {. p .} \\<circ>\n                       [: r :]) \\<parallel>\n                      [: r' :]\n                      \\<le> [: x \\<leadsto> (u,\n                            y) . u \\<in> init \\<and> x = y :] \\<circ>\n                            {. p .} \\<circ>\n                            [: r :]", "assume [simp]: \"(\\<And> x u y . u \\<in> init \\<Longrightarrow> p' x \\<Longrightarrow> r (u, x) y \\<Longrightarrow> r' x y)\""], ["proof (state)\nthis:\n  \\<lbrakk>?u \\<in> init; p' ?x; r (?u, ?x) ?y\\<rbrakk>\n  \\<Longrightarrow> r' ?x ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> init;\n     \\<And>x u y.\n        \\<lbrakk>u \\<in> init; p' x; r (u, x) y\\<rbrakk>\n        \\<Longrightarrow> r' x y\\<rbrakk>\n    \\<Longrightarrow> {. p' .} \\<circ>\n                      ([: x \\<leadsto> (u,\n                       y) . u \\<in> init \\<and> x = y :] \\<circ>\n                       {. p .} \\<circ>\n                       [: r :]) \\<parallel>\n                      [: r' :]\n                      \\<le> [: x \\<leadsto> (u,\n                            y) . u \\<in> init \\<and> x = y :] \\<circ>\n                            {. p .} \\<circ>\n                            [: r :]", "have \" {. x. p' x \\<and> (\\<forall>a. a \\<in> init \\<longrightarrow> p (a, x)) .} \\<circ> [: (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO (\\<lambda>(u, x) y. r (u, x) y \\<and> r' x y) :]\n              \\<le> {. \\<lambda>x. \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x) .} \\<circ> [: (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO r :]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {.x.\n     p' x \\<and>\n     (\\<forall>a. a \\<in> init \\<longrightarrow> p (a, x)).} \\<circ>\n    [: (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO\n       (\\<lambda>(u, x) y. r (u, x) y \\<and> r' x y) :]\n    \\<le> {. \\<lambda>x.\n                \\<forall>a.\n                   a \\<in> init \\<longrightarrow> p (a, x) .} \\<circ>\n          [: (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO r :]", "by (auto simp add: assert_demonic_refinement)"], ["proof (state)\nthis:\n  {.x.\n   p' x \\<and>\n   (\\<forall>a. a \\<in> init \\<longrightarrow> p (a, x)).} \\<circ>\n  [: (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO\n     (\\<lambda>(u, x) y. r (u, x) y \\<and> r' x y) :]\n  \\<le> {. \\<lambda>x.\n              \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x) .} \\<circ>\n        [: (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO r :]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> init;\n     \\<And>x u y.\n        \\<lbrakk>u \\<in> init; p' x; r (u, x) y\\<rbrakk>\n        \\<Longrightarrow> r' x y\\<rbrakk>\n    \\<Longrightarrow> {. p' .} \\<circ>\n                      ([: x \\<leadsto> (u,\n                       y) . u \\<in> init \\<and> x = y :] \\<circ>\n                       {. p .} \\<circ>\n                       [: r :]) \\<parallel>\n                      [: r' :]\n                      \\<le> [: x \\<leadsto> (u,\n                            y) . u \\<in> init \\<and> x = y :] \\<circ>\n                            {. p .} \\<circ>\n                            [: r :]", "from this"], ["proof (chain)\npicking this:\n  {.x.\n   p' x \\<and>\n   (\\<forall>a. a \\<in> init \\<longrightarrow> p (a, x)).} \\<circ>\n  [: (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO\n     (\\<lambda>(u, x) y. r (u, x) y \\<and> r' x y) :]\n  \\<le> {. \\<lambda>x.\n              \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x) .} \\<circ>\n        [: (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO r :]", "have \" {. x. p' x \\<and> (\\<forall>a. a \\<in> init \\<longrightarrow> p (a, x)) .} \\<circ> [: (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO (\\<lambda>(u, x) y. r (u, x) y \\<and> r' x y) :]\n            \\<le> {. \\<lambda>x. \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x) .} \\<circ> [: \\<lambda>x (u, y). u \\<in> init \\<and> x = y :] \\<circ> [: r :]\""], ["proof (prove)\nusing this:\n  {.x.\n   p' x \\<and>\n   (\\<forall>a. a \\<in> init \\<longrightarrow> p (a, x)).} \\<circ>\n  [: (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO\n     (\\<lambda>(u, x) y. r (u, x) y \\<and> r' x y) :]\n  \\<le> {. \\<lambda>x.\n              \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x) .} \\<circ>\n        [: (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO r :]\n\ngoal (1 subgoal):\n 1. {.x.\n     p' x \\<and>\n     (\\<forall>a. a \\<in> init \\<longrightarrow> p (a, x)).} \\<circ>\n    [: (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO\n       (\\<lambda>(u, x) y. r (u, x) y \\<and> r' x y) :]\n    \\<le> {. \\<lambda>x.\n                \\<forall>a.\n                   a \\<in> init \\<longrightarrow> p (a, x) .} \\<circ>\n          [: \\<lambda>x (u, y). u \\<in> init \\<and> x = y :] \\<circ>\n          [: r :]", "by (simp add: comp_assoc demonic_demonic)"], ["proof (state)\nthis:\n  {.x.\n   p' x \\<and>\n   (\\<forall>a. a \\<in> init \\<longrightarrow> p (a, x)).} \\<circ>\n  [: (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO\n     (\\<lambda>(u, x) y. r (u, x) y \\<and> r' x y) :]\n  \\<le> {. \\<lambda>x.\n              \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x) .} \\<circ>\n        [: \\<lambda>x (u, y). u \\<in> init \\<and> x = y :] \\<circ>\n        [: r :]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> init;\n     \\<And>x u y.\n        \\<lbrakk>u \\<in> init; p' x; r (u, x) y\\<rbrakk>\n        \\<Longrightarrow> r' x y\\<rbrakk>\n    \\<Longrightarrow> {. p' .} \\<circ>\n                      ([: x \\<leadsto> (u,\n                       y) . u \\<in> init \\<and> x = y :] \\<circ>\n                       {. p .} \\<circ>\n                       [: r :]) \\<parallel>\n                      [: r' :]\n                      \\<le> [: x \\<leadsto> (u,\n                            y) . u \\<in> init \\<and> x = y :] \\<circ>\n                            {. p .} \\<circ>\n                            [: r :]", "from this"], ["proof (chain)\npicking this:\n  {.x.\n   p' x \\<and>\n   (\\<forall>a. a \\<in> init \\<longrightarrow> p (a, x)).} \\<circ>\n  [: (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO\n     (\\<lambda>(u, x) y. r (u, x) y \\<and> r' x y) :]\n  \\<le> {. \\<lambda>x.\n              \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x) .} \\<circ>\n        [: \\<lambda>x (u, y). u \\<in> init \\<and> x = y :] \\<circ>\n        [: r :]", "have \"{. p' .} \\<circ> [: \\<lambda>x (u, y). u \\<in> init \\<and> x = y :] \\<circ> {. p .} \\<circ> [: \\<lambda>(u, x) y. r (u, x) y \\<and> r' x y :] \n            \\<le> [: x \\<leadsto> u, y. u \\<in> init \\<and> x = y :] \\<circ> {. p .} \\<circ> [: r :]\""], ["proof (prove)\nusing this:\n  {.x.\n   p' x \\<and>\n   (\\<forall>a. a \\<in> init \\<longrightarrow> p (a, x)).} \\<circ>\n  [: (\\<lambda>x (u, y). u \\<in> init \\<and> x = y) OO\n     (\\<lambda>(u, x) y. r (u, x) y \\<and> r' x y) :]\n  \\<le> {. \\<lambda>x.\n              \\<forall>a. a \\<in> init \\<longrightarrow> p (a, x) .} \\<circ>\n        [: \\<lambda>x (u, y). u \\<in> init \\<and> x = y :] \\<circ>\n        [: r :]\n\ngoal (1 subgoal):\n 1. {. p' .} \\<circ>\n    [: \\<lambda>x (u, y). u \\<in> init \\<and> x = y :] \\<circ>\n    {. p .} \\<circ>\n    [: \\<lambda>(u, x) y. r (u, x) y \\<and> r' x y :]\n    \\<le> [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n          {. p .} \\<circ>\n          [: r :]", "by (simp add: demonic_assert_comp assert_demonic_comp)"], ["proof (state)\nthis:\n  {. p' .} \\<circ>\n  [: \\<lambda>x (u, y). u \\<in> init \\<and> x = y :] \\<circ>\n  {. p .} \\<circ>\n  [: \\<lambda>(u, x) y. r (u, x) y \\<and> r' x y :]\n  \\<le> [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n        {. p .} \\<circ>\n        [: r :]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> init;\n     \\<And>x u y.\n        \\<lbrakk>u \\<in> init; p' x; r (u, x) y\\<rbrakk>\n        \\<Longrightarrow> r' x y\\<rbrakk>\n    \\<Longrightarrow> {. p' .} \\<circ>\n                      ([: x \\<leadsto> (u,\n                       y) . u \\<in> init \\<and> x = y :] \\<circ>\n                       {. p .} \\<circ>\n                       [: r :]) \\<parallel>\n                      [: r' :]\n                      \\<le> [: x \\<leadsto> (u,\n                            y) . u \\<in> init \\<and> x = y :] \\<circ>\n                            {. p .} \\<circ>\n                            [: r :]", "from this"], ["proof (chain)\npicking this:\n  {. p' .} \\<circ>\n  [: \\<lambda>x (u, y). u \\<in> init \\<and> x = y :] \\<circ>\n  {. p .} \\<circ>\n  [: \\<lambda>(u, x) y. r (u, x) y \\<and> r' x y :]\n  \\<le> [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n        {. p .} \\<circ>\n        [: r :]", "have \"{. p' .} \\<circ> ([: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ> {. p .} \\<circ> [: (u, x) \\<leadsto> y . r (u, x) y \\<and> r' x y :]) \n          \\<le> [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ> {. p .} \\<circ> [: r :]\""], ["proof (prove)\nusing this:\n  {. p' .} \\<circ>\n  [: \\<lambda>x (u, y). u \\<in> init \\<and> x = y :] \\<circ>\n  {. p .} \\<circ>\n  [: \\<lambda>(u, x) y. r (u, x) y \\<and> r' x y :]\n  \\<le> [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n        {. p .} \\<circ>\n        [: r :]\n\ngoal (1 subgoal):\n 1. {. p' .} \\<circ>\n    ([: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n     {. p .} \\<circ>\n     [: (u, x) \\<leadsto> y . r (u, x) y \\<and> r' x y :])\n    \\<le> [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n          {. p .} \\<circ>\n          [: r :]", "by (simp add: comp_assoc [THEN sym])"], ["proof (state)\nthis:\n  {. p' .} \\<circ>\n  ([: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n   {. p .} \\<circ>\n   [: (u, x) \\<leadsto> y . r (u, x) y \\<and> r' x y :])\n  \\<le> [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n        {. p .} \\<circ>\n        [: r :]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> init;\n     \\<And>x u y.\n        \\<lbrakk>u \\<in> init; p' x; r (u, x) y\\<rbrakk>\n        \\<Longrightarrow> r' x y\\<rbrakk>\n    \\<Longrightarrow> {. p' .} \\<circ>\n                      ([: x \\<leadsto> (u,\n                       y) . u \\<in> init \\<and> x = y :] \\<circ>\n                       {. p .} \\<circ>\n                       [: r :]) \\<parallel>\n                      [: r' :]\n                      \\<le> [: x \\<leadsto> (u,\n                            y) . u \\<in> init \\<and> x = y :] \\<circ>\n                            {. p .} \\<circ>\n                            [: r :]", "from A and this"], ["proof (chain)\npicking this:\n  a \\<in> init\n  {. p' .} \\<circ>\n  ([: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n   {. p .} \\<circ>\n   [: (u, x) \\<leadsto> y . r (u, x) y \\<and> r' x y :])\n  \\<le> [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n        {. p .} \\<circ>\n        [: r :]", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> init\n  {. p' .} \\<circ>\n  ([: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n   {. p .} \\<circ>\n   [: (u, x) \\<leadsto> y . r (u, x) y \\<and> r' x y :])\n  \\<le> [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n        {. p .} \\<circ>\n        [: r :]\n\ngoal (1 subgoal):\n 1. {. p' .} \\<circ>\n    ([: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n     {. p .} \\<circ>\n     [: r :]) \\<parallel>\n    [: r' :]\n    \\<le> [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n          {. p .} \\<circ>\n          [: r :]", "by  (unfold fusion_spec_local_a, simp)"], ["proof (state)\nthis:\n  {. p' .} \\<circ>\n  ([: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n   {. p .} \\<circ>\n   [: r :]) \\<parallel>\n  [: r' :]\n  \\<le> [: x \\<leadsto> (u, y) . u \\<in> init \\<and> x = y :] \\<circ>\n        {. p .} \\<circ>\n        [: r :]\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}