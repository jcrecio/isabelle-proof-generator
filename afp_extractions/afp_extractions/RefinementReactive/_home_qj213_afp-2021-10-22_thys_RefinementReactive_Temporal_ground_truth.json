{"file_name": "/home/qj213/afp-2021-10-22/thys/RefinementReactive/Temporal.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/RefinementReactive", "problem_names": ["lemma until_always: \"(INF n. (SUP i \\<in> {i. i < n} . - p i) \\<squnion> ((p :: nat \\<Rightarrow> 'a) n)) \\<le> p n\"", "lemma [simp]: \"(a \\<squnion> b) !! i = (a !! i) \\<squnion> (b !! i)\"", "lemma always_less [simp]: \"\\<box> p \\<le> p\"", "lemma always_and: \"\\<box> (p \\<sqinter> q) = (\\<box> p) \\<sqinter> (\\<box> q)\"", "lemma eventually_or: \"\\<diamond> (p \\<squnion> q) = (\\<diamond> p) \\<squnion> (\\<diamond> q)\"", "lemma neg_until_always: \"-(p until -p) = \\<box> p\"", "lemma neg_always_eventually: \"\\<box> p = - \\<diamond> (- p)\"", "lemma neg_true_until_always: \"-(\\<top> until -p) = \\<box> p\"", "lemma true_until_eventually: \"(\\<top> until p) = \\<diamond> p\"", "lemma AbsNat_plus: \"AbsNat (i + j) = AbsNat i + AbsNat j\"", "lemma AbsNat_zero [simp]: \"AbsNat 0 + i = i\"", "lemma \"(\\<box> r) OO (\\<box> r') \\<le> (\\<box> (r OO r'))\""], "translations": [["", "lemma until_always: \"(INF n. (SUP i \\<in> {i. i < n} . - p i) \\<squnion> ((p :: nat \\<Rightarrow> 'a) n)) \\<le> p n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> p n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> p n", "have \"(INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> (INF i\\<in>{i. i \\<le> n}. p i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n    \\<le> Inf (p ` {i. i \\<le> n})", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n    \\<le> Inf (p ` {i. i \\<le> 0})\n 2. \\<And>n.\n       (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n       \\<le> Inf (p ` {i. i \\<le> n}) \\<Longrightarrow>\n       (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n       \\<le> Inf (p ` {i. i \\<le> Suc n})", "have \"(INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> (SUP i\\<in>{i. i < 0}. - p i) \\<squnion> p 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n    \\<le> (SUP i\\<in>{i. i < 0}. - p i) \\<squnion> p 0", "by (rule INF_lower, simp)"], ["proof (state)\nthis:\n  (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n  \\<le> (SUP i\\<in>{i. i < 0}. - p i) \\<squnion> p 0\n\ngoal (2 subgoals):\n 1. (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n    \\<le> Inf (p ` {i. i \\<le> 0})\n 2. \\<And>n.\n       (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n       \\<le> Inf (p ` {i. i \\<le> n}) \\<Longrightarrow>\n       (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n       \\<le> Inf (p ` {i. i \\<le> Suc n})", "also"], ["proof (state)\nthis:\n  (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n  \\<le> (SUP i\\<in>{i. i < 0}. - p i) \\<squnion> p 0\n\ngoal (2 subgoals):\n 1. (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n    \\<le> Inf (p ` {i. i \\<le> 0})\n 2. \\<And>n.\n       (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n       \\<le> Inf (p ` {i. i \\<le> n}) \\<Longrightarrow>\n       (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n       \\<le> Inf (p ` {i. i \\<le> Suc n})", "have \"... \\<le> (INF i\\<in>{i. i \\<le> 0}. p i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP i\\<in>{i. i < 0}. - p i) \\<squnion> p 0\n    \\<le> Inf (p ` {i. i \\<le> 0})", "by simp"], ["proof (state)\nthis:\n  (SUP i\\<in>{i. i < 0}. - p i) \\<squnion> p 0\n  \\<le> Inf (p ` {i. i \\<le> 0})\n\ngoal (2 subgoals):\n 1. (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n    \\<le> Inf (p ` {i. i \\<le> 0})\n 2. \\<And>n.\n       (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n       \\<le> Inf (p ` {i. i \\<le> n}) \\<Longrightarrow>\n       (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n       \\<le> Inf (p ` {i. i \\<le> Suc n})", "finally"], ["proof (chain)\npicking this:\n  (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n  \\<le> Inf (p ` {i. i \\<le> 0})", "show \"(INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> (INF i\\<in>{i. i \\<le> 0}. p i)\""], ["proof (prove)\nusing this:\n  (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n  \\<le> Inf (p ` {i. i \\<le> 0})\n\ngoal (1 subgoal):\n 1. (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n    \\<le> Inf (p ` {i. i \\<le> 0})", "by simp"], ["proof (state)\nthis:\n  (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n  \\<le> Inf (p ` {i. i \\<le> 0})\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n       \\<le> Inf (p ` {i. i \\<le> n}) \\<Longrightarrow>\n       (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n       \\<le> Inf (p ` {i. i \\<le> Suc n})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n       \\<le> Inf (p ` {i. i \\<le> n}) \\<Longrightarrow>\n       (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n       \\<le> Inf (p ` {i. i \\<le> Suc n})", "fix n::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n       \\<le> Inf (p ` {i. i \\<le> n}) \\<Longrightarrow>\n       (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n       \\<le> Inf (p ` {i. i \\<le> Suc n})", "assume \"(INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> (INF i \\<in> {i. i \\<le> n}. p i)\""], ["proof (state)\nthis:\n  (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n  \\<le> Inf (p ` {i. i \\<le> n})\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n       \\<le> Inf (p ` {i. i \\<le> n}) \\<Longrightarrow>\n       (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n       \\<le> Inf (p ` {i. i \\<le> Suc n})", "also"], ["proof (state)\nthis:\n  (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n  \\<le> Inf (p ` {i. i \\<le> n})\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n       \\<le> Inf (p ` {i. i \\<le> n}) \\<Longrightarrow>\n       (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n       \\<le> Inf (p ` {i. i \\<le> Suc n})", "have \"\\<And> i . i \\<le> n \\<Longrightarrow> ... \\<le> p i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<le> n \\<Longrightarrow> Inf (p ` {i. i \\<le> n}) \\<le> p i", "by (rule INF_lower, simp)"], ["proof (state)\nthis:\n  ?i \\<le> n \\<Longrightarrow> Inf (p ` {i. i \\<le> n}) \\<le> p ?i\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n       \\<le> Inf (p ` {i. i \\<le> n}) \\<Longrightarrow>\n       (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n       \\<le> Inf (p ` {i. i \\<le> Suc n})", "finally"], ["proof (chain)\npicking this:\n  ?i1 \\<le> n \\<Longrightarrow>\n  (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> p ?i1", "have [simp]: \"\\<And> i . i \\<le> n \\<Longrightarrow> (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> p i\""], ["proof (prove)\nusing this:\n  ?i1 \\<le> n \\<Longrightarrow>\n  (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> p ?i1\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<le> n \\<Longrightarrow>\n       (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> p i", "by simp"], ["proof (state)\nthis:\n  ?i \\<le> n \\<Longrightarrow>\n  (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> p ?i\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n       \\<le> Inf (p ` {i. i \\<le> n}) \\<Longrightarrow>\n       (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n       \\<le> Inf (p ` {i. i \\<le> Suc n})", "show \"(INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> (INF i \\<in> {i. i \\<le> Suc n}. p i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n    \\<le> Inf (p ` {i. i \\<le> Suc n})", "proof (rule INF_greatest, safe, cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> Suc n; ?P3 i\\<rbrakk>\n       \\<Longrightarrow> (INF n.\n                             (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n                         \\<le> p i\n 2. \\<And>i.\n       \\<lbrakk>i \\<le> Suc n; \\<not> ?P3 i\\<rbrakk>\n       \\<Longrightarrow> (INF n.\n                             (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n                         \\<le> p i", "fix i::nat"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> Suc n; ?P3 i\\<rbrakk>\n       \\<Longrightarrow> (INF n.\n                             (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n                         \\<le> p i\n 2. \\<And>i.\n       \\<lbrakk>i \\<le> Suc n; \\<not> ?P3 i\\<rbrakk>\n       \\<Longrightarrow> (INF n.\n                             (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n                         \\<le> p i", "assume \"i \\<le> n\""], ["proof (state)\nthis:\n  i \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> Suc n; ?P3 i\\<rbrakk>\n       \\<Longrightarrow> (INF n.\n                             (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n                         \\<le> p i\n 2. \\<And>i.\n       \\<lbrakk>i \\<le> Suc n; \\<not> ?P3 i\\<rbrakk>\n       \\<Longrightarrow> (INF n.\n                             (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n                         \\<le> p i", "from this"], ["proof (chain)\npicking this:\n  i \\<le> n", "show \"(INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> p i\""], ["proof (prove)\nusing this:\n  i \\<le> n\n\ngoal (1 subgoal):\n 1. (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> p i", "by simp"], ["proof (state)\nthis:\n  (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> p i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> Suc n; \\<not> i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (INF n.\n                             (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n                         \\<le> p i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> Suc n; \\<not> i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (INF n.\n                             (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n                         \\<le> p i", "fix i::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> Suc n; \\<not> i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (INF n.\n                             (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n                         \\<le> p i", "have A: \"{i. i \\<le> n} = {i . i < Suc n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. i \\<le> n} = {i. i < Suc n}", "by auto"], ["proof (state)\nthis:\n  {i. i \\<le> n} = {i. i < Suc n}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> Suc n; \\<not> i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (INF n.\n                             (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n                         \\<le> p i", "have B: \"(SUP i\\<in>{i. i \\<le> n}. - p i) \\<le> - (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP i\\<in>{i. i \\<le> n}. - p i)\n    \\<le> - (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)", "by (metis (lifting, mono_tags) \\<open>(INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> (INF i\\<in>{i. i \\<le> n}. p i)\\<close> compl_mono uminus_INF)"], ["proof (state)\nthis:\n  (SUP i\\<in>{i. i \\<le> n}. - p i)\n  \\<le> - (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> Suc n; \\<not> i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (INF n.\n                             (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n                         \\<le> p i", "assume \"i \\<le> Suc n\" and \"\\<not> i \\<le> n\""], ["proof (state)\nthis:\n  i \\<le> Suc n\n  \\<not> i \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> Suc n; \\<not> i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (INF n.\n                             (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n                         \\<le> p i", "from this"], ["proof (chain)\npicking this:\n  i \\<le> Suc n\n  \\<not> i \\<le> n", "have [simp]: \"i = Suc n\""], ["proof (prove)\nusing this:\n  i \\<le> Suc n\n  \\<not> i \\<le> n\n\ngoal (1 subgoal):\n 1. i = Suc n", "by simp"], ["proof (state)\nthis:\n  i = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> Suc n; \\<not> i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (INF n.\n                             (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n                         \\<le> p i", "have \"(INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<sqinter> ((SUP i\\<in>{i. i \\<le> n}. - p i) \\<squnion> p (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n    \\<le> (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<sqinter>\n          ((SUP i\\<in>{i. i \\<le> n}. - p i) \\<squnion> p (Suc n))", "by (simp add: A, rule INF_lower, simp)"], ["proof (state)\nthis:\n  (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n  \\<le> (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<sqinter>\n        ((SUP i\\<in>{i. i \\<le> n}. - p i) \\<squnion> p (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> Suc n; \\<not> i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (INF n.\n                             (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n                         \\<le> p i", "also"], ["proof (state)\nthis:\n  (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n  \\<le> (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<sqinter>\n        ((SUP i\\<in>{i. i \\<le> n}. - p i) \\<squnion> p (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> Suc n; \\<not> i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (INF n.\n                             (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n                         \\<le> p i", "have \"... \\<le> ((INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<sqinter> ((- (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)) \\<squnion> p (Suc n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<sqinter>\n    ((SUP i\\<in>{i. i \\<le> n}. - p i) \\<squnion> p (Suc n))\n    \\<le> (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<sqinter>\n          (- (INF n.\n                 (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<squnion>\n           p (Suc n))", "by (rule inf_mono, simp_all, rule_tac y = \"- (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\" in order_trans, simp_all add: B)"], ["proof (state)\nthis:\n  (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<sqinter>\n  ((SUP i\\<in>{i. i \\<le> n}. - p i) \\<squnion> p (Suc n))\n  \\<le> (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<sqinter>\n        (- (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<squnion>\n         p (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> Suc n; \\<not> i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (INF n.\n                             (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n                         \\<le> p i", "also"], ["proof (state)\nthis:\n  (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<sqinter>\n  ((SUP i\\<in>{i. i \\<le> n}. - p i) \\<squnion> p (Suc n))\n  \\<le> (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<sqinter>\n        (- (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<squnion>\n         p (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> Suc n; \\<not> i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (INF n.\n                             (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n                         \\<le> p i", "have \"... \\<le> p i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<sqinter>\n    (- (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<squnion>\n     p (Suc n))\n    \\<le> p i", "by (simp add: inf_sup_distrib1 inf_compl_bot)"], ["proof (state)\nthis:\n  (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<sqinter>\n  (- (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<squnion>\n   p (Suc n))\n  \\<le> p i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> Suc n; \\<not> i \\<le> n\\<rbrakk>\n       \\<Longrightarrow> (INF n.\n                             (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n                         \\<le> p i", "finally"], ["proof (chain)\npicking this:\n  (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> p i", "show \"(INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> p i\""], ["proof (prove)\nusing this:\n  (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> p i\n\ngoal (1 subgoal):\n 1. (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> p i", "by simp"], ["proof (state)\nthis:\n  (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> p i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n  \\<le> Inf (p ` {i. i \\<le> Suc n})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n  \\<le> Inf (p ` {i. i \\<le> n})\n\ngoal (1 subgoal):\n 1. (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> p n", "also"], ["proof (state)\nthis:\n  (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n)\n  \\<le> Inf (p ` {i. i \\<le> n})\n\ngoal (1 subgoal):\n 1. (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> p n", "have \"(INF i\\<in>{i. i \\<le> n}. p i) \\<le> p n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf (p ` {i. i \\<le> n}) \\<le> p n", "by (rule INF_lower, auto)"], ["proof (state)\nthis:\n  Inf (p ` {i. i \\<le> n}) \\<le> p n\n\ngoal (1 subgoal):\n 1. (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> p n", "finally"], ["proof (chain)\npicking this:\n  (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> p n", "show \"(INF n. (SUP i \\<in> {i. i < n} . - p i) \\<squnion> ((p :: nat \\<Rightarrow> 'a) n)) \\<le> p n\""], ["proof (prove)\nusing this:\n  (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> p n\n\ngoal (1 subgoal):\n 1. (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> p n", "by simp"], ["proof (state)\nthis:\n  (INF n. (SUP i\\<in>{i. i < n}. - p i) \\<squnion> p n) \\<le> p n\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text\\<open>\n  We prove now a number of results of the temporal class.\n\\<close>"], ["", "context temporal\n    begin"], ["", "lemma [simp]: \"(a \\<squnion> b) !! i = (a !! i) \\<squnion> (b !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<squnion> b) !! i = a !! i \\<squnion> b !! i", "by (subst compl_eq_compl_iff [THEN sym], simp)"], ["", "lemma always_less [simp]: \"\\<box> p \\<le> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<box> p \\<le> p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<box> p \\<le> p", "have \"\\<box> p \\<le> p !! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<box> p \\<le> p !! 0", "by (unfold always_def, rule INF_lower, simp)"], ["proof (state)\nthis:\n  \\<box> p \\<le> p !! 0\n\ngoal (1 subgoal):\n 1. \\<box> p \\<le> p", "also"], ["proof (state)\nthis:\n  \\<box> p \\<le> p !! 0\n\ngoal (1 subgoal):\n 1. \\<box> p \\<le> p", "have \"p !! 0 = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p !! 0 = p", "by simp"], ["proof (state)\nthis:\n  p !! 0 = p\n\ngoal (1 subgoal):\n 1. \\<box> p \\<le> p", "finally"], ["proof (chain)\npicking this:\n  \\<box> p \\<le> p", "show \"\\<box> p \\<le> p\""], ["proof (prove)\nusing this:\n  \\<box> p \\<le> p\n\ngoal (1 subgoal):\n 1. \\<box> p \\<le> p", "by simp"], ["proof (state)\nthis:\n  \\<box> p \\<le> p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma always_and: \"\\<box> (p \\<sqinter> q) = (\\<box> p) \\<sqinter> (\\<box> q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<box> (p \\<sqinter> q) = \\<box> p \\<sqinter> \\<box> q", "by (simp add: always_def INF_inf_distrib)"], ["", "lemma eventually_or: \"\\<diamond> (p \\<squnion> q) = (\\<diamond> p) \\<squnion> (\\<diamond> q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<diamond> (p \\<squnion> q) = \\<diamond> p \\<squnion> \\<diamond> q", "by (simp add: eventually_def SUP_sup_distrib)"], ["", "lemma neg_until_always: \"-(p until -p) = \\<box> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (p until - p) = \\<box> p", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. - (p until - p) \\<le> \\<box> p\n 2. \\<box> p \\<le> - (p until - p)", "show \"- (p until - p) \\<le> \\<box> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (p until - p) \\<le> \\<box> p", "by (simp add: until_def always_def uminus_SUP uminus_INF, rule INF_greatest, cut_tac p = \"\\<lambda> n . p !! n\" in until_always, simp)"], ["proof (state)\nthis:\n  - (p until - p) \\<le> \\<box> p\n\ngoal (1 subgoal):\n 1. \\<box> p \\<le> - (p until - p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<box> p \\<le> - (p until - p)", "have \"\\<And> n . \\<box> p \\<le> p !! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. \\<box> p \\<le> p !! n", "by (simp add: always_def INF_lower)"], ["proof (state)\nthis:\n  \\<box> p \\<le> p !! ?n\n\ngoal (1 subgoal):\n 1. \\<box> p \\<le> - (p until - p)", "also"], ["proof (state)\nthis:\n  \\<box> p \\<le> p !! ?n\n\ngoal (1 subgoal):\n 1. \\<box> p \\<le> - (p until - p)", "have \"\\<And> n . p !! n \\<le> (SUP x\\<in>{i. i < n}. (- p) !! x) \\<squnion> p !! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. p !! n \\<le> Sup ((!!) (- p) ` {i. i < n}) \\<squnion> p !! n", "by simp"], ["proof (state)\nthis:\n  p !! ?n \\<le> Sup ((!!) (- p) ` {i. i < ?n}) \\<squnion> p !! ?n\n\ngoal (1 subgoal):\n 1. \\<box> p \\<le> - (p until - p)", "finally"], ["proof (chain)\npicking this:\n  \\<box> p \\<le> Sup ((!!) (- p) ` {i. i < ?n1}) \\<squnion> p !! ?n1", "show \"\\<box> p \\<le> -(p until -p)\""], ["proof (prove)\nusing this:\n  \\<box> p \\<le> Sup ((!!) (- p) ` {i. i < ?n1}) \\<squnion> p !! ?n1\n\ngoal (1 subgoal):\n 1. \\<box> p \\<le> - (p until - p)", "apply (simp add: until_def uminus_SUP uminus_INF)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<box> p\n        \\<le> Sup ((!!) (- p) ` {i. i < n}) \\<squnion>\n              p !! n) \\<Longrightarrow>\n    \\<box> p \\<le> (INF x. Sup ((!!) (- p) ` {i. i < x}) \\<squnion> p !! x)", "by (rule INF_greatest, simp)"], ["proof (state)\nthis:\n  \\<box> p \\<le> - (p until - p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma neg_always_eventually: \"\\<box> p = - \\<diamond> (- p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<box> p = - \\<diamond> (- p)", "by (simp add: fun_eq_iff always_def eventually_def until_def uminus_SUP)"], ["", "lemma neg_true_until_always: \"-(\\<top> until -p) = \\<box> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (\\<top> until - p) = \\<box> p", "by (simp add: fun_eq_iff always_def until_def uminus_SUP uminus_INF)"], ["", "lemma true_until_eventually: \"(\\<top> until p) = \\<diamond> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> until p = \\<diamond> p", "by (cut_tac p = \"-p\" in neg_always_eventually, cut_tac p = \"-p\" in neg_true_until_always, simp)"], ["", "end"], ["", "text\\<open>\n  Boolean algebras with $b!!i = b$ form a temporal class.\n\\<close>"], ["", "instantiation bool :: temporal\n    begin"], ["", "definition at_bool_def [simp]: \"(p::bool) !! i = p\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(bool, temporal_class)", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a i j. a !! i !! j = a !! (i + j)\n 2. \\<And>a. a !! 0 = a\n 3. \\<And>i. \\<top> !! i = \\<top>\n 4. \\<And>a i. - a !! i = (- a) !! i\n 5. \\<And>a b i. (a \\<sqinter> b) !! i = a !! i \\<sqinter> b !! i", "qed auto"], ["", "end"], ["", "type_synonym 'a trace = \"nat \\<Rightarrow> 'a\""], ["", "text\\<open>\n  Asumming that $\\tv a::temporal$ is a type of class $temporal$, and $\\tv b$ is an arbitrary type,\n  we would like to create the instantiation of $\\tv b\\ trace \\Rightarrow \\tv a$ as a temporal\n  class. However Isabelle allows only instatiations of functions from a class to another \n  class. To solve this problem we introduce a new class called trace with an operation\n  $\\mathit{suffix}::\\tv a \\Rightarrow nat \\Rightarrow \\tv a$ where \n  $\\mathit{suffix}\\;a\\;i\\;j = (a[i..])\\; j = a\\;(i+j)$ when\n  $a$ is a trace with elements of some type $\\tv b$ ($\\tv a = nat \\Rightarrow \\tv b$). \n\\<close>"], ["", "class trace =\n    fixes suffix :: \"'a \\<Rightarrow> nat \\<Rightarrow> 'a\" (\"_[_ ..]\" [80, 15] 80)\n    assumes [simp]: \"a[i..][j..] = a[i + j..]\"\n    assumes [simp]: \"a[0..] = a\"\n    begin"], ["", "definition \"next_trace\" :: \"'a \\<Rightarrow> 'a\"  (\"\\<odot> (_)\" [900] 900) where\n        \"\\<odot> p = p[Suc 0..]\""], ["", "end"], ["", "instantiation \"fun\" :: (trace, temporal) temporal\n    begin"], ["", "definition at_fun_def: \"(P:: 'a \\<Rightarrow> 'b) !! i = (\\<lambda> x . (P (x[i..])) !! i)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, temporal_class)", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a i j. a !! i !! j = a !! (i + j)\n 2. \\<And>a. a !! 0 = a\n 3. \\<And>i. \\<top> !! i = \\<top>\n 4. \\<And>a i. - a !! i = (- a) !! i\n 5. \\<And>a b i. (a \\<sqinter> b) !! i = a !! i \\<sqinter> b !! i", "qed  (simp_all add: at_fun_def add.commute fun_eq_iff le_fun_def)"], ["", "end"], ["", "text\\<open>\n  In the last part of our formalization, we need to instantiate the functions\n  from $nat$ to some arbitrary type $\\tv a$ as a trace class. However, this again is not\n  possible using the instatiation mechanism of Isabelle. We solve this problem\n  by creating another class called $nat$, and then we instatiate the functions\n  from $\\tv a::nat$ to $\\tv b$ as traces. The class $nat$ is defined such that if we\n  have a type $\\tv a::nat$, then $\\tv a$ is isomorphic to the type $nat$. \n\\<close>"], ["", "class nat = zero + plus + minus +\n    fixes RepNat :: \"'a \\<Rightarrow> nat\"\n    fixes AbsNat :: \"nat \\<Rightarrow> 'a\"\n    assumes [simp]: \"RepNat (AbsNat n) = n\"\n    and [simp]: \"AbsNat (RepNat x) = x\"\n    and zero_Nat_def: \"0 = AbsNat 0\"\n    and plus_Nat_def: \"a + b = AbsNat (RepNat a + RepNat b)\"\n    and minus_Nat_def: \"a - b = AbsNat (RepNat a - RepNat b)\"\n  begin"], ["", "lemma AbsNat_plus: \"AbsNat (i + j) = AbsNat i + AbsNat j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AbsNat (i + j) = AbsNat i + AbsNat j", "by (simp add: plus_Nat_def)"], ["", "lemma AbsNat_zero [simp]: \"AbsNat 0 + i = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AbsNat 0 + i = i", "by (simp add: plus_Nat_def)"], ["", "subclass comm_monoid_diff"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.comm_monoid_diff (+) (-) (0::'a)", "apply (unfold_locales)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a b. a + b - a = b\n 4. \\<And>a b c. a - b - c = a - (b + c)\n 5. \\<And>a. (0::'a) + a = a\n 6. \\<And>a. (0::'a) - a = (0::'a)", "apply (simp_all add: plus_Nat_def zero_Nat_def minus_Nat_def add.assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b. AbsNat (RepNat a + RepNat b) = AbsNat (RepNat b + RepNat a)", "by (simp add: add.commute)"], ["", "end"], ["", "text\\<open>\n  The type natural numbers is an instantiation of the class $nat$.\n\\<close>"], ["", "instantiation nat :: nat\n    begin"], ["", "definition RepNat_nat_def [simp]: \"(RepNat:: nat \\<Rightarrow> nat) = id\""], ["", "definition AbsNat_nat_def [simp]: \"(AbsNat:: nat \\<Rightarrow> nat) = id\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(nat, nat_class)", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>n. RepNat (AbsNat n) = n\n 2. \\<And>x. AbsNat (RepNat x) = x\n 3. 0 = AbsNat 0\n 4. \\<And>a b. a + b = AbsNat (RepNat a + RepNat b)\n 5. \\<And>a b. a - b = AbsNat (RepNat a - RepNat b)", "qed auto"], ["", "end"], ["", "text\\<open>\n  Finally, functions from $\\tv a::nat$ to some arbitrary type $\\tv b$ are instatiated\n  as a trace class. \n\\<close>"], ["", "instantiation \"fun\" :: (nat, type) trace\n    begin"], ["", "definition at_trace_def [simp]: \"((t :: 'a \\<Rightarrow> 'b)[i..]) j = (t  (AbsNat i + j))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, trace_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a i j. a[i ..][j ..] = a[i + j ..]\n 2. \\<And>a. a[0 ..] = a", "qed (simp_all add: fun_eq_iff AbsNat_plus add.assoc)"], ["", "end"], ["", "text\\<open>\n  By putting together all class definitions and instatiations introduced so far, we obtain the\n  temporal class structure for predicates on traces with arbitrary number of parameters.\n\n  For example in the next lemma $r$ and $r'$ are predicate relations, and the operator\n  always is available for them as a consequence of the above construction.\n\\<close>"], ["", "lemma \"(\\<box> r) OO (\\<box> r') \\<le> (\\<box> (r OO r'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<box> r OO \\<box> r' \\<le> \\<box> (r OO r')", "by (simp add: le_fun_def always_def at_fun_def, auto)"], ["", "end"]]}