{"file_name": "/home/qj213/afp-2021-10-22/thys/Prpu_Maxflow/Fifo_Push_Relabel.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Prpu_Maxflow", "problem_names": ["lemma Q_invar_when_discharged1: \"\\<lbrakk>QD_invar u f Q; excess f u = 0\\<rbrakk> \\<Longrightarrow> Q_invar f Q\"", "lemma Q_invar_when_discharged2: \"\\<lbrakk>QD_invar u f Q; excess f u \\<noteq> 0\\<rbrakk> \\<Longrightarrow> Q_invar f (Q@[u])\"", "lemma (in Labeling) push_no_activate_pres_QD_invar:\n  fixes v\n  assumes INV: \"QD_invar u f Q\"\n  assumes PRE: \"push_precond f l (u,v)\"\n  assumes VC: \"s=v \\<or> t=v \\<or> excess f v \\<noteq> 0\"  \n  shows \"QD_invar u (push_effect f (u,v)) Q\"", "lemma (in Labeling) push_activate_pres_QD_invar:  \n  fixes v\n  assumes INV: \"QD_invar u f Q\"\n  assumes PRE: \"push_precond f l (u,v)\"\n  assumes VC: \"s\\<noteq>v\" \"t\\<noteq>v\" and [simp]: \"excess f v = 0\"  \n  shows \"QD_invar u (push_effect f (u,v)) (Q@[v])\"", "theorem fifo_discharge_correct[THEN order_trans, refine_vcg]:\n  assumes DINV: \"Height_Bounded_Labeling c s t f l\"\n  assumes QINV: \"Q_invar f Q\" and QNE: \"Q\\<noteq>[]\"\n  shows \"fifo_discharge f l Q \\<le> SPEC (\\<lambda>(f',l',Q'). \n      Height_Bounded_Labeling c s t f' l' \n    \\<and> Q_invar f' Q' \n    \\<and> ((f',l'),(f,l))\\<in>gap_algo_rel\\<^sup>+\n  )\"", "theorem fifo_push_relabel_correct: \n  \"fifo_push_relabel \\<le> SPEC isMaxFlow\""], "translations": [["", "lemma Q_invar_when_discharged1: \"\\<lbrakk>QD_invar u f Q; excess f u = 0\\<rbrakk> \\<Longrightarrow> Q_invar f Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>QD_invar u f Q; excess f u = (0::'capacity)\\<rbrakk>\n    \\<Longrightarrow> Q_invar f Q", "unfolding Q_invar_def QD_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> V - {s, t} \\<and>\n             distinct Q \\<and>\n             set Q =\n             {v \\<in> V - {s, t, u}. excess f v \\<noteq> (0::'capacity)};\n     excess f u = (0::'capacity)\\<rbrakk>\n    \\<Longrightarrow> distinct Q \\<and>\n                      set Q =\n                      {v \\<in> V - {s, t}.\n                       excess f v \\<noteq> (0::'capacity)}", "by auto"], ["", "lemma Q_invar_when_discharged2: \"\\<lbrakk>QD_invar u f Q; excess f u \\<noteq> 0\\<rbrakk> \\<Longrightarrow> Q_invar f (Q@[u])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>QD_invar u f Q; excess f u \\<noteq> (0::'capacity)\\<rbrakk>\n    \\<Longrightarrow> Q_invar f (Q @ [u])", "unfolding Q_invar_def QD_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> V - {s, t} \\<and>\n             distinct Q \\<and>\n             set Q =\n             {v \\<in> V - {s, t, u}. excess f v \\<noteq> (0::'capacity)};\n     excess f u \\<noteq> (0::'capacity)\\<rbrakk>\n    \\<Longrightarrow> distinct (Q @ [u]) \\<and>\n                      set (Q @ [u]) =\n                      {v \\<in> V - {s, t}.\n                       excess f v \\<noteq> (0::'capacity)}", "by auto"], ["", "lemma (in Labeling) push_no_activate_pres_QD_invar:\n  fixes v\n  assumes INV: \"QD_invar u f Q\"\n  assumes PRE: \"push_precond f l (u,v)\"\n  assumes VC: \"s=v \\<or> t=v \\<or> excess f v \\<noteq> 0\"  \n  shows \"QD_invar u (push_effect f (u,v)) Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. QD_invar u (push_effect f (u, v)) Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. QD_invar u (push_effect f (u, v)) Q", "interpret push_effect_locale c s t f l u v"], ["proof (prove)\ngoal (1 subgoal):\n 1. push_effect_locale c s t f l u v", "using PRE"], ["proof (prove)\nusing this:\n  push_precond f l (u, v)\n\ngoal (1 subgoal):\n 1. push_effect_locale c s t f l u v", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. QD_invar u f' Q", "from excess_non_negative \\<Delta>_positive"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>V - {s, t}. (0::'a) \\<le> excess f v\n  (0::'a) < \\<Delta>", "have \"excess f v + \\<Delta> \\<noteq> 0\" if \"v\\<notin>{s,t}\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V - {s, t}. (0::'a) \\<le> excess f v\n  (0::'a) < \\<Delta>\n\ngoal (1 subgoal):\n 1. excess f v + \\<Delta> \\<noteq> (0::'a)", "using that"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V - {s, t}. (0::'a) \\<le> excess f v\n  (0::'a) < \\<Delta>\n  v \\<notin> {s, t}\n\ngoal (1 subgoal):\n 1. excess f v + \\<Delta> \\<noteq> (0::'a)", "by force"], ["proof (state)\nthis:\n  v \\<notin> {s, t} \\<Longrightarrow> excess f v + \\<Delta> \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. QD_invar u f' Q", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<notin> {s, t} \\<Longrightarrow> excess f v + \\<Delta> \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. QD_invar u f' Q", "using VC INV"], ["proof (prove)\nusing this:\n  v \\<notin> {s, t} \\<Longrightarrow> excess f v + \\<Delta> \\<noteq> (0::'a)\n  s = v \\<or> t = v \\<or> excess f v \\<noteq> (0::'a)\n  QD_invar u f Q\n\ngoal (1 subgoal):\n 1. QD_invar u f' Q", "unfolding QD_invar_def"], ["proof (prove)\nusing this:\n  v \\<notin> {s, t} \\<Longrightarrow> excess f v + \\<Delta> \\<noteq> (0::'a)\n  s = v \\<or> t = v \\<or> excess f v \\<noteq> (0::'a)\n  u \\<in> V - {s, t} \\<and>\n  distinct Q \\<and>\n  set Q = {v \\<in> V - {s, t, u}. excess f v \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. u \\<in> V - {s, t} \\<and>\n    distinct Q \\<and>\n    set Q = {v \\<in> V - {s, t, u}. excess f' v \\<noteq> (0::'a)}", "by (auto simp: excess'_if split!: if_splits)"], ["proof (state)\nthis:\n  QD_invar u f' Q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in Labeling) push_activate_pres_QD_invar:  \n  fixes v\n  assumes INV: \"QD_invar u f Q\"\n  assumes PRE: \"push_precond f l (u,v)\"\n  assumes VC: \"s\\<noteq>v\" \"t\\<noteq>v\" and [simp]: \"excess f v = 0\"  \n  shows \"QD_invar u (push_effect f (u,v)) (Q@[v])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. QD_invar u (push_effect f (u, v)) (Q @ [v])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. QD_invar u (push_effect f (u, v)) (Q @ [v])", "interpret push_effect_locale c s t f l u v"], ["proof (prove)\ngoal (1 subgoal):\n 1. push_effect_locale c s t f l u v", "using PRE"], ["proof (prove)\nusing this:\n  push_precond f l (u, v)\n\ngoal (1 subgoal):\n 1. push_effect_locale c s t f l u v", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. QD_invar u f' (Q @ [v])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. QD_invar u f' (Q @ [v])", "using VC INV \\<Delta>_positive"], ["proof (prove)\nusing this:\n  s \\<noteq> v\n  t \\<noteq> v\n  QD_invar u f Q\n  (0::'a) < \\<Delta>\n\ngoal (1 subgoal):\n 1. QD_invar u f' (Q @ [v])", "unfolding QD_invar_def"], ["proof (prove)\nusing this:\n  s \\<noteq> v\n  t \\<noteq> v\n  u \\<in> V - {s, t} \\<and>\n  distinct Q \\<and>\n  set Q = {v \\<in> V - {s, t, u}. excess f v \\<noteq> (0::'a)}\n  (0::'a) < \\<Delta>\n\ngoal (1 subgoal):\n 1. u \\<in> V - {s, t} \\<and>\n    distinct (Q @ [v]) \\<and>\n    set (Q @ [v]) = {v \\<in> V - {s, t, u}. excess f' v \\<noteq> (0::'a)}", "by (auto simp: excess'_if split!: if_splits)"], ["proof (state)\nthis:\n  QD_invar u f' (Q @ [v])\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Main theorem for the discharge operation:\n  It maintains a height bounded labeling, the invariant for the FIFO queue,\n  and only performs valid steps due to the generic push-relabel algorithm with\n  gap-heuristics.\n\\<close>"], ["", "theorem fifo_discharge_correct[THEN order_trans, refine_vcg]:\n  assumes DINV: \"Height_Bounded_Labeling c s t f l\"\n  assumes QINV: \"Q_invar f Q\" and QNE: \"Q\\<noteq>[]\"\n  shows \"fifo_discharge f l Q \\<le> SPEC (\\<lambda>(f',l',Q'). \n      Height_Bounded_Labeling c s t f' l' \n    \\<and> Q_invar f' Q' \n    \\<and> ((f',l'),(f,l))\\<in>gap_algo_rel\\<^sup>+\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fifo_discharge f l Q\n    \\<le> SPEC\n           (\\<lambda>(f', l', Q').\n               Height_Bounded_Labeling c s t f' l' \\<and>\n               Q_invar f' Q' \\<and>\n               ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>+)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fifo_discharge f l Q\n    \\<le> SPEC\n           (\\<lambda>(f', l', Q').\n               Height_Bounded_Labeling c s t f' l' \\<and>\n               Q_invar f' Q' \\<and>\n               ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>+)", "from QNE"], ["proof (chain)\npicking this:\n  Q \\<noteq> []", "obtain u Qr where [simp]: \"Q=u#Qr\""], ["proof (prove)\nusing this:\n  Q \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>u Qr. Q = u # Qr \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases Q) auto"], ["proof (state)\nthis:\n  Q = u # Qr\n\ngoal (1 subgoal):\n 1. fifo_discharge f l Q\n    \\<le> SPEC\n           (\\<lambda>(f', l', Q').\n               Height_Bounded_Labeling c s t f' l' \\<and>\n               Q_invar f' Q' \\<and>\n               ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>+)", "from QINV"], ["proof (chain)\npicking this:\n  Q_invar f Q", "have U: \"u\\<in>V-{s,t}\" \"QD_invar u f Qr\" and XU_orig: \"excess f u \\<noteq> 0\""], ["proof (prove)\nusing this:\n  Q_invar f Q\n\ngoal (1 subgoal):\n 1. (u \\<in> V - {s, t} &&& QD_invar u f Qr) &&&\n    excess f u \\<noteq> (0::'capacity)", "by (auto simp: Q_invar_def QD_invar_def)"], ["proof (state)\nthis:\n  u \\<in> V - {s, t}\n  QD_invar u f Qr\n  excess f u \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. fifo_discharge f l Q\n    \\<le> SPEC\n           (\\<lambda>(f', l', Q').\n               Height_Bounded_Labeling c s t f' l' \\<and>\n               Q_invar f' Q' \\<and>\n               ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>+)", "have [simp, intro!]: \"finite {v. (u, v) \\<in> cfE_of f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {v. (u, v) \\<in> cfE_of f}", "apply (rule finite_subset[where B=V])"], ["proof (prove)\ngoal (2 subgoals):\n 1. {v. (u, v) \\<in> cfE_of f} \\<subseteq> V\n 2. finite V", "using cfE_of_ss_VxV"], ["proof (prove)\nusing this:\n  cfE_of ?f \\<subseteq> V \\<times> V\n\ngoal (2 subgoals):\n 1. {v. (u, v) \\<in> cfE_of f} \\<subseteq> V\n 2. finite V", "by auto"], ["proof (state)\nthis:\n  finite {v. (u, v) \\<in> cfE_of f}\n\ngoal (1 subgoal):\n 1. fifo_discharge f l Q\n    \\<le> SPEC\n           (\\<lambda>(f', l', Q').\n               Height_Bounded_Labeling c s t f' l' \\<and>\n               Q_invar f' Q' \\<and>\n               ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>+)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fifo_discharge f l Q\n    \\<le> SPEC\n           (\\<lambda>(f', l', Q').\n               Height_Bounded_Labeling c s t f' l' \\<and>\n               Q_invar f' Q' \\<and>\n               ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>+)", "using U"], ["proof (prove)\nusing this:\n  u \\<in> V - {s, t}\n  QD_invar u f Qr\n\ngoal (1 subgoal):\n 1. fifo_discharge f l Q\n    \\<le> SPEC\n           (\\<lambda>(f', l', Q').\n               Height_Bounded_Labeling c s t f' l' \\<and>\n               Q_invar f' Q' \\<and>\n               ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>+)", "unfolding fifo_discharge_def fifo_push_def fifo_gap_relabel_def"], ["proof (prove)\nusing this:\n  u \\<in> V - {s, t}\n  QD_invar u f Qr\n\ngoal (1 subgoal):\n 1. assert (Q \\<noteq> []) \\<bind>\n    (\\<lambda>_.\n        let u = hd Q; Q = tl Q\n        in assert\n            (u \\<in> V \\<and> u \\<noteq> s \\<and> u \\<noteq> t) \\<bind>\n           (\\<lambda>_.\n               FOREACH\\<^sub>C {v. (u, v) \\<in> cfE_of f}\n                (\\<lambda>(f, l, Q). excess f u \\<noteq> (0::'capacity))\n                (\\<lambda>v (f, l, Q).\n                    if l u = l v + 1\n                    then (case (u, v) of\n                          (u, v) \\<Rightarrow>\n                            assert (push_precond f l (u, v)) \\<bind>\n                            (\\<lambda>_.\n                                assert (Labeling c s t f l) \\<bind>\n                                (\\<lambda>_.\n                                    let Q =\n    if v \\<noteq> s \\<and> v \\<noteq> t \\<and> excess f v = (0::'capacity)\n    then Q @ [v] else Q\n                                    in return\n  (push_effect f (u, v), Q)))) \\<bind>\n                         (\\<lambda>(f', Q).\n                             assert\n                              (\\<forall>v'.\n                                  v' \\<noteq> v \\<longrightarrow>\n                                  cf_of f' (u, v') =\n                                  cf_of f (u, v')) \\<bind>\n                             (\\<lambda>_. return (f', l, Q)))\n                    else return (f, l, Q))\n                (f, l, Q) \\<bind>\n               (\\<lambda>(f, l, Q).\n                   if excess f u \\<noteq> (0::'capacity)\n                   then assert (u \\<in> V - {s, t}) \\<bind>\n                        (\\<lambda>_.\n                            assert\n                             (Height_Bounded_Labeling c s t f l) \\<bind>\n                            (\\<lambda>_.\n                                let Q = Q @ [u]\n                                in assert (relabel_precond f l u) \\<bind>\n                                   (\\<lambda>_.\n assert\n  (l u < 2 * card V \\<and> relabel_effect f l u u < 2 * card V) \\<bind>\n (\\<lambda>_. let l = gap_relabel_effect f l u in return (l, Q))))) \\<bind>\n                        (\\<lambda>(l, Q). return (f, l, Q))\n                   else return (f, l, Q))))\n    \\<le> SPEC\n           (\\<lambda>(f', l', Q').\n               Height_Bounded_Labeling c s t f' l' \\<and>\n               Q_invar f' Q' \\<and>\n               ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>+)", "apply (simp only: split nres_monad_laws)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> V - {s, t}; QD_invar u f Qr\\<rbrakk>\n    \\<Longrightarrow> assert (Q \\<noteq> []) \\<bind>\n                      (\\<lambda>_.\n                          let u = hd Q; Q = tl Q\n                          in assert\n                              (u \\<in> V \\<and>\n                               u \\<noteq> s \\<and> u \\<noteq> t) \\<bind>\n                             (\\<lambda>_.\n                                 FOREACH\\<^sub>C {v. (u, v) \\<in> cfE_of f}\n                                  (\\<lambda>(f, l, Q).\nexcess f u \\<noteq> (0::'capacity))\n                                  (\\<lambda>v (f, l, Q).\nif l u = l v + 1\nthen assert (push_precond f l (u, v)) \\<bind>\n     (\\<lambda>x.\n         assert (Labeling c s t f l) \\<bind>\n         (\\<lambda>x.\n             (let Q = if v \\<noteq> s \\<and>\n                         v \\<noteq> t \\<and> excess f v = (0::'capacity)\n                      then Q @ [v] else Q\n              in return (push_effect f (u, v), Q)) \\<bind>\n             (\\<lambda>(f', Q).\n                 assert\n                  (\\<forall>v'.\n                      v' \\<noteq> v \\<longrightarrow>\n                      cf_of f' (u, v') = cf_of f (u, v')) \\<bind>\n                 (\\<lambda>_. return (f', l, Q)))))\nelse return (f, l, Q))\n                                  (f, l, Q) \\<bind>\n                                 (\\<lambda>(f, l, Q).\n                                     if excess f u \\<noteq> (0::'capacity)\n                                     then assert\n     (u \\<in> V - {s, t}) \\<bind>\n    (\\<lambda>x.\n        assert (Height_Bounded_Labeling c s t f l) \\<bind>\n        (\\<lambda>x.\n            (let Q = Q @ [u]\n             in assert (relabel_precond f l u) \\<bind>\n                (\\<lambda>_.\n                    assert\n                     (l u < 2 * card V \\<and>\n                      relabel_effect f l u u < 2 * card V) \\<bind>\n                    (\\<lambda>_.\n                        let l = gap_relabel_effect f l u\n                        in return (l, Q)))) \\<bind>\n            (\\<lambda>(l, Q). return (f, l, Q))))\n                                     else return (f, l, Q))))\n                      \\<le> SPEC\n                             (\\<lambda>(f', l', Q').\n                                 Height_Bounded_Labeling c s t f' l' \\<and>\n                                 Q_invar f' Q' \\<and>\n                                 ((f', l'), f, l)\n                                 \\<in> gap_algo_rel\\<^sup>+)", "apply (rewrite in \"FOREACHc _ _ \\<hole> _\" vcg_intro_frame)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> V - {s, t}; QD_invar u f Qr\\<rbrakk>\n    \\<Longrightarrow> assert (Q \\<noteq> []) \\<bind>\n                      (\\<lambda>_.\n                          let u = hd Q; Q = tl Q\n                          in assert\n                              (u \\<in> V \\<and>\n                               u \\<noteq> s \\<and> u \\<noteq> t) \\<bind>\n                             (\\<lambda>_.\n                                 FOREACH\\<^sub>C {v. (u, v) \\<in> cfE_of f}\n                                  (\\<lambda>(f, l, Q).\nexcess f u \\<noteq> (0::'capacity))\n                                  (\\<lambda>v (f, l, Q).\nVCG_FRAME\n (if l u = l v + 1\n  then assert (push_precond f l (u, v)) \\<bind>\n       (\\<lambda>x.\n           assert (Labeling c s t f l) \\<bind>\n           (\\<lambda>x.\n               (let Q = if v \\<noteq> s \\<and>\n                           v \\<noteq> t \\<and> excess f v = (0::'capacity)\n                        then Q @ [v] else Q\n                in return (push_effect f (u, v), Q)) \\<bind>\n               (\\<lambda>(f', Q).\n                   assert\n                    (\\<forall>v'.\n                        v' \\<noteq> v \\<longrightarrow>\n                        cf_of f' (u, v') = cf_of f (u, v')) \\<bind>\n                   (\\<lambda>_. return (f', l, Q)))))\n  else return (f, l, Q)))\n                                  (f, l, Q) \\<bind>\n                                 (\\<lambda>(f, l, Q).\n                                     if excess f u \\<noteq> (0::'capacity)\n                                     then assert\n     (u \\<in> V - {s, t}) \\<bind>\n    (\\<lambda>x.\n        assert (Height_Bounded_Labeling c s t f l) \\<bind>\n        (\\<lambda>x.\n            (let Q = Q @ [u]\n             in assert (relabel_precond f l u) \\<bind>\n                (\\<lambda>_.\n                    assert\n                     (l u < 2 * card V \\<and>\n                      relabel_effect f l u u < 2 * card V) \\<bind>\n                    (\\<lambda>_.\n                        let l = gap_relabel_effect f l u\n                        in return (l, Q)))) \\<bind>\n            (\\<lambda>(l, Q). return (f, l, Q))))\n                                     else return (f, l, Q))))\n                      \\<le> SPEC\n                             (\\<lambda>(f', l', Q').\n                                 Height_Bounded_Labeling c s t f' l' \\<and>\n                                 Q_invar f' Q' \\<and>\n                                 ((f', l'), f, l)\n                                 \\<in> gap_algo_rel\\<^sup>+)", "apply (rewrite in \"if excess _ _ \\<noteq> 0 then \\<hole> else _\" vcg_intro_frame)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> V - {s, t}; QD_invar u f Qr\\<rbrakk>\n    \\<Longrightarrow> assert (Q \\<noteq> []) \\<bind>\n                      (\\<lambda>_.\n                          let u = hd Q; Q = tl Q\n                          in assert\n                              (u \\<in> V \\<and>\n                               u \\<noteq> s \\<and> u \\<noteq> t) \\<bind>\n                             (\\<lambda>_.\n                                 FOREACH\\<^sub>C {v. (u, v) \\<in> cfE_of f}\n                                  (\\<lambda>(f, l, Q).\nexcess f u \\<noteq> (0::'capacity))\n                                  (\\<lambda>v (f, l, Q).\nVCG_FRAME\n (if l u = l v + 1\n  then assert (push_precond f l (u, v)) \\<bind>\n       (\\<lambda>x.\n           assert (Labeling c s t f l) \\<bind>\n           (\\<lambda>x.\n               (let Q = if v \\<noteq> s \\<and>\n                           v \\<noteq> t \\<and> excess f v = (0::'capacity)\n                        then Q @ [v] else Q\n                in return (push_effect f (u, v), Q)) \\<bind>\n               (\\<lambda>(f', Q).\n                   assert\n                    (\\<forall>v'.\n                        v' \\<noteq> v \\<longrightarrow>\n                        cf_of f' (u, v') = cf_of f (u, v')) \\<bind>\n                   (\\<lambda>_. return (f', l, Q)))))\n  else return (f, l, Q)))\n                                  (f, l, Q) \\<bind>\n                                 (\\<lambda>(f, l, Q).\n                                     if excess f u \\<noteq> (0::'capacity)\n                                     then VCG_FRAME\n     (assert (u \\<in> V - {s, t}) \\<bind>\n      (\\<lambda>x.\n          assert (Height_Bounded_Labeling c s t f l) \\<bind>\n          (\\<lambda>x.\n              (let Q = Q @ [u]\n               in assert (relabel_precond f l u) \\<bind>\n                  (\\<lambda>_.\n                      assert\n                       (l u < 2 * card V \\<and>\n                        relabel_effect f l u u < 2 * card V) \\<bind>\n                      (\\<lambda>_.\n                          let l = gap_relabel_effect f l u\n                          in return (l, Q)))) \\<bind>\n              (\\<lambda>(l, Q). return (f, l, Q)))))\n                                     else return (f, l, Q))))\n                      \\<le> SPEC\n                             (\\<lambda>(f', l', Q').\n                                 Height_Bounded_Labeling c s t f' l' \\<and>\n                                 Q_invar f' Q' \\<and>\n                                 ((f', l'), f, l)\n                                 \\<in> gap_algo_rel\\<^sup>+)", "apply (refine_vcg FOREACHc_rule[where \n            I=\"\\<lambda>it (f',l',Q'). \n                Height_Bounded_Labeling c s t f' l' \n              \\<and> QD_invar u f' Q'\n              \\<and> ((f',l'),(f,l))\\<in>gap_algo_rel\\<^sup>*\n              \\<and> it \\<subseteq> {v. (u,v) \\<in> cfE_of f' }\n              \\<and> (excess f' u\\<noteq>0 \\<longrightarrow> (\\<forall>v\\<in>{v. (u,v) \\<in> cfE_of f' }-it. l' u \\<noteq> l' v + 1)\n            )\n            \"\n          ])"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<lbrakk>u \\<in> V - {s, t}; QD_invar u f Qr\\<rbrakk>\n    \\<Longrightarrow> Q \\<noteq> []\n 2. \\<lbrakk>u \\<in> V - {s, t}; QD_invar u f Qr; Q \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> hd Q \\<in> V\n 3. \\<lbrakk>u \\<in> V - {s, t}; QD_invar u f Qr; Q \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> hd Q \\<noteq> s\n 4. \\<lbrakk>u \\<in> V - {s, t}; QD_invar u f Qr; Q \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> hd Q \\<noteq> t\n 5. \\<lbrakk>u \\<in> V - {s, t}; QD_invar u f Qr; Q \\<noteq> [];\n     hd Q \\<in> V \\<and> hd Q \\<noteq> s \\<and> hd Q \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> finite {v. (hd Q, v) \\<in> cfE_of f}\n 6. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>u \\<in> V - {s, t}; QD_invar u f Qr; Q \\<noteq> [];\n        hd Q \\<in> V \\<and> hd Q \\<noteq> s \\<and> hd Q \\<noteq> t;\n        x2 = (x1a, x2a); (f, l, tl Q) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> Height_Bounded_Labeling c s t x1 x1a\n 7. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>u \\<in> V - {s, t}; QD_invar u f Qr; Q \\<noteq> [];\n        hd Q \\<in> V \\<and> hd Q \\<noteq> s \\<and> hd Q \\<noteq> t;\n        x2 = (x1a, x2a); (f, l, tl Q) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> QD_invar u x1 x2a\n 8. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>u \\<in> V - {s, t}; QD_invar u f Qr; Q \\<noteq> [];\n        hd Q \\<in> V \\<and> hd Q \\<noteq> s \\<and> hd Q \\<noteq> t;\n        x2 = (x1a, x2a); (f, l, tl Q) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> ((x1, x1a), f, l) \\<in> gap_algo_rel\\<^sup>*\n 9. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>u \\<in> V - {s, t}; QD_invar u f Qr; Q \\<noteq> [];\n        hd Q \\<in> V \\<and> hd Q \\<noteq> s \\<and> hd Q \\<noteq> t;\n        x2 = (x1a, x2a); (f, l, tl Q) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> {v. (hd Q, v) \\<in> cfE_of f}\n                         \\<subseteq> {v. (u, v) \\<in> cfE_of x1}\n 10. \\<And>x1 x2 x1a x2a.\n        \\<lbrakk>u \\<in> V - {s, t}; QD_invar u f Qr; Q \\<noteq> [];\n         hd Q \\<in> V \\<and> hd Q \\<noteq> s \\<and> hd Q \\<noteq> t;\n         x2 = (x1a, x2a); (f, l, tl Q) = (x1, x2);\n         excess x1 u \\<noteq> (0::'capacity)\\<rbrakk>\n        \\<Longrightarrow> \\<forall>v\\<in>{v. (u, v) \\<in> cfE_of x1} -\n   {v. (hd Q, v) \\<in> cfE_of f}.\n                             x1a u \\<noteq> x1a v + 1\nA total of 19 subgoals...", "apply (vc_solve simp: DINV QINV it_step_insert_iff split del: if_split)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x it ab aaa baa.\n       \\<lbrakk>QD_invar u f Qr; x \\<in> it;\n        it \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n        excess ab u \\<noteq> (0::'capacity); u \\<in> V;\n        Height_Bounded_Labeling c s t ab aaa; u \\<noteq> s; u \\<noteq> t;\n        QD_invar u ab baa; ((ab, aaa), f, l) \\<in> gap_algo_rel\\<^sup>*;\n        it \\<subseteq> {v. (u, v) \\<in> cfE_of ab};\n        \\<forall>v\\<in>{v. (u, v) \\<in> cfE_of ab} - it.\n           aaa u \\<noteq> Suc (aaa v)\\<rbrakk>\n       \\<Longrightarrow> VCG_FRAME\n                          (if aaa (hd Q) = aaa x + 1\n                           then assert\n                                 (push_precond ab aaa (hd Q, x)) \\<bind>\n                                (\\<lambda>xa.\n                                    assert (Labeling c s t ab aaa) \\<bind>\n                                    (\\<lambda>xa.\n  (let Qa = if x \\<noteq> s \\<and>\n               x \\<noteq> t \\<and> excess ab x = (0::'capacity)\n            then baa @ [x] else baa\n   in return (push_effect ab (hd Q, x), Qa)) \\<bind>\n  (\\<lambda>(f', Qa).\n      assert\n       (\\<forall>v'.\n           v' \\<noteq> x \\<longrightarrow>\n           cf_of f' (hd Q, v') = cf_of ab (hd Q, v')) \\<bind>\n      (\\<lambda>_. return (f', aaa, Qa)))))\n                           else return (ab, aaa, baa))\n                         \\<le> SPEC\n                                (\\<lambda>(f', l', Q').\n                                    Height_Bounded_Labeling c s t f'\n                                     l' \\<and>\n                                    QD_invar u f' Q' \\<and>\n                                    ((f', l'), f, l)\n                                    \\<in> gap_algo_rel\\<^sup>* \\<and>\n                                    it - {x}\n                                    \\<subseteq> {v.\n           (u, v) \\<in> cfE_of f'} \\<and>\n                                    (excess f' u \\<noteq>\n                                     (0::'capacity) \\<longrightarrow>\n                                     (\\<forall>v\n         \\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {x}).\n   l' u \\<noteq> Suc (l' v))))\n 2. \\<And>ab aaa baa.\n       \\<lbrakk>QD_invar u f Qr; excess ab u \\<noteq> (0::'capacity);\n        u \\<in> V; Height_Bounded_Labeling c s t ab aaa; u \\<noteq> s;\n        u \\<noteq> t; QD_invar u ab baa;\n        ((ab, aaa), f, l) \\<in> gap_algo_rel\\<^sup>*;\n        \\<forall>v.\n           (u, v) \\<in> cfE_of ab \\<longrightarrow>\n           aaa u \\<noteq> Suc (aaa v)\\<rbrakk>\n       \\<Longrightarrow> VCG_FRAME\n                          (assert (hd Q \\<in> V - {s, t}) \\<bind>\n                           (\\<lambda>x.\n                               assert\n                                (Height_Bounded_Labeling c s t ab\n                                  aaa) \\<bind>\n                               (\\<lambda>x.\n                                   (let Qa = baa @ [hd Q]\n                                    in assert\n  (relabel_precond ab aaa (hd Q)) \\<bind>\n (\\<lambda>_.\n     assert\n      (aaa (hd Q) < 2 * card V \\<and>\n       relabel_effect ab aaa (hd Q) (hd Q) < 2 * card V) \\<bind>\n     (\\<lambda>_.\n         let l = gap_relabel_effect ab aaa (hd Q)\n         in return (l, Qa)))) \\<bind>\n                                   (\\<lambda>(l, Q). return (ab, l, Q)))))\n                         \\<le> SPEC\n                                (\\<lambda>(f', l', Q').\n                                    Height_Bounded_Labeling c s t f'\n                                     l' \\<and>\n                                    Q_invar f' Q' \\<and>\n                                    ((f', l'), f, l)\n                                    \\<in> gap_algo_rel\\<^sup>+)\n 3. \\<And>aaa baa x1.\n       \\<lbrakk>QD_invar u f Qr; excess x1 u = (0::'capacity); u \\<in> V;\n        Height_Bounded_Labeling c s t x1 aaa; u \\<noteq> s; u \\<noteq> t;\n        QD_invar u x1 baa;\n        ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> Q_invar x1 baa\n 4. \\<And>aaa baa x1.\n       \\<lbrakk>QD_invar u f Qr; excess x1 u = (0::'capacity); u \\<in> V;\n        Height_Bounded_Labeling c s t x1 aaa; u \\<noteq> s; u \\<noteq> t;\n        QD_invar u x1 baa;\n        ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>+\n 5. \\<And>it aaa baa x1.\n       \\<lbrakk>QD_invar u f Qr; it \\<noteq> {};\n        it \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n        excess x1 u = (0::'capacity); u \\<in> V;\n        Height_Bounded_Labeling c s t x1 aaa; u \\<noteq> s; u \\<noteq> t;\n        QD_invar u x1 baa; ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>*;\n        it \\<subseteq> {v. (u, v) \\<in> cfE_of x1}\\<rbrakk>\n       \\<Longrightarrow> Q_invar x1 baa\n 6. \\<And>it aaa baa x1.\n       \\<lbrakk>QD_invar u f Qr; it \\<noteq> {};\n        it \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n        excess x1 u = (0::'capacity); u \\<in> V;\n        Height_Bounded_Labeling c s t x1 aaa; u \\<noteq> s; u \\<noteq> t;\n        QD_invar u x1 baa; ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>*;\n        it \\<subseteq> {v. (u, v) \\<in> cfE_of x1}\\<rbrakk>\n       \\<Longrightarrow> ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>+", "subgoal for v it f' l' Q'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>QD_invar u f Qr; v \\<in> it;\n     it \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n     excess f' u \\<noteq> (0::'capacity); u \\<in> V;\n     Height_Bounded_Labeling c s t f' l'; u \\<noteq> s; u \\<noteq> t;\n     QD_invar u f' Q'; ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>*;\n     it \\<subseteq> {v. (u, v) \\<in> cfE_of f'};\n     \\<forall>v\\<in>{v. (u, v) \\<in> cfE_of f'} - it.\n        l' u \\<noteq> Suc (l' v)\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (if l' (hd Q) = l' v + 1\n                        then assert (push_precond f' l' (hd Q, v)) \\<bind>\n                             (\\<lambda>x.\n                                 assert (Labeling c s t f' l') \\<bind>\n                                 (\\<lambda>x.\n                                     (let Qa =\n      if v \\<noteq> s \\<and>\n         v \\<noteq> t \\<and> excess f' v = (0::'capacity)\n      then Q' @ [v] else Q'\nin return (push_effect f' (hd Q, v), Qa)) \\<bind>\n                                     (\\<lambda>(f'a, Qa).\n   assert\n    (\\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow>\n        cf_of f'a (hd Q, v') = cf_of f' (hd Q, v')) \\<bind>\n   (\\<lambda>_. return (f'a, l', Qa)))))\n                        else return (f', l', Q'))\n                      \\<le> SPEC\n                             (\\<lambda>(f', l', Q').\n                                 Height_Bounded_Labeling c s t f' l' \\<and>\n                                 QD_invar u f' Q' \\<and>\n                                 ((f', l'), f, l)\n                                 \\<in> gap_algo_rel\\<^sup>* \\<and>\n                                 it - {v}\n                                 \\<subseteq> {v.\n        (u, v) \\<in> cfE_of f'} \\<and>\n                                 (excess f' u \\<noteq>\n                                  (0::'capacity) \\<longrightarrow>\n                                  (\\<forall>v\n      \\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\nl' u \\<noteq> Suc (l' v))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>QD_invar u f Qr; v \\<in> it;\n     it \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n     excess f' u \\<noteq> (0::'capacity); u \\<in> V;\n     Height_Bounded_Labeling c s t f' l'; u \\<noteq> s; u \\<noteq> t;\n     QD_invar u f' Q'; ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>*;\n     it \\<subseteq> {v. (u, v) \\<in> cfE_of f'};\n     \\<forall>v\\<in>{v. (u, v) \\<in> cfE_of f'} - it.\n        l' u \\<noteq> Suc (l' v)\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (if l' (hd Q) = l' v + 1\n                        then assert (push_precond f' l' (hd Q, v)) \\<bind>\n                             (\\<lambda>x.\n                                 assert (Labeling c s t f' l') \\<bind>\n                                 (\\<lambda>x.\n                                     (let Qa =\n      if v \\<noteq> s \\<and>\n         v \\<noteq> t \\<and> excess f' v = (0::'capacity)\n      then Q' @ [v] else Q'\nin return (push_effect f' (hd Q, v), Qa)) \\<bind>\n                                     (\\<lambda>(f'a, Qa).\n   assert\n    (\\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow>\n        cf_of f'a (hd Q, v') = cf_of f' (hd Q, v')) \\<bind>\n   (\\<lambda>_. return (f'a, l', Qa)))))\n                        else return (f', l', Q'))\n                      \\<le> SPEC\n                             (\\<lambda>(f', l', Q').\n                                 Height_Bounded_Labeling c s t f' l' \\<and>\n                                 QD_invar u f' Q' \\<and>\n                                 ((f', l'), f, l)\n                                 \\<in> gap_algo_rel\\<^sup>* \\<and>\n                                 it - {v}\n                                 \\<subseteq> {v.\n        (u, v) \\<in> cfE_of f'} \\<and>\n                                 (excess f' u \\<noteq>\n                                  (0::'capacity) \\<longrightarrow>\n                                  (\\<forall>v\n      \\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\nl' u \\<noteq> Suc (l' v))))", "assume HBL: \"Height_Bounded_Labeling c s t f' l'\""], ["proof (state)\nthis:\n  Height_Bounded_Labeling c s t f' l'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>QD_invar u f Qr; v \\<in> it;\n     it \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n     excess f' u \\<noteq> (0::'capacity); u \\<in> V;\n     Height_Bounded_Labeling c s t f' l'; u \\<noteq> s; u \\<noteq> t;\n     QD_invar u f' Q'; ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>*;\n     it \\<subseteq> {v. (u, v) \\<in> cfE_of f'};\n     \\<forall>v\\<in>{v. (u, v) \\<in> cfE_of f'} - it.\n        l' u \\<noteq> Suc (l' v)\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (if l' (hd Q) = l' v + 1\n                        then assert (push_precond f' l' (hd Q, v)) \\<bind>\n                             (\\<lambda>x.\n                                 assert (Labeling c s t f' l') \\<bind>\n                                 (\\<lambda>x.\n                                     (let Qa =\n      if v \\<noteq> s \\<and>\n         v \\<noteq> t \\<and> excess f' v = (0::'capacity)\n      then Q' @ [v] else Q'\nin return (push_effect f' (hd Q, v), Qa)) \\<bind>\n                                     (\\<lambda>(f'a, Qa).\n   assert\n    (\\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow>\n        cf_of f'a (hd Q, v') = cf_of f' (hd Q, v')) \\<bind>\n   (\\<lambda>_. return (f'a, l', Qa)))))\n                        else return (f', l', Q'))\n                      \\<le> SPEC\n                             (\\<lambda>(f', l', Q').\n                                 Height_Bounded_Labeling c s t f' l' \\<and>\n                                 QD_invar u f' Q' \\<and>\n                                 ((f', l'), f, l)\n                                 \\<in> gap_algo_rel\\<^sup>* \\<and>\n                                 it - {v}\n                                 \\<subseteq> {v.\n        (u, v) \\<in> cfE_of f'} \\<and>\n                                 (excess f' u \\<noteq>\n                                  (0::'capacity) \\<longrightarrow>\n                                  (\\<forall>v\n      \\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\nl' u \\<noteq> Suc (l' v))))", "then"], ["proof (chain)\npicking this:\n  Height_Bounded_Labeling c s t f' l'", "interpret l': Height_Bounded_Labeling c s t f' l'"], ["proof (prove)\nusing this:\n  Height_Bounded_Labeling c s t f' l'\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f' l'", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>QD_invar u f Qr; v \\<in> it;\n     it \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n     excess f' u \\<noteq> (0::'capacity); u \\<in> V;\n     Height_Bounded_Labeling c s t f' l'; u \\<noteq> s; u \\<noteq> t;\n     QD_invar u f' Q'; ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>*;\n     it \\<subseteq> {v. (u, v) \\<in> l'.cf.E};\n     \\<forall>v\\<in>{v. (u, v) \\<in> l'.cf.E} - it.\n        l' u \\<noteq> Suc (l' v)\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (if l' (hd Q) = l' v + 1\n                        then assert (push_precond f' l' (hd Q, v)) \\<bind>\n                             (\\<lambda>x.\n                                 assert (Labeling c s t f' l') \\<bind>\n                                 (\\<lambda>x.\n                                     (let Qa =\n      if v \\<noteq> s \\<and>\n         v \\<noteq> t \\<and> excess f' v = (0::'capacity)\n      then Q' @ [v] else Q'\nin return (push_effect f' (hd Q, v), Qa)) \\<bind>\n                                     (\\<lambda>(f', Qa).\n   assert\n    (\\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow>\n        cf_of f' (hd Q, v') = l'.cf (hd Q, v')) \\<bind>\n   (\\<lambda>_. return (f', l', Qa)))))\n                        else return (f', l', Q'))\n                      \\<le> SPEC\n                             (\\<lambda>(f', l', Q').\n                                 Height_Bounded_Labeling c s t f' l' \\<and>\n                                 QD_invar u f' Q' \\<and>\n                                 ((f', l'), f, l)\n                                 \\<in> gap_algo_rel\\<^sup>* \\<and>\n                                 it - {v}\n                                 \\<subseteq> {v.\n        (u, v) \\<in> cfE_of f'} \\<and>\n                                 (excess f' u \\<noteq>\n                                  (0::'capacity) \\<longrightarrow>\n                                  (\\<forall>v\n      \\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\nl' u \\<noteq> Suc (l' v))))", "assume X: \"excess f' u \\<noteq> 0\" and UI: \"u \\<in> V\" \"u \\<noteq> s\" \"u \\<noteq> t\" \n        and QDI: \"QD_invar u f' Q'\""], ["proof (state)\nthis:\n  excess f' u \\<noteq> (0::'capacity)\n  u \\<in> V\n  u \\<noteq> s\n  u \\<noteq> t\n  QD_invar u f' Q'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>QD_invar u f Qr; v \\<in> it;\n     it \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n     excess f' u \\<noteq> (0::'capacity); u \\<in> V;\n     Height_Bounded_Labeling c s t f' l'; u \\<noteq> s; u \\<noteq> t;\n     QD_invar u f' Q'; ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>*;\n     it \\<subseteq> {v. (u, v) \\<in> l'.cf.E};\n     \\<forall>v\\<in>{v. (u, v) \\<in> l'.cf.E} - it.\n        l' u \\<noteq> Suc (l' v)\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (if l' (hd Q) = l' v + 1\n                        then assert (push_precond f' l' (hd Q, v)) \\<bind>\n                             (\\<lambda>x.\n                                 assert (Labeling c s t f' l') \\<bind>\n                                 (\\<lambda>x.\n                                     (let Qa =\n      if v \\<noteq> s \\<and>\n         v \\<noteq> t \\<and> excess f' v = (0::'capacity)\n      then Q' @ [v] else Q'\nin return (push_effect f' (hd Q, v), Qa)) \\<bind>\n                                     (\\<lambda>(f', Qa).\n   assert\n    (\\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow>\n        cf_of f' (hd Q, v') = l'.cf (hd Q, v')) \\<bind>\n   (\\<lambda>_. return (f', l', Qa)))))\n                        else return (f', l', Q'))\n                      \\<le> SPEC\n                             (\\<lambda>(f', l', Q').\n                                 Height_Bounded_Labeling c s t f' l' \\<and>\n                                 QD_invar u f' Q' \\<and>\n                                 ((f', l'), f, l)\n                                 \\<in> gap_algo_rel\\<^sup>* \\<and>\n                                 it - {v}\n                                 \\<subseteq> {v.\n        (u, v) \\<in> cfE_of f'} \\<and>\n                                 (excess f' u \\<noteq>\n                                  (0::'capacity) \\<longrightarrow>\n                                  (\\<forall>v\n      \\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\nl' u \\<noteq> Suc (l' v))))", "assume \"v \\<in> it\" and ITSS: \"it \\<subseteq> {v. (u, v) \\<in> l'.cf.E}\""], ["proof (state)\nthis:\n  v \\<in> it\n  it \\<subseteq> {v. (u, v) \\<in> l'.cf.E}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>QD_invar u f Qr; v \\<in> it;\n     it \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n     excess f' u \\<noteq> (0::'capacity); u \\<in> V;\n     Height_Bounded_Labeling c s t f' l'; u \\<noteq> s; u \\<noteq> t;\n     QD_invar u f' Q'; ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>*;\n     it \\<subseteq> {v. (u, v) \\<in> l'.cf.E};\n     \\<forall>v\\<in>{v. (u, v) \\<in> l'.cf.E} - it.\n        l' u \\<noteq> Suc (l' v)\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (if l' (hd Q) = l' v + 1\n                        then assert (push_precond f' l' (hd Q, v)) \\<bind>\n                             (\\<lambda>x.\n                                 assert (Labeling c s t f' l') \\<bind>\n                                 (\\<lambda>x.\n                                     (let Qa =\n      if v \\<noteq> s \\<and>\n         v \\<noteq> t \\<and> excess f' v = (0::'capacity)\n      then Q' @ [v] else Q'\nin return (push_effect f' (hd Q, v), Qa)) \\<bind>\n                                     (\\<lambda>(f', Qa).\n   assert\n    (\\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow>\n        cf_of f' (hd Q, v') = l'.cf (hd Q, v')) \\<bind>\n   (\\<lambda>_. return (f', l', Qa)))))\n                        else return (f', l', Q'))\n                      \\<le> SPEC\n                             (\\<lambda>(f', l', Q').\n                                 Height_Bounded_Labeling c s t f' l' \\<and>\n                                 QD_invar u f' Q' \\<and>\n                                 ((f', l'), f, l)\n                                 \\<in> gap_algo_rel\\<^sup>* \\<and>\n                                 it - {v}\n                                 \\<subseteq> {v.\n        (u, v) \\<in> cfE_of f'} \\<and>\n                                 (excess f' u \\<noteq>\n                                  (0::'capacity) \\<longrightarrow>\n                                  (\\<forall>v\n      \\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\nl' u \\<noteq> Suc (l' v))))", "hence UVE: \"(u,v) \\<in> l'.cf.E\""], ["proof (prove)\nusing this:\n  v \\<in> it\n  it \\<subseteq> {v. (u, v) \\<in> l'.cf.E}\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> l'.cf.E", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<in> l'.cf.E\n\ngoal (1 subgoal):\n 1. \\<lbrakk>QD_invar u f Qr; v \\<in> it;\n     it \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n     excess f' u \\<noteq> (0::'capacity); u \\<in> V;\n     Height_Bounded_Labeling c s t f' l'; u \\<noteq> s; u \\<noteq> t;\n     QD_invar u f' Q'; ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>*;\n     it \\<subseteq> {v. (u, v) \\<in> l'.cf.E};\n     \\<forall>v\\<in>{v. (u, v) \\<in> l'.cf.E} - it.\n        l' u \\<noteq> Suc (l' v)\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (if l' (hd Q) = l' v + 1\n                        then assert (push_precond f' l' (hd Q, v)) \\<bind>\n                             (\\<lambda>x.\n                                 assert (Labeling c s t f' l') \\<bind>\n                                 (\\<lambda>x.\n                                     (let Qa =\n      if v \\<noteq> s \\<and>\n         v \\<noteq> t \\<and> excess f' v = (0::'capacity)\n      then Q' @ [v] else Q'\nin return (push_effect f' (hd Q, v), Qa)) \\<bind>\n                                     (\\<lambda>(f', Qa).\n   assert\n    (\\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow>\n        cf_of f' (hd Q, v') = l'.cf (hd Q, v')) \\<bind>\n   (\\<lambda>_. return (f', l', Qa)))))\n                        else return (f', l', Q'))\n                      \\<le> SPEC\n                             (\\<lambda>(f', l', Q').\n                                 Height_Bounded_Labeling c s t f' l' \\<and>\n                                 QD_invar u f' Q' \\<and>\n                                 ((f', l'), f, l)\n                                 \\<in> gap_algo_rel\\<^sup>* \\<and>\n                                 it - {v}\n                                 \\<subseteq> {v.\n        (u, v) \\<in> cfE_of f'} \\<and>\n                                 (excess f' u \\<noteq>\n                                  (0::'capacity) \\<longrightarrow>\n                                  (\\<forall>v\n      \\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\nl' u \\<noteq> Suc (l' v))))", "assume REL: \"((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>*\""], ["proof (state)\nthis:\n  ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<lbrakk>QD_invar u f Qr; v \\<in> it;\n     it \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n     excess f' u \\<noteq> (0::'capacity); u \\<in> V;\n     Height_Bounded_Labeling c s t f' l'; u \\<noteq> s; u \\<noteq> t;\n     QD_invar u f' Q'; ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>*;\n     it \\<subseteq> {v. (u, v) \\<in> l'.cf.E};\n     \\<forall>v\\<in>{v. (u, v) \\<in> l'.cf.E} - it.\n        l' u \\<noteq> Suc (l' v)\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (if l' (hd Q) = l' v + 1\n                        then assert (push_precond f' l' (hd Q, v)) \\<bind>\n                             (\\<lambda>x.\n                                 assert (Labeling c s t f' l') \\<bind>\n                                 (\\<lambda>x.\n                                     (let Qa =\n      if v \\<noteq> s \\<and>\n         v \\<noteq> t \\<and> excess f' v = (0::'capacity)\n      then Q' @ [v] else Q'\nin return (push_effect f' (hd Q, v), Qa)) \\<bind>\n                                     (\\<lambda>(f', Qa).\n   assert\n    (\\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow>\n        cf_of f' (hd Q, v') = l'.cf (hd Q, v')) \\<bind>\n   (\\<lambda>_. return (f', l', Qa)))))\n                        else return (f', l', Q'))\n                      \\<le> SPEC\n                             (\\<lambda>(f', l', Q').\n                                 Height_Bounded_Labeling c s t f' l' \\<and>\n                                 QD_invar u f' Q' \\<and>\n                                 ((f', l'), f, l)\n                                 \\<in> gap_algo_rel\\<^sup>* \\<and>\n                                 it - {v}\n                                 \\<subseteq> {v.\n        (u, v) \\<in> cfE_of f'} \\<and>\n                                 (excess f' u \\<noteq>\n                                  (0::'capacity) \\<longrightarrow>\n                                  (\\<forall>v\n      \\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\nl' u \\<noteq> Suc (l' v))))", "assume SAT_EDGES: \"\\<forall>v\\<in>{v. (u, v) \\<in> cfE_of f'} - it. l' u \\<noteq> Suc (l' v)\""], ["proof (state)\nthis:\n  \\<forall>v\\<in>{v. (u, v) \\<in> l'.cf.E} - it. l' u \\<noteq> Suc (l' v)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>QD_invar u f Qr; v \\<in> it;\n     it \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n     excess f' u \\<noteq> (0::'capacity); u \\<in> V;\n     Height_Bounded_Labeling c s t f' l'; u \\<noteq> s; u \\<noteq> t;\n     QD_invar u f' Q'; ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>*;\n     it \\<subseteq> {v. (u, v) \\<in> l'.cf.E};\n     \\<forall>v\\<in>{v. (u, v) \\<in> l'.cf.E} - it.\n        l' u \\<noteq> Suc (l' v)\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (if l' (hd Q) = l' v + 1\n                        then assert (push_precond f' l' (hd Q, v)) \\<bind>\n                             (\\<lambda>x.\n                                 assert (Labeling c s t f' l') \\<bind>\n                                 (\\<lambda>x.\n                                     (let Qa =\n      if v \\<noteq> s \\<and>\n         v \\<noteq> t \\<and> excess f' v = (0::'capacity)\n      then Q' @ [v] else Q'\nin return (push_effect f' (hd Q, v), Qa)) \\<bind>\n                                     (\\<lambda>(f', Qa).\n   assert\n    (\\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow>\n        cf_of f' (hd Q, v') = l'.cf (hd Q, v')) \\<bind>\n   (\\<lambda>_. return (f', l', Qa)))))\n                        else return (f', l', Q'))\n                      \\<le> SPEC\n                             (\\<lambda>(f', l', Q').\n                                 Height_Bounded_Labeling c s t f' l' \\<and>\n                                 QD_invar u f' Q' \\<and>\n                                 ((f', l'), f, l)\n                                 \\<in> gap_algo_rel\\<^sup>* \\<and>\n                                 it - {v}\n                                 \\<subseteq> {v.\n        (u, v) \\<in> cfE_of f'} \\<and>\n                                 (excess f' u \\<noteq>\n                                  (0::'capacity) \\<longrightarrow>\n                                  (\\<forall>v\n      \\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\nl' u \\<noteq> Suc (l' v))))", "from X UI l'.excess_non_negative"], ["proof (chain)\npicking this:\n  excess f' u \\<noteq> (0::'capacity)\n  u \\<in> V\n  u \\<noteq> s\n  u \\<noteq> t\n  \\<forall>v\\<in>V - {s, t}. (0::'capacity) \\<le> excess f' v", "have X': \"excess f' u > 0\""], ["proof (prove)\nusing this:\n  excess f' u \\<noteq> (0::'capacity)\n  u \\<in> V\n  u \\<noteq> s\n  u \\<noteq> t\n  \\<forall>v\\<in>V - {s, t}. (0::'capacity) \\<le> excess f' v\n\ngoal (1 subgoal):\n 1. (0::'capacity) < excess f' u", "by force"], ["proof (state)\nthis:\n  (0::'capacity) < excess f' u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>QD_invar u f Qr; v \\<in> it;\n     it \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n     excess f' u \\<noteq> (0::'capacity); u \\<in> V;\n     Height_Bounded_Labeling c s t f' l'; u \\<noteq> s; u \\<noteq> t;\n     QD_invar u f' Q'; ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>*;\n     it \\<subseteq> {v. (u, v) \\<in> l'.cf.E};\n     \\<forall>v\\<in>{v. (u, v) \\<in> l'.cf.E} - it.\n        l' u \\<noteq> Suc (l' v)\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (if l' (hd Q) = l' v + 1\n                        then assert (push_precond f' l' (hd Q, v)) \\<bind>\n                             (\\<lambda>x.\n                                 assert (Labeling c s t f' l') \\<bind>\n                                 (\\<lambda>x.\n                                     (let Qa =\n      if v \\<noteq> s \\<and>\n         v \\<noteq> t \\<and> excess f' v = (0::'capacity)\n      then Q' @ [v] else Q'\nin return (push_effect f' (hd Q, v), Qa)) \\<bind>\n                                     (\\<lambda>(f', Qa).\n   assert\n    (\\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow>\n        cf_of f' (hd Q, v') = l'.cf (hd Q, v')) \\<bind>\n   (\\<lambda>_. return (f', l', Qa)))))\n                        else return (f', l', Q'))\n                      \\<le> SPEC\n                             (\\<lambda>(f', l', Q').\n                                 Height_Bounded_Labeling c s t f' l' \\<and>\n                                 QD_invar u f' Q' \\<and>\n                                 ((f', l'), f, l)\n                                 \\<in> gap_algo_rel\\<^sup>* \\<and>\n                                 it - {v}\n                                 \\<subseteq> {v.\n        (u, v) \\<in> cfE_of f'} \\<and>\n                                 (excess f' u \\<noteq>\n                                  (0::'capacity) \\<longrightarrow>\n                                  (\\<forall>v\n      \\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\nl' u \\<noteq> Suc (l' v))))", "have PP: \"push_precond f' l' (u, v)\" if \"l' u = l' v + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. push_precond f' l' (u, v)", "unfolding push_precond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (u, v) of\n    (u, v) \\<Rightarrow>\n      (0::'capacity) < excess f' u \\<and>\n      (u, v) \\<in> l'.cf.E \\<and> l' u = l' v + 1", "using that UVE X'"], ["proof (prove)\nusing this:\n  l' u = l' v + 1\n  (u, v) \\<in> l'.cf.E\n  (0::'capacity) < excess f' u\n\ngoal (1 subgoal):\n 1. case (u, v) of\n    (u, v) \\<Rightarrow>\n      (0::'capacity) < excess f' u \\<and>\n      (u, v) \\<in> l'.cf.E \\<and> l' u = l' v + 1", "by auto"], ["proof (state)\nthis:\n  l' u = l' v + 1 \\<Longrightarrow> push_precond f' l' (u, v)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>QD_invar u f Qr; v \\<in> it;\n     it \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n     excess f' u \\<noteq> (0::'capacity); u \\<in> V;\n     Height_Bounded_Labeling c s t f' l'; u \\<noteq> s; u \\<noteq> t;\n     QD_invar u f' Q'; ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>*;\n     it \\<subseteq> {v. (u, v) \\<in> l'.cf.E};\n     \\<forall>v\\<in>{v. (u, v) \\<in> l'.cf.E} - it.\n        l' u \\<noteq> Suc (l' v)\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (if l' (hd Q) = l' v + 1\n                        then assert (push_precond f' l' (hd Q, v)) \\<bind>\n                             (\\<lambda>x.\n                                 assert (Labeling c s t f' l') \\<bind>\n                                 (\\<lambda>x.\n                                     (let Qa =\n      if v \\<noteq> s \\<and>\n         v \\<noteq> t \\<and> excess f' v = (0::'capacity)\n      then Q' @ [v] else Q'\nin return (push_effect f' (hd Q, v), Qa)) \\<bind>\n                                     (\\<lambda>(f', Qa).\n   assert\n    (\\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow>\n        cf_of f' (hd Q, v') = l'.cf (hd Q, v')) \\<bind>\n   (\\<lambda>_. return (f', l', Qa)))))\n                        else return (f', l', Q'))\n                      \\<le> SPEC\n                             (\\<lambda>(f', l', Q').\n                                 Height_Bounded_Labeling c s t f' l' \\<and>\n                                 QD_invar u f' Q' \\<and>\n                                 ((f', l'), f, l)\n                                 \\<in> gap_algo_rel\\<^sup>* \\<and>\n                                 it - {v}\n                                 \\<subseteq> {v.\n        (u, v) \\<in> cfE_of f'} \\<and>\n                                 (excess f' u \\<noteq>\n                                  (0::'capacity) \\<longrightarrow>\n                                  (\\<forall>v\n      \\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\nl' u \\<noteq> Suc (l' v))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. VCG_FRAME\n     (if l' (hd Q) = l' v + 1\n      then assert (push_precond f' l' (hd Q, v)) \\<bind>\n           (\\<lambda>x.\n               assert (Labeling c s t f' l') \\<bind>\n               (\\<lambda>x.\n                   (let Qa = if v \\<noteq> s \\<and>\n                                v \\<noteq> t \\<and>\n                                excess f' v = (0::'capacity)\n                             then Q' @ [v] else Q'\n                    in return (push_effect f' (hd Q, v), Qa)) \\<bind>\n                   (\\<lambda>(f', Qa).\n                       assert\n                        (\\<forall>v'.\n                            v' \\<noteq> v \\<longrightarrow>\n                            cf_of f' (hd Q, v') = l'.cf (hd Q, v')) \\<bind>\n                       (\\<lambda>_. return (f', l', Qa)))))\n      else return (f', l', Q'))\n    \\<le> SPEC\n           (\\<lambda>(f', l', Q').\n               Height_Bounded_Labeling c s t f' l' \\<and>\n               QD_invar u f' Q' \\<and>\n               ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>* \\<and>\n               it - {v} \\<subseteq> {v. (u, v) \\<in> cfE_of f'} \\<and>\n               (excess f' u \\<noteq> (0::'capacity) \\<longrightarrow>\n                (\\<forall>v\\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\n                    l' u \\<noteq> Suc (l' v))))", "apply (rule vcg_rem_frame)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if l' (hd Q) = l' v + 1\n     then assert (push_precond f' l' (hd Q, v)) \\<bind>\n          (\\<lambda>x.\n              assert (Labeling c s t f' l') \\<bind>\n              (\\<lambda>x.\n                  (let Qa = if v \\<noteq> s \\<and>\n                               v \\<noteq> t \\<and>\n                               excess f' v = (0::'capacity)\n                            then Q' @ [v] else Q'\n                   in return (push_effect f' (hd Q, v), Qa)) \\<bind>\n                  (\\<lambda>(f', Qa).\n                      assert\n                       (\\<forall>v'.\n                           v' \\<noteq> v \\<longrightarrow>\n                           cf_of f' (hd Q, v') = l'.cf (hd Q, v')) \\<bind>\n                      (\\<lambda>_. return (f', l', Qa)))))\n     else return (f', l', Q'))\n    \\<le> SPEC\n           (\\<lambda>(f', l', Q').\n               Height_Bounded_Labeling c s t f' l' \\<and>\n               QD_invar u f' Q' \\<and>\n               ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>* \\<and>\n               it - {v} \\<subseteq> {v. (u, v) \\<in> cfE_of f'} \\<and>\n               (excess f' u \\<noteq> (0::'capacity) \\<longrightarrow>\n                (\\<forall>v\\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\n                    l' u \\<noteq> Suc (l' v))))", "apply (rewrite in \"if _ then (assert _ \\<then> \\<hole>) else _\" vcg_intro_frame)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if l' (hd Q) = l' v + 1\n     then assert (push_precond f' l' (hd Q, v)) \\<bind>\n          (\\<lambda>x.\n              VCG_FRAME\n               (assert (Labeling c s t f' l') \\<bind>\n                (\\<lambda>x.\n                    (let Qa = if v \\<noteq> s \\<and>\n                                 v \\<noteq> t \\<and>\n                                 excess f' v = (0::'capacity)\n                              then Q' @ [v] else Q'\n                     in return (push_effect f' (hd Q, v), Qa)) \\<bind>\n                    (\\<lambda>(f', Qa).\n                        assert\n                         (\\<forall>v'.\n                             v' \\<noteq> v \\<longrightarrow>\n                             cf_of f' (hd Q, v') = l'.cf (hd Q, v')) \\<bind>\n                        (\\<lambda>_. return (f', l', Qa))))))\n     else return (f', l', Q'))\n    \\<le> SPEC\n           (\\<lambda>(f', l', Q').\n               Height_Bounded_Labeling c s t f' l' \\<and>\n               QD_invar u f' Q' \\<and>\n               ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>* \\<and>\n               it - {v} \\<subseteq> {v. (u, v) \\<in> cfE_of f'} \\<and>\n               (excess f' u \\<noteq> (0::'capacity) \\<longrightarrow>\n                (\\<forall>v\\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\n                    l' u \\<noteq> Suc (l' v))))", "apply refine_vcg"], ["proof (prove)\ngoal (7 subgoals):\n 1. l' (hd Q) = l' v + 1 \\<Longrightarrow> push_precond f' l' (hd Q, v)\n 2. \\<lbrakk>l' (hd Q) = l' v + 1; push_precond f' l' (hd Q, v)\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (assert (Labeling c s t f' l') \\<bind>\n                        (\\<lambda>x.\n                            (let Qa = if v \\<noteq> s \\<and>\n   v \\<noteq> t \\<and> excess f' v = (0::'capacity)\nthen Q' @ [v] else Q'\n                             in return\n                                 (push_effect f' (hd Q, v), Qa)) \\<bind>\n                            (\\<lambda>(f', Qa).\n                                assert\n                                 (\\<forall>v'.\n                                     v' \\<noteq> v \\<longrightarrow>\n                                     cf_of f' (hd Q, v') =\n                                     l'.cf (hd Q, v')) \\<bind>\n                                (\\<lambda>_. return (f', l', Qa)))))\n                      \\<le> SPEC\n                             (\\<lambda>(f', l', Q').\n                                 Height_Bounded_Labeling c s t f' l' \\<and>\n                                 QD_invar u f' Q' \\<and>\n                                 ((f', l'), f, l)\n                                 \\<in> gap_algo_rel\\<^sup>* \\<and>\n                                 it - {v}\n                                 \\<subseteq> {v.\n        (u, v) \\<in> cfE_of f'} \\<and>\n                                 (excess f' u \\<noteq>\n                                  (0::'capacity) \\<longrightarrow>\n                                  (\\<forall>v\n      \\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\nl' u \\<noteq> Suc (l' v))))\n 3. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>l' (hd Q) \\<noteq> l' v + 1; x2 = (x1a, x2a);\n        (f', l', Q') = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> Height_Bounded_Labeling c s t x1 x1a\n 4. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>l' (hd Q) \\<noteq> l' v + 1; x2 = (x1a, x2a);\n        (f', l', Q') = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> QD_invar u x1 x2a\n 5. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>l' (hd Q) \\<noteq> l' v + 1; x2 = (x1a, x2a);\n        (f', l', Q') = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> ((x1, x1a), f, l) \\<in> gap_algo_rel\\<^sup>*\n 6. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>l' (hd Q) \\<noteq> l' v + 1; x2 = (x1a, x2a);\n        (f', l', Q') = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> it - {v} \\<subseteq> {v. (u, v) \\<in> cfE_of x1}\n 7. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>l' (hd Q) \\<noteq> l' v + 1; x2 = (x1a, x2a);\n        (f', l', Q') = (x1, x2);\n        excess x1 u \\<noteq> (0::'capacity)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>{v. (u, v) \\<in> cfE_of x1} -\n  (it - {v}).\n                            x1a u \\<noteq> Suc (x1a v)", "apply (vc_solve simp: REL solve: PP l'.push_pres_height_bound HBL QDI split del: if_split)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>l' u = Suc (l' v); push_precond f' l' (u, v)\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (assert (Labeling c s t f' l') \\<bind>\n                        (\\<lambda>x.\n                            (let Qa = if v \\<noteq> s \\<and>\n   v \\<noteq> t \\<and> excess f' v = (0::'capacity)\nthen Q' @ [v] else Q'\n                             in return\n                                 (push_effect f' (hd Q, v), Qa)) \\<bind>\n                            (\\<lambda>(f', Qa).\n                                assert\n                                 (\\<forall>v'.\n                                     v' \\<noteq> v \\<longrightarrow>\n                                     cf_of f' (hd Q, v') =\n                                     l'.cf (hd Q, v')) \\<bind>\n                                (\\<lambda>_. return (f', l', Qa)))))\n                      \\<le> SPEC\n                             (\\<lambda>(f', l', Q').\n                                 Height_Bounded_Labeling c s t f' l' \\<and>\n                                 QD_invar u f' Q' \\<and>\n                                 ((f', l'), f, l)\n                                 \\<in> gap_algo_rel\\<^sup>* \\<and>\n                                 it - {v}\n                                 \\<subseteq> {v.\n        (u, v) \\<in> cfE_of f'} \\<and>\n                                 (excess f' u \\<noteq>\n                                  (0::'capacity) \\<longrightarrow>\n                                  (\\<forall>v\n      \\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\nl' u \\<noteq> Suc (l' v))))\n 2. \\<And>x.\n       \\<lbrakk>l' u \\<noteq> Suc (l' v); x \\<in> it; x \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> (u, x) \\<in> l'.cf.E\n 3. \\<And>va.\n       \\<lbrakk>l' va \\<noteq> l' v; excess f' u \\<noteq> (0::'capacity);\n        va \\<in> it \\<longrightarrow> va = v; (u, va) \\<in> l'.cf.E;\n        l' u = Suc (l' va)\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l' u = Suc (l' v); push_precond f' l' (u, v)\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (assert (Labeling c s t f' l') \\<bind>\n                        (\\<lambda>x.\n                            (let Qa = if v \\<noteq> s \\<and>\n   v \\<noteq> t \\<and> excess f' v = (0::'capacity)\nthen Q' @ [v] else Q'\n                             in return\n                                 (push_effect f' (hd Q, v), Qa)) \\<bind>\n                            (\\<lambda>(f', Qa).\n                                assert\n                                 (\\<forall>v'.\n                                     v' \\<noteq> v \\<longrightarrow>\n                                     cf_of f' (hd Q, v') =\n                                     l'.cf (hd Q, v')) \\<bind>\n                                (\\<lambda>_. return (f', l', Qa)))))\n                      \\<le> SPEC\n                             (\\<lambda>(f', l', Q').\n                                 Height_Bounded_Labeling c s t f' l' \\<and>\n                                 QD_invar u f' Q' \\<and>\n                                 ((f', l'), f, l)\n                                 \\<in> gap_algo_rel\\<^sup>* \\<and>\n                                 it - {v}\n                                 \\<subseteq> {v.\n        (u, v) \\<in> cfE_of f'} \\<and>\n                                 (excess f' u \\<noteq>\n                                  (0::'capacity) \\<longrightarrow>\n                                  (\\<forall>v\n      \\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\nl' u \\<noteq> Suc (l' v))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>l' u = Suc (l' v); push_precond f' l' (u, v)\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (assert (Labeling c s t f' l') \\<bind>\n                        (\\<lambda>x.\n                            (let Qa = if v \\<noteq> s \\<and>\n   v \\<noteq> t \\<and> excess f' v = (0::'capacity)\nthen Q' @ [v] else Q'\n                             in return\n                                 (push_effect f' (hd Q, v), Qa)) \\<bind>\n                            (\\<lambda>(f', Qa).\n                                assert\n                                 (\\<forall>v'.\n                                     v' \\<noteq> v \\<longrightarrow>\n                                     cf_of f' (hd Q, v') =\n                                     l'.cf (hd Q, v')) \\<bind>\n                                (\\<lambda>_. return (f', l', Qa)))))\n                      \\<le> SPEC\n                             (\\<lambda>(f', l', Q').\n                                 Height_Bounded_Labeling c s t f' l' \\<and>\n                                 QD_invar u f' Q' \\<and>\n                                 ((f', l'), f, l)\n                                 \\<in> gap_algo_rel\\<^sup>* \\<and>\n                                 it - {v}\n                                 \\<subseteq> {v.\n        (u, v) \\<in> cfE_of f'} \\<and>\n                                 (excess f' u \\<noteq>\n                                  (0::'capacity) \\<longrightarrow>\n                                  (\\<forall>v\n      \\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\nl' u \\<noteq> Suc (l' v))))", "assume [simp]: \"l' u = Suc (l' v)\""], ["proof (state)\nthis:\n  l' u = Suc (l' v)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l' u = Suc (l' v); push_precond f' l' (u, v)\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (assert (Labeling c s t f' l') \\<bind>\n                        (\\<lambda>x.\n                            (let Qa = if v \\<noteq> s \\<and>\n   v \\<noteq> t \\<and> excess f' v = (0::'capacity)\nthen Q' @ [v] else Q'\n                             in return\n                                 (push_effect f' (hd Q, v), Qa)) \\<bind>\n                            (\\<lambda>(f', Qa).\n                                assert\n                                 (\\<forall>v'.\n                                     v' \\<noteq> v \\<longrightarrow>\n                                     cf_of f' (hd Q, v') =\n                                     l'.cf (hd Q, v')) \\<bind>\n                                (\\<lambda>_. return (f', l', Qa)))))\n                      \\<le> SPEC\n                             (\\<lambda>(f', l', Q').\n                                 Height_Bounded_Labeling c s t f' l' \\<and>\n                                 QD_invar u f' Q' \\<and>\n                                 ((f', l'), f, l)\n                                 \\<in> gap_algo_rel\\<^sup>* \\<and>\n                                 it - {v}\n                                 \\<subseteq> {v.\n        (u, v) \\<in> cfE_of f'} \\<and>\n                                 (excess f' u \\<noteq>\n                                  (0::'capacity) \\<longrightarrow>\n                                  (\\<forall>v\n      \\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\nl' u \\<noteq> Suc (l' v))))", "assume PRE: \"push_precond f' l' (u, v)\""], ["proof (state)\nthis:\n  push_precond f' l' (u, v)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l' u = Suc (l' v); push_precond f' l' (u, v)\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (assert (Labeling c s t f' l') \\<bind>\n                        (\\<lambda>x.\n                            (let Qa = if v \\<noteq> s \\<and>\n   v \\<noteq> t \\<and> excess f' v = (0::'capacity)\nthen Q' @ [v] else Q'\n                             in return\n                                 (push_effect f' (hd Q, v), Qa)) \\<bind>\n                            (\\<lambda>(f', Qa).\n                                assert\n                                 (\\<forall>v'.\n                                     v' \\<noteq> v \\<longrightarrow>\n                                     cf_of f' (hd Q, v') =\n                                     l'.cf (hd Q, v')) \\<bind>\n                                (\\<lambda>_. return (f', l', Qa)))))\n                      \\<le> SPEC\n                             (\\<lambda>(f', l', Q').\n                                 Height_Bounded_Labeling c s t f' l' \\<and>\n                                 QD_invar u f' Q' \\<and>\n                                 ((f', l'), f, l)\n                                 \\<in> gap_algo_rel\\<^sup>* \\<and>\n                                 it - {v}\n                                 \\<subseteq> {v.\n        (u, v) \\<in> cfE_of f'} \\<and>\n                                 (excess f' u \\<noteq>\n                                  (0::'capacity) \\<longrightarrow>\n                                  (\\<forall>v\n      \\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\nl' u \\<noteq> Suc (l' v))))", "then"], ["proof (chain)\npicking this:\n  push_precond f' l' (u, v)", "interpret pe: push_effect_locale c s t f' l' u v"], ["proof (prove)\nusing this:\n  push_precond f' l' (u, v)\n\ngoal (1 subgoal):\n 1. push_effect_locale c s t f' l' u v", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>l' u = Suc (l' v); push_precond f' l' (u, v)\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (assert (Labeling c s t f' l') \\<bind>\n                        (\\<lambda>x.\n                            (let Qa = if v \\<noteq> s \\<and>\n   v \\<noteq> t \\<and> excess f' v = (0::'capacity)\nthen Q' @ [v] else Q'\n                             in return\n                                 (push_effect f' (hd Q, v), Qa)) \\<bind>\n                            (\\<lambda>(f', Qa).\n                                assert\n                                 (\\<forall>v'.\n                                     v' \\<noteq> v \\<longrightarrow>\n                                     cf_of f' (hd Q, v') =\n                                     l'.cf (hd Q, v')) \\<bind>\n                                (\\<lambda>_. return (f', l', Qa)))))\n                      \\<le> SPEC\n                             (\\<lambda>(f', l', Q').\n                                 Height_Bounded_Labeling c s t f' l' \\<and>\n                                 QD_invar u f' Q' \\<and>\n                                 ((f', l'), f, l)\n                                 \\<in> gap_algo_rel\\<^sup>* \\<and>\n                                 it - {v}\n                                 \\<subseteq> {v.\n        (u, v) \\<in> cfE_of f'} \\<and>\n                                 (excess f' u \\<noteq>\n                                  (0::'capacity) \\<longrightarrow>\n                                  (\\<forall>v\n      \\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\nl' u \\<noteq> Suc (l' v))))", "have UVNE': \"l'.cf (u, v) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l'.cf (u, v) \\<noteq> (0::'capacity)", "using l'.resE_positive"], ["proof (prove)\nusing this:\n  ?e \\<in> l'.cf.E \\<Longrightarrow> (0::'capacity) < l'.cf ?e\n\ngoal (1 subgoal):\n 1. l'.cf (u, v) \\<noteq> (0::'capacity)", "by fastforce"], ["proof (state)\nthis:\n  l'.cf (u, v) \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l' u = Suc (l' v); push_precond f' l' (u, v)\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (assert (Labeling c s t f' l') \\<bind>\n                        (\\<lambda>x.\n                            (let Qa = if v \\<noteq> s \\<and>\n   v \\<noteq> t \\<and> excess f' v = (0::'capacity)\nthen Q' @ [v] else Q'\n                             in return\n                                 (push_effect f' (hd Q, v), Qa)) \\<bind>\n                            (\\<lambda>(f', Qa).\n                                assert\n                                 (\\<forall>v'.\n                                     v' \\<noteq> v \\<longrightarrow>\n                                     cf_of f' (hd Q, v') =\n                                     l'.cf (hd Q, v')) \\<bind>\n                                (\\<lambda>_. return (f', l', Qa)))))\n                      \\<le> SPEC\n                             (\\<lambda>(f', l', Q').\n                                 Height_Bounded_Labeling c s t f' l' \\<and>\n                                 QD_invar u f' Q' \\<and>\n                                 ((f', l'), f, l)\n                                 \\<in> gap_algo_rel\\<^sup>* \\<and>\n                                 it - {v}\n                                 \\<subseteq> {v.\n        (u, v) \\<in> cfE_of f'} \\<and>\n                                 (excess f' u \\<noteq>\n                                  (0::'capacity) \\<longrightarrow>\n                                  (\\<forall>v\n      \\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\nl' u \\<noteq> Suc (l' v))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. VCG_FRAME\n     (assert (Labeling c s t f' l') \\<bind>\n      (\\<lambda>x.\n          (let Qa = if v \\<noteq> s \\<and>\n                       v \\<noteq> t \\<and> excess f' v = (0::'capacity)\n                    then Q' @ [v] else Q'\n           in return (push_effect f' (hd Q, v), Qa)) \\<bind>\n          (\\<lambda>(f', Qa).\n              assert\n               (\\<forall>v'.\n                   v' \\<noteq> v \\<longrightarrow>\n                   cf_of f' (hd Q, v') = l'.cf (hd Q, v')) \\<bind>\n              (\\<lambda>_. return (f', l', Qa)))))\n    \\<le> SPEC\n           (\\<lambda>(f', l', Q').\n               Height_Bounded_Labeling c s t f' l' \\<and>\n               QD_invar u f' Q' \\<and>\n               ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>* \\<and>\n               it - {v} \\<subseteq> {v. (u, v) \\<in> cfE_of f'} \\<and>\n               (excess f' u \\<noteq> (0::'capacity) \\<longrightarrow>\n                (\\<forall>v\\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\n                    l' u \\<noteq> Suc (l' v))))", "apply (rule vcg_rem_frame)"], ["proof (prove)\ngoal (1 subgoal):\n 1. assert (Labeling c s t f' l') \\<bind>\n    (\\<lambda>x.\n        (let Qa = if v \\<noteq> s \\<and>\n                     v \\<noteq> t \\<and> excess f' v = (0::'capacity)\n                  then Q' @ [v] else Q'\n         in return (push_effect f' (hd Q, v), Qa)) \\<bind>\n        (\\<lambda>(f', Qa).\n            assert\n             (\\<forall>v'.\n                 v' \\<noteq> v \\<longrightarrow>\n                 cf_of f' (hd Q, v') = l'.cf (hd Q, v')) \\<bind>\n            (\\<lambda>_. return (f', l', Qa))))\n    \\<le> SPEC\n           (\\<lambda>(f', l', Q').\n               Height_Bounded_Labeling c s t f' l' \\<and>\n               QD_invar u f' Q' \\<and>\n               ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>* \\<and>\n               it - {v} \\<subseteq> {v. (u, v) \\<in> cfE_of f'} \\<and>\n               (excess f' u \\<noteq> (0::'capacity) \\<longrightarrow>\n                (\\<forall>v\\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\n                    l' u \\<noteq> Suc (l' v))))", "apply refine_vcg"], ["proof (prove)\ngoal (7 subgoals):\n 1. Labeling c s t f' l'\n 2. \\<And>a b v'.\n       \\<lbrakk>Labeling c s t f' l';\n        (push_effect f' (hd Q, v),\n         if v \\<noteq> s \\<and>\n            v \\<noteq> t \\<and> excess f' v = (0::'capacity)\n         then Q' @ [v] else Q') =\n        (a, b);\n        v' \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> cf_of a (hd Q, v') = l'.cf (hd Q, v')\n 3. \\<And>a b x1 x2 x1a x2a.\n       \\<lbrakk>Labeling c s t f' l';\n        (push_effect f' (hd Q, v),\n         if v \\<noteq> s \\<and>\n            v \\<noteq> t \\<and> excess f' v = (0::'capacity)\n         then Q' @ [v] else Q') =\n        (a, b);\n        \\<forall>v'.\n           v' \\<noteq> v \\<longrightarrow>\n           cf_of a (hd Q, v') = l'.cf (hd Q, v');\n        x2 = (x1a, x2a); (a, l', b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> Height_Bounded_Labeling c s t x1 x1a\n 4. \\<And>a b x1 x2 x1a x2a.\n       \\<lbrakk>Labeling c s t f' l';\n        (push_effect f' (hd Q, v),\n         if v \\<noteq> s \\<and>\n            v \\<noteq> t \\<and> excess f' v = (0::'capacity)\n         then Q' @ [v] else Q') =\n        (a, b);\n        \\<forall>v'.\n           v' \\<noteq> v \\<longrightarrow>\n           cf_of a (hd Q, v') = l'.cf (hd Q, v');\n        x2 = (x1a, x2a); (a, l', b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> QD_invar u x1 x2a\n 5. \\<And>a b x1 x2 x1a x2a.\n       \\<lbrakk>Labeling c s t f' l';\n        (push_effect f' (hd Q, v),\n         if v \\<noteq> s \\<and>\n            v \\<noteq> t \\<and> excess f' v = (0::'capacity)\n         then Q' @ [v] else Q') =\n        (a, b);\n        \\<forall>v'.\n           v' \\<noteq> v \\<longrightarrow>\n           cf_of a (hd Q, v') = l'.cf (hd Q, v');\n        x2 = (x1a, x2a); (a, l', b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> ((x1, x1a), f, l) \\<in> gap_algo_rel\\<^sup>*\n 6. \\<And>a b x1 x2 x1a x2a.\n       \\<lbrakk>Labeling c s t f' l';\n        (push_effect f' (hd Q, v),\n         if v \\<noteq> s \\<and>\n            v \\<noteq> t \\<and> excess f' v = (0::'capacity)\n         then Q' @ [v] else Q') =\n        (a, b);\n        \\<forall>v'.\n           v' \\<noteq> v \\<longrightarrow>\n           cf_of a (hd Q, v') = l'.cf (hd Q, v');\n        x2 = (x1a, x2a); (a, l', b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> it - {v} \\<subseteq> {v. (u, v) \\<in> cfE_of x1}\n 7. \\<And>a b x1 x2 x1a x2a.\n       \\<lbrakk>Labeling c s t f' l';\n        (push_effect f' (hd Q, v),\n         if v \\<noteq> s \\<and>\n            v \\<noteq> t \\<and> excess f' v = (0::'capacity)\n         then Q' @ [v] else Q') =\n        (a, b);\n        \\<forall>v'.\n           v' \\<noteq> v \\<longrightarrow>\n           cf_of a (hd Q, v') = l'.cf (hd Q, v');\n        x2 = (x1a, x2a); (a, l', b) = (x1, x2);\n        excess x1 u \\<noteq> (0::'capacity)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>v\\<in>{v. (u, v) \\<in> cfE_of x1} -\n  (it - {v}).\n                            x1a u \\<noteq> Suc (x1a v)", "apply (vc_solve simp: l'.push_pres_height_bound[OF PRE])"], ["proof (prove)\ngoal (6 subgoals):\n 1. Labeling c s t f' l'\n 2. \\<And>v'.\n       \\<lbrakk>Labeling c s t f' l'; v' \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v')\n 3. \\<lbrakk>Labeling c s t f' l';\n     \\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow>\n        pe.l'.cf (u, v') = l'.cf (u, v')\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> s \\<and>\n                       v \\<noteq> t \\<and>\n                       excess f' v = (0::'capacity) \\<longrightarrow>\n                       QD_invar u pe.f' (Q' @ [v])) \\<and>\n                      (v = s \\<longrightarrow>\n                       QD_invar u (push_effect f' (u, s)) Q') \\<and>\n                      (v = t \\<longrightarrow>\n                       QD_invar u (push_effect f' (u, t)) Q') \\<and>\n                      (excess f' v \\<noteq> (0::'capacity) \\<longrightarrow>\n                       QD_invar u pe.f' Q')\n 4. \\<lbrakk>Labeling c s t f' l';\n     \\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow>\n        pe.l'.cf (u, v') = l'.cf (u, v')\\<rbrakk>\n    \\<Longrightarrow> ((pe.f', l'), f, l) \\<in> gap_algo_rel\\<^sup>*\n 5. \\<And>x.\n       \\<lbrakk>Labeling c s t f' l';\n        \\<forall>v'.\n           v' \\<noteq> v \\<longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v');\n        x \\<in> it; x \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> (u, x) \\<in> pe.l'.cf.E\n 6. \\<And>va.\n       \\<lbrakk>Labeling c s t f' l';\n        \\<forall>v'.\n           v' \\<noteq> v \\<longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v');\n        excess f' u \\<noteq> pe.\\<Delta>;\n        va \\<in> it \\<longrightarrow> va = v; (u, va) \\<in> pe.l'.cf.E;\n        l' v = l' va\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Labeling c s t f' l'", "by unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>v'.\n       \\<lbrakk>Labeling c s t f' l'; v' \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v')\n 2. \\<lbrakk>Labeling c s t f' l';\n     \\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow>\n        pe.l'.cf (u, v') = l'.cf (u, v')\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> s \\<and>\n                       v \\<noteq> t \\<and>\n                       excess f' v = (0::'capacity) \\<longrightarrow>\n                       QD_invar u pe.f' (Q' @ [v])) \\<and>\n                      (v = s \\<longrightarrow>\n                       QD_invar u (push_effect f' (u, s)) Q') \\<and>\n                      (v = t \\<longrightarrow>\n                       QD_invar u (push_effect f' (u, t)) Q') \\<and>\n                      (excess f' v \\<noteq> (0::'capacity) \\<longrightarrow>\n                       QD_invar u pe.f' Q')\n 3. \\<lbrakk>Labeling c s t f' l';\n     \\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow>\n        pe.l'.cf (u, v') = l'.cf (u, v')\\<rbrakk>\n    \\<Longrightarrow> ((pe.f', l'), f, l) \\<in> gap_algo_rel\\<^sup>*\n 4. \\<And>x.\n       \\<lbrakk>Labeling c s t f' l';\n        \\<forall>v'.\n           v' \\<noteq> v \\<longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v');\n        x \\<in> it; x \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> (u, x) \\<in> pe.l'.cf.E\n 5. \\<And>va.\n       \\<lbrakk>Labeling c s t f' l';\n        \\<forall>v'.\n           v' \\<noteq> v \\<longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v');\n        excess f' u \\<noteq> pe.\\<Delta>;\n        va \\<in> it \\<longrightarrow> va = v; (u, va) \\<in> pe.l'.cf.E;\n        l' v = l' va\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Labeling c s t f' l'; v'_ \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> pe.l'.cf (u, v'_) = l'.cf (u, v'_)", "by (auto simp: pe.cf'_alt augment_edge_cf_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>Labeling c s t f' l';\n     \\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow>\n        pe.l'.cf (u, v') = l'.cf (u, v')\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> s \\<and>\n                       v \\<noteq> t \\<and>\n                       excess f' v = (0::'capacity) \\<longrightarrow>\n                       QD_invar u pe.f' (Q' @ [v])) \\<and>\n                      (v = s \\<longrightarrow>\n                       QD_invar u (push_effect f' (u, s)) Q') \\<and>\n                      (v = t \\<longrightarrow>\n                       QD_invar u (push_effect f' (u, t)) Q') \\<and>\n                      (excess f' v \\<noteq> (0::'capacity) \\<longrightarrow>\n                       QD_invar u pe.f' Q')\n 2. \\<lbrakk>Labeling c s t f' l';\n     \\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow>\n        pe.l'.cf (u, v') = l'.cf (u, v')\\<rbrakk>\n    \\<Longrightarrow> ((pe.f', l'), f, l) \\<in> gap_algo_rel\\<^sup>*\n 3. \\<And>x.\n       \\<lbrakk>Labeling c s t f' l';\n        \\<forall>v'.\n           v' \\<noteq> v \\<longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v');\n        x \\<in> it; x \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> (u, x) \\<in> pe.l'.cf.E\n 4. \\<And>va.\n       \\<lbrakk>Labeling c s t f' l';\n        \\<forall>v'.\n           v' \\<noteq> v \\<longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v');\n        excess f' u \\<noteq> pe.\\<Delta>;\n        va \\<in> it \\<longrightarrow> va = v; (u, va) \\<in> pe.l'.cf.E;\n        l' v = l' va\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Labeling c s t f' l';\n     \\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow>\n        pe.l'.cf (u, v') = l'.cf (u, v')\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> s \\<and>\n                       v \\<noteq> t \\<and>\n                       excess f' v = (0::'capacity) \\<longrightarrow>\n                       QD_invar u pe.f' (Q' @ [v])) \\<and>\n                      (v = s \\<longrightarrow>\n                       QD_invar u (push_effect f' (u, s)) Q') \\<and>\n                      (v = t \\<longrightarrow>\n                       QD_invar u (push_effect f' (u, t)) Q') \\<and>\n                      (excess f' v \\<noteq> (0::'capacity) \\<longrightarrow>\n                       QD_invar u pe.f' Q')", "using l'.push_activate_pres_QD_invar[OF QDI PRE]"], ["proof (prove)\nusing this:\n  \\<lbrakk>s \\<noteq> v; t \\<noteq> v; excess f' v = (0::'capacity)\\<rbrakk>\n  \\<Longrightarrow> QD_invar u pe.f' (Q' @ [v])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Labeling c s t f' l';\n     \\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow>\n        pe.l'.cf (u, v') = l'.cf (u, v')\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> s \\<and>\n                       v \\<noteq> t \\<and>\n                       excess f' v = (0::'capacity) \\<longrightarrow>\n                       QD_invar u pe.f' (Q' @ [v])) \\<and>\n                      (v = s \\<longrightarrow>\n                       QD_invar u (push_effect f' (u, s)) Q') \\<and>\n                      (v = t \\<longrightarrow>\n                       QD_invar u (push_effect f' (u, t)) Q') \\<and>\n                      (excess f' v \\<noteq> (0::'capacity) \\<longrightarrow>\n                       QD_invar u pe.f' Q')", "using l'.push_no_activate_pres_QD_invar[OF QDI PRE]"], ["proof (prove)\nusing this:\n  \\<lbrakk>s \\<noteq> v; t \\<noteq> v; excess f' v = (0::'capacity)\\<rbrakk>\n  \\<Longrightarrow> QD_invar u pe.f' (Q' @ [v])\n  s = v \\<or>\n  t = v \\<or> excess f' v \\<noteq> (0::'capacity) \\<Longrightarrow>\n  QD_invar u pe.f' Q'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Labeling c s t f' l';\n     \\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow>\n        pe.l'.cf (u, v') = l'.cf (u, v')\\<rbrakk>\n    \\<Longrightarrow> (v \\<noteq> s \\<and>\n                       v \\<noteq> t \\<and>\n                       excess f' v = (0::'capacity) \\<longrightarrow>\n                       QD_invar u pe.f' (Q' @ [v])) \\<and>\n                      (v = s \\<longrightarrow>\n                       QD_invar u (push_effect f' (u, s)) Q') \\<and>\n                      (v = t \\<longrightarrow>\n                       QD_invar u (push_effect f' (u, t)) Q') \\<and>\n                      (excess f' v \\<noteq> (0::'capacity) \\<longrightarrow>\n                       QD_invar u pe.f' Q')", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>Labeling c s t f' l';\n     \\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow>\n        pe.l'.cf (u, v') = l'.cf (u, v')\\<rbrakk>\n    \\<Longrightarrow> ((pe.f', l'), f, l) \\<in> gap_algo_rel\\<^sup>*\n 2. \\<And>x.\n       \\<lbrakk>Labeling c s t f' l';\n        \\<forall>v'.\n           v' \\<noteq> v \\<longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v');\n        x \\<in> it; x \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> (u, x) \\<in> pe.l'.cf.E\n 3. \\<And>va.\n       \\<lbrakk>Labeling c s t f' l';\n        \\<forall>v'.\n           v' \\<noteq> v \\<longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v');\n        excess f' u \\<noteq> pe.\\<Delta>;\n        va \\<in> it \\<longrightarrow> va = v; (u, va) \\<in> pe.l'.cf.E;\n        l' v = l' va\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Labeling c s t f' l';\n     \\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow>\n        pe.l'.cf (u, v') = l'.cf (u, v')\\<rbrakk>\n    \\<Longrightarrow> ((pe.f', l'), f, l) \\<in> gap_algo_rel\\<^sup>*", "by (meson gap_algo_rel.push REL PRE converse_rtrancl_into_rtrancl HBL)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Labeling c s t f' l';\n        \\<forall>v'.\n           v' \\<noteq> v \\<longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v');\n        x \\<in> it; x \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> (u, x) \\<in> pe.l'.cf.E\n 2. \\<And>va.\n       \\<lbrakk>Labeling c s t f' l';\n        \\<forall>v'.\n           v' \\<noteq> v \\<longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v');\n        excess f' u \\<noteq> pe.\\<Delta>;\n        va \\<in> it \\<longrightarrow> va = v; (u, va) \\<in> pe.l'.cf.E;\n        l' v = l' va\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Labeling c s t f' l';\n     \\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v');\n     x \\<in> it; x \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> (u, x) \\<in> pe.l'.cf.E", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Labeling c s t f' l';\n     \\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v');\n     x \\<in> it; x \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> (u, x) \\<in> pe.l'.cf.E", "assume \"x\\<in>it\" \"x\\<noteq>v\""], ["proof (state)\nthis:\n  x \\<in> it\n  x \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Labeling c s t f' l';\n     \\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v');\n     x \\<in> it; x \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> (u, x) \\<in> pe.l'.cf.E", "with ITSS"], ["proof (chain)\npicking this:\n  it \\<subseteq> {v. (u, v) \\<in> l'.cf.E}\n  x \\<in> it\n  x \\<noteq> v", "have \"(u,x)\\<in>l'.cf.E\""], ["proof (prove)\nusing this:\n  it \\<subseteq> {v. (u, v) \\<in> l'.cf.E}\n  x \\<in> it\n  x \\<noteq> v\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> l'.cf.E", "by auto"], ["proof (state)\nthis:\n  (u, x) \\<in> l'.cf.E\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Labeling c s t f' l';\n     \\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v');\n     x \\<in> it; x \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> (u, x) \\<in> pe.l'.cf.E", "thus ?thesis"], ["proof (prove)\nusing this:\n  (u, x) \\<in> l'.cf.E\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> pe.l'.cf.E", "using \\<open>x\\<noteq>v\\<close>"], ["proof (prove)\nusing this:\n  (u, x) \\<in> l'.cf.E\n  x \\<noteq> v\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> pe.l'.cf.E", "unfolding pe.f'_alt"], ["proof (prove)\nusing this:\n  (u, x) \\<in> l'.cf.E\n  x \\<noteq> v\n\ngoal (1 subgoal):\n 1. (u, x) \\<in> cfE_of (augment_edge f' (u, v) pe.\\<Delta>)", "apply (simp add: augment_edge_cf')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, x) \\<in> l'.cf.E; x \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> (u, x)\n                      \\<in> Graph.E\n                             (l'.cf\n                              ((u, v) := l'.cf (u, v) - pe.\\<Delta>,\n                               (v, u) := l'.cf (v, u) + pe.\\<Delta>))", "unfolding Graph.E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, x) \\<in> {(u, v). l'.cf (u, v) \\<noteq> (0::'capacity)};\n     x \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> (u, x)\n                      \\<in> {(ua, va).\n                             (l'.cf\n                              ((u, v) := l'.cf (u, v) - pe.\\<Delta>,\n                               (v, u) := l'.cf (v, u) + pe.\\<Delta>))\n                              (ua, va) \\<noteq>\n                             (0::'capacity)}", "by (auto)"], ["proof (state)\nthis:\n  (u, x) \\<in> pe.l'.cf.E\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>va.\n       \\<lbrakk>Labeling c s t f' l';\n        \\<forall>v'.\n           v' \\<noteq> v \\<longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v');\n        excess f' u \\<noteq> pe.\\<Delta>;\n        va \\<in> it \\<longrightarrow> va = v; (u, va) \\<in> pe.l'.cf.E;\n        l' v = l' va\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for v'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Labeling c s t f' l';\n     \\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v');\n     excess f' u \\<noteq> pe.\\<Delta>; v' \\<in> it \\<longrightarrow> v' = v;\n     (u, v') \\<in> pe.l'.cf.E; l' v = l' v'\\<rbrakk>\n    \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Labeling c s t f' l';\n     \\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v');\n     excess f' u \\<noteq> pe.\\<Delta>; v' \\<in> it \\<longrightarrow> v' = v;\n     (u, v') \\<in> pe.l'.cf.E; l' v = l' v'\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"excess f' u \\<noteq> pe.\\<Delta>\""], ["proof (state)\nthis:\n  excess f' u \\<noteq> pe.\\<Delta>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Labeling c s t f' l';\n     \\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v');\n     excess f' u \\<noteq> pe.\\<Delta>; v' \\<in> it \\<longrightarrow> v' = v;\n     (u, v') \\<in> pe.l'.cf.E; l' v = l' v'\\<rbrakk>\n    \\<Longrightarrow> False", "hence PED: \"pe.\\<Delta> = l'.cf (u,v)\""], ["proof (prove)\nusing this:\n  excess f' u \\<noteq> pe.\\<Delta>\n\ngoal (1 subgoal):\n 1. pe.\\<Delta> = l'.cf (u, v)", "unfolding pe.\\<Delta>_def"], ["proof (prove)\nusing this:\n  excess f' u \\<noteq> min (excess f' u) (l'.cf (u, v))\n\ngoal (1 subgoal):\n 1. min (excess f' u) (l'.cf (u, v)) = l'.cf (u, v)", "by auto"], ["proof (state)\nthis:\n  pe.\\<Delta> = l'.cf (u, v)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Labeling c s t f' l';\n     \\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v');\n     excess f' u \\<noteq> pe.\\<Delta>; v' \\<in> it \\<longrightarrow> v' = v;\n     (u, v') \\<in> pe.l'.cf.E; l' v = l' v'\\<rbrakk>\n    \\<Longrightarrow> False", "hence E'SS: \"pe.l'.cf.E \\<subseteq> (l'.cf.E \\<union> {(v,u)}) - {(u,v)}\""], ["proof (prove)\nusing this:\n  pe.\\<Delta> = l'.cf (u, v)\n\ngoal (1 subgoal):\n 1. pe.l'.cf.E \\<subseteq> l'.cf.E \\<union> {(v, u)} - {(u, v)}", "unfolding pe.f'_alt"], ["proof (prove)\nusing this:\n  pe.\\<Delta> = l'.cf (u, v)\n\ngoal (1 subgoal):\n 1. cfE_of (augment_edge f' (u, v) pe.\\<Delta>)\n    \\<subseteq> l'.cf.E \\<union> {(v, u)} - {(u, v)}", "apply (simp add: augment_edge_cf')"], ["proof (prove)\ngoal (1 subgoal):\n 1. pe.\\<Delta> = l'.cf (u, v) \\<Longrightarrow>\n    Graph.E\n     (l'.cf((u, v) := 0::'capacity, (v, u) := l'.cf (v, u) + l'.cf (u, v)))\n    \\<subseteq> insert (v, u) l'.cf.E - {(u, v)}", "unfolding Graph.E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pe.\\<Delta> = l'.cf (u, v) \\<Longrightarrow>\n    {(ua, va).\n     (l'.cf((u, v) := 0::'capacity, (v, u) := l'.cf (v, u) + l'.cf (u, v)))\n      (ua, va) \\<noteq>\n     (0::'capacity)}\n    \\<subseteq> insert (v, u)\n                 {(u, v). l'.cf (u, v) \\<noteq> (0::'capacity)} -\n                {(u, v)}", "by auto"], ["proof (state)\nthis:\n  pe.l'.cf.E \\<subseteq> l'.cf.E \\<union> {(v, u)} - {(u, v)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Labeling c s t f' l';\n     \\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v');\n     excess f' u \\<noteq> pe.\\<Delta>; v' \\<in> it \\<longrightarrow> v' = v;\n     (u, v') \\<in> pe.l'.cf.E; l' v = l' v'\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"v' \\<in> it \\<longrightarrow> v' = v\" and UV'E: \"(u, v') \\<in> pe.l'.cf.E\" and LUSLV': \"l' v = l' v'\""], ["proof (state)\nthis:\n  v' \\<in> it \\<longrightarrow> v' = v\n  (u, v') \\<in> pe.l'.cf.E\n  l' v = l' v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Labeling c s t f' l';\n     \\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v');\n     excess f' u \\<noteq> pe.\\<Delta>; v' \\<in> it \\<longrightarrow> v' = v;\n     (u, v') \\<in> pe.l'.cf.E; l' v = l' v'\\<rbrakk>\n    \\<Longrightarrow> False", "with E'SS"], ["proof (chain)\npicking this:\n  pe.l'.cf.E \\<subseteq> l'.cf.E \\<union> {(v, u)} - {(u, v)}\n  v' \\<in> it \\<longrightarrow> v' = v\n  (u, v') \\<in> pe.l'.cf.E\n  l' v = l' v'", "have \"v'\\<notin>it\""], ["proof (prove)\nusing this:\n  pe.l'.cf.E \\<subseteq> l'.cf.E \\<union> {(v, u)} - {(u, v)}\n  v' \\<in> it \\<longrightarrow> v' = v\n  (u, v') \\<in> pe.l'.cf.E\n  l' v = l' v'\n\ngoal (1 subgoal):\n 1. v' \\<notin> it", "by auto"], ["proof (state)\nthis:\n  v' \\<notin> it\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Labeling c s t f' l';\n     \\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v');\n     excess f' u \\<noteq> pe.\\<Delta>; v' \\<in> it \\<longrightarrow> v' = v;\n     (u, v') \\<in> pe.l'.cf.E; l' v = l' v'\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  v' \\<notin> it\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Labeling c s t f' l';\n     \\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v');\n     excess f' u \\<noteq> pe.\\<Delta>; v' \\<in> it \\<longrightarrow> v' = v;\n     (u, v') \\<in> pe.l'.cf.E; l' v = l' v'\\<rbrakk>\n    \\<Longrightarrow> False", "from UV'E E'SS pe.uv_not_eq(2)"], ["proof (chain)\npicking this:\n  (u, v') \\<in> pe.l'.cf.E\n  pe.l'.cf.E \\<subseteq> l'.cf.E \\<union> {(v, u)} - {(u, v)}\n  v \\<noteq> u", "have \"(u,v')\\<in>l'.cf.E\""], ["proof (prove)\nusing this:\n  (u, v') \\<in> pe.l'.cf.E\n  pe.l'.cf.E \\<subseteq> l'.cf.E \\<union> {(v, u)} - {(u, v)}\n  v \\<noteq> u\n\ngoal (1 subgoal):\n 1. (u, v') \\<in> l'.cf.E", "by auto"], ["proof (state)\nthis:\n  (u, v') \\<in> l'.cf.E\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Labeling c s t f' l';\n     \\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v');\n     excess f' u \\<noteq> pe.\\<Delta>; v' \\<in> it \\<longrightarrow> v' = v;\n     (u, v') \\<in> pe.l'.cf.E; l' v = l' v'\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  v' \\<notin> it\n  (u, v') \\<in> l'.cf.E", "have \"l' u \\<noteq> Suc (l' v')\""], ["proof (prove)\nusing this:\n  v' \\<notin> it\n  (u, v') \\<in> l'.cf.E\n\ngoal (1 subgoal):\n 1. l' u \\<noteq> Suc (l' v')", "using SAT_EDGES"], ["proof (prove)\nusing this:\n  v' \\<notin> it\n  (u, v') \\<in> l'.cf.E\n  \\<forall>v\\<in>{v. (u, v) \\<in> l'.cf.E} - it. l' u \\<noteq> Suc (l' v)\n\ngoal (1 subgoal):\n 1. l' u \\<noteq> Suc (l' v')", "by auto"], ["proof (state)\nthis:\n  l' u \\<noteq> Suc (l' v')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Labeling c s t f' l';\n     \\<forall>v'.\n        v' \\<noteq> v \\<longrightarrow> pe.l'.cf (u, v') = l'.cf (u, v');\n     excess f' u \\<noteq> pe.\\<Delta>; v' \\<in> it \\<longrightarrow> v' = v;\n     (u, v') \\<in> pe.l'.cf.E; l' v = l' v'\\<rbrakk>\n    \\<Longrightarrow> False", "with LUSLV'"], ["proof (chain)\npicking this:\n  l' v = l' v'\n  l' u \\<noteq> Suc (l' v')", "show False"], ["proof (prove)\nusing this:\n  l' v = l' v'\n  l' u \\<noteq> Suc (l' v')\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  VCG_FRAME\n   (assert (Labeling c s t f' l') \\<bind>\n    (\\<lambda>x.\n        (let Qa = if v \\<noteq> s \\<and>\n                     v \\<noteq> t \\<and> excess f' v = (0::'capacity)\n                  then Q' @ [v] else Q'\n         in return (push_effect f' (hd Q, v), Qa)) \\<bind>\n        (\\<lambda>(f', Qa).\n            assert\n             (\\<forall>v'.\n                 v' \\<noteq> v \\<longrightarrow>\n                 cf_of f' (hd Q, v') = l'.cf (hd Q, v')) \\<bind>\n            (\\<lambda>_. return (f', l', Qa)))))\n  \\<le> SPEC\n         (\\<lambda>(f', l', Q').\n             Height_Bounded_Labeling c s t f' l' \\<and>\n             QD_invar u f' Q' \\<and>\n             ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>* \\<and>\n             it - {v} \\<subseteq> {v. (u, v) \\<in> cfE_of f'} \\<and>\n             (excess f' u \\<noteq> (0::'capacity) \\<longrightarrow>\n              (\\<forall>v\\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\n                  l' u \\<noteq> Suc (l' v))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>l' u \\<noteq> Suc (l' v); x \\<in> it; x \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> (u, x) \\<in> l'.cf.E\n 2. \\<And>va.\n       \\<lbrakk>l' va \\<noteq> l' v; excess f' u \\<noteq> (0::'capacity);\n        va \\<in> it \\<longrightarrow> va = v; (u, va) \\<in> l'.cf.E;\n        l' u = Suc (l' va)\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l' u \\<noteq> Suc (l' v); x_ \\<in> it; x_ \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> (u, x_) \\<in> l'.cf.E", "using ITSS"], ["proof (prove)\nusing this:\n  it \\<subseteq> {v. (u, v) \\<in> l'.cf.E}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l' u \\<noteq> Suc (l' v); x_ \\<in> it; x_ \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> (u, x_) \\<in> l'.cf.E", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>va.\n       \\<lbrakk>l' va \\<noteq> l' v; excess f' u \\<noteq> (0::'capacity);\n        va \\<in> it \\<longrightarrow> va = v; (u, va) \\<in> l'.cf.E;\n        l' u = Suc (l' va)\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l' va_ \\<noteq> l' v; excess f' u \\<noteq> (0::'capacity);\n     va_ \\<in> it \\<longrightarrow> va_ = v; (u, va_) \\<in> l'.cf.E;\n     l' u = Suc (l' va_)\\<rbrakk>\n    \\<Longrightarrow> False", "using SAT_EDGES"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>{v. (u, v) \\<in> l'.cf.E} - it. l' u \\<noteq> Suc (l' v)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l' va_ \\<noteq> l' v; excess f' u \\<noteq> (0::'capacity);\n     va_ \\<in> it \\<longrightarrow> va_ = v; (u, va_) \\<in> l'.cf.E;\n     l' u = Suc (l' va_)\\<rbrakk>\n    \\<Longrightarrow> False", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  VCG_FRAME\n   (if l' (hd Q) = l' v + 1\n    then assert (push_precond f' l' (hd Q, v)) \\<bind>\n         (\\<lambda>x.\n             assert (Labeling c s t f' l') \\<bind>\n             (\\<lambda>x.\n                 (let Qa = if v \\<noteq> s \\<and>\n                              v \\<noteq> t \\<and>\n                              excess f' v = (0::'capacity)\n                           then Q' @ [v] else Q'\n                  in return (push_effect f' (hd Q, v), Qa)) \\<bind>\n                 (\\<lambda>(f', Qa).\n                     assert\n                      (\\<forall>v'.\n                          v' \\<noteq> v \\<longrightarrow>\n                          cf_of f' (hd Q, v') = l'.cf (hd Q, v')) \\<bind>\n                     (\\<lambda>_. return (f', l', Qa)))))\n    else return (f', l', Q'))\n  \\<le> SPEC\n         (\\<lambda>(f', l', Q').\n             Height_Bounded_Labeling c s t f' l' \\<and>\n             QD_invar u f' Q' \\<and>\n             ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>* \\<and>\n             it - {v} \\<subseteq> {v. (u, v) \\<in> cfE_of f'} \\<and>\n             (excess f' u \\<noteq> (0::'capacity) \\<longrightarrow>\n              (\\<forall>v\\<in>{v. (u, v) \\<in> cfE_of f'} - (it - {v}).\n                  l' u \\<noteq> Suc (l' v))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>ab aaa baa.\n       \\<lbrakk>QD_invar u f Qr; excess ab u \\<noteq> (0::'capacity);\n        u \\<in> V; Height_Bounded_Labeling c s t ab aaa; u \\<noteq> s;\n        u \\<noteq> t; QD_invar u ab baa;\n        ((ab, aaa), f, l) \\<in> gap_algo_rel\\<^sup>*;\n        \\<forall>v.\n           (u, v) \\<in> cfE_of ab \\<longrightarrow>\n           aaa u \\<noteq> Suc (aaa v)\\<rbrakk>\n       \\<Longrightarrow> VCG_FRAME\n                          (assert (hd Q \\<in> V - {s, t}) \\<bind>\n                           (\\<lambda>x.\n                               assert\n                                (Height_Bounded_Labeling c s t ab\n                                  aaa) \\<bind>\n                               (\\<lambda>x.\n                                   (let Qa = baa @ [hd Q]\n                                    in assert\n  (relabel_precond ab aaa (hd Q)) \\<bind>\n (\\<lambda>_.\n     assert\n      (aaa (hd Q) < 2 * card V \\<and>\n       relabel_effect ab aaa (hd Q) (hd Q) < 2 * card V) \\<bind>\n     (\\<lambda>_.\n         let l = gap_relabel_effect ab aaa (hd Q)\n         in return (l, Qa)))) \\<bind>\n                                   (\\<lambda>(l, Q). return (ab, l, Q)))))\n                         \\<le> SPEC\n                                (\\<lambda>(f', l', Q').\n                                    Height_Bounded_Labeling c s t f'\n                                     l' \\<and>\n                                    Q_invar f' Q' \\<and>\n                                    ((f', l'), f, l)\n                                    \\<in> gap_algo_rel\\<^sup>+)\n 2. \\<And>aaa baa x1.\n       \\<lbrakk>QD_invar u f Qr; excess x1 u = (0::'capacity); u \\<in> V;\n        Height_Bounded_Labeling c s t x1 aaa; u \\<noteq> s; u \\<noteq> t;\n        QD_invar u x1 baa;\n        ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> Q_invar x1 baa\n 3. \\<And>aaa baa x1.\n       \\<lbrakk>QD_invar u f Qr; excess x1 u = (0::'capacity); u \\<in> V;\n        Height_Bounded_Labeling c s t x1 aaa; u \\<noteq> s; u \\<noteq> t;\n        QD_invar u x1 baa;\n        ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>+\n 4. \\<And>it aaa baa x1.\n       \\<lbrakk>QD_invar u f Qr; it \\<noteq> {};\n        it \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n        excess x1 u = (0::'capacity); u \\<in> V;\n        Height_Bounded_Labeling c s t x1 aaa; u \\<noteq> s; u \\<noteq> t;\n        QD_invar u x1 baa; ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>*;\n        it \\<subseteq> {v. (u, v) \\<in> cfE_of x1}\\<rbrakk>\n       \\<Longrightarrow> Q_invar x1 baa\n 5. \\<And>it aaa baa x1.\n       \\<lbrakk>QD_invar u f Qr; it \\<noteq> {};\n        it \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n        excess x1 u = (0::'capacity); u \\<in> V;\n        Height_Bounded_Labeling c s t x1 aaa; u \\<noteq> s; u \\<noteq> t;\n        QD_invar u x1 baa; ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>*;\n        it \\<subseteq> {v. (u, v) \\<in> cfE_of x1}\\<rbrakk>\n       \\<Longrightarrow> ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>+", "subgoal premises prems for f' l' Q'"], ["proof (prove)\ngoal (1 subgoal):\n 1. VCG_FRAME\n     (assert (hd Q \\<in> V - {s, t}) \\<bind>\n      (\\<lambda>x.\n          assert (Height_Bounded_Labeling c s t f' l') \\<bind>\n          (\\<lambda>x.\n              (let Qa = Q' @ [hd Q]\n               in assert (relabel_precond f' l' (hd Q)) \\<bind>\n                  (\\<lambda>_.\n                      assert\n                       (l' (hd Q) < 2 * card V \\<and>\n                        relabel_effect f' l' (hd Q) (hd Q)\n                        < 2 * card V) \\<bind>\n                      (\\<lambda>_.\n                          let l = gap_relabel_effect f' l' (hd Q)\n                          in return (l, Qa)))) \\<bind>\n              (\\<lambda>(l, Q). return (f', l, Q)))))\n    \\<le> SPEC\n           (\\<lambda>(f', l', Q').\n               Height_Bounded_Labeling c s t f' l' \\<and>\n               Q_invar f' Q' \\<and>\n               ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>+)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. VCG_FRAME\n     (assert (hd Q \\<in> V - {s, t}) \\<bind>\n      (\\<lambda>x.\n          assert (Height_Bounded_Labeling c s t f' l') \\<bind>\n          (\\<lambda>x.\n              (let Qa = Q' @ [hd Q]\n               in assert (relabel_precond f' l' (hd Q)) \\<bind>\n                  (\\<lambda>_.\n                      assert\n                       (l' (hd Q) < 2 * card V \\<and>\n                        relabel_effect f' l' (hd Q) (hd Q)\n                        < 2 * card V) \\<bind>\n                      (\\<lambda>_.\n                          let l = gap_relabel_effect f' l' (hd Q)\n                          in return (l, Qa)))) \\<bind>\n              (\\<lambda>(l, Q). return (f', l, Q)))))\n    \\<le> SPEC\n           (\\<lambda>(f', l', Q').\n               Height_Bounded_Labeling c s t f' l' \\<and>\n               Q_invar f' Q' \\<and>\n               ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>+)", "from prems"], ["proof (chain)\npicking this:\n  QD_invar u f Qr\n  excess f' u \\<noteq> (0::'capacity)\n  u \\<in> V\n  Height_Bounded_Labeling c s t f' l'\n  u \\<noteq> s\n  u \\<noteq> t\n  QD_invar u f' Q'\n  ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>*\n  \\<forall>v.\n     (u, v) \\<in> cfE_of f' \\<longrightarrow> l' u \\<noteq> Suc (l' v)", "interpret l': Height_Bounded_Labeling c s t f' l'"], ["proof (prove)\nusing this:\n  QD_invar u f Qr\n  excess f' u \\<noteq> (0::'capacity)\n  u \\<in> V\n  Height_Bounded_Labeling c s t f' l'\n  u \\<noteq> s\n  u \\<noteq> t\n  QD_invar u f' Q'\n  ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>*\n  \\<forall>v.\n     (u, v) \\<in> cfE_of f' \\<longrightarrow> l' u \\<noteq> Suc (l' v)\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f' l'", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. VCG_FRAME\n     (assert (hd Q \\<in> V - {s, t}) \\<bind>\n      (\\<lambda>x.\n          assert (Height_Bounded_Labeling c s t f' l') \\<bind>\n          (\\<lambda>x.\n              (let Qa = Q' @ [hd Q]\n               in assert (relabel_precond f' l' (hd Q)) \\<bind>\n                  (\\<lambda>_.\n                      assert\n                       (l' (hd Q) < 2 * card V \\<and>\n                        relabel_effect f' l' (hd Q) (hd Q)\n                        < 2 * card V) \\<bind>\n                      (\\<lambda>_.\n                          let l = gap_relabel_effect f' l' (hd Q)\n                          in return (l, Qa)))) \\<bind>\n              (\\<lambda>(l, Q). return (f', l, Q)))))\n    \\<le> SPEC\n           (\\<lambda>(f', l', Q').\n               Height_Bounded_Labeling c s t f' l' \\<and>\n               Q_invar f' Q' \\<and>\n               ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>+)", "from prems"], ["proof (chain)\npicking this:\n  QD_invar u f Qr\n  excess f' u \\<noteq> (0::'capacity)\n  u \\<in> V\n  Height_Bounded_Labeling c s t f' l'\n  u \\<noteq> s\n  u \\<noteq> t\n  QD_invar u f' Q'\n  ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>*\n  \\<forall>v.\n     (u, v) \\<in> l'.cf.E \\<longrightarrow> l' u \\<noteq> Suc (l' v)", "have UI: \"u\\<in>V\" \"u\\<noteq>s\" \"u\\<noteq>t\" \n        and X: \"excess f' u \\<noteq> 0\" \n        and QDI: \"QD_invar u f' Q'\"\n        and REL: \"((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>*\"\n        and NO_ADM: \"\\<forall>v. (u, v) \\<in> l'.cf.E \\<longrightarrow> l' u \\<noteq> Suc (l' v)\""], ["proof (prove)\nusing this:\n  QD_invar u f Qr\n  excess f' u \\<noteq> (0::'capacity)\n  u \\<in> V\n  Height_Bounded_Labeling c s t f' l'\n  u \\<noteq> s\n  u \\<noteq> t\n  QD_invar u f' Q'\n  ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>*\n  \\<forall>v.\n     (u, v) \\<in> l'.cf.E \\<longrightarrow> l' u \\<noteq> Suc (l' v)\n\ngoal (1 subgoal):\n 1. ((u \\<in> V &&& u \\<noteq> s &&& u \\<noteq> t) &&&\n     excess f' u \\<noteq> (0::'capacity)) &&&\n    QD_invar u f' Q' &&&\n    ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>* &&&\n    \\<forall>v.\n       (u, v) \\<in> l'.cf.E \\<longrightarrow> l' u \\<noteq> Suc (l' v)", "by simp_all"], ["proof (state)\nthis:\n  u \\<in> V\n  u \\<noteq> s\n  u \\<noteq> t\n  excess f' u \\<noteq> (0::'capacity)\n  QD_invar u f' Q'\n  ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>*\n  \\<forall>v.\n     (u, v) \\<in> l'.cf.E \\<longrightarrow> l' u \\<noteq> Suc (l' v)\n\ngoal (1 subgoal):\n 1. VCG_FRAME\n     (assert (hd Q \\<in> V - {s, t}) \\<bind>\n      (\\<lambda>x.\n          assert (Height_Bounded_Labeling c s t f' l') \\<bind>\n          (\\<lambda>x.\n              (let Qa = Q' @ [hd Q]\n               in assert (relabel_precond f' l' (hd Q)) \\<bind>\n                  (\\<lambda>_.\n                      assert\n                       (l' (hd Q) < 2 * card V \\<and>\n                        relabel_effect f' l' (hd Q) (hd Q)\n                        < 2 * card V) \\<bind>\n                      (\\<lambda>_.\n                          let l = gap_relabel_effect f' l' (hd Q)\n                          in return (l, Qa)))) \\<bind>\n              (\\<lambda>(l, Q). return (f', l, Q)))))\n    \\<le> SPEC\n           (\\<lambda>(f', l', Q').\n               Height_Bounded_Labeling c s t f' l' \\<and>\n               Q_invar f' Q' \\<and>\n               ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>+)", "from X"], ["proof (chain)\npicking this:\n  excess f' u \\<noteq> (0::'capacity)", "have X': \"excess f' u > 0\""], ["proof (prove)\nusing this:\n  excess f' u \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. (0::'capacity) < excess f' u", "using l'.excess_non_negative UI"], ["proof (prove)\nusing this:\n  excess f' u \\<noteq> (0::'capacity)\n  \\<forall>v\\<in>V - {s, t}. (0::'capacity) \\<le> excess f' v\n  u \\<in> V\n  u \\<noteq> s\n  u \\<noteq> t\n\ngoal (1 subgoal):\n 1. (0::'capacity) < excess f' u", "by force"], ["proof (state)\nthis:\n  (0::'capacity) < excess f' u\n\ngoal (1 subgoal):\n 1. VCG_FRAME\n     (assert (hd Q \\<in> V - {s, t}) \\<bind>\n      (\\<lambda>x.\n          assert (Height_Bounded_Labeling c s t f' l') \\<bind>\n          (\\<lambda>x.\n              (let Qa = Q' @ [hd Q]\n               in assert (relabel_precond f' l' (hd Q)) \\<bind>\n                  (\\<lambda>_.\n                      assert\n                       (l' (hd Q) < 2 * card V \\<and>\n                        relabel_effect f' l' (hd Q) (hd Q)\n                        < 2 * card V) \\<bind>\n                      (\\<lambda>_.\n                          let l = gap_relabel_effect f' l' (hd Q)\n                          in return (l, Qa)))) \\<bind>\n              (\\<lambda>(l, Q). return (f', l, Q)))))\n    \\<le> SPEC\n           (\\<lambda>(f', l', Q').\n               Height_Bounded_Labeling c s t f' l' \\<and>\n               Q_invar f' Q' \\<and>\n               ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>+)", "from X' UI NO_ADM"], ["proof (chain)\npicking this:\n  (0::'capacity) < excess f' u\n  u \\<in> V\n  u \\<noteq> s\n  u \\<noteq> t\n  \\<forall>v.\n     (u, v) \\<in> l'.cf.E \\<longrightarrow> l' u \\<noteq> Suc (l' v)", "have PRE: \"relabel_precond f' l' u\""], ["proof (prove)\nusing this:\n  (0::'capacity) < excess f' u\n  u \\<in> V\n  u \\<noteq> s\n  u \\<noteq> t\n  \\<forall>v.\n     (u, v) \\<in> l'.cf.E \\<longrightarrow> l' u \\<noteq> Suc (l' v)\n\ngoal (1 subgoal):\n 1. relabel_precond f' l' u", "unfolding relabel_precond_def"], ["proof (prove)\nusing this:\n  (0::'capacity) < excess f' u\n  u \\<in> V\n  u \\<noteq> s\n  u \\<noteq> t\n  \\<forall>v.\n     (u, v) \\<in> l'.cf.E \\<longrightarrow> l' u \\<noteq> Suc (l' v)\n\ngoal (1 subgoal):\n 1. u \\<noteq> t \\<and>\n    (0::'capacity) < excess f' u \\<and>\n    (\\<forall>v.\n        (u, v) \\<in> l'.cf.E \\<longrightarrow> l' u \\<noteq> l' v + 1)", "by auto"], ["proof (state)\nthis:\n  relabel_precond f' l' u\n\ngoal (1 subgoal):\n 1. VCG_FRAME\n     (assert (hd Q \\<in> V - {s, t}) \\<bind>\n      (\\<lambda>x.\n          assert (Height_Bounded_Labeling c s t f' l') \\<bind>\n          (\\<lambda>x.\n              (let Qa = Q' @ [hd Q]\n               in assert (relabel_precond f' l' (hd Q)) \\<bind>\n                  (\\<lambda>_.\n                      assert\n                       (l' (hd Q) < 2 * card V \\<and>\n                        relabel_effect f' l' (hd Q) (hd Q)\n                        < 2 * card V) \\<bind>\n                      (\\<lambda>_.\n                          let l = gap_relabel_effect f' l' (hd Q)\n                          in return (l, Qa)))) \\<bind>\n              (\\<lambda>(l, Q). return (f', l, Q)))))\n    \\<le> SPEC\n           (\\<lambda>(f', l', Q').\n               Height_Bounded_Labeling c s t f' l' \\<and>\n               Q_invar f' Q' \\<and>\n               ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>+)", "from l'.height_bound \\<open>u\\<in>V\\<close> card_V_ge2"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>V. l' u \\<le> 2 * card V - 1\n  u \\<in> V\n  2 \\<le> card V", "have [simp]: \"l' u < 2*card V\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>V. l' u \\<le> 2 * card V - 1\n  u \\<in> V\n  2 \\<le> card V\n\ngoal (1 subgoal):\n 1. l' u < 2 * card V", "by auto"], ["proof (state)\nthis:\n  l' u < 2 * card V\n\ngoal (1 subgoal):\n 1. VCG_FRAME\n     (assert (hd Q \\<in> V - {s, t}) \\<bind>\n      (\\<lambda>x.\n          assert (Height_Bounded_Labeling c s t f' l') \\<bind>\n          (\\<lambda>x.\n              (let Qa = Q' @ [hd Q]\n               in assert (relabel_precond f' l' (hd Q)) \\<bind>\n                  (\\<lambda>_.\n                      assert\n                       (l' (hd Q) < 2 * card V \\<and>\n                        relabel_effect f' l' (hd Q) (hd Q)\n                        < 2 * card V) \\<bind>\n                      (\\<lambda>_.\n                          let l = gap_relabel_effect f' l' (hd Q)\n                          in return (l, Qa)))) \\<bind>\n              (\\<lambda>(l, Q). return (f', l, Q)))))\n    \\<le> SPEC\n           (\\<lambda>(f', l', Q').\n               Height_Bounded_Labeling c s t f' l' \\<and>\n               Q_invar f' Q' \\<and>\n               ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>+)", "from l'.relabel_pres_height_bound[OF PRE]"], ["proof (chain)\npicking this:\n  Height_Bounded_Labeling c s t f' (relabel_effect f' l' u)", "interpret l'': Height_Bounded_Labeling c s t f' \"relabel_effect f' l' u\""], ["proof (prove)\nusing this:\n  Height_Bounded_Labeling c s t f' (relabel_effect f' l' u)\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f' (relabel_effect f' l' u)", "."], ["proof (state)\ngoal (1 subgoal):\n 1. VCG_FRAME\n     (assert (hd Q \\<in> V - {s, t}) \\<bind>\n      (\\<lambda>x.\n          assert (Height_Bounded_Labeling c s t f' l') \\<bind>\n          (\\<lambda>x.\n              (let Qa = Q' @ [hd Q]\n               in assert (relabel_precond f' l' (hd Q)) \\<bind>\n                  (\\<lambda>_.\n                      assert\n                       (l' (hd Q) < 2 * card V \\<and>\n                        relabel_effect f' l' (hd Q) (hd Q)\n                        < 2 * card V) \\<bind>\n                      (\\<lambda>_.\n                          let l = gap_relabel_effect f' l' (hd Q)\n                          in return (l, Qa)))) \\<bind>\n              (\\<lambda>(l, Q). return (f', l, Q)))))\n    \\<le> SPEC\n           (\\<lambda>(f', l', Q').\n               Height_Bounded_Labeling c s t f' l' \\<and>\n               Q_invar f' Q' \\<and>\n               ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>+)", "from l''.height_bound \\<open>u\\<in>V\\<close> card_V_ge2"], ["proof (chain)\npicking this:\n  \\<forall>ua\\<in>V. relabel_effect f' l' u ua \\<le> 2 * card V - 1\n  u \\<in> V\n  2 \\<le> card V", "have [simp]: \"relabel_effect f' l' u u < 2*card V\""], ["proof (prove)\nusing this:\n  \\<forall>ua\\<in>V. relabel_effect f' l' u ua \\<le> 2 * card V - 1\n  u \\<in> V\n  2 \\<le> card V\n\ngoal (1 subgoal):\n 1. relabel_effect f' l' u u < 2 * card V", "by auto"], ["proof (state)\nthis:\n  relabel_effect f' l' u u < 2 * card V\n\ngoal (1 subgoal):\n 1. VCG_FRAME\n     (assert (hd Q \\<in> V - {s, t}) \\<bind>\n      (\\<lambda>x.\n          assert (Height_Bounded_Labeling c s t f' l') \\<bind>\n          (\\<lambda>x.\n              (let Qa = Q' @ [hd Q]\n               in assert (relabel_precond f' l' (hd Q)) \\<bind>\n                  (\\<lambda>_.\n                      assert\n                       (l' (hd Q) < 2 * card V \\<and>\n                        relabel_effect f' l' (hd Q) (hd Q)\n                        < 2 * card V) \\<bind>\n                      (\\<lambda>_.\n                          let l = gap_relabel_effect f' l' (hd Q)\n                          in return (l, Qa)))) \\<bind>\n              (\\<lambda>(l, Q). return (f', l, Q)))))\n    \\<le> SPEC\n           (\\<lambda>(f', l', Q').\n               Height_Bounded_Labeling c s t f' l' \\<and>\n               Q_invar f' Q' \\<and>\n               ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>+)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. VCG_FRAME\n     (assert (hd Q \\<in> V - {s, t}) \\<bind>\n      (\\<lambda>x.\n          assert (Height_Bounded_Labeling c s t f' l') \\<bind>\n          (\\<lambda>x.\n              (let Qa = Q' @ [hd Q]\n               in assert (relabel_precond f' l' (hd Q)) \\<bind>\n                  (\\<lambda>_.\n                      assert\n                       (l' (hd Q) < 2 * card V \\<and>\n                        relabel_effect f' l' (hd Q) (hd Q)\n                        < 2 * card V) \\<bind>\n                      (\\<lambda>_.\n                          let l = gap_relabel_effect f' l' (hd Q)\n                          in return (l, Qa)))) \\<bind>\n              (\\<lambda>(l, Q). return (f', l, Q)))))\n    \\<le> SPEC\n           (\\<lambda>(f', l', Q').\n               Height_Bounded_Labeling c s t f' l' \\<and>\n               Q_invar f' Q' \\<and>\n               ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>+)", "apply (rule vcg_rem_frame)"], ["proof (prove)\ngoal (1 subgoal):\n 1. assert (hd Q \\<in> V - {s, t}) \\<bind>\n    (\\<lambda>x.\n        assert (Height_Bounded_Labeling c s t f' l') \\<bind>\n        (\\<lambda>x.\n            (let Qa = Q' @ [hd Q]\n             in assert (relabel_precond f' l' (hd Q)) \\<bind>\n                (\\<lambda>_.\n                    assert\n                     (l' (hd Q) < 2 * card V \\<and>\n                      relabel_effect f' l' (hd Q) (hd Q)\n                      < 2 * card V) \\<bind>\n                    (\\<lambda>_.\n                        let l = gap_relabel_effect f' l' (hd Q)\n                        in return (l, Qa)))) \\<bind>\n            (\\<lambda>(l, Q). return (f', l, Q))))\n    \\<le> SPEC\n           (\\<lambda>(f', l', Q').\n               Height_Bounded_Labeling c s t f' l' \\<and>\n               Q_invar f' Q' \\<and>\n               ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>+)", "apply refine_vcg"], ["proof (prove)\ngoal (8 subgoals):\n 1. hd Q \\<in> V - {s, t}\n 2. hd Q \\<in> V - {s, t} \\<Longrightarrow>\n    Height_Bounded_Labeling c s t f' l'\n 3. \\<lbrakk>hd Q \\<in> V - {s, t};\n     Height_Bounded_Labeling c s t f' l'\\<rbrakk>\n    \\<Longrightarrow> relabel_precond f' l' (hd Q)\n 4. \\<lbrakk>hd Q \\<in> V - {s, t}; Height_Bounded_Labeling c s t f' l';\n     relabel_precond f' l' (hd Q)\\<rbrakk>\n    \\<Longrightarrow> l' (hd Q) < 2 * card V\n 5. \\<lbrakk>hd Q \\<in> V - {s, t}; Height_Bounded_Labeling c s t f' l';\n     relabel_precond f' l' (hd Q)\\<rbrakk>\n    \\<Longrightarrow> relabel_effect f' l' (hd Q) (hd Q) < 2 * card V\n 6. \\<And>a b x1 x2 x1a x2a.\n       \\<lbrakk>hd Q \\<in> V - {s, t}; Height_Bounded_Labeling c s t f' l';\n        relabel_precond f' l' (hd Q);\n        l' (hd Q) < 2 * card V \\<and>\n        relabel_effect f' l' (hd Q) (hd Q) < 2 * card V;\n        (gap_relabel_effect f' l' (hd Q), Q' @ [hd Q]) = (a, b);\n        x2 = (x1a, x2a); (f', a, b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> Height_Bounded_Labeling c s t x1 x1a\n 7. \\<And>a b x1 x2 x1a x2a.\n       \\<lbrakk>hd Q \\<in> V - {s, t}; Height_Bounded_Labeling c s t f' l';\n        relabel_precond f' l' (hd Q);\n        l' (hd Q) < 2 * card V \\<and>\n        relabel_effect f' l' (hd Q) (hd Q) < 2 * card V;\n        (gap_relabel_effect f' l' (hd Q), Q' @ [hd Q]) = (a, b);\n        x2 = (x1a, x2a); (f', a, b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> Q_invar x1 x2a\n 8. \\<And>a b x1 x2 x1a x2a.\n       \\<lbrakk>hd Q \\<in> V - {s, t}; Height_Bounded_Labeling c s t f' l';\n        relabel_precond f' l' (hd Q);\n        l' (hd Q) < 2 * card V \\<and>\n        relabel_effect f' l' (hd Q) (hd Q) < 2 * card V;\n        (gap_relabel_effect f' l' (hd Q), Q' @ [hd Q]) = (a, b);\n        x2 = (x1a, x2a); (f', a, b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> ((x1, x1a), f, l) \\<in> gap_algo_rel\\<^sup>+", "apply (vc_solve \n            simp: UI PRE \n            simp: l'.gap_relabel_pres_hb_labeling[OF PRE] \n            simp: Q_invar_when_discharged2[OF QDI X])"], ["proof (prove)\ngoal (2 subgoals):\n 1. Height_Bounded_Labeling c s t f' l'\n 2. Height_Bounded_Labeling c s t f' l' \\<Longrightarrow>\n    ((f', gap_relabel_effect f' l' u), f, l) \\<in> gap_algo_rel\\<^sup>+", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f' l'", "by unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f' l' \\<Longrightarrow>\n    ((f', gap_relabel_effect f' l' u), f, l) \\<in> gap_algo_rel\\<^sup>+", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f' l' \\<Longrightarrow>\n    ((f', gap_relabel_effect f' l' u), f, l) \\<in> gap_algo_rel\\<^sup>+", "by (meson PRE REL gap_algo_rel.relabel l'.Height_Bounded_Labeling_axioms rtrancl_into_trancl2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  VCG_FRAME\n   (assert (hd Q \\<in> V - {s, t}) \\<bind>\n    (\\<lambda>x.\n        assert (Height_Bounded_Labeling c s t f' l') \\<bind>\n        (\\<lambda>x.\n            (let Qa = Q' @ [hd Q]\n             in assert (relabel_precond f' l' (hd Q)) \\<bind>\n                (\\<lambda>_.\n                    assert\n                     (l' (hd Q) < 2 * card V \\<and>\n                      relabel_effect f' l' (hd Q) (hd Q)\n                      < 2 * card V) \\<bind>\n                    (\\<lambda>_.\n                        let l = gap_relabel_effect f' l' (hd Q)\n                        in return (l, Qa)))) \\<bind>\n            (\\<lambda>(l, Q). return (f', l, Q)))))\n  \\<le> SPEC\n         (\\<lambda>(f', l', Q').\n             Height_Bounded_Labeling c s t f' l' \\<and>\n             Q_invar f' Q' \\<and>\n             ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>+)\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aaa baa x1.\n       \\<lbrakk>QD_invar u f Qr; excess x1 u = (0::'capacity); u \\<in> V;\n        Height_Bounded_Labeling c s t x1 aaa; u \\<noteq> s; u \\<noteq> t;\n        QD_invar u x1 baa;\n        ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> Q_invar x1 baa\n 2. \\<And>aaa baa x1.\n       \\<lbrakk>QD_invar u f Qr; excess x1 u = (0::'capacity); u \\<in> V;\n        Height_Bounded_Labeling c s t x1 aaa; u \\<noteq> s; u \\<noteq> t;\n        QD_invar u x1 baa;\n        ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>+\n 3. \\<And>it aaa baa x1.\n       \\<lbrakk>QD_invar u f Qr; it \\<noteq> {};\n        it \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n        excess x1 u = (0::'capacity); u \\<in> V;\n        Height_Bounded_Labeling c s t x1 aaa; u \\<noteq> s; u \\<noteq> t;\n        QD_invar u x1 baa; ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>*;\n        it \\<subseteq> {v. (u, v) \\<in> cfE_of x1}\\<rbrakk>\n       \\<Longrightarrow> Q_invar x1 baa\n 4. \\<And>it aaa baa x1.\n       \\<lbrakk>QD_invar u f Qr; it \\<noteq> {};\n        it \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n        excess x1 u = (0::'capacity); u \\<in> V;\n        Height_Bounded_Labeling c s t x1 aaa; u \\<noteq> s; u \\<noteq> t;\n        QD_invar u x1 baa; ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>*;\n        it \\<subseteq> {v. (u, v) \\<in> cfE_of x1}\\<rbrakk>\n       \\<Longrightarrow> ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>+", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>QD_invar u f Qr; excess x1_ u = (0::'capacity); u \\<in> V;\n     Height_Bounded_Labeling c s t x1_ aaa_; u \\<noteq> s; u \\<noteq> t;\n     QD_invar u x1_ baa_;\n     ((x1_, aaa_), f, l) \\<in> gap_algo_rel\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> Q_invar x1_ baa_", "by (auto simp: Q_invar_when_discharged1 Q_invar_when_discharged2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aaa baa x1.\n       \\<lbrakk>QD_invar u f Qr; excess x1 u = (0::'capacity); u \\<in> V;\n        Height_Bounded_Labeling c s t x1 aaa; u \\<noteq> s; u \\<noteq> t;\n        QD_invar u x1 baa;\n        ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>+\n 2. \\<And>it aaa baa x1.\n       \\<lbrakk>QD_invar u f Qr; it \\<noteq> {};\n        it \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n        excess x1 u = (0::'capacity); u \\<in> V;\n        Height_Bounded_Labeling c s t x1 aaa; u \\<noteq> s; u \\<noteq> t;\n        QD_invar u x1 baa; ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>*;\n        it \\<subseteq> {v. (u, v) \\<in> cfE_of x1}\\<rbrakk>\n       \\<Longrightarrow> Q_invar x1 baa\n 3. \\<And>it aaa baa x1.\n       \\<lbrakk>QD_invar u f Qr; it \\<noteq> {};\n        it \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n        excess x1 u = (0::'capacity); u \\<in> V;\n        Height_Bounded_Labeling c s t x1 aaa; u \\<noteq> s; u \\<noteq> t;\n        QD_invar u x1 baa; ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>*;\n        it \\<subseteq> {v. (u, v) \\<in> cfE_of x1}\\<rbrakk>\n       \\<Longrightarrow> ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>+", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>QD_invar u f Qr; excess x1_ u = (0::'capacity); u \\<in> V;\n     Height_Bounded_Labeling c s t x1_ aaa_; u \\<noteq> s; u \\<noteq> t;\n     QD_invar u x1_ baa_;\n     ((x1_, aaa_), f, l) \\<in> gap_algo_rel\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> ((x1_, aaa_), f, l) \\<in> gap_algo_rel\\<^sup>+", "using XU_orig"], ["proof (prove)\nusing this:\n  excess f u \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>QD_invar u f Qr; excess x1_ u = (0::'capacity); u \\<in> V;\n     Height_Bounded_Labeling c s t x1_ aaa_; u \\<noteq> s; u \\<noteq> t;\n     QD_invar u x1_ baa_;\n     ((x1_, aaa_), f, l) \\<in> gap_algo_rel\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> ((x1_, aaa_), f, l) \\<in> gap_algo_rel\\<^sup>+", "by (metis Pair_inject rtranclD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>it aaa baa x1.\n       \\<lbrakk>QD_invar u f Qr; it \\<noteq> {};\n        it \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n        excess x1 u = (0::'capacity); u \\<in> V;\n        Height_Bounded_Labeling c s t x1 aaa; u \\<noteq> s; u \\<noteq> t;\n        QD_invar u x1 baa; ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>*;\n        it \\<subseteq> {v. (u, v) \\<in> cfE_of x1}\\<rbrakk>\n       \\<Longrightarrow> Q_invar x1 baa\n 2. \\<And>it aaa baa x1.\n       \\<lbrakk>QD_invar u f Qr; it \\<noteq> {};\n        it \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n        excess x1 u = (0::'capacity); u \\<in> V;\n        Height_Bounded_Labeling c s t x1 aaa; u \\<noteq> s; u \\<noteq> t;\n        QD_invar u x1 baa; ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>*;\n        it \\<subseteq> {v. (u, v) \\<in> cfE_of x1}\\<rbrakk>\n       \\<Longrightarrow> ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>+", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>QD_invar u f Qr; it_ \\<noteq> {};\n     it_ \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n     excess x1_ u = (0::'capacity); u \\<in> V;\n     Height_Bounded_Labeling c s t x1_ aaa_; u \\<noteq> s; u \\<noteq> t;\n     QD_invar u x1_ baa_; ((x1_, aaa_), f, l) \\<in> gap_algo_rel\\<^sup>*;\n     it_ \\<subseteq> {v. (u, v) \\<in> cfE_of x1_}\\<rbrakk>\n    \\<Longrightarrow> Q_invar x1_ baa_", "by (auto simp: Q_invar_when_discharged1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>it aaa baa x1.\n       \\<lbrakk>QD_invar u f Qr; it \\<noteq> {};\n        it \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n        excess x1 u = (0::'capacity); u \\<in> V;\n        Height_Bounded_Labeling c s t x1 aaa; u \\<noteq> s; u \\<noteq> t;\n        QD_invar u x1 baa; ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>*;\n        it \\<subseteq> {v. (u, v) \\<in> cfE_of x1}\\<rbrakk>\n       \\<Longrightarrow> ((x1, aaa), f, l) \\<in> gap_algo_rel\\<^sup>+", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>QD_invar u f Qr; it_ \\<noteq> {};\n     it_ \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n     excess x1_ u = (0::'capacity); u \\<in> V;\n     Height_Bounded_Labeling c s t x1_ aaa_; u \\<noteq> s; u \\<noteq> t;\n     QD_invar u x1_ baa_; ((x1_, aaa_), f, l) \\<in> gap_algo_rel\\<^sup>*;\n     it_ \\<subseteq> {v. (u, v) \\<in> cfE_of x1_}\\<rbrakk>\n    \\<Longrightarrow> ((x1_, aaa_), f, l) \\<in> gap_algo_rel\\<^sup>+", "using XU_orig"], ["proof (prove)\nusing this:\n  excess f u \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>QD_invar u f Qr; it_ \\<noteq> {};\n     it_ \\<subseteq> {v. (u, v) \\<in> cfE_of f};\n     excess x1_ u = (0::'capacity); u \\<in> V;\n     Height_Bounded_Labeling c s t x1_ aaa_; u \\<noteq> s; u \\<noteq> t;\n     QD_invar u x1_ baa_; ((x1_, aaa_), f, l) \\<in> gap_algo_rel\\<^sup>*;\n     it_ \\<subseteq> {v. (u, v) \\<in> cfE_of x1_}\\<rbrakk>\n    \\<Longrightarrow> ((x1_, aaa_), f, l) \\<in> gap_algo_rel\\<^sup>+", "by (metis Pair_inject rtranclD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fifo_discharge f l Q\n  \\<le> SPEC\n         (\\<lambda>(f', l', Q').\n             Height_Bounded_Labeling c s t f' l' \\<and>\n             Q_invar f' Q' \\<and>\n             ((f', l'), f, l) \\<in> gap_algo_rel\\<^sup>+)\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>Network\\<close>"], ["", "subsection \\<open>Main Algorithm\\<close>"], ["", "context Network \nbegin"], ["", "text \\<open>The main algorithm initializes the flow, labeling, and the queue, \n  and then applies the discharge operation until the queue is empty:\n\\<close>"], ["", "definition \"fifo_push_relabel \\<equiv> do {\n  let f = pp_init_f;\n  let l = pp_init_l;\n\n  Q \\<leftarrow> spec l. distinct l \\<and> set l = {v\\<in>V - {s,t}. excess f v \\<noteq> 0}; \\<comment> \\<open>TODO: This is exactly \\<open>E``{s} - {t}\\<close>!\\<close>\n\n  (f,l,_) \\<leftarrow> while\\<^sub>T (\\<lambda>(f,l,Q). Q \\<noteq> []) (\\<lambda>(f,l,Q). do {\n    fifo_discharge f l Q\n  }) (f,l,Q);\n\n  assert (Height_Bounded_Labeling c s t f l);\n  return f\n}\""], ["", "text \\<open>Having proved correctness of the discharge operation, the correctness \n  theorem of the main algorithm is straightforward: \n  As the discharge operation implements the generic algorithm, the loop\n  will terminate after finitely many steps.\n  Upon termination, the queue that contains exactly the active nodes is empty.\n  Thus, all nodes are inactive, and the resulting preflow is actually a maximal \n  flow. \n\\<close>"], ["", "theorem fifo_push_relabel_correct: \n  \"fifo_push_relabel \\<le> SPEC isMaxFlow\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fifo_push_relabel \\<le> SPEC isMaxFlow", "unfolding fifo_push_relabel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let f = pp_init_f; l = pp_init_l\n     in (spec l.\n            distinct l \\<and>\n            set l =\n            {v \\<in> V - {s, t}.\n             excess f v \\<noteq> (0::'capacity)}) \\<bind>\n        (\\<lambda>Q.\n            while\\<^sub>T (\\<lambda>(f, l, Q). Q \\<noteq> [])\n             (\\<lambda>(f, l, Q). fifo_discharge f l Q) (f, l, Q) \\<bind>\n            (\\<lambda>(f, l, uu_).\n                assert (Height_Bounded_Labeling c s t f l) \\<bind>\n                (\\<lambda>_. return f))))\n    \\<le> SPEC isMaxFlow", "apply (refine_vcg  \n      WHILET_rule[where \n            I=\"\\<lambda>(f,l,Q). Height_Bounded_Labeling c s t f l \\<and> Q_invar f Q\"\n        and R=\"inv_image (gap_algo_rel\\<^sup>+) (\\<lambda>(f,l,Q). ((f,l)))\"\n        ]\n      )"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x.\n       distinct x \\<and>\n       set x =\n       {v \\<in> V - {s, t}.\n        excess pp_init_f v \\<noteq> (0::'capacity)} \\<Longrightarrow>\n       wf (inv_image (gap_algo_rel\\<^sup>+) (\\<lambda>(f, l, Q). (f, l)))\n 2. \\<And>x x1 x2 x1a x2a.\n       \\<lbrakk>distinct x \\<and>\n                set x =\n                {v \\<in> V - {s, t}.\n                 excess pp_init_f v \\<noteq> (0::'capacity)};\n        x2 = (x1a, x2a); (pp_init_f, pp_init_l, x) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> Height_Bounded_Labeling c s t x1 x1a\n 3. \\<And>x x1 x2 x1a x2a.\n       \\<lbrakk>distinct x \\<and>\n                set x =\n                {v \\<in> V - {s, t}.\n                 excess pp_init_f v \\<noteq> (0::'capacity)};\n        x2 = (x1a, x2a); (pp_init_f, pp_init_l, x) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> Q_invar x1 x2a\n 4. \\<And>x sa a b aa ba.\n       \\<lbrakk>distinct x \\<and>\n                set x =\n                {v \\<in> V - {s, t}.\n                 excess pp_init_f v \\<noteq> (0::'capacity)};\n        case sa of\n        (f, l, Q) \\<Rightarrow>\n          Height_Bounded_Labeling c s t f l \\<and> Q_invar f Q;\n        case sa of (f, l, Q) \\<Rightarrow> Q \\<noteq> []; sa = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> Height_Bounded_Labeling c s t a aa\n 5. \\<And>x sa a b aa ba.\n       \\<lbrakk>distinct x \\<and>\n                set x =\n                {v \\<in> V - {s, t}.\n                 excess pp_init_f v \\<noteq> (0::'capacity)};\n        case sa of\n        (f, l, Q) \\<Rightarrow>\n          Height_Bounded_Labeling c s t f l \\<and> Q_invar f Q;\n        case sa of (f, l, Q) \\<Rightarrow> Q \\<noteq> []; sa = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> Q_invar a ba\n 6. \\<And>x sa a b aa ba.\n       \\<lbrakk>distinct x \\<and>\n                set x =\n                {v \\<in> V - {s, t}.\n                 excess pp_init_f v \\<noteq> (0::'capacity)};\n        case sa of\n        (f, l, Q) \\<Rightarrow>\n          Height_Bounded_Labeling c s t f l \\<and> Q_invar f Q;\n        case sa of (f, l, Q) \\<Rightarrow> Q \\<noteq> []; sa = (a, b);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba \\<noteq> []\n 7. \\<And>x sa a b aa ba xa x1 x2 x1a x2a.\n       \\<lbrakk>distinct x \\<and>\n                set x =\n                {v \\<in> V - {s, t}.\n                 excess pp_init_f v \\<noteq> (0::'capacity)};\n        case sa of\n        (f, l, Q) \\<Rightarrow>\n          Height_Bounded_Labeling c s t f l \\<and> Q_invar f Q;\n        case sa of (f, l, Q) \\<Rightarrow> Q \\<noteq> []; sa = (a, b);\n        b = (aa, ba);\n        case xa of\n        (f', l', Q') \\<Rightarrow>\n          Height_Bounded_Labeling c s t f' l' \\<and>\n          Q_invar f' Q' \\<and> ((f', l'), a, aa) \\<in> gap_algo_rel\\<^sup>+;\n        x2 = (x1a, x2a); xa = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> Height_Bounded_Labeling c s t x1 x1a\n 8. \\<And>x sa a b aa ba xa x1 x2 x1a x2a.\n       \\<lbrakk>distinct x \\<and>\n                set x =\n                {v \\<in> V - {s, t}.\n                 excess pp_init_f v \\<noteq> (0::'capacity)};\n        case sa of\n        (f, l, Q) \\<Rightarrow>\n          Height_Bounded_Labeling c s t f l \\<and> Q_invar f Q;\n        case sa of (f, l, Q) \\<Rightarrow> Q \\<noteq> []; sa = (a, b);\n        b = (aa, ba);\n        case xa of\n        (f', l', Q') \\<Rightarrow>\n          Height_Bounded_Labeling c s t f' l' \\<and>\n          Q_invar f' Q' \\<and> ((f', l'), a, aa) \\<in> gap_algo_rel\\<^sup>+;\n        x2 = (x1a, x2a); xa = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> Q_invar x1 x2a\n 9. \\<And>x sa a b aa ba xa.\n       \\<lbrakk>distinct x \\<and>\n                set x =\n                {v \\<in> V - {s, t}.\n                 excess pp_init_f v \\<noteq> (0::'capacity)};\n        case sa of\n        (f, l, Q) \\<Rightarrow>\n          Height_Bounded_Labeling c s t f l \\<and> Q_invar f Q;\n        case sa of (f, l, Q) \\<Rightarrow> Q \\<noteq> []; sa = (a, b);\n        b = (aa, ba);\n        case xa of\n        (f', l', Q') \\<Rightarrow>\n          Height_Bounded_Labeling c s t f' l' \\<and>\n          Q_invar f' Q' \\<and>\n          ((f', l'), a, aa) \\<in> gap_algo_rel\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> (xa, sa)\n                         \\<in> inv_image (gap_algo_rel\\<^sup>+)\n                                (\\<lambda>(f, l, Q). (f, l))\n 10. \\<And>x sa a b aa ba.\n        \\<lbrakk>distinct x \\<and>\n                 set x =\n                 {v \\<in> V - {s, t}.\n                  excess pp_init_f v \\<noteq> (0::'capacity)};\n         case sa of\n         (f, l, Q) \\<Rightarrow>\n           Height_Bounded_Labeling c s t f l \\<and> Q_invar f Q;\n         \\<not> (case sa of (f, l, Q) \\<Rightarrow> Q \\<noteq> []);\n         sa = (a, b); b = (aa, ba)\\<rbrakk>\n        \\<Longrightarrow> Height_Bounded_Labeling c s t a aa\nA total of 11 subgoals...", "apply (vc_solve solve: pp_init_height_bound)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>distinct x;\n        set x =\n        {v \\<in> V.\n         v \\<noteq> s \\<and>\n         v \\<noteq> t \\<and>\n         excess pp_init_f v \\<noteq> (0::'capacity)}\\<rbrakk>\n       \\<Longrightarrow> wf (gap_algo_rel\\<^sup>+)\n 2. \\<And>x.\n       \\<lbrakk>distinct x;\n        set x =\n        {v \\<in> V.\n         v \\<noteq> s \\<and>\n         v \\<noteq> t \\<and>\n         excess pp_init_f v \\<noteq> (0::'capacity)}\\<rbrakk>\n       \\<Longrightarrow> Q_invar pp_init_f x\n 3. \\<And>x ab aaa.\n       \\<lbrakk>Q_invar ab []; Height_Bounded_Labeling c s t ab aaa;\n        distinct x;\n        set x =\n        {v \\<in> V.\n         v \\<noteq> s \\<and>\n         v \\<noteq> t \\<and>\n         excess pp_init_f v \\<noteq> (0::'capacity)}\\<rbrakk>\n       \\<Longrightarrow> isMaxFlow ab", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct x_;\n     set x_ =\n     {v \\<in> V.\n      v \\<noteq> s \\<and>\n      v \\<noteq> t \\<and>\n      excess pp_init_f v \\<noteq> (0::'capacity)}\\<rbrakk>\n    \\<Longrightarrow> wf (gap_algo_rel\\<^sup>+)", "by (blast intro: wf_lex_prod wf_trancl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>distinct x;\n        set x =\n        {v \\<in> V.\n         v \\<noteq> s \\<and>\n         v \\<noteq> t \\<and>\n         excess pp_init_f v \\<noteq> (0::'capacity)}\\<rbrakk>\n       \\<Longrightarrow> Q_invar pp_init_f x\n 2. \\<And>x ab aaa.\n       \\<lbrakk>Q_invar ab []; Height_Bounded_Labeling c s t ab aaa;\n        distinct x;\n        set x =\n        {v \\<in> V.\n         v \\<noteq> s \\<and>\n         v \\<noteq> t \\<and>\n         excess pp_init_f v \\<noteq> (0::'capacity)}\\<rbrakk>\n       \\<Longrightarrow> isMaxFlow ab", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct x_;\n     set x_ =\n     {v \\<in> V.\n      v \\<noteq> s \\<and>\n      v \\<noteq> t \\<and>\n      excess pp_init_f v \\<noteq> (0::'capacity)}\\<rbrakk>\n    \\<Longrightarrow> Q_invar pp_init_f x_", "unfolding Q_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct x_;\n     set x_ =\n     {v \\<in> V.\n      v \\<noteq> s \\<and>\n      v \\<noteq> t \\<and>\n      excess pp_init_f v \\<noteq> (0::'capacity)}\\<rbrakk>\n    \\<Longrightarrow> distinct x_ \\<and>\n                      set x_ =\n                      {v \\<in> V - {s, t}.\n                       excess pp_init_f v \\<noteq> (0::'capacity)}", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x ab aaa.\n       \\<lbrakk>Q_invar ab []; Height_Bounded_Labeling c s t ab aaa;\n        distinct x;\n        set x =\n        {v \\<in> V.\n         v \\<noteq> s \\<and>\n         v \\<noteq> t \\<and>\n         excess pp_init_f v \\<noteq> (0::'capacity)}\\<rbrakk>\n       \\<Longrightarrow> isMaxFlow ab", "subgoal for initQ f l"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q_invar f []; Height_Bounded_Labeling c s t f l;\n     distinct initQ;\n     set initQ =\n     {v \\<in> V.\n      v \\<noteq> s \\<and>\n      v \\<noteq> t \\<and>\n      excess pp_init_f v \\<noteq> (0::'capacity)}\\<rbrakk>\n    \\<Longrightarrow> isMaxFlow f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q_invar f []; Height_Bounded_Labeling c s t f l;\n     distinct initQ;\n     set initQ =\n     {v \\<in> V.\n      v \\<noteq> s \\<and>\n      v \\<noteq> t \\<and>\n      excess pp_init_f v \\<noteq> (0::'capacity)}\\<rbrakk>\n    \\<Longrightarrow> isMaxFlow f", "assume \"Height_Bounded_Labeling c s t f l\""], ["proof (state)\nthis:\n  Height_Bounded_Labeling c s t f l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Q_invar f []; Height_Bounded_Labeling c s t f l;\n     distinct initQ;\n     set initQ =\n     {v \\<in> V.\n      v \\<noteq> s \\<and>\n      v \\<noteq> t \\<and>\n      excess pp_init_f v \\<noteq> (0::'capacity)}\\<rbrakk>\n    \\<Longrightarrow> isMaxFlow f", "then"], ["proof (chain)\npicking this:\n  Height_Bounded_Labeling c s t f l", "interpret Height_Bounded_Labeling c s t f l"], ["proof (prove)\nusing this:\n  Height_Bounded_Labeling c s t f l\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f l", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q_invar f []; Height_Bounded_Labeling c s t f l;\n     distinct initQ;\n     set initQ =\n     {v \\<in> V.\n      v \\<noteq> s \\<and>\n      v \\<noteq> t \\<and>\n      excess pp_init_f v \\<noteq> (0::'capacity)}\\<rbrakk>\n    \\<Longrightarrow> isMaxFlow f", "assume \"Q_invar f []\""], ["proof (state)\nthis:\n  Q_invar f []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Q_invar f []; Height_Bounded_Labeling c s t f l;\n     distinct initQ;\n     set initQ =\n     {v \\<in> V.\n      v \\<noteq> s \\<and>\n      v \\<noteq> t \\<and>\n      excess pp_init_f v \\<noteq> (0::'capacity)}\\<rbrakk>\n    \\<Longrightarrow> isMaxFlow f", "hence \"\\<forall>u\\<in>V-{s,t}. excess f u = 0\""], ["proof (prove)\nusing this:\n  Q_invar f []\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>V - {s, t}. excess f u = (0::'capacity)", "unfolding Q_invar_def"], ["proof (prove)\nusing this:\n  distinct [] \\<and>\n  set [] = {v \\<in> V - {s, t}. excess f v \\<noteq> (0::'capacity)}\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>V - {s, t}. excess f u = (0::'capacity)", "by auto"], ["proof (state)\nthis:\n  \\<forall>u\\<in>V - {s, t}. excess f u = (0::'capacity)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Q_invar f []; Height_Bounded_Labeling c s t f l;\n     distinct initQ;\n     set initQ =\n     {v \\<in> V.\n      v \\<noteq> s \\<and>\n      v \\<noteq> t \\<and>\n      excess pp_init_f v \\<noteq> (0::'capacity)}\\<rbrakk>\n    \\<Longrightarrow> isMaxFlow f", "thus \"isMaxFlow f\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>V - {s, t}. excess f u = (0::'capacity)\n\ngoal (1 subgoal):\n 1. isMaxFlow f", "by (rule no_excess_imp_maxflow)"], ["proof (state)\nthis:\n  isMaxFlow f\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end \\<comment> \\<open>Network\\<close>"], ["", "end"]]}