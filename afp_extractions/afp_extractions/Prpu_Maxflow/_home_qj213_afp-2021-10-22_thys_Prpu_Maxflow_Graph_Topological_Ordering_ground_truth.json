{"file_name": "/home/qj213/afp-2021-10-22/thys/Prpu_Maxflow/Graph_Topological_Ordering.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Prpu_Maxflow", "problem_names": ["lemma list_before_rel_on_elems: \"list_before_rel l \\<subseteq> set l \\<times> set l\"", "lemma list_before_irrefl_eq_distinct: \"irrefl (list_before_rel l) \\<longleftrightarrow> distinct l\"", "lemma list_before_rel_alt: \"list_before_rel l = { (l!i, l!j) | i j. i<j \\<and> j<length l }\"", "lemma list_before_trans[trans]: \"distinct l \\<Longrightarrow> trans (list_before_rel l)\"", "lemma list_before_asym: \"distinct l \\<Longrightarrow> asym (list_before_rel l)\"", "lemma list_before_rel_empty[simp]: \"list_before_rel [] = {}\"", "lemma list_before_rel_cons: \"list_before_rel (x#l) = ({x}\\<times>set l) \\<union> list_before_rel l\"", "lemma is_top_sorted_alt: \"is_top_sorted R l \\<longleftrightarrow> (\\<forall>x y. (x,y)\\<in>list_before_rel l \\<longrightarrow> (y,x)\\<notin>R\\<^sup>*)\"", "lemma is_top_sorted_empty_rel[simp]: \"is_top_sorted {} l \\<longleftrightarrow> distinct l\"", "lemma is_top_sorted_empty_list[simp]: \"is_top_sorted R []\"", "lemma is_top_sorted_distinct: \n  assumes \"is_top_sorted R l\" \n  shows \"distinct l\"", "lemma is_top_sorted_cons: \"is_top_sorted R (x#l) \\<longleftrightarrow> ({x}\\<times>set l \\<inter> (R\\<^sup>*)\\<inverse> = {}) \\<and> is_top_sorted R l\"", "lemma is_top_sorted_append: \"is_top_sorted R (l1@l2) \n  \\<longleftrightarrow> (set l1\\<times>set l2 \\<inter> (R\\<^sup>*)\\<inverse> = {}) \\<and> is_top_sorted R l1 \\<and> is_top_sorted R l2\"", "lemma is_top_sorted_remove_elem: \"is_top_sorted R (l1@x#l2) \\<Longrightarrow> is_top_sorted R (l1@l2)\"", "lemma is_top_sorted_antimono:\n  assumes \"R\\<subseteq>R'\"\n  assumes \"is_top_sorted R' l\"\n  shows \"is_top_sorted R l\"", "lemma is_top_sorted_isolated_constraint:\n  assumes \"R' \\<subseteq> R \\<union> {x}\\<times>X\" \"R'\\<inter>UNIV\\<times>{x} = {}\"\n  assumes \"x\\<notin>set l\"  \n  assumes \"is_top_sorted R l\"  \n  shows \"is_top_sorted R' l\""], "translations": [["", "lemma list_before_rel_on_elems: \"list_before_rel l \\<subseteq> set l \\<times> set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_before_rel l \\<subseteq> set l \\<times> set l", "unfolding list_before_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(a, b). \\<exists>l1 l2 l3. l = l1 @ a # l2 @ b # l3}\n    \\<subseteq> set l \\<times> set l", "by auto"], ["", "text \\<open>Irreflexivity of list-before is equivalent to the elements of the list being disjoint.\\<close>"], ["", "lemma list_before_irrefl_eq_distinct: \"irrefl (list_before_rel l) \\<longleftrightarrow> distinct l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irrefl (list_before_rel l) = distinct l", "using not_distinct_decomp[of l]"], ["proof (prove)\nusing this:\n  \\<not> distinct l \\<Longrightarrow>\n  \\<exists>xs ys zs y. l = xs @ [y] @ ys @ [y] @ zs\n\ngoal (1 subgoal):\n 1. irrefl (list_before_rel l) = distinct l", "by (auto simp: irrefl_def list_before_rel_def)"], ["", "text \\<open>Alternative characterization via indexes\\<close>"], ["", "lemma list_before_rel_alt: \"list_before_rel l = { (l!i, l!j) | i j. i<j \\<and> j<length l }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_before_rel l = {(l ! i, l ! j) |i j. i < j \\<and> j < length l}", "unfolding list_before_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(a, b). \\<exists>l1 l2 l3. l = l1 @ a # l2 @ b # l3} =\n    {(l ! i, l ! j) |i j. i < j \\<and> j < length l}", "apply (rule; clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b l1 l2 l3.\n       l = l1 @ a # l2 @ b # l3 \\<Longrightarrow>\n       \\<exists>i.\n          a = (l1 @ a # l2 @ b # l3) ! i \\<and>\n          (\\<exists>j.\n              b = (l1 @ a # l2 @ b # l3) ! j \\<and>\n              i < j \\<and>\n              j < Suc (Suc (length l1 + (length l2 + length l3))))\n 2. \\<And>i j.\n       \\<lbrakk>i < j; j < length l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l1 l2 l3. l = l1 @ l ! i # l2 @ l ! j # l3", "subgoal for a b l1 l2 l3"], ["proof (prove)\ngoal (1 subgoal):\n 1. l = l1 @ a # l2 @ b # l3 \\<Longrightarrow>\n    \\<exists>i.\n       a = (l1 @ a # l2 @ b # l3) ! i \\<and>\n       (\\<exists>j.\n           b = (l1 @ a # l2 @ b # l3) ! j \\<and>\n           i < j \\<and> j < Suc (Suc (length l1 + (length l2 + length l3))))", "apply (rule exI[of _ \"length l1\"]; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. l = l1 @ a # l2 @ b # l3 \\<Longrightarrow>\n    \\<exists>j.\n       b = (l1 @ a # l2 @ b # l3) ! j \\<and>\n       length l1 < j \\<and>\n       j < Suc (Suc (length l1 + (length l2 + length l3)))", "apply (rule exI[of _ \"length l1 + Suc (length l2)\"]; auto simp: nth_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < length l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l1 l2 l3. l = l1 @ l ! i # l2 @ l ! j # l3", "subgoal for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < j; j < length l\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l1 l2 l3. l = l1 @ l ! i # l2 @ l ! j # l3", "apply (rule exI[of _ \"take i l\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < j; j < length l\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l2 l3. l = take i l @ l ! i # l2 @ l ! j # l3", "apply (rule exI[of _ \"drop (Suc i) (take j l)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < j; j < length l\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l3.\n                         l =\n                         take i l @\n                         l ! i # drop (Suc i) (take j l) @ l ! j # l3", "apply (rule exI[of _ \"drop (Suc j) l\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < j; j < length l\\<rbrakk>\n    \\<Longrightarrow> l =\n                      take i l @\n                      l ! i #\n                      drop (Suc i) (take j l) @ l ! j # drop (Suc j) l", "by (simp add: Cons_nth_drop_Suc drop_take_drop_unsplit)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>list-before is a strict ordering, i.e., it is transitive and asymmetric.\\<close>"], ["", "lemma list_before_trans[trans]: \"distinct l \\<Longrightarrow> trans (list_before_rel l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct l \\<Longrightarrow> trans (list_before_rel l)", "by (clarsimp simp: trans_def list_before_rel_alt) (metis index_nth_id less_trans)"], ["", "lemma list_before_asym: \"distinct l \\<Longrightarrow> asym (list_before_rel l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct l \\<Longrightarrow> asym (list_before_rel l)", "by (meson asym.intros irrefl_def list_before_irrefl_eq_distinct list_before_trans transE)"], ["", "text \\<open>Structural properties on the list\\<close>"], ["", "lemma list_before_rel_empty[simp]: \"list_before_rel [] = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_before_rel [] = {}", "unfolding list_before_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(a, b). \\<exists>l1 l2 l3. [] = l1 @ a # l2 @ b # l3} = {}", "by auto"], ["", "lemma list_before_rel_cons: \"list_before_rel (x#l) = ({x}\\<times>set l) \\<union> list_before_rel l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_before_rel (x # l) = {x} \\<times> set l \\<union> list_before_rel l", "apply (intro equalityI subsetI; simp add: split_paired_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> list_before_rel (x # l) \\<Longrightarrow>\n       a = x \\<and> b \\<in> set l \\<or> (a, b) \\<in> list_before_rel l\n 2. \\<And>a b.\n       a = x \\<and> b \\<in> set l \\<or>\n       (a, b) \\<in> list_before_rel l \\<Longrightarrow>\n       (a, b) \\<in> list_before_rel (x # l)", "subgoal for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l) \\<Longrightarrow>\n    a = x \\<and> b \\<in> set l \\<or> (a, b) \\<in> list_before_rel l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l) \\<Longrightarrow>\n    a = x \\<and> b \\<in> set l \\<or> (a, b) \\<in> list_before_rel l", "assume \"(a,b) \\<in> list_before_rel (x # l)\""], ["proof (state)\nthis:\n  (a, b) \\<in> list_before_rel (x # l)\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l) \\<Longrightarrow>\n    a = x \\<and> b \\<in> set l \\<or> (a, b) \\<in> list_before_rel l", "then"], ["proof (chain)\npicking this:\n  (a, b) \\<in> list_before_rel (x # l)", "obtain i j where IDX_BOUND: \"i<j\" \"j<Suc (length l)\" and [simp]: \"a=(x#l)!i\" \"b=(x#l)!j\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> list_before_rel (x # l)\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < j; j < Suc (length l); a = (x # l) ! i;\n         b = (x # l) ! j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding list_before_rel_alt"], ["proof (prove)\nusing this:\n  (a, b)\n  \\<in> {((x # l) ! i, (x # l) ! j) |i j. i < j \\<and> j < length (x # l)}\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < j; j < Suc (length l); a = (x # l) ! i;\n         b = (x # l) ! j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < j\n  j < Suc (length l)\n  a = (x # l) ! i\n  b = (x # l) ! j\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l) \\<Longrightarrow>\n    a = x \\<and> b \\<in> set l \\<or> (a, b) \\<in> list_before_rel l", "{"], ["proof (state)\nthis:\n  i < j\n  j < Suc (length l)\n  a = (x # l) ! i\n  b = (x # l) ! j\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l) \\<Longrightarrow>\n    a = x \\<and> b \\<in> set l \\<or> (a, b) \\<in> list_before_rel l", "assume \"i=0\""], ["proof (state)\nthis:\n  i = 0\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l) \\<Longrightarrow>\n    a = x \\<and> b \\<in> set l \\<or> (a, b) \\<in> list_before_rel l", "hence \"x=a\" \"b\\<in>set l\""], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. x = a &&& b \\<in> set l", "using IDX_BOUND"], ["proof (prove)\nusing this:\n  i = 0\n  i < j\n  j < Suc (length l)\n\ngoal (1 subgoal):\n 1. x = a &&& b \\<in> set l", "by (auto simp: nth_Cons split: nat.splits)"], ["proof (state)\nthis:\n  x = a\n  b \\<in> set l\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l) \\<Longrightarrow>\n    a = x \\<and> b \\<in> set l \\<or> (a, b) \\<in> list_before_rel l", "}"], ["proof (state)\nthis:\n  i = 0 \\<Longrightarrow> x = a\n  i = 0 \\<Longrightarrow> b \\<in> set l\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l) \\<Longrightarrow>\n    a = x \\<and> b \\<in> set l \\<or> (a, b) \\<in> list_before_rel l", "moreover"], ["proof (state)\nthis:\n  i = 0 \\<Longrightarrow> x = a\n  i = 0 \\<Longrightarrow> b \\<in> set l\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l) \\<Longrightarrow>\n    a = x \\<and> b \\<in> set l \\<or> (a, b) \\<in> list_before_rel l", "{"], ["proof (state)\nthis:\n  i = 0 \\<Longrightarrow> x = a\n  i = 0 \\<Longrightarrow> b \\<in> set l\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l) \\<Longrightarrow>\n    a = x \\<and> b \\<in> set l \\<or> (a, b) \\<in> list_before_rel l", "assume \"i\\<noteq>0\""], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l) \\<Longrightarrow>\n    a = x \\<and> b \\<in> set l \\<or> (a, b) \\<in> list_before_rel l", "with IDX_BOUND"], ["proof (chain)\npicking this:\n  i < j\n  j < Suc (length l)\n  i \\<noteq> 0", "have \"a=l!(i-1)\" \"b=l!(j-1)\" \"i-1 < j-1\" \"j-1 < length l\""], ["proof (prove)\nusing this:\n  i < j\n  j < Suc (length l)\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (a = l ! (i - 1) &&& b = l ! (j - 1)) &&&\n    i - 1 < j - 1 &&& j - 1 < length l", "by auto"], ["proof (state)\nthis:\n  a = l ! (i - 1)\n  b = l ! (j - 1)\n  i - 1 < j - 1\n  j - 1 < length l\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l) \\<Longrightarrow>\n    a = x \\<and> b \\<in> set l \\<or> (a, b) \\<in> list_before_rel l", "hence \"(a, b) \\<in> list_before_rel l\""], ["proof (prove)\nusing this:\n  a = l ! (i - 1)\n  b = l ! (j - 1)\n  i - 1 < j - 1\n  j - 1 < length l\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel l", "unfolding list_before_rel_alt"], ["proof (prove)\nusing this:\n  a = l ! (i - 1)\n  b = l ! (j - 1)\n  i - 1 < j - 1\n  j - 1 < length l\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> {(l ! i, l ! j) |i j. i < j \\<and> j < length l}", "by blast"], ["proof (state)\nthis:\n  (a, b) \\<in> list_before_rel l\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l) \\<Longrightarrow>\n    a = x \\<and> b \\<in> set l \\<or> (a, b) \\<in> list_before_rel l", "}"], ["proof (state)\nthis:\n  i \\<noteq> 0 \\<Longrightarrow> (a, b) \\<in> list_before_rel l\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l) \\<Longrightarrow>\n    a = x \\<and> b \\<in> set l \\<or> (a, b) \\<in> list_before_rel l", "ultimately"], ["proof (chain)\npicking this:\n  i = 0 \\<Longrightarrow> x = a\n  i = 0 \\<Longrightarrow> b \\<in> set l\n  i \\<noteq> 0 \\<Longrightarrow> (a, b) \\<in> list_before_rel l", "show ?thesis"], ["proof (prove)\nusing this:\n  i = 0 \\<Longrightarrow> x = a\n  i = 0 \\<Longrightarrow> b \\<in> set l\n  i \\<noteq> 0 \\<Longrightarrow> (a, b) \\<in> list_before_rel l\n\ngoal (1 subgoal):\n 1. a = x \\<and> b \\<in> set l \\<or> (a, b) \\<in> list_before_rel l", "by blast"], ["proof (state)\nthis:\n  a = x \\<and> b \\<in> set l \\<or> (a, b) \\<in> list_before_rel l\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       a = x \\<and> b \\<in> set l \\<or>\n       (a, b) \\<in> list_before_rel l \\<Longrightarrow>\n       (a, b) \\<in> list_before_rel (x # l)", "subgoal premises prems for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l)", "assume [simp]: \"a=x\" and \"b\\<in>set l\""], ["proof (state)\nthis:\n  a = x\n  b \\<in> set l\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l)", "then"], ["proof (chain)\npicking this:\n  a = x\n  b \\<in> set l", "obtain j where \"b = l!j\" \"j<length l\""], ["proof (prove)\nusing this:\n  a = x\n  b \\<in> set l\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>b = l ! j; j < length l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_nth)"], ["proof (state)\nthis:\n  b = l ! j\n  j < length l\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l)", "hence \"a=(x#l)!0\" \"b = (x#l)!Suc j\" \"0 < Suc j\" \"Suc j < length (x#l)\""], ["proof (prove)\nusing this:\n  b = l ! j\n  j < length l\n\ngoal (1 subgoal):\n 1. (a = (x # l) ! 0 &&& b = (x # l) ! Suc j) &&&\n    0 < Suc j &&& Suc j < length (x # l)", "by auto"], ["proof (state)\nthis:\n  a = (x # l) ! 0\n  b = (x # l) ! Suc j\n  0 < Suc j\n  Suc j < length (x # l)\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l)", "hence ?thesis"], ["proof (prove)\nusing this:\n  a = (x # l) ! 0\n  b = (x # l) ! Suc j\n  0 < Suc j\n  Suc j < length (x # l)\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l)", "unfolding list_before_rel_alt"], ["proof (prove)\nusing this:\n  a = (x # l) ! 0\n  b = (x # l) ! Suc j\n  0 < Suc j\n  Suc j < length (x # l)\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> {((x # l) ! i, (x # l) ! j) |i j. i < j \\<and> j < length (x # l)}", "by blast"], ["proof (state)\nthis:\n  (a, b) \\<in> list_before_rel (x # l)\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a = x; b \\<in> set l\\<rbrakk>\n  \\<Longrightarrow> (a, b) \\<in> list_before_rel (x # l)\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>a = x; b \\<in> set l\\<rbrakk>\n  \\<Longrightarrow> (a, b) \\<in> list_before_rel (x # l)\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>a = x; b \\<in> set l\\<rbrakk>\n  \\<Longrightarrow> (a, b) \\<in> list_before_rel (x # l)\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l)", "assume \"(a, b) \\<in> list_before_rel l\""], ["proof (state)\nthis:\n  (a, b) \\<in> list_before_rel l\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l)", "hence ?thesis"], ["proof (prove)\nusing this:\n  (a, b) \\<in> list_before_rel l\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l)", "unfolding list_before_rel_alt"], ["proof (prove)\nusing this:\n  (a, b) \\<in> {(l ! i, l ! j) |i j. i < j \\<and> j < length l}\n\ngoal (1 subgoal):\n 1. (a, b)\n    \\<in> {((x # l) ! i, (x # l) ! j) |i j. i < j \\<and> j < length (x # l)}", "by clarsimp (metis Suc_mono nth_Cons_Suc)"], ["proof (state)\nthis:\n  (a, b) \\<in> list_before_rel (x # l)\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l)", "}"], ["proof (state)\nthis:\n  (a, b) \\<in> list_before_rel l \\<Longrightarrow>\n  (a, b) \\<in> list_before_rel (x # l)\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>a = x; b \\<in> set l\\<rbrakk>\n  \\<Longrightarrow> (a, b) \\<in> list_before_rel (x # l)\n  (a, b) \\<in> list_before_rel l \\<Longrightarrow>\n  (a, b) \\<in> list_before_rel (x # l)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>a = x; b \\<in> set l\\<rbrakk>\n  \\<Longrightarrow> (a, b) \\<in> list_before_rel (x # l)\n  (a, b) \\<in> list_before_rel l \\<Longrightarrow>\n  (a, b) \\<in> list_before_rel (x # l)\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l)", "using prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>a = x; b \\<in> set l\\<rbrakk>\n  \\<Longrightarrow> (a, b) \\<in> list_before_rel (x # l)\n  (a, b) \\<in> list_before_rel l \\<Longrightarrow>\n  (a, b) \\<in> list_before_rel (x # l)\n  a = x \\<and> b \\<in> set l \\<or> (a, b) \\<in> list_before_rel l\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> list_before_rel (x # l)", "by blast"], ["proof (state)\nthis:\n  (a, b) \\<in> list_before_rel (x # l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Topological Ordering\\<close>"], ["", "text \\<open>\n  A topological ordering of a graph (binary relation) is an enumeration of its\n  nodes, such that for any two nodes \\<open>x\\<close>,\\<open>y\\<close> with \\<open>x\\<close> being enumerated earlier than \\<open>y\\<close>,\n  there is no path from \\<open>y\\<close> to \\<open>x\\<close> in the graph.\n\n  We define the predicate \\<open>is_top_sorted\\<close> to capture the sortedness criterion, but\n  not the completeness criterion, i.e., the list needs not contain all \n  nodes of the graph.\n\\<close>"], ["", "definition \"is_top_sorted R l \\<equiv> list_before_rel l \\<inter> (R\\<^sup>*)\\<inverse> = {}\""], ["", "lemma is_top_sorted_alt: \"is_top_sorted R l \\<longleftrightarrow> (\\<forall>x y. (x,y)\\<in>list_before_rel l \\<longrightarrow> (y,x)\\<notin>R\\<^sup>*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_top_sorted R l =\n    (\\<forall>x y.\n        (x, y) \\<in> list_before_rel l \\<longrightarrow>\n        (y, x) \\<notin> R\\<^sup>*)", "unfolding is_top_sorted_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_before_rel l \\<inter> (R\\<^sup>*)\\<inverse> = {}) =\n    (\\<forall>x y.\n        (x, y) \\<in> list_before_rel l \\<longrightarrow>\n        (y, x) \\<notin> R\\<^sup>*)", "by auto"], ["", "lemma is_top_sorted_empty_rel[simp]: \"is_top_sorted {} l \\<longleftrightarrow> distinct l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_top_sorted {} l = distinct l", "by (auto simp: is_top_sorted_def list_before_irrefl_eq_distinct[symmetric] irrefl_def)"], ["", "lemma is_top_sorted_empty_list[simp]: \"is_top_sorted R []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_top_sorted R []", "by (auto simp: is_top_sorted_def)"], ["", "text \\<open>A topological sorted list must be distinct\\<close>"], ["", "lemma is_top_sorted_distinct: \n  assumes \"is_top_sorted R l\" \n  shows \"distinct l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct l", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct l \\<Longrightarrow> False", "assume \"\\<not>distinct l\""], ["proof (state)\nthis:\n  \\<not> distinct l\n\ngoal (1 subgoal):\n 1. \\<not> distinct l \\<Longrightarrow> False", "with list_before_irrefl_eq_distinct[of l]"], ["proof (chain)\npicking this:\n  irrefl (list_before_rel l) = distinct l\n  \\<not> distinct l", "obtain x where \"(x,x)\\<in>(list_before_rel l)\""], ["proof (prove)\nusing this:\n  irrefl (list_before_rel l) = distinct l\n  \\<not> distinct l\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        (x, x) \\<in> list_before_rel l \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: irrefl_def)"], ["proof (state)\nthis:\n  (x, x) \\<in> list_before_rel l\n\ngoal (1 subgoal):\n 1. \\<not> distinct l \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  is_top_sorted R l\n  (x, x) \\<in> list_before_rel l", "show False"], ["proof (prove)\nusing this:\n  is_top_sorted R l\n  (x, x) \\<in> list_before_rel l\n\ngoal (1 subgoal):\n 1. False", "unfolding is_top_sorted_def"], ["proof (prove)\nusing this:\n  list_before_rel l \\<inter> (R\\<^sup>*)\\<inverse> = {}\n  (x, x) \\<in> list_before_rel l\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_top_sorted_cons: \"is_top_sorted R (x#l) \\<longleftrightarrow> ({x}\\<times>set l \\<inter> (R\\<^sup>*)\\<inverse> = {}) \\<and> is_top_sorted R l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_top_sorted R (x # l) =\n    ({x} \\<times> set l \\<inter> (R\\<^sup>*)\\<inverse> = {} \\<and>\n     is_top_sorted R l)", "unfolding is_top_sorted_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_before_rel (x # l) \\<inter> (R\\<^sup>*)\\<inverse> = {}) =\n    ({x} \\<times> set l \\<inter> (R\\<^sup>*)\\<inverse> = {} \\<and>\n     list_before_rel l \\<inter> (R\\<^sup>*)\\<inverse> = {})", "by (auto simp: list_before_rel_cons)"], ["", "lemma is_top_sorted_append: \"is_top_sorted R (l1@l2) \n  \\<longleftrightarrow> (set l1\\<times>set l2 \\<inter> (R\\<^sup>*)\\<inverse> = {}) \\<and> is_top_sorted R l1 \\<and> is_top_sorted R l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_top_sorted R (l1 @ l2) =\n    (set l1 \\<times> set l2 \\<inter> (R\\<^sup>*)\\<inverse> = {} \\<and>\n     is_top_sorted R l1 \\<and> is_top_sorted R l2)", "by (induction l1) (auto simp: is_top_sorted_cons)"], ["", "lemma is_top_sorted_remove_elem: \"is_top_sorted R (l1@x#l2) \\<Longrightarrow> is_top_sorted R (l1@l2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_top_sorted R (l1 @ x # l2) \\<Longrightarrow>\n    is_top_sorted R (l1 @ l2)", "by (auto simp: is_top_sorted_cons is_top_sorted_append)"], ["", "text \\<open>Removing edges from the graph preserves topological sorting\\<close>"], ["", "lemma is_top_sorted_antimono:\n  assumes \"R\\<subseteq>R'\"\n  assumes \"is_top_sorted R' l\"\n  shows \"is_top_sorted R l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_top_sorted R l", "using assms"], ["proof (prove)\nusing this:\n  R \\<subseteq> R'\n  is_top_sorted R' l\n\ngoal (1 subgoal):\n 1. is_top_sorted R l", "unfolding is_top_sorted_alt"], ["proof (prove)\nusing this:\n  R \\<subseteq> R'\n  \\<forall>x y.\n     (x, y) \\<in> list_before_rel l \\<longrightarrow>\n     (y, x) \\<notin> R'\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (x, y) \\<in> list_before_rel l \\<longrightarrow>\n       (y, x) \\<notin> R\\<^sup>*", "by (auto dest: rtrancl_mono_mp)"], ["", "text \\<open>\n  Adding a node to the graph, which has no incoming edges preserves topological ordering.\n\\<close>"], ["", "lemma is_top_sorted_isolated_constraint:\n  assumes \"R' \\<subseteq> R \\<union> {x}\\<times>X\" \"R'\\<inter>UNIV\\<times>{x} = {}\"\n  assumes \"x\\<notin>set l\"  \n  assumes \"is_top_sorted R l\"  \n  shows \"is_top_sorted R' l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_top_sorted R' l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_top_sorted R' l", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. is_top_sorted R' l", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. is_top_sorted R' l", "assume \"(a,b)\\<in>R'\\<^sup>*\" \"a\\<noteq>x\" \"b\\<noteq>x\""], ["proof (state)\nthis:\n  (a, b) \\<in> R'\\<^sup>*\n  a \\<noteq> x\n  b \\<noteq> x\n\ngoal (1 subgoal):\n 1. is_top_sorted R' l", "hence \"(a,b)\\<in>R\\<^sup>*\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> R'\\<^sup>*\n  a \\<noteq> x\n  b \\<noteq> x\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> R\\<^sup>*", "proof (induction rule: converse_rtrancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>b \\<noteq> x; b \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> (b, b) \\<in> R\\<^sup>*\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R'; (z, b) \\<in> R'\\<^sup>*;\n        \\<lbrakk>z \\<noteq> x; b \\<noteq> x\\<rbrakk>\n        \\<Longrightarrow> (z, b) \\<in> R\\<^sup>*;\n        y \\<noteq> x; b \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> (y, b) \\<in> R\\<^sup>*", "case base"], ["proof (state)\nthis:\n  b \\<noteq> x\n  b \\<noteq> x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b \\<noteq> x; b \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> (b, b) \\<in> R\\<^sup>*\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R'; (z, b) \\<in> R'\\<^sup>*;\n        \\<lbrakk>z \\<noteq> x; b \\<noteq> x\\<rbrakk>\n        \\<Longrightarrow> (z, b) \\<in> R\\<^sup>*;\n        y \\<noteq> x; b \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> (y, b) \\<in> R\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  b \\<noteq> x\n  b \\<noteq> x", "show ?case"], ["proof (prove)\nusing this:\n  b \\<noteq> x\n  b \\<noteq> x\n\ngoal (1 subgoal):\n 1. (b, b) \\<in> R\\<^sup>*", "by simp"], ["proof (state)\nthis:\n  (b, b) \\<in> R\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R'; (z, b) \\<in> R'\\<^sup>*;\n        \\<lbrakk>z \\<noteq> x; b \\<noteq> x\\<rbrakk>\n        \\<Longrightarrow> (z, b) \\<in> R\\<^sup>*;\n        y \\<noteq> x; b \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> (y, b) \\<in> R\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R'; (z, b) \\<in> R'\\<^sup>*;\n        \\<lbrakk>z \\<noteq> x; b \\<noteq> x\\<rbrakk>\n        \\<Longrightarrow> (z, b) \\<in> R\\<^sup>*;\n        y \\<noteq> x; b \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> (y, b) \\<in> R\\<^sup>*", "case (step y z)"], ["proof (state)\nthis:\n  (y, z) \\<in> R'\n  (z, b) \\<in> R'\\<^sup>*\n  \\<lbrakk>z \\<noteq> x; b \\<noteq> x\\<rbrakk>\n  \\<Longrightarrow> (z, b) \\<in> R\\<^sup>*\n  y \\<noteq> x\n  b \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R'; (z, b) \\<in> R'\\<^sup>*;\n        \\<lbrakk>z \\<noteq> x; b \\<noteq> x\\<rbrakk>\n        \\<Longrightarrow> (z, b) \\<in> R\\<^sup>*;\n        y \\<noteq> x; b \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> (y, b) \\<in> R\\<^sup>*", "with assms(1,2)"], ["proof (chain)\npicking this:\n  R' \\<subseteq> R \\<union> {x} \\<times> X\n  R' \\<inter> UNIV \\<times> {x} = {}\n  (y, z) \\<in> R'\n  (z, b) \\<in> R'\\<^sup>*\n  \\<lbrakk>z \\<noteq> x; b \\<noteq> x\\<rbrakk>\n  \\<Longrightarrow> (z, b) \\<in> R\\<^sup>*\n  y \\<noteq> x\n  b \\<noteq> x", "have \"z\\<noteq>x\" \"(y,z)\\<in>R\""], ["proof (prove)\nusing this:\n  R' \\<subseteq> R \\<union> {x} \\<times> X\n  R' \\<inter> UNIV \\<times> {x} = {}\n  (y, z) \\<in> R'\n  (z, b) \\<in> R'\\<^sup>*\n  \\<lbrakk>z \\<noteq> x; b \\<noteq> x\\<rbrakk>\n  \\<Longrightarrow> (z, b) \\<in> R\\<^sup>*\n  y \\<noteq> x\n  b \\<noteq> x\n\ngoal (1 subgoal):\n 1. z \\<noteq> x &&& (y, z) \\<in> R", "by auto"], ["proof (state)\nthis:\n  z \\<noteq> x\n  (y, z) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> R'; (z, b) \\<in> R'\\<^sup>*;\n        \\<lbrakk>z \\<noteq> x; b \\<noteq> x\\<rbrakk>\n        \\<Longrightarrow> (z, b) \\<in> R\\<^sup>*;\n        y \\<noteq> x; b \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> (y, b) \\<in> R\\<^sup>*", "with step"], ["proof (chain)\npicking this:\n  (y, z) \\<in> R'\n  (z, b) \\<in> R'\\<^sup>*\n  \\<lbrakk>z \\<noteq> x; b \\<noteq> x\\<rbrakk>\n  \\<Longrightarrow> (z, b) \\<in> R\\<^sup>*\n  y \\<noteq> x\n  b \\<noteq> x\n  z \\<noteq> x\n  (y, z) \\<in> R", "show ?case"], ["proof (prove)\nusing this:\n  (y, z) \\<in> R'\n  (z, b) \\<in> R'\\<^sup>*\n  \\<lbrakk>z \\<noteq> x; b \\<noteq> x\\<rbrakk>\n  \\<Longrightarrow> (z, b) \\<in> R\\<^sup>*\n  y \\<noteq> x\n  b \\<noteq> x\n  z \\<noteq> x\n  (y, z) \\<in> R\n\ngoal (1 subgoal):\n 1. (y, b) \\<in> R\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (y, b) \\<in> R\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (a, b) \\<in> R\\<^sup>*\n\ngoal (1 subgoal):\n 1. is_top_sorted R' l", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?a2, ?b2) \\<in> R'\\<^sup>*; ?a2 \\<noteq> x;\n   ?b2 \\<noteq> x\\<rbrakk>\n  \\<Longrightarrow> (?a2, ?b2) \\<in> R\\<^sup>*\n\ngoal (1 subgoal):\n 1. is_top_sorted R' l", "note AUX=this"], ["proof (state)\nthis:\n  \\<lbrakk>(?a2, ?b2) \\<in> R'\\<^sup>*; ?a2 \\<noteq> x;\n   ?b2 \\<noteq> x\\<rbrakk>\n  \\<Longrightarrow> (?a2, ?b2) \\<in> R\\<^sup>*\n\ngoal (1 subgoal):\n 1. is_top_sorted R' l", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_top_sorted R' l", "using assms(3,4) AUX list_before_rel_on_elems"], ["proof (prove)\nusing this:\n  x \\<notin> set l\n  is_top_sorted R l\n  \\<lbrakk>(?a2, ?b2) \\<in> R'\\<^sup>*; ?a2 \\<noteq> x;\n   ?b2 \\<noteq> x\\<rbrakk>\n  \\<Longrightarrow> (?a2, ?b2) \\<in> R\\<^sup>*\n  list_before_rel ?l \\<subseteq> set ?l \\<times> set ?l\n\ngoal (1 subgoal):\n 1. is_top_sorted R' l", "unfolding is_top_sorted_def"], ["proof (prove)\nusing this:\n  x \\<notin> set l\n  list_before_rel l \\<inter> (R\\<^sup>*)\\<inverse> = {}\n  \\<lbrakk>(?a2, ?b2) \\<in> R'\\<^sup>*; ?a2 \\<noteq> x;\n   ?b2 \\<noteq> x\\<rbrakk>\n  \\<Longrightarrow> (?a2, ?b2) \\<in> R\\<^sup>*\n  list_before_rel ?l \\<subseteq> set ?l \\<times> set ?l\n\ngoal (1 subgoal):\n 1. list_before_rel l \\<inter> (R'\\<^sup>*)\\<inverse> = {}", "by fastforce"], ["proof (state)\nthis:\n  is_top_sorted R' l\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}