{"file_name": "/home/qj213/afp-2021-10-22/thys/Prpu_Maxflow/Relabel_To_Front.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Prpu_Maxflow", "problem_names": ["lemma adm_edges_inv_disj: \"adm_edges f l \\<inter> (adm_edges f l)\\<inverse> = {}\"", "lemma finite_adm_edges[simp, intro!]: \"finite (adm_edges f l)\"", "lemma (in push_effect_locale) uv_adm: \"(u,v)\\<in>adm_edges f l\"", "lemma (in Labeling) push_adm_edges:\n  assumes \"push_precond f l e\"  \n  shows \"adm_edges f l - {e} \\<subseteq> adm_edges (push_effect f e) l\" (is ?G1)\n    and \"adm_edges (push_effect f e) l \\<subseteq> adm_edges f l\" (is ?G2)", "lemma (in Labeling) relabel_adm_edges:\n  assumes PRE: \"relabel_precond f l u\"\n  defines \"l' \\<equiv> relabel_effect f l u\"\n  shows \"adm_edges f l' \\<inter> cf.outgoing u \\<noteq> {}\" (is ?G1)\n    and \"adm_edges f l' \\<inter> cf.incoming u = {}\" (is ?G2)\n    and \"adm_edges f l' - cf.adjacent u = adm_edges f l - cf.adjacent u\" (is ?G3)", "lemma nbr_is_hbl: \"Height_Bounded_Labeling c s t f l\"", "lemma push_pres_nbr_invar:\n  assumes PRE: \"push_precond f l e\"\n  shows \"neighbor_invar c s t (push_effect f e) l n\"", "lemma relabel_pres_nbr_invar:  \n  assumes PRE: \"relabel_precond f l u\"\n  shows \"neighbor_invar c s t f (relabel_effect f l u) (n(u:=adjacent_nodes u))\"", "lemma excess_nz_iff_gz: \"\\<lbrakk> u\\<in>V; u\\<noteq>s \\<rbrakk> \\<Longrightarrow> excess f u \\<noteq> 0 \\<longleftrightarrow> excess f u > 0\"", "lemma no_neighbors_relabel_precond: \n  assumes \"n u = {}\" \"u\\<noteq>t\" \"u\\<noteq>s\" \"u\\<in>V\" \"excess f u \\<noteq> 0\"\n  shows \"relabel_precond f l u\"", "lemma remove_neighbor_pres_nbr_invar: \"(u,v)\\<notin>adm_edges f l \n  \\<Longrightarrow> neighbor_invar c s t f l (n (u := n u - {v}))\"", "lemma u_node_simp1[simp]: \"u\\<noteq>s\" \"u\\<noteq>t\" \"s\\<noteq>u\" \"t\\<noteq>u\"", "lemma u_node_simp2[simp, intro!]: \"u\\<in>V\"", "lemma dis_is_lbl: \"Labeling c s t f l\"", "lemma dis_is_hbl: \"Height_Bounded_Labeling c s t f l\"", "lemma dis_is_nbr: \"neighbor_invar c s t f l n\"", "lemma new_adm_imp_relabel: \n  \"(u',v)\\<in>adm_edges f l - adm_edges fo lo \\<Longrightarrow> lo u \\<noteq> l u\"", "lemma push_pres_dis_invar:\n  assumes PRE: \"push_precond f l (u,v)\"\n  shows \"discharge_invar c s t u fo lo no (push_effect f (u,v)) l n\"", "lemma relabel_pres_dis_invar:\n  assumes PRE: \"relabel_precond f l u\"\n  shows \"discharge_invar c s t u fo lo no f \n            (relabel_effect f l u) (n(u := adjacent_nodes u))\"", "lemma push_precondI_nz: \n  \"\\<lbrakk>excess f u \\<noteq> 0; (u,v)\\<in>cfE_of f; l u = l v + 1\\<rbrakk> \\<Longrightarrow> push_precond f l (u,v)\"", "lemma remove_neighbor_pres_dis_invar: \n  assumes PRE: \"(u,v)\\<notin>adm_edges f l\"  \n  defines \"n' \\<equiv> n (u := n u - {v})\"  \n  shows \"discharge_invar c s t u fo lo no f l n'\"", "lemma neighbors_in_V: \"v\\<in>n u \\<Longrightarrow> v\\<in>V\"", "lemma neighbors_in_E: \"v\\<in>n u \\<Longrightarrow> (u,v)\\<in>E\\<union>E\\<inverse>\"", "lemma relabeled_node_has_outgoing: \n  assumes \"relabel_precond f l u\"\n  shows \"\\<exists>v. (u,v)\\<in>cfE_of f\"", "lemma (in neighbor_invar) discharge_invar_init: \n  assumes \"u\\<in>V-{s,t}\"\n  shows \"discharge_invar c s t u f l n f l n\"", "lemma discharge_correct[THEN order_trans, refine_vcg]:\n  assumes DINV: \"neighbor_invar c s t f l n\"\n  assumes NOT_ST: \"u\\<noteq>t\" \"u\\<noteq>s\" and UIV: \"u\\<in>V\"\n  shows \"discharge f l n u \n    \\<le> SPEC (\\<lambda>(f',l',n'). discharge_invar c s t u f l n f' l' n' \n                       \\<and> excess f' u = 0)\"", "lemma rtf_init_n_finite[simp, intro!]: \"finite (rtf_init_n u)\"", "lemma init_no_adm_edges[simp]: \"adm_edges pp_init_f pp_init_l = {}\"", "lemma rtf_init_neighbor_invar: \n  \"neighbor_invar c s t pp_init_f pp_init_l rtf_init_n\"", "lemma rtf_is_nbr: \"neighbor_invar c s t f l n\"", "lemma L_distinct: \"distinct (L_left @ L_right)\"", "lemma terminated_imp_maxflow: \n    assumes [simp]: \"L_right = []\"   \n    shows \"isMaxFlow f\"", "lemma rtf_init_invar: \n  assumes DIS: \"distinct L_left\" and L_set: \"set L_left = V-{s,t}\"\n  shows \"rtf_invar c s t pp_init_f pp_init_l rtf_init_n [] L_left\"", "theorem relabel_to_front_correct: \n  \"relabel_to_front \\<le> SPEC isMaxFlow\""], "translations": [["", "lemma adm_edges_inv_disj: \"adm_edges f l \\<inter> (adm_edges f l)\\<inverse> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm_edges f l \\<inter> (adm_edges f l)\\<inverse> = {}", "unfolding adm_edges_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(u, v). (u, v) \\<in> cfE_of f \\<and> l u = l v + 1} \\<inter>\n    {(u, v). (u, v) \\<in> cfE_of f \\<and> l u = l v + 1}\\<inverse> =\n    {}", "by auto"], ["", "lemma finite_adm_edges[simp, intro!]: \"finite (adm_edges f l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (adm_edges f l)", "apply (rule finite_subset[of _ \"cfE_of f\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. adm_edges f l \\<subseteq> cfE_of f\n 2. finite (cfE_of f)", "by (auto simp: adm_edges_def)"], ["", "end \\<comment> \\<open>Network\\<close>"], ["", "text \\<open>The edge of a push operation is admissible.\\<close>"], ["", "lemma (in push_effect_locale) uv_adm: \"(u,v)\\<in>adm_edges f l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> adm_edges f l", "unfolding adm_edges_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> {(u, v). (u, v) \\<in> cf.E \\<and> l u = l v + 1}", "by auto"], ["", "text \\<open>\n  A push operation will not create new admissible edges, but the \n  edge that we pushed over may become inadmissible \\cormen{26.27}.\n\\<close>"], ["", "lemma (in Labeling) push_adm_edges:\n  assumes \"push_precond f l e\"  \n  shows \"adm_edges f l - {e} \\<subseteq> adm_edges (push_effect f e) l\" (is ?G1)\n    and \"adm_edges (push_effect f e) l \\<subseteq> adm_edges f l\" (is ?G2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. adm_edges f l - {e} \\<subseteq> adm_edges (push_effect f e) l &&&\n    adm_edges (push_effect f e) l \\<subseteq> adm_edges f l", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. adm_edges f l - {e} \\<subseteq> adm_edges (push_effect f e) l\n 2. adm_edges (push_effect f e) l \\<subseteq> adm_edges f l", "from assms"], ["proof (chain)\npicking this:\n  push_precond f l e", "consider (sat) \"sat_push_precond f l e\" \n                 | (nonsat) \"nonsat_push_precond f l e\""], ["proof (prove)\nusing this:\n  push_precond f l e\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sat_push_precond f l e \\<Longrightarrow> thesis;\n     nonsat_push_precond f l e \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (auto simp: push_precond_eq_sat_or_nonsat)"], ["proof (state)\nthis:\n  \\<lbrakk>sat_push_precond f l e \\<Longrightarrow> ?thesis3;\n   nonsat_push_precond f l e \\<Longrightarrow> ?thesis3\\<rbrakk>\n  \\<Longrightarrow> ?thesis3\n\ngoal (2 subgoals):\n 1. adm_edges f l - {e} \\<subseteq> adm_edges (push_effect f e) l\n 2. adm_edges (push_effect f e) l \\<subseteq> adm_edges f l", "hence \"?G1 \\<and> ?G2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>sat_push_precond f l e \\<Longrightarrow> ?thesis3;\n   nonsat_push_precond f l e \\<Longrightarrow> ?thesis3\\<rbrakk>\n  \\<Longrightarrow> ?thesis3\n\ngoal (1 subgoal):\n 1. adm_edges f l - {e} \\<subseteq> adm_edges (push_effect f e) l \\<and>\n    adm_edges (push_effect f e) l \\<subseteq> adm_edges f l", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. sat_push_precond f l e \\<Longrightarrow>\n    adm_edges f l - {e} \\<subseteq> adm_edges (push_effect f e) l \\<and>\n    adm_edges (push_effect f e) l \\<subseteq> adm_edges f l\n 2. nonsat_push_precond f l e \\<Longrightarrow>\n    adm_edges f l - {e} \\<subseteq> adm_edges (push_effect f e) l \\<and>\n    adm_edges (push_effect f e) l \\<subseteq> adm_edges f l", "case sat"], ["proof (state)\nthis:\n  sat_push_precond f l e\n\ngoal (2 subgoals):\n 1. sat_push_precond f l e \\<Longrightarrow>\n    adm_edges f l - {e} \\<subseteq> adm_edges (push_effect f e) l \\<and>\n    adm_edges (push_effect f e) l \\<subseteq> adm_edges f l\n 2. nonsat_push_precond f l e \\<Longrightarrow>\n    adm_edges f l - {e} \\<subseteq> adm_edges (push_effect f e) l \\<and>\n    adm_edges (push_effect f e) l \\<subseteq> adm_edges f l", "have \"adm_edges (push_effect f e) l = adm_edges f l - {e}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm_edges (push_effect f e) l = adm_edges f l - {e}", "unfolding sat_push_alt[OF sat]"], ["proof (prove)\ngoal (1 subgoal):\n 1. adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}", "(* TODO: Clean up. Use push_effect_locale! *)"], ["proof (state)\ngoal (1 subgoal):\n 1. adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}", "let ?f'=\"(augment_edge f e (cf e))\""], ["proof (state)\ngoal (1 subgoal):\n 1. adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}", "interpret l': Labeling c s t ?f' l"], ["proof (prove)\ngoal (1 subgoal):\n 1. Labeling c s t (augment_edge f e (cf e)) l", "using push_pres_Labeling[OF assms]"], ["proof (prove)\nusing this:\n  Labeling c s t (push_effect f e) l\n\ngoal (1 subgoal):\n 1. Labeling c s t (augment_edge f e (cf e)) l", "unfolding sat_push_alt[OF sat]"], ["proof (prove)\nusing this:\n  Labeling c s t (augment_edge f e (cf e)) l\n\ngoal (1 subgoal):\n 1. Labeling c s t (augment_edge f e (cf e)) l", "."], ["proof (state)\ngoal (1 subgoal):\n 1. adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}", "from sat"], ["proof (chain)\npicking this:\n  sat_push_precond f l e", "have G1: \"e\\<in>adm_edges f l\""], ["proof (prove)\nusing this:\n  sat_push_precond f l e\n\ngoal (1 subgoal):\n 1. e \\<in> adm_edges f l", "unfolding sat_push_precond_def adm_edges_def"], ["proof (prove)\nusing this:\n  case e of\n  (u, v) \\<Rightarrow>\n    (0::'a) < excess f u \\<and>\n    cf (u, v) \\<le> excess f u \\<and> (u, v) \\<in> cf.E \\<and> l u = l v + 1\n\ngoal (1 subgoal):\n 1. e \\<in> {(u, v). (u, v) \\<in> cf.E \\<and> l u = l v + 1}", "by auto"], ["proof (state)\nthis:\n  e \\<in> adm_edges f l\n\ngoal (1 subgoal):\n 1. adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}", "have \"l'.cf.E \\<subseteq> insert (prod.swap e) cf.E - {e}\" \"l'.cf.E \\<supseteq> cf.E - {e}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l'.cf.E \\<subseteq> insert (prod.swap e) cf.E - {e} &&&\n    cf.E - {e} \\<subseteq> l'.cf.E", "unfolding l'.cf_def cf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cfE_of\n     (augment_edge f e\n       (case e of\n        (u, v) \\<Rightarrow>\n          if (u, v) \\<in> E then c (u, v) - f (u, v)\n          else if (v, u) \\<in> E then f (v, u) else (0::'a)))\n    \\<subseteq> insert (prod.swap e)\n                 (Graph.E\n                   (\\<lambda>(u, v).\n                       if (u, v) \\<in> E then c (u, v) - f (u, v)\n                       else if (v, u) \\<in> E then f (v, u) else (0::'a))) -\n                {e} &&&\n    Graph.E\n     (\\<lambda>(u, v).\n         if (u, v) \\<in> E then c (u, v) - f (u, v)\n         else if (v, u) \\<in> E then f (v, u) else (0::'a)) -\n    {e}\n    \\<subseteq> cfE_of\n                 (augment_edge f e\n                   (case e of\n                    (u, v) \\<Rightarrow>\n                      if (u, v) \\<in> E then c (u, v) - f (u, v)\n                      else if (v, u) \\<in> E then f (v, u) else (0::'a)))", "unfolding augment_edge_def residualGraph_def Graph.E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(u, v).\n     (case (u, v) of\n      (u, v) \\<Rightarrow>\n        if (u, v) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n        then c (u, v) -\n             (case e of\n              (u, v) \\<Rightarrow>\n                \\<lambda>\\<Delta>.\n                   if (u, v) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                   then f((u, v) := f (u, v) + \\<Delta>)\n                   else if (v, u) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                        then f((v, u) := f (v, u) - \\<Delta>) else f)\n              (case e of\n               (u, v) \\<Rightarrow>\n                 if (u, v) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                 then c (u, v) - f (u, v)\n                 else if (v, u) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                      then f (v, u) else (0::'a))\n              (u, v)\n        else if (v, u) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n             then (case e of\n                   (u, v) \\<Rightarrow>\n                     \\<lambda>\\<Delta>.\n                        if (u, v) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                        then f((u, v) := f (u, v) + \\<Delta>)\n                        else if (v, u)\n                                \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                             then f((v, u) := f (v, u) - \\<Delta>) else f)\n                   (case e of\n                    (u, v) \\<Rightarrow>\n                      if (u, v) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                      then c (u, v) - f (u, v)\n                      else if (v, u)\n                              \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                           then f (v, u) else (0::'a))\n                   (v, u)\n             else (0::'a)) \\<noteq>\n     (0::'a)}\n    \\<subseteq> insert (prod.swap e)\n                 {(u, v).\n                  (case (u, v) of\n                   (u, v) \\<Rightarrow>\n                     if (u, v) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                     then c (u, v) - f (u, v)\n                     else if (v, u)\n                             \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                          then f (v, u) else (0::'a)) \\<noteq>\n                  (0::'a)} -\n                {e} &&&\n    {(u, v).\n     (case (u, v) of\n      (u, v) \\<Rightarrow>\n        if (u, v) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n        then c (u, v) - f (u, v)\n        else if (v, u) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n             then f (v, u) else (0::'a)) \\<noteq>\n     (0::'a)} -\n    {e}\n    \\<subseteq> {(u, v).\n                 (case (u, v) of\n                  (u, v) \\<Rightarrow>\n                    if (u, v) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                    then c (u, v) -\n                         (case e of\n                          (u, v) \\<Rightarrow>\n                            \\<lambda>\\<Delta>.\n                               if (u, v)\n                                  \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                               then f((u, v) := f (u, v) + \\<Delta>)\n                               else if (v, u)\n \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                                    then f((v, u) := f (v, u) - \\<Delta>)\n                                    else f)\n                          (case e of\n                           (u, v) \\<Rightarrow>\n                             if (u, v)\n                                \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                             then c (u, v) - f (u, v)\n                             else if (v, u)\n                                     \\<in> {(u, v).\n      c (u, v) \\<noteq> (0::'a)}\n                                  then f (v, u) else (0::'a))\n                          (u, v)\n                    else if (v, u) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                         then (case e of\n                               (u, v) \\<Rightarrow>\n                                 \\<lambda>\\<Delta>.\n                                    if (u, v)\n \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                                    then f((u, v) := f (u, v) + \\<Delta>)\n                                    else if (v, u)\n      \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n   then f((v, u) := f (v, u) - \\<Delta>) else f)\n                               (case e of\n                                (u, v) \\<Rightarrow>\n                                  if (u, v)\n                                     \\<in> {(u, v).\n      c (u, v) \\<noteq> (0::'a)}\n                                  then c (u, v) - f (u, v)\n                                  else if (v, u)\n    \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n then f (v, u) else (0::'a))\n                               (v, u)\n                         else (0::'a)) \\<noteq>\n                 (0::'a)}", "by (auto split!: if_splits prod.splits)"], ["proof (state)\nthis:\n  l'.cf.E \\<subseteq> insert (prod.swap e) cf.E - {e}\n  cf.E - {e} \\<subseteq> l'.cf.E\n\ngoal (1 subgoal):\n 1. adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}", "hence \"l'.cf.E = insert (prod.swap e) cf.E - {e} \\<or> l'.cf.E = cf.E - {e}\""], ["proof (prove)\nusing this:\n  l'.cf.E \\<subseteq> insert (prod.swap e) cf.E - {e}\n  cf.E - {e} \\<subseteq> l'.cf.E\n\ngoal (1 subgoal):\n 1. l'.cf.E = insert (prod.swap e) cf.E - {e} \\<or> l'.cf.E = cf.E - {e}", "by auto"], ["proof (state)\nthis:\n  l'.cf.E = insert (prod.swap e) cf.E - {e} \\<or> l'.cf.E = cf.E - {e}\n\ngoal (1 subgoal):\n 1. adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}", "thus \"adm_edges ?f' l = adm_edges f l - {e}\""], ["proof (prove)\nusing this:\n  l'.cf.E = insert (prod.swap e) cf.E - {e} \\<or> l'.cf.E = cf.E - {e}\n\ngoal (1 subgoal):\n 1. adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}", "proof (cases rule: disjE[consumes 1])"], ["proof (state)\ngoal (2 subgoals):\n 1. l'.cf.E = insert (prod.swap e) cf.E - {e} \\<Longrightarrow>\n    adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}\n 2. l'.cf.E = cf.E - {e} \\<Longrightarrow>\n    adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}", "case 1"], ["proof (state)\nthis:\n  l'.cf.E = insert (prod.swap e) cf.E - {e}\n\ngoal (2 subgoals):\n 1. l'.cf.E = insert (prod.swap e) cf.E - {e} \\<Longrightarrow>\n    adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}\n 2. l'.cf.E = cf.E - {e} \\<Longrightarrow>\n    adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}", "from sat"], ["proof (chain)\npicking this:\n  sat_push_precond f l e", "have \"e \\<in> adm_edges f l\""], ["proof (prove)\nusing this:\n  sat_push_precond f l e\n\ngoal (1 subgoal):\n 1. e \\<in> adm_edges f l", "unfolding sat_push_precond_def adm_edges_def"], ["proof (prove)\nusing this:\n  case e of\n  (u, v) \\<Rightarrow>\n    (0::'a) < excess f u \\<and>\n    cf (u, v) \\<le> excess f u \\<and> (u, v) \\<in> cf.E \\<and> l u = l v + 1\n\ngoal (1 subgoal):\n 1. e \\<in> {(u, v). (u, v) \\<in> cf.E \\<and> l u = l v + 1}", "by auto"], ["proof (state)\nthis:\n  e \\<in> adm_edges f l\n\ngoal (2 subgoals):\n 1. l'.cf.E = insert (prod.swap e) cf.E - {e} \\<Longrightarrow>\n    adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}\n 2. l'.cf.E = cf.E - {e} \\<Longrightarrow>\n    adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}", "with adm_edges_inv_disj"], ["proof (chain)\npicking this:\n  adm_edges ?f ?l \\<inter> (adm_edges ?f ?l)\\<inverse> = {}\n  e \\<in> adm_edges f l", "have \"prod.swap e \\<notin> adm_edges f l\""], ["proof (prove)\nusing this:\n  adm_edges ?f ?l \\<inter> (adm_edges ?f ?l)\\<inverse> = {}\n  e \\<in> adm_edges f l\n\ngoal (1 subgoal):\n 1. prod.swap e \\<notin> adm_edges f l", "by (auto simp: swap_in_iff_inv)"], ["proof (state)\nthis:\n  prod.swap e \\<notin> adm_edges f l\n\ngoal (2 subgoals):\n 1. l'.cf.E = insert (prod.swap e) cf.E - {e} \\<Longrightarrow>\n    adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}\n 2. l'.cf.E = cf.E - {e} \\<Longrightarrow>\n    adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}", "thus \"adm_edges ?f' l = adm_edges f l - {e}\""], ["proof (prove)\nusing this:\n  prod.swap e \\<notin> adm_edges f l\n\ngoal (1 subgoal):\n 1. adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}", "using G1"], ["proof (prove)\nusing this:\n  prod.swap e \\<notin> adm_edges f l\n  e \\<in> adm_edges f l\n\ngoal (1 subgoal):\n 1. adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}", "unfolding adm_edges_def 1"], ["proof (prove)\nusing this:\n  prod.swap e \\<notin> {(u, v). (u, v) \\<in> cf.E \\<and> l u = l v + 1}\n  e \\<in> {(u, v). (u, v) \\<in> cf.E \\<and> l u = l v + 1}\n\ngoal (1 subgoal):\n 1. {(u, v).\n     (u, v) \\<in> insert (prod.swap e) cf.E - {e} \\<and> l u = l v + 1} =\n    {(u, v). (u, v) \\<in> cf.E \\<and> l u = l v + 1} - {e}", "by auto"], ["proof (state)\nthis:\n  adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}\n\ngoal (1 subgoal):\n 1. l'.cf.E = cf.E - {e} \\<Longrightarrow>\n    adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l'.cf.E = cf.E - {e} \\<Longrightarrow>\n    adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}", "case 2"], ["proof (state)\nthis:\n  l'.cf.E = cf.E - {e}\n\ngoal (1 subgoal):\n 1. l'.cf.E = cf.E - {e} \\<Longrightarrow>\n    adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}", "thus \"adm_edges ?f' l = adm_edges f l - {e}\""], ["proof (prove)\nusing this:\n  l'.cf.E = cf.E - {e}\n\ngoal (1 subgoal):\n 1. adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}", "unfolding adm_edges_def 2"], ["proof (prove)\nusing this:\n  cf.E - {e} = cf.E - {e}\n\ngoal (1 subgoal):\n 1. {(u, v). (u, v) \\<in> cf.E - {e} \\<and> l u = l v + 1} =\n    {(u, v). (u, v) \\<in> cf.E \\<and> l u = l v + 1} - {e}", "by auto"], ["proof (state)\nthis:\n  adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  adm_edges (augment_edge f e (cf e)) l = adm_edges f l - {e}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  adm_edges (push_effect f e) l = adm_edges f l - {e}\n\ngoal (2 subgoals):\n 1. sat_push_precond f l e \\<Longrightarrow>\n    adm_edges f l - {e} \\<subseteq> adm_edges (push_effect f e) l \\<and>\n    adm_edges (push_effect f e) l \\<subseteq> adm_edges f l\n 2. nonsat_push_precond f l e \\<Longrightarrow>\n    adm_edges f l - {e} \\<subseteq> adm_edges (push_effect f e) l \\<and>\n    adm_edges (push_effect f e) l \\<subseteq> adm_edges f l", "thus ?thesis"], ["proof (prove)\nusing this:\n  adm_edges (push_effect f e) l = adm_edges f l - {e}\n\ngoal (1 subgoal):\n 1. adm_edges f l - {e} \\<subseteq> adm_edges (push_effect f e) l \\<and>\n    adm_edges (push_effect f e) l \\<subseteq> adm_edges f l", "by auto"], ["proof (state)\nthis:\n  adm_edges f l - {e} \\<subseteq> adm_edges (push_effect f e) l \\<and>\n  adm_edges (push_effect f e) l \\<subseteq> adm_edges f l\n\ngoal (1 subgoal):\n 1. nonsat_push_precond f l e \\<Longrightarrow>\n    adm_edges f l - {e} \\<subseteq> adm_edges (push_effect f e) l \\<and>\n    adm_edges (push_effect f e) l \\<subseteq> adm_edges f l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nonsat_push_precond f l e \\<Longrightarrow>\n    adm_edges f l - {e} \\<subseteq> adm_edges (push_effect f e) l \\<and>\n    adm_edges (push_effect f e) l \\<subseteq> adm_edges f l", "case nonsat"], ["proof (state)\nthis:\n  nonsat_push_precond f l e\n\ngoal (1 subgoal):\n 1. nonsat_push_precond f l e \\<Longrightarrow>\n    adm_edges f l - {e} \\<subseteq> adm_edges (push_effect f e) l \\<and>\n    adm_edges (push_effect f e) l \\<subseteq> adm_edges f l", "hence \"adm_edges (push_effect f e) l = adm_edges f l\""], ["proof (prove)\nusing this:\n  nonsat_push_precond f l e\n\ngoal (1 subgoal):\n 1. adm_edges (push_effect f e) l = adm_edges f l", "proof (cases e; simp add: nonsat_push_alt)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>nonsat_push_precond f l (a, b); e = (a, b)\\<rbrakk>\n       \\<Longrightarrow> adm_edges (augment_edge f (a, b) (excess f a)) l =\n                         adm_edges f l", "fix u v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>nonsat_push_precond f l (a, b); e = (a, b)\\<rbrakk>\n       \\<Longrightarrow> adm_edges (augment_edge f (a, b) (excess f a)) l =\n                         adm_edges f l", "assume [simp]: \"e=(u,v)\""], ["proof (state)\nthis:\n  e = (u, v)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>nonsat_push_precond f l (a, b); e = (a, b)\\<rbrakk>\n       \\<Longrightarrow> adm_edges (augment_edge f (a, b) (excess f a)) l =\n                         adm_edges f l", "let ?f'=\"(augment_edge f (u,v) (excess f u))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>nonsat_push_precond f l (a, b); e = (a, b)\\<rbrakk>\n       \\<Longrightarrow> adm_edges (augment_edge f (a, b) (excess f a)) l =\n                         adm_edges f l", "interpret l': Labeling c s t ?f' l"], ["proof (prove)\ngoal (1 subgoal):\n 1. Labeling c s t (augment_edge f (u, v) (excess f u)) l", "using push_pres_Labeling[OF assms] nonsat_push_alt nonsat"], ["proof (prove)\nusing this:\n  Labeling c s t (push_effect f e) l\n  nonsat_push_precond ?f ?l (?u, ?v) \\<Longrightarrow>\n  push_effect ?f (?u, ?v) = augment_edge ?f (?u, ?v) (excess ?f ?u)\n  nonsat_push_precond f l e\n\ngoal (1 subgoal):\n 1. Labeling c s t (augment_edge f (u, v) (excess f u)) l", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>nonsat_push_precond f l (a, b); e = (a, b)\\<rbrakk>\n       \\<Longrightarrow> adm_edges (augment_edge f (a, b) (excess f a)) l =\n                         adm_edges f l", "from nonsat"], ["proof (chain)\npicking this:\n  nonsat_push_precond f l e", "have \"e \\<in> adm_edges f l\""], ["proof (prove)\nusing this:\n  nonsat_push_precond f l e\n\ngoal (1 subgoal):\n 1. e \\<in> adm_edges f l", "unfolding nonsat_push_precond_def adm_edges_def"], ["proof (prove)\nusing this:\n  case e of\n  (u, v) \\<Rightarrow>\n    (0::'a) < excess f u \\<and>\n    excess f u < cf (u, v) \\<and> (u, v) \\<in> cf.E \\<and> l u = l v + 1\n\ngoal (1 subgoal):\n 1. e \\<in> {(u, v). (u, v) \\<in> cf.E \\<and> l u = l v + 1}", "by auto"], ["proof (state)\nthis:\n  e \\<in> adm_edges f l\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>nonsat_push_precond f l (a, b); e = (a, b)\\<rbrakk>\n       \\<Longrightarrow> adm_edges (augment_edge f (a, b) (excess f a)) l =\n                         adm_edges f l", "with adm_edges_inv_disj"], ["proof (chain)\npicking this:\n  adm_edges ?f ?l \\<inter> (adm_edges ?f ?l)\\<inverse> = {}\n  e \\<in> adm_edges f l", "have AUX: \"prod.swap e \\<notin> adm_edges f l\""], ["proof (prove)\nusing this:\n  adm_edges ?f ?l \\<inter> (adm_edges ?f ?l)\\<inverse> = {}\n  e \\<in> adm_edges f l\n\ngoal (1 subgoal):\n 1. prod.swap e \\<notin> adm_edges f l", "by (auto simp: swap_in_iff_inv)"], ["proof (state)\nthis:\n  prod.swap e \\<notin> adm_edges f l\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>nonsat_push_precond f l (a, b); e = (a, b)\\<rbrakk>\n       \\<Longrightarrow> adm_edges (augment_edge f (a, b) (excess f a)) l =\n                         adm_edges f l", "from nonsat"], ["proof (chain)\npicking this:\n  nonsat_push_precond f l e", "have \n        \"excess f u < cf (u,v)\" \"0 < excess f u\"\n        and [simp]: \"l u = l v + 1\""], ["proof (prove)\nusing this:\n  nonsat_push_precond f l e\n\ngoal (1 subgoal):\n 1. (excess f u < cf (u, v) &&& (0::'a) < excess f u) &&& l u = l v + 1", "unfolding nonsat_push_precond_def"], ["proof (prove)\nusing this:\n  case e of\n  (u, v) \\<Rightarrow>\n    (0::'a) < excess f u \\<and>\n    excess f u < cf (u, v) \\<and> (u, v) \\<in> cf.E \\<and> l u = l v + 1\n\ngoal (1 subgoal):\n 1. (excess f u < cf (u, v) &&& (0::'a) < excess f u) &&& l u = l v + 1", "by auto"], ["proof (state)\nthis:\n  excess f u < cf (u, v)\n  (0::'a) < excess f u\n  l u = l v + 1\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>nonsat_push_precond f l (a, b); e = (a, b)\\<rbrakk>\n       \\<Longrightarrow> adm_edges (augment_edge f (a, b) (excess f a)) l =\n                         adm_edges f l", "hence \"l'.cf.E \\<subseteq> insert (prod.swap e) cf.E\" \"l'.cf.E \\<supseteq> cf.E\""], ["proof (prove)\nusing this:\n  excess f u < cf (u, v)\n  (0::'a) < excess f u\n  l u = l v + 1\n\ngoal (1 subgoal):\n 1. l'.cf.E \\<subseteq> insert (prod.swap e) cf.E &&&\n    cf.E \\<subseteq> l'.cf.E", "unfolding l'.cf_def cf_def"], ["proof (prove)\nusing this:\n  excess f u\n  < (case (u, v) of\n     (u, v) \\<Rightarrow>\n       if (u, v) \\<in> E then c (u, v) - f (u, v)\n       else if (v, u) \\<in> E then f (v, u) else (0::'a))\n  (0::'a) < excess f u\n  l u = l v + 1\n\ngoal (1 subgoal):\n 1. Graph.E\n     (\\<lambda>(ua, va).\n         if (ua, va) \\<in> E\n         then c (ua, va) - augment_edge f (u, v) (excess f u) (ua, va)\n         else if (va, ua) \\<in> E\n              then augment_edge f (u, v) (excess f u) (va, ua) else (0::'a))\n    \\<subseteq> insert (prod.swap e)\n                 (Graph.E\n                   (\\<lambda>(u, v).\n                       if (u, v) \\<in> E then c (u, v) - f (u, v)\n                       else if (v, u) \\<in> E then f (v, u)\n                            else (0::'a))) &&&\n    Graph.E\n     (\\<lambda>(u, v).\n         if (u, v) \\<in> E then c (u, v) - f (u, v)\n         else if (v, u) \\<in> E then f (v, u) else (0::'a))\n    \\<subseteq> Graph.E\n                 (\\<lambda>(ua, va).\n                     if (ua, va) \\<in> E\n                     then c (ua, va) -\n                          augment_edge f (u, v) (excess f u) (ua, va)\n                     else if (va, ua) \\<in> E\n                          then augment_edge f (u, v) (excess f u) (va, ua)\n                          else (0::'a))", "unfolding augment_edge_def residualGraph_def Graph.E_def"], ["proof (prove)\nusing this:\n  excess f u\n  < (case (u, v) of\n     (u, v) \\<Rightarrow>\n       if (u, v) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n       then c (u, v) - f (u, v)\n       else if (v, u) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n            then f (v, u) else (0::'a))\n  (0::'a) < excess f u\n  l u = l v + 1\n\ngoal (1 subgoal):\n 1. {(ua, va).\n     (case (ua, va) of\n      (ua, va) \\<Rightarrow>\n        if (ua, va) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n        then c (ua, va) -\n             (case (u, v) of\n              (u, v) \\<Rightarrow>\n                \\<lambda>\\<Delta>.\n                   if (u, v) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                   then f((u, v) := f (u, v) + \\<Delta>)\n                   else if (v, u) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                        then f((v, u) := f (v, u) - \\<Delta>) else f)\n              (excess f u) (ua, va)\n        else if (va, ua) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n             then (case (u, v) of\n                   (u, v) \\<Rightarrow>\n                     \\<lambda>\\<Delta>.\n                        if (u, v) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                        then f((u, v) := f (u, v) + \\<Delta>)\n                        else if (v, u)\n                                \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                             then f((v, u) := f (v, u) - \\<Delta>) else f)\n                   (excess f u) (va, ua)\n             else (0::'a)) \\<noteq>\n     (0::'a)}\n    \\<subseteq> insert (prod.swap e)\n                 {(u, v).\n                  (case (u, v) of\n                   (u, v) \\<Rightarrow>\n                     if (u, v) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                     then c (u, v) - f (u, v)\n                     else if (v, u)\n                             \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                          then f (v, u) else (0::'a)) \\<noteq>\n                  (0::'a)} &&&\n    {(u, v).\n     (case (u, v) of\n      (u, v) \\<Rightarrow>\n        if (u, v) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n        then c (u, v) - f (u, v)\n        else if (v, u) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n             then f (v, u) else (0::'a)) \\<noteq>\n     (0::'a)}\n    \\<subseteq> {(ua, va).\n                 (case (ua, va) of\n                  (ua, va) \\<Rightarrow>\n                    if (ua, va) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                    then c (ua, va) -\n                         (case (u, v) of\n                          (u, v) \\<Rightarrow>\n                            \\<lambda>\\<Delta>.\n                               if (u, v)\n                                  \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                               then f((u, v) := f (u, v) + \\<Delta>)\n                               else if (v, u)\n \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                                    then f((v, u) := f (v, u) - \\<Delta>)\n                                    else f)\n                          (excess f u) (ua, va)\n                    else if (va, ua)\n                            \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                         then (case (u, v) of\n                               (u, v) \\<Rightarrow>\n                                 \\<lambda>\\<Delta>.\n                                    if (u, v)\n \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                                    then f((u, v) := f (u, v) + \\<Delta>)\n                                    else if (v, u)\n      \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n   then f((v, u) := f (v, u) - \\<Delta>) else f)\n                               (excess f u) (va, ua)\n                         else (0::'a)) \\<noteq>\n                 (0::'a)}", "apply (safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>excess f u\n                < (if (u, v) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                   then c (u, v) - f (u, v)\n                   else if (v, u) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                        then f (v, u) else (0::'a));\n        (0::'a) < excess f u; l u = l v + 1;\n        (if (a, b) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n         then c (a, b) -\n              (if (u, v) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n               then f((u, v) := f (u, v) + excess f u)\n               else if (v, u) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                    then f((v, u) := f (v, u) - excess f u) else f)\n               (a, b)\n         else if (b, a) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n              then (if (u, v) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                    then f((u, v) := f (u, v) + excess f u)\n                    else if (v, u) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                         then f((v, u) := f (v, u) - excess f u) else f)\n                    (b, a)\n              else (0::'a)) \\<noteq>\n        (0::'a);\n        (a, b) \\<noteq> prod.swap e;\n        (if (a, b) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n         then c (a, b) - f (a, b)\n         else if (b, a) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n              then f (b, a) else (0::'a)) =\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b.\n       \\<lbrakk>excess f u\n                < (if (u, v) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                   then c (u, v) - f (u, v)\n                   else if (v, u) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                        then f (v, u) else (0::'a));\n        (0::'a) < excess f u; l u = l v + 1;\n        (if (a, b) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n         then c (a, b) - f (a, b)\n         else if (b, a) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n              then f (b, a) else (0::'a)) \\<noteq>\n        (0::'a);\n        (if (a, b) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n         then c (a, b) -\n              (if (u, v) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n               then f((u, v) := f (u, v) + excess f u)\n               else if (v, u) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                    then f((v, u) := f (v, u) - excess f u) else f)\n               (a, b)\n         else if (b, a) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n              then (if (u, v) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                    then f((u, v) := f (u, v) + excess f u)\n                    else if (v, u) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                         then f((v, u) := f (v, u) - excess f u) else f)\n                    (b, a)\n              else (0::'a)) =\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>excess f u\n                < (if (u, v) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                   then c (u, v) - f (u, v)\n                   else if (v, u) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                        then f (v, u) else (0::'a));\n        (0::'a) < excess f u; l u = l v + 1;\n        (if (a, b) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n         then c (a, b) - f (a, b)\n         else if (b, a) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n              then f (b, a) else (0::'a)) \\<noteq>\n        (0::'a);\n        (if (a, b) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n         then c (a, b) -\n              (if (u, v) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n               then f((u, v) := f (u, v) + excess f u)\n               else if (v, u) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                    then f((v, u) := f (v, u) - excess f u) else f)\n               (a, b)\n         else if (b, a) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n              then (if (u, v) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                    then f((u, v) := f (u, v) + excess f u)\n                    else if (v, u) \\<in> {(u, v). c (u, v) \\<noteq> (0::'a)}\n                         then f((v, u) := f (v, u) - excess f u) else f)\n                    (b, a)\n              else (0::'a)) =\n        (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp split: if_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>c (v, u) = f (v, u) - excess f u; c (u, v) = (0::'a);\n        excess f u < f (v, u); (0::'a) < excess f u; a = v; b = u\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b.\n       \\<lbrakk>excess f u < c (u, v) - f (u, v); (0::'a) < excess f u;\n        c (v, u) = (0::'a); b = u; a = v;\n        f (u, v) + excess f u = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c (v, u) = f (v, u) - excess f u; c (u, v) = (0::'a);\n     excess f u < f (v, u); (0::'a) < excess f u; a_ = v; b_ = u\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis (full_types) capacity_const diff_0_right \n                diff_strict_left_mono not_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>excess f u < c (u, v) - f (u, v); (0::'a) < excess f u;\n        c (v, u) = (0::'a); b = u; a = v;\n        f (u, v) + excess f u = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>excess f u < c (u, v) - f (u, v); (0::'a) < excess f u;\n     c (v, u) = (0::'a); b_ = u; a_ = v;\n     f (u, v) + excess f u = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis add_le_same_cancel1 f_non_negative linorder_not_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  l'.cf.E \\<subseteq> insert (prod.swap e) cf.E\n  cf.E \\<subseteq> l'.cf.E\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>nonsat_push_precond f l (a, b); e = (a, b)\\<rbrakk>\n       \\<Longrightarrow> adm_edges (augment_edge f (a, b) (excess f a)) l =\n                         adm_edges f l", "hence \"l'.cf.E = insert (prod.swap e) cf.E \\<or> l'.cf.E = cf.E\""], ["proof (prove)\nusing this:\n  l'.cf.E \\<subseteq> insert (prod.swap e) cf.E\n  cf.E \\<subseteq> l'.cf.E\n\ngoal (1 subgoal):\n 1. l'.cf.E = insert (prod.swap e) cf.E \\<or> l'.cf.E = cf.E", "by auto"], ["proof (state)\nthis:\n  l'.cf.E = insert (prod.swap e) cf.E \\<or> l'.cf.E = cf.E\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>nonsat_push_precond f l (a, b); e = (a, b)\\<rbrakk>\n       \\<Longrightarrow> adm_edges (augment_edge f (a, b) (excess f a)) l =\n                         adm_edges f l", "thus \"adm_edges ?f' l = adm_edges f l\""], ["proof (prove)\nusing this:\n  l'.cf.E = insert (prod.swap e) cf.E \\<or> l'.cf.E = cf.E\n\ngoal (1 subgoal):\n 1. adm_edges (augment_edge f (u, v) (excess f u)) l = adm_edges f l", "using AUX"], ["proof (prove)\nusing this:\n  l'.cf.E = insert (prod.swap e) cf.E \\<or> l'.cf.E = cf.E\n  prod.swap e \\<notin> adm_edges f l\n\ngoal (1 subgoal):\n 1. adm_edges (augment_edge f (u, v) (excess f u)) l = adm_edges f l", "unfolding adm_edges_def"], ["proof (prove)\nusing this:\n  l'.cf.E = insert (prod.swap e) cf.E \\<or> l'.cf.E = cf.E\n  prod.swap e \\<notin> {(u, v). (u, v) \\<in> cf.E \\<and> l u = l v + 1}\n\ngoal (1 subgoal):\n 1. {(u, v). (u, v) \\<in> l'.cf.E \\<and> l u = l v + 1} =\n    {(u, v). (u, v) \\<in> cf.E \\<and> l u = l v + 1}", "by auto"], ["proof (state)\nthis:\n  adm_edges (augment_edge f (u, v) (excess f u)) l = adm_edges f l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  adm_edges (push_effect f e) l = adm_edges f l\n\ngoal (1 subgoal):\n 1. nonsat_push_precond f l e \\<Longrightarrow>\n    adm_edges f l - {e} \\<subseteq> adm_edges (push_effect f e) l \\<and>\n    adm_edges (push_effect f e) l \\<subseteq> adm_edges f l", "thus ?thesis"], ["proof (prove)\nusing this:\n  adm_edges (push_effect f e) l = adm_edges f l\n\ngoal (1 subgoal):\n 1. adm_edges f l - {e} \\<subseteq> adm_edges (push_effect f e) l \\<and>\n    adm_edges (push_effect f e) l \\<subseteq> adm_edges f l", "by auto"], ["proof (state)\nthis:\n  adm_edges f l - {e} \\<subseteq> adm_edges (push_effect f e) l \\<and>\n  adm_edges (push_effect f e) l \\<subseteq> adm_edges f l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  adm_edges f l - {e} \\<subseteq> adm_edges (push_effect f e) l \\<and>\n  adm_edges (push_effect f e) l \\<subseteq> adm_edges f l\n\ngoal (2 subgoals):\n 1. adm_edges f l - {e} \\<subseteq> adm_edges (push_effect f e) l\n 2. adm_edges (push_effect f e) l \\<subseteq> adm_edges f l", "thus ?G1 ?G2"], ["proof (prove)\nusing this:\n  adm_edges f l - {e} \\<subseteq> adm_edges (push_effect f e) l \\<and>\n  adm_edges (push_effect f e) l \\<subseteq> adm_edges f l\n\ngoal (1 subgoal):\n 1. adm_edges f l - {e} \\<subseteq> adm_edges (push_effect f e) l &&&\n    adm_edges (push_effect f e) l \\<subseteq> adm_edges f l", "by auto"], ["proof (state)\nthis:\n  adm_edges f l - {e} \\<subseteq> adm_edges (push_effect f e) l\n  adm_edges (push_effect f e) l \\<subseteq> adm_edges f l\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>After a relabel operation, there is at least \n  one admissible edge leaving the relabeled node, \n  but no admissible edges do enter the relabeled node~\\cormen{26.28}.\n  Moreover, the part of the admissible network not adjacent to the relabeled \n  node does not change.\n\\<close>"], ["", "lemma (in Labeling) relabel_adm_edges:\n  assumes PRE: \"relabel_precond f l u\"\n  defines \"l' \\<equiv> relabel_effect f l u\"\n  shows \"adm_edges f l' \\<inter> cf.outgoing u \\<noteq> {}\" (is ?G1)\n    and \"adm_edges f l' \\<inter> cf.incoming u = {}\" (is ?G2)\n    and \"adm_edges f l' - cf.adjacent u = adm_edges f l - cf.adjacent u\" (is ?G3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. adm_edges f l' \\<inter> cf.outgoing u \\<noteq> {} &&&\n    adm_edges f l' \\<inter> cf.incoming u = {} &&&\n    adm_edges f l' - cf.adjacent u = adm_edges f l - cf.adjacent u", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. adm_edges f l' \\<inter> cf.outgoing u \\<noteq> {}\n 2. adm_edges f l' \\<inter> cf.incoming u = {}\n 3. adm_edges f l' - cf.adjacent u = adm_edges f l - cf.adjacent u", "from PRE"], ["proof (chain)\npicking this:\n  relabel_precond f l u", "have  \n        NOT_SINK: \"u\\<noteq>t\"\n    and ACTIVE: \"excess f u > 0\"\n    and NO_ADM: \"\\<And>v. (u,v)\\<in>cf.E \\<Longrightarrow> l u \\<noteq> l v + 1\""], ["proof (prove)\nusing this:\n  relabel_precond f l u\n\ngoal (1 subgoal):\n 1. u \\<noteq> t &&&\n    (0::'a) < excess f u &&&\n    (\\<And>v. (u, v) \\<in> cf.E \\<Longrightarrow> l u \\<noteq> l v + 1)", "unfolding relabel_precond_def"], ["proof (prove)\nusing this:\n  u \\<noteq> t \\<and>\n  (0::'a) < excess f u \\<and>\n  (\\<forall>v. (u, v) \\<in> cf.E \\<longrightarrow> l u \\<noteq> l v + 1)\n\ngoal (1 subgoal):\n 1. u \\<noteq> t &&&\n    (0::'a) < excess f u &&&\n    (\\<And>v. (u, v) \\<in> cf.E \\<Longrightarrow> l u \\<noteq> l v + 1)", "by auto"], ["proof (state)\nthis:\n  u \\<noteq> t\n  (0::'a) < excess f u\n  (u, ?v3) \\<in> cf.E \\<Longrightarrow> l u \\<noteq> l ?v3 + 1\n\ngoal (3 subgoals):\n 1. adm_edges f l' \\<inter> cf.outgoing u \\<noteq> {}\n 2. adm_edges f l' \\<inter> cf.incoming u = {}\n 3. adm_edges f l' - cf.adjacent u = adm_edges f l - cf.adjacent u", "have NE: \"{l v |v. (u, v) \\<in> cf.E} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l v |v. (u, v) \\<in> cf.E} \\<noteq> {}", "using active_has_cf_outgoing[OF ACTIVE] cf.outgoing_def"], ["proof (prove)\nusing this:\n  cf.outgoing u \\<noteq> {}\n  cf.outgoing ?v \\<equiv> {(?v, u) |u. (?v, u) \\<in> cf.E}\n\ngoal (1 subgoal):\n 1. {l v |v. (u, v) \\<in> cf.E} \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  {l v |v. (u, v) \\<in> cf.E} \\<noteq> {}\n\ngoal (3 subgoals):\n 1. adm_edges f l' \\<inter> cf.outgoing u \\<noteq> {}\n 2. adm_edges f l' \\<inter> cf.incoming u = {}\n 3. adm_edges f l' - cf.adjacent u = adm_edges f l - cf.adjacent u", "obtain v \n    where VUE: \"(u,v)\\<in>cf.E\" and [simp]: \"l v = Min {l v |v. (u, v) \\<in> cf.E}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>(u, v) \\<in> cf.E;\n         l v = Min {l v |v. (u, v) \\<in> cf.E}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Min_in[OF finite_min_cf_outgoing[of u] NE]"], ["proof (prove)\nusing this:\n  Min {l v |v. (u, v) \\<in> cf.E} \\<in> {l v |v. (u, v) \\<in> cf.E}\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>(u, v) \\<in> cf.E;\n         l v = Min {l v |v. (u, v) \\<in> cf.E}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<in> cf.E\n  l v = Min {l v |v. (u, v) \\<in> cf.E}\n\ngoal (3 subgoals):\n 1. adm_edges f l' \\<inter> cf.outgoing u \\<noteq> {}\n 2. adm_edges f l' \\<inter> cf.incoming u = {}\n 3. adm_edges f l' - cf.adjacent u = adm_edges f l - cf.adjacent u", "hence \"(u,v) \\<in> adm_edges f l' \\<inter> cf.outgoing u\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> cf.E\n  l v = Min {l v |v. (u, v) \\<in> cf.E}\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> adm_edges f l' \\<inter> cf.outgoing u", "unfolding l'_def relabel_effect_def adm_edges_def cf.outgoing_def"], ["proof (prove)\nusing this:\n  (u, v) \\<in> cf.E\n  l v = Min {l v |v. (u, v) \\<in> cf.E}\n\ngoal (1 subgoal):\n 1. (u, v)\n    \\<in> {(ua, v).\n           (ua, v) \\<in> cf.E \\<and>\n           (l(u := Min {l v |v. (u, v) \\<in> cf.E} + 1)) ua =\n           (l(u := Min {l v |v. (u, v) \\<in> cf.E} + 1)) v + 1} \\<inter>\n          {(u, ua) |ua. (u, ua) \\<in> cf.E}", "by (auto simp: cf_no_self_loop)"], ["proof (state)\nthis:\n  (u, v) \\<in> adm_edges f l' \\<inter> cf.outgoing u\n\ngoal (3 subgoals):\n 1. adm_edges f l' \\<inter> cf.outgoing u \\<noteq> {}\n 2. adm_edges f l' \\<inter> cf.incoming u = {}\n 3. adm_edges f l' - cf.adjacent u = adm_edges f l - cf.adjacent u", "thus ?G1"], ["proof (prove)\nusing this:\n  (u, v) \\<in> adm_edges f l' \\<inter> cf.outgoing u\n\ngoal (1 subgoal):\n 1. adm_edges f l' \\<inter> cf.outgoing u \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  adm_edges f l' \\<inter> cf.outgoing u \\<noteq> {}\n\ngoal (2 subgoals):\n 1. adm_edges f l' \\<inter> cf.incoming u = {}\n 2. adm_edges f l' - cf.adjacent u = adm_edges f l - cf.adjacent u", "{"], ["proof (state)\nthis:\n  adm_edges f l' \\<inter> cf.outgoing u \\<noteq> {}\n\ngoal (2 subgoals):\n 1. adm_edges f l' \\<inter> cf.incoming u = {}\n 2. adm_edges f l' - cf.adjacent u = adm_edges f l - cf.adjacent u", "fix uh"], ["proof (state)\ngoal (2 subgoals):\n 1. adm_edges f l' \\<inter> cf.incoming u = {}\n 2. adm_edges f l' - cf.adjacent u = adm_edges f l - cf.adjacent u", "assume \"(uh,u) \\<in> adm_edges f l'\""], ["proof (state)\nthis:\n  (uh, u) \\<in> adm_edges f l'\n\ngoal (2 subgoals):\n 1. adm_edges f l' \\<inter> cf.incoming u = {}\n 2. adm_edges f l' - cf.adjacent u = adm_edges f l - cf.adjacent u", "hence 1: \"l' uh = l' u + 1\" and UHUE: \"(uh,u) \\<in> cf.E\""], ["proof (prove)\nusing this:\n  (uh, u) \\<in> adm_edges f l'\n\ngoal (1 subgoal):\n 1. l' uh = l' u + 1 &&& (uh, u) \\<in> cf.E", "unfolding adm_edges_def"], ["proof (prove)\nusing this:\n  (uh, u) \\<in> {(u, v). (u, v) \\<in> cf.E \\<and> l' u = l' v + 1}\n\ngoal (1 subgoal):\n 1. l' uh = l' u + 1 &&& (uh, u) \\<in> cf.E", "by auto"], ["proof (state)\nthis:\n  l' uh = l' u + 1\n  (uh, u) \\<in> cf.E\n\ngoal (2 subgoals):\n 1. adm_edges f l' \\<inter> cf.incoming u = {}\n 2. adm_edges f l' - cf.adjacent u = adm_edges f l - cf.adjacent u", "hence \"uh \\<noteq> u\""], ["proof (prove)\nusing this:\n  l' uh = l' u + 1\n  (uh, u) \\<in> cf.E\n\ngoal (1 subgoal):\n 1. uh \\<noteq> u", "using cf_no_self_loop"], ["proof (prove)\nusing this:\n  l' uh = l' u + 1\n  (uh, u) \\<in> cf.E\n  (?u, ?u) \\<notin> cfE_of ?f\n\ngoal (1 subgoal):\n 1. uh \\<noteq> u", "by auto"], ["proof (state)\nthis:\n  uh \\<noteq> u\n\ngoal (2 subgoals):\n 1. adm_edges f l' \\<inter> cf.incoming u = {}\n 2. adm_edges f l' - cf.adjacent u = adm_edges f l - cf.adjacent u", "hence [simp]: \"l' uh = l uh\""], ["proof (prove)\nusing this:\n  uh \\<noteq> u\n\ngoal (1 subgoal):\n 1. l' uh = l uh", "unfolding l'_def relabel_effect_def"], ["proof (prove)\nusing this:\n  uh \\<noteq> u\n\ngoal (1 subgoal):\n 1. (l(u := Min {l v |v. (u, v) \\<in> cf.E} + 1)) uh = l uh", "by simp"], ["proof (state)\nthis:\n  l' uh = l uh\n\ngoal (2 subgoals):\n 1. adm_edges f l' \\<inter> cf.incoming u = {}\n 2. adm_edges f l' - cf.adjacent u = adm_edges f l - cf.adjacent u", "from 1 relabel_increase_u[OF PRE, folded l'_def]"], ["proof (chain)\npicking this:\n  l' uh = l' u + 1\n  l u < l' u", "have \"l uh > l u + 1\""], ["proof (prove)\nusing this:\n  l' uh = l' u + 1\n  l u < l' u\n\ngoal (1 subgoal):\n 1. l u + 1 < l uh", "by simp"], ["proof (state)\nthis:\n  l u + 1 < l uh\n\ngoal (2 subgoals):\n 1. adm_edges f l' \\<inter> cf.incoming u = {}\n 2. adm_edges f l' - cf.adjacent u = adm_edges f l - cf.adjacent u", "with valid[OF UHUE]"], ["proof (chain)\npicking this:\n  l uh \\<le> l u + 1\n  l u + 1 < l uh", "have False"], ["proof (prove)\nusing this:\n  l uh \\<le> l u + 1\n  l u + 1 < l uh\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. adm_edges f l' \\<inter> cf.incoming u = {}\n 2. adm_edges f l' - cf.adjacent u = adm_edges f l - cf.adjacent u", "}"], ["proof (state)\nthis:\n  (?uh5, u) \\<in> adm_edges f l' \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. adm_edges f l' \\<inter> cf.incoming u = {}\n 2. adm_edges f l' - cf.adjacent u = adm_edges f l - cf.adjacent u", "thus ?G2"], ["proof (prove)\nusing this:\n  (?uh5, u) \\<in> adm_edges f l' \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. adm_edges f l' \\<inter> cf.incoming u = {}", "by (auto simp: cf.incoming_def)"], ["proof (state)\nthis:\n  adm_edges f l' \\<inter> cf.incoming u = {}\n\ngoal (1 subgoal):\n 1. adm_edges f l' - cf.adjacent u = adm_edges f l - cf.adjacent u", "show ?G3"], ["proof (prove)\ngoal (1 subgoal):\n 1. adm_edges f l' - cf.adjacent u = adm_edges f l - cf.adjacent u", "unfolding adm_edges_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(u, v). (u, v) \\<in> cf.E \\<and> l' u = l' v + 1} - cf.adjacent u =\n    {(u, v). (u, v) \\<in> cf.E \\<and> l u = l v + 1} - cf.adjacent u", "by (auto \n        simp: l'_def relabel_effect_def cf.adjacent_def \n        simp: cf.incoming_def cf.outgoing_def\n        split: if_splits)"], ["proof (state)\nthis:\n  adm_edges f l' - cf.adjacent u = adm_edges f l - cf.adjacent u\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Neighbor Lists\\<close>"], ["", "text \\<open>\n  For each node, the algorithm will cycle through the adjacent edges \n  when discharging. This cycling takes place across the boundaries of\n  discharge operations, i.e.\\ when a node is discharged, discharging will \n  start at the edge where the last discharge operation stopped.\n\n  The crucial invariant for the neighbor lists is that already visited \n  edges are not admissible.\n\n  Formally, we maintain a function \\<open>n :: node \\<Rightarrow> node set\\<close> from \n  each node to the set of target nodes of not yet visited edges.\n\\<close>"], ["", "locale neighbor_invar = Height_Bounded_Labeling +\n  fixes n :: \"node \\<Rightarrow> node set\"  \n  assumes neighbors_adm: \"\\<lbrakk>v \\<in> adjacent_nodes u - n u\\<rbrakk> \\<Longrightarrow> (u,v) \\<notin> adm_edges f l\"\n  assumes neighbors_adj: \"n u \\<subseteq> adjacent_nodes u\"  \n  assumes neighbors_finite[simp, intro!]: \"finite (n u)\"  \nbegin"], ["", "lemma nbr_is_hbl: \"Height_Bounded_Labeling c s t f l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f l", "by unfold_locales"], ["", "lemma push_pres_nbr_invar:\n  assumes PRE: \"push_precond f l e\"\n  shows \"neighbor_invar c s t (push_effect f e) l n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neighbor_invar c s t (push_effect f e) l n", "proof (cases e)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       e = (a, b) \\<Longrightarrow>\n       neighbor_invar c s t (push_effect f e) l n", "case [simp]: (Pair u v)"], ["proof (state)\nthis:\n  e = (u, v)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       e = (a, b) \\<Longrightarrow>\n       neighbor_invar c s t (push_effect f e) l n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. neighbor_invar c s t (push_effect f e) l n", "proof simp"], ["proof (state)\ngoal (1 subgoal):\n 1. neighbor_invar c s t (push_effect f (u, v)) l n", "from PRE"], ["proof (chain)\npicking this:\n  push_precond f l e", "interpret push_effect_locale c s t f l u v"], ["proof (prove)\nusing this:\n  push_precond f l e\n\ngoal (1 subgoal):\n 1. push_effect_locale c s t f l u v", "by unfold_locales simp"], ["proof (state)\ngoal (1 subgoal):\n 1. neighbor_invar c s t f' l n", "from push_pres_height_bound[OF PRE]"], ["proof (chain)\npicking this:\n  Height_Bounded_Labeling c s t f' l", "interpret l': Height_Bounded_Labeling c s t f' l"], ["proof (prove)\nusing this:\n  Height_Bounded_Labeling c s t f' l\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f' l", "."], ["proof (state)\ngoal (1 subgoal):\n 1. neighbor_invar c s t f' l n", "show \"neighbor_invar c s t f' l n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neighbor_invar c s t f' l n", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v u.\n       v \\<in> adjacent_nodes u - n u \\<Longrightarrow>\n       (u, v) \\<notin> adm_edges f' l\n 2. \\<And>u. n u \\<subseteq> adjacent_nodes u\n 3. \\<And>u. finite (n u)", "using push_adm_edges[OF PRE] neighbors_adm neighbors_adj"], ["proof (prove)\nusing this:\n  adm_edges f l - {(u, v)} \\<subseteq> adm_edges f' l\n  adm_edges f' l \\<subseteq> adm_edges f l\n  ?v \\<in> adjacent_nodes ?u - n ?u \\<Longrightarrow>\n  (?u, ?v) \\<notin> adm_edges f l\n  n ?u \\<subseteq> adjacent_nodes ?u\n\ngoal (3 subgoals):\n 1. \\<And>v u.\n       v \\<in> adjacent_nodes u - n u \\<Longrightarrow>\n       (u, v) \\<notin> adm_edges f' l\n 2. \\<And>u. n u \\<subseteq> adjacent_nodes u\n 3. \\<And>u. finite (n u)", "by auto"], ["proof (state)\nthis:\n  neighbor_invar c s t f' l n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  neighbor_invar c s t (push_effect f e) l n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma relabel_pres_nbr_invar:  \n  assumes PRE: \"relabel_precond f l u\"\n  shows \"neighbor_invar c s t f (relabel_effect f l u) (n(u:=adjacent_nodes u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neighbor_invar c s t f (relabel_effect f l u) (n(u := adjacent_nodes u))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. neighbor_invar c s t f (relabel_effect f l u) (n(u := adjacent_nodes u))", "let ?l' = \"relabel_effect f l u\""], ["proof (state)\ngoal (1 subgoal):\n 1. neighbor_invar c s t f (relabel_effect f l u) (n(u := adjacent_nodes u))", "from relabel_pres_height_bound[OF PRE]"], ["proof (chain)\npicking this:\n  Height_Bounded_Labeling c s t f (relabel_effect f l u)", "interpret l': Height_Bounded_Labeling c s t f ?l'"], ["proof (prove)\nusing this:\n  Height_Bounded_Labeling c s t f (relabel_effect f l u)\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f (relabel_effect f l u)", "."], ["proof (state)\ngoal (1 subgoal):\n 1. neighbor_invar c s t f (relabel_effect f l u) (n(u := adjacent_nodes u))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. neighbor_invar c s t f (relabel_effect f l u) (n(u := adjacent_nodes u))", "using neighbors_adj"], ["proof (prove)\nusing this:\n  n ?u \\<subseteq> adjacent_nodes ?u\n\ngoal (1 subgoal):\n 1. neighbor_invar c s t f (relabel_effect f l u) (n(u := adjacent_nodes u))", "proof (unfold_locales; clarsimp split: if_splits)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v ua.\n       \\<lbrakk>\\<And>u. n u \\<subseteq> adjacent_nodes u; ua \\<noteq> u;\n        v \\<in> adjacent_nodes ua; v \\<notin> n ua;\n        (ua, v) \\<in> adm_edges f (relabel_effect f l u)\\<rbrakk>\n       \\<Longrightarrow> False", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v ua.\n       \\<lbrakk>\\<And>u. n u \\<subseteq> adjacent_nodes u; ua \\<noteq> u;\n        v \\<in> adjacent_nodes ua; v \\<notin> n ua;\n        (ua, v) \\<in> adm_edges f (relabel_effect f l u)\\<rbrakk>\n       \\<Longrightarrow> False", "assume A: \"a\\<noteq>u\" \"b\\<in>adjacent_nodes a\" \"b \\<notin> n a\" \"(a,b)\\<in>adm_edges f ?l'\""], ["proof (state)\nthis:\n  a \\<noteq> u\n  b \\<in> adjacent_nodes a\n  b \\<notin> n a\n  (a, b) \\<in> adm_edges f (relabel_effect f l u)\n\ngoal (1 subgoal):\n 1. \\<And>v ua.\n       \\<lbrakk>\\<And>u. n u \\<subseteq> adjacent_nodes u; ua \\<noteq> u;\n        v \\<in> adjacent_nodes ua; v \\<notin> n ua;\n        (ua, v) \\<in> adm_edges f (relabel_effect f l u)\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"(a,b)\\<in>cf.E\""], ["proof (prove)\nusing this:\n  a \\<noteq> u\n  b \\<in> adjacent_nodes a\n  b \\<notin> n a\n  (a, b) \\<in> adm_edges f (relabel_effect f l u)\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> cf.E", "unfolding adm_edges_def"], ["proof (prove)\nusing this:\n  a \\<noteq> u\n  b \\<in> adjacent_nodes a\n  b \\<notin> n a\n  (a, b)\n  \\<in> {(ua, v).\n         (ua, v) \\<in> cf.E \\<and>\n         relabel_effect f l u ua = relabel_effect f l u v + 1}\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> cf.E", "by auto"], ["proof (state)\nthis:\n  (a, b) \\<in> cf.E\n\ngoal (1 subgoal):\n 1. \\<And>v ua.\n       \\<lbrakk>\\<And>u. n u \\<subseteq> adjacent_nodes u; ua \\<noteq> u;\n        v \\<in> adjacent_nodes ua; v \\<notin> n ua;\n        (ua, v) \\<in> adm_edges f (relabel_effect f l u)\\<rbrakk>\n       \\<Longrightarrow> False", "with A relabel_adm_edges(2,3)[OF PRE] neighbors_adm"], ["proof (chain)\npicking this:\n  a \\<noteq> u\n  b \\<in> adjacent_nodes a\n  b \\<notin> n a\n  (a, b) \\<in> adm_edges f (relabel_effect f l u)\n  adm_edges f (relabel_effect f l u) \\<inter> cf.incoming u = {}\n  adm_edges f (relabel_effect f l u) - cf.adjacent u =\n  adm_edges f l - cf.adjacent u\n  ?v \\<in> adjacent_nodes ?u - n ?u \\<Longrightarrow>\n  (?u, ?v) \\<notin> adm_edges f l\n  (a, b) \\<in> cf.E", "show False"], ["proof (prove)\nusing this:\n  a \\<noteq> u\n  b \\<in> adjacent_nodes a\n  b \\<notin> n a\n  (a, b) \\<in> adm_edges f (relabel_effect f l u)\n  adm_edges f (relabel_effect f l u) \\<inter> cf.incoming u = {}\n  adm_edges f (relabel_effect f l u) - cf.adjacent u =\n  adm_edges f l - cf.adjacent u\n  ?v \\<in> adjacent_nodes ?u - n ?u \\<Longrightarrow>\n  (?u, ?v) \\<notin> adm_edges f l\n  (a, b) \\<in> cf.E\n\ngoal (1 subgoal):\n 1. False", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> u; b \\<in> adjacent_nodes a; b \\<notin> n a;\n     (a, b) \\<in> adm_edges f (relabel_effect f l u);\n     adm_edges f (relabel_effect f l u) \\<inter> cf.incoming u = {};\n     adm_edges f (relabel_effect f l u) - cf.adjacent u =\n     adm_edges f l - cf.adjacent u;\n     \\<And>v u.\n        v \\<in> adjacent_nodes u \\<and> v \\<notin> n u \\<Longrightarrow>\n        (u, v) \\<notin> adm_edges f l;\n     (a, b) \\<in> cf.E\\<rbrakk>\n    \\<Longrightarrow> False", "(* TODO: Clean up this mess *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> u; b \\<in> adjacent_nodes a; b \\<notin> n a;\n     (a, b) \\<in> adm_edges f (relabel_effect f l u);\n     adm_edges f (relabel_effect f l u) \\<inter> cf.incoming u = {};\n     adm_edges f (relabel_effect f l u) - cf.adjacent u =\n     adm_edges f l - cf.adjacent u;\n     \\<And>v u.\n        v \\<in> adjacent_nodes u \\<and> v \\<notin> n u \\<Longrightarrow>\n        (u, v) \\<notin> adm_edges f l;\n     (a, b) \\<in> cf.E\\<rbrakk>\n    \\<Longrightarrow> False", "by (smt DiffD2 Diff_triv adm_edges_def cf.incoming_def \n          mem_Collect_eq prod.simps(2) relabel_preserve_other)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  neighbor_invar c s t f (relabel_effect f l u) (n(u := adjacent_nodes u))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma excess_nz_iff_gz: \"\\<lbrakk> u\\<in>V; u\\<noteq>s \\<rbrakk> \\<Longrightarrow> excess f u \\<noteq> 0 \\<longleftrightarrow> excess f u > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> V; u \\<noteq> s\\<rbrakk>\n    \\<Longrightarrow> (excess f u \\<noteq> (0::'a)) = ((0::'a) < excess f u)", "using excess_non_negative'"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V - {s}. (0::'a) \\<le> excess f v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> V; u \\<noteq> s\\<rbrakk>\n    \\<Longrightarrow> (excess f u \\<noteq> (0::'a)) = ((0::'a) < excess f u)", "by force"], ["", "lemma no_neighbors_relabel_precond: \n  assumes \"n u = {}\" \"u\\<noteq>t\" \"u\\<noteq>s\" \"u\\<in>V\" \"excess f u \\<noteq> 0\"\n  shows \"relabel_precond f l u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. relabel_precond f l u", "using assms neighbors_adm cfE_ss_invE"], ["proof (prove)\nusing this:\n  n u = {}\n  u \\<noteq> t\n  u \\<noteq> s\n  u \\<in> V\n  excess f u \\<noteq> (0::'a)\n  ?v \\<in> adjacent_nodes ?u - n ?u \\<Longrightarrow>\n  (?u, ?v) \\<notin> adm_edges f l\n  cf.E \\<subseteq> E \\<union> E\\<inverse>\n\ngoal (1 subgoal):\n 1. relabel_precond f l u", "unfolding relabel_precond_def adm_edges_def"], ["proof (prove)\nusing this:\n  n u = {}\n  u \\<noteq> t\n  u \\<noteq> s\n  u \\<in> V\n  excess f u \\<noteq> (0::'a)\n  ?v \\<in> adjacent_nodes ?u - n ?u \\<Longrightarrow>\n  (?u, ?v) \\<notin> {(u, v). (u, v) \\<in> cf.E \\<and> l u = l v + 1}\n  cf.E \\<subseteq> E \\<union> E\\<inverse>\n\ngoal (1 subgoal):\n 1. u \\<noteq> t \\<and>\n    (0::'a) < excess f u \\<and>\n    (\\<forall>v. (u, v) \\<in> cf.E \\<longrightarrow> l u \\<noteq> l v + 1)", "by (auto simp: adjacent_nodes_def excess_nz_iff_gz)"], ["", "lemma remove_neighbor_pres_nbr_invar: \"(u,v)\\<notin>adm_edges f l \n  \\<Longrightarrow> neighbor_invar c s t f l (n (u := n u - {v}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<notin> adm_edges f l \\<Longrightarrow>\n    neighbor_invar c s t f l (n(u := n u - {v}))", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>va ua.\n       \\<lbrakk>(u, v) \\<notin> adm_edges f l;\n        va \\<in> adjacent_nodes ua - (n(u := n u - {v})) ua\\<rbrakk>\n       \\<Longrightarrow> (ua, va) \\<notin> adm_edges f l\n 2. \\<And>ua.\n       (u, v) \\<notin> adm_edges f l \\<Longrightarrow>\n       (n(u := n u - {v})) ua \\<subseteq> adjacent_nodes ua\n 3. \\<And>ua.\n       (u, v) \\<notin> adm_edges f l \\<Longrightarrow>\n       finite ((n(u := n u - {v})) ua)", "using neighbors_adm neighbors_adj"], ["proof (prove)\nusing this:\n  ?v \\<in> adjacent_nodes ?u - n ?u \\<Longrightarrow>\n  (?u, ?v) \\<notin> adm_edges f l\n  n ?u \\<subseteq> adjacent_nodes ?u\n\ngoal (3 subgoals):\n 1. \\<And>va ua.\n       \\<lbrakk>(u, v) \\<notin> adm_edges f l;\n        va \\<in> adjacent_nodes ua - (n(u := n u - {v})) ua\\<rbrakk>\n       \\<Longrightarrow> (ua, va) \\<notin> adm_edges f l\n 2. \\<And>ua.\n       (u, v) \\<notin> adm_edges f l \\<Longrightarrow>\n       (n(u := n u - {v})) ua \\<subseteq> adjacent_nodes ua\n 3. \\<And>ua.\n       (u, v) \\<notin> adm_edges f l \\<Longrightarrow>\n       finite ((n(u := n u - {v})) ua)", "by (auto split: if_splits)"], ["", "end"], ["", "subsection \\<open>Discharge Operation\\<close>"], ["", "context Network \nbegin"], ["", "text \\<open>The discharge operation performs push and relabel operations on a \n  node until it becomes inactive.\n  The lemmas in this section are based on the ideas described in\n the proof of \\cormen{26.29}.\n\\<close>"], ["", "definition \"discharge f l n u \\<equiv> do {  \n  assert (u \\<in> V - {s,t});\n  while\\<^sub>T (\\<lambda>(f,l,n). excess f u \\<noteq> 0) (\\<lambda>(f,l,n). do {\n    v \\<leftarrow> select v. v\\<in>n u;\n    case v of\n      None \\<Rightarrow> do {\n        l \\<leftarrow> relabel f l u;\n        return (f,l,n(u := adjacent_nodes u))\n      }\n    | Some v \\<Rightarrow> do {\n        assert (v\\<in>V \\<and> (u,v)\\<in>E\\<union>E\\<inverse>);\n        if ((u,v) \\<in> cfE_of f \\<and> l u = l v + 1) then do {\n          f \\<leftarrow> push f l (u,v);\n          return (f,l,n)\n        } else do {\n          assert ( (u,v) \\<notin> adm_edges f l );\n          return (f,l,n( u := n u - {v} ))\n        }\n      }\n  }) (f,l,n)\n}\""], ["", "end \\<comment> \\<open>Network\\<close>"], ["", "text \\<open>Invariant for the discharge loop\\<close>"], ["", "locale discharge_invar = \n        neighbor_invar c s t f l n \n  + lo: neighbor_invar c s t fo lo no\n  for c s t and u :: node and fo lo no f l n +\n  assumes lu_incr: \"lo u \\<le> l u\"\n  assumes u_node: \"u\\<in>V-{s,t}\"  \n  assumes no_relabel_adm_edges: \"lo u = l u \\<Longrightarrow> adm_edges f l \\<subseteq> adm_edges fo lo\"\n  assumes no_relabel_excess: \n    \"\\<lbrakk>lo u = l u; u\\<noteq>v; excess fo v \\<noteq> excess f v\\<rbrakk> \\<Longrightarrow> (u,v)\\<in>adm_edges fo lo\"\n  assumes adm_edges_leaving_u: \"(u',v)\\<in>adm_edges f l - adm_edges fo lo \\<Longrightarrow> u'=u\"\n  assumes relabel_u_no_incoming_adm: \"lo u \\<noteq> l u \\<Longrightarrow> (v,u)\\<notin>adm_edges f l\"\n  assumes algo_rel: \"((f,l),(fo,lo)) \\<in> pr_algo_rel\\<^sup>*\"  \nbegin"], ["", "lemma u_node_simp1[simp]: \"u\\<noteq>s\" \"u\\<noteq>t\" \"s\\<noteq>u\" \"t\\<noteq>u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<noteq> s &&& u \\<noteq> t) &&& s \\<noteq> u &&& t \\<noteq> u", "using u_node"], ["proof (prove)\nusing this:\n  u \\<in> V - {s, t}\n\ngoal (1 subgoal):\n 1. (u \\<noteq> s &&& u \\<noteq> t) &&& s \\<noteq> u &&& t \\<noteq> u", "by auto"], ["", "lemma u_node_simp2[simp, intro!]: \"u\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> V", "using u_node"], ["proof (prove)\nusing this:\n  u \\<in> V - {s, t}\n\ngoal (1 subgoal):\n 1. u \\<in> V", "by auto"], ["", "lemma dis_is_lbl: \"Labeling c s t f l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Labeling c s t f l", "by unfold_locales"], ["", "lemma dis_is_hbl: \"Height_Bounded_Labeling c s t f l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f l", "by unfold_locales"], ["", "lemma dis_is_nbr: \"neighbor_invar c s t f l n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neighbor_invar c s t f l n", "by unfold_locales"], ["", "lemma new_adm_imp_relabel: \n  \"(u',v)\\<in>adm_edges f l - adm_edges fo lo \\<Longrightarrow> lo u \\<noteq> l u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u', v) \\<in> adm_edges f l - adm_edges fo lo \\<Longrightarrow>\n    lo u \\<noteq> l u", "using no_relabel_adm_edges adm_edges_leaving_u"], ["proof (prove)\nusing this:\n  lo u = l u \\<Longrightarrow> adm_edges f l \\<subseteq> adm_edges fo lo\n  (?u', ?v) \\<in> adm_edges f l - adm_edges fo lo \\<Longrightarrow> ?u' = u\n\ngoal (1 subgoal):\n 1. (u', v) \\<in> adm_edges f l - adm_edges fo lo \\<Longrightarrow>\n    lo u \\<noteq> l u", "by auto"], ["", "lemma push_pres_dis_invar:\n  assumes PRE: \"push_precond f l (u,v)\"\n  shows \"discharge_invar c s t u fo lo no (push_effect f (u,v)) l n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. discharge_invar c s t u fo lo no (push_effect f (u, v)) l n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. discharge_invar c s t u fo lo no (push_effect f (u, v)) l n", "from PRE"], ["proof (chain)\npicking this:\n  push_precond f l (u, v)", "interpret push_effect_locale"], ["proof (prove)\nusing this:\n  push_precond f l (u, v)\n\ngoal (1 subgoal):\n 1. push_effect_locale c s t f l u v", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. discharge_invar c s t u fo lo no f' l n", "from push_pres_nbr_invar[OF PRE]"], ["proof (chain)\npicking this:\n  neighbor_invar c s t f' l n", "interpret neighbor_invar c s t f' l n"], ["proof (prove)\nusing this:\n  neighbor_invar c s t f' l n\n\ngoal (1 subgoal):\n 1. neighbor_invar c s t f' l n", "."], ["proof (state)\ngoal (1 subgoal):\n 1. discharge_invar c s t u fo lo no f' l n", "show \"discharge_invar c s t u fo lo no f' l n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. discharge_invar c s t u fo lo no f' l n", "apply unfold_locales"], ["proof (prove)\ngoal (7 subgoals):\n 1. lo u \\<le> l u\n 2. u \\<in> V - {s, t}\n 3. lo u = l u \\<Longrightarrow> adm_edges f' l \\<subseteq> adm_edges fo lo\n 4. \\<And>v.\n       \\<lbrakk>lo u = l u; u \\<noteq> v;\n        excess fo v \\<noteq> excess f' v\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> adm_edges fo lo\n 5. \\<And>u' v.\n       (u', v) \\<in> adm_edges f' l - adm_edges fo lo \\<Longrightarrow>\n       u' = u\n 6. \\<And>v.\n       lo u \\<noteq> l u \\<Longrightarrow> (v, u) \\<notin> adm_edges f' l\n 7. ((f', l), fo, lo) \\<in> pr_algo_rel\\<^sup>*", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo u \\<le> l u", "using lu_incr"], ["proof (prove)\nusing this:\n  lo u \\<le> l u\n\ngoal (1 subgoal):\n 1. lo u \\<le> l u", "by auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. u \\<in> V - {s, t}\n 2. lo u = l u \\<Longrightarrow> adm_edges f' l \\<subseteq> adm_edges fo lo\n 3. \\<And>v.\n       \\<lbrakk>lo u = l u; u \\<noteq> v;\n        excess fo v \\<noteq> excess f' v\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> adm_edges fo lo\n 4. \\<And>u' v.\n       (u', v) \\<in> adm_edges f' l - adm_edges fo lo \\<Longrightarrow>\n       u' = u\n 5. \\<And>v.\n       lo u \\<noteq> l u \\<Longrightarrow> (v, u) \\<notin> adm_edges f' l\n 6. ((f', l), fo, lo) \\<in> pr_algo_rel\\<^sup>*", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> V - {s, t}", "by auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. lo u = l u \\<Longrightarrow> adm_edges f' l \\<subseteq> adm_edges fo lo\n 2. \\<And>v.\n       \\<lbrakk>lo u = l u; u \\<noteq> v;\n        excess fo v \\<noteq> excess f' v\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> adm_edges fo lo\n 3. \\<And>u' v.\n       (u', v) \\<in> adm_edges f' l - adm_edges fo lo \\<Longrightarrow>\n       u' = u\n 4. \\<And>v.\n       lo u \\<noteq> l u \\<Longrightarrow> (v, u) \\<notin> adm_edges f' l\n 5. ((f', l), fo, lo) \\<in> pr_algo_rel\\<^sup>*", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo u = l u \\<Longrightarrow> adm_edges f' l \\<subseteq> adm_edges fo lo", "using no_relabel_adm_edges push_adm_edges(2)[OF PRE]"], ["proof (prove)\nusing this:\n  lo u = l u \\<Longrightarrow> adm_edges f l \\<subseteq> adm_edges fo lo\n  adm_edges f' l \\<subseteq> adm_edges f l\n\ngoal (1 subgoal):\n 1. lo u = l u \\<Longrightarrow> adm_edges f' l \\<subseteq> adm_edges fo lo", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>lo u = l u; u \\<noteq> v;\n        excess fo v \\<noteq> excess f' v\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> adm_edges fo lo\n 2. \\<And>u' v.\n       (u', v) \\<in> adm_edges f' l - adm_edges fo lo \\<Longrightarrow>\n       u' = u\n 3. \\<And>v.\n       lo u \\<noteq> l u \\<Longrightarrow> (v, u) \\<notin> adm_edges f' l\n 4. ((f', l), fo, lo) \\<in> pr_algo_rel\\<^sup>*", "subgoal for v'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u = l u; u \\<noteq> v';\n     excess fo v' \\<noteq> excess f' v'\\<rbrakk>\n    \\<Longrightarrow> (u, v') \\<in> adm_edges fo lo", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u = l u; u \\<noteq> v';\n     excess fo v' \\<noteq> excess f' v'\\<rbrakk>\n    \\<Longrightarrow> (u, v') \\<in> adm_edges fo lo", "assume LOU: \"lo u = l u\""], ["proof (state)\nthis:\n  lo u = l u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u = l u; u \\<noteq> v';\n     excess fo v' \\<noteq> excess f' v'\\<rbrakk>\n    \\<Longrightarrow> (u, v') \\<in> adm_edges fo lo", "assume EXNE: \"excess fo v' \\<noteq> excess f' v'\""], ["proof (state)\nthis:\n  excess fo v' \\<noteq> excess f' v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u = l u; u \\<noteq> v';\n     excess fo v' \\<noteq> excess f' v'\\<rbrakk>\n    \\<Longrightarrow> (u, v') \\<in> adm_edges fo lo", "assume UNV': \"u\\<noteq>v'\""], ["proof (state)\nthis:\n  u \\<noteq> v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u = l u; u \\<noteq> v';\n     excess fo v' \\<noteq> excess f' v'\\<rbrakk>\n    \\<Longrightarrow> (u, v') \\<in> adm_edges fo lo", "{"], ["proof (state)\nthis:\n  u \\<noteq> v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u = l u; u \\<noteq> v';\n     excess fo v' \\<noteq> excess f' v'\\<rbrakk>\n    \\<Longrightarrow> (u, v') \\<in> adm_edges fo lo", "assume \"excess fo v' \\<noteq> excess f v'\""], ["proof (state)\nthis:\n  excess fo v' \\<noteq> excess f v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u = l u; u \\<noteq> v';\n     excess fo v' \\<noteq> excess f' v'\\<rbrakk>\n    \\<Longrightarrow> (u, v') \\<in> adm_edges fo lo", "from no_relabel_excess[OF LOU UNV' this]"], ["proof (chain)\npicking this:\n  (u, v') \\<in> adm_edges fo lo", "have ?thesis"], ["proof (prove)\nusing this:\n  (u, v') \\<in> adm_edges fo lo\n\ngoal (1 subgoal):\n 1. (u, v') \\<in> adm_edges fo lo", "."], ["proof (state)\nthis:\n  (u, v') \\<in> adm_edges fo lo\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u = l u; u \\<noteq> v';\n     excess fo v' \\<noteq> excess f' v'\\<rbrakk>\n    \\<Longrightarrow> (u, v') \\<in> adm_edges fo lo", "}"], ["proof (state)\nthis:\n  excess fo v' \\<noteq> excess f v' \\<Longrightarrow>\n  (u, v') \\<in> adm_edges fo lo\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u = l u; u \\<noteq> v';\n     excess fo v' \\<noteq> excess f' v'\\<rbrakk>\n    \\<Longrightarrow> (u, v') \\<in> adm_edges fo lo", "moreover"], ["proof (state)\nthis:\n  excess fo v' \\<noteq> excess f v' \\<Longrightarrow>\n  (u, v') \\<in> adm_edges fo lo\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u = l u; u \\<noteq> v';\n     excess fo v' \\<noteq> excess f' v'\\<rbrakk>\n    \\<Longrightarrow> (u, v') \\<in> adm_edges fo lo", "{"], ["proof (state)\nthis:\n  excess fo v' \\<noteq> excess f v' \\<Longrightarrow>\n  (u, v') \\<in> adm_edges fo lo\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u = l u; u \\<noteq> v';\n     excess fo v' \\<noteq> excess f' v'\\<rbrakk>\n    \\<Longrightarrow> (u, v') \\<in> adm_edges fo lo", "assume \"excess fo v' = excess f v'\""], ["proof (state)\nthis:\n  excess fo v' = excess f v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u = l u; u \\<noteq> v';\n     excess fo v' \\<noteq> excess f' v'\\<rbrakk>\n    \\<Longrightarrow> (u, v') \\<in> adm_edges fo lo", "with EXNE"], ["proof (chain)\npicking this:\n  excess fo v' \\<noteq> excess f' v'\n  excess fo v' = excess f v'", "have \"excess f v' \\<noteq> excess f' v'\""], ["proof (prove)\nusing this:\n  excess fo v' \\<noteq> excess f' v'\n  excess fo v' = excess f v'\n\ngoal (1 subgoal):\n 1. excess f v' \\<noteq> excess f' v'", "by simp"], ["proof (state)\nthis:\n  excess f v' \\<noteq> excess f' v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u = l u; u \\<noteq> v';\n     excess fo v' \\<noteq> excess f' v'\\<rbrakk>\n    \\<Longrightarrow> (u, v') \\<in> adm_edges fo lo", "hence \"v'=v\""], ["proof (prove)\nusing this:\n  excess f v' \\<noteq> excess f' v'\n\ngoal (1 subgoal):\n 1. v' = v", "using UNV'"], ["proof (prove)\nusing this:\n  excess f v' \\<noteq> excess f' v'\n  u \\<noteq> v'\n\ngoal (1 subgoal):\n 1. v' = v", "by (auto simp: excess'_if split: if_splits)"], ["proof (state)\nthis:\n  v' = v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u = l u; u \\<noteq> v';\n     excess fo v' \\<noteq> excess f' v'\\<rbrakk>\n    \\<Longrightarrow> (u, v') \\<in> adm_edges fo lo", "hence ?thesis"], ["proof (prove)\nusing this:\n  v' = v\n\ngoal (1 subgoal):\n 1. (u, v') \\<in> adm_edges fo lo", "using no_relabel_adm_edges[OF LOU] uv_adm"], ["proof (prove)\nusing this:\n  v' = v\n  adm_edges f l \\<subseteq> adm_edges fo lo\n  (u, v) \\<in> adm_edges f l\n\ngoal (1 subgoal):\n 1. (u, v') \\<in> adm_edges fo lo", "by auto"], ["proof (state)\nthis:\n  (u, v') \\<in> adm_edges fo lo\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u = l u; u \\<noteq> v';\n     excess fo v' \\<noteq> excess f' v'\\<rbrakk>\n    \\<Longrightarrow> (u, v') \\<in> adm_edges fo lo", "}"], ["proof (state)\nthis:\n  excess fo v' = excess f v' \\<Longrightarrow> (u, v') \\<in> adm_edges fo lo\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u = l u; u \\<noteq> v';\n     excess fo v' \\<noteq> excess f' v'\\<rbrakk>\n    \\<Longrightarrow> (u, v') \\<in> adm_edges fo lo", "ultimately"], ["proof (chain)\npicking this:\n  excess fo v' \\<noteq> excess f v' \\<Longrightarrow>\n  (u, v') \\<in> adm_edges fo lo\n  excess fo v' = excess f v' \\<Longrightarrow> (u, v') \\<in> adm_edges fo lo", "show ?thesis"], ["proof (prove)\nusing this:\n  excess fo v' \\<noteq> excess f v' \\<Longrightarrow>\n  (u, v') \\<in> adm_edges fo lo\n  excess fo v' = excess f v' \\<Longrightarrow> (u, v') \\<in> adm_edges fo lo\n\ngoal (1 subgoal):\n 1. (u, v') \\<in> adm_edges fo lo", "by blast"], ["proof (state)\nthis:\n  (u, v') \\<in> adm_edges fo lo\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>u' v.\n       (u', v) \\<in> adm_edges f' l - adm_edges fo lo \\<Longrightarrow>\n       u' = u\n 2. \\<And>v.\n       lo u \\<noteq> l u \\<Longrightarrow> (v, u) \\<notin> adm_edges f' l\n 3. ((f', l), fo, lo) \\<in> pr_algo_rel\\<^sup>*", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u'_, va_) \\<in> adm_edges f' l - adm_edges fo lo \\<Longrightarrow>\n    u'_ = u", "by (meson Diff_iff push_adm_edges(2)[OF PRE] adm_edges_leaving_u subsetCE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       lo u \\<noteq> l u \\<Longrightarrow> (v, u) \\<notin> adm_edges f' l\n 2. ((f', l), fo, lo) \\<in> pr_algo_rel\\<^sup>*", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo u \\<noteq> l u \\<Longrightarrow> (va_, u) \\<notin> adm_edges f' l", "using push_adm_edges(2)[OF PRE] relabel_u_no_incoming_adm"], ["proof (prove)\nusing this:\n  adm_edges f' l \\<subseteq> adm_edges f l\n  lo u \\<noteq> l u \\<Longrightarrow> (?v, u) \\<notin> adm_edges f l\n\ngoal (1 subgoal):\n 1. lo u \\<noteq> l u \\<Longrightarrow> (va_, u) \\<notin> adm_edges f' l", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((f', l), fo, lo) \\<in> pr_algo_rel\\<^sup>*", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((f', l), fo, lo) \\<in> pr_algo_rel\\<^sup>*", "using converse_rtrancl_into_rtrancl[\n              OF pr_algo_rel.push[OF dis_is_hbl PRE] algo_rel]"], ["proof (prove)\nusing this:\n  ((f', l), fo, lo) \\<in> pr_algo_rel\\<^sup>*\n\ngoal (1 subgoal):\n 1. ((f', l), fo, lo) \\<in> pr_algo_rel\\<^sup>*", "."], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  discharge_invar c s t u fo lo no f' l n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma relabel_pres_dis_invar:\n  assumes PRE: \"relabel_precond f l u\"\n  shows \"discharge_invar c s t u fo lo no f \n            (relabel_effect f l u) (n(u := adjacent_nodes u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. discharge_invar c s t u fo lo no f (relabel_effect f l u)\n     (n(u := adjacent_nodes u))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. discharge_invar c s t u fo lo no f (relabel_effect f l u)\n     (n(u := adjacent_nodes u))", "let ?l' = \"relabel_effect f l u\""], ["proof (state)\ngoal (1 subgoal):\n 1. discharge_invar c s t u fo lo no f (relabel_effect f l u)\n     (n(u := adjacent_nodes u))", "let ?n' = \"n(u := adjacent_nodes u)\""], ["proof (state)\ngoal (1 subgoal):\n 1. discharge_invar c s t u fo lo no f (relabel_effect f l u)\n     (n(u := adjacent_nodes u))", "from relabel_pres_nbr_invar[OF PRE]"], ["proof (chain)\npicking this:\n  neighbor_invar c s t f (relabel_effect f l u) (n(u := adjacent_nodes u))", "interpret l': neighbor_invar c s t f ?l' ?n'"], ["proof (prove)\nusing this:\n  neighbor_invar c s t f (relabel_effect f l u) (n(u := adjacent_nodes u))\n\ngoal (1 subgoal):\n 1. neighbor_invar c s t f (relabel_effect f l u) (n(u := adjacent_nodes u))", "."], ["proof (state)\ngoal (1 subgoal):\n 1. discharge_invar c s t u fo lo no f (relabel_effect f l u)\n     (n(u := adjacent_nodes u))", "note lu_incr"], ["proof (state)\nthis:\n  lo u \\<le> l u\n\ngoal (1 subgoal):\n 1. discharge_invar c s t u fo lo no f (relabel_effect f l u)\n     (n(u := adjacent_nodes u))", "also"], ["proof (state)\nthis:\n  lo u \\<le> l u\n\ngoal (1 subgoal):\n 1. discharge_invar c s t u fo lo no f (relabel_effect f l u)\n     (n(u := adjacent_nodes u))", "note relabel_increase_u[OF PRE]"], ["proof (state)\nthis:\n  l u < relabel_effect f l u u\n\ngoal (1 subgoal):\n 1. discharge_invar c s t u fo lo no f (relabel_effect f l u)\n     (n(u := adjacent_nodes u))", "finally"], ["proof (chain)\npicking this:\n  lo u < relabel_effect f l u u", "have INCR: \"lo u < ?l' u\""], ["proof (prove)\nusing this:\n  lo u < relabel_effect f l u u\n\ngoal (1 subgoal):\n 1. lo u < relabel_effect f l u u", "."], ["proof (state)\nthis:\n  lo u < relabel_effect f l u u\n\ngoal (1 subgoal):\n 1. discharge_invar c s t u fo lo no f (relabel_effect f l u)\n     (n(u := adjacent_nodes u))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. discharge_invar c s t u fo lo no f (relabel_effect f l u)\n     (n(u := adjacent_nodes u))", "apply unfold_locales"], ["proof (prove)\ngoal (7 subgoals):\n 1. lo u \\<le> relabel_effect f l u u\n 2. u \\<in> V - {s, t}\n 3. lo u = relabel_effect f l u u \\<Longrightarrow>\n    adm_edges f (relabel_effect f l u) \\<subseteq> adm_edges fo lo\n 4. \\<And>v.\n       \\<lbrakk>lo u = relabel_effect f l u u; u \\<noteq> v;\n        excess fo v \\<noteq> excess f v\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> adm_edges fo lo\n 5. \\<And>u' v.\n       (u', v)\n       \\<in> adm_edges f (relabel_effect f l u) -\n             adm_edges fo lo \\<Longrightarrow>\n       u' = u\n 6. \\<And>v.\n       lo u \\<noteq> relabel_effect f l u u \\<Longrightarrow>\n       (v, u) \\<notin> adm_edges f (relabel_effect f l u)\n 7. ((f, relabel_effect f l u), fo, lo) \\<in> pr_algo_rel\\<^sup>*", "using INCR"], ["proof (prove)\nusing this:\n  lo u < relabel_effect f l u u\n\ngoal (7 subgoals):\n 1. lo u \\<le> relabel_effect f l u u\n 2. u \\<in> V - {s, t}\n 3. lo u = relabel_effect f l u u \\<Longrightarrow>\n    adm_edges f (relabel_effect f l u) \\<subseteq> adm_edges fo lo\n 4. \\<And>v.\n       \\<lbrakk>lo u = relabel_effect f l u u; u \\<noteq> v;\n        excess fo v \\<noteq> excess f v\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> adm_edges fo lo\n 5. \\<And>u' v.\n       (u', v)\n       \\<in> adm_edges f (relabel_effect f l u) -\n             adm_edges fo lo \\<Longrightarrow>\n       u' = u\n 6. \\<And>v.\n       lo u \\<noteq> relabel_effect f l u u \\<Longrightarrow>\n       (v, u) \\<notin> adm_edges f (relabel_effect f l u)\n 7. ((f, relabel_effect f l u), fo, lo) \\<in> pr_algo_rel\\<^sup>*", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>u' v.\n       \\<lbrakk>(u', v) \\<in> adm_edges f (relabel_effect f l u) \\<and>\n                (u', v) \\<notin> adm_edges fo lo;\n        lo u < relabel_effect f l u u\\<rbrakk>\n       \\<Longrightarrow> u' = u\n 2. \\<And>v.\n       lo u < relabel_effect f l u u \\<Longrightarrow>\n       (v, u) \\<notin> adm_edges f (relabel_effect f l u)\n 3. lo u < relabel_effect f l u u \\<Longrightarrow>\n    ((f, relabel_effect f l u), fo, lo) \\<in> pr_algo_rel\\<^sup>*", "subgoal for u' v"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u', v) \\<in> adm_edges f (relabel_effect f l u) \\<and>\n             (u', v) \\<notin> adm_edges fo lo;\n     lo u < relabel_effect f l u u\\<rbrakk>\n    \\<Longrightarrow> u' = u", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u < relabel_effect f l u u;\n     (u', v) \\<in> adm_edges f (relabel_effect f l u);\n     (u', v) \\<notin> adm_edges fo lo\\<rbrakk>\n    \\<Longrightarrow> u' = u", "assume IN': \"(u', v) \\<in> adm_edges f ?l'\" \n         and NOT_INO: \"(u', v) \\<notin> adm_edges fo lo\""], ["proof (state)\nthis:\n  (u', v) \\<in> adm_edges f (relabel_effect f l u)\n  (u', v) \\<notin> adm_edges fo lo\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u < relabel_effect f l u u;\n     (u', v) \\<in> adm_edges f (relabel_effect f l u);\n     (u', v) \\<notin> adm_edges fo lo\\<rbrakk>\n    \\<Longrightarrow> u' = u", "{"], ["proof (state)\nthis:\n  (u', v) \\<in> adm_edges f (relabel_effect f l u)\n  (u', v) \\<notin> adm_edges fo lo\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u < relabel_effect f l u u;\n     (u', v) \\<in> adm_edges f (relabel_effect f l u);\n     (u', v) \\<notin> adm_edges fo lo\\<rbrakk>\n    \\<Longrightarrow> u' = u", "assume IN: \"(u', v) \\<in> adm_edges f l\""], ["proof (state)\nthis:\n  (u', v) \\<in> adm_edges f l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u < relabel_effect f l u u;\n     (u', v) \\<in> adm_edges f (relabel_effect f l u);\n     (u', v) \\<notin> adm_edges fo lo\\<rbrakk>\n    \\<Longrightarrow> u' = u", "with adm_edges_leaving_u NOT_INO"], ["proof (chain)\npicking this:\n  (?u', ?v) \\<in> adm_edges f l - adm_edges fo lo \\<Longrightarrow> ?u' = u\n  (u', v) \\<notin> adm_edges fo lo\n  (u', v) \\<in> adm_edges f l", "have \"u'=u\""], ["proof (prove)\nusing this:\n  (?u', ?v) \\<in> adm_edges f l - adm_edges fo lo \\<Longrightarrow> ?u' = u\n  (u', v) \\<notin> adm_edges fo lo\n  (u', v) \\<in> adm_edges f l\n\ngoal (1 subgoal):\n 1. u' = u", "by auto"], ["proof (state)\nthis:\n  u' = u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u < relabel_effect f l u u;\n     (u', v) \\<in> adm_edges f (relabel_effect f l u);\n     (u', v) \\<notin> adm_edges fo lo\\<rbrakk>\n    \\<Longrightarrow> u' = u", "}"], ["proof (state)\nthis:\n  (u', v) \\<in> adm_edges f l \\<Longrightarrow> u' = u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u < relabel_effect f l u u;\n     (u', v) \\<in> adm_edges f (relabel_effect f l u);\n     (u', v) \\<notin> adm_edges fo lo\\<rbrakk>\n    \\<Longrightarrow> u' = u", "moreover"], ["proof (state)\nthis:\n  (u', v) \\<in> adm_edges f l \\<Longrightarrow> u' = u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u < relabel_effect f l u u;\n     (u', v) \\<in> adm_edges f (relabel_effect f l u);\n     (u', v) \\<notin> adm_edges fo lo\\<rbrakk>\n    \\<Longrightarrow> u' = u", "{"], ["proof (state)\nthis:\n  (u', v) \\<in> adm_edges f l \\<Longrightarrow> u' = u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u < relabel_effect f l u u;\n     (u', v) \\<in> adm_edges f (relabel_effect f l u);\n     (u', v) \\<notin> adm_edges fo lo\\<rbrakk>\n    \\<Longrightarrow> u' = u", "assume NOT_IN: \"(u', v) \\<notin> adm_edges f l\""], ["proof (state)\nthis:\n  (u', v) \\<notin> adm_edges f l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u < relabel_effect f l u u;\n     (u', v) \\<in> adm_edges f (relabel_effect f l u);\n     (u', v) \\<notin> adm_edges fo lo\\<rbrakk>\n    \\<Longrightarrow> u' = u", "with IN' relabel_adm_edges[OF PRE]"], ["proof (chain)\npicking this:\n  (u', v) \\<in> adm_edges f (relabel_effect f l u)\n  adm_edges f (relabel_effect f l u) \\<inter> cf.outgoing u \\<noteq> {}\n  adm_edges f (relabel_effect f l u) \\<inter> cf.incoming u = {}\n  adm_edges f (relabel_effect f l u) - cf.adjacent u =\n  adm_edges f l - cf.adjacent u\n  (u', v) \\<notin> adm_edges f l", "have \"u'=u\""], ["proof (prove)\nusing this:\n  (u', v) \\<in> adm_edges f (relabel_effect f l u)\n  adm_edges f (relabel_effect f l u) \\<inter> cf.outgoing u \\<noteq> {}\n  adm_edges f (relabel_effect f l u) \\<inter> cf.incoming u = {}\n  adm_edges f (relabel_effect f l u) - cf.adjacent u =\n  adm_edges f l - cf.adjacent u\n  (u', v) \\<notin> adm_edges f l\n\ngoal (1 subgoal):\n 1. u' = u", "unfolding cf.incoming_def cf.outgoing_def cf.adjacent_def"], ["proof (prove)\nusing this:\n  (u', v) \\<in> adm_edges f (relabel_effect f l u)\n  adm_edges f (relabel_effect f l u) \\<inter>\n  {(u, ua) |ua. (u, ua) \\<in> cf.E} \\<noteq>\n  {}\n  adm_edges f (relabel_effect f l u) \\<inter>\n  {(ua, u) |ua. (ua, u) \\<in> cf.E} =\n  {}\n  adm_edges f (relabel_effect f l u) -\n  ({(ua, u) |ua. (ua, u) \\<in> cf.E} \\<union>\n   {(u, ua) |ua. (u, ua) \\<in> cf.E}) =\n  adm_edges f l -\n  ({(ua, u) |ua. (ua, u) \\<in> cf.E} \\<union>\n   {(u, ua) |ua. (u, ua) \\<in> cf.E})\n  (u', v) \\<notin> adm_edges f l\n\ngoal (1 subgoal):\n 1. u' = u", "by auto"], ["proof (state)\nthis:\n  u' = u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u < relabel_effect f l u u;\n     (u', v) \\<in> adm_edges f (relabel_effect f l u);\n     (u', v) \\<notin> adm_edges fo lo\\<rbrakk>\n    \\<Longrightarrow> u' = u", "}"], ["proof (state)\nthis:\n  (u', v) \\<notin> adm_edges f l \\<Longrightarrow> u' = u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lo u < relabel_effect f l u u;\n     (u', v) \\<in> adm_edges f (relabel_effect f l u);\n     (u', v) \\<notin> adm_edges fo lo\\<rbrakk>\n    \\<Longrightarrow> u' = u", "ultimately"], ["proof (chain)\npicking this:\n  (u', v) \\<in> adm_edges f l \\<Longrightarrow> u' = u\n  (u', v) \\<notin> adm_edges f l \\<Longrightarrow> u' = u", "show ?thesis"], ["proof (prove)\nusing this:\n  (u', v) \\<in> adm_edges f l \\<Longrightarrow> u' = u\n  (u', v) \\<notin> adm_edges f l \\<Longrightarrow> u' = u\n\ngoal (1 subgoal):\n 1. u' = u", "by blast"], ["proof (state)\nthis:\n  u' = u\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       lo u < relabel_effect f l u u \\<Longrightarrow>\n       (v, u) \\<notin> adm_edges f (relabel_effect f l u)\n 2. lo u < relabel_effect f l u u \\<Longrightarrow>\n    ((f, relabel_effect f l u), fo, lo) \\<in> pr_algo_rel\\<^sup>*", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo u < relabel_effect f l u u \\<Longrightarrow>\n    (v_, u) \\<notin> adm_edges f (relabel_effect f l u)", "using relabel_adm_edges(2)[OF PRE]"], ["proof (prove)\nusing this:\n  adm_edges f (relabel_effect f l u) \\<inter> cf.incoming u = {}\n\ngoal (1 subgoal):\n 1. lo u < relabel_effect f l u u \\<Longrightarrow>\n    (v_, u) \\<notin> adm_edges f (relabel_effect f l u)", "unfolding adm_edges_def cf.incoming_def"], ["proof (prove)\nusing this:\n  {(ua, v).\n   (ua, v) \\<in> cf.E \\<and>\n   relabel_effect f l u ua = relabel_effect f l u v + 1} \\<inter>\n  {(ua, u) |ua. (ua, u) \\<in> cf.E} =\n  {}\n\ngoal (1 subgoal):\n 1. lo u < relabel_effect f l u u \\<Longrightarrow>\n    (v_, u)\n    \\<notin> {(ua, v).\n              (ua, v) \\<in> cf.E \\<and>\n              relabel_effect f l u ua = relabel_effect f l u v + 1}", "by fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo u < relabel_effect f l u u \\<Longrightarrow>\n    ((f, relabel_effect f l u), fo, lo) \\<in> pr_algo_rel\\<^sup>*", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lo u < relabel_effect f l u u \\<Longrightarrow>\n    ((f, relabel_effect f l u), fo, lo) \\<in> pr_algo_rel\\<^sup>*", "using converse_rtrancl_into_rtrancl[\n              OF pr_algo_rel.relabel[OF dis_is_hbl PRE] algo_rel]"], ["proof (prove)\nusing this:\n  ((f, relabel_effect f l u), fo, lo) \\<in> pr_algo_rel\\<^sup>*\n\ngoal (1 subgoal):\n 1. lo u < relabel_effect f l u u \\<Longrightarrow>\n    ((f, relabel_effect f l u), fo, lo) \\<in> pr_algo_rel\\<^sup>*", "."], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  discharge_invar c s t u fo lo no f (relabel_effect f l u)\n   (n(u := adjacent_nodes u))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma push_precondI_nz: \n  \"\\<lbrakk>excess f u \\<noteq> 0; (u,v)\\<in>cfE_of f; l u = l v + 1\\<rbrakk> \\<Longrightarrow> push_precond f l (u,v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>excess f u \\<noteq> (0::'a); (u, v) \\<in> cf.E;\n     l u = l v + 1\\<rbrakk>\n    \\<Longrightarrow> push_precond f l (u, v)", "unfolding push_precond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>excess f u \\<noteq> (0::'a); (u, v) \\<in> cf.E;\n     l u = l v + 1\\<rbrakk>\n    \\<Longrightarrow> case (u, v) of\n                      (u, v) \\<Rightarrow>\n                        (0::'a) < excess f u \\<and>\n                        (u, v) \\<in> cf.E \\<and> l u = l v + 1", "by (auto simp: excess_nz_iff_gz)"], ["", "lemma remove_neighbor_pres_dis_invar: \n  assumes PRE: \"(u,v)\\<notin>adm_edges f l\"  \n  defines \"n' \\<equiv> n (u := n u - {v})\"  \n  shows \"discharge_invar c s t u fo lo no f l n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. discharge_invar c s t u fo lo no f l n'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. discharge_invar c s t u fo lo no f l n'", "from remove_neighbor_pres_nbr_invar[OF PRE]"], ["proof (chain)\npicking this:\n  neighbor_invar c s t f l (n(u := n u - {v}))", "interpret neighbor_invar c s t f l n'"], ["proof (prove)\nusing this:\n  neighbor_invar c s t f l (n(u := n u - {v}))\n\ngoal (1 subgoal):\n 1. neighbor_invar c s t f l n'", "unfolding n'_def"], ["proof (prove)\nusing this:\n  neighbor_invar c s t f l (n(u := n u - {v}))\n\ngoal (1 subgoal):\n 1. neighbor_invar c s t f l (n(u := n u - {v}))", "."], ["proof (state)\ngoal (1 subgoal):\n 1. discharge_invar c s t u fo lo no f l n'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. discharge_invar c s t u fo lo no f l n'", "apply unfold_locales"], ["proof (prove)\ngoal (7 subgoals):\n 1. lo u \\<le> l u\n 2. u \\<in> V - {s, t}\n 3. lo u = l u \\<Longrightarrow> adm_edges f l \\<subseteq> adm_edges fo lo\n 4. \\<And>v.\n       \\<lbrakk>lo u = l u; u \\<noteq> v;\n        excess fo v \\<noteq> excess f v\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> adm_edges fo lo\n 5. \\<And>u' v.\n       (u', v) \\<in> adm_edges f l - adm_edges fo lo \\<Longrightarrow>\n       u' = u\n 6. \\<And>v.\n       lo u \\<noteq> l u \\<Longrightarrow> (v, u) \\<notin> adm_edges f l\n 7. ((f, l), fo, lo) \\<in> pr_algo_rel\\<^sup>*", "using lu_incr no_relabel_adm_edges no_relabel_excess adm_edges_leaving_u \n      relabel_u_no_incoming_adm algo_rel"], ["proof (prove)\nusing this:\n  lo u \\<le> l u\n  lo u = l u \\<Longrightarrow> adm_edges f l \\<subseteq> adm_edges fo lo\n  \\<lbrakk>lo u = l u; u \\<noteq> ?v;\n   excess fo ?v \\<noteq> excess f ?v\\<rbrakk>\n  \\<Longrightarrow> (u, ?v) \\<in> adm_edges fo lo\n  (?u', ?v) \\<in> adm_edges f l - adm_edges fo lo \\<Longrightarrow> ?u' = u\n  lo u \\<noteq> l u \\<Longrightarrow> (?v, u) \\<notin> adm_edges f l\n  ((f, l), fo, lo) \\<in> pr_algo_rel\\<^sup>*\n\ngoal (7 subgoals):\n 1. lo u \\<le> l u\n 2. u \\<in> V - {s, t}\n 3. lo u = l u \\<Longrightarrow> adm_edges f l \\<subseteq> adm_edges fo lo\n 4. \\<And>v.\n       \\<lbrakk>lo u = l u; u \\<noteq> v;\n        excess fo v \\<noteq> excess f v\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> adm_edges fo lo\n 5. \\<And>u' v.\n       (u', v) \\<in> adm_edges f l - adm_edges fo lo \\<Longrightarrow>\n       u' = u\n 6. \\<And>v.\n       lo u \\<noteq> l u \\<Longrightarrow> (v, u) \\<notin> adm_edges f l\n 7. ((f, l), fo, lo) \\<in> pr_algo_rel\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  discharge_invar c s t u fo lo no f l n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma neighbors_in_V: \"v\\<in>n u \\<Longrightarrow> v\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> n u \\<Longrightarrow> v \\<in> V", "using neighbors_adj[of u] E_ss_VxV"], ["proof (prove)\nusing this:\n  n u \\<subseteq> adjacent_nodes u\n  E \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. v \\<in> n u \\<Longrightarrow> v \\<in> V", "unfolding adjacent_nodes_def"], ["proof (prove)\nusing this:\n  n u \\<subseteq> E `` {u} \\<union> E\\<inverse> `` {u}\n  E \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. v \\<in> n u \\<Longrightarrow> v \\<in> V", "by auto"], ["", "lemma neighbors_in_E: \"v\\<in>n u \\<Longrightarrow> (u,v)\\<in>E\\<union>E\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> n u \\<Longrightarrow> (u, v) \\<in> E \\<union> E\\<inverse>", "using neighbors_adj[of u] E_ss_VxV"], ["proof (prove)\nusing this:\n  n u \\<subseteq> adjacent_nodes u\n  E \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. v \\<in> n u \\<Longrightarrow> (u, v) \\<in> E \\<union> E\\<inverse>", "unfolding adjacent_nodes_def"], ["proof (prove)\nusing this:\n  n u \\<subseteq> E `` {u} \\<union> E\\<inverse> `` {u}\n  E \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. v \\<in> n u \\<Longrightarrow> (u, v) \\<in> E \\<union> E\\<inverse>", "by auto"], ["", "lemma relabeled_node_has_outgoing: \n  assumes \"relabel_precond f l u\"\n  shows \"\\<exists>v. (u,v)\\<in>cfE_of f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v. (u, v) \\<in> cf.E", "using assms"], ["proof (prove)\nusing this:\n  relabel_precond f l u\n\ngoal (1 subgoal):\n 1. \\<exists>v. (u, v) \\<in> cf.E", "unfolding relabel_precond_def"], ["proof (prove)\nusing this:\n  u \\<noteq> t \\<and>\n  (0::'a) < excess f u \\<and>\n  (\\<forall>v. (u, v) \\<in> cf.E \\<longrightarrow> l u \\<noteq> l v + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>v. (u, v) \\<in> cf.E", "using active_has_cf_outgoing"], ["proof (prove)\nusing this:\n  u \\<noteq> t \\<and>\n  (0::'a) < excess f u \\<and>\n  (\\<forall>v. (u, v) \\<in> cf.E \\<longrightarrow> l u \\<noteq> l v + 1)\n  (0::'a) < excess f ?u \\<Longrightarrow> cf.outgoing ?u \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>v. (u, v) \\<in> cf.E", "unfolding cf.outgoing_def"], ["proof (prove)\nusing this:\n  u \\<noteq> t \\<and>\n  (0::'a) < excess f u \\<and>\n  (\\<forall>v. (u, v) \\<in> cf.E \\<longrightarrow> l u \\<noteq> l v + 1)\n  (0::'a) < excess f ?u \\<Longrightarrow>\n  {(?u, u) |u. (?u, u) \\<in> cf.E} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>v. (u, v) \\<in> cf.E", "by auto"], ["", "end"], ["", "lemma (in neighbor_invar) discharge_invar_init: \n  assumes \"u\\<in>V-{s,t}\"\n  shows \"discharge_invar c s t u f l n f l n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. discharge_invar c s t u f l n f l n", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> V - {s, t}\n\ngoal (1 subgoal):\n 1. discharge_invar c s t u f l n f l n", "by unfold_locales auto"], ["", "context Network begin"], ["", "text \\<open>\n  The discharge operation preserves the invariant, and discharges the node.\n\\<close>"], ["", "lemma discharge_correct[THEN order_trans, refine_vcg]:\n  assumes DINV: \"neighbor_invar c s t f l n\"\n  assumes NOT_ST: \"u\\<noteq>t\" \"u\\<noteq>s\" and UIV: \"u\\<in>V\"\n  shows \"discharge f l n u \n    \\<le> SPEC (\\<lambda>(f',l',n'). discharge_invar c s t u f l n f' l' n' \n                       \\<and> excess f' u = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. discharge f l n u\n    \\<le> SPEC\n           (\\<lambda>(f', l', n').\n               discharge_invar c s t u f l n f' l' n' \\<and>\n               excess f' u = (0::'capacity))", "unfolding discharge_def push_def relabel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. assert (u \\<in> V - {s, t}) \\<bind>\n    (\\<lambda>_.\n        while\\<^sub>T\n         (\\<lambda>(f, l, n). excess f u \\<noteq> (0::'capacity))\n         (\\<lambda>(f, l, n).\n             (select v. v \\<in> n u) \\<bind>\n             (\\<lambda>v.\n                 case v of\n                 None \\<Rightarrow>\n                   assert (Height_Bounded_Labeling c s t f l) \\<bind>\n                   (\\<lambda>_.\n                       assert (relabel_precond f l u) \\<bind>\n                       (\\<lambda>_.\n                           assert (u \\<in> V - {s, t}) \\<bind>\n                           (\\<lambda>_.\n                               return (relabel_effect f l u)))) \\<bind>\n                   (\\<lambda>l. return (f, l, n(u := adjacent_nodes u)))\n                 | Some v \\<Rightarrow>\n                     assert\n                      (v \\<in> V \\<and>\n                       (u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n                     (\\<lambda>_.\n                         if (u, v) \\<in> cfE_of f \\<and> l u = l v + 1\n                         then (case (u, v) of\n                               (u, v) \\<Rightarrow>\n                                 assert (push_precond f l (u, v)) \\<bind>\n                                 (\\<lambda>_.\n                                     assert (Labeling c s t f l) \\<bind>\n                                     (\\<lambda>_.\n   return (push_effect f (u, v))))) \\<bind>\n                              (\\<lambda>f. return (f, l, n))\n                         else assert ((u, v) \\<notin> adm_edges f l) \\<bind>\n                              (\\<lambda>_.\n                                  return (f, l, n(u := n u - {v}))))))\n         (f, l, n))\n    \\<le> SPEC\n           (\\<lambda>(f', l', n').\n               discharge_invar c s t u f l n f' l' n' \\<and>\n               excess f' u = (0::'capacity))", "apply (refine_vcg WHILET_rule[where \n            I=\"\\<lambda>(f',l',n'). discharge_invar c s t u f l n f' l' n'\"\n        and R=\"inv_image (pr_algo_rel <*lex*> finite_psubset) \n                (\\<lambda>(f',l',n'). ((f',l'),n' u))\"]\n      )"], ["proof (prove)\ngoal (31 subgoals):\n 1. u \\<in> V - {s, t}\n 2. u \\<in> V - {s, t} \\<Longrightarrow>\n    wf (inv_image (pr_algo_rel <*lex*> finite_psubset)\n         (\\<lambda>(f', l', n'). ((f', l'), n' u)))\n 3. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>u \\<in> V - {s, t}; x2 = (x1a, x2a);\n        (f, l, n) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> discharge_invar c s t u f l n x1 x1a x2a\n 4. \\<And>sa a b aa ba x.\n       \\<lbrakk>u \\<in> V - {s, t};\n        case sa of\n        (f', l', n') \\<Rightarrow> discharge_invar c s t u f l n f' l' n';\n        case sa of\n        (f, l, n) \\<Rightarrow> excess f u \\<noteq> (0::'capacity);\n        sa = (a, b); b = (aa, ba); x \\<in> ba u; Some x = None\\<rbrakk>\n       \\<Longrightarrow> Height_Bounded_Labeling c s t a aa\n 5. \\<And>sa a b aa ba x.\n       \\<lbrakk>u \\<in> V - {s, t};\n        case sa of\n        (f', l', n') \\<Rightarrow> discharge_invar c s t u f l n f' l' n';\n        case sa of\n        (f, l, n) \\<Rightarrow> excess f u \\<noteq> (0::'capacity);\n        sa = (a, b); b = (aa, ba); x \\<in> ba u; Some x = None;\n        Height_Bounded_Labeling c s t a aa\\<rbrakk>\n       \\<Longrightarrow> relabel_precond a aa u\n 6. \\<And>sa a b aa ba x x1 x2 x1a x2a.\n       \\<lbrakk>u \\<in> V - {s, t};\n        case sa of\n        (f', l', n') \\<Rightarrow> discharge_invar c s t u f l n f' l' n';\n        case sa of\n        (f, l, n) \\<Rightarrow> excess f u \\<noteq> (0::'capacity);\n        sa = (a, b); b = (aa, ba); x \\<in> ba u; Some x = None;\n        Height_Bounded_Labeling c s t a aa; relabel_precond a aa u;\n        u \\<in> V - {s, t}; x2 = (x1a, x2a);\n        (a, relabel_effect a aa u, ba(u := adjacent_nodes u)) =\n        (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> discharge_invar c s t u f l n x1 x1a x2a\n 7. \\<And>sa a b aa ba x.\n       \\<lbrakk>u \\<in> V - {s, t};\n        case sa of\n        (f', l', n') \\<Rightarrow> discharge_invar c s t u f l n f' l' n';\n        case sa of\n        (f, l, n) \\<Rightarrow> excess f u \\<noteq> (0::'capacity);\n        sa = (a, b); b = (aa, ba); x \\<in> ba u; Some x = None;\n        Height_Bounded_Labeling c s t a aa; relabel_precond a aa u;\n        u \\<in> V - {s, t}\\<rbrakk>\n       \\<Longrightarrow> ((a, relabel_effect a aa u, ba\n                           (u := adjacent_nodes u)),\n                          sa)\n                         \\<in> inv_image\n                                (pr_algo_rel <*lex*> finite_psubset)\n                                (\\<lambda>(f', l', n'). ((f', l'), n' u))\n 8. \\<And>sa a b aa ba x xa.\n       \\<lbrakk>u \\<in> V - {s, t};\n        case sa of\n        (f', l', n') \\<Rightarrow> discharge_invar c s t u f l n f' l' n';\n        case sa of\n        (f, l, n) \\<Rightarrow> excess f u \\<noteq> (0::'capacity);\n        sa = (a, b); b = (aa, ba); x \\<in> ba u; Some x = Some xa\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> V\n 9. \\<And>sa a b aa ba x xa.\n       \\<lbrakk>u \\<in> V - {s, t};\n        case sa of\n        (f', l', n') \\<Rightarrow> discharge_invar c s t u f l n f' l' n';\n        case sa of\n        (f, l, n) \\<Rightarrow> excess f u \\<noteq> (0::'capacity);\n        sa = (a, b); b = (aa, ba); x \\<in> ba u; Some x = Some xa\\<rbrakk>\n       \\<Longrightarrow> (u, xa) \\<in> E \\<union> E\\<inverse>\n 10. \\<And>sa a b aa ba x xa ab bb.\n        \\<lbrakk>u \\<in> V - {s, t};\n         case sa of\n         (f', l', n') \\<Rightarrow> discharge_invar c s t u f l n f' l' n';\n         case sa of\n         (f, l, n) \\<Rightarrow> excess f u \\<noteq> (0::'capacity);\n         sa = (a, b); b = (aa, ba); x \\<in> ba u; Some x = Some xa;\n         xa \\<in> V \\<and> (u, xa) \\<in> E \\<union> E\\<inverse>;\n         (u, xa) \\<in> cfE_of a \\<and> aa u = aa xa + 1;\n         (u, xa) = (ab, bb)\\<rbrakk>\n        \\<Longrightarrow> push_precond a aa (ab, bb)\nA total of 31 subgoals...", "apply (vc_solve \n      solve: wf_lex_prod DINV \n      solve: neighbor_invar.discharge_invar_init[OF DINV]\n      solve: neighbor_invar.no_neighbors_relabel_precond \n      solve: discharge_invar.relabel_pres_dis_invar \n      solve: discharge_invar.push_pres_dis_invar\n      solve: discharge_invar.push_precondI_nz pr_algo_rel.relabel \n      solve: pr_algo_rel.push[OF discharge_invar.dis_is_hbl]\n      solve: discharge_invar.remove_neighbor_pres_dis_invar\n      solve: discharge_invar.neighbors_in_V\n      solve: discharge_invar.relabeled_node_has_outgoing\n      solve: discharge_invar.dis_is_hbl \n      intro: discharge_invar.dis_is_nbr \n      solve: discharge_invar.dis_is_lbl\n      simp: NOT_ST \n      simp: neighbor_invar.neighbors_finite[OF discharge_invar.dis_is_nbr] UIV)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ab aaa baa xa.\n       \\<lbrakk>discharge_invar c s t u f l n ab aaa baa;\n        excess ab u \\<noteq> (0::'capacity); xa \\<in> baa u;\n        (xa, u) \\<notin> E\\<rbrakk>\n       \\<Longrightarrow> (u, xa) \\<in> E\n 2. \\<And>ab aaa baa xa.\n       \\<lbrakk>discharge_invar c s t u f l n ab aaa baa;\n        excess ab u \\<noteq> (0::'capacity); xa \\<in> baa u;\n        (u, xa) \\<in> cfE_of ab \\<longrightarrow>\n        aaa u \\<noteq> Suc (aaa xa);\n        xa \\<in> V; (u, xa) \\<in> E \\<or> (xa, u) \\<in> E;\n        (u, xa) \\<in> adm_edges ab aaa\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>ab aaa baa xa.\n       \\<lbrakk>discharge_invar c s t u f l n ab aaa baa;\n        excess ab u \\<noteq> (0::'capacity); xa \\<in> baa u;\n        (u, xa) \\<in> cfE_of ab \\<longrightarrow>\n        aaa u \\<noteq> Suc (aaa xa);\n        (u, xa) \\<notin> adm_edges ab aaa; xa \\<in> V;\n        (u, xa) \\<in> E \\<or> (xa, u) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> baa u - {xa} \\<subset> baa u", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>discharge_invar c s t u f l n ab_ aaa_ baa_;\n     excess ab_ u \\<noteq> (0::'capacity); xa_ \\<in> baa_ u;\n     (xa_, u) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> (u, xa_) \\<in> E", "by (auto dest: discharge_invar.neighbors_in_E)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ab aaa baa xa.\n       \\<lbrakk>discharge_invar c s t u f l n ab aaa baa;\n        excess ab u \\<noteq> (0::'capacity); xa \\<in> baa u;\n        (u, xa) \\<in> cfE_of ab \\<longrightarrow>\n        aaa u \\<noteq> Suc (aaa xa);\n        xa \\<in> V; (u, xa) \\<in> E \\<or> (xa, u) \\<in> E;\n        (u, xa) \\<in> adm_edges ab aaa\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ab aaa baa xa.\n       \\<lbrakk>discharge_invar c s t u f l n ab aaa baa;\n        excess ab u \\<noteq> (0::'capacity); xa \\<in> baa u;\n        (u, xa) \\<in> cfE_of ab \\<longrightarrow>\n        aaa u \\<noteq> Suc (aaa xa);\n        (u, xa) \\<notin> adm_edges ab aaa; xa \\<in> V;\n        (u, xa) \\<in> E \\<or> (xa, u) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> baa u - {xa} \\<subset> baa u", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>discharge_invar c s t u f l n ab_ aaa_ baa_;\n     excess ab_ u \\<noteq> (0::'capacity); xa_ \\<in> baa_ u;\n     (u, xa_) \\<in> cfE_of ab_ \\<longrightarrow>\n     aaa_ u \\<noteq> Suc (aaa_ xa_);\n     xa_ \\<in> V; (u, xa_) \\<in> E \\<or> (xa_, u) \\<in> E;\n     (u, xa_) \\<in> adm_edges ab_ aaa_\\<rbrakk>\n    \\<Longrightarrow> False", "unfolding adm_edges_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>discharge_invar c s t u f l n ab_ aaa_ baa_;\n     excess ab_ u \\<noteq> (0::'capacity); xa_ \\<in> baa_ u;\n     (u, xa_) \\<in> cfE_of ab_ \\<longrightarrow>\n     aaa_ u \\<noteq> Suc (aaa_ xa_);\n     xa_ \\<in> V; (u, xa_) \\<in> E \\<or> (xa_, u) \\<in> E;\n     (u, xa_)\n     \\<in> {(u, v).\n            (u, v) \\<in> cfE_of ab_ \\<and> aaa_ u = aaa_ v + 1}\\<rbrakk>\n    \\<Longrightarrow> False", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab aaa baa xa.\n       \\<lbrakk>discharge_invar c s t u f l n ab aaa baa;\n        excess ab u \\<noteq> (0::'capacity); xa \\<in> baa u;\n        (u, xa) \\<in> cfE_of ab \\<longrightarrow>\n        aaa u \\<noteq> Suc (aaa xa);\n        (u, xa) \\<notin> adm_edges ab aaa; xa \\<in> V;\n        (u, xa) \\<in> E \\<or> (xa, u) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> baa u - {xa} \\<subset> baa u", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>discharge_invar c s t u f l n ab_ aaa_ baa_;\n     excess ab_ u \\<noteq> (0::'capacity); xa_ \\<in> baa_ u;\n     (u, xa_) \\<in> cfE_of ab_ \\<longrightarrow>\n     aaa_ u \\<noteq> Suc (aaa_ xa_);\n     (u, xa_) \\<notin> adm_edges ab_ aaa_; xa_ \\<in> V;\n     (u, xa_) \\<in> E \\<or> (xa_, u) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> baa_ u - {xa_} \\<subset> baa_ u", "by (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end \\<comment> \\<open>Network\\<close>"], ["", "subsection \\<open>Main Algorithm\\<close>"], ["", "text \\<open>We state the main algorithm and prove its \n  termination and correctness\\<close>"], ["", "context Network\nbegin"], ["", "text \\<open>Initially, all edges are unprocessed. \\<close>"], ["", "definition \"rtf_init_n u \\<equiv> if u\\<in>V-{s,t} then adjacent_nodes u else {}\""], ["", "lemma rtf_init_n_finite[simp, intro!]: \"finite (rtf_init_n u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (rtf_init_n u)", "unfolding rtf_init_n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (if u \\<in> V - {s, t} then adjacent_nodes u else {})", "by auto"], ["", "lemma init_no_adm_edges[simp]: \"adm_edges pp_init_f pp_init_l = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm_edges pp_init_f pp_init_l = {}", "unfolding adm_edges_def pp_init_l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(u, v).\n     (u, v) \\<in> cfE_of pp_init_f \\<and>\n     ((\\<lambda>x. 0)(s := card V)) u =\n     ((\\<lambda>x. 0)(s := card V)) v + 1} =\n    {}", "using card_V_ge2"], ["proof (prove)\nusing this:\n  2 \\<le> card V\n\ngoal (1 subgoal):\n 1. {(u, v).\n     (u, v) \\<in> cfE_of pp_init_f \\<and>\n     ((\\<lambda>x. 0)(s := card V)) u =\n     ((\\<lambda>x. 0)(s := card V)) v + 1} =\n    {}", "by auto"], ["", "lemma rtf_init_neighbor_invar: \n  \"neighbor_invar c s t pp_init_f pp_init_l rtf_init_n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neighbor_invar c s t pp_init_f pp_init_l rtf_init_n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. neighbor_invar c s t pp_init_f pp_init_l rtf_init_n", "from pp_init_height_bound"], ["proof (chain)\npicking this:\n  Height_Bounded_Labeling c s t pp_init_f pp_init_l", "interpret Height_Bounded_Labeling c s t pp_init_f pp_init_l"], ["proof (prove)\nusing this:\n  Height_Bounded_Labeling c s t pp_init_f pp_init_l\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t pp_init_f pp_init_l", "."], ["proof (state)\ngoal (1 subgoal):\n 1. neighbor_invar c s t pp_init_f pp_init_l rtf_init_n", "have [simp]: \"rtf_init_n u \\<subseteq> adjacent_nodes u\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. rtf_init_n u \\<subseteq> adjacent_nodes u", "by (auto simp: rtf_init_n_def)"], ["proof (state)\nthis:\n  rtf_init_n ?u3 \\<subseteq> adjacent_nodes ?u3\n\ngoal (1 subgoal):\n 1. neighbor_invar c s t pp_init_f pp_init_l rtf_init_n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. neighbor_invar c s t pp_init_f pp_init_l rtf_init_n", "by unfold_locales auto"], ["proof (state)\nthis:\n  neighbor_invar c s t pp_init_f pp_init_l rtf_init_n\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"relabel_to_front \\<equiv> do {\n  let f = pp_init_f;\n  let l = pp_init_l;\n  let n = rtf_init_n;\n\n  let L_left=[];\n  L_right \\<leftarrow> spec l. distinct l \\<and> set l = V - {s,t};\n\n  (f,l,n,L_left,L_right) \\<leftarrow> while\\<^sub>T \n    (\\<lambda>(f,l,n,L_left,L_right). L_right \\<noteq> []) \n    (\\<lambda>(f,l,n,L_left,L_right). do {\n      let u = hd L_right;\n      assert (u \\<in> V);\n      let old_lu = l u;\n  \n      (f,l,n) \\<leftarrow> discharge f l n u;\n  \n      if (l u \\<noteq> old_lu) then do {\n        \\<comment> \\<open>Move \\<open>u\\<close> to front of \\<open>l\\<close>, and restart scanning \\<open>L\\<close>\\<close>\n        let (L_left,L_right) = ([u],L_left @ tl L_right);\n        return (f,l,n,L_left,L_right)\n      } else do {\n        \\<comment> \\<open>Goto next node in \\<open>l\\<close>\\<close>\n        let (L_left,L_right) = (L_left@[u], tl L_right);\n        return (f,l,n,L_left,L_right)\n      }\n  \n    }) (f,l,n,L_left,L_right);\n\n  assert (neighbor_invar c s t f l n);\n\n  return f\n}\""], ["", "end \\<comment> \\<open>Network\\<close>"], ["", "text \\<open>Invariant for the main algorithm:\n  \\<^enum> Nodes in the queue left of the current node are not active\n  \\<^enum> The queue is a topological sort of the admissible network\n  \\<^enum> All nodes except source and sink are on the queue\n\\<close>"], ["", "locale rtf_invar = neighbor_invar +\n  fixes L_left L_right :: \"node list\"\n  assumes left_no_excess: \"\\<forall>u\\<in>set (L_left). excess f u = 0\"  \n  assumes L_sorted: \"is_top_sorted (adm_edges f l) (L_left @ L_right)\"\n  assumes L_set: \"set L_left \\<union> set L_right = V-{s,t}\"  \nbegin"], ["", "lemma rtf_is_nbr: \"neighbor_invar c s t f l n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. neighbor_invar c s t f l n", "by unfold_locales"], ["", "lemma L_distinct: \"distinct (L_left @ L_right)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (L_left @ L_right)", "using is_top_sorted_distinct[OF L_sorted]"], ["proof (prove)\nusing this:\n  distinct (L_left @ L_right)\n\ngoal (1 subgoal):\n 1. distinct (L_left @ L_right)", "."], ["", "lemma terminated_imp_maxflow: \n    assumes [simp]: \"L_right = []\"   \n    shows \"isMaxFlow f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isMaxFlow f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. isMaxFlow f", "from L_set left_no_excess"], ["proof (chain)\npicking this:\n  set L_left \\<union> set L_right = V - {s, t}\n  \\<forall>u\\<in>set L_left. excess f u = (0::'a)", "have \"\\<forall>u\\<in>V-{s,t}. excess f u = 0\""], ["proof (prove)\nusing this:\n  set L_left \\<union> set L_right = V - {s, t}\n  \\<forall>u\\<in>set L_left. excess f u = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>V - {s, t}. excess f u = (0::'a)", "by auto"], ["proof (state)\nthis:\n  \\<forall>u\\<in>V - {s, t}. excess f u = (0::'a)\n\ngoal (1 subgoal):\n 1. isMaxFlow f", "with no_excess_imp_maxflow"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>V - {s, t}. excess f u = (0::'a) \\<Longrightarrow>\n  isMaxFlow f\n  \\<forall>u\\<in>V - {s, t}. excess f u = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>V - {s, t}. excess f u = (0::'a) \\<Longrightarrow>\n  isMaxFlow f\n  \\<forall>u\\<in>V - {s, t}. excess f u = (0::'a)\n\ngoal (1 subgoal):\n 1. isMaxFlow f", "."], ["proof (state)\nthis:\n  isMaxFlow f\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context Network begin"], ["", "lemma rtf_init_invar: \n  assumes DIS: \"distinct L_left\" and L_set: \"set L_left = V-{s,t}\"\n  shows \"rtf_invar c s t pp_init_f pp_init_l rtf_init_n [] L_left\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rtf_invar c s t pp_init_f pp_init_l rtf_init_n [] L_left", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rtf_invar c s t pp_init_f pp_init_l rtf_init_n [] L_left", "from rtf_init_neighbor_invar"], ["proof (chain)\npicking this:\n  neighbor_invar c s t pp_init_f pp_init_l rtf_init_n", "interpret neighbor_invar c s t pp_init_f pp_init_l rtf_init_n"], ["proof (prove)\nusing this:\n  neighbor_invar c s t pp_init_f pp_init_l rtf_init_n\n\ngoal (1 subgoal):\n 1. neighbor_invar c s t pp_init_f pp_init_l rtf_init_n", "."], ["proof (state)\ngoal (1 subgoal):\n 1. rtf_invar c s t pp_init_f pp_init_l rtf_init_n [] L_left", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rtf_invar c s t pp_init_f pp_init_l rtf_init_n [] L_left", "using DIS L_set"], ["proof (prove)\nusing this:\n  distinct L_left\n  set L_left = V - {s, t}\n\ngoal (1 subgoal):\n 1. rtf_invar c s t pp_init_f pp_init_l rtf_init_n [] L_left", "by unfold_locales auto"], ["proof (state)\nthis:\n  rtf_invar c s t pp_init_f pp_init_l rtf_init_n [] L_left\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem relabel_to_front_correct: \n  \"relabel_to_front \\<le> SPEC isMaxFlow\""], ["proof (prove)\ngoal (1 subgoal):\n 1. relabel_to_front \\<le> SPEC isMaxFlow", "unfolding relabel_to_front_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let f = pp_init_f; l = pp_init_l; n = rtf_init_n; L_left = []\n     in (spec l. distinct l \\<and> set l = V - {s, t}) \\<bind>\n        (\\<lambda>L_right.\n            while\\<^sub>T\n             (\\<lambda>(f, l, n, L_left, L_right). L_right \\<noteq> [])\n             (\\<lambda>(f, l, n, L_left, L_right).\n                 let u = hd L_right\n                 in assert (u \\<in> V) \\<bind>\n                    (\\<lambda>_.\n                        let old_lu = l u\n                        in discharge f l n u \\<bind>\n                           (\\<lambda>(f, l, n).\n                               if l u \\<noteq> old_lu\n                               then let (L_left, L_right) =\n    ([u], L_left @ tl L_right)\n                                    in return (f, l, n, L_left, L_right)\n                               else let (L_left, L_right) =\n    (L_left @ [u], tl L_right)\n                                    in return (f, l, n, L_left, L_right))))\n             (f, l, n, L_left, L_right) \\<bind>\n            (\\<lambda>(f, l, n, L_left, L_right).\n                assert (neighbor_invar c s t f l n) \\<bind>\n                (\\<lambda>_. return f))))\n    \\<le> SPEC isMaxFlow", "apply (rewrite in \"while\\<^sub>T _ \\<hole>\" vcg_intro_frame)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let f = pp_init_f; l = pp_init_l; n = rtf_init_n; L_left = []\n     in (spec l. distinct l \\<and> set l = V - {s, t}) \\<bind>\n        (\\<lambda>L_right.\n            while\\<^sub>T\n             (\\<lambda>(f, l, n, L_left, L_right). L_right \\<noteq> [])\n             (\\<lambda>(f, l, n, L_left, L_right).\n                 VCG_FRAME\n                  (let u = hd L_right\n                   in assert (u \\<in> V) \\<bind>\n                      (\\<lambda>_.\n                          let old_lu = l u\n                          in discharge f l n u \\<bind>\n                             (\\<lambda>(f, l, n).\n                                 if l u \\<noteq> old_lu\n                                 then let (L_left, L_right) =\n      ([u], L_left @ tl L_right)\nin return (f, l, n, L_left, L_right)\n                                 else let (L_left, L_right) =\n      (L_left @ [u], tl L_right)\nin return (f, l, n, L_left, L_right)))))\n             (f, l, n, L_left, L_right) \\<bind>\n            (\\<lambda>(f, l, n, L_left, L_right).\n                assert (neighbor_invar c s t f l n) \\<bind>\n                (\\<lambda>_. return f))))\n    \\<le> SPEC isMaxFlow", "apply (refine_vcg  \n      WHILET_rule[where \n            I=\"\\<lambda>(f,l,n,L_left,L_right). rtf_invar c s t f l n L_left L_right\"\n        and R=\"inv_image \n                (pr_algo_rel\\<^sup>+ <*lex*> less_than) \n                (\\<lambda>(f,l,n,L_left,L_right). ((f,l),length L_right))\"\n        ]\n      )"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       distinct x \\<and> set x = V - {s, t} \\<Longrightarrow>\n       wf (inv_image (pr_algo_rel\\<^sup>+ <*lex*> less_than)\n            (\\<lambda>(f, l, n, L_left, L_right). ((f, l), length L_right)))\n 2. \\<And>x x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>distinct x \\<and> set x = V - {s, t}; x2b = (x1c, x2c);\n        x2a = (x1b, x2b); x2 = (x1a, x2a);\n        (pp_init_f, pp_init_l, rtf_init_n, [], x) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> rtf_invar c s t x1 x1a x1b x1c x2c\n 3. \\<And>x sa a b aa ba ab bb ac bc.\n       \\<lbrakk>distinct x \\<and> set x = V - {s, t};\n        case sa of\n        (f, l, n, L_left, L_right) \\<Rightarrow>\n          rtf_invar c s t f l n L_left L_right;\n        case sa of\n        (f, l, n, L_left, L_right) \\<Rightarrow> L_right \\<noteq> [];\n        sa = (a, b); b = (aa, ba); ba = (ab, bb); bb = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> VCG_FRAME\n                          (let u = hd bc\n                           in assert (u \\<in> V) \\<bind>\n                              (\\<lambda>_.\n                                  let old_lu = aa u\n                                  in discharge a aa ab u \\<bind>\n                                     (\\<lambda>(f, l, n).\n   if l u \\<noteq> old_lu\n   then let (L_left, L_right) = ([u], ac @ tl bc)\n        in return (f, l, n, L_left, L_right)\n   else let (L_left, L_right) = (ac @ [u], tl bc)\n        in return (f, l, n, L_left, L_right))))\n                         \\<le> (spec s'.\n                                   (case s' of\n                                    (f, l, n, L_left, L_right) \\<Rightarrow>\nrtf_invar c s t f l n L_left L_right) \\<and>\n                                   (s', sa)\n                                   \\<in> inv_image\n    (pr_algo_rel\\<^sup>+ <*lex*> less_than)\n    (\\<lambda>(f, l, n, L_left, L_right). ((f, l), length L_right)))\n 4. \\<And>x sa a b aa ba ab bb ac bc.\n       \\<lbrakk>distinct x \\<and> set x = V - {s, t};\n        case sa of\n        (f, l, n, L_left, L_right) \\<Rightarrow>\n          rtf_invar c s t f l n L_left L_right;\n        \\<not> (case sa of\n                (f, l, n, L_left, L_right) \\<Rightarrow>\n                  L_right \\<noteq> []);\n        sa = (a, b); b = (aa, ba); ba = (ab, bb); bb = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> neighbor_invar c s t a aa ab\n 5. \\<And>x sa a b aa ba ab bb ac bc.\n       \\<lbrakk>distinct x \\<and> set x = V - {s, t};\n        case sa of\n        (f, l, n, L_left, L_right) \\<Rightarrow>\n          rtf_invar c s t f l n L_left L_right;\n        \\<not> (case sa of\n                (f, l, n, L_left, L_right) \\<Rightarrow>\n                  L_right \\<noteq> []);\n        sa = (a, b); b = (aa, ba); ba = (ab, bb); bb = (ac, bc);\n        neighbor_invar c s t a aa ab\\<rbrakk>\n       \\<Longrightarrow> isMaxFlow a", "apply (vc_solve simp: rtf_init_invar rtf_invar.rtf_is_nbr)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>distinct x; set x = V - {s, t}\\<rbrakk>\n       \\<Longrightarrow> wf (pr_algo_rel\\<^sup>+ <*lex*> less_than)\n 2. \\<And>x ad aaa aba aca bca.\n       \\<lbrakk>rtf_invar c s t ad aaa aba aca bca; bca \\<noteq> [];\n        distinct x; set x = V - {s, t}\\<rbrakk>\n       \\<Longrightarrow> VCG_FRAME\n                          (let u = hd bca\n                           in assert (u \\<in> V) \\<bind>\n                              (\\<lambda>_.\n                                  let old_lu = aaa u\n                                  in discharge ad aaa aba u \\<bind>\n                                     (\\<lambda>(f, l, n).\n   if l u \\<noteq> old_lu\n   then let (L_left, L_right) = ([u], aca @ tl bca)\n        in return (f, l, n, L_left, L_right)\n   else let (L_left, L_right) = (aca @ [u], tl bca)\n        in return (f, l, n, L_left, L_right))))\n                         \\<le> (spec s'.\n                                   (case s' of\n                                    (f, l, n, xa, xb) \\<Rightarrow>\nrtf_invar c s t f l n xa xb) \\<and>\n                                   (case s' of\n                                    (f, l, n, L_left, L_right) \\<Rightarrow>\n((f, l), length L_right),\n                                    (ad, aaa), length bca)\n                                   \\<in> pr_algo_rel\\<^sup>+ <*lex*>\n   less_than)\n 3. \\<And>x ad aaa aba aca.\n       \\<lbrakk>rtf_invar c s t ad aaa aba aca []; distinct x;\n        set x = V - {s, t}\\<rbrakk>\n       \\<Longrightarrow> isMaxFlow ad", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct x_; set x_ = V - {s, t}\\<rbrakk>\n    \\<Longrightarrow> wf (pr_algo_rel\\<^sup>+ <*lex*> less_than)", "by (blast intro: wf_lex_prod wf_trancl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x ad aaa aba aca bca.\n       \\<lbrakk>rtf_invar c s t ad aaa aba aca bca; bca \\<noteq> [];\n        distinct x; set x = V - {s, t}\\<rbrakk>\n       \\<Longrightarrow> VCG_FRAME\n                          (let u = hd bca\n                           in assert (u \\<in> V) \\<bind>\n                              (\\<lambda>_.\n                                  let old_lu = aaa u\n                                  in discharge ad aaa aba u \\<bind>\n                                     (\\<lambda>(f, l, n).\n   if l u \\<noteq> old_lu\n   then let (L_left, L_right) = ([u], aca @ tl bca)\n        in return (f, l, n, L_left, L_right)\n   else let (L_left, L_right) = (aca @ [u], tl bca)\n        in return (f, l, n, L_left, L_right))))\n                         \\<le> (spec s'.\n                                   (case s' of\n                                    (f, l, n, xa, xb) \\<Rightarrow>\nrtf_invar c s t f l n xa xb) \\<and>\n                                   (case s' of\n                                    (f, l, n, L_left, L_right) \\<Rightarrow>\n((f, l), length L_right),\n                                    (ad, aaa), length bca)\n                                   \\<in> pr_algo_rel\\<^sup>+ <*lex*>\n   less_than)\n 2. \\<And>x ad aaa aba aca.\n       \\<lbrakk>rtf_invar c s t ad aaa aba aca []; distinct x;\n        set x = V - {s, t}\\<rbrakk>\n       \\<Longrightarrow> isMaxFlow ad", "subgoal for _ f l n L_left L_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rtf_invar c s t f l n L_left L_right; L_right \\<noteq> [];\n     distinct x_; set x_ = V - {s, t}\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (let u = hd L_right\n                        in assert (u \\<in> V) \\<bind>\n                           (\\<lambda>_.\n                               let old_lu = l u\n                               in discharge f l n u \\<bind>\n                                  (\\<lambda>(f, l, n).\nif l u \\<noteq> old_lu\nthen let (L_left, L_right) = ([u], L_left @ tl L_right)\n     in return (f, l, n, L_left, L_right)\nelse let (L_left, L_right) = (L_left @ [u], tl L_right)\n     in return (f, l, n, L_left, L_right))))\n                      \\<le> (spec s'.\n                                (case s' of\n                                 (f, l, n, xa, xb) \\<Rightarrow>\n                                   rtf_invar c s t f l n xa xb) \\<and>\n                                (case s' of\n                                 (f, l, n, L_left, L_right) \\<Rightarrow>\n                                   ((f, l), length L_right),\n                                 (f, l), length L_right)\n                                \\<in> pr_algo_rel\\<^sup>+ <*lex*> less_than)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>rtf_invar c s t f l n L_left L_right; L_right \\<noteq> [];\n     distinct x_; set x_ = V - {s, t}\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (let u = hd L_right\n                        in assert (u \\<in> V) \\<bind>\n                           (\\<lambda>_.\n                               let old_lu = l u\n                               in discharge f l n u \\<bind>\n                                  (\\<lambda>(f, l, n).\nif l u \\<noteq> old_lu\nthen let (L_left, L_right) = ([u], L_left @ tl L_right)\n     in return (f, l, n, L_left, L_right)\nelse let (L_left, L_right) = (L_left @ [u], tl L_right)\n     in return (f, l, n, L_left, L_right))))\n                      \\<le> (spec s'.\n                                (case s' of\n                                 (f, l, n, xa, xb) \\<Rightarrow>\n                                   rtf_invar c s t f l n xa xb) \\<and>\n                                (case s' of\n                                 (f, l, n, L_left, L_right) \\<Rightarrow>\n                                   ((f, l), length L_right),\n                                 (f, l), length L_right)\n                                \\<in> pr_algo_rel\\<^sup>+ <*lex*> less_than)", "assume \"rtf_invar c s t f l n L_left L_right\""], ["proof (state)\nthis:\n  rtf_invar c s t f l n L_left L_right\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rtf_invar c s t f l n L_left L_right; L_right \\<noteq> [];\n     distinct x_; set x_ = V - {s, t}\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (let u = hd L_right\n                        in assert (u \\<in> V) \\<bind>\n                           (\\<lambda>_.\n                               let old_lu = l u\n                               in discharge f l n u \\<bind>\n                                  (\\<lambda>(f, l, n).\nif l u \\<noteq> old_lu\nthen let (L_left, L_right) = ([u], L_left @ tl L_right)\n     in return (f, l, n, L_left, L_right)\nelse let (L_left, L_right) = (L_left @ [u], tl L_right)\n     in return (f, l, n, L_left, L_right))))\n                      \\<le> (spec s'.\n                                (case s' of\n                                 (f, l, n, xa, xb) \\<Rightarrow>\n                                   rtf_invar c s t f l n xa xb) \\<and>\n                                (case s' of\n                                 (f, l, n, L_left, L_right) \\<Rightarrow>\n                                   ((f, l), length L_right),\n                                 (f, l), length L_right)\n                                \\<in> pr_algo_rel\\<^sup>+ <*lex*> less_than)", "then"], ["proof (chain)\npicking this:\n  rtf_invar c s t f l n L_left L_right", "interpret rtf_invar c s t f l n L_left L_right"], ["proof (prove)\nusing this:\n  rtf_invar c s t f l n L_left L_right\n\ngoal (1 subgoal):\n 1. rtf_invar c s t f l n L_left L_right", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>rtf_invar c s t f l n L_left L_right; L_right \\<noteq> [];\n     distinct x_; set x_ = V - {s, t}\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (let u = hd L_right\n                        in assert (u \\<in> V) \\<bind>\n                           (\\<lambda>_.\n                               let old_lu = l u\n                               in discharge f l n u \\<bind>\n                                  (\\<lambda>(f, l, n).\nif l u \\<noteq> old_lu\nthen let (L_left, L_right) = ([u], L_left @ tl L_right)\n     in return (f, l, n, L_left, L_right)\nelse let (L_left, L_right) = (L_left @ [u], tl L_right)\n     in return (f, l, n, L_left, L_right))))\n                      \\<le> (spec s'.\n                                (case s' of\n                                 (f, l, n, xa, xb) \\<Rightarrow>\n                                   rtf_invar c s t f l n xa xb) \\<and>\n                                (case s' of\n                                 (f, l, n, L_left, L_right) \\<Rightarrow>\n                                   ((f, l), length L_right),\n                                 (f, l), length L_right)\n                                \\<in> pr_algo_rel\\<^sup>+ <*lex*> less_than)", "assume \"L_right \\<noteq> []\""], ["proof (state)\nthis:\n  L_right \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rtf_invar c s t f l n L_left L_right; L_right \\<noteq> [];\n     distinct x_; set x_ = V - {s, t}\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (let u = hd L_right\n                        in assert (u \\<in> V) \\<bind>\n                           (\\<lambda>_.\n                               let old_lu = l u\n                               in discharge f l n u \\<bind>\n                                  (\\<lambda>(f, l, n).\nif l u \\<noteq> old_lu\nthen let (L_left, L_right) = ([u], L_left @ tl L_right)\n     in return (f, l, n, L_left, L_right)\nelse let (L_left, L_right) = (L_left @ [u], tl L_right)\n     in return (f, l, n, L_left, L_right))))\n                      \\<le> (spec s'.\n                                (case s' of\n                                 (f, l, n, xa, xb) \\<Rightarrow>\n                                   rtf_invar c s t f l n xa xb) \\<and>\n                                (case s' of\n                                 (f, l, n, L_left, L_right) \\<Rightarrow>\n                                   ((f, l), length L_right),\n                                 (f, l), length L_right)\n                                \\<in> pr_algo_rel\\<^sup>+ <*lex*> less_than)", "then"], ["proof (chain)\npicking this:\n  L_right \\<noteq> []", "obtain u L_right' \n      where [simp]: \"L_right = u#L_right'\""], ["proof (prove)\nusing this:\n  L_right \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>u L_right'.\n        L_right = u # L_right' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases L_right) auto"], ["proof (state)\nthis:\n  L_right = u # L_right'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rtf_invar c s t f l n L_left L_right; L_right \\<noteq> [];\n     distinct x_; set x_ = V - {s, t}\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (let u = hd L_right\n                        in assert (u \\<in> V) \\<bind>\n                           (\\<lambda>_.\n                               let old_lu = l u\n                               in discharge f l n u \\<bind>\n                                  (\\<lambda>(f, l, n).\nif l u \\<noteq> old_lu\nthen let (L_left, L_right) = ([u], L_left @ tl L_right)\n     in return (f, l, n, L_left, L_right)\nelse let (L_left, L_right) = (L_left @ [u], tl L_right)\n     in return (f, l, n, L_left, L_right))))\n                      \\<le> (spec s'.\n                                (case s' of\n                                 (f, l, n, xa, xb) \\<Rightarrow>\n                                   rtf_invar c s t f l n xa xb) \\<and>\n                                (case s' of\n                                 (f, l, n, L_left, L_right) \\<Rightarrow>\n                                   ((f, l), length L_right),\n                                 (f, l), length L_right)\n                                \\<in> pr_algo_rel\\<^sup>+ <*lex*> less_than)", "from L_set"], ["proof (chain)\npicking this:\n  set L_left \\<union> set L_right = V - {s, t}", "have [simp]: \"u\\<in>V\" \"u\\<noteq>s\" \"u\\<noteq>t\" \"s\\<noteq>u\" \"t\\<noteq>u\""], ["proof (prove)\nusing this:\n  set L_left \\<union> set L_right = V - {s, t}\n\ngoal (1 subgoal):\n 1. (u \\<in> V &&& u \\<noteq> s) &&&\n    u \\<noteq> t &&& s \\<noteq> u &&& t \\<noteq> u", "by auto"], ["proof (state)\nthis:\n  u \\<in> V\n  u \\<noteq> s\n  u \\<noteq> t\n  s \\<noteq> u\n  t \\<noteq> u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rtf_invar c s t f l n L_left L_right; L_right \\<noteq> [];\n     distinct x_; set x_ = V - {s, t}\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (let u = hd L_right\n                        in assert (u \\<in> V) \\<bind>\n                           (\\<lambda>_.\n                               let old_lu = l u\n                               in discharge f l n u \\<bind>\n                                  (\\<lambda>(f, l, n).\nif l u \\<noteq> old_lu\nthen let (L_left, L_right) = ([u], L_left @ tl L_right)\n     in return (f, l, n, L_left, L_right)\nelse let (L_left, L_right) = (L_left @ [u], tl L_right)\n     in return (f, l, n, L_left, L_right))))\n                      \\<le> (spec s'.\n                                (case s' of\n                                 (f, l, n, xa, xb) \\<Rightarrow>\n                                   rtf_invar c s t f l n xa xb) \\<and>\n                                (case s' of\n                                 (f, l, n, L_left, L_right) \\<Rightarrow>\n                                   ((f, l), length L_right),\n                                 (f, l), length L_right)\n                                \\<in> pr_algo_rel\\<^sup>+ <*lex*> less_than)", "from L_distinct"], ["proof (chain)\npicking this:\n  distinct (L_left @ L_right)", "have [simp]: \"u\\<notin>set L_left\" \"u\\<notin>set L_right'\""], ["proof (prove)\nusing this:\n  distinct (L_left @ L_right)\n\ngoal (1 subgoal):\n 1. u \\<notin> set L_left &&& u \\<notin> set L_right'", "by auto"], ["proof (state)\nthis:\n  u \\<notin> set L_left\n  u \\<notin> set L_right'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>rtf_invar c s t f l n L_left L_right; L_right \\<noteq> [];\n     distinct x_; set x_ = V - {s, t}\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (let u = hd L_right\n                        in assert (u \\<in> V) \\<bind>\n                           (\\<lambda>_.\n                               let old_lu = l u\n                               in discharge f l n u \\<bind>\n                                  (\\<lambda>(f, l, n).\nif l u \\<noteq> old_lu\nthen let (L_left, L_right) = ([u], L_left @ tl L_right)\n     in return (f, l, n, L_left, L_right)\nelse let (L_left, L_right) = (L_left @ [u], tl L_right)\n     in return (f, l, n, L_left, L_right))))\n                      \\<le> (spec s'.\n                                (case s' of\n                                 (f, l, n, xa, xb) \\<Rightarrow>\n                                   rtf_invar c s t f l n xa xb) \\<and>\n                                (case s' of\n                                 (f, l, n, L_left, L_right) \\<Rightarrow>\n                                   ((f, l), length L_right),\n                                 (f, l), length L_right)\n                                \\<in> pr_algo_rel\\<^sup>+ <*lex*> less_than)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. VCG_FRAME\n     (let u = hd L_right\n      in assert (u \\<in> V) \\<bind>\n         (\\<lambda>_.\n             let old_lu = l u\n             in discharge f l n u \\<bind>\n                (\\<lambda>(f, l, n).\n                    if l u \\<noteq> old_lu\n                    then let (L_left, L_right) = ([u], L_left @ tl L_right)\n                         in return (f, l, n, L_left, L_right)\n                    else let (L_left, L_right) = (L_left @ [u], tl L_right)\n                         in return (f, l, n, L_left, L_right))))\n    \\<le> (spec s'.\n              (case s' of\n               (f, l, n, xa, xb) \\<Rightarrow>\n                 rtf_invar c s t f l n xa xb) \\<and>\n              (case s' of\n               (f, l, n, L_left, L_right) \\<Rightarrow>\n                 ((f, l), length L_right),\n               (f, l), length L_right)\n              \\<in> pr_algo_rel\\<^sup>+ <*lex*> less_than)", "apply (rule vcg_rem_frame)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let u = hd L_right\n     in assert (u \\<in> V) \\<bind>\n        (\\<lambda>_.\n            let old_lu = l u\n            in discharge f l n u \\<bind>\n               (\\<lambda>(f, l, n).\n                   if l u \\<noteq> old_lu\n                   then let (L_left, L_right) = ([u], L_left @ tl L_right)\n                        in return (f, l, n, L_left, L_right)\n                   else let (L_left, L_right) = (L_left @ [u], tl L_right)\n                        in return (f, l, n, L_left, L_right))))\n    \\<le> (spec s'.\n              (case s' of\n               (f, l, n, xa, xb) \\<Rightarrow>\n                 rtf_invar c s t f l n xa xb) \\<and>\n              (case s' of\n               (f, l, n, L_left, L_right) \\<Rightarrow>\n                 ((f, l), length L_right),\n               (f, l), length L_right)\n              \\<in> pr_algo_rel\\<^sup>+ <*lex*> less_than)", "apply (rewrite in \"do {(_,_,_) \\<leftarrow> discharge _ _ _ _; \\<hole>}\" vcg_intro_frame)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let u = hd L_right\n     in assert (u \\<in> V) \\<bind>\n        (\\<lambda>_.\n            let old_lu = l u\n            in discharge f l n u \\<bind>\n               (\\<lambda>(f, l, n).\n                   VCG_FRAME\n                    (if l u \\<noteq> old_lu\n                     then let (L_left, L_right) = ([u], L_left @ tl L_right)\n                          in return (f, l, n, L_left, L_right)\n                     else let (L_left, L_right) = (L_left @ [u], tl L_right)\n                          in return (f, l, n, L_left, L_right)))))\n    \\<le> (spec s'.\n              (case s' of\n               (f, l, n, xa, xb) \\<Rightarrow>\n                 rtf_invar c s t f l n xa xb) \\<and>\n              (case s' of\n               (f, l, n, L_left, L_right) \\<Rightarrow>\n                 ((f, l), length L_right),\n               (f, l), length L_right)\n              \\<in> pr_algo_rel\\<^sup>+ <*lex*> less_than)", "apply refine_vcg"], ["proof (prove)\ngoal (5 subgoals):\n 1. hd L_right \\<in> V\n 2. hd L_right \\<in> V \\<Longrightarrow> neighbor_invar c s t f l n\n 3. hd L_right \\<in> V \\<Longrightarrow> hd L_right \\<noteq> t\n 4. hd L_right \\<in> V \\<Longrightarrow> hd L_right \\<noteq> s\n 5. \\<And>x a b aa ba.\n       \\<lbrakk>hd L_right \\<in> V;\n        case x of\n        (f', l', n') \\<Rightarrow>\n          discharge_invar c s t (hd L_right) f l n f' l' n' \\<and>\n          excess f' (hd L_right) = (0::'capacity);\n        x = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> VCG_FRAME\n                          (if aa (hd L_right) \\<noteq> l (hd L_right)\n                           then let (L_left, L_right) =\n([hd L_right], L_left @ tl L_right)\n                                in return (a, aa, ba, L_left, L_right)\n                           else let (L_left, L_right) =\n(L_left @ [hd L_right], tl L_right)\n                                in return (a, aa, ba, L_left, L_right))\n                         \\<le> (spec s'.\n                                   (case s' of\n                                    (f, l, n, xa, xb) \\<Rightarrow>\nrtf_invar c s t f l n xa xb) \\<and>\n                                   (case s' of\n                                    (f, l, n, L_left, L_right) \\<Rightarrow>\n((f, l), length L_right),\n                                    (f, l), length L_right)\n                                   \\<in> pr_algo_rel\\<^sup>+ <*lex*>\n   less_than)", "apply (vc_solve simp: rtf_is_nbr split del: if_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab aaa baa.\n       \\<lbrakk>discharge_invar c s t u f l n ab aaa baa;\n        excess ab u = (0::'capacity)\\<rbrakk>\n       \\<Longrightarrow> VCG_FRAME\n                          (if aaa (hd L_right) \\<noteq> l (hd L_right)\n                           then let (L_left, L_right) =\n([hd L_right], L_left @ tl L_right)\n                                in return (ab, aaa, baa, L_left, L_right)\n                           else let (L_left, L_right) =\n(L_left @ [hd L_right], tl L_right)\n                                in return (ab, aaa, baa, L_left, L_right))\n                         \\<le> (spec s'.\n                                   (case s' of\n                                    (f, l, n, xa, xb) \\<Rightarrow>\nrtf_invar c s t f l n xa xb) \\<and>\n                                   (case s' of\n                                    (f, l, n, L_left, L_right) \\<Rightarrow>\n((f, l), length L_right),\n                                    (f, l), Suc (length L_right'))\n                                   \\<in> pr_algo_rel\\<^sup>+ <*lex*>\n   less_than)", "subgoal for f' l' n'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>discharge_invar c s t u f l n f' l' n';\n     excess f' u = (0::'capacity)\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (if l' (hd L_right) \\<noteq> l (hd L_right)\n                        then let (L_left, L_right) =\n                                   ([hd L_right], L_left @ tl L_right)\n                             in return (f', l', n', L_left, L_right)\n                        else let (L_left, L_right) =\n                                   (L_left @ [hd L_right], tl L_right)\n                             in return (f', l', n', L_left, L_right))\n                      \\<le> (spec s'.\n                                (case s' of\n                                 (f, l, n, xa, xb) \\<Rightarrow>\n                                   rtf_invar c s t f l n xa xb) \\<and>\n                                (case s' of\n                                 (f, l, n, L_left, L_right) \\<Rightarrow>\n                                   ((f, l), length L_right),\n                                 (f, l), Suc (length L_right'))\n                                \\<in> pr_algo_rel\\<^sup>+ <*lex*> less_than)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>discharge_invar c s t u f l n f' l' n';\n     excess f' u = (0::'capacity)\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (if l' (hd L_right) \\<noteq> l (hd L_right)\n                        then let (L_left, L_right) =\n                                   ([hd L_right], L_left @ tl L_right)\n                             in return (f', l', n', L_left, L_right)\n                        else let (L_left, L_right) =\n                                   (L_left @ [hd L_right], tl L_right)\n                             in return (f', l', n', L_left, L_right))\n                      \\<le> (spec s'.\n                                (case s' of\n                                 (f, l, n, xa, xb) \\<Rightarrow>\n                                   rtf_invar c s t f l n xa xb) \\<and>\n                                (case s' of\n                                 (f, l, n, L_left, L_right) \\<Rightarrow>\n                                   ((f, l), length L_right),\n                                 (f, l), Suc (length L_right'))\n                                \\<in> pr_algo_rel\\<^sup>+ <*lex*> less_than)", "assume \"discharge_invar c s t u f l n f' l' n'\""], ["proof (state)\nthis:\n  discharge_invar c s t u f l n f' l' n'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>discharge_invar c s t u f l n f' l' n';\n     excess f' u = (0::'capacity)\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (if l' (hd L_right) \\<noteq> l (hd L_right)\n                        then let (L_left, L_right) =\n                                   ([hd L_right], L_left @ tl L_right)\n                             in return (f', l', n', L_left, L_right)\n                        else let (L_left, L_right) =\n                                   (L_left @ [hd L_right], tl L_right)\n                             in return (f', l', n', L_left, L_right))\n                      \\<le> (spec s'.\n                                (case s' of\n                                 (f, l, n, xa, xb) \\<Rightarrow>\n                                   rtf_invar c s t f l n xa xb) \\<and>\n                                (case s' of\n                                 (f, l, n, L_left, L_right) \\<Rightarrow>\n                                   ((f, l), length L_right),\n                                 (f, l), Suc (length L_right'))\n                                \\<in> pr_algo_rel\\<^sup>+ <*lex*> less_than)", "then"], ["proof (chain)\npicking this:\n  discharge_invar c s t u f l n f' l' n'", "interpret l': discharge_invar c s t u f l n f' l' n'"], ["proof (prove)\nusing this:\n  discharge_invar c s t u f l n f' l' n'\n\ngoal (1 subgoal):\n 1. discharge_invar c s t u f l n f' l' n'", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>discharge_invar c s t u f l n f' l' n';\n     excess f' u = (0::'capacity)\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (if l' (hd L_right) \\<noteq> l (hd L_right)\n                        then let (L_left, L_right) =\n                                   ([hd L_right], L_left @ tl L_right)\n                             in return (f', l', n', L_left, L_right)\n                        else let (L_left, L_right) =\n                                   (L_left @ [hd L_right], tl L_right)\n                             in return (f', l', n', L_left, L_right))\n                      \\<le> (spec s'.\n                                (case s' of\n                                 (f, l, n, xa, xb) \\<Rightarrow>\n                                   rtf_invar c s t f l n xa xb) \\<and>\n                                (case s' of\n                                 (f, l, n, L_left, L_right) \\<Rightarrow>\n                                   ((f, l), length L_right),\n                                 (f, l), Suc (length L_right'))\n                                \\<in> pr_algo_rel\\<^sup>+ <*lex*> less_than)", "assume [simp]: \"excess f' u = 0\""], ["proof (state)\nthis:\n  excess f' u = (0::'capacity)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>discharge_invar c s t u f l n f' l' n';\n     excess f' u = (0::'capacity)\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (if l' (hd L_right) \\<noteq> l (hd L_right)\n                        then let (L_left, L_right) =\n                                   ([hd L_right], L_left @ tl L_right)\n                             in return (f', l', n', L_left, L_right)\n                        else let (L_left, L_right) =\n                                   (L_left @ [hd L_right], tl L_right)\n                             in return (f', l', n', L_left, L_right))\n                      \\<le> (spec s'.\n                                (case s' of\n                                 (f, l, n, xa, xb) \\<Rightarrow>\n                                   rtf_invar c s t f l n xa xb) \\<and>\n                                (case s' of\n                                 (f, l, n, L_left, L_right) \\<Rightarrow>\n                                   ((f, l), length L_right),\n                                 (f, l), Suc (length L_right'))\n                                \\<in> pr_algo_rel\\<^sup>+ <*lex*> less_than)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. VCG_FRAME\n     (if l' (hd L_right) \\<noteq> l (hd L_right)\n      then let (L_left, L_right) = ([hd L_right], L_left @ tl L_right)\n           in return (f', l', n', L_left, L_right)\n      else let (L_left, L_right) = (L_left @ [hd L_right], tl L_right)\n           in return (f', l', n', L_left, L_right))\n    \\<le> (spec s'.\n              (case s' of\n               (f, l, n, xa, xb) \\<Rightarrow>\n                 rtf_invar c s t f l n xa xb) \\<and>\n              (case s' of\n               (f, l, n, L_left, L_right) \\<Rightarrow>\n                 ((f, l), length L_right),\n               (f, l), Suc (length L_right'))\n              \\<in> pr_algo_rel\\<^sup>+ <*lex*> less_than)", "apply (rule vcg_rem_frame)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if l' (hd L_right) \\<noteq> l (hd L_right)\n     then let (L_left, L_right) = ([hd L_right], L_left @ tl L_right)\n          in return (f', l', n', L_left, L_right)\n     else let (L_left, L_right) = (L_left @ [hd L_right], tl L_right)\n          in return (f', l', n', L_left, L_right))\n    \\<le> (spec s'.\n              (case s' of\n               (f, l, n, xa, xb) \\<Rightarrow>\n                 rtf_invar c s t f l n xa xb) \\<and>\n              (case s' of\n               (f, l, n, L_left, L_right) \\<Rightarrow>\n                 ((f, l), length L_right),\n               (f, l), Suc (length L_right'))\n              \\<in> pr_algo_rel\\<^sup>+ <*lex*> less_than)", "apply refine_vcg"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>l' (hd L_right) \\<noteq> l (hd L_right);\n        ([hd L_right], L_left @ tl L_right) = (a, b); x2b = (x1c, x2c);\n        x2a = (x1b, x2b); x2 = (x1a, x2a);\n        (f', l', n', a, b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> rtf_invar c s t x1 x1a x1b x1c x2c\n 2. \\<And>a b x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>l' (hd L_right) \\<noteq> l (hd L_right);\n        ([hd L_right], L_left @ tl L_right) = (a, b); x2b = (x1c, x2c);\n        x2a = (x1b, x2b); x2 = (x1a, x2a);\n        (f', l', n', a, b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> (((x1, x1a), length x2c), (f, l),\n                          Suc (length L_right'))\n                         \\<in> pr_algo_rel\\<^sup>+ <*lex*> less_than\n 3. \\<And>a b x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>\\<not> l' (hd L_right) \\<noteq> l (hd L_right);\n        (L_left @ [hd L_right], tl L_right) = (a, b); x2b = (x1c, x2c);\n        x2a = (x1b, x2b); x2 = (x1a, x2a);\n        (f', l', n', a, b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> rtf_invar c s t x1 x1a x1b x1c x2c\n 4. \\<And>a b x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>\\<not> l' (hd L_right) \\<noteq> l (hd L_right);\n        (L_left @ [hd L_right], tl L_right) = (a, b); x2b = (x1c, x2c);\n        x2a = (x1b, x2b); x2 = (x1a, x2a);\n        (f', l', n', a, b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> (((x1, x1a), length x2c), (f, l),\n                          Suc (length L_right'))\n                         \\<in> pr_algo_rel\\<^sup>+ <*lex*> less_than", "apply (vc_solve)"], ["proof (prove)\ngoal (4 subgoals):\n 1. l' u \\<noteq> l u \\<Longrightarrow>\n    rtf_invar c s t f' l' n' [u] (L_left @ L_right')\n 2. \\<lbrakk>l' u \\<noteq> l u;\n     l' = l \\<longrightarrow>\n     f' = f \\<longrightarrow> L_left \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ((f', l'), f, l) \\<in> pr_algo_rel\\<^sup>+\n 3. l' u = l u \\<Longrightarrow>\n    rtf_invar c s t f' l' n' (L_left @ [u]) L_right'\n 4. \\<lbrakk>l' u = l u; f' = f \\<longrightarrow> l' \\<noteq> l\\<rbrakk>\n    \\<Longrightarrow> ((f', l'), f, l) \\<in> pr_algo_rel\\<^sup>+", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. l' u \\<noteq> l u \\<Longrightarrow>\n    rtf_invar c s t f' l' n' [u] (L_left @ L_right')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. l' u \\<noteq> l u \\<Longrightarrow>\n    rtf_invar c s t f' l' n' [u] (L_left @ L_right')", "assume RELABEL: \"l' u \\<noteq> l u\""], ["proof (state)\nthis:\n  l' u \\<noteq> l u\n\ngoal (1 subgoal):\n 1. l' u \\<noteq> l u \\<Longrightarrow>\n    rtf_invar c s t f' l' n' [u] (L_left @ L_right')", "have AUX1: \"x=u\" if \"(x, u) \\<in> (adm_edges f' l')\\<^sup>*\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = u", "using that l'.relabel_u_no_incoming_adm[OF RELABEL[symmetric]]"], ["proof (prove)\nusing this:\n  (x, u) \\<in> (adm_edges f' l')\\<^sup>*\n  (?v, u) \\<notin> adm_edges f' l'\n\ngoal (1 subgoal):\n 1. x = u", "by (auto elim: rtranclE)"], ["proof (state)\nthis:\n  (?x3, u) \\<in> (adm_edges f' l')\\<^sup>* \\<Longrightarrow> ?x3 = u\n\ngoal (1 subgoal):\n 1. l' u \\<noteq> l u \\<Longrightarrow>\n    rtf_invar c s t f' l' n' [u] (L_left @ L_right')", "have TS1: \"is_top_sorted (adm_edges f l) (L_left @ L_right')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_top_sorted (adm_edges f l) (L_left @ L_right')", "using L_sorted"], ["proof (prove)\nusing this:\n  is_top_sorted (adm_edges f l) (L_left @ L_right)\n\ngoal (1 subgoal):\n 1. is_top_sorted (adm_edges f l) (L_left @ L_right')", "by (auto intro: is_top_sorted_remove_elem)\n\n            \\<comment> \\<open>Intuition:\\<close>\n              \\<comment> \\<open>new edges come from \\<open>u\\<close>, but \\<open>u\\<close> has no incoming edges, nor is it in \\<open>L_left@L_right'\\<close>.\\<close>\n              \\<comment> \\<open>thus, these new edges cannot add effective constraints.\\<close>"], ["proof (state)\nthis:\n  is_top_sorted (adm_edges f l) (L_left @ L_right')\n\ngoal (1 subgoal):\n 1. l' u \\<noteq> l u \\<Longrightarrow>\n    rtf_invar c s t f' l' n' [u] (L_left @ L_right')", "from l'.adm_edges_leaving_u \n              and l'.relabel_u_no_incoming_adm[OF RELABEL[symmetric]]"], ["proof (chain)\npicking this:\n  (?u', ?v) \\<in> adm_edges f' l' - adm_edges f l \\<Longrightarrow> ?u' = u\n  (?v, u) \\<notin> adm_edges f' l'", "have \"adm_edges f' l' \\<subseteq> adm_edges f l \\<union> {u}\\<times>UNIV\" \n              and \"adm_edges f' l' \\<inter> UNIV\\<times>{u}={}\""], ["proof (prove)\nusing this:\n  (?u', ?v) \\<in> adm_edges f' l' - adm_edges f l \\<Longrightarrow> ?u' = u\n  (?v, u) \\<notin> adm_edges f' l'\n\ngoal (1 subgoal):\n 1. adm_edges f' l' \\<subseteq> adm_edges f l \\<union> {u} \\<times> UNIV &&&\n    adm_edges f' l' \\<inter> UNIV \\<times> {u} = {}", "by auto"], ["proof (state)\nthis:\n  adm_edges f' l' \\<subseteq> adm_edges f l \\<union> {u} \\<times> UNIV\n  adm_edges f' l' \\<inter> UNIV \\<times> {u} = {}\n\ngoal (1 subgoal):\n 1. l' u \\<noteq> l u \\<Longrightarrow>\n    rtf_invar c s t f' l' n' [u] (L_left @ L_right')", "from is_top_sorted_isolated_constraint[OF this _ TS1]"], ["proof (chain)\npicking this:\n  u \\<notin> set (L_left @ L_right') \\<Longrightarrow>\n  is_top_sorted (adm_edges f' l') (L_left @ L_right')", "have AUX2: \"is_top_sorted (adm_edges f' l') (L_left @ L_right')\""], ["proof (prove)\nusing this:\n  u \\<notin> set (L_left @ L_right') \\<Longrightarrow>\n  is_top_sorted (adm_edges f' l') (L_left @ L_right')\n\ngoal (1 subgoal):\n 1. is_top_sorted (adm_edges f' l') (L_left @ L_right')", "by simp"], ["proof (state)\nthis:\n  is_top_sorted (adm_edges f' l') (L_left @ L_right')\n\ngoal (1 subgoal):\n 1. l' u \\<noteq> l u \\<Longrightarrow>\n    rtf_invar c s t f' l' n' [u] (L_left @ L_right')", "show \"rtf_invar c s t f' l' n' [u] (L_left @ L_right')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rtf_invar c s t f' l' n' [u] (L_left @ L_right')", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>u\\<in>set [u]. excess f' u = (0::'capacity)\n 2. is_top_sorted (adm_edges f' l') ([u] @ L_left @ L_right')\n 3. set [u] \\<union> set (L_left @ L_right') = V - {s, t}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>set [u]. excess f' u = (0::'capacity)", "by simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_top_sorted (adm_edges f' l') ([u] @ L_left @ L_right')\n 2. set [u] \\<union> set (L_left @ L_right') = V - {s, t}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_top_sorted (adm_edges f' l') ([u] @ L_left @ L_right')", "using AUX2"], ["proof (prove)\nusing this:\n  is_top_sorted (adm_edges f' l') (L_left @ L_right')\n\ngoal (1 subgoal):\n 1. is_top_sorted (adm_edges f' l') ([u] @ L_left @ L_right')", "by (auto simp: is_top_sorted_cons dest!: AUX1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set [u] \\<union> set (L_left @ L_right') = V - {s, t}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. set [u] \\<union> set (L_left @ L_right') = V - {s, t}", "using L_set"], ["proof (prove)\nusing this:\n  set L_left \\<union> set L_right = V - {s, t}\n\ngoal (1 subgoal):\n 1. set [u] \\<union> set (L_left @ L_right') = V - {s, t}", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rtf_invar c s t f' l' n' [u] (L_left @ L_right')\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>l' u \\<noteq> l u;\n     l' = l \\<longrightarrow>\n     f' = f \\<longrightarrow> L_left \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ((f', l'), f, l) \\<in> pr_algo_rel\\<^sup>+\n 2. l' u = l u \\<Longrightarrow>\n    rtf_invar c s t f' l' n' (L_left @ [u]) L_right'\n 3. \\<lbrakk>l' u = l u; f' = f \\<longrightarrow> l' \\<noteq> l\\<rbrakk>\n    \\<Longrightarrow> ((f', l'), f, l) \\<in> pr_algo_rel\\<^sup>+", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l' u \\<noteq> l u;\n     l' = l \\<longrightarrow>\n     f' = f \\<longrightarrow> L_left \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ((f', l'), f, l) \\<in> pr_algo_rel\\<^sup>+", "using l'.algo_rel"], ["proof (prove)\nusing this:\n  ((f', l'), f, l) \\<in> pr_algo_rel\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l' u \\<noteq> l u;\n     l' = l \\<longrightarrow>\n     f' = f \\<longrightarrow> L_left \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ((f', l'), f, l) \\<in> pr_algo_rel\\<^sup>+", "by (auto dest: rtranclD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. l' u = l u \\<Longrightarrow>\n    rtf_invar c s t f' l' n' (L_left @ [u]) L_right'\n 2. \\<lbrakk>l' u = l u; f' = f \\<longrightarrow> l' \\<noteq> l\\<rbrakk>\n    \\<Longrightarrow> ((f', l'), f, l) \\<in> pr_algo_rel\\<^sup>+", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. l' u = l u \\<Longrightarrow>\n    rtf_invar c s t f' l' n' (L_left @ [u]) L_right'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. l' u = l u \\<Longrightarrow>\n    rtf_invar c s t f' l' n' (L_left @ [u]) L_right'", "assume NO_RELABEL[simp]: \"l' u = l u\"\n            \\<comment> \\<open>Intuition: non-zero excess would imply an admissible edge contrary to \\<open>top_sorted\\<close>.\\<close>"], ["proof (state)\nthis:\n  l' u = l u\n\ngoal (1 subgoal):\n 1. l' u = l u \\<Longrightarrow>\n    rtf_invar c s t f' l' n' (L_left @ [u]) L_right'", "have AUX: \"excess f' v = 0\" if \"v\\<in>set L_left\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. excess f' v = (0::'capacity)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. excess f' v \\<noteq> (0::'capacity) \\<Longrightarrow> False", "from that \\<open>u\\<notin>set L_left\\<close>"], ["proof (chain)\npicking this:\n  v \\<in> set L_left\n  u \\<notin> set L_left", "have \"u \\<noteq> v\""], ["proof (prove)\nusing this:\n  v \\<in> set L_left\n  u \\<notin> set L_left\n\ngoal (1 subgoal):\n 1. u \\<noteq> v", "by blast"], ["proof (state)\nthis:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. excess f' v \\<noteq> (0::'capacity) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. excess f' v \\<noteq> (0::'capacity) \\<Longrightarrow> False", "assume \"excess f' v \\<noteq> 0\""], ["proof (state)\nthis:\n  excess f' v \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. excess f' v \\<noteq> (0::'capacity) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  excess f' v \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. excess f' v \\<noteq> (0::'capacity) \\<Longrightarrow> False", "from that left_no_excess"], ["proof (chain)\npicking this:\n  v \\<in> set L_left\n  \\<forall>u\\<in>set L_left. excess f u = (0::'capacity)", "have \"excess f v = 0\""], ["proof (prove)\nusing this:\n  v \\<in> set L_left\n  \\<forall>u\\<in>set L_left. excess f u = (0::'capacity)\n\ngoal (1 subgoal):\n 1. excess f v = (0::'capacity)", "by auto"], ["proof (state)\nthis:\n  excess f v = (0::'capacity)\n\ngoal (1 subgoal):\n 1. excess f' v \\<noteq> (0::'capacity) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  u \\<noteq> v\n  excess f' v \\<noteq> (0::'capacity)\n  excess f v = (0::'capacity)", "have \"(u,v)\\<in>adm_edges f l\""], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  excess f' v \\<noteq> (0::'capacity)\n  excess f v = (0::'capacity)\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> adm_edges f l", "using l'.no_relabel_excess[OF NO_RELABEL[symmetric]]"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  excess f' v \\<noteq> (0::'capacity)\n  excess f v = (0::'capacity)\n  \\<lbrakk>u \\<noteq> ?v; excess f ?v \\<noteq> excess f' ?v\\<rbrakk>\n  \\<Longrightarrow> (u, ?v) \\<in> adm_edges f l\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> adm_edges f l", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<in> adm_edges f l\n\ngoal (1 subgoal):\n 1. excess f' v \\<noteq> (0::'capacity) \\<Longrightarrow> False", "with L_sorted that"], ["proof (chain)\npicking this:\n  is_top_sorted (adm_edges f l) (L_left @ L_right)\n  v \\<in> set L_left\n  (u, v) \\<in> adm_edges f l", "show False"], ["proof (prove)\nusing this:\n  is_top_sorted (adm_edges f l) (L_left @ L_right)\n  v \\<in> set L_left\n  (u, v) \\<in> adm_edges f l\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: is_top_sorted_append is_top_sorted_cons)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?v3 \\<in> set L_left \\<Longrightarrow> excess f' ?v3 = (0::'capacity)\n\ngoal (1 subgoal):\n 1. l' u = l u \\<Longrightarrow>\n    rtf_invar c s t f' l' n' (L_left @ [u]) L_right'", "show \"rtf_invar c s t f' l' n' (L_left @ [u]) L_right'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rtf_invar c s t f' l' n' (L_left @ [u]) L_right'", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>u\\<in>set (L_left @ [u]). excess f' u = (0::'capacity)\n 2. is_top_sorted (adm_edges f' l') ((L_left @ [u]) @ L_right')\n 3. set (L_left @ [u]) \\<union> set L_right' = V - {s, t}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>set (L_left @ [u]). excess f' u = (0::'capacity)", "by (auto simp: AUX)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_top_sorted (adm_edges f' l') ((L_left @ [u]) @ L_right')\n 2. set (L_left @ [u]) \\<union> set L_right' = V - {s, t}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_top_sorted (adm_edges f' l') ((L_left @ [u]) @ L_right')", "apply (rule is_top_sorted_antimono[\n                  OF l'.no_relabel_adm_edges[OF NO_RELABEL[symmetric]]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_top_sorted (adm_edges f l) ((L_left @ [u]) @ L_right')", "using L_sorted"], ["proof (prove)\nusing this:\n  is_top_sorted (adm_edges f l) (L_left @ L_right)\n\ngoal (1 subgoal):\n 1. is_top_sorted (adm_edges f l) ((L_left @ [u]) @ L_right')", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (L_left @ [u]) \\<union> set L_right' = V - {s, t}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (L_left @ [u]) \\<union> set L_right' = V - {s, t}", "using L_set"], ["proof (prove)\nusing this:\n  set L_left \\<union> set L_right = V - {s, t}\n\ngoal (1 subgoal):\n 1. set (L_left @ [u]) \\<union> set L_right' = V - {s, t}", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rtf_invar c s t f' l' n' (L_left @ [u]) L_right'\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l' u = l u; f' = f \\<longrightarrow> l' \\<noteq> l\\<rbrakk>\n    \\<Longrightarrow> ((f', l'), f, l) \\<in> pr_algo_rel\\<^sup>+", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l' u = l u; f' = f \\<longrightarrow> l' \\<noteq> l\\<rbrakk>\n    \\<Longrightarrow> ((f', l'), f, l) \\<in> pr_algo_rel\\<^sup>+", "using l'.algo_rel"], ["proof (prove)\nusing this:\n  ((f', l'), f, l) \\<in> pr_algo_rel\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l' u = l u; f' = f \\<longrightarrow> l' \\<noteq> l\\<rbrakk>\n    \\<Longrightarrow> ((f', l'), f, l) \\<in> pr_algo_rel\\<^sup>+", "by (auto dest: rtranclD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  VCG_FRAME\n   (if l' (hd L_right) \\<noteq> l (hd L_right)\n    then let (L_left, L_right) = ([hd L_right], L_left @ tl L_right)\n         in return (f', l', n', L_left, L_right)\n    else let (L_left, L_right) = (L_left @ [hd L_right], tl L_right)\n         in return (f', l', n', L_left, L_right))\n  \\<le> (spec s'.\n            (case s' of\n             (f, l, n, xa, xb) \\<Rightarrow>\n               rtf_invar c s t f l n xa xb) \\<and>\n            (case s' of\n             (f, l, n, L_left, L_right) \\<Rightarrow>\n               ((f, l), length L_right),\n             (f, l), Suc (length L_right'))\n            \\<in> pr_algo_rel\\<^sup>+ <*lex*> less_than)\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  VCG_FRAME\n   (let u = hd L_right\n    in assert (u \\<in> V) \\<bind>\n       (\\<lambda>_.\n           let old_lu = l u\n           in discharge f l n u \\<bind>\n              (\\<lambda>(f, l, n).\n                  if l u \\<noteq> old_lu\n                  then let (L_left, L_right) = ([u], L_left @ tl L_right)\n                       in return (f, l, n, L_left, L_right)\n                  else let (L_left, L_right) = (L_left @ [u], tl L_right)\n                       in return (f, l, n, L_left, L_right))))\n  \\<le> (spec s'.\n            (case s' of\n             (f, l, n, xa, xb) \\<Rightarrow>\n               rtf_invar c s t f l n xa xb) \\<and>\n            (case s' of\n             (f, l, n, L_left, L_right) \\<Rightarrow>\n               ((f, l), length L_right),\n             (f, l), length L_right)\n            \\<in> pr_algo_rel\\<^sup>+ <*lex*> less_than)\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x ad aaa aba aca.\n       \\<lbrakk>rtf_invar c s t ad aaa aba aca []; distinct x;\n        set x = V - {s, t}\\<rbrakk>\n       \\<Longrightarrow> isMaxFlow ad", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rtf_invar c s t ad_ aaa_ aba_ aca_ []; distinct x_;\n     set x_ = V - {s, t}\\<rbrakk>\n    \\<Longrightarrow> isMaxFlow ad_", "by (auto intro: rtf_invar.terminated_imp_maxflow)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end \\<comment> \\<open>Network\\<close>"], ["", "end"]]}