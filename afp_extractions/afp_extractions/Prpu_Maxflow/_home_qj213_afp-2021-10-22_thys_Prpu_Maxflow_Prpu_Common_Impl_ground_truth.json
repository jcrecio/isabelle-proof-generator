{"file_name": "/home/qj213/afp-2021-10-22/thys/Prpu_Maxflow/Prpu_Common_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Prpu_Maxflow", "problem_names": ["lemma xf_rel_RELATES[refine_dref_RELATES]: \"RELATES xf_rel\"", "lemma excess_pp_init_f[simp]: \"excess pp_init_f = pp_init_x\"", "lemma cf_of_pp_init_f[simp]: \"cf_of pp_init_f = pp_init_cf\"", "lemma pp_init_x_rel: \"((pp_init_x, pp_init_cf), pp_init_f) \\<in> xf_rel\"", "lemma pp_init_xcf2_aux_spec: \n  shows \"pp_init_xcf2_aux \\<le> SPEC (\\<lambda>(x,cf). x=pp_init_x \\<and> cf = pp_init_cf)\"", "lemma pp_init_xcf2_refine_aux:\n  assumes AM: \"is_adj_map am\"  \n  shows \"pp_init_xcf2 am \\<le> \\<Down>Id (pp_init_xcf2_aux)\"", "lemma pp_init_xcf2_refine[refine2]: \n  assumes AM: \"is_adj_map am\"  \n  shows \"pp_init_xcf2 am \\<le>\\<Down>xf_rel (RETURN pp_init_f)\"", "lemma (in -) set_filter_xform_aux: \n  \"{ f x | x. ( x = a \\<or> x\\<in>S \\<and> x\\<notin>it ) \\<and> P x } \n  = (if P a then {f a} else {}) \\<union> {f x | x. x\\<in>S-it \\<and> P x}\"", "lemma (in Labeling) min_adj_label_aux_spec: \n  assumes PRE: \"relabel_precond f l u\"\n  shows \"min_adj_label_aux cf l u \\<le> SPEC (\\<lambda>x. x = Min { l v | v. (u,v)\\<in>cf.E })\"", "lemma min_adj_label_refine[THEN order_trans, refine_vcg]:\n  assumes \"Height_Bounded_Labeling c s t f l\"\n  assumes AM: \"(am,adjacent_nodes)\\<in>nat_rel\\<rightarrow>\\<langle>nat_rel\\<rangle>list_set_rel\"\n  assumes PRE: \"relabel_precond f l u\"\n  assumes [simp]: \"cf = cf_of f\"  \n  shows \"min_adj_label am cf l u \\<le> SPEC (\\<lambda>x. x \n        = Min { l v | v. (u,v)\\<in>cfE_of f })\"", "lemma relabel2_refine[refine]: \n  assumes \"((x,cf),f)\\<in>xf_rel\"\n  assumes AM: \"(am,adjacent_nodes)\\<in>nat_rel\\<rightarrow>\\<langle>nat_rel\\<rangle>list_set_rel\"\n  assumes [simplified,simp]: \"(li,l)\\<in>Id\" \"(ui,u)\\<in>Id\"\n  shows \"relabel2 am cf li ui \\<le> \\<Down>Id (relabel f l u)\"", "lemma push2_aux_refine: \n  \"\\<lbrakk>((x,cf),f)\\<in>xf_rel; (ei,e)\\<in>Id\\<times>\\<^sub>rId\\<rbrakk> \n    \\<Longrightarrow> push2_aux x cf ei \\<le> \\<Down>xf_rel (push f l e)\"", "lemma push2_refine[refine]: \n  assumes \"((x,cf),f)\\<in>xf_rel\" \"(ei,e)\\<in>Id\\<times>\\<^sub>rId\"\n  shows \"push2 x cf ei \\<le> \\<Down>xf_rel (push f l e)\"", "lemma cardV_le_N: \"card V \\<le> N\"", "lemma N_not_Z: \"N \\<noteq> 0\"", "lemma N_ge_2: \"2\\<le>N\"", "lemma clc_init_refine[refine]:\n  assumes [simplified,simp]: \"(Ci,C)\\<in>nat_rel\" \n  assumes [simp]: \"C = card V\" \n  shows \"clc_init Ci \\<le>\\<Down>clc_rel (l_init C)\"", "lemma clc_get_refine[refine]: \n  \"\\<lbrakk> (clc,l)\\<in>clc_rel; (ui,u)\\<in>nat_rel \\<rbrakk> \\<Longrightarrow> clc_get clc ui \\<le>\\<Down>Id (l_get l u)\"", "lemma clc_get_rlx_refine[refine]: \n  \"\\<lbrakk> (clc,l)\\<in>clc_rel; (ui,u)\\<in>nat_rel \\<rbrakk> \n  \\<Longrightarrow> clc_get_rlx clc ui \\<le>\\<Down>Id (l_get_rlx l u)\"", "lemma card_insert_disjointI: \n  \"\\<lbrakk> finite Y; X = insert x Y; x\\<notin>Y \\<rbrakk> \\<Longrightarrow> card X = Suc (card Y)\"", "lemma clc_set_refine[refine]:\n  \"\\<lbrakk> (clc,l) \\<in> clc_rel; (ui,u)\\<in>nat_rel; (ai,a)\\<in>nat_rel \\<rbrakk> \\<Longrightarrow>\n    clc_set clc ui ai \\<le>\\<Down>clc_rel (l_set l u a)\"", "lemma clc_has_gap_correct[THEN order_trans, refine_vcg]:\n  \"\\<lbrakk>(clc,l)\\<in>clc_rel; k<2*N\\<rbrakk> \n  \\<Longrightarrow> clc_has_gap clc k \\<le> (spec r. r \\<longleftrightarrow> gap_precond l k)\"", "lemma gap_effect_invar[simp]: \"l_invar l \\<Longrightarrow> l_invar (gap_effect l k)\"", "lemma relabel_effect_invar[simp]: \"\\<lbrakk>l_invar l; u\\<in>V\\<rbrakk> \\<Longrightarrow> l_invar (relabel_effect f l u)\"", "lemma gap_aux_correct[THEN order_trans, refine_vcg]: \n  \"\\<lbrakk>l_invar l; C=card V\\<rbrakk> \\<Longrightarrow> gap_aux C l k \\<le> SPEC (\\<lambda>r. r=gap_effect l k)\"", "lemma gap2_refine[refine]:  \n  assumes [simplified,simp]: \"(Ci,C)\\<in>nat_rel\" \"(ki,k)\\<in>nat_rel\"\n  assumes CLC: \"(clc,l)\\<in>clc_rel\"  \n  shows \"gap2 Ci clc ki \\<le>\\<Down>clc_rel (gap_aux C l k)\"", "lemma gap_relabel_aux_refine: \n  assumes [simp]: \"C = card V\" \"l_invar l\"\n  shows \"gap_relabel_aux C f l u \\<le> gap_relabel f l u\"", "lemma clc_relabel2_refine[refine]: \n  assumes XF: \"((x,cf),f)\\<in>xf_rel\"\n  assumes CLC: \"(clc,l)\\<in>clc_rel\"  \n  assumes AM: \"(am,adjacent_nodes)\\<in>nat_rel\\<rightarrow>\\<langle>nat_rel\\<rangle>list_set_rel\"\n  assumes [simplified,simp]: \"(ui,u)\\<in>Id\"\n  shows \"clc_relabel2 am cf clc ui \\<le> \\<Down>clc_rel (relabel f l u)\"", "lemma gap_relabel2_refine_aux:\n  assumes XCF: \"((x, cf), f) \\<in> xf_rel\"  \n  assumes CLC: \"(clc,l)\\<in>clc_rel\"  \n  assumes AM: \"(am,adjacent_nodes)\\<in>nat_rel\\<rightarrow>\\<langle>nat_rel\\<rangle>list_set_rel\"\n  assumes [simplified,simp]: \"(Ci,C)\\<in>Id\" \"(ui,u)\\<in>Id\"\n  shows \"gap_relabel2 Ci am cf clc ui \\<le> \\<Down>clc_rel (gap_relabel_aux C f l u)\"", "lemma gap_relabel2_refine[refine]:\n  assumes XCF: \"((x, cf), f) \\<in> xf_rel\"  \n  assumes CLC: \"(clc,l)\\<in>clc_rel\"  \n  assumes AM: \"(am,adjacent_nodes)\\<in>nat_rel\\<rightarrow>\\<langle>nat_rel\\<rangle>list_set_rel\"\n  assumes [simplified,simp]: \"(ui,u)\\<in>Id\"    \n  assumes CC: \"C = card V\"  \n  shows \"gap_relabel2 C am cf clc ui \\<le>\\<Down>clc_rel (gap_relabel f l u)\"", "lemma x_init_hnr[sepref_fr_rules]: \n  \"(uncurry0 (Array.new N 0), uncurry0 x_init) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a x_assn\"", "lemma x_get_hnr[sepref_fr_rules]: \n  \"(uncurry Array.nth, uncurry (PR_CONST x_get)) \n  \\<in> x_assn\\<^sup>k *\\<^sub>a node_assn\\<^sup>k \\<rightarrow>\\<^sub>a cap_assn\"", "lemma x_add_hnr[sepref_fr_rules]: \n  \"(uncurry2 x_add_impl, uncurry2 (PR_CONST x_add)) \n  \\<in> x_assn\\<^sup>d *\\<^sub>a node_assn\\<^sup>k *\\<^sub>a cap_assn\\<^sup>k \\<rightarrow>\\<^sub>a x_assn\"", "lemma l_init_hnr[sepref_fr_rules]: \n  \"(l_init_impl N s, (PR_CONST l_init)) \\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a l_assn\"", "lemma l_get_hnr[sepref_fr_rules]: \n  \"(uncurry Array.nth, uncurry (PR_CONST l_get)) \n  \\<in> l_assn\\<^sup>k *\\<^sub>a node_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\"", "lemma l_get_rlx_hnr[sepref_fr_rules]: \n  \"(uncurry Array.nth, uncurry (PR_CONST l_get_rlx)) \n  \\<in> l_assn\\<^sup>k *\\<^sub>a node_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\"", "lemma l_set_hnr[sepref_fr_rules]: \n  \"(uncurry2 (\\<lambda>a i x. Array.upd i x a), uncurry2 (PR_CONST l_set)) \n  \\<in> l_assn\\<^sup>d *\\<^sub>a node_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a l_assn\"", "lemma cnt_init_hnr[sepref_fr_rules]: \"(cnt_init_impl N, PR_CONST cnt_init) \\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a cnt_assn\"", "lemma cnt_get_hnr[sepref_fr_rules]: \"(uncurry Array.nth, uncurry (PR_CONST cnt_get)) \\<in> cnt_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\"", "lemma cnt_incr_hnr[sepref_fr_rules]: \"(uncurry cnt_incr_impl, uncurry (PR_CONST cnt_incr)) \\<in> cnt_assn\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a cnt_assn\"", "lemma cnt_decr_hnr[sepref_fr_rules]: \"(uncurry cnt_decr_impl, uncurry (PR_CONST cnt_decr)) \\<in> cnt_assn\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a cnt_assn\"", "lemmas [sepref_fr_rules] = clc_init_impl.refine[OF Network_Impl_axioms]", "lemmas [sepref_fr_rules] = clc_get_impl.refine[OF Network_Impl_axioms]", "lemmas [sepref_fr_rules] = clc_get_rlx_impl.refine[OF Network_Impl_axioms]", "lemmas [sepref_fr_rules] = clc_set_impl.refine[OF Network_Impl_axioms]", "lemmas [sepref_fr_rules] = clc_has_gap_impl.refine[OF Network_Impl_axioms]", "lemmas [sepref_fr_rules] = push_impl.refine[OF Network_Impl_axioms]", "lemmas [sepref_fr_rules] = min_adj_label_impl.refine[OF Network_Impl_axioms]", "lemmas [sepref_fr_rules] = relabel_impl.refine[OF Network_Impl_axioms]", "lemmas [sepref_fr_rules] = gap_impl.refine[OF Network_Impl_axioms]", "lemmas [sepref_fr_rules] = min_adj_label_clc_impl.refine[OF Network_Impl_axioms]", "lemmas [sepref_fr_rules] = clc_relabel_impl.refine[OF Network_Impl_axioms]", "lemmas [sepref_fr_rules] = gap_relabel_impl.refine[OF Network_Impl_axioms]", "lemmas [sepref_fr_rules] = pp_init_xcf2_impl.refine[OF Network_Impl_axioms]"], "translations": [["", "lemma xf_rel_RELATES[refine_dref_RELATES]: \"RELATES xf_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RELATES xf_rel", "by (auto simp: RELATES_def)"], ["", "definition \"pp_init_x \n  \\<equiv> \\<lambda>u. (if u=s then (\\<Sum>(u,v)\\<in>outgoing s. - c(u,v)) else c (s,u))\""], ["", "lemma excess_pp_init_f[simp]: \"excess pp_init_f = pp_init_x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. excess pp_init_f = pp_init_x", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. excess pp_init_f x = pp_init_x x", "subgoal for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. excess pp_init_f u = pp_init_x u", "unfolding excess_def pp_init_f_def pp_init_x_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>incoming u.\n       case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) -\n    (\\<Sum>e\\<in>outgoing u.\n       case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) =\n    (if u = s then \\<Sum>(u, v)\\<in>outgoing s. - c (u, v) else c (s, u))", "apply (cases \"u=s\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. u = s \\<Longrightarrow>\n    (\\<Sum>e\\<in>incoming u.\n       case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) -\n    (\\<Sum>e\\<in>outgoing u.\n       case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) =\n    (if u = s then \\<Sum>(u, v)\\<in>outgoing s. - c (u, v) else c (s, u))\n 2. u \\<noteq> s \\<Longrightarrow>\n    (\\<Sum>e\\<in>incoming u.\n       case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) -\n    (\\<Sum>e\\<in>outgoing u.\n       case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) =\n    (if u = s then \\<Sum>(u, v)\\<in>outgoing s. - c (u, v) else c (s, u))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. u = s \\<Longrightarrow>\n    (\\<Sum>e\\<in>incoming u.\n       case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) -\n    (\\<Sum>e\\<in>outgoing u.\n       case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) =\n    (if u = s then \\<Sum>(u, v)\\<in>outgoing s. - c (u, v) else c (s, u))", "unfolding outgoing_def incoming_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. u = s \\<Longrightarrow>\n    (\\<Sum>e\\<in>{(ua, u) |ua. (ua, u) \\<in> E}.\n       case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) -\n    (\\<Sum>e\\<in>{(u, ua) |ua. (u, ua) \\<in> E}.\n       case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) =\n    (if u = s then \\<Sum>(u, v)\\<in>{(s, u) |u. (s, u) \\<in> E}. - c (u, v)\n     else c (s, u))", "by (auto intro: sum.cong simp: sum_negf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<noteq> s \\<Longrightarrow>\n    (\\<Sum>e\\<in>incoming u.\n       case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) -\n    (\\<Sum>e\\<in>outgoing u.\n       case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) =\n    (if u = s then \\<Sum>(u, v)\\<in>outgoing s. - c (u, v) else c (s, u))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<noteq> s \\<Longrightarrow>\n    (\\<Sum>e\\<in>incoming u.\n       case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) -\n    (\\<Sum>e\\<in>outgoing u.\n       case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) =\n    (if u = s then \\<Sum>(u, v)\\<in>outgoing s. - c (u, v) else c (s, u))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<noteq> s \\<Longrightarrow>\n    (\\<Sum>e\\<in>incoming u.\n       case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) -\n    (\\<Sum>e\\<in>outgoing u.\n       case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) =\n    (if u = s then \\<Sum>(u, v)\\<in>outgoing s. - c (u, v) else c (s, u))", "assume [simp]: \"u\\<noteq>s\""], ["proof (state)\nthis:\n  u \\<noteq> s\n\ngoal (1 subgoal):\n 1. u \\<noteq> s \\<Longrightarrow>\n    (\\<Sum>e\\<in>incoming u.\n       case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) -\n    (\\<Sum>e\\<in>outgoing u.\n       case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) =\n    (if u = s then \\<Sum>(u, v)\\<in>outgoing s. - c (u, v) else c (s, u))", "have [simp]: \n        \"(case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) = 0\" \n        if \"e\\<in>outgoing u\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) = 0", "using that"], ["proof (prove)\nusing this:\n  e \\<in> outgoing u\n\ngoal (1 subgoal):\n 1. (case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) = 0", "by (auto simp: outgoing_def)"], ["proof (state)\nthis:\n  ?e3 \\<in> outgoing u \\<Longrightarrow>\n  (case ?e3 of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) = 0\n\ngoal (1 subgoal):\n 1. u \\<noteq> s \\<Longrightarrow>\n    (\\<Sum>e\\<in>incoming u.\n       case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) -\n    (\\<Sum>e\\<in>outgoing u.\n       case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) =\n    (if u = s then \\<Sum>(u, v)\\<in>outgoing s. - c (u, v) else c (s, u))", "have [simp]: \"(case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) \n        = (if e = (s,u) then c (s,u) else 0)\" \n        if \"e\\<in>incoming u\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) =\n    (if e = (s, u) then c (s, u) else 0)", "using that"], ["proof (prove)\nusing this:\n  e \\<in> incoming u\n\ngoal (1 subgoal):\n 1. (case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) =\n    (if e = (s, u) then c (s, u) else 0)", "by (auto simp: incoming_def split: if_splits)"], ["proof (state)\nthis:\n  ?e3 \\<in> incoming u \\<Longrightarrow>\n  (case ?e3 of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) =\n  (if ?e3 = (s, u) then c (s, u) else 0)\n\ngoal (1 subgoal):\n 1. u \\<noteq> s \\<Longrightarrow>\n    (\\<Sum>e\\<in>incoming u.\n       case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) -\n    (\\<Sum>e\\<in>outgoing u.\n       case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) =\n    (if u = s then \\<Sum>(u, v)\\<in>outgoing s. - c (u, v) else c (s, u))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>incoming u.\n       case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) -\n    (\\<Sum>e\\<in>outgoing u.\n       case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) =\n    (if u = s then \\<Sum>(u, v)\\<in>outgoing s. - c (u, v) else c (s, u))", "by (simp add: sum.delta) (simp add: incoming_def)"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>incoming u.\n     case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) -\n  (\\<Sum>e\\<in>outgoing u.\n     case e of (u, v) \\<Rightarrow> if u = s then c (u, v) else 0) =\n  (if u = s then \\<Sum>(u, v)\\<in>outgoing s. - c (u, v) else c (s, u))\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"pp_init_cf \n  \\<equiv> \\<lambda>(u,v). if (v=s) then c (v,u) else if u=s then 0 else c (u,v)\""], ["", "lemma cf_of_pp_init_f[simp]: \"cf_of pp_init_f = pp_init_cf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cf_of pp_init_f = pp_init_cf", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. cf_of pp_init_f x = pp_init_cf x", "unfolding pp_init_cf_def pp_init_f_def residualGraph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case x of\n        (u, v) \\<Rightarrow>\n          if (u, v) \\<in> E\n          then c (u, v) -\n               (case (u, v) of\n                (u, v) \\<Rightarrow> if u = s then c (u, v) else 0)\n          else if (v, u) \\<in> E\n               then case (v, u) of\n                    (u, v) \\<Rightarrow> if u = s then c (u, v) else 0\n               else 0) =\n       (case x of\n        (u, v) \\<Rightarrow>\n          if v = s then c (v, u) else if u = s then 0 else c (u, v))", "using no_parallel_edge"], ["proof (prove)\nusing this:\n  \\<forall>u v. (u, v) \\<in> E \\<longrightarrow> (v, u) \\<notin> E\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case x of\n        (u, v) \\<Rightarrow>\n          if (u, v) \\<in> E\n          then c (u, v) -\n               (case (u, v) of\n                (u, v) \\<Rightarrow> if u = s then c (u, v) else 0)\n          else if (v, u) \\<in> E\n               then case (v, u) of\n                    (u, v) \\<Rightarrow> if u = s then c (u, v) else 0\n               else 0) =\n       (case x of\n        (u, v) \\<Rightarrow>\n          if v = s then c (v, u) else if u = s then 0 else c (u, v))", "by auto"], ["", "lemma pp_init_x_rel: \"((pp_init_x, pp_init_cf), pp_init_f) \\<in> xf_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((pp_init_x, pp_init_cf), pp_init_f) \\<in> xf_rel", "unfolding xf_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((pp_init_x, pp_init_cf), pp_init_f)\n    \\<in> {((excess f, cf_of f), f) |f. True}", "by auto"], ["", "subsubsection \\<open>Algorithm to Compute Initial Excess and Flow\\<close>"], ["", "definition \"pp_init_xcf2_aux \\<equiv> do {\n  let x=(\\<lambda>_. 0);\n  let cf=c;\n\n  foreach (adjacent_nodes s) (\\<lambda>v (x,cf). do {\n    assert ((s,v)\\<in>E);\n    assert (s \\<noteq> v);\n    let a = cf (s,v);\n    assert (x v = 0);\n    let x = x( s := x s - a, v := a );\n    let cf = cf( (s,v) := 0, (v,s) := a);\n    return (x,cf)\n  }) (x,cf)\n}\""], ["", "lemma pp_init_xcf2_aux_spec: \n  shows \"pp_init_xcf2_aux \\<le> SPEC (\\<lambda>(x,cf). x=pp_init_x \\<and> cf = pp_init_cf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_init_xcf2_aux\n    \\<le> SPEC (\\<lambda>(x, cf). x = pp_init_x \\<and> cf = pp_init_cf)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pp_init_xcf2_aux\n    \\<le> SPEC (\\<lambda>(x, cf). x = pp_init_x \\<and> cf = pp_init_cf)", "have ADJ_S_AUX: \"adjacent_nodes s = {v . (s,v)\\<in>E}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent_nodes s = {v. (s, v) \\<in> E}", "unfolding adjacent_nodes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. E `` {s} \\<union> E\\<inverse> `` {s} = {v. (s, v) \\<in> E}", "using no_incoming_s"], ["proof (prove)\nusing this:\n  \\<forall>u. (u, s) \\<notin> E\n\ngoal (1 subgoal):\n 1. E `` {s} \\<union> E\\<inverse> `` {s} = {v. (s, v) \\<in> E}", "by auto"], ["proof (state)\nthis:\n  adjacent_nodes s = {v. (s, v) \\<in> E}\n\ngoal (1 subgoal):\n 1. pp_init_xcf2_aux\n    \\<le> SPEC (\\<lambda>(x, cf). x = pp_init_x \\<and> cf = pp_init_cf)", "have CSU_AUX: \"c (s,u) = 0\" if \"u\\<notin>adjacent_nodes s\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. c (s, u) = 0", "using that"], ["proof (prove)\nusing this:\n  u \\<notin> adjacent_nodes s\n\ngoal (1 subgoal):\n 1. c (s, u) = 0", "unfolding adjacent_nodes_def"], ["proof (prove)\nusing this:\n  u \\<notin> E `` {s} \\<union> E\\<inverse> `` {s}\n\ngoal (1 subgoal):\n 1. c (s, u) = 0", "by auto"], ["proof (state)\nthis:\n  ?u3 \\<notin> adjacent_nodes s \\<Longrightarrow> c (s, ?u3) = 0\n\ngoal (1 subgoal):\n 1. pp_init_xcf2_aux\n    \\<le> SPEC (\\<lambda>(x, cf). x = pp_init_x \\<and> cf = pp_init_cf)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_init_xcf2_aux\n    \\<le> SPEC (\\<lambda>(x, cf). x = pp_init_x \\<and> cf = pp_init_cf)", "unfolding pp_init_xcf2_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let x = \\<lambda>_. 0; cf = c\n     in foreach (adjacent_nodes s)\n         (\\<lambda>v (x, cf).\n             assert ((s, v) \\<in> E) \\<bind>\n             (\\<lambda>_.\n                 assert (s \\<noteq> v) \\<bind>\n                 (\\<lambda>_.\n                     let a = cf (s, v)\n                     in assert (x v = 0) \\<bind>\n                        (\\<lambda>_.\n                            let x = x(s := x s - a, v := a);\n                                cf = cf((s, v) := 0, (v, s) := a)\n                            in return (x, cf)))))\n         (x, cf))\n    \\<le> SPEC (\\<lambda>(x, cf). x = pp_init_x \\<and> cf = pp_init_cf)", "apply (refine_vcg FOREACH_rule[where I=\"\\<lambda>it (x,cf). \n        x s = (\\<Sum>v\\<in>adjacent_nodes s - it. - c(s,v)) \n      \\<and> (\\<forall>v\\<in>adjacent_nodes s. x v = (if v\\<in>it then 0 else c (s,v)))\n      \\<and> (\\<forall>v\\<in>-insert s (adjacent_nodes s). x v = 0)\n      \\<and> (\\<forall>v\\<in>adjacent_nodes s. \n            if v\\<notin>it then cf (s,v) = 0 \\<and> cf (v,s) = c (s,v) \n            else cf (s,v) = c (s,v) \\<and> cf (v,s) = c (v,s))\n      \\<and> (\\<forall>u v. u\\<noteq>s \\<and> v\\<noteq>s \\<longrightarrow> cf (u,v) = c (u,v) )\n      \\<and> (\\<forall>u. u\\<notin>adjacent_nodes s \\<longrightarrow> cf (u,s) = 0 \\<and> cf (s,u) = 0)\n    \"])"], ["proof (prove)\ngoal (20 subgoals):\n 1. finite (adjacent_nodes s)\n 2. \\<And>x1 x2.\n       (\\<lambda>_. 0, c) = (x1, x2) \\<Longrightarrow>\n       x1 s = (\\<Sum>v\\<in>adjacent_nodes s - adjacent_nodes s. - c (s, v))\n 3. \\<And>x1 x2.\n       (\\<lambda>_. 0, c) = (x1, x2) \\<Longrightarrow>\n       \\<forall>v\\<in>adjacent_nodes s.\n          x1 v = (if v \\<in> adjacent_nodes s then 0 else c (s, v))\n 4. \\<And>x1 x2.\n       (\\<lambda>_. 0, c) = (x1, x2) \\<Longrightarrow>\n       \\<forall>v\\<in>- insert s (adjacent_nodes s). x1 v = 0\n 5. \\<And>x1 x2.\n       (\\<lambda>_. 0, c) = (x1, x2) \\<Longrightarrow>\n       \\<forall>v\\<in>adjacent_nodes s.\n          if v \\<notin> adjacent_nodes s\n          then x2 (s, v) = 0 \\<and> x2 (v, s) = c (s, v)\n          else x2 (s, v) = c (s, v) \\<and> x2 (v, s) = c (v, s)\n 6. \\<And>x1 x2 u v.\n       \\<lbrakk>(\\<lambda>_. 0, c) = (x1, x2);\n        u \\<noteq> s \\<and> v \\<noteq> s\\<rbrakk>\n       \\<Longrightarrow> x2 (u, v) = c (u, v)\n 7. \\<And>x1 x2 u.\n       \\<lbrakk>(\\<lambda>_. 0, c) = (x1, x2);\n        u \\<notin> adjacent_nodes s\\<rbrakk>\n       \\<Longrightarrow> x2 (u, s) = 0\n 8. \\<And>x1 x2 u.\n       \\<lbrakk>(\\<lambda>_. 0, c) = (x1, x2);\n        u \\<notin> adjacent_nodes s\\<rbrakk>\n       \\<Longrightarrow> x2 (s, u) = 0\n 9. \\<And>x it \\<sigma> a b.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> adjacent_nodes s;\n        case \\<sigma> of\n        (x, cf) \\<Rightarrow>\n          x s = (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v)) \\<and>\n          (\\<forall>v\\<in>adjacent_nodes s.\n              x v = (if v \\<in> it then 0 else c (s, v))) \\<and>\n          (\\<forall>v\\<in>- insert s (adjacent_nodes s). x v = 0) \\<and>\n          (\\<forall>v\\<in>adjacent_nodes s.\n              if v \\<notin> it\n              then cf (s, v) = 0 \\<and> cf (v, s) = c (s, v)\n              else cf (s, v) = c (s, v) \\<and> cf (v, s) = c (v, s)) \\<and>\n          (\\<forall>u v.\n              u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n              cf (u, v) = c (u, v)) \\<and>\n          (\\<forall>u.\n              u \\<notin> adjacent_nodes s \\<longrightarrow>\n              cf (u, s) = 0 \\<and> cf (s, u) = 0);\n        \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (s, x) \\<in> E\n 10. \\<And>x it \\<sigma> a b.\n        \\<lbrakk>x \\<in> it; it \\<subseteq> adjacent_nodes s;\n         case \\<sigma> of\n         (x, cf) \\<Rightarrow>\n           x s = (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v)) \\<and>\n           (\\<forall>v\\<in>adjacent_nodes s.\n               x v = (if v \\<in> it then 0 else c (s, v))) \\<and>\n           (\\<forall>v\\<in>- insert s (adjacent_nodes s). x v = 0) \\<and>\n           (\\<forall>v\\<in>adjacent_nodes s.\n               if v \\<notin> it\n               then cf (s, v) = 0 \\<and> cf (v, s) = c (s, v)\n               else cf (s, v) = c (s, v) \\<and> cf (v, s) = c (v, s)) \\<and>\n           (\\<forall>u v.\n               u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n               cf (u, v) = c (u, v)) \\<and>\n           (\\<forall>u.\n               u \\<notin> adjacent_nodes s \\<longrightarrow>\n               cf (u, s) = 0 \\<and> cf (s, u) = 0);\n         \\<sigma> = (a, b); (s, x) \\<in> E\\<rbrakk>\n        \\<Longrightarrow> s \\<noteq> x\nA total of 20 subgoals...", "apply (vc_solve simp: it_step_insert_iff simp: CSU_AUX)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x it aa ba.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> adjacent_nodes s;\n        aa s = (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s.\n           aa v = (if v \\<in> it then 0 else c (s, v));\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). aa v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           if v \\<in> it\n           then ba (s, v) = c (s, v) \\<and> ba (v, s) = c (v, s)\n           else ba (s, v) = 0 \\<and> ba (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           ba (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           ba (u, s) = 0 \\<and> ba (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> (s, x) \\<in> E\n 2. \\<And>x it aa ba.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> adjacent_nodes s; (s, x) \\<in> E;\n        s \\<noteq> x;\n        aa s = (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s.\n           aa v = (if v \\<in> it then 0 else c (s, v));\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). aa v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           if v \\<in> it\n           then ba (s, v) = c (s, v) \\<and> ba (v, s) = c (v, s)\n           else ba (s, v) = 0 \\<and> ba (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           ba (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           ba (u, s) = 0 \\<and> ba (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> aa x = 0\n 3. \\<And>x it aa ba.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> adjacent_nodes s; (s, x) \\<in> E;\n        s \\<noteq> x; aa x = 0;\n        aa s = (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s.\n           aa v = (if v \\<in> it then 0 else c (s, v));\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). aa v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           if v \\<in> it\n           then ba (s, v) = c (s, v) \\<and> ba (v, s) = c (v, s)\n           else ba (s, v) = 0 \\<and> ba (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           ba (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           ba (u, s) = 0 \\<and> ba (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> ba (s, x) = c (s, x)\n 4. \\<And>x it aa ba v.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> adjacent_nodes s; (s, x) \\<in> E;\n        s \\<noteq> x; aa x = 0; v \\<in> adjacent_nodes s;\n        aa s = (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s.\n           aa v = (if v \\<in> it then 0 else c (s, v));\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). aa v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           if v \\<in> it\n           then ba (s, v) = c (s, v) \\<and> ba (v, s) = c (v, s)\n           else ba (s, v) = 0 \\<and> ba (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           ba (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           ba (u, s) = 0 \\<and> ba (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> (v = s \\<longrightarrow>\n                          (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v)) =\n                          ba (s, x)) \\<and>\n                         (v \\<noteq> s \\<longrightarrow>\n                          v = x \\<longrightarrow> ba (s, x) = c (s, x))\n 5. \\<And>x it aa ba v.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> adjacent_nodes s; (s, x) \\<in> E;\n        s \\<noteq> x; aa x = 0;\n        (if v = x then ba (s, x)\n         else (aa(s := (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v)) -\n                       ba (s, x)))\n               v) \\<noteq>\n        0;\n        v \\<notin> adjacent_nodes s;\n        aa s = (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s.\n           aa v = (if v \\<in> it then 0 else c (s, v));\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). aa v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           if v \\<in> it\n           then ba (s, v) = c (s, v) \\<and> ba (v, s) = c (v, s)\n           else ba (s, v) = 0 \\<and> ba (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           ba (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           ba (u, s) = 0 \\<and> ba (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> v = s\n 6. \\<And>x1 x2.\n       \\<lbrakk>x1 s = (\\<Sum>v\\<in>adjacent_nodes s. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s. x1 v = c (s, v);\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). x1 v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           x2 (s, v) = 0 \\<and> x2 (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           x2 (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           x2 (u, s) = 0 \\<and> x2 (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> x1 = pp_init_x\n 7. \\<And>x1 x2.\n       \\<lbrakk>x1 s = (\\<Sum>v\\<in>adjacent_nodes s. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s. x1 v = c (s, v);\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). x1 v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           x2 (s, v) = 0 \\<and> x2 (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           x2 (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           x2 (u, s) = 0 \\<and> x2 (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> x2 = pp_init_cf", "subgoal for v it"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> it; it \\<subseteq> adjacent_nodes s;\n     aa_ s = (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v));\n     \\<forall>v\\<in>adjacent_nodes s.\n        aa_ v = (if v \\<in> it then 0 else c (s, v));\n     \\<forall>v\\<in>- insert s (adjacent_nodes s). aa_ v = 0;\n     \\<forall>v\\<in>adjacent_nodes s.\n        if v \\<in> it\n        then ba_ (s, v) = c (s, v) \\<and> ba_ (v, s) = c (v, s)\n        else ba_ (s, v) = 0 \\<and> ba_ (v, s) = c (s, v);\n     \\<forall>u v.\n        u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n        ba_ (u, v) = c (u, v);\n     \\<forall>u.\n        u \\<notin> adjacent_nodes s \\<longrightarrow>\n        ba_ (u, s) = 0 \\<and> ba_ (s, u) = 0\\<rbrakk>\n    \\<Longrightarrow> (s, v) \\<in> E", "by (auto simp: ADJ_S_AUX)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x it aa ba.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> adjacent_nodes s; (s, x) \\<in> E;\n        s \\<noteq> x;\n        aa s = (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s.\n           aa v = (if v \\<in> it then 0 else c (s, v));\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). aa v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           if v \\<in> it\n           then ba (s, v) = c (s, v) \\<and> ba (v, s) = c (v, s)\n           else ba (s, v) = 0 \\<and> ba (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           ba (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           ba (u, s) = 0 \\<and> ba (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> aa x = 0\n 2. \\<And>x it aa ba.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> adjacent_nodes s; (s, x) \\<in> E;\n        s \\<noteq> x; aa x = 0;\n        aa s = (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s.\n           aa v = (if v \\<in> it then 0 else c (s, v));\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). aa v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           if v \\<in> it\n           then ba (s, v) = c (s, v) \\<and> ba (v, s) = c (v, s)\n           else ba (s, v) = 0 \\<and> ba (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           ba (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           ba (u, s) = 0 \\<and> ba (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> ba (s, x) = c (s, x)\n 3. \\<And>x it aa ba v.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> adjacent_nodes s; (s, x) \\<in> E;\n        s \\<noteq> x; aa x = 0; v \\<in> adjacent_nodes s;\n        aa s = (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s.\n           aa v = (if v \\<in> it then 0 else c (s, v));\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). aa v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           if v \\<in> it\n           then ba (s, v) = c (s, v) \\<and> ba (v, s) = c (v, s)\n           else ba (s, v) = 0 \\<and> ba (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           ba (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           ba (u, s) = 0 \\<and> ba (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> (v = s \\<longrightarrow>\n                          (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v)) =\n                          ba (s, x)) \\<and>\n                         (v \\<noteq> s \\<longrightarrow>\n                          v = x \\<longrightarrow> ba (s, x) = c (s, x))\n 4. \\<And>x it aa ba v.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> adjacent_nodes s; (s, x) \\<in> E;\n        s \\<noteq> x; aa x = 0;\n        (if v = x then ba (s, x)\n         else (aa(s := (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v)) -\n                       ba (s, x)))\n               v) \\<noteq>\n        0;\n        v \\<notin> adjacent_nodes s;\n        aa s = (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s.\n           aa v = (if v \\<in> it then 0 else c (s, v));\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). aa v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           if v \\<in> it\n           then ba (s, v) = c (s, v) \\<and> ba (v, s) = c (v, s)\n           else ba (s, v) = 0 \\<and> ba (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           ba (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           ba (u, s) = 0 \\<and> ba (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> v = s\n 5. \\<And>x1 x2.\n       \\<lbrakk>x1 s = (\\<Sum>v\\<in>adjacent_nodes s. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s. x1 v = c (s, v);\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). x1 v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           x2 (s, v) = 0 \\<and> x2 (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           x2 (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           x2 (u, s) = 0 \\<and> x2 (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> x1 = pp_init_x\n 6. \\<And>x1 x2.\n       \\<lbrakk>x1 s = (\\<Sum>v\\<in>adjacent_nodes s. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s. x1 v = c (s, v);\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). x1 v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           x2 (s, v) = 0 \\<and> x2 (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           x2 (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           x2 (u, s) = 0 \\<and> x2 (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> x2 = pp_init_cf", "subgoal for u it _ v"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> it; it \\<subseteq> adjacent_nodes s; (s, u) \\<in> E;\n     s \\<noteq> u; aa_ s = (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v));\n     \\<forall>v\\<in>adjacent_nodes s.\n        aa_ v = (if v \\<in> it then 0 else c (s, v));\n     \\<forall>v\\<in>- insert s (adjacent_nodes s). aa_ v = 0;\n     \\<forall>va\\<in>adjacent_nodes s.\n        if va \\<in> it\n        then v (s, va) = c (s, va) \\<and> v (va, s) = c (va, s)\n        else v (s, va) = 0 \\<and> v (va, s) = c (s, va);\n     \\<forall>u va.\n        u \\<noteq> s \\<and> va \\<noteq> s \\<longrightarrow>\n        v (u, va) = c (u, va);\n     \\<forall>u.\n        u \\<notin> adjacent_nodes s \\<longrightarrow>\n        v (u, s) = 0 \\<and> v (s, u) = 0\\<rbrakk>\n    \\<Longrightarrow> aa_ u = 0", "by (auto split: if_splits)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x it aa ba.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> adjacent_nodes s; (s, x) \\<in> E;\n        s \\<noteq> x; aa x = 0;\n        aa s = (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s.\n           aa v = (if v \\<in> it then 0 else c (s, v));\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). aa v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           if v \\<in> it\n           then ba (s, v) = c (s, v) \\<and> ba (v, s) = c (v, s)\n           else ba (s, v) = 0 \\<and> ba (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           ba (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           ba (u, s) = 0 \\<and> ba (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> ba (s, x) = c (s, x)\n 2. \\<And>x it aa ba v.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> adjacent_nodes s; (s, x) \\<in> E;\n        s \\<noteq> x; aa x = 0; v \\<in> adjacent_nodes s;\n        aa s = (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s.\n           aa v = (if v \\<in> it then 0 else c (s, v));\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). aa v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           if v \\<in> it\n           then ba (s, v) = c (s, v) \\<and> ba (v, s) = c (v, s)\n           else ba (s, v) = 0 \\<and> ba (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           ba (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           ba (u, s) = 0 \\<and> ba (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> (v = s \\<longrightarrow>\n                          (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v)) =\n                          ba (s, x)) \\<and>\n                         (v \\<noteq> s \\<longrightarrow>\n                          v = x \\<longrightarrow> ba (s, x) = c (s, x))\n 3. \\<And>x it aa ba v.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> adjacent_nodes s; (s, x) \\<in> E;\n        s \\<noteq> x; aa x = 0;\n        (if v = x then ba (s, x)\n         else (aa(s := (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v)) -\n                       ba (s, x)))\n               v) \\<noteq>\n        0;\n        v \\<notin> adjacent_nodes s;\n        aa s = (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s.\n           aa v = (if v \\<in> it then 0 else c (s, v));\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). aa v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           if v \\<in> it\n           then ba (s, v) = c (s, v) \\<and> ba (v, s) = c (v, s)\n           else ba (s, v) = 0 \\<and> ba (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           ba (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           ba (u, s) = 0 \\<and> ba (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> v = s\n 4. \\<And>x1 x2.\n       \\<lbrakk>x1 s = (\\<Sum>v\\<in>adjacent_nodes s. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s. x1 v = c (s, v);\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). x1 v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           x2 (s, v) = 0 \\<and> x2 (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           x2 (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           x2 (u, s) = 0 \\<and> x2 (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> x1 = pp_init_x\n 5. \\<And>x1 x2.\n       \\<lbrakk>x1 s = (\\<Sum>v\\<in>adjacent_nodes s. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s. x1 v = c (s, v);\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). x1 v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           x2 (s, v) = 0 \\<and> x2 (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           x2 (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           x2 (u, s) = 0 \\<and> x2 (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> x2 = pp_init_cf", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<in> it_; it_ \\<subseteq> adjacent_nodes s;\n     (s, x_) \\<in> E; s \\<noteq> x_; aa_ x_ = 0;\n     aa_ s = (\\<Sum>v\\<in>adjacent_nodes s - it_. - c (s, v));\n     \\<forall>v\\<in>adjacent_nodes s.\n        aa_ v = (if v \\<in> it_ then 0 else c (s, v));\n     \\<forall>v\\<in>- insert s (adjacent_nodes s). aa_ v = 0;\n     \\<forall>v\\<in>adjacent_nodes s.\n        if v \\<in> it_\n        then ba_ (s, v) = c (s, v) \\<and> ba_ (v, s) = c (v, s)\n        else ba_ (s, v) = 0 \\<and> ba_ (v, s) = c (s, v);\n     \\<forall>u v.\n        u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n        ba_ (u, v) = c (u, v);\n     \\<forall>u.\n        u \\<notin> adjacent_nodes s \\<longrightarrow>\n        ba_ (u, s) = 0 \\<and> ba_ (s, u) = 0\\<rbrakk>\n    \\<Longrightarrow> ba_ (s, x_) = c (s, x_)", "by (auto simp: ADJ_S_AUX)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x it aa ba v.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> adjacent_nodes s; (s, x) \\<in> E;\n        s \\<noteq> x; aa x = 0; v \\<in> adjacent_nodes s;\n        aa s = (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s.\n           aa v = (if v \\<in> it then 0 else c (s, v));\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). aa v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           if v \\<in> it\n           then ba (s, v) = c (s, v) \\<and> ba (v, s) = c (v, s)\n           else ba (s, v) = 0 \\<and> ba (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           ba (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           ba (u, s) = 0 \\<and> ba (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> (v = s \\<longrightarrow>\n                          (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v)) =\n                          ba (s, x)) \\<and>\n                         (v \\<noteq> s \\<longrightarrow>\n                          v = x \\<longrightarrow> ba (s, x) = c (s, x))\n 2. \\<And>x it aa ba v.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> adjacent_nodes s; (s, x) \\<in> E;\n        s \\<noteq> x; aa x = 0;\n        (if v = x then ba (s, x)\n         else (aa(s := (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v)) -\n                       ba (s, x)))\n               v) \\<noteq>\n        0;\n        v \\<notin> adjacent_nodes s;\n        aa s = (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s.\n           aa v = (if v \\<in> it then 0 else c (s, v));\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). aa v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           if v \\<in> it\n           then ba (s, v) = c (s, v) \\<and> ba (v, s) = c (v, s)\n           else ba (s, v) = 0 \\<and> ba (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           ba (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           ba (u, s) = 0 \\<and> ba (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> v = s\n 3. \\<And>x1 x2.\n       \\<lbrakk>x1 s = (\\<Sum>v\\<in>adjacent_nodes s. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s. x1 v = c (s, v);\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). x1 v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           x2 (s, v) = 0 \\<and> x2 (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           x2 (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           x2 (u, s) = 0 \\<and> x2 (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> x1 = pp_init_x\n 4. \\<And>x1 x2.\n       \\<lbrakk>x1 s = (\\<Sum>v\\<in>adjacent_nodes s. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s. x1 v = c (s, v);\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). x1 v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           x2 (s, v) = 0 \\<and> x2 (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           x2 (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           x2 (u, s) = 0 \\<and> x2 (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> x2 = pp_init_cf", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<in> it_; it_ \\<subseteq> adjacent_nodes s;\n     (s, x_) \\<in> E; s \\<noteq> x_; aa_ x_ = 0; v_ \\<in> adjacent_nodes s;\n     aa_ s = (\\<Sum>v\\<in>adjacent_nodes s - it_. - c (s, v));\n     \\<forall>v\\<in>adjacent_nodes s.\n        aa_ v = (if v \\<in> it_ then 0 else c (s, v));\n     \\<forall>v\\<in>- insert s (adjacent_nodes s). aa_ v = 0;\n     \\<forall>v\\<in>adjacent_nodes s.\n        if v \\<in> it_\n        then ba_ (s, v) = c (s, v) \\<and> ba_ (v, s) = c (v, s)\n        else ba_ (s, v) = 0 \\<and> ba_ (v, s) = c (s, v);\n     \\<forall>u v.\n        u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n        ba_ (u, v) = c (u, v);\n     \\<forall>u.\n        u \\<notin> adjacent_nodes s \\<longrightarrow>\n        ba_ (u, s) = 0 \\<and> ba_ (s, u) = 0\\<rbrakk>\n    \\<Longrightarrow> (v_ = s \\<longrightarrow>\n                       (\\<Sum>v\\<in>adjacent_nodes s - it_. - c (s, v)) =\n                       ba_ (s, x_)) \\<and>\n                      (v_ \\<noteq> s \\<longrightarrow>\n                       v_ = x_ \\<longrightarrow> ba_ (s, x_) = c (s, x_))", "by (auto simp: ADJ_S_AUX)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it aa ba v.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> adjacent_nodes s; (s, x) \\<in> E;\n        s \\<noteq> x; aa x = 0;\n        (if v = x then ba (s, x)\n         else (aa(s := (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v)) -\n                       ba (s, x)))\n               v) \\<noteq>\n        0;\n        v \\<notin> adjacent_nodes s;\n        aa s = (\\<Sum>v\\<in>adjacent_nodes s - it. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s.\n           aa v = (if v \\<in> it then 0 else c (s, v));\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). aa v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           if v \\<in> it\n           then ba (s, v) = c (s, v) \\<and> ba (v, s) = c (v, s)\n           else ba (s, v) = 0 \\<and> ba (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           ba (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           ba (u, s) = 0 \\<and> ba (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> v = s\n 2. \\<And>x1 x2.\n       \\<lbrakk>x1 s = (\\<Sum>v\\<in>adjacent_nodes s. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s. x1 v = c (s, v);\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). x1 v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           x2 (s, v) = 0 \\<and> x2 (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           x2 (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           x2 (u, s) = 0 \\<and> x2 (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> x1 = pp_init_x\n 3. \\<And>x1 x2.\n       \\<lbrakk>x1 s = (\\<Sum>v\\<in>adjacent_nodes s. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s. x1 v = c (s, v);\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). x1 v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           x2 (s, v) = 0 \\<and> x2 (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           x2 (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           x2 (u, s) = 0 \\<and> x2 (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> x2 = pp_init_cf", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<in> it_; it_ \\<subseteq> adjacent_nodes s;\n     (s, x_) \\<in> E; s \\<noteq> x_; aa_ x_ = 0;\n     (if v_ = x_ then ba_ (s, x_)\n      else (aa_(s := (\\<Sum>v\\<in>adjacent_nodes s - it_. - c (s, v)) -\n                     ba_ (s, x_)))\n            v_) \\<noteq>\n     0;\n     v_ \\<notin> adjacent_nodes s;\n     aa_ s = (\\<Sum>v\\<in>adjacent_nodes s - it_. - c (s, v));\n     \\<forall>v\\<in>adjacent_nodes s.\n        aa_ v = (if v \\<in> it_ then 0 else c (s, v));\n     \\<forall>v\\<in>- insert s (adjacent_nodes s). aa_ v = 0;\n     \\<forall>v\\<in>adjacent_nodes s.\n        if v \\<in> it_\n        then ba_ (s, v) = c (s, v) \\<and> ba_ (v, s) = c (v, s)\n        else ba_ (s, v) = 0 \\<and> ba_ (v, s) = c (s, v);\n     \\<forall>u v.\n        u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n        ba_ (u, v) = c (u, v);\n     \\<forall>u.\n        u \\<notin> adjacent_nodes s \\<longrightarrow>\n        ba_ (u, s) = 0 \\<and> ba_ (s, u) = 0\\<rbrakk>\n    \\<Longrightarrow> v_ = s", "by (auto split: if_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>x1 s = (\\<Sum>v\\<in>adjacent_nodes s. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s. x1 v = c (s, v);\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). x1 v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           x2 (s, v) = 0 \\<and> x2 (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           x2 (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           x2 (u, s) = 0 \\<and> x2 (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> x1 = pp_init_x\n 2. \\<And>x1 x2.\n       \\<lbrakk>x1 s = (\\<Sum>v\\<in>adjacent_nodes s. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s. x1 v = c (s, v);\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). x1 v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           x2 (s, v) = 0 \\<and> x2 (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           x2 (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           x2 (u, s) = 0 \\<and> x2 (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> x2 = pp_init_cf", "(* TODO: This proof is still a bit fragile *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>x1 s = (\\<Sum>v\\<in>adjacent_nodes s. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s. x1 v = c (s, v);\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). x1 v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           x2 (s, v) = 0 \\<and> x2 (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           x2 (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           x2 (u, s) = 0 \\<and> x2 (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> x1 = pp_init_x\n 2. \\<And>x1 x2.\n       \\<lbrakk>x1 s = (\\<Sum>v\\<in>adjacent_nodes s. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s. x1 v = c (s, v);\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). x1 v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           x2 (s, v) = 0 \\<and> x2 (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           x2 (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           x2 (u, s) = 0 \\<and> x2 (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> x2 = pp_init_cf", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x s = (\\<Sum>v\\<in>adjacent_nodes s. - c (s, v));\n     \\<forall>v\\<in>adjacent_nodes s. x v = c (s, v);\n     \\<forall>v\\<in>- insert s (adjacent_nodes s). x v = 0;\n     \\<forall>v\\<in>adjacent_nodes s.\n        x2_ (s, v) = 0 \\<and> x2_ (v, s) = c (s, v);\n     \\<forall>u v.\n        u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n        x2_ (u, v) = c (u, v);\n     \\<forall>u.\n        u \\<notin> adjacent_nodes s \\<longrightarrow>\n        x2_ (u, s) = 0 \\<and> x2_ (s, u) = 0\\<rbrakk>\n    \\<Longrightarrow> x = pp_init_x", "unfolding pp_init_x_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x s = (\\<Sum>v\\<in>adjacent_nodes s. - c (s, v));\n     \\<forall>v\\<in>adjacent_nodes s. x v = c (s, v);\n     \\<forall>v\\<in>- insert s (adjacent_nodes s). x v = 0;\n     \\<forall>v\\<in>adjacent_nodes s.\n        x2_ (s, v) = 0 \\<and> x2_ (v, s) = c (s, v);\n     \\<forall>u v.\n        u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n        x2_ (u, v) = c (u, v);\n     \\<forall>u.\n        u \\<notin> adjacent_nodes s \\<longrightarrow>\n        x2_ (u, s) = 0 \\<and> x2_ (s, u) = 0\\<rbrakk>\n    \\<Longrightarrow> x =\n                      (\\<lambda>u.\n                          if u = s\n                          then \\<Sum>(u, v)\\<in>outgoing s. - c (u, v)\n                          else c (s, u))", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>x s = (\\<Sum>v\\<in>adjacent_nodes s. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s. x v = c (s, v);\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). x v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           x2_ (s, v) = 0 \\<and> x2_ (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           x2_ (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           x2_ (u, s) = 0 \\<and> x2_ (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> x u =\n                         (if u = s\n                          then \\<Sum>(u, v)\\<in>outgoing s. - c (u, v)\n                          else c (s, u))", "subgoal for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x s = (\\<Sum>v\\<in>adjacent_nodes s. - c (s, v));\n     \\<forall>v\\<in>adjacent_nodes s. x v = c (s, v);\n     \\<forall>v\\<in>- insert s (adjacent_nodes s). x v = 0;\n     \\<forall>v\\<in>adjacent_nodes s.\n        x2_ (s, v) = 0 \\<and> x2_ (v, s) = c (s, v);\n     \\<forall>u v.\n        u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n        x2_ (u, v) = c (u, v);\n     \\<forall>u.\n        u \\<notin> adjacent_nodes s \\<longrightarrow>\n        x2_ (u, s) = 0 \\<and> x2_ (s, u) = 0\\<rbrakk>\n    \\<Longrightarrow> x u =\n                      (if u = s then \\<Sum>(u, v)\\<in>outgoing s. - c (u, v)\n                       else c (s, u))", "apply (clarsimp simp: ADJ_S_AUX outgoing_def; intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x s = (\\<Sum>v | (s, v) \\<in> E. - c (s, v));\n     \\<forall>v. (s, v) \\<in> E \\<longrightarrow> x v = c (s, v);\n     \\<forall>v\\<in>- insert s {v. (s, v) \\<in> E}. x v = 0;\n     \\<forall>v.\n        (s, v) \\<in> E \\<longrightarrow>\n        x2_ (s, v) = 0 \\<and> x2_ (v, s) = c (s, v);\n     \\<forall>u v.\n        u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n        x2_ (u, v) = c (u, v);\n     \\<forall>u.\n        (s, u) \\<notin> E \\<longrightarrow>\n        x2_ (u, s) = 0 \\<and> x2_ (s, u) = 0\\<rbrakk>\n    \\<Longrightarrow> u = s \\<longrightarrow>\n                      (\\<Sum>v | (s, v) \\<in> E. - c (s, v)) =\n                      (\\<Sum>x\\<in>{(s, u) |u. (s, u) \\<in> E}. - c x)\n 2. \\<lbrakk>x s = (\\<Sum>v | (s, v) \\<in> E. - c (s, v));\n     \\<forall>v. (s, v) \\<in> E \\<longrightarrow> x v = c (s, v);\n     \\<forall>v\\<in>- insert s {v. (s, v) \\<in> E}. x v = 0;\n     \\<forall>v.\n        (s, v) \\<in> E \\<longrightarrow>\n        x2_ (s, v) = 0 \\<and> x2_ (v, s) = c (s, v);\n     \\<forall>u v.\n        u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n        x2_ (u, v) = c (u, v);\n     \\<forall>u.\n        (s, u) \\<notin> E \\<longrightarrow>\n        x2_ (u, s) = 0 \\<and> x2_ (s, u) = 0\\<rbrakk>\n    \\<Longrightarrow> u \\<noteq> s \\<longrightarrow> x u = c (s, u)", "applyS (auto intro!: sum.reindex_cong[where l=snd] intro: inj_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x s = (\\<Sum>v | (s, v) \\<in> E. - c (s, v));\n     \\<forall>v. (s, v) \\<in> E \\<longrightarrow> x v = c (s, v);\n     \\<forall>v\\<in>- insert s {v. (s, v) \\<in> E}. x v = 0;\n     \\<forall>v.\n        (s, v) \\<in> E \\<longrightarrow>\n        x2_ (s, v) = 0 \\<and> x2_ (v, s) = c (s, v);\n     \\<forall>u v.\n        u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n        x2_ (u, v) = c (u, v);\n     \\<forall>u.\n        (s, u) \\<notin> E \\<longrightarrow>\n        x2_ (u, s) = 0 \\<and> x2_ (s, u) = 0\\<rbrakk>\n    \\<Longrightarrow> u \\<noteq> s \\<longrightarrow> x u = c (s, u)", "applyS (metis (mono_tags, lifting) Compl_iff Graph.zero_cap_simp insertE mem_Collect_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>x1 s = (\\<Sum>v\\<in>adjacent_nodes s. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s. x1 v = c (s, v);\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). x1 v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           x2 (s, v) = 0 \\<and> x2 (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           x2 (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           x2 (u, s) = 0 \\<and> x2 (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> x2 = pp_init_cf", "subgoal for x cf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x s = (\\<Sum>v\\<in>adjacent_nodes s. - c (s, v));\n     \\<forall>v\\<in>adjacent_nodes s. x v = c (s, v);\n     \\<forall>v\\<in>- insert s (adjacent_nodes s). x v = 0;\n     \\<forall>v\\<in>adjacent_nodes s.\n        cf (s, v) = 0 \\<and> cf (v, s) = c (s, v);\n     \\<forall>u v.\n        u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n        cf (u, v) = c (u, v);\n     \\<forall>u.\n        u \\<notin> adjacent_nodes s \\<longrightarrow>\n        cf (u, s) = 0 \\<and> cf (s, u) = 0\\<rbrakk>\n    \\<Longrightarrow> cf = pp_init_cf", "unfolding pp_init_cf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x s = (\\<Sum>v\\<in>adjacent_nodes s. - c (s, v));\n     \\<forall>v\\<in>adjacent_nodes s. x v = c (s, v);\n     \\<forall>v\\<in>- insert s (adjacent_nodes s). x v = 0;\n     \\<forall>v\\<in>adjacent_nodes s.\n        cf (s, v) = 0 \\<and> cf (v, s) = c (s, v);\n     \\<forall>u v.\n        u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n        cf (u, v) = c (u, v);\n     \\<forall>u.\n        u \\<notin> adjacent_nodes s \\<longrightarrow>\n        cf (u, s) = 0 \\<and> cf (s, u) = 0\\<rbrakk>\n    \\<Longrightarrow> cf =\n                      (\\<lambda>(u, v).\n                          if v = s then c (v, u)\n                          else if u = s then 0 else c (u, v))", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>x s = (\\<Sum>v\\<in>adjacent_nodes s. - c (s, v));\n        \\<forall>v\\<in>adjacent_nodes s. x v = c (s, v);\n        \\<forall>v\\<in>- insert s (adjacent_nodes s). x v = 0;\n        \\<forall>v\\<in>adjacent_nodes s.\n           cf (s, v) = 0 \\<and> cf (v, s) = c (s, v);\n        \\<forall>u v.\n           u \\<noteq> s \\<and> v \\<noteq> s \\<longrightarrow>\n           cf (u, v) = c (u, v);\n        \\<forall>u.\n           u \\<notin> adjacent_nodes s \\<longrightarrow>\n           cf (u, s) = 0 \\<and> cf (s, u) = 0\\<rbrakk>\n       \\<Longrightarrow> cf xa =\n                         (case xa of\n                          (u, v) \\<Rightarrow>\n                            if v = s then c (v, u)\n                            else if u = s then 0 else c (u, v))", "apply (clarsimp; auto simp: CSU_AUX)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pp_init_xcf2_aux\n  \\<le> SPEC (\\<lambda>(x, cf). x = pp_init_x \\<and> cf = pp_init_cf)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"pp_init_xcf2 am \\<equiv> do {\n  x \\<leftarrow> x_init;\n  cf \\<leftarrow> cf_init;\n\n  assert (s\\<in>V);\n  adj \\<leftarrow> am_get am s;\n  nfoldli adj (\\<lambda>_. True) (\\<lambda>v (x,cf). do {\n    assert ((s,v)\\<in>E);\n    assert (s \\<noteq> v);\n    a \\<leftarrow> cf_get cf (s,v);\n    x \\<leftarrow> x_add x s (-a);\n    x \\<leftarrow> x_add x v a;\n    cf \\<leftarrow> cf_set cf (s,v) 0; \n    cf \\<leftarrow> cf_set cf (v,s) a; \n    return (x,cf)\n  }) (x,cf)\n}\""], ["", "lemma pp_init_xcf2_refine_aux:\n  assumes AM: \"is_adj_map am\"  \n  shows \"pp_init_xcf2 am \\<le> \\<Down>Id (pp_init_xcf2_aux)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_init_xcf2 am \\<le> \\<Down> Id pp_init_xcf2_aux", "unfolding pp_init_xcf2_def pp_init_xcf2_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_init \\<bind>\n    (\\<lambda>x.\n        cf_init \\<bind>\n        (\\<lambda>cf.\n            assert (s \\<in> V) \\<bind>\n            (\\<lambda>_.\n                am_get am s \\<bind>\n                (\\<lambda>adj.\n                    nfoldli adj (\\<lambda>_. True)\n                     (\\<lambda>v (x, cf).\n                         assert ((s, v) \\<in> E) \\<bind>\n                         (\\<lambda>_.\n                             assert (s \\<noteq> v) \\<bind>\n                             (\\<lambda>_.\n                                 cf_get cf (s, v) \\<bind>\n                                 (\\<lambda>a.\n                                     x_add x s (- a) \\<bind>\n                                     (\\<lambda>x.\n   x_add x v a \\<bind>\n   (\\<lambda>x.\n       cf_set cf (s, v) 0 \\<bind>\n       (\\<lambda>cf.\n           cf_set cf (v, s) a \\<bind> (\\<lambda>cf. return (x, cf)))))))))\n                     (x, cf)))))\n    \\<le> \\<Down> Id\n           (let x = \\<lambda>_. 0; cf = c\n            in foreach (adjacent_nodes s)\n                (\\<lambda>v (x, cf).\n                    assert ((s, v) \\<in> E) \\<bind>\n                    (\\<lambda>_.\n                        assert (s \\<noteq> v) \\<bind>\n                        (\\<lambda>_.\n                            let a = cf (s, v)\n                            in assert (x v = 0) \\<bind>\n                               (\\<lambda>_.\n                                   let x = x(s := x s - a, v := a);\n cf = cf((s, v) := 0, (v, s) := a)\n                                   in return (x, cf)))))\n                (x, cf))", "unfolding x_init_def cf_init_def am_get_def cf_get_def cf_set_def x_add_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. return (\\<lambda>_. 0) \\<bind>\n    (\\<lambda>x.\n        return (op_mtx_new c) \\<bind>\n        (\\<lambda>cf.\n            assert (s \\<in> V) \\<bind>\n            (\\<lambda>_.\n                assert (s \\<in> V) \\<bind>\n                (\\<lambda>_. return (am s)) \\<bind>\n                (\\<lambda>adj.\n                    nfoldli adj (\\<lambda>_. True)\n                     (\\<lambda>v (x, cf).\n                         assert ((s, v) \\<in> E) \\<bind>\n                         (\\<lambda>_.\n                             assert (s \\<noteq> v) \\<bind>\n                             (\\<lambda>_.\n                                 assert\n                                  ((s, v)\n                                   \\<in> E \\<union> E\\<inverse>) \\<bind>\n                                 (\\<lambda>_. return (cf (s, v))) \\<bind>\n                                 (\\<lambda>a.\n                                     assert (s \\<in> V) \\<bind>\n                                     (\\<lambda>_.\n   return (x(s := x s + - a))) \\<bind>\n                                     (\\<lambda>x.\n   assert (v \\<in> V) \\<bind> (\\<lambda>_. return (x(v := x v + a))) \\<bind>\n   (\\<lambda>x.\n       assert ((s, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n       (\\<lambda>_. return (cf((s, v) := 0))) \\<bind>\n       (\\<lambda>cf.\n           assert ((v, s) \\<in> E \\<union> E\\<inverse>) \\<bind>\n           (\\<lambda>_. return (cf((v, s) := a))) \\<bind>\n           (\\<lambda>cf. return (x, cf)))))))))\n                     (x, cf)))))\n    \\<le> \\<Down> Id\n           (let x = \\<lambda>_. 0; cf = c\n            in foreach (adjacent_nodes s)\n                (\\<lambda>v (x, cf).\n                    assert ((s, v) \\<in> E) \\<bind>\n                    (\\<lambda>_.\n                        assert (s \\<noteq> v) \\<bind>\n                        (\\<lambda>_.\n                            let a = cf (s, v)\n                            in assert (x v = 0) \\<bind>\n                               (\\<lambda>_.\n                                   let x = x(s := x s - a, v := a);\n cf = cf((s, v) := 0, (v, s) := a)\n                                   in return (x, cf)))))\n                (x, cf))", "apply (simp only: nres_monad_laws)"], ["proof (prove)\ngoal (1 subgoal):\n 1. assert (s \\<in> V) \\<bind>\n    (\\<lambda>_.\n        assert (s \\<in> V) \\<bind>\n        (\\<lambda>x.\n            nfoldli (am s) (\\<lambda>_. True)\n             (\\<lambda>v (x, cf).\n                 assert ((s, v) \\<in> E) \\<bind>\n                 (\\<lambda>_.\n                     assert (s \\<noteq> v) \\<bind>\n                     (\\<lambda>_.\n                         assert\n                          ((s, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n                         (\\<lambda>xa.\n                             assert (s \\<in> V) \\<bind>\n                             (\\<lambda>xa.\n                                 assert (v \\<in> V) \\<bind>\n                                 (\\<lambda>xa.\n                                     assert\n((s, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n                                     (\\<lambda>xa.\n   assert ((v, s) \\<in> E \\<union> E\\<inverse>) \\<bind>\n   (\\<lambda>xa.\n       return\n        (x(s := x s + - cf (s, v),\n           v := (x(s := x s + - cf (s, v))) v + cf (s, v)),\n         cf((s, v) := 0, (v, s) := cf (s, v)))))))))))\n             (\\<lambda>_. 0, op_mtx_new c)))\n    \\<le> \\<Down> Id\n           (let x = \\<lambda>_. 0; cf = c\n            in foreach (adjacent_nodes s)\n                (\\<lambda>v (x, cf).\n                    assert ((s, v) \\<in> E) \\<bind>\n                    (\\<lambda>_.\n                        assert (s \\<noteq> v) \\<bind>\n                        (\\<lambda>_.\n                            let a = cf (s, v)\n                            in assert (x v = 0) \\<bind>\n                               (\\<lambda>_.\n                                   let x = x(s := x s - a, v := a);\n cf = cf((s, v) := 0, (v, s) := a)\n                                   in return (x, cf)))))\n                (x, cf))", "supply LFO_refine[OF am_to_adj_nodes_refine[OF AM], refine]"], ["proof (prove)\ngoal (1 subgoal):\n 1. assert (s \\<in> V) \\<bind>\n    (\\<lambda>_.\n        assert (s \\<in> V) \\<bind>\n        (\\<lambda>x.\n            nfoldli (am s) (\\<lambda>_. True)\n             (\\<lambda>v (x, cf).\n                 assert ((s, v) \\<in> E) \\<bind>\n                 (\\<lambda>_.\n                     assert (s \\<noteq> v) \\<bind>\n                     (\\<lambda>_.\n                         assert\n                          ((s, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n                         (\\<lambda>xa.\n                             assert (s \\<in> V) \\<bind>\n                             (\\<lambda>xa.\n                                 assert (v \\<in> V) \\<bind>\n                                 (\\<lambda>xa.\n                                     assert\n((s, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n                                     (\\<lambda>xa.\n   assert ((v, s) \\<in> E \\<union> E\\<inverse>) \\<bind>\n   (\\<lambda>xa.\n       return\n        (x(s := x s + - cf (s, v),\n           v := (x(s := x s + - cf (s, v))) v + cf (s, v)),\n         cf((s, v) := 0, (v, s) := cf (s, v)))))))))))\n             (\\<lambda>_. 0, op_mtx_new c)))\n    \\<le> \\<Down> Id\n           (let x = \\<lambda>_. 0; cf = c\n            in foreach (adjacent_nodes s)\n                (\\<lambda>v (x, cf).\n                    assert ((s, v) \\<in> E) \\<bind>\n                    (\\<lambda>_.\n                        assert (s \\<noteq> v) \\<bind>\n                        (\\<lambda>_.\n                            let a = cf (s, v)\n                            in assert (x v = 0) \\<bind>\n                               (\\<lambda>_.\n                                   let x = x(s := x s - a, v := a);\n cf = cf((s, v) := 0, (v, s) := a)\n                                   in return (x, cf)))))\n                (x, cf))", "apply refine_rcg"], ["proof (prove)\ngoal (8 subgoals):\n 1. s \\<in> V\n 2. \\<And>x xi sa si x1 x2 x1a x2a.\n       \\<lbrakk>s \\<in> V; s \\<in> V; (xi, x) \\<in> nat_rel;\n        (si, sa) \\<in> Id; sa = (x1, x2); si = (x1a, x2a); (s, x) \\<in> E;\n        s \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> (s, xi) \\<in> E\n 3. \\<And>x xi sa si x1 x2 x1a x2a.\n       \\<lbrakk>s \\<in> V; s \\<in> V; (xi, x) \\<in> nat_rel;\n        (si, sa) \\<in> Id; sa = (x1, x2); si = (x1a, x2a); (s, x) \\<in> E;\n        s \\<noteq> x; (s, xi) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> s \\<noteq> xi\n 4. \\<And>x xi sa si x1 x2 x1a x2a.\n       \\<lbrakk>s \\<in> V; s \\<in> V; (xi, x) \\<in> nat_rel;\n        (si, sa) \\<in> Id; sa = (x1, x2); si = (x1a, x2a); (s, x) \\<in> E;\n        s \\<noteq> x; (s, xi) \\<in> E; s \\<noteq> xi\\<rbrakk>\n       \\<Longrightarrow> (s, xi) \\<in> E \\<union> E\\<inverse>\n 5. \\<And>x xi sa si x1 x2 x1a x2a.\n       \\<lbrakk>s \\<in> V; s \\<in> V; (xi, x) \\<in> nat_rel;\n        (si, sa) \\<in> Id; sa = (x1, x2); si = (x1a, x2a); (s, x) \\<in> E;\n        s \\<noteq> x; (s, xi) \\<in> E; s \\<noteq> xi;\n        (s, xi) \\<in> E \\<union> E\\<inverse>; s \\<in> V\\<rbrakk>\n       \\<Longrightarrow> xi \\<in> V\n 6. \\<And>x xi sa si x1 x2 x1a x2a.\n       \\<lbrakk>s \\<in> V; s \\<in> V; (xi, x) \\<in> nat_rel;\n        (si, sa) \\<in> Id; sa = (x1, x2); si = (x1a, x2a); (s, x) \\<in> E;\n        s \\<noteq> x; (s, xi) \\<in> E; s \\<noteq> xi;\n        (s, xi) \\<in> E \\<union> E\\<inverse>; s \\<in> V; xi \\<in> V;\n        (s, xi) \\<in> E \\<union> E\\<inverse>\\<rbrakk>\n       \\<Longrightarrow> (xi, s) \\<in> E \\<union> E\\<inverse>\n 7. \\<And>x xi sa si x1 x2 x1a x2a.\n       \\<lbrakk>s \\<in> V; s \\<in> V; (xi, x) \\<in> nat_rel;\n        (si, sa) \\<in> Id; sa = (x1, x2); si = (x1a, x2a); (s, x) \\<in> E;\n        s \\<noteq> x; (s, xi) \\<in> E; s \\<noteq> xi;\n        (s, xi) \\<in> E \\<union> E\\<inverse>; s \\<in> V; xi \\<in> V;\n        (s, xi) \\<in> E \\<union> E\\<inverse>;\n        (xi, s) \\<in> E \\<union> E\\<inverse>; x1 x = 0\\<rbrakk>\n       \\<Longrightarrow> ((x1a(s := x1a s + - x2a (s, xi),\n                               xi :=\n                                 (x1a(s := x1a s + - x2a (s, xi))) xi +\n                                 x2a (s, xi)),\n                           x2a((s, xi) := 0, (xi, s) := x2a (s, xi))),\n                          x1(s := x1 s - x2 (s, x), x := x2 (s, x)), x2\n                          ((s, x) := 0, (x, s) := x2 (s, x)))\n                         \\<in> Id\n 8. \\<lbrakk>s \\<in> V; s \\<in> V\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>_. 0, op_mtx_new c), \\<lambda>_. 0, c)\n                      \\<in> Id", "using E_ss_VxV"], ["proof (prove)\nusing this:\n  E \\<subseteq> V \\<times> V\n\ngoal (8 subgoals):\n 1. s \\<in> V\n 2. \\<And>x xi sa si x1 x2 x1a x2a.\n       \\<lbrakk>s \\<in> V; s \\<in> V; (xi, x) \\<in> nat_rel;\n        (si, sa) \\<in> Id; sa = (x1, x2); si = (x1a, x2a); (s, x) \\<in> E;\n        s \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> (s, xi) \\<in> E\n 3. \\<And>x xi sa si x1 x2 x1a x2a.\n       \\<lbrakk>s \\<in> V; s \\<in> V; (xi, x) \\<in> nat_rel;\n        (si, sa) \\<in> Id; sa = (x1, x2); si = (x1a, x2a); (s, x) \\<in> E;\n        s \\<noteq> x; (s, xi) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> s \\<noteq> xi\n 4. \\<And>x xi sa si x1 x2 x1a x2a.\n       \\<lbrakk>s \\<in> V; s \\<in> V; (xi, x) \\<in> nat_rel;\n        (si, sa) \\<in> Id; sa = (x1, x2); si = (x1a, x2a); (s, x) \\<in> E;\n        s \\<noteq> x; (s, xi) \\<in> E; s \\<noteq> xi\\<rbrakk>\n       \\<Longrightarrow> (s, xi) \\<in> E \\<union> E\\<inverse>\n 5. \\<And>x xi sa si x1 x2 x1a x2a.\n       \\<lbrakk>s \\<in> V; s \\<in> V; (xi, x) \\<in> nat_rel;\n        (si, sa) \\<in> Id; sa = (x1, x2); si = (x1a, x2a); (s, x) \\<in> E;\n        s \\<noteq> x; (s, xi) \\<in> E; s \\<noteq> xi;\n        (s, xi) \\<in> E \\<union> E\\<inverse>; s \\<in> V\\<rbrakk>\n       \\<Longrightarrow> xi \\<in> V\n 6. \\<And>x xi sa si x1 x2 x1a x2a.\n       \\<lbrakk>s \\<in> V; s \\<in> V; (xi, x) \\<in> nat_rel;\n        (si, sa) \\<in> Id; sa = (x1, x2); si = (x1a, x2a); (s, x) \\<in> E;\n        s \\<noteq> x; (s, xi) \\<in> E; s \\<noteq> xi;\n        (s, xi) \\<in> E \\<union> E\\<inverse>; s \\<in> V; xi \\<in> V;\n        (s, xi) \\<in> E \\<union> E\\<inverse>\\<rbrakk>\n       \\<Longrightarrow> (xi, s) \\<in> E \\<union> E\\<inverse>\n 7. \\<And>x xi sa si x1 x2 x1a x2a.\n       \\<lbrakk>s \\<in> V; s \\<in> V; (xi, x) \\<in> nat_rel;\n        (si, sa) \\<in> Id; sa = (x1, x2); si = (x1a, x2a); (s, x) \\<in> E;\n        s \\<noteq> x; (s, xi) \\<in> E; s \\<noteq> xi;\n        (s, xi) \\<in> E \\<union> E\\<inverse>; s \\<in> V; xi \\<in> V;\n        (s, xi) \\<in> E \\<union> E\\<inverse>;\n        (xi, s) \\<in> E \\<union> E\\<inverse>; x1 x = 0\\<rbrakk>\n       \\<Longrightarrow> ((x1a(s := x1a s + - x2a (s, xi),\n                               xi :=\n                                 (x1a(s := x1a s + - x2a (s, xi))) xi +\n                                 x2a (s, xi)),\n                           x2a((s, xi) := 0, (xi, s) := x2a (s, xi))),\n                          x1(s := x1 s - x2 (s, x), x := x2 (s, x)), x2\n                          ((s, x) := 0, (x, s) := x2 (s, x)))\n                         \\<in> Id\n 8. \\<lbrakk>s \\<in> V; s \\<in> V\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>_. 0, op_mtx_new c), \\<lambda>_. 0, c)\n                      \\<in> Id", "by auto"], ["", "lemma pp_init_xcf2_refine[refine2]: \n  assumes AM: \"is_adj_map am\"  \n  shows \"pp_init_xcf2 am \\<le>\\<Down>xf_rel (RETURN pp_init_f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_init_xcf2 am \\<le> \\<Down> xf_rel (return pp_init_f)", "using pp_init_xcf2_refine_aux[OF AM] pp_init_xcf2_aux_spec pp_init_x_rel"], ["proof (prove)\nusing this:\n  pp_init_xcf2 am \\<le> \\<Down> Id pp_init_xcf2_aux\n  pp_init_xcf2_aux\n  \\<le> SPEC (\\<lambda>(x, cf). x = pp_init_x \\<and> cf = pp_init_cf)\n  ((pp_init_x, pp_init_cf), pp_init_f) \\<in> xf_rel\n\ngoal (1 subgoal):\n 1. pp_init_xcf2 am \\<le> \\<Down> xf_rel (return pp_init_f)", "by (auto simp: pw_le_iff refine_pw_simps)"], ["", "subsubsection \\<open>Computing the Minimal Adjacent Label\\<close>"], ["", "definition (in Network) \"min_adj_label_aux cf l u \\<equiv> do {\n  assert (u\\<in>V);\n  x \\<leftarrow> foreach (adjacent_nodes u) (\\<lambda>v x. do {\n    assert ((u,v)\\<in>E\\<union>E\\<inverse>);\n    assert (v\\<in>V);\n    if (cf (u,v) \\<noteq> 0) then \n      case x of \n        None \\<Rightarrow> return (Some (l v)) \n      | Some xx \\<Rightarrow> return (Some (min (l v) (xx)))\n    else\n      return x\n  }) None;\n\n  assert (x\\<noteq>None);\n  return (the x)\n}\""], ["", "lemma (in -) set_filter_xform_aux: \n  \"{ f x | x. ( x = a \\<or> x\\<in>S \\<and> x\\<notin>it ) \\<and> P x } \n  = (if P a then {f a} else {}) \\<union> {f x | x. x\\<in>S-it \\<and> P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {f x |x. (x = a \\<or> x \\<in> S \\<and> x \\<notin> it) \\<and> P x} =\n    (if P a then {f a} else {}) \\<union> {f x |x. x \\<in> S - it \\<and> P x}", "by auto"], ["", "lemma (in Labeling) min_adj_label_aux_spec: \n  assumes PRE: \"relabel_precond f l u\"\n  shows \"min_adj_label_aux cf l u \\<le> SPEC (\\<lambda>x. x = Min { l v | v. (u,v)\\<in>cf.E })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_adj_label_aux cf l u\n    \\<le> (spec x. x = Min {l v |v. (u, v) \\<in> cf.E})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. min_adj_label_aux cf l u\n    \\<le> (spec x. x = Min {l v |v. (u, v) \\<in> cf.E})", "have AUX: \"cf (u,v) \\<noteq> 0 \\<longleftrightarrow> (u,v)\\<in>cf.E\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cf (u, v) \\<noteq> (0::'a)) = ((u, v) \\<in> cf.E)", "unfolding cf.E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cf (u, v) \\<noteq> (0::'a)) =\n    ((u, v) \\<in> {(u, v). cf (u, v) \\<noteq> (0::'a)})", "by auto"], ["proof (state)\nthis:\n  (cf (u, ?v4) \\<noteq> (0::'a)) = ((u, ?v4) \\<in> cf.E)\n\ngoal (1 subgoal):\n 1. min_adj_label_aux cf l u\n    \\<le> (spec x. x = Min {l v |v. (u, v) \\<in> cf.E})", "have EQ: \"{ l v | v. (u,v)\\<in>cf.E } \n    = { l v | v. v\\<in>adjacent_nodes u \\<and> cf (u,v)\\<noteq>0 }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l v |v. (u, v) \\<in> cf.E} =\n    {l v |v. v \\<in> adjacent_nodes u \\<and> cf (u, v) \\<noteq> (0::'a)}", "unfolding AUX"], ["proof (prove)\ngoal (1 subgoal):\n 1. {l v |v. (u, v) \\<in> cf.E} =\n    {l v |v. v \\<in> adjacent_nodes u \\<and> (u, v) \\<in> cf.E}", "using cfE_ss_invE"], ["proof (prove)\nusing this:\n  cf.E \\<subseteq> E \\<union> E\\<inverse>\n\ngoal (1 subgoal):\n 1. {l v |v. (u, v) \\<in> cf.E} =\n    {l v |v. v \\<in> adjacent_nodes u \\<and> (u, v) \\<in> cf.E}", "by (auto simp: adjacent_nodes_def)"], ["proof (state)\nthis:\n  {l v |v. (u, v) \\<in> cf.E} =\n  {l v |v. v \\<in> adjacent_nodes u \\<and> cf (u, v) \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. min_adj_label_aux cf l u\n    \\<le> (spec x. x = Min {l v |v. (u, v) \\<in> cf.E})", "define Min_option :: \"nat set \\<rightharpoonup> nat\" \n    where \"Min_option X \\<equiv> if X={} then None else Some (Min X)\" for X"], ["proof (state)\nthis:\n  Min_option ?X \\<equiv> if ?X = {} then None else Some (Min ?X)\n\ngoal (1 subgoal):\n 1. min_adj_label_aux cf l u\n    \\<le> (spec x. x = Min {l v |v. (u, v) \\<in> cf.E})", "from PRE active_has_cf_outgoing"], ["proof (chain)\npicking this:\n  relabel_precond f l u\n  (0::'a) < excess f ?u \\<Longrightarrow> cf.outgoing ?u \\<noteq> {}", "have \"cf.outgoing u \\<noteq> {}\""], ["proof (prove)\nusing this:\n  relabel_precond f l u\n  (0::'a) < excess f ?u \\<Longrightarrow> cf.outgoing ?u \\<noteq> {}\n\ngoal (1 subgoal):\n 1. cf.outgoing u \\<noteq> {}", "unfolding relabel_precond_def"], ["proof (prove)\nusing this:\n  u \\<noteq> t \\<and>\n  (0::'a) < excess f u \\<and>\n  (\\<forall>v. (u, v) \\<in> cf.E \\<longrightarrow> l u \\<noteq> l v + 1)\n  (0::'a) < excess f ?u \\<Longrightarrow> cf.outgoing ?u \\<noteq> {}\n\ngoal (1 subgoal):\n 1. cf.outgoing u \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  cf.outgoing u \\<noteq> {}\n\ngoal (1 subgoal):\n 1. min_adj_label_aux cf l u\n    \\<le> (spec x. x = Min {l v |v. (u, v) \\<in> cf.E})", "hence [simp]: \"u\\<in>V\""], ["proof (prove)\nusing this:\n  cf.outgoing u \\<noteq> {}\n\ngoal (1 subgoal):\n 1. u \\<in> V", "unfolding cf.outgoing_def"], ["proof (prove)\nusing this:\n  {(u, ua) |ua. (u, ua) \\<in> cf.E} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. u \\<in> V", "using cfE_of_ss_VxV"], ["proof (prove)\nusing this:\n  {(u, ua) |ua. (u, ua) \\<in> cf.E} \\<noteq> {}\n  cfE_of ?f \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. u \\<in> V", "by auto"], ["proof (state)\nthis:\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. min_adj_label_aux cf l u\n    \\<le> (spec x. x = Min {l v |v. (u, v) \\<in> cf.E})", "from \\<open>cf.outgoing u \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  cf.outgoing u \\<noteq> {}", "have AUX2: \"\\<exists>v. v \\<in> adjacent_nodes u \\<and> cf (u, v) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  cf.outgoing u \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<in> adjacent_nodes u \\<and> cf (u, v) \\<noteq> (0::'a)", "by (smt AUX Collect_empty_eq Image_singleton_iff UnCI adjacent_nodes_def \n            cf.outgoing_def cf_def converse_iff prod.simps(2))"], ["proof (state)\nthis:\n  \\<exists>v. v \\<in> adjacent_nodes u \\<and> cf (u, v) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. min_adj_label_aux cf l u\n    \\<le> (spec x. x = Min {l v |v. (u, v) \\<in> cf.E})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. min_adj_label_aux cf l u\n    \\<le> (spec x. x = Min {l v |v. (u, v) \\<in> cf.E})", "unfolding min_adj_label_aux_def EQ"], ["proof (prove)\ngoal (1 subgoal):\n 1. assert (u \\<in> V) \\<bind>\n    (\\<lambda>_.\n        foreach (adjacent_nodes u)\n         (\\<lambda>v x.\n             assert ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n             (\\<lambda>_.\n                 assert (v \\<in> V) \\<bind>\n                 (\\<lambda>_.\n                     if cf (u, v) \\<noteq> (0::'a)\n                     then case x of None \\<Rightarrow> return (Some (l v))\n                          | Some xx \\<Rightarrow>\n                              return (Some (min (l v) xx))\n                     else return x)))\n         None \\<bind>\n        (\\<lambda>x.\n            assert (x \\<noteq> None) \\<bind> (\\<lambda>_. return (the x))))\n    \\<le> (spec x.\n              x =\n              Min {l v |v.\n                   v \\<in> adjacent_nodes u \\<and>\n                   cf (u, v) \\<noteq> (0::'a)})", "apply (refine_vcg \n        FOREACH_rule[where \n          I=\"\\<lambda>it x. x = Min_option \n                          { l v | v. v\\<in>adjacent_nodes u - it \\<and> cf (u,v)\\<noteq>0 }\"]\n        )"], ["proof (prove)\ngoal (10 subgoals):\n 1. u \\<in> V\n 2. u \\<in> V \\<Longrightarrow> finite (adjacent_nodes u)\n 3. u \\<in> V \\<Longrightarrow>\n    None =\n    Min_option\n     {l v |v.\n      v \\<in> adjacent_nodes u - adjacent_nodes u \\<and>\n      cf (u, v) \\<noteq> (0::'a)}\n 4. \\<And>x it \\<sigma>.\n       \\<lbrakk>u \\<in> V; x \\<in> it; it \\<subseteq> adjacent_nodes u;\n        \\<sigma> =\n        Min_option\n         {l v |v.\n          v \\<in> adjacent_nodes u - it \\<and>\n          cf (u, v) \\<noteq> (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> (u, x) \\<in> E \\<union> E\\<inverse>\n 5. \\<And>x it \\<sigma>.\n       \\<lbrakk>u \\<in> V; x \\<in> it; it \\<subseteq> adjacent_nodes u;\n        \\<sigma> =\n        Min_option\n         {l v |v.\n          v \\<in> adjacent_nodes u - it \\<and> cf (u, v) \\<noteq> (0::'a)};\n        (u, x) \\<in> E \\<union> E\\<inverse>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> V\n 6. \\<And>x it \\<sigma>.\n       \\<lbrakk>u \\<in> V; x \\<in> it; it \\<subseteq> adjacent_nodes u;\n        \\<sigma> =\n        Min_option\n         {l v |v.\n          v \\<in> adjacent_nodes u - it \\<and> cf (u, v) \\<noteq> (0::'a)};\n        (u, x) \\<in> E \\<union> E\\<inverse>; x \\<in> V;\n        cf (u, x) \\<noteq> (0::'a); \\<sigma> = None\\<rbrakk>\n       \\<Longrightarrow> Some (l x) =\n                         Min_option\n                          {l v |v.\n                           v \\<in> adjacent_nodes u - (it - {x}) \\<and>\n                           cf (u, v) \\<noteq> (0::'a)}\n 7. \\<And>x it \\<sigma> xa.\n       \\<lbrakk>u \\<in> V; x \\<in> it; it \\<subseteq> adjacent_nodes u;\n        \\<sigma> =\n        Min_option\n         {l v |v.\n          v \\<in> adjacent_nodes u - it \\<and> cf (u, v) \\<noteq> (0::'a)};\n        (u, x) \\<in> E \\<union> E\\<inverse>; x \\<in> V;\n        cf (u, x) \\<noteq> (0::'a); \\<sigma> = Some xa\\<rbrakk>\n       \\<Longrightarrow> Some (min (l x) xa) =\n                         Min_option\n                          {l v |v.\n                           v \\<in> adjacent_nodes u - (it - {x}) \\<and>\n                           cf (u, v) \\<noteq> (0::'a)}\n 8. \\<And>x it \\<sigma>.\n       \\<lbrakk>u \\<in> V; x \\<in> it; it \\<subseteq> adjacent_nodes u;\n        \\<sigma> =\n        Min_option\n         {l v |v.\n          v \\<in> adjacent_nodes u - it \\<and> cf (u, v) \\<noteq> (0::'a)};\n        (u, x) \\<in> E \\<union> E\\<inverse>; x \\<in> V;\n        \\<not> cf (u, x) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> =\n                         Min_option\n                          {l v |v.\n                           v \\<in> adjacent_nodes u - (it - {x}) \\<and>\n                           cf (u, v) \\<noteq> (0::'a)}\n 9. \\<And>\\<sigma>.\n       \\<lbrakk>u \\<in> V;\n        \\<sigma> =\n        Min_option\n         {l v |v.\n          v \\<in> adjacent_nodes u - {} \\<and>\n          cf (u, v) \\<noteq> (0::'a)}\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<noteq> None\n 10. \\<And>\\<sigma>.\n        \\<lbrakk>u \\<in> V;\n         \\<sigma> =\n         Min_option\n          {l v |v.\n           v \\<in> adjacent_nodes u - {} \\<and> cf (u, v) \\<noteq> (0::'a)};\n         \\<sigma> \\<noteq> None\\<rbrakk>\n        \\<Longrightarrow> the \\<sigma> =\n                          Min {l v |v.\n                               v \\<in> adjacent_nodes u \\<and>\n                               cf (u, v) \\<noteq> (0::'a)}", "apply (vc_solve \n        simp: Min_option_def it_step_insert_iff set_filter_xform_aux \n        split: if_splits)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x it.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> adjacent_nodes u;\n        \\<forall>v.\n           v \\<in> adjacent_nodes u \\<longrightarrow>\n           v \\<in> it \\<or> cf (u, v) = (0::'a);\n        (x, u) \\<notin> E\\<rbrakk>\n       \\<Longrightarrow> (u, x) \\<in> E\n 2. \\<And>x it v.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> adjacent_nodes u;\n        v \\<in> adjacent_nodes u; v \\<notin> it; cf (u, v) \\<noteq> (0::'a);\n        (x, u) \\<notin> E\\<rbrakk>\n       \\<Longrightarrow> (u, x) \\<in> E\n 3. \\<And>x it.\n       \\<lbrakk>(u, x) \\<in> E \\<or> (x, u) \\<in> E; x \\<in> it;\n        it \\<subseteq> adjacent_nodes u;\n        \\<forall>v.\n           v \\<in> adjacent_nodes u \\<longrightarrow>\n           v \\<in> it \\<or> cf (u, v) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> V\n 4. \\<And>x it v.\n       \\<lbrakk>(u, x) \\<in> E \\<or> (x, u) \\<in> E; x \\<in> it;\n        it \\<subseteq> adjacent_nodes u; v \\<in> adjacent_nodes u;\n        v \\<notin> it; cf (u, v) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> V\n 5. \\<And>x it.\n       \\<lbrakk>(u, x) \\<in> E \\<or> (x, u) \\<in> E; x \\<in> V;\n        cf (u, x) \\<noteq> (0::'a); x \\<in> it;\n        it \\<subseteq> adjacent_nodes u;\n        \\<forall>v.\n           v \\<in> adjacent_nodes u \\<longrightarrow>\n           v \\<in> it \\<or> cf (u, v) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> l x =\n                         Min (insert (l x)\n                               {l v |v.\n                                v \\<in> adjacent_nodes u \\<and>\n                                v \\<notin> it \\<and>\n                                cf (u, v) \\<noteq> (0::'a)})\n 6. \\<exists>v. v \\<in> adjacent_nodes u \\<and> cf (u, v) \\<noteq> (0::'a)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<in> it_; it_ \\<subseteq> adjacent_nodes u;\n     \\<forall>v.\n        v \\<in> adjacent_nodes u \\<longrightarrow>\n        v \\<in> it_ \\<or> cf (u, v) = (0::'a);\n     (x_, u) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> (u, x_) \\<in> E", "unfolding adjacent_nodes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<in> it_;\n     it_ \\<subseteq> E `` {u} \\<union> E\\<inverse> `` {u};\n     \\<forall>v.\n        v \\<in> E `` {u} \\<union> E\\<inverse> `` {u} \\<longrightarrow>\n        v \\<in> it_ \\<or> cf (u, v) = (0::'a);\n     (x_, u) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> (u, x_) \\<in> E", "by auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x it v.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> adjacent_nodes u;\n        v \\<in> adjacent_nodes u; v \\<notin> it; cf (u, v) \\<noteq> (0::'a);\n        (x, u) \\<notin> E\\<rbrakk>\n       \\<Longrightarrow> (u, x) \\<in> E\n 2. \\<And>x it.\n       \\<lbrakk>(u, x) \\<in> E \\<or> (x, u) \\<in> E; x \\<in> it;\n        it \\<subseteq> adjacent_nodes u;\n        \\<forall>v.\n           v \\<in> adjacent_nodes u \\<longrightarrow>\n           v \\<in> it \\<or> cf (u, v) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> V\n 3. \\<And>x it v.\n       \\<lbrakk>(u, x) \\<in> E \\<or> (x, u) \\<in> E; x \\<in> it;\n        it \\<subseteq> adjacent_nodes u; v \\<in> adjacent_nodes u;\n        v \\<notin> it; cf (u, v) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> V\n 4. \\<And>x it.\n       \\<lbrakk>(u, x) \\<in> E \\<or> (x, u) \\<in> E; x \\<in> V;\n        cf (u, x) \\<noteq> (0::'a); x \\<in> it;\n        it \\<subseteq> adjacent_nodes u;\n        \\<forall>v.\n           v \\<in> adjacent_nodes u \\<longrightarrow>\n           v \\<in> it \\<or> cf (u, v) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> l x =\n                         Min (insert (l x)\n                               {l v |v.\n                                v \\<in> adjacent_nodes u \\<and>\n                                v \\<notin> it \\<and>\n                                cf (u, v) \\<noteq> (0::'a)})\n 5. \\<exists>v. v \\<in> adjacent_nodes u \\<and> cf (u, v) \\<noteq> (0::'a)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<in> it_; it_ \\<subseteq> adjacent_nodes u;\n     v_ \\<in> adjacent_nodes u; v_ \\<notin> it_;\n     cf (u, v_) \\<noteq> (0::'a); (x_, u) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> (u, x_) \\<in> E", "unfolding adjacent_nodes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x_ \\<in> it_;\n     it_ \\<subseteq> E `` {u} \\<union> E\\<inverse> `` {u};\n     v_ \\<in> E `` {u} \\<union> E\\<inverse> `` {u}; v_ \\<notin> it_;\n     cf (u, v_) \\<noteq> (0::'a); (x_, u) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> (u, x_) \\<in> E", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x it.\n       \\<lbrakk>(u, x) \\<in> E \\<or> (x, u) \\<in> E; x \\<in> it;\n        it \\<subseteq> adjacent_nodes u;\n        \\<forall>v.\n           v \\<in> adjacent_nodes u \\<longrightarrow>\n           v \\<in> it \\<or> cf (u, v) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> V\n 2. \\<And>x it v.\n       \\<lbrakk>(u, x) \\<in> E \\<or> (x, u) \\<in> E; x \\<in> it;\n        it \\<subseteq> adjacent_nodes u; v \\<in> adjacent_nodes u;\n        v \\<notin> it; cf (u, v) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> V\n 3. \\<And>x it.\n       \\<lbrakk>(u, x) \\<in> E \\<or> (x, u) \\<in> E; x \\<in> V;\n        cf (u, x) \\<noteq> (0::'a); x \\<in> it;\n        it \\<subseteq> adjacent_nodes u;\n        \\<forall>v.\n           v \\<in> adjacent_nodes u \\<longrightarrow>\n           v \\<in> it \\<or> cf (u, v) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> l x =\n                         Min (insert (l x)\n                               {l v |v.\n                                v \\<in> adjacent_nodes u \\<and>\n                                v \\<notin> it \\<and>\n                                cf (u, v) \\<noteq> (0::'a)})\n 4. \\<exists>v. v \\<in> adjacent_nodes u \\<and> cf (u, v) \\<noteq> (0::'a)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, x_) \\<in> E \\<or> (x_, u) \\<in> E; x_ \\<in> it_;\n     it_ \\<subseteq> adjacent_nodes u;\n     \\<forall>v.\n        v \\<in> adjacent_nodes u \\<longrightarrow>\n        v \\<in> it_ \\<or> cf (u, v) = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> x_ \\<in> V", "using adjacent_nodes_ss_V"], ["proof (prove)\nusing this:\n  adjacent_nodes ?u \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, x_) \\<in> E \\<or> (x_, u) \\<in> E; x_ \\<in> it_;\n     it_ \\<subseteq> adjacent_nodes u;\n     \\<forall>v.\n        v \\<in> adjacent_nodes u \\<longrightarrow>\n        v \\<in> it_ \\<or> cf (u, v) = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> x_ \\<in> V", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it v.\n       \\<lbrakk>(u, x) \\<in> E \\<or> (x, u) \\<in> E; x \\<in> it;\n        it \\<subseteq> adjacent_nodes u; v \\<in> adjacent_nodes u;\n        v \\<notin> it; cf (u, v) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> V\n 2. \\<And>x it.\n       \\<lbrakk>(u, x) \\<in> E \\<or> (x, u) \\<in> E; x \\<in> V;\n        cf (u, x) \\<noteq> (0::'a); x \\<in> it;\n        it \\<subseteq> adjacent_nodes u;\n        \\<forall>v.\n           v \\<in> adjacent_nodes u \\<longrightarrow>\n           v \\<in> it \\<or> cf (u, v) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> l x =\n                         Min (insert (l x)\n                               {l v |v.\n                                v \\<in> adjacent_nodes u \\<and>\n                                v \\<notin> it \\<and>\n                                cf (u, v) \\<noteq> (0::'a)})\n 3. \\<exists>v. v \\<in> adjacent_nodes u \\<and> cf (u, v) \\<noteq> (0::'a)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, x_) \\<in> E \\<or> (x_, u) \\<in> E; x_ \\<in> it_;\n     it_ \\<subseteq> adjacent_nodes u; v_ \\<in> adjacent_nodes u;\n     v_ \\<notin> it_; cf (u, v_) \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> x_ \\<in> V", "using adjacent_nodes_ss_V"], ["proof (prove)\nusing this:\n  adjacent_nodes ?u \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, x_) \\<in> E \\<or> (x_, u) \\<in> E; x_ \\<in> it_;\n     it_ \\<subseteq> adjacent_nodes u; v_ \\<in> adjacent_nodes u;\n     v_ \\<notin> it_; cf (u, v_) \\<noteq> (0::'a)\\<rbrakk>\n    \\<Longrightarrow> x_ \\<in> V", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it.\n       \\<lbrakk>(u, x) \\<in> E \\<or> (x, u) \\<in> E; x \\<in> V;\n        cf (u, x) \\<noteq> (0::'a); x \\<in> it;\n        it \\<subseteq> adjacent_nodes u;\n        \\<forall>v.\n           v \\<in> adjacent_nodes u \\<longrightarrow>\n           v \\<in> it \\<or> cf (u, v) = (0::'a)\\<rbrakk>\n       \\<Longrightarrow> l x =\n                         Min (insert (l x)\n                               {l v |v.\n                                v \\<in> adjacent_nodes u \\<and>\n                                v \\<notin> it \\<and>\n                                cf (u, v) \\<noteq> (0::'a)})\n 2. \\<exists>v. v \\<in> adjacent_nodes u \\<and> cf (u, v) \\<noteq> (0::'a)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, x_) \\<in> E \\<or> (x_, u) \\<in> E; x_ \\<in> V;\n     cf (u, x_) \\<noteq> (0::'a); x_ \\<in> it_;\n     it_ \\<subseteq> adjacent_nodes u;\n     \\<forall>v.\n        v \\<in> adjacent_nodes u \\<longrightarrow>\n        v \\<in> it_ \\<or> cf (u, v) = (0::'a)\\<rbrakk>\n    \\<Longrightarrow> l x_ =\n                      Min (insert (l x_)\n                            {l v |v.\n                             v \\<in> adjacent_nodes u \\<and>\n                             v \\<notin> it_ \\<and>\n                             cf (u, v) \\<noteq> (0::'a)})", "by (auto simp: Min.insert_remove)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<in> adjacent_nodes u \\<and> cf (u, v) \\<noteq> (0::'a)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<in> adjacent_nodes u \\<and> cf (u, v) \\<noteq> (0::'a)", "using AUX2"], ["proof (prove)\nusing this:\n  \\<exists>v. v \\<in> adjacent_nodes u \\<and> cf (u, v) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<in> adjacent_nodes u \\<and> cf (u, v) \\<noteq> (0::'a)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  min_adj_label_aux cf l u\n  \\<le> (spec x. x = Min {l v |v. (u, v) \\<in> cf.E})\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"min_adj_label am cf l u \\<equiv> do {\n  assert (u\\<in>V);\n  adj \\<leftarrow> am_get am u;\n  x \\<leftarrow> nfoldli adj (\\<lambda>_. True) (\\<lambda>v x. do {\n    assert ((u,v)\\<in> E \\<union> E\\<inverse>);\n    assert (v\\<in>V);\n    cfuv \\<leftarrow> cf_get cf (u,v);\n    if (cfuv \\<noteq> 0) then do {\n      lv \\<leftarrow> l_get l v;\n      case x of \n        None \\<Rightarrow> return (Some lv) \n      | Some xx \\<Rightarrow> return (Some (min lv xx))\n    } else\n      return x\n  }) None;\n\n  assert (x\\<noteq>None);\n  return (the x)\n}\""], ["", "lemma min_adj_label_refine[THEN order_trans, refine_vcg]:\n  assumes \"Height_Bounded_Labeling c s t f l\"\n  assumes AM: \"(am,adjacent_nodes)\\<in>nat_rel\\<rightarrow>\\<langle>nat_rel\\<rangle>list_set_rel\"\n  assumes PRE: \"relabel_precond f l u\"\n  assumes [simp]: \"cf = cf_of f\"  \n  shows \"min_adj_label am cf l u \\<le> SPEC (\\<lambda>x. x \n        = Min { l v | v. (u,v)\\<in>cfE_of f })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_adj_label am cf l u\n    \\<le> (spec x. x = Min {l v |v. (u, v) \\<in> cfE_of f})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. min_adj_label am cf l u\n    \\<le> (spec x. x = Min {l v |v. (u, v) \\<in> cfE_of f})", "interpret Height_Bounded_Labeling c s t f l"], ["proof (prove)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f l", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. min_adj_label am cf l u\n    \\<le> (spec x. x = Min {l v |v. (u, v) \\<in> cf.E})", "have \"min_adj_label am (cf_of f) l u \\<le> \\<Down>Id (min_adj_label_aux (cf_of f) l u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_adj_label am cf l u \\<le> \\<Down> nat_rel (min_adj_label_aux cf l u)", "unfolding min_adj_label_def min_adj_label_aux_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. assert (u \\<in> V) \\<bind>\n    (\\<lambda>_.\n        am_get am u \\<bind>\n        (\\<lambda>adj.\n            nfoldli adj (\\<lambda>_. True)\n             (\\<lambda>v x.\n                 assert ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n                 (\\<lambda>_.\n                     assert (v \\<in> V) \\<bind>\n                     (\\<lambda>_.\n                         cf_get cf (u, v) \\<bind>\n                         (\\<lambda>cfuv.\n                             if cfuv \\<noteq> 0\n                             then l_get l v \\<bind>\n                                  (\\<lambda>lv.\ncase x of None \\<Rightarrow> return (Some lv)\n| Some xx \\<Rightarrow> return (Some (min lv xx)))\n                             else return x))))\n             None \\<bind>\n            (\\<lambda>x.\n                assert (x \\<noteq> None) \\<bind>\n                (\\<lambda>_. return (the x)))))\n    \\<le> \\<Down> nat_rel\n           (assert (u \\<in> V) \\<bind>\n            (\\<lambda>_.\n                foreach (adjacent_nodes u)\n                 (\\<lambda>v x.\n                     assert ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n                     (\\<lambda>_.\n                         assert (v \\<in> V) \\<bind>\n                         (\\<lambda>_.\n                             if cf (u, v) \\<noteq> 0\n                             then case x of\n                                  None \\<Rightarrow> return (Some (l v))\n                                  | Some xx \\<Rightarrow>\nreturn (Some (min (l v) xx))\n                             else return x)))\n                 None \\<bind>\n                (\\<lambda>x.\n                    assert (x \\<noteq> None) \\<bind>\n                    (\\<lambda>_. return (the x)))))", "unfolding am_get_def cf_get_def l_get_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. assert (u \\<in> V) \\<bind>\n    (\\<lambda>_.\n        assert (u \\<in> V) \\<bind> (\\<lambda>_. return (am u)) \\<bind>\n        (\\<lambda>adj.\n            nfoldli adj (\\<lambda>_. True)\n             (\\<lambda>v x.\n                 assert ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n                 (\\<lambda>_.\n                     assert (v \\<in> V) \\<bind>\n                     (\\<lambda>_.\n                         assert\n                          ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n                         (\\<lambda>_. return (cf (u, v))) \\<bind>\n                         (\\<lambda>cfuv.\n                             if cfuv \\<noteq> 0\n                             then assert (v \\<in> V) \\<bind>\n                                  (\\<lambda>_. return (l v)) \\<bind>\n                                  (\\<lambda>lv.\ncase x of None \\<Rightarrow> return (Some lv)\n| Some xx \\<Rightarrow> return (Some (min lv xx)))\n                             else return x))))\n             None \\<bind>\n            (\\<lambda>x.\n                assert (x \\<noteq> None) \\<bind>\n                (\\<lambda>_. return (the x)))))\n    \\<le> \\<Down> nat_rel\n           (assert (u \\<in> V) \\<bind>\n            (\\<lambda>_.\n                foreach (adjacent_nodes u)\n                 (\\<lambda>v x.\n                     assert ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n                     (\\<lambda>_.\n                         assert (v \\<in> V) \\<bind>\n                         (\\<lambda>_.\n                             if cf (u, v) \\<noteq> 0\n                             then case x of\n                                  None \\<Rightarrow> return (Some (l v))\n                                  | Some xx \\<Rightarrow>\nreturn (Some (min (l v) xx))\n                             else return x)))\n                 None \\<bind>\n                (\\<lambda>x.\n                    assert (x \\<noteq> None) \\<bind>\n                    (\\<lambda>_. return (the x)))))", "apply (simp only: nres_monad_laws)"], ["proof (prove)\ngoal (1 subgoal):\n 1. assert (u \\<in> V) \\<bind>\n    (\\<lambda>_.\n        assert (u \\<in> V) \\<bind>\n        (\\<lambda>x.\n            nfoldli (am u) (\\<lambda>_. True)\n             (\\<lambda>v x.\n                 assert ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n                 (\\<lambda>_.\n                     assert (v \\<in> V) \\<bind>\n                     (\\<lambda>_.\n                         assert\n                          ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n                         (\\<lambda>xa.\n                             if cf (u, v) \\<noteq> 0\n                             then assert (v \\<in> V) \\<bind>\n                                  (\\<lambda>xa.\ncase x of None \\<Rightarrow> return (Some (l v))\n| Some xx \\<Rightarrow> return (Some (min (l v) xx)))\n                             else return x))))\n             None \\<bind>\n            (\\<lambda>x.\n                assert (x \\<noteq> None) \\<bind>\n                (\\<lambda>_. return (the x)))))\n    \\<le> \\<Down> nat_rel\n           (assert (u \\<in> V) \\<bind>\n            (\\<lambda>_.\n                foreach (adjacent_nodes u)\n                 (\\<lambda>v x.\n                     assert ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n                     (\\<lambda>_.\n                         assert (v \\<in> V) \\<bind>\n                         (\\<lambda>_.\n                             if cf (u, v) \\<noteq> 0\n                             then case x of\n                                  None \\<Rightarrow> return (Some (l v))\n                                  | Some xx \\<Rightarrow>\nreturn (Some (min (l v) xx))\n                             else return x)))\n                 None \\<bind>\n                (\\<lambda>x.\n                    assert (x \\<noteq> None) \\<bind>\n                    (\\<lambda>_. return (the x)))))", "supply LFO_refine[OF fun_relD[OF AM IdI] _ IdI, refine]"], ["proof (prove)\ngoal (1 subgoal):\n 1. assert (u \\<in> V) \\<bind>\n    (\\<lambda>_.\n        assert (u \\<in> V) \\<bind>\n        (\\<lambda>x.\n            nfoldli (am u) (\\<lambda>_. True)\n             (\\<lambda>v x.\n                 assert ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n                 (\\<lambda>_.\n                     assert (v \\<in> V) \\<bind>\n                     (\\<lambda>_.\n                         assert\n                          ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n                         (\\<lambda>xa.\n                             if cf (u, v) \\<noteq> 0\n                             then assert (v \\<in> V) \\<bind>\n                                  (\\<lambda>xa.\ncase x of None \\<Rightarrow> return (Some (l v))\n| Some xx \\<Rightarrow> return (Some (min (l v) xx)))\n                             else return x))))\n             None \\<bind>\n            (\\<lambda>x.\n                assert (x \\<noteq> None) \\<bind>\n                (\\<lambda>_. return (the x)))))\n    \\<le> \\<Down> nat_rel\n           (assert (u \\<in> V) \\<bind>\n            (\\<lambda>_.\n                foreach (adjacent_nodes u)\n                 (\\<lambda>v x.\n                     assert ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n                     (\\<lambda>_.\n                         assert (v \\<in> V) \\<bind>\n                         (\\<lambda>_.\n                             if cf (u, v) \\<noteq> 0\n                             then case x of\n                                  None \\<Rightarrow> return (Some (l v))\n                                  | Some xx \\<Rightarrow>\nreturn (Some (min (l v) xx))\n                             else return x)))\n                 None \\<bind>\n                (\\<lambda>x.\n                    assert (x \\<noteq> None) \\<bind>\n                    (\\<lambda>_. return (the x)))))", "apply (refine_rcg)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x xi s si.\n       \\<lbrakk>u \\<in> V; u \\<in> V; u \\<in> V; (xi, x) \\<in> nat_rel;\n        (si, s) \\<in> Id; (u, x) \\<in> E \\<union> E\\<inverse>;\n        x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> (u, xi) \\<in> E \\<union> E\\<inverse>\n 2. \\<And>x xi s si.\n       \\<lbrakk>u \\<in> V; u \\<in> V; u \\<in> V; (xi, x) \\<in> nat_rel;\n        (si, s) \\<in> Id; (u, x) \\<in> E \\<union> E\\<inverse>; x \\<in> V;\n        (u, xi) \\<in> E \\<union> E\\<inverse>\\<rbrakk>\n       \\<Longrightarrow> xi \\<in> V\n 3. \\<And>x xi s si.\n       \\<lbrakk>u \\<in> V; u \\<in> V; u \\<in> V; (xi, x) \\<in> nat_rel;\n        (si, s) \\<in> Id; (u, x) \\<in> E \\<union> E\\<inverse>; x \\<in> V;\n        (u, xi) \\<in> E \\<union> E\\<inverse>; xi \\<in> V;\n        (u, xi) \\<in> E \\<union> E\\<inverse>\\<rbrakk>\n       \\<Longrightarrow> (cf (u, xi) \\<noteq> 0) = (cf (u, x) \\<noteq> 0)\n 4. \\<And>x xi s si.\n       \\<lbrakk>u \\<in> V; u \\<in> V; u \\<in> V; (xi, x) \\<in> nat_rel;\n        (si, s) \\<in> Id; (u, x) \\<in> E \\<union> E\\<inverse>; x \\<in> V;\n        (u, xi) \\<in> E \\<union> E\\<inverse>; xi \\<in> V;\n        (u, xi) \\<in> E \\<union> E\\<inverse>; cf (u, xi) \\<noteq> 0;\n        cf (u, x) \\<noteq> 0; xi \\<in> V\\<rbrakk>\n       \\<Longrightarrow> (si, s)\n                         \\<in> \\<langle>?Ra16 x xi s si\\<rangle>option_rel\n 5. \\<And>x xi s si.\n       \\<lbrakk>u \\<in> V; u \\<in> V; u \\<in> V; (xi, x) \\<in> nat_rel;\n        (si, s) \\<in> Id; (u, x) \\<in> E \\<union> E\\<inverse>; x \\<in> V;\n        (u, xi) \\<in> E \\<union> E\\<inverse>; xi \\<in> V;\n        (u, xi) \\<in> E \\<union> E\\<inverse>; cf (u, xi) \\<noteq> 0;\n        cf (u, x) \\<noteq> 0; xi \\<in> V; si = None; s = None\\<rbrakk>\n       \\<Longrightarrow> (Some (l xi), Some (l x)) \\<in> Id\n 6. \\<And>x xi s si xa x'.\n       \\<lbrakk>u \\<in> V; u \\<in> V; u \\<in> V; (xi, x) \\<in> nat_rel;\n        (si, s) \\<in> Id; (u, x) \\<in> E \\<union> E\\<inverse>; x \\<in> V;\n        (u, xi) \\<in> E \\<union> E\\<inverse>; xi \\<in> V;\n        (u, xi) \\<in> E \\<union> E\\<inverse>; cf (u, xi) \\<noteq> 0;\n        cf (u, x) \\<noteq> 0; xi \\<in> V; si = Some xa; s = Some x';\n        (xa, x') \\<in> ?Ra16 x xi s si\\<rbrakk>\n       \\<Longrightarrow> (Some (min (l xi) xa), Some (min (l x) x'))\n                         \\<in> Id\n 7. \\<And>x xa.\n       \\<lbrakk>u \\<in> V; u \\<in> V; u \\<in> V; (x, xa) \\<in> Id;\n        xa \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> None\n 8. \\<And>x xa.\n       \\<lbrakk>u \\<in> V; u \\<in> V; u \\<in> V; (x, xa) \\<in> Id;\n        xa \\<noteq> None; x \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> (the x, the xa) \\<in> nat_rel", "apply refine_dref_type"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x xi s si.\n       \\<lbrakk>u \\<in> V; u \\<in> V; u \\<in> V; (xi, x) \\<in> nat_rel;\n        (si, s) \\<in> Id; (u, x) \\<in> E \\<union> E\\<inverse>;\n        x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> (u, xi) \\<in> E \\<union> E\\<inverse>\n 2. \\<And>x xi s si.\n       \\<lbrakk>u \\<in> V; u \\<in> V; u \\<in> V; (xi, x) \\<in> nat_rel;\n        (si, s) \\<in> Id; (u, x) \\<in> E \\<union> E\\<inverse>; x \\<in> V;\n        (u, xi) \\<in> E \\<union> E\\<inverse>\\<rbrakk>\n       \\<Longrightarrow> xi \\<in> V\n 3. \\<And>x xi s si.\n       \\<lbrakk>u \\<in> V; u \\<in> V; u \\<in> V; (xi, x) \\<in> nat_rel;\n        (si, s) \\<in> Id; (u, x) \\<in> E \\<union> E\\<inverse>; x \\<in> V;\n        (u, xi) \\<in> E \\<union> E\\<inverse>; xi \\<in> V;\n        (u, xi) \\<in> E \\<union> E\\<inverse>\\<rbrakk>\n       \\<Longrightarrow> (cf (u, xi) \\<noteq> 0) = (cf (u, x) \\<noteq> 0)\n 4. \\<And>x xi s si.\n       \\<lbrakk>u \\<in> V; u \\<in> V; u \\<in> V; (xi, x) \\<in> nat_rel;\n        (si, s) \\<in> Id; (u, x) \\<in> E \\<union> E\\<inverse>; x \\<in> V;\n        (u, xi) \\<in> E \\<union> E\\<inverse>; xi \\<in> V;\n        (u, xi) \\<in> E \\<union> E\\<inverse>; cf (u, xi) \\<noteq> 0;\n        cf (u, x) \\<noteq> 0; xi \\<in> V\\<rbrakk>\n       \\<Longrightarrow> (si, s) \\<in> \\<langle>nat_rel\\<rangle>option_rel\n 5. \\<And>x xi s si.\n       \\<lbrakk>u \\<in> V; u \\<in> V; u \\<in> V; (xi, x) \\<in> nat_rel;\n        (si, s) \\<in> Id; (u, x) \\<in> E \\<union> E\\<inverse>; x \\<in> V;\n        (u, xi) \\<in> E \\<union> E\\<inverse>; xi \\<in> V;\n        (u, xi) \\<in> E \\<union> E\\<inverse>; cf (u, xi) \\<noteq> 0;\n        cf (u, x) \\<noteq> 0; xi \\<in> V; si = None; s = None\\<rbrakk>\n       \\<Longrightarrow> (Some (l xi), Some (l x)) \\<in> Id\n 6. \\<And>x xi s si xa x'.\n       \\<lbrakk>u \\<in> V; u \\<in> V; u \\<in> V; (xi, x) \\<in> nat_rel;\n        (si, s) \\<in> Id; (u, x) \\<in> E \\<union> E\\<inverse>; x \\<in> V;\n        (u, xi) \\<in> E \\<union> E\\<inverse>; xi \\<in> V;\n        (u, xi) \\<in> E \\<union> E\\<inverse>; cf (u, xi) \\<noteq> 0;\n        cf (u, x) \\<noteq> 0; xi \\<in> V; si = Some xa; s = Some x';\n        (xa, x') \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (Some (min (l xi) xa), Some (min (l x) x'))\n                         \\<in> Id\n 7. \\<And>x xa.\n       \\<lbrakk>u \\<in> V; u \\<in> V; u \\<in> V; (x, xa) \\<in> Id;\n        xa \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> None\n 8. \\<And>x xa.\n       \\<lbrakk>u \\<in> V; u \\<in> V; u \\<in> V; (x, xa) \\<in> Id;\n        xa \\<noteq> None; x \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> (the x, the xa) \\<in> nat_rel", "by auto"], ["proof (state)\nthis:\n  min_adj_label am cf l u \\<le> \\<Down> nat_rel (min_adj_label_aux cf l u)\n\ngoal (1 subgoal):\n 1. min_adj_label am cf l u\n    \\<le> (spec x. x = Min {l v |v. (u, v) \\<in> cf.E})", "also"], ["proof (state)\nthis:\n  min_adj_label am cf l u \\<le> \\<Down> nat_rel (min_adj_label_aux cf l u)\n\ngoal (1 subgoal):\n 1. min_adj_label am cf l u\n    \\<le> (spec x. x = Min {l v |v. (u, v) \\<in> cf.E})", "note min_adj_label_aux_spec[OF PRE]"], ["proof (state)\nthis:\n  min_adj_label_aux cf l u\n  \\<le> (spec x. x = Min {l v |v. (u, v) \\<in> cf.E})\n\ngoal (1 subgoal):\n 1. min_adj_label am cf l u\n    \\<le> (spec x. x = Min {l v |v. (u, v) \\<in> cf.E})", "finally"], ["proof (chain)\npicking this:\n  min_adj_label am cf l u\n  \\<le> (spec x. x = Min {l v |v. (u, v) \\<in> cf.E})", "show ?thesis"], ["proof (prove)\nusing this:\n  min_adj_label am cf l u\n  \\<le> (spec x. x = Min {l v |v. (u, v) \\<in> cf.E})\n\ngoal (1 subgoal):\n 1. min_adj_label am cf l u\n    \\<le> (spec x. x = Min {l v |v. (u, v) \\<in> cf.E})", "by simp"], ["proof (state)\nthis:\n  min_adj_label am cf l u\n  \\<le> (spec x. x = Min {l v |v. (u, v) \\<in> cf.E})\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Refinement of Relabel\\<close>"], ["", "text \\<open>Utilities to Implement Relabel Operations\\<close>"], ["", "definition \"relabel2 am cf l u \\<equiv> do {\n  assert (u\\<in>V - {s,t});\n  nl \\<leftarrow> min_adj_label am cf l u;\n  l \\<leftarrow> l_set l u (nl+1);\n  return l\n}\""], ["", "lemma relabel2_refine[refine]: \n  assumes \"((x,cf),f)\\<in>xf_rel\"\n  assumes AM: \"(am,adjacent_nodes)\\<in>nat_rel\\<rightarrow>\\<langle>nat_rel\\<rangle>list_set_rel\"\n  assumes [simplified,simp]: \"(li,l)\\<in>Id\" \"(ui,u)\\<in>Id\"\n  shows \"relabel2 am cf li ui \\<le> \\<Down>Id (relabel f l u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. relabel2 am cf li ui \\<le> \\<Down> Id (relabel f l u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. relabel2 am cf li ui \\<le> \\<Down> Id (relabel f l u)", "have [simp]: \"{l v |v. v \\<in> V \\<and> cf_of f (u, v) \\<noteq> 0} = {l v |v. cf_of f (u, v) \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l v |v. v \\<in> V \\<and> cf_of f (u, v) \\<noteq> 0} =\n    {l v |v. cf_of f (u, v) \\<noteq> 0}", "using cfE_of_ss_VxV[of f]"], ["proof (prove)\nusing this:\n  cfE_of f \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. {l v |v. v \\<in> V \\<and> cf_of f (u, v) \\<noteq> 0} =\n    {l v |v. cf_of f (u, v) \\<noteq> 0}", "by (auto simp: Graph.E_def)"], ["proof (state)\nthis:\n  {l v |v. v \\<in> V \\<and> cf_of f (u, v) \\<noteq> 0} =\n  {l v |v. cf_of f (u, v) \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. relabel2 am cf li ui \\<le> \\<Down> Id (relabel f l u)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. relabel2 am cf li ui \\<le> \\<Down> Id (relabel f l u)", "using assms"], ["proof (prove)\nusing this:\n  ((x, cf), f) \\<in> xf_rel\n  (am, adjacent_nodes)\n  \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel\n  (li, l) \\<in> Id\n  (ui, u) \\<in> nat_rel\n\ngoal (1 subgoal):\n 1. relabel2 am cf li ui \\<le> \\<Down> Id (relabel f l u)", "unfolding relabel2_def relabel_def"], ["proof (prove)\nusing this:\n  ((x, cf), f) \\<in> xf_rel\n  (am, adjacent_nodes)\n  \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel\n  (li, l) \\<in> Id\n  (ui, u) \\<in> nat_rel\n\ngoal (1 subgoal):\n 1. assert (ui \\<in> V - {s, t}) \\<bind>\n    (\\<lambda>_.\n        min_adj_label am cf li ui \\<bind>\n        (\\<lambda>nl. l_set li ui (nl + 1) \\<bind> return))\n    \\<le> \\<Down> Id\n           (assert (Height_Bounded_Labeling c s t f l) \\<bind>\n            (\\<lambda>_.\n                assert (relabel_precond f l u) \\<bind>\n                (\\<lambda>_.\n                    assert (u \\<in> V - {s, t}) \\<bind>\n                    (\\<lambda>_. return (relabel_effect f l u)))))", "unfolding l_set_def"], ["proof (prove)\nusing this:\n  ((x, cf), f) \\<in> xf_rel\n  (am, adjacent_nodes)\n  \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel\n  (li, l) \\<in> Id\n  (ui, u) \\<in> nat_rel\n\ngoal (1 subgoal):\n 1. assert (ui \\<in> V - {s, t}) \\<bind>\n    (\\<lambda>_.\n        min_adj_label am cf li ui \\<bind>\n        (\\<lambda>nl.\n            assert (ui \\<in> V) \\<bind>\n            (\\<lambda>_.\n                assert (nl + 1 < 2 * card V) \\<bind>\n                (\\<lambda>_. return (li(ui := nl + 1)))) \\<bind>\n            return))\n    \\<le> \\<Down> Id\n           (assert (Height_Bounded_Labeling c s t f l) \\<bind>\n            (\\<lambda>_.\n                assert (relabel_precond f l u) \\<bind>\n                (\\<lambda>_.\n                    assert (u \\<in> V - {s, t}) \\<bind>\n                    (\\<lambda>_. return (relabel_effect f l u)))))", "apply (refine_vcg AM)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>((x, cf), f) \\<in> xf_rel;\n     (am, adjacent_nodes)\n     \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n     (li, l) \\<in> Id; (ui, u) \\<in> nat_rel;\n     Height_Bounded_Labeling c s t f l; relabel_precond f l u;\n     u \\<in> V - {s, t}\\<rbrakk>\n    \\<Longrightarrow> ui \\<in> V - {s, t}\n 2. \\<lbrakk>((x, cf), f) \\<in> xf_rel;\n     (am, adjacent_nodes)\n     \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n     (li, l) \\<in> Id; (ui, u) \\<in> nat_rel;\n     Height_Bounded_Labeling c s t f l; relabel_precond f l u;\n     u \\<in> V - {s, t}; ui \\<in> V - {s, t}\\<rbrakk>\n    \\<Longrightarrow> Height_Bounded_Labeling c s t ?f10 li\n 3. \\<lbrakk>((x, cf), f) \\<in> xf_rel;\n     (am, adjacent_nodes)\n     \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n     (li, l) \\<in> Id; (ui, u) \\<in> nat_rel;\n     Height_Bounded_Labeling c s t f l; relabel_precond f l u;\n     u \\<in> V - {s, t}; ui \\<in> V - {s, t}\\<rbrakk>\n    \\<Longrightarrow> relabel_precond ?f10 li ui\n 4. \\<lbrakk>((x, cf), f) \\<in> xf_rel;\n     (am, adjacent_nodes)\n     \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n     (li, l) \\<in> Id; (ui, u) \\<in> nat_rel;\n     Height_Bounded_Labeling c s t f l; relabel_precond f l u;\n     u \\<in> V - {s, t}; ui \\<in> V - {s, t}\\<rbrakk>\n    \\<Longrightarrow> cf = cf_of ?f10\n 5. \\<And>xa.\n       \\<lbrakk>((x, cf), f) \\<in> xf_rel;\n        (am, adjacent_nodes)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (li, l) \\<in> Id; (ui, u) \\<in> nat_rel;\n        Height_Bounded_Labeling c s t f l; relabel_precond f l u;\n        u \\<in> V - {s, t}; ui \\<in> V - {s, t};\n        xa = Min {li v |v. (ui, v) \\<in> cfE_of ?f10}\\<rbrakk>\n       \\<Longrightarrow> ui \\<in> V\n 6. \\<And>xa.\n       \\<lbrakk>((x, cf), f) \\<in> xf_rel;\n        (am, adjacent_nodes)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (li, l) \\<in> Id; (ui, u) \\<in> nat_rel;\n        Height_Bounded_Labeling c s t f l; relabel_precond f l u;\n        u \\<in> V - {s, t}; ui \\<in> V - {s, t};\n        xa = Min {li v |v. (ui, v) \\<in> cfE_of ?f10}; ui \\<in> V\\<rbrakk>\n       \\<Longrightarrow> xa + 1 < 2 * card V\n 7. \\<And>xa.\n       \\<lbrakk>((x, cf), f) \\<in> xf_rel;\n        (am, adjacent_nodes)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (li, l) \\<in> Id; (ui, u) \\<in> nat_rel;\n        Height_Bounded_Labeling c s t f l; relabel_precond f l u;\n        u \\<in> V - {s, t}; ui \\<in> V - {s, t};\n        xa = Min {li v |v. (ui, v) \\<in> cfE_of ?f10}; ui \\<in> V;\n        xa + 1 < 2 * card V\\<rbrakk>\n       \\<Longrightarrow> (li(ui := xa + 1), relabel_effect f l u) \\<in> Id", "apply (vc_solve (nopre) simp: xf_rel_def relabel_effect_def solve: asm_rl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>((x, cf), f) \\<in> xf_rel;\n        (am, adjacent_nodes)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (li, l) \\<in> Id; (ui, u) \\<in> nat_rel;\n        Height_Bounded_Labeling c s t f l; relabel_precond f l u;\n        u \\<in> V - {s, t}; ui \\<in> V - {s, t};\n        xa = Min {li v |v. (ui, v) \\<in> cfE_of f}; ui \\<in> V\\<rbrakk>\n       \\<Longrightarrow> xa + 1 < 2 * card V", "subgoal premises prems for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + 1 < 2 * card V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a + 1 < 2 * card V", "from prems"], ["proof (chain)\npicking this:\n  ((x, cf), f) \\<in> xf_rel\n  (am, adjacent_nodes)\n  \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel\n  (li, l) \\<in> Id\n  (ui, u) \\<in> nat_rel\n  Height_Bounded_Labeling c s t f l\n  relabel_precond f l u\n  u \\<in> V - {s, t}\n  ui \\<in> V - {s, t}\n  a = Min {li v |v. (ui, v) \\<in> cfE_of f}\n  ui \\<in> V", "interpret Height_Bounded_Labeling c s t f l"], ["proof (prove)\nusing this:\n  ((x, cf), f) \\<in> xf_rel\n  (am, adjacent_nodes)\n  \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel\n  (li, l) \\<in> Id\n  (ui, u) \\<in> nat_rel\n  Height_Bounded_Labeling c s t f l\n  relabel_precond f l u\n  u \\<in> V - {s, t}\n  ui \\<in> V - {s, t}\n  a = Min {li v |v. (ui, v) \\<in> cfE_of f}\n  ui \\<in> V\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f l", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. a + 1 < 2 * card V", "interpret l': Height_Bounded_Labeling c s t f \"relabel_effect f l u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f (relabel_effect f l u)", "by (rule relabel_pres_height_bound) (rule prems)"], ["proof (state)\ngoal (1 subgoal):\n 1. a + 1 < 2 * card V", "from prems"], ["proof (chain)\npicking this:\n  ((x, cf), f) \\<in> xf_rel\n  (am, adjacent_nodes)\n  \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel\n  (li, l) \\<in> Id\n  (ui, u) \\<in> nat_rel\n  Height_Bounded_Labeling c s t f l\n  relabel_precond f l u\n  u \\<in> V - {s, t}\n  ui \\<in> V - {s, t}\n  a = Min {li v |v. (ui, v) \\<in> cf.E}\n  ui \\<in> V", "have \"u\\<in>V\""], ["proof (prove)\nusing this:\n  ((x, cf), f) \\<in> xf_rel\n  (am, adjacent_nodes)\n  \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel\n  (li, l) \\<in> Id\n  (ui, u) \\<in> nat_rel\n  Height_Bounded_Labeling c s t f l\n  relabel_precond f l u\n  u \\<in> V - {s, t}\n  ui \\<in> V - {s, t}\n  a = Min {li v |v. (ui, v) \\<in> cf.E}\n  ui \\<in> V\n\ngoal (1 subgoal):\n 1. u \\<in> V", "by simp"], ["proof (state)\nthis:\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. a + 1 < 2 * card V", "from prems"], ["proof (chain)\npicking this:\n  ((x, cf), f) \\<in> xf_rel\n  (am, adjacent_nodes)\n  \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel\n  (li, l) \\<in> Id\n  (ui, u) \\<in> nat_rel\n  Height_Bounded_Labeling c s t f l\n  relabel_precond f l u\n  u \\<in> V - {s, t}\n  ui \\<in> V - {s, t}\n  a = Min {li v |v. (ui, v) \\<in> cf.E}\n  ui \\<in> V", "have \"a + 1 = relabel_effect f l u u\""], ["proof (prove)\nusing this:\n  ((x, cf), f) \\<in> xf_rel\n  (am, adjacent_nodes)\n  \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel\n  (li, l) \\<in> Id\n  (ui, u) \\<in> nat_rel\n  Height_Bounded_Labeling c s t f l\n  relabel_precond f l u\n  u \\<in> V - {s, t}\n  ui \\<in> V - {s, t}\n  a = Min {li v |v. (ui, v) \\<in> cf.E}\n  ui \\<in> V\n\ngoal (1 subgoal):\n 1. a + 1 = relabel_effect f l u u", "by (auto simp: relabel_effect_def)"], ["proof (state)\nthis:\n  a + 1 = relabel_effect f l u u\n\ngoal (1 subgoal):\n 1. a + 1 < 2 * card V", "also"], ["proof (state)\nthis:\n  a + 1 = relabel_effect f l u u\n\ngoal (1 subgoal):\n 1. a + 1 < 2 * card V", "note l'.height_bound[THEN bspec, OF \\<open>u\\<in>V\\<close>]"], ["proof (state)\nthis:\n  relabel_effect f l u u \\<le> 2 * card V - 1\n\ngoal (1 subgoal):\n 1. a + 1 < 2 * card V", "finally"], ["proof (chain)\npicking this:\n  a + 1 \\<le> 2 * card V - 1", "show \"a + 1 < 2 * card V\""], ["proof (prove)\nusing this:\n  a + 1 \\<le> 2 * card V - 1\n\ngoal (1 subgoal):\n 1. a + 1 < 2 * card V", "using card_V_ge2"], ["proof (prove)\nusing this:\n  a + 1 \\<le> 2 * card V - 1\n  2 \\<le> card V\n\ngoal (1 subgoal):\n 1. a + 1 < 2 * card V", "by auto"], ["proof (state)\nthis:\n  a + 1 < 2 * card V\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  relabel2 am cf li ui \\<le> \\<Down> Id (relabel f l u)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Refinement of Push\\<close>"], ["", "definition \"push2_aux x cf \\<equiv> \\<lambda>(u,v). do {\n  assert ( (u,v) \\<in> E \\<union> E\\<inverse> );\n  assert ( u \\<noteq> v );\n  let \\<Delta> = min (x u) (cf (u,v));\n  return ((x( u := x u - \\<Delta>, v := x v + \\<Delta> ),augment_edge_cf cf (u,v) \\<Delta>))\n}\""], ["", "lemma push2_aux_refine: \n  \"\\<lbrakk>((x,cf),f)\\<in>xf_rel; (ei,e)\\<in>Id\\<times>\\<^sub>rId\\<rbrakk> \n    \\<Longrightarrow> push2_aux x cf ei \\<le> \\<Down>xf_rel (push f l e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((x, cf), f) \\<in> xf_rel;\n     (ei, e) \\<in> nat_rel \\<times>\\<^sub>r nat_rel\\<rbrakk>\n    \\<Longrightarrow> push2_aux x cf ei \\<le> \\<Down> xf_rel (push f l e)", "unfolding push_def push2_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((x, cf), f) \\<in> xf_rel;\n     (ei, e) \\<in> nat_rel \\<times>\\<^sub>r nat_rel\\<rbrakk>\n    \\<Longrightarrow> (case ei of\n                       (u, v) \\<Rightarrow>\n                         assert\n                          ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n                         (\\<lambda>_.\n                             assert (u \\<noteq> v) \\<bind>\n                             (\\<lambda>_.\n                                 let \\<Delta> = min (x u) (cf (u, v))\n                                 in return\n                                     (x\n(u := x u - \\<Delta>, v := x v + \\<Delta>),\naugment_edge_cf cf (u, v) \\<Delta>))))\n                      \\<le> \\<Down> xf_rel\n                             (case e of\n                              (u, v) \\<Rightarrow>\n                                assert (push_precond f l (u, v)) \\<bind>\n                                (\\<lambda>_.\n                                    assert (Labeling c s t f l) \\<bind>\n                                    (\\<lambda>_.\n  return (push_effect f (u, v)))))", "apply refine_vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>((x, cf), f) \\<in> xf_rel;\n        (ei, e) \\<in> nat_rel \\<times>\\<^sub>r nat_rel; e = (x1, x2);\n        ei = (x1a, x2a); push_precond f l (x1, x2);\n        Labeling c s t f l\\<rbrakk>\n       \\<Longrightarrow> (x1a, x2a) \\<in> E \\<union> E\\<inverse>\n 2. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>((x, cf), f) \\<in> xf_rel;\n        (ei, e) \\<in> nat_rel \\<times>\\<^sub>r nat_rel; e = (x1, x2);\n        ei = (x1a, x2a); push_precond f l (x1, x2); Labeling c s t f l;\n        (x1a, x2a) \\<in> E \\<union> E\\<inverse>\\<rbrakk>\n       \\<Longrightarrow> x1a \\<noteq> x2a\n 3. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>((x, cf), f) \\<in> xf_rel;\n        (ei, e) \\<in> nat_rel \\<times>\\<^sub>r nat_rel; e = (x1, x2);\n        ei = (x1a, x2a); push_precond f l (x1, x2); Labeling c s t f l;\n        (x1a, x2a) \\<in> E \\<union> E\\<inverse>; x1a \\<noteq> x2a\\<rbrakk>\n       \\<Longrightarrow> ((x(x1a := x x1a - min (x x1a) (cf (x1a, x2a)),\n                             x2a := x x2a + min (x x1a) (cf (x1a, x2a))),\n                           augment_edge_cf cf (x1a, x2a)\n                            (min (x x1a) (cf (x1a, x2a)))),\n                          push_effect f (x1, x2))\n                         \\<in> xf_rel", "apply (vc_solve simp: xf_rel_def no_self_loop)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>e = (x1, x2); ei = (x1, x2); push_precond f l (x1, x2);\n        Labeling c s t f l; x = excess f; cf = cf_of f;\n        (x2, x1) \\<notin> E\\<rbrakk>\n       \\<Longrightarrow> (x1, x2) \\<in> E\n 2. \\<And>x1 x2.\n       \\<lbrakk>e = (x1, x2); ei = (x1, x2); push_precond f l (x1, x2);\n        Labeling c s t f l; (x1, x2) \\<in> E \\<or> (x2, x1) \\<in> E;\n        x1 \\<noteq> x2; x = excess f; cf = cf_of f\\<rbrakk>\n       \\<Longrightarrow> (excess f)\n                         (x1 :=\n                            excess f x1 -\n                            min (excess f x1) (cf_of f (x1, x2)),\n                          x2 :=\n                            excess f x2 +\n                            min (excess f x1) (cf_of f (x1, x2))) =\n                         excess (push_effect f (x1, x2)) \\<and>\n                         augment_edge_cf (cf_of f) (x1, x2)\n                          (min (excess f x1) (cf_of f (x1, x2))) =\n                         cf_of (push_effect f (x1, x2))", "subgoal for u v"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>e = (u, v); ei = (u, v); push_precond f l (u, v);\n     Labeling c s t f l; x = excess f; cf = cf_of f;\n     (v, u) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> E", "unfolding push_precond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>e = (u, v); ei = (u, v);\n     case (u, v) of\n     (u, v) \\<Rightarrow>\n       0 < excess f u \\<and> (u, v) \\<in> cfE_of f \\<and> l u = l v + 1;\n     Labeling c s t f l; x = excess f; cf = cf_of f;\n     (v, u) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> E", "using cfE_of_ss_invE"], ["proof (prove)\nusing this:\n  cfE_of ?cf \\<subseteq> E \\<union> E\\<inverse>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e = (u, v); ei = (u, v);\n     case (u, v) of\n     (u, v) \\<Rightarrow>\n       0 < excess f u \\<and> (u, v) \\<in> cfE_of f \\<and> l u = l v + 1;\n     Labeling c s t f l; x = excess f; cf = cf_of f;\n     (v, u) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> E", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>e = (x1, x2); ei = (x1, x2); push_precond f l (x1, x2);\n        Labeling c s t f l; (x1, x2) \\<in> E \\<or> (x2, x1) \\<in> E;\n        x1 \\<noteq> x2; x = excess f; cf = cf_of f\\<rbrakk>\n       \\<Longrightarrow> (excess f)\n                         (x1 :=\n                            excess f x1 -\n                            min (excess f x1) (cf_of f (x1, x2)),\n                          x2 :=\n                            excess f x2 +\n                            min (excess f x1) (cf_of f (x1, x2))) =\n                         excess (push_effect f (x1, x2)) \\<and>\n                         augment_edge_cf (cf_of f) (x1, x2)\n                          (min (excess f x1) (cf_of f (x1, x2))) =\n                         cf_of (push_effect f (x1, x2))", "subgoal for u v"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>e = (u, v); ei = (u, v); push_precond f l (u, v);\n     Labeling c s t f l; (u, v) \\<in> E \\<or> (v, u) \\<in> E; u \\<noteq> v;\n     x = excess f; cf = cf_of f\\<rbrakk>\n    \\<Longrightarrow> (excess f)\n                      (u := excess f u - min (excess f u) (cf_of f (u, v)),\n                       v := excess f v +\n                            min (excess f u) (cf_of f (u, v))) =\n                      excess (push_effect f (u, v)) \\<and>\n                      augment_edge_cf (cf_of f) (u, v)\n                       (min (excess f u) (cf_of f (u, v))) =\n                      cf_of (push_effect f (u, v))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>e = (u, v); ei = (u, v); push_precond f l (u, v);\n     Labeling c s t f l; (u, v) \\<in> E \\<or> (v, u) \\<in> E; u \\<noteq> v;\n     x = excess f; cf = cf_of f\\<rbrakk>\n    \\<Longrightarrow> (excess f)\n                      (u := excess f u - min (excess f u) (cf_of f (u, v)),\n                       v := excess f v +\n                            min (excess f u) (cf_of f (u, v))) =\n                      excess (push_effect f (u, v)) \\<and>\n                      augment_edge_cf (cf_of f) (u, v)\n                       (min (excess f u) (cf_of f (u, v))) =\n                      cf_of (push_effect f (u, v))", "assume [simp]: \"Labeling c s t f l\""], ["proof (state)\nthis:\n  Labeling c s t f l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e = (u, v); ei = (u, v); push_precond f l (u, v);\n     Labeling c s t f l; (u, v) \\<in> E \\<or> (v, u) \\<in> E; u \\<noteq> v;\n     x = excess f; cf = cf_of f\\<rbrakk>\n    \\<Longrightarrow> (excess f)\n                      (u := excess f u - min (excess f u) (cf_of f (u, v)),\n                       v := excess f v +\n                            min (excess f u) (cf_of f (u, v))) =\n                      excess (push_effect f (u, v)) \\<and>\n                      augment_edge_cf (cf_of f) (u, v)\n                       (min (excess f u) (cf_of f (u, v))) =\n                      cf_of (push_effect f (u, v))", "then"], ["proof (chain)\npicking this:\n  Labeling c s t f l", "interpret Labeling c s t f l"], ["proof (prove)\nusing this:\n  Labeling c s t f l\n\ngoal (1 subgoal):\n 1. Labeling c s t f l", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>e = (u, v); ei = (u, v); push_precond f l (u, v);\n     Labeling c s t f l; (u, v) \\<in> E \\<or> (v, u) \\<in> E; u \\<noteq> v;\n     x = excess f; cf = cf\\<rbrakk>\n    \\<Longrightarrow> (excess f)\n                      (u := excess f u - min (excess f u) (cf (u, v)),\n                       v := excess f v + min (excess f u) (cf (u, v))) =\n                      excess (push_effect f (u, v)) \\<and>\n                      augment_edge_cf cf (u, v)\n                       (min (excess f u) (cf (u, v))) =\n                      cf_of (push_effect f (u, v))", "assume \"push_precond f l (u, v)\""], ["proof (state)\nthis:\n  push_precond f l (u, v)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e = (u, v); ei = (u, v); push_precond f l (u, v);\n     Labeling c s t f l; (u, v) \\<in> E \\<or> (v, u) \\<in> E; u \\<noteq> v;\n     x = excess f; cf = cf\\<rbrakk>\n    \\<Longrightarrow> (excess f)\n                      (u := excess f u - min (excess f u) (cf (u, v)),\n                       v := excess f v + min (excess f u) (cf (u, v))) =\n                      excess (push_effect f (u, v)) \\<and>\n                      augment_edge_cf cf (u, v)\n                       (min (excess f u) (cf (u, v))) =\n                      cf_of (push_effect f (u, v))", "then"], ["proof (chain)\npicking this:\n  push_precond f l (u, v)", "interpret l': push_effect_locale c s t f l u v"], ["proof (prove)\nusing this:\n  push_precond f l (u, v)\n\ngoal (1 subgoal):\n 1. push_effect_locale c s t f l u v", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>e = (u, v); ei = (u, v); push_precond f l (u, v);\n     Labeling c s t f l; (u, v) \\<in> E \\<or> (v, u) \\<in> E; u \\<noteq> v;\n     x = excess f; cf = cf\\<rbrakk>\n    \\<Longrightarrow> (excess f)\n                      (u := excess f u - min (excess f u) (cf (u, v)),\n                       v := excess f v + min (excess f u) (cf (u, v))) =\n                      excess l'.f' \\<and>\n                      augment_edge_cf cf (u, v)\n                       (min (excess f u) (cf (u, v))) =\n                      l'.l'.cf", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (excess f)\n    (u := excess f u - min (excess f u) (cf (u, v)),\n     v := excess f v + min (excess f u) (cf (u, v))) =\n    excess l'.f' \\<and>\n    augment_edge_cf cf (u, v) (min (excess f u) (cf (u, v))) = l'.l'.cf", "apply (safe intro!: ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       ((excess f)\n        (u := excess f u - min (excess f u) (cf (u, v)),\n         v := excess f v + min (excess f u) (cf (u, v))))\n        x =\n       excess l'.f' x\n 2. \\<And>a b.\n       augment_edge_cf cf (u, v) (min (excess f u) (cf (u, v))) (a, b) =\n       l'.l'.cf (a, b)", "using l'.excess'_if l'.\\<Delta>_def l'.cf'_alt l'.uv_not_eq(1)"], ["proof (prove)\nusing this:\n  excess l'.f' ?x =\n  (if ?x = u then excess f u - l'.\\<Delta>\n   else if ?x = v then excess f v + l'.\\<Delta> else excess f ?x)\n  l'.\\<Delta> = min (excess f u) (cf (u, v))\n  l'.l'.cf = augment_edge_cf cf (u, v) l'.\\<Delta>\n  u \\<noteq> v\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       ((excess f)\n        (u := excess f u - min (excess f u) (cf (u, v)),\n         v := excess f v + min (excess f u) (cf (u, v))))\n        x =\n       excess l'.f' x\n 2. \\<And>a b.\n       augment_edge_cf cf (u, v) (min (excess f u) (cf (u, v))) (a, b) =\n       l'.l'.cf (a, b)", "by (auto)"], ["proof (state)\nthis:\n  (excess f)\n  (u := excess f u - min (excess f u) (cf (u, v)),\n   v := excess f v + min (excess f u) (cf (u, v))) =\n  excess l'.f' \\<and>\n  augment_edge_cf cf (u, v) (min (excess f u) (cf (u, v))) = l'.l'.cf\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"push2 x cf \\<equiv> \\<lambda>(u,v). do {\n  assert ( (u,v) \\<in> E \\<union> E\\<inverse> );\n  xu \\<leftarrow> x_get x u;\n  cfuv \\<leftarrow> cf_get cf (u,v);\n  cfvu \\<leftarrow> cf_get cf (v,u);\n  let \\<Delta> = min xu cfuv;\n  x \\<leftarrow> x_add x u (-\\<Delta>);\n  x \\<leftarrow> x_add x v \\<Delta>;\n\n  cf \\<leftarrow> cf_set cf (u,v) (cfuv - \\<Delta>);\n  cf \\<leftarrow> cf_set cf (v,u) (cfvu + \\<Delta>);\n\n  return (x,cf)\n}\""], ["", "lemma push2_refine[refine]: \n  assumes \"((x,cf),f)\\<in>xf_rel\" \"(ei,e)\\<in>Id\\<times>\\<^sub>rId\"\n  shows \"push2 x cf ei \\<le> \\<Down>xf_rel (push f l e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. push2 x cf ei \\<le> \\<Down> xf_rel (push f l e)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. push2 x cf ei \\<le> \\<Down> xf_rel (push f l e)", "have \"push2 x cf ei \\<le> (push2_aux x cf ei)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. push2 x cf ei \\<le> push2_aux x cf ei", "unfolding push2_def push2_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case ei of\n     (u, v) \\<Rightarrow>\n       assert ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n       (\\<lambda>_.\n           x_get x u \\<bind>\n           (\\<lambda>xu.\n               cf_get cf (u, v) \\<bind>\n               (\\<lambda>cfuv.\n                   cf_get cf (v, u) \\<bind>\n                   (\\<lambda>cfvu.\n                       let \\<Delta> = min xu cfuv\n                       in x_add x u (- \\<Delta>) \\<bind>\n                          (\\<lambda>x.\n                              x_add x v \\<Delta> \\<bind>\n                              (\\<lambda>x.\n                                  cf_set cf (u, v) (cfuv - \\<Delta>) \\<bind>\n                                  (\\<lambda>cf.\ncf_set cf (v, u) (cfvu + \\<Delta>) \\<bind>\n(\\<lambda>cf. return (x, cf))))))))))\n    \\<le> (case ei of\n           (u, v) \\<Rightarrow>\n             assert ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n             (\\<lambda>_.\n                 assert (u \\<noteq> v) \\<bind>\n                 (\\<lambda>_.\n                     let \\<Delta> = min (x u) (cf (u, v))\n                     in return\n                         (x(u := x u - \\<Delta>, v := x v + \\<Delta>),\n                          augment_edge_cf cf (u, v) \\<Delta>))))", "unfolding x_get_def x_add_def cf_get_def cf_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case ei of\n     (u, v) \\<Rightarrow>\n       assert ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n       (\\<lambda>_.\n           assert (u \\<in> V) \\<bind> (\\<lambda>_. return (x u)) \\<bind>\n           (\\<lambda>xu.\n               assert ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n               (\\<lambda>_. return (cf (u, v))) \\<bind>\n               (\\<lambda>cfuv.\n                   assert ((v, u) \\<in> E \\<union> E\\<inverse>) \\<bind>\n                   (\\<lambda>_. return (cf (v, u))) \\<bind>\n                   (\\<lambda>cfvu.\n                       let \\<Delta> = min xu cfuv\n                       in assert (u \\<in> V) \\<bind>\n                          (\\<lambda>_.\n                              return (x(u := x u + - \\<Delta>))) \\<bind>\n                          (\\<lambda>x.\n                              assert (v \\<in> V) \\<bind>\n                              (\\<lambda>_.\n                                  return (x(v := x v + \\<Delta>))) \\<bind>\n                              (\\<lambda>x.\n                                  assert\n                                   ((u, v)\n                                    \\<in> E \\<union> E\\<inverse>) \\<bind>\n                                  (\\<lambda>_.\nreturn (cf((u, v) := cfuv - \\<Delta>))) \\<bind>\n                                  (\\<lambda>cf.\nassert ((v, u) \\<in> E \\<union> E\\<inverse>) \\<bind>\n(\\<lambda>_. return (cf((v, u) := cfvu + \\<Delta>))) \\<bind>\n(\\<lambda>cf. return (x, cf))))))))))\n    \\<le> (case ei of\n           (u, v) \\<Rightarrow>\n             assert ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n             (\\<lambda>_.\n                 assert (u \\<noteq> v) \\<bind>\n                 (\\<lambda>_.\n                     let \\<Delta> = min (x u) (cf (u, v))\n                     in return\n                         (x(u := x u - \\<Delta>, v := x v + \\<Delta>),\n                          augment_edge_cf cf (u, v) \\<Delta>))))", "unfolding augment_edge_cf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case ei of\n     (u, v) \\<Rightarrow>\n       assert ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n       (\\<lambda>_.\n           assert (u \\<in> V) \\<bind> (\\<lambda>_. return (x u)) \\<bind>\n           (\\<lambda>xu.\n               assert ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n               (\\<lambda>_. return (cf (u, v))) \\<bind>\n               (\\<lambda>cfuv.\n                   assert ((v, u) \\<in> E \\<union> E\\<inverse>) \\<bind>\n                   (\\<lambda>_. return (cf (v, u))) \\<bind>\n                   (\\<lambda>cfvu.\n                       let \\<Delta> = min xu cfuv\n                       in assert (u \\<in> V) \\<bind>\n                          (\\<lambda>_.\n                              return (x(u := x u + - \\<Delta>))) \\<bind>\n                          (\\<lambda>x.\n                              assert (v \\<in> V) \\<bind>\n                              (\\<lambda>_.\n                                  return (x(v := x v + \\<Delta>))) \\<bind>\n                              (\\<lambda>x.\n                                  assert\n                                   ((u, v)\n                                    \\<in> E \\<union> E\\<inverse>) \\<bind>\n                                  (\\<lambda>_.\nreturn (cf((u, v) := cfuv - \\<Delta>))) \\<bind>\n                                  (\\<lambda>cf.\nassert ((v, u) \\<in> E \\<union> E\\<inverse>) \\<bind>\n(\\<lambda>_. return (cf((v, u) := cfvu + \\<Delta>))) \\<bind>\n(\\<lambda>cf. return (x, cf))))))))))\n    \\<le> (case ei of\n           (u, v) \\<Rightarrow>\n             assert ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n             (\\<lambda>_.\n                 assert (u \\<noteq> v) \\<bind>\n                 (\\<lambda>_.\n                     let \\<Delta> = min (x u) (cf (u, v))\n                     in return\n                         (x(u := x u - \\<Delta>, v := x v + \\<Delta>),\n                          (case (u, v) of\n                           (u, v) \\<Rightarrow>\n                             \\<lambda>\\<Delta>. cf\n                                ((u, v) := cf (u, v) - \\<Delta>,\n                                 (v, u) := cf (v, u) + \\<Delta>))\n                           \\<Delta>))))", "apply (simp only: nres_monad_laws)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case ei of\n     (u, v) \\<Rightarrow>\n       assert ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n       (\\<lambda>_.\n           assert (u \\<in> V) \\<bind>\n           (\\<lambda>xa.\n               assert ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n               (\\<lambda>xa.\n                   assert ((v, u) \\<in> E \\<union> E\\<inverse>) \\<bind>\n                   (\\<lambda>xa.\n                       let \\<Delta> = min (x u) (cf (u, v))\n                       in assert (u \\<in> V) \\<bind>\n                          (\\<lambda>xa.\n                              assert (v \\<in> V) \\<bind>\n                              (\\<lambda>xa.\n                                  assert\n                                   ((u, v)\n                                    \\<in> E \\<union> E\\<inverse>) \\<bind>\n                                  (\\<lambda>xa.\nassert ((v, u) \\<in> E \\<union> E\\<inverse>) \\<bind>\n(\\<lambda>xa.\n    return\n     (x(u := x u + - \\<Delta>,\n        v := (x(u := x u + - \\<Delta>)) v + \\<Delta>),\n      cf((u, v) := cf (u, v) - \\<Delta>,\n         (v, u) := cf (v, u) + \\<Delta>)))))))))))\n    \\<le> (case ei of\n           (u, v) \\<Rightarrow>\n             assert ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n             (\\<lambda>_.\n                 assert (u \\<noteq> v) \\<bind>\n                 (\\<lambda>_.\n                     let \\<Delta> = min (x u) (cf (u, v))\n                     in return\n                         (x(u := x u - \\<Delta>, v := x v + \\<Delta>),\n                          (case (u, v) of\n                           (u, v) \\<Rightarrow>\n                             \\<lambda>\\<Delta>. cf\n                                ((u, v) := cf (u, v) - \\<Delta>,\n                                 (v, u) := cf (v, u) + \\<Delta>))\n                           \\<Delta>))))", "apply refine_vcg"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 x2 x1a x2a x1b x2b.\n       \\<lbrakk>ei = (x1, x2); (x1a, x2a) = (x1b, x2b); ei = (x1a, x2a);\n        (x1a, x2a) \\<in> E \\<union> E\\<inverse>; x1a \\<noteq> x2a\\<rbrakk>\n       \\<Longrightarrow> (x1, x2) \\<in> E \\<union> E\\<inverse>\n 2. \\<And>x1 x2 x1a x2a x1b x2b.\n       \\<lbrakk>ei = (x1, x2); (x1a, x2a) = (x1b, x2b); ei = (x1a, x2a);\n        (x1a, x2a) \\<in> E \\<union> E\\<inverse>; x1a \\<noteq> x2a;\n        (x1, x2) \\<in> E \\<union> E\\<inverse>\\<rbrakk>\n       \\<Longrightarrow> x1 \\<in> V\n 3. \\<And>x1 x2 x1a x2a x1b x2b.\n       \\<lbrakk>ei = (x1, x2); (x1a, x2a) = (x1b, x2b); ei = (x1a, x2a);\n        (x1a, x2a) \\<in> E \\<union> E\\<inverse>; x1a \\<noteq> x2a;\n        (x1, x2) \\<in> E \\<union> E\\<inverse>; x1 \\<in> V;\n        (x1, x2) \\<in> E \\<union> E\\<inverse>\\<rbrakk>\n       \\<Longrightarrow> (x2, x1) \\<in> E \\<union> E\\<inverse>\n 4. \\<And>x1 x2 x1a x2a x1b x2b.\n       \\<lbrakk>ei = (x1, x2); (x1a, x2a) = (x1b, x2b); ei = (x1a, x2a);\n        (x1a, x2a) \\<in> E \\<union> E\\<inverse>; x1a \\<noteq> x2a;\n        (x1, x2) \\<in> E \\<union> E\\<inverse>; x1 \\<in> V;\n        (x1, x2) \\<in> E \\<union> E\\<inverse>;\n        (x2, x1) \\<in> E \\<union> E\\<inverse>\\<rbrakk>\n       \\<Longrightarrow> (let \\<Delta> = min (x x1) (cf (x1, x2))\n                          in assert (x1 \\<in> V) \\<bind>\n                             (\\<lambda>xa.\n                                 assert (x2 \\<in> V) \\<bind>\n                                 (\\<lambda>xa.\n                                     assert\n((x1, x2) \\<in> E \\<union> E\\<inverse>) \\<bind>\n                                     (\\<lambda>xa.\n   assert ((x2, x1) \\<in> E \\<union> E\\<inverse>) \\<bind>\n   (\\<lambda>xa.\n       return\n        (x(x1 := x x1 + - \\<Delta>,\n           x2 := (x(x1 := x x1 + - \\<Delta>)) x2 + \\<Delta>),\n         cf((x1, x2) := cf (x1, x2) - \\<Delta>,\n            (x2, x1) := cf (x2, x1) + \\<Delta>)))))))\n                         \\<le> (let \\<Delta> = min (x x1a) (cf (x1a, x2a))\n                                in return\n                                    (x(x1a := x x1a - \\<Delta>,\n x2a := x x2a + \\<Delta>),\n                                     cf((x1b, x2b) :=\n    cf (x1b, x2b) - \\<Delta>,\n  (x2b, x1b) := cf (x2b, x1b) + \\<Delta>)))", "using E_ss_VxV"], ["proof (prove)\nusing this:\n  E \\<subseteq> V \\<times> V\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 x1a x2a x1b x2b.\n       \\<lbrakk>ei = (x1, x2); (x1a, x2a) = (x1b, x2b); ei = (x1a, x2a);\n        (x1a, x2a) \\<in> E \\<union> E\\<inverse>; x1a \\<noteq> x2a\\<rbrakk>\n       \\<Longrightarrow> (x1, x2) \\<in> E \\<union> E\\<inverse>\n 2. \\<And>x1 x2 x1a x2a x1b x2b.\n       \\<lbrakk>ei = (x1, x2); (x1a, x2a) = (x1b, x2b); ei = (x1a, x2a);\n        (x1a, x2a) \\<in> E \\<union> E\\<inverse>; x1a \\<noteq> x2a;\n        (x1, x2) \\<in> E \\<union> E\\<inverse>\\<rbrakk>\n       \\<Longrightarrow> x1 \\<in> V\n 3. \\<And>x1 x2 x1a x2a x1b x2b.\n       \\<lbrakk>ei = (x1, x2); (x1a, x2a) = (x1b, x2b); ei = (x1a, x2a);\n        (x1a, x2a) \\<in> E \\<union> E\\<inverse>; x1a \\<noteq> x2a;\n        (x1, x2) \\<in> E \\<union> E\\<inverse>; x1 \\<in> V;\n        (x1, x2) \\<in> E \\<union> E\\<inverse>\\<rbrakk>\n       \\<Longrightarrow> (x2, x1) \\<in> E \\<union> E\\<inverse>\n 4. \\<And>x1 x2 x1a x2a x1b x2b.\n       \\<lbrakk>ei = (x1, x2); (x1a, x2a) = (x1b, x2b); ei = (x1a, x2a);\n        (x1a, x2a) \\<in> E \\<union> E\\<inverse>; x1a \\<noteq> x2a;\n        (x1, x2) \\<in> E \\<union> E\\<inverse>; x1 \\<in> V;\n        (x1, x2) \\<in> E \\<union> E\\<inverse>;\n        (x2, x1) \\<in> E \\<union> E\\<inverse>\\<rbrakk>\n       \\<Longrightarrow> (let \\<Delta> = min (x x1) (cf (x1, x2))\n                          in assert (x1 \\<in> V) \\<bind>\n                             (\\<lambda>xa.\n                                 assert (x2 \\<in> V) \\<bind>\n                                 (\\<lambda>xa.\n                                     assert\n((x1, x2) \\<in> E \\<union> E\\<inverse>) \\<bind>\n                                     (\\<lambda>xa.\n   assert ((x2, x1) \\<in> E \\<union> E\\<inverse>) \\<bind>\n   (\\<lambda>xa.\n       return\n        (x(x1 := x x1 + - \\<Delta>,\n           x2 := (x(x1 := x x1 + - \\<Delta>)) x2 + \\<Delta>),\n         cf((x1, x2) := cf (x1, x2) - \\<Delta>,\n            (x2, x1) := cf (x2, x1) + \\<Delta>)))))))\n                         \\<le> (let \\<Delta> = min (x x1a) (cf (x1a, x2a))\n                                in return\n                                    (x(x1a := x x1a - \\<Delta>,\n x2a := x x2a + \\<Delta>),\n                                     cf((x1b, x2b) :=\n    cf (x1b, x2b) - \\<Delta>,\n  (x2b, x1b) := cf (x2b, x1b) + \\<Delta>)))", "by auto"], ["proof (state)\nthis:\n  push2 x cf ei \\<le> push2_aux x cf ei\n\ngoal (1 subgoal):\n 1. push2 x cf ei \\<le> \\<Down> xf_rel (push f l e)", "also"], ["proof (state)\nthis:\n  push2 x cf ei \\<le> push2_aux x cf ei\n\ngoal (1 subgoal):\n 1. push2 x cf ei \\<le> \\<Down> xf_rel (push f l e)", "note push2_aux_refine[OF assms]"], ["proof (state)\nthis:\n  push2_aux x cf ei \\<le> \\<Down> xf_rel (push f ?l e)\n\ngoal (1 subgoal):\n 1. push2 x cf ei \\<le> \\<Down> xf_rel (push f l e)", "finally"], ["proof (chain)\npicking this:\n  push2 x cf ei \\<le> \\<Down> xf_rel (push f ?l1 e)", "show ?thesis"], ["proof (prove)\nusing this:\n  push2 x cf ei \\<le> \\<Down> xf_rel (push f ?l1 e)\n\ngoal (1 subgoal):\n 1. push2 x cf ei \\<le> \\<Down> xf_rel (push f l e)", "."], ["proof (state)\nthis:\n  push2 x cf ei \\<le> \\<Down> xf_rel (push f l e)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Adding frequency counters to labeling\\<close>"], ["", "definition \"l_invar l \\<equiv> \\<forall>v. l v \\<noteq> 0 \\<longrightarrow> v\\<in>V\""], ["", "definition \"clc_invar \\<equiv> \\<lambda>(cnt,l). \n  (\\<forall>lv. cnt lv = card { u\\<in>V . l u = lv }) \n\\<and> (\\<forall>u. l u < 2*N) \\<and> l_invar l\""], ["", "definition \"clc_rel \\<equiv> br snd clc_invar\""], ["", "definition \"clc_init C \\<equiv> do {\n  l \\<leftarrow> l_init C;\n  cnt \\<leftarrow> cnt_init C;\n  return (cnt,l)\n}\""], ["", "definition \"clc_get \\<equiv> \\<lambda>(cnt,l) u. l_get l u\""], ["", "definition \"clc_set \\<equiv> \\<lambda>(cnt,l) u a. do {\n  assert (a<2*N);\n  lu \\<leftarrow> l_get l u;\n  cnt \\<leftarrow> cnt_decr cnt lu;\n  l \\<leftarrow> l_set l u a;\n  lu \\<leftarrow> l_get l u;\n  cnt \\<leftarrow> cnt_incr cnt lu;\n  return (cnt,l)\n}\""], ["", "definition \"clc_has_gap \\<equiv> \\<lambda>(cnt,l) lu. do {\n  nlu \\<leftarrow> cnt_get cnt lu;\n  return (nlu = 0)\n}\""], ["", "lemma cardV_le_N: \"card V \\<le> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card V \\<le> N", "using card_mono[OF _ V_ss]"], ["proof (prove)\nusing this:\n  finite {0..<N} \\<Longrightarrow> card V \\<le> card {0..<N}\n\ngoal (1 subgoal):\n 1. card V \\<le> N", "by auto"], ["", "lemma N_not_Z: \"N \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N \\<noteq> 0", "using card_V_ge2 cardV_le_N"], ["proof (prove)\nusing this:\n  2 \\<le> card V\n  card V \\<le> N\n\ngoal (1 subgoal):\n 1. N \\<noteq> 0", "by auto"], ["", "lemma N_ge_2: \"2\\<le>N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> N", "using card_V_ge2 cardV_le_N"], ["proof (prove)\nusing this:\n  2 \\<le> card V\n  card V \\<le> N\n\ngoal (1 subgoal):\n 1. 2 \\<le> N", "by auto"], ["", "lemma clc_init_refine[refine]:\n  assumes [simplified,simp]: \"(Ci,C)\\<in>nat_rel\" \n  assumes [simp]: \"C = card V\" \n  shows \"clc_init Ci \\<le>\\<Down>clc_rel (l_init C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clc_init Ci \\<le> \\<Down> clc_rel (l_init C)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. clc_init Ci \\<le> \\<Down> clc_rel (l_init C)", "have AUX: \"{u. u \\<noteq> s \\<and> u \\<in> V} = V-{s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {u. u \\<noteq> s \\<and> u \\<in> V} = V - {s}", "by auto"], ["proof (state)\nthis:\n  {u. u \\<noteq> s \\<and> u \\<in> V} = V - {s}\n\ngoal (1 subgoal):\n 1. clc_init Ci \\<le> \\<Down> clc_rel (l_init C)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. clc_init Ci \\<le> \\<Down> clc_rel (l_init C)", "unfolding clc_init_def l_init_def cnt_init_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. return ((\\<lambda>_. 0)(s := Ci)) \\<bind>\n    (\\<lambda>l.\n        assert (Ci < 2 * N) \\<bind>\n        (\\<lambda>_. return ((\\<lambda>_. 0)(0 := Ci - 1, Ci := 1))) \\<bind>\n        (\\<lambda>cnt. return (cnt, l)))\n    \\<le> \\<Down> clc_rel (return ((\\<lambda>_. 0)(s := C)))", "apply refine_vcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. Ci < 2 * N\n 2. Ci < 2 * N \\<Longrightarrow>\n    (((\\<lambda>_. 0)(0 := Ci - 1, Ci := 1), (\\<lambda>_. 0)(s := Ci)),\n     (\\<lambda>_. 0)(s := C))\n    \\<in> clc_rel", "unfolding clc_rel_def clc_invar_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. Ci < 2 * N\n 2. Ci < 2 * N \\<Longrightarrow>\n    (((\\<lambda>_. 0)(0 := Ci - 1, Ci := 1), (\\<lambda>_. 0)(s := Ci)),\n     (\\<lambda>_. 0)(s := C))\n    \\<in> br snd\n           (\\<lambda>(cnt, l).\n               (\\<forall>lv. cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n               (\\<forall>u. l u < 2 * N) \\<and> l_invar l)", "using cardV_le_N N_not_Z"], ["proof (prove)\nusing this:\n  card V \\<le> N\n  N \\<noteq> 0\n\ngoal (2 subgoals):\n 1. Ci < 2 * N\n 2. Ci < 2 * N \\<Longrightarrow>\n    (((\\<lambda>_. 0)(0 := Ci - 1, Ci := 1), (\\<lambda>_. 0)(s := Ci)),\n     (\\<lambda>_. 0)(s := C))\n    \\<in> br snd\n           (\\<lambda>(cnt, l).\n               (\\<forall>lv. cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n               (\\<forall>u. l u < 2 * N) \\<and> l_invar l)", "by (auto simp: in_br_conv V_not_empty AUX l_invar_def)"], ["proof (state)\nthis:\n  clc_init Ci \\<le> \\<Down> clc_rel (l_init C)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma clc_get_refine[refine]: \n  \"\\<lbrakk> (clc,l)\\<in>clc_rel; (ui,u)\\<in>nat_rel \\<rbrakk> \\<Longrightarrow> clc_get clc ui \\<le>\\<Down>Id (l_get l u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(clc, l) \\<in> clc_rel; (ui, u) \\<in> nat_rel\\<rbrakk>\n    \\<Longrightarrow> clc_get clc ui \\<le> \\<Down> nat_rel (l_get l u)", "unfolding clc_get_def clc_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(clc, l) \\<in> br snd clc_invar; (ui, u) \\<in> nat_rel\\<rbrakk>\n    \\<Longrightarrow> (case clc of (cnt, x) \\<Rightarrow> l_get x) ui\n                      \\<le> \\<Down> nat_rel (l_get l u)", "by (auto simp: in_br_conv split: prod.split)"], ["", "definition l_get_rlx :: \"(node \\<Rightarrow> nat) \\<Rightarrow> node \\<Rightarrow> nat nres\"    \n  where \"l_get_rlx l u \\<equiv> do {\n    assert (u < N);\n    return (l u)\n  }\""], ["", "definition \"clc_get_rlx \\<equiv> \\<lambda>(cnt,l) u. l_get_rlx l u\""], ["", "lemma clc_get_rlx_refine[refine]: \n  \"\\<lbrakk> (clc,l)\\<in>clc_rel; (ui,u)\\<in>nat_rel \\<rbrakk> \n  \\<Longrightarrow> clc_get_rlx clc ui \\<le>\\<Down>Id (l_get_rlx l u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(clc, l) \\<in> clc_rel; (ui, u) \\<in> nat_rel\\<rbrakk>\n    \\<Longrightarrow> clc_get_rlx clc ui\n                      \\<le> \\<Down> nat_rel (l_get_rlx l u)", "unfolding clc_get_rlx_def clc_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(clc, l) \\<in> br snd clc_invar; (ui, u) \\<in> nat_rel\\<rbrakk>\n    \\<Longrightarrow> (case clc of (cnt, x) \\<Rightarrow> l_get_rlx x) ui\n                      \\<le> \\<Down> nat_rel (l_get_rlx l u)", "by (auto simp: in_br_conv split: prod.split)"], ["", "lemma card_insert_disjointI: \n  \"\\<lbrakk> finite Y; X = insert x Y; x\\<notin>Y \\<rbrakk> \\<Longrightarrow> card X = Suc (card Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite Y; X = insert x Y; x \\<notin> Y\\<rbrakk>\n    \\<Longrightarrow> card X = Suc (card Y)", "by auto"], ["", "lemma clc_set_refine[refine]:\n  \"\\<lbrakk> (clc,l) \\<in> clc_rel; (ui,u)\\<in>nat_rel; (ai,a)\\<in>nat_rel \\<rbrakk> \\<Longrightarrow>\n    clc_set clc ui ai \\<le>\\<Down>clc_rel (l_set l u a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(clc, l) \\<in> clc_rel; (ui, u) \\<in> nat_rel;\n     (ai, a) \\<in> nat_rel\\<rbrakk>\n    \\<Longrightarrow> clc_set clc ui ai \\<le> \\<Down> clc_rel (l_set l u a)", "unfolding clc_set_def l_set_def l_get_def cnt_decr_def cnt_incr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(clc, l) \\<in> clc_rel; (ui, u) \\<in> nat_rel;\n     (ai, a) \\<in> nat_rel\\<rbrakk>\n    \\<Longrightarrow> (case clc of\n                       (cnt, l) \\<Rightarrow>\n                         \\<lambda>u a.\n                            assert (a < 2 * N) \\<bind>\n                            (\\<lambda>_.\n                                assert (u \\<in> V) \\<bind>\n                                (\\<lambda>_. return (l u)) \\<bind>\n                                (\\<lambda>lu.\n                                    assert\n                                     (lu < 2 * N \\<and> 0 < cnt lu) \\<bind>\n                                    (\\<lambda>_.\n  return (cnt(lu := cnt lu - 1))) \\<bind>\n                                    (\\<lambda>cnt.\n  assert (u \\<in> V) \\<bind>\n  (\\<lambda>_.\n      assert (a < 2 * card V) \\<bind>\n      (\\<lambda>_. return (l(u := a)))) \\<bind>\n  (\\<lambda>l.\n      assert (u \\<in> V) \\<bind> (\\<lambda>_. return (l u)) \\<bind>\n      (\\<lambda>lu.\n          assert (lu < 2 * N) \\<bind>\n          (\\<lambda>_. return (cnt(lu := cnt lu + 1))) \\<bind>\n          (\\<lambda>cnt. return (cnt, l))))))))\n                       ui ai\n                      \\<le> \\<Down> clc_rel\n                             (assert (u \\<in> V) \\<bind>\n                              (\\<lambda>_.\n                                  assert (a < 2 * card V) \\<bind>\n                                  (\\<lambda>_. return (l(u := a)))))", "apply refine_vcg"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>(clc, l) \\<in> clc_rel; (ui, u) \\<in> nat_rel;\n        (ai, a) \\<in> nat_rel; u \\<in> V; a < 2 * card V;\n        clc = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> ai < 2 * N\n 2. \\<And>x1 x2.\n       \\<lbrakk>(clc, l) \\<in> clc_rel; (ui, u) \\<in> nat_rel;\n        (ai, a) \\<in> nat_rel; u \\<in> V; a < 2 * card V; clc = (x1, x2);\n        ai < 2 * N\\<rbrakk>\n       \\<Longrightarrow> ui \\<in> V\n 3. \\<And>x1 x2.\n       \\<lbrakk>(clc, l) \\<in> clc_rel; (ui, u) \\<in> nat_rel;\n        (ai, a) \\<in> nat_rel; u \\<in> V; a < 2 * card V; clc = (x1, x2);\n        ai < 2 * N; ui \\<in> V\\<rbrakk>\n       \\<Longrightarrow> x2 ui < 2 * N\n 4. \\<And>x1 x2.\n       \\<lbrakk>(clc, l) \\<in> clc_rel; (ui, u) \\<in> nat_rel;\n        (ai, a) \\<in> nat_rel; u \\<in> V; a < 2 * card V; clc = (x1, x2);\n        ai < 2 * N; ui \\<in> V\\<rbrakk>\n       \\<Longrightarrow> 0 < x1 (x2 ui)\n 5. \\<And>x1 x2.\n       \\<lbrakk>(clc, l) \\<in> clc_rel; (ui, u) \\<in> nat_rel;\n        (ai, a) \\<in> nat_rel; u \\<in> V; a < 2 * card V; clc = (x1, x2);\n        ai < 2 * N; ui \\<in> V; x2 ui < 2 * N \\<and> 0 < x1 (x2 ui);\n        ui \\<in> V\\<rbrakk>\n       \\<Longrightarrow> ai < 2 * card V\n 6. \\<And>x1 x2.\n       \\<lbrakk>(clc, l) \\<in> clc_rel; (ui, u) \\<in> nat_rel;\n        (ai, a) \\<in> nat_rel; u \\<in> V; a < 2 * card V; clc = (x1, x2);\n        ai < 2 * N; ui \\<in> V; x2 ui < 2 * N \\<and> 0 < x1 (x2 ui);\n        ui \\<in> V; ai < 2 * card V; ui \\<in> V\\<rbrakk>\n       \\<Longrightarrow> (x2(ui := ai)) ui < 2 * N\n 7. \\<And>x1 x2.\n       \\<lbrakk>(clc, l) \\<in> clc_rel; (ui, u) \\<in> nat_rel;\n        (ai, a) \\<in> nat_rel; u \\<in> V; a < 2 * card V; clc = (x1, x2);\n        ai < 2 * N; ui \\<in> V; x2 ui < 2 * N \\<and> 0 < x1 (x2 ui);\n        ui \\<in> V; ai < 2 * card V; ui \\<in> V;\n        (x2(ui := ai)) ui < 2 * N\\<rbrakk>\n       \\<Longrightarrow> ((x1(x2 ui := x1 (x2 ui) - 1,\n                              (x2(ui := ai)) ui :=\n                                (x1(x2 ui := x1 (x2 ui) - 1))\n                                 ((x2(ui := ai)) ui) +\n                                1),\n                           x2(ui := ai)),\n                          l(u := a))\n                         \\<in> clc_rel", "apply vc_solve"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>((x1, x2), l) \\<in> clc_rel; ui = u; ai = a; u \\<in> V;\n        a < 2 * card V; clc = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> a < 2 * N\n 2. \\<And>x1 x2.\n       \\<lbrakk>((x1, x2), l) \\<in> clc_rel; ui = u; ai = a; u \\<in> V;\n        a < 2 * card V; clc = (x1, x2); a < 2 * N\\<rbrakk>\n       \\<Longrightarrow> x2 u < 2 * N\n 3. \\<And>x1 x2.\n       \\<lbrakk>((x1, x2), l) \\<in> clc_rel; ui = u; ai = a; u \\<in> V;\n        a < 2 * card V; clc = (x1, x2); a < 2 * N\\<rbrakk>\n       \\<Longrightarrow> 0 < x1 (x2 u)\n 4. \\<And>x1 x2.\n       \\<lbrakk>((x1, x2), l) \\<in> clc_rel; ui = u; ai = a; u \\<in> V;\n        clc = (x1, x2); a < 2 * N; a < 2 * card V; x2 u < 2 * N;\n        0 < x1 (x2 u)\\<rbrakk>\n       \\<Longrightarrow> (a = x2 u \\<longrightarrow>\n                          ((x1, x2), l(u := x2 u)) \\<in> clc_rel) \\<and>\n                         (a \\<noteq> x2 u \\<longrightarrow>\n                          ((x1(x2 u := x1 (x2 u) - Suc 0, a := Suc (x1 a)),\n                            x2(u := a)),\n                           l(u := a))\n                          \\<in> clc_rel)", "unfolding clc_rel_def in_br_conv clc_invar_def l_invar_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>l = snd (x1, x2) \\<and>\n                (case (x1, x2) of\n                 (cnt, l) \\<Rightarrow>\n                   (\\<forall>lv. cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n                   (\\<forall>u. l u < 2 * N) \\<and>\n                   (\\<forall>v.\n                       l v \\<noteq> 0 \\<longrightarrow> v \\<in> V));\n        ui = u; ai = a; u \\<in> V; a < 2 * card V; clc = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> a < 2 * N\n 2. \\<And>x1 x2.\n       \\<lbrakk>l = snd (x1, x2) \\<and>\n                (case (x1, x2) of\n                 (cnt, l) \\<Rightarrow>\n                   (\\<forall>lv. cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n                   (\\<forall>u. l u < 2 * N) \\<and>\n                   (\\<forall>v.\n                       l v \\<noteq> 0 \\<longrightarrow> v \\<in> V));\n        ui = u; ai = a; u \\<in> V; a < 2 * card V; clc = (x1, x2);\n        a < 2 * N\\<rbrakk>\n       \\<Longrightarrow> x2 u < 2 * N\n 3. \\<And>x1 x2.\n       \\<lbrakk>l = snd (x1, x2) \\<and>\n                (case (x1, x2) of\n                 (cnt, l) \\<Rightarrow>\n                   (\\<forall>lv. cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n                   (\\<forall>u. l u < 2 * N) \\<and>\n                   (\\<forall>v.\n                       l v \\<noteq> 0 \\<longrightarrow> v \\<in> V));\n        ui = u; ai = a; u \\<in> V; a < 2 * card V; clc = (x1, x2);\n        a < 2 * N\\<rbrakk>\n       \\<Longrightarrow> 0 < x1 (x2 u)\n 4. \\<And>x1 x2.\n       \\<lbrakk>l = snd (x1, x2) \\<and>\n                (case (x1, x2) of\n                 (cnt, l) \\<Rightarrow>\n                   (\\<forall>lv. cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n                   (\\<forall>u. l u < 2 * N) \\<and>\n                   (\\<forall>v.\n                       l v \\<noteq> 0 \\<longrightarrow> v \\<in> V));\n        ui = u; ai = a; u \\<in> V; clc = (x1, x2); a < 2 * N;\n        a < 2 * card V; x2 u < 2 * N; 0 < x1 (x2 u)\\<rbrakk>\n       \\<Longrightarrow> (a = x2 u \\<longrightarrow>\n                          l(u := x2 u) = snd (x1, x2) \\<and>\n                          (case (x1, x2) of\n                           (cnt, l) \\<Rightarrow>\n                             (\\<forall>lv.\n                                 cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n                             (\\<forall>u. l u < 2 * N) \\<and>\n                             (\\<forall>v.\n                                 l v \\<noteq> 0 \\<longrightarrow>\n                                 v \\<in> V))) \\<and>\n                         (a \\<noteq> x2 u \\<longrightarrow>\n                          l(u := a) =\n                          snd (x1(x2 u := x1 (x2 u) - Suc 0,\n                                  a := Suc (x1 a)),\n                               x2(u := a)) \\<and>\n                          (case (x1(x2 u := x1 (x2 u) - Suc 0,\n                                    a := Suc (x1 a)),\n                                 x2(u := a)) of\n                           (cnt, l) \\<Rightarrow>\n                             (\\<forall>lv.\n                                 cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n                             (\\<forall>u. l u < 2 * N) \\<and>\n                             (\\<forall>v.\n                                 l v \\<noteq> 0 \\<longrightarrow>\n                                 v \\<in> V)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l = snd (x1_, x2_) \\<and>\n             (case (x1_, x2_) of\n              (cnt, l) \\<Rightarrow>\n                (\\<forall>lv. cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n                (\\<forall>u. l u < 2 * N) \\<and>\n                (\\<forall>v. l v \\<noteq> 0 \\<longrightarrow> v \\<in> V));\n     ui = u; ai = a; u \\<in> V; a < 2 * card V; clc = (x1_, x2_)\\<rbrakk>\n    \\<Longrightarrow> a < 2 * N", "using cardV_le_N"], ["proof (prove)\nusing this:\n  card V \\<le> N\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l = snd (x1_, x2_) \\<and>\n             (case (x1_, x2_) of\n              (cnt, l) \\<Rightarrow>\n                (\\<forall>lv. cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n                (\\<forall>u. l u < 2 * N) \\<and>\n                (\\<forall>v. l v \\<noteq> 0 \\<longrightarrow> v \\<in> V));\n     ui = u; ai = a; u \\<in> V; a < 2 * card V; clc = (x1_, x2_)\\<rbrakk>\n    \\<Longrightarrow> a < 2 * N", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>l = snd (x1, x2) \\<and>\n                (case (x1, x2) of\n                 (cnt, l) \\<Rightarrow>\n                   (\\<forall>lv. cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n                   (\\<forall>u. l u < 2 * N) \\<and>\n                   (\\<forall>v.\n                       l v \\<noteq> 0 \\<longrightarrow> v \\<in> V));\n        ui = u; ai = a; u \\<in> V; a < 2 * card V; clc = (x1, x2);\n        a < 2 * N\\<rbrakk>\n       \\<Longrightarrow> x2 u < 2 * N\n 2. \\<And>x1 x2.\n       \\<lbrakk>l = snd (x1, x2) \\<and>\n                (case (x1, x2) of\n                 (cnt, l) \\<Rightarrow>\n                   (\\<forall>lv. cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n                   (\\<forall>u. l u < 2 * N) \\<and>\n                   (\\<forall>v.\n                       l v \\<noteq> 0 \\<longrightarrow> v \\<in> V));\n        ui = u; ai = a; u \\<in> V; a < 2 * card V; clc = (x1, x2);\n        a < 2 * N\\<rbrakk>\n       \\<Longrightarrow> 0 < x1 (x2 u)\n 3. \\<And>x1 x2.\n       \\<lbrakk>l = snd (x1, x2) \\<and>\n                (case (x1, x2) of\n                 (cnt, l) \\<Rightarrow>\n                   (\\<forall>lv. cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n                   (\\<forall>u. l u < 2 * N) \\<and>\n                   (\\<forall>v.\n                       l v \\<noteq> 0 \\<longrightarrow> v \\<in> V));\n        ui = u; ai = a; u \\<in> V; clc = (x1, x2); a < 2 * N;\n        a < 2 * card V; x2 u < 2 * N; 0 < x1 (x2 u)\\<rbrakk>\n       \\<Longrightarrow> (a = x2 u \\<longrightarrow>\n                          l(u := x2 u) = snd (x1, x2) \\<and>\n                          (case (x1, x2) of\n                           (cnt, l) \\<Rightarrow>\n                             (\\<forall>lv.\n                                 cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n                             (\\<forall>u. l u < 2 * N) \\<and>\n                             (\\<forall>v.\n                                 l v \\<noteq> 0 \\<longrightarrow>\n                                 v \\<in> V))) \\<and>\n                         (a \\<noteq> x2 u \\<longrightarrow>\n                          l(u := a) =\n                          snd (x1(x2 u := x1 (x2 u) - Suc 0,\n                                  a := Suc (x1 a)),\n                               x2(u := a)) \\<and>\n                          (case (x1(x2 u := x1 (x2 u) - Suc 0,\n                                    a := Suc (x1 a)),\n                                 x2(u := a)) of\n                           (cnt, l) \\<Rightarrow>\n                             (\\<forall>lv.\n                                 cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n                             (\\<forall>u. l u < 2 * N) \\<and>\n                             (\\<forall>v.\n                                 l v \\<noteq> 0 \\<longrightarrow>\n                                 v \\<in> V)))", "applyS auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>l = snd (x1, x2) \\<and>\n                (case (x1, x2) of\n                 (cnt, l) \\<Rightarrow>\n                   (\\<forall>lv. cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n                   (\\<forall>u. l u < 2 * N) \\<and>\n                   (\\<forall>v.\n                       l v \\<noteq> 0 \\<longrightarrow> v \\<in> V));\n        ui = u; ai = a; u \\<in> V; a < 2 * card V; clc = (x1, x2);\n        a < 2 * N\\<rbrakk>\n       \\<Longrightarrow> 0 < x1 (x2 u)\n 2. \\<And>x1 x2.\n       \\<lbrakk>l = snd (x1, x2) \\<and>\n                (case (x1, x2) of\n                 (cnt, l) \\<Rightarrow>\n                   (\\<forall>lv. cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n                   (\\<forall>u. l u < 2 * N) \\<and>\n                   (\\<forall>v.\n                       l v \\<noteq> 0 \\<longrightarrow> v \\<in> V));\n        ui = u; ai = a; u \\<in> V; clc = (x1, x2); a < 2 * N;\n        a < 2 * card V; x2 u < 2 * N; 0 < x1 (x2 u)\\<rbrakk>\n       \\<Longrightarrow> (a = x2 u \\<longrightarrow>\n                          l(u := x2 u) = snd (x1, x2) \\<and>\n                          (case (x1, x2) of\n                           (cnt, l) \\<Rightarrow>\n                             (\\<forall>lv.\n                                 cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n                             (\\<forall>u. l u < 2 * N) \\<and>\n                             (\\<forall>v.\n                                 l v \\<noteq> 0 \\<longrightarrow>\n                                 v \\<in> V))) \\<and>\n                         (a \\<noteq> x2 u \\<longrightarrow>\n                          l(u := a) =\n                          snd (x1(x2 u := x1 (x2 u) - Suc 0,\n                                  a := Suc (x1 a)),\n                               x2(u := a)) \\<and>\n                          (case (x1(x2 u := x1 (x2 u) - Suc 0,\n                                    a := Suc (x1 a)),\n                                 x2(u := a)) of\n                           (cnt, l) \\<Rightarrow>\n                             (\\<forall>lv.\n                                 cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n                             (\\<forall>u. l u < 2 * N) \\<and>\n                             (\\<forall>v.\n                                 l v \\<noteq> 0 \\<longrightarrow>\n                                 v \\<in> V)))", "applyS (auto simp: simp: card_gt_0_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>l = snd (x1, x2) \\<and>\n                (case (x1, x2) of\n                 (cnt, l) \\<Rightarrow>\n                   (\\<forall>lv. cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n                   (\\<forall>u. l u < 2 * N) \\<and>\n                   (\\<forall>v.\n                       l v \\<noteq> 0 \\<longrightarrow> v \\<in> V));\n        ui = u; ai = a; u \\<in> V; clc = (x1, x2); a < 2 * N;\n        a < 2 * card V; x2 u < 2 * N; 0 < x1 (x2 u)\\<rbrakk>\n       \\<Longrightarrow> (a = x2 u \\<longrightarrow>\n                          l(u := x2 u) = snd (x1, x2) \\<and>\n                          (case (x1, x2) of\n                           (cnt, l) \\<Rightarrow>\n                             (\\<forall>lv.\n                                 cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n                             (\\<forall>u. l u < 2 * N) \\<and>\n                             (\\<forall>v.\n                                 l v \\<noteq> 0 \\<longrightarrow>\n                                 v \\<in> V))) \\<and>\n                         (a \\<noteq> x2 u \\<longrightarrow>\n                          l(u := a) =\n                          snd (x1(x2 u := x1 (x2 u) - Suc 0,\n                                  a := Suc (x1 a)),\n                               x2(u := a)) \\<and>\n                          (case (x1(x2 u := x1 (x2 u) - Suc 0,\n                                    a := Suc (x1 a)),\n                                 x2(u := a)) of\n                           (cnt, l) \\<Rightarrow>\n                             (\\<forall>lv.\n                                 cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n                             (\\<forall>u. l u < 2 * N) \\<and>\n                             (\\<forall>v.\n                                 l v \\<noteq> 0 \\<longrightarrow>\n                                 v \\<in> V)))", "subgoal for cnt ll"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l = snd (cnt, ll) \\<and>\n             (case (cnt, ll) of\n              (cnt, l) \\<Rightarrow>\n                (\\<forall>lv. cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n                (\\<forall>u. l u < 2 * N) \\<and>\n                (\\<forall>v. l v \\<noteq> 0 \\<longrightarrow> v \\<in> V));\n     ui = u; ai = a; u \\<in> V; clc = (cnt, ll); a < 2 * N; a < 2 * card V;\n     ll u < 2 * N; 0 < cnt (ll u)\\<rbrakk>\n    \\<Longrightarrow> (a = ll u \\<longrightarrow>\n                       l(u := ll u) = snd (cnt, ll) \\<and>\n                       (case (cnt, ll) of\n                        (cnt, l) \\<Rightarrow>\n                          (\\<forall>lv.\n                              cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n                          (\\<forall>u. l u < 2 * N) \\<and>\n                          (\\<forall>v.\n                              l v \\<noteq> 0 \\<longrightarrow>\n                              v \\<in> V))) \\<and>\n                      (a \\<noteq> ll u \\<longrightarrow>\n                       l(u := a) =\n                       snd (cnt(ll u := cnt (ll u) - Suc 0,\n                                a := Suc (cnt a)),\n                            ll(u := a)) \\<and>\n                       (case (cnt(ll u := cnt (ll u) - Suc 0,\n                                  a := Suc (cnt a)),\n                              ll(u := a)) of\n                        (cnt, l) \\<Rightarrow>\n                          (\\<forall>lv.\n                              cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n                          (\\<forall>u. l u < 2 * N) \\<and>\n                          (\\<forall>v.\n                              l v \\<noteq> 0 \\<longrightarrow> v \\<in> V)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lv.\n       \\<lbrakk>ui = u; ai = a; u \\<in> V; clc = (cnt, ll); a < 2 * N;\n        a < 2 * card V; 0 < card {ua \\<in> V. ll ua = ll u}; l = ll;\n        \\<forall>lv. cnt lv = card {u \\<in> V. ll u = lv};\n        \\<forall>u. ll u < 2 * N;\n        \\<forall>v. 0 < ll v \\<longrightarrow> v \\<in> V;\n        a \\<noteq> ll u\\<rbrakk>\n       \\<Longrightarrow> (lv = ll u \\<longrightarrow>\n                          card {ua \\<in> V. ll ua = ll u} - Suc 0 =\n                          card\n                           {ua.\n                            ua \\<noteq> u \\<and>\n                            ua \\<in> V \\<and> ll ua = ll u}) \\<and>\n                         (lv \\<noteq> ll u \\<longrightarrow>\n                          (lv = a \\<longrightarrow>\n                           Suc (card {u \\<in> V. ll u = a}) =\n                           card\n                            {ua.\n                             ua \\<noteq> u \\<longrightarrow>\n                             ua \\<in> V \\<and> ll ua = a}) \\<and>\n                          (lv \\<noteq> a \\<longrightarrow>\n                           card {u \\<in> V. ll u = lv} =\n                           card\n                            {ua.\n                             ua \\<noteq> u \\<and>\n                             ua \\<in> V \\<and> ll ua = lv}))", "apply (intro impI conjI; clarsimp?)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>ui = u; ai = a; u \\<in> V; clc = (cnt, ll); a < 2 * N;\n     a < 2 * card V; 0 < card {ua \\<in> V. ll ua = ll u}; l = ll;\n     \\<forall>lv. cnt lv = card {u \\<in> V. ll u = lv};\n     \\<forall>u. ll u < 2 * N;\n     \\<forall>v. 0 < ll v \\<longrightarrow> v \\<in> V;\n     a \\<noteq> ll u\\<rbrakk>\n    \\<Longrightarrow> card {ua \\<in> V. ll ua = ll u} - Suc 0 =\n                      card\n                       {ua.\n                        ua \\<noteq> u \\<and> ua \\<in> V \\<and> ll ua = ll u}\n 2. \\<lbrakk>ui = u; ai = a; u \\<in> V; clc = (cnt, ll); a < 2 * N;\n     a < 2 * card V; 0 < card {ua \\<in> V. ll ua = ll u}; l = ll;\n     \\<forall>lv. cnt lv = card {u \\<in> V. ll u = lv};\n     \\<forall>u. ll u < 2 * N;\n     \\<forall>v. 0 < ll v \\<longrightarrow> v \\<in> V;\n     a \\<noteq> ll u\\<rbrakk>\n    \\<Longrightarrow> Suc (card {u \\<in> V. ll u = a}) =\n                      card\n                       {ua.\n                        ua \\<noteq> u \\<longrightarrow>\n                        ua \\<in> V \\<and> ll ua = a}\n 3. \\<And>lv.\n       \\<lbrakk>ui = u; ai = a; u \\<in> V; clc = (cnt, ll); a < 2 * N;\n        a < 2 * card V; 0 < card {ua \\<in> V. ll ua = ll u}; l = ll;\n        \\<forall>lv. cnt lv = card {u \\<in> V. ll u = lv};\n        \\<forall>u. ll u < 2 * N;\n        \\<forall>v. 0 < ll v \\<longrightarrow> v \\<in> V; a \\<noteq> ll u;\n        lv \\<noteq> ll u; lv \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> card {u \\<in> V. ll u = lv} =\n                         card\n                          {ua.\n                           ua \\<noteq> u \\<and>\n                           ua \\<in> V \\<and> ll ua = lv}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ui = u; ai = a; u \\<in> V; clc = (cnt, ll); a < 2 * N;\n     a < 2 * card V; 0 < card {ua \\<in> V. ll ua = ll u}; l = ll;\n     \\<forall>lv. cnt lv = card {u \\<in> V. ll u = lv};\n     \\<forall>u. ll u < 2 * N;\n     \\<forall>v. 0 < ll v \\<longrightarrow> v \\<in> V;\n     a \\<noteq> ll u\\<rbrakk>\n    \\<Longrightarrow> card {ua \\<in> V. ll ua = ll u} - Suc 0 =\n                      card\n                       {ua.\n                        ua \\<noteq> u \\<and> ua \\<in> V \\<and> ll ua = ll u}", "apply (subst le_imp_diff_is_add; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ui = u; ai = a; u \\<in> V; clc = (cnt, ll); a < 2 * N;\n     a < 2 * card V; 0 < card {ua \\<in> V. ll ua = ll u}; l = ll;\n     \\<forall>lv. cnt lv = card {u \\<in> V. ll u = lv};\n     \\<forall>u. ll u < 2 * N;\n     \\<forall>v. 0 < ll v \\<longrightarrow> v \\<in> V;\n     a \\<noteq> ll u\\<rbrakk>\n    \\<Longrightarrow> card {ua \\<in> V. ll ua = ll u} =\n                      Suc (card\n                            {ua.\n                             ua \\<noteq> u \\<and>\n                             ua \\<in> V \\<and> ll ua = ll u})", "apply (rule card_insert_disjointI[where x=u])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>ui = u; ai = a; u \\<in> V; clc = (cnt, ll); a < 2 * N;\n     a < 2 * card V; 0 < card {ua \\<in> V. ll ua = ll u}; l = ll;\n     \\<forall>lv. cnt lv = card {u \\<in> V. ll u = lv};\n     \\<forall>u. ll u < 2 * N;\n     \\<forall>v. 0 < ll v \\<longrightarrow> v \\<in> V;\n     a \\<noteq> ll u\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {ua.\n                        ua \\<noteq> u \\<and> ua \\<in> V \\<and> ll ua = ll u}\n 2. \\<lbrakk>ui = u; ai = a; u \\<in> V; clc = (cnt, ll); a < 2 * N;\n     a < 2 * card V; 0 < card {ua \\<in> V. ll ua = ll u}; l = ll;\n     \\<forall>lv. cnt lv = card {u \\<in> V. ll u = lv};\n     \\<forall>u. ll u < 2 * N;\n     \\<forall>v. 0 < ll v \\<longrightarrow> v \\<in> V;\n     a \\<noteq> ll u\\<rbrakk>\n    \\<Longrightarrow> {ua \\<in> V. ll ua = ll u} =\n                      insert u\n                       {ua.\n                        ua \\<noteq> u \\<and> ua \\<in> V \\<and> ll ua = ll u}\n 3. \\<lbrakk>ui = u; ai = a; u \\<in> V; clc = (cnt, ll); a < 2 * N;\n     a < 2 * card V; 0 < card {ua \\<in> V. ll ua = ll u}; l = ll;\n     \\<forall>lv. cnt lv = card {u \\<in> V. ll u = lv};\n     \\<forall>u. ll u < 2 * N;\n     \\<forall>v. 0 < ll v \\<longrightarrow> v \\<in> V;\n     a \\<noteq> ll u\\<rbrakk>\n    \\<Longrightarrow> u \\<notin> {ua.\n                                  ua \\<noteq> u \\<and>\n                                  ua \\<in> V \\<and> ll ua = ll u}", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ui = u; ai = a; u \\<in> V; clc = (cnt, ll); a < 2 * N;\n     a < 2 * card V; 0 < card {ua \\<in> V. ll ua = ll u}; l = ll;\n     \\<forall>lv. cnt lv = card {u \\<in> V. ll u = lv};\n     \\<forall>u. ll u < 2 * N;\n     \\<forall>v. 0 < ll v \\<longrightarrow> v \\<in> V;\n     a \\<noteq> ll u\\<rbrakk>\n    \\<Longrightarrow> Suc (card {u \\<in> V. ll u = a}) =\n                      card\n                       {ua.\n                        ua \\<noteq> u \\<longrightarrow>\n                        ua \\<in> V \\<and> ll ua = a}\n 2. \\<And>lv.\n       \\<lbrakk>ui = u; ai = a; u \\<in> V; clc = (cnt, ll); a < 2 * N;\n        a < 2 * card V; 0 < card {ua \\<in> V. ll ua = ll u}; l = ll;\n        \\<forall>lv. cnt lv = card {u \\<in> V. ll u = lv};\n        \\<forall>u. ll u < 2 * N;\n        \\<forall>v. 0 < ll v \\<longrightarrow> v \\<in> V; a \\<noteq> ll u;\n        lv \\<noteq> ll u; lv \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> card {u \\<in> V. ll u = lv} =\n                         card\n                          {ua.\n                           ua \\<noteq> u \\<and>\n                           ua \\<in> V \\<and> ll ua = lv}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ui = u; ai = a; u \\<in> V; clc = (cnt, ll); a < 2 * N;\n     a < 2 * card V; 0 < card {ua \\<in> V. ll ua = ll u}; l = ll;\n     \\<forall>lv. cnt lv = card {u \\<in> V. ll u = lv};\n     \\<forall>u. ll u < 2 * N;\n     \\<forall>v. 0 < ll v \\<longrightarrow> v \\<in> V;\n     a \\<noteq> ll u\\<rbrakk>\n    \\<Longrightarrow> Suc (card {u \\<in> V. ll u = a}) =\n                      card\n                       {ua.\n                        ua \\<noteq> u \\<longrightarrow>\n                        ua \\<in> V \\<and> ll ua = a}", "apply (rule card_insert_disjointI[where x=u, symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>ui = u; ai = a; u \\<in> V; clc = (cnt, ll); a < 2 * N;\n     a < 2 * card V; 0 < card {ua \\<in> V. ll ua = ll u}; l = ll;\n     \\<forall>lv. cnt lv = card {u \\<in> V. ll u = lv};\n     \\<forall>u. ll u < 2 * N;\n     \\<forall>v. 0 < ll v \\<longrightarrow> v \\<in> V;\n     a \\<noteq> ll u\\<rbrakk>\n    \\<Longrightarrow> finite {u \\<in> V. ll u = a}\n 2. \\<lbrakk>ui = u; ai = a; u \\<in> V; clc = (cnt, ll); a < 2 * N;\n     a < 2 * card V; 0 < card {ua \\<in> V. ll ua = ll u}; l = ll;\n     \\<forall>lv. cnt lv = card {u \\<in> V. ll u = lv};\n     \\<forall>u. ll u < 2 * N;\n     \\<forall>v. 0 < ll v \\<longrightarrow> v \\<in> V;\n     a \\<noteq> ll u\\<rbrakk>\n    \\<Longrightarrow> {ua.\n                       ua \\<noteq> u \\<longrightarrow>\n                       ua \\<in> V \\<and> ll ua = a} =\n                      insert u {u \\<in> V. ll u = a}\n 3. \\<lbrakk>ui = u; ai = a; u \\<in> V; clc = (cnt, ll); a < 2 * N;\n     a < 2 * card V; 0 < card {ua \\<in> V. ll ua = ll u}; l = ll;\n     \\<forall>lv. cnt lv = card {u \\<in> V. ll u = lv};\n     \\<forall>u. ll u < 2 * N;\n     \\<forall>v. 0 < ll v \\<longrightarrow> v \\<in> V;\n     a \\<noteq> ll u\\<rbrakk>\n    \\<Longrightarrow> u \\<notin> {u \\<in> V. ll u = a}", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lv.\n       \\<lbrakk>ui = u; ai = a; u \\<in> V; clc = (cnt, ll); a < 2 * N;\n        a < 2 * card V; 0 < card {ua \\<in> V. ll ua = ll u}; l = ll;\n        \\<forall>lv. cnt lv = card {u \\<in> V. ll u = lv};\n        \\<forall>u. ll u < 2 * N;\n        \\<forall>v. 0 < ll v \\<longrightarrow> v \\<in> V; a \\<noteq> ll u;\n        lv \\<noteq> ll u; lv \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> card {u \\<in> V. ll u = lv} =\n                         card\n                          {ua.\n                           ua \\<noteq> u \\<and>\n                           ua \\<in> V \\<and> ll ua = lv}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ui = u; ai = a; u \\<in> V; clc = (cnt, ll); a < 2 * N;\n     a < 2 * card V; 0 < card {ua \\<in> V. ll ua = ll u}; l = ll;\n     \\<forall>lv. cnt lv = card {u \\<in> V. ll u = lv};\n     \\<forall>u. ll u < 2 * N;\n     \\<forall>v. 0 < ll v \\<longrightarrow> v \\<in> V; a \\<noteq> ll u;\n     lv_ \\<noteq> ll u; lv_ \\<noteq> a\\<rbrakk>\n    \\<Longrightarrow> card {u \\<in> V. ll u = lv_} =\n                      card\n                       {ua.\n                        ua \\<noteq> u \\<and> ua \\<in> V \\<and> ll ua = lv_}", "by (auto intro!: arg_cong[where f=card])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma clc_has_gap_correct[THEN order_trans, refine_vcg]:\n  \"\\<lbrakk>(clc,l)\\<in>clc_rel; k<2*N\\<rbrakk> \n  \\<Longrightarrow> clc_has_gap clc k \\<le> (spec r. r \\<longleftrightarrow> gap_precond l k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(clc, l) \\<in> clc_rel; k < 2 * N\\<rbrakk>\n    \\<Longrightarrow> clc_has_gap clc k \\<le> (spec r. r = gap_precond l k)", "unfolding clc_has_gap_def cnt_get_def gap_precond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(clc, l) \\<in> clc_rel; k < 2 * N\\<rbrakk>\n    \\<Longrightarrow> (case clc of\n                       (cnt, l) \\<Rightarrow>\n                         \\<lambda>lu.\n                            assert (lu < 2 * N) \\<bind>\n                            (\\<lambda>_. return (cnt lu)) \\<bind>\n                            (\\<lambda>nlu. return (nlu = 0)))\n                       k\n                      \\<le> (spec r. r = (\\<forall>v\\<in>V. l v \\<noteq> k))", "apply refine_vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>(clc, l) \\<in> clc_rel; k < 2 * N; clc = (x1, x2);\n        k < 2 * N\\<rbrakk>\n       \\<Longrightarrow> (x1 k = 0) = (\\<forall>v\\<in>V. l v \\<noteq> k)", "unfolding clc_rel_def clc_invar_def in_br_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>l = snd clc \\<and>\n                (case clc of\n                 (cnt, l) \\<Rightarrow>\n                   (\\<forall>lv. cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n                   (\\<forall>u. l u < 2 * N) \\<and> l_invar l);\n        k < 2 * N; clc = (x1, x2); k < 2 * N\\<rbrakk>\n       \\<Longrightarrow> (x1 k = 0) = (\\<forall>v\\<in>V. l v \\<noteq> k)", "by auto"], ["", "subsubsection \\<open>Refinement of Gap-Heuristics\\<close>"], ["", "text \\<open>Utilities to Implement Gap-Heuristics\\<close>"], ["", "definition \"gap_aux C l k \\<equiv> do {\n  nfoldli [0..<N] (\\<lambda>_. True) (\\<lambda>v l. do {\n    lv \\<leftarrow> l_get_rlx l v;\n    if (k < lv \\<and> lv < C) then do {\n      assert (C+1 < 2*N);\n      l \\<leftarrow> l_set l v (C+1);\n      return l\n    } else return l\n  }) l\n}\""], ["", "lemma gap_effect_invar[simp]: \"l_invar l \\<Longrightarrow> l_invar (gap_effect l k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_invar l \\<Longrightarrow> l_invar (gap_effect l k)", "unfolding gap_effect_def l_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v. l v \\<noteq> 0 \\<longrightarrow> v \\<in> V \\<Longrightarrow>\n    \\<forall>v.\n       (if k < l v \\<and> l v < card V then card V + 1 else l v) \\<noteq>\n       0 \\<longrightarrow>\n       v \\<in> V", "by auto"], ["", "lemma relabel_effect_invar[simp]: \"\\<lbrakk>l_invar l; u\\<in>V\\<rbrakk> \\<Longrightarrow> l_invar (relabel_effect f l u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l_invar l; u \\<in> V\\<rbrakk>\n    \\<Longrightarrow> l_invar (relabel_effect f l u)", "unfolding relabel_effect_def l_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v. l v \\<noteq> 0 \\<longrightarrow> v \\<in> V;\n     u \\<in> V\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         (l(u := Min {l v |v. (u, v) \\<in> cfE_of f} + 1))\n                          v \\<noteq>\n                         0 \\<longrightarrow>\n                         v \\<in> V", "by auto"], ["", "lemma gap_aux_correct[THEN order_trans, refine_vcg]: \n  \"\\<lbrakk>l_invar l; C=card V\\<rbrakk> \\<Longrightarrow> gap_aux C l k \\<le> SPEC (\\<lambda>r. r=gap_effect l k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l_invar l; C = card V\\<rbrakk>\n    \\<Longrightarrow> gap_aux C l k \\<le> (spec r. r = gap_effect l k)", "unfolding gap_aux_def l_get_rlx_def l_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l_invar l; C = card V\\<rbrakk>\n    \\<Longrightarrow> nfoldli [0..<N] (\\<lambda>_. True)\n                       (\\<lambda>v l.\n                           assert (v < N) \\<bind>\n                           (\\<lambda>_. return (l v)) \\<bind>\n                           (\\<lambda>lv.\n                               if k < lv \\<and> lv < C\n                               then assert (C + 1 < 2 * N) \\<bind>\n                                    (\\<lambda>_.\n  assert (v \\<in> V) \\<bind>\n  (\\<lambda>_.\n      assert (C + 1 < 2 * card V) \\<bind>\n      (\\<lambda>_. return (l(v := C + 1)))) \\<bind>\n  return)\n                               else return l))\n                       l\n                      \\<le> (spec r. r = gap_effect l k)", "apply (simp only: nres_monad_laws)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l_invar l; C = card V\\<rbrakk>\n    \\<Longrightarrow> nfoldli [0..<N] (\\<lambda>_. True)\n                       (\\<lambda>v l.\n                           assert (v < N) \\<bind>\n                           (\\<lambda>x.\n                               if k < l v \\<and> l v < card V\n                               then assert (card V + 1 < 2 * N) \\<bind>\n                                    (\\<lambda>_.\n  assert (v \\<in> V) \\<bind>\n  (\\<lambda>_.\n      assert (card V + 1 < 2 * card V) \\<bind>\n      (\\<lambda>_. return (l(v := card V + 1)))))\n                               else return l))\n                       l\n                      \\<le> (spec r. r = gap_effect l k)", "apply (refine_vcg nfoldli_rule[where I = \"\\<lambda>it1 it2 l'. \\<forall>u. if u\\<in>set it2 then l' u = l u else l' u = gap_effect l k u\"])"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>l_invar l; C = card V\\<rbrakk>\n       \\<Longrightarrow> if u \\<in> set [0..<N] then l u = l u\n                         else l u = gap_effect l k u\n 2. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>l_invar l; C = card V; [0..<N] = l1 @ x # l2;\n        \\<forall>u.\n           if u \\<in> set (x # l2) then \\<sigma> u = l u\n           else \\<sigma> u = gap_effect l k u;\n        True\\<rbrakk>\n       \\<Longrightarrow> x < N\n 3. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>l_invar l; C = card V; [0..<N] = l1 @ x # l2;\n        \\<forall>u.\n           if u \\<in> set (x # l2) then \\<sigma> u = l u\n           else \\<sigma> u = gap_effect l k u;\n        True; x < N; k < \\<sigma> x \\<and> \\<sigma> x < card V\\<rbrakk>\n       \\<Longrightarrow> card V + 1 < 2 * N\n 4. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>l_invar l; C = card V; [0..<N] = l1 @ x # l2;\n        \\<forall>u.\n           if u \\<in> set (x # l2) then \\<sigma> u = l u\n           else \\<sigma> u = gap_effect l k u;\n        True; x < N; k < \\<sigma> x \\<and> \\<sigma> x < card V;\n        card V + 1 < 2 * N\\<rbrakk>\n       \\<Longrightarrow> x \\<in> V\n 5. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>l_invar l; C = card V; [0..<N] = l1 @ x # l2;\n        \\<forall>u.\n           if u \\<in> set (x # l2) then \\<sigma> u = l u\n           else \\<sigma> u = gap_effect l k u;\n        True; x < N; k < \\<sigma> x \\<and> \\<sigma> x < card V;\n        card V + 1 < 2 * N; x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> card V + 1 < 2 * card V\n 6. \\<And>x l1 l2 \\<sigma> u.\n       \\<lbrakk>l_invar l; C = card V; [0..<N] = l1 @ x # l2;\n        \\<forall>u.\n           if u \\<in> set (x # l2) then \\<sigma> u = l u\n           else \\<sigma> u = gap_effect l k u;\n        True; x < N; k < \\<sigma> x \\<and> \\<sigma> x < card V;\n        card V + 1 < 2 * N; x \\<in> V; card V + 1 < 2 * card V\\<rbrakk>\n       \\<Longrightarrow> if u \\<in> set l2\n                         then (\\<sigma>(x := card V + 1)) u = l u\n                         else (\\<sigma>(x := card V + 1)) u =\n                              gap_effect l k u\n 7. \\<And>x l1 l2 \\<sigma> u.\n       \\<lbrakk>l_invar l; C = card V; [0..<N] = l1 @ x # l2;\n        \\<forall>u.\n           if u \\<in> set (x # l2) then \\<sigma> u = l u\n           else \\<sigma> u = gap_effect l k u;\n        True; x < N;\n        \\<not> (k < \\<sigma> x \\<and> \\<sigma> x < card V)\\<rbrakk>\n       \\<Longrightarrow> if u \\<in> set l2 then \\<sigma> u = l u\n                         else \\<sigma> u = gap_effect l k u\n 8. \\<And>l1 l2 \\<sigma>.\n       \\<lbrakk>l_invar l; C = card V; [0..<N] = l1 @ l2;\n        \\<forall>u.\n           if u \\<in> set l2 then \\<sigma> u = l u\n           else \\<sigma> u = gap_effect l k u;\n        \\<not> True\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = gap_effect l k\n 9. \\<And>\\<sigma>.\n       \\<lbrakk>l_invar l; C = card V;\n        \\<forall>u.\n           if u \\<in> set [] then \\<sigma> u = l u\n           else \\<sigma> u = gap_effect l k u;\n        True\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = gap_effect l k", "apply (vc_solve simp: upt_eq_lel_conv)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>l_invar l; C = card V; \\<not> u < N\\<rbrakk>\n       \\<Longrightarrow> l u = gap_effect l k u\n 2. \\<And>x \\<sigma>.\n       \\<lbrakk>l_invar l; C = card V;\n        \\<forall>u.\n           if u = x \\<or> Suc x \\<le> u \\<and> u < N then \\<sigma> u = l u\n           else \\<sigma> u = gap_effect l k u;\n        x < N; k < l x; l x < card V\\<rbrakk>\n       \\<Longrightarrow> Suc (card V) < 2 * N\n 3. \\<And>x \\<sigma>.\n       \\<lbrakk>l_invar l; C = card V;\n        \\<forall>u.\n           if u = x \\<or> Suc x \\<le> u \\<and> u < N then \\<sigma> u = l u\n           else \\<sigma> u = gap_effect l k u;\n        x < N; Suc (card V) < 2 * N; k < l x; l x < card V\\<rbrakk>\n       \\<Longrightarrow> x \\<in> V\n 4. \\<And>x \\<sigma>.\n       \\<lbrakk>l_invar l; C = card V;\n        \\<forall>u.\n           if u = x \\<or> Suc x \\<le> u \\<and> u < N then \\<sigma> u = l u\n           else \\<sigma> u = gap_effect l k u;\n        Suc (card V) < 2 * N; x \\<in> V; k < l x; l x < card V\\<rbrakk>\n       \\<Longrightarrow> Suc (card V) = gap_effect l k x\n 5. \\<And>x \\<sigma> u.\n       \\<lbrakk>l_invar l; C = card V;\n        \\<forall>u.\n           if u = x \\<or> Suc x \\<le> u \\<and> u < N then \\<sigma> u = l u\n           else \\<sigma> u = gap_effect l k u;\n        x < N; k < l x \\<longrightarrow> \\<not> l x < card V;\n        Suc x \\<le> u \\<longrightarrow> \\<not> u < N\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> u = gap_effect l k u\n 6. \\<And>\\<sigma>.\n       \\<lbrakk>l_invar l; C = card V;\n        \\<forall>u. \\<sigma> u = gap_effect l k u\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = gap_effect l k", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l_invar l; C = card V; \\<not> u_ < N\\<rbrakk>\n    \\<Longrightarrow> l u_ = gap_effect l k u_", "apply (frule gap_effect_invar[where k=k])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l_invar l; C = card V; \\<not> u_ < N;\n     l_invar (gap_effect l k)\\<rbrakk>\n    \\<Longrightarrow> l u_ = gap_effect l k u_", "unfolding l_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v. l v \\<noteq> 0 \\<longrightarrow> v \\<in> V;\n     C = card V; \\<not> u_ < N;\n     \\<forall>v.\n        gap_effect l k v \\<noteq> 0 \\<longrightarrow> v \\<in> V\\<rbrakk>\n    \\<Longrightarrow> l u_ = gap_effect l k u_", "using V_ss"], ["proof (prove)\nusing this:\n  V \\<subseteq> {0..<N}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v. l v \\<noteq> 0 \\<longrightarrow> v \\<in> V;\n     C = card V; \\<not> u_ < N;\n     \\<forall>v.\n        gap_effect l k v \\<noteq> 0 \\<longrightarrow> v \\<in> V\\<rbrakk>\n    \\<Longrightarrow> l u_ = gap_effect l k u_", "by force"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x \\<sigma>.\n       \\<lbrakk>l_invar l; C = card V;\n        \\<forall>u.\n           if u = x \\<or> Suc x \\<le> u \\<and> u < N then \\<sigma> u = l u\n           else \\<sigma> u = gap_effect l k u;\n        x < N; k < l x; l x < card V\\<rbrakk>\n       \\<Longrightarrow> Suc (card V) < 2 * N\n 2. \\<And>x \\<sigma>.\n       \\<lbrakk>l_invar l; C = card V;\n        \\<forall>u.\n           if u = x \\<or> Suc x \\<le> u \\<and> u < N then \\<sigma> u = l u\n           else \\<sigma> u = gap_effect l k u;\n        x < N; Suc (card V) < 2 * N; k < l x; l x < card V\\<rbrakk>\n       \\<Longrightarrow> x \\<in> V\n 3. \\<And>x \\<sigma>.\n       \\<lbrakk>l_invar l; C = card V;\n        \\<forall>u.\n           if u = x \\<or> Suc x \\<le> u \\<and> u < N then \\<sigma> u = l u\n           else \\<sigma> u = gap_effect l k u;\n        Suc (card V) < 2 * N; x \\<in> V; k < l x; l x < card V\\<rbrakk>\n       \\<Longrightarrow> Suc (card V) = gap_effect l k x\n 4. \\<And>x \\<sigma> u.\n       \\<lbrakk>l_invar l; C = card V;\n        \\<forall>u.\n           if u = x \\<or> Suc x \\<le> u \\<and> u < N then \\<sigma> u = l u\n           else \\<sigma> u = gap_effect l k u;\n        x < N; k < l x \\<longrightarrow> \\<not> l x < card V;\n        Suc x \\<le> u \\<longrightarrow> \\<not> u < N\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> u = gap_effect l k u\n 5. \\<And>\\<sigma>.\n       \\<lbrakk>l_invar l; C = card V;\n        \\<forall>u. \\<sigma> u = gap_effect l k u\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = gap_effect l k", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l_invar l; C = card V;\n     \\<forall>u.\n        if u = x_ \\<or> Suc x_ \\<le> u \\<and> u < N then \\<sigma>_ u = l u\n        else \\<sigma>_ u = gap_effect l k u;\n     x_ < N; k < l x_; l x_ < card V\\<rbrakk>\n    \\<Longrightarrow> Suc (card V) < 2 * N", "using N_not_Z cardV_le_N"], ["proof (prove)\nusing this:\n  N \\<noteq> 0\n  card V \\<le> N\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l_invar l; C = card V;\n     \\<forall>u.\n        if u = x_ \\<or> Suc x_ \\<le> u \\<and> u < N then \\<sigma>_ u = l u\n        else \\<sigma>_ u = gap_effect l k u;\n     x_ < N; k < l x_; l x_ < card V\\<rbrakk>\n    \\<Longrightarrow> Suc (card V) < 2 * N", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x \\<sigma>.\n       \\<lbrakk>l_invar l; C = card V;\n        \\<forall>u.\n           if u = x \\<or> Suc x \\<le> u \\<and> u < N then \\<sigma> u = l u\n           else \\<sigma> u = gap_effect l k u;\n        x < N; Suc (card V) < 2 * N; k < l x; l x < card V\\<rbrakk>\n       \\<Longrightarrow> x \\<in> V\n 2. \\<And>x \\<sigma>.\n       \\<lbrakk>l_invar l; C = card V;\n        \\<forall>u.\n           if u = x \\<or> Suc x \\<le> u \\<and> u < N then \\<sigma> u = l u\n           else \\<sigma> u = gap_effect l k u;\n        Suc (card V) < 2 * N; x \\<in> V; k < l x; l x < card V\\<rbrakk>\n       \\<Longrightarrow> Suc (card V) = gap_effect l k x\n 3. \\<And>x \\<sigma> u.\n       \\<lbrakk>l_invar l; C = card V;\n        \\<forall>u.\n           if u = x \\<or> Suc x \\<le> u \\<and> u < N then \\<sigma> u = l u\n           else \\<sigma> u = gap_effect l k u;\n        x < N; k < l x \\<longrightarrow> \\<not> l x < card V;\n        Suc x \\<le> u \\<longrightarrow> \\<not> u < N\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> u = gap_effect l k u\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>l_invar l; C = card V;\n        \\<forall>u. \\<sigma> u = gap_effect l k u\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = gap_effect l k", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l_invar l; C = card V;\n     \\<forall>u.\n        if u = x_ \\<or> Suc x_ \\<le> u \\<and> u < N then \\<sigma>_ u = l u\n        else \\<sigma>_ u = gap_effect l k u;\n     x_ < N; Suc (card V) < 2 * N; k < l x_; l x_ < card V\\<rbrakk>\n    \\<Longrightarrow> x_ \\<in> V", "unfolding l_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v. l v \\<noteq> 0 \\<longrightarrow> v \\<in> V;\n     C = card V;\n     \\<forall>u.\n        if u = x_ \\<or> Suc x_ \\<le> u \\<and> u < N then \\<sigma>_ u = l u\n        else \\<sigma>_ u = gap_effect l k u;\n     x_ < N; Suc (card V) < 2 * N; k < l x_; l x_ < card V\\<rbrakk>\n    \\<Longrightarrow> x_ \\<in> V", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x \\<sigma>.\n       \\<lbrakk>l_invar l; C = card V;\n        \\<forall>u.\n           if u = x \\<or> Suc x \\<le> u \\<and> u < N then \\<sigma> u = l u\n           else \\<sigma> u = gap_effect l k u;\n        Suc (card V) < 2 * N; x \\<in> V; k < l x; l x < card V\\<rbrakk>\n       \\<Longrightarrow> Suc (card V) = gap_effect l k x\n 2. \\<And>x \\<sigma> u.\n       \\<lbrakk>l_invar l; C = card V;\n        \\<forall>u.\n           if u = x \\<or> Suc x \\<le> u \\<and> u < N then \\<sigma> u = l u\n           else \\<sigma> u = gap_effect l k u;\n        x < N; k < l x \\<longrightarrow> \\<not> l x < card V;\n        Suc x \\<le> u \\<longrightarrow> \\<not> u < N\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> u = gap_effect l k u\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>l_invar l; C = card V;\n        \\<forall>u. \\<sigma> u = gap_effect l k u\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = gap_effect l k", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l_invar l; C = card V;\n     \\<forall>u.\n        if u = x_ \\<or> Suc x_ \\<le> u \\<and> u < N then \\<sigma>_ u = l u\n        else \\<sigma>_ u = gap_effect l k u;\n     Suc (card V) < 2 * N; x_ \\<in> V; k < l x_; l x_ < card V\\<rbrakk>\n    \\<Longrightarrow> Suc (card V) = gap_effect l k x_", "unfolding gap_effect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l_invar l; C = card V;\n     \\<forall>u.\n        if u = x_ \\<or> Suc x_ \\<le> u \\<and> u < N then \\<sigma>_ u = l u\n        else \\<sigma>_ u =\n             (if k < l u \\<and> l u < card V then card V + 1 else l u);\n     Suc (card V) < 2 * N; x_ \\<in> V; k < l x_; l x_ < card V\\<rbrakk>\n    \\<Longrightarrow> Suc (card V) =\n                      (if k < l x_ \\<and> l x_ < card V then card V + 1\n                       else l x_)", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x \\<sigma> u.\n       \\<lbrakk>l_invar l; C = card V;\n        \\<forall>u.\n           if u = x \\<or> Suc x \\<le> u \\<and> u < N then \\<sigma> u = l u\n           else \\<sigma> u = gap_effect l k u;\n        x < N; k < l x \\<longrightarrow> \\<not> l x < card V;\n        Suc x \\<le> u \\<longrightarrow> \\<not> u < N\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> u = gap_effect l k u\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>l_invar l; C = card V;\n        \\<forall>u. \\<sigma> u = gap_effect l k u\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = gap_effect l k", "subgoal for v l' u"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l_invar l; C = card V;\n     \\<forall>u.\n        if u = v \\<or> Suc v \\<le> u \\<and> u < N then l' u = l u\n        else l' u = gap_effect l k u;\n     v < N; k < l v \\<longrightarrow> \\<not> l v < card V;\n     Suc v \\<le> u \\<longrightarrow> \\<not> u < N\\<rbrakk>\n    \\<Longrightarrow> l' u = gap_effect l k u", "apply (drule spec[where x=u])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l_invar l; C = card V; v < N;\n     k < l v \\<longrightarrow> \\<not> l v < card V;\n     Suc v \\<le> u \\<longrightarrow> \\<not> u < N;\n     if u = v \\<or> Suc v \\<le> u \\<and> u < N then l' u = l u\n     else l' u = gap_effect l k u\\<rbrakk>\n    \\<Longrightarrow> l' u = gap_effect l k u", "by (auto split: if_splits simp: gap_effect_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>l_invar l; C = card V;\n        \\<forall>u. \\<sigma> u = gap_effect l k u\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = gap_effect l k", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l_invar l; C = card V;\n     \\<forall>u. \\<sigma>_ u = gap_effect l k u\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>_ = gap_effect l k", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"gap2 C clc k \\<equiv> do {\n  nfoldli [0..<N] (\\<lambda>_. True) (\\<lambda>v clc. do {\n    lv \\<leftarrow> clc_get_rlx clc v;\n    if (k < lv \\<and> lv < C) then do {\n      clc \\<leftarrow> clc_set clc v (C+1);\n      return clc\n    } else return clc\n  }) clc\n}\""], ["", "lemma gap2_refine[refine]:  \n  assumes [simplified,simp]: \"(Ci,C)\\<in>nat_rel\" \"(ki,k)\\<in>nat_rel\"\n  assumes CLC: \"(clc,l)\\<in>clc_rel\"  \n  shows \"gap2 Ci clc ki \\<le>\\<Down>clc_rel (gap_aux C l k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gap2 Ci clc ki \\<le> \\<Down> clc_rel (gap_aux C l k)", "unfolding gap2_def gap_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli [0..<N] (\\<lambda>_. True)\n     (\\<lambda>v clc.\n         clc_get_rlx clc v \\<bind>\n         (\\<lambda>lv.\n             if ki < lv \\<and> lv < Ci\n             then clc_set clc v (Ci + 1) \\<bind> return else return clc))\n     clc\n    \\<le> \\<Down> clc_rel\n           (nfoldli [0..<N] (\\<lambda>_. True)\n             (\\<lambda>v l.\n                 l_get_rlx l v \\<bind>\n                 (\\<lambda>lv.\n                     if k < lv \\<and> lv < C\n                     then assert (C + 1 < 2 * N) \\<bind>\n                          (\\<lambda>_. l_set l v (C + 1) \\<bind> return)\n                     else return l))\n             l)", "apply (refine_rcg CLC)"], ["proof (prove)\ngoal (6 subgoals):\n 1. ([0..<N], [0..<N]) \\<in> \\<langle>?S\\<rangle>list_rel\n 2. \\<And>a a'.\n       (a, a') \\<in> clc_rel \\<Longrightarrow> (True, True) \\<in> bool_rel\n 3. \\<And>xi x si s.\n       \\<lbrakk>(xi, x) \\<in> ?S; (si, s) \\<in> clc_rel; True\\<rbrakk>\n       \\<Longrightarrow> (xi, x) \\<in> nat_rel\n 4. \\<And>xi x si s lv lva.\n       \\<lbrakk>(xi, x) \\<in> ?S; (si, s) \\<in> clc_rel; True;\n        (lv, lva) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (ki < lv \\<and> lv < Ci) = (k < lva \\<and> lva < C)\n 5. \\<And>xi x si s lv lva.\n       \\<lbrakk>(xi, x) \\<in> ?S; (si, s) \\<in> clc_rel; True;\n        (lv, lva) \\<in> nat_rel; ki < lv \\<and> lv < Ci;\n        k < lva \\<and> lva < C; C + 1 < 2 * N\\<rbrakk>\n       \\<Longrightarrow> (xi, x) \\<in> nat_rel\n 6. \\<And>xi x si s lv lva.\n       \\<lbrakk>(xi, x) \\<in> ?S; (si, s) \\<in> clc_rel; True;\n        (lv, lva) \\<in> nat_rel; ki < lv \\<and> lv < Ci;\n        k < lva \\<and> lva < C; C + 1 < 2 * N\\<rbrakk>\n       \\<Longrightarrow> (Ci + 1, C + 1) \\<in> nat_rel", "apply refine_dref_type"], ["proof (prove)\ngoal (4 subgoals):\n 1. ([0..<N], [0..<N]) \\<in> \\<langle>nat_rel\\<rangle>list_rel\n 2. \\<And>a a'.\n       (a, a') \\<in> clc_rel \\<Longrightarrow> (True, True) \\<in> bool_rel\n 3. \\<And>xi x si s lv lva.\n       \\<lbrakk>(xi, x) \\<in> nat_rel; (si, s) \\<in> clc_rel; True;\n        (lv, lva) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (ki < lv \\<and> lv < Ci) = (k < lva \\<and> lva < C)\n 4. \\<And>xi x si s lv lva.\n       \\<lbrakk>(xi, x) \\<in> nat_rel; (si, s) \\<in> clc_rel; True;\n        (lv, lva) \\<in> nat_rel; ki < lv \\<and> lv < Ci;\n        k < lva \\<and> lva < C; C + 1 < 2 * N\\<rbrakk>\n       \\<Longrightarrow> (Ci + 1, C + 1) \\<in> nat_rel", "by auto"], ["", "definition \"gap_relabel_aux C f l u \\<equiv> do {\n  lu \\<leftarrow> l_get l u;\n  l \\<leftarrow> relabel f l u;\n  if gap_precond l lu then \n    gap_aux C l lu\n  else return l\n}\""], ["", "lemma gap_relabel_aux_refine: \n  assumes [simp]: \"C = card V\" \"l_invar l\"\n  shows \"gap_relabel_aux C f l u \\<le> gap_relabel f l u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gap_relabel_aux C f l u \\<le> gap_relabel f l u", "unfolding gap_relabel_aux_def gap_relabel_def relabel_def \n    gap_relabel_effect_def l_get_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. assert (u \\<in> V) \\<bind> (\\<lambda>_. return (l u)) \\<bind>\n    (\\<lambda>lu.\n        assert (Height_Bounded_Labeling c s t f l) \\<bind>\n        (\\<lambda>_.\n            assert (relabel_precond f l u) \\<bind>\n            (\\<lambda>_.\n                assert (u \\<in> V - {s, t}) \\<bind>\n                (\\<lambda>_. return (relabel_effect f l u)))) \\<bind>\n        (\\<lambda>l. if gap_precond l lu then gap_aux C l lu else return l))\n    \\<le> assert (u \\<in> V - {s, t}) \\<bind>\n          (\\<lambda>_.\n              assert (Height_Bounded_Labeling c s t f l) \\<bind>\n              (\\<lambda>_.\n                  assert (relabel_precond f l u) \\<bind>\n                  (\\<lambda>_.\n                      assert\n                       (l u < 2 * card V \\<and>\n                        relabel_effect f l u u < 2 * card V) \\<bind>\n                      (\\<lambda>_.\n                          return\n                           (let l' = relabel_effect f l u\n                            in if gap_precond l' (l u)\n                               then gap_effect l' (l u) else l')))))", "apply (simp only: Let_def nres_monad_laws)"], ["proof (prove)\ngoal (1 subgoal):\n 1. assert (u \\<in> V) \\<bind>\n    (\\<lambda>x.\n        assert (Height_Bounded_Labeling c s t f l) \\<bind>\n        (\\<lambda>x.\n            assert (relabel_precond f l u) \\<bind>\n            (\\<lambda>x.\n                assert (u \\<in> V - {s, t}) \\<bind>\n                (\\<lambda>x.\n                    if gap_precond (relabel_effect f l u) (l u)\n                    then gap_aux C (relabel_effect f l u) (l u)\n                    else return (relabel_effect f l u)))))\n    \\<le> assert (u \\<in> V - {s, t}) \\<bind>\n          (\\<lambda>_.\n              assert (Height_Bounded_Labeling c s t f l) \\<bind>\n              (\\<lambda>_.\n                  assert (relabel_precond f l u) \\<bind>\n                  (\\<lambda>_.\n                      assert\n                       (l u < 2 * card V \\<and>\n                        relabel_effect f l u u < 2 * card V) \\<bind>\n                      (\\<lambda>_.\n                          return\n                           (if gap_precond (relabel_effect f l u) (l u)\n                            then gap_effect (relabel_effect f l u) (l u)\n                            else relabel_effect f l u)))))", "apply refine_vcg"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>u \\<in> V - {s, t}; Height_Bounded_Labeling c s t f l;\n     relabel_precond f l u;\n     l u < 2 * card V \\<and> relabel_effect f l u u < 2 * card V\\<rbrakk>\n    \\<Longrightarrow> u \\<in> V\n 2. \\<lbrakk>u \\<in> V - {s, t}; Height_Bounded_Labeling c s t f l;\n     relabel_precond f l u;\n     l u < 2 * card V \\<and> relabel_effect f l u u < 2 * card V; u \\<in> V;\n     Height_Bounded_Labeling c s t f l; relabel_precond f l u;\n     u \\<in> V - {s, t}; gap_precond (relabel_effect f l u) (l u)\\<rbrakk>\n    \\<Longrightarrow> l_invar (relabel_effect f l u)\n 3. \\<lbrakk>u \\<in> V - {s, t}; Height_Bounded_Labeling c s t f l;\n     relabel_precond f l u;\n     l u < 2 * card V \\<and> relabel_effect f l u u < 2 * card V; u \\<in> V;\n     Height_Bounded_Labeling c s t f l; relabel_precond f l u;\n     u \\<in> V - {s, t}; gap_precond (relabel_effect f l u) (l u)\\<rbrakk>\n    \\<Longrightarrow> C = card V\n 4. \\<And>x.\n       \\<lbrakk>u \\<in> V - {s, t}; Height_Bounded_Labeling c s t f l;\n        relabel_precond f l u;\n        l u < 2 * card V \\<and> relabel_effect f l u u < 2 * card V;\n        u \\<in> V; Height_Bounded_Labeling c s t f l; relabel_precond f l u;\n        u \\<in> V - {s, t}; gap_precond (relabel_effect f l u) (l u);\n        x = gap_effect (relabel_effect f l u) (l u)\\<rbrakk>\n       \\<Longrightarrow> (if gap_precond (relabel_effect f l u) (l u)\n                          then gap_effect (relabel_effect f l u) (l u)\n                          else relabel_effect f l u) =\n                         x\n 5. \\<lbrakk>u \\<in> V - {s, t}; Height_Bounded_Labeling c s t f l;\n     relabel_precond f l u;\n     l u < 2 * card V \\<and> relabel_effect f l u u < 2 * card V; u \\<in> V;\n     Height_Bounded_Labeling c s t f l; relabel_precond f l u;\n     u \\<in> V - {s, t};\n     \\<not> gap_precond (relabel_effect f l u) (l u)\\<rbrakk>\n    \\<Longrightarrow> (if gap_precond (relabel_effect f l u) (l u)\n                       then gap_effect (relabel_effect f l u) (l u)\n                       else relabel_effect f l u) =\n                      relabel_effect f l u", "by auto"], ["", "definition \"min_adj_label_clc am cf clc u \\<equiv> case clc of (_,l) \\<Rightarrow> min_adj_label am cf l u\""], ["", "definition \"clc_relabel2 am cf clc u \\<equiv> do {\n  assert (u\\<in>V - {s,t});\n  nl \\<leftarrow> min_adj_label_clc am cf clc u;\n  clc \\<leftarrow> clc_set clc u (nl+1);\n  return clc\n}\""], ["", "lemma clc_relabel2_refine[refine]: \n  assumes XF: \"((x,cf),f)\\<in>xf_rel\"\n  assumes CLC: \"(clc,l)\\<in>clc_rel\"  \n  assumes AM: \"(am,adjacent_nodes)\\<in>nat_rel\\<rightarrow>\\<langle>nat_rel\\<rangle>list_set_rel\"\n  assumes [simplified,simp]: \"(ui,u)\\<in>Id\"\n  shows \"clc_relabel2 am cf clc ui \\<le> \\<Down>clc_rel (relabel f l u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clc_relabel2 am cf clc ui \\<le> \\<Down> clc_rel (relabel f l u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. clc_relabel2 am cf clc ui \\<le> \\<Down> clc_rel (relabel f l u)", "have \"clc_relabel2 am cf clc ui \\<le>\\<Down>clc_rel (relabel2 am cf l ui)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clc_relabel2 am cf clc ui \\<le> \\<Down> clc_rel (relabel2 am cf l ui)", "unfolding clc_relabel2_def relabel2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. assert (ui \\<in> V - {s, t}) \\<bind>\n    (\\<lambda>_.\n        min_adj_label_clc am cf clc ui \\<bind>\n        (\\<lambda>nl. clc_set clc ui (nl + 1) \\<bind> return))\n    \\<le> \\<Down> clc_rel\n           (assert (ui \\<in> V - {s, t}) \\<bind>\n            (\\<lambda>_.\n                min_adj_label am cf l ui \\<bind>\n                (\\<lambda>nl. l_set l ui (nl + 1) \\<bind> return)))", "apply (refine_rcg)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>ui \\<in> V - {s, t}; ui \\<in> V - {s, t}\\<rbrakk>\n    \\<Longrightarrow> min_adj_label_clc am cf clc ui\n                      \\<le> \\<Down> ?R'2 (min_adj_label am cf l ui)\n 2. \\<And>nl nla.\n       \\<lbrakk>ui \\<in> V - {s, t}; ui \\<in> V - {s, t};\n        (nl, nla) \\<in> ?R'2\\<rbrakk>\n       \\<Longrightarrow> (clc, l) \\<in> clc_rel\n 3. \\<And>nl nla.\n       \\<lbrakk>ui \\<in> V - {s, t}; ui \\<in> V - {s, t};\n        (nl, nla) \\<in> ?R'2\\<rbrakk>\n       \\<Longrightarrow> (ui, ui) \\<in> nat_rel\n 4. \\<And>nl nla.\n       \\<lbrakk>ui \\<in> V - {s, t}; ui \\<in> V - {s, t};\n        (nl, nla) \\<in> ?R'2\\<rbrakk>\n       \\<Longrightarrow> (nl + 1, nla + 1) \\<in> nat_rel", "apply (refine_dref_type)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>ui \\<in> V - {s, t}; ui \\<in> V - {s, t}\\<rbrakk>\n    \\<Longrightarrow> min_adj_label_clc am cf clc ui\n                      \\<le> \\<Down> nat_rel (min_adj_label am cf l ui)\n 2. \\<And>nl nla.\n       \\<lbrakk>ui \\<in> V - {s, t}; ui \\<in> V - {s, t};\n        (nl, nla) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (clc, l) \\<in> clc_rel\n 3. \\<And>nl nla.\n       \\<lbrakk>ui \\<in> V - {s, t}; ui \\<in> V - {s, t};\n        (nl, nla) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (ui, ui) \\<in> nat_rel\n 4. \\<And>nl nla.\n       \\<lbrakk>ui \\<in> V - {s, t}; ui \\<in> V - {s, t};\n        (nl, nla) \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (nl + 1, nla + 1) \\<in> nat_rel", "apply (vc_solve simp: CLC)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> V; u \\<noteq> s; u \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> min_adj_label_clc am cf clc u\n                      \\<le> min_adj_label am cf l u", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> V; u \\<noteq> s; u \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> min_adj_label_clc am cf clc u\n                      \\<le> min_adj_label am cf l u", "using CLC"], ["proof (prove)\nusing this:\n  (clc, l) \\<in> clc_rel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> V; u \\<noteq> s; u \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> min_adj_label_clc am cf clc u\n                      \\<le> min_adj_label am cf l u", "unfolding clc_rel_def in_br_conv min_adj_label_clc_def"], ["proof (prove)\nusing this:\n  l = snd clc \\<and> clc_invar clc\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> V; u \\<noteq> s; u \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> (case clc of\n                       (x, l) \\<Rightarrow> min_adj_label am cf l u)\n                      \\<le> min_adj_label am cf l u", "by (auto split: prod.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  clc_relabel2 am cf clc ui \\<le> \\<Down> clc_rel (relabel2 am cf l ui)\n\ngoal (1 subgoal):\n 1. clc_relabel2 am cf clc ui \\<le> \\<Down> clc_rel (relabel f l u)", "also"], ["proof (state)\nthis:\n  clc_relabel2 am cf clc ui \\<le> \\<Down> clc_rel (relabel2 am cf l ui)\n\ngoal (1 subgoal):\n 1. clc_relabel2 am cf clc ui \\<le> \\<Down> clc_rel (relabel f l u)", "note relabel2_refine[OF XF AM, of l l ui u]"], ["proof (state)\nthis:\n  \\<lbrakk>(l, l) \\<in> Id; (ui, u) \\<in> nat_rel\\<rbrakk>\n  \\<Longrightarrow> relabel2 am cf l ui \\<le> \\<Down> Id (relabel f l u)\n\ngoal (1 subgoal):\n 1. clc_relabel2 am cf clc ui \\<le> \\<Down> clc_rel (relabel f l u)", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>(l, l) \\<in> Id; (ui, u) \\<in> nat_rel\\<rbrakk>\n  \\<Longrightarrow> clc_relabel2 am cf clc ui\n                    \\<le> \\<Down> clc_rel (relabel f l u)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(l, l) \\<in> Id; (ui, u) \\<in> nat_rel\\<rbrakk>\n  \\<Longrightarrow> clc_relabel2 am cf clc ui\n                    \\<le> \\<Down> clc_rel (relabel f l u)\n\ngoal (1 subgoal):\n 1. clc_relabel2 am cf clc ui \\<le> \\<Down> clc_rel (relabel f l u)", "by simp"], ["proof (state)\nthis:\n  clc_relabel2 am cf clc ui \\<le> \\<Down> clc_rel (relabel f l u)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"gap_relabel2 C am cf clc u \\<equiv> do {\n  lu \\<leftarrow> clc_get clc u;\n  clc \\<leftarrow> clc_relabel2 am cf clc u;\n  has_gap \\<leftarrow> clc_has_gap clc lu;\n  if has_gap then gap2 C clc lu\n  else \n    RETURN clc\n}\""], ["", "lemma gap_relabel2_refine_aux:\n  assumes XCF: \"((x, cf), f) \\<in> xf_rel\"  \n  assumes CLC: \"(clc,l)\\<in>clc_rel\"  \n  assumes AM: \"(am,adjacent_nodes)\\<in>nat_rel\\<rightarrow>\\<langle>nat_rel\\<rangle>list_set_rel\"\n  assumes [simplified,simp]: \"(Ci,C)\\<in>Id\" \"(ui,u)\\<in>Id\"\n  shows \"gap_relabel2 Ci am cf clc ui \\<le> \\<Down>clc_rel (gap_relabel_aux C f l u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gap_relabel2 Ci am cf clc ui\n    \\<le> \\<Down> clc_rel (gap_relabel_aux C f l u)", "unfolding gap_relabel2_def gap_relabel_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. clc_get clc ui \\<bind>\n    (\\<lambda>lu.\n        clc_relabel2 am cf clc ui \\<bind>\n        (\\<lambda>clc.\n            clc_has_gap clc lu \\<bind>\n            (\\<lambda>has_gap.\n                if has_gap then gap2 Ci clc lu else return clc)))\n    \\<le> \\<Down> clc_rel\n           (l_get l u \\<bind>\n            (\\<lambda>lu.\n                relabel f l u \\<bind>\n                (\\<lambda>l.\n                    if gap_precond l lu then gap_aux C l lu else return l)))", "apply (refine_vcg XCF AM CLC if_bind_cond_refine bind_refine')"], ["proof (prove)\ngoal (6 subgoals):\n 1. (ui, u) \\<in> nat_rel\n 2. \\<And>lu lua.\n       \\<lbrakk>(lu, lua) \\<in> nat_rel; inres (clc_get clc ui) lu;\n        inres (l_get l u) lua; nofail (clc_get clc ui);\n        nofail (l_get l u)\\<rbrakk>\n       \\<Longrightarrow> (ui, u) \\<in> nat_rel\n 3. \\<And>lu lua clca la.\n       \\<lbrakk>(lu, lua) \\<in> nat_rel; inres (clc_get clc ui) lu;\n        inres (l_get l u) lua; nofail (clc_get clc ui); nofail (l_get l u);\n        (clca, la) \\<in> clc_rel; inres (clc_relabel2 am cf clc ui) clca;\n        inres (relabel f l u) la; nofail (clc_relabel2 am cf clc ui);\n        nofail (relabel f l u)\\<rbrakk>\n       \\<Longrightarrow> (clca, ?l5 lu lua clca la) \\<in> clc_rel\n 4. \\<And>lu lua clca la.\n       \\<lbrakk>(lu, lua) \\<in> nat_rel; inres (clc_get clc ui) lu;\n        inres (l_get l u) lua; nofail (clc_get clc ui); nofail (l_get l u);\n        (clca, la) \\<in> clc_rel; inres (clc_relabel2 am cf clc ui) clca;\n        inres (relabel f l u) la; nofail (clc_relabel2 am cf clc ui);\n        nofail (relabel f l u)\\<rbrakk>\n       \\<Longrightarrow> lu < 2 * N\n 5. \\<And>lu lua clca la x.\n       \\<lbrakk>(lu, lua) \\<in> nat_rel; inres (clc_get clc ui) lu;\n        inres (l_get l u) lua; nofail (clc_get clc ui); nofail (l_get l u);\n        (clca, la) \\<in> clc_rel; inres (clc_relabel2 am cf clc ui) clca;\n        inres (relabel f l u) la; nofail (clc_relabel2 am cf clc ui);\n        nofail (relabel f l u);\n        x = gap_precond (?l5 lu lua clca la) lu\\<rbrakk>\n       \\<Longrightarrow> gap_precond la lua = x\n 6. \\<And>lu lua clca la.\n       \\<lbrakk>(lu, lua) \\<in> nat_rel; inres (clc_get clc ui) lu;\n        inres (l_get l u) lua; nofail (clc_get clc ui); nofail (l_get l u);\n        (clca, la) \\<in> clc_rel; inres (clc_relabel2 am cf clc ui) clca;\n        inres (relabel f l u) la; nofail (clc_relabel2 am cf clc ui);\n        nofail (relabel f l u); gap_precond la lua\\<rbrakk>\n       \\<Longrightarrow> (Ci, C) \\<in> nat_rel", "apply (vc_solve solve: refl )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>lua a b la.\n       \\<lbrakk>inres (clc_get clc u) lua; inres (l_get l u) lua;\n        nofail (clc_get clc u); nofail (l_get l u);\n        ((a, b), la) \\<in> clc_rel; inres (clc_relabel2 am cf clc u) (a, b);\n        inres (relabel f l u) la; nofail (clc_relabel2 am cf clc u);\n        nofail (relabel f l u)\\<rbrakk>\n       \\<Longrightarrow> lua < 2 * N", "subgoal for _ lu"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>inres (clc_get clc u) lua_; inres (l_get l u) lua_;\n     nofail (clc_get clc u); nofail (l_get l u);\n     ((lu, b_), la_) \\<in> clc_rel;\n     inres (clc_relabel2 am cf clc u) (lu, b_); inres (relabel f l u) la_;\n     nofail (clc_relabel2 am cf clc u); nofail (relabel f l u)\\<rbrakk>\n    \\<Longrightarrow> lua_ < 2 * N", "using CLC"], ["proof (prove)\nusing this:\n  (clc, l) \\<in> clc_rel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inres (clc_get clc u) lua_; inres (l_get l u) lua_;\n     nofail (clc_get clc u); nofail (l_get l u);\n     ((lu, b_), la_) \\<in> clc_rel;\n     inres (clc_relabel2 am cf clc u) (lu, b_); inres (relabel f l u) la_;\n     nofail (clc_relabel2 am cf clc u); nofail (relabel f l u)\\<rbrakk>\n    \\<Longrightarrow> lua_ < 2 * N", "unfolding clc_get_def l_get_def clc_rel_def in_br_conv clc_invar_def"], ["proof (prove)\nusing this:\n  l = snd clc \\<and>\n  (case clc of\n   (cnt, l) \\<Rightarrow>\n     (\\<forall>lv. cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n     (\\<forall>u. l u < 2 * N) \\<and> l_invar l)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>inres\n              ((case clc of\n                (cnt, l) \\<Rightarrow>\n                  \\<lambda>u.\n                     assert (u \\<in> V) \\<bind> (\\<lambda>_. return (l u)))\n                u)\n              lua_;\n     inres (assert (u \\<in> V) \\<bind> (\\<lambda>_. return (l u))) lua_;\n     nofail\n      ((case clc of\n        (cnt, l) \\<Rightarrow>\n          \\<lambda>u. assert (u \\<in> V) \\<bind> (\\<lambda>_. return (l u)))\n        u);\n     nofail (assert (u \\<in> V) \\<bind> (\\<lambda>_. return (l u)));\n     la_ = snd (lu, b_) \\<and>\n     (case (lu, b_) of\n      (cnt, l) \\<Rightarrow>\n        (\\<forall>lv. cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n        (\\<forall>u. l u < 2 * N) \\<and> l_invar l);\n     inres (clc_relabel2 am cf clc u) (lu, b_); inres (relabel f l u) la_;\n     nofail (clc_relabel2 am cf clc u); nofail (relabel f l u)\\<rbrakk>\n    \\<Longrightarrow> lua_ < 2 * N", "by (auto simp: refine_pw_simps split: prod.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gap_relabel2_refine[refine]:\n  assumes XCF: \"((x, cf), f) \\<in> xf_rel\"  \n  assumes CLC: \"(clc,l)\\<in>clc_rel\"  \n  assumes AM: \"(am,adjacent_nodes)\\<in>nat_rel\\<rightarrow>\\<langle>nat_rel\\<rangle>list_set_rel\"\n  assumes [simplified,simp]: \"(ui,u)\\<in>Id\"    \n  assumes CC: \"C = card V\"  \n  shows \"gap_relabel2 C am cf clc ui \\<le>\\<Down>clc_rel (gap_relabel f l u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gap_relabel2 C am cf clc ui \\<le> \\<Down> clc_rel (gap_relabel f l u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gap_relabel2 C am cf clc ui \\<le> \\<Down> clc_rel (gap_relabel f l u)", "from CLC"], ["proof (chain)\npicking this:\n  (clc, l) \\<in> clc_rel", "have LINV: \"l_invar l\""], ["proof (prove)\nusing this:\n  (clc, l) \\<in> clc_rel\n\ngoal (1 subgoal):\n 1. l_invar l", "unfolding clc_rel_def in_br_conv clc_invar_def"], ["proof (prove)\nusing this:\n  l = snd clc \\<and>\n  (case clc of\n   (cnt, l) \\<Rightarrow>\n     (\\<forall>lv. cnt lv = card {u \\<in> V. l u = lv}) \\<and>\n     (\\<forall>u. l u < 2 * N) \\<and> l_invar l)\n\ngoal (1 subgoal):\n 1. l_invar l", "by auto"], ["proof (state)\nthis:\n  l_invar l\n\ngoal (1 subgoal):\n 1. gap_relabel2 C am cf clc ui \\<le> \\<Down> clc_rel (gap_relabel f l u)", "note gap_relabel2_refine_aux[OF XCF CLC AM IdI IdI]"], ["proof (state)\nthis:\n  gap_relabel2 ?C am cf clc ?u\n  \\<le> \\<Down> clc_rel (gap_relabel_aux ?C f l ?u)\n\ngoal (1 subgoal):\n 1. gap_relabel2 C am cf clc ui \\<le> \\<Down> clc_rel (gap_relabel f l u)", "also"], ["proof (state)\nthis:\n  gap_relabel2 ?C am cf clc ?u\n  \\<le> \\<Down> clc_rel (gap_relabel_aux ?C f l ?u)\n\ngoal (1 subgoal):\n 1. gap_relabel2 C am cf clc ui \\<le> \\<Down> clc_rel (gap_relabel f l u)", "note gap_relabel_aux_refine[OF CC LINV]"], ["proof (state)\nthis:\n  gap_relabel_aux C ?f l ?u \\<le> gap_relabel ?f l ?u\n\ngoal (1 subgoal):\n 1. gap_relabel2 C am cf clc ui \\<le> \\<Down> clc_rel (gap_relabel f l u)", "finally"], ["proof (chain)\npicking this:\n  gap_relabel2 C am cf clc ?u1 \\<le> \\<Down> clc_rel (gap_relabel f l ?u1)", "show ?thesis"], ["proof (prove)\nusing this:\n  gap_relabel2 C am cf clc ?u1 \\<le> \\<Down> clc_rel (gap_relabel f l ?u1)\n\ngoal (1 subgoal):\n 1. gap_relabel2 C am cf clc ui \\<le> \\<Down> clc_rel (gap_relabel f l u)", "by simp"], ["proof (state)\nthis:\n  gap_relabel2 C am cf clc ui \\<le> \\<Down> clc_rel (gap_relabel f l u)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Refinement to Efficient Data Structures\\<close>"], ["", "subsubsection \\<open>Registration of Abstract Operations\\<close>"], ["", "text \\<open>We register all abstract operations at once, \n  auto-rewriting the capacity matrix type\\<close>"], ["", "context includes Network_Impl_Sepref_Register \nbegin"], ["", "sepref_register x_get x_add"], ["", "sepref_register l_init l_get l_get_rlx l_set"], ["", "sepref_register clc_init clc_get clc_set clc_has_gap clc_get_rlx"], ["", "sepref_register cnt_init cnt_get cnt_incr cnt_decr"], ["", "sepref_register gap2 min_adj_label min_adj_label_clc"], ["", "sepref_register push2 relabel2 clc_relabel2 gap_relabel2"], ["", "sepref_register pp_init_xcf2"], ["", "end \\<comment> \\<open>Anonymous Context\\<close>"], ["", "subsubsection \\<open>Excess by Array\\<close>"], ["", "definition \"x_assn \\<equiv> is_nf N (0::capacity_impl)\""], ["", "lemma x_init_hnr[sepref_fr_rules]: \n  \"(uncurry0 (Array.new N 0), uncurry0 x_init) \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a x_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 (Array.new N 0), uncurry0 x_init)\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a x_assn", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit); nofail x_init\\<rbrakk>\n       \\<Longrightarrow> <emp> Array.new N\n                                0 <\\<lambda>r.\nemp *\n(\\<exists>\\<^sub>Ax. x_assn x r * \\<up> (return x \\<le> x_init))>\\<^sub>t", "unfolding x_assn_def x_init_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit);\n        nofail (return (\\<lambda>_. 0))\\<rbrakk>\n       \\<Longrightarrow> <emp> Array.new N\n                                0 <\\<lambda>r.\nemp *\n(\\<exists>\\<^sub>Ax.\n    is_nf N 0 x r * \\<up> (return x \\<le> return (\\<lambda>_. 0)))>\\<^sub>t", "by (sep_auto heap: nf_init_rule)"], ["", "lemma x_get_hnr[sepref_fr_rules]: \n  \"(uncurry Array.nth, uncurry (PR_CONST x_get)) \n  \\<in> x_assn\\<^sup>k *\\<^sub>a node_assn\\<^sup>k \\<rightarrow>\\<^sub>a cap_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry Array.nth, uncurry (PR_CONST x_get))\n    \\<in> x_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a cap_assn", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> int);\n        b ::\\<^sub>i TYPE(nat); nofail (PR_CONST x_get a b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          x_assn a\n                           ai> Array.nth ai\n                                bi <\\<lambda>r.\n \\<up> ((bi, b) \\<in> nat_rel) * x_assn a ai *\n (\\<exists>\\<^sub>Ax.\n     \\<up> ((r, x) \\<in> int_rel) *\n     \\<up> (return x \\<le> PR_CONST x_get a b))>\\<^sub>t", "unfolding x_assn_def x_get_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> int);\n        b ::\\<^sub>i TYPE(nat);\n        nofail\n         (PR_CONST\n           (\\<lambda>x u.\n               assert (u \\<in> V) \\<bind> (\\<lambda>_. return (x u)))\n           a b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          is_nf N 0 a\n                           ai> Array.nth ai\n                                bi <\\<lambda>r.\n \\<up> ((bi, b) \\<in> nat_rel) * is_nf N 0 a ai *\n (\\<exists>\\<^sub>Ax.\n     \\<up> ((r, x) \\<in> int_rel) *\n     \\<up>\n      (return x\n       \\<le> PR_CONST\n              (\\<lambda>x u.\n                  assert (u \\<in> V) \\<bind> (\\<lambda>_. return (x u)))\n              a b))>\\<^sub>t", "by (sep_auto simp: refine_pw_simps)"], ["", "definition (in -) \"x_add_impl x u \\<Delta> \\<equiv> do {\n  xu \\<leftarrow> Array.nth x u;\n  x \\<leftarrow> Array.upd u (xu+\\<Delta>) x;\n  return x\n}\""], ["", "lemma x_add_hnr[sepref_fr_rules]: \n  \"(uncurry2 x_add_impl, uncurry2 (PR_CONST x_add)) \n  \\<in> x_assn\\<^sup>d *\\<^sub>a node_assn\\<^sup>k *\\<^sub>a cap_assn\\<^sup>k \\<rightarrow>\\<^sub>a x_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 x_add_impl, uncurry2 (PR_CONST x_add))\n    \\<in> x_assn\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          cap_assn\\<^sup>k \\<rightarrow>\\<^sub>a x_assn", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi ba bia a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> int);\n        ba ::\\<^sub>i TYPE(nat); b ::\\<^sub>i TYPE(int);\n        nofail (PR_CONST x_add a ba b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> int_rel) *\n                          \\<up> ((bia, ba) \\<in> nat_rel) *\n                          x_assn a\n                           ai> x_add_impl ai bia\n                                bi <\\<lambda>r.\n \\<up> ((bi, b) \\<in> int_rel) * \\<up> ((bia, ba) \\<in> nat_rel) * true *\n (\\<exists>\\<^sub>Ax.\n     x_assn x r * \\<up> (return x \\<le> PR_CONST x_add a ba b))>\\<^sub>t", "unfolding x_assn_def x_add_impl_def x_add_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi ba bia a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> int);\n        ba ::\\<^sub>i TYPE(nat); b ::\\<^sub>i TYPE(int);\n        nofail\n         (PR_CONST\n           (\\<lambda>x u \\<Delta>.\n               assert (u \\<in> V) \\<bind>\n               (\\<lambda>_. return (x(u := x u + \\<Delta>))))\n           a ba b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> int_rel) *\n                          \\<up> ((bia, ba) \\<in> nat_rel) *\n                          is_nf N 0 a\n                           ai> Array.nth ai bia \\<bind>\n                               (\\<lambda>xu.\n                                   Array.upd bia (xu + bi) ai \\<bind>\n                                   return) <\\<lambda>r.\n         \\<up> ((bi, b) \\<in> int_rel) * \\<up> ((bia, ba) \\<in> nat_rel) *\n         true *\n         (\\<exists>\\<^sub>Ax.\n             is_nf N 0 x r *\n             \\<up>\n              (return x\n               \\<le> PR_CONST\n                      (\\<lambda>x u \\<Delta>.\n                          assert (u \\<in> V) \\<bind>\n                          (\\<lambda>_. return (x(u := x u + \\<Delta>))))\n                      a ba b))>\\<^sub>t", "by (sep_auto simp: refine_pw_simps)"], ["", "subsubsection \\<open>Labeling by Array\\<close>"], ["", "definition \"l_assn \\<equiv> is_nf N (0::nat)\""], ["", "definition (in -) \"l_init_impl N s cardV \\<equiv> do {\n  l \\<leftarrow> Array.new N (0::nat);\n  l \\<leftarrow> Array.upd s cardV l;\n  return l\n}\""], ["", "lemma l_init_hnr[sepref_fr_rules]: \n  \"(l_init_impl N s, (PR_CONST l_init)) \\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a l_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l_init_impl N s, PR_CONST l_init)\n    \\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a l_assn", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat); nofail (PR_CONST l_init x)\\<rbrakk>\n       \\<Longrightarrow> <\\<up>\n                           ((xi, x)\n                            \\<in> nat_rel)> l_init_impl N s\n       xi <\\<lambda>r.\n              \\<up> ((xi, x) \\<in> nat_rel) *\n              (\\<exists>\\<^sub>Axa.\n                  l_assn xa r *\n                  \\<up> (return xa \\<le> PR_CONST l_init x))>\\<^sub>t", "unfolding l_assn_def l_init_def l_init_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat);\n        nofail\n         (PR_CONST (\\<lambda>C. return ((\\<lambda>_. 0)(s := C)))\n           x)\\<rbrakk>\n       \\<Longrightarrow> <\\<up>\n                           ((xi, x)\n                            \\<in> nat_rel)> Array.new N 0 \\<bind>\n      (\\<lambda>l.\n          Array.upd s xi l \\<bind>\n          return) <\\<lambda>r.\n                      \\<up> ((xi, x) \\<in> nat_rel) *\n                      (\\<exists>\\<^sub>Axa.\n                          is_nf N 0 xa r *\n                          \\<up>\n                           (return xa\n                            \\<le> PR_CONST\n                                   (\\<lambda>C.\n return ((\\<lambda>_. 0)(s := C)))\n                                   x))>\\<^sub>t", "by (sep_auto heap: nf_init_rule)"], ["", "lemma l_get_hnr[sepref_fr_rules]: \n  \"(uncurry Array.nth, uncurry (PR_CONST l_get)) \n  \\<in> l_assn\\<^sup>k *\\<^sub>a node_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry Array.nth, uncurry (PR_CONST l_get))\n    \\<in> l_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> nat);\n        b ::\\<^sub>i TYPE(nat); nofail (PR_CONST l_get a b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          l_assn a\n                           ai> Array.nth ai\n                                bi <\\<lambda>r.\n \\<up> ((bi, b) \\<in> nat_rel) * l_assn a ai *\n (\\<exists>\\<^sub>Ax.\n     \\<up> ((r, x) \\<in> nat_rel) *\n     \\<up> (return x \\<le> PR_CONST l_get a b))>\\<^sub>t", "unfolding l_assn_def l_get_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> nat);\n        b ::\\<^sub>i TYPE(nat);\n        nofail\n         (PR_CONST\n           (\\<lambda>l u.\n               assert (u \\<in> V) \\<bind> (\\<lambda>_. return (l u)))\n           a b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          is_nf N 0 a\n                           ai> Array.nth ai\n                                bi <\\<lambda>r.\n \\<up> ((bi, b) \\<in> nat_rel) * is_nf N 0 a ai *\n (\\<exists>\\<^sub>Ax.\n     \\<up> ((r, x) \\<in> nat_rel) *\n     \\<up>\n      (return x\n       \\<le> PR_CONST\n              (\\<lambda>l u.\n                  assert (u \\<in> V) \\<bind> (\\<lambda>_. return (l u)))\n              a b))>\\<^sub>t", "by (sep_auto simp: refine_pw_simps)"], ["", "lemma l_get_rlx_hnr[sepref_fr_rules]: \n  \"(uncurry Array.nth, uncurry (PR_CONST l_get_rlx)) \n  \\<in> l_assn\\<^sup>k *\\<^sub>a node_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry Array.nth, uncurry (PR_CONST l_get_rlx))\n    \\<in> l_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> nat);\n        b ::\\<^sub>i TYPE(nat); nofail (PR_CONST l_get_rlx a b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          l_assn a\n                           ai> Array.nth ai\n                                bi <\\<lambda>r.\n \\<up> ((bi, b) \\<in> nat_rel) * l_assn a ai *\n (\\<exists>\\<^sub>Ax.\n     \\<up> ((r, x) \\<in> nat_rel) *\n     \\<up> (return x \\<le> PR_CONST l_get_rlx a b))>\\<^sub>t", "unfolding l_assn_def l_get_rlx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> nat);\n        b ::\\<^sub>i TYPE(nat);\n        nofail\n         (PR_CONST\n           (\\<lambda>l u. assert (u < N) \\<bind> (\\<lambda>_. return (l u)))\n           a b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          is_nf N 0 a\n                           ai> Array.nth ai\n                                bi <\\<lambda>r.\n \\<up> ((bi, b) \\<in> nat_rel) * is_nf N 0 a ai *\n (\\<exists>\\<^sub>Ax.\n     \\<up> ((r, x) \\<in> nat_rel) *\n     \\<up>\n      (return x\n       \\<le> PR_CONST\n              (\\<lambda>l u.\n                  assert (u < N) \\<bind> (\\<lambda>_. return (l u)))\n              a b))>\\<^sub>t", "by (sep_auto simp: refine_pw_simps)"], ["", "lemma l_set_hnr[sepref_fr_rules]: \n  \"(uncurry2 (\\<lambda>a i x. Array.upd i x a), uncurry2 (PR_CONST l_set)) \n  \\<in> l_assn\\<^sup>d *\\<^sub>a node_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a l_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (\\<lambda>a i x. Array.upd i x a), uncurry2 (PR_CONST l_set))\n    \\<in> l_assn\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a l_assn", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi ba bia a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> nat);\n        ba ::\\<^sub>i TYPE(nat); b ::\\<^sub>i TYPE(nat);\n        nofail (PR_CONST l_set a ba b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          \\<up> ((bia, ba) \\<in> nat_rel) *\n                          l_assn a\n                           ai> Array.upd bia bi\n                                ai <\\<lambda>r.\n \\<up> ((bi, b) \\<in> nat_rel) * \\<up> ((bia, ba) \\<in> nat_rel) * true *\n (\\<exists>\\<^sub>Ax.\n     l_assn x r * \\<up> (return x \\<le> PR_CONST l_set a ba b))>\\<^sub>t", "unfolding l_assn_def l_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi ba bia a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> nat);\n        ba ::\\<^sub>i TYPE(nat); b ::\\<^sub>i TYPE(nat);\n        nofail\n         (PR_CONST\n           (\\<lambda>l u a.\n               assert (u \\<in> V) \\<bind>\n               (\\<lambda>_.\n                   assert (a < 2 * card V) \\<bind>\n                   (\\<lambda>_. return (l(u := a)))))\n           a ba b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          \\<up> ((bia, ba) \\<in> nat_rel) *\n                          is_nf N 0 a\n                           ai> Array.upd bia bi\n                                ai <\\<lambda>r.\n \\<up> ((bi, b) \\<in> nat_rel) * \\<up> ((bia, ba) \\<in> nat_rel) * true *\n (\\<exists>\\<^sub>Ax.\n     is_nf N 0 x r *\n     \\<up>\n      (return x\n       \\<le> PR_CONST\n              (\\<lambda>l u a.\n                  assert (u \\<in> V) \\<bind>\n                  (\\<lambda>_.\n                      assert (a < 2 * card V) \\<bind>\n                      (\\<lambda>_. return (l(u := a)))))\n              a ba b))>\\<^sub>t", "by (sep_auto simp: refine_pw_simps split: prod.split)"], ["", "subsubsection \\<open>Label Frequency by Array\\<close>"], ["", "definition \"cnt_assn (f::node\\<Rightarrow>nat) a \n  \\<equiv> \\<exists>\\<^sub>Al. a\\<mapsto>\\<^sub>al * \\<up>(length l = 2*N \\<and> (\\<forall>i<2*N. l!i = f i) \\<and> (\\<forall>i\\<ge>2*N. f i = 0))\""], ["", "definition (in -) \"cnt_init_impl N C \\<equiv> do {\n  a \\<leftarrow> Array.new (2*N) (0::nat);\n  a \\<leftarrow> Array.upd 0 (C-1) a;\n  a \\<leftarrow> Array.upd C 1 a;\n  return a\n}\""], ["", "definition (in -) \"cnt_incr_impl a k \\<equiv> do {\n  freq \\<leftarrow> Array.nth a k;\n  a \\<leftarrow> Array.upd k (freq+1) a;\n  return a\n}\""], ["", "definition (in -) \"cnt_decr_impl a k \\<equiv> do {\n  freq \\<leftarrow> Array.nth a k;\n  a \\<leftarrow> Array.upd k (freq-1) a;\n  return a\n}\""], ["", "lemma cnt_init_hnr[sepref_fr_rules]: \"(cnt_init_impl N, PR_CONST cnt_init) \\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a cnt_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cnt_init_impl N, PR_CONST cnt_init)\n    \\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a cnt_assn", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat);\n        nofail (PR_CONST cnt_init x)\\<rbrakk>\n       \\<Longrightarrow> <\\<up>\n                           ((xi, x)\n                            \\<in> nat_rel)> cnt_init_impl N\n       xi <\\<lambda>r.\n              \\<up> ((xi, x) \\<in> nat_rel) *\n              (\\<exists>\\<^sub>Axa.\n                  cnt_assn xa r *\n                  \\<up> (return xa \\<le> PR_CONST cnt_init x))>\\<^sub>t", "unfolding cnt_init_def cnt_init_impl_def cnt_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat);\n        nofail\n         (PR_CONST\n           (\\<lambda>C.\n               assert (C < 2 * N) \\<bind>\n               (\\<lambda>_. return ((\\<lambda>_. 0)(0 := C - 1, C := 1))))\n           x)\\<rbrakk>\n       \\<Longrightarrow> <\\<up>\n                           ((xi, x)\n                            \\<in> nat_rel)> Array.new (2 * N) 0 \\<bind>\n      (\\<lambda>a.\n          Array.upd 0 (xi - 1) a \\<bind>\n          (\\<lambda>a.\n              Array.upd xi 1 a \\<bind>\n              return)) <\\<lambda>r.\n                           \\<up> ((xi, x) \\<in> nat_rel) *\n                           (\\<exists>\\<^sub>Axa.\n                               (\\<exists>\\<^sub>Al.\n                                   r \\<mapsto>\\<^sub>a l *\n                                   \\<up>\n                                    (length l = 2 * N \\<and>\n                                     (\\<forall>i<2 * N. l ! i = xa i) \\<and>\n                                     (\\<forall>i\\<ge>2 * N. xa i = 0))) *\n                               \\<up>\n                                (return xa\n                                 \\<le> PR_CONST\n  (\\<lambda>C.\n      assert (C < 2 * N) \\<bind>\n      (\\<lambda>_. return ((\\<lambda>_. 0)(0 := C - 1, C := 1))))\n  x))>\\<^sub>t", "by (sep_auto simp: refine_pw_simps)"], ["", "lemma cnt_get_hnr[sepref_fr_rules]: \"(uncurry Array.nth, uncurry (PR_CONST cnt_get)) \\<in> cnt_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry Array.nth, uncurry (PR_CONST cnt_get))\n    \\<in> cnt_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> nat);\n        b ::\\<^sub>i TYPE(nat); nofail (PR_CONST cnt_get a b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          cnt_assn a\n                           ai> Array.nth ai\n                                bi <\\<lambda>r.\n \\<up> ((bi, b) \\<in> nat_rel) * cnt_assn a ai *\n (\\<exists>\\<^sub>Ax.\n     \\<up> ((r, x) \\<in> nat_rel) *\n     \\<up> (return x \\<le> PR_CONST cnt_get a b))>\\<^sub>t", "unfolding cnt_get_def cnt_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> nat);\n        b ::\\<^sub>i TYPE(nat);\n        nofail\n         (PR_CONST\n           (\\<lambda>cnt lv.\n               assert (lv < 2 * N) \\<bind> (\\<lambda>_. return (cnt lv)))\n           a b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          (\\<exists>\\<^sub>Al.\n                              ai \\<mapsto>\\<^sub>a l *\n                              \\<up>\n                               (length l = 2 * N \\<and>\n                                (\\<forall>i<2 * N. l ! i = a i) \\<and>\n                                (\\<forall>i\\<ge>2 * N.\n                                    a i =\n                                    0)))> Array.nth ai\n     bi <\\<lambda>r.\n            \\<up> ((bi, b) \\<in> nat_rel) *\n            (\\<exists>\\<^sub>Al.\n                ai \\<mapsto>\\<^sub>a l *\n                \\<up>\n                 (length l = 2 * N \\<and>\n                  (\\<forall>i<2 * N. l ! i = a i) \\<and>\n                  (\\<forall>i\\<ge>2 * N. a i = 0))) *\n            (\\<exists>\\<^sub>Ax.\n                \\<up> ((r, x) \\<in> nat_rel) *\n                \\<up>\n                 (return x\n                  \\<le> PR_CONST\n                         (\\<lambda>cnt lv.\n                             assert (lv < 2 * N) \\<bind>\n                             (\\<lambda>_. return (cnt lv)))\n                         a b))>\\<^sub>t", "by (sep_auto simp: refine_pw_simps)"], ["", "lemma cnt_incr_hnr[sepref_fr_rules]: \"(uncurry cnt_incr_impl, uncurry (PR_CONST cnt_incr)) \\<in> cnt_assn\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a cnt_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry cnt_incr_impl, uncurry (PR_CONST cnt_incr))\n    \\<in> cnt_assn\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a cnt_assn", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> nat);\n        b ::\\<^sub>i TYPE(nat); nofail (PR_CONST cnt_incr a b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          cnt_assn a\n                           ai> cnt_incr_impl ai\n                                bi <\\<lambda>r.\n \\<up> ((bi, b) \\<in> nat_rel) * true *\n (\\<exists>\\<^sub>Ax.\n     cnt_assn x r * \\<up> (return x \\<le> PR_CONST cnt_incr a b))>\\<^sub>t", "unfolding cnt_incr_def cnt_incr_impl_def cnt_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> nat);\n        b ::\\<^sub>i TYPE(nat);\n        nofail\n         (PR_CONST\n           (\\<lambda>cnt lv.\n               assert (lv < 2 * N) \\<bind>\n               (\\<lambda>_. return (cnt(lv := cnt lv + 1))))\n           a b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          (\\<exists>\\<^sub>Al.\n                              ai \\<mapsto>\\<^sub>a l *\n                              \\<up>\n                               (length l = 2 * N \\<and>\n                                (\\<forall>i<2 * N. l ! i = a i) \\<and>\n                                (\\<forall>i\\<ge>2 * N.\n                                    a i =\n                                    0)))> Array.nth ai bi \\<bind>\n    (\\<lambda>freq.\n        Array.upd bi (freq + 1) ai \\<bind>\n        return) <\\<lambda>r.\n                    \\<up> ((bi, b) \\<in> nat_rel) * true *\n                    (\\<exists>\\<^sub>Ax.\n                        (\\<exists>\\<^sub>Al.\n                            r \\<mapsto>\\<^sub>a l *\n                            \\<up>\n                             (length l = 2 * N \\<and>\n                              (\\<forall>i<2 * N. l ! i = x i) \\<and>\n                              (\\<forall>i\\<ge>2 * N. x i = 0))) *\n                        \\<up>\n                         (return x\n                          \\<le> PR_CONST\n                                 (\\<lambda>cnt lv.\n                                     assert (lv < 2 * N) \\<bind>\n                                     (\\<lambda>_.\n   return (cnt(lv := cnt lv + 1))))\n                                 a b))>\\<^sub>t", "by (sep_auto simp: refine_pw_simps)"], ["", "lemma cnt_decr_hnr[sepref_fr_rules]: \"(uncurry cnt_decr_impl, uncurry (PR_CONST cnt_decr)) \\<in> cnt_assn\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a cnt_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry cnt_decr_impl, uncurry (PR_CONST cnt_decr))\n    \\<in> cnt_assn\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a cnt_assn", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> nat);\n        b ::\\<^sub>i TYPE(nat); nofail (PR_CONST cnt_decr a b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          cnt_assn a\n                           ai> cnt_decr_impl ai\n                                bi <\\<lambda>r.\n \\<up> ((bi, b) \\<in> nat_rel) * true *\n (\\<exists>\\<^sub>Ax.\n     cnt_assn x r * \\<up> (return x \\<le> PR_CONST cnt_decr a b))>\\<^sub>t", "unfolding cnt_decr_def cnt_decr_impl_def cnt_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> nat);\n        b ::\\<^sub>i TYPE(nat);\n        nofail\n         (PR_CONST\n           (\\<lambda>cnt lv.\n               assert (lv < 2 * N \\<and> 0 < cnt lv) \\<bind>\n               (\\<lambda>_. return (cnt(lv := cnt lv - 1))))\n           a b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          (\\<exists>\\<^sub>Al.\n                              ai \\<mapsto>\\<^sub>a l *\n                              \\<up>\n                               (length l = 2 * N \\<and>\n                                (\\<forall>i<2 * N. l ! i = a i) \\<and>\n                                (\\<forall>i\\<ge>2 * N.\n                                    a i =\n                                    0)))> Array.nth ai bi \\<bind>\n    (\\<lambda>freq.\n        Array.upd bi (freq - 1) ai \\<bind>\n        return) <\\<lambda>r.\n                    \\<up> ((bi, b) \\<in> nat_rel) * true *\n                    (\\<exists>\\<^sub>Ax.\n                        (\\<exists>\\<^sub>Al.\n                            r \\<mapsto>\\<^sub>a l *\n                            \\<up>\n                             (length l = 2 * N \\<and>\n                              (\\<forall>i<2 * N. l ! i = x i) \\<and>\n                              (\\<forall>i\\<ge>2 * N. x i = 0))) *\n                        \\<up>\n                         (return x\n                          \\<le> PR_CONST\n                                 (\\<lambda>cnt lv.\n                                     assert\n(lv < 2 * N \\<and> 0 < cnt lv) \\<bind>\n                                     (\\<lambda>_.\n   return (cnt(lv := cnt lv - 1))))\n                                 a b))>\\<^sub>t", "by (sep_auto simp: refine_pw_simps)"], ["", "subsubsection \\<open>Combined Frequency Count and Labeling\\<close>"], ["", "definition \"clc_assn \\<equiv> cnt_assn \\<times>\\<^sub>a l_assn\""], ["", "sepref_thm clc_init_impl is \"PR_CONST clc_init\" :: \"nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a clc_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, PR_CONST clc_init)\n    \\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a clc_assn", "unfolding clc_init_def PR_CONST_def clc_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>C.\n        l_init C \\<bind>\n        (\\<lambda>l. cnt_init C \\<bind> (\\<lambda>cnt. return (cnt, l))))\n    \\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a cnt_assn \\<times>\\<^sub>a\n           l_assn", "by sepref"], ["", "concrete_definition (in -) clc_init_impl \n  uses Network_Impl.clc_init_impl.refine_raw"], ["", "lemmas [sepref_fr_rules] = clc_init_impl.refine[OF Network_Impl_axioms]"], ["", "sepref_thm clc_get_impl is \"uncurry (PR_CONST clc_get)\" \n  :: \"clc_assn\\<^sup>k *\\<^sub>a node_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (PR_CONST clc_get))\n    \\<in> clc_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "unfolding clc_get_def PR_CONST_def clc_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (\\<lambda>(cnt, y). l_get y))\n    \\<in> (cnt_assn \\<times>\\<^sub>a l_assn)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref"], ["", "concrete_definition (in -) clc_get_impl \n  uses Network_Impl.clc_get_impl.refine_raw is \"(uncurry ?f,_)\\<in>_\""], ["", "lemmas [sepref_fr_rules] = clc_get_impl.refine[OF Network_Impl_axioms]"], ["", "sepref_thm clc_get_rlx_impl is \"uncurry (PR_CONST clc_get_rlx)\" \n  :: \"clc_assn\\<^sup>k *\\<^sub>a node_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (PR_CONST clc_get_rlx))\n    \\<in> clc_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "unfolding clc_get_rlx_def PR_CONST_def clc_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (\\<lambda>(cnt, y). l_get_rlx y))\n    \\<in> (cnt_assn \\<times>\\<^sub>a l_assn)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref"], ["", "concrete_definition (in -) clc_get_rlx_impl \n  uses Network_Impl.clc_get_rlx_impl.refine_raw is \"(uncurry ?f,_)\\<in>_\""], ["", "lemmas [sepref_fr_rules] = clc_get_rlx_impl.refine[OF Network_Impl_axioms]"], ["", "sepref_thm clc_set_impl is \"uncurry2 (PR_CONST clc_set)\" \n  :: \"clc_assn\\<^sup>d *\\<^sub>a node_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a clc_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 (PR_CONST clc_set))\n    \\<in> clc_assn\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a clc_assn", "unfolding clc_set_def PR_CONST_def clc_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>(cnt, l) u a.\n          assert (a < 2 * N) \\<bind>\n          (\\<lambda>_.\n              l_get l u \\<bind>\n              (\\<lambda>lu.\n                  cnt_decr cnt lu \\<bind>\n                  (\\<lambda>cnt.\n                      l_set l u a \\<bind>\n                      (\\<lambda>l.\n                          l_get l u \\<bind>\n                          (\\<lambda>lu.\n                              cnt_incr cnt lu \\<bind>\n                              (\\<lambda>cnt. return (cnt, l)))))))))\n    \\<in> (cnt_assn \\<times>\\<^sub>a l_assn)\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a cnt_assn \\<times>\\<^sub>a\n           l_assn", "by sepref"], ["", "concrete_definition (in -) clc_set_impl \n  uses Network_Impl.clc_set_impl.refine_raw is \"(uncurry2 ?f,_)\\<in>_\""], ["", "lemmas [sepref_fr_rules] = clc_set_impl.refine[OF Network_Impl_axioms]"], ["", "sepref_thm clc_has_gap_impl is \"uncurry (PR_CONST clc_has_gap)\" \n  :: \"clc_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (PR_CONST clc_has_gap))\n    \\<in> clc_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "unfolding clc_has_gap_def PR_CONST_def clc_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>(cnt, l) lu.\n          cnt_get cnt lu \\<bind> (\\<lambda>nlu. return (nlu = 0))))\n    \\<in> (cnt_assn \\<times>\\<^sub>a l_assn)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "by sepref"], ["", "concrete_definition (in -) clc_has_gap_impl \n  uses Network_Impl.clc_has_gap_impl.refine_raw is \"(uncurry ?f,_)\\<in>_\""], ["", "lemmas [sepref_fr_rules] = clc_has_gap_impl.refine[OF Network_Impl_axioms]"], ["", "subsubsection \\<open>Push\\<close>"], ["", "sepref_thm push_impl is \"uncurry2 (PR_CONST push2)\" \n  :: \"x_assn\\<^sup>d *\\<^sub>a cf_assn\\<^sup>d *\\<^sub>a edge_assn\\<^sup>k \\<rightarrow>\\<^sub>a (x_assn\\<times>\\<^sub>acf_assn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 (PR_CONST push2))\n    \\<in> x_assn\\<^sup>d *\\<^sub>a local.cf_assn\\<^sup>d *\\<^sub>a\n          edge_assn\\<^sup>k \\<rightarrow>\\<^sub>a x_assn \\<times>\\<^sub>a\n            local.cf_assn", "unfolding push2_def PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>x cf (u, v).\n          assert ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n          (\\<lambda>_.\n              x_get x u \\<bind>\n              (\\<lambda>xu.\n                  cf_get cf (u, v) \\<bind>\n                  (\\<lambda>cfuv.\n                      cf_get cf (v, u) \\<bind>\n                      (\\<lambda>cfvu.\n                          let \\<Delta> = min xu cfuv\n                          in x_add x u (- \\<Delta>) \\<bind>\n                             (\\<lambda>x.\n                                 x_add x v \\<Delta> \\<bind>\n                                 (\\<lambda>x.\n                                     cf_set cf (u, v)\n(cfuv - \\<Delta>) \\<bind>\n                                     (\\<lambda>cf.\n   cf_set cf (v, u) (cfvu + \\<Delta>) \\<bind>\n   (\\<lambda>cf. return (x, cf)))))))))))\n    \\<in> x_assn\\<^sup>d *\\<^sub>a local.cf_assn\\<^sup>d *\\<^sub>a\n          edge_assn\\<^sup>k \\<rightarrow>\\<^sub>a x_assn \\<times>\\<^sub>a\n            local.cf_assn", "by sepref"], ["", "concrete_definition (in -) push_impl \n  uses Network_Impl.push_impl.refine_raw is \"(uncurry2 ?f,_)\\<in>_\""], ["", "lemmas [sepref_fr_rules] = push_impl.refine[OF Network_Impl_axioms]"], ["", "subsubsection \\<open>Relabel\\<close>"], ["", "sepref_thm min_adj_label_impl is \"uncurry3 (PR_CONST min_adj_label)\" \n  :: \"am_assn\\<^sup>k *\\<^sub>a cf_assn\\<^sup>k *\\<^sub>a l_assn\\<^sup>k *\\<^sub>a node_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry ?f4), uncurry2 (uncurry (PR_CONST min_adj_label)))\n    \\<in> local.am_assn\\<^sup>k *\\<^sub>a local.cf_assn\\<^sup>k *\\<^sub>a\n          l_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "unfolding min_adj_label_def PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry ?f4),\n     uncurry2\n      (uncurry\n        (\\<lambda>am cf l u.\n            assert (u \\<in> V) \\<bind>\n            (\\<lambda>_.\n                am_get am u \\<bind>\n                (\\<lambda>adj.\n                    nfoldli adj (\\<lambda>_. True)\n                     (\\<lambda>v x.\n                         assert\n                          ((u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n                         (\\<lambda>_.\n                             assert (v \\<in> V) \\<bind>\n                             (\\<lambda>_.\n                                 cf_get cf (u, v) \\<bind>\n                                 (\\<lambda>cfuv.\n                                     if cfuv \\<noteq> 0\n                                     then l_get l v \\<bind>\n    (\\<lambda>lv.\n        case x of None \\<Rightarrow> return (Some lv)\n        | Some xx \\<Rightarrow> return (Some (min lv xx)))\n                                     else return x))))\n                     None \\<bind>\n                    (\\<lambda>x.\n                        assert (x \\<noteq> None) \\<bind>\n                        (\\<lambda>_. return (the x))))))))\n    \\<in> local.am_assn\\<^sup>k *\\<^sub>a local.cf_assn\\<^sup>k *\\<^sub>a\n          l_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref"], ["", "concrete_definition (in -) min_adj_label_impl \n  uses Network_Impl.min_adj_label_impl.refine_raw is \"(uncurry3 ?f,_)\\<in>_\""], ["", "lemmas [sepref_fr_rules] = min_adj_label_impl.refine[OF Network_Impl_axioms]"], ["", "sepref_thm relabel_impl is \"uncurry3 (PR_CONST relabel2)\" \n  :: \"am_assn\\<^sup>k *\\<^sub>a cf_assn\\<^sup>k *\\<^sub>a l_assn\\<^sup>d *\\<^sub>a node_assn\\<^sup>k \\<rightarrow>\\<^sub>a l_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry ?f4), uncurry2 (uncurry (PR_CONST relabel2)))\n    \\<in> local.am_assn\\<^sup>k *\\<^sub>a local.cf_assn\\<^sup>k *\\<^sub>a\n          l_assn\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a l_assn", "unfolding relabel2_def PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry ?f4),\n     uncurry2\n      (uncurry\n        (\\<lambda>am cf l u.\n            assert (u \\<in> V - {s, t}) \\<bind>\n            (\\<lambda>_.\n                min_adj_label am cf l u \\<bind>\n                (\\<lambda>nl. l_set l u (nl + 1) \\<bind> return)))))\n    \\<in> local.am_assn\\<^sup>k *\\<^sub>a local.cf_assn\\<^sup>k *\\<^sub>a\n          l_assn\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a l_assn", "by sepref"], ["", "concrete_definition (in -) relabel_impl \n  uses Network_Impl.relabel_impl.refine_raw is \"(uncurry3 ?f,_)\\<in>_\""], ["", "lemmas [sepref_fr_rules] = relabel_impl.refine[OF Network_Impl_axioms]"], ["", "subsubsection \\<open>Gap-Relabel\\<close>"], ["", "sepref_thm gap_impl is \"uncurry2 (PR_CONST gap2)\" \n  :: \"nat_assn\\<^sup>k *\\<^sub>a clc_assn\\<^sup>d *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a clc_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 (PR_CONST gap2))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a clc_assn\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a clc_assn", "unfolding gap2_def PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>C clc k.\n          nfoldli [0..<N] (\\<lambda>_. True)\n           (\\<lambda>v clc.\n               clc_get_rlx clc v \\<bind>\n               (\\<lambda>lv.\n                   if k < lv \\<and> lv < C\n                   then clc_set clc v (C + 1) \\<bind> return\n                   else return clc))\n           clc))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a clc_assn\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a clc_assn", "by sepref"], ["", "concrete_definition (in -) gap_impl \n  uses Network_Impl.gap_impl.refine_raw is \"(uncurry2 ?f,_)\\<in>_\""], ["", "lemmas [sepref_fr_rules] = gap_impl.refine[OF Network_Impl_axioms]"], ["", "sepref_thm min_adj_label_clc_impl is \"uncurry3 (PR_CONST min_adj_label_clc)\" \n  :: \"am_assn\\<^sup>k *\\<^sub>a cf_assn\\<^sup>k *\\<^sub>a clc_assn\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry ?f4),\n     uncurry2 (uncurry (PR_CONST min_adj_label_clc)))\n    \\<in> local.am_assn\\<^sup>k *\\<^sub>a local.cf_assn\\<^sup>k *\\<^sub>a\n          clc_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "unfolding min_adj_label_clc_def PR_CONST_def clc_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry ?f4),\n     uncurry2\n      (uncurry\n        (\\<lambda>am cf clc u.\n            case clc of (x, l) \\<Rightarrow> min_adj_label am cf l u)))\n    \\<in> local.am_assn\\<^sup>k *\\<^sub>a local.cf_assn\\<^sup>k *\\<^sub>a\n          (cnt_assn \\<times>\\<^sub>a l_assn)\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref"], ["", "concrete_definition (in -) min_adj_label_clc_impl \n  uses Network_Impl.min_adj_label_clc_impl.refine_raw is \"(uncurry3 ?f,_)\\<in>_\""], ["", "lemmas [sepref_fr_rules] = min_adj_label_clc_impl.refine[OF Network_Impl_axioms]"], ["", "sepref_thm clc_relabel_impl is \"uncurry3 (PR_CONST clc_relabel2)\" \n    :: \"am_assn\\<^sup>k *\\<^sub>a cf_assn\\<^sup>k *\\<^sub>a clc_assn\\<^sup>d *\\<^sub>a node_assn\\<^sup>k \\<rightarrow>\\<^sub>a clc_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry ?f4), uncurry2 (uncurry (PR_CONST clc_relabel2)))\n    \\<in> local.am_assn\\<^sup>k *\\<^sub>a local.cf_assn\\<^sup>k *\\<^sub>a\n          clc_assn\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a clc_assn", "unfolding clc_relabel2_def PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry ?f4),\n     uncurry2\n      (uncurry\n        (\\<lambda>am cf clc u.\n            assert (u \\<in> V - {s, t}) \\<bind>\n            (\\<lambda>_.\n                min_adj_label_clc am cf clc u \\<bind>\n                (\\<lambda>nl. clc_set clc u (nl + 1) \\<bind> return)))))\n    \\<in> local.am_assn\\<^sup>k *\\<^sub>a local.cf_assn\\<^sup>k *\\<^sub>a\n          clc_assn\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a clc_assn", "by sepref"], ["", "concrete_definition (in -) clc_relabel_impl \n  uses Network_Impl.clc_relabel_impl.refine_raw is \"(uncurry3 ?f,_)\\<in>_\""], ["", "lemmas [sepref_fr_rules] = clc_relabel_impl.refine[OF Network_Impl_axioms]"], ["", "sepref_thm gap_relabel_impl is \"uncurry4 (PR_CONST gap_relabel2)\" \n    :: \"nat_assn\\<^sup>k *\\<^sub>a am_assn\\<^sup>k *\\<^sub>a cf_assn\\<^sup>k *\\<^sub>a clc_assn\\<^sup>d *\\<^sub>a node_assn\\<^sup>k \n      \\<rightarrow>\\<^sub>a clc_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry2 ?f5), uncurry2 (uncurry2 (PR_CONST gap_relabel2)))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a local.am_assn\\<^sup>k *\\<^sub>a\n          local.cf_assn\\<^sup>k *\\<^sub>a\n          clc_assn\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a clc_assn", "unfolding gap_relabel2_def PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry2 ?f5),\n     uncurry2\n      (uncurry2\n        (\\<lambda>C am cf clc u.\n            clc_get clc u \\<bind>\n            (\\<lambda>lu.\n                clc_relabel2 am cf clc u \\<bind>\n                (\\<lambda>clc.\n                    clc_has_gap clc lu \\<bind>\n                    (\\<lambda>has_gap.\n                        if has_gap then gap2 C clc lu else return clc))))))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a local.am_assn\\<^sup>k *\\<^sub>a\n          local.cf_assn\\<^sup>k *\\<^sub>a\n          clc_assn\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a clc_assn", "by sepref"], ["", "concrete_definition (in -) gap_relabel_impl \n  uses Network_Impl.gap_relabel_impl.refine_raw is \"(uncurry4 ?f,_)\\<in>_\""], ["", "lemmas [sepref_fr_rules] = gap_relabel_impl.refine[OF Network_Impl_axioms]"], ["", "subsubsection \\<open>Initialization\\<close>"], ["", "sepref_thm pp_init_xcf2_impl is \"(PR_CONST pp_init_xcf2)\" \n    :: \"am_assn\\<^sup>k \\<rightarrow>\\<^sub>a x_assn \\<times>\\<^sub>a cf_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, PR_CONST pp_init_xcf2)\n    \\<in> local.am_assn\\<^sup>k \\<rightarrow>\\<^sub>a x_assn \\<times>\\<^sub>a\n                local.cf_assn", "unfolding pp_init_xcf2_def PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>am.\n        x_init \\<bind>\n        (\\<lambda>x.\n            cf_init \\<bind>\n            (\\<lambda>cf.\n                assert (s \\<in> V) \\<bind>\n                (\\<lambda>_.\n                    am_get am s \\<bind>\n                    (\\<lambda>adj.\n                        nfoldli adj (\\<lambda>_. True)\n                         (\\<lambda>v (x, cf).\n                             assert ((s, v) \\<in> E) \\<bind>\n                             (\\<lambda>_.\n                                 assert (s \\<noteq> v) \\<bind>\n                                 (\\<lambda>_.\n                                     cf_get cf (s, v) \\<bind>\n                                     (\\<lambda>a.\n   x_add x s (- a) \\<bind>\n   (\\<lambda>x.\n       x_add x v a \\<bind>\n       (\\<lambda>x.\n           cf_set cf (s, v) 0 \\<bind>\n           (\\<lambda>cf.\n               cf_set cf (v, s) a \\<bind>\n               (\\<lambda>cf. return (x, cf)))))))))\n                         (x, cf))))))\n    \\<in> local.am_assn\\<^sup>k \\<rightarrow>\\<^sub>a x_assn \\<times>\\<^sub>a\n                local.cf_assn", "by sepref"], ["", "concrete_definition (in -) pp_init_xcf2_impl \n  uses Network_Impl.pp_init_xcf2_impl.refine_raw is \"(?f,_)\\<in>_\""], ["", "lemmas [sepref_fr_rules] = pp_init_xcf2_impl.refine[OF Network_Impl_axioms]"], ["", "end \\<comment> \\<open>Network Implementation Locale\\<close>"], ["", "end"]]}