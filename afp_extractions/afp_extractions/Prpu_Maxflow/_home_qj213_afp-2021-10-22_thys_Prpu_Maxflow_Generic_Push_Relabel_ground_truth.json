{"file_name": "/home/qj213/afp-2021-10-22/thys/Prpu_Maxflow/Generic_Push_Relabel.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Prpu_Maxflow", "problem_names": ["lemma gen_valid: \"l(u) \\<le> l(x) + length p\" if \"cf.isPath u p x\"", "theorem no_augmenting_path: \"\\<not>isAugmentingPath p\"", "lemma augment_edge_zero[simp]: \"augment_edge f e 0 = f\"", "lemma augment_edge_same[simp]: \"e\\<in>E \\<Longrightarrow> augment_edge f e \\<Delta> e = f e + \\<Delta>\"", "lemma augment_edge_other[simp]:\"\\<lbrakk>e\\<in>E; e'\\<noteq>e \\<rbrakk> \\<Longrightarrow> augment_edge f e \\<Delta> e' = f e'\"", "lemma augment_edge_rev_same[simp]: \n  \"(v,u)\\<in>E \\<Longrightarrow> augment_edge f (u,v) \\<Delta> (v,u) = f (v,u) - \\<Delta>\"", "lemma augment_edge_rev_other[simp]: \n  \"\\<lbrakk>(u,v)\\<notin>E; e'\\<noteq>(v,u)\\<rbrakk> \\<Longrightarrow> augment_edge f (u,v) \\<Delta> e' = f e'\"", "lemma augment_edge_cf[simp]: \"(u,v)\\<in>E\\<union>E\\<inverse> \\<Longrightarrow> \n    cf_of (augment_edge f (u,v) \\<Delta>) \n  = (cf_of f)( (u,v) := cf_of f (u,v) - \\<Delta>, (v,u) := cf_of f (v,u) + \\<Delta>)\"", "lemma augment_edge_cf': \"(u,v)\\<in>cfE_of f \\<Longrightarrow> \n    cf_of (augment_edge f (u,v) \\<Delta>) \n  = (cf_of f)( (u,v) := cf_of f (u,v) - \\<Delta>, (v,u) := cf_of f (v,u) + \\<Delta>)\"", "lemma cf_of_augment_edge:\n  assumes A: \"(u,v)\\<in>cfE_of f\" \n  shows \"cf_of (augment_edge f (u,v) \\<Delta>) = augment_edge_cf (cf_of f) (u,v) \\<Delta>\"", "lemma cfE_augment_ss:\n  assumes EDGE: \"(u,v)\\<in>cfE_of f\"  \n  shows \"cfE_of (augment_edge f (u,v) \\<Delta>) \\<subseteq> insert (v,u) (cfE_of f)\"", "lemma augment_edge_preflow_preserve: \"\\<lbrakk>0\\<le>\\<Delta>; \\<Delta> \\<le> cf (u,v); \\<Delta> \\<le> excess f u\\<rbrakk> \n  \\<Longrightarrow> Preflow c s t (augment_edge f (u,v) \\<Delta>)\"", "lemma push_precondI[intro?]: \n  \"\\<lbrakk>excess f u > 0; (u,v)\\<in>cfE_of f; l u = l v + 1\\<rbrakk> \\<Longrightarrow> push_precond f l (u,v)\"", "lemma pp_init_invar: \"Labeling c s t pp_init_f pp_init_l\"", "lemma pp_init_f_preflow: \"NPreflow c s t pp_init_f\"", "theorem push_pres_Labeling:\n  assumes \"push_precond f l e\"\n  shows \"Labeling c s t (push_effect f e) l\"", "lemma finite_min_cf_outgoing[simp, intro!]: \"finite {l v |v. (u, v) \\<in> cf.E}\"", "theorem \n  assumes PRE: \"relabel_precond f l u\"\n  shows relabel_increase_u: \"relabel_effect f l u u > l u\" (is ?G1)\n    and relabel_pres_Labeling: \"Labeling c s t f (relabel_effect f l u)\" (is ?G2)", "lemma relabel_preserve_other: \"u\\<noteq>v \\<Longrightarrow> relabel_effect f l u v = l v\"", "theorem push_relabel_term_imp_maxflow:\n  assumes no_push: \"\\<forall>(u,v)\\<in>cf.E. \\<not>push_precond f l (u,v)\"\n  assumes no_relabel: \"\\<forall>u. \\<not>relabel_precond f l u\"\n  shows \"isMaxFlow f\"", "lemma uv_cf_edge[simp, intro!]: \"(u,v)\\<in>cf.E\"", "lemma excess_u_pos: \"excess f u > 0\"", "lemma l_u_eq[simp]: \"l u = l v + 1\"", "lemma uv_edge_cases:\n    obtains (par) \"(u,v)\\<in>E\" \"(v,u)\\<notin>E\" \n          | (rev) \"(v,u)\\<in>E\" \"(u,v)\\<notin>E\"", "lemma uv_nodes[simp, intro!]: \"u\\<in>V\" \"v\\<in>V\"", "lemma uv_not_eq[simp]: \"u\\<noteq>v\" \"v\\<noteq>u\"", "lemma \\<Delta>_positive: \"\\<Delta> > 0\"", "lemma f'_alt: \"f' = augment_edge f (u,v) \\<Delta>\"", "lemma cf'_alt: \"l'.cf = augment_edge_cf cf (u,v) \\<Delta>\"", "lemma excess'_u[simp]: \"excess f' u = excess f u - \\<Delta>\"", "lemma excess'_v[simp]: \"excess f' v = excess f v + \\<Delta>\"", "lemma excess'_other[simp]:\n    assumes \"x \\<noteq> u\" \"x \\<noteq> v\"  \n    shows \"excess f' x = excess f x\"", "lemma excess'_if: \n    \"excess f' x = (\n           if x=u then excess f u - \\<Delta> \n      else if x=v then excess f v + \\<Delta> \n         else excess f x)\"", "lemma cardE_nz_aux[simp, intro!]:\n  \"card E \\<noteq> 0\" \"card E \\<ge> Suc 0\" \"card E > 0\"", "lemma card_V_est_E: \"card V \\<le> 2 * card E\"", "lemma height_bound': \"u\\<in>V \\<Longrightarrow> l u \\<le> 2*card V - 1\"", "lemma (in Network) pp_init_height_bound: \n  \"Height_Bounded_Labeling c s t pp_init_f pp_init_l\"", "lemma push_pres_height_bound:\n  assumes \"push_precond f l e\"\n  shows \"Height_Bounded_Labeling c s t (push_effect f e) l\"", "lemma (in Labeling) excess_imp_source_path: \n  assumes \"excess f u > 0\"\n  obtains p where \"cf.isSimplePath u p s\"", "lemma relabel_pres_height_bound:\n  assumes \"relabel_precond f l u\"\n  shows \"Height_Bounded_Labeling c s t f (relabel_effect f l u)\"", "lemma (in Network) sum_height_measure_is_OV2: \n  \"sum_heights_measure l \\<le> 2*(card V)\\<^sup>2\"", "lemma (in Height_Bounded_Labeling) pr_algo_maintains_hb_labeling:\n  assumes \"((f,l),a,(f',l')) \\<in> pr_algo_lts\"\n  shows \"Height_Bounded_Labeling c s t f' l'\"", "lemma (in Height_Bounded_Labeling) pr_algo_term_maxflow:\n  assumes \"(f,l)\\<notin>Domain pr_algo_lts\"\n  shows \"isMaxFlow f\"", "lemma push_precond_eq_sat_or_nonsat: \n  \"push_precond f l e \\<longleftrightarrow> sat_push_precond f l e \\<or> nonsat_push_precond f l e\"", "lemma sat_nonsat_push_disj: \n  \"sat_push_precond f l e \\<Longrightarrow> \\<not>nonsat_push_precond f l e\"\n  \"nonsat_push_precond f l e \\<Longrightarrow> \\<not>sat_push_precond f l e\"", "lemma sat_push_alt: \"sat_push_precond f l e \n  \\<Longrightarrow> push_effect f e = augment_edge f e (cf_of f e)\"", "lemma nonsat_push_alt: \"nonsat_push_precond f l (u,v) \n  \\<Longrightarrow> push_effect f (u,v) = augment_edge f (u,v) (excess f u)\"", "lemma nonsat_push_\\<Delta>: \"nonsat_push_precond f l (u,v) \\<Longrightarrow> \\<Delta> = excess f u\"", "lemma sat_push_\\<Delta>: \"sat_push_precond f l (u,v) \\<Longrightarrow> \\<Delta> = cf (u,v)\"", "lemma is_RELABEL_project_conv[simp]: \n  \"is_RELABEL \\<circ> project_operation = is_RELABEL'\"", "lemma is_PUSH_project_conv[simp]: \n  \"is_PUSH \\<circ> project_operation = (\\<lambda>x. is_SAT_PUSH' x \\<or> is_NONSAT_PUSH' x)\"", "lemma (in Height_Bounded_Labeling) xfer_run:\n  assumes \"((f,l),p,(f',l')) \\<in> trcl pr_algo_lts\"\n  obtains p' where \"((f,l),p',(f',l')) \\<in> trcl pr_algo_lts'\" \n               and \"p = map project_operation p'\"", "lemma xfer_relabel_bound:\n  assumes BOUND: \"\\<forall>p'. ((f,l),p',(f',l')) \\<in> trcl pr_algo_lts' \n          \\<longrightarrow> length (filter is_RELABEL' p') \\<le> B\"\n  assumes RUN: \"((f,l),p,(f',l')) \\<in> trcl pr_algo_lts\"\n  shows \"length (filter is_RELABEL p) \\<le> B\"", "lemma xfer_push_bounds:\n  assumes BOUND_SAT: \"\\<forall>p'. ((f,l),p',(f',l')) \\<in> trcl pr_algo_lts' \n          \\<longrightarrow> length (filter is_SAT_PUSH' p') \\<le> B1\"\n  assumes BOUND_NONSAT: \"\\<forall>p'. ((f,l),p',(f',l')) \\<in> trcl pr_algo_lts' \n          \\<longrightarrow> length (filter is_NONSAT_PUSH' p') \\<le> B2\"\n  assumes RUN: \"((f,l),p,(f',l')) \\<in> trcl pr_algo_lts\"\n  shows \"length (filter is_PUSH p) \\<le> B1 + B2\"", "lemma (in Network) relabel_action_bound':\n  assumes A: \"(fxl,p,fxl') \\<in> trcl pr_algo_lts'\"\n  shows \"length (filter (is_RELABEL') p) \\<le> 2 * (card V)\\<^sup>2\"", "lemma (in Height_Bounded_Labeling) relabel_action_bound:\n  assumes A: \"((f,l),p,(f',l')) \\<in> trcl pr_algo_lts\"\n  shows \"length (filter (is_RELABEL) p) \\<le> 2 * (card V)\\<^sup>2\"", "lemma labels_path_increasing:\n  assumes \"((f,l),p,(f',l')) \\<in> trcl pr_algo_lts'\"\n  shows \"l u \\<le> l' u\"", "lemma edge_reappears_at_increased_labeling:\n  assumes \"((f,l),p,(f',l')) \\<in> trcl pr_algo_lts'\"\n  assumes \"l u \\<ge> l v + 1\"\n  assumes \"(u,v) \\<notin> cfE_of f\"  \n  assumes E': \"(u,v) \\<in> cfE_of f'\"\n  shows \"l v < l' v\"", "lemma sat_push_edge_action_bound':\n  assumes \"((f,l),p,(f',l')) \\<in> trcl pr_algo_lts'\" \n  shows \"length (filter ((=) (SAT_PUSH' e)) p) \\<le> 2*card V\"", "lemma sat_push_action_bound':\n  assumes A: \"((f,l),p,(f',l')) \\<in> trcl pr_algo_lts'\"\n  shows \"length (filter is_SAT_PUSH' p) \\<le> 4 * card V * card E\"", "lemma nonsat_potential_bound:\n  shows \"nonsat_potential f l \\<le> 2 * (card V)^2\"", "lemma nonsat_push_decr_nonsat_potential:\n  assumes \"nonsat_push_precond f l e\"\n  shows \"nonsat_potential (push_effect f e) l < nonsat_potential f l\"", "lemma sat_push_nonsat_potential:\n  assumes PRE: \"sat_push_precond f l e\"\n  shows \"nonsat_potential (push_effect f e) l \n      \\<le> nonsat_potential f l + 2 * card V\"", "lemma relabel_nonsat_potential:\n  assumes PRE: \"relabel_precond f l u\"\n  shows \"nonsat_potential f (relabel_effect f l u) \n       \\<le> nonsat_potential f l + 2 * card V\"", "lemma nonsat_push_action_bound':\n  assumes A: \"((f,l),p,(f',l')) \\<in> trcl pr_algo_lts'\"\n  shows \"length (filter is_NONSAT_PUSH' p) \\<le> 18 * (card V)\\<^sup>2 * card E\"", "lemma (in Height_Bounded_Labeling) push_action_bound:\n  assumes A: \"((f,l),p,(f',l')) \\<in> trcl pr_algo_lts\"\n  shows \"length (filter (is_PUSH) p) \\<le> 22 * (card V)\\<^sup>2 * card E\"", "theorem (in Height_Bounded_Labeling) pr_algo_cost_bound:  \n  assumes A: \"((f,l),p,(f',l')) \\<in> trcl pr_algo_lts\"\n  shows \"(\\<Sum>a\\<leftarrow>p. cost_estimate a) \\<le> 26 * (card V)^2 * card E\"", "theorem (in Network) generic_preflow_push_OV2E_and_correct:\n  assumes A: \"((pp_init_f, pp_init_l), p, (f, l)) \\<in> trcl pr_algo_lts\" \n  shows \"(\\<Sum>x\\<leftarrow>p. cost_estimate x) \\<le> 26 * (card V)^2 * card E\" (is ?G1)\n    and \"(f,l)\\<notin>Domain pr_algo_lts \\<longrightarrow> isMaxFlow f\" (is ?G2)", "lemma pr_algo_rel_alt: \"pr_algo_rel = \n    { ((push_effect f e,l),(f,l)) | f e l. \n        Height_Bounded_Labeling c s t f l \\<and> push_precond f l e }\n  \\<union> { ((f, relabel_effect f l u), (f,l)) | f u l. \n        Height_Bounded_Labeling c s t f l \\<and> relabel_precond f l u }\"", "lemma (in Height_Bounded_Labeling) pr_algo_lts_length_bound:  \n  assumes A: \"((f, l), p, (f', l')) \\<in> trcl pr_algo_lts\"\n  shows \"length p \\<le> pr_algo_len_bound\"", "lemma (in Height_Bounded_Labeling) path_set_finite:  \n  \"finite {p. \\<exists>f' l'. ((f,l),p,(f',l')) \\<in> trcl pr_algo_lts}\"", "lemma pr_algo_measure: \n  assumes \"(fl',fl) \\<in> pr_algo_rel\"  \n  shows \"pr_algo_measure fl' < pr_algo_measure fl\"", "lemma wf_pr_algo_rel[simp, intro!]: \"wf pr_algo_rel\"", "lemma (in Labeling) gap_pres_Labeling:\n  assumes PRE: \"gap_precond l k\"\n  defines \"l' \\<equiv> gap_effect l k\"\n  shows \"Labeling c s t f l'\"", "lemma (in Height_Bounded_Labeling) gap_pres_hb_labeling:\n  assumes PRE: \"gap_precond l k\"\n  defines \"l' \\<equiv> gap_effect l k\"\n  shows \"Height_Bounded_Labeling c s t f l'\"", "lemma (in Labeling) gap_relabel_pres_Labeling:\n  assumes PRE: \"relabel_precond f l u\"\n  defines \"l' \\<equiv> gap_relabel_effect f l u\"\n  shows \"Labeling c s t f l'\"", "lemma (in Height_Bounded_Labeling) gap_relabel_pres_hb_labeling:\n  assumes PRE: \"relabel_precond f l u\"\n  defines \"l' \\<equiv> gap_relabel_effect f l u\"\n  shows \"Height_Bounded_Labeling c s t f l'\"", "lemma (in Height_Bounded_Labeling) gap_measure:\n  assumes \"gap_precond l k\"\n  shows \"sum_heights_measure (gap_effect l k) \\<le> sum_heights_measure l\"", "lemma (in Height_Bounded_Labeling) gap_relabel_measure:\n  assumes PRE: \"relabel_precond f l u\"\n  shows \"sum_heights_measure (gap_relabel_effect f l u) < sum_heights_measure l\"", "lemma wf_gap_algo_rel[simp, intro!]: \"wf gap_algo_rel\""], "translations": [["", "lemma gen_valid: \"l(u) \\<le> l(x) + length p\" if \"cf.isPath u p x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l u \\<le> l x + length p", "using that"], ["proof (prove)\nusing this:\n  cf.isPath u p x\n\ngoal (1 subgoal):\n 1. l u \\<le> l x + length p", "by (induction p arbitrary: u; fastforce dest: valid)"], ["", "text \\<open>\n  In a valid labeling, there cannot be an augmenting path~\\cormen{26.17}.\n\n  The proof works by contradiction, using the validity constraint \n  to show that any augmenting path would be too long for a simple path.\n\\<close>"], ["", "theorem no_augmenting_path: \"\\<not>isAugmentingPath p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> isAugmentingPath p", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. isAugmentingPath p \\<Longrightarrow> False", "assume \"isAugmentingPath p\""], ["proof (state)\nthis:\n  isAugmentingPath p\n\ngoal (1 subgoal):\n 1. isAugmentingPath p \\<Longrightarrow> False", "hence SP: \"cf.isSimplePath s p t\""], ["proof (prove)\nusing this:\n  isAugmentingPath p\n\ngoal (1 subgoal):\n 1. cf.isSimplePath s p t", "unfolding isAugmentingPath_def"], ["proof (prove)\nusing this:\n  cf.isSimplePath s p t\n\ngoal (1 subgoal):\n 1. cf.isSimplePath s p t", "."], ["proof (state)\nthis:\n  cf.isSimplePath s p t\n\ngoal (1 subgoal):\n 1. isAugmentingPath p \\<Longrightarrow> False", "hence \"cf.isPath s p t\""], ["proof (prove)\nusing this:\n  cf.isSimplePath s p t\n\ngoal (1 subgoal):\n 1. cf.isPath s p t", "unfolding cf.isSimplePath_def"], ["proof (prove)\nusing this:\n  cf.isPath s p t \\<and> distinct (cf.pathVertices s p)\n\ngoal (1 subgoal):\n 1. cf.isPath s p t", "by auto"], ["proof (state)\nthis:\n  cf.isPath s p t\n\ngoal (1 subgoal):\n 1. isAugmentingPath p \\<Longrightarrow> False", "from gen_valid[OF this]"], ["proof (chain)\npicking this:\n  l s \\<le> l t + length p", "have \"length p \\<ge> card V\""], ["proof (prove)\nusing this:\n  l s \\<le> l t + length p\n\ngoal (1 subgoal):\n 1. card V \\<le> length p", "by auto"], ["proof (state)\nthis:\n  card V \\<le> length p\n\ngoal (1 subgoal):\n 1. isAugmentingPath p \\<Longrightarrow> False", "with cf.simplePath_length_less_V[OF _ SP]"], ["proof (chain)\npicking this:\n  s \\<in> cf.V \\<Longrightarrow> length p < card cf.V\n  card V \\<le> length p", "show False"], ["proof (prove)\nusing this:\n  s \\<in> cf.V \\<Longrightarrow> length p < card cf.V\n  card V \\<le> length p\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The idea of push relabel algorithms is to maintain a valid labeling,\n  and, ultimately, arrive at a valid flow, i.e., no nodes have excess flow. \n  We then immediately get that the flow is maximal:\n\\<close>"], ["", "corollary no_excess_imp_maxflow:    \n  assumes \"\\<forall>u\\<in>V-{s,t}. excess f u = 0\"\n  shows \"isMaxFlow f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isMaxFlow f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. isMaxFlow f", "from assms"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>V - {s, t}. excess f u = (0::'a)", "interpret NFlow"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>V - {s, t}. excess f u = (0::'a)\n\ngoal (1 subgoal):\n 1. NFlow c s t f", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>V - {s, t}. excess f u = (0::'a) \\<Longrightarrow>\n    \\<forall>v\\<in>V - {s, t}. sum f (incoming v) \\<le> sum f (outgoing v)", "using no_deficient_nodes"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V - {s, t}. sum f (outgoing v) \\<le> sum f (incoming v)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>V - {s, t}. excess f u = (0::'a) \\<Longrightarrow>\n    \\<forall>v\\<in>V - {s, t}. sum f (incoming v) \\<le> sum f (outgoing v)", "unfolding excess_def"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V - {s, t}. sum f (outgoing v) \\<le> sum f (incoming v)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>V - {s, t}.\n       sum f (incoming u) - sum f (outgoing u) = (0::'a) \\<Longrightarrow>\n    \\<forall>v\\<in>V - {s, t}. sum f (incoming v) \\<le> sum f (outgoing v)", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. isMaxFlow f", "from noAugPath_iff_maxFlow no_augmenting_path"], ["proof (chain)\npicking this:\n  (\\<not> Ex isAugmentingPath) = isMaxFlow f\n  \\<not> isAugmentingPath ?p", "show \"isMaxFlow f\""], ["proof (prove)\nusing this:\n  (\\<not> Ex isAugmentingPath) = isMaxFlow f\n  \\<not> isAugmentingPath ?p\n\ngoal (1 subgoal):\n 1. isMaxFlow f", "by auto"], ["proof (state)\nthis:\n  isMaxFlow f\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>Labeling\\<close>"], ["", "subsection \\<open>Basic Operations\\<close>"], ["", "text \\<open>\n  The operations of the push relabel algorithm are local operations on \n  single nodes and edges.  \n\\<close>"], ["", "subsubsection \\<open>Augmentation of Edges\\<close>"], ["", "context Network\nbegin"], ["", "text \\<open>We define a function to augment a single edge in the residual graph.\\<close>"], ["", "definition augment_edge :: \"'capacity flow \\<Rightarrow> _\" \n  where \"augment_edge f \\<equiv> \\<lambda>(u,v) \\<Delta>. \n    if (u,v)\\<in>E then f( (u,v) := f (u,v) + \\<Delta> )\n    else if (v,u)\\<in>E then f( (v,u) := f (v,u) - \\<Delta> )\n    else f\""], ["", "lemma augment_edge_zero[simp]: \"augment_edge f e 0 = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. augment_edge f e (0::'capacity) = f", "unfolding augment_edge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case e of\n     (u, v) \\<Rightarrow>\n       \\<lambda>\\<Delta>.\n          if (u, v) \\<in> E then f((u, v) := f (u, v) + \\<Delta>)\n          else if (v, u) \\<in> E then f((v, u) := f (v, u) - \\<Delta>)\n               else f)\n     (0::'capacity) =\n    f", "by (auto split: prod.split)"], ["", "lemma augment_edge_same[simp]: \"e\\<in>E \\<Longrightarrow> augment_edge f e \\<Delta> e = f e + \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> E \\<Longrightarrow> augment_edge f e \\<Delta> e = f e + \\<Delta>", "unfolding augment_edge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> E \\<Longrightarrow>\n    (case e of\n     (u, v) \\<Rightarrow>\n       \\<lambda>\\<Delta>.\n          if (u, v) \\<in> E then f((u, v) := f (u, v) + \\<Delta>)\n          else if (v, u) \\<in> E then f((v, u) := f (v, u) - \\<Delta>)\n               else f)\n     \\<Delta> e =\n    f e + \\<Delta>", "by (auto split!: prod.splits)"], ["", "lemma augment_edge_other[simp]:\"\\<lbrakk>e\\<in>E; e'\\<noteq>e \\<rbrakk> \\<Longrightarrow> augment_edge f e \\<Delta> e' = f e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> E; e' \\<noteq> e\\<rbrakk>\n    \\<Longrightarrow> augment_edge f e \\<Delta> e' = f e'", "unfolding augment_edge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> E; e' \\<noteq> e\\<rbrakk>\n    \\<Longrightarrow> (case e of\n                       (u, v) \\<Rightarrow>\n                         \\<lambda>\\<Delta>.\n                            if (u, v) \\<in> E\n                            then f((u, v) := f (u, v) + \\<Delta>)\n                            else if (v, u) \\<in> E\n                                 then f((v, u) := f (v, u) - \\<Delta>)\n                                 else f)\n                       \\<Delta> e' =\n                      f e'", "by (auto split!: prod.splits)"], ["", "lemma augment_edge_rev_same[simp]: \n  \"(v,u)\\<in>E \\<Longrightarrow> augment_edge f (u,v) \\<Delta> (v,u) = f (v,u) - \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, u) \\<in> E \\<Longrightarrow>\n    augment_edge f (u, v) \\<Delta> (v, u) = f (v, u) - \\<Delta>", "using no_parallel_edge"], ["proof (prove)\nusing this:\n  \\<forall>u v. (u, v) \\<in> E \\<longrightarrow> (v, u) \\<notin> E\n\ngoal (1 subgoal):\n 1. (v, u) \\<in> E \\<Longrightarrow>\n    augment_edge f (u, v) \\<Delta> (v, u) = f (v, u) - \\<Delta>", "unfolding augment_edge_def"], ["proof (prove)\nusing this:\n  \\<forall>u v. (u, v) \\<in> E \\<longrightarrow> (v, u) \\<notin> E\n\ngoal (1 subgoal):\n 1. (v, u) \\<in> E \\<Longrightarrow>\n    (case (u, v) of\n     (u, v) \\<Rightarrow>\n       \\<lambda>\\<Delta>.\n          if (u, v) \\<in> E then f((u, v) := f (u, v) + \\<Delta>)\n          else if (v, u) \\<in> E then f((v, u) := f (v, u) - \\<Delta>)\n               else f)\n     \\<Delta> (v, u) =\n    f (v, u) - \\<Delta>", "by (auto split!: prod.splits)"], ["", "lemma augment_edge_rev_other[simp]: \n  \"\\<lbrakk>(u,v)\\<notin>E; e'\\<noteq>(v,u)\\<rbrakk> \\<Longrightarrow> augment_edge f (u,v) \\<Delta> e' = f e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, v) \\<notin> E; e' \\<noteq> (v, u)\\<rbrakk>\n    \\<Longrightarrow> augment_edge f (u, v) \\<Delta> e' = f e'", "unfolding augment_edge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, v) \\<notin> E; e' \\<noteq> (v, u)\\<rbrakk>\n    \\<Longrightarrow> (case (u, v) of\n                       (u, v) \\<Rightarrow>\n                         \\<lambda>\\<Delta>.\n                            if (u, v) \\<in> E\n                            then f((u, v) := f (u, v) + \\<Delta>)\n                            else if (v, u) \\<in> E\n                                 then f((v, u) := f (v, u) - \\<Delta>)\n                                 else f)\n                       \\<Delta> e' =\n                      f e'", "by (auto split!: prod.splits)"], ["", "lemma augment_edge_cf[simp]: \"(u,v)\\<in>E\\<union>E\\<inverse> \\<Longrightarrow> \n    cf_of (augment_edge f (u,v) \\<Delta>) \n  = (cf_of f)( (u,v) := cf_of f (u,v) - \\<Delta>, (v,u) := cf_of f (v,u) + \\<Delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> E \\<union> E\\<inverse> \\<Longrightarrow>\n    cf_of (augment_edge f (u, v) \\<Delta>) = (cf_of f)\n    ((u, v) := cf_of f (u, v) - \\<Delta>,\n     (v, u) := cf_of f (v, u) + \\<Delta>)", "apply (intro ext; cases \"(u,v)\\<in>E\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>(u, v) \\<in> E \\<union> E\\<inverse>; (u, v) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> cf_of (augment_edge f (u, v) \\<Delta>) x =\n                         ((cf_of f)\n                          ((u, v) := cf_of f (u, v) - \\<Delta>,\n                           (v, u) := cf_of f (v, u) + \\<Delta>))\n                          x\n 2. \\<And>x.\n       \\<lbrakk>(u, v) \\<in> E \\<union> E\\<inverse>;\n        (u, v) \\<notin> E\\<rbrakk>\n       \\<Longrightarrow> cf_of (augment_edge f (u, v) \\<Delta>) x =\n                         ((cf_of f)\n                          ((u, v) := cf_of f (u, v) - \\<Delta>,\n                           (v, u) := cf_of f (v, u) + \\<Delta>))\n                          x", "subgoal for e'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, v) \\<in> E \\<union> E\\<inverse>; (u, v) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> cf_of (augment_edge f (u, v) \\<Delta>) e' =\n                      ((cf_of f)\n                       ((u, v) := cf_of f (u, v) - \\<Delta>,\n                        (v, u) := cf_of f (v, u) + \\<Delta>))\n                       e'", "apply (cases \"e'=(u,v)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(u, v) \\<in> E \\<union> E\\<inverse>; (u, v) \\<in> E;\n     e' = (u, v)\\<rbrakk>\n    \\<Longrightarrow> cf_of (augment_edge f (u, v) \\<Delta>) e' =\n                      ((cf_of f)\n                       ((u, v) := cf_of f (u, v) - \\<Delta>,\n                        (v, u) := cf_of f (v, u) + \\<Delta>))\n                       e'\n 2. \\<lbrakk>(u, v) \\<in> E \\<union> E\\<inverse>; (u, v) \\<in> E;\n     e' \\<noteq> (u, v)\\<rbrakk>\n    \\<Longrightarrow> cf_of (augment_edge f (u, v) \\<Delta>) e' =\n                      ((cf_of f)\n                       ((u, v) := cf_of f (u, v) - \\<Delta>,\n                        (v, u) := cf_of f (v, u) + \\<Delta>))\n                       e'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, v) \\<in> E \\<union> E\\<inverse>; (u, v) \\<in> E;\n     e' = (u, v)\\<rbrakk>\n    \\<Longrightarrow> cf_of (augment_edge f (u, v) \\<Delta>) e' =\n                      ((cf_of f)\n                       ((u, v) := cf_of f (u, v) - \\<Delta>,\n                        (v, u) := cf_of f (v, u) + \\<Delta>))\n                       e'", "by (simp split!: if_splits add: no_self_loop residualGraph_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, v) \\<in> E \\<union> E\\<inverse>; (u, v) \\<in> E;\n     e' \\<noteq> (u, v)\\<rbrakk>\n    \\<Longrightarrow> cf_of (augment_edge f (u, v) \\<Delta>) e' =\n                      ((cf_of f)\n                       ((u, v) := cf_of f (u, v) - \\<Delta>,\n                        (v, u) := cf_of f (v, u) + \\<Delta>))\n                       e'", "apply (cases \"e'=(v,u)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(u, v) \\<in> E \\<union> E\\<inverse>; (u, v) \\<in> E;\n     e' \\<noteq> (u, v); e' = (v, u)\\<rbrakk>\n    \\<Longrightarrow> cf_of (augment_edge f (u, v) \\<Delta>) e' =\n                      ((cf_of f)\n                       ((u, v) := cf_of f (u, v) - \\<Delta>,\n                        (v, u) := cf_of f (v, u) + \\<Delta>))\n                       e'\n 2. \\<lbrakk>(u, v) \\<in> E \\<union> E\\<inverse>; (u, v) \\<in> E;\n     e' \\<noteq> (u, v); e' \\<noteq> (v, u)\\<rbrakk>\n    \\<Longrightarrow> cf_of (augment_edge f (u, v) \\<Delta>) e' =\n                      ((cf_of f)\n                       ((u, v) := cf_of f (u, v) - \\<Delta>,\n                        (v, u) := cf_of f (v, u) + \\<Delta>))\n                       e'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, v) \\<in> E \\<union> E\\<inverse>; (u, v) \\<in> E;\n     e' \\<noteq> (u, v); e' = (v, u)\\<rbrakk>\n    \\<Longrightarrow> cf_of (augment_edge f (u, v) \\<Delta>) e' =\n                      ((cf_of f)\n                       ((u, v) := cf_of f (u, v) - \\<Delta>,\n                        (v, u) := cf_of f (v, u) + \\<Delta>))\n                       e'", "by (simp split!: if_splits add: no_parallel_edge residualGraph_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, v) \\<in> E \\<union> E\\<inverse>; (u, v) \\<in> E;\n     e' \\<noteq> (u, v); e' \\<noteq> (v, u)\\<rbrakk>\n    \\<Longrightarrow> cf_of (augment_edge f (u, v) \\<Delta>) e' =\n                      ((cf_of f)\n                       ((u, v) := cf_of f (u, v) - \\<Delta>,\n                        (v, u) := cf_of f (v, u) + \\<Delta>))\n                       e'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, v) \\<in> E \\<union> E\\<inverse>; (u, v) \\<in> E;\n     e' \\<noteq> (u, v); e' \\<noteq> (v, u)\\<rbrakk>\n    \\<Longrightarrow> cf_of (augment_edge f (u, v) \\<Delta>) e' =\n                      ((cf_of f)\n                       ((u, v) := cf_of f (u, v) - \\<Delta>,\n                        (v, u) := cf_of f (v, u) + \\<Delta>))\n                       e'", "by (simp \n                  split!: if_splits prod.splits \n                  add: residualGraph_def augment_edge_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(u, v) \\<in> E \\<union> E\\<inverse>;\n        (u, v) \\<notin> E\\<rbrakk>\n       \\<Longrightarrow> cf_of (augment_edge f (u, v) \\<Delta>) x =\n                         ((cf_of f)\n                          ((u, v) := cf_of f (u, v) - \\<Delta>,\n                           (v, u) := cf_of f (v, u) + \\<Delta>))\n                          x", "subgoal for e'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, v) \\<in> E \\<union> E\\<inverse>; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> cf_of (augment_edge f (u, v) \\<Delta>) e' =\n                      ((cf_of f)\n                       ((u, v) := cf_of f (u, v) - \\<Delta>,\n                        (v, u) := cf_of f (v, u) + \\<Delta>))\n                       e'", "apply (cases \"e'=(u,v)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(u, v) \\<in> E \\<union> E\\<inverse>; (u, v) \\<notin> E;\n     e' = (u, v)\\<rbrakk>\n    \\<Longrightarrow> cf_of (augment_edge f (u, v) \\<Delta>) e' =\n                      ((cf_of f)\n                       ((u, v) := cf_of f (u, v) - \\<Delta>,\n                        (v, u) := cf_of f (v, u) + \\<Delta>))\n                       e'\n 2. \\<lbrakk>(u, v) \\<in> E \\<union> E\\<inverse>; (u, v) \\<notin> E;\n     e' \\<noteq> (u, v)\\<rbrakk>\n    \\<Longrightarrow> cf_of (augment_edge f (u, v) \\<Delta>) e' =\n                      ((cf_of f)\n                       ((u, v) := cf_of f (u, v) - \\<Delta>,\n                        (v, u) := cf_of f (v, u) + \\<Delta>))\n                       e'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, v) \\<in> E \\<union> E\\<inverse>; (u, v) \\<notin> E;\n     e' = (u, v)\\<rbrakk>\n    \\<Longrightarrow> cf_of (augment_edge f (u, v) \\<Delta>) e' =\n                      ((cf_of f)\n                       ((u, v) := cf_of f (u, v) - \\<Delta>,\n                        (v, u) := cf_of f (v, u) + \\<Delta>))\n                       e'", "by (simp split!: if_splits add: no_self_loop residualGraph_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, v) \\<in> E \\<union> E\\<inverse>; (u, v) \\<notin> E;\n     e' \\<noteq> (u, v)\\<rbrakk>\n    \\<Longrightarrow> cf_of (augment_edge f (u, v) \\<Delta>) e' =\n                      ((cf_of f)\n                       ((u, v) := cf_of f (u, v) - \\<Delta>,\n                        (v, u) := cf_of f (v, u) + \\<Delta>))\n                       e'", "apply (cases \"e'=(v,u)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(u, v) \\<in> E \\<union> E\\<inverse>; (u, v) \\<notin> E;\n     e' \\<noteq> (u, v); e' = (v, u)\\<rbrakk>\n    \\<Longrightarrow> cf_of (augment_edge f (u, v) \\<Delta>) e' =\n                      ((cf_of f)\n                       ((u, v) := cf_of f (u, v) - \\<Delta>,\n                        (v, u) := cf_of f (v, u) + \\<Delta>))\n                       e'\n 2. \\<lbrakk>(u, v) \\<in> E \\<union> E\\<inverse>; (u, v) \\<notin> E;\n     e' \\<noteq> (u, v); e' \\<noteq> (v, u)\\<rbrakk>\n    \\<Longrightarrow> cf_of (augment_edge f (u, v) \\<Delta>) e' =\n                      ((cf_of f)\n                       ((u, v) := cf_of f (u, v) - \\<Delta>,\n                        (v, u) := cf_of f (v, u) + \\<Delta>))\n                       e'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, v) \\<in> E \\<union> E\\<inverse>; (u, v) \\<notin> E;\n     e' \\<noteq> (u, v); e' = (v, u)\\<rbrakk>\n    \\<Longrightarrow> cf_of (augment_edge f (u, v) \\<Delta>) e' =\n                      ((cf_of f)\n                       ((u, v) := cf_of f (u, v) - \\<Delta>,\n                        (v, u) := cf_of f (v, u) + \\<Delta>))\n                       e'", "by (simp split!: if_splits add: no_self_loop residualGraph_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, v) \\<in> E \\<union> E\\<inverse>; (u, v) \\<notin> E;\n     e' \\<noteq> (u, v); e' \\<noteq> (v, u)\\<rbrakk>\n    \\<Longrightarrow> cf_of (augment_edge f (u, v) \\<Delta>) e' =\n                      ((cf_of f)\n                       ((u, v) := cf_of f (u, v) - \\<Delta>,\n                        (v, u) := cf_of f (v, u) + \\<Delta>))\n                       e'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, v) \\<in> E \\<union> E\\<inverse>; (u, v) \\<notin> E;\n     e' \\<noteq> (u, v); e' \\<noteq> (v, u)\\<rbrakk>\n    \\<Longrightarrow> cf_of (augment_edge f (u, v) \\<Delta>) e' =\n                      ((cf_of f)\n                       ((u, v) := cf_of f (u, v) - \\<Delta>,\n                        (v, u) := cf_of f (v, u) + \\<Delta>))\n                       e'", "by (simp \n                  split!: if_splits prod.splits \n                  add: residualGraph_def augment_edge_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma augment_edge_cf': \"(u,v)\\<in>cfE_of f \\<Longrightarrow> \n    cf_of (augment_edge f (u,v) \\<Delta>) \n  = (cf_of f)( (u,v) := cf_of f (u,v) - \\<Delta>, (v,u) := cf_of f (v,u) + \\<Delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> cfE_of f \\<Longrightarrow>\n    cf_of (augment_edge f (u, v) \\<Delta>) = (cf_of f)\n    ((u, v) := cf_of f (u, v) - \\<Delta>,\n     (v, u) := cf_of f (v, u) + \\<Delta>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (u, v) \\<in> cfE_of f \\<Longrightarrow>\n    cf_of (augment_edge f (u, v) \\<Delta>) = (cf_of f)\n    ((u, v) := cf_of f (u, v) - \\<Delta>,\n     (v, u) := cf_of f (v, u) + \\<Delta>)", "assume \"(u,v)\\<in>cfE_of f\""], ["proof (state)\nthis:\n  (u, v) \\<in> cfE_of f\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> cfE_of f \\<Longrightarrow>\n    cf_of (augment_edge f (u, v) \\<Delta>) = (cf_of f)\n    ((u, v) := cf_of f (u, v) - \\<Delta>,\n     (v, u) := cf_of f (v, u) + \\<Delta>)", "hence \"(u,v)\\<in>E\\<union>E\\<inverse>\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> cfE_of f\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> E \\<union> E\\<inverse>", "using cfE_of_ss_invE"], ["proof (prove)\nusing this:\n  (u, v) \\<in> cfE_of f\n  cfE_of ?cf \\<subseteq> E \\<union> E\\<inverse>\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> E \\<union> E\\<inverse>", ".."], ["proof (state)\nthis:\n  (u, v) \\<in> E \\<union> E\\<inverse>\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> cfE_of f \\<Longrightarrow>\n    cf_of (augment_edge f (u, v) \\<Delta>) = (cf_of f)\n    ((u, v) := cf_of f (u, v) - \\<Delta>,\n     (v, u) := cf_of f (v, u) + \\<Delta>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (u, v) \\<in> E \\<union> E\\<inverse>\n\ngoal (1 subgoal):\n 1. cf_of (augment_edge f (u, v) \\<Delta>) = (cf_of f)\n    ((u, v) := cf_of f (u, v) - \\<Delta>,\n     (v, u) := cf_of f (v, u) + \\<Delta>)", "by simp"], ["proof (state)\nthis:\n  cf_of (augment_edge f (u, v) \\<Delta>) = (cf_of f)\n  ((u, v) := cf_of f (u, v) - \\<Delta>, (v, u) := cf_of f (v, u) + \\<Delta>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The effect of augmenting an edge on the residual graph\\<close>"], ["", "definition (in -) augment_edge_cf :: \"_ flow \\<Rightarrow> _\" where \n  \"augment_edge_cf cf \n    \\<equiv> \\<lambda>(u,v) \\<Delta>. (cf)( (u,v) := cf (u,v) - \\<Delta>, (v,u) := cf (v,u) + \\<Delta>)\""], ["", "lemma cf_of_augment_edge:\n  assumes A: \"(u,v)\\<in>cfE_of f\" \n  shows \"cf_of (augment_edge f (u,v) \\<Delta>) = augment_edge_cf (cf_of f) (u,v) \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cf_of (augment_edge f (u, v) \\<Delta>) =\n    augment_edge_cf (cf_of f) (u, v) \\<Delta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cf_of (augment_edge f (u, v) \\<Delta>) =\n    augment_edge_cf (cf_of f) (u, v) \\<Delta>", "show \"cf_of (augment_edge f (u, v) \\<Delta>) = augment_edge_cf (cf_of f) (u, v) \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cf_of (augment_edge f (u, v) \\<Delta>) =\n    augment_edge_cf (cf_of f) (u, v) \\<Delta>", "by (simp add: augment_edge_cf_def A augment_edge_cf')"], ["proof (state)\nthis:\n  cf_of (augment_edge f (u, v) \\<Delta>) =\n  augment_edge_cf (cf_of f) (u, v) \\<Delta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cfE_augment_ss:\n  assumes EDGE: \"(u,v)\\<in>cfE_of f\"  \n  shows \"cfE_of (augment_edge f (u,v) \\<Delta>) \\<subseteq> insert (v,u) (cfE_of f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfE_of (augment_edge f (u, v) \\<Delta>)\n    \\<subseteq> insert (v, u) (cfE_of f)", "using EDGE"], ["proof (prove)\nusing this:\n  (u, v) \\<in> cfE_of f\n\ngoal (1 subgoal):\n 1. cfE_of (augment_edge f (u, v) \\<Delta>)\n    \\<subseteq> insert (v, u) (cfE_of f)", "apply (clarsimp simp: augment_edge_cf')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(u, v) \\<in> cfE_of f;\n        (a, b)\n        \\<in> Graph.E\n               ((cf_of f)\n                ((u, v) := cf_of f (u, v) - \\<Delta>,\n                 (v, u) := cf_of f (v, u) + \\<Delta>));\n        (a, b) \\<notin> cfE_of f\\<rbrakk>\n       \\<Longrightarrow> a = v \\<and> b = u", "unfolding Graph.E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(u, v)\n                \\<in> {(u, v). cf_of f (u, v) \\<noteq> (0::'capacity)};\n        (a, b)\n        \\<in> {(ua, va).\n               ((cf_of f)\n                ((u, v) := cf_of f (u, v) - \\<Delta>,\n                 (v, u) := cf_of f (v, u) + \\<Delta>))\n                (ua, va) \\<noteq>\n               (0::'capacity)};\n        (a, b)\n        \\<notin> {(u, v). cf_of f (u, v) \\<noteq> (0::'capacity)}\\<rbrakk>\n       \\<Longrightarrow> a = v \\<and> b = u", "apply (auto split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end \\<comment> \\<open>Network\\<close>"], ["", "context NPreflow begin"], ["", "text \\<open>Augmenting an edge \\<open>(u,v)\\<close> with a flow \\<open>\\<Delta>\\<close> that does not exceed the \n  available edge capacity, nor the available excess flow on the source node,\n  preserves the preflow property.\n\\<close>"], ["", "lemma augment_edge_preflow_preserve: \"\\<lbrakk>0\\<le>\\<Delta>; \\<Delta> \\<le> cf (u,v); \\<Delta> \\<le> excess f u\\<rbrakk> \n  \\<Longrightarrow> Preflow c s t (augment_edge f (u,v) \\<Delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(0::'capacity) \\<le> \\<Delta>; \\<Delta> \\<le> cf (u, v);\n     \\<Delta> \\<le> excess f u\\<rbrakk>\n    \\<Longrightarrow> Preflow c s t (augment_edge f (u, v) \\<Delta>)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'capacity) \\<le> \\<Delta>; \\<Delta> \\<le> cf (u, v);\n     \\<Delta> \\<le> excess f u\\<rbrakk>\n    \\<Longrightarrow> \\<forall>e.\n                         (0::'capacity)\n                         \\<le> augment_edge f (u, v) \\<Delta> e \\<and>\n                         augment_edge f (u, v) \\<Delta> e \\<le> c e\n 2. \\<lbrakk>(0::'capacity) \\<le> \\<Delta>; \\<Delta> \\<le> cf (u, v);\n     \\<Delta> \\<le> excess f u\\<rbrakk>\n    \\<Longrightarrow> \\<forall>va\\<in>V - {s, t}.\n                         sum (augment_edge f (u, v) \\<Delta>) (outgoing va)\n                         \\<le> sum (augment_edge f (u, v) \\<Delta>)\n                                (incoming va)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(0::'capacity) \\<le> \\<Delta>; \\<Delta> \\<le> cf (u, v);\n     \\<Delta> \\<le> excess f u\\<rbrakk>\n    \\<Longrightarrow> \\<forall>e.\n                         (0::'capacity)\n                         \\<le> augment_edge f (u, v) \\<Delta> e \\<and>\n                         augment_edge f (u, v) \\<Delta> e \\<le> c e", "unfolding residualGraph_def augment_edge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(0::'capacity) \\<le> \\<Delta>;\n     \\<Delta>\n     \\<le> (case (u, v) of\n            (u, v) \\<Rightarrow>\n              if (u, v) \\<in> E then c (u, v) - f (u, v)\n              else if (v, u) \\<in> E then f (v, u) else (0::'capacity));\n     \\<Delta> \\<le> excess f u\\<rbrakk>\n    \\<Longrightarrow> \\<forall>e.\n                         (0::'capacity)\n                         \\<le> (case (u, v) of\n                                (u, v) \\<Rightarrow>\n                                  \\<lambda>\\<Delta>.\n                                     if (u, v) \\<in> E\n                                     then f((u, v) := f (u, v) + \\<Delta>)\n                                     else if (v, u) \\<in> E\n    then f((v, u) := f (v, u) - \\<Delta>) else f)\n                                \\<Delta> e \\<and>\n                         (case (u, v) of\n                          (u, v) \\<Rightarrow>\n                            \\<lambda>\\<Delta>.\n                               if (u, v) \\<in> E\n                               then f((u, v) := f (u, v) + \\<Delta>)\n                               else if (v, u) \\<in> E\n                                    then f((v, u) := f (v, u) - \\<Delta>)\n                                    else f)\n                          \\<Delta> e\n                         \\<le> c e", "using capacity_const"], ["proof (prove)\nusing this:\n  \\<forall>e. (0::'capacity) \\<le> f e \\<and> f e \\<le> c e\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(0::'capacity) \\<le> \\<Delta>;\n     \\<Delta>\n     \\<le> (case (u, v) of\n            (u, v) \\<Rightarrow>\n              if (u, v) \\<in> E then c (u, v) - f (u, v)\n              else if (v, u) \\<in> E then f (v, u) else (0::'capacity));\n     \\<Delta> \\<le> excess f u\\<rbrakk>\n    \\<Longrightarrow> \\<forall>e.\n                         (0::'capacity)\n                         \\<le> (case (u, v) of\n                                (u, v) \\<Rightarrow>\n                                  \\<lambda>\\<Delta>.\n                                     if (u, v) \\<in> E\n                                     then f((u, v) := f (u, v) + \\<Delta>)\n                                     else if (v, u) \\<in> E\n    then f((v, u) := f (v, u) - \\<Delta>) else f)\n                                \\<Delta> e \\<and>\n                         (case (u, v) of\n                          (u, v) \\<Rightarrow>\n                            \\<lambda>\\<Delta>.\n                               if (u, v) \\<in> E\n                               then f((u, v) := f (u, v) + \\<Delta>)\n                               else if (v, u) \\<in> E\n                                    then f((v, u) := f (v, u) - \\<Delta>)\n                                    else f)\n                          \\<Delta> e\n                         \\<le> c e", "by (fastforce split!: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(0::'capacity) \\<le> \\<Delta>; \\<Delta> \\<le> cf (u, v);\n     \\<Delta> \\<le> excess f u\\<rbrakk>\n    \\<Longrightarrow> \\<forall>va\\<in>V - {s, t}.\n                         sum (augment_edge f (u, v) \\<Delta>) (outgoing va)\n                         \\<le> sum (augment_edge f (u, v) \\<Delta>)\n                                (incoming va)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(0::'capacity) \\<le> \\<Delta>; \\<Delta> \\<le> cf (u, v);\n     \\<Delta> \\<le> excess f u\\<rbrakk>\n    \\<Longrightarrow> \\<forall>va\\<in>V - {s, t}.\n                         sum (augment_edge f (u, v) \\<Delta>) (outgoing va)\n                         \\<le> sum (augment_edge f (u, v) \\<Delta>)\n                                (incoming va)", "proof (intro ballI; clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>va.\n       \\<lbrakk>(0::'capacity) \\<le> \\<Delta>; \\<Delta> \\<le> cf (u, v);\n        \\<Delta> \\<le> excess f u; va \\<in> V; va \\<noteq> s;\n        va \\<noteq> t\\<rbrakk>\n       \\<Longrightarrow> sum (augment_edge f (u, v) \\<Delta>) (outgoing va)\n                         \\<le> sum (augment_edge f (u, v) \\<Delta>)\n                                (incoming va)", "assume \"0\\<le>\\<Delta>\" \"\\<Delta> \\<le> cf (u,v)\" \"\\<Delta> \\<le> excess f u\""], ["proof (state)\nthis:\n  (0::'capacity) \\<le> \\<Delta>\n  \\<Delta> \\<le> cf (u, v)\n  \\<Delta> \\<le> excess f u\n\ngoal (1 subgoal):\n 1. \\<And>va.\n       \\<lbrakk>(0::'capacity) \\<le> \\<Delta>; \\<Delta> \\<le> cf (u, v);\n        \\<Delta> \\<le> excess f u; va \\<in> V; va \\<noteq> s;\n        va \\<noteq> t\\<rbrakk>\n       \\<Longrightarrow> sum (augment_edge f (u, v) \\<Delta>) (outgoing va)\n                         \\<le> sum (augment_edge f (u, v) \\<Delta>)\n                                (incoming va)", "fix v'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>va.\n       \\<lbrakk>(0::'capacity) \\<le> \\<Delta>; \\<Delta> \\<le> cf (u, v);\n        \\<Delta> \\<le> excess f u; va \\<in> V; va \\<noteq> s;\n        va \\<noteq> t\\<rbrakk>\n       \\<Longrightarrow> sum (augment_edge f (u, v) \\<Delta>) (outgoing va)\n                         \\<le> sum (augment_edge f (u, v) \\<Delta>)\n                                (incoming va)", "assume V': \"v'\\<in>V\" \"v'\\<noteq>s\" \"v'\\<noteq>t\""], ["proof (state)\nthis:\n  v' \\<in> V\n  v' \\<noteq> s\n  v' \\<noteq> t\n\ngoal (1 subgoal):\n 1. \\<And>va.\n       \\<lbrakk>(0::'capacity) \\<le> \\<Delta>; \\<Delta> \\<le> cf (u, v);\n        \\<Delta> \\<le> excess f u; va \\<in> V; va \\<noteq> s;\n        va \\<noteq> t\\<rbrakk>\n       \\<Longrightarrow> sum (augment_edge f (u, v) \\<Delta>) (outgoing va)\n                         \\<le> sum (augment_edge f (u, v) \\<Delta>)\n                                (incoming va)", "show \"sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n            \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "assume \"\\<Delta> = 0\""], ["proof (state)\nthis:\n  \\<Delta> = (0::'capacity)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "with no_deficient_nodes"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>V - {s, t}. sum f (outgoing v) \\<le> sum f (incoming v)\n  \\<Delta> = (0::'capacity)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V - {s, t}. sum f (outgoing v) \\<le> sum f (incoming v)\n  \\<Delta> = (0::'capacity)\n\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "using V'"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V - {s, t}. sum f (outgoing v) \\<le> sum f (incoming v)\n  \\<Delta> = (0::'capacity)\n  v' \\<in> V\n  v' \\<noteq> s\n  v' \\<noteq> t\n\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "by auto"], ["proof (state)\nthis:\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (1 subgoal):\n 1. \\<Delta> \\<noteq> (0::'capacity) \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Delta> \\<noteq> (0::'capacity) \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "assume \"\\<Delta> \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<Delta> \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. \\<Delta> \\<noteq> (0::'capacity) \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "with \\<open>0\\<le>\\<Delta>\\<close>"], ["proof (chain)\npicking this:\n  (0::'capacity) \\<le> \\<Delta>\n  \\<Delta> \\<noteq> (0::'capacity)", "have \"0<\\<Delta>\""], ["proof (prove)\nusing this:\n  (0::'capacity) \\<le> \\<Delta>\n  \\<Delta> \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. (0::'capacity) < \\<Delta>", "by auto"], ["proof (state)\nthis:\n  (0::'capacity) < \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<Delta> \\<noteq> (0::'capacity) \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "with \\<open>\\<Delta> \\<le> cf (u,v)\\<close>"], ["proof (chain)\npicking this:\n  \\<Delta> \\<le> cf (u, v)\n  (0::'capacity) < \\<Delta>", "have \"(u,v)\\<in>cf.E\""], ["proof (prove)\nusing this:\n  \\<Delta> \\<le> cf (u, v)\n  (0::'capacity) < \\<Delta>\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> cf.E", "unfolding Graph.E_def"], ["proof (prove)\nusing this:\n  \\<Delta> \\<le> cf (u, v)\n  (0::'capacity) < \\<Delta>\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> {(u, v). cf (u, v) \\<noteq> (0::'capacity)}", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<in> cf.E\n\ngoal (1 subgoal):\n 1. \\<Delta> \\<noteq> (0::'capacity) \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "assume [simp]: \"(u,v)\\<in>E\""], ["proof (state)\nthis:\n  (u, v) \\<in> E\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "hence AE: \"augment_edge f (u,v) \\<Delta> = f ( (u,v) := f (u,v) + \\<Delta> )\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> E\n\ngoal (1 subgoal):\n 1. augment_edge f (u, v) \\<Delta> = f((u, v) := f (u, v) + \\<Delta>)", "unfolding augment_edge_def"], ["proof (prove)\nusing this:\n  (u, v) \\<in> E\n\ngoal (1 subgoal):\n 1. (case (u, v) of\n     (u, v) \\<Rightarrow>\n       \\<lambda>\\<Delta>.\n          if (u, v) \\<in> E then f((u, v) := f (u, v) + \\<Delta>)\n          else if (v, u) \\<in> E then f((v, u) := f (v, u) - \\<Delta>)\n               else f)\n     \\<Delta> =\n    f((u, v) := f (u, v) + \\<Delta>)", "by auto"], ["proof (state)\nthis:\n  augment_edge f (u, v) \\<Delta> = f((u, v) := f (u, v) + \\<Delta>)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "have 1: \"\\<forall>e\\<in>outgoing v'. augment_edge f (u,v) \\<Delta> e = f e\" if \"v'\\<noteq>u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>outgoing v'. augment_edge f (u, v) \\<Delta> e = f e", "using that"], ["proof (prove)\nusing this:\n  v' \\<noteq> u\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>outgoing v'. augment_edge f (u, v) \\<Delta> e = f e", "unfolding outgoing_def AE"], ["proof (prove)\nusing this:\n  v' \\<noteq> u\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>{(v', u) |u. (v', u) \\<in> E}.\n       (f((u, v) := f (u, v) + \\<Delta>)) e = f e", "by auto"], ["proof (state)\nthis:\n  v' \\<noteq> u \\<Longrightarrow>\n  \\<forall>e\\<in>outgoing v'. augment_edge f (u, v) \\<Delta> e = f e\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "have 2: \"\\<forall>e\\<in>incoming v'. augment_edge f (u,v) \\<Delta> e = f e\" if \"v'\\<noteq>v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>incoming v'. augment_edge f (u, v) \\<Delta> e = f e", "using that"], ["proof (prove)\nusing this:\n  v' \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>incoming v'. augment_edge f (u, v) \\<Delta> e = f e", "unfolding incoming_def AE"], ["proof (prove)\nusing this:\n  v' \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>{(u, v') |u. (u, v') \\<in> E}.\n       (f((u, v) := f (u, v) + \\<Delta>)) e = f e", "by auto"], ["proof (state)\nthis:\n  v' \\<noteq> v \\<Longrightarrow>\n  \\<forall>e\\<in>incoming v'. augment_edge f (u, v) \\<Delta> e = f e\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "from \\<open>(u,v)\\<in>E\\<close> no_self_loop"], ["proof (chain)\npicking this:\n  (u, v) \\<in> E\n  \\<forall>u. (u, u) \\<notin> E", "have \"u\\<noteq>v\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> E\n  \\<forall>u. (u, u) \\<notin> E\n\ngoal (1 subgoal):\n 1. u \\<noteq> v", "by blast"], ["proof (state)\nthis:\n  u \\<noteq> v\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "{"], ["proof (state)\nthis:\n  u \\<noteq> v\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "assume \"v' \\<noteq> u\" \"v' \\<noteq> v\""], ["proof (state)\nthis:\n  v' \\<noteq> u\n  v' \\<noteq> v\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "with 1 2 V' no_deficient_nodes"], ["proof (chain)\npicking this:\n  v' \\<noteq> u \\<Longrightarrow>\n  \\<forall>e\\<in>outgoing v'. augment_edge f (u, v) \\<Delta> e = f e\n  v' \\<noteq> v \\<Longrightarrow>\n  \\<forall>e\\<in>incoming v'. augment_edge f (u, v) \\<Delta> e = f e\n  v' \\<in> V\n  v' \\<noteq> s\n  v' \\<noteq> t\n  \\<forall>v\\<in>V - {s, t}. sum f (outgoing v) \\<le> sum f (incoming v)\n  v' \\<noteq> u\n  v' \\<noteq> v", "have ?thesis"], ["proof (prove)\nusing this:\n  v' \\<noteq> u \\<Longrightarrow>\n  \\<forall>e\\<in>outgoing v'. augment_edge f (u, v) \\<Delta> e = f e\n  v' \\<noteq> v \\<Longrightarrow>\n  \\<forall>e\\<in>incoming v'. augment_edge f (u, v) \\<Delta> e = f e\n  v' \\<in> V\n  v' \\<noteq> s\n  v' \\<noteq> t\n  \\<forall>v\\<in>V - {s, t}. sum f (outgoing v) \\<le> sum f (incoming v)\n  v' \\<noteq> u\n  v' \\<noteq> v\n\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "by auto"], ["proof (state)\nthis:\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "}"], ["proof (state)\nthis:\n  \\<lbrakk>v' \\<noteq> u; v' \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n                    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>v' \\<noteq> u; v' \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n                    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "{"], ["proof (state)\nthis:\n  \\<lbrakk>v' \\<noteq> u; v' \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n                    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "assume [simp]: \"v'=v\""], ["proof (state)\nthis:\n  v' = v\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "have \"sum (augment_edge f (u, v) \\<Delta>) (outgoing v') \n              = sum f (outgoing v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (outgoing v') = sum f (outgoing v)", "using 1 \\<open>u\\<noteq>v\\<close> V'"], ["proof (prove)\nusing this:\n  v' \\<noteq> u \\<Longrightarrow>\n  \\<forall>e\\<in>outgoing v'. augment_edge f (u, v) \\<Delta> e = f e\n  u \\<noteq> v\n  v' \\<in> V\n  v' \\<noteq> s\n  v' \\<noteq> t\n\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (outgoing v') = sum f (outgoing v)", "by auto"], ["proof (state)\nthis:\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v') = sum f (outgoing v)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "also"], ["proof (state)\nthis:\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v') = sum f (outgoing v)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "have \"\\<dots> \\<le> sum f (incoming v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (outgoing v) \\<le> sum f (incoming v)", "using V' no_deficient_nodes"], ["proof (prove)\nusing this:\n  v' \\<in> V\n  v' \\<noteq> s\n  v' \\<noteq> t\n  \\<forall>v\\<in>V - {s, t}. sum f (outgoing v) \\<le> sum f (incoming v)\n\ngoal (1 subgoal):\n 1. sum f (outgoing v) \\<le> sum f (incoming v)", "by auto"], ["proof (state)\nthis:\n  sum f (outgoing v) \\<le> sum f (incoming v)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "also"], ["proof (state)\nthis:\n  sum f (outgoing v) \\<le> sum f (incoming v)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "have \"\\<dots> \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (incoming v)\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v)", "apply (rule sum_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> incoming v \\<Longrightarrow>\n       f i \\<le> augment_edge f (u, v) \\<Delta> i", "using \\<open>0\\<le>\\<Delta>\\<close>"], ["proof (prove)\nusing this:\n  (0::'capacity) \\<le> \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> incoming v \\<Longrightarrow>\n       f i \\<le> augment_edge f (u, v) \\<Delta> i", "by (auto simp: incoming_def augment_edge_def split!: if_split)"], ["proof (state)\nthis:\n  sum f (incoming v) \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "finally"], ["proof (chain)\npicking this:\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v)", "have ?thesis"], ["proof (prove)\nusing this:\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v)\n\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "by simp"], ["proof (state)\nthis:\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "}"], ["proof (state)\nthis:\n  v' = v \\<Longrightarrow>\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "moreover"], ["proof (state)\nthis:\n  v' = v \\<Longrightarrow>\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "{"], ["proof (state)\nthis:\n  v' = v \\<Longrightarrow>\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "assume [simp]: \"v'=u\""], ["proof (state)\nthis:\n  v' = u\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "have A1: \"sum (augment_edge f (u,v) \\<Delta>) (incoming v') \n                  = sum f (incoming u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (incoming v') = sum f (incoming u)", "using 2 \\<open>u\\<noteq>v\\<close>"], ["proof (prove)\nusing this:\n  v' \\<noteq> v \\<Longrightarrow>\n  \\<forall>e\\<in>incoming v'. augment_edge f (u, v) \\<Delta> e = f e\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (incoming v') = sum f (incoming u)", "by auto"], ["proof (state)\nthis:\n  sum (augment_edge f (u, v) \\<Delta>) (incoming v') = sum f (incoming u)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "have \"(u,v) \\<in> outgoing u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> outgoing u", "using \\<open>(u,v)\\<in>E\\<close>"], ["proof (prove)\nusing this:\n  (u, v) \\<in> E\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> outgoing u", "by (auto simp: outgoing_def)"], ["proof (state)\nthis:\n  (u, v) \\<in> outgoing u\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "note AUX = sum.remove[OF _ this, simplified]"], ["proof (state)\nthis:\n  sum ?g (outgoing u) = ?g (u, v) + sum ?g (outgoing u - {(u, v)})\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "have A2: \"sum (augment_edge f (u,v) \\<Delta>) (outgoing u) \n                  = sum f (outgoing u) + \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (outgoing u) =\n    sum f (outgoing u) + \\<Delta>", "using AUX[of \"augment_edge f (u,v) \\<Delta>\"] AUX[of \"f\"]"], ["proof (prove)\nusing this:\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing u) =\n  augment_edge f (u, v) \\<Delta> (u, v) +\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing u - {(u, v)})\n  sum f (outgoing u) = f (u, v) + sum f (outgoing u - {(u, v)})\n\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (outgoing u) =\n    sum f (outgoing u) + \\<Delta>", "by auto"], ["proof (state)\nthis:\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing u) =\n  sum f (outgoing u) + \\<Delta>\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "from A1 A2 \\<open>\\<Delta> \\<le> excess f u\\<close> no_deficient_nodes V'"], ["proof (chain)\npicking this:\n  sum (augment_edge f (u, v) \\<Delta>) (incoming v') = sum f (incoming u)\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing u) =\n  sum f (outgoing u) + \\<Delta>\n  \\<Delta> \\<le> excess f u\n  \\<forall>v\\<in>V - {s, t}. sum f (outgoing v) \\<le> sum f (incoming v)\n  v' \\<in> V\n  v' \\<noteq> s\n  v' \\<noteq> t", "have ?thesis"], ["proof (prove)\nusing this:\n  sum (augment_edge f (u, v) \\<Delta>) (incoming v') = sum f (incoming u)\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing u) =\n  sum f (outgoing u) + \\<Delta>\n  \\<Delta> \\<le> excess f u\n  \\<forall>v\\<in>V - {s, t}. sum f (outgoing v) \\<le> sum f (incoming v)\n  v' \\<in> V\n  v' \\<noteq> s\n  v' \\<noteq> t\n\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "unfolding excess_def"], ["proof (prove)\nusing this:\n  sum (augment_edge f (u, v) \\<Delta>) (incoming v') = sum f (incoming u)\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing u) =\n  sum f (outgoing u) + \\<Delta>\n  \\<Delta> \\<le> sum f (incoming u) - sum f (outgoing u)\n  \\<forall>v\\<in>V - {s, t}. sum f (outgoing v) \\<le> sum f (incoming v)\n  v' \\<in> V\n  v' \\<noteq> s\n  v' \\<noteq> t\n\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "by auto"], ["proof (state)\nthis:\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "}"], ["proof (state)\nthis:\n  v' = u \\<Longrightarrow>\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n 2. \\<not> ?P \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>v' \\<noteq> u; v' \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n                    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n  v' = v \\<Longrightarrow>\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n  v' = u \\<Longrightarrow>\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>v' \\<noteq> u; v' \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n                    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n  v' = v \\<Longrightarrow>\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n  v' = u \\<Longrightarrow>\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "by blast"], ["proof (state)\nthis:\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "assume [simp]: \\<open>(u,v)\\<notin>E\\<close>"], ["proof (state)\nthis:\n  (u, v) \\<notin> E\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "hence [simp]: \"(v,u)\\<in>E\""], ["proof (prove)\nusing this:\n  (u, v) \\<notin> E\n\ngoal (1 subgoal):\n 1. (v, u) \\<in> E", "using cfE_ss_invE \\<open>(u,v)\\<in>cf.E\\<close>"], ["proof (prove)\nusing this:\n  (u, v) \\<notin> E\n  cf.E \\<subseteq> E \\<union> E\\<inverse>\n  (u, v) \\<in> cf.E\n\ngoal (1 subgoal):\n 1. (v, u) \\<in> E", "by auto"], ["proof (state)\nthis:\n  (v, u) \\<in> E\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "from \\<open>(u,v)\\<notin>E\\<close> \\<open>(v,u)\\<in>E\\<close>"], ["proof (chain)\npicking this:\n  (u, v) \\<notin> E\n  (v, u) \\<in> E", "have \"u\\<noteq>v\""], ["proof (prove)\nusing this:\n  (u, v) \\<notin> E\n  (v, u) \\<in> E\n\ngoal (1 subgoal):\n 1. u \\<noteq> v", "by blast"], ["proof (state)\nthis:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "have AE: \"augment_edge f (u,v) \\<Delta> = f ( (v,u) := f (v,u) - \\<Delta> )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. augment_edge f (u, v) \\<Delta> = f((v, u) := f (v, u) - \\<Delta>)", "unfolding augment_edge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (u, v) of\n     (u, v) \\<Rightarrow>\n       \\<lambda>\\<Delta>.\n          if (u, v) \\<in> E then f((u, v) := f (u, v) + \\<Delta>)\n          else if (v, u) \\<in> E then f((v, u) := f (v, u) - \\<Delta>)\n               else f)\n     \\<Delta> =\n    f((v, u) := f (v, u) - \\<Delta>)", "by simp"], ["proof (state)\nthis:\n  augment_edge f (u, v) \\<Delta> = f((v, u) := f (v, u) - \\<Delta>)\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "have 1: \"\\<forall>e\\<in>outgoing v'. augment_edge f (u,v) \\<Delta> e = f e\" if \"v'\\<noteq>v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>outgoing v'. augment_edge f (u, v) \\<Delta> e = f e", "using that"], ["proof (prove)\nusing this:\n  v' \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>outgoing v'. augment_edge f (u, v) \\<Delta> e = f e", "unfolding outgoing_def AE"], ["proof (prove)\nusing this:\n  v' \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>{(v', u) |u. (v', u) \\<in> E}.\n       (f((v, u) := f (v, u) - \\<Delta>)) e = f e", "by auto"], ["proof (state)\nthis:\n  v' \\<noteq> v \\<Longrightarrow>\n  \\<forall>e\\<in>outgoing v'. augment_edge f (u, v) \\<Delta> e = f e\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "have 2: \"\\<forall>e\\<in>incoming v'. augment_edge f (u,v) \\<Delta> e = f e\" if \"v'\\<noteq>u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>incoming v'. augment_edge f (u, v) \\<Delta> e = f e", "using that"], ["proof (prove)\nusing this:\n  v' \\<noteq> u\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>incoming v'. augment_edge f (u, v) \\<Delta> e = f e", "unfolding incoming_def AE"], ["proof (prove)\nusing this:\n  v' \\<noteq> u\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>{(u, v') |u. (u, v') \\<in> E}.\n       (f((v, u) := f (v, u) - \\<Delta>)) e = f e", "by auto"], ["proof (state)\nthis:\n  v' \\<noteq> u \\<Longrightarrow>\n  \\<forall>e\\<in>incoming v'. augment_edge f (u, v) \\<Delta> e = f e\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "{"], ["proof (state)\nthis:\n  v' \\<noteq> u \\<Longrightarrow>\n  \\<forall>e\\<in>incoming v'. augment_edge f (u, v) \\<Delta> e = f e\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "assume \"v' \\<noteq> u\" \"v' \\<noteq> v\""], ["proof (state)\nthis:\n  v' \\<noteq> u\n  v' \\<noteq> v\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "with 1 2 V' no_deficient_nodes"], ["proof (chain)\npicking this:\n  v' \\<noteq> v \\<Longrightarrow>\n  \\<forall>e\\<in>outgoing v'. augment_edge f (u, v) \\<Delta> e = f e\n  v' \\<noteq> u \\<Longrightarrow>\n  \\<forall>e\\<in>incoming v'. augment_edge f (u, v) \\<Delta> e = f e\n  v' \\<in> V\n  v' \\<noteq> s\n  v' \\<noteq> t\n  \\<forall>v\\<in>V - {s, t}. sum f (outgoing v) \\<le> sum f (incoming v)\n  v' \\<noteq> u\n  v' \\<noteq> v", "have ?thesis"], ["proof (prove)\nusing this:\n  v' \\<noteq> v \\<Longrightarrow>\n  \\<forall>e\\<in>outgoing v'. augment_edge f (u, v) \\<Delta> e = f e\n  v' \\<noteq> u \\<Longrightarrow>\n  \\<forall>e\\<in>incoming v'. augment_edge f (u, v) \\<Delta> e = f e\n  v' \\<in> V\n  v' \\<noteq> s\n  v' \\<noteq> t\n  \\<forall>v\\<in>V - {s, t}. sum f (outgoing v) \\<le> sum f (incoming v)\n  v' \\<noteq> u\n  v' \\<noteq> v\n\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "by auto"], ["proof (state)\nthis:\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "}"], ["proof (state)\nthis:\n  \\<lbrakk>v' \\<noteq> u; v' \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n                    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>v' \\<noteq> u; v' \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n                    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "{"], ["proof (state)\nthis:\n  \\<lbrakk>v' \\<noteq> u; v' \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n                    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "assume [simp]: \"v'=u\""], ["proof (state)\nthis:\n  v' = u\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "have A1: \"sum (augment_edge f (u, v) \\<Delta>) (outgoing v') \n                  = sum f (outgoing u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (outgoing v') = sum f (outgoing u)", "using 1 \\<open>u\\<noteq>v\\<close> V'"], ["proof (prove)\nusing this:\n  v' \\<noteq> v \\<Longrightarrow>\n  \\<forall>e\\<in>outgoing v'. augment_edge f (u, v) \\<Delta> e = f e\n  u \\<noteq> v\n  v' \\<in> V\n  v' \\<noteq> s\n  v' \\<noteq> t\n\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (outgoing v') = sum f (outgoing u)", "by auto"], ["proof (state)\nthis:\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v') = sum f (outgoing u)\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "have \"(v,u) \\<in> incoming u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, u) \\<in> incoming u", "using \\<open>(v,u)\\<in>E\\<close>"], ["proof (prove)\nusing this:\n  (v, u) \\<in> E\n\ngoal (1 subgoal):\n 1. (v, u) \\<in> incoming u", "by (auto simp: incoming_def)"], ["proof (state)\nthis:\n  (v, u) \\<in> incoming u\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "note AUX = sum.remove[OF _ this, simplified]"], ["proof (state)\nthis:\n  sum ?g (incoming u) = ?g (v, u) + sum ?g (incoming u - {(v, u)})\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "have A2: \"sum (augment_edge f (u,v) \\<Delta>) (incoming u) \n                  = sum f (incoming u) - \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (incoming u) =\n    sum f (incoming u) - \\<Delta>", "using AUX[of \"augment_edge f (u,v) \\<Delta>\"] AUX[of \"f\"]"], ["proof (prove)\nusing this:\n  sum (augment_edge f (u, v) \\<Delta>) (incoming u) =\n  augment_edge f (u, v) \\<Delta> (v, u) +\n  sum (augment_edge f (u, v) \\<Delta>) (incoming u - {(v, u)})\n  sum f (incoming u) = f (v, u) + sum f (incoming u - {(v, u)})\n\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (incoming u) =\n    sum f (incoming u) - \\<Delta>", "by auto"], ["proof (state)\nthis:\n  sum (augment_edge f (u, v) \\<Delta>) (incoming u) =\n  sum f (incoming u) - \\<Delta>\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "from A1 A2 \\<open>\\<Delta> \\<le> excess f u\\<close> no_deficient_nodes V'"], ["proof (chain)\npicking this:\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v') = sum f (outgoing u)\n  sum (augment_edge f (u, v) \\<Delta>) (incoming u) =\n  sum f (incoming u) - \\<Delta>\n  \\<Delta> \\<le> excess f u\n  \\<forall>v\\<in>V - {s, t}. sum f (outgoing v) \\<le> sum f (incoming v)\n  v' \\<in> V\n  v' \\<noteq> s\n  v' \\<noteq> t", "have ?thesis"], ["proof (prove)\nusing this:\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v') = sum f (outgoing u)\n  sum (augment_edge f (u, v) \\<Delta>) (incoming u) =\n  sum f (incoming u) - \\<Delta>\n  \\<Delta> \\<le> excess f u\n  \\<forall>v\\<in>V - {s, t}. sum f (outgoing v) \\<le> sum f (incoming v)\n  v' \\<in> V\n  v' \\<noteq> s\n  v' \\<noteq> t\n\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "unfolding excess_def"], ["proof (prove)\nusing this:\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v') = sum f (outgoing u)\n  sum (augment_edge f (u, v) \\<Delta>) (incoming u) =\n  sum f (incoming u) - \\<Delta>\n  \\<Delta> \\<le> sum f (incoming u) - sum f (outgoing u)\n  \\<forall>v\\<in>V - {s, t}. sum f (outgoing v) \\<le> sum f (incoming v)\n  v' \\<in> V\n  v' \\<noteq> s\n  v' \\<noteq> t\n\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "by auto"], ["proof (state)\nthis:\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "}"], ["proof (state)\nthis:\n  v' = u \\<Longrightarrow>\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "moreover"], ["proof (state)\nthis:\n  v' = u \\<Longrightarrow>\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "{"], ["proof (state)\nthis:\n  v' = u \\<Longrightarrow>\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "assume [simp]: \"v'=v\""], ["proof (state)\nthis:\n  v' = v\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "have \"sum (augment_edge f (u,v) \\<Delta>) (outgoing v') \n              \\<le> sum f (outgoing v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum f (outgoing v')", "apply (rule sum_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> outgoing v' \\<Longrightarrow>\n       augment_edge f (u, v) \\<Delta> i \\<le> f i", "using \\<open>0<\\<Delta>\\<close>"], ["proof (prove)\nusing this:\n  (0::'capacity) < \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> outgoing v' \\<Longrightarrow>\n       augment_edge f (u, v) \\<Delta> i \\<le> f i", "by (auto simp: augment_edge_def)"], ["proof (state)\nthis:\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum f (outgoing v')\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "also"], ["proof (state)\nthis:\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum f (outgoing v')\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "have \"\\<dots> \\<le> sum f (incoming v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (outgoing v') \\<le> sum f (incoming v)", "using no_deficient_nodes V'"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V - {s, t}. sum f (outgoing v) \\<le> sum f (incoming v)\n  v' \\<in> V\n  v' \\<noteq> s\n  v' \\<noteq> t\n\ngoal (1 subgoal):\n 1. sum f (outgoing v') \\<le> sum f (incoming v)", "by auto"], ["proof (state)\nthis:\n  sum f (outgoing v') \\<le> sum f (incoming v)\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "also"], ["proof (state)\nthis:\n  sum f (outgoing v') \\<le> sum f (incoming v)\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "have \"\\<dots> \\<le> sum (augment_edge f (u,v) \\<Delta>) (incoming v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (incoming v)\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "using 2 \\<open>u\\<noteq>v\\<close>"], ["proof (prove)\nusing this:\n  v' \\<noteq> u \\<Longrightarrow>\n  \\<forall>e\\<in>incoming v'. augment_edge f (u, v) \\<Delta> e = f e\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. sum f (incoming v)\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "by auto"], ["proof (state)\nthis:\n  sum f (incoming v)\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "finally"], ["proof (chain)\npicking this:\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "have ?thesis"], ["proof (prove)\nusing this:\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "by simp"], ["proof (state)\nthis:\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "}"], ["proof (state)\nthis:\n  v' = v \\<Longrightarrow>\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow>\n    sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>v' \\<noteq> u; v' \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n                    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n  v' = u \\<Longrightarrow>\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n  v' = v \\<Longrightarrow>\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>v' \\<noteq> u; v' \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n                    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n  v' = u \\<Longrightarrow>\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n  v' = v \\<Longrightarrow>\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n    \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')", "by blast"], ["proof (state)\nthis:\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (augment_edge f (u, v) \\<Delta>) (outgoing v')\n  \\<le> sum (augment_edge f (u, v) \\<Delta>) (incoming v')\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end \\<comment> \\<open>Network with Preflow\\<close>"], ["", "subsubsection \\<open>Push Operation\\<close>"], ["", "context Network \nbegin"], ["", "text \\<open>The push operation pushes as much flow as possible flow from an active \n  node over an admissible edge.\n\n  A node is called \\emph{active} if it has positive excess, and an edge \\<open>(u,v)\\<close>\n  of the residual graph is called admissible, if @{term \\<open>l u = l v + 1\\<close>}.\n\\<close>"], ["", "definition push_precond :: \"'capacity flow \\<Rightarrow> labeling \\<Rightarrow> edge \\<Rightarrow> bool\" \n  where \"push_precond f l \n    \\<equiv> \\<lambda>(u,v). excess f u > 0 \\<and> (u,v)\\<in>cfE_of f \\<and> l u = l v + 1\""], ["", "text \\<open>The maximum possible flow is determined by the available excess flow at \n  the source node and the available capacity of the edge.\\<close>"], ["", "definition push_effect :: \"'capacity flow \\<Rightarrow> edge \\<Rightarrow> 'capacity flow\" \n  where \"push_effect f \n    \\<equiv> \\<lambda>(u,v). augment_edge f (u,v) (min (excess f u) (cf_of f (u,v)))\""], ["", "lemma push_precondI[intro?]: \n  \"\\<lbrakk>excess f u > 0; (u,v)\\<in>cfE_of f; l u = l v + 1\\<rbrakk> \\<Longrightarrow> push_precond f l (u,v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(0::'capacity) < excess f u; (u, v) \\<in> cfE_of f;\n     l u = l v + 1\\<rbrakk>\n    \\<Longrightarrow> push_precond f l (u, v)", "unfolding push_precond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(0::'capacity) < excess f u; (u, v) \\<in> cfE_of f;\n     l u = l v + 1\\<rbrakk>\n    \\<Longrightarrow> case (u, v) of\n                      (u, v) \\<Rightarrow>\n                        (0::'capacity) < excess f u \\<and>\n                        (u, v) \\<in> cfE_of f \\<and> l u = l v + 1", "by auto"], ["", "subsubsection \\<open>Relabel Operation\\<close>"], ["", "text \\<open>\n  An active node (not the sink) without any outgoing admissible edges \n  can be relabeled. \n\\<close>"], ["", "definition relabel_precond :: \"'capacity flow \\<Rightarrow> labeling \\<Rightarrow> node \\<Rightarrow> bool\" \n  where \"relabel_precond f l u \n    \\<equiv> u\\<noteq>t \\<and> excess f u > 0 \\<and> (\\<forall>v. (u,v)\\<in>cfE_of f \\<longrightarrow> l u \\<noteq> l v + 1)\""], ["", "text \\<open>The new label is computed from the neighbour's labels, to be the minimum\n  value that will create an outgoing admissible edge.\\<close>"], ["", "definition relabel_effect :: \"'capacity flow \\<Rightarrow> labeling \\<Rightarrow> node \\<Rightarrow> labeling\"\n  where \"relabel_effect f l u \n    \\<equiv> l( u := Min { l v | v. (u,v)\\<in>cfE_of f } + 1 )\""], ["", "subsubsection \\<open>Initialization\\<close>"], ["", "(* TODO: The algorithm can be initialized with other labelings ... \n  reflect this in abstract complexity/correctness theorem.*)"], ["", "text \\<open>\n  The initial preflow exhausts all outgoing edges of the source node.\n\\<close>"], ["", "definition \"pp_init_f \\<equiv> \\<lambda>(u,v). if (u=s) then c (u,v) else 0\""], ["", "text \\<open>\n  The initial labeling labels the source with \\<open>|V|\\<close>, and all other nodes\n  with \\<open>0\\<close>.\n\\<close>"], ["", "definition \"pp_init_l \\<equiv> (\\<lambda>x. 0)(s := card V)\""], ["", "end \\<comment> \\<open>Network\\<close>"], ["", "subsection \\<open>Abstract Correctness\\<close>"], ["", "text \\<open>We formalize the abstract correctness argument of the algorithm. \n  It consists of two parts:\n    \\<^enum> Execution of push and relabel operations maintain a valid labeling\n    \\<^enum> If no push or relabel operations can be executed, the preflow is actually \n      a flow.\n\n  This section corresponds to the proof of \\cormen{26.18}.\n\\<close>"], ["", "subsubsection \\<open>Maintenance of Invariants\\<close>"], ["", "context Network \nbegin"], ["", "lemma pp_init_invar: \"Labeling c s t pp_init_f pp_init_l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Labeling c s t pp_init_f pp_init_l", "apply (unfold_locales;\n      ((auto simp: pp_init_f_def pp_init_l_def cap_non_negative; fail) \n        | (intro ballI)?))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       v \\<in> V - {s, t} \\<Longrightarrow>\n       sum pp_init_f (outgoing v) \\<le> sum pp_init_f (incoming v)\n 2. \\<And>u v.\n       (u, v) \\<in> cfE_of pp_init_f \\<Longrightarrow>\n       pp_init_l u \\<le> pp_init_l v + 1", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       v \\<in> V - {s, t} \\<Longrightarrow>\n       sum pp_init_f (outgoing v) \\<le> sum pp_init_f (incoming v)\n 2. \\<And>u v.\n       (u, v) \\<in> cfE_of pp_init_f \\<Longrightarrow>\n       pp_init_l u \\<le> pp_init_l v + 1", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       v \\<in> V - {s, t} \\<Longrightarrow>\n       sum pp_init_f (outgoing v) \\<le> sum pp_init_f (incoming v)\n 2. \\<And>u v.\n       (u, v) \\<in> cfE_of pp_init_f \\<Longrightarrow>\n       pp_init_l u \\<le> pp_init_l v + 1", "assume \"v\\<in>V - {s,t}\""], ["proof (state)\nthis:\n  v \\<in> V - {s, t}\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       v \\<in> V - {s, t} \\<Longrightarrow>\n       sum pp_init_f (outgoing v) \\<le> sum pp_init_f (incoming v)\n 2. \\<And>u v.\n       (u, v) \\<in> cfE_of pp_init_f \\<Longrightarrow>\n       pp_init_l u \\<le> pp_init_l v + 1", "hence \"\\<forall>e\\<in>outgoing v. pp_init_f e = 0\""], ["proof (prove)\nusing this:\n  v \\<in> V - {s, t}\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>outgoing v. pp_init_f e = (0::'capacity)", "by (auto simp: outgoing_def pp_init_f_def)"], ["proof (state)\nthis:\n  \\<forall>e\\<in>outgoing v. pp_init_f e = (0::'capacity)\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       v \\<in> V - {s, t} \\<Longrightarrow>\n       sum pp_init_f (outgoing v) \\<le> sum pp_init_f (incoming v)\n 2. \\<And>u v.\n       (u, v) \\<in> cfE_of pp_init_f \\<Longrightarrow>\n       pp_init_l u \\<le> pp_init_l v + 1", "hence [simp]: \"sum pp_init_f (outgoing v) = 0\""], ["proof (prove)\nusing this:\n  \\<forall>e\\<in>outgoing v. pp_init_f e = (0::'capacity)\n\ngoal (1 subgoal):\n 1. sum pp_init_f (outgoing v) = (0::'capacity)", "by auto"], ["proof (state)\nthis:\n  sum pp_init_f (outgoing v) = (0::'capacity)\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       v \\<in> V - {s, t} \\<Longrightarrow>\n       sum pp_init_f (outgoing v) \\<le> sum pp_init_f (incoming v)\n 2. \\<And>u v.\n       (u, v) \\<in> cfE_of pp_init_f \\<Longrightarrow>\n       pp_init_l u \\<le> pp_init_l v + 1", "have \"0 \\<le> pp_init_f e\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'capacity) \\<le> pp_init_f e", "by (auto simp: pp_init_f_def cap_non_negative split: prod.split)"], ["proof (state)\nthis:\n  (0::'capacity) \\<le> pp_init_f ?e\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       v \\<in> V - {s, t} \\<Longrightarrow>\n       sum pp_init_f (outgoing v) \\<le> sum pp_init_f (incoming v)\n 2. \\<And>u v.\n       (u, v) \\<in> cfE_of pp_init_f \\<Longrightarrow>\n       pp_init_l u \\<le> pp_init_l v + 1", "from sum_bounded_below[of \"incoming v\" 0 pp_init_f, OF this]"], ["proof (chain)\npicking this:\n  of_nat (card (incoming v)) * (0::'capacity)\n  \\<le> sum pp_init_f (incoming v)", "have \"0 \\<le> sum pp_init_f (incoming v)\""], ["proof (prove)\nusing this:\n  of_nat (card (incoming v)) * (0::'capacity)\n  \\<le> sum pp_init_f (incoming v)\n\ngoal (1 subgoal):\n 1. (0::'capacity) \\<le> sum pp_init_f (incoming v)", "by auto"], ["proof (state)\nthis:\n  (0::'capacity) \\<le> sum pp_init_f (incoming v)\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       v \\<in> V - {s, t} \\<Longrightarrow>\n       sum pp_init_f (outgoing v) \\<le> sum pp_init_f (incoming v)\n 2. \\<And>u v.\n       (u, v) \\<in> cfE_of pp_init_f \\<Longrightarrow>\n       pp_init_l u \\<le> pp_init_l v + 1", "thus \"sum pp_init_f (outgoing v) \\<le> sum pp_init_f (incoming v)\""], ["proof (prove)\nusing this:\n  (0::'capacity) \\<le> sum pp_init_f (incoming v)\n\ngoal (1 subgoal):\n 1. sum pp_init_f (outgoing v) \\<le> sum pp_init_f (incoming v)", "by auto"], ["proof (state)\nthis:\n  sum pp_init_f (outgoing v) \\<le> sum pp_init_f (incoming v)\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       (u, v) \\<in> cfE_of pp_init_f \\<Longrightarrow>\n       pp_init_l u \\<le> pp_init_l v + 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       (u, v) \\<in> cfE_of pp_init_f \\<Longrightarrow>\n       pp_init_l u \\<le> pp_init_l v + 1", "fix u v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       (u, v) \\<in> cfE_of pp_init_f \\<Longrightarrow>\n       pp_init_l u \\<le> pp_init_l v + 1", "assume \"(u, v) \\<in> Graph.E (residualGraph c pp_init_f)\""], ["proof (state)\nthis:\n  (u, v) \\<in> cfE_of pp_init_f\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       (u, v) \\<in> cfE_of pp_init_f \\<Longrightarrow>\n       pp_init_l u \\<le> pp_init_l v + 1", "thus \"pp_init_l u \\<le> pp_init_l v + 1\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> cfE_of pp_init_f\n\ngoal (1 subgoal):\n 1. pp_init_l u \\<le> pp_init_l v + 1", "unfolding pp_init_l_def Graph.E_def pp_init_f_def residualGraph_def"], ["proof (prove)\nusing this:\n  (u, v)\n  \\<in> {(u, v).\n         (case (u, v) of\n          (u, v) \\<Rightarrow>\n            if (u, v) \\<in> {(u, v). c (u, v) \\<noteq> (0::'capacity)}\n            then c (u, v) -\n                 (case (u, v) of\n                  (u, v) \\<Rightarrow>\n                    if u = s then c (u, v) else (0::'capacity))\n            else if (v, u) \\<in> {(u, v). c (u, v) \\<noteq> (0::'capacity)}\n                 then case (v, u) of\n                      (u, v) \\<Rightarrow>\n                        if u = s then c (u, v) else (0::'capacity)\n                 else (0::'capacity)) \\<noteq>\n         (0::'capacity)}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. 0)(s := card V)) u\n    \\<le> ((\\<lambda>x. 0)(s := card V)) v + 1", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  pp_init_l u \\<le> pp_init_l v + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pp_init_f_preflow: \"NPreflow c s t pp_init_f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NPreflow c s t pp_init_f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. NPreflow c s t pp_init_f", "from pp_init_invar"], ["proof (chain)\npicking this:\n  Labeling c s t pp_init_f pp_init_l", "interpret Labeling c s t pp_init_f pp_init_l"], ["proof (prove)\nusing this:\n  Labeling c s t pp_init_f pp_init_l\n\ngoal (1 subgoal):\n 1. Labeling c s t pp_init_f pp_init_l", "."], ["proof (state)\ngoal (1 subgoal):\n 1. NPreflow c s t pp_init_f", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. NPreflow c s t pp_init_f", "by unfold_locales"], ["proof (state)\nthis:\n  NPreflow c s t pp_init_f\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>Network\\<close>"], ["", "context Labeling\nbegin"], ["", "text \\<open>Push operations preserve a valid labeling~\\cormen{26.16}.\\<close>"], ["", "theorem push_pres_Labeling:\n  assumes \"push_precond f l e\"\n  shows \"Labeling c s t (push_effect f e) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Labeling c s t (push_effect f e) l", "unfolding push_effect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Labeling c s t\n     (case e of\n      (u, v) \\<Rightarrow>\n        augment_edge f (u, v) (min (excess f u) (cf (u, v))))\n     l", "proof (cases e; clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       e = (a, b) \\<Longrightarrow>\n       Labeling c s t (augment_edge f (a, b) (min (excess f a) (cf (a, b))))\n        l", "fix u v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       e = (a, b) \\<Longrightarrow>\n       Labeling c s t (augment_edge f (a, b) (min (excess f a) (cf (a, b))))\n        l", "assume [simp]: \"e=(u,v)\""], ["proof (state)\nthis:\n  e = (u, v)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       e = (a, b) \\<Longrightarrow>\n       Labeling c s t (augment_edge f (a, b) (min (excess f a) (cf (a, b))))\n        l", "let ?f' = \"(augment_edge f (u, v) (min (excess f u) (cf (u, v))))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       e = (a, b) \\<Longrightarrow>\n       Labeling c s t (augment_edge f (a, b) (min (excess f a) (cf (a, b))))\n        l", "from assms"], ["proof (chain)\npicking this:\n  push_precond f l e", "have   \n    ACTIVE: \"excess f u > 0\"\n    and EDGE: \"(u,v)\\<in>cf.E\"  \n    and ADM: \"l u = l v + 1\""], ["proof (prove)\nusing this:\n  push_precond f l e\n\ngoal (1 subgoal):\n 1. (0::'a) < excess f u &&& (u, v) \\<in> cf.E &&& l u = l v + 1", "unfolding push_precond_def"], ["proof (prove)\nusing this:\n  case e of\n  (u, v) \\<Rightarrow>\n    (0::'a) < excess f u \\<and> (u, v) \\<in> cf.E \\<and> l u = l v + 1\n\ngoal (1 subgoal):\n 1. (0::'a) < excess f u &&& (u, v) \\<in> cf.E &&& l u = l v + 1", "by auto"], ["proof (state)\nthis:\n  (0::'a) < excess f u\n  (u, v) \\<in> cf.E\n  l u = l v + 1\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       e = (a, b) \\<Longrightarrow>\n       Labeling c s t (augment_edge f (a, b) (min (excess f a) (cf (a, b))))\n        l", "interpret cf': Preflow c s t ?f'"], ["proof (prove)\ngoal (1 subgoal):\n 1. Preflow c s t (augment_edge f (u, v) (min (excess f u) (cf (u, v))))", "apply (rule augment_edge_preflow_preserve)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (0::'a) \\<le> min (excess f u) (cf (u, v))\n 2. min (excess f u) (cf (u, v)) \\<le> cf (u, v)\n 3. min (excess f u) (cf (u, v)) \\<le> excess f u", "using ACTIVE resE_nonNegative"], ["proof (prove)\nusing this:\n  (0::'a) < excess f u\n  (0::'a) \\<le> cf ?e\n\ngoal (3 subgoals):\n 1. (0::'a) \\<le> min (excess f u) (cf (u, v))\n 2. min (excess f u) (cf (u, v)) \\<le> cf (u, v)\n 3. min (excess f u) (cf (u, v)) \\<le> excess f u", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       e = (a, b) \\<Longrightarrow>\n       Labeling c s t (augment_edge f (a, b) (min (excess f a) (cf (a, b))))\n        l", "show \"Labeling c s t ?f' l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Labeling c s t (augment_edge f (u, v) (min (excess f u) (cf (u, v)))) l", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ua va.\n       (ua, va)\n       \\<in> cfE_of\n              (augment_edge f (u, v)\n                (min (excess f u) (cf (u, v)))) \\<Longrightarrow>\n       l ua \\<le> l va + 1\n 2. l s = card V\n 3. l t = 0", "using valid"], ["proof (prove)\nusing this:\n  (?u, ?v) \\<in> cf.E \\<Longrightarrow> l ?u \\<le> l ?v + 1\n\ngoal (3 subgoals):\n 1. \\<And>ua va.\n       (ua, va)\n       \\<in> cfE_of\n              (augment_edge f (u, v)\n                (min (excess f u) (cf (u, v)))) \\<Longrightarrow>\n       l ua \\<le> l va + 1\n 2. l s = card V\n 3. l t = 0", "using cfE_augment_ss[OF EDGE] ADM"], ["proof (prove)\nusing this:\n  (?u, ?v) \\<in> cf.E \\<Longrightarrow> l ?u \\<le> l ?v + 1\n  cfE_of (augment_edge f (u, v) ?\\<Delta>) \\<subseteq> insert (v, u) cf.E\n  l u = l v + 1\n\ngoal (3 subgoals):\n 1. \\<And>ua va.\n       (ua, va)\n       \\<in> cfE_of\n              (augment_edge f (u, v)\n                (min (excess f u) (cf (u, v)))) \\<Longrightarrow>\n       l ua \\<le> l va + 1\n 2. l s = card V\n 3. l t = 0", "apply (fastforce)"], ["proof (prove)\ngoal (2 subgoals):\n 1. l s = card V\n 2. l t = 0", "by auto"], ["proof (state)\nthis:\n  Labeling c s t (augment_edge f (u, v) (min (excess f u) (cf (u, v)))) l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_min_cf_outgoing[simp, intro!]: \"finite {l v |v. (u, v) \\<in> cf.E}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {l v |v. (u, v) \\<in> cf.E}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {l v |v. (u, v) \\<in> cf.E}", "have \"{l v |v. (u, v) \\<in> cf.E} = l`snd`cf.outgoing u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l v |v. (u, v) \\<in> cf.E} = l ` snd ` cf.outgoing u", "by (auto simp: cf.outgoing_def)"], ["proof (state)\nthis:\n  {l v |v. (u, v) \\<in> cf.E} = l ` snd ` cf.outgoing u\n\ngoal (1 subgoal):\n 1. finite {l v |v. (u, v) \\<in> cf.E}", "moreover"], ["proof (state)\nthis:\n  {l v |v. (u, v) \\<in> cf.E} = l ` snd ` cf.outgoing u\n\ngoal (1 subgoal):\n 1. finite {l v |v. (u, v) \\<in> cf.E}", "have \"finite (l`snd`cf.outgoing u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (l ` snd ` cf.outgoing u)", "by auto"], ["proof (state)\nthis:\n  finite (l ` snd ` cf.outgoing u)\n\ngoal (1 subgoal):\n 1. finite {l v |v. (u, v) \\<in> cf.E}", "ultimately"], ["proof (chain)\npicking this:\n  {l v |v. (u, v) \\<in> cf.E} = l ` snd ` cf.outgoing u\n  finite (l ` snd ` cf.outgoing u)", "show ?thesis"], ["proof (prove)\nusing this:\n  {l v |v. (u, v) \\<in> cf.E} = l ` snd ` cf.outgoing u\n  finite (l ` snd ` cf.outgoing u)\n\ngoal (1 subgoal):\n 1. finite {l v |v. (u, v) \\<in> cf.E}", "by auto"], ["proof (state)\nthis:\n  finite {l v |v. (u, v) \\<in> cf.E}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Relabel operations preserve a valid labeling~\\cormen{26.16}. \n  Moreover, they increase the label of the relabeled node~\\cormen{26.15}.\n\\<close>"], ["", "theorem \n  assumes PRE: \"relabel_precond f l u\"\n  shows relabel_increase_u: \"relabel_effect f l u u > l u\" (is ?G1)\n    and relabel_pres_Labeling: \"Labeling c s t f (relabel_effect f l u)\" (is ?G2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. l u < relabel_effect f l u u &&& Labeling c s t f (relabel_effect f l u)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. l u < relabel_effect f l u u\n 2. Labeling c s t f (relabel_effect f l u)", "from PRE"], ["proof (chain)\npicking this:\n  relabel_precond f l u", "have  \n        NOT_SINK: \"u\\<noteq>t\"\n    and ACTIVE: \"excess f u > 0\"\n    and NO_ADM: \"\\<And>v. (u,v)\\<in>cf.E \\<Longrightarrow> l u \\<noteq> l v + 1\""], ["proof (prove)\nusing this:\n  relabel_precond f l u\n\ngoal (1 subgoal):\n 1. u \\<noteq> t &&&\n    (0::'a) < excess f u &&&\n    (\\<And>v. (u, v) \\<in> cf.E \\<Longrightarrow> l u \\<noteq> l v + 1)", "unfolding relabel_precond_def"], ["proof (prove)\nusing this:\n  u \\<noteq> t \\<and>\n  (0::'a) < excess f u \\<and>\n  (\\<forall>v. (u, v) \\<in> cf.E \\<longrightarrow> l u \\<noteq> l v + 1)\n\ngoal (1 subgoal):\n 1. u \\<noteq> t &&&\n    (0::'a) < excess f u &&&\n    (\\<And>v. (u, v) \\<in> cf.E \\<Longrightarrow> l u \\<noteq> l v + 1)", "by auto"], ["proof (state)\nthis:\n  u \\<noteq> t\n  (0::'a) < excess f u\n  (u, ?v) \\<in> cf.E \\<Longrightarrow> l u \\<noteq> l ?v + 1\n\ngoal (2 subgoals):\n 1. l u < relabel_effect f l u u\n 2. Labeling c s t f (relabel_effect f l u)", "from ACTIVE"], ["proof (chain)\npicking this:\n  (0::'a) < excess f u", "have [simp]: \"s\\<noteq>u\""], ["proof (prove)\nusing this:\n  (0::'a) < excess f u\n\ngoal (1 subgoal):\n 1. s \\<noteq> u", "using excess_s_non_pos"], ["proof (prove)\nusing this:\n  (0::'a) < excess f u\n  excess f s \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. s \\<noteq> u", "by auto"], ["proof (state)\nthis:\n  s \\<noteq> u\n\ngoal (2 subgoals):\n 1. l u < relabel_effect f l u u\n 2. Labeling c s t f (relabel_effect f l u)", "from active_has_cf_outgoing[OF ACTIVE]"], ["proof (chain)\npicking this:\n  cf.outgoing u \\<noteq> {}", "have [simp]: \"\\<exists>v. (u, v) \\<in> cf.E\""], ["proof (prove)\nusing this:\n  cf.outgoing u \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>v. (u, v) \\<in> cf.E", "by (auto simp: cf.outgoing_def)"], ["proof (state)\nthis:\n  \\<exists>v. (u, v) \\<in> cf.E\n\ngoal (2 subgoals):\n 1. l u < relabel_effect f l u u\n 2. Labeling c s t f (relabel_effect f l u)", "from NO_ADM valid"], ["proof (chain)\npicking this:\n  (u, ?v) \\<in> cf.E \\<Longrightarrow> l u \\<noteq> l ?v + 1\n  (?u, ?v) \\<in> cf.E \\<Longrightarrow> l ?u \\<le> l ?v + 1", "have \"l u < l v + 1\" if \"(u,v)\\<in>cf.E\" for v"], ["proof (prove)\nusing this:\n  (u, ?v) \\<in> cf.E \\<Longrightarrow> l u \\<noteq> l ?v + 1\n  (?u, ?v) \\<in> cf.E \\<Longrightarrow> l ?u \\<le> l ?v + 1\n\ngoal (1 subgoal):\n 1. l u < l v + 1", "by (simp add: nat_less_le that)"], ["proof (state)\nthis:\n  (u, ?v) \\<in> cf.E \\<Longrightarrow> l u < l ?v + 1\n\ngoal (2 subgoals):\n 1. l u < relabel_effect f l u u\n 2. Labeling c s t f (relabel_effect f l u)", "hence LU_INCR: \"l u \\<le> Min { l v | v. (u,v)\\<in>cf.E }\""], ["proof (prove)\nusing this:\n  (u, ?v) \\<in> cf.E \\<Longrightarrow> l u < l ?v + 1\n\ngoal (1 subgoal):\n 1. l u \\<le> Min {l v |v. (u, v) \\<in> cf.E}", "by (auto simp: less_Suc_eq_le)"], ["proof (state)\nthis:\n  l u \\<le> Min {l v |v. (u, v) \\<in> cf.E}\n\ngoal (2 subgoals):\n 1. l u < relabel_effect f l u u\n 2. Labeling c s t f (relabel_effect f l u)", "with valid"], ["proof (chain)\npicking this:\n  (?u, ?v) \\<in> cf.E \\<Longrightarrow> l ?u \\<le> l ?v + 1\n  l u \\<le> Min {l v |v. (u, v) \\<in> cf.E}", "have \"\\<forall>u'. (u',u)\\<in>cf.E \\<longrightarrow> l u' \\<le> Min { l v | v. (u,v)\\<in>cf.E } + 1\""], ["proof (prove)\nusing this:\n  (?u, ?v) \\<in> cf.E \\<Longrightarrow> l ?u \\<le> l ?v + 1\n  l u \\<le> Min {l v |v. (u, v) \\<in> cf.E}\n\ngoal (1 subgoal):\n 1. \\<forall>u'.\n       (u', u) \\<in> cf.E \\<longrightarrow>\n       l u' \\<le> Min {l v |v. (u, v) \\<in> cf.E} + 1", "by (smt ab_semigroup_add_class.add.commute add_le_cancel_left le_trans)"], ["proof (state)\nthis:\n  \\<forall>u'.\n     (u', u) \\<in> cf.E \\<longrightarrow>\n     l u' \\<le> Min {l v |v. (u, v) \\<in> cf.E} + 1\n\ngoal (2 subgoals):\n 1. l u < relabel_effect f l u u\n 2. Labeling c s t f (relabel_effect f l u)", "moreover"], ["proof (state)\nthis:\n  \\<forall>u'.\n     (u', u) \\<in> cf.E \\<longrightarrow>\n     l u' \\<le> Min {l v |v. (u, v) \\<in> cf.E} + 1\n\ngoal (2 subgoals):\n 1. l u < relabel_effect f l u u\n 2. Labeling c s t f (relabel_effect f l u)", "have \"\\<forall>v. (u,v)\\<in>cf.E \\<longrightarrow> Min { l v | v. (u,v)\\<in>cf.E } + 1 \\<le> l v + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v.\n       (u, v) \\<in> cf.E \\<longrightarrow>\n       Min {l v |v. (u, v) \\<in> cf.E} + 1 \\<le> l v + 1", "using Min_le"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?A; ?x \\<in> ?A\\<rbrakk> \\<Longrightarrow> Min ?A \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<forall>v.\n       (u, v) \\<in> cf.E \\<longrightarrow>\n       Min {l v |v. (u, v) \\<in> cf.E} + 1 \\<le> l v + 1", "by auto"], ["proof (state)\nthis:\n  \\<forall>v.\n     (u, v) \\<in> cf.E \\<longrightarrow>\n     Min {l v |v. (u, v) \\<in> cf.E} + 1 \\<le> l v + 1\n\ngoal (2 subgoals):\n 1. l u < relabel_effect f l u u\n 2. Labeling c s t f (relabel_effect f l u)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>u'.\n     (u', u) \\<in> cf.E \\<longrightarrow>\n     l u' \\<le> Min {l v |v. (u, v) \\<in> cf.E} + 1\n  \\<forall>v.\n     (u, v) \\<in> cf.E \\<longrightarrow>\n     Min {l v |v. (u, v) \\<in> cf.E} + 1 \\<le> l v + 1", "show ?G1 ?G2"], ["proof (prove)\nusing this:\n  \\<forall>u'.\n     (u', u) \\<in> cf.E \\<longrightarrow>\n     l u' \\<le> Min {l v |v. (u, v) \\<in> cf.E} + 1\n  \\<forall>v.\n     (u, v) \\<in> cf.E \\<longrightarrow>\n     Min {l v |v. (u, v) \\<in> cf.E} + 1 \\<le> l v + 1\n\ngoal (1 subgoal):\n 1. l u < relabel_effect f l u u &&& Labeling c s t f (relabel_effect f l u)", "unfolding relabel_effect_def"], ["proof (prove)\nusing this:\n  \\<forall>u'.\n     (u', u) \\<in> cf.E \\<longrightarrow>\n     l u' \\<le> Min {l v |v. (u, v) \\<in> cf.E} + 1\n  \\<forall>v.\n     (u, v) \\<in> cf.E \\<longrightarrow>\n     Min {l v |v. (u, v) \\<in> cf.E} + 1 \\<le> l v + 1\n\ngoal (1 subgoal):\n 1. l u < (l(u := Min {l v |v. (u, v) \\<in> cf.E} + 1)) u &&&\n    Labeling c s t f (l(u := Min {l v |v. (u, v) \\<in> cf.E} + 1))", "apply (clarsimp_all simp: PRE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>u'.\n                (u', u) \\<in> cf.E \\<longrightarrow>\n                l u' \\<le> Suc (Min {l v |v. (u, v) \\<in> cf.E});\n     \\<forall>v.\n        (u, v) \\<in> cf.E \\<longrightarrow>\n        Min {l v |v. (u, v) \\<in> cf.E} \\<le> l v\\<rbrakk>\n    \\<Longrightarrow> l u < Suc (Min {l v |v. (u, v) \\<in> cf.E})\n 2. \\<lbrakk>\\<forall>u'.\n                (u', u) \\<in> cf.E \\<longrightarrow>\n                l u' \\<le> Suc (Min {l v |v. (u, v) \\<in> cf.E});\n     \\<forall>v.\n        (u, v) \\<in> cf.E \\<longrightarrow>\n        Min {l v |v. (u, v) \\<in> cf.E} \\<le> l v\\<rbrakk>\n    \\<Longrightarrow> Labeling c s t f\n                       (l(u := Suc (Min {l v |v. (u, v) \\<in> cf.E})))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>u'.\n                (u', u) \\<in> cf.E \\<longrightarrow>\n                l u' \\<le> Suc (Min {l v |v. (u, v) \\<in> cf.E});\n     \\<forall>v.\n        (u, v) \\<in> cf.E \\<longrightarrow>\n        Min {l v |v. (u, v) \\<in> cf.E} \\<le> l v\\<rbrakk>\n    \\<Longrightarrow> l u < Suc (Min {l v |v. (u, v) \\<in> cf.E})", "using LU_INCR"], ["proof (prove)\nusing this:\n  l u \\<le> Min {l v |v. (u, v) \\<in> cf.E}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>u'.\n                (u', u) \\<in> cf.E \\<longrightarrow>\n                l u' \\<le> Suc (Min {l v |v. (u, v) \\<in> cf.E});\n     \\<forall>v.\n        (u, v) \\<in> cf.E \\<longrightarrow>\n        Min {l v |v. (u, v) \\<in> cf.E} \\<le> l v\\<rbrakk>\n    \\<Longrightarrow> l u < Suc (Min {l v |v. (u, v) \\<in> cf.E})", "by (simp add: less_Suc_eq_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>u'.\n                (u', u) \\<in> cf.E \\<longrightarrow>\n                l u' \\<le> Suc (Min {l v |v. (u, v) \\<in> cf.E});\n     \\<forall>v.\n        (u, v) \\<in> cf.E \\<longrightarrow>\n        Min {l v |v. (u, v) \\<in> cf.E} \\<le> l v\\<rbrakk>\n    \\<Longrightarrow> Labeling c s t f\n                       (l(u := Suc (Min {l v |v. (u, v) \\<in> cf.E})))", "apply (unfold_locales)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ua v.\n       \\<lbrakk>\\<forall>u'.\n                   (u', u) \\<in> cf.E \\<longrightarrow>\n                   l u' \\<le> Suc (Min {l v |v. (u, v) \\<in> cf.E});\n        \\<forall>v.\n           (u, v) \\<in> cf.E \\<longrightarrow>\n           Min {l v |v. (u, v) \\<in> cf.E} \\<le> l v;\n        (ua, v) \\<in> cf.E\\<rbrakk>\n       \\<Longrightarrow> (l(u := Suc (Min {l v |v. (u, v) \\<in> cf.E}))) ua\n                         \\<le> (l(u := Suc\n  (Min {l v |v. (u, v) \\<in> cf.E})))\n                                v +\n                               1\n 2. \\<lbrakk>\\<forall>u'.\n                (u', u) \\<in> cf.E \\<longrightarrow>\n                l u' \\<le> Suc (Min {l v |v. (u, v) \\<in> cf.E});\n     \\<forall>v.\n        (u, v) \\<in> cf.E \\<longrightarrow>\n        Min {l v |v. (u, v) \\<in> cf.E} \\<le> l v\\<rbrakk>\n    \\<Longrightarrow> (l(u := Suc (Min {l v |v. (u, v) \\<in> cf.E}))) s =\n                      card V\n 3. \\<lbrakk>\\<forall>u'.\n                (u', u) \\<in> cf.E \\<longrightarrow>\n                l u' \\<le> Suc (Min {l v |v. (u, v) \\<in> cf.E});\n     \\<forall>v.\n        (u, v) \\<in> cf.E \\<longrightarrow>\n        Min {l v |v. (u, v) \\<in> cf.E} \\<le> l v\\<rbrakk>\n    \\<Longrightarrow> (l(u := Suc (Min {l v |v. (u, v) \\<in> cf.E}))) t = 0", "subgoal for u' v'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>u'.\n                (u', u) \\<in> cf.E \\<longrightarrow>\n                l u' \\<le> Suc (Min {l v |v. (u, v) \\<in> cf.E});\n     \\<forall>v.\n        (u, v) \\<in> cf.E \\<longrightarrow>\n        Min {l v |v. (u, v) \\<in> cf.E} \\<le> l v;\n     (u', v') \\<in> cf.E\\<rbrakk>\n    \\<Longrightarrow> (l(u := Suc (Min {l v |v. (u, v) \\<in> cf.E}))) u'\n                      \\<le> (l(u := Suc (Min {l v |v. (u, v) \\<in> cf.E})))\n                             v' +\n                            1", "using valid"], ["proof (prove)\nusing this:\n  (?u, ?v) \\<in> cf.E \\<Longrightarrow> l ?u \\<le> l ?v + 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>u'.\n                (u', u) \\<in> cf.E \\<longrightarrow>\n                l u' \\<le> Suc (Min {l v |v. (u, v) \\<in> cf.E});\n     \\<forall>v.\n        (u, v) \\<in> cf.E \\<longrightarrow>\n        Min {l v |v. (u, v) \\<in> cf.E} \\<le> l v;\n     (u', v') \\<in> cf.E\\<rbrakk>\n    \\<Longrightarrow> (l(u := Suc (Min {l v |v. (u, v) \\<in> cf.E}))) u'\n                      \\<le> (l(u := Suc (Min {l v |v. (u, v) \\<in> cf.E})))\n                             v' +\n                            1", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>u'.\n                (u', u) \\<in> cf.E \\<longrightarrow>\n                l u' \\<le> Suc (Min {l v |v. (u, v) \\<in> cf.E});\n     \\<forall>v.\n        (u, v) \\<in> cf.E \\<longrightarrow>\n        Min {l v |v. (u, v) \\<in> cf.E} \\<le> l v\\<rbrakk>\n    \\<Longrightarrow> (l(u := Suc (Min {l v |v. (u, v) \\<in> cf.E}))) s =\n                      card V\n 2. \\<lbrakk>\\<forall>u'.\n                (u', u) \\<in> cf.E \\<longrightarrow>\n                l u' \\<le> Suc (Min {l v |v. (u, v) \\<in> cf.E});\n     \\<forall>v.\n        (u, v) \\<in> cf.E \\<longrightarrow>\n        Min {l v |v. (u, v) \\<in> cf.E} \\<le> l v\\<rbrakk>\n    \\<Longrightarrow> (l(u := Suc (Min {l v |v. (u, v) \\<in> cf.E}))) t = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>u'.\n                (u', u) \\<in> cf.E \\<longrightarrow>\n                l u' \\<le> Suc (Min {l v |v. (u, v) \\<in> cf.E});\n     \\<forall>v.\n        (u, v) \\<in> cf.E \\<longrightarrow>\n        Min {l v |v. (u, v) \\<in> cf.E} \\<le> l v\\<rbrakk>\n    \\<Longrightarrow> (l(u := Suc (Min {l v |v. (u, v) \\<in> cf.E}))) s =\n                      card V", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>u'.\n                (u', u) \\<in> cf.E \\<longrightarrow>\n                l u' \\<le> Suc (Min {l v |v. (u, v) \\<in> cf.E});\n     \\<forall>v.\n        (u, v) \\<in> cf.E \\<longrightarrow>\n        Min {l v |v. (u, v) \\<in> cf.E} \\<le> l v\\<rbrakk>\n    \\<Longrightarrow> (l(u := Suc (Min {l v |v. (u, v) \\<in> cf.E}))) t = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>u'.\n                (u', u) \\<in> cf.E \\<longrightarrow>\n                l u' \\<le> Suc (Min {l v |v. (u, v) \\<in> cf.E});\n     \\<forall>v.\n        (u, v) \\<in> cf.E \\<longrightarrow>\n        Min {l v |v. (u, v) \\<in> cf.E} \\<le> l v\\<rbrakk>\n    \\<Longrightarrow> (l(u := Suc (Min {l v |v. (u, v) \\<in> cf.E}))) t = 0", "using NOT_SINK"], ["proof (prove)\nusing this:\n  u \\<noteq> t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>u'.\n                (u', u) \\<in> cf.E \\<longrightarrow>\n                l u' \\<le> Suc (Min {l v |v. (u, v) \\<in> cf.E});\n     \\<forall>v.\n        (u, v) \\<in> cf.E \\<longrightarrow>\n        Min {l v |v. (u, v) \\<in> cf.E} \\<le> l v\\<rbrakk>\n    \\<Longrightarrow> (l(u := Suc (Min {l v |v. (u, v) \\<in> cf.E}))) t = 0", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  l u < relabel_effect f l u u\n  Labeling c s t f (relabel_effect f l u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma relabel_preserve_other: \"u\\<noteq>v \\<Longrightarrow> relabel_effect f l u v = l v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow> relabel_effect f l u v = l v", "unfolding relabel_effect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    (l(u := Min {l v |v. (u, v) \\<in> cf.E} + 1)) v = l v", "by auto"], ["", "subsubsection \\<open>Maxflow on Termination\\<close>"], ["", "text \\<open>\n  If no push or relabel operations can be performed any more,\n  we have arrived at a maximal flow.\n\\<close>"], ["", "theorem push_relabel_term_imp_maxflow:\n  assumes no_push: \"\\<forall>(u,v)\\<in>cf.E. \\<not>push_precond f l (u,v)\"\n  assumes no_relabel: \"\\<forall>u. \\<not>relabel_precond f l u\"\n  shows \"isMaxFlow f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isMaxFlow f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. isMaxFlow f", "from assms"], ["proof (chain)\npicking this:\n  \\<forall>(u, v)\\<in>cf.E. \\<not> push_precond f l (u, v)\n  \\<forall>u. \\<not> relabel_precond f l u", "have \"\\<forall>u\\<in>V-{t}. excess f u \\<le> 0\""], ["proof (prove)\nusing this:\n  \\<forall>(u, v)\\<in>cf.E. \\<not> push_precond f l (u, v)\n  \\<forall>u. \\<not> relabel_precond f l u\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>V - {t}. excess f u \\<le> (0::'a)", "unfolding push_precond_def relabel_precond_def"], ["proof (prove)\nusing this:\n  \\<forall>(u, v)\\<in>cf.E.\n     \\<not> (case (u, v) of\n             (u, v) \\<Rightarrow>\n               (0::'a) < excess f u \\<and>\n               (u, v) \\<in> cf.E \\<and> l u = l v + 1)\n  \\<forall>u.\n     \\<not> (u \\<noteq> t \\<and>\n             (0::'a) < excess f u \\<and>\n             (\\<forall>v.\n                 (u, v) \\<in> cf.E \\<longrightarrow> l u \\<noteq> l v + 1))\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>V - {t}. excess f u \\<le> (0::'a)", "by force"], ["proof (state)\nthis:\n  \\<forall>u\\<in>V - {t}. excess f u \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. isMaxFlow f", "with excess_non_negative"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>V - {s, t}. (0::'a) \\<le> excess f v\n  \\<forall>u\\<in>V - {t}. excess f u \\<le> (0::'a)", "have \"\\<forall>u\\<in>V-{s,t}. excess f u = 0\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V - {s, t}. (0::'a) \\<le> excess f v\n  \\<forall>u\\<in>V - {t}. excess f u \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>V - {s, t}. excess f u = (0::'a)", "by force"], ["proof (state)\nthis:\n  \\<forall>u\\<in>V - {s, t}. excess f u = (0::'a)\n\ngoal (1 subgoal):\n 1. isMaxFlow f", "with no_excess_imp_maxflow"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>V - {s, t}. excess f u = (0::'a) \\<Longrightarrow>\n  isMaxFlow f\n  \\<forall>u\\<in>V - {s, t}. excess f u = (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>V - {s, t}. excess f u = (0::'a) \\<Longrightarrow>\n  isMaxFlow f\n  \\<forall>u\\<in>V - {s, t}. excess f u = (0::'a)\n\ngoal (1 subgoal):\n 1. isMaxFlow f", "."], ["proof (state)\nthis:\n  isMaxFlow f\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>Labeling\\<close>"], ["", "subsection \\<open>Convenience Lemmas\\<close>"], ["", "text \\<open>We define a locale to reflect the effect of a push operation\\<close>"], ["", "locale push_effect_locale = Labeling +\n  fixes u v\n  assumes PRE: \"push_precond f l (u,v)\"\nbegin"], ["", "abbreviation \"f' \\<equiv> push_effect f (u,v)\""], ["", "sublocale l': Labeling c s t f' l"], ["proof (prove)\ngoal (1 subgoal):\n 1. Labeling c s t f' l", "using push_pres_Labeling[OF PRE]"], ["proof (prove)\nusing this:\n  Labeling c s t f' l\n\ngoal (1 subgoal):\n 1. Labeling c s t f' l", "."], ["", "lemma uv_cf_edge[simp, intro!]: \"(u,v)\\<in>cf.E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> cf.E", "using PRE"], ["proof (prove)\nusing this:\n  push_precond f l (u, v)\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> cf.E", "unfolding push_precond_def"], ["proof (prove)\nusing this:\n  case (u, v) of\n  (u, v) \\<Rightarrow>\n    (0::'a) < excess f u \\<and> (u, v) \\<in> cf.E \\<and> l u = l v + 1\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> cf.E", "by auto"], ["", "lemma excess_u_pos: \"excess f u > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < excess f u", "using PRE"], ["proof (prove)\nusing this:\n  push_precond f l (u, v)\n\ngoal (1 subgoal):\n 1. (0::'a) < excess f u", "unfolding push_precond_def"], ["proof (prove)\nusing this:\n  case (u, v) of\n  (u, v) \\<Rightarrow>\n    (0::'a) < excess f u \\<and> (u, v) \\<in> cf.E \\<and> l u = l v + 1\n\ngoal (1 subgoal):\n 1. (0::'a) < excess f u", "by auto"], ["", "lemma l_u_eq[simp]: \"l u = l v + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l u = l v + 1", "using PRE"], ["proof (prove)\nusing this:\n  push_precond f l (u, v)\n\ngoal (1 subgoal):\n 1. l u = l v + 1", "unfolding push_precond_def"], ["proof (prove)\nusing this:\n  case (u, v) of\n  (u, v) \\<Rightarrow>\n    (0::'a) < excess f u \\<and> (u, v) \\<in> cf.E \\<and> l u = l v + 1\n\ngoal (1 subgoal):\n 1. l u = l v + 1", "by auto"], ["", "lemma uv_edge_cases:\n    obtains (par) \"(u,v)\\<in>E\" \"(v,u)\\<notin>E\" \n          | (rev) \"(v,u)\\<in>E\" \"(u,v)\\<notin>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>(u, v) \\<in> E; (v, u) \\<notin> E\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using uv_cf_edge cfE_ss_invE no_parallel_edge"], ["proof (prove)\nusing this:\n  (u, v) \\<in> cf.E\n  cf.E \\<subseteq> E \\<union> E\\<inverse>\n  \\<forall>u v. (u, v) \\<in> E \\<longrightarrow> (v, u) \\<notin> E\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>(u, v) \\<in> E; (v, u) \\<notin> E\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["", "lemma uv_nodes[simp, intro!]: \"u\\<in>V\" \"v\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> V &&& v \\<in> V", "using E_ss_VxV cfE_ss_invE no_parallel_edge"], ["proof (prove)\nusing this:\n  E \\<subseteq> V \\<times> V\n  cf.E \\<subseteq> E \\<union> E\\<inverse>\n  \\<forall>u v. (u, v) \\<in> E \\<longrightarrow> (v, u) \\<notin> E\n\ngoal (1 subgoal):\n 1. u \\<in> V &&& v \\<in> V", "by auto"], ["", "lemma uv_not_eq[simp]: \"u\\<noteq>v\" \"v\\<noteq>u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<noteq> v &&& v \\<noteq> u", "using E_ss_VxV cfE_ss_invE[THEN subsetD, OF uv_cf_edge] no_parallel_edge"], ["proof (prove)\nusing this:\n  E \\<subseteq> V \\<times> V\n  (u, v) \\<in> E \\<union> E\\<inverse>\n  \\<forall>u v. (u, v) \\<in> E \\<longrightarrow> (v, u) \\<notin> E\n\ngoal (1 subgoal):\n 1. u \\<noteq> v &&& v \\<noteq> u", "by auto"], ["", "definition \"\\<Delta> = min (excess f u) (cf_of f (u,v))\""], ["", "lemma \\<Delta>_positive: \"\\<Delta> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < \\<Delta>", "unfolding \\<Delta>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < min (excess f u) (cf (u, v))", "using excess_u_pos uv_cf_edge[unfolded cf.E_def] resE_positive"], ["proof (prove)\nusing this:\n  (0::'a) < excess f u\n  (u, v) \\<in> {(u, v). cf (u, v) \\<noteq> (0::'a)}\n  ?e \\<in> cf.E \\<Longrightarrow> (0::'a) < cf ?e\n\ngoal (1 subgoal):\n 1. (0::'a) < min (excess f u) (cf (u, v))", "by auto"], ["", "lemma f'_alt: \"f' = augment_edge f (u,v) \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f' = augment_edge f (u, v) \\<Delta>", "unfolding push_effect_def \\<Delta>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (u, v) of\n     (u, v) \\<Rightarrow>\n       augment_edge f (u, v) (min (excess f u) (cf (u, v)))) =\n    augment_edge f (u, v) (min (excess f u) (cf (u, v)))", "by auto"], ["", "lemma cf'_alt: \"l'.cf = augment_edge_cf cf (u,v) \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l'.cf = augment_edge_cf cf (u, v) \\<Delta>", "unfolding push_effect_def \\<Delta>_def augment_edge_cf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cf_of\n     (case (u, v) of\n      (u, v) \\<Rightarrow>\n        augment_edge f (u, v) (min (excess f u) (cf (u, v)))) =\n    (case (u, v) of\n     (u, v) \\<Rightarrow>\n       \\<lambda>\\<Delta>. cf\n          ((u, v) := cf (u, v) - \\<Delta>, (v, u) := cf (v, u) + \\<Delta>))\n     (min (excess f u) (cf (u, v)))", "by (auto simp: augment_edge_cf')"], ["", "lemma excess'_u[simp]: \"excess f' u = excess f u - \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. excess f' u = excess f u - \\<Delta>", "unfolding excess_def[where f=f']"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f' (incoming u) - sum f' (outgoing u) = excess f u - \\<Delta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum f' (incoming u) - sum f' (outgoing u) = excess f u - \\<Delta>", "show \"sum f' (incoming u) - sum f' (outgoing u) = excess f u - \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f' (incoming u) - sum f' (outgoing u) = excess f u - \\<Delta>", "proof (cases rule: uv_edge_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(u, v) \\<in> E; (v, u) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming u) - sum f' (outgoing u) =\n                      excess f u - \\<Delta>\n 2. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming u) - sum f' (outgoing u) =\n                      excess f u - \\<Delta>", "case [simp]: par"], ["proof (state)\nthis:\n  (u, v) \\<in> E\n  (v, u) \\<notin> E\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(u, v) \\<in> E; (v, u) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming u) - sum f' (outgoing u) =\n                      excess f u - \\<Delta>\n 2. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming u) - sum f' (outgoing u) =\n                      excess f u - \\<Delta>", "hence UV_ONI:\"(u,v)\\<in>outgoing u - incoming u\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> E\n  (v, u) \\<notin> E\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> outgoing u - incoming u", "by (auto simp: incoming_def outgoing_def no_self_loop)"], ["proof (state)\nthis:\n  (u, v) \\<in> outgoing u - incoming u\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(u, v) \\<in> E; (v, u) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming u) - sum f' (outgoing u) =\n                      excess f u - \\<Delta>\n 2. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming u) - sum f' (outgoing u) =\n                      excess f u - \\<Delta>", "have 1: \"sum f' (incoming u) = sum f (incoming u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f' (incoming u) = sum f (incoming u)", "apply (rule sum.cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> incoming u \\<Longrightarrow> f' x = f x", "using UV_ONI"], ["proof (prove)\nusing this:\n  (u, v) \\<in> outgoing u - incoming u\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> incoming u \\<Longrightarrow> f' x = f x", "unfolding f'_alt"], ["proof (prove)\nusing this:\n  (u, v) \\<in> outgoing u - incoming u\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> incoming u \\<Longrightarrow>\n       augment_edge f (u, v) \\<Delta> x = f x", "apply (subst augment_edge_other)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> incoming u;\n        (u, v) \\<in> outgoing u - incoming u\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> E\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> incoming u;\n        (u, v) \\<in> outgoing u - incoming u\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> (u, v)\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> incoming u;\n        (u, v) \\<in> outgoing u - incoming u\\<rbrakk>\n       \\<Longrightarrow> f x = f x", "by auto"], ["proof (state)\nthis:\n  sum f' (incoming u) = sum f (incoming u)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(u, v) \\<in> E; (v, u) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming u) - sum f' (outgoing u) =\n                      excess f u - \\<Delta>\n 2. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming u) - sum f' (outgoing u) =\n                      excess f u - \\<Delta>", "have \"sum f' (outgoing u) \n        = sum f (outgoing u) + (\\<Sum>x\\<in>outgoing u. if x = (u, v) then \\<Delta> else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f' (outgoing u) =\n    sum f (outgoing u) +\n    (\\<Sum>x\\<in>outgoing u. if x = (u, v) then \\<Delta> else (0::'a))", "unfolding f'_alt augment_edge_def sum.distrib[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((case (u, v) of\n          (u, v) \\<Rightarrow>\n            \\<lambda>\\<Delta>.\n               if (u, v) \\<in> E then f((u, v) := f (u, v) + \\<Delta>)\n               else if (v, u) \\<in> E then f((v, u) := f (v, u) - \\<Delta>)\n                    else f)\n          \\<Delta>)\n     (outgoing u) =\n    (\\<Sum>x\\<in>outgoing u.\n       f x + (if x = (u, v) then \\<Delta> else (0::'a)))", "by (rule sum.cong) auto"], ["proof (state)\nthis:\n  sum f' (outgoing u) =\n  sum f (outgoing u) +\n  (\\<Sum>x\\<in>outgoing u. if x = (u, v) then \\<Delta> else (0::'a))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(u, v) \\<in> E; (v, u) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming u) - sum f' (outgoing u) =\n                      excess f u - \\<Delta>\n 2. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming u) - sum f' (outgoing u) =\n                      excess f u - \\<Delta>", "also"], ["proof (state)\nthis:\n  sum f' (outgoing u) =\n  sum f (outgoing u) +\n  (\\<Sum>x\\<in>outgoing u. if x = (u, v) then \\<Delta> else (0::'a))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(u, v) \\<in> E; (v, u) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming u) - sum f' (outgoing u) =\n                      excess f u - \\<Delta>\n 2. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming u) - sum f' (outgoing u) =\n                      excess f u - \\<Delta>", "have \"\\<dots> = sum f (outgoing u) + \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (outgoing u) +\n    (\\<Sum>x\\<in>outgoing u. if x = (u, v) then \\<Delta> else (0::'a)) =\n    sum f (outgoing u) + \\<Delta>", "using UV_ONI"], ["proof (prove)\nusing this:\n  (u, v) \\<in> outgoing u - incoming u\n\ngoal (1 subgoal):\n 1. sum f (outgoing u) +\n    (\\<Sum>x\\<in>outgoing u. if x = (u, v) then \\<Delta> else (0::'a)) =\n    sum f (outgoing u) + \\<Delta>", "by (auto simp: sum.delta)"], ["proof (state)\nthis:\n  sum f (outgoing u) +\n  (\\<Sum>x\\<in>outgoing u. if x = (u, v) then \\<Delta> else (0::'a)) =\n  sum f (outgoing u) + \\<Delta>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(u, v) \\<in> E; (v, u) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming u) - sum f' (outgoing u) =\n                      excess f u - \\<Delta>\n 2. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming u) - sum f' (outgoing u) =\n                      excess f u - \\<Delta>", "finally"], ["proof (chain)\npicking this:\n  sum f' (outgoing u) = sum f (outgoing u) + \\<Delta>", "show ?thesis"], ["proof (prove)\nusing this:\n  sum f' (outgoing u) = sum f (outgoing u) + \\<Delta>\n\ngoal (1 subgoal):\n 1. sum f' (incoming u) - sum f' (outgoing u) = excess f u - \\<Delta>", "using 1"], ["proof (prove)\nusing this:\n  sum f' (outgoing u) = sum f (outgoing u) + \\<Delta>\n  sum f' (incoming u) = sum f (incoming u)\n\ngoal (1 subgoal):\n 1. sum f' (incoming u) - sum f' (outgoing u) = excess f u - \\<Delta>", "unfolding excess_def"], ["proof (prove)\nusing this:\n  sum f' (outgoing u) = sum f (outgoing u) + \\<Delta>\n  sum f' (incoming u) = sum f (incoming u)\n\ngoal (1 subgoal):\n 1. sum f' (incoming u) - sum f' (outgoing u) =\n    sum f (incoming u) - sum f (outgoing u) - \\<Delta>", "by simp"], ["proof (state)\nthis:\n  sum f' (incoming u) - sum f' (outgoing u) = excess f u - \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming u) - sum f' (outgoing u) =\n                      excess f u - \\<Delta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming u) - sum f' (outgoing u) =\n                      excess f u - \\<Delta>", "case [simp]: rev"], ["proof (state)\nthis:\n  (v, u) \\<in> E\n  (u, v) \\<notin> E\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming u) - sum f' (outgoing u) =\n                      excess f u - \\<Delta>", "have UV_INO:\"(v,u)\\<in>incoming u - outgoing u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, u) \\<in> incoming u - outgoing u", "by (auto simp: incoming_def outgoing_def no_self_loop)"], ["proof (state)\nthis:\n  (v, u) \\<in> incoming u - outgoing u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming u) - sum f' (outgoing u) =\n                      excess f u - \\<Delta>", "have 1: \"sum f' (outgoing u) = sum f (outgoing u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f' (outgoing u) = sum f (outgoing u)", "apply (rule sum.cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> outgoing u \\<Longrightarrow> f' x = f x", "using UV_INO"], ["proof (prove)\nusing this:\n  (v, u) \\<in> incoming u - outgoing u\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> outgoing u \\<Longrightarrow> f' x = f x", "unfolding f'_alt"], ["proof (prove)\nusing this:\n  (v, u) \\<in> incoming u - outgoing u\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> outgoing u \\<Longrightarrow>\n       augment_edge f (u, v) \\<Delta> x = f x", "apply (subst augment_edge_rev_other)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> outgoing u;\n        (v, u) \\<in> incoming u - outgoing u\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<notin> E\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> outgoing u;\n        (v, u) \\<in> incoming u - outgoing u\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> (v, u)\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> outgoing u;\n        (v, u) \\<in> incoming u - outgoing u\\<rbrakk>\n       \\<Longrightarrow> f x = f x", "by (auto)"], ["proof (state)\nthis:\n  sum f' (outgoing u) = sum f (outgoing u)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming u) - sum f' (outgoing u) =\n                      excess f u - \\<Delta>", "have \"sum f' (incoming u) \n        = sum f (incoming u) + (\\<Sum>x\\<in>incoming u. if x = (v, u) then - \\<Delta> else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f' (incoming u) =\n    sum f (incoming u) +\n    (\\<Sum>x\\<in>incoming u. if x = (v, u) then - \\<Delta> else (0::'a))", "unfolding f'_alt augment_edge_def sum.distrib[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((case (u, v) of\n          (u, v) \\<Rightarrow>\n            \\<lambda>\\<Delta>.\n               if (u, v) \\<in> E then f((u, v) := f (u, v) + \\<Delta>)\n               else if (v, u) \\<in> E then f((v, u) := f (v, u) - \\<Delta>)\n                    else f)\n          \\<Delta>)\n     (incoming u) =\n    (\\<Sum>x\\<in>incoming u.\n       f x + (if x = (v, u) then - \\<Delta> else (0::'a)))", "by (rule sum.cong) auto"], ["proof (state)\nthis:\n  sum f' (incoming u) =\n  sum f (incoming u) +\n  (\\<Sum>x\\<in>incoming u. if x = (v, u) then - \\<Delta> else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming u) - sum f' (outgoing u) =\n                      excess f u - \\<Delta>", "also"], ["proof (state)\nthis:\n  sum f' (incoming u) =\n  sum f (incoming u) +\n  (\\<Sum>x\\<in>incoming u. if x = (v, u) then - \\<Delta> else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming u) - sum f' (outgoing u) =\n                      excess f u - \\<Delta>", "have \"\\<dots> = sum f (incoming u) - \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (incoming u) +\n    (\\<Sum>x\\<in>incoming u. if x = (v, u) then - \\<Delta> else (0::'a)) =\n    sum f (incoming u) - \\<Delta>", "using UV_INO"], ["proof (prove)\nusing this:\n  (v, u) \\<in> incoming u - outgoing u\n\ngoal (1 subgoal):\n 1. sum f (incoming u) +\n    (\\<Sum>x\\<in>incoming u. if x = (v, u) then - \\<Delta> else (0::'a)) =\n    sum f (incoming u) - \\<Delta>", "by (auto simp: sum.delta)"], ["proof (state)\nthis:\n  sum f (incoming u) +\n  (\\<Sum>x\\<in>incoming u. if x = (v, u) then - \\<Delta> else (0::'a)) =\n  sum f (incoming u) - \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming u) - sum f' (outgoing u) =\n                      excess f u - \\<Delta>", "finally"], ["proof (chain)\npicking this:\n  sum f' (incoming u) = sum f (incoming u) - \\<Delta>", "show ?thesis"], ["proof (prove)\nusing this:\n  sum f' (incoming u) = sum f (incoming u) - \\<Delta>\n\ngoal (1 subgoal):\n 1. sum f' (incoming u) - sum f' (outgoing u) = excess f u - \\<Delta>", "using 1"], ["proof (prove)\nusing this:\n  sum f' (incoming u) = sum f (incoming u) - \\<Delta>\n  sum f' (outgoing u) = sum f (outgoing u)\n\ngoal (1 subgoal):\n 1. sum f' (incoming u) - sum f' (outgoing u) = excess f u - \\<Delta>", "unfolding excess_def"], ["proof (prove)\nusing this:\n  sum f' (incoming u) = sum f (incoming u) - \\<Delta>\n  sum f' (outgoing u) = sum f (outgoing u)\n\ngoal (1 subgoal):\n 1. sum f' (incoming u) - sum f' (outgoing u) =\n    sum f (incoming u) - sum f (outgoing u) - \\<Delta>", "by auto"], ["proof (state)\nthis:\n  sum f' (incoming u) - sum f' (outgoing u) = excess f u - \\<Delta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum f' (incoming u) - sum f' (outgoing u) = excess f u - \\<Delta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma excess'_v[simp]: \"excess f' v = excess f v + \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. excess f' v = excess f v + \\<Delta>", "unfolding excess_def[where f=f']"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f' (incoming v) - sum f' (outgoing v) = excess f v + \\<Delta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum f' (incoming v) - sum f' (outgoing v) = excess f v + \\<Delta>", "show \"sum f' (incoming v) - sum f' (outgoing v) = excess f v + \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f' (incoming v) - sum f' (outgoing v) = excess f v + \\<Delta>", "proof (cases rule: uv_edge_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(u, v) \\<in> E; (v, u) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming v) - sum f' (outgoing v) =\n                      excess f v + \\<Delta>\n 2. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming v) - sum f' (outgoing v) =\n                      excess f v + \\<Delta>", "case [simp]: par"], ["proof (state)\nthis:\n  (u, v) \\<in> E\n  (v, u) \\<notin> E\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(u, v) \\<in> E; (v, u) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming v) - sum f' (outgoing v) =\n                      excess f v + \\<Delta>\n 2. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming v) - sum f' (outgoing v) =\n                      excess f v + \\<Delta>", "have UV_INO: \"(u,v)\\<in>incoming v - outgoing v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> incoming v - outgoing v", "unfolding incoming_def outgoing_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> {(u, v) |u. (u, v) \\<in> E} - {(v, u) |u. (v, u) \\<in> E}", "by (auto simp: no_self_loop)"], ["proof (state)\nthis:\n  (u, v) \\<in> incoming v - outgoing v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(u, v) \\<in> E; (v, u) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming v) - sum f' (outgoing v) =\n                      excess f v + \\<Delta>\n 2. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming v) - sum f' (outgoing v) =\n                      excess f v + \\<Delta>", "have 1: \"sum f' (outgoing v) = sum f (outgoing v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f' (outgoing v) = sum f (outgoing v)", "using UV_INO"], ["proof (prove)\nusing this:\n  (u, v) \\<in> incoming v - outgoing v\n\ngoal (1 subgoal):\n 1. sum f' (outgoing v) = sum f (outgoing v)", "unfolding f'_alt"], ["proof (prove)\nusing this:\n  (u, v) \\<in> incoming v - outgoing v\n\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (outgoing v) = sum f (outgoing v)", "by (auto simp: augment_edge_def intro: sum.cong)"], ["proof (state)\nthis:\n  sum f' (outgoing v) = sum f (outgoing v)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(u, v) \\<in> E; (v, u) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming v) - sum f' (outgoing v) =\n                      excess f v + \\<Delta>\n 2. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming v) - sum f' (outgoing v) =\n                      excess f v + \\<Delta>", "have \"sum f' (incoming v) \n        = sum f (incoming v) + (\\<Sum>x\\<in>incoming v. if x=(u,v) then \\<Delta> else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f' (incoming v) =\n    sum f (incoming v) +\n    (\\<Sum>x\\<in>incoming v. if x = (u, v) then \\<Delta> else (0::'a))", "unfolding f'_alt augment_edge_def sum.distrib[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((case (u, v) of\n          (u, v) \\<Rightarrow>\n            \\<lambda>\\<Delta>.\n               if (u, v) \\<in> E then f((u, v) := f (u, v) + \\<Delta>)\n               else if (v, u) \\<in> E then f((v, u) := f (v, u) - \\<Delta>)\n                    else f)\n          \\<Delta>)\n     (incoming v) =\n    (\\<Sum>x\\<in>incoming v.\n       f x + (if x = (u, v) then \\<Delta> else (0::'a)))", "apply (rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. incoming v = incoming v\n 2. \\<And>x.\n       x \\<in> incoming v \\<Longrightarrow>\n       (case (u, v) of\n        (u, v) \\<Rightarrow>\n          \\<lambda>\\<Delta>.\n             if (u, v) \\<in> E then f((u, v) := f (u, v) + \\<Delta>)\n             else if (v, u) \\<in> E then f((v, u) := f (v, u) - \\<Delta>)\n                  else f)\n        \\<Delta> x =\n       f x + (if x = (u, v) then \\<Delta> else (0::'a))", "using UV_INO"], ["proof (prove)\nusing this:\n  (u, v) \\<in> incoming v - outgoing v\n\ngoal (2 subgoals):\n 1. incoming v = incoming v\n 2. \\<And>x.\n       x \\<in> incoming v \\<Longrightarrow>\n       (case (u, v) of\n        (u, v) \\<Rightarrow>\n          \\<lambda>\\<Delta>.\n             if (u, v) \\<in> E then f((u, v) := f (u, v) + \\<Delta>)\n             else if (v, u) \\<in> E then f((v, u) := f (v, u) - \\<Delta>)\n                  else f)\n        \\<Delta> x =\n       f x + (if x = (u, v) then \\<Delta> else (0::'a))", "unfolding f'_alt"], ["proof (prove)\nusing this:\n  (u, v) \\<in> incoming v - outgoing v\n\ngoal (2 subgoals):\n 1. incoming v = incoming v\n 2. \\<And>x.\n       x \\<in> incoming v \\<Longrightarrow>\n       (case (u, v) of\n        (u, v) \\<Rightarrow>\n          \\<lambda>\\<Delta>.\n             if (u, v) \\<in> E then f((u, v) := f (u, v) + \\<Delta>)\n             else if (v, u) \\<in> E then f((v, u) := f (v, u) - \\<Delta>)\n                  else f)\n        \\<Delta> x =\n       f x + (if x = (u, v) then \\<Delta> else (0::'a))", "by auto"], ["proof (state)\nthis:\n  sum f' (incoming v) =\n  sum f (incoming v) +\n  (\\<Sum>x\\<in>incoming v. if x = (u, v) then \\<Delta> else (0::'a))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(u, v) \\<in> E; (v, u) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming v) - sum f' (outgoing v) =\n                      excess f v + \\<Delta>\n 2. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming v) - sum f' (outgoing v) =\n                      excess f v + \\<Delta>", "also"], ["proof (state)\nthis:\n  sum f' (incoming v) =\n  sum f (incoming v) +\n  (\\<Sum>x\\<in>incoming v. if x = (u, v) then \\<Delta> else (0::'a))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(u, v) \\<in> E; (v, u) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming v) - sum f' (outgoing v) =\n                      excess f v + \\<Delta>\n 2. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming v) - sum f' (outgoing v) =\n                      excess f v + \\<Delta>", "have \"\\<dots> = sum f (incoming v) + \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (incoming v) +\n    (\\<Sum>x\\<in>incoming v. if x = (u, v) then \\<Delta> else (0::'a)) =\n    sum f (incoming v) + \\<Delta>", "using UV_INO"], ["proof (prove)\nusing this:\n  (u, v) \\<in> incoming v - outgoing v\n\ngoal (1 subgoal):\n 1. sum f (incoming v) +\n    (\\<Sum>x\\<in>incoming v. if x = (u, v) then \\<Delta> else (0::'a)) =\n    sum f (incoming v) + \\<Delta>", "by (auto simp: sum.delta)"], ["proof (state)\nthis:\n  sum f (incoming v) +\n  (\\<Sum>x\\<in>incoming v. if x = (u, v) then \\<Delta> else (0::'a)) =\n  sum f (incoming v) + \\<Delta>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(u, v) \\<in> E; (v, u) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming v) - sum f' (outgoing v) =\n                      excess f v + \\<Delta>\n 2. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming v) - sum f' (outgoing v) =\n                      excess f v + \\<Delta>", "finally"], ["proof (chain)\npicking this:\n  sum f' (incoming v) = sum f (incoming v) + \\<Delta>", "show ?thesis"], ["proof (prove)\nusing this:\n  sum f' (incoming v) = sum f (incoming v) + \\<Delta>\n\ngoal (1 subgoal):\n 1. sum f' (incoming v) - sum f' (outgoing v) = excess f v + \\<Delta>", "using 1"], ["proof (prove)\nusing this:\n  sum f' (incoming v) = sum f (incoming v) + \\<Delta>\n  sum f' (outgoing v) = sum f (outgoing v)\n\ngoal (1 subgoal):\n 1. sum f' (incoming v) - sum f' (outgoing v) = excess f v + \\<Delta>", "by (auto simp: excess_def)"], ["proof (state)\nthis:\n  sum f' (incoming v) - sum f' (outgoing v) = excess f v + \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming v) - sum f' (outgoing v) =\n                      excess f v + \\<Delta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming v) - sum f' (outgoing v) =\n                      excess f v + \\<Delta>", "case [simp]: rev"], ["proof (state)\nthis:\n  (v, u) \\<in> E\n  (u, v) \\<notin> E\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming v) - sum f' (outgoing v) =\n                      excess f v + \\<Delta>", "have UV_INO:\"(v,u)\\<in>outgoing v - incoming v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, u) \\<in> outgoing v - incoming v", "by (auto simp: incoming_def outgoing_def no_self_loop)"], ["proof (state)\nthis:\n  (v, u) \\<in> outgoing v - incoming v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming v) - sum f' (outgoing v) =\n                      excess f v + \\<Delta>", "have 1: \"sum f' (incoming v) = sum f (incoming v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f' (incoming v) = sum f (incoming v)", "using UV_INO"], ["proof (prove)\nusing this:\n  (v, u) \\<in> outgoing v - incoming v\n\ngoal (1 subgoal):\n 1. sum f' (incoming v) = sum f (incoming v)", "unfolding f'_alt"], ["proof (prove)\nusing this:\n  (v, u) \\<in> outgoing v - incoming v\n\ngoal (1 subgoal):\n 1. sum (augment_edge f (u, v) \\<Delta>) (incoming v) = sum f (incoming v)", "by (auto simp: augment_edge_def intro: sum.cong)"], ["proof (state)\nthis:\n  sum f' (incoming v) = sum f (incoming v)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming v) - sum f' (outgoing v) =\n                      excess f v + \\<Delta>", "have \"sum f' (outgoing v) \n        = sum f (outgoing v) + (\\<Sum>x\\<in>outgoing v. if x=(v,u) then - \\<Delta> else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f' (outgoing v) =\n    sum f (outgoing v) +\n    (\\<Sum>x\\<in>outgoing v. if x = (v, u) then - \\<Delta> else (0::'a))", "unfolding f'_alt augment_edge_def sum.distrib[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((case (u, v) of\n          (u, v) \\<Rightarrow>\n            \\<lambda>\\<Delta>.\n               if (u, v) \\<in> E then f((u, v) := f (u, v) + \\<Delta>)\n               else if (v, u) \\<in> E then f((v, u) := f (v, u) - \\<Delta>)\n                    else f)\n          \\<Delta>)\n     (outgoing v) =\n    (\\<Sum>x\\<in>outgoing v.\n       f x + (if x = (v, u) then - \\<Delta> else (0::'a)))", "apply (rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. outgoing v = outgoing v\n 2. \\<And>x.\n       x \\<in> outgoing v \\<Longrightarrow>\n       (case (u, v) of\n        (u, v) \\<Rightarrow>\n          \\<lambda>\\<Delta>.\n             if (u, v) \\<in> E then f((u, v) := f (u, v) + \\<Delta>)\n             else if (v, u) \\<in> E then f((v, u) := f (v, u) - \\<Delta>)\n                  else f)\n        \\<Delta> x =\n       f x + (if x = (v, u) then - \\<Delta> else (0::'a))", "using UV_INO"], ["proof (prove)\nusing this:\n  (v, u) \\<in> outgoing v - incoming v\n\ngoal (2 subgoals):\n 1. outgoing v = outgoing v\n 2. \\<And>x.\n       x \\<in> outgoing v \\<Longrightarrow>\n       (case (u, v) of\n        (u, v) \\<Rightarrow>\n          \\<lambda>\\<Delta>.\n             if (u, v) \\<in> E then f((u, v) := f (u, v) + \\<Delta>)\n             else if (v, u) \\<in> E then f((v, u) := f (v, u) - \\<Delta>)\n                  else f)\n        \\<Delta> x =\n       f x + (if x = (v, u) then - \\<Delta> else (0::'a))", "unfolding f'_alt"], ["proof (prove)\nusing this:\n  (v, u) \\<in> outgoing v - incoming v\n\ngoal (2 subgoals):\n 1. outgoing v = outgoing v\n 2. \\<And>x.\n       x \\<in> outgoing v \\<Longrightarrow>\n       (case (u, v) of\n        (u, v) \\<Rightarrow>\n          \\<lambda>\\<Delta>.\n             if (u, v) \\<in> E then f((u, v) := f (u, v) + \\<Delta>)\n             else if (v, u) \\<in> E then f((v, u) := f (v, u) - \\<Delta>)\n                  else f)\n        \\<Delta> x =\n       f x + (if x = (v, u) then - \\<Delta> else (0::'a))", "by auto"], ["proof (state)\nthis:\n  sum f' (outgoing v) =\n  sum f (outgoing v) +\n  (\\<Sum>x\\<in>outgoing v. if x = (v, u) then - \\<Delta> else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming v) - sum f' (outgoing v) =\n                      excess f v + \\<Delta>", "also"], ["proof (state)\nthis:\n  sum f' (outgoing v) =\n  sum f (outgoing v) +\n  (\\<Sum>x\\<in>outgoing v. if x = (v, u) then - \\<Delta> else (0::'a))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming v) - sum f' (outgoing v) =\n                      excess f v + \\<Delta>", "have \"\\<dots> = sum f (outgoing v) - \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (outgoing v) +\n    (\\<Sum>x\\<in>outgoing v. if x = (v, u) then - \\<Delta> else (0::'a)) =\n    sum f (outgoing v) - \\<Delta>", "using UV_INO"], ["proof (prove)\nusing this:\n  (v, u) \\<in> outgoing v - incoming v\n\ngoal (1 subgoal):\n 1. sum f (outgoing v) +\n    (\\<Sum>x\\<in>outgoing v. if x = (v, u) then - \\<Delta> else (0::'a)) =\n    sum f (outgoing v) - \\<Delta>", "by (auto simp: sum.delta)"], ["proof (state)\nthis:\n  sum f (outgoing v) +\n  (\\<Sum>x\\<in>outgoing v. if x = (v, u) then - \\<Delta> else (0::'a)) =\n  sum f (outgoing v) - \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(v, u) \\<in> E; (u, v) \\<notin> E\\<rbrakk>\n    \\<Longrightarrow> sum f' (incoming v) - sum f' (outgoing v) =\n                      excess f v + \\<Delta>", "finally"], ["proof (chain)\npicking this:\n  sum f' (outgoing v) = sum f (outgoing v) - \\<Delta>", "show ?thesis"], ["proof (prove)\nusing this:\n  sum f' (outgoing v) = sum f (outgoing v) - \\<Delta>\n\ngoal (1 subgoal):\n 1. sum f' (incoming v) - sum f' (outgoing v) = excess f v + \\<Delta>", "using 1"], ["proof (prove)\nusing this:\n  sum f' (outgoing v) = sum f (outgoing v) - \\<Delta>\n  sum f' (incoming v) = sum f (incoming v)\n\ngoal (1 subgoal):\n 1. sum f' (incoming v) - sum f' (outgoing v) = excess f v + \\<Delta>", "by (auto simp: excess_def)"], ["proof (state)\nthis:\n  sum f' (incoming v) - sum f' (outgoing v) = excess f v + \\<Delta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum f' (incoming v) - sum f' (outgoing v) = excess f v + \\<Delta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma excess'_other[simp]:\n    assumes \"x \\<noteq> u\" \"x \\<noteq> v\"  \n    shows \"excess f' x = excess f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. excess f' x = excess f x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. excess f' x = excess f x", "have NE: \"(u,v)\\<notin>incoming x\" \"(u,v)\\<notin>outgoing x\"\n          \"(v,u)\\<notin>incoming x\" \"(v,u)\\<notin>outgoing x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((u, v) \\<notin> incoming x &&& (u, v) \\<notin> outgoing x) &&&\n    (v, u) \\<notin> incoming x &&& (v, u) \\<notin> outgoing x", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> u\n  x \\<noteq> v\n\ngoal (1 subgoal):\n 1. ((u, v) \\<notin> incoming x &&& (u, v) \\<notin> outgoing x) &&&\n    (v, u) \\<notin> incoming x &&& (v, u) \\<notin> outgoing x", "unfolding incoming_def outgoing_def"], ["proof (prove)\nusing this:\n  x \\<noteq> u\n  x \\<noteq> v\n\ngoal (1 subgoal):\n 1. ((u, v) \\<notin> {(u, x) |u. (u, x) \\<in> E} &&&\n     (u, v) \\<notin> {(x, u) |u. (x, u) \\<in> E}) &&&\n    (v, u) \\<notin> {(u, x) |u. (u, x) \\<in> E} &&&\n    (v, u) \\<notin> {(x, u) |u. (x, u) \\<in> E}", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<notin> incoming x\n  (u, v) \\<notin> outgoing x\n  (v, u) \\<notin> incoming x\n  (v, u) \\<notin> outgoing x\n\ngoal (1 subgoal):\n 1. excess f' x = excess f x", "have \n      \"sum f' (outgoing x) = sum f (outgoing x)\"\n      \"sum f' (incoming x) = sum f (incoming x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f' (outgoing x) = sum f (outgoing x) &&&\n    sum f' (incoming x) = sum f (incoming x)", "by (auto \n            simp: augment_edge_def f'_alt NE \n            split!: if_split \n            intro: sum.cong)"], ["proof (state)\nthis:\n  sum f' (outgoing x) = sum f (outgoing x)\n  sum f' (incoming x) = sum f (incoming x)\n\ngoal (1 subgoal):\n 1. excess f' x = excess f x", "thus ?thesis"], ["proof (prove)\nusing this:\n  sum f' (outgoing x) = sum f (outgoing x)\n  sum f' (incoming x) = sum f (incoming x)\n\ngoal (1 subgoal):\n 1. excess f' x = excess f x", "unfolding excess_def"], ["proof (prove)\nusing this:\n  sum f' (outgoing x) = sum f (outgoing x)\n  sum f' (incoming x) = sum f (incoming x)\n\ngoal (1 subgoal):\n 1. sum f' (incoming x) - sum f' (outgoing x) =\n    sum f (incoming x) - sum f (outgoing x)", "by auto"], ["proof (state)\nthis:\n  excess f' x = excess f x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma excess'_if: \n    \"excess f' x = (\n           if x=u then excess f u - \\<Delta> \n      else if x=v then excess f v + \\<Delta> \n         else excess f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. excess f' x =\n    (if x = u then excess f u - \\<Delta>\n     else if x = v then excess f v + \\<Delta> else excess f x)", "by simp"], ["", "end \\<comment> \\<open>Push Effect Locale\\<close>"], ["", "subsection \\<open>Complexity\\<close>"], ["", "text \\<open>\n  Next, we analyze the complexity of the generic push relabel algorithm.\n  We will show that it has a complexity of \\<open>O(V\\<^sup>2E)\\<close> basic operations.\n  Here, we often trade precise estimation of constant factors for simplicity\n  of the proof.\n\\<close>"], ["", "subsubsection \\<open>Auxiliary Lemmas\\<close>"], ["", "context Network \nbegin"], ["", "lemma cardE_nz_aux[simp, intro!]:\n  \"card E \\<noteq> 0\" \"card E \\<ge> Suc 0\" \"card E > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card E \\<noteq> 0 &&& Suc 0 \\<le> card E &&& 0 < card E", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. card E \\<noteq> 0\n 2. Suc 0 \\<le> card E\n 3. 0 < card E", "show \"card E \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card E \\<noteq> 0", "by (simp add: E_not_empty)"], ["proof (state)\nthis:\n  card E \\<noteq> 0\n\ngoal (2 subgoals):\n 1. Suc 0 \\<le> card E\n 2. 0 < card E", "thus \"card E \\<ge> Suc 0\""], ["proof (prove)\nusing this:\n  card E \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Suc 0 \\<le> card E", "by linarith"], ["proof (state)\nthis:\n  Suc 0 \\<le> card E\n\ngoal (1 subgoal):\n 1. 0 < card E", "thus \"card E > 0\""], ["proof (prove)\nusing this:\n  Suc 0 \\<le> card E\n\ngoal (1 subgoal):\n 1. 0 < card E", "by auto"], ["proof (state)\nthis:\n  0 < card E\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The number of nodes can be estimated by the number of edges.\n  This estimation is done in various places to get smoother bounds.\n\\<close>"], ["", "lemma card_V_est_E: \"card V \\<le> 2 * card E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card V \\<le> 2 * card E", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card V \\<le> 2 * card E", "have \"card V \\<le> card (fst`E) + card (snd`E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card V \\<le> card (fst ` E) + card (snd ` E)", "by (auto simp: card_Un_le V_alt)"], ["proof (state)\nthis:\n  card V \\<le> card (fst ` E) + card (snd ` E)\n\ngoal (1 subgoal):\n 1. card V \\<le> 2 * card E", "also"], ["proof (state)\nthis:\n  card V \\<le> card (fst ` E) + card (snd ` E)\n\ngoal (1 subgoal):\n 1. card V \\<le> 2 * card E", "note card_image_le[OF finite_E]"], ["proof (state)\nthis:\n  card (?f ` E) \\<le> card E\n\ngoal (1 subgoal):\n 1. card V \\<le> 2 * card E", "also"], ["proof (state)\nthis:\n  card (?f ` E) \\<le> card E\n\ngoal (1 subgoal):\n 1. card V \\<le> 2 * card E", "note card_image_le[OF finite_E]"], ["proof (state)\nthis:\n  card (?f ` E) \\<le> card E\n\ngoal (1 subgoal):\n 1. card V \\<le> 2 * card E", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              card (fst ` E) + x \\<le> card (fst ` E) + y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow> x + card E \\<le> y + card E\\<rbrakk>\n  \\<Longrightarrow> card V \\<le> card E + card E", "show \"card V \\<le> 2 * card E\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              card (fst ` E) + x \\<le> card (fst ` E) + y;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow> x + card E \\<le> y + card E\\<rbrakk>\n  \\<Longrightarrow> card V \\<le> card E + card E\n\ngoal (1 subgoal):\n 1. card V \\<le> 2 * card E", "by auto"], ["proof (state)\nthis:\n  card V \\<le> 2 * card E\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Height Bound\\<close>"], ["", "text \\<open>A crucial idea of estimating the complexity is the insight that \n  no label will exceed \\<open>2|V|-1\\<close> during the algorithm.\n\n  We define a locale that states this invariant, and show that the algorithm\n  maintains it. The corresponds to the proof of \\cormen{26.20}.\n\\<close>"], ["", "locale Height_Bounded_Labeling = Labeling +\n  assumes height_bound: \"\\<forall>u\\<in>V. l u \\<le> 2*card V - 1\"\nbegin"], ["", "lemma height_bound': \"u\\<in>V \\<Longrightarrow> l u \\<le> 2*card V - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> V \\<Longrightarrow> l u \\<le> 2 * card V - 1", "using height_bound"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>V. l u \\<le> 2 * card V - 1\n\ngoal (1 subgoal):\n 1. u \\<in> V \\<Longrightarrow> l u \\<le> 2 * card V - 1", "by auto"], ["", "end"], ["", "lemma (in Network) pp_init_height_bound: \n  \"Height_Bounded_Labeling c s t pp_init_f pp_init_l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t pp_init_f pp_init_l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t pp_init_f pp_init_l", "interpret Labeling c s t pp_init_f pp_init_l"], ["proof (prove)\ngoal (1 subgoal):\n 1. Labeling c s t pp_init_f pp_init_l", "by (rule pp_init_invar)"], ["proof (state)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t pp_init_f pp_init_l", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t pp_init_f pp_init_l", "by unfold_locales (auto simp: pp_init_l_def)"], ["proof (state)\nthis:\n  Height_Bounded_Labeling c s t pp_init_f pp_init_l\n\ngoal:\nNo subgoals!", "qed"], ["", "context Height_Bounded_Labeling\nbegin"], ["", "text \\<open>As push does not change the labeling, it trivially preserves the \n  height bound.\\<close>"], ["", "lemma push_pres_height_bound:\n  assumes \"push_precond f l e\"\n  shows \"Height_Bounded_Labeling c s t (push_effect f e) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t (push_effect f e) l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t (push_effect f e) l", "from push_pres_Labeling[OF assms]"], ["proof (chain)\npicking this:\n  Labeling c s t (push_effect f e) l", "interpret l': Labeling c s t \"push_effect f e\" l"], ["proof (prove)\nusing this:\n  Labeling c s t (push_effect f e) l\n\ngoal (1 subgoal):\n 1. Labeling c s t (push_effect f e) l", "."], ["proof (state)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t (push_effect f e) l", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t (push_effect f e) l", "using height_bound"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>V. l u \\<le> 2 * card V - 1\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t (push_effect f e) l", "by unfold_locales"], ["proof (state)\nthis:\n  Height_Bounded_Labeling c s t (push_effect f e) l\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  In a valid labeling,\n  any active node has a (simple) path to the source node in \n  the residual graph~\\cormen{26.19}.\n\\<close>"], ["", "lemma (in Labeling) excess_imp_source_path: \n  assumes \"excess f u > 0\"\n  obtains p where \"cf.isSimplePath u p s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        cf.isSimplePath u p s \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        cf.isSimplePath u p s \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain U where U_def: \"U = {v|p v. cf.isSimplePath u p v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>U.\n        U =\n        {uu_.\n         \\<exists>p v.\n            uu_ = v \\<and> cf.isSimplePath u p v} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  U = {uu_. \\<exists>p v. uu_ = v \\<and> cf.isSimplePath u p v}\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        cf.isSimplePath u p s \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have fct1: \"U \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> V", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> U \\<Longrightarrow> x \\<in> V", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> U \\<Longrightarrow> x \\<in> V", "assume \"v \\<in> U\""], ["proof (state)\nthis:\n  v \\<in> U\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> U \\<Longrightarrow> x \\<in> V", "then"], ["proof (chain)\npicking this:\n  v \\<in> U", "have \"(u, v) \\<in> cf.E\\<^sup>*\""], ["proof (prove)\nusing this:\n  v \\<in> U\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> cf.E\\<^sup>*", "using U_def cf.isSimplePath_def cf.isPath_rtc"], ["proof (prove)\nusing this:\n  v \\<in> U\n  U = {uu_. \\<exists>p v. uu_ = v \\<and> cf.isSimplePath u p v}\n  cf.isSimplePath ?u ?p ?v \\<equiv>\n  cf.isPath ?u ?p ?v \\<and> distinct (cf.pathVertices ?u ?p)\n  cf.isPath ?u ?p ?v \\<Longrightarrow> (?u, ?v) \\<in> cf.E\\<^sup>*\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> cf.E\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<in> cf.E\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> U \\<Longrightarrow> x \\<in> V", "then"], ["proof (chain)\npicking this:\n  (u, v) \\<in> cf.E\\<^sup>*", "obtain u' where \"u = v \\<or> ((u, u') \\<in> cf.E\\<^sup>* \\<and> (u', v) \\<in> cf.E)\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> cf.E\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>u'.\n        u = v \\<or>\n        (u, u') \\<in> cf.E\\<^sup>* \\<and>\n        (u', v) \\<in> cf.E \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson rtranclE)"], ["proof (state)\nthis:\n  u = v \\<or> (u, u') \\<in> cf.E\\<^sup>* \\<and> (u', v) \\<in> cf.E\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> U \\<Longrightarrow> x \\<in> V", "thus \"v \\<in> V\""], ["proof (prove)\nusing this:\n  u = v \\<or> (u, u') \\<in> cf.E\\<^sup>* \\<and> (u', v) \\<in> cf.E\n\ngoal (1 subgoal):\n 1. v \\<in> V", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow> v \\<in> V\n 2. (u, u') \\<in> cf.E\\<^sup>* \\<and> (u', v) \\<in> cf.E \\<Longrightarrow>\n    v \\<in> V", "assume \"u = v\""], ["proof (state)\nthis:\n  u = v\n\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow> v \\<in> V\n 2. (u, u') \\<in> cf.E\\<^sup>* \\<and> (u', v) \\<in> cf.E \\<Longrightarrow>\n    v \\<in> V", "thus ?thesis"], ["proof (prove)\nusing this:\n  u = v\n\ngoal (1 subgoal):\n 1. v \\<in> V", "using excess_nodes_only[OF assms]"], ["proof (prove)\nusing this:\n  u = v\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. v \\<in> V", "by blast"], ["proof (state)\nthis:\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. (u, u') \\<in> cf.E\\<^sup>* \\<and> (u', v) \\<in> cf.E \\<Longrightarrow>\n    v \\<in> V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (u, u') \\<in> cf.E\\<^sup>* \\<and> (u', v) \\<in> cf.E \\<Longrightarrow>\n    v \\<in> V", "assume \"(u, u') \\<in> cf.E\\<^sup>* \\<and> (u', v) \\<in> cf.E\""], ["proof (state)\nthis:\n  (u, u') \\<in> cf.E\\<^sup>* \\<and> (u', v) \\<in> cf.E\n\ngoal (1 subgoal):\n 1. (u, u') \\<in> cf.E\\<^sup>* \\<and> (u', v) \\<in> cf.E \\<Longrightarrow>\n    v \\<in> V", "then"], ["proof (chain)\npicking this:\n  (u, u') \\<in> cf.E\\<^sup>* \\<and> (u', v) \\<in> cf.E", "have \"v \\<in> cf.V\""], ["proof (prove)\nusing this:\n  (u, u') \\<in> cf.E\\<^sup>* \\<and> (u', v) \\<in> cf.E\n\ngoal (1 subgoal):\n 1. v \\<in> cf.V", "unfolding cf.V_def"], ["proof (prove)\nusing this:\n  (u, u') \\<in> cf.E\\<^sup>* \\<and> (u', v) \\<in> cf.E\n\ngoal (1 subgoal):\n 1. v \\<in> {u. \\<exists>v. (u, v) \\<in> cf.E \\<or> (v, u) \\<in> cf.E}", "by blast"], ["proof (state)\nthis:\n  v \\<in> cf.V\n\ngoal (1 subgoal):\n 1. (u, u') \\<in> cf.E\\<^sup>* \\<and> (u', v) \\<in> cf.E \\<Longrightarrow>\n    v \\<in> V", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> cf.V\n\ngoal (1 subgoal):\n 1. v \\<in> V", "by simp"], ["proof (state)\nthis:\n  v \\<in> V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<in> V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U \\<subseteq> V\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        cf.isSimplePath u p s \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"s \\<in> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> U", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<notin> U \\<Longrightarrow> False", "assume \"s \\<notin> U\""], ["proof (state)\nthis:\n  s \\<notin> U\n\ngoal (1 subgoal):\n 1. s \\<notin> U \\<Longrightarrow> False", "obtain U' where U'_def: \"U' = V - U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>U'. U' = V - U \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  U' = V - U\n\ngoal (1 subgoal):\n 1. s \\<notin> U \\<Longrightarrow> False", "have \"(\\<Sum>u\\<in>U. excess f u) \n        = (\\<Sum>u\\<in>U. (\\<Sum>v\\<in>U'. f (v, u))) - (\\<Sum>u\\<in>U. (\\<Sum>v\\<in>U'. f (u, v)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (excess f) U =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u)) -\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum (excess f) U =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u)) -\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))", "have \"(\\<Sum>u\\<in>U. excess f u) \n          = (\\<Sum>u\\<in>U. (\\<Sum>v\\<in>incoming u. f v)) - (\\<Sum>u\\<in>U.(\\<Sum>v\\<in>outgoing u. f v))\"\n        (is \"_ = ?R1 - ?R2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (excess f) U =\n    (\\<Sum>u\\<in>U. sum f (incoming u)) -\n    (\\<Sum>u\\<in>U. sum f (outgoing u))", "unfolding excess_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>U. sum f (incoming u) - sum f (outgoing u)) =\n    (\\<Sum>u\\<in>U. sum f (incoming u)) -\n    (\\<Sum>u\\<in>U. sum f (outgoing u))", "by (simp add: sum_subtractf)"], ["proof (state)\nthis:\n  sum (excess f) U =\n  (\\<Sum>u\\<in>U. sum f (incoming u)) - (\\<Sum>u\\<in>U. sum f (outgoing u))\n\ngoal (1 subgoal):\n 1. sum (excess f) U =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u)) -\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))", "also"], ["proof (state)\nthis:\n  sum (excess f) U =\n  (\\<Sum>u\\<in>U. sum f (incoming u)) - (\\<Sum>u\\<in>U. sum f (outgoing u))\n\ngoal (1 subgoal):\n 1. sum (excess f) U =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u)) -\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))", "have \"?R1 = (\\<Sum>u\\<in>U. (\\<Sum>v\\<in>V. f (v, u)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>U. sum f (incoming u)) =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>V. f (v, u))", "using sum_incoming_alt_flow fct1"], ["proof (prove)\nusing this:\n  ?u \\<in> V \\<Longrightarrow>\n  sum f (incoming ?u) = (\\<Sum>v\\<in>V. f (v, ?u))\n  U \\<subseteq> V\n\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>U. sum f (incoming u)) =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>V. f (v, u))", "by (meson subsetCE sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>U. sum f (incoming u)) =\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>V. f (v, u))\n\ngoal (1 subgoal):\n 1. sum (excess f) U =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u)) -\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))", "also"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>U. sum f (incoming u)) =\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>V. f (v, u))\n\ngoal (1 subgoal):\n 1. sum (excess f) U =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u)) -\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))", "have \"\\<dots> = (\\<Sum>u\\<in>U. (\\<Sum>v\\<in>U. f (v, u))) + (\\<Sum>u\\<in>U. (\\<Sum>v\\<in>U'. f (v, u)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>U. \\<Sum>v\\<in>V. f (v, u)) =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u)) +\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>U. \\<Sum>v\\<in>V. f (v, u)) =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u)) +\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u))", "have \"(\\<Sum>v\\<in>V. f (v, u)) = (\\<Sum>v\\<in>U. f (v, u)) + (\\<Sum>v\\<in>U'. f (v, u))\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>V. f (v, u)) =\n    (\\<Sum>v\\<in>U. f (v, u)) + (\\<Sum>v\\<in>U'. f (v, u))", "using U'_def fct1 finite_V"], ["proof (prove)\nusing this:\n  U' = V - U\n  U \\<subseteq> V\n  finite V\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>V. f (v, u)) =\n    (\\<Sum>v\\<in>U. f (v, u)) + (\\<Sum>v\\<in>U'. f (v, u))", "by (metis ab_semigroup_add_class.add.commute sum.subset_diff)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>V. f (v, ?u)) =\n  (\\<Sum>v\\<in>U. f (v, ?u)) + (\\<Sum>v\\<in>U'. f (v, ?u))\n\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>U. \\<Sum>v\\<in>V. f (v, u)) =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u)) +\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>v\\<in>V. f (v, ?u)) =\n  (\\<Sum>v\\<in>U. f (v, ?u)) + (\\<Sum>v\\<in>U'. f (v, ?u))\n\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>U. \\<Sum>v\\<in>V. f (v, u)) =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u)) +\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u))", "by (simp add: sum.distrib)"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>V. f (v, u)) =\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u)) +\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>V. f (v, u)) =\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u)) +\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u))\n\ngoal (1 subgoal):\n 1. sum (excess f) U =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u)) -\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))", "also"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>V. f (v, u)) =\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u)) +\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u))\n\ngoal (1 subgoal):\n 1. sum (excess f) U =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u)) -\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))", "have \"?R2 = (\\<Sum>u\\<in>U. (\\<Sum>v\\<in>V. f (u, v)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>U. sum f (outgoing u)) =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>V. f (u, v))", "using sum_outgoing_alt_flow fct1"], ["proof (prove)\nusing this:\n  ?u \\<in> V \\<Longrightarrow>\n  sum f (outgoing ?u) = (\\<Sum>v\\<in>V. f (?u, v))\n  U \\<subseteq> V\n\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>U. sum f (outgoing u)) =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>V. f (u, v))", "by (meson subsetCE sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>U. sum f (outgoing u)) =\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>V. f (u, v))\n\ngoal (1 subgoal):\n 1. sum (excess f) U =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u)) -\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))", "also"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>U. sum f (outgoing u)) =\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>V. f (u, v))\n\ngoal (1 subgoal):\n 1. sum (excess f) U =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u)) -\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))", "have \"\\<dots> = (\\<Sum>u\\<in>U. (\\<Sum>v\\<in>U. f (u, v))) + (\\<Sum>u\\<in>U. (\\<Sum>v\\<in>U'. f (u, v)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>U. \\<Sum>v\\<in>V. f (u, v)) =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (u, v)) +\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>U. \\<Sum>v\\<in>V. f (u, v)) =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (u, v)) +\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))", "have \"(\\<Sum>v\\<in>V. f (u, v)) = (\\<Sum>v\\<in>U. f (u, v)) + (\\<Sum>v\\<in>U'. f (u, v))\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>V. f (u, v)) =\n    (\\<Sum>v\\<in>U. f (u, v)) + (\\<Sum>v\\<in>U'. f (u, v))", "using U'_def fct1 finite_V"], ["proof (prove)\nusing this:\n  U' = V - U\n  U \\<subseteq> V\n  finite V\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>V. f (u, v)) =\n    (\\<Sum>v\\<in>U. f (u, v)) + (\\<Sum>v\\<in>U'. f (u, v))", "by (metis ab_semigroup_add_class.add.commute sum.subset_diff)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>V. f (?u, v)) =\n  (\\<Sum>v\\<in>U. f (?u, v)) + (\\<Sum>v\\<in>U'. f (?u, v))\n\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>U. \\<Sum>v\\<in>V. f (u, v)) =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (u, v)) +\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>v\\<in>V. f (?u, v)) =\n  (\\<Sum>v\\<in>U. f (?u, v)) + (\\<Sum>v\\<in>U'. f (?u, v))\n\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>U. \\<Sum>v\\<in>V. f (u, v)) =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (u, v)) +\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))", "by (simp add: sum.distrib)"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>V. f (u, v)) =\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (u, v)) +\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>V. f (u, v)) =\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (u, v)) +\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))\n\ngoal (1 subgoal):\n 1. sum (excess f) U =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u)) -\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))", "also"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>V. f (u, v)) =\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (u, v)) +\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))\n\ngoal (1 subgoal):\n 1. sum (excess f) U =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u)) -\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))", "have \"(\\<Sum>u\\<in>U. (\\<Sum>v\\<in>U. f (u, v))) = (\\<Sum>u\\<in>U. (\\<Sum>v\\<in>U. f (v, u)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (u, v)) =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (u, v)) =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (u, v)) =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u))", "fix A :: \"nat set\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (u, v)) =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u))", "assume \"finite A\""], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (u, v)) =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u))", "then"], ["proof (chain)\npicking this:\n  finite A", "have \"(\\<Sum>u\\<in>A. (\\<Sum>v\\<in>A. f (u, v))) = (\\<Sum>u\\<in>A. (\\<Sum>v\\<in>A. f (v, u)))\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n    (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))", "proof (induction \"card A\" arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>0 = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n                         (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))\n 2. \\<And>x A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>x = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (u, v)) =\n                                     (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (v, u));\n        Suc x = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n                         (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))", "case 0"], ["proof (state)\nthis:\n  0 = card A\n  finite A\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>0 = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n                         (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))\n 2. \\<And>x A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>x = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (u, v)) =\n                                     (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (v, u));\n        Suc x = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n                         (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))", "then"], ["proof (chain)\npicking this:\n  0 = card A\n  finite A", "show ?case"], ["proof (prove)\nusing this:\n  0 = card A\n  finite A\n\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n    (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n  (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>x = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (u, v)) =\n                                     (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (v, u));\n        Suc x = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n                         (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>x = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (u, v)) =\n                                     (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (v, u));\n        Suc x = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n                         (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))", "case (Suc x)"], ["proof (state)\nthis:\n  \\<lbrakk>x = card ?A; finite ?A\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>u\\<in>?A. \\<Sum>v\\<in>?A. f (u, v)) =\n                    (\\<Sum>u\\<in>?A. \\<Sum>v\\<in>?A. f (v, u))\n  Suc x = card A\n  finite A\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>x = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (u, v)) =\n                                     (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (v, u));\n        Suc x = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n                         (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>x = card ?A; finite ?A\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>u\\<in>?A. \\<Sum>v\\<in>?A. f (u, v)) =\n                    (\\<Sum>u\\<in>?A. \\<Sum>v\\<in>?A. f (v, u))\n  Suc x = card A\n  finite A", "obtain A' a \n              where o1:\"A = insert a A'\" and o2:\"x = card A'\" and o3:\"finite A'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x = card ?A; finite ?A\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>u\\<in>?A. \\<Sum>v\\<in>?A. f (u, v)) =\n                    (\\<Sum>u\\<in>?A. \\<Sum>v\\<in>?A. f (v, u))\n  Suc x = card A\n  finite A\n\ngoal (1 subgoal):\n 1. (\\<And>a A'.\n        \\<lbrakk>A = insert a A'; x = card A'; finite A'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis card_insert_disjoint card_le_Suc_iff le_refl nat.inject)"], ["proof (state)\nthis:\n  A = insert a A'\n  x = card A'\n  finite A'\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>x = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (u, v)) =\n                                     (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (v, u));\n        Suc x = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n                         (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))", "then"], ["proof (chain)\npicking this:\n  A = insert a A'\n  x = card A'\n  finite A'", "have lm:\"(\\<Sum>e\\<in>A. g e) = (\\<Sum>e\\<in>A'. g e) + g a\" \n              for g :: \"nat \\<Rightarrow> 'a\""], ["proof (prove)\nusing this:\n  A = insert a A'\n  x = card A'\n  finite A'\n\ngoal (1 subgoal):\n 1. sum g A = sum g A' + g a", "using Suc.hyps(2)"], ["proof (prove)\nusing this:\n  A = insert a A'\n  x = card A'\n  finite A'\n  Suc x = card A\n\ngoal (1 subgoal):\n 1. sum g A = sum g A' + g a", "by (metis card_insert_if n_not_Suc_n \n                        semiring_normalization_rules(24) sum.insert)"], ["proof (state)\nthis:\n  sum ?g A = sum ?g A' + ?g a\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>x = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (u, v)) =\n                                     (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (v, u));\n        Suc x = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n                         (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))", "have \"(\\<Sum>u\\<in>A. (\\<Sum>v\\<in>A. f (u, v))) \n              = (\\<Sum>u\\<in>A'. (\\<Sum>v\\<in>A. f (u, v))) + (\\<Sum>v\\<in>A. f (a, v))\"\n              (is \"_ = ?R1 + ?R2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n    (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A. f (u, v)) + (\\<Sum>v\\<in>A. f (a, v))", "using lm"], ["proof (prove)\nusing this:\n  sum ?g A = sum ?g A' + ?g a\n\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n    (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A. f (u, v)) + (\\<Sum>v\\<in>A. f (a, v))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n  (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A. f (u, v)) + (\\<Sum>v\\<in>A. f (a, v))\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>x = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (u, v)) =\n                                     (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (v, u));\n        Suc x = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n                         (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))", "also"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n  (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A. f (u, v)) + (\\<Sum>v\\<in>A. f (a, v))\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>x = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (u, v)) =\n                                     (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (v, u));\n        Suc x = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n                         (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))", "have \"?R1 = (\\<Sum>u\\<in>A'. (\\<Sum>v\\<in>A'. f (u, v))) + (\\<Sum>u\\<in>A'. f(u, a))\" \n              (is \"_ = ?R1_1 + ?R1_2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A. f (u, v)) =\n    (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A'. f (u, v)) + (\\<Sum>u\\<in>A'. f (u, a))", "using lm sum.distrib"], ["proof (prove)\nusing this:\n  sum ?g A = sum ?g A' + ?g a\n  (\\<Sum>x\\<in>?A. ?g x + ?h x) = sum ?g ?A + sum ?h ?A\n\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A. f (u, v)) =\n    (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A'. f (u, v)) + (\\<Sum>u\\<in>A'. f (u, a))", "by force"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A. f (u, v)) =\n  (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A'. f (u, v)) + (\\<Sum>u\\<in>A'. f (u, a))\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>x = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (u, v)) =\n                                     (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (v, u));\n        Suc x = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n                         (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))", "also"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A. f (u, v)) =\n  (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A'. f (u, v)) + (\\<Sum>u\\<in>A'. f (u, a))\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>x = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (u, v)) =\n                                     (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (v, u));\n        Suc x = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n                         (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))", "note add.assoc"], ["proof (state)\nthis:\n  ?a + ?b + ?c = ?a + (?b + ?c)\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>x = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (u, v)) =\n                                     (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (v, u));\n        Suc x = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n                         (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))", "also"], ["proof (state)\nthis:\n  ?a + ?b + ?c = ?a + (?b + ?c)\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>x = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (u, v)) =\n                                     (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (v, u));\n        Suc x = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n                         (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))", "have \"?R1_2 + ?R2 = (\\<Sum>u\\<in>A'. f(a, u)) + (\\<Sum>v\\<in>A. f(v, a))\"\n              (is \"_ = ?R1_2' + ?R2'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>A'. f (u, a)) + (\\<Sum>v\\<in>A. f (a, v)) =\n    (\\<Sum>u\\<in>A'. f (a, u)) + (\\<Sum>v\\<in>A. f (v, a))", "using lm"], ["proof (prove)\nusing this:\n  sum ?g A = sum ?g A' + ?g a\n\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>A'. f (u, a)) + (\\<Sum>v\\<in>A. f (a, v)) =\n    (\\<Sum>u\\<in>A'. f (a, u)) + (\\<Sum>v\\<in>A. f (v, a))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>A'. f (u, a)) + (\\<Sum>v\\<in>A. f (a, v)) =\n  (\\<Sum>u\\<in>A'. f (a, u)) + (\\<Sum>v\\<in>A. f (v, a))\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>x = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (u, v)) =\n                                     (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (v, u));\n        Suc x = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n                         (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))", "also"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>A'. f (u, a)) + (\\<Sum>v\\<in>A. f (a, v)) =\n  (\\<Sum>u\\<in>A'. f (a, u)) + (\\<Sum>v\\<in>A. f (v, a))\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>x = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (u, v)) =\n                                     (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (v, u));\n        Suc x = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n                         (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))", "have \"?R1_1 = (\\<Sum>u\\<in>A'. (\\<Sum>v\\<in>A'. f (v, u)))\" \n              (is \"_ = ?R1_1'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A'. f (u, v)) =\n    (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A'. f (v, u))", "using Suc.hyps(1)[of A'] o2 o3"], ["proof (prove)\nusing this:\n  \\<lbrakk>x = card A'; finite A'\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A'. f (u, v)) =\n                    (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A'. f (v, u))\n  x = card A'\n  finite A'\n\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A'. f (u, v)) =\n    (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A'. f (v, u))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A'. f (u, v)) =\n  (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A'. f (v, u))\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>x = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (u, v)) =\n                                     (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (v, u));\n        Suc x = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n                         (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))", "also"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A'. f (u, v)) =\n  (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A'. f (v, u))\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>x = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (u, v)) =\n                                     (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (v, u));\n        Suc x = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n                         (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))", "note add.assoc[symmetric]"], ["proof (state)\nthis:\n  ?a + (?b + ?c) = ?a + ?b + ?c\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>x = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (u, v)) =\n                                     (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (v, u));\n        Suc x = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n                         (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))", "also"], ["proof (state)\nthis:\n  ?a + (?b + ?c) = ?a + ?b + ?c\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>x = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (u, v)) =\n                                     (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (v, u));\n        Suc x = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n                         (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))", "have \"?R1_1' + ?R1_2' = (\\<Sum>u\\<in>A'. (\\<Sum>v\\<in>A. f (v, u)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A'. f (v, u)) +\n    (\\<Sum>u\\<in>A'. f (a, u)) =\n    (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A. f (v, u))", "by (metis (no_types, lifting) lm sum.cong sum.distrib)"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A'. f (v, u)) + (\\<Sum>u\\<in>A'. f (a, u)) =\n  (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A. f (v, u))\n\ngoal (1 subgoal):\n 1. \\<And>x A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>x = card A; finite A\\<rbrakk>\n                   \\<Longrightarrow> (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (u, v)) =\n                                     (\\<Sum>u\\<in>A.\n  \\<Sum>v\\<in>A. f (v, u));\n        Suc x = card A; finite A\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n                         (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n  (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A. f (v, u)) + (\\<Sum>v\\<in>A. f (v, a))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n  (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A. f (v, u)) + (\\<Sum>v\\<in>A. f (v, a))\n\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n    (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))", "using lm[symmetric]"], ["proof (prove)\nusing this:\n  (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n  (\\<Sum>u\\<in>A'. \\<Sum>v\\<in>A. f (v, u)) + (\\<Sum>v\\<in>A. f (v, a))\n  sum ?g A' + ?g a = sum ?g A\n\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n    (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n  (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (u, v)) =\n  (\\<Sum>u\\<in>A. \\<Sum>v\\<in>A. f (v, u))\n\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (u, v)) =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u))", "}"], ["proof (state)\nthis:\n  finite ?A2 \\<Longrightarrow>\n  (\\<Sum>u\\<in>?A2. \\<Sum>v\\<in>?A2. f (u, v)) =\n  (\\<Sum>u\\<in>?A2. \\<Sum>v\\<in>?A2. f (v, u))\n\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (u, v)) =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u))", "note this[of U]"], ["proof (state)\nthis:\n  finite U \\<Longrightarrow>\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (u, v)) =\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u))\n\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (u, v)) =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u))", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite U \\<Longrightarrow>\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (u, v)) =\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u))\n\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (u, v)) =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u))", "using fct1 finite_V finite_subset"], ["proof (prove)\nusing this:\n  finite U \\<Longrightarrow>\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (u, v)) =\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u))\n  U \\<subseteq> V\n  finite V\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (u, v)) =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (u, v)) =\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (u, v)) =\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u))\n\ngoal (1 subgoal):\n 1. sum (excess f) U =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u)) -\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))", "finally"], ["proof (chain)\npicking this:\n  sum (excess f) U =\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u)) +\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u)) -\n  ((\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u)) +\n   (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v)))", "show ?thesis"], ["proof (prove)\nusing this:\n  sum (excess f) U =\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u)) +\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u)) -\n  ((\\<Sum>u\\<in>U. \\<Sum>v\\<in>U. f (v, u)) +\n   (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v)))\n\ngoal (1 subgoal):\n 1. sum (excess f) U =\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u)) -\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))", "by arith"], ["proof (state)\nthis:\n  sum (excess f) U =\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u)) -\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (excess f) U =\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u)) -\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))\n\ngoal (1 subgoal):\n 1. s \\<notin> U \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  sum (excess f) U =\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u)) -\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))\n\ngoal (1 subgoal):\n 1. s \\<notin> U \\<Longrightarrow> False", "have \"(\\<Sum>u\\<in>U. excess f u) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < sum (excess f) U", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (0::'a) < sum (excess f) U", "have \"u \\<in> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> U", "using U_def"], ["proof (prove)\nusing this:\n  U = {uu_. \\<exists>p v. uu_ = v \\<and> cf.isSimplePath u p v}\n\ngoal (1 subgoal):\n 1. u \\<in> U", "by simp"], ["proof (state)\nthis:\n  u \\<in> U\n\ngoal (1 subgoal):\n 1. (0::'a) < sum (excess f) U", "moreover"], ["proof (state)\nthis:\n  u \\<in> U\n\ngoal (1 subgoal):\n 1. (0::'a) < sum (excess f) U", "have \"u \\<in> U \\<Longrightarrow> excess f u \\<ge> 0\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> U \\<Longrightarrow> (0::'a) \\<le> excess f u", "using fct1 excess_non_negative' \\<open>s \\<notin> U\\<close>"], ["proof (prove)\nusing this:\n  U \\<subseteq> V\n  \\<forall>v\\<in>V - {s}. (0::'a) \\<le> excess f v\n  s \\<notin> U\n\ngoal (1 subgoal):\n 1. u \\<in> U \\<Longrightarrow> (0::'a) \\<le> excess f u", "by auto"], ["proof (state)\nthis:\n  ?u \\<in> U \\<Longrightarrow> (0::'a) \\<le> excess f ?u\n\ngoal (1 subgoal):\n 1. (0::'a) < sum (excess f) U", "ultimately"], ["proof (chain)\npicking this:\n  u \\<in> U\n  ?u \\<in> U \\<Longrightarrow> (0::'a) \\<le> excess f ?u", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<in> U\n  ?u \\<in> U \\<Longrightarrow> (0::'a) \\<le> excess f ?u\n\ngoal (1 subgoal):\n 1. (0::'a) < sum (excess f) U", "using assms fct1 finite_V"], ["proof (prove)\nusing this:\n  u \\<in> U\n  ?u \\<in> U \\<Longrightarrow> (0::'a) \\<le> excess f ?u\n  (0::'a) < excess f u\n  U \\<subseteq> V\n  finite V\n\ngoal (1 subgoal):\n 1. (0::'a) < sum (excess f) U", "by (metis Diff_cancel Diff_eq_empty_iff \n                  Diff_infinite_finite finite_Diff sum_pos2)"], ["proof (state)\nthis:\n  (0::'a) < sum (excess f) U\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (0::'a) < sum (excess f) U\n\ngoal (1 subgoal):\n 1. s \\<notin> U \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  sum (excess f) U =\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u)) -\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))\n  (0::'a) < sum (excess f) U", "have \n      fct2: \"(\\<Sum>u\\<in>U. (\\<Sum>v\\<in>U'. f (v, u))) - (\\<Sum>u\\<in>U. (\\<Sum>v\\<in>U'. f (u, v))) > 0\""], ["proof (prove)\nusing this:\n  sum (excess f) U =\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u)) -\n  (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))\n  (0::'a) < sum (excess f) U\n\ngoal (1 subgoal):\n 1. (0::'a)\n    < (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u)) -\n      (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))", "by simp"], ["proof (state)\nthis:\n  (0::'a)\n  < (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u)) -\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))\n\ngoal (1 subgoal):\n 1. s \\<notin> U \\<Longrightarrow> False", "have fct3: \"(\\<Sum>u\\<in>U. (\\<Sum>v\\<in>U'. f (v, u))) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) < (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (0::'a) < (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u))", "have \"(\\<Sum>u\\<in>U. (\\<Sum>v\\<in>U'. f (v, u))) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u))", "using capacity_const"], ["proof (prove)\nusing this:\n  \\<forall>e. (0::'a) \\<le> f e \\<and> f e \\<le> c e\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u))", "by (simp add: sum_nonneg)"], ["proof (state)\nthis:\n  (0::'a) \\<le> (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u))\n\ngoal (1 subgoal):\n 1. (0::'a) < (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u))", "moreover"], ["proof (state)\nthis:\n  (0::'a) \\<le> (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u))\n\ngoal (1 subgoal):\n 1. (0::'a) < (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u))", "have \"(\\<Sum>u\\<in>U. (\\<Sum>v\\<in>U'. f (u, v))) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))", "using capacity_const"], ["proof (prove)\nusing this:\n  \\<forall>e. (0::'a) \\<le> f e \\<and> f e \\<le> c e\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))", "by (simp add: sum_nonneg)"], ["proof (state)\nthis:\n  (0::'a) \\<le> (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))\n\ngoal (1 subgoal):\n 1. (0::'a) < (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u))", "ultimately"], ["proof (chain)\npicking this:\n  (0::'a) \\<le> (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u))\n  (0::'a) \\<le> (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))", "show ?thesis"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u))\n  (0::'a) \\<le> (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))\n\ngoal (1 subgoal):\n 1. (0::'a) < (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u))", "using fct2"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u))\n  (0::'a) \\<le> (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))\n  (0::'a)\n  < (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u)) -\n    (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (u, v))\n\ngoal (1 subgoal):\n 1. (0::'a) < (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u))", "by simp"], ["proof (state)\nthis:\n  (0::'a) < (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (0::'a) < (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u))\n\ngoal (1 subgoal):\n 1. s \\<notin> U \\<Longrightarrow> False", "have \"\\<exists>u' v'. (u' \\<in> U \\<and> v' \\<in> U' \\<and> f (v', u') > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u' v'.\n       u' \\<in> U \\<and> v' \\<in> U' \\<and> (0::'a) < f (v', u')", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>u' v'.\n       u' \\<in> U \\<and>\n       v' \\<in> U' \\<and> (0::'a) < f (v', u') \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<exists>u' v'. u' \\<in> U \\<and> v' \\<in> U' \\<and> f (v', u') > 0)\""], ["proof (state)\nthis:\n  \\<nexists>u' v'. u' \\<in> U \\<and> v' \\<in> U' \\<and> (0::'a) < f (v', u')\n\ngoal (1 subgoal):\n 1. \\<nexists>u' v'.\n       u' \\<in> U \\<and>\n       v' \\<in> U' \\<and> (0::'a) < f (v', u') \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<nexists>u' v'. u' \\<in> U \\<and> v' \\<in> U' \\<and> (0::'a) < f (v', u')", "have \"(\\<forall>u' v'. (u' \\<in> U \\<and> v' \\<in> U' \\<longrightarrow> f (v', u') = 0))\""], ["proof (prove)\nusing this:\n  \\<nexists>u' v'. u' \\<in> U \\<and> v' \\<in> U' \\<and> (0::'a) < f (v', u')\n\ngoal (1 subgoal):\n 1. \\<forall>u' v'.\n       u' \\<in> U \\<and> v' \\<in> U' \\<longrightarrow> f (v', u') = (0::'a)", "using capacity_const"], ["proof (prove)\nusing this:\n  \\<nexists>u' v'. u' \\<in> U \\<and> v' \\<in> U' \\<and> (0::'a) < f (v', u')\n  \\<forall>e. (0::'a) \\<le> f e \\<and> f e \\<le> c e\n\ngoal (1 subgoal):\n 1. \\<forall>u' v'.\n       u' \\<in> U \\<and> v' \\<in> U' \\<longrightarrow> f (v', u') = (0::'a)", "by (metis le_neq_trans)"], ["proof (state)\nthis:\n  \\<forall>u' v'.\n     u' \\<in> U \\<and> v' \\<in> U' \\<longrightarrow> f (v', u') = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<nexists>u' v'.\n       u' \\<in> U \\<and>\n       v' \\<in> U' \\<and> (0::'a) < f (v', u') \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  \\<forall>u' v'.\n     u' \\<in> U \\<and> v' \\<in> U' \\<longrightarrow> f (v', u') = (0::'a)\n\ngoal (1 subgoal):\n 1. False", "using fct3"], ["proof (prove)\nusing this:\n  \\<forall>u' v'.\n     u' \\<in> U \\<and> v' \\<in> U' \\<longrightarrow> f (v', u') = (0::'a)\n  (0::'a) < (\\<Sum>u\\<in>U. \\<Sum>v\\<in>U'. f (v, u))\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>u' v'. u' \\<in> U \\<and> v' \\<in> U' \\<and> (0::'a) < f (v', u')\n\ngoal (1 subgoal):\n 1. s \\<notin> U \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>u' v'. u' \\<in> U \\<and> v' \\<in> U' \\<and> (0::'a) < f (v', u')", "obtain u' v' where \"u' \\<in> U\" and \"v' \\<in> U'\" and \"f (v', u') > 0\""], ["proof (prove)\nusing this:\n  \\<exists>u' v'. u' \\<in> U \\<and> v' \\<in> U' \\<and> (0::'a) < f (v', u')\n\ngoal (1 subgoal):\n 1. (\\<And>u' v'.\n        \\<lbrakk>u' \\<in> U; v' \\<in> U'; (0::'a) < f (v', u')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  u' \\<in> U\n  v' \\<in> U'\n  (0::'a) < f (v', u')\n\ngoal (1 subgoal):\n 1. s \\<notin> U \\<Longrightarrow> False", "obtain p1 where \"cf.isSimplePath u p1 u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1.\n        cf.isSimplePath u p1 u' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using U_def \\<open>u' \\<in> U\\<close>"], ["proof (prove)\nusing this:\n  U = {uu_. \\<exists>p v. uu_ = v \\<and> cf.isSimplePath u p v}\n  u' \\<in> U\n\ngoal (1 subgoal):\n 1. (\\<And>p1.\n        cf.isSimplePath u p1 u' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  cf.isSimplePath u p1 u'\n\ngoal (1 subgoal):\n 1. s \\<notin> U \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  cf.isSimplePath u p1 u'\n\ngoal (1 subgoal):\n 1. s \\<notin> U \\<Longrightarrow> False", "have \"(u', v') \\<in> cf.E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u', v') \\<in> cf.E", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (u', v') \\<in> cf.E", "have \"(v', u') \\<in> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v', u') \\<in> E", "using capacity_const \\<open>f (v', u') > 0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>e. (0::'a) \\<le> f e \\<and> f e \\<le> c e\n  (0::'a) < f (v', u')\n\ngoal (1 subgoal):\n 1. (v', u') \\<in> E", "by (metis not_less zero_flow_simp)"], ["proof (state)\nthis:\n  (v', u') \\<in> E\n\ngoal (1 subgoal):\n 1. (u', v') \\<in> cf.E", "then"], ["proof (chain)\npicking this:\n  (v', u') \\<in> E", "have \"cf (u', v') > 0\""], ["proof (prove)\nusing this:\n  (v', u') \\<in> E\n\ngoal (1 subgoal):\n 1. (0::'a) < cf (u', v')", "unfolding cf_def"], ["proof (prove)\nusing this:\n  (v', u') \\<in> E\n\ngoal (1 subgoal):\n 1. (0::'a)\n    < (case (u', v') of\n       (u, v) \\<Rightarrow>\n         if (u, v) \\<in> E then c (u, v) - f (u, v)\n         else if (v, u) \\<in> E then f (v, u) else (0::'a))", "using no_parallel_edge \\<open>f (v', u') > 0\\<close>"], ["proof (prove)\nusing this:\n  (v', u') \\<in> E\n  \\<forall>u v. (u, v) \\<in> E \\<longrightarrow> (v, u) \\<notin> E\n  (0::'a) < f (v', u')\n\ngoal (1 subgoal):\n 1. (0::'a)\n    < (case (u', v') of\n       (u, v) \\<Rightarrow>\n         if (u, v) \\<in> E then c (u, v) - f (u, v)\n         else if (v, u) \\<in> E then f (v, u) else (0::'a))", "by (auto split: if_split)"], ["proof (state)\nthis:\n  (0::'a) < cf (u', v')\n\ngoal (1 subgoal):\n 1. (u', v') \\<in> cf.E", "thus ?thesis"], ["proof (prove)\nusing this:\n  (0::'a) < cf (u', v')\n\ngoal (1 subgoal):\n 1. (u', v') \\<in> cf.E", "unfolding cf.E_def"], ["proof (prove)\nusing this:\n  (0::'a) < cf (u', v')\n\ngoal (1 subgoal):\n 1. (u', v') \\<in> {(u, v). cf (u, v) \\<noteq> (0::'a)}", "by simp"], ["proof (state)\nthis:\n  (u', v') \\<in> cf.E\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (u', v') \\<in> cf.E\n\ngoal (1 subgoal):\n 1. s \\<notin> U \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  cf.isSimplePath u p1 u'\n  (u', v') \\<in> cf.E", "have \"cf.isPath u (p1 @ [(u', v')]) v'\""], ["proof (prove)\nusing this:\n  cf.isSimplePath u p1 u'\n  (u', v') \\<in> cf.E\n\ngoal (1 subgoal):\n 1. cf.isPath u (p1 @ [(u', v')]) v'", "using Graph.isPath_append_edge Graph.isSimplePath_def"], ["proof (prove)\nusing this:\n  cf.isSimplePath u p1 u'\n  (u', v') \\<in> cf.E\n  \\<lbrakk>Graph.isPath ?c ?v ?p ?v'; (?v', ?v'') \\<in> Graph.E ?c\\<rbrakk>\n  \\<Longrightarrow> Graph.isPath ?c ?v (?p @ [(?v', ?v'')]) ?v''\n  Graph.isSimplePath ?c ?u ?p ?v \\<equiv>\n  Graph.isPath ?c ?u ?p ?v \\<and> distinct (cf.pathVertices ?u ?p)\n\ngoal (1 subgoal):\n 1. cf.isPath u (p1 @ [(u', v')]) v'", "by blast"], ["proof (state)\nthis:\n  cf.isPath u (p1 @ [(u', v')]) v'\n\ngoal (1 subgoal):\n 1. s \\<notin> U \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  cf.isPath u (p1 @ [(u', v')]) v'", "obtain p2 where \"cf.isSimplePath u p2 v'\""], ["proof (prove)\nusing this:\n  cf.isPath u (p1 @ [(u', v')]) v'\n\ngoal (1 subgoal):\n 1. (\\<And>p2.\n        cf.isSimplePath u p2 v' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cf.isSPath_pathLE"], ["proof (prove)\nusing this:\n  cf.isPath u (p1 @ [(u', v')]) v'\n  cf.isPath ?s ?p ?t \\<Longrightarrow> \\<exists>p'. cf.isSimplePath ?s p' ?t\n\ngoal (1 subgoal):\n 1. (\\<And>p2.\n        cf.isSimplePath u p2 v' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  cf.isSimplePath u p2 v'\n\ngoal (1 subgoal):\n 1. s \\<notin> U \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  cf.isSimplePath u p2 v'", "have \"v' \\<in> U\""], ["proof (prove)\nusing this:\n  cf.isSimplePath u p2 v'\n\ngoal (1 subgoal):\n 1. v' \\<in> U", "using U_def"], ["proof (prove)\nusing this:\n  cf.isSimplePath u p2 v'\n  U = {uu_. \\<exists>p v. uu_ = v \\<and> cf.isSimplePath u p v}\n\ngoal (1 subgoal):\n 1. v' \\<in> U", "by auto"], ["proof (state)\nthis:\n  v' \\<in> U\n\ngoal (1 subgoal):\n 1. s \\<notin> U \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  v' \\<in> U\n\ngoal (1 subgoal):\n 1. False", "using \\<open>v' \\<in> U'\\<close> and U'_def"], ["proof (prove)\nusing this:\n  v' \\<in> U\n  v' \\<in> U'\n  U' = V - U\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s \\<in> U\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        cf.isSimplePath u p s \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  s \\<in> U", "obtain p' where \"cf.isSimplePath u p' s\""], ["proof (prove)\nusing this:\n  s \\<in> U\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        cf.isSimplePath u p' s \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using U_def"], ["proof (prove)\nusing this:\n  s \\<in> U\n  U = {uu_. \\<exists>p v. uu_ = v \\<and> cf.isSimplePath u p v}\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        cf.isSimplePath u p' s \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  cf.isSimplePath u p' s\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        cf.isSimplePath u p s \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  cf.isSimplePath u p' s\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Relabel operations preserve the height bound~\\cormen{26.20}.\\<close>"], ["", "lemma relabel_pres_height_bound:\n  assumes \"relabel_precond f l u\"\n  shows \"Height_Bounded_Labeling c s t f (relabel_effect f l u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f (relabel_effect f l u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f (relabel_effect f l u)", "let ?l' = \"relabel_effect f l u\""], ["proof (state)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f (relabel_effect f l u)", "from relabel_pres_Labeling[OF assms]"], ["proof (chain)\npicking this:\n  Labeling c s t f (relabel_effect f l u)", "interpret l': Labeling c s t f ?l'"], ["proof (prove)\nusing this:\n  Labeling c s t f (relabel_effect f l u)\n\ngoal (1 subgoal):\n 1. Labeling c s t f (relabel_effect f l u)", "."], ["proof (state)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f (relabel_effect f l u)", "from assms"], ["proof (chain)\npicking this:\n  relabel_precond f l u", "have \"excess f u > 0\""], ["proof (prove)\nusing this:\n  relabel_precond f l u\n\ngoal (1 subgoal):\n 1. (0::'a) < excess f u", "unfolding relabel_precond_def"], ["proof (prove)\nusing this:\n  u \\<noteq> t \\<and>\n  (0::'a) < excess f u \\<and>\n  (\\<forall>v. (u, v) \\<in> cf.E \\<longrightarrow> l u \\<noteq> l v + 1)\n\ngoal (1 subgoal):\n 1. (0::'a) < excess f u", "by auto"], ["proof (state)\nthis:\n  (0::'a) < excess f u\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f (relabel_effect f l u)", "with l'.excess_imp_source_path"], ["proof (chain)\npicking this:\n  \\<lbrakk>(0::'a) < excess f ?u;\n   \\<And>p. cf.isSimplePath ?u p s \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  (0::'a) < excess f u", "obtain p where p_obt: \"cf.isSimplePath u p s\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(0::'a) < excess f ?u;\n   \\<And>p. cf.isSimplePath ?u p s \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  (0::'a) < excess f u\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        cf.isSimplePath u p s \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  cf.isSimplePath u p s\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f (relabel_effect f l u)", "have \"u \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> V", "using excess_nodes_only \\<open>excess f u > 0\\<close>"], ["proof (prove)\nusing this:\n  (0::'a) < excess f ?v \\<Longrightarrow> ?v \\<in> V\n  (0::'a) < excess f u\n\ngoal (1 subgoal):\n 1. u \\<in> V", "."], ["proof (state)\nthis:\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f (relabel_effect f l u)", "then"], ["proof (chain)\npicking this:\n  u \\<in> V", "have \"length p < card V\""], ["proof (prove)\nusing this:\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. length p < card V", "using cf.simplePath_length_less_V[of u p] p_obt"], ["proof (prove)\nusing this:\n  u \\<in> V\n  \\<lbrakk>u \\<in> cf.V; cf.isSimplePath u p ?v\\<rbrakk>\n  \\<Longrightarrow> length p < card cf.V\n  cf.isSimplePath u p s\n\ngoal (1 subgoal):\n 1. length p < card V", "by auto"], ["proof (state)\nthis:\n  length p < card V\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f (relabel_effect f l u)", "moreover"], ["proof (state)\nthis:\n  length p < card V\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f (relabel_effect f l u)", "have \"?l' u \\<le> ?l' s + length p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. relabel_effect f l u u \\<le> relabel_effect f l u s + length p", "using p_obt l'.gen_valid[of u p s] p_obt"], ["proof (prove)\nusing this:\n  cf.isSimplePath u p s\n  cf.isPath u p s \\<Longrightarrow>\n  relabel_effect f l u u \\<le> relabel_effect f l u s + length p\n  cf.isSimplePath u p s\n\ngoal (1 subgoal):\n 1. relabel_effect f l u u \\<le> relabel_effect f l u s + length p", "unfolding cf.isSimplePath_def"], ["proof (prove)\nusing this:\n  cf.isPath u p s \\<and> distinct (cf.pathVertices u p)\n  cf.isPath u p s \\<Longrightarrow>\n  relabel_effect f l u u \\<le> relabel_effect f l u s + length p\n  cf.isPath u p s \\<and> distinct (cf.pathVertices u p)\n\ngoal (1 subgoal):\n 1. relabel_effect f l u u \\<le> relabel_effect f l u s + length p", "by auto"], ["proof (state)\nthis:\n  relabel_effect f l u u \\<le> relabel_effect f l u s + length p\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f (relabel_effect f l u)", "moreover"], ["proof (state)\nthis:\n  relabel_effect f l u u \\<le> relabel_effect f l u s + length p\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f (relabel_effect f l u)", "have \"?l' s = card V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. relabel_effect f l u s = card V", "using l'.Labeling_axioms Labeling_def Labeling_axioms_def"], ["proof (prove)\nusing this:\n  Labeling c s t f (relabel_effect f l u)\n  Labeling ?c ?s ?t ?f ?l \\<equiv>\n  NPreflow ?c ?s ?t ?f \\<and> Labeling_axioms ?c ?s ?t ?f ?l\n  Labeling_axioms ?c ?s ?t ?f ?l \\<equiv>\n  (\\<forall>u v.\n      (u, v) \\<in> Graph.E (residualGraph ?c ?f) \\<longrightarrow>\n      ?l u \\<le> ?l v + 1) \\<and>\n  ?l ?s = card (Graph.V ?c) \\<and> ?l ?t = 0\n\ngoal (1 subgoal):\n 1. relabel_effect f l u s = card V", "by auto"], ["proof (state)\nthis:\n  relabel_effect f l u s = card V\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f (relabel_effect f l u)", "ultimately"], ["proof (chain)\npicking this:\n  length p < card V\n  relabel_effect f l u u \\<le> relabel_effect f l u s + length p\n  relabel_effect f l u s = card V", "have \"?l' u \\<le> 2*card V - 1\""], ["proof (prove)\nusing this:\n  length p < card V\n  relabel_effect f l u u \\<le> relabel_effect f l u s + length p\n  relabel_effect f l u s = card V\n\ngoal (1 subgoal):\n 1. relabel_effect f l u u \\<le> 2 * card V - 1", "by auto"], ["proof (state)\nthis:\n  relabel_effect f l u u \\<le> 2 * card V - 1\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f (relabel_effect f l u)", "thus \"Height_Bounded_Labeling c s t f ?l'\""], ["proof (prove)\nusing this:\n  relabel_effect f l u u \\<le> 2 * card V - 1\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f (relabel_effect f l u)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. relabel_effect f l u u \\<le> 2 * card V - 1 \\<Longrightarrow>\n    \\<forall>ua\\<in>V. relabel_effect f l u ua \\<le> 2 * card V - 1", "using height_bound relabel_preserve_other"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>V. l u \\<le> 2 * card V - 1\n  ?u \\<noteq> ?v \\<Longrightarrow> relabel_effect f l ?u ?v = l ?v\n\ngoal (1 subgoal):\n 1. relabel_effect f l u u \\<le> 2 * card V - 1 \\<Longrightarrow>\n    \\<forall>ua\\<in>V. relabel_effect f l u ua \\<le> 2 * card V - 1", "by metis"], ["proof (state)\nthis:\n  Height_Bounded_Labeling c s t f (relabel_effect f l u)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Thus, the total number of relabel operations is \n  bounded by \\<open>O(V\\<^sup>2)\\<close>~\\cormen{26.21}. \n\n  We express this bound by defining a measure function, and show that \n  it is decreased by relabel operations.\n\\<close>"], ["", "definition (in Network) \"sum_heights_measure l \\<equiv> \\<Sum>v\\<in>V. 2*card V - l v\""], ["", "corollary relabel_measure:\n  assumes \"relabel_precond f l u\"\n  shows \"sum_heights_measure (relabel_effect f l u) < sum_heights_measure l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_heights_measure (relabel_effect f l u) < sum_heights_measure l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum_heights_measure (relabel_effect f l u) < sum_heights_measure l", "let ?l' = \"relabel_effect f l u\""], ["proof (state)\ngoal (1 subgoal):\n 1. sum_heights_measure (relabel_effect f l u) < sum_heights_measure l", "from relabel_pres_height_bound[OF assms]"], ["proof (chain)\npicking this:\n  Height_Bounded_Labeling c s t f (relabel_effect f l u)", "interpret l': Height_Bounded_Labeling c s t f ?l'"], ["proof (prove)\nusing this:\n  Height_Bounded_Labeling c s t f (relabel_effect f l u)\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f (relabel_effect f l u)", "."], ["proof (state)\ngoal (1 subgoal):\n 1. sum_heights_measure (relabel_effect f l u) < sum_heights_measure l", "from assms"], ["proof (chain)\npicking this:\n  relabel_precond f l u", "have \"u\\<in>V\""], ["proof (prove)\nusing this:\n  relabel_precond f l u\n\ngoal (1 subgoal):\n 1. u \\<in> V", "by (simp add: excess_nodes_only relabel_precond_def)"], ["proof (state)\nthis:\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. sum_heights_measure (relabel_effect f l u) < sum_heights_measure l", "hence V_split: \"V = insert u V\""], ["proof (prove)\nusing this:\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. V = insert u V", "by auto"], ["proof (state)\nthis:\n  V = insert u V\n\ngoal (1 subgoal):\n 1. sum_heights_measure (relabel_effect f l u) < sum_heights_measure l", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_heights_measure (relabel_effect f l u) < sum_heights_measure l", "using relabel_increase_u[OF assms] relabel_preserve_other[of u]"], ["proof (prove)\nusing this:\n  l u < relabel_effect f l u u\n  u \\<noteq> ?v \\<Longrightarrow> relabel_effect f l u ?v = l ?v\n\ngoal (1 subgoal):\n 1. sum_heights_measure (relabel_effect f l u) < sum_heights_measure l", "using l'.height_bound"], ["proof (prove)\nusing this:\n  l u < relabel_effect f l u u\n  u \\<noteq> ?v \\<Longrightarrow> relabel_effect f l u ?v = l ?v\n  \\<forall>ua\\<in>V. relabel_effect f l u ua \\<le> 2 * card V - 1\n\ngoal (1 subgoal):\n 1. sum_heights_measure (relabel_effect f l u) < sum_heights_measure l", "unfolding sum_heights_measure_def"], ["proof (prove)\nusing this:\n  l u < relabel_effect f l u u\n  u \\<noteq> ?v \\<Longrightarrow> relabel_effect f l u ?v = l ?v\n  \\<forall>ua\\<in>V. relabel_effect f l u ua \\<le> 2 * card V - 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>V. 2 * card V - relabel_effect f l u v)\n    < (\\<Sum>v\\<in>V. 2 * card V - l v)", "apply (rewrite at \"\\<Sum>_\\<in>\\<hole>. _\" V_split)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l u < relabel_effect f l u u;\n     \\<And>v. u \\<noteq> v \\<Longrightarrow> relabel_effect f l u v = l v;\n     \\<forall>ua\\<in>V. relabel_effect f l u ua \\<le> 2 * card V - 1;\n     l u < relabel_effect f l u u;\n     \\<And>v. u \\<noteq> v \\<Longrightarrow> relabel_effect f l u v = l v;\n     \\<forall>ua\\<in>V.\n        relabel_effect f l u ua \\<le> 2 * card V - 1\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>v\\<in>insert u V.\n                         2 * card V - relabel_effect f l u v)\n                      < (\\<Sum>v\\<in>insert u V. 2 * card V - l v)", "apply (subst sum.insert_remove[OF finite_V])+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l u < relabel_effect f l u u;\n     \\<And>v. u \\<noteq> v \\<Longrightarrow> relabel_effect f l u v = l v;\n     \\<forall>ua\\<in>V. relabel_effect f l u ua \\<le> 2 * card V - 1;\n     l u < relabel_effect f l u u;\n     \\<And>v. u \\<noteq> v \\<Longrightarrow> relabel_effect f l u v = l v;\n     \\<forall>ua\\<in>V.\n        relabel_effect f l u ua \\<le> 2 * card V - 1\\<rbrakk>\n    \\<Longrightarrow> 2 * card V - relabel_effect f l u u +\n                      (\\<Sum>v\\<in>V - {u}.\n                         2 * card V - relabel_effect f l u v)\n                      < 2 * card V - l u +\n                        (\\<Sum>v\\<in>V - {u}. 2 * card V - l v)", "using \\<open>u\\<in>V\\<close>"], ["proof (prove)\nusing this:\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l u < relabel_effect f l u u;\n     \\<And>v. u \\<noteq> v \\<Longrightarrow> relabel_effect f l u v = l v;\n     \\<forall>ua\\<in>V. relabel_effect f l u ua \\<le> 2 * card V - 1;\n     l u < relabel_effect f l u u;\n     \\<And>v. u \\<noteq> v \\<Longrightarrow> relabel_effect f l u v = l v;\n     \\<forall>ua\\<in>V.\n        relabel_effect f l u ua \\<le> 2 * card V - 1\\<rbrakk>\n    \\<Longrightarrow> 2 * card V - relabel_effect f l u u +\n                      (\\<Sum>v\\<in>V - {u}.\n                         2 * card V - relabel_effect f l u v)\n                      < 2 * card V - l u +\n                        (\\<Sum>v\\<in>V - {u}. 2 * card V - l v)", "by auto"], ["proof (state)\nthis:\n  sum_heights_measure (relabel_effect f l u) < sum_heights_measure l\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>Height Bounded Labeling\\<close>"], ["", "lemma (in Network) sum_height_measure_is_OV2: \n  \"sum_heights_measure l \\<le> 2*(card V)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_heights_measure l \\<le> 2 * (card V)\\<^sup>2", "unfolding  sum_heights_measure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>V. 2 * card V - l v) \\<le> 2 * (card V)\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>V. 2 * card V - l v) \\<le> 2 * (card V)\\<^sup>2", "have \"2 * card V - l v \\<le> 2 * card V\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * card V - l v \\<le> 2 * card V", "by auto"], ["proof (state)\nthis:\n  2 * card V - l ?v \\<le> 2 * card V\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>V. 2 * card V - l v) \\<le> 2 * (card V)\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  2 * card V - l ?v \\<le> 2 * card V", "have \"(\\<Sum>v\\<in>V. 2 * card V - l v) \\<le> (\\<Sum>v\\<in>V. 2 * card V)\""], ["proof (prove)\nusing this:\n  2 * card V - l ?v \\<le> 2 * card V\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>V. 2 * card V - l v) \\<le> (\\<Sum>v\\<in>V. 2 * card V)", "by (meson sum_mono)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>V. 2 * card V - l v) \\<le> (\\<Sum>v\\<in>V. 2 * card V)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>V. 2 * card V - l v) \\<le> 2 * (card V)\\<^sup>2", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>V. 2 * card V - l v) \\<le> (\\<Sum>v\\<in>V. 2 * card V)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>V. 2 * card V - l v) \\<le> 2 * (card V)\\<^sup>2", "have \"(\\<Sum>v\\<in>V. 2 * card V) = card V * (2 * card V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>V. 2 * card V) = card V * (2 * card V)", "using finite_V"], ["proof (prove)\nusing this:\n  finite V\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>V. 2 * card V) = card V * (2 * card V)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>V. 2 * card V) = card V * (2 * card V)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>V. 2 * card V - l v) \\<le> 2 * (card V)\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>v\\<in>V. 2 * card V - l v) \\<le> card V * (2 * card V)", "show \"(\\<Sum>v\\<in>V. 2 * card V - l v) \\<le> 2 * (card V)^2\""], ["proof (prove)\nusing this:\n  (\\<Sum>v\\<in>V. 2 * card V - l v) \\<le> card V * (2 * card V)\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>V. 2 * card V - l v) \\<le> 2 * (card V)\\<^sup>2", "by (simp add: power2_eq_square)"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>V. 2 * card V - l v) \\<le> 2 * (card V)\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Formulation of the Abstract Algorithm\\<close>"], ["", "text \\<open>We give a simple relational characterization \n  of the abstract algorithm as a labeled transition system,\n  where the labels indicate the type of operation (push or relabel) that\n  have been executed.\n\\<close>"], ["", "context Network\nbegin"], ["", "datatype pr_operation = is_PUSH: PUSH | is_RELABEL: RELABEL"], ["", "inductive_set pr_algo_lts \n  :: \"(('capacity flow\\<times>labeling) \\<times> pr_operation \\<times> ('capacity flow\\<times>labeling)) set\" \nwhere\n  push: \"\\<lbrakk>push_precond f l e\\<rbrakk> \n    \\<Longrightarrow> ((f,l),PUSH,(push_effect f e,l))\\<in>pr_algo_lts\"\n| relabel: \"\\<lbrakk>relabel_precond f l u\\<rbrakk>\n    \\<Longrightarrow> ((f,l),RELABEL,(f,relabel_effect f l u))\\<in>pr_algo_lts\""], ["", "end \\<comment> \\<open>Network\\<close>"], ["", "text \\<open>We show invariant maintenance and correctness on termination\\<close>"], ["", "lemma (in Height_Bounded_Labeling) pr_algo_maintains_hb_labeling:\n  assumes \"((f,l),a,(f',l')) \\<in> pr_algo_lts\"\n  shows \"Height_Bounded_Labeling c s t f' l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f' l'", "using assms"], ["proof (prove)\nusing this:\n  ((f, l), a, f', l') \\<in> pr_algo_lts\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f' l'", "by cases (simp_all add: push_pres_height_bound relabel_pres_height_bound)"], ["", "lemma (in Height_Bounded_Labeling) pr_algo_term_maxflow:\n  assumes \"(f,l)\\<notin>Domain pr_algo_lts\"\n  shows \"isMaxFlow f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isMaxFlow f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. isMaxFlow f", "from assms"], ["proof (chain)\npicking this:\n  (f, l) \\<notin> Domain pr_algo_lts", "have \"\\<nexists>e. push_precond f l e\" and \"\\<nexists>u. relabel_precond f l u\""], ["proof (prove)\nusing this:\n  (f, l) \\<notin> Domain pr_algo_lts\n\ngoal (1 subgoal):\n 1. \\<nexists>e. push_precond f l e &&& \\<nexists>u. relabel_precond f l u", "by (auto simp: Domain_iff dest: pr_algo_lts.intros)"], ["proof (state)\nthis:\n  \\<nexists>e. push_precond f l e\n  \\<nexists>u. relabel_precond f l u\n\ngoal (1 subgoal):\n 1. isMaxFlow f", "with push_relabel_term_imp_maxflow"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>(u, v)\\<in>cf.E. \\<not> push_precond f l (u, v);\n   \\<forall>u. \\<not> relabel_precond f l u\\<rbrakk>\n  \\<Longrightarrow> isMaxFlow f\n  \\<nexists>e. push_precond f l e\n  \\<nexists>u. relabel_precond f l u", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>(u, v)\\<in>cf.E. \\<not> push_precond f l (u, v);\n   \\<forall>u. \\<not> relabel_precond f l u\\<rbrakk>\n  \\<Longrightarrow> isMaxFlow f\n  \\<nexists>e. push_precond f l e\n  \\<nexists>u. relabel_precond f l u\n\ngoal (1 subgoal):\n 1. isMaxFlow f", "by blast"], ["proof (state)\nthis:\n  isMaxFlow f\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Saturating and Non-Saturating Push Operations\\<close>"], ["", "context Network\nbegin"], ["", "text \\<open>\n  For complexity estimation, it is distinguished whether a push operation\n  saturates the edge or not.\n\\<close>"], ["", "definition sat_push_precond :: \"'capacity flow \\<Rightarrow> labeling \\<Rightarrow> edge \\<Rightarrow> bool\"\n  where \"sat_push_precond f l \n  \\<equiv> \\<lambda>(u,v). excess f u > 0 \n          \\<and> excess f u \\<ge> cf_of f (u,v) \n          \\<and> (u,v)\\<in>cfE_of f \n          \\<and> l u = l v + 1\""], ["", "definition nonsat_push_precond :: \"'capacity flow \\<Rightarrow> labeling \\<Rightarrow> edge \\<Rightarrow> bool\"\n  where \"nonsat_push_precond f l \n  \\<equiv> \\<lambda>(u,v). excess f u > 0 \n          \\<and> excess f u < cf_of f (u,v) \n          \\<and> (u,v)\\<in>cfE_of f \n          \\<and> l u = l v + 1\""], ["", "lemma push_precond_eq_sat_or_nonsat: \n  \"push_precond f l e \\<longleftrightarrow> sat_push_precond f l e \\<or> nonsat_push_precond f l e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. push_precond f l e =\n    (sat_push_precond f l e \\<or> nonsat_push_precond f l e)", "unfolding push_precond_def sat_push_precond_def nonsat_push_precond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case e of\n     (u, v) \\<Rightarrow>\n       (0::'capacity) < excess f u \\<and>\n       (u, v) \\<in> cfE_of f \\<and> l u = l v + 1) =\n    ((case e of\n      (u, v) \\<Rightarrow>\n        (0::'capacity) < excess f u \\<and>\n        cf_of f (u, v) \\<le> excess f u \\<and>\n        (u, v) \\<in> cfE_of f \\<and> l u = l v + 1) \\<or>\n     (case e of\n      (u, v) \\<Rightarrow>\n        (0::'capacity) < excess f u \\<and>\n        excess f u < cf_of f (u, v) \\<and>\n        (u, v) \\<in> cfE_of f \\<and> l u = l v + 1))", "by auto"], ["", "lemma sat_nonsat_push_disj: \n  \"sat_push_precond f l e \\<Longrightarrow> \\<not>nonsat_push_precond f l e\"\n  \"nonsat_push_precond f l e \\<Longrightarrow> \\<not>sat_push_precond f l e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sat_push_precond f l e \\<Longrightarrow>\n     \\<not> nonsat_push_precond f l e) &&&\n    (nonsat_push_precond f l e \\<Longrightarrow>\n     \\<not> sat_push_precond f l e)", "unfolding sat_push_precond_def nonsat_push_precond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case e of\n     (u, v) \\<Rightarrow>\n       (0::'capacity) < excess f u \\<and>\n       cf_of f (u, v) \\<le> excess f u \\<and>\n       (u, v) \\<in> cfE_of f \\<and> l u = l v + 1 \\<Longrightarrow>\n     \\<not> (case e of\n             (u, v) \\<Rightarrow>\n               (0::'capacity) < excess f u \\<and>\n               excess f u < cf_of f (u, v) \\<and>\n               (u, v) \\<in> cfE_of f \\<and> l u = l v + 1)) &&&\n    (case e of\n     (u, v) \\<Rightarrow>\n       (0::'capacity) < excess f u \\<and>\n       excess f u < cf_of f (u, v) \\<and>\n       (u, v) \\<in> cfE_of f \\<and> l u = l v + 1 \\<Longrightarrow>\n     \\<not> (case e of\n             (u, v) \\<Rightarrow>\n               (0::'capacity) < excess f u \\<and>\n               cf_of f (u, v) \\<le> excess f u \\<and>\n               (u, v) \\<in> cfE_of f \\<and> l u = l v + 1))", "by auto"], ["", "lemma sat_push_alt: \"sat_push_precond f l e \n  \\<Longrightarrow> push_effect f e = augment_edge f e (cf_of f e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat_push_precond f l e \\<Longrightarrow>\n    push_effect f e = augment_edge f e (cf_of f e)", "unfolding push_effect_def push_precond_eq_sat_or_nonsat sat_push_precond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case e of\n    (u, v) \\<Rightarrow>\n      (0::'capacity) < excess f u \\<and>\n      cf_of f (u, v) \\<le> excess f u \\<and>\n      (u, v) \\<in> cfE_of f \\<and> l u = l v + 1 \\<Longrightarrow>\n    (case e of\n     (u, v) \\<Rightarrow>\n       augment_edge f (u, v) (min (excess f u) (cf_of f (u, v)))) =\n    augment_edge f e (cf_of f e)", "by (auto simp: min_absorb2)"], ["", "lemma nonsat_push_alt: \"nonsat_push_precond f l (u,v) \n  \\<Longrightarrow> push_effect f (u,v) = augment_edge f (u,v) (excess f u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonsat_push_precond f l (u, v) \\<Longrightarrow>\n    push_effect f (u, v) = augment_edge f (u, v) (excess f u)", "unfolding push_effect_def push_precond_eq_sat_or_nonsat nonsat_push_precond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (u, v) of\n    (u, v) \\<Rightarrow>\n      (0::'capacity) < excess f u \\<and>\n      excess f u < cf_of f (u, v) \\<and>\n      (u, v) \\<in> cfE_of f \\<and> l u = l v + 1 \\<Longrightarrow>\n    (case (u, v) of\n     (u, v) \\<Rightarrow>\n       augment_edge f (u, v) (min (excess f u) (cf_of f (u, v)))) =\n    augment_edge f (u, v) (excess f u)", "by (auto simp: min_absorb1)"], ["", "end \\<comment> \\<open>Network\\<close>"], ["", "context push_effect_locale\nbegin"], ["", "lemma nonsat_push_\\<Delta>: \"nonsat_push_precond f l (u,v) \\<Longrightarrow> \\<Delta> = excess f u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonsat_push_precond f l (u, v) \\<Longrightarrow> \\<Delta> = excess f u", "unfolding \\<Delta>_def nonsat_push_precond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (u, v) of\n    (u, v) \\<Rightarrow>\n      (0::'a) < excess f u \\<and>\n      excess f u < cf (u, v) \\<and>\n      (u, v) \\<in> cf.E \\<and> l u = l v + 1 \\<Longrightarrow>\n    min (excess f u) (cf (u, v)) = excess f u", "by auto"], ["", "lemma sat_push_\\<Delta>: \"sat_push_precond f l (u,v) \\<Longrightarrow> \\<Delta> = cf (u,v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat_push_precond f l (u, v) \\<Longrightarrow> \\<Delta> = cf (u, v)", "unfolding \\<Delta>_def sat_push_precond_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (u, v) of\n    (u, v) \\<Rightarrow>\n      (0::'a) < excess f u \\<and>\n      cf (u, v) \\<le> excess f u \\<and>\n      (u, v) \\<in> cf.E \\<and> l u = l v + 1 \\<Longrightarrow>\n    min (excess f u) (cf (u, v)) = cf (u, v)", "by auto"], ["", "end"], ["", "subsubsection \\<open>Refined Labeled Transition System\\<close>"], ["", "context Network\nbegin"], ["", "text \\<open>For simpler reasoning, we make explicit the different push operations,\n  and integrate the invariant into the LTS\\<close>"], ["", "datatype pr_operation' = \n  is_RELABEL': RELABEL' \n| is_NONSAT_PUSH': NONSAT_PUSH'\n| is_SAT_PUSH': SAT_PUSH' edge"], ["", "inductive_set pr_algo_lts' where\n  nonsat_push': \"\\<lbrakk>Height_Bounded_Labeling c s t f l; nonsat_push_precond f l e\\<rbrakk> \n    \\<Longrightarrow> ((f,l),NONSAT_PUSH',(push_effect f e,l))\\<in>pr_algo_lts'\"\n| sat_push': \"\\<lbrakk>Height_Bounded_Labeling c s t f l; sat_push_precond f l e\\<rbrakk> \n    \\<Longrightarrow> ((f,l),SAT_PUSH' e,(push_effect f e,l))\\<in>pr_algo_lts'\"\n| relabel': \"\\<lbrakk>Height_Bounded_Labeling c s t f l; relabel_precond f l u \\<rbrakk>\n    \\<Longrightarrow> ((f,l),RELABEL',(f,relabel_effect f l u))\\<in>pr_algo_lts'\""], ["", "fun project_operation where\n  \"project_operation RELABEL' = RELABEL\"\n| \"project_operation NONSAT_PUSH' = PUSH\"  \n| \"project_operation (SAT_PUSH' _) = PUSH\""], ["", "lemma is_RELABEL_project_conv[simp]: \n  \"is_RELABEL \\<circ> project_operation = is_RELABEL'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_RELABEL \\<circ> project_operation = is_RELABEL'", "apply (clarsimp intro!: ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. is_RELABEL (project_operation x) = is_RELABEL' x", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_RELABEL (project_operation x) = is_RELABEL' x", "by (cases x) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_PUSH_project_conv[simp]: \n  \"is_PUSH \\<circ> project_operation = (\\<lambda>x. is_SAT_PUSH' x \\<or> is_NONSAT_PUSH' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_PUSH \\<circ> project_operation =\n    (\\<lambda>x. is_SAT_PUSH' x \\<or> is_NONSAT_PUSH' x)", "apply (clarsimp intro!: ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       is_PUSH (project_operation x) =\n       (is_SAT_PUSH' x \\<or> is_NONSAT_PUSH' x)", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_PUSH (project_operation x) = (is_SAT_PUSH' x \\<or> is_NONSAT_PUSH' x)", "by (cases x) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end \\<comment> \\<open>Network\\<close>"], ["", "context Height_Bounded_Labeling\nbegin"], ["", "lemma (in Height_Bounded_Labeling) xfer_run:\n  assumes \"((f,l),p,(f',l')) \\<in> trcl pr_algo_lts\"\n  obtains p' where \"((f,l),p',(f',l')) \\<in> trcl pr_algo_lts'\" \n               and \"p = map project_operation p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>((f, l), p', f', l') \\<in> trcl pr_algo_lts';\n         p = map project_operation p'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>((f, l), p', f', l') \\<in> trcl pr_algo_lts';\n         p = map project_operation p'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists>p'. \n      Height_Bounded_Labeling c s t f' l'\n    \\<and> ((f,l),p',(f',l')) \\<in> trcl pr_algo_lts' \n    \\<and> p = map project_operation p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p'.\n       Height_Bounded_Labeling c s t f' l' \\<and>\n       ((f, l), p', f', l') \\<in> trcl pr_algo_lts' \\<and>\n       p = map project_operation p'", "using assms"], ["proof (prove)\nusing this:\n  ((f, l), p, f', l') \\<in> trcl pr_algo_lts\n\ngoal (1 subgoal):\n 1. \\<exists>p'.\n       Height_Bounded_Labeling c s t f' l' \\<and>\n       ((f, l), p', f', l') \\<in> trcl pr_algo_lts' \\<and>\n       p = map project_operation p'", "proof (induction p arbitrary: f' l' rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f' l'.\n       ((f, l), [], f', l') \\<in> trcl pr_algo_lts \\<Longrightarrow>\n       \\<exists>p'.\n          Height_Bounded_Labeling c s t f' l' \\<and>\n          ((f, l), p', f', l') \\<in> trcl pr_algo_lts' \\<and>\n          [] = map project_operation p'\n 2. \\<And>x xs f' l'.\n       \\<lbrakk>\\<And>f' l'.\n                   ((f, l), xs, f', l')\n                   \\<in> trcl pr_algo_lts \\<Longrightarrow>\n                   \\<exists>p'.\n                      Height_Bounded_Labeling c s t f' l' \\<and>\n                      ((f, l), p', f', l') \\<in> trcl pr_algo_lts' \\<and>\n                      xs = map project_operation p';\n        ((f, l), xs @ [x], f', l') \\<in> trcl pr_algo_lts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            Height_Bounded_Labeling c s t f' l' \\<and>\n                            ((f, l), p', f', l')\n                            \\<in> trcl pr_algo_lts' \\<and>\n                            xs @ [x] = map project_operation p'", "case Nil"], ["proof (state)\nthis:\n  ((f, l), [], f', l') \\<in> trcl pr_algo_lts\n\ngoal (2 subgoals):\n 1. \\<And>f' l'.\n       ((f, l), [], f', l') \\<in> trcl pr_algo_lts \\<Longrightarrow>\n       \\<exists>p'.\n          Height_Bounded_Labeling c s t f' l' \\<and>\n          ((f, l), p', f', l') \\<in> trcl pr_algo_lts' \\<and>\n          [] = map project_operation p'\n 2. \\<And>x xs f' l'.\n       \\<lbrakk>\\<And>f' l'.\n                   ((f, l), xs, f', l')\n                   \\<in> trcl pr_algo_lts \\<Longrightarrow>\n                   \\<exists>p'.\n                      Height_Bounded_Labeling c s t f' l' \\<and>\n                      ((f, l), p', f', l') \\<in> trcl pr_algo_lts' \\<and>\n                      xs = map project_operation p';\n        ((f, l), xs @ [x], f', l') \\<in> trcl pr_algo_lts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            Height_Bounded_Labeling c s t f' l' \\<and>\n                            ((f, l), p', f', l')\n                            \\<in> trcl pr_algo_lts' \\<and>\n                            xs @ [x] = map project_operation p'", "thus ?case"], ["proof (prove)\nusing this:\n  ((f, l), [], f', l') \\<in> trcl pr_algo_lts\n\ngoal (1 subgoal):\n 1. \\<exists>p'.\n       Height_Bounded_Labeling c s t f' l' \\<and>\n       ((f, l), p', f', l') \\<in> trcl pr_algo_lts' \\<and>\n       [] = map project_operation p'", "using Height_Bounded_Labeling_axioms"], ["proof (prove)\nusing this:\n  ((f, l), [], f', l') \\<in> trcl pr_algo_lts\n  Height_Bounded_Labeling c s t f l\n\ngoal (1 subgoal):\n 1. \\<exists>p'.\n       Height_Bounded_Labeling c s t f' l' \\<and>\n       ((f, l), p', f', l') \\<in> trcl pr_algo_lts' \\<and>\n       [] = map project_operation p'", "by simp"], ["proof (state)\nthis:\n  \\<exists>p'.\n     Height_Bounded_Labeling c s t f' l' \\<and>\n     ((f, l), p', f', l') \\<in> trcl pr_algo_lts' \\<and>\n     [] = map project_operation p'\n\ngoal (1 subgoal):\n 1. \\<And>x xs f' l'.\n       \\<lbrakk>\\<And>f' l'.\n                   ((f, l), xs, f', l')\n                   \\<in> trcl pr_algo_lts \\<Longrightarrow>\n                   \\<exists>p'.\n                      Height_Bounded_Labeling c s t f' l' \\<and>\n                      ((f, l), p', f', l') \\<in> trcl pr_algo_lts' \\<and>\n                      xs = map project_operation p';\n        ((f, l), xs @ [x], f', l') \\<in> trcl pr_algo_lts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            Height_Bounded_Labeling c s t f' l' \\<and>\n                            ((f, l), p', f', l')\n                            \\<in> trcl pr_algo_lts' \\<and>\n                            xs @ [x] = map project_operation p'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs f' l'.\n       \\<lbrakk>\\<And>f' l'.\n                   ((f, l), xs, f', l')\n                   \\<in> trcl pr_algo_lts \\<Longrightarrow>\n                   \\<exists>p'.\n                      Height_Bounded_Labeling c s t f' l' \\<and>\n                      ((f, l), p', f', l') \\<in> trcl pr_algo_lts' \\<and>\n                      xs = map project_operation p';\n        ((f, l), xs @ [x], f', l') \\<in> trcl pr_algo_lts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            Height_Bounded_Labeling c s t f' l' \\<and>\n                            ((f, l), p', f', l')\n                            \\<in> trcl pr_algo_lts' \\<and>\n                            xs @ [x] = map project_operation p'", "case (snoc a p)"], ["proof (state)\nthis:\n  ((f, l), p, ?f', ?l') \\<in> trcl pr_algo_lts \\<Longrightarrow>\n  \\<exists>p'.\n     Height_Bounded_Labeling c s t ?f' ?l' \\<and>\n     ((f, l), p', ?f', ?l') \\<in> trcl pr_algo_lts' \\<and>\n     p = map project_operation p'\n  ((f, l), p @ [a], f', l') \\<in> trcl pr_algo_lts\n\ngoal (1 subgoal):\n 1. \\<And>x xs f' l'.\n       \\<lbrakk>\\<And>f' l'.\n                   ((f, l), xs, f', l')\n                   \\<in> trcl pr_algo_lts \\<Longrightarrow>\n                   \\<exists>p'.\n                      Height_Bounded_Labeling c s t f' l' \\<and>\n                      ((f, l), p', f', l') \\<in> trcl pr_algo_lts' \\<and>\n                      xs = map project_operation p';\n        ((f, l), xs @ [x], f', l') \\<in> trcl pr_algo_lts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            Height_Bounded_Labeling c s t f' l' \\<and>\n                            ((f, l), p', f', l')\n                            \\<in> trcl pr_algo_lts' \\<and>\n                            xs @ [x] = map project_operation p'", "from snoc.prems"], ["proof (chain)\npicking this:\n  ((f, l), p @ [a], f', l') \\<in> trcl pr_algo_lts", "obtain fh lh \n      where PP: \"((f, l), p, fh, lh) \\<in> trcl pr_algo_lts\" \n        and LAST: \"((fh,lh),a,(f',l'))\\<in>pr_algo_lts\""], ["proof (prove)\nusing this:\n  ((f, l), p @ [a], f', l') \\<in> trcl pr_algo_lts\n\ngoal (1 subgoal):\n 1. (\\<And>fh lh.\n        \\<lbrakk>((f, l), p, fh, lh) \\<in> trcl pr_algo_lts;\n         ((fh, lh), a, f', l') \\<in> pr_algo_lts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest!: trcl_rev_uncons)"], ["proof (state)\nthis:\n  ((f, l), p, fh, lh) \\<in> trcl pr_algo_lts\n  ((fh, lh), a, f', l') \\<in> pr_algo_lts\n\ngoal (1 subgoal):\n 1. \\<And>x xs f' l'.\n       \\<lbrakk>\\<And>f' l'.\n                   ((f, l), xs, f', l')\n                   \\<in> trcl pr_algo_lts \\<Longrightarrow>\n                   \\<exists>p'.\n                      Height_Bounded_Labeling c s t f' l' \\<and>\n                      ((f, l), p', f', l') \\<in> trcl pr_algo_lts' \\<and>\n                      xs = map project_operation p';\n        ((f, l), xs @ [x], f', l') \\<in> trcl pr_algo_lts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            Height_Bounded_Labeling c s t f' l' \\<and>\n                            ((f, l), p', f', l')\n                            \\<in> trcl pr_algo_lts' \\<and>\n                            xs @ [x] = map project_operation p'", "from snoc.IH[OF PP]"], ["proof (chain)\npicking this:\n  \\<exists>p'.\n     Height_Bounded_Labeling c s t fh lh \\<and>\n     ((f, l), p', fh, lh) \\<in> trcl pr_algo_lts' \\<and>\n     p = map project_operation p'", "obtain p' \n      where HBL: \"Height_Bounded_Labeling c s t fh lh\" \n        and PP': \"((f, l), p', fh, lh) \\<in> trcl pr_algo_lts'\" \n        and [simp]: \"p = map project_operation p'\""], ["proof (prove)\nusing this:\n  \\<exists>p'.\n     Height_Bounded_Labeling c s t fh lh \\<and>\n     ((f, l), p', fh, lh) \\<in> trcl pr_algo_lts' \\<and>\n     p = map project_operation p'\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>Height_Bounded_Labeling c s t fh lh;\n         ((f, l), p', fh, lh) \\<in> trcl pr_algo_lts';\n         p = map project_operation p'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Height_Bounded_Labeling c s t fh lh\n  ((f, l), p', fh, lh) \\<in> trcl pr_algo_lts'\n  p = map project_operation p'\n\ngoal (1 subgoal):\n 1. \\<And>x xs f' l'.\n       \\<lbrakk>\\<And>f' l'.\n                   ((f, l), xs, f', l')\n                   \\<in> trcl pr_algo_lts \\<Longrightarrow>\n                   \\<exists>p'.\n                      Height_Bounded_Labeling c s t f' l' \\<and>\n                      ((f, l), p', f', l') \\<in> trcl pr_algo_lts' \\<and>\n                      xs = map project_operation p';\n        ((f, l), xs @ [x], f', l') \\<in> trcl pr_algo_lts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            Height_Bounded_Labeling c s t f' l' \\<and>\n                            ((f, l), p', f', l')\n                            \\<in> trcl pr_algo_lts' \\<and>\n                            xs @ [x] = map project_operation p'", "from LAST"], ["proof (chain)\npicking this:\n  ((fh, lh), a, f', l') \\<in> pr_algo_lts", "obtain a' \n      where LAST': \"((fh,lh),a',(f',l'))\\<in>pr_algo_lts'\"\n        and [simp]: \"a = project_operation a'\""], ["proof (prove)\nusing this:\n  ((fh, lh), a, f', l') \\<in> pr_algo_lts\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>((fh, lh), a', f', l') \\<in> pr_algo_lts';\n         a = project_operation a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply cases"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>\\<And>a'.\n                   \\<lbrakk>((fh, lh), a', f', l') \\<in> pr_algo_lts';\n                    a = project_operation a'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        a = PUSH; f' = push_effect fh e; l' = lh;\n        push_precond fh lh e\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>u.\n       \\<lbrakk>\\<And>a'.\n                   \\<lbrakk>((fh, lh), a', f', l') \\<in> pr_algo_lts';\n                    a = project_operation a'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        a = RELABEL; f' = fh; l' = relabel_effect fh lh u;\n        relabel_precond fh lh u\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (auto \n          simp: push_precond_eq_sat_or_nonsat\n          dest: relabel'[OF HBL] nonsat_push'[OF HBL] sat_push'[OF HBL])"], ["proof (state)\nthis:\n  ((fh, lh), a', f', l') \\<in> pr_algo_lts'\n  a = project_operation a'\n\ngoal (1 subgoal):\n 1. \\<And>x xs f' l'.\n       \\<lbrakk>\\<And>f' l'.\n                   ((f, l), xs, f', l')\n                   \\<in> trcl pr_algo_lts \\<Longrightarrow>\n                   \\<exists>p'.\n                      Height_Bounded_Labeling c s t f' l' \\<and>\n                      ((f, l), p', f', l') \\<in> trcl pr_algo_lts' \\<and>\n                      xs = map project_operation p';\n        ((f, l), xs @ [x], f', l') \\<in> trcl pr_algo_lts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            Height_Bounded_Labeling c s t f' l' \\<and>\n                            ((f, l), p', f', l')\n                            \\<in> trcl pr_algo_lts' \\<and>\n                            xs @ [x] = map project_operation p'", "note HBL' = \n      Height_Bounded_Labeling.pr_algo_maintains_hb_labeling[OF HBL LAST]"], ["proof (state)\nthis:\n  Height_Bounded_Labeling c s t f' l'\n\ngoal (1 subgoal):\n 1. \\<And>x xs f' l'.\n       \\<lbrakk>\\<And>f' l'.\n                   ((f, l), xs, f', l')\n                   \\<in> trcl pr_algo_lts \\<Longrightarrow>\n                   \\<exists>p'.\n                      Height_Bounded_Labeling c s t f' l' \\<and>\n                      ((f, l), p', f', l') \\<in> trcl pr_algo_lts' \\<and>\n                      xs = map project_operation p';\n        ((f, l), xs @ [x], f', l') \\<in> trcl pr_algo_lts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'.\n                            Height_Bounded_Labeling c s t f' l' \\<and>\n                            ((f, l), p', f', l')\n                            \\<in> trcl pr_algo_lts' \\<and>\n                            xs @ [x] = map project_operation p'", "from HBL' trcl_rev_cons[OF PP' LAST']"], ["proof (chain)\npicking this:\n  Height_Bounded_Labeling c s t f' l'\n  ((f, l), p' @ [a'], f', l') \\<in> trcl pr_algo_lts'", "show ?case"], ["proof (prove)\nusing this:\n  Height_Bounded_Labeling c s t f' l'\n  ((f, l), p' @ [a'], f', l') \\<in> trcl pr_algo_lts'\n\ngoal (1 subgoal):\n 1. \\<exists>p'.\n       Height_Bounded_Labeling c s t f' l' \\<and>\n       ((f, l), p', f', l') \\<in> trcl pr_algo_lts' \\<and>\n       p @ [a] = map project_operation p'", "by auto"], ["proof (state)\nthis:\n  \\<exists>p'.\n     Height_Bounded_Labeling c s t f' l' \\<and>\n     ((f, l), p', f', l') \\<in> trcl pr_algo_lts' \\<and>\n     p @ [a] = map project_operation p'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p'.\n     Height_Bounded_Labeling c s t f' l' \\<and>\n     ((f, l), p', f', l') \\<in> trcl pr_algo_lts' \\<and>\n     p = map project_operation p'\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>((f, l), p', f', l') \\<in> trcl pr_algo_lts';\n         p = map project_operation p'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with assms that"], ["proof (chain)\npicking this:\n  ((f, l), p, f', l') \\<in> trcl pr_algo_lts\n  \\<lbrakk>((f, l), ?p', f', l') \\<in> trcl pr_algo_lts';\n   p = map project_operation ?p'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<exists>p'.\n     Height_Bounded_Labeling c s t f' l' \\<and>\n     ((f, l), p', f', l') \\<in> trcl pr_algo_lts' \\<and>\n     p = map project_operation p'", "show ?thesis"], ["proof (prove)\nusing this:\n  ((f, l), p, f', l') \\<in> trcl pr_algo_lts\n  \\<lbrakk>((f, l), ?p', f', l') \\<in> trcl pr_algo_lts';\n   p = map project_operation ?p'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<exists>p'.\n     Height_Bounded_Labeling c s t f' l' \\<and>\n     ((f, l), p', f', l') \\<in> trcl pr_algo_lts' \\<and>\n     p = map project_operation p'\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma xfer_relabel_bound:\n  assumes BOUND: \"\\<forall>p'. ((f,l),p',(f',l')) \\<in> trcl pr_algo_lts' \n          \\<longrightarrow> length (filter is_RELABEL' p') \\<le> B\"\n  assumes RUN: \"((f,l),p,(f',l')) \\<in> trcl pr_algo_lts\"\n  shows \"length (filter is_RELABEL p) \\<le> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter is_RELABEL p) \\<le> B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (filter is_RELABEL p) \\<le> B", "from xfer_run[OF RUN]"], ["proof (chain)\npicking this:\n  (\\<And>p'.\n      \\<lbrakk>((f, l), p', f', l') \\<in> trcl pr_algo_lts';\n       p = map project_operation p'\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain p' \n    where RUN': \"((f,l),p',(f',l')) \\<in> trcl pr_algo_lts'\" \n      and [simp]: \"p = map project_operation p'\""], ["proof (prove)\nusing this:\n  (\\<And>p'.\n      \\<lbrakk>((f, l), p', f', l') \\<in> trcl pr_algo_lts';\n       p = map project_operation p'\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>((f, l), p', f', l') \\<in> trcl pr_algo_lts';\n         p = map project_operation p'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  ((f, l), p', f', l') \\<in> trcl pr_algo_lts'\n  p = map project_operation p'\n\ngoal (1 subgoal):\n 1. length (filter is_RELABEL p) \\<le> B", "have \"length (filter is_RELABEL p) = length (filter is_RELABEL' p')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter is_RELABEL p) = length (filter is_RELABEL' p')", "by simp"], ["proof (state)\nthis:\n  length (filter is_RELABEL p) = length (filter is_RELABEL' p')\n\ngoal (1 subgoal):\n 1. length (filter is_RELABEL p) \\<le> B", "also"], ["proof (state)\nthis:\n  length (filter is_RELABEL p) = length (filter is_RELABEL' p')\n\ngoal (1 subgoal):\n 1. length (filter is_RELABEL p) \\<le> B", "from BOUND[rule_format,OF RUN']"], ["proof (chain)\npicking this:\n  length (filter is_RELABEL' p') \\<le> B", "have \"length (filter is_RELABEL' p') \\<le> B\""], ["proof (prove)\nusing this:\n  length (filter is_RELABEL' p') \\<le> B\n\ngoal (1 subgoal):\n 1. length (filter is_RELABEL' p') \\<le> B", "."], ["proof (state)\nthis:\n  length (filter is_RELABEL' p') \\<le> B\n\ngoal (1 subgoal):\n 1. length (filter is_RELABEL p) \\<le> B", "finally"], ["proof (chain)\npicking this:\n  length (filter is_RELABEL p) \\<le> B", "show ?thesis"], ["proof (prove)\nusing this:\n  length (filter is_RELABEL p) \\<le> B\n\ngoal (1 subgoal):\n 1. length (filter is_RELABEL p) \\<le> B", "."], ["proof (state)\nthis:\n  length (filter is_RELABEL p) \\<le> B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma xfer_push_bounds:\n  assumes BOUND_SAT: \"\\<forall>p'. ((f,l),p',(f',l')) \\<in> trcl pr_algo_lts' \n          \\<longrightarrow> length (filter is_SAT_PUSH' p') \\<le> B1\"\n  assumes BOUND_NONSAT: \"\\<forall>p'. ((f,l),p',(f',l')) \\<in> trcl pr_algo_lts' \n          \\<longrightarrow> length (filter is_NONSAT_PUSH' p') \\<le> B2\"\n  assumes RUN: \"((f,l),p,(f',l')) \\<in> trcl pr_algo_lts\"\n  shows \"length (filter is_PUSH p) \\<le> B1 + B2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter is_PUSH p) \\<le> B1 + B2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (filter is_PUSH p) \\<le> B1 + B2", "from xfer_run[OF RUN]"], ["proof (chain)\npicking this:\n  (\\<And>p'.\n      \\<lbrakk>((f, l), p', f', l') \\<in> trcl pr_algo_lts';\n       p = map project_operation p'\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain p' \n    where RUN': \"((f,l),p',(f',l')) \\<in> trcl pr_algo_lts'\" \n      and [simp]: \"p = map project_operation p'\""], ["proof (prove)\nusing this:\n  (\\<And>p'.\n      \\<lbrakk>((f, l), p', f', l') \\<in> trcl pr_algo_lts';\n       p = map project_operation p'\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>((f, l), p', f', l') \\<in> trcl pr_algo_lts';\n         p = map project_operation p'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  ((f, l), p', f', l') \\<in> trcl pr_algo_lts'\n  p = map project_operation p'\n\ngoal (1 subgoal):\n 1. length (filter is_PUSH p) \\<le> B1 + B2", "have [simp]: \"length [x\\<leftarrow>p' . is_SAT_PUSH' x \\<or> is_NONSAT_PUSH' x]\n    = length (filter is_SAT_PUSH' p') + length (filter is_NONSAT_PUSH' p')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (filter (\\<lambda>x. is_SAT_PUSH' x \\<or> is_NONSAT_PUSH' x) p') =\n    length (filter is_SAT_PUSH' p') + length (filter is_NONSAT_PUSH' p')", "by (induction p') auto"], ["proof (state)\nthis:\n  length (filter (\\<lambda>x. is_SAT_PUSH' x \\<or> is_NONSAT_PUSH' x) p') =\n  length (filter is_SAT_PUSH' p') + length (filter is_NONSAT_PUSH' p')\n\ngoal (1 subgoal):\n 1. length (filter is_PUSH p) \\<le> B1 + B2", "have \"length (filter is_PUSH p) \n    = length (filter is_SAT_PUSH' p') + length (filter is_NONSAT_PUSH' p')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter is_PUSH p) =\n    length (filter is_SAT_PUSH' p') + length (filter is_NONSAT_PUSH' p')", "by simp"], ["proof (state)\nthis:\n  length (filter is_PUSH p) =\n  length (filter is_SAT_PUSH' p') + length (filter is_NONSAT_PUSH' p')\n\ngoal (1 subgoal):\n 1. length (filter is_PUSH p) \\<le> B1 + B2", "also"], ["proof (state)\nthis:\n  length (filter is_PUSH p) =\n  length (filter is_SAT_PUSH' p') + length (filter is_NONSAT_PUSH' p')\n\ngoal (1 subgoal):\n 1. length (filter is_PUSH p) \\<le> B1 + B2", "note BOUND_SAT[rule_format,OF RUN']"], ["proof (state)\nthis:\n  length (filter is_SAT_PUSH' p') \\<le> B1\n\ngoal (1 subgoal):\n 1. length (filter is_PUSH p) \\<le> B1 + B2", "also"], ["proof (state)\nthis:\n  length (filter is_SAT_PUSH' p') \\<le> B1\n\ngoal (1 subgoal):\n 1. length (filter is_PUSH p) \\<le> B1 + B2", "note BOUND_NONSAT[rule_format,OF RUN']"], ["proof (state)\nthis:\n  length (filter is_NONSAT_PUSH' p') \\<le> B2\n\ngoal (1 subgoal):\n 1. length (filter is_PUSH p) \\<le> B1 + B2", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + length (filter is_NONSAT_PUSH' p')\n              \\<le> y + length (filter is_NONSAT_PUSH' p');\n   \\<And>x y. x \\<le> y \\<Longrightarrow> B1 + x \\<le> B1 + y\\<rbrakk>\n  \\<Longrightarrow> length (filter is_PUSH p) \\<le> B1 + B2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + length (filter is_NONSAT_PUSH' p')\n              \\<le> y + length (filter is_NONSAT_PUSH' p');\n   \\<And>x y. x \\<le> y \\<Longrightarrow> B1 + x \\<le> B1 + y\\<rbrakk>\n  \\<Longrightarrow> length (filter is_PUSH p) \\<le> B1 + B2\n\ngoal (1 subgoal):\n 1. length (filter is_PUSH p) \\<le> B1 + B2", "by simp"], ["proof (state)\nthis:\n  length (filter is_PUSH p) \\<le> B1 + B2\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>Height Bounded Labeling\\<close>"], ["", "subsubsection \\<open>Bounding the Relabel Operations\\<close>"], ["", "lemma (in Network) relabel_action_bound':\n  assumes A: \"(fxl,p,fxl') \\<in> trcl pr_algo_lts'\"\n  shows \"length (filter (is_RELABEL') p) \\<le> 2 * (card V)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter is_RELABEL' p) \\<le> 2 * (card V)\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (filter is_RELABEL' p) \\<le> 2 * (card V)\\<^sup>2", "from A"], ["proof (chain)\npicking this:\n  (fxl, p, fxl') \\<in> trcl pr_algo_lts'", "have \"length (filter (is_RELABEL') p) \\<le> sum_heights_measure (snd fxl)\""], ["proof (prove)\nusing this:\n  (fxl, p, fxl') \\<in> trcl pr_algo_lts'\n\ngoal (1 subgoal):\n 1. length (filter is_RELABEL' p) \\<le> sum_heights_measure (snd fxl)", "apply (induction rule: trcl.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c.\n       length (filter is_RELABEL' []) \\<le> sum_heights_measure (snd c)\n 2. \\<And>c a c' w c''.\n       \\<lbrakk>(c, a, c') \\<in> pr_algo_lts';\n        (c', w, c'') \\<in> trcl pr_algo_lts';\n        length (filter is_RELABEL' w)\n        \\<le> sum_heights_measure (snd c')\\<rbrakk>\n       \\<Longrightarrow> length (filter is_RELABEL' (a # w))\n                         \\<le> sum_heights_measure (snd c)", "apply (auto elim!: pr_algo_lts'.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w ac bb f l u.\n       \\<lbrakk>((f, relabel_effect f l u), w, ac, bb)\n                \\<in> trcl pr_algo_lts';\n        length (filter is_RELABEL' w)\n        \\<le> sum_heights_measure (relabel_effect f l u);\n        Height_Bounded_Labeling c s t f l; relabel_precond f l u\\<rbrakk>\n       \\<Longrightarrow> Suc (length (filter is_RELABEL' w))\n                         \\<le> sum_heights_measure l", "apply (drule (1) Height_Bounded_Labeling.relabel_measure)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w ac bb f l u.\n       \\<lbrakk>((f, relabel_effect f l u), w, ac, bb)\n                \\<in> trcl pr_algo_lts';\n        length (filter is_RELABEL' w)\n        \\<le> sum_heights_measure (relabel_effect f l u);\n        relabel_precond f l u;\n        sum_heights_measure (relabel_effect f l u)\n        < sum_heights_measure l\\<rbrakk>\n       \\<Longrightarrow> Suc (length (filter is_RELABEL' w))\n                         \\<le> sum_heights_measure l", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  length (filter is_RELABEL' p) \\<le> sum_heights_measure (snd fxl)\n\ngoal (1 subgoal):\n 1. length (filter is_RELABEL' p) \\<le> 2 * (card V)\\<^sup>2", "also"], ["proof (state)\nthis:\n  length (filter is_RELABEL' p) \\<le> sum_heights_measure (snd fxl)\n\ngoal (1 subgoal):\n 1. length (filter is_RELABEL' p) \\<le> 2 * (card V)\\<^sup>2", "note sum_height_measure_is_OV2"], ["proof (state)\nthis:\n  sum_heights_measure ?l \\<le> 2 * (card V)\\<^sup>2\n\ngoal (1 subgoal):\n 1. length (filter is_RELABEL' p) \\<le> 2 * (card V)\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  length (filter is_RELABEL' p) \\<le> 2 * (card V)\\<^sup>2", "show \"length (filter (is_RELABEL') p) \\<le> 2 * (card V)\\<^sup>2\""], ["proof (prove)\nusing this:\n  length (filter is_RELABEL' p) \\<le> 2 * (card V)\\<^sup>2\n\ngoal (1 subgoal):\n 1. length (filter is_RELABEL' p) \\<le> 2 * (card V)\\<^sup>2", "."], ["proof (state)\nthis:\n  length (filter is_RELABEL' p) \\<le> 2 * (card V)\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in Height_Bounded_Labeling) relabel_action_bound:\n  assumes A: \"((f,l),p,(f',l')) \\<in> trcl pr_algo_lts\"\n  shows \"length (filter (is_RELABEL) p) \\<le> 2 * (card V)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter is_RELABEL p) \\<le> 2 * (card V)\\<^sup>2", "using xfer_relabel_bound relabel_action_bound' A"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>p'.\n              ((f, l), p', ?f', ?l')\n              \\<in> trcl pr_algo_lts' \\<longrightarrow>\n              length (filter is_RELABEL' p') \\<le> ?B;\n   ((f, l), ?p, ?f', ?l') \\<in> trcl pr_algo_lts\\<rbrakk>\n  \\<Longrightarrow> length (filter is_RELABEL ?p) \\<le> ?B\n  (?fxl, ?p, ?fxl') \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n  length (filter is_RELABEL' ?p) \\<le> 2 * (card V)\\<^sup>2\n  ((f, l), p, f', l') \\<in> trcl pr_algo_lts\n\ngoal (1 subgoal):\n 1. length (filter is_RELABEL p) \\<le> 2 * (card V)\\<^sup>2", "by meson"], ["", "subsubsection \\<open>Bounding the Saturating Push Operations\\<close>"], ["", "context Network\nbegin"], ["", "text \\<open>\n  The basic idea is to estimate the saturating push operations per edge:\n  After a saturating push, the edge disappears from the residual graph.\n  It can only re-appear due to a push over the reverse edge, which requires\n  relabeling of the nodes. \n\n  The estimation in \\cormen{26.22} uses the same idea. However, it invests \n  some extra work in getting a more precise constant factor \n  by counting the pushes for an edge and its reverse edge together.\n\\<close>"], ["", "lemma labels_path_increasing:\n  assumes \"((f,l),p,(f',l')) \\<in> trcl pr_algo_lts'\"\n  shows \"l u \\<le> l' u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l u \\<le> l' u", "using assms"], ["proof (prove)\nusing this:\n  ((f, l), p, f', l') \\<in> trcl pr_algo_lts'\n\ngoal (1 subgoal):\n 1. l u \\<le> l' u", "proof (induction p arbitrary: f l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f l.\n       ((f, l), [], f', l') \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n       l u \\<le> l' u\n 2. \\<And>a p f l.\n       \\<lbrakk>\\<And>f l.\n                   ((f, l), p, f', l')\n                   \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n                   l u \\<le> l' u;\n        ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'\\<rbrakk>\n       \\<Longrightarrow> l u \\<le> l' u", "case Nil"], ["proof (state)\nthis:\n  ((f, l), [], f', l') \\<in> trcl pr_algo_lts'\n\ngoal (2 subgoals):\n 1. \\<And>f l.\n       ((f, l), [], f', l') \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n       l u \\<le> l' u\n 2. \\<And>a p f l.\n       \\<lbrakk>\\<And>f l.\n                   ((f, l), p, f', l')\n                   \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n                   l u \\<le> l' u;\n        ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'\\<rbrakk>\n       \\<Longrightarrow> l u \\<le> l' u", "thus ?case"], ["proof (prove)\nusing this:\n  ((f, l), [], f', l') \\<in> trcl pr_algo_lts'\n\ngoal (1 subgoal):\n 1. l u \\<le> l' u", "by simp"], ["proof (state)\nthis:\n  l u \\<le> l' u\n\ngoal (1 subgoal):\n 1. \\<And>a p f l.\n       \\<lbrakk>\\<And>f l.\n                   ((f, l), p, f', l')\n                   \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n                   l u \\<le> l' u;\n        ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'\\<rbrakk>\n       \\<Longrightarrow> l u \\<le> l' u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p f l.\n       \\<lbrakk>\\<And>f l.\n                   ((f, l), p, f', l')\n                   \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n                   l u \\<le> l' u;\n        ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'\\<rbrakk>\n       \\<Longrightarrow> l u \\<le> l' u", "case (Cons a p)"], ["proof (state)\nthis:\n  ((?f, ?l), p, f', l') \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n  ?l u \\<le> l' u\n  ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'\n\ngoal (1 subgoal):\n 1. \\<And>a p f l.\n       \\<lbrakk>\\<And>f l.\n                   ((f, l), p, f', l')\n                   \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n                   l u \\<le> l' u;\n        ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'\\<rbrakk>\n       \\<Longrightarrow> l u \\<le> l' u", "then"], ["proof (chain)\npicking this:\n  ((?f, ?l), p, f', l') \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n  ?l u \\<le> l' u\n  ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'", "obtain fh lh \n    where FIRST: \"((f,l),a,(fh,lh)) \\<in> pr_algo_lts'\"\n      and PP: \"((fh,lh),p,(f',l')): trcl pr_algo_lts'\""], ["proof (prove)\nusing this:\n  ((?f, ?l), p, f', l') \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n  ?l u \\<le> l' u\n  ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'\n\ngoal (1 subgoal):\n 1. (\\<And>fh lh.\n        \\<lbrakk>((f, l), a, fh, lh) \\<in> pr_algo_lts';\n         ((fh, lh), p, f', l') \\<in> trcl pr_algo_lts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: trcl_conv)"], ["proof (state)\nthis:\n  ((f, l), a, fh, lh) \\<in> pr_algo_lts'\n  ((fh, lh), p, f', l') \\<in> trcl pr_algo_lts'\n\ngoal (1 subgoal):\n 1. \\<And>a p f l.\n       \\<lbrakk>\\<And>f l.\n                   ((f, l), p, f', l')\n                   \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n                   l u \\<le> l' u;\n        ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'\\<rbrakk>\n       \\<Longrightarrow> l u \\<le> l' u", "from FIRST"], ["proof (chain)\npicking this:\n  ((f, l), a, fh, lh) \\<in> pr_algo_lts'", "interpret Height_Bounded_Labeling c s t f l"], ["proof (prove)\nusing this:\n  ((f, l), a, fh, lh) \\<in> pr_algo_lts'\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f l", "by cases auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p f l.\n       \\<lbrakk>\\<And>f l.\n                   ((f, l), p, f', l')\n                   \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n                   l u \\<le> l' u;\n        ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'\\<rbrakk>\n       \\<Longrightarrow> l u \\<le> l' u", "from FIRST Cons.IH[OF PP]"], ["proof (chain)\npicking this:\n  ((f, l), a, fh, lh) \\<in> pr_algo_lts'\n  lh u \\<le> l' u", "show ?case"], ["proof (prove)\nusing this:\n  ((f, l), a, fh, lh) \\<in> pr_algo_lts'\n  lh u \\<le> l' u\n\ngoal (1 subgoal):\n 1. l u \\<le> l' u", "apply (auto elim!: pr_algo_lts'.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ua.\n       \\<lbrakk>relabel_effect f l ua u \\<le> l' u; a = RELABEL'; fh = f;\n        lh = relabel_effect f l ua; Height_Bounded_Labeling c s t f l;\n        relabel_precond f l ua\\<rbrakk>\n       \\<Longrightarrow> l u \\<le> l' u", "using relabel_increase_u relabel_preserve_other"], ["proof (prove)\nusing this:\n  relabel_precond f l ?u \\<Longrightarrow> l ?u < relabel_effect f l ?u ?u\n  ?u \\<noteq> ?v \\<Longrightarrow> relabel_effect f l ?u ?v = l ?v\n\ngoal (1 subgoal):\n 1. \\<And>ua.\n       \\<lbrakk>relabel_effect f l ua u \\<le> l' u; a = RELABEL'; fh = f;\n        lh = relabel_effect f l ua; Height_Bounded_Labeling c s t f l;\n        relabel_precond f l ua\\<rbrakk>\n       \\<Longrightarrow> l u \\<le> l' u", "by (metis le_trans nat_le_linear not_less)"], ["proof (state)\nthis:\n  l u \\<le> l' u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma edge_reappears_at_increased_labeling:\n  assumes \"((f,l),p,(f',l')) \\<in> trcl pr_algo_lts'\"\n  assumes \"l u \\<ge> l v + 1\"\n  assumes \"(u,v) \\<notin> cfE_of f\"  \n  assumes E': \"(u,v) \\<in> cfE_of f'\"\n  shows \"l v < l' v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l v < l' v", "using assms(1-3)"], ["proof (prove)\nusing this:\n  ((f, l), p, f', l') \\<in> trcl pr_algo_lts'\n  l v + 1 \\<le> l u\n  (u, v) \\<notin> cfE_of f\n\ngoal (1 subgoal):\n 1. l v < l' v", "proof (induction p arbitrary: f l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f l.\n       \\<lbrakk>((f, l), [], f', l') \\<in> trcl pr_algo_lts';\n        l v + 1 \\<le> l u; (u, v) \\<notin> cfE_of f\\<rbrakk>\n       \\<Longrightarrow> l v < l' v\n 2. \\<And>a p f l.\n       \\<lbrakk>\\<And>f l.\n                   \\<lbrakk>((f, l), p, f', l') \\<in> trcl pr_algo_lts';\n                    l v + 1 \\<le> l u; (u, v) \\<notin> cfE_of f\\<rbrakk>\n                   \\<Longrightarrow> l v < l' v;\n        ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'; l v + 1 \\<le> l u;\n        (u, v) \\<notin> cfE_of f\\<rbrakk>\n       \\<Longrightarrow> l v < l' v", "case Nil"], ["proof (state)\nthis:\n  ((f, l), [], f', l') \\<in> trcl pr_algo_lts'\n  l v + 1 \\<le> l u\n  (u, v) \\<notin> cfE_of f\n\ngoal (2 subgoals):\n 1. \\<And>f l.\n       \\<lbrakk>((f, l), [], f', l') \\<in> trcl pr_algo_lts';\n        l v + 1 \\<le> l u; (u, v) \\<notin> cfE_of f\\<rbrakk>\n       \\<Longrightarrow> l v < l' v\n 2. \\<And>a p f l.\n       \\<lbrakk>\\<And>f l.\n                   \\<lbrakk>((f, l), p, f', l') \\<in> trcl pr_algo_lts';\n                    l v + 1 \\<le> l u; (u, v) \\<notin> cfE_of f\\<rbrakk>\n                   \\<Longrightarrow> l v < l' v;\n        ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'; l v + 1 \\<le> l u;\n        (u, v) \\<notin> cfE_of f\\<rbrakk>\n       \\<Longrightarrow> l v < l' v", "thus ?case"], ["proof (prove)\nusing this:\n  ((f, l), [], f', l') \\<in> trcl pr_algo_lts'\n  l v + 1 \\<le> l u\n  (u, v) \\<notin> cfE_of f\n\ngoal (1 subgoal):\n 1. l v < l' v", "using E'"], ["proof (prove)\nusing this:\n  ((f, l), [], f', l') \\<in> trcl pr_algo_lts'\n  l v + 1 \\<le> l u\n  (u, v) \\<notin> cfE_of f\n  (u, v) \\<in> cfE_of f'\n\ngoal (1 subgoal):\n 1. l v < l' v", "by auto"], ["proof (state)\nthis:\n  l v < l' v\n\ngoal (1 subgoal):\n 1. \\<And>a p f l.\n       \\<lbrakk>\\<And>f l.\n                   \\<lbrakk>((f, l), p, f', l') \\<in> trcl pr_algo_lts';\n                    l v + 1 \\<le> l u; (u, v) \\<notin> cfE_of f\\<rbrakk>\n                   \\<Longrightarrow> l v < l' v;\n        ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'; l v + 1 \\<le> l u;\n        (u, v) \\<notin> cfE_of f\\<rbrakk>\n       \\<Longrightarrow> l v < l' v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p f l.\n       \\<lbrakk>\\<And>f l.\n                   \\<lbrakk>((f, l), p, f', l') \\<in> trcl pr_algo_lts';\n                    l v + 1 \\<le> l u; (u, v) \\<notin> cfE_of f\\<rbrakk>\n                   \\<Longrightarrow> l v < l' v;\n        ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'; l v + 1 \\<le> l u;\n        (u, v) \\<notin> cfE_of f\\<rbrakk>\n       \\<Longrightarrow> l v < l' v", "case (Cons a p)"], ["proof (state)\nthis:\n  \\<lbrakk>((?f, ?l), p, f', l') \\<in> trcl pr_algo_lts';\n   ?l v + 1 \\<le> ?l u; (u, v) \\<notin> cfE_of ?f\\<rbrakk>\n  \\<Longrightarrow> ?l v < l' v\n  ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'\n  l v + 1 \\<le> l u\n  (u, v) \\<notin> cfE_of f\n\ngoal (1 subgoal):\n 1. \\<And>a p f l.\n       \\<lbrakk>\\<And>f l.\n                   \\<lbrakk>((f, l), p, f', l') \\<in> trcl pr_algo_lts';\n                    l v + 1 \\<le> l u; (u, v) \\<notin> cfE_of f\\<rbrakk>\n                   \\<Longrightarrow> l v < l' v;\n        ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'; l v + 1 \\<le> l u;\n        (u, v) \\<notin> cfE_of f\\<rbrakk>\n       \\<Longrightarrow> l v < l' v", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>((?f, ?l), p, f', l') \\<in> trcl pr_algo_lts';\n   ?l v + 1 \\<le> ?l u; (u, v) \\<notin> cfE_of ?f\\<rbrakk>\n  \\<Longrightarrow> ?l v < l' v\n  ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'\n  l v + 1 \\<le> l u\n  (u, v) \\<notin> cfE_of f", "obtain fh lh \n    where FIRST: \"((f,l),a,(fh,lh)) \\<in> pr_algo_lts'\"\n      and PP: \"((fh,lh),p,(f',l')): trcl pr_algo_lts'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>((?f, ?l), p, f', l') \\<in> trcl pr_algo_lts';\n   ?l v + 1 \\<le> ?l u; (u, v) \\<notin> cfE_of ?f\\<rbrakk>\n  \\<Longrightarrow> ?l v < l' v\n  ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'\n  l v + 1 \\<le> l u\n  (u, v) \\<notin> cfE_of f\n\ngoal (1 subgoal):\n 1. (\\<And>fh lh.\n        \\<lbrakk>((f, l), a, fh, lh) \\<in> pr_algo_lts';\n         ((fh, lh), p, f', l') \\<in> trcl pr_algo_lts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: trcl_conv)"], ["proof (state)\nthis:\n  ((f, l), a, fh, lh) \\<in> pr_algo_lts'\n  ((fh, lh), p, f', l') \\<in> trcl pr_algo_lts'\n\ngoal (1 subgoal):\n 1. \\<And>a p f l.\n       \\<lbrakk>\\<And>f l.\n                   \\<lbrakk>((f, l), p, f', l') \\<in> trcl pr_algo_lts';\n                    l v + 1 \\<le> l u; (u, v) \\<notin> cfE_of f\\<rbrakk>\n                   \\<Longrightarrow> l v < l' v;\n        ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'; l v + 1 \\<le> l u;\n        (u, v) \\<notin> cfE_of f\\<rbrakk>\n       \\<Longrightarrow> l v < l' v", "from FIRST"], ["proof (chain)\npicking this:\n  ((f, l), a, fh, lh) \\<in> pr_algo_lts'", "interpret Height_Bounded_Labeling c s t f l"], ["proof (prove)\nusing this:\n  ((f, l), a, fh, lh) \\<in> pr_algo_lts'\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f l", "by cases auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p f l.\n       \\<lbrakk>\\<And>f l.\n                   \\<lbrakk>((f, l), p, f', l') \\<in> trcl pr_algo_lts';\n                    l v + 1 \\<le> l u; (u, v) \\<notin> cfE_of f\\<rbrakk>\n                   \\<Longrightarrow> l v < l' v;\n        ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'; l v + 1 \\<le> l u;\n        (u, v) \\<notin> cfE_of f\\<rbrakk>\n       \\<Longrightarrow> l v < l' v", "consider \n    (push) u' v' \n      where \"push_precond f l (u',v')\" \"fh = push_effect f (u',v')\" \"lh=l\"\n  | (relabel) u' \n      where \"relabel_precond f l u'\" \"fh=f\" \"lh=relabel_effect f l u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u' v'.\n                \\<lbrakk>push_precond f l (u', v');\n                 fh = push_effect f (u', v'); lh = l\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>u'.\n        \\<lbrakk>relabel_precond f l u'; fh = f;\n         lh = relabel_effect f l u'\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using FIRST"], ["proof (prove)\nusing this:\n  ((f, l), a, fh, lh) \\<in> pr_algo_lts'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>u' v'.\n                \\<lbrakk>push_precond f l (u', v');\n                 fh = push_effect f (u', v'); lh = l\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>u'.\n        \\<lbrakk>relabel_precond f l u'; fh = f;\n         lh = relabel_effect f l u'\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (auto elim!: pr_algo_lts'.cases simp: push_precond_eq_sat_or_nonsat)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>u' v'.\n              \\<lbrakk>push_precond f l (u', v');\n               fh = push_effect f (u', v'); lh = l\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>u'.\n      \\<lbrakk>relabel_precond f l u'; fh = f;\n       lh = relabel_effect f l u'\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>a p f l.\n       \\<lbrakk>\\<And>f l.\n                   \\<lbrakk>((f, l), p, f', l') \\<in> trcl pr_algo_lts';\n                    l v + 1 \\<le> l u; (u, v) \\<notin> cfE_of f\\<rbrakk>\n                   \\<Longrightarrow> l v < l' v;\n        ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'; l v + 1 \\<le> l u;\n        (u, v) \\<notin> cfE_of f\\<rbrakk>\n       \\<Longrightarrow> l v < l' v", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>u' v'.\n              \\<lbrakk>push_precond f l (u', v');\n               fh = push_effect f (u', v'); lh = l\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>u'.\n      \\<lbrakk>relabel_precond f l u'; fh = f;\n       lh = relabel_effect f l u'\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>u' v'.\n              \\<lbrakk>push_precond f l (u', v');\n               fh = push_effect f (u', v'); lh = l\\<rbrakk>\n              \\<Longrightarrow> ?thesis;\n   \\<And>u'.\n      \\<lbrakk>relabel_precond f l u'; fh = f;\n       lh = relabel_effect f l u'\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. l v < l' v", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u' v'.\n       \\<lbrakk>push_precond f l (u', v'); fh = push_effect f (u', v');\n        lh = l\\<rbrakk>\n       \\<Longrightarrow> l v < l' v\n 2. \\<And>u'.\n       \\<lbrakk>relabel_precond f l u'; fh = f;\n        lh = relabel_effect f l u'\\<rbrakk>\n       \\<Longrightarrow> l v < l' v", "case push"], ["proof (state)\nthis:\n  push_precond f l (u', v')\n  fh = push_effect f (u', v')\n  lh = l\n\ngoal (2 subgoals):\n 1. \\<And>u' v'.\n       \\<lbrakk>push_precond f l (u', v'); fh = push_effect f (u', v');\n        lh = l\\<rbrakk>\n       \\<Longrightarrow> l v < l' v\n 2. \\<And>u'.\n       \\<lbrakk>relabel_precond f l u'; fh = f;\n        lh = relabel_effect f l u'\\<rbrakk>\n       \\<Longrightarrow> l v < l' v", "note [simp] = push(2,3)"], ["proof (state)\nthis:\n  fh = push_effect f (u', v')\n  lh = l\n\ngoal (2 subgoals):\n 1. \\<And>u' v'.\n       \\<lbrakk>push_precond f l (u', v'); fh = push_effect f (u', v');\n        lh = l\\<rbrakk>\n       \\<Longrightarrow> l v < l' v\n 2. \\<And>u'.\n       \\<lbrakk>relabel_precond f l u'; fh = f;\n        lh = relabel_effect f l u'\\<rbrakk>\n       \\<Longrightarrow> l v < l' v", "text \\<open>The push operation cannot go on edge \\<open>(u,v)\\<close> or \\<open>(v,u)\\<close>\\<close>"], ["proof (state)\nthis:\n  fh = push_effect f (u', v')\n  lh = l\n\ngoal (2 subgoals):\n 1. \\<And>u' v'.\n       \\<lbrakk>push_precond f l (u', v'); fh = push_effect f (u', v');\n        lh = l\\<rbrakk>\n       \\<Longrightarrow> l v < l' v\n 2. \\<And>u'.\n       \\<lbrakk>relabel_precond f l u'; fh = f;\n        lh = relabel_effect f l u'\\<rbrakk>\n       \\<Longrightarrow> l v < l' v", "from push(1)"], ["proof (chain)\npicking this:\n  push_precond f l (u', v')", "have \"(u',v')\\<noteq>(u,v)\" \"(u',v')\\<noteq>(v,u)\" \"(u',v')\\<in>cf.E\""], ["proof (prove)\nusing this:\n  push_precond f l (u', v')\n\ngoal (1 subgoal):\n 1. (u', v') \\<noteq> (u, v) &&&\n    (u', v') \\<noteq> (v, u) &&& (u', v') \\<in> cf.E", "using \\<open>l u \\<ge> l v + 1\\<close> \\<open>(u,v)\\<notin>cf.E\\<close>"], ["proof (prove)\nusing this:\n  push_precond f l (u', v')\n  l v + 1 \\<le> l u\n  (u, v) \\<notin> cf.E\n\ngoal (1 subgoal):\n 1. (u', v') \\<noteq> (u, v) &&&\n    (u', v') \\<noteq> (v, u) &&& (u', v') \\<in> cf.E", "by (auto simp: push_precond_def)"], ["proof (state)\nthis:\n  (u', v') \\<noteq> (u, v)\n  (u', v') \\<noteq> (v, u)\n  (u', v') \\<in> cf.E\n\ngoal (2 subgoals):\n 1. \\<And>u' v'.\n       \\<lbrakk>push_precond f l (u', v'); fh = push_effect f (u', v');\n        lh = l\\<rbrakk>\n       \\<Longrightarrow> l v < l' v\n 2. \\<And>u'.\n       \\<lbrakk>relabel_precond f l u'; fh = f;\n        lh = relabel_effect f l u'\\<rbrakk>\n       \\<Longrightarrow> l v < l' v", "hence NE': \"(u,v)\\<notin>cfE_of fh\""], ["proof (prove)\nusing this:\n  (u', v') \\<noteq> (u, v)\n  (u', v') \\<noteq> (v, u)\n  (u', v') \\<in> cf.E\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> cfE_of fh", "using \\<open>(u,v)\\<notin>cf.E\\<close>"], ["proof (prove)\nusing this:\n  (u', v') \\<noteq> (u, v)\n  (u', v') \\<noteq> (v, u)\n  (u', v') \\<in> cf.E\n  (u, v) \\<notin> cf.E\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> cfE_of fh", "using cfE_augment_ss[of u' v' f]"], ["proof (prove)\nusing this:\n  (u', v') \\<noteq> (u, v)\n  (u', v') \\<noteq> (v, u)\n  (u', v') \\<in> cf.E\n  (u, v) \\<notin> cf.E\n  (u', v') \\<in> cf.E \\<Longrightarrow>\n  cfE_of (augment_edge f (u', v') ?\\<Delta>)\n  \\<subseteq> insert (v', u') cf.E\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> cfE_of fh", "by (auto simp: push_effect_def)"], ["proof (state)\nthis:\n  (u, v) \\<notin> cfE_of fh\n\ngoal (2 subgoals):\n 1. \\<And>u' v'.\n       \\<lbrakk>push_precond f l (u', v'); fh = push_effect f (u', v');\n        lh = l\\<rbrakk>\n       \\<Longrightarrow> l v < l' v\n 2. \\<And>u'.\n       \\<lbrakk>relabel_precond f l u'; fh = f;\n        lh = relabel_effect f l u'\\<rbrakk>\n       \\<Longrightarrow> l v < l' v", "from Cons.IH[OF PP _ NE'] \\<open>l u \\<ge> l v + 1\\<close>"], ["proof (chain)\npicking this:\n  lh v + 1 \\<le> lh u \\<Longrightarrow> lh v < l' v\n  l v + 1 \\<le> l u", "show ?thesis"], ["proof (prove)\nusing this:\n  lh v + 1 \\<le> lh u \\<Longrightarrow> lh v < l' v\n  l v + 1 \\<le> l u\n\ngoal (1 subgoal):\n 1. l v < l' v", "by simp"], ["proof (state)\nthis:\n  l v < l' v\n\ngoal (1 subgoal):\n 1. \\<And>u'.\n       \\<lbrakk>relabel_precond f l u'; fh = f;\n        lh = relabel_effect f l u'\\<rbrakk>\n       \\<Longrightarrow> l v < l' v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u'.\n       \\<lbrakk>relabel_precond f l u'; fh = f;\n        lh = relabel_effect f l u'\\<rbrakk>\n       \\<Longrightarrow> l v < l' v", "case relabel"], ["proof (state)\nthis:\n  relabel_precond f l u'\n  fh = f\n  lh = relabel_effect f l u'\n\ngoal (1 subgoal):\n 1. \\<And>u'.\n       \\<lbrakk>relabel_precond f l u'; fh = f;\n        lh = relabel_effect f l u'\\<rbrakk>\n       \\<Longrightarrow> l v < l' v", "note [simp] = relabel(2)"], ["proof (state)\nthis:\n  fh = f\n\ngoal (1 subgoal):\n 1. \\<And>u'.\n       \\<lbrakk>relabel_precond f l u'; fh = f;\n        lh = relabel_effect f l u'\\<rbrakk>\n       \\<Longrightarrow> l v < l' v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. l v < l' v", "proof (cases \"u'=v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u' = v \\<Longrightarrow> l v < l' v\n 2. u' \\<noteq> v \\<Longrightarrow> l v < l' v", "case False"], ["proof (state)\nthis:\n  u' \\<noteq> v\n\ngoal (2 subgoals):\n 1. u' = v \\<Longrightarrow> l v < l' v\n 2. u' \\<noteq> v \\<Longrightarrow> l v < l' v", "from False relabel(3) relabel_preserve_other"], ["proof (chain)\npicking this:\n  u' \\<noteq> v\n  lh = relabel_effect f l u'\n  ?u \\<noteq> ?v \\<Longrightarrow> relabel_effect f l ?u ?v = l ?v", "have [simp]: \"lh v = l v\""], ["proof (prove)\nusing this:\n  u' \\<noteq> v\n  lh = relabel_effect f l u'\n  ?u \\<noteq> ?v \\<Longrightarrow> relabel_effect f l ?u ?v = l ?v\n\ngoal (1 subgoal):\n 1. lh v = l v", "by auto"], ["proof (state)\nthis:\n  lh v = l v\n\ngoal (2 subgoals):\n 1. u' = v \\<Longrightarrow> l v < l' v\n 2. u' \\<noteq> v \\<Longrightarrow> l v < l' v", "from False relabel(3) \n           relabel_preserve_other relabel_increase_u[OF relabel(1)]"], ["proof (chain)\npicking this:\n  u' \\<noteq> v\n  lh = relabel_effect f l u'\n  ?u \\<noteq> ?v \\<Longrightarrow> relabel_effect f l ?u ?v = l ?v\n  l u' < relabel_effect f l u' u'", "have \"lh u \\<ge> l u\""], ["proof (prove)\nusing this:\n  u' \\<noteq> v\n  lh = relabel_effect f l u'\n  ?u \\<noteq> ?v \\<Longrightarrow> relabel_effect f l ?u ?v = l ?v\n  l u' < relabel_effect f l u' u'\n\ngoal (1 subgoal):\n 1. l u \\<le> lh u", "by (cases \"u'=u\") auto"], ["proof (state)\nthis:\n  l u \\<le> lh u\n\ngoal (2 subgoals):\n 1. u' = v \\<Longrightarrow> l v < l' v\n 2. u' \\<noteq> v \\<Longrightarrow> l v < l' v", "with \\<open>l u \\<ge> l v + 1\\<close>"], ["proof (chain)\npicking this:\n  l v + 1 \\<le> l u\n  l u \\<le> lh u", "have LHG: \"lh u \\<ge> lh v + 1\""], ["proof (prove)\nusing this:\n  l v + 1 \\<le> l u\n  l u \\<le> lh u\n\ngoal (1 subgoal):\n 1. lh v + 1 \\<le> lh u", "by auto"], ["proof (state)\nthis:\n  lh v + 1 \\<le> lh u\n\ngoal (2 subgoals):\n 1. u' = v \\<Longrightarrow> l v < l' v\n 2. u' \\<noteq> v \\<Longrightarrow> l v < l' v", "from Cons.IH[OF PP LHG] \\<open>(u,v)\\<notin>cf.E\\<close>"], ["proof (chain)\npicking this:\n  (u, v) \\<notin> cfE_of fh \\<Longrightarrow> lh v < l' v\n  (u, v) \\<notin> cf.E", "show ?thesis"], ["proof (prove)\nusing this:\n  (u, v) \\<notin> cfE_of fh \\<Longrightarrow> lh v < l' v\n  (u, v) \\<notin> cf.E\n\ngoal (1 subgoal):\n 1. l v < l' v", "by simp"], ["proof (state)\nthis:\n  l v < l' v\n\ngoal (1 subgoal):\n 1. u' = v \\<Longrightarrow> l v < l' v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u' = v \\<Longrightarrow> l v < l' v", "case True"], ["proof (state)\nthis:\n  u' = v\n\ngoal (1 subgoal):\n 1. u' = v \\<Longrightarrow> l v < l' v", "note [simp] = relabel(3)"], ["proof (state)\nthis:\n  lh = relabel_effect f l u'\n\ngoal (1 subgoal):\n 1. u' = v \\<Longrightarrow> l v < l' v", "from True relabel_increase_u[OF relabel(1)]"], ["proof (chain)\npicking this:\n  u' = v\n  l u' < relabel_effect f l u' u'", "have \"l v < lh v\""], ["proof (prove)\nusing this:\n  u' = v\n  l u' < relabel_effect f l u' u'\n\ngoal (1 subgoal):\n 1. l v < lh v", "by simp"], ["proof (state)\nthis:\n  l v < lh v\n\ngoal (1 subgoal):\n 1. u' = v \\<Longrightarrow> l v < l' v", "also"], ["proof (state)\nthis:\n  l v < lh v\n\ngoal (1 subgoal):\n 1. u' = v \\<Longrightarrow> l v < l' v", "note labels_path_increasing[OF PP, of v]"], ["proof (state)\nthis:\n  lh v \\<le> l' v\n\ngoal (1 subgoal):\n 1. u' = v \\<Longrightarrow> l v < l' v", "finally"], ["proof (chain)\npicking this:\n  l v < l' v", "show ?thesis"], ["proof (prove)\nusing this:\n  l v < l' v\n\ngoal (1 subgoal):\n 1. l v < l' v", "by simp"], ["proof (state)\nthis:\n  l v < l' v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l v < l' v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l v < l' v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sat_push_edge_action_bound':\n  assumes \"((f,l),p,(f',l')) \\<in> trcl pr_algo_lts'\" \n  shows \"length (filter ((=) (SAT_PUSH' e)) p) \\<le> 2*card V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter ((=) (SAT_PUSH' e)) p) \\<le> 2 * card V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (filter ((=) (SAT_PUSH' e)) p) \\<le> 2 * card V", "obtain u v where [simp]: \"e=(u,v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v. e = (u, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases e)"], ["proof (state)\nthis:\n  e = (u, v)\n\ngoal (1 subgoal):\n 1. length (filter ((=) (SAT_PUSH' e)) p) \\<le> 2 * card V", "have \"length (filter ((=) (SAT_PUSH' (u,v))) p) \\<le> 2*card V - l v\"\n    if \"((f,l),p,(f',l')) \\<in> trcl pr_algo_lts'\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "using that"], ["proof (prove)\nusing this:\n  ((f, l), p, f', l') \\<in> trcl pr_algo_lts'\n\ngoal (1 subgoal):\n 1. length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "proof (induction p arbitrary: f l rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs f l.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ((x, xa), ys, f', l')\n                       \\<in> trcl pr_algo_lts' \\<longrightarrow>\n                       length (filter ((=) (SAT_PUSH' (u, v))) ys)\n                       \\<le> 2 * card V - xa v);\n        ((f, l), xs, f', l') \\<in> trcl pr_algo_lts'\\<rbrakk>\n       \\<Longrightarrow> length (filter ((=) (SAT_PUSH' (u, v))) xs)\n                         \\<le> 2 * card V - l v", "case (1 p)"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length p \\<longrightarrow>\n     (\\<forall>x xa.\n         ((x, xa), ys, f', l') \\<in> trcl pr_algo_lts' \\<longrightarrow>\n         length (filter ((=) (SAT_PUSH' (u, v))) ys)\n         \\<le> 2 * card V - xa v)\n  ((f, l), p, f', l') \\<in> trcl pr_algo_lts'\n\ngoal (1 subgoal):\n 1. \\<And>xs f l.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ((x, xa), ys, f', l')\n                       \\<in> trcl pr_algo_lts' \\<longrightarrow>\n                       length (filter ((=) (SAT_PUSH' (u, v))) ys)\n                       \\<le> 2 * card V - xa v);\n        ((f, l), xs, f', l') \\<in> trcl pr_algo_lts'\\<rbrakk>\n       \\<Longrightarrow> length (filter ((=) (SAT_PUSH' (u, v))) xs)\n                         \\<le> 2 * card V - l v", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>ys.\n     length ys < length p \\<longrightarrow>\n     (\\<forall>x xa.\n         ((x, xa), ys, f', l') \\<in> trcl pr_algo_lts' \\<longrightarrow>\n         length (filter ((=) (SAT_PUSH' (u, v))) ys)\n         \\<le> 2 * card V - xa v)\n  ((f, l), p, f', l') \\<in> trcl pr_algo_lts'\n\ngoal (1 subgoal):\n 1. length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "proof (cases p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>ys.\n                length ys < length p \\<longrightarrow>\n                (\\<forall>x xa.\n                    ((x, xa), ys, f', l')\n                    \\<in> trcl pr_algo_lts' \\<longrightarrow>\n                    length (filter ((=) (SAT_PUSH' (u, v))) ys)\n                    \\<le> 2 * card V - xa v);\n     ((f, l), p, f', l') \\<in> trcl pr_algo_lts'; p = []\\<rbrakk>\n    \\<Longrightarrow> length (filter ((=) (SAT_PUSH' (u, v))) p)\n                      \\<le> 2 * card V - l v\n 2. \\<And>a list.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length p \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ((x, xa), ys, f', l')\n                       \\<in> trcl pr_algo_lts' \\<longrightarrow>\n                       length (filter ((=) (SAT_PUSH' (u, v))) ys)\n                       \\<le> 2 * card V - xa v);\n        ((f, l), p, f', l') \\<in> trcl pr_algo_lts'; p = a # list\\<rbrakk>\n       \\<Longrightarrow> length (filter ((=) (SAT_PUSH' (u, v))) p)\n                         \\<le> 2 * card V - l v", "case Nil"], ["proof (state)\nthis:\n  p = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>ys.\n                length ys < length p \\<longrightarrow>\n                (\\<forall>x xa.\n                    ((x, xa), ys, f', l')\n                    \\<in> trcl pr_algo_lts' \\<longrightarrow>\n                    length (filter ((=) (SAT_PUSH' (u, v))) ys)\n                    \\<le> 2 * card V - xa v);\n     ((f, l), p, f', l') \\<in> trcl pr_algo_lts'; p = []\\<rbrakk>\n    \\<Longrightarrow> length (filter ((=) (SAT_PUSH' (u, v))) p)\n                      \\<le> 2 * card V - l v\n 2. \\<And>a list.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length p \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ((x, xa), ys, f', l')\n                       \\<in> trcl pr_algo_lts' \\<longrightarrow>\n                       length (filter ((=) (SAT_PUSH' (u, v))) ys)\n                       \\<le> 2 * card V - xa v);\n        ((f, l), p, f', l') \\<in> trcl pr_algo_lts'; p = a # list\\<rbrakk>\n       \\<Longrightarrow> length (filter ((=) (SAT_PUSH' (u, v))) p)\n                         \\<le> 2 * card V - l v", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = []\n\ngoal (1 subgoal):\n 1. length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "by auto"], ["proof (state)\nthis:\n  length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length p \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ((x, xa), ys, f', l')\n                       \\<in> trcl pr_algo_lts' \\<longrightarrow>\n                       length (filter ((=) (SAT_PUSH' (u, v))) ys)\n                       \\<le> 2 * card V - xa v);\n        ((f, l), p, f', l') \\<in> trcl pr_algo_lts'; p = a # list\\<rbrakk>\n       \\<Longrightarrow> length (filter ((=) (SAT_PUSH' (u, v))) p)\n                         \\<le> 2 * card V - l v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length p \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ((x, xa), ys, f', l')\n                       \\<in> trcl pr_algo_lts' \\<longrightarrow>\n                       length (filter ((=) (SAT_PUSH' (u, v))) ys)\n                       \\<le> 2 * card V - xa v);\n        ((f, l), p, f', l') \\<in> trcl pr_algo_lts'; p = a # list\\<rbrakk>\n       \\<Longrightarrow> length (filter ((=) (SAT_PUSH' (u, v))) p)\n                         \\<le> 2 * card V - l v", "case [simp]: (Cons a p')"], ["proof (state)\nthis:\n  p = a # p'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length p \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ((x, xa), ys, f', l')\n                       \\<in> trcl pr_algo_lts' \\<longrightarrow>\n                       length (filter ((=) (SAT_PUSH' (u, v))) ys)\n                       \\<le> 2 * card V - xa v);\n        ((f, l), p, f', l') \\<in> trcl pr_algo_lts'; p = a # list\\<rbrakk>\n       \\<Longrightarrow> length (filter ((=) (SAT_PUSH' (u, v))) p)\n                         \\<le> 2 * card V - l v", "from \"1.prems\""], ["proof (chain)\npicking this:\n  ((f, l), p, f', l') \\<in> trcl pr_algo_lts'", "obtain fh lh \n        where FIRST: \"((f,l),a,(fh,lh)) \\<in> pr_algo_lts'\"\n          and PP: \"((fh,lh),p',(f',l')) \\<in> trcl pr_algo_lts'\""], ["proof (prove)\nusing this:\n  ((f, l), p, f', l') \\<in> trcl pr_algo_lts'\n\ngoal (1 subgoal):\n 1. (\\<And>fh lh.\n        \\<lbrakk>((f, l), a, fh, lh) \\<in> pr_algo_lts';\n         ((fh, lh), p', f', l') \\<in> trcl pr_algo_lts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest!: trcl_uncons)"], ["proof (state)\nthis:\n  ((f, l), a, fh, lh) \\<in> pr_algo_lts'\n  ((fh, lh), p', f', l') \\<in> trcl pr_algo_lts'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length p \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ((x, xa), ys, f', l')\n                       \\<in> trcl pr_algo_lts' \\<longrightarrow>\n                       length (filter ((=) (SAT_PUSH' (u, v))) ys)\n                       \\<le> 2 * card V - xa v);\n        ((f, l), p, f', l') \\<in> trcl pr_algo_lts'; p = a # list\\<rbrakk>\n       \\<Longrightarrow> length (filter ((=) (SAT_PUSH' (u, v))) p)\n                         \\<le> 2 * card V - l v", "from FIRST"], ["proof (chain)\npicking this:\n  ((f, l), a, fh, lh) \\<in> pr_algo_lts'", "interpret Height_Bounded_Labeling c s t f l"], ["proof (prove)\nusing this:\n  ((f, l), a, fh, lh) \\<in> pr_algo_lts'\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f l", "by cases auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length p \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ((x, xa), ys, f', l')\n                       \\<in> trcl pr_algo_lts' \\<longrightarrow>\n                       length (filter ((=) (SAT_PUSH' (u, v))) ys)\n                       \\<le> 2 * card V - xa v);\n        ((f, l), p, f', l') \\<in> trcl pr_algo_lts'; p = a # list\\<rbrakk>\n       \\<Longrightarrow> length (filter ((=) (SAT_PUSH' (u, v))) p)\n                         \\<le> 2 * card V - l v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "proof (cases \"a = SAT_PUSH' (u,v)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = SAT_PUSH' (u, v) \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v\n 2. a \\<noteq> SAT_PUSH' (u, v) \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "case [simp]: False"], ["proof (state)\nthis:\n  a \\<noteq> SAT_PUSH' (u, v)\n\ngoal (2 subgoals):\n 1. a = SAT_PUSH' (u, v) \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v\n 2. a \\<noteq> SAT_PUSH' (u, v) \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "from \"1.IH\" PP"], ["proof (chain)\npicking this:\n  \\<forall>ys.\n     length ys < length p \\<longrightarrow>\n     (\\<forall>x xa.\n         ((x, xa), ys, f', l') \\<in> trcl pr_algo_lts' \\<longrightarrow>\n         length (filter ((=) (SAT_PUSH' (u, v))) ys)\n         \\<le> 2 * card V - xa v)\n  ((fh, lh), p', f', l') \\<in> trcl pr_algo_lts'", "have \n          \"length (filter ((=) (SAT_PUSH' (u, v))) p') \n          \\<le> 2 * card V - lh v\""], ["proof (prove)\nusing this:\n  \\<forall>ys.\n     length ys < length p \\<longrightarrow>\n     (\\<forall>x xa.\n         ((x, xa), ys, f', l') \\<in> trcl pr_algo_lts' \\<longrightarrow>\n         length (filter ((=) (SAT_PUSH' (u, v))) ys)\n         \\<le> 2 * card V - xa v)\n  ((fh, lh), p', f', l') \\<in> trcl pr_algo_lts'\n\ngoal (1 subgoal):\n 1. length (filter ((=) (SAT_PUSH' (u, v))) p') \\<le> 2 * card V - lh v", "by auto"], ["proof (state)\nthis:\n  length (filter ((=) (SAT_PUSH' (u, v))) p') \\<le> 2 * card V - lh v\n\ngoal (2 subgoals):\n 1. a = SAT_PUSH' (u, v) \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v\n 2. a \\<noteq> SAT_PUSH' (u, v) \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "with FIRST"], ["proof (chain)\npicking this:\n  ((f, l), a, fh, lh) \\<in> pr_algo_lts'\n  length (filter ((=) (SAT_PUSH' (u, v))) p') \\<le> 2 * card V - lh v", "show ?thesis"], ["proof (prove)\nusing this:\n  ((f, l), a, fh, lh) \\<in> pr_algo_lts'\n  length (filter ((=) (SAT_PUSH' (u, v))) p') \\<le> 2 * card V - lh v\n\ngoal (1 subgoal):\n 1. length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "apply (cases; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ua.\n       \\<lbrakk>length (filter ((=) (SAT_PUSH' (u, v))) p')\n                \\<le> 2 * card V - relabel_effect f l ua v;\n        a = RELABEL'; fh = f; lh = relabel_effect f l ua;\n        Height_Bounded_Labeling c s t f l; relabel_precond f l ua;\n        ((f, l), RELABEL', f, relabel_effect f l ua)\n        \\<in> pr_algo_lts'\\<rbrakk>\n       \\<Longrightarrow> length (filter ((=) (SAT_PUSH' (u, v))) p')\n                         \\<le> 2 * card V - l v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ua.\n       \\<lbrakk>length (filter ((=) (SAT_PUSH' (u, v))) p')\n                \\<le> 2 * card V - relabel_effect f l ua v;\n        a = RELABEL'; fh = f; lh = relabel_effect f l ua;\n        Height_Bounded_Labeling c s t f l; relabel_precond f l ua;\n        ((f, l), RELABEL', f, relabel_effect f l ua)\n        \\<in> pr_algo_lts'\\<rbrakk>\n       \\<Longrightarrow> length (filter ((=) (SAT_PUSH' (u, v))) p')\n                         \\<le> 2 * card V - l v", "fix ua :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ua.\n       \\<lbrakk>length (filter ((=) (SAT_PUSH' (u, v))) p')\n                \\<le> 2 * card V - relabel_effect f l ua v;\n        a = RELABEL'; fh = f; lh = relabel_effect f l ua;\n        Height_Bounded_Labeling c s t f l; relabel_precond f l ua;\n        ((f, l), RELABEL', f, relabel_effect f l ua)\n        \\<in> pr_algo_lts'\\<rbrakk>\n       \\<Longrightarrow> length (filter ((=) (SAT_PUSH' (u, v))) p')\n                         \\<le> 2 * card V - l v", "assume a1: \"length (filter ((=) (SAT_PUSH' (u, v))) p') \n                    \\<le> 2 * card V - relabel_effect f l ua v\""], ["proof (state)\nthis:\n  length (filter ((=) (SAT_PUSH' (u, v))) p')\n  \\<le> 2 * card V - relabel_effect f l ua v\n\ngoal (1 subgoal):\n 1. \\<And>ua.\n       \\<lbrakk>length (filter ((=) (SAT_PUSH' (u, v))) p')\n                \\<le> 2 * card V - relabel_effect f l ua v;\n        a = RELABEL'; fh = f; lh = relabel_effect f l ua;\n        Height_Bounded_Labeling c s t f l; relabel_precond f l ua;\n        ((f, l), RELABEL', f, relabel_effect f l ua)\n        \\<in> pr_algo_lts'\\<rbrakk>\n       \\<Longrightarrow> length (filter ((=) (SAT_PUSH' (u, v))) p')\n                         \\<le> 2 * card V - l v", "assume a2: \"relabel_precond f l ua\""], ["proof (state)\nthis:\n  relabel_precond f l ua\n\ngoal (1 subgoal):\n 1. \\<And>ua.\n       \\<lbrakk>length (filter ((=) (SAT_PUSH' (u, v))) p')\n                \\<le> 2 * card V - relabel_effect f l ua v;\n        a = RELABEL'; fh = f; lh = relabel_effect f l ua;\n        Height_Bounded_Labeling c s t f l; relabel_precond f l ua;\n        ((f, l), RELABEL', f, relabel_effect f l ua)\n        \\<in> pr_algo_lts'\\<rbrakk>\n       \\<Longrightarrow> length (filter ((=) (SAT_PUSH' (u, v))) p')\n                         \\<le> 2 * card V - l v", "have \"2 * card V - relabel_effect f l ua v \\<le> 2 * card V - l v \n          \\<longrightarrow> length (filter ((=) (SAT_PUSH' (u, v))) p') \\<le> 2 * card V - l v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * card V - relabel_effect f l ua v\n    \\<le> 2 * card V - l v \\<longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p') \\<le> 2 * card V - l v", "using a1 order_trans"], ["proof (prove)\nusing this:\n  length (filter ((=) (SAT_PUSH' (u, v))) p')\n  \\<le> 2 * card V - relabel_effect f l ua v\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. 2 * card V - relabel_effect f l ua v\n    \\<le> 2 * card V - l v \\<longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p') \\<le> 2 * card V - l v", "by blast"], ["proof (state)\nthis:\n  2 * card V - relabel_effect f l ua v\n  \\<le> 2 * card V - l v \\<longrightarrow>\n  length (filter ((=) (SAT_PUSH' (u, v))) p') \\<le> 2 * card V - l v\n\ngoal (1 subgoal):\n 1. \\<And>ua.\n       \\<lbrakk>length (filter ((=) (SAT_PUSH' (u, v))) p')\n                \\<le> 2 * card V - relabel_effect f l ua v;\n        a = RELABEL'; fh = f; lh = relabel_effect f l ua;\n        Height_Bounded_Labeling c s t f l; relabel_precond f l ua;\n        ((f, l), RELABEL', f, relabel_effect f l ua)\n        \\<in> pr_algo_lts'\\<rbrakk>\n       \\<Longrightarrow> length (filter ((=) (SAT_PUSH' (u, v))) p')\n                         \\<le> 2 * card V - l v", "then"], ["proof (chain)\npicking this:\n  2 * card V - relabel_effect f l ua v\n  \\<le> 2 * card V - l v \\<longrightarrow>\n  length (filter ((=) (SAT_PUSH' (u, v))) p') \\<le> 2 * card V - l v", "show \"length (filter ((=) (SAT_PUSH' (u, v))) p') \n                    \\<le> 2 * card V - l v\""], ["proof (prove)\nusing this:\n  2 * card V - relabel_effect f l ua v\n  \\<le> 2 * card V - l v \\<longrightarrow>\n  length (filter ((=) (SAT_PUSH' (u, v))) p') \\<le> 2 * card V - l v\n\ngoal (1 subgoal):\n 1. length (filter ((=) (SAT_PUSH' (u, v))) p') \\<le> 2 * card V - l v", "using a2 a1"], ["proof (prove)\nusing this:\n  2 * card V - relabel_effect f l ua v\n  \\<le> 2 * card V - l v \\<longrightarrow>\n  length (filter ((=) (SAT_PUSH' (u, v))) p') \\<le> 2 * card V - l v\n  relabel_precond f l ua\n  length (filter ((=) (SAT_PUSH' (u, v))) p')\n  \\<le> 2 * card V - relabel_effect f l ua v\n\ngoal (1 subgoal):\n 1. length (filter ((=) (SAT_PUSH' (u, v))) p') \\<le> 2 * card V - l v", "by (metis (no_types) Labeling.relabel_increase_u \n                Labeling_axioms diff_le_mono2 nat_less_le \n                relabel_preserve_other)"], ["proof (state)\nthis:\n  length (filter ((=) (SAT_PUSH' (u, v))) p') \\<le> 2 * card V - l v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v\n\ngoal (1 subgoal):\n 1. a = SAT_PUSH' (u, v) \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a = SAT_PUSH' (u, v) \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "case [simp]: True"], ["proof (state)\nthis:\n  a = SAT_PUSH' (u, v)\n\ngoal (1 subgoal):\n 1. a = SAT_PUSH' (u, v) \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "from FIRST"], ["proof (chain)\npicking this:\n  ((f, l), a, fh, lh) \\<in> pr_algo_lts'", "have \n          [simp]: \"fh = push_effect f (u,v)\" \"lh = l\" \n          and PRE: \"sat_push_precond f l (u,v)\""], ["proof (prove)\nusing this:\n  ((f, l), a, fh, lh) \\<in> pr_algo_lts'\n\ngoal (1 subgoal):\n 1. (fh = push_effect f (u, v) &&& lh = l) &&& sat_push_precond f l (u, v)", "by (auto elim !: pr_algo_lts'.cases)"], ["proof (state)\nthis:\n  fh = push_effect f (u, v)\n  lh = l\n  sat_push_precond f l (u, v)\n\ngoal (1 subgoal):\n 1. a = SAT_PUSH' (u, v) \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "from PRE"], ["proof (chain)\npicking this:\n  sat_push_precond f l (u, v)", "have \"(u,v)\\<in>cf.E\" \"l u = l v + 1\""], ["proof (prove)\nusing this:\n  sat_push_precond f l (u, v)\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> cf.E &&& l u = l v + 1", "unfolding sat_push_precond_def"], ["proof (prove)\nusing this:\n  case (u, v) of\n  (u, v) \\<Rightarrow>\n    (0::'capacity) < excess f u \\<and>\n    cf (u, v) \\<le> excess f u \\<and> (u, v) \\<in> cf.E \\<and> l u = l v + 1\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> cf.E &&& l u = l v + 1", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<in> cf.E\n  l u = l v + 1\n\ngoal (1 subgoal):\n 1. a = SAT_PUSH' (u, v) \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "hence \"u\\<in>V\" \"v\\<in>V\" \"u\\<noteq>v\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> cf.E\n  l u = l v + 1\n\ngoal (1 subgoal):\n 1. u \\<in> V &&& v \\<in> V &&& u \\<noteq> v", "using cfE_ss_invE E_ss_VxV"], ["proof (prove)\nusing this:\n  (u, v) \\<in> cf.E\n  l u = l v + 1\n  cf.E \\<subseteq> E \\<union> E\\<inverse>\n  E \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. u \\<in> V &&& v \\<in> V &&& u \\<noteq> v", "by auto"], ["proof (state)\nthis:\n  u \\<in> V\n  v \\<in> V\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. a = SAT_PUSH' (u, v) \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "have UVNEH: \"(u,v)\\<notin>cfE_of fh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<notin> cfE_of fh", "using \\<open>u\\<noteq>v\\<close>"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. (u, v) \\<notin> cfE_of fh", "apply (simp \n                  add: sat_push_alt[OF PRE] augment_edge_cf'[OF \\<open>(u,v)\\<in>cf.E\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    (u, v)\n    \\<notin> Graph.E\n              (cf((u, v) := 0::'capacity, (v, u) := cf (v, u) + cf (u, v)))", "unfolding Graph.E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    (u, v)\n    \\<notin> {(ua, va).\n              (cf((u, v) := 0::'capacity, (v, u) := cf (v, u) + cf (u, v)))\n               (ua, va) \\<noteq>\n              (0::'capacity)}", "by simp"], ["proof (state)\nthis:\n  (u, v) \\<notin> cfE_of fh\n\ngoal (1 subgoal):\n 1. a = SAT_PUSH' (u, v) \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "proof (cases \"SAT_PUSH' (u,v) \\<in> set p'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. SAT_PUSH' (u, v) \\<in> set p' \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v\n 2. SAT_PUSH' (u, v) \\<notin> set p' \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "case False"], ["proof (state)\nthis:\n  SAT_PUSH' (u, v) \\<notin> set p'\n\ngoal (2 subgoals):\n 1. SAT_PUSH' (u, v) \\<in> set p' \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v\n 2. SAT_PUSH' (u, v) \\<notin> set p' \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "hence [simp]: \"filter ((=) (SAT_PUSH' (u,v))) p' = []\""], ["proof (prove)\nusing this:\n  SAT_PUSH' (u, v) \\<notin> set p'\n\ngoal (1 subgoal):\n 1. filter ((=) (SAT_PUSH' (u, v))) p' = []", "by (induction p') auto"], ["proof (state)\nthis:\n  filter ((=) (SAT_PUSH' (u, v))) p' = []\n\ngoal (2 subgoals):\n 1. SAT_PUSH' (u, v) \\<in> set p' \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v\n 2. SAT_PUSH' (u, v) \\<notin> set p' \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "using bspec[OF height_bound \\<open>u\\<in>V\\<close>]"], ["proof (prove)\nusing this:\n  l u \\<le> 2 * card V - 1\n\ngoal (1 subgoal):\n 1. length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "using bspec[OF height_bound \\<open>v\\<in>V\\<close>]"], ["proof (prove)\nusing this:\n  l u \\<le> 2 * card V - 1\n  l v \\<le> 2 * card V - 1\n\ngoal (1 subgoal):\n 1. length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "using card_V_ge2"], ["proof (prove)\nusing this:\n  l u \\<le> 2 * card V - 1\n  l v \\<le> 2 * card V - 1\n  2 \\<le> card V\n\ngoal (1 subgoal):\n 1. length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "by simp"], ["proof (state)\nthis:\n  length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v\n\ngoal (1 subgoal):\n 1. SAT_PUSH' (u, v) \\<in> set p' \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. SAT_PUSH' (u, v) \\<in> set p' \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "case True"], ["proof (state)\nthis:\n  SAT_PUSH' (u, v) \\<in> set p'\n\ngoal (1 subgoal):\n 1. SAT_PUSH' (u, v) \\<in> set p' \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "then"], ["proof (chain)\npicking this:\n  SAT_PUSH' (u, v) \\<in> set p'", "obtain p1 p2 \n            where [simp]: \"p'=p1@SAT_PUSH' (u,v)#p2\" \n              and NP1: \"SAT_PUSH' (u,v) \\<notin> set p1\""], ["proof (prove)\nusing this:\n  SAT_PUSH' (u, v) \\<in> set p'\n\ngoal (1 subgoal):\n 1. (\\<And>p1 p2.\n        \\<lbrakk>p' = p1 @ SAT_PUSH' (u, v) # p2;\n         SAT_PUSH' (u, v) \\<notin> set p1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using in_set_conv_decomp_first[of _ p']"], ["proof (prove)\nusing this:\n  SAT_PUSH' (u, v) \\<in> set p'\n  (?x \\<in> set p') =\n  (\\<exists>ys zs. p' = ys @ ?x # zs \\<and> ?x \\<notin> set ys)\n\ngoal (1 subgoal):\n 1. (\\<And>p1 p2.\n        \\<lbrakk>p' = p1 @ SAT_PUSH' (u, v) # p2;\n         SAT_PUSH' (u, v) \\<notin> set p1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p' = p1 @ SAT_PUSH' (u, v) # p2\n  SAT_PUSH' (u, v) \\<notin> set p1\n\ngoal (1 subgoal):\n 1. SAT_PUSH' (u, v) \\<in> set p' \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "from NP1"], ["proof (chain)\npicking this:\n  SAT_PUSH' (u, v) \\<notin> set p1", "have [simp]: \"filter ((=) (SAT_PUSH' (u,v))) p1 = []\""], ["proof (prove)\nusing this:\n  SAT_PUSH' (u, v) \\<notin> set p1\n\ngoal (1 subgoal):\n 1. filter ((=) (SAT_PUSH' (u, v))) p1 = []", "by (induction p1) auto"], ["proof (state)\nthis:\n  filter ((=) (SAT_PUSH' (u, v))) p1 = []\n\ngoal (1 subgoal):\n 1. SAT_PUSH' (u, v) \\<in> set p' \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "from PP"], ["proof (chain)\npicking this:\n  ((fh, lh), p', f', l') \\<in> trcl pr_algo_lts'", "obtain f2 l2 f3 l3 \n            where P1: \"((fh,lh),p1,(f2,l2)) \\<in> trcl pr_algo_lts'\"\n              and S: \"((f2,l2),SAT_PUSH' (u,v),(f3,l3)) \\<in> pr_algo_lts'\"\n              and P2: \"((f3,l3),p2,(f',l'))\\<in>trcl pr_algo_lts'\""], ["proof (prove)\nusing this:\n  ((fh, lh), p', f', l') \\<in> trcl pr_algo_lts'\n\ngoal (1 subgoal):\n 1. (\\<And>f2 l2 f3 l3.\n        \\<lbrakk>((fh, lh), p1, f2, l2) \\<in> trcl pr_algo_lts';\n         ((f2, l2), SAT_PUSH' (u, v), f3, l3) \\<in> pr_algo_lts';\n         ((f3, l3), p2, f', l') \\<in> trcl pr_algo_lts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: trcl_conv)"], ["proof (state)\nthis:\n  ((fh, lh), p1, f2, l2) \\<in> trcl pr_algo_lts'\n  ((f2, l2), SAT_PUSH' (u, v), f3, l3) \\<in> pr_algo_lts'\n  ((f3, l3), p2, f', l') \\<in> trcl pr_algo_lts'\n\ngoal (1 subgoal):\n 1. SAT_PUSH' (u, v) \\<in> set p' \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "from S"], ["proof (chain)\npicking this:\n  ((f2, l2), SAT_PUSH' (u, v), f3, l3) \\<in> pr_algo_lts'", "have \"(u,v)\\<in>cfE_of f2\" and [simp]: \"l3=l2\""], ["proof (prove)\nusing this:\n  ((f2, l2), SAT_PUSH' (u, v), f3, l3) \\<in> pr_algo_lts'\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> cfE_of f2 &&& l3 = l2", "by (auto elim!: pr_algo_lts'.cases simp: sat_push_precond_def)"], ["proof (state)\nthis:\n  (u, v) \\<in> cfE_of f2\n  l3 = l2\n\ngoal (1 subgoal):\n 1. SAT_PUSH' (u, v) \\<in> set p' \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "with edge_reappears_at_increased_labeling[OF P1 _ UVNEH] \n            \\<open>l u = l v + 1\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>lh v + 1 \\<le> lh u; (u, v) \\<in> cfE_of f2\\<rbrakk>\n  \\<Longrightarrow> lh v < l2 v\n  l u = l v + 1\n  (u, v) \\<in> cfE_of f2\n  l3 = l2", "have AUX1: \"l v < l2 v\""], ["proof (prove)\nusing this:\n  \\<lbrakk>lh v + 1 \\<le> lh u; (u, v) \\<in> cfE_of f2\\<rbrakk>\n  \\<Longrightarrow> lh v < l2 v\n  l u = l v + 1\n  (u, v) \\<in> cfE_of f2\n  l3 = l2\n\ngoal (1 subgoal):\n 1. l v < l2 v", "by auto"], ["proof (state)\nthis:\n  l v < l2 v\n\ngoal (1 subgoal):\n 1. SAT_PUSH' (u, v) \\<in> set p' \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "from S"], ["proof (chain)\npicking this:\n  ((f2, l2), SAT_PUSH' (u, v), f3, l3) \\<in> pr_algo_lts'", "interpret l2: Height_Bounded_Labeling c s t f2 l2"], ["proof (prove)\nusing this:\n  ((f2, l2), SAT_PUSH' (u, v), f3, l3) \\<in> pr_algo_lts'\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f2 l2", "by (auto elim!: pr_algo_lts'.cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. SAT_PUSH' (u, v) \\<in> set p' \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "from spec[OF \"1.IH\", of \"SAT_PUSH' (u,v)#p2\"] S P2"], ["proof (chain)\npicking this:\n  length (SAT_PUSH' (u, v) # p2) < length p \\<longrightarrow>\n  (\\<forall>x xa.\n      ((x, xa), SAT_PUSH' (u, v) # p2, f', l')\n      \\<in> trcl pr_algo_lts' \\<longrightarrow>\n      length (filter ((=) (SAT_PUSH' (u, v))) (SAT_PUSH' (u, v) # p2))\n      \\<le> 2 * card V - xa v)\n  ((f2, l2), SAT_PUSH' (u, v), f3, l3) \\<in> pr_algo_lts'\n  ((f3, l3), p2, f', l') \\<in> trcl pr_algo_lts'", "have \n            \"Suc (length (filter ((=) (SAT_PUSH' (u, v))) p2)) \n            \\<le> 2 * card V - l2 v\""], ["proof (prove)\nusing this:\n  length (SAT_PUSH' (u, v) # p2) < length p \\<longrightarrow>\n  (\\<forall>x xa.\n      ((x, xa), SAT_PUSH' (u, v) # p2, f', l')\n      \\<in> trcl pr_algo_lts' \\<longrightarrow>\n      length (filter ((=) (SAT_PUSH' (u, v))) (SAT_PUSH' (u, v) # p2))\n      \\<le> 2 * card V - xa v)\n  ((f2, l2), SAT_PUSH' (u, v), f3, l3) \\<in> pr_algo_lts'\n  ((f3, l3), p2, f', l') \\<in> trcl pr_algo_lts'\n\ngoal (1 subgoal):\n 1. Suc (length (filter ((=) (SAT_PUSH' (u, v))) p2))\n    \\<le> 2 * card V - l2 v", "by (auto simp: trcl_conv)"], ["proof (state)\nthis:\n  Suc (length (filter ((=) (SAT_PUSH' (u, v))) p2)) \\<le> 2 * card V - l2 v\n\ngoal (1 subgoal):\n 1. SAT_PUSH' (u, v) \\<in> set p' \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "also"], ["proof (state)\nthis:\n  Suc (length (filter ((=) (SAT_PUSH' (u, v))) p2)) \\<le> 2 * card V - l2 v\n\ngoal (1 subgoal):\n 1. SAT_PUSH' (u, v) \\<in> set p' \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "have \"\\<dots> + 1 \\<le> 2*card V - l v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * card V - l2 v + 1 \\<le> 2 * card V - l v", "using AUX1"], ["proof (prove)\nusing this:\n  l v < l2 v\n\ngoal (1 subgoal):\n 1. 2 * card V - l2 v + 1 \\<le> 2 * card V - l v", "using bspec[OF l2.height_bound \\<open>u\\<in>V\\<close>]"], ["proof (prove)\nusing this:\n  l v < l2 v\n  l2 u \\<le> 2 * card V - 1\n\ngoal (1 subgoal):\n 1. 2 * card V - l2 v + 1 \\<le> 2 * card V - l v", "using bspec[OF l2.height_bound \\<open>v\\<in>V\\<close>]"], ["proof (prove)\nusing this:\n  l v < l2 v\n  l2 u \\<le> 2 * card V - 1\n  l2 v \\<le> 2 * card V - 1\n\ngoal (1 subgoal):\n 1. 2 * card V - l2 v + 1 \\<le> 2 * card V - l v", "by auto"], ["proof (state)\nthis:\n  2 * card V - l2 v + 1 \\<le> 2 * card V - l v\n\ngoal (1 subgoal):\n 1. SAT_PUSH' (u, v) \\<in> set p' \\<Longrightarrow>\n    length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> x + 1 \\<le> y + 1) \\<Longrightarrow>\n  Suc (length (filter ((=) (SAT_PUSH' (u, v))) p2)) + 1\n  \\<le> 2 * card V - l v", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> x + 1 \\<le> y + 1) \\<Longrightarrow>\n  Suc (length (filter ((=) (SAT_PUSH' (u, v))) p2)) + 1\n  \\<le> 2 * card V - l v\n\ngoal (1 subgoal):\n 1. length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v", "by simp"], ["proof (state)\nthis:\n  length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (filter ((=) (SAT_PUSH' (u, v))) p) \\<le> 2 * card V - l v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((f, l), ?p, f', l') \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n  length (filter ((=) (SAT_PUSH' (u, v))) ?p) \\<le> 2 * card V - l v\n\ngoal (1 subgoal):\n 1. length (filter ((=) (SAT_PUSH' e)) p) \\<le> 2 * card V", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((f, l), ?p, f', l') \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n  length (filter ((=) (SAT_PUSH' (u, v))) ?p) \\<le> 2 * card V - l v\n\ngoal (1 subgoal):\n 1. length (filter ((=) (SAT_PUSH' e)) p) \\<le> 2 * card V", "using assms"], ["proof (prove)\nusing this:\n  ((f, l), ?p, f', l') \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n  length (filter ((=) (SAT_PUSH' (u, v))) ?p) \\<le> 2 * card V - l v\n  ((f, l), p, f', l') \\<in> trcl pr_algo_lts'\n\ngoal (1 subgoal):\n 1. length (filter ((=) (SAT_PUSH' e)) p) \\<le> 2 * card V", "by fastforce"], ["proof (state)\nthis:\n  length (filter ((=) (SAT_PUSH' e)) p) \\<le> 2 * card V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sat_push_action_bound':\n  assumes A: \"((f,l),p,(f',l')) \\<in> trcl pr_algo_lts'\"\n  shows \"length (filter is_SAT_PUSH' p) \\<le> 4 * card V * card E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter is_SAT_PUSH' p) \\<le> 4 * card V * card E", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (filter is_SAT_PUSH' p) \\<le> 4 * card V * card E", "from A"], ["proof (chain)\npicking this:\n  ((f, l), p, f', l') \\<in> trcl pr_algo_lts'", "have IN_E: \"e\\<in>E\\<union>E\\<inverse>\" if \"SAT_PUSH' e \\<in> set p\" for e"], ["proof (prove)\nusing this:\n  ((f, l), p, f', l') \\<in> trcl pr_algo_lts'\n\ngoal (1 subgoal):\n 1. e \\<in> E \\<union> E\\<inverse>", "using that cfE_of_ss_invE"], ["proof (prove)\nusing this:\n  ((f, l), p, f', l') \\<in> trcl pr_algo_lts'\n  SAT_PUSH' e \\<in> set p\n  cfE_of ?cf \\<subseteq> E \\<union> E\\<inverse>\n\ngoal (1 subgoal):\n 1. e \\<in> E \\<union> E\\<inverse>", "apply (induction p arbitrary: f l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f l.\n       \\<lbrakk>((f, l), [], f', l') \\<in> trcl pr_algo_lts';\n        SAT_PUSH' e \\<in> set [];\n        \\<And>cf. cfE_of cf \\<subseteq> E \\<union> E\\<inverse>\\<rbrakk>\n       \\<Longrightarrow> e \\<in> E \\<union> E\\<inverse>\n 2. \\<And>a p f l.\n       \\<lbrakk>\\<And>f l.\n                   \\<lbrakk>((f, l), p, f', l') \\<in> trcl pr_algo_lts';\n                    SAT_PUSH' e \\<in> set p;\n                    \\<And>cf.\n                       cfE_of cf \\<subseteq> E \\<union> E\\<inverse>\\<rbrakk>\n                   \\<Longrightarrow> e \\<in> E \\<union> E\\<inverse>;\n        ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts';\n        SAT_PUSH' e \\<in> set (a # p);\n        \\<And>cf. cfE_of cf \\<subseteq> E \\<union> E\\<inverse>\\<rbrakk>\n       \\<Longrightarrow> e \\<in> E \\<union> E\\<inverse>", "apply (auto \n        simp: trcl_conv sat_push_precond_def \n        elim!: pr_algo_lts'.cases\n      ; blast)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  SAT_PUSH' ?e \\<in> set p \\<Longrightarrow> ?e \\<in> E \\<union> E\\<inverse>\n\ngoal (1 subgoal):\n 1. length (filter is_SAT_PUSH' p) \\<le> 4 * card V * card E", "have AUX: \"length (filter (\\<lambda>a. \\<exists>e\\<in>S. a = SAT_PUSH' e) p) \n    = (\\<Sum>e\\<in>S. length (filter ((=) (SAT_PUSH' e)) p))\" if \"finite S\" for S"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>a. \\<exists>e\\<in>S. a = SAT_PUSH' e) p) =\n    (\\<Sum>e\\<in>S. length (filter ((=) (SAT_PUSH' e)) p))", "using that"], ["proof (prove)\nusing this:\n  finite S\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>a. \\<exists>e\\<in>S. a = SAT_PUSH' e) p) =\n    (\\<Sum>e\\<in>S. length (filter ((=) (SAT_PUSH' e)) p))", "apply induction"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (filter (\\<lambda>a. \\<exists>e\\<in>{}. a = SAT_PUSH' e) p) =\n    (\\<Sum>e\\<in>{}. length (filter ((=) (SAT_PUSH' e)) p))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        length (filter (\\<lambda>a. \\<exists>e\\<in>F. a = SAT_PUSH' e) p) =\n        (\\<Sum>e\\<in>F. length (filter ((=) (SAT_PUSH' e)) p))\\<rbrakk>\n       \\<Longrightarrow> length\n                          (filter\n                            (\\<lambda>a.\n                                \\<exists>e\\<in>insert x F. a = SAT_PUSH' e)\n                            p) =\n                         (\\<Sum>e\\<in>insert x F.\n                            length (filter ((=) (SAT_PUSH' e)) p))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        length (filter (\\<lambda>a. \\<exists>e\\<in>F. a = SAT_PUSH' e) p) =\n        (\\<Sum>e\\<in>F. length (filter ((=) (SAT_PUSH' e)) p))\\<rbrakk>\n       \\<Longrightarrow> length\n                          (filter\n                            (\\<lambda>a.\n                                \\<exists>e\\<in>insert x F. a = SAT_PUSH' e)\n                            p) =\n                         (\\<Sum>e\\<in>insert x F.\n                            length (filter ((=) (SAT_PUSH' e)) p))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b F.\n       \\<lbrakk>finite F; (a, b) \\<notin> F;\n        length (filter (\\<lambda>a. \\<exists>e\\<in>F. a = SAT_PUSH' e) p) =\n        (\\<Sum>e\\<in>F. length (filter ((=) (SAT_PUSH' e)) p))\\<rbrakk>\n       \\<Longrightarrow> length\n                          (filter\n                            (\\<lambda>aa.\n                                aa = SAT_PUSH' (a, b) \\<or>\n                                (\\<exists>e\\<in>F. aa = SAT_PUSH' e))\n                            p) =\n                         length (filter ((=) (SAT_PUSH' (a, b))) p) +\n                         (\\<Sum>e\\<in>F.\n                            length (filter ((=) (SAT_PUSH' e)) p))", "apply (subst length_filter_disj_or_conv; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b F.\n       \\<lbrakk>finite F; (a, b) \\<notin> F;\n        length (filter (\\<lambda>a. \\<exists>e\\<in>F. a = SAT_PUSH' e) p) =\n        (\\<Sum>e\\<in>F. length (filter ((=) (SAT_PUSH' e)) p))\\<rbrakk>\n       \\<Longrightarrow> length\n                          (filter (\\<lambda>aa. aa = SAT_PUSH' (a, b)) p) =\n                         length (filter ((=) (SAT_PUSH' (a, b))) p)", "apply (fo_rule arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b F.\n       \\<lbrakk>finite F; (a, b) \\<notin> F;\n        length (filter (\\<lambda>a. \\<exists>e\\<in>F. a = SAT_PUSH' e) p) =\n        (\\<Sum>e\\<in>F. length (filter ((=) (SAT_PUSH' e)) p))\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>aa. aa = SAT_PUSH' (a, b)) p =\n                         filter ((=) (SAT_PUSH' (a, b))) p", "subgoal premises"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>aa. aa = SAT_PUSH' (a_, b_)) p =\n    filter ((=) (SAT_PUSH' (a_, b_))) p", "by (induction p) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  finite ?S \\<Longrightarrow>\n  length (filter (\\<lambda>a. \\<exists>e\\<in>?S. a = SAT_PUSH' e) p) =\n  (\\<Sum>e\\<in>?S. length (filter ((=) (SAT_PUSH' e)) p))\n\ngoal (1 subgoal):\n 1. length (filter is_SAT_PUSH' p) \\<le> 4 * card V * card E", "have \"is_SAT_PUSH' a = (\\<exists>e\\<in>E\\<union>E\\<inverse>. a = SAT_PUSH' e)\" if \"a\\<in>set p\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_SAT_PUSH' a =\n    (\\<exists>e\\<in>E \\<union> E\\<inverse>. a = SAT_PUSH' e)", "using IN_E that"], ["proof (prove)\nusing this:\n  SAT_PUSH' ?e \\<in> set p \\<Longrightarrow> ?e \\<in> E \\<union> E\\<inverse>\n  a \\<in> set p\n\ngoal (1 subgoal):\n 1. is_SAT_PUSH' a =\n    (\\<exists>e\\<in>E \\<union> E\\<inverse>. a = SAT_PUSH' e)", "by (cases a) auto"], ["proof (state)\nthis:\n  ?a \\<in> set p \\<Longrightarrow>\n  is_SAT_PUSH' ?a =\n  (\\<exists>e\\<in>E \\<union> E\\<inverse>. ?a = SAT_PUSH' e)\n\ngoal (1 subgoal):\n 1. length (filter is_SAT_PUSH' p) \\<le> 4 * card V * card E", "hence \"length (filter is_SAT_PUSH' p) \n    = length (filter (\\<lambda>a. \\<exists>e\\<in>E\\<union>E\\<inverse>. a = SAT_PUSH' e) p)\""], ["proof (prove)\nusing this:\n  ?a \\<in> set p \\<Longrightarrow>\n  is_SAT_PUSH' ?a =\n  (\\<exists>e\\<in>E \\<union> E\\<inverse>. ?a = SAT_PUSH' e)\n\ngoal (1 subgoal):\n 1. length (filter is_SAT_PUSH' p) =\n    length\n     (filter\n       (\\<lambda>a. \\<exists>e\\<in>E \\<union> E\\<inverse>. a = SAT_PUSH' e)\n       p)", "by (auto cong: filter_cong)"], ["proof (state)\nthis:\n  length (filter is_SAT_PUSH' p) =\n  length\n   (filter\n     (\\<lambda>a. \\<exists>e\\<in>E \\<union> E\\<inverse>. a = SAT_PUSH' e) p)\n\ngoal (1 subgoal):\n 1. length (filter is_SAT_PUSH' p) \\<le> 4 * card V * card E", "also"], ["proof (state)\nthis:\n  length (filter is_SAT_PUSH' p) =\n  length\n   (filter\n     (\\<lambda>a. \\<exists>e\\<in>E \\<union> E\\<inverse>. a = SAT_PUSH' e) p)\n\ngoal (1 subgoal):\n 1. length (filter is_SAT_PUSH' p) \\<le> 4 * card V * card E", "have \"\\<dots> = (\\<Sum>e\\<in>E\\<union>E\\<inverse>. length (filter ((=) (SAT_PUSH' e)) p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (filter\n       (\\<lambda>a. \\<exists>e\\<in>E \\<union> E\\<inverse>. a = SAT_PUSH' e)\n       p) =\n    (\\<Sum>e\\<in>E \\<union> E\\<inverse>.\n       length (filter ((=) (SAT_PUSH' e)) p))", "by (auto simp: AUX)"], ["proof (state)\nthis:\n  length\n   (filter\n     (\\<lambda>a. \\<exists>e\\<in>E \\<union> E\\<inverse>. a = SAT_PUSH' e)\n     p) =\n  (\\<Sum>e\\<in>E \\<union> E\\<inverse>.\n     length (filter ((=) (SAT_PUSH' e)) p))\n\ngoal (1 subgoal):\n 1. length (filter is_SAT_PUSH' p) \\<le> 4 * card V * card E", "also"], ["proof (state)\nthis:\n  length\n   (filter\n     (\\<lambda>a. \\<exists>e\\<in>E \\<union> E\\<inverse>. a = SAT_PUSH' e)\n     p) =\n  (\\<Sum>e\\<in>E \\<union> E\\<inverse>.\n     length (filter ((=) (SAT_PUSH' e)) p))\n\ngoal (1 subgoal):\n 1. length (filter is_SAT_PUSH' p) \\<le> 4 * card V * card E", "have \"\\<dots> \\<le> (\\<Sum>i\\<in>E \\<union> E\\<inverse>. 2 * card V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>E \\<union> E\\<inverse>.\n       length (filter ((=) (SAT_PUSH' e)) p))\n    \\<le> (\\<Sum>i\\<in>E \\<union> E\\<inverse>. 2 * card V)", "using sum_mono[OF sat_push_edge_action_bound'[OF A], where K=\"E\\<union>E\\<inverse>\"]"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>E \\<union> E\\<inverse>.\n     length (filter ((=) (SAT_PUSH' (?e1 i))) p))\n  \\<le> (\\<Sum>i\\<in>E \\<union> E\\<inverse>. 2 * card V)\n\ngoal (1 subgoal):\n 1. (\\<Sum>e\\<in>E \\<union> E\\<inverse>.\n       length (filter ((=) (SAT_PUSH' e)) p))\n    \\<le> (\\<Sum>i\\<in>E \\<union> E\\<inverse>. 2 * card V)", "."], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>E \\<union> E\\<inverse>.\n     length (filter ((=) (SAT_PUSH' e)) p))\n  \\<le> (\\<Sum>i\\<in>E \\<union> E\\<inverse>. 2 * card V)\n\ngoal (1 subgoal):\n 1. length (filter is_SAT_PUSH' p) \\<le> 4 * card V * card E", "also"], ["proof (state)\nthis:\n  (\\<Sum>e\\<in>E \\<union> E\\<inverse>.\n     length (filter ((=) (SAT_PUSH' e)) p))\n  \\<le> (\\<Sum>i\\<in>E \\<union> E\\<inverse>. 2 * card V)\n\ngoal (1 subgoal):\n 1. length (filter is_SAT_PUSH' p) \\<le> 4 * card V * card E", "have \"\\<dots> \\<le> 4 * card V * card E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>E \\<union> E\\<inverse>. 2 * card V)\n    \\<le> 4 * card V * card E", "using card_Un_le[of E \"E\\<inverse>\"]"], ["proof (prove)\nusing this:\n  card (E \\<union> E\\<inverse>) \\<le> card E + card (E\\<inverse>)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>E \\<union> E\\<inverse>. 2 * card V)\n    \\<le> 4 * card V * card E", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>E \\<union> E\\<inverse>. 2 * card V) \\<le> 4 * card V * card E\n\ngoal (1 subgoal):\n 1. length (filter is_SAT_PUSH' p) \\<le> 4 * card V * card E", "finally"], ["proof (chain)\npicking this:\n  length (filter is_SAT_PUSH' p) \\<le> 4 * card V * card E", "show \"length (filter is_SAT_PUSH' p) \\<le> 4 * card V * card E\""], ["proof (prove)\nusing this:\n  length (filter is_SAT_PUSH' p) \\<le> 4 * card V * card E\n\ngoal (1 subgoal):\n 1. length (filter is_SAT_PUSH' p) \\<le> 4 * card V * card E", "."], ["proof (state)\nthis:\n  length (filter is_SAT_PUSH' p) \\<le> 4 * card V * card E\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>Network\\<close>"], ["", "subsubsection \\<open>Bounding the Non-Saturating Push Operations\\<close>"], ["", "text \\<open>\n  For estimating the number of non-saturating push operations, we\n  define a potential function that is the sum of the labels of\n  all active nodes, and examine the effect of the operations\n  on this potential:\n    \\<^item> A non-saturating push deactivates the source node and may activate \n      the target node. As the source node's label is higher, the potential\n      decreases.\n    \\<^item> A saturating push may activate a node, thus increasing the potential \n      by \\<open>O(V)\\<close>.\n    \\<^item> A relabel operation may increase the potential by \\<open>O(V)\\<close>.\n\n  As there are at most \\<open>O(V\\<^sup>2)\\<close> relabel and \\<open>O(VE)\\<close> saturating push operations,\n  the above bounds suffice to yield an \\<open>O(V\\<^sup>2E)\\<close> bound for the non-saturating \n  push operations.\n\n  This argumentation corresponds to \\cormen{26.23}.\n\\<close>"], ["", "text \\<open>Sum of heights of all active nodes\\<close>"], ["", "definition (in Network) \"nonsat_potential f l \\<equiv> sum l {v\\<in>V. excess f v > 0}\""], ["", "context Height_Bounded_Labeling\nbegin"], ["", "text \\<open>The potential does not exceed \\<open>O(V\\<^sup>2)\\<close>. \\<close>"], ["", "lemma nonsat_potential_bound:\n  shows \"nonsat_potential f l \\<le> 2 * (card V)^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonsat_potential f l \\<le> 2 * (card V)\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nonsat_potential f l \\<le> 2 * (card V)\\<^sup>2", "have \"nonsat_potential f l = (\\<Sum>v\\<in>{v \\<in> V. 0 < excess f v}. l v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonsat_potential f l =\n    (\\<Sum>v | v \\<in> V \\<and> (0::'a) < excess f v. l v)", "unfolding nonsat_potential_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum l {v \\<in> V. (0::'a) < excess f v} =\n    (\\<Sum>v | v \\<in> V \\<and> (0::'a) < excess f v. l v)", "by auto"], ["proof (state)\nthis:\n  nonsat_potential f l =\n  (\\<Sum>v | v \\<in> V \\<and> (0::'a) < excess f v. l v)\n\ngoal (1 subgoal):\n 1. nonsat_potential f l \\<le> 2 * (card V)\\<^sup>2", "also"], ["proof (state)\nthis:\n  nonsat_potential f l =\n  (\\<Sum>v | v \\<in> V \\<and> (0::'a) < excess f v. l v)\n\ngoal (1 subgoal):\n 1. nonsat_potential f l \\<le> 2 * (card V)\\<^sup>2", "have \"\\<dots> \\<le> (\\<Sum>v\\<in>V. l v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v | v \\<in> V \\<and> (0::'a) < excess f v. l v) \\<le> sum l V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>v | v \\<in> V \\<and> (0::'a) < excess f v. l v) \\<le> sum l V", "have f1:\"{v \\<in> V. 0 < excess f v} \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {v \\<in> V. (0::'a) < excess f v} \\<subseteq> V", "by auto"], ["proof (state)\nthis:\n  {v \\<in> V. (0::'a) < excess f v} \\<subseteq> V\n\ngoal (1 subgoal):\n 1. (\\<Sum>v | v \\<in> V \\<and> (0::'a) < excess f v. l v) \\<le> sum l V", "thus ?thesis"], ["proof (prove)\nusing this:\n  {v \\<in> V. (0::'a) < excess f v} \\<subseteq> V\n\ngoal (1 subgoal):\n 1. (\\<Sum>v | v \\<in> V \\<and> (0::'a) < excess f v. l v) \\<le> sum l V", "using sum.subset_diff[OF f1 finite_V, of l]"], ["proof (prove)\nusing this:\n  {v \\<in> V. (0::'a) < excess f v} \\<subseteq> V\n  sum l V =\n  sum l (V - {v \\<in> V. (0::'a) < excess f v}) +\n  sum l {v \\<in> V. (0::'a) < excess f v}\n\ngoal (1 subgoal):\n 1. (\\<Sum>v | v \\<in> V \\<and> (0::'a) < excess f v. l v) \\<le> sum l V", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>v | v \\<in> V \\<and> (0::'a) < excess f v. l v) \\<le> sum l V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>v | v \\<in> V \\<and> (0::'a) < excess f v. l v) \\<le> sum l V\n\ngoal (1 subgoal):\n 1. nonsat_potential f l \\<le> 2 * (card V)\\<^sup>2", "also"], ["proof (state)\nthis:\n  (\\<Sum>v | v \\<in> V \\<and> (0::'a) < excess f v. l v) \\<le> sum l V\n\ngoal (1 subgoal):\n 1. nonsat_potential f l \\<le> 2 * (card V)\\<^sup>2", "have \"\\<dots>  \\<le> (\\<Sum>v\\<in>V. 2 * card V - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum l V \\<le> (\\<Sum>v\\<in>V. 2 * card V - 1)", "using height_bound"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>V. l u \\<le> 2 * card V - 1\n\ngoal (1 subgoal):\n 1. sum l V \\<le> (\\<Sum>v\\<in>V. 2 * card V - 1)", "by (meson sum_mono)"], ["proof (state)\nthis:\n  sum l V \\<le> (\\<Sum>v\\<in>V. 2 * card V - 1)\n\ngoal (1 subgoal):\n 1. nonsat_potential f l \\<le> 2 * (card V)\\<^sup>2", "also"], ["proof (state)\nthis:\n  sum l V \\<le> (\\<Sum>v\\<in>V. 2 * card V - 1)\n\ngoal (1 subgoal):\n 1. nonsat_potential f l \\<le> 2 * (card V)\\<^sup>2", "have \"\\<dots> = card V * (2 * card V - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>V. 2 * card V - 1) = card V * (2 * card V - 1)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>V. 2 * card V - 1) = card V * (2 * card V - 1)\n\ngoal (1 subgoal):\n 1. nonsat_potential f l \\<le> 2 * (card V)\\<^sup>2", "also"], ["proof (state)\nthis:\n  (\\<Sum>v\\<in>V. 2 * card V - 1) = card V * (2 * card V - 1)\n\ngoal (1 subgoal):\n 1. nonsat_potential f l \\<le> 2 * (card V)\\<^sup>2", "have \"card V * (2 * card V - 1) \\<le> 2 * card V * card V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card V * (2 * card V - 1) \\<le> 2 * card V * card V", "by auto"], ["proof (state)\nthis:\n  card V * (2 * card V - 1) \\<le> 2 * card V * card V\n\ngoal (1 subgoal):\n 1. nonsat_potential f l \\<le> 2 * (card V)\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  nonsat_potential f l \\<le> 2 * card V * card V", "show ?thesis"], ["proof (prove)\nusing this:\n  nonsat_potential f l \\<le> 2 * card V * card V\n\ngoal (1 subgoal):\n 1. nonsat_potential f l \\<le> 2 * (card V)\\<^sup>2", "by (simp add: power2_eq_square)"], ["proof (state)\nthis:\n  nonsat_potential f l \\<le> 2 * (card V)\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>A non-saturating push decreases the potential.\\<close>"], ["", "lemma nonsat_push_decr_nonsat_potential:\n  assumes \"nonsat_push_precond f l e\"\n  shows \"nonsat_potential (push_effect f e) l < nonsat_potential f l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonsat_potential (push_effect f e) l < nonsat_potential f l", "proof (cases e)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       e = (a, b) \\<Longrightarrow>\n       nonsat_potential (push_effect f e) l < nonsat_potential f l", "case [simp]: (Pair u v)"], ["proof (state)\nthis:\n  e = (u, v)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       e = (a, b) \\<Longrightarrow>\n       nonsat_potential (push_effect f e) l < nonsat_potential f l", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. nonsat_potential (push_effect f e) l < nonsat_potential f l", "proof simp"], ["proof (state)\ngoal (1 subgoal):\n 1. nonsat_potential (push_effect f (u, v)) l < nonsat_potential f l", "interpret push_effect_locale c s t f l u v"], ["proof (prove)\ngoal (1 subgoal):\n 1. push_effect_locale c s t f l u v", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. push_precond f l (u, v)", "using assms"], ["proof (prove)\nusing this:\n  nonsat_push_precond f l e\n\ngoal (1 subgoal):\n 1. push_precond f l (u, v)", "by (simp add: push_precond_eq_sat_or_nonsat)"], ["proof (state)\ngoal (1 subgoal):\n 1. nonsat_potential f' l < nonsat_potential f l", "note [simp] = nonsat_push_\\<Delta>[OF assms[simplified]]"], ["proof (state)\nthis:\n  \\<Delta> = excess f u\n\ngoal (1 subgoal):\n 1. nonsat_potential f' l < nonsat_potential f l", "define S where \"S={x\\<in>V. x\\<noteq>u \\<and> x\\<noteq>v \\<and> 0<excess f x}\""], ["proof (state)\nthis:\n  S =\n  {x \\<in> V. x \\<noteq> u \\<and> x \\<noteq> v \\<and> (0::'a) < excess f x}\n\ngoal (1 subgoal):\n 1. nonsat_potential f' l < nonsat_potential f l", "have S_alt: \"S = {x\\<in>V. x\\<noteq>u \\<and> x\\<noteq>v \\<and> 0<excess f' x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S =\n    {x \\<in> V.\n     x \\<noteq> u \\<and> x \\<noteq> v \\<and> (0::'a) < excess f' x}", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> V.\n     x \\<noteq> u \\<and> x \\<noteq> v \\<and> (0::'a) < excess f x} =\n    {x \\<in> V.\n     x \\<noteq> u \\<and> x \\<noteq> v \\<and> (0::'a) < excess f' x}", "by auto"], ["proof (state)\nthis:\n  S =\n  {x \\<in> V. x \\<noteq> u \\<and> x \\<noteq> v \\<and> (0::'a) < excess f' x}\n\ngoal (1 subgoal):\n 1. nonsat_potential f' l < nonsat_potential f l", "have NES: \"s\\<notin>S\" \"u\\<notin>S\" \"v\\<notin>S\" \n      and [simp, intro!]: \"finite S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<notin> S &&& u \\<notin> S &&& v \\<notin> S) &&& finite S", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<notin> {x \\<in> V.\n                 x \\<noteq> u \\<and>\n                 x \\<noteq> v \\<and> (0::'a) < excess f x} &&&\n     u \\<notin> {x \\<in> V.\n                 x \\<noteq> u \\<and>\n                 x \\<noteq> v \\<and> (0::'a) < excess f x} &&&\n     v \\<notin> {x \\<in> V.\n                 x \\<noteq> u \\<and>\n                 x \\<noteq> v \\<and> (0::'a) < excess f x}) &&&\n    finite\n     {x \\<in> V.\n      x \\<noteq> u \\<and> x \\<noteq> v \\<and> (0::'a) < excess f x}", "using excess_s_non_pos"], ["proof (prove)\nusing this:\n  excess f s \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. (s \\<notin> {x \\<in> V.\n                 x \\<noteq> u \\<and>\n                 x \\<noteq> v \\<and> (0::'a) < excess f x} &&&\n     u \\<notin> {x \\<in> V.\n                 x \\<noteq> u \\<and>\n                 x \\<noteq> v \\<and> (0::'a) < excess f x} &&&\n     v \\<notin> {x \\<in> V.\n                 x \\<noteq> u \\<and>\n                 x \\<noteq> v \\<and> (0::'a) < excess f x}) &&&\n    finite\n     {x \\<in> V.\n      x \\<noteq> u \\<and> x \\<noteq> v \\<and> (0::'a) < excess f x}", "by auto"], ["proof (state)\nthis:\n  s \\<notin> S\n  u \\<notin> S\n  v \\<notin> S\n  finite S\n\ngoal (1 subgoal):\n 1. nonsat_potential f' l < nonsat_potential f l", "have 1: \"{v\\<in>V. 0 < excess f' v} = (if s=v then S else insert v S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {v \\<in> V. (0::'a) < excess f' v} = (if s = v then S else insert v S)", "unfolding S_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v \\<in> V. (0::'a) < excess f' v} =\n    (if s = v\n     then {x \\<in> V.\n           x \\<noteq> u \\<and> x \\<noteq> v \\<and> (0::'a) < excess f' x}\n     else insert v\n           {x \\<in> V.\n            x \\<noteq> u \\<and> x \\<noteq> v \\<and> (0::'a) < excess f' x})", "using excess_u_pos excess_non_negative' l'.excess_s_non_pos"], ["proof (prove)\nusing this:\n  (0::'a) < excess f u\n  \\<forall>v\\<in>V - {s}. (0::'a) \\<le> excess f v\n  excess f' s \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. {v \\<in> V. (0::'a) < excess f' v} =\n    (if s = v\n     then {x \\<in> V.\n           x \\<noteq> u \\<and> x \\<noteq> v \\<and> (0::'a) < excess f' x}\n     else insert v\n           {x \\<in> V.\n            x \\<noteq> u \\<and> x \\<noteq> v \\<and> (0::'a) < excess f' x})", "by (auto intro!: add_nonneg_pos)"], ["proof (state)\nthis:\n  {v \\<in> V. (0::'a) < excess f' v} = (if s = v then S else insert v S)\n\ngoal (1 subgoal):\n 1. nonsat_potential f' l < nonsat_potential f l", "have 2: \"{v\\<in>V. 0 < excess f v} \n      = insert u S \\<union> (if excess f v>0 then {v} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {v \\<in> V. (0::'a) < excess f v} =\n    insert u S \\<union> (if (0::'a) < excess f v then {v} else {})", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v \\<in> V. (0::'a) < excess f v} =\n    insert u\n     {x \\<in> V.\n      x \\<noteq> u \\<and> x \\<noteq> v \\<and> (0::'a) < excess f x} \\<union>\n    (if (0::'a) < excess f v then {v} else {})", "using excess_u_pos"], ["proof (prove)\nusing this:\n  (0::'a) < excess f u\n\ngoal (1 subgoal):\n 1. {v \\<in> V. (0::'a) < excess f v} =\n    insert u\n     {x \\<in> V.\n      x \\<noteq> u \\<and> x \\<noteq> v \\<and> (0::'a) < excess f x} \\<union>\n    (if (0::'a) < excess f v then {v} else {})", "by auto"], ["proof (state)\nthis:\n  {v \\<in> V. (0::'a) < excess f v} =\n  insert u S \\<union> (if (0::'a) < excess f v then {v} else {})\n\ngoal (1 subgoal):\n 1. nonsat_potential f' l < nonsat_potential f l", "show \"nonsat_potential f' l < nonsat_potential f l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonsat_potential f' l < nonsat_potential f l", "unfolding nonsat_potential_def 1 2"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum l (if s = v then S else insert v S)\n    < sum l (insert u S \\<union> (if (0::'a) < excess f v then {v} else {}))", "by (cases \"s=v\"; cases \"0<excess f v\"; auto simp: NES)"], ["proof (state)\nthis:\n  nonsat_potential f' l < nonsat_potential f l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nonsat_potential (push_effect f e) l < nonsat_potential f l\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>A saturating push increases the potential by \\<open>O(V)\\<close>.\\<close>"], ["", "lemma sat_push_nonsat_potential:\n  assumes PRE: \"sat_push_precond f l e\"\n  shows \"nonsat_potential (push_effect f e) l \n      \\<le> nonsat_potential f l + 2 * card V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonsat_potential (push_effect f e) l\n    \\<le> nonsat_potential f l + 2 * card V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nonsat_potential (push_effect f e) l\n    \\<le> nonsat_potential f l + 2 * card V", "obtain u v where [simp]: \"e = (u, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v. e = (u, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases e) auto"], ["proof (state)\nthis:\n  e = (u, v)\n\ngoal (1 subgoal):\n 1. nonsat_potential (push_effect f e) l\n    \\<le> nonsat_potential f l + 2 * card V", "interpret push_effect_locale c s t f l u v"], ["proof (prove)\ngoal (1 subgoal):\n 1. push_effect_locale c s t f l u v", "using PRE"], ["proof (prove)\nusing this:\n  sat_push_precond f l e\n\ngoal (1 subgoal):\n 1. push_effect_locale c s t f l u v", "by unfold_locales (simp add: push_precond_eq_sat_or_nonsat)"], ["proof (state)\ngoal (1 subgoal):\n 1. nonsat_potential (push_effect f e) l\n    \\<le> nonsat_potential f l + 2 * card V", "have [simp, intro!]: \"finite {v\\<in>V. excess f v > 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {v \\<in> V. (0::'a) < excess f v}", "by auto"], ["proof (state)\nthis:\n  finite {v \\<in> V. (0::'a) < excess f v}\n\ngoal (1 subgoal):\n 1. nonsat_potential (push_effect f e) l\n    \\<le> nonsat_potential f l + 2 * card V", "text \\<open>Only target node may get activated\\<close>"], ["proof (state)\nthis:\n  finite {v \\<in> V. (0::'a) < excess f v}\n\ngoal (1 subgoal):\n 1. nonsat_potential (push_effect f e) l\n    \\<le> nonsat_potential f l + 2 * card V", "have \"{v\\<in>V. excess f' v > 0} \\<subseteq> insert v {v\\<in>V. excess f v > 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {v \\<in> V. (0::'a) < excess f' v}\n    \\<subseteq> insert v {v \\<in> V. (0::'a) < excess f v}", "using \\<Delta>_positive"], ["proof (prove)\nusing this:\n  (0::'a) < \\<Delta>\n\ngoal (1 subgoal):\n 1. {v \\<in> V. (0::'a) < excess f' v}\n    \\<subseteq> insert v {v \\<in> V. (0::'a) < excess f v}", "by (auto simp: excess'_if)"], ["proof (state)\nthis:\n  {v \\<in> V. (0::'a) < excess f' v}\n  \\<subseteq> insert v {v \\<in> V. (0::'a) < excess f v}\n\ngoal (1 subgoal):\n 1. nonsat_potential (push_effect f e) l\n    \\<le> nonsat_potential f l + 2 * card V", "text \\<open>Thus, potential increases by at most \\<open>l v\\<close>\\<close>"], ["proof (state)\nthis:\n  {v \\<in> V. (0::'a) < excess f' v}\n  \\<subseteq> insert v {v \\<in> V. (0::'a) < excess f v}\n\ngoal (1 subgoal):\n 1. nonsat_potential (push_effect f e) l\n    \\<le> nonsat_potential f l + 2 * card V", "with sum_mono2[OF _ this, of l]"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite (insert v {v \\<in> V. (0::'a) < excess f v});\n   \\<And>b.\n      b \\<in> insert v {v \\<in> V. (0::'a) < excess f v} -\n              {v \\<in> V. (0::'a) < excess f' v} \\<Longrightarrow>\n      0 \\<le> l b\\<rbrakk>\n  \\<Longrightarrow> sum l {v \\<in> V. (0::'a) < excess f' v}\n                    \\<le> sum l (insert v {v \\<in> V. (0::'a) < excess f v})\n  {v \\<in> V. (0::'a) < excess f' v}\n  \\<subseteq> insert v {v \\<in> V. (0::'a) < excess f v}", "have \"nonsat_potential f' l \\<le> nonsat_potential f l + l v\""], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (insert v {v \\<in> V. (0::'a) < excess f v});\n   \\<And>b.\n      b \\<in> insert v {v \\<in> V. (0::'a) < excess f v} -\n              {v \\<in> V. (0::'a) < excess f' v} \\<Longrightarrow>\n      0 \\<le> l b\\<rbrakk>\n  \\<Longrightarrow> sum l {v \\<in> V. (0::'a) < excess f' v}\n                    \\<le> sum l (insert v {v \\<in> V. (0::'a) < excess f v})\n  {v \\<in> V. (0::'a) < excess f' v}\n  \\<subseteq> insert v {v \\<in> V. (0::'a) < excess f v}\n\ngoal (1 subgoal):\n 1. nonsat_potential f' l \\<le> nonsat_potential f l + l v", "unfolding nonsat_potential_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (insert v {v \\<in> V. (0::'a) < excess f v});\n   \\<And>b.\n      b \\<in> insert v {v \\<in> V. (0::'a) < excess f v} -\n              {v \\<in> V. (0::'a) < excess f' v} \\<Longrightarrow>\n      0 \\<le> l b\\<rbrakk>\n  \\<Longrightarrow> sum l {v \\<in> V. (0::'a) < excess f' v}\n                    \\<le> sum l (insert v {v \\<in> V. (0::'a) < excess f v})\n  {v \\<in> V. (0::'a) < excess f' v}\n  \\<subseteq> insert v {v \\<in> V. (0::'a) < excess f v}\n\ngoal (1 subgoal):\n 1. sum l {v \\<in> V. (0::'a) < excess f' v}\n    \\<le> sum l {v \\<in> V. (0::'a) < excess f v} + l v", "by (auto simp: sum.insert_if split: if_splits)"], ["proof (state)\nthis:\n  nonsat_potential f' l \\<le> nonsat_potential f l + l v\n\ngoal (1 subgoal):\n 1. nonsat_potential (push_effect f e) l\n    \\<le> nonsat_potential f l + 2 * card V", "text \\<open>Which is bounded by \\<open>O(V)\\<close>\\<close>"], ["proof (state)\nthis:\n  nonsat_potential f' l \\<le> nonsat_potential f l + l v\n\ngoal (1 subgoal):\n 1. nonsat_potential (push_effect f e) l\n    \\<le> nonsat_potential f l + 2 * card V", "also"], ["proof (state)\nthis:\n  nonsat_potential f' l \\<le> nonsat_potential f l + l v\n\ngoal (1 subgoal):\n 1. nonsat_potential (push_effect f e) l\n    \\<le> nonsat_potential f l + 2 * card V", "note height_bound'[of v]"], ["proof (state)\nthis:\n  v \\<in> V \\<Longrightarrow> l v \\<le> 2 * card V - 1\n\ngoal (1 subgoal):\n 1. nonsat_potential (push_effect f e) l\n    \\<le> nonsat_potential f l + 2 * card V", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>v \\<in> V;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      nonsat_potential f l + x \\<le> nonsat_potential f l + y\\<rbrakk>\n  \\<Longrightarrow> nonsat_potential f' l\n                    \\<le> nonsat_potential f l + (2 * card V - 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>v \\<in> V;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      nonsat_potential f l + x \\<le> nonsat_potential f l + y\\<rbrakk>\n  \\<Longrightarrow> nonsat_potential f' l\n                    \\<le> nonsat_potential f l + (2 * card V - 1)\n\ngoal (1 subgoal):\n 1. nonsat_potential (push_effect f e) l\n    \\<le> nonsat_potential f l + 2 * card V", "by simp"], ["proof (state)\nthis:\n  nonsat_potential (push_effect f e) l\n  \\<le> nonsat_potential f l + 2 * card V\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>A relabeling increases the potential by at most \\<open>O(V)\\<close>\\<close>"], ["", "lemma relabel_nonsat_potential:\n  assumes PRE: \"relabel_precond f l u\"\n  shows \"nonsat_potential f (relabel_effect f l u) \n       \\<le> nonsat_potential f l + 2 * card V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonsat_potential f (relabel_effect f l u)\n    \\<le> nonsat_potential f l + 2 * card V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nonsat_potential f (relabel_effect f l u)\n    \\<le> nonsat_potential f l + 2 * card V", "have [simp, intro!]: \"finite {v\\<in>V. excess f v > 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {v \\<in> V. (0::'a) < excess f v}", "by auto"], ["proof (state)\nthis:\n  finite {v \\<in> V. (0::'a) < excess f v}\n\ngoal (1 subgoal):\n 1. nonsat_potential f (relabel_effect f l u)\n    \\<le> nonsat_potential f l + 2 * card V", "let ?l' = \"relabel_effect f l u\""], ["proof (state)\ngoal (1 subgoal):\n 1. nonsat_potential f (relabel_effect f l u)\n    \\<le> nonsat_potential f l + 2 * card V", "interpret l': Height_Bounded_Labeling c s t f ?l'"], ["proof (prove)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f (relabel_effect f l u)", "using relabel_pres_height_bound[OF assms]"], ["proof (prove)\nusing this:\n  Height_Bounded_Labeling c s t f (relabel_effect f l u)\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f (relabel_effect f l u)", "."], ["proof (state)\ngoal (1 subgoal):\n 1. nonsat_potential f (relabel_effect f l u)\n    \\<le> nonsat_potential f l + 2 * card V", "from PRE"], ["proof (chain)\npicking this:\n  relabel_precond f l u", "have U_ACTIVE: \"u \\<in> {v\\<in>V. excess f v > 0}\" and [simp]: \"u\\<in>V\""], ["proof (prove)\nusing this:\n  relabel_precond f l u\n\ngoal (1 subgoal):\n 1. u \\<in> {v \\<in> V. (0::'a) < excess f v} &&& u \\<in> V", "unfolding relabel_precond_def"], ["proof (prove)\nusing this:\n  u \\<noteq> t \\<and>\n  (0::'a) < excess f u \\<and>\n  (\\<forall>v. (u, v) \\<in> cf.E \\<longrightarrow> l u \\<noteq> l v + 1)\n\ngoal (1 subgoal):\n 1. u \\<in> {v \\<in> V. (0::'a) < excess f v} &&& u \\<in> V", "using excess_nodes_only"], ["proof (prove)\nusing this:\n  u \\<noteq> t \\<and>\n  (0::'a) < excess f u \\<and>\n  (\\<forall>v. (u, v) \\<in> cf.E \\<longrightarrow> l u \\<noteq> l v + 1)\n  (0::'a) < excess f ?v \\<Longrightarrow> ?v \\<in> V\n\ngoal (1 subgoal):\n 1. u \\<in> {v \\<in> V. (0::'a) < excess f v} &&& u \\<in> V", "by auto"], ["proof (state)\nthis:\n  u \\<in> {v \\<in> V. (0::'a) < excess f v}\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. nonsat_potential f (relabel_effect f l u)\n    \\<le> nonsat_potential f l + 2 * card V", "have \"nonsat_potential f ?l' \n      = sum ?l' ({v \\<in> V. 0 < excess f v} - {u}) + ?l' u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonsat_potential f (relabel_effect f l u) =\n    sum (relabel_effect f l u) ({v \\<in> V. (0::'a) < excess f v} - {u}) +\n    relabel_effect f l u u", "unfolding nonsat_potential_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (relabel_effect f l u) {v \\<in> V. (0::'a) < excess f v} =\n    sum (relabel_effect f l u) ({v \\<in> V. (0::'a) < excess f v} - {u}) +\n    relabel_effect f l u u", "using U_ACTIVE"], ["proof (prove)\nusing this:\n  u \\<in> {v \\<in> V. (0::'a) < excess f v}\n\ngoal (1 subgoal):\n 1. sum (relabel_effect f l u) {v \\<in> V. (0::'a) < excess f v} =\n    sum (relabel_effect f l u) ({v \\<in> V. (0::'a) < excess f v} - {u}) +\n    relabel_effect f l u u", "by (auto intro: sum_arb)"], ["proof (state)\nthis:\n  nonsat_potential f (relabel_effect f l u) =\n  sum (relabel_effect f l u) ({v \\<in> V. (0::'a) < excess f v} - {u}) +\n  relabel_effect f l u u\n\ngoal (1 subgoal):\n 1. nonsat_potential f (relabel_effect f l u)\n    \\<le> nonsat_potential f l + 2 * card V", "also"], ["proof (state)\nthis:\n  nonsat_potential f (relabel_effect f l u) =\n  sum (relabel_effect f l u) ({v \\<in> V. (0::'a) < excess f v} - {u}) +\n  relabel_effect f l u u\n\ngoal (1 subgoal):\n 1. nonsat_potential f (relabel_effect f l u)\n    \\<le> nonsat_potential f l + 2 * card V", "have \"sum ?l' ({v \\<in> V. 0 < excess f v} - {u}) \n      = sum l ({v \\<in> V. 0 < excess f v} - {u})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (relabel_effect f l u) ({v \\<in> V. (0::'a) < excess f v} - {u}) =\n    sum l ({v \\<in> V. (0::'a) < excess f v} - {u})", "using relabel_preserve_other"], ["proof (prove)\nusing this:\n  ?u \\<noteq> ?v \\<Longrightarrow> relabel_effect f l ?u ?v = l ?v\n\ngoal (1 subgoal):\n 1. sum (relabel_effect f l u) ({v \\<in> V. (0::'a) < excess f v} - {u}) =\n    sum l ({v \\<in> V. (0::'a) < excess f v} - {u})", "by auto"], ["proof (state)\nthis:\n  sum (relabel_effect f l u) ({v \\<in> V. (0::'a) < excess f v} - {u}) =\n  sum l ({v \\<in> V. (0::'a) < excess f v} - {u})\n\ngoal (1 subgoal):\n 1. nonsat_potential f (relabel_effect f l u)\n    \\<le> nonsat_potential f l + 2 * card V", "also"], ["proof (state)\nthis:\n  sum (relabel_effect f l u) ({v \\<in> V. (0::'a) < excess f v} - {u}) =\n  sum l ({v \\<in> V. (0::'a) < excess f v} - {u})\n\ngoal (1 subgoal):\n 1. nonsat_potential f (relabel_effect f l u)\n    \\<le> nonsat_potential f l + 2 * card V", "have \"?l' u \\<le> l u + 2*card V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. relabel_effect f l u u \\<le> l u + 2 * card V", "using l'.height_bound'[OF \\<open>u\\<in>V\\<close>]"], ["proof (prove)\nusing this:\n  relabel_effect f l u u \\<le> 2 * card V - 1\n\ngoal (1 subgoal):\n 1. relabel_effect f l u u \\<le> l u + 2 * card V", "by auto"], ["proof (state)\nthis:\n  relabel_effect f l u u \\<le> l u + 2 * card V\n\ngoal (1 subgoal):\n 1. nonsat_potential f (relabel_effect f l u)\n    \\<le> nonsat_potential f l + 2 * card V", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      sum l ({v \\<in> V. (0::'a) < excess f v} - {u}) + x\n      \\<le> sum l ({v \\<in> V. (0::'a) < excess f v} - {u}) +\n            y) \\<Longrightarrow>\n  nonsat_potential f (relabel_effect f l u)\n  \\<le> sum l ({v \\<in> V. (0::'a) < excess f v} - {u}) + (l u + 2 * card V)", "have \"nonsat_potential f ?l' \n              \\<le> sum l ({v \\<in> V. 0 < excess f v} - {u}) + l u + 2 * card V\""], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      sum l ({v \\<in> V. (0::'a) < excess f v} - {u}) + x\n      \\<le> sum l ({v \\<in> V. (0::'a) < excess f v} - {u}) +\n            y) \\<Longrightarrow>\n  nonsat_potential f (relabel_effect f l u)\n  \\<le> sum l ({v \\<in> V. (0::'a) < excess f v} - {u}) + (l u + 2 * card V)\n\ngoal (1 subgoal):\n 1. nonsat_potential f (relabel_effect f l u)\n    \\<le> sum l ({v \\<in> V. (0::'a) < excess f v} - {u}) + l u + 2 * card V", "by auto"], ["proof (state)\nthis:\n  nonsat_potential f (relabel_effect f l u)\n  \\<le> sum l ({v \\<in> V. (0::'a) < excess f v} - {u}) + l u + 2 * card V\n\ngoal (1 subgoal):\n 1. nonsat_potential f (relabel_effect f l u)\n    \\<le> nonsat_potential f l + 2 * card V", "also"], ["proof (state)\nthis:\n  nonsat_potential f (relabel_effect f l u)\n  \\<le> sum l ({v \\<in> V. (0::'a) < excess f v} - {u}) + l u + 2 * card V\n\ngoal (1 subgoal):\n 1. nonsat_potential f (relabel_effect f l u)\n    \\<le> nonsat_potential f l + 2 * card V", "have \"sum l ({v \\<in> V. 0 < excess f v} - {u}) + l u \n           = nonsat_potential f l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum l ({v \\<in> V. (0::'a) < excess f v} - {u}) + l u =\n    nonsat_potential f l", "unfolding nonsat_potential_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum l ({v \\<in> V. (0::'a) < excess f v} - {u}) + l u =\n    sum l {v \\<in> V. (0::'a) < excess f v}", "using U_ACTIVE"], ["proof (prove)\nusing this:\n  u \\<in> {v \\<in> V. (0::'a) < excess f v}\n\ngoal (1 subgoal):\n 1. sum l ({v \\<in> V. (0::'a) < excess f v} - {u}) + l u =\n    sum l {v \\<in> V. (0::'a) < excess f v}", "by (auto intro: sum_arb[symmetric])"], ["proof (state)\nthis:\n  sum l ({v \\<in> V. (0::'a) < excess f v} - {u}) + l u =\n  nonsat_potential f l\n\ngoal (1 subgoal):\n 1. nonsat_potential f (relabel_effect f l u)\n    \\<le> nonsat_potential f l + 2 * card V", "finally"], ["proof (chain)\npicking this:\n  nonsat_potential f (relabel_effect f l u)\n  \\<le> nonsat_potential f l + 2 * card V", "show ?thesis"], ["proof (prove)\nusing this:\n  nonsat_potential f (relabel_effect f l u)\n  \\<le> nonsat_potential f l + 2 * card V\n\ngoal (1 subgoal):\n 1. nonsat_potential f (relabel_effect f l u)\n    \\<le> nonsat_potential f l + 2 * card V", "."], ["proof (state)\nthis:\n  nonsat_potential f (relabel_effect f l u)\n  \\<le> nonsat_potential f l + 2 * card V\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>Height Bounded Labeling\\<close>"], ["", "context Network \nbegin"], ["", "lemma nonsat_push_action_bound':\n  assumes A: \"((f,l),p,(f',l')) \\<in> trcl pr_algo_lts'\"\n  shows \"length (filter is_NONSAT_PUSH' p) \\<le> 18 * (card V)\\<^sup>2 * card E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter is_NONSAT_PUSH' p) \\<le> 18 * (card V)\\<^sup>2 * card E", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (filter is_NONSAT_PUSH' p) \\<le> 18 * (card V)\\<^sup>2 * card E", "have B1: \"length (filter is_NONSAT_PUSH' p) \n    \\<le>   nonsat_potential f l \n      + 2 * card V * (length (filter is_SAT_PUSH' p))\n      + 2 * card V * (length (filter is_RELABEL' p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter is_NONSAT_PUSH' p)\n    \\<le> nonsat_potential f l +\n          2 * card V * length (filter is_SAT_PUSH' p) +\n          2 * card V * length (filter is_RELABEL' p)", "using A"], ["proof (prove)\nusing this:\n  ((f, l), p, f', l') \\<in> trcl pr_algo_lts'\n\ngoal (1 subgoal):\n 1. length (filter is_NONSAT_PUSH' p)\n    \\<le> nonsat_potential f l +\n          2 * card V * length (filter is_SAT_PUSH' p) +\n          2 * card V * length (filter is_RELABEL' p)", "proof (induction p arbitrary: f l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f l.\n       ((f, l), [], f', l') \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n       length (filter is_NONSAT_PUSH' [])\n       \\<le> nonsat_potential f l +\n             2 * card V * length (filter is_SAT_PUSH' []) +\n             2 * card V * length (filter is_RELABEL' [])\n 2. \\<And>a p f l.\n       \\<lbrakk>\\<And>f l.\n                   ((f, l), p, f', l')\n                   \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n                   length (filter is_NONSAT_PUSH' p)\n                   \\<le> nonsat_potential f l +\n                         2 * card V * length (filter is_SAT_PUSH' p) +\n                         2 * card V * length (filter is_RELABEL' p);\n        ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'\\<rbrakk>\n       \\<Longrightarrow> length (filter is_NONSAT_PUSH' (a # p))\n                         \\<le> nonsat_potential f l +\n                               2 * card V *\n                               length (filter is_SAT_PUSH' (a # p)) +\n                               2 * card V *\n                               length (filter is_RELABEL' (a # p))", "case Nil"], ["proof (state)\nthis:\n  ((f, l), [], f', l') \\<in> trcl pr_algo_lts'\n\ngoal (2 subgoals):\n 1. \\<And>f l.\n       ((f, l), [], f', l') \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n       length (filter is_NONSAT_PUSH' [])\n       \\<le> nonsat_potential f l +\n             2 * card V * length (filter is_SAT_PUSH' []) +\n             2 * card V * length (filter is_RELABEL' [])\n 2. \\<And>a p f l.\n       \\<lbrakk>\\<And>f l.\n                   ((f, l), p, f', l')\n                   \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n                   length (filter is_NONSAT_PUSH' p)\n                   \\<le> nonsat_potential f l +\n                         2 * card V * length (filter is_SAT_PUSH' p) +\n                         2 * card V * length (filter is_RELABEL' p);\n        ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'\\<rbrakk>\n       \\<Longrightarrow> length (filter is_NONSAT_PUSH' (a # p))\n                         \\<le> nonsat_potential f l +\n                               2 * card V *\n                               length (filter is_SAT_PUSH' (a # p)) +\n                               2 * card V *\n                               length (filter is_RELABEL' (a # p))", "thus ?case"], ["proof (prove)\nusing this:\n  ((f, l), [], f', l') \\<in> trcl pr_algo_lts'\n\ngoal (1 subgoal):\n 1. length (filter is_NONSAT_PUSH' [])\n    \\<le> nonsat_potential f l +\n          2 * card V * length (filter is_SAT_PUSH' []) +\n          2 * card V * length (filter is_RELABEL' [])", "by auto"], ["proof (state)\nthis:\n  length (filter is_NONSAT_PUSH' [])\n  \\<le> nonsat_potential f l +\n        2 * card V * length (filter is_SAT_PUSH' []) +\n        2 * card V * length (filter is_RELABEL' [])\n\ngoal (1 subgoal):\n 1. \\<And>a p f l.\n       \\<lbrakk>\\<And>f l.\n                   ((f, l), p, f', l')\n                   \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n                   length (filter is_NONSAT_PUSH' p)\n                   \\<le> nonsat_potential f l +\n                         2 * card V * length (filter is_SAT_PUSH' p) +\n                         2 * card V * length (filter is_RELABEL' p);\n        ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'\\<rbrakk>\n       \\<Longrightarrow> length (filter is_NONSAT_PUSH' (a # p))\n                         \\<le> nonsat_potential f l +\n                               2 * card V *\n                               length (filter is_SAT_PUSH' (a # p)) +\n                               2 * card V *\n                               length (filter is_RELABEL' (a # p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p f l.\n       \\<lbrakk>\\<And>f l.\n                   ((f, l), p, f', l')\n                   \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n                   length (filter is_NONSAT_PUSH' p)\n                   \\<le> nonsat_potential f l +\n                         2 * card V * length (filter is_SAT_PUSH' p) +\n                         2 * card V * length (filter is_RELABEL' p);\n        ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'\\<rbrakk>\n       \\<Longrightarrow> length (filter is_NONSAT_PUSH' (a # p))\n                         \\<le> nonsat_potential f l +\n                               2 * card V *\n                               length (filter is_SAT_PUSH' (a # p)) +\n                               2 * card V *\n                               length (filter is_RELABEL' (a # p))", "case [simp]: (Cons a p)"], ["proof (state)\nthis:\n  ((?f1, ?l1), p, f', l') \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n  length (filter is_NONSAT_PUSH' p)\n  \\<le> nonsat_potential ?f1 ?l1 +\n        2 * card V * length (filter is_SAT_PUSH' p) +\n        2 * card V * length (filter is_RELABEL' p)\n  ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'\n\ngoal (1 subgoal):\n 1. \\<And>a p f l.\n       \\<lbrakk>\\<And>f l.\n                   ((f, l), p, f', l')\n                   \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n                   length (filter is_NONSAT_PUSH' p)\n                   \\<le> nonsat_potential f l +\n                         2 * card V * length (filter is_SAT_PUSH' p) +\n                         2 * card V * length (filter is_RELABEL' p);\n        ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'\\<rbrakk>\n       \\<Longrightarrow> length (filter is_NONSAT_PUSH' (a # p))\n                         \\<le> nonsat_potential f l +\n                               2 * card V *\n                               length (filter is_SAT_PUSH' (a # p)) +\n                               2 * card V *\n                               length (filter is_RELABEL' (a # p))", "then"], ["proof (chain)\npicking this:\n  ((?f1, ?l1), p, f', l') \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n  length (filter is_NONSAT_PUSH' p)\n  \\<le> nonsat_potential ?f1 ?l1 +\n        2 * card V * length (filter is_SAT_PUSH' p) +\n        2 * card V * length (filter is_RELABEL' p)\n  ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'", "obtain fh lh \n      where FIRST: \"((f,l),a,(fh,lh))\\<in>pr_algo_lts'\" \n          and PP: \"((fh,lh),p,(f',l')) \\<in> trcl pr_algo_lts'\""], ["proof (prove)\nusing this:\n  ((?f1, ?l1), p, f', l') \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n  length (filter is_NONSAT_PUSH' p)\n  \\<le> nonsat_potential ?f1 ?l1 +\n        2 * card V * length (filter is_SAT_PUSH' p) +\n        2 * card V * length (filter is_RELABEL' p)\n  ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'\n\ngoal (1 subgoal):\n 1. (\\<And>fh lh.\n        \\<lbrakk>((f, l), a, fh, lh) \\<in> pr_algo_lts';\n         ((fh, lh), p, f', l') \\<in> trcl pr_algo_lts'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: trcl_conv)"], ["proof (state)\nthis:\n  ((f, l), a, fh, lh) \\<in> pr_algo_lts'\n  ((fh, lh), p, f', l') \\<in> trcl pr_algo_lts'\n\ngoal (1 subgoal):\n 1. \\<And>a p f l.\n       \\<lbrakk>\\<And>f l.\n                   ((f, l), p, f', l')\n                   \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n                   length (filter is_NONSAT_PUSH' p)\n                   \\<le> nonsat_potential f l +\n                         2 * card V * length (filter is_SAT_PUSH' p) +\n                         2 * card V * length (filter is_RELABEL' p);\n        ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'\\<rbrakk>\n       \\<Longrightarrow> length (filter is_NONSAT_PUSH' (a # p))\n                         \\<le> nonsat_potential f l +\n                               2 * card V *\n                               length (filter is_SAT_PUSH' (a # p)) +\n                               2 * card V *\n                               length (filter is_RELABEL' (a # p))", "note IH = Cons.IH[OF PP]"], ["proof (state)\nthis:\n  length (filter is_NONSAT_PUSH' p)\n  \\<le> nonsat_potential fh lh +\n        2 * card V * length (filter is_SAT_PUSH' p) +\n        2 * card V * length (filter is_RELABEL' p)\n\ngoal (1 subgoal):\n 1. \\<And>a p f l.\n       \\<lbrakk>\\<And>f l.\n                   ((f, l), p, f', l')\n                   \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n                   length (filter is_NONSAT_PUSH' p)\n                   \\<le> nonsat_potential f l +\n                         2 * card V * length (filter is_SAT_PUSH' p) +\n                         2 * card V * length (filter is_RELABEL' p);\n        ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'\\<rbrakk>\n       \\<Longrightarrow> length (filter is_NONSAT_PUSH' (a # p))\n                         \\<le> nonsat_potential f l +\n                               2 * card V *\n                               length (filter is_SAT_PUSH' (a # p)) +\n                               2 * card V *\n                               length (filter is_RELABEL' (a # p))", "from FIRST"], ["proof (chain)\npicking this:\n  ((f, l), a, fh, lh) \\<in> pr_algo_lts'", "interpret Height_Bounded_Labeling c s t f l"], ["proof (prove)\nusing this:\n  ((f, l), a, fh, lh) \\<in> pr_algo_lts'\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f l", "by cases auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p f l.\n       \\<lbrakk>\\<And>f l.\n                   ((f, l), p, f', l')\n                   \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n                   length (filter is_NONSAT_PUSH' p)\n                   \\<le> nonsat_potential f l +\n                         2 * card V * length (filter is_SAT_PUSH' p) +\n                         2 * card V * length (filter is_RELABEL' p);\n        ((f, l), a # p, f', l') \\<in> trcl pr_algo_lts'\\<rbrakk>\n       \\<Longrightarrow> length (filter is_NONSAT_PUSH' (a # p))\n                         \\<le> nonsat_potential f l +\n                               2 * card V *\n                               length (filter is_SAT_PUSH' (a # p)) +\n                               2 * card V *\n                               length (filter is_RELABEL' (a # p))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter is_NONSAT_PUSH' (a # p))\n    \\<le> nonsat_potential f l +\n          2 * card V * length (filter is_SAT_PUSH' (a # p)) +\n          2 * card V * length (filter is_RELABEL' (a # p))", "using FIRST IH"], ["proof (prove)\nusing this:\n  ((f, l), a, fh, lh) \\<in> pr_algo_lts'\n  length (filter is_NONSAT_PUSH' p)\n  \\<le> nonsat_potential fh lh +\n        2 * card V * length (filter is_SAT_PUSH' p) +\n        2 * card V * length (filter is_RELABEL' p)\n\ngoal (1 subgoal):\n 1. length (filter is_NONSAT_PUSH' (a # p))\n    \\<le> nonsat_potential f l +\n          2 * card V * length (filter is_SAT_PUSH' (a # p)) +\n          2 * card V * length (filter is_RELABEL' (a # p))", "apply (cases a)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>((f, l), a, fh, lh) \\<in> pr_algo_lts';\n     length (filter is_NONSAT_PUSH' p)\n     \\<le> nonsat_potential fh lh +\n           2 * card V * length (filter is_SAT_PUSH' p) +\n           2 * card V * length (filter is_RELABEL' p);\n     a = RELABEL'\\<rbrakk>\n    \\<Longrightarrow> length (filter is_NONSAT_PUSH' (a # p))\n                      \\<le> nonsat_potential f l +\n                            2 * card V *\n                            length (filter is_SAT_PUSH' (a # p)) +\n                            2 * card V * length (filter is_RELABEL' (a # p))\n 2. \\<lbrakk>((f, l), a, fh, lh) \\<in> pr_algo_lts';\n     length (filter is_NONSAT_PUSH' p)\n     \\<le> nonsat_potential fh lh +\n           2 * card V * length (filter is_SAT_PUSH' p) +\n           2 * card V * length (filter is_RELABEL' p);\n     a = NONSAT_PUSH'\\<rbrakk>\n    \\<Longrightarrow> length (filter is_NONSAT_PUSH' (a # p))\n                      \\<le> nonsat_potential f l +\n                            2 * card V *\n                            length (filter is_SAT_PUSH' (a # p)) +\n                            2 * card V * length (filter is_RELABEL' (a # p))\n 3. \\<And>x3.\n       \\<lbrakk>((f, l), a, fh, lh) \\<in> pr_algo_lts';\n        length (filter is_NONSAT_PUSH' p)\n        \\<le> nonsat_potential fh lh +\n              2 * card V * length (filter is_SAT_PUSH' p) +\n              2 * card V * length (filter is_RELABEL' p);\n        a = SAT_PUSH' x3\\<rbrakk>\n       \\<Longrightarrow> length (filter is_NONSAT_PUSH' (a # p))\n                         \\<le> nonsat_potential f l +\n                               2 * card V *\n                               length (filter is_SAT_PUSH' (a # p)) +\n                               2 * card V *\n                               length (filter is_RELABEL' (a # p))", "apply (auto \n          elim!: pr_algo_lts'.cases \n          dest!: relabel_nonsat_potential nonsat_push_decr_nonsat_potential \n          dest!: sat_push_nonsat_potential\n      )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  length (filter is_NONSAT_PUSH' (a # p))\n  \\<le> nonsat_potential f l +\n        2 * card V * length (filter is_SAT_PUSH' (a # p)) +\n        2 * card V * length (filter is_RELABEL' (a # p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (filter is_NONSAT_PUSH' p)\n  \\<le> nonsat_potential f l + 2 * card V * length (filter is_SAT_PUSH' p) +\n        2 * card V * length (filter is_RELABEL' p)\n\ngoal (1 subgoal):\n 1. length (filter is_NONSAT_PUSH' p) \\<le> 18 * (card V)\\<^sup>2 * card E", "(* TODO: Technical case distinction, as we do not assume invariant on f,l! *)"], ["proof (state)\nthis:\n  length (filter is_NONSAT_PUSH' p)\n  \\<le> nonsat_potential f l + 2 * card V * length (filter is_SAT_PUSH' p) +\n        2 * card V * length (filter is_RELABEL' p)\n\ngoal (1 subgoal):\n 1. length (filter is_NONSAT_PUSH' p) \\<le> 18 * (card V)\\<^sup>2 * card E", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter is_NONSAT_PUSH' p) \\<le> 18 * (card V)\\<^sup>2 * card E", "proof (cases p)"], ["proof (state)\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    length (filter is_NONSAT_PUSH' p) \\<le> 18 * (card V)\\<^sup>2 * card E\n 2. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       length (filter is_NONSAT_PUSH' p)\n       \\<le> 18 * (card V)\\<^sup>2 * card E", "case Nil"], ["proof (state)\nthis:\n  p = []\n\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    length (filter is_NONSAT_PUSH' p) \\<le> 18 * (card V)\\<^sup>2 * card E\n 2. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       length (filter is_NONSAT_PUSH' p)\n       \\<le> 18 * (card V)\\<^sup>2 * card E", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = []\n\ngoal (1 subgoal):\n 1. length (filter is_NONSAT_PUSH' p) \\<le> 18 * (card V)\\<^sup>2 * card E", "by simp"], ["proof (state)\nthis:\n  length (filter is_NONSAT_PUSH' p) \\<le> 18 * (card V)\\<^sup>2 * card E\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       length (filter is_NONSAT_PUSH' p)\n       \\<le> 18 * (card V)\\<^sup>2 * card E", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       length (filter is_NONSAT_PUSH' p)\n       \\<le> 18 * (card V)\\<^sup>2 * card E", "case (Cons a' p')"], ["proof (state)\nthis:\n  p = a' # p'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       length (filter is_NONSAT_PUSH' p)\n       \\<le> 18 * (card V)\\<^sup>2 * card E", "then"], ["proof (chain)\npicking this:\n  p = a' # p'", "interpret Height_Bounded_Labeling c s t f l"], ["proof (prove)\nusing this:\n  p = a' # p'\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f l", "using A"], ["proof (prove)\nusing this:\n  p = a' # p'\n  ((f, l), p, f', l') \\<in> trcl pr_algo_lts'\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f l", "by (auto simp: trcl_conv elim!: pr_algo_lts'.cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       length (filter is_NONSAT_PUSH' p)\n       \\<le> 18 * (card V)\\<^sup>2 * card E", "note B1"], ["proof (state)\nthis:\n  length (filter is_NONSAT_PUSH' p)\n  \\<le> nonsat_potential f l + 2 * card V * length (filter is_SAT_PUSH' p) +\n        2 * card V * length (filter is_RELABEL' p)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       length (filter is_NONSAT_PUSH' p)\n       \\<le> 18 * (card V)\\<^sup>2 * card E", "also"], ["proof (state)\nthis:\n  length (filter is_NONSAT_PUSH' p)\n  \\<le> nonsat_potential f l + 2 * card V * length (filter is_SAT_PUSH' p) +\n        2 * card V * length (filter is_RELABEL' p)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       length (filter is_NONSAT_PUSH' p)\n       \\<le> 18 * (card V)\\<^sup>2 * card E", "note nonsat_potential_bound"], ["proof (state)\nthis:\n  nonsat_potential f l \\<le> 2 * (card V)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       length (filter is_NONSAT_PUSH' p)\n       \\<le> 18 * (card V)\\<^sup>2 * card E", "also"], ["proof (state)\nthis:\n  nonsat_potential f l \\<le> 2 * (card V)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       length (filter is_NONSAT_PUSH' p)\n       \\<le> 18 * (card V)\\<^sup>2 * card E", "note sat_push_action_bound'[OF A]"], ["proof (state)\nthis:\n  length (filter is_SAT_PUSH' p) \\<le> 4 * card V * card E\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       length (filter is_NONSAT_PUSH' p)\n       \\<le> 18 * (card V)\\<^sup>2 * card E", "also"], ["proof (state)\nthis:\n  length (filter is_SAT_PUSH' p) \\<le> 4 * card V * card E\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       length (filter is_NONSAT_PUSH' p)\n       \\<le> 18 * (card V)\\<^sup>2 * card E", "note relabel_action_bound'[OF A]"], ["proof (state)\nthis:\n  length (filter is_RELABEL' p) \\<le> 2 * (card V)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       length (filter is_NONSAT_PUSH' p)\n       \\<le> 18 * (card V)\\<^sup>2 * card E", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + 2 * card V * length (filter is_SAT_PUSH' p) +\n              2 * card V * length (filter is_RELABEL' p)\n              \\<le> y + 2 * card V * length (filter is_SAT_PUSH' p) +\n                    2 * card V * length (filter is_RELABEL' p);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      2 * (card V)\\<^sup>2 + 2 * card V * x +\n      2 * card V * length (filter is_RELABEL' p)\n      \\<le> 2 * (card V)\\<^sup>2 + 2 * card V * y +\n            2 * card V * length (filter is_RELABEL' p);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      2 * (card V)\\<^sup>2 + 2 * card V * (4 * card V * card E) +\n      2 * card V * x\n      \\<le> 2 * (card V)\\<^sup>2 + 2 * card V * (4 * card V * card E) +\n            2 * card V * y\\<rbrakk>\n  \\<Longrightarrow> length (filter is_NONSAT_PUSH' p)\n                    \\<le> 2 * (card V)\\<^sup>2 +\n                          2 * card V * (4 * card V * card E) +\n                          2 * card V * (2 * (card V)\\<^sup>2)", "have \"length (filter is_NONSAT_PUSH' p)\n      \\<le> 2 * (card V)\\<^sup>2 + 8 * (card V)\\<^sup>2 * card E + 4 * (card V)^3\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + 2 * card V * length (filter is_SAT_PUSH' p) +\n              2 * card V * length (filter is_RELABEL' p)\n              \\<le> y + 2 * card V * length (filter is_SAT_PUSH' p) +\n                    2 * card V * length (filter is_RELABEL' p);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      2 * (card V)\\<^sup>2 + 2 * card V * x +\n      2 * card V * length (filter is_RELABEL' p)\n      \\<le> 2 * (card V)\\<^sup>2 + 2 * card V * y +\n            2 * card V * length (filter is_RELABEL' p);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      2 * (card V)\\<^sup>2 + 2 * card V * (4 * card V * card E) +\n      2 * card V * x\n      \\<le> 2 * (card V)\\<^sup>2 + 2 * card V * (4 * card V * card E) +\n            2 * card V * y\\<rbrakk>\n  \\<Longrightarrow> length (filter is_NONSAT_PUSH' p)\n                    \\<le> 2 * (card V)\\<^sup>2 +\n                          2 * card V * (4 * card V * card E) +\n                          2 * card V * (2 * (card V)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. length (filter is_NONSAT_PUSH' p)\n    \\<le> 2 * (card V)\\<^sup>2 + 8 * (card V)\\<^sup>2 * card E +\n          4 * card V ^ 3", "by (simp add: power2_eq_square power3_eq_cube)"], ["proof (state)\nthis:\n  length (filter is_NONSAT_PUSH' p)\n  \\<le> 2 * (card V)\\<^sup>2 + 8 * (card V)\\<^sup>2 * card E +\n        4 * card V ^ 3\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       length (filter is_NONSAT_PUSH' p)\n       \\<le> 18 * (card V)\\<^sup>2 * card E", "also"], ["proof (state)\nthis:\n  length (filter is_NONSAT_PUSH' p)\n  \\<le> 2 * (card V)\\<^sup>2 + 8 * (card V)\\<^sup>2 * card E +\n        4 * card V ^ 3\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       length (filter is_NONSAT_PUSH' p)\n       \\<le> 18 * (card V)\\<^sup>2 * card E", "have \"(card V)^3 \\<le> 2 * (card V)\\<^sup>2 * card E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card V ^ 3 \\<le> 2 * (card V)\\<^sup>2 * card E", "by (simp add: card_V_est_E power2_eq_square power3_eq_cube)"], ["proof (state)\nthis:\n  card V ^ 3 \\<le> 2 * (card V)\\<^sup>2 * card E\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       length (filter is_NONSAT_PUSH' p)\n       \\<le> 18 * (card V)\\<^sup>2 * card E", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      2 * (card V)\\<^sup>2 + 8 * (card V)\\<^sup>2 * card E + 4 * x\n      \\<le> 2 * (card V)\\<^sup>2 + 8 * (card V)\\<^sup>2 * card E +\n            4 * y) \\<Longrightarrow>\n  length (filter is_NONSAT_PUSH' p)\n  \\<le> 2 * (card V)\\<^sup>2 + 8 * (card V)\\<^sup>2 * card E +\n        4 * (2 * (card V)\\<^sup>2 * card E)", "have \"length (filter is_NONSAT_PUSH' p) \n      \\<le> 2 * (card V)\\<^sup>2 + 16 * (card V)\\<^sup>2 * card E\""], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      2 * (card V)\\<^sup>2 + 8 * (card V)\\<^sup>2 * card E + 4 * x\n      \\<le> 2 * (card V)\\<^sup>2 + 8 * (card V)\\<^sup>2 * card E +\n            4 * y) \\<Longrightarrow>\n  length (filter is_NONSAT_PUSH' p)\n  \\<le> 2 * (card V)\\<^sup>2 + 8 * (card V)\\<^sup>2 * card E +\n        4 * (2 * (card V)\\<^sup>2 * card E)\n\ngoal (1 subgoal):\n 1. length (filter is_NONSAT_PUSH' p)\n    \\<le> 2 * (card V)\\<^sup>2 + 16 * (card V)\\<^sup>2 * card E", "by linarith"], ["proof (state)\nthis:\n  length (filter is_NONSAT_PUSH' p)\n  \\<le> 2 * (card V)\\<^sup>2 + 16 * (card V)\\<^sup>2 * card E\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       length (filter is_NONSAT_PUSH' p)\n       \\<le> 18 * (card V)\\<^sup>2 * card E", "also"], ["proof (state)\nthis:\n  length (filter is_NONSAT_PUSH' p)\n  \\<le> 2 * (card V)\\<^sup>2 + 16 * (card V)\\<^sup>2 * card E\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       length (filter is_NONSAT_PUSH' p)\n       \\<le> 18 * (card V)\\<^sup>2 * card E", "have \"2 * (card V)\\<^sup>2 \\<le> 2*(card V)\\<^sup>2 * card E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (card V)\\<^sup>2 \\<le> 2 * (card V)\\<^sup>2 * card E", "by auto"], ["proof (state)\nthis:\n  2 * (card V)\\<^sup>2 \\<le> 2 * (card V)\\<^sup>2 * card E\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       p = a # list \\<Longrightarrow>\n       length (filter is_NONSAT_PUSH' p)\n       \\<le> 18 * (card V)\\<^sup>2 * card E", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + 16 * (card V)\\<^sup>2 * card E\n      \\<le> y + 16 * (card V)\\<^sup>2 * card E) \\<Longrightarrow>\n  length (filter is_NONSAT_PUSH' p)\n  \\<le> 2 * (card V)\\<^sup>2 * card E + 16 * (card V)\\<^sup>2 * card E", "show \"length (filter is_NONSAT_PUSH' p) \\<le> 18 * (card V)\\<^sup>2 * card E\""], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + 16 * (card V)\\<^sup>2 * card E\n      \\<le> y + 16 * (card V)\\<^sup>2 * card E) \\<Longrightarrow>\n  length (filter is_NONSAT_PUSH' p)\n  \\<le> 2 * (card V)\\<^sup>2 * card E + 16 * (card V)\\<^sup>2 * card E\n\ngoal (1 subgoal):\n 1. length (filter is_NONSAT_PUSH' p) \\<le> 18 * (card V)\\<^sup>2 * card E", "by linarith"], ["proof (state)\nthis:\n  length (filter is_NONSAT_PUSH' p) \\<le> 18 * (card V)\\<^sup>2 * card E\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (filter is_NONSAT_PUSH' p) \\<le> 18 * (card V)\\<^sup>2 * card E\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>Network\\<close>"], ["", "subsubsection \\<open>Assembling the Final Theorem\\<close>"], ["", "text \\<open>We combine the bounds for saturating and non-saturating push \n  operations.\\<close>"], ["", "lemma (in Height_Bounded_Labeling) push_action_bound:\n  assumes A: \"((f,l),p,(f',l')) \\<in> trcl pr_algo_lts\"\n  shows \"length (filter (is_PUSH) p) \\<le> 22 * (card V)\\<^sup>2 * card E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter is_PUSH p) \\<le> 22 * (card V)\\<^sup>2 * card E", "apply (rule order_trans[OF xfer_push_bounds[OF _ _ A]]; (intro allI impI)?)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>p'.\n       ((f, l), p', f', l') \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n       length (filter is_SAT_PUSH' p') \\<le> ?B1.2\n 2. \\<And>p'.\n       ((f, l), p', f', l') \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n       length (filter is_NONSAT_PUSH' p') \\<le> ?B2.2\n 3. ?B1.2 + ?B2.2 \\<le> 22 * (card V)\\<^sup>2 * card E", "apply (erule sat_push_action_bound'; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p'.\n       ((f, l), p', f', l') \\<in> trcl pr_algo_lts' \\<Longrightarrow>\n       length (filter is_NONSAT_PUSH' p') \\<le> ?B2.2\n 2. 4 * card V * card E + ?B2.2 \\<le> 22 * (card V)\\<^sup>2 * card E", "apply (erule nonsat_push_action_bound'; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * card V * card E + 18 * (card V)\\<^sup>2 * card E\n    \\<le> 22 * (card V)\\<^sup>2 * card E", "apply (auto simp: power2_eq_square)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>We estimate the cost of a push by \\<open>O(1)\\<close>, and of \n  a relabel operation by \\<open>O(V)\\<close>\\<close>"], ["", "fun (in Network) cost_estimate :: \"pr_operation \\<Rightarrow> nat\" where\n  \"cost_estimate RELABEL = card V\"\n| \"cost_estimate PUSH = 1\""], ["", "text \\<open>We show the complexity bound of \\<open>O(V\\<^sup>2E)\\<close> when starting from any valid\n  labeling \\cormen{26.24}.\\<close>"], ["", "theorem (in Height_Bounded_Labeling) pr_algo_cost_bound:  \n  assumes A: \"((f,l),p,(f',l')) \\<in> trcl pr_algo_lts\"\n  shows \"(\\<Sum>a\\<leftarrow>p. cost_estimate a) \\<le> 26 * (card V)^2 * card E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map cost_estimate p) \\<le> 26 * (card V)\\<^sup>2 * card E", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum_list (map cost_estimate p) \\<le> 26 * (card V)\\<^sup>2 * card E", "have \"(\\<Sum>a\\<leftarrow>p. cost_estimate a) \n    = card V * length (filter is_RELABEL p) + length (filter is_PUSH p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map cost_estimate p) =\n    card V * length (filter is_RELABEL p) + length (filter is_PUSH p)", "proof (induction p)"], ["proof (state)\ngoal (2 subgoals):\n 1. sum_list (map cost_estimate []) =\n    card V * length (filter is_RELABEL []) + length (filter is_PUSH [])\n 2. \\<And>a p.\n       sum_list (map cost_estimate p) =\n       card V * length (filter is_RELABEL p) +\n       length (filter is_PUSH p) \\<Longrightarrow>\n       sum_list (map cost_estimate (a # p)) =\n       card V * length (filter is_RELABEL (a # p)) +\n       length (filter is_PUSH (a # p))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. sum_list (map cost_estimate []) =\n    card V * length (filter is_RELABEL []) + length (filter is_PUSH [])\n 2. \\<And>a p.\n       sum_list (map cost_estimate p) =\n       card V * length (filter is_RELABEL p) +\n       length (filter is_PUSH p) \\<Longrightarrow>\n       sum_list (map cost_estimate (a # p)) =\n       card V * length (filter is_RELABEL (a # p)) +\n       length (filter is_PUSH (a # p))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map cost_estimate []) =\n    card V * length (filter is_RELABEL []) + length (filter is_PUSH [])", "by simp"], ["proof (state)\nthis:\n  sum_list (map cost_estimate []) =\n  card V * length (filter is_RELABEL []) + length (filter is_PUSH [])\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       sum_list (map cost_estimate p) =\n       card V * length (filter is_RELABEL p) +\n       length (filter is_PUSH p) \\<Longrightarrow>\n       sum_list (map cost_estimate (a # p)) =\n       card V * length (filter is_RELABEL (a # p)) +\n       length (filter is_PUSH (a # p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       sum_list (map cost_estimate p) =\n       card V * length (filter is_RELABEL p) +\n       length (filter is_PUSH p) \\<Longrightarrow>\n       sum_list (map cost_estimate (a # p)) =\n       card V * length (filter is_RELABEL (a # p)) +\n       length (filter is_PUSH (a # p))", "case (Cons a p)"], ["proof (state)\nthis:\n  sum_list (map cost_estimate p) =\n  card V * length (filter is_RELABEL p) + length (filter is_PUSH p)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       sum_list (map cost_estimate p) =\n       card V * length (filter is_RELABEL p) +\n       length (filter is_PUSH p) \\<Longrightarrow>\n       sum_list (map cost_estimate (a # p)) =\n       card V * length (filter is_RELABEL (a # p)) +\n       length (filter is_PUSH (a # p))", "then"], ["proof (chain)\npicking this:\n  sum_list (map cost_estimate p) =\n  card V * length (filter is_RELABEL p) + length (filter is_PUSH p)", "show ?case"], ["proof (prove)\nusing this:\n  sum_list (map cost_estimate p) =\n  card V * length (filter is_RELABEL p) + length (filter is_PUSH p)\n\ngoal (1 subgoal):\n 1. sum_list (map cost_estimate (a # p)) =\n    card V * length (filter is_RELABEL (a # p)) +\n    length (filter is_PUSH (a # p))", "by (cases a) auto"], ["proof (state)\nthis:\n  sum_list (map cost_estimate (a # p)) =\n  card V * length (filter is_RELABEL (a # p)) +\n  length (filter is_PUSH (a # p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list (map cost_estimate p) =\n  card V * length (filter is_RELABEL p) + length (filter is_PUSH p)\n\ngoal (1 subgoal):\n 1. sum_list (map cost_estimate p) \\<le> 26 * (card V)\\<^sup>2 * card E", "also"], ["proof (state)\nthis:\n  sum_list (map cost_estimate p) =\n  card V * length (filter is_RELABEL p) + length (filter is_PUSH p)\n\ngoal (1 subgoal):\n 1. sum_list (map cost_estimate p) \\<le> 26 * (card V)\\<^sup>2 * card E", "have \"card V * length (filter is_RELABEL p) \\<le> 2 * (card V)^3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card V * length (filter is_RELABEL p) \\<le> 2 * card V ^ 3", "using relabel_action_bound[OF A]"], ["proof (prove)\nusing this:\n  length (filter is_RELABEL p) \\<le> 2 * (card V)\\<^sup>2\n\ngoal (1 subgoal):\n 1. card V * length (filter is_RELABEL p) \\<le> 2 * card V ^ 3", "by (auto simp: power2_eq_square power3_eq_cube)"], ["proof (state)\nthis:\n  card V * length (filter is_RELABEL p) \\<le> 2 * card V ^ 3\n\ngoal (1 subgoal):\n 1. sum_list (map cost_estimate p) \\<le> 26 * (card V)\\<^sup>2 * card E", "also"], ["proof (state)\nthis:\n  card V * length (filter is_RELABEL p) \\<le> 2 * card V ^ 3\n\ngoal (1 subgoal):\n 1. sum_list (map cost_estimate p) \\<le> 26 * (card V)\\<^sup>2 * card E", "note push_action_bound[OF A]"], ["proof (state)\nthis:\n  length (filter is_PUSH p) \\<le> 22 * (card V)\\<^sup>2 * card E\n\ngoal (1 subgoal):\n 1. sum_list (map cost_estimate p) \\<le> 26 * (card V)\\<^sup>2 * card E", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + length (filter is_PUSH p)\n              \\<le> y + length (filter is_PUSH p);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      2 * card V ^ 3 + x \\<le> 2 * card V ^ 3 + y\\<rbrakk>\n  \\<Longrightarrow> sum_list (map cost_estimate p)\n                    \\<le> 2 * card V ^ 3 + 22 * (card V)\\<^sup>2 * card E", "have \"sum_list (map cost_estimate p) \n              \\<le> 2 * card V ^ 3 + 22 * (card V)\\<^sup>2 * card E\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + length (filter is_PUSH p)\n              \\<le> y + length (filter is_PUSH p);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      2 * card V ^ 3 + x \\<le> 2 * card V ^ 3 + y\\<rbrakk>\n  \\<Longrightarrow> sum_list (map cost_estimate p)\n                    \\<le> 2 * card V ^ 3 + 22 * (card V)\\<^sup>2 * card E\n\ngoal (1 subgoal):\n 1. sum_list (map cost_estimate p)\n    \\<le> 2 * card V ^ 3 + 22 * (card V)\\<^sup>2 * card E", "by simp"], ["proof (state)\nthis:\n  sum_list (map cost_estimate p)\n  \\<le> 2 * card V ^ 3 + 22 * (card V)\\<^sup>2 * card E\n\ngoal (1 subgoal):\n 1. sum_list (map cost_estimate p) \\<le> 26 * (card V)\\<^sup>2 * card E", "also"], ["proof (state)\nthis:\n  sum_list (map cost_estimate p)\n  \\<le> 2 * card V ^ 3 + 22 * (card V)\\<^sup>2 * card E\n\ngoal (1 subgoal):\n 1. sum_list (map cost_estimate p) \\<le> 26 * (card V)\\<^sup>2 * card E", "have \"(card V)^3 \\<le> 2 * (card V)\\<^sup>2 * card E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card V ^ 3 \\<le> 2 * (card V)\\<^sup>2 * card E", "by (simp add: card_V_est_E power2_eq_square power3_eq_cube)"], ["proof (state)\nthis:\n  card V ^ 3 \\<le> 2 * (card V)\\<^sup>2 * card E\n\ngoal (1 subgoal):\n 1. sum_list (map cost_estimate p) \\<le> 26 * (card V)\\<^sup>2 * card E", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      2 * x + 22 * (card V)\\<^sup>2 * card E\n      \\<le> 2 * y + 22 * (card V)\\<^sup>2 * card E) \\<Longrightarrow>\n  sum_list (map cost_estimate p)\n  \\<le> 2 * (2 * (card V)\\<^sup>2 * card E) + 22 * (card V)\\<^sup>2 * card E", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      2 * x + 22 * (card V)\\<^sup>2 * card E\n      \\<le> 2 * y + 22 * (card V)\\<^sup>2 * card E) \\<Longrightarrow>\n  sum_list (map cost_estimate p)\n  \\<le> 2 * (2 * (card V)\\<^sup>2 * card E) + 22 * (card V)\\<^sup>2 * card E\n\ngoal (1 subgoal):\n 1. sum_list (map cost_estimate p) \\<le> 26 * (card V)\\<^sup>2 * card E", "by linarith"], ["proof (state)\nthis:\n  sum_list (map cost_estimate p) \\<le> 26 * (card V)\\<^sup>2 * card E\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Main Theorem: Correctness and Complexity\\<close>"], ["", "text \\<open>Finally, we state the main theorem of this section:\n  If the algorithm executes some steps from the beginning, then\n    \\<^enum> If no further steps are possible from the reached state, we have \n      computed a maximum flow~\\cormen{26.18}.\n    \\<^enum> The cost of these steps is bounded by \\<open>O(V\\<^sup>2E)\\<close>~\\cormen{26.24}. \n      Note that this also implies termination.\n\\<close>"], ["", "theorem (in Network) generic_preflow_push_OV2E_and_correct:\n  assumes A: \"((pp_init_f, pp_init_l), p, (f, l)) \\<in> trcl pr_algo_lts\" \n  shows \"(\\<Sum>x\\<leftarrow>p. cost_estimate x) \\<le> 26 * (card V)^2 * card E\" (is ?G1)\n    and \"(f,l)\\<notin>Domain pr_algo_lts \\<longrightarrow> isMaxFlow f\" (is ?G2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map cost_estimate p) \\<le> 26 * (card V)\\<^sup>2 * card E &&&\n    (f, l) \\<notin> Domain pr_algo_lts \\<longrightarrow> isMaxFlow f", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. sum_list (map cost_estimate p) \\<le> 26 * (card V)\\<^sup>2 * card E\n 2. (f, l) \\<notin> Domain pr_algo_lts \\<longrightarrow> isMaxFlow f", "show ?G1"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map cost_estimate p) \\<le> 26 * (card V)\\<^sup>2 * card E", "using pp_init_height_bound Height_Bounded_Labeling.pr_algo_cost_bound A"], ["proof (prove)\nusing this:\n  Height_Bounded_Labeling c s t pp_init_f pp_init_l\n  \\<lbrakk>Height_Bounded_Labeling ?c ?s ?t ?f ?l;\n   ((?f, ?l), ?p, ?f', ?l') \\<in> trcl (Network.pr_algo_lts ?c ?t)\\<rbrakk>\n  \\<Longrightarrow> sum_list (map (Network.cost_estimate ?c) ?p)\n                    \\<le> 26 * (card (Graph.V ?c))\\<^sup>2 *\n                          card (Graph.E ?c)\n  ((pp_init_f, pp_init_l), p, f, l) \\<in> trcl pr_algo_lts\n\ngoal (1 subgoal):\n 1. sum_list (map cost_estimate p) \\<le> 26 * (card V)\\<^sup>2 * card E", "by blast"], ["proof (state)\nthis:\n  sum_list (map cost_estimate p) \\<le> 26 * (card V)\\<^sup>2 * card E\n\ngoal (1 subgoal):\n 1. (f, l) \\<notin> Domain pr_algo_lts \\<longrightarrow> isMaxFlow f", "show ?G2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f, l) \\<notin> Domain pr_algo_lts \\<longrightarrow> isMaxFlow f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (f, l) \\<notin> Domain pr_algo_lts \\<longrightarrow> isMaxFlow f", "from A"], ["proof (chain)\npicking this:\n  ((pp_init_f, pp_init_l), p, f, l) \\<in> trcl pr_algo_lts", "interpret Height_Bounded_Labeling c s t f l"], ["proof (prove)\nusing this:\n  ((pp_init_f, pp_init_l), p, f, l) \\<in> trcl pr_algo_lts\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f l", "apply (induction p arbitrary: f l rule: rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f l.\n       ((pp_init_f, pp_init_l), [], f, l)\n       \\<in> trcl pr_algo_lts \\<Longrightarrow>\n       Height_Bounded_Labeling c s t f l\n 2. \\<And>x xs f l.\n       \\<lbrakk>\\<And>f l.\n                   ((pp_init_f, pp_init_l), xs, f, l)\n                   \\<in> trcl pr_algo_lts \\<Longrightarrow>\n                   Height_Bounded_Labeling c s t f l;\n        ((pp_init_f, pp_init_l), xs @ [x], f, l)\n        \\<in> trcl pr_algo_lts\\<rbrakk>\n       \\<Longrightarrow> Height_Bounded_Labeling c s t f l", "apply (auto \n        simp: pp_init_height_bound trcl_conv \n        intro: Height_Bounded_Labeling.pr_algo_maintains_hb_labeling)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\ngoal (1 subgoal):\n 1. (f, l) \\<notin> Domain pr_algo_lts \\<longrightarrow> isMaxFlow f", "from pr_algo_term_maxflow"], ["proof (chain)\npicking this:\n  (f, l) \\<notin> Domain pr_algo_lts \\<Longrightarrow> isMaxFlow f", "show ?G2"], ["proof (prove)\nusing this:\n  (f, l) \\<notin> Domain pr_algo_lts \\<Longrightarrow> isMaxFlow f\n\ngoal (1 subgoal):\n 1. (f, l) \\<notin> Domain pr_algo_lts \\<longrightarrow> isMaxFlow f", "by simp"], ["proof (state)\nthis:\n  (f, l) \\<notin> Domain pr_algo_lts \\<longrightarrow> isMaxFlow f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f, l) \\<notin> Domain pr_algo_lts \\<longrightarrow> isMaxFlow f\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Convenience Tools for Implementation\\<close>"], ["", "context Network\nbegin"], ["", "text \\<open>In order to show termination of the algorithm, \n  we only need a well-founded relation over push and relabel steps\\<close>"], ["", "inductive_set pr_algo_rel where\n  push: \"\\<lbrakk>Height_Bounded_Labeling c s t f l; push_precond f l e\\<rbrakk> \n    \\<Longrightarrow> ((push_effect f e,l),(f,l))\\<in>pr_algo_rel\"\n| relabel: \"\\<lbrakk>Height_Bounded_Labeling c s t f l; relabel_precond f l u\\<rbrakk>\n    \\<Longrightarrow> ((f,relabel_effect f l u),(f,l))\\<in>pr_algo_rel\""], ["", "lemma pr_algo_rel_alt: \"pr_algo_rel = \n    { ((push_effect f e,l),(f,l)) | f e l. \n        Height_Bounded_Labeling c s t f l \\<and> push_precond f l e }\n  \\<union> { ((f, relabel_effect f l u), (f,l)) | f u l. \n        Height_Bounded_Labeling c s t f l \\<and> relabel_precond f l u }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pr_algo_rel =\n    {((push_effect f e, l), f, l) |f e l.\n     Height_Bounded_Labeling c s t f l \\<and> push_precond f l e} \\<union>\n    {((f, relabel_effect f l u), f, l) |f u l.\n     Height_Bounded_Labeling c s t f l \\<and> relabel_precond f l u}", "by (auto elim!: pr_algo_rel.cases intro: pr_algo_rel.intros)"], ["", "definition \"pr_algo_len_bound \\<equiv> 2 * (card V)\\<^sup>2 + 22 * (card V)\\<^sup>2 * card E\""], ["", "lemma (in Height_Bounded_Labeling) pr_algo_lts_length_bound:  \n  assumes A: \"((f, l), p, (f', l')) \\<in> trcl pr_algo_lts\"\n  shows \"length p \\<le> pr_algo_len_bound\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length p \\<le> pr_algo_len_bound", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length p \\<le> pr_algo_len_bound", "have \"length p = length (filter is_PUSH p) + length (filter is_RELABEL p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length p = length (filter is_PUSH p) + length (filter is_RELABEL p)", "proof (induction p)"], ["proof (state)\ngoal (2 subgoals):\n 1. length [] = length (filter is_PUSH []) + length (filter is_RELABEL [])\n 2. \\<And>a p.\n       length p =\n       length (filter is_PUSH p) +\n       length (filter is_RELABEL p) \\<Longrightarrow>\n       length (a # p) =\n       length (filter is_PUSH (a # p)) + length (filter is_RELABEL (a # p))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. length [] = length (filter is_PUSH []) + length (filter is_RELABEL [])\n 2. \\<And>a p.\n       length p =\n       length (filter is_PUSH p) +\n       length (filter is_RELABEL p) \\<Longrightarrow>\n       length (a # p) =\n       length (filter is_PUSH (a # p)) + length (filter is_RELABEL (a # p))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length [] = length (filter is_PUSH []) + length (filter is_RELABEL [])", "by simp"], ["proof (state)\nthis:\n  length [] = length (filter is_PUSH []) + length (filter is_RELABEL [])\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       length p =\n       length (filter is_PUSH p) +\n       length (filter is_RELABEL p) \\<Longrightarrow>\n       length (a # p) =\n       length (filter is_PUSH (a # p)) + length (filter is_RELABEL (a # p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p.\n       length p =\n       length (filter is_PUSH p) +\n       length (filter is_RELABEL p) \\<Longrightarrow>\n       length (a # p) =\n       length (filter is_PUSH (a # p)) + length (filter is_RELABEL (a # p))", "case (Cons a p)"], ["proof (state)\nthis:\n  length p = length (filter is_PUSH p) + length (filter is_RELABEL p)\n\ngoal (1 subgoal):\n 1. \\<And>a p.\n       length p =\n       length (filter is_PUSH p) +\n       length (filter is_RELABEL p) \\<Longrightarrow>\n       length (a # p) =\n       length (filter is_PUSH (a # p)) + length (filter is_RELABEL (a # p))", "then"], ["proof (chain)\npicking this:\n  length p = length (filter is_PUSH p) + length (filter is_RELABEL p)", "show ?case"], ["proof (prove)\nusing this:\n  length p = length (filter is_PUSH p) + length (filter is_RELABEL p)\n\ngoal (1 subgoal):\n 1. length (a # p) =\n    length (filter is_PUSH (a # p)) + length (filter is_RELABEL (a # p))", "by (cases a) auto"], ["proof (state)\nthis:\n  length (a # p) =\n  length (filter is_PUSH (a # p)) + length (filter is_RELABEL (a # p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length p = length (filter is_PUSH p) + length (filter is_RELABEL p)\n\ngoal (1 subgoal):\n 1. length p \\<le> pr_algo_len_bound", "also"], ["proof (state)\nthis:\n  length p = length (filter is_PUSH p) + length (filter is_RELABEL p)\n\ngoal (1 subgoal):\n 1. length p \\<le> pr_algo_len_bound", "note push_action_bound[OF A]"], ["proof (state)\nthis:\n  length (filter is_PUSH p) \\<le> 22 * (card V)\\<^sup>2 * card E\n\ngoal (1 subgoal):\n 1. length p \\<le> pr_algo_len_bound", "also"], ["proof (state)\nthis:\n  length (filter is_PUSH p) \\<le> 22 * (card V)\\<^sup>2 * card E\n\ngoal (1 subgoal):\n 1. length p \\<le> pr_algo_len_bound", "note relabel_action_bound[OF A]"], ["proof (state)\nthis:\n  length (filter is_RELABEL p) \\<le> 2 * (card V)\\<^sup>2\n\ngoal (1 subgoal):\n 1. length p \\<le> pr_algo_len_bound", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + length (filter is_RELABEL p)\n              \\<le> y + length (filter is_RELABEL p);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      22 * (card V)\\<^sup>2 * card E + x\n      \\<le> 22 * (card V)\\<^sup>2 * card E + y\\<rbrakk>\n  \\<Longrightarrow> length p\n                    \\<le> 22 * (card V)\\<^sup>2 * card E +\n                          2 * (card V)\\<^sup>2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + length (filter is_RELABEL p)\n              \\<le> y + length (filter is_RELABEL p);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      22 * (card V)\\<^sup>2 * card E + x\n      \\<le> 22 * (card V)\\<^sup>2 * card E + y\\<rbrakk>\n  \\<Longrightarrow> length p\n                    \\<le> 22 * (card V)\\<^sup>2 * card E +\n                          2 * (card V)\\<^sup>2\n\ngoal (1 subgoal):\n 1. length p \\<le> pr_algo_len_bound", "unfolding pr_algo_len_bound_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              x + length (filter is_RELABEL p)\n              \\<le> y + length (filter is_RELABEL p);\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      22 * (card V)\\<^sup>2 * card E + x\n      \\<le> 22 * (card V)\\<^sup>2 * card E + y\\<rbrakk>\n  \\<Longrightarrow> length p\n                    \\<le> 22 * (card V)\\<^sup>2 * card E +\n                          2 * (card V)\\<^sup>2\n\ngoal (1 subgoal):\n 1. length p \\<le> 2 * (card V)\\<^sup>2 + 22 * (card V)\\<^sup>2 * card E", "by simp"], ["proof (state)\nthis:\n  length p \\<le> pr_algo_len_bound\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in Height_Bounded_Labeling) path_set_finite:  \n  \"finite {p. \\<exists>f' l'. ((f,l),p,(f',l')) \\<in> trcl pr_algo_lts}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {p. \\<exists>f' l'. ((f, l), p, f', l') \\<in> trcl pr_algo_lts}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {p. \\<exists>f' l'. ((f, l), p, f', l') \\<in> trcl pr_algo_lts}", "have FIN_OPS: \"finite (UNIV::pr_operation set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV", "apply (rule finite_subset[where B=\"{PUSH,RELABEL}\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. UNIV \\<subseteq> {PUSH, RELABEL}\n 2. finite {PUSH, RELABEL}", "using pr_operation.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = PUSH \\<Longrightarrow> ?P;\n   ?y = RELABEL \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (2 subgoals):\n 1. UNIV \\<subseteq> {PUSH, RELABEL}\n 2. finite {PUSH, RELABEL}", "by auto"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite {p. \\<exists>f' l'. ((f, l), p, f', l') \\<in> trcl pr_algo_lts}", "have \"{p. \\<exists>f' l'. ((f,l),p,(f',l')) \\<in> trcl pr_algo_lts} \n    \\<subseteq> {p. length p \\<le> pr_algo_len_bound}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. \\<exists>f' l'. ((f, l), p, f', l') \\<in> trcl pr_algo_lts}\n    \\<subseteq> {p. length p \\<le> pr_algo_len_bound}", "by (auto simp: pr_algo_lts_length_bound)"], ["proof (state)\nthis:\n  {p. \\<exists>f' l'. ((f, l), p, f', l') \\<in> trcl pr_algo_lts}\n  \\<subseteq> {p. length p \\<le> pr_algo_len_bound}\n\ngoal (1 subgoal):\n 1. finite {p. \\<exists>f' l'. ((f, l), p, f', l') \\<in> trcl pr_algo_lts}", "also"], ["proof (state)\nthis:\n  {p. \\<exists>f' l'. ((f, l), p, f', l') \\<in> trcl pr_algo_lts}\n  \\<subseteq> {p. length p \\<le> pr_algo_len_bound}\n\ngoal (1 subgoal):\n 1. finite {p. \\<exists>f' l'. ((f, l), p, f', l') \\<in> trcl pr_algo_lts}", "note finite_lists_length_le[OF FIN_OPS, simplified]"], ["proof (state)\nthis:\n  finite {xs. length xs \\<le> ?n}\n\ngoal (1 subgoal):\n 1. finite {p. \\<exists>f' l'. ((f, l), p, f', l') \\<in> trcl pr_algo_lts}", "finally (finite_subset)"], ["proof (chain)\npicking this:\n  finite {p. \\<exists>f' l'. ((f, l), p, f', l') \\<in> trcl pr_algo_lts}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {p. \\<exists>f' l'. ((f, l), p, f', l') \\<in> trcl pr_algo_lts}\n\ngoal (1 subgoal):\n 1. finite {p. \\<exists>f' l'. ((f, l), p, f', l') \\<in> trcl pr_algo_lts}", "."], ["proof (state)\nthis:\n  finite {p. \\<exists>f' l'. ((f, l), p, f', l') \\<in> trcl pr_algo_lts}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"pr_algo_measure \n  \\<equiv> \\<lambda>(f,l). Max {length p |p. \\<exists>aa ba. ((f, l), p, aa, ba) \\<in> trcl pr_algo_lts}\""], ["", "lemma pr_algo_measure: \n  assumes \"(fl',fl) \\<in> pr_algo_rel\"  \n  shows \"pr_algo_measure fl' < pr_algo_measure fl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pr_algo_measure fl' < pr_algo_measure fl", "using assms"], ["proof (prove)\nusing this:\n  (fl', fl) \\<in> pr_algo_rel\n\ngoal (1 subgoal):\n 1. pr_algo_measure fl' < pr_algo_measure fl", "proof (cases fl'; cases fl; simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> pr_algo_rel; fl' = (a, b);\n        fl = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> pr_algo_measure (a, b) < pr_algo_measure (aa, ba)", "fix f l f' l'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> pr_algo_rel; fl' = (a, b);\n        fl = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> pr_algo_measure (a, b) < pr_algo_measure (aa, ba)", "assume A: \"((f',l'),(f,l)) \\<in> pr_algo_rel\""], ["proof (state)\nthis:\n  ((f', l'), f, l) \\<in> pr_algo_rel\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> pr_algo_rel; fl' = (a, b);\n        fl = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> pr_algo_measure (a, b) < pr_algo_measure (aa, ba)", "then"], ["proof (chain)\npicking this:\n  ((f', l'), f, l) \\<in> pr_algo_rel", "obtain a where LTS_STEP: \"((f,l),a,(f',l'))\\<in>pr_algo_lts\""], ["proof (prove)\nusing this:\n  ((f', l'), f, l) \\<in> pr_algo_rel\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        ((f, l), a, f', l') \\<in> pr_algo_lts \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by cases (auto intro: pr_algo_lts.intros)"], ["proof (state)\nthis:\n  ((f, l), a, f', l') \\<in> pr_algo_lts\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> pr_algo_rel; fl' = (a, b);\n        fl = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> pr_algo_measure (a, b) < pr_algo_measure (aa, ba)", "from A"], ["proof (chain)\npicking this:\n  ((f', l'), f, l) \\<in> pr_algo_rel", "interpret Height_Bounded_Labeling c s t f l"], ["proof (prove)\nusing this:\n  ((f', l'), f, l) \\<in> pr_algo_rel\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f l", "by cases auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> pr_algo_rel; fl' = (a, b);\n        fl = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> pr_algo_measure (a, b) < pr_algo_measure (aa, ba)", "from pr_algo_maintains_hb_labeling[OF LTS_STEP]"], ["proof (chain)\npicking this:\n  Height_Bounded_Labeling c s t f' l'", "interpret f': Height_Bounded_Labeling c s t f' l'"], ["proof (prove)\nusing this:\n  Height_Bounded_Labeling c s t f' l'\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f' l'", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> pr_algo_rel; fl' = (a, b);\n        fl = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> pr_algo_measure (a, b) < pr_algo_measure (aa, ba)", "let ?S1 = \"{length p |p. \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> pr_algo_rel; fl' = (a, b);\n        fl = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> pr_algo_measure (a, b) < pr_algo_measure (aa, ba)", "let ?S2 = \"{length p |p. \\<exists>fx lx. ((f', l'), p, fx, lx) \\<in> trcl pr_algo_lts}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> pr_algo_rel; fl' = (a, b);\n        fl = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> pr_algo_measure (a, b) < pr_algo_measure (aa, ba)", "have \"finite ?S1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {length p |p.\n      \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts}", "using finite_image_set path_set_finite"], ["proof (prove)\nusing this:\n  finite {x. ?P x} \\<Longrightarrow> finite {?f x |x. ?P x}\n  finite {p. \\<exists>f' l'. ((f, l), p, f', l') \\<in> trcl pr_algo_lts}\n\ngoal (1 subgoal):\n 1. finite\n     {length p |p.\n      \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts}", "by blast"], ["proof (state)\nthis:\n  finite\n   {length p |p. \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> pr_algo_rel; fl' = (a, b);\n        fl = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> pr_algo_measure (a, b) < pr_algo_measure (aa, ba)", "moreover"], ["proof (state)\nthis:\n  finite\n   {length p |p. \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> pr_algo_rel; fl' = (a, b);\n        fl = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> pr_algo_measure (a, b) < pr_algo_measure (aa, ba)", "have \"?S1 \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {length p |p.\n     \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts} \\<noteq>\n    {}", "by (auto intro: exI[where x=\"[]\"])"], ["proof (state)\nthis:\n  {length p |p.\n   \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> pr_algo_rel; fl' = (a, b);\n        fl = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> pr_algo_measure (a, b) < pr_algo_measure (aa, ba)", "ultimately"], ["proof (chain)\npicking this:\n  finite\n   {length p |p. \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts}\n  {length p |p.\n   \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts} \\<noteq>\n  {}", "obtain p fx lx where \n    \"length p = Max ?S1\" \n    \"((f, l), p, fx, lx) \\<in> trcl pr_algo_lts\""], ["proof (prove)\nusing this:\n  finite\n   {length p |p. \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts}\n  {length p |p.\n   \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>p fx lx.\n        \\<lbrakk>length p =\n                 Max {length p |p.\n                      \\<exists>fx lx.\n                         ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts};\n         ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p fx lx.\n                \\<lbrakk>length p =\n                         Max {length p |p.\n                              \\<exists>fx lx.\n                                 ((f, l), p, fx, lx)\n                                 \\<in> trcl pr_algo_lts};\n                 ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     finite\n      {length p |p.\n       \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts};\n     {length p |p.\n      \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts} \\<noteq>\n     {}\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (drule (1) Max_in)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p fx lx.\n                \\<lbrakk>length p =\n                         Max {length p |p.\n                              \\<exists>fx lx.\n                                 ((f, l), p, fx, lx)\n                                 \\<in> trcl pr_algo_lts};\n                 ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     {length p |p.\n      \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts} \\<noteq>\n     {};\n     Max {length p |p.\n          \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts}\n     \\<in> {length p |p.\n            \\<exists>fx lx.\n               ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts}\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  length p =\n  Max {length p |p.\n       \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts}\n  ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> pr_algo_rel; fl' = (a, b);\n        fl = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> pr_algo_measure (a, b) < pr_algo_measure (aa, ba)", "have \"finite ?S2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {length p |p.\n      \\<exists>fx lx. ((f', l'), p, fx, lx) \\<in> trcl pr_algo_lts}", "using finite_image_set f'.path_set_finite"], ["proof (prove)\nusing this:\n  finite {x. ?P x} \\<Longrightarrow> finite {?f x |x. ?P x}\n  finite\n   {p. \\<exists>f'a l'a. ((f', l'), p, f'a, l'a) \\<in> trcl pr_algo_lts}\n\ngoal (1 subgoal):\n 1. finite\n     {length p |p.\n      \\<exists>fx lx. ((f', l'), p, fx, lx) \\<in> trcl pr_algo_lts}", "by blast"], ["proof (state)\nthis:\n  finite\n   {length p |p.\n    \\<exists>fx lx. ((f', l'), p, fx, lx) \\<in> trcl pr_algo_lts}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> pr_algo_rel; fl' = (a, b);\n        fl = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> pr_algo_measure (a, b) < pr_algo_measure (aa, ba)", "have \"?S2 \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {length p |p.\n     \\<exists>fx lx. ((f', l'), p, fx, lx) \\<in> trcl pr_algo_lts} \\<noteq>\n    {}", "by (auto intro: exI[where x=\"[]\"])"], ["proof (state)\nthis:\n  {length p |p.\n   \\<exists>fx lx. ((f', l'), p, fx, lx) \\<in> trcl pr_algo_lts} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> pr_algo_rel; fl' = (a, b);\n        fl = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> pr_algo_measure (a, b) < pr_algo_measure (aa, ba)", "{"], ["proof (state)\nthis:\n  {length p |p.\n   \\<exists>fx lx. ((f', l'), p, fx, lx) \\<in> trcl pr_algo_lts} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> pr_algo_rel; fl' = (a, b);\n        fl = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> pr_algo_measure (a, b) < pr_algo_measure (aa, ba)", "assume MG: \"Max ?S2 \\<ge> Max ?S1\""], ["proof (state)\nthis:\n  Max {length p |p.\n       \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts}\n  \\<le> Max {length p |p.\n             \\<exists>fx lx. ((f', l'), p, fx, lx) \\<in> trcl pr_algo_lts}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> pr_algo_rel; fl' = (a, b);\n        fl = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> pr_algo_measure (a, b) < pr_algo_measure (aa, ba)", "from Max_in[OF \\<open>finite ?S2\\<close> \\<open>?S2\\<noteq>{}\\<close>]"], ["proof (chain)\npicking this:\n  Max {length p |p.\n       \\<exists>fx lx. ((f', l'), p, fx, lx) \\<in> trcl pr_algo_lts}\n  \\<in> {length p |p.\n         \\<exists>fx lx. ((f', l'), p, fx, lx) \\<in> trcl pr_algo_lts}", "obtain p fx lx where  \n      \"length p = Max ?S2\" \n      \"((f', l'), p, fx, lx) \\<in> trcl pr_algo_lts\""], ["proof (prove)\nusing this:\n  Max {length p |p.\n       \\<exists>fx lx. ((f', l'), p, fx, lx) \\<in> trcl pr_algo_lts}\n  \\<in> {length p |p.\n         \\<exists>fx lx. ((f', l'), p, fx, lx) \\<in> trcl pr_algo_lts}\n\ngoal (1 subgoal):\n 1. (\\<And>p fx lx.\n        \\<lbrakk>length p =\n                 Max {length p |p.\n                      \\<exists>fx lx.\n                         ((f', l'), p, fx, lx) \\<in> trcl pr_algo_lts};\n         ((f', l'), p, fx, lx) \\<in> trcl pr_algo_lts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  length p =\n  Max {length p |p.\n       \\<exists>fx lx. ((f', l'), p, fx, lx) \\<in> trcl pr_algo_lts}\n  ((f', l'), p, fx, lx) \\<in> trcl pr_algo_lts\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> pr_algo_rel; fl' = (a, b);\n        fl = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> pr_algo_measure (a, b) < pr_algo_measure (aa, ba)", "with MG LTS_STEP"], ["proof (chain)\npicking this:\n  Max {length p |p.\n       \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts}\n  \\<le> Max {length p |p.\n             \\<exists>fx lx. ((f', l'), p, fx, lx) \\<in> trcl pr_algo_lts}\n  ((f, l), a, f', l') \\<in> pr_algo_lts\n  length p =\n  Max {length p |p.\n       \\<exists>fx lx. ((f', l'), p, fx, lx) \\<in> trcl pr_algo_lts}\n  ((f', l'), p, fx, lx) \\<in> trcl pr_algo_lts", "have\n      LEN: \"length (a#p) > Max ?S1\"\n      and P: \"((f,l),a#p,(fx,lx)) \\<in> trcl pr_algo_lts\""], ["proof (prove)\nusing this:\n  Max {length p |p.\n       \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts}\n  \\<le> Max {length p |p.\n             \\<exists>fx lx. ((f', l'), p, fx, lx) \\<in> trcl pr_algo_lts}\n  ((f, l), a, f', l') \\<in> pr_algo_lts\n  length p =\n  Max {length p |p.\n       \\<exists>fx lx. ((f', l'), p, fx, lx) \\<in> trcl pr_algo_lts}\n  ((f', l'), p, fx, lx) \\<in> trcl pr_algo_lts\n\ngoal (1 subgoal):\n 1. Max {length p |p.\n         \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts}\n    < length (a # p) &&&\n    ((f, l), a # p, fx, lx) \\<in> trcl pr_algo_lts", "by (auto simp: trcl_conv)"], ["proof (state)\nthis:\n  Max {length p |p.\n       \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts}\n  < length (a # p)\n  ((f, l), a # p, fx, lx) \\<in> trcl pr_algo_lts\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> pr_algo_rel; fl' = (a, b);\n        fl = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> pr_algo_measure (a, b) < pr_algo_measure (aa, ba)", "from P"], ["proof (chain)\npicking this:\n  ((f, l), a # p, fx, lx) \\<in> trcl pr_algo_lts", "have \"length (a#p) \\<in> ?S1\""], ["proof (prove)\nusing this:\n  ((f, l), a # p, fx, lx) \\<in> trcl pr_algo_lts\n\ngoal (1 subgoal):\n 1. length (a # p)\n    \\<in> {length p |p.\n           \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts}", "by blast"], ["proof (state)\nthis:\n  length (a # p)\n  \\<in> {length p |p.\n         \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts}\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> pr_algo_rel; fl' = (a, b);\n        fl = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> pr_algo_measure (a, b) < pr_algo_measure (aa, ba)", "from Max_ge[OF \\<open>finite ?S1\\<close> this] LEN"], ["proof (chain)\npicking this:\n  length (a # p)\n  \\<le> Max {length p |p.\n             \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts}\n  Max {length p |p.\n       \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts}\n  < length (a # p)", "have False"], ["proof (prove)\nusing this:\n  length (a # p)\n  \\<le> Max {length p |p.\n             \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts}\n  Max {length p |p.\n       \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts}\n  < length (a # p)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> pr_algo_rel; fl' = (a, b);\n        fl = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> pr_algo_measure (a, b) < pr_algo_measure (aa, ba)", "}"], ["proof (state)\nthis:\n  Max {length p |p.\n       \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts}\n  \\<le> Max {length p |p.\n             \\<exists>fx lx.\n                ((f', l'), p, fx, lx)\n                \\<in> trcl pr_algo_lts} \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>((a, b), aa, ba) \\<in> pr_algo_rel; fl' = (a, b);\n        fl = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> pr_algo_measure (a, b) < pr_algo_measure (aa, ba)", "thus \"pr_algo_measure (f', l') < pr_algo_measure (f, l)\""], ["proof (prove)\nusing this:\n  Max {length p |p.\n       \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts}\n  \\<le> Max {length p |p.\n             \\<exists>fx lx.\n                ((f', l'), p, fx, lx)\n                \\<in> trcl pr_algo_lts} \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. pr_algo_measure (f', l') < pr_algo_measure (f, l)", "unfolding pr_algo_measure_def"], ["proof (prove)\nusing this:\n  Max {length p |p.\n       \\<exists>fx lx. ((f, l), p, fx, lx) \\<in> trcl pr_algo_lts}\n  \\<le> Max {length p |p.\n             \\<exists>fx lx.\n                ((f', l'), p, fx, lx)\n                \\<in> trcl pr_algo_lts} \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. (case (f', l') of\n     (f, l) \\<Rightarrow>\n       Max {length p |p.\n            \\<exists>aa ba. ((f, l), p, aa, ba) \\<in> trcl pr_algo_lts})\n    < (case (f, l) of\n       (f, l) \\<Rightarrow>\n         Max {length p |p.\n              \\<exists>aa ba. ((f, l), p, aa, ba) \\<in> trcl pr_algo_lts})", "by (rule ccontr) auto"], ["proof (state)\nthis:\n  pr_algo_measure (f', l') < pr_algo_measure (f, l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_pr_algo_rel[simp, intro!]: \"wf pr_algo_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf pr_algo_rel", "apply (rule wf_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf ?r\n 2. pr_algo_rel \\<subseteq> ?r", "apply (rule wf_measure[where f=pr_algo_measure])"], ["proof (prove)\ngoal (1 subgoal):\n 1. pr_algo_rel \\<subseteq> measure pr_algo_measure", "by (auto simp: pr_algo_measure)"], ["", "end \\<comment> \\<open>Network\\<close>"], ["", "subsection \\<open>Gap Heuristics\\<close>"], ["", "context Network\nbegin"], ["", "text \\<open>If we find a label value \\<open>k\\<close> that is assigned to no node,\n  we may relabel all nodes \\<open>v\\<close> with \\<open>k < l v < card V\\<close> to \\<open>card V + 1\\<close>.\n\\<close>"], ["", "definition \"gap_precond l k \\<equiv> \\<forall>v\\<in>V. l v \\<noteq> k\""], ["", "definition \"gap_effect l k \n  \\<equiv> \\<lambda>v. if k<l v \\<and> l v < card V then card V + 1 else l v\""], ["", "text \\<open>The gap heuristics preserves a valid labeling.\\<close>"], ["", "lemma (in Labeling) gap_pres_Labeling:\n  assumes PRE: \"gap_precond l k\"\n  defines \"l' \\<equiv> gap_effect l k\"\n  shows \"Labeling c s t f l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Labeling c s t f l'", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u v. (u, v) \\<in> cf.E \\<Longrightarrow> l' u \\<le> l' v + 1\n 2. l' s = card V\n 3. l' t = 0", "from lab_src"], ["proof (chain)\npicking this:\n  l s = card V", "show \"l' s = card V\""], ["proof (prove)\nusing this:\n  l s = card V\n\ngoal (1 subgoal):\n 1. l' s = card V", "unfolding l'_def gap_effect_def"], ["proof (prove)\nusing this:\n  l s = card V\n\ngoal (1 subgoal):\n 1. (if k < l s \\<and> l s < card V then card V + 1 else l s) = card V", "by auto"], ["proof (state)\nthis:\n  l' s = card V\n\ngoal (2 subgoals):\n 1. \\<And>u v. (u, v) \\<in> cf.E \\<Longrightarrow> l' u \\<le> l' v + 1\n 2. l' t = 0", "from lab_sink"], ["proof (chain)\npicking this:\n  l t = 0", "show \"l' t = 0\""], ["proof (prove)\nusing this:\n  l t = 0\n\ngoal (1 subgoal):\n 1. l' t = 0", "unfolding l'_def gap_effect_def"], ["proof (prove)\nusing this:\n  l t = 0\n\ngoal (1 subgoal):\n 1. (if k < l t \\<and> l t < card V then card V + 1 else l t) = 0", "by auto"], ["proof (state)\nthis:\n  l' t = 0\n\ngoal (1 subgoal):\n 1. \\<And>u v. (u, v) \\<in> cf.E \\<Longrightarrow> l' u \\<le> l' v + 1", "have l'_incr: \"l' v \\<ge> l v\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. l v \\<le> l' v", "unfolding l'_def gap_effect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. l v \\<le> (if k < l v \\<and> l v < card V then card V + 1 else l v)", "by auto"], ["proof (state)\nthis:\n  l ?v3 \\<le> l' ?v3\n\ngoal (1 subgoal):\n 1. \\<And>u v. (u, v) \\<in> cf.E \\<Longrightarrow> l' u \\<le> l' v + 1", "fix u v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v. (u, v) \\<in> cf.E \\<Longrightarrow> l' u \\<le> l' v + 1", "assume A: \"(u,v) \\<in> cf.E\""], ["proof (state)\nthis:\n  (u, v) \\<in> cf.E\n\ngoal (1 subgoal):\n 1. \\<And>u v. (u, v) \\<in> cf.E \\<Longrightarrow> l' u \\<le> l' v + 1", "hence \"u\\<in>V\" \"v\\<in>V\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> cf.E\n\ngoal (1 subgoal):\n 1. u \\<in> V &&& v \\<in> V", "using cfE_ss_invE E_ss_VxV"], ["proof (prove)\nusing this:\n  (u, v) \\<in> cf.E\n  cf.E \\<subseteq> E \\<union> E\\<inverse>\n  E \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. u \\<in> V &&& v \\<in> V", "by auto"], ["proof (state)\nthis:\n  u \\<in> V\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>u v. (u, v) \\<in> cf.E \\<Longrightarrow> l' u \\<le> l' v + 1", "thus \"l' u \\<le> l' v + 1\""], ["proof (prove)\nusing this:\n  u \\<in> V\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. l' u \\<le> l' v + 1", "unfolding l'_def gap_effect_def"], ["proof (prove)\nusing this:\n  u \\<in> V\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. (if k < l u \\<and> l u < card V then card V + 1 else l u)\n    \\<le> (if k < l v \\<and> l v < card V then card V + 1 else l v) + 1", "using valid[OF A] PRE"], ["proof (prove)\nusing this:\n  u \\<in> V\n  v \\<in> V\n  l u \\<le> l v + 1\n  gap_precond l k\n\ngoal (1 subgoal):\n 1. (if k < l u \\<and> l u < card V then card V + 1 else l u)\n    \\<le> (if k < l v \\<and> l v < card V then card V + 1 else l v) + 1", "unfolding gap_precond_def"], ["proof (prove)\nusing this:\n  u \\<in> V\n  v \\<in> V\n  l u \\<le> l v + 1\n  \\<forall>v\\<in>V. l v \\<noteq> k\n\ngoal (1 subgoal):\n 1. (if k < l u \\<and> l u < card V then card V + 1 else l u)\n    \\<le> (if k < l v \\<and> l v < card V then card V + 1 else l v) + 1", "by auto"], ["proof (state)\nthis:\n  l' u \\<le> l' v + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The gap heuristics also preserves the height bounds.\\<close>"], ["", "lemma (in Height_Bounded_Labeling) gap_pres_hb_labeling:\n  assumes PRE: \"gap_precond l k\"\n  defines \"l' \\<equiv> gap_effect l k\"\n  shows \"Height_Bounded_Labeling c s t f l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f l'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f l'", "from gap_pres_Labeling[OF PRE]"], ["proof (chain)\npicking this:\n  Labeling c s t f (gap_effect l k)", "interpret Labeling c s t f l'"], ["proof (prove)\nusing this:\n  Labeling c s t f (gap_effect l k)\n\ngoal (1 subgoal):\n 1. Labeling c s t f l'", "unfolding l'_def"], ["proof (prove)\nusing this:\n  Labeling c s t f (gap_effect l k)\n\ngoal (1 subgoal):\n 1. Labeling c s t f (gap_effect l k)", "."], ["proof (state)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f l'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f l'", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>V. l' u \\<le> 2 * card V - 1", "unfolding l'_def gap_effect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>V.\n       (if k < l u \\<and> l u < card V then card V + 1 else l u)\n       \\<le> 2 * card V - 1", "using height_bound"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>V. l u \\<le> 2 * card V - 1\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>V.\n       (if k < l u \\<and> l u < card V then card V + 1 else l u)\n       \\<le> 2 * card V - 1", "by auto"], ["proof (state)\nthis:\n  Height_Bounded_Labeling c s t f l'\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We combine the regular relabel operation with the gap heuristics:\n  If relabeling results in a gap, the gap heuristics is applied immediately.\n\\<close>"], ["", "definition \"gap_relabel_effect f l u \\<equiv> let l' = relabel_effect f l u in\n  if (gap_precond l' (l u)) then gap_effect l' (l u) else l'\n\""], ["", "text \\<open>The combined gap-relabel operation preserves a valid labeling.\\<close>"], ["", "lemma (in Labeling) gap_relabel_pres_Labeling:\n  assumes PRE: \"relabel_precond f l u\"\n  defines \"l' \\<equiv> gap_relabel_effect f l u\"\n  shows \"Labeling c s t f l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Labeling c s t f l'", "unfolding l'_def gap_relabel_effect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Labeling c s t f\n     (let l' = relabel_effect f l u\n      in if gap_precond l' (l u) then gap_effect l' (l u) else l')", "using relabel_pres_Labeling[OF PRE] Labeling.gap_pres_Labeling"], ["proof (prove)\nusing this:\n  Labeling c s t f (relabel_effect f l u)\n  \\<lbrakk>Labeling ?c ?s ?t ?f ?l; Network.gap_precond ?c ?l ?k\\<rbrakk>\n  \\<Longrightarrow> Labeling ?c ?s ?t ?f (Network.gap_effect ?c ?l ?k)\n\ngoal (1 subgoal):\n 1. Labeling c s t f\n     (let l' = relabel_effect f l u\n      in if gap_precond l' (l u) then gap_effect l' (l u) else l')", "by (fastforce simp: Let_def)"], ["", "text \\<open>The combined gap-relabel operation preserves the height-bound.\\<close>"], ["", "lemma (in Height_Bounded_Labeling) gap_relabel_pres_hb_labeling:\n  assumes PRE: \"relabel_precond f l u\"\n  defines \"l' \\<equiv> gap_relabel_effect f l u\"\n  shows \"Height_Bounded_Labeling c s t f l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f l'", "unfolding l'_def gap_relabel_effect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f\n     (let l' = relabel_effect f l u\n      in if gap_precond l' (l u) then gap_effect l' (l u) else l')", "using relabel_pres_height_bound[OF PRE] Height_Bounded_Labeling.gap_pres_hb_labeling"], ["proof (prove)\nusing this:\n  Height_Bounded_Labeling c s t f (relabel_effect f l u)\n  \\<lbrakk>Height_Bounded_Labeling ?c ?s ?t ?f ?l;\n   Network.gap_precond ?c ?l ?k\\<rbrakk>\n  \\<Longrightarrow> Height_Bounded_Labeling ?c ?s ?t ?f\n                     (Network.gap_effect ?c ?l ?k)\n\ngoal (1 subgoal):\n 1. Height_Bounded_Labeling c s t f\n     (let l' = relabel_effect f l u\n      in if gap_precond l' (l u) then gap_effect l' (l u) else l')", "by (fastforce simp: Let_def)"], ["", "subsubsection \\<open>Termination with Gap Heuristics\\<close>"], ["", "text \\<open>\n  Intuitively, the algorithm with the gap heuristics terminates because \n  relabeling according to the gap heuristics preserves the invariant and \n  increases some labels towards their upper bound. \n\n  Formally, the simplest way is to combine a heights measure function with\n  the already established measure for the standard algorithm:\n\\<close>"], ["", "lemma (in Height_Bounded_Labeling) gap_measure:\n  assumes \"gap_precond l k\"\n  shows \"sum_heights_measure (gap_effect l k) \\<le> sum_heights_measure l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_heights_measure (gap_effect l k) \\<le> sum_heights_measure l", "unfolding gap_effect_def sum_heights_measure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>V.\n       2 * card V -\n       (if k < l v \\<and> l v < card V then card V + 1 else l v))\n    \\<le> (\\<Sum>v\\<in>V. 2 * card V - l v)", "by (auto intro!: sum_mono)"], ["", "lemma (in Height_Bounded_Labeling) gap_relabel_measure:\n  assumes PRE: \"relabel_precond f l u\"\n  shows \"sum_heights_measure (gap_relabel_effect f l u) < sum_heights_measure l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_heights_measure (gap_relabel_effect f l u) < sum_heights_measure l", "unfolding gap_relabel_effect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_heights_measure\n     (let l' = relabel_effect f l u\n      in if gap_precond l' (l u) then gap_effect l' (l u) else l')\n    < sum_heights_measure l", "using relabel_measure[OF PRE] relabel_pres_height_bound[OF PRE] Height_Bounded_Labeling.gap_measure"], ["proof (prove)\nusing this:\n  sum_heights_measure (relabel_effect f l u) < sum_heights_measure l\n  Height_Bounded_Labeling c s t f (relabel_effect f l u)\n  \\<lbrakk>Height_Bounded_Labeling ?c ?s ?t ?f ?l;\n   Network.gap_precond ?c ?l ?k\\<rbrakk>\n  \\<Longrightarrow> Network.sum_heights_measure ?c\n                     (Network.gap_effect ?c ?l ?k)\n                    \\<le> Network.sum_heights_measure ?c ?l\n\ngoal (1 subgoal):\n 1. sum_heights_measure\n     (let l' = relabel_effect f l u\n      in if gap_precond l' (l u) then gap_effect l' (l u) else l')\n    < sum_heights_measure l", "by (fastforce simp: Let_def)"], ["", "text \\<open>Analogously to @{const pr_algo_rel}, we provide a well-founded relation \n  that over-approximates the steps of a push-relabel algorithm with gap \n  heuristics.\n\\<close>"], ["", "inductive_set gap_algo_rel where\n  push: \"\\<lbrakk>Height_Bounded_Labeling c s t f l; push_precond f l e\\<rbrakk> \n    \\<Longrightarrow> ((push_effect f e,l),(f,l))\\<in>gap_algo_rel\"\n| relabel: \"\\<lbrakk>Height_Bounded_Labeling c s t f l; relabel_precond f l u\\<rbrakk>\n    \\<Longrightarrow> ((f,gap_relabel_effect f l u),(f,l))\\<in>gap_algo_rel\""], ["", "lemma wf_gap_algo_rel[simp, intro!]: \"wf gap_algo_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf gap_algo_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf gap_algo_rel", "have \"gap_algo_rel \\<subseteq> inv_image (less_than <*lex*> less_than) (\\<lambda>(f,l). (sum_heights_measure l, pr_algo_measure (f,l)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gap_algo_rel\n    \\<subseteq> inv_image (less_than <*lex*> less_than)\n                 (\\<lambda>(f, l).\n                     (sum_heights_measure l, pr_algo_measure (f, l)))", "using pr_algo_measure"], ["proof (prove)\nusing this:\n  (?fl', ?fl) \\<in> pr_algo_rel \\<Longrightarrow>\n  pr_algo_measure ?fl' < pr_algo_measure ?fl\n\ngoal (1 subgoal):\n 1. gap_algo_rel\n    \\<subseteq> inv_image (less_than <*lex*> less_than)\n                 (\\<lambda>(f, l).\n                     (sum_heights_measure l, pr_algo_measure (f, l)))", "using Height_Bounded_Labeling.gap_relabel_measure"], ["proof (prove)\nusing this:\n  (?fl', ?fl) \\<in> pr_algo_rel \\<Longrightarrow>\n  pr_algo_measure ?fl' < pr_algo_measure ?fl\n  \\<lbrakk>Height_Bounded_Labeling ?c ?s ?t ?f ?l;\n   Network.relabel_precond ?c ?t ?f ?l ?u\\<rbrakk>\n  \\<Longrightarrow> Network.sum_heights_measure ?c\n                     (Network.gap_relabel_effect ?c ?f ?l ?u)\n                    < Network.sum_heights_measure ?c ?l\n\ngoal (1 subgoal):\n 1. gap_algo_rel\n    \\<subseteq> inv_image (less_than <*lex*> less_than)\n                 (\\<lambda>(f, l).\n                     (sum_heights_measure l, pr_algo_measure (f, l)))", "by (fastforce elim!: gap_algo_rel.cases intro: pr_algo_rel.intros )"], ["proof (state)\nthis:\n  gap_algo_rel\n  \\<subseteq> inv_image (less_than <*lex*> less_than)\n               (\\<lambda>(f, l).\n                   (sum_heights_measure l, pr_algo_measure (f, l)))\n\ngoal (1 subgoal):\n 1. wf gap_algo_rel", "thus ?thesis"], ["proof (prove)\nusing this:\n  gap_algo_rel\n  \\<subseteq> inv_image (less_than <*lex*> less_than)\n               (\\<lambda>(f, l).\n                   (sum_heights_measure l, pr_algo_measure (f, l)))\n\ngoal (1 subgoal):\n 1. wf gap_algo_rel", "by (rule_tac wf_subset; auto)"], ["proof (state)\nthis:\n  wf gap_algo_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>Network\\<close>"], ["", "end"]]}