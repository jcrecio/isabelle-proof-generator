{"file_name": "/home/qj213/afp-2021-10-22/thys/Prpu_Maxflow/Relabel_To_Front_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Prpu_Maxflow", "problem_names": ["lemma n_init_refine[refine2]: \n  assumes AM: \"is_adj_map am\"  \n  shows \"n_init am \n    \\<le> (spec c. (c, rtf_init_n) \\<in> (nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel))\"", "lemma discharge_structure_refine_aux:\n  assumes SR: \"(ni,n)\\<in>nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel\"\n  assumes SU: \"(ui,u)\\<in>Id\"  \n  assumes fNR: \"fNi \\<le> \\<Down>R fN\"\n  assumes UIV: \"u\\<in>V-{s,t}\"  \n  assumes fSR: \"\\<And>v vi vs. \\<lbrakk> \n      (vi,v)\\<in>Id; v\\<in>n u; ni u = v#vs; (v#vs,n u)\\<in>\\<langle>nat_rel\\<rangle>list_set_rel \n    \\<rbrakk> \\<Longrightarrow> fSi vi \\<le> \\<Down>R (fS v)\"\n  shows\n  \"( do {\n    at_end \\<leftarrow> n_at_end ni ui;\n    if at_end then fNi\n    else do {\n      v \\<leftarrow> n_get_hd ni ui;\n      fSi v\n    }\n  } ) \\<le> \\<Down>R (\n\n  do {\n    v \\<leftarrow> select v. v\\<in>n u;\n    case v of\n      None \\<Rightarrow> fN\n    | Some v \\<Rightarrow> fS v\n  })\" (is \"?lhs \\<le>\\<Down>R ?rhs\")", "lemma xf_rel_RELATES[refine_dref_RELATES]: \"RELATES xf_rel\"", "lemma discharge2_refine[refine]:     \n  assumes A: \"((x,cf),f) \\<in> xf_rel\"\n  assumes AM: \"(am,adjacent_nodes)\\<in>nat_rel\\<rightarrow>\\<langle>nat_rel\\<rangle>list_set_rel\"\n  assumes [simplified,simp]: \"(li,l)\\<in>Id\" \"(ui,u)\\<in>Id\"\n  assumes NR: \"(ni,n)\\<in>nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel\"  \n  shows \"discharge2 am x cf li ni ui \n    \\<le> \\<Down>(xf_rel \\<times>\\<^sub>r Id \\<times>\\<^sub>r (nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel)) (discharge f l n u)\"", "lemma V_is_adj_nodes: \"V = { v . adjacent_nodes v \\<noteq> {} }\"", "lemma init_CQ_correct[THEN order_trans, refine_vcg]:\n  assumes AM: \"is_adj_map am\"  \n  shows \"init_CQ am \\<le> SPEC (\\<lambda>(C,Q). C = card V \\<and> distinct Q \\<and> set Q = V-{s,t})\"", "lemma relabel_to_front2_refine[refine]: \n  assumes AM: \"is_adj_map am\"  \n  shows \"relabel_to_front2 am \n    \\<le> \\<Down>(br (flow_of_cf) (RPreGraph c s t)) relabel_to_front\"", "lemma [sepref_fr_rules]: \n  \"(n_init_impl s t,PR_CONST n_init) \\<in> am_assn\\<^sup>k \\<rightarrow>\\<^sub>a n_assn\"", "lemma [sepref_fr_rules]: \n  \"(uncurry n_at_end_impl, uncurry (PR_CONST n_at_end)) \n  \\<in> n_assn\\<^sup>k *\\<^sub>a node_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\"", "lemma [sepref_fr_rules]: \n  \"(uncurry n_get_hd_impl, uncurry (PR_CONST n_get_hd)) \n  \\<in> n_assn\\<^sup>k *\\<^sub>a node_assn\\<^sup>k \\<rightarrow>\\<^sub>a node_assn\"", "lemma [sepref_fr_rules]: \n  \"(uncurry n_move_next_impl, uncurry (PR_CONST n_move_next)) \n  \\<in> n_assn\\<^sup>d *\\<^sub>a node_assn\\<^sup>k \\<rightarrow>\\<^sub>a n_assn\"", "lemma [sepref_fr_rules]: \n  \"(uncurry2 n_reset_impl, uncurry2 (PR_CONST n_reset)) \n  \\<in> am_assn\\<^sup>k *\\<^sub>a n_assn\\<^sup>d *\\<^sub>a node_assn\\<^sup>k \\<rightarrow>\\<^sub>a n_assn\"", "lemmas [sepref_fr_rules] = discharge_impl.refine[OF Network_Impl_axioms]", "lemmas [sepref_fr_rules] = init_CQ_impl.refine[OF Network_Impl_axioms]", "lemmas [sepref_fr_rules] = relabel_to_front_impl.refine[OF Network_Impl_axioms]", "theorem relabel_to_front_impl_correct[sep_heap_rules]: \n    assumes AM: \"is_adj_map am\"\n    shows \"\n      <am_assn am ami> \n        relabel_to_front_impl c s t N ami\n      <\\<lambda>cfi. \\<exists>\\<^sub>Acf. cf_assn cf cfi \n                * \\<up>(isMaxFlow (flow_of_cf cf) \\<and> RGraph_Impl c s t N cf)>\\<^sub>t\"", "theorem relabel_to_front_impl_tab_am_correct[sep_heap_rules]: \n  assumes NW: \"Network c s t\"\n  assumes VN: \"Graph.V c \\<subseteq> {0..<N}\"\n  assumes ABS_PS: \"Graph.is_adj_map c am\"\n  shows \"\n    <emp> \n      relabel_to_front_impl_tab_am c s t N am\n    <\\<lambda>cfi. \\<exists>\\<^sub>Acf. \n        asmtx_assn N id_assn cf cfi \n      * \\<up>(Network.isMaxFlow c s t (Network.flow_of_cf c cf)\n        \\<and> RGraph_Impl c s t N cf\n        )>\\<^sub>t\"", "theorem relabel_to_front_correct:\n  \"<emp>\n  relabel_to_front el s t\n  <\\<lambda>\n    None \\<Rightarrow> \\<up>(\\<not>ln_invar el \\<or> \\<not>Network (ln_\\<alpha> el) s t)\n  | Some (c,am,N,cfi) \\<Rightarrow> \n      \\<up>(c = ln_\\<alpha> el \\<and> ln_invar el) \n    * (\\<exists>\\<^sub>Acf. asmtx_assn N int_assn cf cfi\n          * \\<up>(RGraph_Impl c s t N cf \n            \\<and> Network.isMaxFlow c s t (Network.flow_of_cf c cf))) \n    * \\<up>(Graph.is_adj_map c am)\n  >\\<^sub>t\n  \""], "translations": [["", "lemma n_init_refine[refine2]: \n  assumes AM: \"is_adj_map am\"  \n  shows \"n_init am \n    \\<le> (spec c. (c, rtf_init_n) \\<in> (nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n_init am\n    \\<le> (spec c.\n              (c, rtf_init_n)\n              \\<in> nat_rel \\<rightarrow>\n                    \\<langle>nat_rel\\<rangle>list_set_rel)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n_init am\n    \\<le> (spec c.\n              (c, rtf_init_n)\n              \\<in> nat_rel \\<rightarrow>\n                    \\<langle>nat_rel\\<rangle>list_set_rel)", "have[simp]: \"am v = []\" if \"v\\<notin>V\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. am v = []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. am v = []", "from that"], ["proof (chain)\npicking this:\n  v \\<notin> V", "have \"adjacent_nodes v = {}\""], ["proof (prove)\nusing this:\n  v \\<notin> V\n\ngoal (1 subgoal):\n 1. adjacent_nodes v = {}", "unfolding adjacent_nodes_def"], ["proof (prove)\nusing this:\n  v \\<notin> V\n\ngoal (1 subgoal):\n 1. E `` {v} \\<union> E\\<inverse> `` {v} = {}", "using E_ss_VxV"], ["proof (prove)\nusing this:\n  v \\<notin> V\n  E \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. E `` {v} \\<union> E\\<inverse> `` {v} = {}", "by auto"], ["proof (state)\nthis:\n  adjacent_nodes v = {}\n\ngoal (1 subgoal):\n 1. am v = []", "thus ?thesis"], ["proof (prove)\nusing this:\n  adjacent_nodes v = {}\n\ngoal (1 subgoal):\n 1. am v = []", "using am_to_adj_nodes_refine[OF AM]"], ["proof (prove)\nusing this:\n  adjacent_nodes v = {}\n  (am ?u, adjacent_nodes ?u) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel\n\ngoal (1 subgoal):\n 1. am v = []", "by (auto simp: list_set_rel_def in_br_conv)"], ["proof (state)\nthis:\n  am v = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?v10 \\<notin> V \\<Longrightarrow> am ?v10 = []\n\ngoal (1 subgoal):\n 1. n_init am\n    \\<le> (spec c.\n              (c, rtf_init_n)\n              \\<in> nat_rel \\<rightarrow>\n                    \\<langle>nat_rel\\<rangle>list_set_rel)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n_init am\n    \\<le> (spec c.\n              (c, rtf_init_n)\n              \\<in> nat_rel \\<rightarrow>\n                    \\<langle>nat_rel\\<rangle>list_set_rel)", "unfolding n_init_def rtf_init_n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. return (am(s := [], t := []))\n    \\<le> (spec c.\n              (c, \\<lambda>u.\n                     if u \\<in> V - {s, t} then adjacent_nodes u else {})\n              \\<in> nat_rel \\<rightarrow>\n                    \\<langle>nat_rel\\<rangle>list_set_rel)", "by (auto \n        simp: pw_le_iff refine_pw_simps list_set_autoref_empty \n        simp: am_to_adj_nodes_refine[OF AM])"], ["proof (state)\nthis:\n  n_init am\n  \\<le> (spec c.\n            (c, rtf_init_n)\n            \\<in> nat_rel \\<rightarrow>\n                  \\<langle>nat_rel\\<rangle>list_set_rel)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Refinement to Basic Operations\\<close>"], ["", "subsubsection \\<open>Discharge\\<close>"], ["", "definition \"discharge2 am x cf l n u \\<equiv> do {  \n  assert (u \\<in> V);\n  monadic_WHILEIT (\\<lambda>_. True) \n    (\\<lambda>((x,cf),l,n). do { xu \\<leftarrow> x_get x u; return (xu \\<noteq> 0) } ) \n    (\\<lambda>((x,cf),l,n). do {\n      at_end \\<leftarrow> n_at_end n u;\n      if at_end then do {\n        l \\<leftarrow> relabel2 am cf l u;\n        n \\<leftarrow> n_reset am n u;\n        return ((x,cf),l,n)\n      } else do {\n        v \\<leftarrow> n_get_hd n u;\n        cfuv \\<leftarrow> cf_get cf (u,v);\n        lu \\<leftarrow> l_get l u;\n        lv \\<leftarrow> l_get l v;\n        if (cfuv \\<noteq> 0 \\<and> lu = lv + 1) then do {\n          (x,cf) \\<leftarrow> push2 x cf (u,v);\n          return ((x,cf),l,n)\n        } else do {\n          n \\<leftarrow> n_move_next n u;\n          return ((x,cf),l,n)\n        }\n      }\n    }) ((x,cf),l,n)\n}\""], ["", "lemma discharge_structure_refine_aux:\n  assumes SR: \"(ni,n)\\<in>nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel\"\n  assumes SU: \"(ui,u)\\<in>Id\"  \n  assumes fNR: \"fNi \\<le> \\<Down>R fN\"\n  assumes UIV: \"u\\<in>V-{s,t}\"  \n  assumes fSR: \"\\<And>v vi vs. \\<lbrakk> \n      (vi,v)\\<in>Id; v\\<in>n u; ni u = v#vs; (v#vs,n u)\\<in>\\<langle>nat_rel\\<rangle>list_set_rel \n    \\<rbrakk> \\<Longrightarrow> fSi vi \\<le> \\<Down>R (fS v)\"\n  shows\n  \"( do {\n    at_end \\<leftarrow> n_at_end ni ui;\n    if at_end then fNi\n    else do {\n      v \\<leftarrow> n_get_hd ni ui;\n      fSi v\n    }\n  } ) \\<le> \\<Down>R (\n\n  do {\n    v \\<leftarrow> select v. v\\<in>n u;\n    case v of\n      None \\<Rightarrow> fN\n    | Some v \\<Rightarrow> fS v\n  })\" (is \"?lhs \\<le>\\<Down>R ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. n_at_end ni ui \\<bind>\n    (\\<lambda>at_end. if at_end then fNi else n_get_hd ni ui \\<bind> fSi)\n    \\<le> \\<Down> R\n           ((select v. v \\<in> n u) \\<bind>\n            (\\<lambda>v.\n                case v of None \\<Rightarrow> fN\n                | Some v \\<Rightarrow> fS v))", "unfolding n_at_end_def n_get_hd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. assert (ui \\<in> V - {s, t}) \\<bind>\n    (\\<lambda>_. return (ni ui = [])) \\<bind>\n    (\\<lambda>at_end.\n        if at_end then fNi\n        else assert (ui \\<in> V - {s, t} \\<and> ni ui \\<noteq> []) \\<bind>\n             (\\<lambda>_. return (hd (ni ui))) \\<bind>\n             fSi)\n    \\<le> \\<Down> R\n           ((select v. v \\<in> n u) \\<bind>\n            (\\<lambda>v.\n                case v of None \\<Rightarrow> fN\n                | Some v \\<Rightarrow> fS v))", "apply (simp only: nres_monad_laws)"], ["proof (prove)\ngoal (1 subgoal):\n 1. assert (ui \\<in> V - {s, t}) \\<bind>\n    (\\<lambda>x.\n        if ni ui = [] then fNi\n        else assert (ui \\<in> V - {s, t} \\<and> ni ui \\<noteq> []) \\<bind>\n             (\\<lambda>x. fSi (hd (ni ui))))\n    \\<le> \\<Down> R\n           ((select v. v \\<in> n u) \\<bind>\n            (\\<lambda>v.\n                case v of None \\<Rightarrow> fN\n                | Some v \\<Rightarrow> fS v))", "apply (cases \"ni u\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. ni u = [] \\<Longrightarrow>\n    assert (ui \\<in> V - {s, t}) \\<bind>\n    (\\<lambda>x.\n        if ni ui = [] then fNi\n        else assert (ui \\<in> V - {s, t} \\<and> ni ui \\<noteq> []) \\<bind>\n             (\\<lambda>x. fSi (hd (ni ui))))\n    \\<le> \\<Down> R\n           ((select v. v \\<in> n u) \\<bind>\n            (\\<lambda>v.\n                case v of None \\<Rightarrow> fN\n                | Some v \\<Rightarrow> fS v))\n 2. \\<And>a list.\n       ni u = a # list \\<Longrightarrow>\n       assert (ui \\<in> V - {s, t}) \\<bind>\n       (\\<lambda>x.\n           if ni ui = [] then fNi\n           else assert\n                 (ui \\<in> V - {s, t} \\<and> ni ui \\<noteq> []) \\<bind>\n                (\\<lambda>x. fSi (hd (ni ui))))\n       \\<le> \\<Down> R\n              ((select v. v \\<in> n u) \\<bind>\n               (\\<lambda>v.\n                   case v of None \\<Rightarrow> fN\n                   | Some v \\<Rightarrow> fS v))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ni u = [] \\<Longrightarrow>\n    assert (ui \\<in> V - {s, t}) \\<bind>\n    (\\<lambda>x.\n        if ni ui = [] then fNi\n        else assert (ui \\<in> V - {s, t} \\<and> ni ui \\<noteq> []) \\<bind>\n             (\\<lambda>x. fSi (hd (ni ui))))\n    \\<le> \\<Down> R\n           ((select v. v \\<in> n u) \\<bind>\n            (\\<lambda>v.\n                case v of None \\<Rightarrow> fN\n                | Some v \\<Rightarrow> fS v))", "using fun_relD[OF SR SU] SU UIV fNR"], ["proof (prove)\nusing this:\n  (ni ui, n u) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel\n  (ui, u) \\<in> nat_rel\n  u \\<in> V - {s, t}\n  fNi \\<le> \\<Down> R fN\n\ngoal (1 subgoal):\n 1. ni u = [] \\<Longrightarrow>\n    assert (ui \\<in> V - {s, t}) \\<bind>\n    (\\<lambda>x.\n        if ni ui = [] then fNi\n        else assert (ui \\<in> V - {s, t} \\<and> ni ui \\<noteq> []) \\<bind>\n             (\\<lambda>x. fSi (hd (ni ui))))\n    \\<le> \\<Down> R\n           ((select v. v \\<in> n u) \\<bind>\n            (\\<lambda>v.\n                case v of None \\<Rightarrow> fN\n                | Some v \\<Rightarrow> fS v))", "by (auto simp: list_set_rel_def in_br_conv pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ni u = a # list \\<Longrightarrow>\n       assert (ui \\<in> V - {s, t}) \\<bind>\n       (\\<lambda>x.\n           if ni ui = [] then fNi\n           else assert\n                 (ui \\<in> V - {s, t} \\<and> ni ui \\<noteq> []) \\<bind>\n                (\\<lambda>x. fSi (hd (ni ui))))\n       \\<le> \\<Down> R\n              ((select v. v \\<in> n u) \\<bind>\n               (\\<lambda>v.\n                   case v of None \\<Rightarrow> fN\n                   | Some v \\<Rightarrow> fS v))", "subgoal for v vs"], ["proof (prove)\ngoal (1 subgoal):\n 1. ni u = v # vs \\<Longrightarrow>\n    assert (ui \\<in> V - {s, t}) \\<bind>\n    (\\<lambda>x.\n        if ni ui = [] then fNi\n        else assert (ui \\<in> V - {s, t} \\<and> ni ui \\<noteq> []) \\<bind>\n             (\\<lambda>x. fSi (hd (ni ui))))\n    \\<le> \\<Down> R\n           ((select v. v \\<in> n u) \\<bind>\n            (\\<lambda>v.\n                case v of None \\<Rightarrow> fN\n                | Some v \\<Rightarrow> fS v))", "using fun_relD[OF SR SU] SU UIV"], ["proof (prove)\nusing this:\n  (ni ui, n u) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel\n  (ui, u) \\<in> nat_rel\n  u \\<in> V - {s, t}\n\ngoal (1 subgoal):\n 1. ni u = v # vs \\<Longrightarrow>\n    assert (ui \\<in> V - {s, t}) \\<bind>\n    (\\<lambda>x.\n        if ni ui = [] then fNi\n        else assert (ui \\<in> V - {s, t} \\<and> ni ui \\<noteq> []) \\<bind>\n             (\\<lambda>x. fSi (hd (ni ui))))\n    \\<le> \\<Down> R\n           ((select v. v \\<in> n u) \\<bind>\n            (\\<lambda>v.\n                case v of None \\<Rightarrow> fN\n                | Some v \\<Rightarrow> fS v))", "using fSR[OF IdI[of v], of vs]"], ["proof (prove)\nusing this:\n  (ni ui, n u) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel\n  (ui, u) \\<in> nat_rel\n  u \\<in> V - {s, t}\n  \\<lbrakk>v \\<in> n u; ni u = v # vs;\n   (v # vs, n u) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel\\<rbrakk>\n  \\<Longrightarrow> fSi v \\<le> \\<Down> R (fS v)\n\ngoal (1 subgoal):\n 1. ni u = v # vs \\<Longrightarrow>\n    assert (ui \\<in> V - {s, t}) \\<bind>\n    (\\<lambda>x.\n        if ni ui = [] then fNi\n        else assert (ui \\<in> V - {s, t} \\<and> ni ui \\<noteq> []) \\<bind>\n             (\\<lambda>x. fSi (hd (ni ui))))\n    \\<le> \\<Down> R\n           ((select v. v \\<in> n u) \\<bind>\n            (\\<lambda>v.\n                case v of None \\<Rightarrow> fN\n                | Some v \\<Rightarrow> fS v))", "apply (clarsimp \n        simp: list_set_rel_def in_br_conv pw_le_iff refine_pw_simps \n        split: option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>ni u = v # vs; ui = u; n u = insert v (set vs); u \\<in> V;\n        v \\<notin> set vs; distinct vs; u \\<noteq> s; u \\<noteq> t;\n        \\<forall>x.\n           (x = None \\<longrightarrow>\n            (\\<forall>x.\n                x \\<noteq> v \\<and> x \\<notin> set vs) \\<longrightarrow>\n            nofail fN) \\<and>\n           (\\<forall>x2.\n               x = Some x2 \\<longrightarrow>\n               (x2 = v \\<longrightarrow> nofail (fS v)) \\<and>\n               (x2 \\<in> set vs \\<longrightarrow> nofail (fS x2)));\n        inres (fSi v) x; nofail (fSi v);\n        \\<forall>x.\n           inres (fSi v) x \\<longrightarrow>\n           (\\<exists>s'. (x, s') \\<in> R \\<and> inres (fS v) s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            (x, s') \\<in> R \\<and>\n                            (\\<exists>y.\n                                (y = None \\<longrightarrow>\n                                 (\\<forall>x.\n                                     x \\<noteq> v \\<and>\n                                     x \\<notin> set vs) \\<and>\n                                 inres fN s') \\<and>\n                                (\\<forall>x2.\n                                    y = Some x2 \\<longrightarrow>\n                                    (x2 = v \\<or> x2 \\<in> set vs) \\<and>\n                                    inres (fS x2) s'))", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma xf_rel_RELATES[refine_dref_RELATES]: \"RELATES xf_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RELATES xf_rel", "by (auto simp: RELATES_def)"], ["", "lemma discharge2_refine[refine]:     \n  assumes A: \"((x,cf),f) \\<in> xf_rel\"\n  assumes AM: \"(am,adjacent_nodes)\\<in>nat_rel\\<rightarrow>\\<langle>nat_rel\\<rangle>list_set_rel\"\n  assumes [simplified,simp]: \"(li,l)\\<in>Id\" \"(ui,u)\\<in>Id\"\n  assumes NR: \"(ni,n)\\<in>nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel\"  \n  shows \"discharge2 am x cf li ni ui \n    \\<le> \\<Down>(xf_rel \\<times>\\<^sub>r Id \\<times>\\<^sub>r (nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel)) (discharge f l n u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. discharge2 am x cf li ni ui\n    \\<le> \\<Down>\n           (xf_rel \\<times>\\<^sub>r\n            Id \\<times>\\<^sub>r\n            (nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel))\n           (discharge f l n u)", "unfolding discharge2_def discharge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. assert (ui \\<in> V) \\<bind>\n    (\\<lambda>_.\n        monadic_WHILEIT (\\<lambda>_. True)\n         (\\<lambda>((x, cf), l, n).\n             x_get x ui \\<bind> (\\<lambda>xu. return (xu \\<noteq> 0)))\n         (\\<lambda>((x, cf), l, n).\n             n_at_end n ui \\<bind>\n             (\\<lambda>at_end.\n                 if at_end\n                 then relabel2 am cf l ui \\<bind>\n                      (\\<lambda>l.\n                          n_reset am n ui \\<bind>\n                          (\\<lambda>n. return ((x, cf), l, n)))\n                 else n_get_hd n ui \\<bind>\n                      (\\<lambda>v.\n                          cf_get cf (ui, v) \\<bind>\n                          (\\<lambda>cfuv.\n                              l_get l ui \\<bind>\n                              (\\<lambda>lu.\n                                  l_get l v \\<bind>\n                                  (\\<lambda>lv.\nif cfuv \\<noteq> 0 \\<and> lu = lv + 1\nthen push2 x cf (ui, v) \\<bind> (\\<lambda>(x, cf). return ((x, cf), l, n))\nelse n_move_next n ui \\<bind> (\\<lambda>n. return ((x, cf), l, n))))))))\n         ((x, cf), li, ni))\n    \\<le> \\<Down>\n           (xf_rel \\<times>\\<^sub>r\n            Id \\<times>\\<^sub>r\n            (nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel))\n           (assert (u \\<in> V - {s, t}) \\<bind>\n            (\\<lambda>_.\n                while\\<^sub>T (\\<lambda>(f, l, n). excess f u \\<noteq> 0)\n                 (\\<lambda>(f, l, n).\n                     (select v. v \\<in> n u) \\<bind>\n                     (\\<lambda>v.\n                         case v of\n                         None \\<Rightarrow>\n                           relabel f l u \\<bind>\n                           (\\<lambda>l.\n                               return (f, l, n(u := adjacent_nodes u)))\n                         | Some v \\<Rightarrow>\n                             assert\n                              (v \\<in> V \\<and>\n                               (u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n                             (\\<lambda>_.\n                                 if (u, v) \\<in> cfE_of f \\<and>\n                                    l u = l v + 1\n                                 then push f l (u, v) \\<bind>\n(\\<lambda>f. return (f, l, n))\n                                 else assert\n ((u, v) \\<notin> adm_edges f l) \\<bind>\n(\\<lambda>_. return (f, l, n(u := n u - {v}))))))\n                 (f, l, n)))", "apply (rewrite in \"monadic_WHILEIT _ _ \\<hole> _\" vcg_intro_frame)"], ["proof (prove)\ngoal (1 subgoal):\n 1. assert (ui \\<in> V) \\<bind>\n    (\\<lambda>_.\n        monadic_WHILEIT (\\<lambda>_. True)\n         (\\<lambda>((x, cf), l, n).\n             x_get x ui \\<bind> (\\<lambda>xu. return (xu \\<noteq> 0)))\n         (\\<lambda>((x, cf), l, n).\n             VCG_FRAME\n              (n_at_end n ui \\<bind>\n               (\\<lambda>at_end.\n                   if at_end\n                   then relabel2 am cf l ui \\<bind>\n                        (\\<lambda>l.\n                            n_reset am n ui \\<bind>\n                            (\\<lambda>n. return ((x, cf), l, n)))\n                   else n_get_hd n ui \\<bind>\n                        (\\<lambda>v.\n                            cf_get cf (ui, v) \\<bind>\n                            (\\<lambda>cfuv.\n                                l_get l ui \\<bind>\n                                (\\<lambda>lu.\n                                    l_get l v \\<bind>\n                                    (\\<lambda>lv.\n  if cfuv \\<noteq> 0 \\<and> lu = lv + 1\n  then push2 x cf (ui, v) \\<bind> (\\<lambda>(x, cf). return ((x, cf), l, n))\n  else n_move_next n ui \\<bind> (\\<lambda>n. return ((x, cf), l, n)))))))))\n         ((x, cf), li, ni))\n    \\<le> \\<Down>\n           (xf_rel \\<times>\\<^sub>r\n            Id \\<times>\\<^sub>r\n            (nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel))\n           (assert (u \\<in> V - {s, t}) \\<bind>\n            (\\<lambda>_.\n                while\\<^sub>T (\\<lambda>(f, l, n). excess f u \\<noteq> 0)\n                 (\\<lambda>(f, l, n).\n                     (select v. v \\<in> n u) \\<bind>\n                     (\\<lambda>v.\n                         case v of\n                         None \\<Rightarrow>\n                           relabel f l u \\<bind>\n                           (\\<lambda>l.\n                               return (f, l, n(u := adjacent_nodes u)))\n                         | Some v \\<Rightarrow>\n                             assert\n                              (v \\<in> V \\<and>\n                               (u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n                             (\\<lambda>_.\n                                 if (u, v) \\<in> cfE_of f \\<and>\n                                    l u = l v + 1\n                                 then push f l (u, v) \\<bind>\n(\\<lambda>f. return (f, l, n))\n                                 else assert\n ((u, v) \\<notin> adm_edges f l) \\<bind>\n(\\<lambda>_. return (f, l, n(u := n u - {v}))))))\n                 (f, l, n)))", "apply refine_rcg"], ["proof (prove)\ngoal (4 subgoals):\n 1. u \\<in> V - {s, t} \\<Longrightarrow> ui \\<in> V\n 2. \\<lbrakk>u \\<in> V - {s, t}; ui \\<in> V\\<rbrakk>\n    \\<Longrightarrow> (((x, cf), li, ni), f, l, n)\n                      \\<in> xf_rel \\<times>\\<^sub>r\n                            Id \\<times>\\<^sub>r\n                            (nat_rel \\<rightarrow>\n                             \\<langle>nat_rel\\<rangle>list_set_rel)\n 3. \\<And>s' sa x1 x2 x1a x2a x1b x1c x2b x2c x1d x2d.\n       \\<lbrakk>u \\<in> V - {s, t}; ui \\<in> V;\n        (s', sa)\n        \\<in> xf_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              (nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel);\n        x2 = (x1a, x2a); sa = (x1, x2); x1b = (x1c, x2b); x2c = (x1d, x2d);\n        s' = (x1b, x2c)\\<rbrakk>\n       \\<Longrightarrow> x_get x1c ui \\<bind>\n                         (\\<lambda>xu. return (xu \\<noteq> 0))\n                         \\<le> (spec r. r = (excess x1 u \\<noteq> 0))\n 4. \\<And>s' sa x1 x2 x1a x2a x1b x1c x2b x2c x1d x2d.\n       \\<lbrakk>u \\<in> V - {s, t}; ui \\<in> V;\n        (s', sa)\n        \\<in> xf_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              (nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel);\n        case sa of (f, l, n) \\<Rightarrow> excess f u \\<noteq> 0;\n        x2 = (x1a, x2a); sa = (x1, x2); x1b = (x1c, x2b); x2c = (x1d, x2d);\n        s' = (x1b, x2c)\\<rbrakk>\n       \\<Longrightarrow> VCG_FRAME\n                          (n_at_end x2d ui \\<bind>\n                           (\\<lambda>at_end.\n                               if at_end\n                               then relabel2 am x2b x1d ui \\<bind>\n                                    (\\<lambda>l.\n  n_reset am x2d ui \\<bind> (\\<lambda>n. return ((x1c, x2b), l, n)))\n                               else n_get_hd x2d ui \\<bind>\n                                    (\\<lambda>v.\n  cf_get x2b (ui, v) \\<bind>\n  (\\<lambda>cfuv.\n      l_get x1d ui \\<bind>\n      (\\<lambda>lu.\n          l_get x1d v \\<bind>\n          (\\<lambda>lv.\n              if cfuv \\<noteq> 0 \\<and> lu = lv + 1\n              then push2 x1c x2b (ui, v) \\<bind>\n                   (\\<lambda>(x, cf). return ((x, cf), x1d, x2d))\n              else n_move_next x2d ui \\<bind>\n                   (\\<lambda>n. return ((x1c, x2b), x1d, n))))))))\n                         \\<le> \\<Down>\n                                (xf_rel \\<times>\\<^sub>r\n                                 Id \\<times>\\<^sub>r\n                                 (nat_rel \\<rightarrow>\n                                  \\<langle>nat_rel\\<rangle>list_set_rel))\n                                ((select v. v \\<in> x2a u) \\<bind>\n                                 (\\<lambda>v.\n                                     case v of\n                                     None \\<Rightarrow>\n relabel x1 x1a u \\<bind>\n (\\<lambda>l. return (x1, l, x2a(u := adjacent_nodes u)))\n                                     | Some v \\<Rightarrow>\n   assert (v \\<in> V \\<and> (u, v) \\<in> E \\<union> E\\<inverse>) \\<bind>\n   (\\<lambda>_.\n       if (u, v) \\<in> cfE_of x1 \\<and> x1a u = x1a v + 1\n       then push x1 x1a (u, v) \\<bind> (\\<lambda>f. return (f, x1a, x2a))\n       else assert ((u, v) \\<notin> adm_edges x1 x1a) \\<bind>\n            (\\<lambda>_. return (x1, x1a, x2a(u := x2a u - {v}))))))", "apply (vc_solve simp: A NR)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2a x1c x2b x2d.\n       \\<lbrakk>u \\<in> V; ((x1c, x2b), x1) \\<in> xf_rel;\n        (x2d, x2a)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        u \\<noteq> s; u \\<noteq> t\\<rbrakk>\n       \\<Longrightarrow> x_get x1c u \\<bind>\n                         (\\<lambda>xu. return (xu \\<noteq> 0))\n                         \\<le> RES {excess x1 u \\<noteq> 0}\n 2. \\<And>x1 x1a x2a x1c x2b x2d.\n       \\<lbrakk>excess x1 u \\<noteq> 0; u \\<in> V;\n        ((x1c, x2b), x1) \\<in> xf_rel;\n        (x2d, x2a)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        u \\<noteq> s; u \\<noteq> t\\<rbrakk>\n       \\<Longrightarrow> VCG_FRAME\n                          (n_at_end x2d ui \\<bind>\n                           (\\<lambda>at_end.\n                               if at_end\n                               then relabel2 am x2b x1a ui \\<bind>\n                                    (\\<lambda>l.\n  n_reset am x2d ui \\<bind> (\\<lambda>n. return ((x1c, x2b), l, n)))\n                               else n_get_hd x2d ui \\<bind>\n                                    (\\<lambda>v.\n  cf_get x2b (ui, v) \\<bind>\n  (\\<lambda>cfuv.\n      l_get x1a ui \\<bind>\n      (\\<lambda>lu.\n          l_get x1a v \\<bind>\n          (\\<lambda>lv.\n              if cfuv \\<noteq> 0 \\<and> lu = lv + 1\n              then push2 x1c x2b (ui, v) \\<bind>\n                   (\\<lambda>(x, cf). return ((x, cf), x1a, x2d))\n              else n_move_next x2d ui \\<bind>\n                   (\\<lambda>n. return ((x1c, x2b), x1a, n))))))))\n                         \\<le> \\<Down>\n                                (xf_rel \\<times>\\<^sub>r\n                                 Id \\<times>\\<^sub>r\n                                 (nat_rel \\<rightarrow>\n                                  \\<langle>nat_rel\\<rangle>list_set_rel))\n                                ((select v. v \\<in> x2a u) \\<bind>\n                                 case_option\n                                  (relabel x1 x1a u \\<bind>\n                                   (\\<lambda>l.\n return (x1, l, x2a(u := adjacent_nodes u))))\n                                  (\\<lambda>v.\nassert (v \\<in> V \\<and> ((u, v) \\<in> E \\<or> (v, u) \\<in> E)) \\<bind>\n(\\<lambda>_.\n    if (u, v) \\<in> cfE_of x1 \\<and> x1a u = Suc (x1a v)\n    then push x1 x1a (u, v) \\<bind> (\\<lambda>f. return (f, x1a, x2a))\n    else assert ((u, v) \\<notin> adm_edges x1 x1a) \\<bind>\n         (\\<lambda>_. return (x1, x1a, x2a(u := x2a u - {v}))))))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> V; ((x1c_, x2b_), x1_) \\<in> xf_rel;\n     (x2d_, x2a_)\n     \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n     u \\<noteq> s; u \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> x_get x1c_ u \\<bind>\n                      (\\<lambda>xu. return (xu \\<noteq> 0))\n                      \\<le> RES {excess x1_ u \\<noteq> 0}", "by (simp add: xf_rel_def x_get_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x1a x2a x1c x2b x2d.\n       \\<lbrakk>excess x1 u \\<noteq> 0; u \\<in> V;\n        ((x1c, x2b), x1) \\<in> xf_rel;\n        (x2d, x2a)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        u \\<noteq> s; u \\<noteq> t\\<rbrakk>\n       \\<Longrightarrow> VCG_FRAME\n                          (n_at_end x2d ui \\<bind>\n                           (\\<lambda>at_end.\n                               if at_end\n                               then relabel2 am x2b x1a ui \\<bind>\n                                    (\\<lambda>l.\n  n_reset am x2d ui \\<bind> (\\<lambda>n. return ((x1c, x2b), l, n)))\n                               else n_get_hd x2d ui \\<bind>\n                                    (\\<lambda>v.\n  cf_get x2b (ui, v) \\<bind>\n  (\\<lambda>cfuv.\n      l_get x1a ui \\<bind>\n      (\\<lambda>lu.\n          l_get x1a v \\<bind>\n          (\\<lambda>lv.\n              if cfuv \\<noteq> 0 \\<and> lu = lv + 1\n              then push2 x1c x2b (ui, v) \\<bind>\n                   (\\<lambda>(x, cf). return ((x, cf), x1a, x2d))\n              else n_move_next x2d ui \\<bind>\n                   (\\<lambda>n. return ((x1c, x2b), x1a, n))))))))\n                         \\<le> \\<Down>\n                                (xf_rel \\<times>\\<^sub>r\n                                 Id \\<times>\\<^sub>r\n                                 (nat_rel \\<rightarrow>\n                                  \\<langle>nat_rel\\<rangle>list_set_rel))\n                                ((select v. v \\<in> x2a u) \\<bind>\n                                 case_option\n                                  (relabel x1 x1a u \\<bind>\n                                   (\\<lambda>l.\n return (x1, l, x2a(u := adjacent_nodes u))))\n                                  (\\<lambda>v.\nassert (v \\<in> V \\<and> ((u, v) \\<in> E \\<or> (v, u) \\<in> E)) \\<bind>\n(\\<lambda>_.\n    if (u, v) \\<in> cfE_of x1 \\<and> x1a u = Suc (x1a v)\n    then push x1 x1a (u, v) \\<bind> (\\<lambda>f. return (f, x1a, x2a))\n    else assert ((u, v) \\<notin> adm_edges x1 x1a) \\<bind>\n         (\\<lambda>_. return (x1, x1a, x2a(u := x2a u - {v}))))))", "subgoal for f l n x cf ni"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>excess f u \\<noteq> 0; u \\<in> V; ((x, cf), f) \\<in> xf_rel;\n     (ni, n)\n     \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n     u \\<noteq> s; u \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> VCG_FRAME\n                       (n_at_end ni ui \\<bind>\n                        (\\<lambda>at_end.\n                            if at_end\n                            then relabel2 am cf l ui \\<bind>\n                                 (\\<lambda>l.\n                                     n_reset am ni ui \\<bind>\n                                     (\\<lambda>n. return ((x, cf), l, n)))\n                            else n_get_hd ni ui \\<bind>\n                                 (\\<lambda>v.\n                                     cf_get cf (ui, v) \\<bind>\n                                     (\\<lambda>cfuv.\n   l_get l ui \\<bind>\n   (\\<lambda>lu.\n       l_get l v \\<bind>\n       (\\<lambda>lv.\n           if cfuv \\<noteq> 0 \\<and> lu = lv + 1\n           then push2 x cf (ui, v) \\<bind>\n                (\\<lambda>(x, cf). return ((x, cf), l, ni))\n           else n_move_next ni ui \\<bind>\n                (\\<lambda>n. return ((x, cf), l, n))))))))\n                      \\<le> \\<Down>\n                             (xf_rel \\<times>\\<^sub>r\n                              Id \\<times>\\<^sub>r\n                              (nat_rel \\<rightarrow>\n                               \\<langle>nat_rel\\<rangle>list_set_rel))\n                             ((select v. v \\<in> n u) \\<bind>\n                              case_option\n                               (relabel f l u \\<bind>\n                                (\\<lambda>l.\n                                    return\n                                     (f, l, n(u := adjacent_nodes u))))\n                               (\\<lambda>v.\n                                   assert\n                                    (v \\<in> V \\<and>\n                                     ((u, v) \\<in> E \\<or>\n(v, u) \\<in> E)) \\<bind>\n                                   (\\<lambda>_.\n if (u, v) \\<in> cfE_of f \\<and> l u = Suc (l v)\n then push f l (u, v) \\<bind> (\\<lambda>f. return (f, l, n))\n else assert ((u, v) \\<notin> adm_edges f l) \\<bind>\n      (\\<lambda>_. return (f, l, n(u := n u - {v}))))))", "apply (subst vcg_rem_frame)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>excess f u \\<noteq> 0; u \\<in> V; ((x, cf), f) \\<in> xf_rel;\n     (ni, n)\n     \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n     u \\<noteq> s; u \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> n_at_end ni ui \\<bind>\n                      (\\<lambda>at_end.\n                          if at_end\n                          then relabel2 am cf l ui \\<bind>\n                               (\\<lambda>l.\n                                   n_reset am ni ui \\<bind>\n                                   (\\<lambda>n. return ((x, cf), l, n)))\n                          else n_get_hd ni ui \\<bind>\n                               (\\<lambda>v.\n                                   cf_get cf (ui, v) \\<bind>\n                                   (\\<lambda>cfuv.\n l_get l ui \\<bind>\n (\\<lambda>lu.\n     l_get l v \\<bind>\n     (\\<lambda>lv.\n         if cfuv \\<noteq> 0 \\<and> lu = lv + 1\n         then push2 x cf (ui, v) \\<bind>\n              (\\<lambda>(x, cf). return ((x, cf), l, ni))\n         else n_move_next ni ui \\<bind>\n              (\\<lambda>n. return ((x, cf), l, n)))))))\n                      \\<le> \\<Down>\n                             (xf_rel \\<times>\\<^sub>r\n                              Id \\<times>\\<^sub>r\n                              (nat_rel \\<rightarrow>\n                               \\<langle>nat_rel\\<rangle>list_set_rel))\n                             ((select v. v \\<in> n u) \\<bind>\n                              case_option\n                               (relabel f l u \\<bind>\n                                (\\<lambda>l.\n                                    return\n                                     (f, l, n(u := adjacent_nodes u))))\n                               (\\<lambda>v.\n                                   assert\n                                    (v \\<in> V \\<and>\n                                     ((u, v) \\<in> E \\<or>\n(v, u) \\<in> E)) \\<bind>\n                                   (\\<lambda>_.\n if (u, v) \\<in> cfE_of f \\<and> l u = Suc (l v)\n then push f l (u, v) \\<bind> (\\<lambda>f. return (f, l, n))\n else assert ((u, v) \\<notin> adm_edges f l) \\<bind>\n      (\\<lambda>_. return (f, l, n(u := n u - {v}))))))\n 2. \\<lbrakk>excess f u \\<noteq> 0; u \\<in> V; ((x, cf), f) \\<in> xf_rel;\n     (ni, n)\n     \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n     u \\<noteq> s; u \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> True", "unfolding n_reset_def cf_get_def l_get_def n_move_next_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>excess f u \\<noteq> 0; u \\<in> V; ((x, cf), f) \\<in> xf_rel;\n     (ni, n)\n     \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n     u \\<noteq> s; u \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> n_at_end ni ui \\<bind>\n                      (\\<lambda>at_end.\n                          if at_end\n                          then relabel2 am cf l ui \\<bind>\n                               (\\<lambda>l.\n                                   assert (ui \\<in> V - {s, t}) \\<bind>\n                                   (\\<lambda>_.\n return (ni(ui := am ui))) \\<bind>\n                                   (\\<lambda>n. return ((x, cf), l, n)))\n                          else n_get_hd ni ui \\<bind>\n                               (\\<lambda>v.\n                                   assert\n                                    ((ui, v)\n                                     \\<in> E \\<union> E\\<inverse>) \\<bind>\n                                   (\\<lambda>_. return (cf (ui, v))) \\<bind>\n                                   (\\<lambda>cfuv.\n assert (ui \\<in> V) \\<bind> (\\<lambda>_. return (l ui)) \\<bind>\n (\\<lambda>lu.\n     assert (v \\<in> V) \\<bind> (\\<lambda>_. return (l v)) \\<bind>\n     (\\<lambda>lv.\n         if cfuv \\<noteq> 0 \\<and> lu = lv + 1\n         then push2 x cf (ui, v) \\<bind>\n              (\\<lambda>(x, cf). return ((x, cf), l, ni))\n         else assert (ui \\<in> V - {s, t} \\<and> ni ui \\<noteq> []) \\<bind>\n              (\\<lambda>_. return (map_entry ui tl ni)) \\<bind>\n              (\\<lambda>n. return ((x, cf), l, n)))))))\n                      \\<le> \\<Down>\n                             (xf_rel \\<times>\\<^sub>r\n                              Id \\<times>\\<^sub>r\n                              (nat_rel \\<rightarrow>\n                               \\<langle>nat_rel\\<rangle>list_set_rel))\n                             ((select v. v \\<in> n u) \\<bind>\n                              case_option\n                               (relabel f l u \\<bind>\n                                (\\<lambda>l.\n                                    return\n                                     (f, l, n(u := adjacent_nodes u))))\n                               (\\<lambda>v.\n                                   assert\n                                    (v \\<in> V \\<and>\n                                     ((u, v) \\<in> E \\<or>\n(v, u) \\<in> E)) \\<bind>\n                                   (\\<lambda>_.\n if (u, v) \\<in> cfE_of f \\<and> l u = Suc (l v)\n then push f l (u, v) \\<bind> (\\<lambda>f. return (f, l, n))\n else assert ((u, v) \\<notin> adm_edges f l) \\<bind>\n      (\\<lambda>_. return (f, l, n(u := n u - {v}))))))\n 2. \\<lbrakk>excess f u \\<noteq> 0; u \\<in> V; ((x, cf), f) \\<in> xf_rel;\n     (ni, n)\n     \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n     u \\<noteq> s; u \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> True", "apply (simp only: nres_monad_laws)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>excess f u \\<noteq> 0; u \\<in> V; ((x, cf), f) \\<in> xf_rel;\n     (ni, n)\n     \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n     u \\<noteq> s; u \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> n_at_end ni ui \\<bind>\n                      (\\<lambda>at_end.\n                          if at_end\n                          then relabel2 am cf l ui \\<bind>\n                               (\\<lambda>l.\n                                   assert (ui \\<in> V - {s, t}) \\<bind>\n                                   (\\<lambda>x.\n return ((x, cf), l, ni(ui := am ui))))\n                          else n_get_hd ni ui \\<bind>\n                               (\\<lambda>v.\n                                   assert\n                                    ((ui, v)\n                                     \\<in> E \\<union> E\\<inverse>) \\<bind>\n                                   (\\<lambda>x.\n assert (ui \\<in> V) \\<bind>\n (\\<lambda>x.\n     assert (v \\<in> V) \\<bind>\n     (\\<lambda>x.\n         if cf (ui, v) \\<noteq> 0 \\<and> l ui = l v + 1\n         then push2 x cf (ui, v) \\<bind>\n              (\\<lambda>(x, cf). return ((x, cf), l, ni))\n         else assert (ui \\<in> V - {s, t} \\<and> ni ui \\<noteq> []) \\<bind>\n              (\\<lambda>x. return ((x, cf), l, map_entry ui tl ni)))))))\n                      \\<le> \\<Down>\n                             (xf_rel \\<times>\\<^sub>r\n                              Id \\<times>\\<^sub>r\n                              (nat_rel \\<rightarrow>\n                               \\<langle>nat_rel\\<rangle>list_set_rel))\n                             ((select v. v \\<in> n u) \\<bind>\n                              case_option\n                               (relabel f l u \\<bind>\n                                (\\<lambda>l.\n                                    return\n                                     (f, l, n(u := adjacent_nodes u))))\n                               (\\<lambda>v.\n                                   assert\n                                    (v \\<in> V \\<and>\n                                     ((u, v) \\<in> E \\<or>\n(v, u) \\<in> E)) \\<bind>\n                                   (\\<lambda>_.\n if (u, v) \\<in> cfE_of f \\<and> l u = Suc (l v)\n then push f l (u, v) \\<bind> (\\<lambda>f. return (f, l, n))\n else assert ((u, v) \\<notin> adm_edges f l) \\<bind>\n      (\\<lambda>_. return (f, l, n(u := n u - {v}))))))\n 2. \\<lbrakk>excess f u \\<noteq> 0; u \\<in> V; ((x, cf), f) \\<in> xf_rel;\n     (ni, n)\n     \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n     u \\<noteq> s; u \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> True", "apply (rule discharge_structure_refine_aux; (refine_vcg AM)?; (assumption)?)"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>excess f u \\<noteq> 0; u \\<in> V; ((x, cf), f) \\<in> xf_rel;\n        (ni, n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        u \\<noteq> s; u \\<noteq> t; (a, a') \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (ni a, n a')\n                         \\<in> \\<langle>nat_rel\\<rangle>list_set_rel\n 2. \\<lbrakk>excess f u \\<noteq> 0; u \\<in> V; ((x, cf), f) \\<in> xf_rel;\n     (ni, n)\n     \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n     u \\<noteq> s; u \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> (ui, u) \\<in> nat_rel\n 3. \\<lbrakk>excess f u \\<noteq> 0; u \\<in> V; ((x, cf), f) \\<in> xf_rel;\n     (ni, n)\n     \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n     u \\<noteq> s; u \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> (l, l) \\<in> Id\n 4. \\<lbrakk>excess f u \\<noteq> 0; u \\<in> V; ((x, cf), f) \\<in> xf_rel;\n     (ni, n)\n     \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n     u \\<noteq> s; u \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> (ui, u) \\<in> nat_rel\n 5. \\<And>l la.\n       \\<lbrakk>excess f u \\<noteq> 0; u \\<in> V; ((x, cf), f) \\<in> xf_rel;\n        (ni, n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        u \\<noteq> s; u \\<noteq> t; (l, la) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> ui \\<in> V - {s, t}\n 6. \\<And>l la.\n       \\<lbrakk>excess f u \\<noteq> 0; u \\<in> V; ((x, cf), f) \\<in> xf_rel;\n        (ni, n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        u \\<noteq> s; u \\<noteq> t; (l, la) \\<in> Id;\n        ui \\<in> V - {s, t}\\<rbrakk>\n       \\<Longrightarrow> (((x, cf), l, ni(ui := am ui)), f, la, n\n                          (u := adjacent_nodes u))\n                         \\<in> xf_rel \\<times>\\<^sub>r\n                               Id \\<times>\\<^sub>r\n                               (nat_rel \\<rightarrow>\n                                \\<langle>nat_rel\\<rangle>list_set_rel)\n 7. \\<lbrakk>excess f u \\<noteq> 0; u \\<in> V; ((x, cf), f) \\<in> xf_rel;\n     (ni, n)\n     \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n     u \\<noteq> s; u \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> u \\<in> V - {s, t}\n 8. \\<And>v vi vs.\n       \\<lbrakk>excess f u \\<noteq> 0; u \\<in> V; ((x, cf), f) \\<in> xf_rel;\n        (ni, n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        u \\<noteq> s; u \\<noteq> t; (vi, v) \\<in> nat_rel; v \\<in> n u;\n        ni u = v # vs;\n        (v # vs, n u) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel;\n        v \\<in> V \\<and> ((u, v) \\<in> E \\<or> (v, u) \\<in> E)\\<rbrakk>\n       \\<Longrightarrow> (ui, vi) \\<in> E \\<union> E\\<inverse>\n 9. \\<And>v vi vs.\n       \\<lbrakk>excess f u \\<noteq> 0; u \\<in> V; ((x, cf), f) \\<in> xf_rel;\n        (ni, n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        u \\<noteq> s; u \\<noteq> t; (vi, v) \\<in> nat_rel; v \\<in> n u;\n        ni u = v # vs;\n        (v # vs, n u) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel;\n        v \\<in> V \\<and> ((u, v) \\<in> E \\<or> (v, u) \\<in> E);\n        (ui, vi) \\<in> E \\<union> E\\<inverse>\\<rbrakk>\n       \\<Longrightarrow> ui \\<in> V\n 10. \\<And>v vi vs.\n        \\<lbrakk>excess f u \\<noteq> 0; u \\<in> V;\n         ((x, cf), f) \\<in> xf_rel;\n         (ni, n)\n         \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n         u \\<noteq> s; u \\<noteq> t; (vi, v) \\<in> nat_rel; v \\<in> n u;\n         ni u = v # vs;\n         (v # vs, n u) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel;\n         v \\<in> V \\<and> ((u, v) \\<in> E \\<or> (v, u) \\<in> E);\n         (ui, vi) \\<in> E \\<union> E\\<inverse>; ui \\<in> V\\<rbrakk>\n        \\<Longrightarrow> vi \\<in> V\nA total of 17 subgoals...", "apply (vc_solve simp: fun_relD fun_relD[OF AM])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v vs.\n       \\<lbrakk>excess f u \\<noteq> 0; u \\<in> V; ((x, cf), f) \\<in> xf_rel;\n        (ni, n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        u \\<noteq> s; u \\<noteq> t; v \\<in> n u; ni u = v # vs;\n        (v # vs, n u) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel;\n        v \\<in> V; (u, v) \\<in> E \\<or> (v, u) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> (cf (u, v) \\<noteq> 0 \\<and> l u = Suc (l v)) =\n                         ((u, v) \\<in> cfE_of f \\<and> l u = Suc (l v))\n 2. \\<And>v vs.\n       \\<lbrakk>excess f u \\<noteq> 0; u \\<in> V; ((x, cf), f) \\<in> xf_rel;\n        (ni, n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        u \\<noteq> s; u \\<noteq> t; v \\<in> n u; ni u = v # vs;\n        (v # vs, n u) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel;\n        cf (u, v) = 0 \\<or> l u \\<noteq> Suc (l v);\n        (u, v) \\<in> cfE_of f \\<longrightarrow> l u \\<noteq> Suc (l v);\n        (u, v) \\<notin> adm_edges f l; v \\<in> V;\n        (u, v) \\<in> E \\<or> (v, u) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> (vs, n u - {v})\n                         \\<in> \\<langle>nat_rel\\<rangle>list_set_rel", "subgoal for v vs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>excess f u \\<noteq> 0; u \\<in> V; ((x, cf), f) \\<in> xf_rel;\n     (ni, n)\n     \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n     u \\<noteq> s; u \\<noteq> t; v \\<in> n u; ni u = v # vs;\n     (v # vs, n u) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel; v \\<in> V;\n     (u, v) \\<in> E \\<or> (v, u) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> (cf (u, v) \\<noteq> 0 \\<and> l u = Suc (l v)) =\n                      ((u, v) \\<in> cfE_of f \\<and> l u = Suc (l v))", "unfolding xf_rel_def Graph.E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>excess f u \\<noteq> 0; u \\<in> V;\n     ((x, cf), f) \\<in> {((excess f, cf_of f), f) |f. True};\n     (ni, n)\n     \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n     u \\<noteq> s; u \\<noteq> t; v \\<in> n u; ni u = v # vs;\n     (v # vs, n u) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel; v \\<in> V;\n     (u, v) \\<in> {(u, v). c (u, v) \\<noteq> 0} \\<or>\n     (v, u) \\<in> {(u, v). c (u, v) \\<noteq> 0}\\<rbrakk>\n    \\<Longrightarrow> (cf (u, v) \\<noteq> 0 \\<and> l u = Suc (l v)) =\n                      ((u, v)\n                       \\<in> {(u, v). cf_of f (u, v) \\<noteq> 0} \\<and>\n                       l u = Suc (l v))", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v vs.\n       \\<lbrakk>excess f u \\<noteq> 0; u \\<in> V; ((x, cf), f) \\<in> xf_rel;\n        (ni, n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        u \\<noteq> s; u \\<noteq> t; v \\<in> n u; ni u = v # vs;\n        (v # vs, n u) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel;\n        cf (u, v) = 0 \\<or> l u \\<noteq> Suc (l v);\n        (u, v) \\<in> cfE_of f \\<longrightarrow> l u \\<noteq> Suc (l v);\n        (u, v) \\<notin> adm_edges f l; v \\<in> V;\n        (u, v) \\<in> E \\<or> (v, u) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> (vs, n u - {v})\n                         \\<in> \\<langle>nat_rel\\<rangle>list_set_rel", "subgoal for v vs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>excess f u \\<noteq> 0; u \\<in> V; ((x, cf), f) \\<in> xf_rel;\n     (ni, n)\n     \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n     u \\<noteq> s; u \\<noteq> t; v \\<in> n u; ni u = v # vs;\n     (v # vs, n u) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel;\n     cf (u, v) = 0 \\<or> l u \\<noteq> Suc (l v);\n     (u, v) \\<in> cfE_of f \\<longrightarrow> l u \\<noteq> Suc (l v);\n     (u, v) \\<notin> adm_edges f l; v \\<in> V;\n     (u, v) \\<in> E \\<or> (v, u) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> (vs, n u - {v})\n                      \\<in> \\<langle>nat_rel\\<rangle>list_set_rel", "by (auto simp: list_set_rel_def in_br_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open> Initialization of Queue \\<close>"], ["", "lemma V_is_adj_nodes: \"V = { v . adjacent_nodes v \\<noteq> {} }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V = {v. adjacent_nodes v \\<noteq> {}}", "unfolding V_def adjacent_nodes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {u. \\<exists>v. (u, v) \\<in> E \\<or> (v, u) \\<in> E} =\n    {v. E `` {v} \\<union> E\\<inverse> `` {v} \\<noteq> {}}", "by auto"], ["", "definition \"init_CQ am \\<equiv> do {\n  let cardV=0;\n  let Q=[];\n  nfoldli [0..<N] (\\<lambda>_. True) (\\<lambda>v (cardV,Q). do {\n    assert (v<N);\n    inV \\<leftarrow> am_is_in_V am v;\n    if inV then do {\n      let cardV = cardV + 1;\n      if v\\<noteq>s \\<and> v\\<noteq>t then\n        return (cardV,v#Q)\n      else \n        return (cardV,Q)\n    } else\n      return (cardV,Q)\n  }) (cardV,Q)\n}\""], ["", "lemma init_CQ_correct[THEN order_trans, refine_vcg]:\n  assumes AM: \"is_adj_map am\"  \n  shows \"init_CQ am \\<le> SPEC (\\<lambda>(C,Q). C = card V \\<and> distinct Q \\<and> set Q = V-{s,t})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init_CQ am\n    \\<le> SPEC\n           (\\<lambda>(C, Q).\n               C = card V \\<and> distinct Q \\<and> set Q = V - {s, t})", "unfolding init_CQ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let cardV = 0; Q = []\n     in nfoldli [0..<N] (\\<lambda>_. True)\n         (\\<lambda>v (cardV, Q).\n             assert (v < N) \\<bind>\n             (\\<lambda>_.\n                 am_is_in_V am v \\<bind>\n                 (\\<lambda>inV.\n                     if inV\n                     then let cardV = cardV + 1\n                          in if v \\<noteq> s \\<and> v \\<noteq> t\n                             then return (cardV, v # Q)\n                             else return (cardV, Q)\n                     else return (cardV, Q))))\n         (cardV, Q))\n    \\<le> SPEC\n           (\\<lambda>(C, Q).\n               C = card V \\<and> distinct Q \\<and> set Q = V - {s, t})", "apply (refine_vcg \n      nfoldli_rule[where \n        I=\"\\<lambda>l1 _ (C,Q). \n             C = card (V\\<inter>set l1) \\<and> distinct Q \\<and> set Q = (V\\<inter>set l1)-{s,t} \"]\n      )"], ["proof (prove)\ngoal (20 subgoals):\n 1. \\<And>x1 x2.\n       (0, []) = (x1, x2) \\<Longrightarrow> x1 = card (V \\<inter> set [])\n 2. \\<And>x1 x2. (0, []) = (x1, x2) \\<Longrightarrow> distinct x2\n 3. \\<And>x1 x2.\n       (0, []) = (x1, x2) \\<Longrightarrow>\n       set x2 = V \\<inter> set [] - {s, t}\n 4. \\<And>x l1 l2 \\<sigma> a b.\n       \\<lbrakk>[0..<N] = l1 @ x # l2;\n        case \\<sigma> of\n        (C, Q) \\<Rightarrow>\n          C = card (V \\<inter> set l1) \\<and>\n          distinct Q \\<and> set Q = V \\<inter> set l1 - {s, t};\n        True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> x < N\n 5. \\<And>x l1 l2 \\<sigma> a b aa a'.\n       \\<lbrakk>[0..<N] = l1 @ x # l2;\n        case \\<sigma> of\n        (C, Q) \\<Rightarrow>\n          C = card (V \\<inter> set l1) \\<and>\n          distinct Q \\<and> set Q = V \\<inter> set l1 - {s, t};\n        True; \\<sigma> = (a, b); x < N; (aa, a') \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (am aa, adjacent_nodes a')\n                         \\<in> \\<langle>nat_rel\\<rangle>list_set_rel\n 6. \\<And>x l1 l2 \\<sigma> a b xa x1 x2.\n       \\<lbrakk>[0..<N] = l1 @ x # l2;\n        case \\<sigma> of\n        (C, Q) \\<Rightarrow>\n          C = card (V \\<inter> set l1) \\<and>\n          distinct Q \\<and> set Q = V \\<inter> set l1 - {s, t};\n        True; \\<sigma> = (a, b); x < N; xa = (x \\<in> V); xa;\n        x \\<noteq> s \\<and> x \\<noteq> t; (a + 1, x # b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 = card (V \\<inter> set (l1 @ [x]))\n 7. \\<And>x l1 l2 \\<sigma> a b xa x1 x2.\n       \\<lbrakk>[0..<N] = l1 @ x # l2;\n        case \\<sigma> of\n        (C, Q) \\<Rightarrow>\n          C = card (V \\<inter> set l1) \\<and>\n          distinct Q \\<and> set Q = V \\<inter> set l1 - {s, t};\n        True; \\<sigma> = (a, b); x < N; xa = (x \\<in> V); xa;\n        x \\<noteq> s \\<and> x \\<noteq> t; (a + 1, x # b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> distinct x2\n 8. \\<And>x l1 l2 \\<sigma> a b xa x1 x2.\n       \\<lbrakk>[0..<N] = l1 @ x # l2;\n        case \\<sigma> of\n        (C, Q) \\<Rightarrow>\n          C = card (V \\<inter> set l1) \\<and>\n          distinct Q \\<and> set Q = V \\<inter> set l1 - {s, t};\n        True; \\<sigma> = (a, b); x < N; xa = (x \\<in> V); xa;\n        x \\<noteq> s \\<and> x \\<noteq> t; (a + 1, x # b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> set x2 = V \\<inter> set (l1 @ [x]) - {s, t}\n 9. \\<And>x l1 l2 \\<sigma> a b xa x1 x2.\n       \\<lbrakk>[0..<N] = l1 @ x # l2;\n        case \\<sigma> of\n        (C, Q) \\<Rightarrow>\n          C = card (V \\<inter> set l1) \\<and>\n          distinct Q \\<and> set Q = V \\<inter> set l1 - {s, t};\n        True; \\<sigma> = (a, b); x < N; xa = (x \\<in> V); xa;\n        \\<not> (x \\<noteq> s \\<and> x \\<noteq> t);\n        (a + 1, b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 = card (V \\<inter> set (l1 @ [x]))\n 10. \\<And>x l1 l2 \\<sigma> a b xa x1 x2.\n        \\<lbrakk>[0..<N] = l1 @ x # l2;\n         case \\<sigma> of\n         (C, Q) \\<Rightarrow>\n           C = card (V \\<inter> set l1) \\<and>\n           distinct Q \\<and> set Q = V \\<inter> set l1 - {s, t};\n         True; \\<sigma> = (a, b); x < N; xa = (x \\<in> V); xa;\n         \\<not> (x \\<noteq> s \\<and> x \\<noteq> t);\n         (a + 1, b) = (x1, x2)\\<rbrakk>\n        \\<Longrightarrow> distinct x2\nA total of 20 subgoals...", "apply (clarsimp_all simp: am_to_adj_nodes_refine[OF AM])"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x l1 l2 ba.\n       \\<lbrakk>[0..<N] = l1 @ x # l2; distinct ba;\n        set ba = V \\<inter> set l1 - {s, t}\\<rbrakk>\n       \\<Longrightarrow> x < N\n 2. \\<And>x l1 l2 ba xa.\n       \\<lbrakk>[0..<N] = l1 @ x # l2; x \\<in> V; xa; distinct ba;\n        set ba = V \\<inter> set l1 - {s, t}; x \\<noteq> s;\n        x \\<noteq> t\\<rbrakk>\n       \\<Longrightarrow> Suc (card (V \\<inter> set l1)) =\n                         card (insert x (V \\<inter> set l1))\n 3. \\<And>x l1 l2 ba xa.\n       \\<lbrakk>[0..<N] = l1 @ x # l2; x \\<in> V; xa; distinct ba;\n        set ba = V \\<inter> set l1 - {s, t}; x \\<noteq> s; x \\<noteq> t;\n        x \\<in> set l1\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x l1 l2 ba xa.\n       \\<lbrakk>[0..<N] = l1 @ x # l2; x \\<in> V; xa; distinct ba;\n        set ba = V \\<inter> set l1 - {s, t}; x \\<noteq> s;\n        x \\<noteq> t\\<rbrakk>\n       \\<Longrightarrow> insert x (V \\<inter> set l1 - {s, t}) =\n                         insert x (V \\<inter> set l1) - {s, t}\n 5. \\<And>x l1 l2 ba xa.\n       \\<lbrakk>[0..<N] = l1 @ x # l2; x \\<in> V; xa; x = s \\<or> x = t;\n        distinct ba; set ba = V \\<inter> set l1 - {s, t}\\<rbrakk>\n       \\<Longrightarrow> Suc (card (V \\<inter> set l1)) =\n                         card (insert x (V \\<inter> set l1))\n 6. \\<And>x2.\n       \\<lbrakk>distinct x2; set x2 = V \\<inter> {0..<N} - {s, t}\\<rbrakk>\n       \\<Longrightarrow> card (V \\<inter> {0..<N}) = card V\n 7. \\<And>x2.\n       \\<lbrakk>distinct x2; set x2 = V \\<inter> {0..<N} - {s, t}\\<rbrakk>\n       \\<Longrightarrow> V \\<inter> {0..<N} - {s, t} = V - {s, t}", "using V_ss"], ["proof (prove)\nusing this:\n  V \\<subseteq> {0..<N}\n\ngoal (7 subgoals):\n 1. \\<And>x l1 l2 ba.\n       \\<lbrakk>[0..<N] = l1 @ x # l2; distinct ba;\n        set ba = V \\<inter> set l1 - {s, t}\\<rbrakk>\n       \\<Longrightarrow> x < N\n 2. \\<And>x l1 l2 ba xa.\n       \\<lbrakk>[0..<N] = l1 @ x # l2; x \\<in> V; xa; distinct ba;\n        set ba = V \\<inter> set l1 - {s, t}; x \\<noteq> s;\n        x \\<noteq> t\\<rbrakk>\n       \\<Longrightarrow> Suc (card (V \\<inter> set l1)) =\n                         card (insert x (V \\<inter> set l1))\n 3. \\<And>x l1 l2 ba xa.\n       \\<lbrakk>[0..<N] = l1 @ x # l2; x \\<in> V; xa; distinct ba;\n        set ba = V \\<inter> set l1 - {s, t}; x \\<noteq> s; x \\<noteq> t;\n        x \\<in> set l1\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x l1 l2 ba xa.\n       \\<lbrakk>[0..<N] = l1 @ x # l2; x \\<in> V; xa; distinct ba;\n        set ba = V \\<inter> set l1 - {s, t}; x \\<noteq> s;\n        x \\<noteq> t\\<rbrakk>\n       \\<Longrightarrow> insert x (V \\<inter> set l1 - {s, t}) =\n                         insert x (V \\<inter> set l1) - {s, t}\n 5. \\<And>x l1 l2 ba xa.\n       \\<lbrakk>[0..<N] = l1 @ x # l2; x \\<in> V; xa; x = s \\<or> x = t;\n        distinct ba; set ba = V \\<inter> set l1 - {s, t}\\<rbrakk>\n       \\<Longrightarrow> Suc (card (V \\<inter> set l1)) =\n                         card (insert x (V \\<inter> set l1))\n 6. \\<And>x2.\n       \\<lbrakk>distinct x2; set x2 = V \\<inter> {0..<N} - {s, t}\\<rbrakk>\n       \\<Longrightarrow> card (V \\<inter> {0..<N}) = card V\n 7. \\<And>x2.\n       \\<lbrakk>distinct x2; set x2 = V \\<inter> {0..<N} - {s, t}\\<rbrakk>\n       \\<Longrightarrow> V \\<inter> {0..<N} - {s, t} = V - {s, t}", "by (auto simp: upt_eq_lel_conv Int_absorb2)"], ["", "subsubsection \\<open>Main Algorithm\\<close>"], ["", "definition \"relabel_to_front2 am \\<equiv> do {\n  (cardV, L_right) \\<leftarrow> init_CQ am;\n\n  xcf \\<leftarrow> pp_init_xcf2 am;\n  l \\<leftarrow> l_init cardV;\n  n \\<leftarrow> n_init am;\n\n  let L_left=[];\n\n  ((x,cf),l,n,L_left,L_right) \\<leftarrow> while\\<^sub>T \n    (\\<lambda>((x,cf),l,n,L_left,L_right). L_right \\<noteq> []) \n    (\\<lambda>((x,cf),l,n,L_left,L_right). do {\n      assert (L_right \\<noteq> []);\n      let u = hd L_right;\n      old_lu \\<leftarrow> l_get l u;\n  \n      ((x,cf),l,n) \\<leftarrow> discharge2 am x cf l n u;\n  \n      lu \\<leftarrow> l_get l u;\n      if (lu \\<noteq> old_lu) then do {\n        \\<comment> \\<open>Move \\<open>u\\<close> to front of \\<open>l\\<close>, and restart scanning \\<open>L\\<close>. The cost for\\<close>\n        \\<comment> \\<open>\\<open>rev_append\\<close> is amortized by going to next node in \\<open>L\\<close>\\<close>\n        let (L_left,L_right) = ([u],rev_append L_left (tl L_right));\n        return ((x,cf),l,n,L_left,L_right)\n      } else do {\n        \\<comment> \\<open>Goto next node in \\<open>L\\<close>\\<close>\n        let (L_left,L_right) = (u#L_left, tl L_right);\n        return ((x,cf),l,n,L_left,L_right)\n      }\n  \n    }) (xcf,l,n,L_left,L_right);\n\n  return cf\n}\""], ["", "lemma relabel_to_front2_refine[refine]: \n  assumes AM: \"is_adj_map am\"  \n  shows \"relabel_to_front2 am \n    \\<le> \\<Down>(br (flow_of_cf) (RPreGraph c s t)) relabel_to_front\""], ["proof (prove)\ngoal (1 subgoal):\n 1. relabel_to_front2 am\n    \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t)) relabel_to_front", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. relabel_to_front2 am\n    \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t)) relabel_to_front", "define s_rel \n    :: \"( _ \\<times> (\n       capacity_impl flow \n    \\<times> (nat\\<Rightarrow>nat) \n    \\<times> (node\\<Rightarrow>node set) \n    \\<times> node list \n    \\<times> node list)) set\"\n    where \"s_rel \\<equiv> \n       xf_rel \n    \\<times>\\<^sub>r Id \n    \\<times>\\<^sub>r (nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel) \n    \\<times>\\<^sub>r br rev (\\<lambda>_. True) \n    \\<times>\\<^sub>r Id\""], ["proof (state)\nthis:\n  s_rel \\<equiv>\n  xf_rel \\<times>\\<^sub>r\n  Id \\<times>\\<^sub>r\n  (nat_rel \\<rightarrow>\n   \\<langle>nat_rel\\<rangle>list_set_rel) \\<times>\\<^sub>r\n  br rev (\\<lambda>_. True) \\<times>\\<^sub>r Id\n\ngoal (1 subgoal):\n 1. relabel_to_front2 am\n    \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t)) relabel_to_front", "have [refine_dref_RELATES]: \"RELATES s_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RELATES s_rel", "unfolding RELATES_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. True", ".."], ["proof (state)\nthis:\n  RELATES s_rel\n\ngoal (1 subgoal):\n 1. relabel_to_front2 am\n    \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t)) relabel_to_front", "{"], ["proof (state)\nthis:\n  RELATES s_rel\n\ngoal (1 subgoal):\n 1. relabel_to_front2 am\n    \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t)) relabel_to_front", "fix f l n"], ["proof (state)\ngoal (1 subgoal):\n 1. relabel_to_front2 am\n    \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t)) relabel_to_front", "assume \"neighbor_invar c s t f l n\""], ["proof (state)\nthis:\n  neighbor_invar c s t f l n\n\ngoal (1 subgoal):\n 1. relabel_to_front2 am\n    \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t)) relabel_to_front", "then"], ["proof (chain)\npicking this:\n  neighbor_invar c s t f l n", "interpret neighbor_invar c s t f l n"], ["proof (prove)\nusing this:\n  neighbor_invar c s t f l n\n\ngoal (1 subgoal):\n 1. neighbor_invar c s t f l n", "."], ["proof (state)\ngoal (1 subgoal):\n 1. relabel_to_front2 am\n    \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t)) relabel_to_front", "have G1: \"flow_of_cf cf = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flow_of_cf cf = f", "by (rule fo_rg_inv)"], ["proof (state)\nthis:\n  flow_of_cf cf = f\n\ngoal (1 subgoal):\n 1. relabel_to_front2 am\n    \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t)) relabel_to_front", "have G2: \"RPreGraph c s t cf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RPreGraph c s t cf", "by (rule is_RPreGraph)"], ["proof (state)\nthis:\n  RPreGraph c s t cf\n\ngoal (1 subgoal):\n 1. relabel_to_front2 am\n    \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t)) relabel_to_front", "note G1 G2"], ["proof (state)\nthis:\n  flow_of_cf cf = f\n  RPreGraph c s t cf\n\ngoal (1 subgoal):\n 1. relabel_to_front2 am\n    \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t)) relabel_to_front", "}"], ["proof (state)\nthis:\n  neighbor_invar c s t ?f13 ?l13 ?n13 \\<Longrightarrow>\n  flow_of_cf (cf_of ?f13) = ?f13\n  neighbor_invar c s t ?f13 ?l13 ?n13 \\<Longrightarrow>\n  RPreGraph c s t (cf_of ?f13)\n\ngoal (1 subgoal):\n 1. relabel_to_front2 am\n    \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t)) relabel_to_front", "note AUX1=this"], ["proof (state)\nthis:\n  neighbor_invar c s t ?f13 ?l13 ?n13 \\<Longrightarrow>\n  flow_of_cf (cf_of ?f13) = ?f13\n  neighbor_invar c s t ?f13 ?l13 ?n13 \\<Longrightarrow>\n  RPreGraph c s t (cf_of ?f13)\n\ngoal (1 subgoal):\n 1. relabel_to_front2 am\n    \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t)) relabel_to_front", "have AUXR: \"do {\n      (cardV, L_right) \\<leftarrow> init_CQ am;\n      xcf \\<leftarrow> pp_init_xcf2 am;\n      l \\<leftarrow> l_init cardV;\n      n \\<leftarrow> n_init am;\n      Fi L_right xcf l n\n    }\n    \\<le> \\<Down>R (do {\n      L_right \\<leftarrow> spec l. distinct l \\<and> set l = V - {s, t};\n      F L_right\n    })\n  \" \n  if \"\\<And>L_right xcf n. \n    \\<lbrakk> (xcf,pp_init_f)\\<in>xf_rel; (n,rtf_init_n) \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel \\<rbrakk>\n    \\<Longrightarrow> Fi L_right xcf pp_init_l n \\<le> \\<Down>R (F L_right)\"\n  for Fi F R"], ["proof (prove)\ngoal (1 subgoal):\n 1. init_CQ am \\<bind>\n    (\\<lambda>(cardV, L_right).\n        pp_init_xcf2 am \\<bind>\n        (\\<lambda>xcf.\n            l_init cardV \\<bind>\n            (\\<lambda>l. n_init am \\<bind> Fi L_right xcf l)))\n    \\<le> \\<Down> R\n           ((spec l. distinct l \\<and> set l = V - {s, t}) \\<bind> F)", "unfolding l_init_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. init_CQ am \\<bind>\n    (\\<lambda>(cardV, L_right).\n        pp_init_xcf2 am \\<bind>\n        (\\<lambda>xcf.\n            return ((\\<lambda>_. 0)(s := cardV)) \\<bind>\n            (\\<lambda>l. n_init am \\<bind> Fi L_right xcf l)))\n    \\<le> \\<Down> R\n           ((spec l. distinct l \\<and> set l = V - {s, t}) \\<bind> F)", "apply (rule refine2specI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail\n     ((spec l. distinct l \\<and> set l = V - {s, t}) \\<bind>\n      F) \\<Longrightarrow>\n    init_CQ am \\<bind>\n    (\\<lambda>(cardV, L_right).\n        pp_init_xcf2 am \\<bind>\n        (\\<lambda>xcf.\n            return ((\\<lambda>_. 0)(s := cardV)) \\<bind>\n            (\\<lambda>l. n_init am \\<bind> Fi L_right xcf l)))\n    \\<le> (spec r.\n              \\<exists>x.\n                 inres\n                  ((spec l. distinct l \\<and> set l = V - {s, t}) \\<bind> F)\n                  x \\<and>\n                 (r, x) \\<in> R)", "supply pp_init_xcf2_refine\n            [OF AM, unfolded conc_fun_RETURN, THEN order_trans, refine_vcg]"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail\n     ((spec l. distinct l \\<and> set l = V - {s, t}) \\<bind>\n      F) \\<Longrightarrow>\n    init_CQ am \\<bind>\n    (\\<lambda>(cardV, L_right).\n        pp_init_xcf2 am \\<bind>\n        (\\<lambda>xcf.\n            return ((\\<lambda>_. 0)(s := cardV)) \\<bind>\n            (\\<lambda>l. n_init am \\<bind> Fi L_right xcf l)))\n    \\<le> (spec r.\n              \\<exists>x.\n                 inres\n                  ((spec l. distinct l \\<and> set l = V - {s, t}) \\<bind> F)\n                  x \\<and>\n                 (r, x) \\<in> R)", "supply n_init_refine[OF AM,THEN order_trans, refine_vcg]"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail\n     ((spec l. distinct l \\<and> set l = V - {s, t}) \\<bind>\n      F) \\<Longrightarrow>\n    init_CQ am \\<bind>\n    (\\<lambda>(cardV, L_right).\n        pp_init_xcf2 am \\<bind>\n        (\\<lambda>xcf.\n            return ((\\<lambda>_. 0)(s := cardV)) \\<bind>\n            (\\<lambda>l. n_init am \\<bind> Fi L_right xcf l)))\n    \\<le> (spec r.\n              \\<exists>x.\n                 inres\n                  ((spec l. distinct l \\<and> set l = V - {s, t}) \\<bind> F)\n                  x \\<and>\n                 (r, x) \\<in> R)", "apply (refine_vcg AM V_ss)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b xa xb.\n       \\<lbrakk>nofail\n                 ((spec l. distinct l \\<and> set l = V - {s, t}) \\<bind> F);\n        case x of\n        (C, Q) \\<Rightarrow>\n          C = card V \\<and> distinct Q \\<and> set Q = V - {s, t};\n        x = (a, b); (xa, pp_init_f) \\<in> xf_rel;\n        (xb, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow>\n              \\<langle>nat_rel\\<rangle>list_set_rel\\<rbrakk>\n       \\<Longrightarrow> Fi b xa ((\\<lambda>_. 0)(s := a)) xb\n                         \\<le> (spec r.\n                                   \\<exists>x.\ninres ((spec l. distinct l \\<and> set l = V - {s, t}) \\<bind> F) x \\<and>\n(r, x) \\<in> R)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba aa bb xb.\n       \\<lbrakk>nofail\n                 ((spec l. distinct l \\<and> set l = V - {s, t}) \\<bind> F);\n        ((aa, bb), pp_init_f) \\<in> xf_rel;\n        (xb, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        distinct ba; set ba = V - {s, t}\\<rbrakk>\n       \\<Longrightarrow> Fi ba (aa, bb) ((\\<lambda>_. 0)(s := card V)) xb\n                         \\<le> (spec r.\n                                   \\<exists>x.\ninres ((spec l. distinct l \\<and> set l = V - {s, t}) \\<bind> F) x \\<and>\n(r, x) \\<in> R)", "subgoal for L_right x cf n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail\n              ((spec l. distinct l \\<and> set l = V - {s, t}) \\<bind> F);\n     ((x, cf), pp_init_f) \\<in> xf_rel;\n     (n, rtf_init_n)\n     \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n     distinct L_right; set L_right = V - {s, t}\\<rbrakk>\n    \\<Longrightarrow> Fi L_right (x, cf) ((\\<lambda>_. 0)(s := card V)) n\n                      \\<le> (spec r.\n                                \\<exists>x.\n                                   inres\n                                    ((spec l.\n   distinct l \\<and> set l = V - {s, t}) \\<bind>\n                                     F)\n                                    x \\<and>\n                                   (r, x) \\<in> R)", "using that[of \"(x,cf)\" n L_right]"], ["proof (prove)\nusing this:\n  \\<lbrakk>((x, cf), pp_init_f) \\<in> xf_rel;\n   (n, rtf_init_n)\n   \\<in> nat_rel \\<rightarrow>\n         \\<langle>nat_rel\\<rangle>list_set_rel\\<rbrakk>\n  \\<Longrightarrow> Fi L_right (x, cf) pp_init_l n\n                    \\<le> \\<Down> R (F L_right)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail\n              ((spec l. distinct l \\<and> set l = V - {s, t}) \\<bind> F);\n     ((x, cf), pp_init_f) \\<in> xf_rel;\n     (n, rtf_init_n)\n     \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n     distinct L_right; set L_right = V - {s, t}\\<rbrakk>\n    \\<Longrightarrow> Fi L_right (x, cf) ((\\<lambda>_. 0)(s := card V)) n\n                      \\<le> (spec r.\n                                \\<exists>x.\n                                   inres\n                                    ((spec l.\n   distinct l \\<and> set l = V - {s, t}) \\<bind>\n                                     F)\n                                    x \\<and>\n                                   (r, x) \\<in> R)", "unfolding pp_init_l_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>((x, cf), pp_init_f) \\<in> xf_rel;\n   (n, rtf_init_n)\n   \\<in> nat_rel \\<rightarrow>\n         \\<langle>nat_rel\\<rangle>list_set_rel\\<rbrakk>\n  \\<Longrightarrow> Fi L_right (x, cf) ((\\<lambda>x. 0)(s := card V)) n\n                    \\<le> \\<Down> R (F L_right)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nofail\n              ((spec l. distinct l \\<and> set l = V - {s, t}) \\<bind> F);\n     ((x, cf), pp_init_f) \\<in> xf_rel;\n     (n, rtf_init_n)\n     \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n     distinct L_right; set L_right = V - {s, t}\\<rbrakk>\n    \\<Longrightarrow> Fi L_right (x, cf) ((\\<lambda>_. 0)(s := card V)) n\n                      \\<le> (spec r.\n                                \\<exists>x.\n                                   inres\n                                    ((spec l.\n   distinct l \\<and> set l = V - {s, t}) \\<bind>\n                                     F)\n                                    x \\<and>\n                                   (r, x) \\<in> R)", "by (clarsimp simp: pw_le_iff refine_pw_simps; meson)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<And>L_right xcf n.\n      \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n       (n, rtf_init_n)\n       \\<in> nat_rel \\<rightarrow>\n             \\<langle>nat_rel\\<rangle>list_set_rel\\<rbrakk>\n      \\<Longrightarrow> ?Fi12 L_right xcf pp_init_l n\n                        \\<le> \\<Down> ?R12 (?F12 L_right)) \\<Longrightarrow>\n  init_CQ am \\<bind>\n  (\\<lambda>(cardV, L_right).\n      pp_init_xcf2 am \\<bind>\n      (\\<lambda>xcf.\n          l_init cardV \\<bind>\n          (\\<lambda>l. n_init am \\<bind> ?Fi12 L_right xcf l)))\n  \\<le> \\<Down> ?R12\n         ((spec l. distinct l \\<and> set l = V - {s, t}) \\<bind> ?F12)\n\ngoal (1 subgoal):\n 1. relabel_to_front2 am\n    \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t)) relabel_to_front", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. relabel_to_front2 am\n    \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t)) relabel_to_front", "unfolding relabel_to_front2_def relabel_to_front_def Let_def l_get_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. init_CQ am \\<bind>\n    (\\<lambda>(cardV, L_right).\n        pp_init_xcf2 am \\<bind>\n        (\\<lambda>xcf.\n            l_init cardV \\<bind>\n            (\\<lambda>l.\n                n_init am \\<bind>\n                (\\<lambda>n.\n                    while\\<^sub>T\n                     (\\<lambda>((x, cf), l, n, L_left, L_right).\n                         L_right \\<noteq> [])\n                     (\\<lambda>((x, cf), l, n, L_left, L_right).\n                         assert (L_right \\<noteq> []) \\<bind>\n                         (\\<lambda>_.\n                             assert (hd L_right \\<in> V) \\<bind>\n                             (\\<lambda>_. return (l (hd L_right))) \\<bind>\n                             (\\<lambda>old_lu.\n                                 discharge2 am x cf l n (hd L_right) \\<bind>\n                                 (\\<lambda>((x, cf), l, n).\n                                     assert (hd L_right \\<in> V) \\<bind>\n                                     (\\<lambda>_.\n   return (l (hd L_right))) \\<bind>\n                                     (\\<lambda>lu.\n   if lu \\<noteq> old_lu\n   then case ([hd L_right], rev_append L_left (tl L_right)) of\n        (L_left, L_right) \\<Rightarrow>\n          return ((x, cf), l, n, L_left, L_right)\n   else case (hd L_right # L_left, tl L_right) of\n        (L_left, L_right) \\<Rightarrow>\n          return ((x, cf), l, n, L_left, L_right))))))\n                     (xcf, l, n, [], L_right) \\<bind>\n                    (\\<lambda>((x, cf), l, n, L_left, L_right).\n                        return cf)))))\n    \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t))\n           ((spec l. distinct l \\<and> set l = V - {s, t}) \\<bind>\n            (\\<lambda>L_right.\n                while\\<^sub>T\n                 (\\<lambda>(f, l, n, L_left, L_right). L_right \\<noteq> [])\n                 (\\<lambda>(f, l, n, L_left, L_right).\n                     assert (hd L_right \\<in> V) \\<bind>\n                     (\\<lambda>_.\n                         discharge f l n (hd L_right) \\<bind>\n                         (\\<lambda>(f, la, n).\n                             if la (hd L_right) \\<noteq> l (hd L_right)\n                             then case ([hd L_right],\n  L_left @ tl L_right) of\n                                  (L_left, L_right) \\<Rightarrow>\n                                    return (f, la, n, L_left, L_right)\n                             else case (L_left @ [hd L_right],\n  tl L_right) of\n                                  (L_left, L_right) \\<Rightarrow>\n                                    return (f, la, n, L_left, L_right))))\n                 (pp_init_f, pp_init_l, rtf_init_n, [], L_right) \\<bind>\n                (\\<lambda>(f, l, n, L_left, L_right).\n                    assert (neighbor_invar c s t f l n) \\<bind>\n                    (\\<lambda>_. return f))))", "apply (simp only: nres_monad_laws)"], ["proof (prove)\ngoal (1 subgoal):\n 1. init_CQ am \\<bind>\n    (\\<lambda>(cardV, L_right).\n        pp_init_xcf2 am \\<bind>\n        (\\<lambda>xcf.\n            l_init cardV \\<bind>\n            (\\<lambda>l.\n                n_init am \\<bind>\n                (\\<lambda>n.\n                    while\\<^sub>T\n                     (\\<lambda>((x, cf), l, n, L_left, L_right).\n                         L_right \\<noteq> [])\n                     (\\<lambda>((x, cf), l, n, L_left, L_right).\n                         assert (L_right \\<noteq> []) \\<bind>\n                         (\\<lambda>_.\n                             assert (hd L_right \\<in> V) \\<bind>\n                             (\\<lambda>xa.\n                                 discharge2 am x cf l n (hd L_right) \\<bind>\n                                 (\\<lambda>((x, cf), la, n).\n                                     assert (hd L_right \\<in> V) \\<bind>\n                                     (\\<lambda>xa.\n   if la (hd L_right) \\<noteq> l (hd L_right)\n   then case ([hd L_right], rev_append L_left (tl L_right)) of\n        (L_left, L_right) \\<Rightarrow>\n          return ((x, cf), la, n, L_left, L_right)\n   else case (hd L_right # L_left, tl L_right) of\n        (L_left, L_right) \\<Rightarrow>\n          return ((x, cf), la, n, L_left, L_right))))))\n                     (xcf, l, n, [], L_right) \\<bind>\n                    (\\<lambda>((x, cf), l, n, L_left, L_right).\n                        return cf)))))\n    \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t))\n           ((spec l. distinct l \\<and> set l = V - {s, t}) \\<bind>\n            (\\<lambda>L_right.\n                while\\<^sub>T\n                 (\\<lambda>(f, l, n, L_left, L_right). L_right \\<noteq> [])\n                 (\\<lambda>(f, l, n, L_left, L_right).\n                     assert (hd L_right \\<in> V) \\<bind>\n                     (\\<lambda>_.\n                         discharge f l n (hd L_right) \\<bind>\n                         (\\<lambda>(f, la, n).\n                             if la (hd L_right) \\<noteq> l (hd L_right)\n                             then case ([hd L_right],\n  L_left @ tl L_right) of\n                                  (L_left, L_right) \\<Rightarrow>\n                                    return (f, la, n, L_left, L_right)\n                             else case (L_left @ [hd L_right],\n  tl L_right) of\n                                  (L_left, L_right) \\<Rightarrow>\n                                    return (f, la, n, L_left, L_right))))\n                 (pp_init_f, pp_init_l, rtf_init_n, [], L_right) \\<bind>\n                (\\<lambda>(f, l, n, L_left, L_right).\n                    assert (neighbor_invar c s t f l n) \\<bind>\n                    (\\<lambda>_. return f))))", "apply (rule AUXR)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>L_right xcf n.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow>\n              \\<langle>nat_rel\\<rangle>list_set_rel\\<rbrakk>\n       \\<Longrightarrow> while\\<^sub>T\n                          (\\<lambda>((x, cf), l, n, L_left, L_right).\n                              L_right \\<noteq> [])\n                          (\\<lambda>((x, cf), l, n, L_left, L_right).\n                              assert (L_right \\<noteq> []) \\<bind>\n                              (\\<lambda>_.\n                                  assert (hd L_right \\<in> V) \\<bind>\n                                  (\\<lambda>xa.\ndischarge2 am x cf l n (hd L_right) \\<bind>\n(\\<lambda>((x, cf), la, n).\n    assert (hd L_right \\<in> V) \\<bind>\n    (\\<lambda>xa.\n        if la (hd L_right) \\<noteq> l (hd L_right)\n        then case ([hd L_right], rev_append L_left (tl L_right)) of\n             (L_left, L_right) \\<Rightarrow>\n               return ((x, cf), la, n, L_left, L_right)\n        else case (hd L_right # L_left, tl L_right) of\n             (L_left, L_right) \\<Rightarrow>\n               return ((x, cf), la, n, L_left, L_right))))))\n                          (xcf, pp_init_l, n, [], L_right) \\<bind>\n                         (\\<lambda>((x, cf), l, n, L_left, L_right).\n                             return cf)\n                         \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t))\n                                (while\\<^sub>T\n                                  (\\<lambda>(f, l, n, L_left, L_right).\nL_right \\<noteq> [])\n                                  (\\<lambda>(f, l, n, L_left, L_right).\nassert (hd L_right \\<in> V) \\<bind>\n(\\<lambda>_.\n    discharge f l n (hd L_right) \\<bind>\n    (\\<lambda>(f, la, n).\n        if la (hd L_right) \\<noteq> l (hd L_right)\n        then case ([hd L_right], L_left @ tl L_right) of\n             (L_left, L_right) \\<Rightarrow>\n               return (f, la, n, L_left, L_right)\n        else case (L_left @ [hd L_right], tl L_right) of\n             (L_left, L_right) \\<Rightarrow>\n               return (f, la, n, L_left, L_right))))\n                                  (pp_init_f, pp_init_l, rtf_init_n, [],\n                                   L_right) \\<bind>\n                                 (\\<lambda>(f, l, n, L_left, L_right).\n                                     assert\n(neighbor_invar c s t f l n) \\<bind>\n                                     (\\<lambda>_. return f)))", "apply (refine_rcg)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>L_right xcf n.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow>\n              \\<langle>nat_rel\\<rangle>list_set_rel\\<rbrakk>\n       \\<Longrightarrow> ((xcf, pp_init_l, n, [], L_right), pp_init_f,\n                          pp_init_l, rtf_init_n, [], L_right)\n                         \\<in> ?R'16 L_right xcf n\n 2. \\<And>L_right xcf n x x' x1 x1a x2 x2a x1b x2b x1c x2c x1d x2d x1e x2e\n       x1f x2f x1g x2g x1h x2h.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (x, x') \\<in> ?R'16 L_right xcf n; x1 = (x1a, x2); x2c = (x1d, x2d);\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x = (x1, x2a); x2g = (x1h, x2h);\n        x2f = (x1g, x2g); x2e = (x1f, x2f); x' = (x1e, x2e)\\<rbrakk>\n       \\<Longrightarrow> (x2d \\<noteq> []) = (x2h \\<noteq> [])\n 3. \\<And>L_right xcf n x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x1e x2d x2e\n       x1f x2f x1g x2g x1h x2h.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (x, x') \\<in> ?R'16 L_right xcf n;\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (x, cf) \\<Rightarrow>\n             \\<lambda>(l, n, L_left, L_right). L_right \\<noteq> [])\n           xa;\n        case x' of\n        (f, l, n, L_left, L_right) \\<Rightarrow> L_right \\<noteq> [];\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x1d = (x1e, x2d); x2g = (x1h, x2h); x2f = (x1g, x2g);\n        x2e = (x1f, x2f); x = (x1d, x2e); hd x2c \\<in> V\\<rbrakk>\n       \\<Longrightarrow> x2h \\<noteq> []\n 4. \\<And>L_right xcf n x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x1e x2d x2e\n       x1f x2f x1g x2g x1h x2h.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (x, x') \\<in> ?R'16 L_right xcf n;\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (x, cf) \\<Rightarrow>\n             \\<lambda>(l, n, L_left, L_right). L_right \\<noteq> [])\n           xa;\n        case x' of\n        (f, l, n, L_left, L_right) \\<Rightarrow> L_right \\<noteq> [];\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x1d = (x1e, x2d); x2g = (x1h, x2h); x2f = (x1g, x2g);\n        x2e = (x1f, x2f); x = (x1d, x2e); hd x2c \\<in> V;\n        x2h \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> hd x2h \\<in> V\n 5. \\<And>L_right xcf n x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x1e x2d x2e\n       x1f x2f x1g x2g x1h x2h.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (x, x') \\<in> ?R'16 L_right xcf n;\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (x, cf) \\<Rightarrow>\n             \\<lambda>(l, n, L_left, L_right). L_right \\<noteq> [])\n           xa;\n        case x' of\n        (f, l, n, L_left, L_right) \\<Rightarrow> L_right \\<noteq> [];\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x1d = (x1e, x2d); x2g = (x1h, x2h); x2f = (x1g, x2g);\n        x2e = (x1f, x2f); x = (x1d, x2e); hd x2c \\<in> V; x2h \\<noteq> [];\n        hd x2h \\<in> V\\<rbrakk>\n       \\<Longrightarrow> ((x1e, x2d), x1) \\<in> xf_rel\n 6. \\<And>L_right xcf n x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x1e x2d x2e\n       x1f x2f x1g x2g x1h x2h a a'.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (x, x') \\<in> ?R'16 L_right xcf n;\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (x, cf) \\<Rightarrow>\n             \\<lambda>(l, n, L_left, L_right). L_right \\<noteq> [])\n           xa;\n        case x' of\n        (f, l, n, L_left, L_right) \\<Rightarrow> L_right \\<noteq> [];\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x1d = (x1e, x2d); x2g = (x1h, x2h); x2f = (x1g, x2g);\n        x2e = (x1f, x2f); x = (x1d, x2e); hd x2c \\<in> V; x2h \\<noteq> [];\n        hd x2h \\<in> V; (a, a') \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (am a, adjacent_nodes a')\n                         \\<in> \\<langle>nat_rel\\<rangle>list_set_rel\n 7. \\<And>L_right xcf n x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x1e x2d x2e\n       x1f x2f x1g x2g x1h x2h.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (x, x') \\<in> ?R'16 L_right xcf n;\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (x, cf) \\<Rightarrow>\n             \\<lambda>(l, n, L_left, L_right). L_right \\<noteq> [])\n           xa;\n        case x' of\n        (f, l, n, L_left, L_right) \\<Rightarrow> L_right \\<noteq> [];\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x1d = (x1e, x2d); x2g = (x1h, x2h); x2f = (x1g, x2g);\n        x2e = (x1f, x2f); x = (x1d, x2e); hd x2c \\<in> V; x2h \\<noteq> [];\n        hd x2h \\<in> V\\<rbrakk>\n       \\<Longrightarrow> (x1f, x1a) \\<in> Id\n 8. \\<And>L_right xcf n x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x1e x2d x2e\n       x1f x2f x1g x2g x1h x2h.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (x, x') \\<in> ?R'16 L_right xcf n;\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (x, cf) \\<Rightarrow>\n             \\<lambda>(l, n, L_left, L_right). L_right \\<noteq> [])\n           xa;\n        case x' of\n        (f, l, n, L_left, L_right) \\<Rightarrow> L_right \\<noteq> [];\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x1d = (x1e, x2d); x2g = (x1h, x2h); x2f = (x1g, x2g);\n        x2e = (x1f, x2f); x = (x1d, x2e); hd x2c \\<in> V; x2h \\<noteq> [];\n        hd x2h \\<in> V\\<rbrakk>\n       \\<Longrightarrow> (hd x2h, hd x2c) \\<in> nat_rel\n 9. \\<And>L_right xcf n x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x1e x2d x2e\n       x1f x2f x1g x2g x1h x2h a a'.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (x, x') \\<in> ?R'16 L_right xcf n;\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (x, cf) \\<Rightarrow>\n             \\<lambda>(l, n, L_left, L_right). L_right \\<noteq> [])\n           xa;\n        case x' of\n        (f, l, n, L_left, L_right) \\<Rightarrow> L_right \\<noteq> [];\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x1d = (x1e, x2d); x2g = (x1h, x2h); x2f = (x1g, x2g);\n        x2e = (x1f, x2f); x = (x1d, x2e); hd x2c \\<in> V; x2h \\<noteq> [];\n        hd x2h \\<in> V; (a, a') \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (x1g a, x1b a')\n                         \\<in> \\<langle>nat_rel\\<rangle>list_set_rel\n 10. \\<And>L_right xcf n x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x1e x2d x2e\n        x1f x2f x1g x2g x1h x2h xa x'a x1i x2i x1j x2j x1k x2k x1l x2l x1m\n        x1n x2m x2n x1o x2o x1p x2p x1q x2q.\n        \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n         (n, rtf_init_n)\n         \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n         (x, x') \\<in> ?R'16 L_right xcf n;\n         case x of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (x, cf) \\<Rightarrow>\n              \\<lambda>(l, n, L_left, L_right). L_right \\<noteq> [])\n            xa;\n         case x' of\n         (f, l, n, L_left, L_right) \\<Rightarrow> L_right \\<noteq> [];\n         x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n         x1d = (x1e, x2d); x2g = (x1h, x2h); x2f = (x1g, x2g);\n         x2e = (x1f, x2f); x = (x1d, x2e); hd x2c \\<in> V; x2h \\<noteq> [];\n         hd x2h \\<in> V;\n         (xa, x'a)\n         \\<in> xf_rel \\<times>\\<^sub>r\n               Id \\<times>\\<^sub>r\n               (nat_rel \\<rightarrow>\n                \\<langle>nat_rel\\<rangle>list_set_rel);\n         ([hd x2c], x1c @ tl x2c) = (x1k, x2k);\n         (x1c @ [hd x2c], tl x2c) = (x1l, x2l); x2i = (x1j, x2j);\n         x'a = (x1i, x2i); x1m = (x1n, x2m);\n         ([hd x2h], rev_append x1h (tl x2h)) = (x1p, x2p);\n         (hd x2h # x1h, tl x2h) = (x1q, x2q); x2n = (x1o, x2o);\n         xa = (x1m, x2n); hd x2h \\<in> V\\<rbrakk>\n        \\<Longrightarrow> (x1o (hd x2h) \\<noteq> x1f (hd x2h)) =\n                          (x1j (hd x2c) \\<noteq> x1a (hd x2c))\nA total of 13 subgoals...", "apply refine_dref_type"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>L_right xcf n.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow>\n              \\<langle>nat_rel\\<rangle>list_set_rel\\<rbrakk>\n       \\<Longrightarrow> ((xcf, pp_init_l, n, [], L_right), pp_init_f,\n                          pp_init_l, rtf_init_n, [], L_right)\n                         \\<in> s_rel\n 2. \\<And>L_right xcf n x x' x1 x1a x2 x2a x1b x2b x1c x2c x1d x2d x1e x2e\n       x1f x2f x1g x2g x1h x2h.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (x, x') \\<in> s_rel; x1 = (x1a, x2); x2c = (x1d, x2d);\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x = (x1, x2a); x2g = (x1h, x2h);\n        x2f = (x1g, x2g); x2e = (x1f, x2f); x' = (x1e, x2e)\\<rbrakk>\n       \\<Longrightarrow> (x2d \\<noteq> []) = (x2h \\<noteq> [])\n 3. \\<And>L_right xcf n x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x1e x2d x2e\n       x1f x2f x1g x2g x1h x2h.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (x, x') \\<in> s_rel;\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (x, cf) \\<Rightarrow>\n             \\<lambda>(l, n, L_left, L_right). L_right \\<noteq> [])\n           xa;\n        case x' of\n        (f, l, n, L_left, L_right) \\<Rightarrow> L_right \\<noteq> [];\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x1d = (x1e, x2d); x2g = (x1h, x2h); x2f = (x1g, x2g);\n        x2e = (x1f, x2f); x = (x1d, x2e); hd x2c \\<in> V\\<rbrakk>\n       \\<Longrightarrow> x2h \\<noteq> []\n 4. \\<And>L_right xcf n x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x1e x2d x2e\n       x1f x2f x1g x2g x1h x2h.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (x, x') \\<in> s_rel;\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (x, cf) \\<Rightarrow>\n             \\<lambda>(l, n, L_left, L_right). L_right \\<noteq> [])\n           xa;\n        case x' of\n        (f, l, n, L_left, L_right) \\<Rightarrow> L_right \\<noteq> [];\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x1d = (x1e, x2d); x2g = (x1h, x2h); x2f = (x1g, x2g);\n        x2e = (x1f, x2f); x = (x1d, x2e); hd x2c \\<in> V;\n        x2h \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> hd x2h \\<in> V\n 5. \\<And>L_right xcf n x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x1e x2d x2e\n       x1f x2f x1g x2g x1h x2h.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (x, x') \\<in> s_rel;\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (x, cf) \\<Rightarrow>\n             \\<lambda>(l, n, L_left, L_right). L_right \\<noteq> [])\n           xa;\n        case x' of\n        (f, l, n, L_left, L_right) \\<Rightarrow> L_right \\<noteq> [];\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x1d = (x1e, x2d); x2g = (x1h, x2h); x2f = (x1g, x2g);\n        x2e = (x1f, x2f); x = (x1d, x2e); hd x2c \\<in> V; x2h \\<noteq> [];\n        hd x2h \\<in> V\\<rbrakk>\n       \\<Longrightarrow> ((x1e, x2d), x1) \\<in> xf_rel\n 6. \\<And>L_right xcf n x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x1e x2d x2e\n       x1f x2f x1g x2g x1h x2h a a'.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (x, x') \\<in> s_rel;\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (x, cf) \\<Rightarrow>\n             \\<lambda>(l, n, L_left, L_right). L_right \\<noteq> [])\n           xa;\n        case x' of\n        (f, l, n, L_left, L_right) \\<Rightarrow> L_right \\<noteq> [];\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x1d = (x1e, x2d); x2g = (x1h, x2h); x2f = (x1g, x2g);\n        x2e = (x1f, x2f); x = (x1d, x2e); hd x2c \\<in> V; x2h \\<noteq> [];\n        hd x2h \\<in> V; (a, a') \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (am a, adjacent_nodes a')\n                         \\<in> \\<langle>nat_rel\\<rangle>list_set_rel\n 7. \\<And>L_right xcf n x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x1e x2d x2e\n       x1f x2f x1g x2g x1h x2h.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (x, x') \\<in> s_rel;\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (x, cf) \\<Rightarrow>\n             \\<lambda>(l, n, L_left, L_right). L_right \\<noteq> [])\n           xa;\n        case x' of\n        (f, l, n, L_left, L_right) \\<Rightarrow> L_right \\<noteq> [];\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x1d = (x1e, x2d); x2g = (x1h, x2h); x2f = (x1g, x2g);\n        x2e = (x1f, x2f); x = (x1d, x2e); hd x2c \\<in> V; x2h \\<noteq> [];\n        hd x2h \\<in> V\\<rbrakk>\n       \\<Longrightarrow> (x1f, x1a) \\<in> Id\n 8. \\<And>L_right xcf n x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x1e x2d x2e\n       x1f x2f x1g x2g x1h x2h.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (x, x') \\<in> s_rel;\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (x, cf) \\<Rightarrow>\n             \\<lambda>(l, n, L_left, L_right). L_right \\<noteq> [])\n           xa;\n        case x' of\n        (f, l, n, L_left, L_right) \\<Rightarrow> L_right \\<noteq> [];\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x1d = (x1e, x2d); x2g = (x1h, x2h); x2f = (x1g, x2g);\n        x2e = (x1f, x2f); x = (x1d, x2e); hd x2c \\<in> V; x2h \\<noteq> [];\n        hd x2h \\<in> V\\<rbrakk>\n       \\<Longrightarrow> (hd x2h, hd x2c) \\<in> nat_rel\n 9. \\<And>L_right xcf n x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x1e x2d x2e\n       x1f x2f x1g x2g x1h x2h a a'.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (x, x') \\<in> s_rel;\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (x, cf) \\<Rightarrow>\n             \\<lambda>(l, n, L_left, L_right). L_right \\<noteq> [])\n           xa;\n        case x' of\n        (f, l, n, L_left, L_right) \\<Rightarrow> L_right \\<noteq> [];\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x1d = (x1e, x2d); x2g = (x1h, x2h); x2f = (x1g, x2g);\n        x2e = (x1f, x2f); x = (x1d, x2e); hd x2c \\<in> V; x2h \\<noteq> [];\n        hd x2h \\<in> V; (a, a') \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (x1g a, x1b a')\n                         \\<in> \\<langle>nat_rel\\<rangle>list_set_rel\n 10. \\<And>L_right xcf n x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x1e x2d x2e\n        x1f x2f x1g x2g x1h x2h xa x'a x1i x2i x1j x2j x1k x2k x1l x2l x1m\n        x1n x2m x2n x1o x2o x1p x2p x1q x2q.\n        \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n         (n, rtf_init_n)\n         \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n         (x, x') \\<in> s_rel;\n         case x of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (x, cf) \\<Rightarrow>\n              \\<lambda>(l, n, L_left, L_right). L_right \\<noteq> [])\n            xa;\n         case x' of\n         (f, l, n, L_left, L_right) \\<Rightarrow> L_right \\<noteq> [];\n         x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n         x1d = (x1e, x2d); x2g = (x1h, x2h); x2f = (x1g, x2g);\n         x2e = (x1f, x2f); x = (x1d, x2e); hd x2c \\<in> V; x2h \\<noteq> [];\n         hd x2h \\<in> V;\n         (xa, x'a)\n         \\<in> xf_rel \\<times>\\<^sub>r\n               Id \\<times>\\<^sub>r\n               (nat_rel \\<rightarrow>\n                \\<langle>nat_rel\\<rangle>list_set_rel);\n         ([hd x2c], x1c @ tl x2c) = (x1k, x2k);\n         (x1c @ [hd x2c], tl x2c) = (x1l, x2l); x2i = (x1j, x2j);\n         x'a = (x1i, x2i); x1m = (x1n, x2m);\n         ([hd x2h], rev_append x1h (tl x2h)) = (x1p, x2p);\n         (hd x2h # x1h, tl x2h) = (x1q, x2q); x2n = (x1o, x2o);\n         xa = (x1m, x2n); hd x2h \\<in> V\\<rbrakk>\n        \\<Longrightarrow> (x1o (hd x2h) \\<noteq> x1f (hd x2h)) =\n                          (x1j (hd x2c) \\<noteq> x1a (hd x2c))\nA total of 13 subgoals...", "unfolding s_rel_def"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>L_right xcf n.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow>\n              \\<langle>nat_rel\\<rangle>list_set_rel\\<rbrakk>\n       \\<Longrightarrow> ((xcf, pp_init_l, n, [], L_right), pp_init_f,\n                          pp_init_l, rtf_init_n, [], L_right)\n                         \\<in> xf_rel \\<times>\\<^sub>r\n                               Id \\<times>\\<^sub>r\n                               (nat_rel \\<rightarrow>\n                                \\<langle>nat_rel\\<rangle>list_set_rel) \\<times>\\<^sub>r\n                               br rev (\\<lambda>_. True) \\<times>\\<^sub>r Id\n 2. \\<And>L_right xcf n x x' x1 x1a x2 x2a x1b x2b x1c x2c x1d x2d x1e x2e\n       x1f x2f x1g x2g x1h x2h.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (x, x')\n        \\<in> xf_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              (nat_rel \\<rightarrow>\n               \\<langle>nat_rel\\<rangle>list_set_rel) \\<times>\\<^sub>r\n              br rev (\\<lambda>_. True) \\<times>\\<^sub>r Id;\n        x1 = (x1a, x2); x2c = (x1d, x2d); x2b = (x1c, x2c);\n        x2a = (x1b, x2b); x = (x1, x2a); x2g = (x1h, x2h); x2f = (x1g, x2g);\n        x2e = (x1f, x2f); x' = (x1e, x2e)\\<rbrakk>\n       \\<Longrightarrow> (x2d \\<noteq> []) = (x2h \\<noteq> [])\n 3. \\<And>L_right xcf n x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x1e x2d x2e\n       x1f x2f x1g x2g x1h x2h.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (x, x')\n        \\<in> xf_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              (nat_rel \\<rightarrow>\n               \\<langle>nat_rel\\<rangle>list_set_rel) \\<times>\\<^sub>r\n              br rev (\\<lambda>_. True) \\<times>\\<^sub>r Id;\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (x, cf) \\<Rightarrow>\n             \\<lambda>(l, n, L_left, L_right). L_right \\<noteq> [])\n           xa;\n        case x' of\n        (f, l, n, L_left, L_right) \\<Rightarrow> L_right \\<noteq> [];\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x1d = (x1e, x2d); x2g = (x1h, x2h); x2f = (x1g, x2g);\n        x2e = (x1f, x2f); x = (x1d, x2e); hd x2c \\<in> V\\<rbrakk>\n       \\<Longrightarrow> x2h \\<noteq> []\n 4. \\<And>L_right xcf n x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x1e x2d x2e\n       x1f x2f x1g x2g x1h x2h.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (x, x')\n        \\<in> xf_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              (nat_rel \\<rightarrow>\n               \\<langle>nat_rel\\<rangle>list_set_rel) \\<times>\\<^sub>r\n              br rev (\\<lambda>_. True) \\<times>\\<^sub>r Id;\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (x, cf) \\<Rightarrow>\n             \\<lambda>(l, n, L_left, L_right). L_right \\<noteq> [])\n           xa;\n        case x' of\n        (f, l, n, L_left, L_right) \\<Rightarrow> L_right \\<noteq> [];\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x1d = (x1e, x2d); x2g = (x1h, x2h); x2f = (x1g, x2g);\n        x2e = (x1f, x2f); x = (x1d, x2e); hd x2c \\<in> V;\n        x2h \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> hd x2h \\<in> V\n 5. \\<And>L_right xcf n x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x1e x2d x2e\n       x1f x2f x1g x2g x1h x2h.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (x, x')\n        \\<in> xf_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              (nat_rel \\<rightarrow>\n               \\<langle>nat_rel\\<rangle>list_set_rel) \\<times>\\<^sub>r\n              br rev (\\<lambda>_. True) \\<times>\\<^sub>r Id;\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (x, cf) \\<Rightarrow>\n             \\<lambda>(l, n, L_left, L_right). L_right \\<noteq> [])\n           xa;\n        case x' of\n        (f, l, n, L_left, L_right) \\<Rightarrow> L_right \\<noteq> [];\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x1d = (x1e, x2d); x2g = (x1h, x2h); x2f = (x1g, x2g);\n        x2e = (x1f, x2f); x = (x1d, x2e); hd x2c \\<in> V; x2h \\<noteq> [];\n        hd x2h \\<in> V\\<rbrakk>\n       \\<Longrightarrow> ((x1e, x2d), x1) \\<in> xf_rel\n 6. \\<And>L_right xcf n x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x1e x2d x2e\n       x1f x2f x1g x2g x1h x2h a a'.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (x, x')\n        \\<in> xf_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              (nat_rel \\<rightarrow>\n               \\<langle>nat_rel\\<rangle>list_set_rel) \\<times>\\<^sub>r\n              br rev (\\<lambda>_. True) \\<times>\\<^sub>r Id;\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (x, cf) \\<Rightarrow>\n             \\<lambda>(l, n, L_left, L_right). L_right \\<noteq> [])\n           xa;\n        case x' of\n        (f, l, n, L_left, L_right) \\<Rightarrow> L_right \\<noteq> [];\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x1d = (x1e, x2d); x2g = (x1h, x2h); x2f = (x1g, x2g);\n        x2e = (x1f, x2f); x = (x1d, x2e); hd x2c \\<in> V; x2h \\<noteq> [];\n        hd x2h \\<in> V; (a, a') \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (am a, adjacent_nodes a')\n                         \\<in> \\<langle>nat_rel\\<rangle>list_set_rel\n 7. \\<And>L_right xcf n x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x1e x2d x2e\n       x1f x2f x1g x2g x1h x2h.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (x, x')\n        \\<in> xf_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              (nat_rel \\<rightarrow>\n               \\<langle>nat_rel\\<rangle>list_set_rel) \\<times>\\<^sub>r\n              br rev (\\<lambda>_. True) \\<times>\\<^sub>r Id;\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (x, cf) \\<Rightarrow>\n             \\<lambda>(l, n, L_left, L_right). L_right \\<noteq> [])\n           xa;\n        case x' of\n        (f, l, n, L_left, L_right) \\<Rightarrow> L_right \\<noteq> [];\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x1d = (x1e, x2d); x2g = (x1h, x2h); x2f = (x1g, x2g);\n        x2e = (x1f, x2f); x = (x1d, x2e); hd x2c \\<in> V; x2h \\<noteq> [];\n        hd x2h \\<in> V\\<rbrakk>\n       \\<Longrightarrow> (x1f, x1a) \\<in> Id\n 8. \\<And>L_right xcf n x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x1e x2d x2e\n       x1f x2f x1g x2g x1h x2h.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (x, x')\n        \\<in> xf_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              (nat_rel \\<rightarrow>\n               \\<langle>nat_rel\\<rangle>list_set_rel) \\<times>\\<^sub>r\n              br rev (\\<lambda>_. True) \\<times>\\<^sub>r Id;\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (x, cf) \\<Rightarrow>\n             \\<lambda>(l, n, L_left, L_right). L_right \\<noteq> [])\n           xa;\n        case x' of\n        (f, l, n, L_left, L_right) \\<Rightarrow> L_right \\<noteq> [];\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x1d = (x1e, x2d); x2g = (x1h, x2h); x2f = (x1g, x2g);\n        x2e = (x1f, x2f); x = (x1d, x2e); hd x2c \\<in> V; x2h \\<noteq> [];\n        hd x2h \\<in> V\\<rbrakk>\n       \\<Longrightarrow> (hd x2h, hd x2c) \\<in> nat_rel\n 9. \\<And>L_right xcf n x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x1e x2d x2e\n       x1f x2f x1g x2g x1h x2h a a'.\n       \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n        (n, rtf_init_n)\n        \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n        (x, x')\n        \\<in> xf_rel \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              (nat_rel \\<rightarrow>\n               \\<langle>nat_rel\\<rangle>list_set_rel) \\<times>\\<^sub>r\n              br rev (\\<lambda>_. True) \\<times>\\<^sub>r Id;\n        case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (x, cf) \\<Rightarrow>\n             \\<lambda>(l, n, L_left, L_right). L_right \\<noteq> [])\n           xa;\n        case x' of\n        (f, l, n, L_left, L_right) \\<Rightarrow> L_right \\<noteq> [];\n        x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n        x1d = (x1e, x2d); x2g = (x1h, x2h); x2f = (x1g, x2g);\n        x2e = (x1f, x2f); x = (x1d, x2e); hd x2c \\<in> V; x2h \\<noteq> [];\n        hd x2h \\<in> V; (a, a') \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (x1g a, x1b a')\n                         \\<in> \\<langle>nat_rel\\<rangle>list_set_rel\n 10. \\<And>L_right xcf n x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x1e x2d x2e\n        x1f x2f x1g x2g x1h x2h xa x'a x1i x2i x1j x2j x1k x2k x1l x2l x1m\n        x1n x2m x2n x1o x2o x1p x2p x1q x2q.\n        \\<lbrakk>(xcf, pp_init_f) \\<in> xf_rel;\n         (n, rtf_init_n)\n         \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel;\n         (x, x')\n         \\<in> xf_rel \\<times>\\<^sub>r\n               Id \\<times>\\<^sub>r\n               (nat_rel \\<rightarrow>\n                \\<langle>nat_rel\\<rangle>list_set_rel) \\<times>\\<^sub>r\n               br rev (\\<lambda>_. True) \\<times>\\<^sub>r Id;\n         case x of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (x, cf) \\<Rightarrow>\n              \\<lambda>(l, n, L_left, L_right). L_right \\<noteq> [])\n            xa;\n         case x' of\n         (f, l, n, L_left, L_right) \\<Rightarrow> L_right \\<noteq> [];\n         x2b = (x1c, x2c); x2a = (x1b, x2b); x2 = (x1a, x2a); x' = (x1, x2);\n         x1d = (x1e, x2d); x2g = (x1h, x2h); x2f = (x1g, x2g);\n         x2e = (x1f, x2f); x = (x1d, x2e); hd x2c \\<in> V; x2h \\<noteq> [];\n         hd x2h \\<in> V;\n         (xa, x'a)\n         \\<in> xf_rel \\<times>\\<^sub>r\n               Id \\<times>\\<^sub>r\n               (nat_rel \\<rightarrow>\n                \\<langle>nat_rel\\<rangle>list_set_rel);\n         ([hd x2c], x1c @ tl x2c) = (x1k, x2k);\n         (x1c @ [hd x2c], tl x2c) = (x1l, x2l); x2i = (x1j, x2j);\n         x'a = (x1i, x2i); x1m = (x1n, x2m);\n         ([hd x2h], rev_append x1h (tl x2h)) = (x1p, x2p);\n         (hd x2h # x1h, tl x2h) = (x1q, x2q); x2n = (x1o, x2o);\n         xa = (x1m, x2n); hd x2h \\<in> V\\<rbrakk>\n        \\<Longrightarrow> (x1o (hd x2h) \\<noteq> x1f (hd x2h)) =\n                          (x1j (hd x2c) \\<noteq> x1a (hd x2c))\nA total of 13 subgoals...", "apply (vc_solve \n        simp: in_br_conv rev_append_eq xf_rel_def AUX1 fun_relD \n        simp: am_to_adj_nodes_refine[OF AM])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  relabel_to_front2 am\n  \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t)) relabel_to_front\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Refinement to Efficient Data Structures\\<close>"], ["", "context includes Network_Impl_Sepref_Register \nbegin"], ["", "sepref_register n_init"], ["", "sepref_register n_at_end"], ["", "sepref_register n_get_hd"], ["", "sepref_register n_move_next"], ["", "sepref_register n_reset"], ["", "sepref_register discharge2"], ["", "sepref_register \"init_CQ\""], ["", "sepref_register relabel_to_front2"], ["", "end"], ["", "subsubsection \\<open>Neighbor Lists by Array of Lists\\<close>"], ["", "definition \"n_assn \\<equiv> is_nf N ([]::nat list)\""], ["", "definition (in -) \"n_init_impl s t am \\<equiv> do {\n  n \\<leftarrow> array_copy am;\n  n \\<leftarrow> Array.upd s [] n;\n  n \\<leftarrow> Array.upd t [] n;\n  return n\n}\""], ["", "lemma [sepref_fr_rules]: \n  \"(n_init_impl s t,PR_CONST n_init) \\<in> am_assn\\<^sup>k \\<rightarrow>\\<^sub>a n_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n_init_impl s t, PR_CONST n_init)\n    \\<in> local.am_assn\\<^sup>k \\<rightarrow>\\<^sub>a n_assn", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat \\<Rightarrow> nat list);\n        nofail (PR_CONST n_init x)\\<rbrakk>\n       \\<Longrightarrow> <local.am_assn x\n                           xi> n_init_impl s t\n                                xi <\\<lambda>r.\n local.am_assn x xi *\n (\\<exists>\\<^sub>Axa.\n     n_assn xa r * \\<up> (return xa \\<le> PR_CONST n_init x))>\\<^sub>t", "unfolding am_assn_def n_assn_def n_init_impl_def n_init_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE(nat \\<Rightarrow> nat list);\n        nofail\n         (PR_CONST (\\<lambda>am. return (am(s := [], t := []))) x)\\<rbrakk>\n       \\<Longrightarrow> <is_nf N [] x\n                           xi> array_copy xi \\<bind>\n                               (\\<lambda>n.\n                                   Array.upd s [] n \\<bind>\n                                   (\\<lambda>n.\n Array.upd t [] n \\<bind>\n return)) <\\<lambda>r.\n              is_nf N [] x xi *\n              (\\<exists>\\<^sub>Axa.\n                  is_nf N [] xa r *\n                  \\<up>\n                   (return xa\n                    \\<le> PR_CONST\n                           (\\<lambda>am. return (am(s := [], t := [])))\n                           x))>\\<^sub>t", "by (sep_auto)"], ["", "definition (in -) \"n_at_end_impl n u \\<equiv> do {\n  nu \\<leftarrow> Array.nth n u;\n  return (is_Nil nu)\n}\""], ["", "lemma [sepref_fr_rules]: \n  \"(uncurry n_at_end_impl, uncurry (PR_CONST n_at_end)) \n  \\<in> n_assn\\<^sup>k *\\<^sub>a node_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry n_at_end_impl, uncurry (PR_CONST n_at_end))\n    \\<in> n_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> nat list);\n        b ::\\<^sub>i TYPE(nat); nofail (PR_CONST n_at_end a b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          n_assn a\n                           ai> n_at_end_impl ai\n                                bi <\\<lambda>r.\n \\<up> ((bi, b) \\<in> nat_rel) * n_assn a ai *\n (\\<exists>\\<^sub>Ax.\n     \\<up> ((r, x) \\<in> bool_rel) *\n     \\<up> (return x \\<le> PR_CONST n_at_end a b))>\\<^sub>t", "unfolding n_at_end_impl_def n_at_end_def n_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> nat list);\n        b ::\\<^sub>i TYPE(nat);\n        nofail\n         (PR_CONST\n           (\\<lambda>n u.\n               assert (u \\<in> V - {s, t}) \\<bind>\n               (\\<lambda>_. return (n u = [])))\n           a b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          is_nf N [] a\n                           ai> Array.nth ai bi \\<bind>\n                               (\\<lambda>nu.\n                                   return\n                                    (is_Nil\nnu)) <\\<lambda>r.\n         \\<up> ((bi, b) \\<in> nat_rel) * is_nf N [] a ai *\n         (\\<exists>\\<^sub>Ax.\n             \\<up> ((r, x) \\<in> bool_rel) *\n             \\<up>\n              (return x\n               \\<le> PR_CONST\n                      (\\<lambda>n u.\n                          assert (u \\<in> V - {s, t}) \\<bind>\n                          (\\<lambda>_. return (n u = [])))\n                      a b))>\\<^sub>t", "by (sep_auto simp: refine_pw_simps split: list.split)"], ["", "definition (in -) \"n_get_hd_impl n u \\<equiv> do {\n  nu \\<leftarrow> Array.nth n u;\n  return (hd nu)\n}\""], ["", "lemma [sepref_fr_rules]: \n  \"(uncurry n_get_hd_impl, uncurry (PR_CONST n_get_hd)) \n  \\<in> n_assn\\<^sup>k *\\<^sub>a node_assn\\<^sup>k \\<rightarrow>\\<^sub>a node_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry n_get_hd_impl, uncurry (PR_CONST n_get_hd))\n    \\<in> n_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> nat list);\n        b ::\\<^sub>i TYPE(nat); nofail (PR_CONST n_get_hd a b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          n_assn a\n                           ai> n_get_hd_impl ai\n                                bi <\\<lambda>r.\n \\<up> ((bi, b) \\<in> nat_rel) * n_assn a ai *\n (\\<exists>\\<^sub>Ax.\n     \\<up> ((r, x) \\<in> nat_rel) *\n     \\<up> (return x \\<le> PR_CONST n_get_hd a b))>\\<^sub>t", "unfolding n_get_hd_impl_def n_get_hd_def n_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> nat list);\n        b ::\\<^sub>i TYPE(nat);\n        nofail\n         (PR_CONST\n           (\\<lambda>n u.\n               assert (u \\<in> V - {s, t} \\<and> n u \\<noteq> []) \\<bind>\n               (\\<lambda>_. return (hd (n u))))\n           a b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          is_nf N [] a\n                           ai> Array.nth ai bi \\<bind>\n                               (\\<lambda>nu.\n                                   return\n                                    (hd\nnu)) <\\<lambda>r.\n         \\<up> ((bi, b) \\<in> nat_rel) * is_nf N [] a ai *\n         (\\<exists>\\<^sub>Ax.\n             \\<up> ((r, x) \\<in> nat_rel) *\n             \\<up>\n              (return x\n               \\<le> PR_CONST\n                      (\\<lambda>n u.\n                          assert\n                           (u \\<in> V - {s, t} \\<and>\n                            n u \\<noteq> []) \\<bind>\n                          (\\<lambda>_. return (hd (n u))))\n                      a b))>\\<^sub>t", "by (sep_auto simp: refine_pw_simps)"], ["", "definition (in -) \"n_move_next_impl n u \\<equiv> do {\n  nu \\<leftarrow> Array.nth n u;\n  n \\<leftarrow> Array.upd u (tl nu) n;\n  return n\n}\""], ["", "lemma [sepref_fr_rules]: \n  \"(uncurry n_move_next_impl, uncurry (PR_CONST n_move_next)) \n  \\<in> n_assn\\<^sup>d *\\<^sub>a node_assn\\<^sup>k \\<rightarrow>\\<^sub>a n_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry n_move_next_impl, uncurry (PR_CONST n_move_next))\n    \\<in> n_assn\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a n_assn", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> nat list);\n        b ::\\<^sub>i TYPE(nat); nofail (PR_CONST n_move_next a b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          n_assn a\n                           ai> n_move_next_impl ai\n                                bi <\\<lambda>r.\n \\<up> ((bi, b) \\<in> nat_rel) * true *\n (\\<exists>\\<^sub>Ax.\n     n_assn x r * \\<up> (return x \\<le> PR_CONST n_move_next a b))>\\<^sub>t", "unfolding n_move_next_impl_def n_move_next_def n_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> nat list);\n        b ::\\<^sub>i TYPE(nat);\n        nofail\n         (PR_CONST\n           (\\<lambda>n u.\n               assert (u \\<in> V - {s, t} \\<and> n u \\<noteq> []) \\<bind>\n               (\\<lambda>_. return (map_entry u tl n)))\n           a b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          is_nf N [] a\n                           ai> Array.nth ai bi \\<bind>\n                               (\\<lambda>nu.\n                                   Array.upd bi (tl nu) ai \\<bind>\n                                   return) <\\<lambda>r.\n         \\<up> ((bi, b) \\<in> nat_rel) * true *\n         (\\<exists>\\<^sub>Ax.\n             is_nf N [] x r *\n             \\<up>\n              (return x\n               \\<le> PR_CONST\n                      (\\<lambda>n u.\n                          assert\n                           (u \\<in> V - {s, t} \\<and>\n                            n u \\<noteq> []) \\<bind>\n                          (\\<lambda>_. return (map_entry u tl n)))\n                      a b))>\\<^sub>t", "by (sep_auto simp: refine_pw_simps)"], ["", "definition (in -) \"n_reset_impl am n u \\<equiv> do {\n  nu \\<leftarrow> Array.nth am u;\n  n \\<leftarrow> Array.upd u nu n;\n  return n\n}\""], ["", "lemma [sepref_fr_rules]: \n  \"(uncurry2 n_reset_impl, uncurry2 (PR_CONST n_reset)) \n  \\<in> am_assn\\<^sup>k *\\<^sub>a n_assn\\<^sup>d *\\<^sub>a node_assn\\<^sup>k \\<rightarrow>\\<^sub>a n_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 n_reset_impl, uncurry2 (PR_CONST n_reset))\n    \\<in> local.am_assn\\<^sup>k *\\<^sub>a n_assn\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a n_assn", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi ba bia a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> nat list);\n        ba ::\\<^sub>i TYPE(nat \\<Rightarrow> nat list);\n        b ::\\<^sub>i TYPE(nat); nofail (PR_CONST n_reset a ba b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) * n_assn ba bia *\n                          local.am_assn a\n                           ai> n_reset_impl ai bia\n                                bi <\\<lambda>r.\n \\<up> ((bi, b) \\<in> nat_rel) * true * local.am_assn a ai *\n (\\<exists>\\<^sub>Ax.\n     n_assn x r * \\<up> (return x \\<le> PR_CONST n_reset a ba b))>\\<^sub>t", "unfolding n_reset_impl_def n_reset_def n_assn_def am_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi ba bia a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE(nat \\<Rightarrow> nat list);\n        ba ::\\<^sub>i TYPE(nat \\<Rightarrow> nat list);\n        b ::\\<^sub>i TYPE(nat);\n        nofail\n         (PR_CONST\n           (\\<lambda>am n u.\n               assert (u \\<in> V - {s, t}) \\<bind>\n               (\\<lambda>_. return (n(u := am u))))\n           a ba b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          is_nf N [] ba bia *\n                          is_nf N [] a\n                           ai> Array.nth ai bi \\<bind>\n                               (\\<lambda>nu.\n                                   Array.upd bi nu bia \\<bind>\n                                   return) <\\<lambda>r.\n         \\<up> ((bi, b) \\<in> nat_rel) * true * is_nf N [] a ai *\n         (\\<exists>\\<^sub>Ax.\n             is_nf N [] x r *\n             \\<up>\n              (return x\n               \\<le> PR_CONST\n                      (\\<lambda>am n u.\n                          assert (u \\<in> V - {s, t}) \\<bind>\n                          (\\<lambda>_. return (n(u := am u))))\n                      a ba b))>\\<^sub>t", "by (sep_auto simp: refine_pw_simps)"], ["", "subsubsection \\<open>Discharge\\<close>"], ["", "sepref_thm discharge_impl is \"uncurry5 (PR_CONST discharge2)\" \n  :: \"am_assn\\<^sup>k *\\<^sub>a x_assn\\<^sup>d *\\<^sub>a cf_assn\\<^sup>d *\\<^sub>a l_assn\\<^sup>d *\\<^sub>a n_assn\\<^sup>d *\\<^sub>a node_assn\\<^sup>k \n    \\<rightarrow>\\<^sub>a (x_assn \\<times>\\<^sub>a cf_assn) \\<times>\\<^sub>a l_assn \\<times>\\<^sub>a n_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry2 (uncurry ?f6)),\n     uncurry2 (uncurry2 (uncurry (PR_CONST discharge2))))\n    \\<in> local.am_assn\\<^sup>k *\\<^sub>a x_assn\\<^sup>d *\\<^sub>a\n          local.cf_assn\\<^sup>d *\\<^sub>a\n          l_assn\\<^sup>d *\\<^sub>a\n          n_assn\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a (x_assn \\<times>\\<^sub>a\n            local.cf_assn) \\<times>\\<^sub>a\n           l_assn \\<times>\\<^sub>a n_assn", "unfolding discharge2_def PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (uncurry2 (uncurry ?f6)),\n     uncurry2\n      (uncurry2\n        (uncurry\n          (\\<lambda>am x cf l n u.\n              assert (u \\<in> V) \\<bind>\n              (\\<lambda>_.\n                  monadic_WHILEIT (\\<lambda>_. True)\n                   (\\<lambda>((x, cf), l, n).\n                       x_get x u \\<bind>\n                       (\\<lambda>xu. return (xu \\<noteq> 0)))\n                   (\\<lambda>((x, cf), l, n).\n                       n_at_end n u \\<bind>\n                       (\\<lambda>at_end.\n                           if at_end\n                           then relabel2 am cf l u \\<bind>\n                                (\\<lambda>l.\n                                    n_reset am n u \\<bind>\n                                    (\\<lambda>n. return ((x, cf), l, n)))\n                           else n_get_hd n u \\<bind>\n                                (\\<lambda>v.\n                                    cf_get cf (u, v) \\<bind>\n                                    (\\<lambda>cfuv.\n  l_get l u \\<bind>\n  (\\<lambda>lu.\n      l_get l v \\<bind>\n      (\\<lambda>lv.\n          if cfuv \\<noteq> 0 \\<and> lu = lv + 1\n          then push2 x cf (u, v) \\<bind>\n               (\\<lambda>(x, cf). return ((x, cf), l, n))\n          else n_move_next n u \\<bind>\n               (\\<lambda>n. return ((x, cf), l, n))))))))\n                   ((x, cf), l, n))))))\n    \\<in> local.am_assn\\<^sup>k *\\<^sub>a x_assn\\<^sup>d *\\<^sub>a\n          local.cf_assn\\<^sup>d *\\<^sub>a\n          l_assn\\<^sup>d *\\<^sub>a\n          n_assn\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a (x_assn \\<times>\\<^sub>a\n            local.cf_assn) \\<times>\\<^sub>a\n           l_assn \\<times>\\<^sub>a n_assn", "by sepref"], ["", "concrete_definition (in -) discharge_impl \n  uses Network_Impl.discharge_impl.refine_raw is \"(uncurry5 ?f,_)\\<in>_\""], ["", "lemmas [sepref_fr_rules] = discharge_impl.refine[OF Network_Impl_axioms]"], ["", "subsubsection \\<open>Initialization of Queue\\<close>"], ["", "sepref_thm init_CQ_impl is \"(PR_CONST init_CQ)\" \n  :: \"am_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a list_assn nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, PR_CONST init_CQ)\n    \\<in> local.am_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n                list_assn nat_assn", "unfolding init_CQ_def PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>am.\n        let cardV = 0; Q = []\n        in nfoldli [0..<N] (\\<lambda>_. True)\n            (\\<lambda>v (cardV, Q).\n                assert (v < N) \\<bind>\n                (\\<lambda>_.\n                    am_is_in_V am v \\<bind>\n                    (\\<lambda>inV.\n                        if inV\n                        then let cardV = cardV + 1\n                             in if v \\<noteq> s \\<and> v \\<noteq> t\n                                then return (cardV, v # Q)\n                                else return (cardV, Q)\n                        else return (cardV, Q))))\n            (cardV, Q))\n    \\<in> local.am_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n                list_assn nat_assn", "apply (rewrite HOL_list.fold_custom_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>am.\n        let cardV = 0; Q = op_HOL_list_empty\n        in nfoldli [0..<N] (\\<lambda>_. True)\n            (\\<lambda>v (cardV, Q).\n                assert (v < N) \\<bind>\n                (\\<lambda>_.\n                    am_is_in_V am v \\<bind>\n                    (\\<lambda>inV.\n                        if inV\n                        then let cardV = cardV + 1\n                             in if v \\<noteq> s \\<and> v \\<noteq> t\n                                then return (cardV, v # Q)\n                                else return (cardV, Q)\n                        else return (cardV, Q))))\n            (cardV, Q))\n    \\<in> local.am_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn \\<times>\\<^sub>a\n                list_assn nat_assn", "by sepref"], ["", "concrete_definition (in -) init_CQ_impl \n  uses Network_Impl.init_CQ_impl.refine_raw is \"(?f,_)\\<in>_\""], ["", "lemmas [sepref_fr_rules] = init_CQ_impl.refine[OF Network_Impl_axioms]"], ["", "subsubsection \\<open>Main Algorithm\\<close>"], ["", "sepref_thm relabel_to_front_impl is \n  \"(PR_CONST relabel_to_front2)\" :: \"am_assn\\<^sup>k \\<rightarrow>\\<^sub>a cf_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, PR_CONST relabel_to_front2)\n    \\<in> local.am_assn\\<^sup>k \\<rightarrow>\\<^sub>a local.cf_assn", "unfolding relabel_to_front2_def PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>am.\n        init_CQ am \\<bind>\n        (\\<lambda>(cardV, L_right).\n            pp_init_xcf2 am \\<bind>\n            (\\<lambda>xcf.\n                l_init cardV \\<bind>\n                (\\<lambda>l.\n                    n_init am \\<bind>\n                    (\\<lambda>n.\n                        let L_left = []\n                        in while\\<^sub>T\n                            (\\<lambda>((x, cf), l, n, L_left, L_right).\n                                L_right \\<noteq> [])\n                            (\\<lambda>((x, cf), l, n, L_left, L_right).\n                                assert (L_right \\<noteq> []) \\<bind>\n                                (\\<lambda>_.\n                                    let u = hd L_right\n                                    in l_get l u \\<bind>\n (\\<lambda>old_lu.\n     discharge2 am x cf l n u \\<bind>\n     (\\<lambda>((x, cf), l, n).\n         l_get l u \\<bind>\n         (\\<lambda>lu.\n             if lu \\<noteq> old_lu\n             then let (L_left, L_right) =\n                        ([u], rev_append L_left (tl L_right))\n                  in return ((x, cf), l, n, L_left, L_right)\n             else let (L_left, L_right) = (u # L_left, tl L_right)\n                  in return ((x, cf), l, n, L_left, L_right))))))\n                            (xcf, l, n, L_left, L_right) \\<bind>\n                           (\\<lambda>((x, cf), l, n, L_left, L_right).\n                               return cf))))))\n    \\<in> local.am_assn\\<^sup>k \\<rightarrow>\\<^sub>a local.cf_assn", "supply [[goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>am.\n        init_CQ am \\<bind>\n        (\\<lambda>(cardV, L_right).\n            pp_init_xcf2 am \\<bind>\n            (\\<lambda>xcf.\n                l_init cardV \\<bind>\n                (\\<lambda>l.\n                    n_init am \\<bind>\n                    (\\<lambda>n.\n                        let L_left = []\n                        in while\\<^sub>T\n                            (\\<lambda>((x, cf), l, n, L_left, L_right).\n                                L_right \\<noteq> [])\n                            (\\<lambda>((x, cf), l, n, L_left, L_right).\n                                assert (L_right \\<noteq> []) \\<bind>\n                                (\\<lambda>_.\n                                    let u = hd L_right\n                                    in l_get l u \\<bind>\n (\\<lambda>old_lu.\n     discharge2 am x cf l n u \\<bind>\n     (\\<lambda>((x, cf), l, n).\n         l_get l u \\<bind>\n         (\\<lambda>lu.\n             if lu \\<noteq> old_lu\n             then let (L_left, L_right) =\n                        ([u], rev_append L_left (tl L_right))\n                  in return ((x, cf), l, n, L_left, L_right)\n             else let (L_left, L_right) = (u # L_left, tl L_right)\n                  in return ((x, cf), l, n, L_left, L_right))))))\n                            (xcf, l, n, L_left, L_right) \\<bind>\n                           (\\<lambda>((x, cf), l, n, L_left, L_right).\n                               return cf))))))\n    \\<in> local.am_assn\\<^sup>k \\<rightarrow>\\<^sub>a local.cf_assn", "apply (rewrite in \"Let [] _\" HOL_list.fold_custom_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>am.\n        init_CQ am \\<bind>\n        (\\<lambda>(cardV, L_right).\n            pp_init_xcf2 am \\<bind>\n            (\\<lambda>xcf.\n                l_init cardV \\<bind>\n                (\\<lambda>l.\n                    n_init am \\<bind>\n                    (\\<lambda>n.\n                        let L_left = op_HOL_list_empty\n                        in while\\<^sub>T\n                            (\\<lambda>((x, cf), l, n, L_left, L_right).\n                                L_right \\<noteq> [])\n                            (\\<lambda>((x, cf), l, n, L_left, L_right).\n                                assert (L_right \\<noteq> []) \\<bind>\n                                (\\<lambda>_.\n                                    let u = hd L_right\n                                    in l_get l u \\<bind>\n (\\<lambda>old_lu.\n     discharge2 am x cf l n u \\<bind>\n     (\\<lambda>((x, cf), l, n).\n         l_get l u \\<bind>\n         (\\<lambda>lu.\n             if lu \\<noteq> old_lu\n             then let (L_left, L_right) =\n                        ([u], rev_append L_left (tl L_right))\n                  in return ((x, cf), l, n, L_left, L_right)\n             else let (L_left, L_right) = (u # L_left, tl L_right)\n                  in return ((x, cf), l, n, L_left, L_right))))))\n                            (xcf, l, n, L_left, L_right) \\<bind>\n                           (\\<lambda>((x, cf), l, n, L_left, L_right).\n                               return cf))))))\n    \\<in> local.am_assn\\<^sup>k \\<rightarrow>\\<^sub>a local.cf_assn", "apply (rewrite in \"[_]\" HOL_list.fold_custom_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>am.\n        init_CQ am \\<bind>\n        (\\<lambda>(cardV, L_right).\n            pp_init_xcf2 am \\<bind>\n            (\\<lambda>xcf.\n                l_init cardV \\<bind>\n                (\\<lambda>l.\n                    n_init am \\<bind>\n                    (\\<lambda>n.\n                        let L_left = op_HOL_list_empty\n                        in while\\<^sub>T\n                            (\\<lambda>((x, cf), l, n, L_left, L_right).\n                                L_right \\<noteq> [])\n                            (\\<lambda>((x, cf), l, n, L_left, L_right).\n                                assert (L_right \\<noteq> []) \\<bind>\n                                (\\<lambda>_.\n                                    let u = hd L_right\n                                    in l_get l u \\<bind>\n (\\<lambda>old_lu.\n     discharge2 am x cf l n u \\<bind>\n     (\\<lambda>((x, cf), l, n).\n         l_get l u \\<bind>\n         (\\<lambda>lu.\n             if lu \\<noteq> old_lu\n             then let (L_left, L_right) =\n                        (u # op_HOL_list_empty,\n                         rev_append L_left (tl L_right))\n                  in return ((x, cf), l, n, L_left, L_right)\n             else let (L_left, L_right) = (u # L_left, tl L_right)\n                  in return ((x, cf), l, n, L_left, L_right))))))\n                            (xcf, l, n, L_left, L_right) \\<bind>\n                           (\\<lambda>((x, cf), l, n, L_left, L_right).\n                               return cf))))))\n    \\<in> local.am_assn\\<^sup>k \\<rightarrow>\\<^sub>a local.cf_assn", "by sepref"], ["", "concrete_definition (in -) relabel_to_front_impl \n  uses Network_Impl.relabel_to_front_impl.refine_raw is \"(?f,_)\\<in>_\""], ["", "lemmas [sepref_fr_rules] = relabel_to_front_impl.refine[OF Network_Impl_axioms]"], ["", "end \\<comment> \\<open>Network Implementation Locale\\<close>"], ["", "export_code relabel_to_front_impl checking SML_imp"], ["", "subsection \\<open>Combination with Network Checker and Correctness\\<close>"], ["", "context Network_Impl begin"], ["", "theorem relabel_to_front_impl_correct[sep_heap_rules]: \n    assumes AM: \"is_adj_map am\"\n    shows \"\n      <am_assn am ami> \n        relabel_to_front_impl c s t N ami\n      <\\<lambda>cfi. \\<exists>\\<^sub>Acf. cf_assn cf cfi \n                * \\<up>(isMaxFlow (flow_of_cf cf) \\<and> RGraph_Impl c s t N cf)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <local.am_assn am\n      ami> relabel_to_front_impl c s t N\n            ami <\\<lambda>r.\n                    \\<exists>\\<^sub>Acf.\n                       local.cf_assn cf r *\n                       \\<up>\n                        (isMaxFlow (flow_of_cf cf) \\<and>\n                         RGraph_Impl c s t N cf)>\\<^sub>t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <local.am_assn am\n      ami> relabel_to_front_impl c s t N\n            ami <\\<lambda>r.\n                    \\<exists>\\<^sub>Acf.\n                       local.cf_assn cf r *\n                       \\<up>\n                        (isMaxFlow (flow_of_cf cf) \\<and>\n                         RGraph_Impl c s t N cf)>\\<^sub>t", "note relabel_to_front2_refine[OF AM]"], ["proof (state)\nthis:\n  relabel_to_front2 am\n  \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t)) relabel_to_front\n\ngoal (1 subgoal):\n 1. <local.am_assn am\n      ami> relabel_to_front_impl c s t N\n            ami <\\<lambda>r.\n                    \\<exists>\\<^sub>Acf.\n                       local.cf_assn cf r *\n                       \\<up>\n                        (isMaxFlow (flow_of_cf cf) \\<and>\n                         RGraph_Impl c s t N cf)>\\<^sub>t", "also"], ["proof (state)\nthis:\n  relabel_to_front2 am\n  \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t)) relabel_to_front\n\ngoal (1 subgoal):\n 1. <local.am_assn am\n      ami> relabel_to_front_impl c s t N\n            ami <\\<lambda>r.\n                    \\<exists>\\<^sub>Acf.\n                       local.cf_assn cf r *\n                       \\<up>\n                        (isMaxFlow (flow_of_cf cf) \\<and>\n                         RGraph_Impl c s t N cf)>\\<^sub>t", "note relabel_to_front_correct"], ["proof (state)\nthis:\n  relabel_to_front \\<le> SPEC isMaxFlow\n\ngoal (1 subgoal):\n 1. <local.am_assn am\n      ami> relabel_to_front_impl c s t N\n            ami <\\<lambda>r.\n                    \\<exists>\\<^sub>Acf.\n                       local.cf_assn cf r *\n                       \\<up>\n                        (isMaxFlow (flow_of_cf cf) \\<and>\n                         RGraph_Impl c s t N cf)>\\<^sub>t", "finally"], ["proof (chain)\npicking this:\n  relabel_to_front2 am\n  \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t)) (SPEC isMaxFlow)", "have R1: \n      \"relabel_to_front2 am \n      \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t)) (SPEC isMaxFlow)\""], ["proof (prove)\nusing this:\n  relabel_to_front2 am\n  \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t)) (SPEC isMaxFlow)\n\ngoal (1 subgoal):\n 1. relabel_to_front2 am\n    \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t)) (SPEC isMaxFlow)", "."], ["proof (state)\nthis:\n  relabel_to_front2 am\n  \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t)) (SPEC isMaxFlow)\n\ngoal (1 subgoal):\n 1. <local.am_assn am\n      ami> relabel_to_front_impl c s t N\n            ami <\\<lambda>r.\n                    \\<exists>\\<^sub>Acf.\n                       local.cf_assn cf r *\n                       \\<up>\n                        (isMaxFlow (flow_of_cf cf) \\<and>\n                         RGraph_Impl c s t N cf)>\\<^sub>t", "have [simp]: \"nofail (\\<Down>R (RES X))\" for R X"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (\\<Down> R (RES X))", "by (auto simp: refine_pw_simps)"], ["proof (state)\nthis:\n  nofail (\\<Down> ?R12 (RES ?X12))\n\ngoal (1 subgoal):\n 1. <local.am_assn am\n      ami> relabel_to_front_impl c s t N\n            ami <\\<lambda>r.\n                    \\<exists>\\<^sub>Acf.\n                       local.cf_assn cf r *\n                       \\<up>\n                        (isMaxFlow (flow_of_cf cf) \\<and>\n                         RGraph_Impl c s t N cf)>\\<^sub>t", "note R2 = relabel_to_front_impl.refine[\n      OF Network_Impl_axioms, to_hnr, unfolded autoref_tag_defs]"], ["proof (state)\nthis:\n  hn_refine (hn_ctxt local.am_assn ?x ?xi)\n   (relabel_to_front_impl c s t N ?xi) (hn_ctxt local.am_assn ?x ?xi)\n   local.cf_assn (relabel_to_front2 ?x)\n\ngoal (1 subgoal):\n 1. <local.am_assn am\n      ami> relabel_to_front_impl c s t N\n            ami <\\<lambda>r.\n                    \\<exists>\\<^sub>Acf.\n                       local.cf_assn cf r *\n                       \\<up>\n                        (isMaxFlow (flow_of_cf cf) \\<and>\n                         RGraph_Impl c s t N cf)>\\<^sub>t", "note R3 = hn_refine_ref[OF R1 R2, of ami]"], ["proof (state)\nthis:\n  hn_refine (hn_ctxt local.am_assn am ami)\n   (relabel_to_front_impl c s t N ami) (hn_ctxt local.am_assn am ami)\n   local.cf_assn\n   (\\<Down> (br flow_of_cf (RPreGraph c s t)) (SPEC isMaxFlow))\n\ngoal (1 subgoal):\n 1. <local.am_assn am\n      ami> relabel_to_front_impl c s t N\n            ami <\\<lambda>r.\n                    \\<exists>\\<^sub>Acf.\n                       local.cf_assn cf r *\n                       \\<up>\n                        (isMaxFlow (flow_of_cf cf) \\<and>\n                         RGraph_Impl c s t N cf)>\\<^sub>t", "note R4 = R3[unfolded hn_ctxt_def pure_def, THEN hn_refineD, simplified]"], ["proof (state)\nthis:\n  <local.am_assn am ami> relabel_to_front_impl c s t N ami\n  <\\<lambda>r.\n      \\<exists>\\<^sub>Ax.\n         local.am_assn am ami * local.cf_assn x r * true *\n         \\<up>\n          (return x\n           \\<le> \\<Down> (br flow_of_cf (RPreGraph c s t))\n                  (SPEC isMaxFlow))>\n\ngoal (1 subgoal):\n 1. <local.am_assn am\n      ami> relabel_to_front_impl c s t N\n            ami <\\<lambda>r.\n                    \\<exists>\\<^sub>Acf.\n                       local.cf_assn cf r *\n                       \\<up>\n                        (isMaxFlow (flow_of_cf cf) \\<and>\n                         RGraph_Impl c s t N cf)>\\<^sub>t", "note RGII = rgraph_and_network_impl_imp_rgraph_impl[OF \n      RPreGraph.maxflow_imp_rgraph\n      Network_Impl_axioms\n        ]"], ["proof (state)\nthis:\n  \\<lbrakk>RPreGraph c s t ?cf; isMaxFlow (flow_of_cf ?cf)\\<rbrakk>\n  \\<Longrightarrow> RGraph_Impl c s t N ?cf\n\ngoal (1 subgoal):\n 1. <local.am_assn am\n      ami> relabel_to_front_impl c s t N\n            ami <\\<lambda>r.\n                    \\<exists>\\<^sub>Acf.\n                       local.cf_assn cf r *\n                       \\<up>\n                        (isMaxFlow (flow_of_cf cf) \\<and>\n                         RGraph_Impl c s t N cf)>\\<^sub>t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. <local.am_assn am\n      ami> relabel_to_front_impl c s t N\n            ami <\\<lambda>r.\n                    \\<exists>\\<^sub>Acf.\n                       local.cf_assn cf r *\n                       \\<up>\n                        (isMaxFlow (flow_of_cf cf) \\<and>\n                         RGraph_Impl c s t N cf)>\\<^sub>t", "by (sep_auto heap: R4 simp: pw_le_iff refine_pw_simps in_br_conv RGII)"], ["proof (state)\nthis:\n  <local.am_assn am\n    ami> relabel_to_front_impl c s t N\n          ami <\\<lambda>r.\n                  \\<exists>\\<^sub>Acf.\n                     local.cf_assn cf r *\n                     \\<up>\n                      (isMaxFlow (flow_of_cf cf) \\<and>\n                       RGraph_Impl c s t N cf)>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "definition \"relabel_to_front_impl_tab_am c s t N am \\<equiv> do {\n  ami \\<leftarrow> Array.make N am;  \\<comment> \\<open>TODO/DUP: Called \\<open>init_ps\\<close> in Edmonds-Karp impl\\<close>\n  relabel_to_front_impl c s t N ami\n}\""], ["", "theorem relabel_to_front_impl_tab_am_correct[sep_heap_rules]: \n  assumes NW: \"Network c s t\"\n  assumes VN: \"Graph.V c \\<subseteq> {0..<N}\"\n  assumes ABS_PS: \"Graph.is_adj_map c am\"\n  shows \"\n    <emp> \n      relabel_to_front_impl_tab_am c s t N am\n    <\\<lambda>cfi. \\<exists>\\<^sub>Acf. \n        asmtx_assn N id_assn cf cfi \n      * \\<up>(Network.isMaxFlow c s t (Network.flow_of_cf c cf)\n        \\<and> RGraph_Impl c s t N cf\n        )>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> relabel_to_front_impl_tab_am c s t N\n           am <\\<lambda>r.\n                  \\<exists>\\<^sub>Acf.\n                     asmtx_assn N cap_assn cf r *\n                     \\<up>\n                      (Network.isMaxFlow c s t\n                        (Network.flow_of_cf c cf) \\<and>\n                       RGraph_Impl c s t N cf)>\\<^sub>t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <emp> relabel_to_front_impl_tab_am c s t N\n           am <\\<lambda>r.\n                  \\<exists>\\<^sub>Acf.\n                     asmtx_assn N cap_assn cf r *\n                     \\<up>\n                      (Network.isMaxFlow c s t\n                        (Network.flow_of_cf c cf) \\<and>\n                       RGraph_Impl c s t N cf)>\\<^sub>t", "interpret Network c s t"], ["proof (prove)\ngoal (1 subgoal):\n 1. Network c s t", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. <emp> relabel_to_front_impl_tab_am c s t N\n           am <\\<lambda>r.\n                  \\<exists>\\<^sub>Acf.\n                     asmtx_assn N cap_assn cf r *\n                     \\<up>\n                      (isMaxFlow (flow_of_cf cf) \\<and>\n                       RGraph_Impl c s t N cf)>\\<^sub>t", "interpret Network_Impl c s t N"], ["proof (prove)\ngoal (1 subgoal):\n 1. Network_Impl c s t N", "using VN"], ["proof (prove)\nusing this:\n  V \\<subseteq> {0..<N}\n\ngoal (1 subgoal):\n 1. Network_Impl c s t N", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. <emp> relabel_to_front_impl_tab_am c s t N\n           am <\\<lambda>r.\n                  \\<exists>\\<^sub>Acf.\n                     asmtx_assn N cap_assn cf r *\n                     \\<up>\n                      (isMaxFlow (flow_of_cf cf) \\<and>\n                       RGraph_Impl c s t N cf)>\\<^sub>t", "from ABS_PS"], ["proof (chain)\npicking this:\n  is_adj_map am", "have [simp]: \"am u = []\" if \"u\\<ge>N\" for u"], ["proof (prove)\nusing this:\n  is_adj_map am\n\ngoal (1 subgoal):\n 1. am u = []", "unfolding is_adj_map_def"], ["proof (prove)\nusing this:\n  \\<forall>u.\n     distinct (am u) \\<and>\n     set (am u) = E `` {u} \\<union> E\\<inverse> `` {u}\n\ngoal (1 subgoal):\n 1. am u = []", "using E_ss_VxV VN that"], ["proof (prove)\nusing this:\n  \\<forall>u.\n     distinct (am u) \\<and>\n     set (am u) = E `` {u} \\<union> E\\<inverse> `` {u}\n  E \\<subseteq> V \\<times> V\n  V \\<subseteq> {0..<N}\n  N \\<le> u\n\ngoal (1 subgoal):\n 1. am u = []", "apply (subgoal_tac \"u\\<notin>V\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>u.\n                distinct (am u) \\<and>\n                set (am u) = E `` {u} \\<union> E\\<inverse> `` {u};\n     E \\<subseteq> V \\<times> V; V \\<subseteq> {0..<N}; N \\<le> u;\n     u \\<notin> V\\<rbrakk>\n    \\<Longrightarrow> am u = []\n 2. \\<lbrakk>\\<forall>u.\n                distinct (am u) \\<and>\n                set (am u) = E `` {u} \\<union> E\\<inverse> `` {u};\n     E \\<subseteq> V \\<times> V; V \\<subseteq> {0..<N}; N \\<le> u\\<rbrakk>\n    \\<Longrightarrow> u \\<notin> V", "by (auto simp del: inV_less_N)"], ["proof (state)\nthis:\n  N \\<le> ?u1 \\<Longrightarrow> am ?u1 = []\n\ngoal (1 subgoal):\n 1. <emp> relabel_to_front_impl_tab_am c s t N\n           am <\\<lambda>r.\n                  \\<exists>\\<^sub>Acf.\n                     asmtx_assn N cap_assn cf r *\n                     \\<up>\n                      (isMaxFlow (flow_of_cf cf) \\<and>\n                       RGraph_Impl c s t N cf)>\\<^sub>t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> relabel_to_front_impl_tab_am c s t N\n           am <\\<lambda>r.\n                  \\<exists>\\<^sub>Acf.\n                     asmtx_assn N cap_assn cf r *\n                     \\<up>\n                      (isMaxFlow (flow_of_cf cf) \\<and>\n                       RGraph_Impl c s t N cf)>\\<^sub>t", "unfolding relabel_to_front_impl_tab_am_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> Array.make N am \\<bind>\n          relabel_to_front_impl c s t\n           N <\\<lambda>r.\n                 \\<exists>\\<^sub>Acf.\n                    asmtx_assn N cap_assn cf r *\n                    \\<up>\n                     (isMaxFlow (flow_of_cf cf) \\<and>\n                      RGraph_Impl c s t N cf)>\\<^sub>t", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       <x \\<mapsto>\\<^sub>a map am [0..<N]> relabel_to_front_impl c s t N x\n       <\\<lambda>r.\n           \\<exists>\\<^sub>Acf.\n              asmtx_assn N cap_assn cf r * true *\n              \\<up>\n               (isMaxFlow (flow_of_cf cf) \\<and> RGraph_Impl c s t N cf)>", "apply (rule \n        Hoare_Triple.cons_rule[OF _ _ relabel_to_front_impl_correct[OF ABS_PS]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<mapsto>\\<^sub>a map am [0..<N] \\<Longrightarrow>\\<^sub>A\n       local.am_assn am x\n 2. \\<And>x xa.\n       (\\<exists>\\<^sub>Acf.\n           local.cf_assn cf xa *\n           \\<up>\n            (isMaxFlow (flow_of_cf cf) \\<and> RGraph_Impl c s t N cf)) *\n       true \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Acf.\n          asmtx_assn N cap_assn cf xa * true *\n          \\<up> (isMaxFlow (flow_of_cf cf) \\<and> RGraph_Impl c s t N cf)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<mapsto>\\<^sub>a map am [0..<N] \\<Longrightarrow>\\<^sub>A\n    local.am_assn am x_", "unfolding am_assn_def is_nf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<mapsto>\\<^sub>a map am [0..<N] \\<Longrightarrow>\\<^sub>A\n    \\<exists>\\<^sub>Al.\n       x_ \\<mapsto>\\<^sub>a l *\n       \\<up>\n        (length l = N \\<and>\n         (\\<forall>i<N. l ! i = am i) \\<and> (\\<forall>i\\<ge>N. am i = []))", "by sep_auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (\\<exists>\\<^sub>Acf.\n           local.cf_assn cf xa *\n           \\<up>\n            (isMaxFlow (flow_of_cf cf) \\<and> RGraph_Impl c s t N cf)) *\n       true \\<Longrightarrow>\\<^sub>A\n       \\<exists>\\<^sub>Acf.\n          asmtx_assn N cap_assn cf xa * true *\n          \\<up> (isMaxFlow (flow_of_cf cf) \\<and> RGraph_Impl c s t N cf)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>Acf.\n        local.cf_assn cf xa_ *\n        \\<up> (isMaxFlow (flow_of_cf cf) \\<and> RGraph_Impl c s t N cf)) *\n    true \\<Longrightarrow>\\<^sub>A\n    \\<exists>\\<^sub>Acf.\n       asmtx_assn N cap_assn cf xa_ * true *\n       \\<up> (isMaxFlow (flow_of_cf cf) \\<and> RGraph_Impl c s t N cf)", "unfolding cf_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<^sub>Acf.\n        asmtx_assn N cap_assn cf xa_ *\n        \\<up> (isMaxFlow (flow_of_cf cf) \\<and> RGraph_Impl c s t N cf)) *\n    true \\<Longrightarrow>\\<^sub>A\n    \\<exists>\\<^sub>Acf.\n       asmtx_assn N cap_assn cf xa_ * true *\n       \\<up> (isMaxFlow (flow_of_cf cf) \\<and> RGraph_Impl c s t N cf)", "by sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <emp> relabel_to_front_impl_tab_am c s t N\n         am <\\<lambda>r.\n                \\<exists>\\<^sub>Acf.\n                   asmtx_assn N cap_assn cf r *\n                   \\<up>\n                    (isMaxFlow (flow_of_cf cf) \\<and>\n                     RGraph_Impl c s t N cf)>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"relabel_to_front el s t \\<equiv> do {\n  case prepareNet el s t of\n    None \\<Rightarrow> return None\n  | Some (c,am,N) \\<Rightarrow> do {\n      cf \\<leftarrow> relabel_to_front_impl_tab_am c s t N am;\n      return (Some (c,am,N,cf))\n  }\n}\""], ["", "export_code relabel_to_front checking SML_imp"], ["", "text \\<open>\n  Main correctness statement:\n  \\<^item> If \\<open>relabel_to_front\\<close> returns \\<open>None\\<close>, the edge list was invalid or described \n    an invalid network. \n  \\<^item> If it returns \\<open>Some (c,am,N,cfi)\\<close>, then the edge list is valid and describes\n    a valid network. Moreover, \\<open>cfi\\<close> is an integer square matrix of \n    dimension \\<open>N\\<close>, which describes a valid residual graph in the network, whose\n    corresponding flow is maximal. Finally, \\<open>am\\<close> is a valid adjacency map of the\n    graph, and the nodes of the graph are integers less than \\<open>N\\<close>.\n\\<close>"], ["", "theorem relabel_to_front_correct:\n  \"<emp>\n  relabel_to_front el s t\n  <\\<lambda>\n    None \\<Rightarrow> \\<up>(\\<not>ln_invar el \\<or> \\<not>Network (ln_\\<alpha> el) s t)\n  | Some (c,am,N,cfi) \\<Rightarrow> \n      \\<up>(c = ln_\\<alpha> el \\<and> ln_invar el) \n    * (\\<exists>\\<^sub>Acf. asmtx_assn N int_assn cf cfi\n          * \\<up>(RGraph_Impl c s t N cf \n            \\<and> Network.isMaxFlow c s t (Network.flow_of_cf c cf))) \n    * \\<up>(Graph.is_adj_map c am)\n  >\\<^sub>t\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> relabel_to_front el s\n           t <\\<lambda>r.\n                 case r of\n                 None \\<Rightarrow>\n                   \\<up>\n                    (\\<not> ln_invar el \\<or>\n                     \\<not> Network (ln_\\<alpha> el) s t)\n                 | Some (c, am, N, cfi) \\<Rightarrow>\n                     \\<up> (c = ln_\\<alpha> el \\<and> ln_invar el) *\n                     (\\<exists>\\<^sub>Acf.\n                         asmtx_assn N cap_assn cf cfi *\n                         \\<up>\n                          (RGraph_Impl c s t N cf \\<and>\n                           Network.isMaxFlow c s t\n                            (Network.flow_of_cf c cf))) *\n                     \\<up> (Graph.is_adj_map c am)>\\<^sub>t", "unfolding relabel_to_front_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> case prepareNet el s t of None \\<Rightarrow> return None\n          | Some (c, am, N) \\<Rightarrow>\n              relabel_to_front_impl_tab_am c s t N am \\<bind>\n              (\\<lambda>cf.\n                  return\n                   (Some\n                     (c, am, N,\n                      cf))) <\\<lambda>r.\n                                case r of\n                                None \\<Rightarrow>\n                                  \\<up>\n                                   (\\<not> ln_invar el \\<or>\n                                    \\<not> Network (ln_\\<alpha> el) s t)\n                                | Some (c, am, N, cfi) \\<Rightarrow>\n                                    \\<up>\n                                     (c = ln_\\<alpha> el \\<and>\nln_invar el) *\n                                    (\\<exists>\\<^sub>Acf.\n  asmtx_assn N cap_assn cf cfi *\n  \\<up>\n   (RGraph_Impl c s t N cf \\<and>\n    Network.isMaxFlow c s t (Network.flow_of_cf c cf))) *\n                                    \\<up> (Graph.is_adj_map c am)>\\<^sub>t", "using prepareNet_correct[of el s t]"], ["proof (prove)\nusing this:\n  case prepareNet el s t of\n  None \\<Rightarrow>\n    \\<not> ln_invar el \\<or> \\<not> Network (ln_\\<alpha> el) s t\n  | Some (c, adjmap, N) \\<Rightarrow>\n      (el, c) \\<in> ln_rel \\<and>\n      Network c s t \\<and>\n      Graph.is_adj_map c adjmap \\<and> Graph.V c \\<subseteq> {0..<N}\n\ngoal (1 subgoal):\n 1. <emp> case prepareNet el s t of None \\<Rightarrow> return None\n          | Some (c, am, N) \\<Rightarrow>\n              relabel_to_front_impl_tab_am c s t N am \\<bind>\n              (\\<lambda>cf.\n                  return\n                   (Some\n                     (c, am, N,\n                      cf))) <\\<lambda>r.\n                                case r of\n                                None \\<Rightarrow>\n                                  \\<up>\n                                   (\\<not> ln_invar el \\<or>\n                                    \\<not> Network (ln_\\<alpha> el) s t)\n                                | Some (c, am, N, cfi) \\<Rightarrow>\n                                    \\<up>\n                                     (c = ln_\\<alpha> el \\<and>\nln_invar el) *\n                                    (\\<exists>\\<^sub>Acf.\n  asmtx_assn N cap_assn cf cfi *\n  \\<up>\n   (RGraph_Impl c s t N cf \\<and>\n    Network.isMaxFlow c s t (Network.flow_of_cf c cf))) *\n                                    \\<up> (Graph.is_adj_map c am)>\\<^sub>t", "by (sep_auto simp: ln_rel_def in_br_conv)"], ["", "end"]]}