{"file_name": "/home/qj213/afp-2021-10-22/thys/Gauss_Sums/Complex_Roots_Of_Unity.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Gauss_Sums", "problem_names": ["lemma \n  unity_root_k_0 [simp]: \"unity_root k 0 = 1\" and\n  unity_root_0_n [simp]: \"unity_root 0 n = 1\"", "lemma unity_root_conv_exp: \n  \"unity_root k n = exp (of_real (2*pi*n/k) * \\<i>)\"", "lemma unity_root_mod: \n  \"unity_root k (n mod int k) = unity_root k n\"", "lemma unity_root_cong:\n  assumes \"[m = n] (mod int k)\"\n  shows   \"unity_root k m = unity_root k n\"", "lemma unity_root_mod_nat: \n  \"unity_root k (nat (n mod int k)) = unity_root k n\"", "lemma unity_root_eqD:\n assumes gr: \"k > 0\"\n assumes eq: \"unity_root k i = unity_root k j\"\n shows \"i mod k = j mod k\"", "lemma unity_root_eq_1_iff:\n  fixes k n :: nat\n  assumes \"k > 0\" \n  shows \"unity_root k n = 1 \\<longleftrightarrow> k dvd n\"", "lemma unity_root_pow: \"unity_root k n ^ m = unity_root k (n * m)\"", "lemma unity_root_add: \"unity_root k (m + n) = unity_root k m * unity_root k n\"", "lemma unity_root_uminus: \"unity_root k (-m) = cnj (unity_root k m)\"", "lemma inverse_unity_root: \"inverse (unity_root k m) = cnj (unity_root k m)\"", "lemma unity_root_diff: \"unity_root k (m - n) = unity_root k m * cnj (unity_root k n)\"", "lemma unity_root_eq_1_iff_int:\n  fixes k :: nat and n :: int\n  assumes \"k > 0\" \n  shows \"unity_root k n = 1 \\<longleftrightarrow> k dvd n\"", "lemma unity_root_eq_1 [simp]: \"int k dvd n \\<Longrightarrow> unity_root k n = 1\"", "lemma unity_periodic_arithmetic:\n  \"periodic_arithmetic (unity_root k) k\"", "lemma unity_periodic_arithmetic_mult:\n  \"periodic_arithmetic (\\<lambda>n. unity_root k (m * int n)) k\"", "lemma unity_root_periodic_arithmetic_mult_minus:\n  shows \"periodic_arithmetic (\\<lambda>i. unity_root k (-int i*int m)) k\"", "lemma unity_div:\n fixes a :: int and d :: nat\n assumes \"d dvd k\"\n shows \"unity_root k (a*d) = unity_root (k div d) a\"", "lemma unity_div_num:\n  assumes \"k > 0\" \"d > 0\" \"d dvd k\"\n  shows \"unity_root k (x * (k div d)) = unity_root d x\"", "lemma unity_root_sum_0_left [simp]: \"unity_root_sum 0 n = 0\" and\n      unity_root_sum_0_right [simp]: \"k > 0 \\<Longrightarrow> unity_root_sum k 0 = k\"", "theorem unity_root_sum:\n  fixes k :: nat and n :: int\n  assumes gr: \"k \\<ge> 1\"\n  shows \"k dvd n \\<Longrightarrow> unity_root_sum k n = k\"\n    and \"\\<not>k dvd n \\<Longrightarrow> unity_root_sum k n = 0\"", "lemma unity_root_sum_nonzero_iff:\n  fixes r :: int\n  assumes \"k \\<ge> 1\" and \"r \\<in> {-k<..<k}\"\n  shows \"unity_root_sum k r \\<noteq> 0 \\<longleftrightarrow> r = 0\""], "translations": [["", "lemma \n  unity_root_k_0 [simp]: \"unity_root k 0 = 1\" and\n  unity_root_0_n [simp]: \"unity_root 0 n = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k 0 = 1 &&& unity_root 0 n = 1", "unfolding unity_root_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (2 * pi * real_of_int 0 / real k) = 1 &&&\n    cis (2 * pi * real_of_int n / real 0) = 1", "by simp+"], ["", "lemma unity_root_conv_exp: \n  \"unity_root k n = exp (of_real (2*pi*n/k) * \\<i>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k n =\n    exp (complex_of_real (2 * pi * real_of_int n / real k) * \\<i>)", "unfolding unity_root_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (2 * pi * real_of_int n / real k) =\n    exp (complex_of_real (2 * pi * real_of_int n / real k) * \\<i>)", "by (subst cis_conv_exp,subst mult.commute,blast)"], ["", "lemma unity_root_mod: \n  \"unity_root k (n mod int k) = unity_root k n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k (n mod int k) = unity_root k n", "proof (cases \"k = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> unity_root k (n mod int k) = unity_root k n\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    unity_root k (n mod int k) = unity_root k n", "case True"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> unity_root k (n mod int k) = unity_root k n\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    unity_root k (n mod int k) = unity_root k n", "then"], ["proof (chain)\npicking this:\n  k = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  k = 0\n\ngoal (1 subgoal):\n 1. unity_root k (n mod int k) = unity_root k n", "by simp"], ["proof (state)\nthis:\n  unity_root k (n mod int k) = unity_root k n\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    unity_root k (n mod int k) = unity_root k n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    unity_root k (n mod int k) = unity_root k n", "case False"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    unity_root k (n mod int k) = unity_root k n", "obtain q :: int where q_def: \"n = q*k + (n mod k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        n = q * int k + n mod int k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using div_mult_mod_eq[symmetric]"], ["proof (prove)\nusing this:\n  ?t = ?t div ?b * ?b + ?t mod ?b\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        n = q * int k + n mod int k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n = q * int k + n mod int k\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    unity_root k (n mod int k) = unity_root k n", "have \"n / k = q + (n mod k) / k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int n / real k =\n    real_of_int q + real_of_int (n mod int k) / real k", "proof (auto simp add: divide_simps False)"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int n = real_of_int q * real k + real_of_int (n mod int k)", "have \"real_of_int n = real_of_int (q*k + (n mod k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int n = real_of_int (q * int k + n mod int k)", "using q_def"], ["proof (prove)\nusing this:\n  n = q * int k + n mod int k\n\ngoal (1 subgoal):\n 1. real_of_int n = real_of_int (q * int k + n mod int k)", "by simp"], ["proof (state)\nthis:\n  real_of_int n = real_of_int (q * int k + n mod int k)\n\ngoal (1 subgoal):\n 1. real_of_int n = real_of_int q * real k + real_of_int (n mod int k)", "also"], ["proof (state)\nthis:\n  real_of_int n = real_of_int (q * int k + n mod int k)\n\ngoal (1 subgoal):\n 1. real_of_int n = real_of_int q * real k + real_of_int (n mod int k)", "have \"\\<dots> = real_of_int q * real k + real_of_int (n mod k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (q * int k + n mod int k) =\n    real_of_int q * real k + real_of_int (n mod int k)", "using of_int_add of_int_mult"], ["proof (prove)\nusing this:\n  of_int (?w + ?z) = of_int ?w + of_int ?z\n  of_int (?w * ?z) = of_int ?w * of_int ?z\n\ngoal (1 subgoal):\n 1. real_of_int (q * int k + n mod int k) =\n    real_of_int q * real k + real_of_int (n mod int k)", "by simp"], ["proof (state)\nthis:\n  real_of_int (q * int k + n mod int k) =\n  real_of_int q * real k + real_of_int (n mod int k)\n\ngoal (1 subgoal):\n 1. real_of_int n = real_of_int q * real k + real_of_int (n mod int k)", "finally"], ["proof (chain)\npicking this:\n  real_of_int n = real_of_int q * real k + real_of_int (n mod int k)", "show \"real_of_int n = real_of_int q * real k + real_of_int (n mod k)\""], ["proof (prove)\nusing this:\n  real_of_int n = real_of_int q * real k + real_of_int (n mod int k)\n\ngoal (1 subgoal):\n 1. real_of_int n = real_of_int q * real k + real_of_int (n mod int k)", "by blast"], ["proof (state)\nthis:\n  real_of_int n = real_of_int q * real k + real_of_int (n mod int k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_int n / real k =\n  real_of_int q + real_of_int (n mod int k) / real k\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    unity_root k (n mod int k) = unity_root k n", "then"], ["proof (chain)\npicking this:\n  real_of_int n / real k =\n  real_of_int q + real_of_int (n mod int k) / real k", "have \"(2*pi*n/k) = 2*pi*q + (2*pi*(n mod k)/k)\""], ["proof (prove)\nusing this:\n  real_of_int n / real k =\n  real_of_int q + real_of_int (n mod int k) / real k\n\ngoal (1 subgoal):\n 1. 2 * pi * real_of_int n / real k =\n    2 * pi * real_of_int q + 2 * pi * real_of_int (n mod int k) / real k", "using False"], ["proof (prove)\nusing this:\n  real_of_int n / real k =\n  real_of_int q + real_of_int (n mod int k) / real k\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 * pi * real_of_int n / real k =\n    2 * pi * real_of_int q + 2 * pi * real_of_int (n mod int k) / real k", "by (auto simp add: field_simps)"], ["proof (state)\nthis:\n  2 * pi * real_of_int n / real k =\n  2 * pi * real_of_int q + 2 * pi * real_of_int (n mod int k) / real k\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    unity_root k (n mod int k) = unity_root k n", "then"], ["proof (chain)\npicking this:\n  2 * pi * real_of_int n / real k =\n  2 * pi * real_of_int q + 2 * pi * real_of_int (n mod int k) / real k", "have \"(2*pi*n/k)*\\<i> = 2*pi*q*\\<i> + (2*pi*(n mod k)/k)*\\<i>\" (is \"?l = ?r1 + ?r2\")"], ["proof (prove)\nusing this:\n  2 * pi * real_of_int n / real k =\n  2 * pi * real_of_int q + 2 * pi * real_of_int (n mod int k) / real k\n\ngoal (1 subgoal):\n 1. complex_of_real (2 * pi * real_of_int n / real k) * \\<i> =\n    complex_of_real (2 * pi * real_of_int q) * \\<i> +\n    complex_of_real (2 * pi * real_of_int (n mod int k) / real k) * \\<i>", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  complex_of_real (2 * pi * real_of_int n / real k) * \\<i> =\n  complex_of_real (2 * pi * real_of_int q) * \\<i> +\n  complex_of_real (2 * pi * real_of_int (n mod int k) / real k) * \\<i>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    unity_root k (n mod int k) = unity_root k n", "then"], ["proof (chain)\npicking this:\n  complex_of_real (2 * pi * real_of_int n / real k) * \\<i> =\n  complex_of_real (2 * pi * real_of_int q) * \\<i> +\n  complex_of_real (2 * pi * real_of_int (n mod int k) / real k) * \\<i>", "have \"exp ?l = exp ?r2\""], ["proof (prove)\nusing this:\n  complex_of_real (2 * pi * real_of_int n / real k) * \\<i> =\n  complex_of_real (2 * pi * real_of_int q) * \\<i> +\n  complex_of_real (2 * pi * real_of_int (n mod int k) / real k) * \\<i>\n\ngoal (1 subgoal):\n 1. exp (complex_of_real (2 * pi * real_of_int n / real k) * \\<i>) =\n    exp (complex_of_real (2 * pi * real_of_int (n mod int k) / real k) *\n         \\<i>)", "using exp_plus_2pin"], ["proof (prove)\nusing this:\n  complex_of_real (2 * pi * real_of_int n / real k) * \\<i> =\n  complex_of_real (2 * pi * real_of_int q) * \\<i> +\n  complex_of_real (2 * pi * real_of_int (n mod int k) / real k) * \\<i>\n  exp (?z + \\<i> * (of_int ?n * (complex_of_real pi * 2))) = exp ?z\n\ngoal (1 subgoal):\n 1. exp (complex_of_real (2 * pi * real_of_int n / real k) * \\<i>) =\n    exp (complex_of_real (2 * pi * real_of_int (n mod int k) / real k) *\n         \\<i>)", "by (simp add: exp_add mult.commute)"], ["proof (state)\nthis:\n  exp (complex_of_real (2 * pi * real_of_int n / real k) * \\<i>) =\n  exp (complex_of_real (2 * pi * real_of_int (n mod int k) / real k) * \\<i>)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    unity_root k (n mod int k) = unity_root k n", "then"], ["proof (chain)\npicking this:\n  exp (complex_of_real (2 * pi * real_of_int n / real k) * \\<i>) =\n  exp (complex_of_real (2 * pi * real_of_int (n mod int k) / real k) * \\<i>)", "show ?thesis"], ["proof (prove)\nusing this:\n  exp (complex_of_real (2 * pi * real_of_int n / real k) * \\<i>) =\n  exp (complex_of_real (2 * pi * real_of_int (n mod int k) / real k) * \\<i>)\n\ngoal (1 subgoal):\n 1. unity_root k (n mod int k) = unity_root k n", "using unity_root_def unity_root_conv_exp"], ["proof (prove)\nusing this:\n  exp (complex_of_real (2 * pi * real_of_int n / real k) * \\<i>) =\n  exp (complex_of_real (2 * pi * real_of_int (n mod int k) / real k) * \\<i>)\n  unity_root ?k ?n = cis (2 * pi * real_of_int ?n / real ?k)\n  unity_root ?k ?n =\n  exp (complex_of_real (2 * pi * real_of_int ?n / real ?k) * \\<i>)\n\ngoal (1 subgoal):\n 1. unity_root k (n mod int k) = unity_root k n", "by simp"], ["proof (state)\nthis:\n  unity_root k (n mod int k) = unity_root k n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unity_root_cong:\n  assumes \"[m = n] (mod int k)\"\n  shows   \"unity_root k m = unity_root k n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k m = unity_root k n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unity_root k m = unity_root k n", "from assms"], ["proof (chain)\npicking this:\n  [m = n] (mod int k)", "have \"m mod int k = n mod int k\""], ["proof (prove)\nusing this:\n  [m = n] (mod int k)\n\ngoal (1 subgoal):\n 1. m mod int k = n mod int k", "by (auto simp: cong_def)"], ["proof (state)\nthis:\n  m mod int k = n mod int k\n\ngoal (1 subgoal):\n 1. unity_root k m = unity_root k n", "hence \"unity_root k (m mod int k) = unity_root k (n mod int k)\""], ["proof (prove)\nusing this:\n  m mod int k = n mod int k\n\ngoal (1 subgoal):\n 1. unity_root k (m mod int k) = unity_root k (n mod int k)", "by simp"], ["proof (state)\nthis:\n  unity_root k (m mod int k) = unity_root k (n mod int k)\n\ngoal (1 subgoal):\n 1. unity_root k m = unity_root k n", "thus ?thesis"], ["proof (prove)\nusing this:\n  unity_root k (m mod int k) = unity_root k (n mod int k)\n\ngoal (1 subgoal):\n 1. unity_root k m = unity_root k n", "by (simp add: unity_root_mod)"], ["proof (state)\nthis:\n  unity_root k m = unity_root k n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unity_root_mod_nat: \n  \"unity_root k (nat (n mod int k)) = unity_root k n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k (int (nat (n mod int k))) = unity_root k n", "proof (cases k)"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    unity_root k (int (nat (n mod int k))) = unity_root k n\n 2. \\<And>nata.\n       k = Suc nata \\<Longrightarrow>\n       unity_root k (int (nat (n mod int k))) = unity_root k n", "case (Suc l)"], ["proof (state)\nthis:\n  k = Suc l\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    unity_root k (int (nat (n mod int k))) = unity_root k n\n 2. \\<And>nata.\n       k = Suc nata \\<Longrightarrow>\n       unity_root k (int (nat (n mod int k))) = unity_root k n", "then"], ["proof (chain)\npicking this:\n  k = Suc l", "have \"n mod int k \\<ge> 0\""], ["proof (prove)\nusing this:\n  k = Suc l\n\ngoal (1 subgoal):\n 1. 0 \\<le> n mod int k", "by auto"], ["proof (state)\nthis:\n  0 \\<le> n mod int k\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    unity_root k (int (nat (n mod int k))) = unity_root k n\n 2. \\<And>nata.\n       k = Suc nata \\<Longrightarrow>\n       unity_root k (int (nat (n mod int k))) = unity_root k n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k (int (nat (n mod int k))) = unity_root k n", "unfolding int_nat_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k (if 0 \\<le> n mod int k then n mod int k else 0) =\n    unity_root k n", "by (simp add: \\<open>n mod int k \\<ge> 0\\<close> unity_root_mod)"], ["proof (state)\nthis:\n  unity_root k (int (nat (n mod int k))) = unity_root k n\n\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow>\n    unity_root k (int (nat (n mod int k))) = unity_root k n", "qed auto"], ["", "lemma unity_root_eqD:\n assumes gr: \"k > 0\"\n assumes eq: \"unity_root k i = unity_root k j\"\n shows \"i mod k = j mod k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i mod int k = j mod int k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i mod int k = j mod int k", "let ?arg1 = \"(2*pi*i/k)* \\<i>\""], ["proof (state)\ngoal (1 subgoal):\n 1. i mod int k = j mod int k", "let ?arg2 = \"(2*pi*j/k)* \\<i>\""], ["proof (state)\ngoal (1 subgoal):\n 1. i mod int k = j mod int k", "from eq unity_root_conv_exp"], ["proof (chain)\npicking this:\n  unity_root k i = unity_root k j\n  unity_root ?k ?n =\n  exp (complex_of_real (2 * pi * real_of_int ?n / real ?k) * \\<i>)", "have \"exp ?arg1 = exp ?arg2\""], ["proof (prove)\nusing this:\n  unity_root k i = unity_root k j\n  unity_root ?k ?n =\n  exp (complex_of_real (2 * pi * real_of_int ?n / real ?k) * \\<i>)\n\ngoal (1 subgoal):\n 1. exp (complex_of_real (2 * pi * real_of_int i / real k) * \\<i>) =\n    exp (complex_of_real (2 * pi * real_of_int j / real k) * \\<i>)", "by simp"], ["proof (state)\nthis:\n  exp (complex_of_real (2 * pi * real_of_int i / real k) * \\<i>) =\n  exp (complex_of_real (2 * pi * real_of_int j / real k) * \\<i>)\n\ngoal (1 subgoal):\n 1. i mod int k = j mod int k", "from this exp_eq"], ["proof (chain)\npicking this:\n  exp (complex_of_real (2 * pi * real_of_int i / real k) * \\<i>) =\n  exp (complex_of_real (2 * pi * real_of_int j / real k) * \\<i>)\n  (exp ?w = exp ?z) =\n  (\\<exists>n. ?w = ?z + complex_of_real (real_of_int (2 * n) * pi) * \\<i>)", "obtain n :: int where \"?arg1 = ?arg2 +(2*n*pi)*\\<i>\""], ["proof (prove)\nusing this:\n  exp (complex_of_real (2 * pi * real_of_int i / real k) * \\<i>) =\n  exp (complex_of_real (2 * pi * real_of_int j / real k) * \\<i>)\n  (exp ?w = exp ?z) =\n  (\\<exists>n. ?w = ?z + complex_of_real (real_of_int (2 * n) * pi) * \\<i>)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        complex_of_real (2 * pi * real_of_int i / real k) * \\<i> =\n        complex_of_real (2 * pi * real_of_int j / real k) * \\<i> +\n        complex_of_real (real_of_int (2 * n) * pi) * \\<i> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  complex_of_real (2 * pi * real_of_int i / real k) * \\<i> =\n  complex_of_real (2 * pi * real_of_int j / real k) * \\<i> +\n  complex_of_real (real_of_int (2 * n) * pi) * \\<i>\n\ngoal (1 subgoal):\n 1. i mod int k = j mod int k", "then"], ["proof (chain)\npicking this:\n  complex_of_real (2 * pi * real_of_int i / real k) * \\<i> =\n  complex_of_real (2 * pi * real_of_int j / real k) * \\<i> +\n  complex_of_real (real_of_int (2 * n) * pi) * \\<i>", "have e1: \"?arg1 - ?arg2 = 2*n*pi*\\<i>\""], ["proof (prove)\nusing this:\n  complex_of_real (2 * pi * real_of_int i / real k) * \\<i> =\n  complex_of_real (2 * pi * real_of_int j / real k) * \\<i> +\n  complex_of_real (real_of_int (2 * n) * pi) * \\<i>\n\ngoal (1 subgoal):\n 1. complex_of_real (2 * pi * real_of_int i / real k) * \\<i> -\n    complex_of_real (2 * pi * real_of_int j / real k) * \\<i> =\n    complex_of_real (real_of_int (2 * n) * pi) * \\<i>", "by simp"], ["proof (state)\nthis:\n  complex_of_real (2 * pi * real_of_int i / real k) * \\<i> -\n  complex_of_real (2 * pi * real_of_int j / real k) * \\<i> =\n  complex_of_real (real_of_int (2 * n) * pi) * \\<i>\n\ngoal (1 subgoal):\n 1. i mod int k = j mod int k", "have e2: \"?arg1 - ?arg2 = 2*(i-j)*(1/k)*pi*\\<i>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (2 * pi * real_of_int i / real k) * \\<i> -\n    complex_of_real (2 * pi * real_of_int j / real k) * \\<i> =\n    complex_of_real (real_of_int (2 * (i - j)) * (1 / real k) * pi) * \\<i>", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  complex_of_real (2 * pi * real_of_int i / real k) * \\<i> -\n  complex_of_real (2 * pi * real_of_int j / real k) * \\<i> =\n  complex_of_real (real_of_int (2 * (i - j)) * (1 / real k) * pi) * \\<i>\n\ngoal (1 subgoal):\n 1. i mod int k = j mod int k", "from e1 e2"], ["proof (chain)\npicking this:\n  complex_of_real (2 * pi * real_of_int i / real k) * \\<i> -\n  complex_of_real (2 * pi * real_of_int j / real k) * \\<i> =\n  complex_of_real (real_of_int (2 * n) * pi) * \\<i>\n  complex_of_real (2 * pi * real_of_int i / real k) * \\<i> -\n  complex_of_real (2 * pi * real_of_int j / real k) * \\<i> =\n  complex_of_real (real_of_int (2 * (i - j)) * (1 / real k) * pi) * \\<i>", "have \"2*n*pi*\\<i> = 2*(i-j)*(1/k)*pi*\\<i>\""], ["proof (prove)\nusing this:\n  complex_of_real (2 * pi * real_of_int i / real k) * \\<i> -\n  complex_of_real (2 * pi * real_of_int j / real k) * \\<i> =\n  complex_of_real (real_of_int (2 * n) * pi) * \\<i>\n  complex_of_real (2 * pi * real_of_int i / real k) * \\<i> -\n  complex_of_real (2 * pi * real_of_int j / real k) * \\<i> =\n  complex_of_real (real_of_int (2 * (i - j)) * (1 / real k) * pi) * \\<i>\n\ngoal (1 subgoal):\n 1. complex_of_real (real_of_int (2 * n) * pi) * \\<i> =\n    complex_of_real (real_of_int (2 * (i - j)) * (1 / real k) * pi) * \\<i>", "by simp"], ["proof (state)\nthis:\n  complex_of_real (real_of_int (2 * n) * pi) * \\<i> =\n  complex_of_real (real_of_int (2 * (i - j)) * (1 / real k) * pi) * \\<i>\n\ngoal (1 subgoal):\n 1. i mod int k = j mod int k", "then"], ["proof (chain)\npicking this:\n  complex_of_real (real_of_int (2 * n) * pi) * \\<i> =\n  complex_of_real (real_of_int (2 * (i - j)) * (1 / real k) * pi) * \\<i>", "have \"2*n*k*pi*\\<i> = 2*(i-j)*pi*\\<i>\""], ["proof (prove)\nusing this:\n  complex_of_real (real_of_int (2 * n) * pi) * \\<i> =\n  complex_of_real (real_of_int (2 * (i - j)) * (1 / real k) * pi) * \\<i>\n\ngoal (1 subgoal):\n 1. complex_of_real (real_of_int (2 * n * int k) * pi) * \\<i> =\n    complex_of_real (real_of_int (2 * (i - j)) * pi) * \\<i>", "by (simp add: divide_simps \\<open>k > 0\\<close>)(simp add: field_simps)"], ["proof (state)\nthis:\n  complex_of_real (real_of_int (2 * n * int k) * pi) * \\<i> =\n  complex_of_real (real_of_int (2 * (i - j)) * pi) * \\<i>\n\ngoal (1 subgoal):\n 1. i mod int k = j mod int k", "then"], ["proof (chain)\npicking this:\n  complex_of_real (real_of_int (2 * n * int k) * pi) * \\<i> =\n  complex_of_real (real_of_int (2 * (i - j)) * pi) * \\<i>", "have \"2*n*k = 2*(i-j)\""], ["proof (prove)\nusing this:\n  complex_of_real (real_of_int (2 * n * int k) * pi) * \\<i> =\n  complex_of_real (real_of_int (2 * (i - j)) * pi) * \\<i>\n\ngoal (1 subgoal):\n 1. 2 * n * int k = 2 * (i - j)", "by (meson complex_i_not_zero mult_cancel_right of_int_eq_iff of_real_eq_iff pi_neq_zero)"], ["proof (state)\nthis:\n  2 * n * int k = 2 * (i - j)\n\ngoal (1 subgoal):\n 1. i mod int k = j mod int k", "then"], ["proof (chain)\npicking this:\n  2 * n * int k = 2 * (i - j)", "have \"n*k = i-j\""], ["proof (prove)\nusing this:\n  2 * n * int k = 2 * (i - j)\n\ngoal (1 subgoal):\n 1. n * int k = i - j", "by auto"], ["proof (state)\nthis:\n  n * int k = i - j\n\ngoal (1 subgoal):\n 1. i mod int k = j mod int k", "then"], ["proof (chain)\npicking this:\n  n * int k = i - j", "show ?thesis"], ["proof (prove)\nusing this:\n  n * int k = i - j\n\ngoal (1 subgoal):\n 1. i mod int k = j mod int k", "by Groebner_Basis.algebra"], ["proof (state)\nthis:\n  i mod int k = j mod int k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unity_root_eq_1_iff:\n  fixes k n :: nat\n  assumes \"k > 0\" \n  shows \"unity_root k n = 1 \\<longleftrightarrow> k dvd n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (unity_root k (int n) = 1) = (k dvd n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (unity_root k (int n) = 1) = (k dvd n)", "have \"unity_root k n = exp ((2*pi*n/k) * \\<i>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k (int n) =\n    exp (complex_of_real (2 * pi * real n / real k) * \\<i>)", "by (simp add: unity_root_conv_exp)"], ["proof (state)\nthis:\n  unity_root k (int n) =\n  exp (complex_of_real (2 * pi * real n / real k) * \\<i>)\n\ngoal (1 subgoal):\n 1. (unity_root k (int n) = 1) = (k dvd n)", "also"], ["proof (state)\nthis:\n  unity_root k (int n) =\n  exp (complex_of_real (2 * pi * real n / real k) * \\<i>)\n\ngoal (1 subgoal):\n 1. (unity_root k (int n) = 1) = (k dvd n)", "have \"exp ((2*pi*n/k)* \\<i>) = 1 \\<longleftrightarrow> k dvd n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (exp (complex_of_real (2 * pi * real n / real k) * \\<i>) = 1) =\n    (k dvd n)", "using complex_root_unity_eq_1[of k n] assms"], ["proof (prove)\nusing this:\n  1 \\<le> k \\<Longrightarrow>\n  (exp (2 * complex_of_real pi * \\<i> * of_nat n / of_nat k) = 1) =\n  (k dvd n)\n  0 < k\n\ngoal (1 subgoal):\n 1. (exp (complex_of_real (2 * pi * real n / real k) * \\<i>) = 1) =\n    (k dvd n)", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  (exp (complex_of_real (2 * pi * real n / real k) * \\<i>) = 1) = (k dvd n)\n\ngoal (1 subgoal):\n 1. (unity_root k (int n) = 1) = (k dvd n)", "finally"], ["proof (chain)\npicking this:\n  (unity_root k (int n) = 1) = (k dvd n)", "show ?thesis"], ["proof (prove)\nusing this:\n  (unity_root k (int n) = 1) = (k dvd n)\n\ngoal (1 subgoal):\n 1. (unity_root k (int n) = 1) = (k dvd n)", "by simp"], ["proof (state)\nthis:\n  (unity_root k (int n) = 1) = (k dvd n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unity_root_pow: \"unity_root k n ^ m = unity_root k (n * m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k n ^ m = unity_root k (n * int m)", "using unity_root_def"], ["proof (prove)\nusing this:\n  unity_root ?k ?n = cis (2 * pi * real_of_int ?n / real ?k)\n\ngoal (1 subgoal):\n 1. unity_root k n ^ m = unity_root k (n * int m)", "by (simp add: Complex.DeMoivre mult.commute algebra_split_simps(6))"], ["", "lemma unity_root_add: \"unity_root k (m + n) = unity_root k m * unity_root k n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k (m + n) = unity_root k m * unity_root k n", "by (simp add: unity_root_conv_exp add_divide_distrib algebra_simps exp_add)"], ["", "lemma unity_root_uminus: \"unity_root k (-m) = cnj (unity_root k m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k (- m) = cnj (unity_root k m)", "unfolding unity_root_conv_exp exp_cnj"], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (complex_of_real (2 * pi * real_of_int (- m) / real k) * \\<i>) =\n    exp (cnj (complex_of_real (2 * pi * real_of_int m / real k) * \\<i>))", "by simp"], ["", "lemma inverse_unity_root: \"inverse (unity_root k m) = cnj (unity_root k m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (unity_root k m) = cnj (unity_root k m)", "unfolding unity_root_conv_exp exp_cnj"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse\n     (exp (complex_of_real (2 * pi * real_of_int m / real k) * \\<i>)) =\n    exp (cnj (complex_of_real (2 * pi * real_of_int m / real k) * \\<i>))", "by (simp add: field_simps exp_minus)"], ["", "lemma unity_root_diff: \"unity_root k (m - n) = unity_root k m * cnj (unity_root k n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k (m - n) = unity_root k m * cnj (unity_root k n)", "using unity_root_add[of k m \"-n\"]"], ["proof (prove)\nusing this:\n  unity_root k (m + - n) = unity_root k m * unity_root k (- n)\n\ngoal (1 subgoal):\n 1. unity_root k (m - n) = unity_root k m * cnj (unity_root k n)", "by (simp add: unity_root_uminus)"], ["", "lemma unity_root_eq_1_iff_int:\n  fixes k :: nat and n :: int\n  assumes \"k > 0\" \n  shows \"unity_root k n = 1 \\<longleftrightarrow> k dvd n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (unity_root k n = 1) = (int k dvd n)", "proof (cases \"n \\<ge> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow> (unity_root k n = 1) = (int k dvd n)\n 2. \\<not> 0 \\<le> n \\<Longrightarrow> (unity_root k n = 1) = (int k dvd n)", "case True"], ["proof (state)\nthis:\n  0 \\<le> n\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow> (unity_root k n = 1) = (int k dvd n)\n 2. \\<not> 0 \\<le> n \\<Longrightarrow> (unity_root k n = 1) = (int k dvd n)", "obtain n' where \"n = int n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n'. n = int n' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using zero_le_imp_eq_int[OF True]"], ["proof (prove)\nusing this:\n  \\<exists>na. n = int na\n\ngoal (1 subgoal):\n 1. (\\<And>n'. n = int n' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  n = int n'\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow> (unity_root k n = 1) = (int k dvd n)\n 2. \\<not> 0 \\<le> n \\<Longrightarrow> (unity_root k n = 1) = (int k dvd n)", "then"], ["proof (chain)\npicking this:\n  n = int n'", "show ?thesis"], ["proof (prove)\nusing this:\n  n = int n'\n\ngoal (1 subgoal):\n 1. (unity_root k n = 1) = (int k dvd n)", "using unity_root_eq_1_iff[OF \\<open>k > 0\\<close>, of n'] of_nat_dvd_iff"], ["proof (prove)\nusing this:\n  n = int n'\n  (unity_root k (int n') = 1) = (k dvd n')\n  (of_nat ?m dvd of_nat ?n) = (?m dvd ?n)\n\ngoal (1 subgoal):\n 1. (unity_root k n = 1) = (int k dvd n)", "by blast"], ["proof (state)\nthis:\n  (unity_root k n = 1) = (int k dvd n)\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow> (unity_root k n = 1) = (int k dvd n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow> (unity_root k n = 1) = (int k dvd n)", "case False"], ["proof (state)\nthis:\n  \\<not> 0 \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow> (unity_root k n = 1) = (int k dvd n)", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 \\<le> n", "have \"-n \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> n\n\ngoal (1 subgoal):\n 1. 0 \\<le> - n", "by auto"], ["proof (state)\nthis:\n  0 \\<le> - n\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow> (unity_root k n = 1) = (int k dvd n)", "have \"unity_root k n = inverse (unity_root k (-n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k n = inverse (unity_root k (- n))", "unfolding inverse_unity_root"], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k n = cnj (unity_root k (- n))", "by (simp add: unity_root_uminus)"], ["proof (state)\nthis:\n  unity_root k n = inverse (unity_root k (- n))\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow> (unity_root k n = 1) = (int k dvd n)", "then"], ["proof (chain)\npicking this:\n  unity_root k n = inverse (unity_root k (- n))", "have \"(unity_root k n = 1) = (unity_root k (-n) = 1)\""], ["proof (prove)\nusing this:\n  unity_root k n = inverse (unity_root k (- n))\n\ngoal (1 subgoal):\n 1. (unity_root k n = 1) = (unity_root k (- n) = 1)", "by simp"], ["proof (state)\nthis:\n  (unity_root k n = 1) = (unity_root k (- n) = 1)\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow> (unity_root k n = 1) = (int k dvd n)", "also"], ["proof (state)\nthis:\n  (unity_root k n = 1) = (unity_root k (- n) = 1)\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow> (unity_root k n = 1) = (int k dvd n)", "have \"(unity_root k (-n) = 1) = (k dvd (-n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (unity_root k (- n) = 1) = (int k dvd - n)", "using unity_root_eq_1_iff[of k \"nat (-n)\",OF \\<open>k > 0\\<close>] False \n          int_dvd_int_iff[of k \"nat (-n)\"] nat_0_le[OF \\<open>-n \\<ge> 0\\<close>]"], ["proof (prove)\nusing this:\n  (unity_root k (int (nat (- n))) = 1) = (k dvd nat (- n))\n  \\<not> 0 \\<le> n\n  (int k dvd int (nat (- n))) = (k dvd nat (- n))\n  int (nat (- n)) = - n\n\ngoal (1 subgoal):\n 1. (unity_root k (- n) = 1) = (int k dvd - n)", "by auto"], ["proof (state)\nthis:\n  (unity_root k (- n) = 1) = (int k dvd - n)\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow> (unity_root k n = 1) = (int k dvd n)", "finally"], ["proof (chain)\npicking this:\n  (unity_root k n = 1) = (int k dvd - n)", "show ?thesis"], ["proof (prove)\nusing this:\n  (unity_root k n = 1) = (int k dvd - n)\n\ngoal (1 subgoal):\n 1. (unity_root k n = 1) = (int k dvd n)", "by simp"], ["proof (state)\nthis:\n  (unity_root k n = 1) = (int k dvd n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unity_root_eq_1 [simp]: \"int k dvd n \\<Longrightarrow> unity_root k n = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int k dvd n \\<Longrightarrow> unity_root k n = 1", "by (cases \"k = 0\") (auto simp: unity_root_eq_1_iff_int)"], ["", "lemma unity_periodic_arithmetic:\n  \"periodic_arithmetic (unity_root k) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>x. unity_root k (int x)) k", "unfolding periodic_arithmetic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. unity_root k (int (n + k)) = unity_root k (int n)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. unity_root k (int (n + k)) = unity_root k (int n)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. unity_root k (int (n + k)) = unity_root k (int n)", "have \"unity_root k (n + k) = unity_root k ((n+k) mod k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k (int (n + k)) = unity_root k (int ((n + k) mod k))", "using unity_root_mod[of k] zmod_int"], ["proof (prove)\nusing this:\n  unity_root k (?n mod int k) = unity_root k ?n\n  int (?a mod ?b) = int ?a mod int ?b\n\ngoal (1 subgoal):\n 1. unity_root k (int (n + k)) = unity_root k (int ((n + k) mod k))", "by presburger"], ["proof (state)\nthis:\n  unity_root k (int (n + k)) = unity_root k (int ((n + k) mod k))\n\ngoal (1 subgoal):\n 1. \\<And>n. unity_root k (int (n + k)) = unity_root k (int n)", "also"], ["proof (state)\nthis:\n  unity_root k (int (n + k)) = unity_root k (int ((n + k) mod k))\n\ngoal (1 subgoal):\n 1. \\<And>n. unity_root k (int (n + k)) = unity_root k (int n)", "have \"unity_root k ((n+k) mod k) = unity_root k n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k (int ((n + k) mod k)) = unity_root k (int n)", "using unity_root_mod zmod_int"], ["proof (prove)\nusing this:\n  unity_root ?k (?n mod int ?k) = unity_root ?k ?n\n  int (?a mod ?b) = int ?a mod int ?b\n\ngoal (1 subgoal):\n 1. unity_root k (int ((n + k) mod k)) = unity_root k (int n)", "by auto"], ["proof (state)\nthis:\n  unity_root k (int ((n + k) mod k)) = unity_root k (int n)\n\ngoal (1 subgoal):\n 1. \\<And>n. unity_root k (int (n + k)) = unity_root k (int n)", "finally"], ["proof (chain)\npicking this:\n  unity_root k (int (n + k)) = unity_root k (int n)", "show \"unity_root k (n + k) = unity_root k n\""], ["proof (prove)\nusing this:\n  unity_root k (int (n + k)) = unity_root k (int n)\n\ngoal (1 subgoal):\n 1. unity_root k (int (n + k)) = unity_root k (int n)", "by simp"], ["proof (state)\nthis:\n  unity_root k (int (n + k)) = unity_root k (int n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unity_periodic_arithmetic_mult:\n  \"periodic_arithmetic (\\<lambda>n. unity_root k (m * int n)) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>n. unity_root k (m * int n)) k", "unfolding periodic_arithmetic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. unity_root k (m * int (n + k)) = unity_root k (m * int n)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. unity_root k (m * int (n + k)) = unity_root k (m * int n)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. unity_root k (m * int (n + k)) = unity_root k (m * int n)", "have \"unity_root k (m * int (n + k)) = \n        unity_root k (m*n + m*k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k (m * int (n + k)) = unity_root k (m * int n + m * int k)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  unity_root k (m * int (n + k)) = unity_root k (m * int n + m * int k)\n\ngoal (1 subgoal):\n 1. \\<And>n. unity_root k (m * int (n + k)) = unity_root k (m * int n)", "also"], ["proof (state)\nthis:\n  unity_root k (m * int (n + k)) = unity_root k (m * int n + m * int k)\n\ngoal (1 subgoal):\n 1. \\<And>n. unity_root k (m * int (n + k)) = unity_root k (m * int n)", "have \"\\<dots> = unity_root k (m*n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k (m * int n + m * int k) = unity_root k (m * int n)", "using unity_root_mod[of k \"m * int n\"] unity_root_mod[of k \"m * int n + m * int k\"] \n          mod_mult_self3"], ["proof (prove)\nusing this:\n  unity_root k (m * int n mod int k) = unity_root k (m * int n)\n  unity_root k ((m * int n + m * int k) mod int k) =\n  unity_root k (m * int n + m * int k)\n  (?c * ?b + ?a) mod ?b = ?a mod ?b\n\ngoal (1 subgoal):\n 1. unity_root k (m * int n + m * int k) = unity_root k (m * int n)", "by presburger"], ["proof (state)\nthis:\n  unity_root k (m * int n + m * int k) = unity_root k (m * int n)\n\ngoal (1 subgoal):\n 1. \\<And>n. unity_root k (m * int (n + k)) = unity_root k (m * int n)", "finally"], ["proof (chain)\npicking this:\n  unity_root k (m * int (n + k)) = unity_root k (m * int n)", "show \"unity_root k (m * int (n + k)) =\n             unity_root k (m * int n)\""], ["proof (prove)\nusing this:\n  unity_root k (m * int (n + k)) = unity_root k (m * int n)\n\ngoal (1 subgoal):\n 1. unity_root k (m * int (n + k)) = unity_root k (m * int n)", "by simp"], ["proof (state)\nthis:\n  unity_root k (m * int (n + k)) = unity_root k (m * int n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unity_root_periodic_arithmetic_mult_minus:\n  shows \"periodic_arithmetic (\\<lambda>i. unity_root k (-int i*int m)) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>i. unity_root k (- int i * int m)) k", "unfolding periodic_arithmetic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       unity_root k (- int (n + k) * int m) = unity_root k (- int n * int m)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       unity_root k (- int (n + k) * int m) = unity_root k (- int n * int m)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       unity_root k (- int (n + k) * int m) = unity_root k (- int n * int m)", "have \"unity_root k (-(n + k) * m) = cnj (unity_root k (n*m+k*m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k (- int (n + k) * int m) =\n    cnj (unity_root k (int (n * m + k * m)))", "by (simp add: ring_distribs unity_root_diff unity_root_add unity_root_uminus)"], ["proof (state)\nthis:\n  unity_root k (- int (n + k) * int m) =\n  cnj (unity_root k (int (n * m + k * m)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       unity_root k (- int (n + k) * int m) = unity_root k (- int n * int m)", "also"], ["proof (state)\nthis:\n  unity_root k (- int (n + k) * int m) =\n  cnj (unity_root k (int (n * m + k * m)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       unity_root k (- int (n + k) * int m) = unity_root k (- int n * int m)", "have \"\\<dots> = cnj (unity_root k (n*m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (unity_root k (int (n * m + k * m))) =\n    cnj (unity_root k (int (n * m)))", "using mult_period[of \"unity_root k\" k m] unity_periodic_arithmetic[of k]"], ["proof (prove)\nusing this:\n  periodic_arithmetic (\\<lambda>x. unity_root k (int x)) k \\<Longrightarrow>\n  periodic_arithmetic (\\<lambda>x. unity_root k (int x)) (k * m)\n  periodic_arithmetic (\\<lambda>x. unity_root k (int x)) k\n\ngoal (1 subgoal):\n 1. cnj (unity_root k (int (n * m + k * m))) =\n    cnj (unity_root k (int (n * m)))", "unfolding periodic_arithmetic_def"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     unity_root k (int (n + k)) = unity_root k (int n) \\<Longrightarrow>\n  \\<forall>n. unity_root k (int (n + k * m)) = unity_root k (int n)\n  \\<forall>n. unity_root k (int (n + k)) = unity_root k (int n)\n\ngoal (1 subgoal):\n 1. cnj (unity_root k (int (n * m + k * m))) =\n    cnj (unity_root k (int (n * m)))", "by presburger"], ["proof (state)\nthis:\n  cnj (unity_root k (int (n * m + k * m))) =\n  cnj (unity_root k (int (n * m)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       unity_root k (- int (n + k) * int m) = unity_root k (- int n * int m)", "also"], ["proof (state)\nthis:\n  cnj (unity_root k (int (n * m + k * m))) =\n  cnj (unity_root k (int (n * m)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       unity_root k (- int (n + k) * int m) = unity_root k (- int n * int m)", "have \"\\<dots> = unity_root k (-n*m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (unity_root k (int (n * m))) = unity_root k (- int n * int m)", "by (simp add: unity_root_uminus)"], ["proof (state)\nthis:\n  cnj (unity_root k (int (n * m))) = unity_root k (- int n * int m)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       unity_root k (- int (n + k) * int m) = unity_root k (- int n * int m)", "finally"], ["proof (chain)\npicking this:\n  unity_root k (- int (n + k) * int m) = unity_root k (- int n * int m)", "show \"unity_root k (-(n + k) * m) = unity_root k (-n*m)\""], ["proof (prove)\nusing this:\n  unity_root k (- int (n + k) * int m) = unity_root k (- int n * int m)\n\ngoal (1 subgoal):\n 1. unity_root k (- int (n + k) * int m) = unity_root k (- int n * int m)", "by simp"], ["proof (state)\nthis:\n  unity_root k (- int (n + k) * int m) = unity_root k (- int n * int m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unity_div:\n fixes a :: int and d :: nat\n assumes \"d dvd k\"\n shows \"unity_root k (a*d) = unity_root (k div d) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k (a * int d) = unity_root (k div d) a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. unity_root k (a * int d) = unity_root (k div d) a", "have 1: \"(2*pi*(a*d)/k) = (2*pi*a)/(k div d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * pi * real_of_int (a * int d) / real k =\n    2 * pi * real_of_int a / real (k div d)", "using Suc_pred assms"], ["proof (prove)\nusing this:\n  0 < ?n \\<Longrightarrow> Suc (?n - Suc 0) = ?n\n  d dvd k\n\ngoal (1 subgoal):\n 1. 2 * pi * real_of_int (a * int d) / real k =\n    2 * pi * real_of_int a / real (k div d)", "by (simp add: divide_simps, fastforce)"], ["proof (state)\nthis:\n  2 * pi * real_of_int (a * int d) / real k =\n  2 * pi * real_of_int a / real (k div d)\n\ngoal (1 subgoal):\n 1. unity_root k (a * int d) = unity_root (k div d) a", "have \"unity_root k (a*d) = exp ((2*pi*(a*d)/k)* \\<i>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k (a * int d) =\n    exp (complex_of_real (2 * pi * real_of_int (a * int d) / real k) * \\<i>)", "using unity_root_conv_exp"], ["proof (prove)\nusing this:\n  unity_root ?k ?n =\n  exp (complex_of_real (2 * pi * real_of_int ?n / real ?k) * \\<i>)\n\ngoal (1 subgoal):\n 1. unity_root k (a * int d) =\n    exp (complex_of_real (2 * pi * real_of_int (a * int d) / real k) * \\<i>)", "by simp"], ["proof (state)\nthis:\n  unity_root k (a * int d) =\n  exp (complex_of_real (2 * pi * real_of_int (a * int d) / real k) * \\<i>)\n\ngoal (1 subgoal):\n 1. unity_root k (a * int d) = unity_root (k div d) a", "also"], ["proof (state)\nthis:\n  unity_root k (a * int d) =\n  exp (complex_of_real (2 * pi * real_of_int (a * int d) / real k) * \\<i>)\n\ngoal (1 subgoal):\n 1. unity_root k (a * int d) = unity_root (k div d) a", "have \"\\<dots> = exp (((2*pi*a)/(k div d))* \\<i>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (complex_of_real (2 * pi * real_of_int (a * int d) / real k) *\n         \\<i>) =\n    exp (complex_of_real (2 * pi * real_of_int a / real (k div d)) * \\<i>)", "using 1"], ["proof (prove)\nusing this:\n  2 * pi * real_of_int (a * int d) / real k =\n  2 * pi * real_of_int a / real (k div d)\n\ngoal (1 subgoal):\n 1. exp (complex_of_real (2 * pi * real_of_int (a * int d) / real k) *\n         \\<i>) =\n    exp (complex_of_real (2 * pi * real_of_int a / real (k div d)) * \\<i>)", "by simp"], ["proof (state)\nthis:\n  exp (complex_of_real (2 * pi * real_of_int (a * int d) / real k) * \\<i>) =\n  exp (complex_of_real (2 * pi * real_of_int a / real (k div d)) * \\<i>)\n\ngoal (1 subgoal):\n 1. unity_root k (a * int d) = unity_root (k div d) a", "also"], ["proof (state)\nthis:\n  exp (complex_of_real (2 * pi * real_of_int (a * int d) / real k) * \\<i>) =\n  exp (complex_of_real (2 * pi * real_of_int a / real (k div d)) * \\<i>)\n\ngoal (1 subgoal):\n 1. unity_root k (a * int d) = unity_root (k div d) a", "have \"\\<dots> = unity_root (k div d) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (complex_of_real (2 * pi * real_of_int a / real (k div d)) * \\<i>) =\n    unity_root (k div d) a", "using unity_root_conv_exp"], ["proof (prove)\nusing this:\n  unity_root ?k ?n =\n  exp (complex_of_real (2 * pi * real_of_int ?n / real ?k) * \\<i>)\n\ngoal (1 subgoal):\n 1. exp (complex_of_real (2 * pi * real_of_int a / real (k div d)) * \\<i>) =\n    unity_root (k div d) a", "by simp"], ["proof (state)\nthis:\n  exp (complex_of_real (2 * pi * real_of_int a / real (k div d)) * \\<i>) =\n  unity_root (k div d) a\n\ngoal (1 subgoal):\n 1. unity_root k (a * int d) = unity_root (k div d) a", "finally"], ["proof (chain)\npicking this:\n  unity_root k (a * int d) = unity_root (k div d) a", "show ?thesis"], ["proof (prove)\nusing this:\n  unity_root k (a * int d) = unity_root (k div d) a\n\ngoal (1 subgoal):\n 1. unity_root k (a * int d) = unity_root (k div d) a", "by simp"], ["proof (state)\nthis:\n  unity_root k (a * int d) = unity_root (k div d) a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unity_div_num:\n  assumes \"k > 0\" \"d > 0\" \"d dvd k\"\n  shows \"unity_root k (x * (k div d)) = unity_root d x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k (int (x * (k div d))) = unity_root d (int x)", "using assms dvd_div_mult_self unity_div"], ["proof (prove)\nusing this:\n  0 < k\n  0 < d\n  d dvd k\n  ?a dvd ?b \\<Longrightarrow> ?b div ?a * ?a = ?b\n  ?d dvd ?k \\<Longrightarrow>\n  unity_root ?k (?a * int ?d) = unity_root (?k div ?d) ?a\n\ngoal (1 subgoal):\n 1. unity_root k (int (x * (k div d))) = unity_root d (int x)", "by auto"], ["", "section \\<open>Geometric sums of roots of unity\\<close>"], ["", "text\\<open>\n  Apostol calls these `geometric sums', which is a bit too generic. We therefore decided\n  to refer to them as `sums of roots of unity'.\n\\<close>"], ["", "definition \"unity_root_sum k n = (\\<Sum>m<k. unity_root k (n * of_nat m))\""], ["", "lemma unity_root_sum_0_left [simp]: \"unity_root_sum 0 n = 0\" and\n      unity_root_sum_0_right [simp]: \"k > 0 \\<Longrightarrow> unity_root_sum k 0 = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root_sum 0 n = 0 &&&\n    (0 < k \\<Longrightarrow> unity_root_sum k 0 = of_nat k)", "unfolding unity_root_sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m<0. unity_root 0 (n * int m)) = 0 &&&\n    (0 < k \\<Longrightarrow>\n     (\\<Sum>m<k. unity_root k (0 * int m)) = of_nat k)", "by simp_all"], ["", "text \\<open>Theorem 8.1\\<close>"], ["", "theorem unity_root_sum:\n  fixes k :: nat and n :: int\n  assumes gr: \"k \\<ge> 1\"\n  shows \"k dvd n \\<Longrightarrow> unity_root_sum k n = k\"\n    and \"\\<not>k dvd n \\<Longrightarrow> unity_root_sum k n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (int k dvd n \\<Longrightarrow> unity_root_sum k n = of_nat k) &&&\n    (\\<not> int k dvd n \\<Longrightarrow> unity_root_sum k n = 0)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. int k dvd n \\<Longrightarrow> unity_root_sum k n = of_nat k\n 2. \\<not> int k dvd n \\<Longrightarrow> unity_root_sum k n = 0", "assume dvd: \"k dvd n\""], ["proof (state)\nthis:\n  int k dvd n\n\ngoal (2 subgoals):\n 1. int k dvd n \\<Longrightarrow> unity_root_sum k n = of_nat k\n 2. \\<not> int k dvd n \\<Longrightarrow> unity_root_sum k n = 0", "let ?x = \"unity_root k n\""], ["proof (state)\ngoal (2 subgoals):\n 1. int k dvd n \\<Longrightarrow> unity_root_sum k n = of_nat k\n 2. \\<not> int k dvd n \\<Longrightarrow> unity_root_sum k n = 0", "have unit: \"?x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k n = 1", "using dvd gr unity_root_eq_1_iff_int"], ["proof (prove)\nusing this:\n  int k dvd n\n  1 \\<le> k\n  0 < ?k \\<Longrightarrow> (unity_root ?k ?n = 1) = (int ?k dvd ?n)\n\ngoal (1 subgoal):\n 1. unity_root k n = 1", "by auto"], ["proof (state)\nthis:\n  unity_root k n = 1\n\ngoal (2 subgoals):\n 1. int k dvd n \\<Longrightarrow> unity_root_sum k n = of_nat k\n 2. \\<not> int k dvd n \\<Longrightarrow> unity_root_sum k n = 0", "have exp: \"?x^m = unity_root k (n*m)\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k n ^ m = unity_root k (n * int m)", "using unity_root_pow"], ["proof (prove)\nusing this:\n  unity_root ?k ?n ^ ?m = unity_root ?k (?n * int ?m)\n\ngoal (1 subgoal):\n 1. unity_root k n ^ m = unity_root k (n * int m)", "by simp"], ["proof (state)\nthis:\n  unity_root k n ^ ?m = unity_root k (n * int ?m)\n\ngoal (2 subgoals):\n 1. int k dvd n \\<Longrightarrow> unity_root_sum k n = of_nat k\n 2. \\<not> int k dvd n \\<Longrightarrow> unity_root_sum k n = 0", "have \"unity_root_sum k n = (\\<Sum>m<k. unity_root k (n*m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root_sum k n = (\\<Sum>m<k. unity_root k (n * int m))", "using unity_root_sum_def"], ["proof (prove)\nusing this:\n  unity_root_sum ?k ?n = (\\<Sum>m<?k. unity_root ?k (?n * int m))\n\ngoal (1 subgoal):\n 1. unity_root_sum k n = (\\<Sum>m<k. unity_root k (n * int m))", "by simp"], ["proof (state)\nthis:\n  unity_root_sum k n = (\\<Sum>m<k. unity_root k (n * int m))\n\ngoal (2 subgoals):\n 1. int k dvd n \\<Longrightarrow> unity_root_sum k n = of_nat k\n 2. \\<not> int k dvd n \\<Longrightarrow> unity_root_sum k n = 0", "also"], ["proof (state)\nthis:\n  unity_root_sum k n = (\\<Sum>m<k. unity_root k (n * int m))\n\ngoal (2 subgoals):\n 1. int k dvd n \\<Longrightarrow> unity_root_sum k n = of_nat k\n 2. \\<not> int k dvd n \\<Longrightarrow> unity_root_sum k n = 0", "have \"\\<dots> = (\\<Sum>m<k. ?x^m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m<k. unity_root k (n * int m)) =\n    sum ((^) (unity_root k n)) {..<k}", "using exp"], ["proof (prove)\nusing this:\n  unity_root k n ^ ?m = unity_root k (n * int ?m)\n\ngoal (1 subgoal):\n 1. (\\<Sum>m<k. unity_root k (n * int m)) =\n    sum ((^) (unity_root k n)) {..<k}", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>m<k. unity_root k (n * int m)) = sum ((^) (unity_root k n)) {..<k}\n\ngoal (2 subgoals):\n 1. int k dvd n \\<Longrightarrow> unity_root_sum k n = of_nat k\n 2. \\<not> int k dvd n \\<Longrightarrow> unity_root_sum k n = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>m<k. unity_root k (n * int m)) = sum ((^) (unity_root k n)) {..<k}\n\ngoal (2 subgoals):\n 1. int k dvd n \\<Longrightarrow> unity_root_sum k n = of_nat k\n 2. \\<not> int k dvd n \\<Longrightarrow> unity_root_sum k n = 0", "have \"\\<dots> = (\\<Sum>m<k. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((^) (unity_root k n)) {..<k} = (\\<Sum>m<k. 1)", "using unit"], ["proof (prove)\nusing this:\n  unity_root k n = 1\n\ngoal (1 subgoal):\n 1. sum ((^) (unity_root k n)) {..<k} = (\\<Sum>m<k. 1)", "by simp"], ["proof (state)\nthis:\n  sum ((^) (unity_root k n)) {..<k} = (\\<Sum>m<k. 1)\n\ngoal (2 subgoals):\n 1. int k dvd n \\<Longrightarrow> unity_root_sum k n = of_nat k\n 2. \\<not> int k dvd n \\<Longrightarrow> unity_root_sum k n = 0", "also"], ["proof (state)\nthis:\n  sum ((^) (unity_root k n)) {..<k} = (\\<Sum>m<k. 1)\n\ngoal (2 subgoals):\n 1. int k dvd n \\<Longrightarrow> unity_root_sum k n = of_nat k\n 2. \\<not> int k dvd n \\<Longrightarrow> unity_root_sum k n = 0", "have \"\\<dots> = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m<k. 1) = of_nat k", "using gr"], ["proof (prove)\nusing this:\n  1 \\<le> k\n\ngoal (1 subgoal):\n 1. (\\<Sum>m<k. 1) = of_nat k", "by (induction k, auto)"], ["proof (state)\nthis:\n  (\\<Sum>m<k. 1) = of_nat k\n\ngoal (2 subgoals):\n 1. int k dvd n \\<Longrightarrow> unity_root_sum k n = of_nat k\n 2. \\<not> int k dvd n \\<Longrightarrow> unity_root_sum k n = 0", "finally"], ["proof (chain)\npicking this:\n  unity_root_sum k n = of_nat k", "show \"unity_root_sum k n = k\""], ["proof (prove)\nusing this:\n  unity_root_sum k n = of_nat k\n\ngoal (1 subgoal):\n 1. unity_root_sum k n = of_nat k", "by simp"], ["proof (state)\nthis:\n  unity_root_sum k n = of_nat k\n\ngoal (1 subgoal):\n 1. \\<not> int k dvd n \\<Longrightarrow> unity_root_sum k n = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> int k dvd n \\<Longrightarrow> unity_root_sum k n = 0", "assume dvd: \"\\<not>k dvd n\""], ["proof (state)\nthis:\n  \\<not> int k dvd n\n\ngoal (1 subgoal):\n 1. \\<not> int k dvd n \\<Longrightarrow> unity_root_sum k n = 0", "let ?x = \"unity_root k n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> int k dvd n \\<Longrightarrow> unity_root_sum k n = 0", "have \"?x \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k n \\<noteq> 1", "using dvd gr unity_root_eq_1_iff_int"], ["proof (prove)\nusing this:\n  \\<not> int k dvd n\n  1 \\<le> k\n  0 < ?k \\<Longrightarrow> (unity_root ?k ?n = 1) = (int ?k dvd ?n)\n\ngoal (1 subgoal):\n 1. unity_root k n \\<noteq> 1", "by auto"], ["proof (state)\nthis:\n  unity_root k n \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<not> int k dvd n \\<Longrightarrow> unity_root_sum k n = 0", "have \"(?x^k - 1)/(?x - 1) = (\\<Sum>m<k. ?x^m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (unity_root k n ^ k - 1) / (unity_root k n - 1) =\n    sum ((^) (unity_root k n)) {..<k}", "using geometric_sum[of ?x k, OF \\<open>?x \\<noteq> 1\\<close>]"], ["proof (prove)\nusing this:\n  sum ((^) (unity_root k n)) {..<k} =\n  (unity_root k n ^ k - 1) / (unity_root k n - 1)\n\ngoal (1 subgoal):\n 1. (unity_root k n ^ k - 1) / (unity_root k n - 1) =\n    sum ((^) (unity_root k n)) {..<k}", "by auto"], ["proof (state)\nthis:\n  (unity_root k n ^ k - 1) / (unity_root k n - 1) =\n  sum ((^) (unity_root k n)) {..<k}\n\ngoal (1 subgoal):\n 1. \\<not> int k dvd n \\<Longrightarrow> unity_root_sum k n = 0", "then"], ["proof (chain)\npicking this:\n  (unity_root k n ^ k - 1) / (unity_root k n - 1) =\n  sum ((^) (unity_root k n)) {..<k}", "have sum: \"unity_root_sum k n = (?x^k - 1)/(?x - 1)\""], ["proof (prove)\nusing this:\n  (unity_root k n ^ k - 1) / (unity_root k n - 1) =\n  sum ((^) (unity_root k n)) {..<k}\n\ngoal (1 subgoal):\n 1. unity_root_sum k n = (unity_root k n ^ k - 1) / (unity_root k n - 1)", "using unity_root_sum_def unity_root_pow"], ["proof (prove)\nusing this:\n  (unity_root k n ^ k - 1) / (unity_root k n - 1) =\n  sum ((^) (unity_root k n)) {..<k}\n  unity_root_sum ?k ?n = (\\<Sum>m<?k. unity_root ?k (?n * int m))\n  unity_root ?k ?n ^ ?m = unity_root ?k (?n * int ?m)\n\ngoal (1 subgoal):\n 1. unity_root_sum k n = (unity_root k n ^ k - 1) / (unity_root k n - 1)", "by simp"], ["proof (state)\nthis:\n  unity_root_sum k n = (unity_root k n ^ k - 1) / (unity_root k n - 1)\n\ngoal (1 subgoal):\n 1. \\<not> int k dvd n \\<Longrightarrow> unity_root_sum k n = 0", "have \"?x^k = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k n ^ k = 1", "using gr unity_root_eq_1_iff_int unity_root_pow"], ["proof (prove)\nusing this:\n  1 \\<le> k\n  0 < ?k \\<Longrightarrow> (unity_root ?k ?n = 1) = (int ?k dvd ?n)\n  unity_root ?k ?n ^ ?m = unity_root ?k (?n * int ?m)\n\ngoal (1 subgoal):\n 1. unity_root k n ^ k = 1", "by simp"], ["proof (state)\nthis:\n  unity_root k n ^ k = 1\n\ngoal (1 subgoal):\n 1. \\<not> int k dvd n \\<Longrightarrow> unity_root_sum k n = 0", "then"], ["proof (chain)\npicking this:\n  unity_root k n ^ k = 1", "show \"unity_root_sum k n = 0\""], ["proof (prove)\nusing this:\n  unity_root k n ^ k = 1\n\ngoal (1 subgoal):\n 1. unity_root_sum k n = 0", "using sum"], ["proof (prove)\nusing this:\n  unity_root k n ^ k = 1\n  unity_root_sum k n = (unity_root k n ^ k - 1) / (unity_root k n - 1)\n\ngoal (1 subgoal):\n 1. unity_root_sum k n = 0", "by auto"], ["proof (state)\nthis:\n  unity_root_sum k n = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary unity_root_sum_periodic_arithmetic: \n \"periodic_arithmetic (unity_root_sum k) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>x. unity_root_sum k (int x)) k", "unfolding periodic_arithmetic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. unity_root_sum k (int (n + k)) = unity_root_sum k (int n)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. unity_root_sum k (int (n + k)) = unity_root_sum k (int n)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. unity_root_sum k (int (n + k)) = unity_root_sum k (int n)", "show \"unity_root_sum k (n + k) = unity_root_sum k n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root_sum k (int (n + k)) = unity_root_sum k (int n)", "by (cases \"k = 0\"; cases \"k dvd n\") (auto simp add: unity_root_sum)"], ["proof (state)\nthis:\n  unity_root_sum k (int (n + k)) = unity_root_sum k (int n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unity_root_sum_nonzero_iff:\n  fixes r :: int\n  assumes \"k \\<ge> 1\" and \"r \\<in> {-k<..<k}\"\n  shows \"unity_root_sum k r \\<noteq> 0 \\<longleftrightarrow> r = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (unity_root_sum k r \\<noteq> 0) = (r = 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. unity_root_sum k r \\<noteq> 0 \\<Longrightarrow> r = 0\n 2. r = 0 \\<Longrightarrow> unity_root_sum k r \\<noteq> 0", "assume \"unity_root_sum k r \\<noteq> 0\""], ["proof (state)\nthis:\n  unity_root_sum k r \\<noteq> 0\n\ngoal (2 subgoals):\n 1. unity_root_sum k r \\<noteq> 0 \\<Longrightarrow> r = 0\n 2. r = 0 \\<Longrightarrow> unity_root_sum k r \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  unity_root_sum k r \\<noteq> 0", "have \"k dvd r\""], ["proof (prove)\nusing this:\n  unity_root_sum k r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. int k dvd r", "using unity_root_sum assms"], ["proof (prove)\nusing this:\n  unity_root_sum k r \\<noteq> 0\n  \\<lbrakk>1 \\<le> ?k; int ?k dvd ?n\\<rbrakk>\n  \\<Longrightarrow> unity_root_sum ?k ?n = of_nat ?k\n  \\<lbrakk>1 \\<le> ?k; \\<not> int ?k dvd ?n\\<rbrakk>\n  \\<Longrightarrow> unity_root_sum ?k ?n = 0\n  1 \\<le> k\n  r \\<in> {- int k<..<int k}\n\ngoal (1 subgoal):\n 1. int k dvd r", "by blast"], ["proof (state)\nthis:\n  int k dvd r\n\ngoal (2 subgoals):\n 1. unity_root_sum k r \\<noteq> 0 \\<Longrightarrow> r = 0\n 2. r = 0 \\<Longrightarrow> unity_root_sum k r \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  int k dvd r", "show \"r = 0\""], ["proof (prove)\nusing this:\n  int k dvd r\n\ngoal (1 subgoal):\n 1. r = 0", "using assms(2)"], ["proof (prove)\nusing this:\n  int k dvd r\n  r \\<in> {- int k<..<int k}\n\ngoal (1 subgoal):\n 1. r = 0", "using dvd_imp_le_int"], ["proof (prove)\nusing this:\n  int k dvd r\n  r \\<in> {- int k<..<int k}\n  \\<lbrakk>?i \\<noteq> 0; ?d dvd ?i\\<rbrakk>\n  \\<Longrightarrow> \\<bar>?d\\<bar> \\<le> \\<bar>?i\\<bar>\n\ngoal (1 subgoal):\n 1. r = 0", "by force"], ["proof (state)\nthis:\n  r = 0\n\ngoal (1 subgoal):\n 1. r = 0 \\<Longrightarrow> unity_root_sum k r \\<noteq> 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. r = 0 \\<Longrightarrow> unity_root_sum k r \\<noteq> 0", "assume \"r = 0\""], ["proof (state)\nthis:\n  r = 0\n\ngoal (1 subgoal):\n 1. r = 0 \\<Longrightarrow> unity_root_sum k r \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  r = 0", "have \"k dvd r\""], ["proof (prove)\nusing this:\n  r = 0\n\ngoal (1 subgoal):\n 1. int k dvd r", "by auto"], ["proof (state)\nthis:\n  int k dvd r\n\ngoal (1 subgoal):\n 1. r = 0 \\<Longrightarrow> unity_root_sum k r \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  int k dvd r", "have \"unity_root_sum k r = k\""], ["proof (prove)\nusing this:\n  int k dvd r\n\ngoal (1 subgoal):\n 1. unity_root_sum k r = of_nat k", "using assms(1) unity_root_sum"], ["proof (prove)\nusing this:\n  int k dvd r\n  1 \\<le> k\n  \\<lbrakk>1 \\<le> ?k; int ?k dvd ?n\\<rbrakk>\n  \\<Longrightarrow> unity_root_sum ?k ?n = of_nat ?k\n  \\<lbrakk>1 \\<le> ?k; \\<not> int ?k dvd ?n\\<rbrakk>\n  \\<Longrightarrow> unity_root_sum ?k ?n = 0\n\ngoal (1 subgoal):\n 1. unity_root_sum k r = of_nat k", "by blast"], ["proof (state)\nthis:\n  unity_root_sum k r = of_nat k\n\ngoal (1 subgoal):\n 1. r = 0 \\<Longrightarrow> unity_root_sum k r \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  unity_root_sum k r = of_nat k", "show \"unity_root_sum k r \\<noteq> 0\""], ["proof (prove)\nusing this:\n  unity_root_sum k r = of_nat k\n\ngoal (1 subgoal):\n 1. unity_root_sum k r \\<noteq> 0", "using assms(1)"], ["proof (prove)\nusing this:\n  unity_root_sum k r = of_nat k\n  1 \\<le> k\n\ngoal (1 subgoal):\n 1. unity_root_sum k r \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  unity_root_sum k r \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}