{"file_name": "/home/qj213/afp-2021-10-22/thys/Gauss_Sums/Finite_Fourier_Series.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Gauss_Sums", "problem_names": ["lemma lagrange_exists:\n  assumes d: \"distinct (map fst zs_ws)\"\n  defines e: \"(p :: complex poly) \\<equiv> lagrange_interpolation_poly zs_ws\"\n  shows \"degree p \\<le> (length zs_ws)-1\"\n        \"(\\<forall>x y. (x,y) \\<in> set zs_ws \\<longrightarrow> poly p x = y)\"", "lemma lagrange_unique:\n  assumes o: \"length zs_ws > 0\" (* implicit in theorem *)\n  assumes d: \"distinct (map fst zs_ws)\"\n  assumes 1: \"degree (p1 :: complex poly) \\<le> (length zs_ws)-1 \\<and>\n               (\\<forall>x y. (x,y) \\<in> set zs_ws \\<longrightarrow> poly p1 x = y)\"\n  assumes 2: \"degree (p2 :: complex poly) \\<le> (length zs_ws)-1 \\<and>\n               (\\<forall>x y. (x,y) \\<in> set zs_ws \\<longrightarrow> poly p2 x = y)\"\n  shows \"p1 = p2\"", "lemma poly_altdef':\n assumes gr: \"k \\<ge> degree p\"  \n shows \"poly p (z::complex) = (\\<Sum>i\\<le>k. coeff p i * z ^ i)\"", "lemma degree_poly_of_list_le: \"degree (poly_of_list ws) \\<le> length ws - 1\"", "lemma degree_finite_fourier_poly: \"degree (finite_fourier_poly ws) \\<le> length ws - 1\"", "lemma coeff_finite_fourier_poly:\n  assumes \"n < length ws\"\n  defines \"k \\<equiv> length ws\"\n  shows \"coeff (finite_fourier_poly ws) n = \n         (1/k) * (\\<Sum>m < k. ws ! m * unity_root k (-n*m))\"", "lemma poly_finite_fourier_poly:\n  fixes m :: int and ws\n  defines \"k \\<equiv> length ws\"\n  assumes \"m \\<in> {0..<k}\"\n  assumes \"m < length ws\"\n  shows \"poly (finite_fourier_poly ws) (unity_root k m) = ws ! (nat m)\"", "theorem finite_fourier_poly_unique:\n  assumes \"length ws > 0\"\n  defines \"k \\<equiv> length ws\"\n  assumes \"(degree p \\<le> k - 1)\"\n  assumes \"(\\<forall>m \\<le> k-1. (ws ! m) = poly p (unity_root k m))\"\n  shows \"p = finite_fourier_poly ws\"", "lemma finite_fourier_poly'_conv_finite_fourier_poly:\n  \"finite_fourier_poly' ws k = finite_fourier_poly [ws n. n \\<leftarrow> [0..<k]]\"", "lemma coeff_finite_fourier_poly': \n  assumes \"n < k\"\n  shows \"coeff (finite_fourier_poly' ws k) n = \n         (1/k) * (\\<Sum>m < k. (ws m) * unity_root k (-n*m))\"", "lemma degree_finite_fourier_poly': \"degree (finite_fourier_poly' ws k) \\<le> k - 1\"", "lemma poly_finite_fourier_poly':\n  fixes m :: int and k\n  assumes \"m \\<in> {0..<k}\"\n  shows \"poly (finite_fourier_poly' ws k) (unity_root k m) = ws (nat m)\"", "lemma finite_fourier_poly'_unique:\n  assumes \"k > 0\"\n  assumes \"degree p \\<le> k - 1\"\n  assumes \"\\<forall>m\\<le>k-1. ws m = poly p (unity_root k m)\"\n  shows \"p = finite_fourier_poly' ws k\"", "lemma fourier_unity_root:\n  fixes k :: nat\n  assumes \"k > 0\" \n  shows \"poly (finite_fourier_poly' f k) (unity_root k m) = \n    (\\<Sum>n<k.1/k*(\\<Sum>m<k.(f m)*unity_root k (-n*m))*unity_root k (m*n))\"", "theorem fourier_expansion_periodic_arithmetic:\n  assumes \"k > 0\"\n  assumes \"periodic_arithmetic f k\"\n  defines \"g \\<equiv> (\\<lambda>n. (1 / k) * (\\<Sum>m<k. f m * unity_root k (-n * m)))\"\n    shows \"periodic_arithmetic g k\" \n      and \"f m = (\\<Sum>n<k. g n * unity_root k (m * n))\"", "theorem fourier_expansion_periodic_arithmetic_unique:\n  fixes f g :: \"nat \\<Rightarrow> complex\" \n  assumes \"k > 0\"\n  assumes \"periodic_arithmetic f k\" and \"periodic_arithmetic g k\"\n  assumes \"\\<And>m. m < k \\<Longrightarrow> f m = (\\<Sum>n<k. g n * unity_root k (int (m * n)))\" \n  shows   \"g n = (1 / k) * (\\<Sum>m<k. f m * unity_root k (-n * m))\""], "translations": [["", "lemma lagrange_exists:\n  assumes d: \"distinct (map fst zs_ws)\"\n  defines e: \"(p :: complex poly) \\<equiv> lagrange_interpolation_poly zs_ws\"\n  shows \"degree p \\<le> (length zs_ws)-1\"\n        \"(\\<forall>x y. (x,y) \\<in> set zs_ws \\<longrightarrow> poly p x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p \\<le> length zs_ws - 1 &&&\n    \\<forall>x y. (x, y) \\<in> set zs_ws \\<longrightarrow> poly p x = y", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p \\<le> length zs_ws - 1\n 2. \\<forall>x y. (x, y) \\<in> set zs_ws \\<longrightarrow> poly p x = y", "from e"], ["proof (chain)\npicking this:\n  p \\<equiv> lagrange_interpolation_poly zs_ws", "show \"degree p \\<le> (length zs_ws - 1)\""], ["proof (prove)\nusing this:\n  p \\<equiv> lagrange_interpolation_poly zs_ws\n\ngoal (1 subgoal):\n 1. degree p \\<le> length zs_ws - 1", "using degree_lagrange_interpolation_poly"], ["proof (prove)\nusing this:\n  p \\<equiv> lagrange_interpolation_poly zs_ws\n  degree (lagrange_interpolation_poly ?xs_ys) \\<le> length ?xs_ys - 1\n\ngoal (1 subgoal):\n 1. degree p \\<le> length zs_ws - 1", "by auto"], ["proof (state)\nthis:\n  degree p \\<le> length zs_ws - 1\n\ngoal (1 subgoal):\n 1. \\<forall>x y. (x, y) \\<in> set zs_ws \\<longrightarrow> poly p x = y", "from e d"], ["proof (chain)\npicking this:\n  p \\<equiv> lagrange_interpolation_poly zs_ws\n  distinct (map fst zs_ws)", "have \n    \"poly p x = y\" if \"(x,y) \\<in> set zs_ws\" for x y"], ["proof (prove)\nusing this:\n  p \\<equiv> lagrange_interpolation_poly zs_ws\n  distinct (map fst zs_ws)\n\ngoal (1 subgoal):\n 1. poly p x = y", "using that lagrange_interpolation_poly"], ["proof (prove)\nusing this:\n  p \\<equiv> lagrange_interpolation_poly zs_ws\n  distinct (map fst zs_ws)\n  (x, y) \\<in> set zs_ws\n  \\<lbrakk>distinct (map fst ?xs_ys);\n   ?p = lagrange_interpolation_poly ?xs_ys;\n   (?x, ?y) \\<in> set ?xs_ys\\<rbrakk>\n  \\<Longrightarrow> poly ?p ?x = ?y\n\ngoal (1 subgoal):\n 1. poly p x = y", "by auto"], ["proof (state)\nthis:\n  (?x, ?y) \\<in> set zs_ws \\<Longrightarrow> poly p ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<forall>x y. (x, y) \\<in> set zs_ws \\<longrightarrow> poly p x = y", "then"], ["proof (chain)\npicking this:\n  (?x, ?y) \\<in> set zs_ws \\<Longrightarrow> poly p ?x = ?y", "show \"(\\<forall>x y. (x,y) \\<in> set zs_ws \\<longrightarrow> poly p x = y)\""], ["proof (prove)\nusing this:\n  (?x, ?y) \\<in> set zs_ws \\<Longrightarrow> poly p ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<forall>x y. (x, y) \\<in> set zs_ws \\<longrightarrow> poly p x = y", "by auto"], ["proof (state)\nthis:\n  \\<forall>x y. (x, y) \\<in> set zs_ws \\<longrightarrow> poly p x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lagrange_unique:\n  assumes o: \"length zs_ws > 0\" (* implicit in theorem *)\n  assumes d: \"distinct (map fst zs_ws)\"\n  assumes 1: \"degree (p1 :: complex poly) \\<le> (length zs_ws)-1 \\<and>\n               (\\<forall>x y. (x,y) \\<in> set zs_ws \\<longrightarrow> poly p1 x = y)\"\n  assumes 2: \"degree (p2 :: complex poly) \\<le> (length zs_ws)-1 \\<and>\n               (\\<forall>x y. (x,y) \\<in> set zs_ws \\<longrightarrow> poly p2 x = y)\"\n  shows \"p1 = p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 = p2", "proof (cases \"p1 - p2 = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p1 - p2 = 0 \\<Longrightarrow> p1 = p2\n 2. p1 - p2 \\<noteq> 0 \\<Longrightarrow> p1 = p2", "case True"], ["proof (state)\nthis:\n  p1 - p2 = 0\n\ngoal (2 subgoals):\n 1. p1 - p2 = 0 \\<Longrightarrow> p1 = p2\n 2. p1 - p2 \\<noteq> 0 \\<Longrightarrow> p1 = p2", "then"], ["proof (chain)\npicking this:\n  p1 - p2 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p1 - p2 = 0\n\ngoal (1 subgoal):\n 1. p1 = p2", "by simp"], ["proof (state)\nthis:\n  p1 = p2\n\ngoal (1 subgoal):\n 1. p1 - p2 \\<noteq> 0 \\<Longrightarrow> p1 = p2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p1 - p2 \\<noteq> 0 \\<Longrightarrow> p1 = p2", "case False"], ["proof (state)\nthis:\n  p1 - p2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p1 - p2 \\<noteq> 0 \\<Longrightarrow> p1 = p2", "have \"poly (p1-p2) x = 0\" if \"x \\<in> set (map fst zs_ws)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (p1 - p2) x = 0", "using 1 2 that"], ["proof (prove)\nusing this:\n  degree p1 \\<le> length zs_ws - 1 \\<and>\n  (\\<forall>x y. (x, y) \\<in> set zs_ws \\<longrightarrow> poly p1 x = y)\n  degree p2 \\<le> length zs_ws - 1 \\<and>\n  (\\<forall>x y. (x, y) \\<in> set zs_ws \\<longrightarrow> poly p2 x = y)\n  x \\<in> set (map fst zs_ws)\n\ngoal (1 subgoal):\n 1. poly (p1 - p2) x = 0", "by (auto simp add: field_simps)"], ["proof (state)\nthis:\n  ?x \\<in> set (map fst zs_ws) \\<Longrightarrow> poly (p1 - p2) ?x = 0\n\ngoal (1 subgoal):\n 1. p1 - p2 \\<noteq> 0 \\<Longrightarrow> p1 = p2", "from this d"], ["proof (chain)\npicking this:\n  ?x \\<in> set (map fst zs_ws) \\<Longrightarrow> poly (p1 - p2) ?x = 0\n  distinct (map fst zs_ws)", "have 3: \"card {x. poly (p1-p2) x = 0} \\<ge> length zs_ws\""], ["proof (prove)\nusing this:\n  ?x \\<in> set (map fst zs_ws) \\<Longrightarrow> poly (p1 - p2) ?x = 0\n  distinct (map fst zs_ws)\n\ngoal (1 subgoal):\n 1. length zs_ws \\<le> card {x. poly (p1 - p2) x = 0}", "proof (induction zs_ws)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                x \\<in> set (map fst []) \\<Longrightarrow>\n                poly (p1 - p2) x = 0;\n     distinct (map fst [])\\<rbrakk>\n    \\<Longrightarrow> length [] \\<le> card {x. poly (p1 - p2) x = 0}\n 2. \\<And>a zs_ws.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> set (map fst zs_ws) \\<Longrightarrow>\n                            poly (p1 - p2) x = 0;\n                 distinct (map fst zs_ws)\\<rbrakk>\n                \\<Longrightarrow> length zs_ws\n                                  \\<le> card {x. poly (p1 - p2) x = 0};\n        \\<And>x.\n           x \\<in> set (map fst (a # zs_ws)) \\<Longrightarrow>\n           poly (p1 - p2) x = 0;\n        distinct (map fst (a # zs_ws))\\<rbrakk>\n       \\<Longrightarrow> length (a # zs_ws)\n                         \\<le> card {x. poly (p1 - p2) x = 0}", "case Nil"], ["proof (state)\nthis:\n  ?x \\<in> set (map fst []) \\<Longrightarrow> poly (p1 - p2) ?x = 0\n  distinct (map fst [])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                x \\<in> set (map fst []) \\<Longrightarrow>\n                poly (p1 - p2) x = 0;\n     distinct (map fst [])\\<rbrakk>\n    \\<Longrightarrow> length [] \\<le> card {x. poly (p1 - p2) x = 0}\n 2. \\<And>a zs_ws.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> set (map fst zs_ws) \\<Longrightarrow>\n                            poly (p1 - p2) x = 0;\n                 distinct (map fst zs_ws)\\<rbrakk>\n                \\<Longrightarrow> length zs_ws\n                                  \\<le> card {x. poly (p1 - p2) x = 0};\n        \\<And>x.\n           x \\<in> set (map fst (a # zs_ws)) \\<Longrightarrow>\n           poly (p1 - p2) x = 0;\n        distinct (map fst (a # zs_ws))\\<rbrakk>\n       \\<Longrightarrow> length (a # zs_ws)\n                         \\<le> card {x. poly (p1 - p2) x = 0}", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> set (map fst []) \\<Longrightarrow> poly (p1 - p2) ?x = 0\n  distinct (map fst [])", "show ?case"], ["proof (prove)\nusing this:\n  ?x \\<in> set (map fst []) \\<Longrightarrow> poly (p1 - p2) ?x = 0\n  distinct (map fst [])\n\ngoal (1 subgoal):\n 1. length [] \\<le> card {x. poly (p1 - p2) x = 0}", "by simp"], ["proof (state)\nthis:\n  length [] \\<le> card {x. poly (p1 - p2) x = 0}\n\ngoal (1 subgoal):\n 1. \\<And>a zs_ws.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> set (map fst zs_ws) \\<Longrightarrow>\n                            poly (p1 - p2) x = 0;\n                 distinct (map fst zs_ws)\\<rbrakk>\n                \\<Longrightarrow> length zs_ws\n                                  \\<le> card {x. poly (p1 - p2) x = 0};\n        \\<And>x.\n           x \\<in> set (map fst (a # zs_ws)) \\<Longrightarrow>\n           poly (p1 - p2) x = 0;\n        distinct (map fst (a # zs_ws))\\<rbrakk>\n       \\<Longrightarrow> length (a # zs_ws)\n                         \\<le> card {x. poly (p1 - p2) x = 0}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a zs_ws.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> set (map fst zs_ws) \\<Longrightarrow>\n                            poly (p1 - p2) x = 0;\n                 distinct (map fst zs_ws)\\<rbrakk>\n                \\<Longrightarrow> length zs_ws\n                                  \\<le> card {x. poly (p1 - p2) x = 0};\n        \\<And>x.\n           x \\<in> set (map fst (a # zs_ws)) \\<Longrightarrow>\n           poly (p1 - p2) x = 0;\n        distinct (map fst (a # zs_ws))\\<rbrakk>\n       \\<Longrightarrow> length (a # zs_ws)\n                         \\<le> card {x. poly (p1 - p2) x = 0}", "case (Cons z_w zs_ws)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>x.\n              x \\<in> set (map fst zs_ws) \\<Longrightarrow>\n              poly (p1 - p2) x = 0;\n   distinct (map fst zs_ws)\\<rbrakk>\n  \\<Longrightarrow> length zs_ws \\<le> card {x. poly (p1 - p2) x = 0}\n  ?x \\<in> set (map fst (z_w # zs_ws)) \\<Longrightarrow>\n  poly (p1 - p2) ?x = 0\n  distinct (map fst (z_w # zs_ws))\n\ngoal (1 subgoal):\n 1. \\<And>a zs_ws.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> set (map fst zs_ws) \\<Longrightarrow>\n                            poly (p1 - p2) x = 0;\n                 distinct (map fst zs_ws)\\<rbrakk>\n                \\<Longrightarrow> length zs_ws\n                                  \\<le> card {x. poly (p1 - p2) x = 0};\n        \\<And>x.\n           x \\<in> set (map fst (a # zs_ws)) \\<Longrightarrow>\n           poly (p1 - p2) x = 0;\n        distinct (map fst (a # zs_ws))\\<rbrakk>\n       \\<Longrightarrow> length (a # zs_ws)\n                         \\<le> card {x. poly (p1 - p2) x = 0}", "from  False poly_roots_finite"], ["proof (chain)\npicking this:\n  p1 - p2 \\<noteq> 0\n  ?p \\<noteq> 0 \\<Longrightarrow> finite {x. poly ?p x = (0::?'a)}", "have f: \"finite {x. poly (p1 - p2) x = 0}\""], ["proof (prove)\nusing this:\n  p1 - p2 \\<noteq> 0\n  ?p \\<noteq> 0 \\<Longrightarrow> finite {x. poly ?p x = (0::?'a)}\n\ngoal (1 subgoal):\n 1. finite {x. poly (p1 - p2) x = 0}", "by blast"], ["proof (state)\nthis:\n  finite {x. poly (p1 - p2) x = 0}\n\ngoal (1 subgoal):\n 1. \\<And>a zs_ws.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> set (map fst zs_ws) \\<Longrightarrow>\n                            poly (p1 - p2) x = 0;\n                 distinct (map fst zs_ws)\\<rbrakk>\n                \\<Longrightarrow> length zs_ws\n                                  \\<le> card {x. poly (p1 - p2) x = 0};\n        \\<And>x.\n           x \\<in> set (map fst (a # zs_ws)) \\<Longrightarrow>\n           poly (p1 - p2) x = 0;\n        distinct (map fst (a # zs_ws))\\<rbrakk>\n       \\<Longrightarrow> length (a # zs_ws)\n                         \\<le> card {x. poly (p1 - p2) x = 0}", "from Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x.\n              x \\<in> set (map fst zs_ws) \\<Longrightarrow>\n              poly (p1 - p2) x = 0;\n   distinct (map fst zs_ws)\\<rbrakk>\n  \\<Longrightarrow> length zs_ws \\<le> card {x. poly (p1 - p2) x = 0}\n  ?x \\<in> set (map fst (z_w # zs_ws)) \\<Longrightarrow>\n  poly (p1 - p2) ?x = 0\n  distinct (map fst (z_w # zs_ws))", "have \"set (map fst (z_w # zs_ws)) \\<subseteq> {x. poly (p1 - p2) x = 0}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x.\n              x \\<in> set (map fst zs_ws) \\<Longrightarrow>\n              poly (p1 - p2) x = 0;\n   distinct (map fst zs_ws)\\<rbrakk>\n  \\<Longrightarrow> length zs_ws \\<le> card {x. poly (p1 - p2) x = 0}\n  ?x \\<in> set (map fst (z_w # zs_ws)) \\<Longrightarrow>\n  poly (p1 - p2) ?x = 0\n  distinct (map fst (z_w # zs_ws))\n\ngoal (1 subgoal):\n 1. set (map fst (z_w # zs_ws)) \\<subseteq> {x. poly (p1 - p2) x = 0}", "by auto"], ["proof (state)\nthis:\n  set (map fst (z_w # zs_ws)) \\<subseteq> {x. poly (p1 - p2) x = 0}\n\ngoal (1 subgoal):\n 1. \\<And>a zs_ws.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> set (map fst zs_ws) \\<Longrightarrow>\n                            poly (p1 - p2) x = 0;\n                 distinct (map fst zs_ws)\\<rbrakk>\n                \\<Longrightarrow> length zs_ws\n                                  \\<le> card {x. poly (p1 - p2) x = 0};\n        \\<And>x.\n           x \\<in> set (map fst (a # zs_ws)) \\<Longrightarrow>\n           poly (p1 - p2) x = 0;\n        distinct (map fst (a # zs_ws))\\<rbrakk>\n       \\<Longrightarrow> length (a # zs_ws)\n                         \\<le> card {x. poly (p1 - p2) x = 0}", "then"], ["proof (chain)\npicking this:\n  set (map fst (z_w # zs_ws)) \\<subseteq> {x. poly (p1 - p2) x = 0}", "have i: \"card (set (map fst (z_w # zs_ws))) \\<le> card {x. poly (p1 - p2) x = 0}\""], ["proof (prove)\nusing this:\n  set (map fst (z_w # zs_ws)) \\<subseteq> {x. poly (p1 - p2) x = 0}\n\ngoal (1 subgoal):\n 1. card (set (map fst (z_w # zs_ws))) \\<le> card {x. poly (p1 - p2) x = 0}", "using card_mono f"], ["proof (prove)\nusing this:\n  set (map fst (z_w # zs_ws)) \\<subseteq> {x. poly (p1 - p2) x = 0}\n  \\<lbrakk>finite ?B; ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> card ?A \\<le> card ?B\n  finite {x. poly (p1 - p2) x = 0}\n\ngoal (1 subgoal):\n 1. card (set (map fst (z_w # zs_ws))) \\<le> card {x. poly (p1 - p2) x = 0}", "by blast"], ["proof (state)\nthis:\n  card (set (map fst (z_w # zs_ws))) \\<le> card {x. poly (p1 - p2) x = 0}\n\ngoal (1 subgoal):\n 1. \\<And>a zs_ws.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> set (map fst zs_ws) \\<Longrightarrow>\n                            poly (p1 - p2) x = 0;\n                 distinct (map fst zs_ws)\\<rbrakk>\n                \\<Longrightarrow> length zs_ws\n                                  \\<le> card {x. poly (p1 - p2) x = 0};\n        \\<And>x.\n           x \\<in> set (map fst (a # zs_ws)) \\<Longrightarrow>\n           poly (p1 - p2) x = 0;\n        distinct (map fst (a # zs_ws))\\<rbrakk>\n       \\<Longrightarrow> length (a # zs_ws)\n                         \\<le> card {x. poly (p1 - p2) x = 0}", "have \"length (z_w # zs_ws) \\<le> card (set (map fst (z_w # zs_ws)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (z_w # zs_ws) \\<le> card (set (map fst (z_w # zs_ws)))", "using Cons.prems(2) distinct_card"], ["proof (prove)\nusing this:\n  distinct (map fst (z_w # zs_ws))\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. length (z_w # zs_ws) \\<le> card (set (map fst (z_w # zs_ws)))", "by fastforce"], ["proof (state)\nthis:\n  length (z_w # zs_ws) \\<le> card (set (map fst (z_w # zs_ws)))\n\ngoal (1 subgoal):\n 1. \\<And>a zs_ws.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> set (map fst zs_ws) \\<Longrightarrow>\n                            poly (p1 - p2) x = 0;\n                 distinct (map fst zs_ws)\\<rbrakk>\n                \\<Longrightarrow> length zs_ws\n                                  \\<le> card {x. poly (p1 - p2) x = 0};\n        \\<And>x.\n           x \\<in> set (map fst (a # zs_ws)) \\<Longrightarrow>\n           poly (p1 - p2) x = 0;\n        distinct (map fst (a # zs_ws))\\<rbrakk>\n       \\<Longrightarrow> length (a # zs_ws)\n                         \\<le> card {x. poly (p1 - p2) x = 0}", "from this i"], ["proof (chain)\npicking this:\n  length (z_w # zs_ws) \\<le> card (set (map fst (z_w # zs_ws)))\n  card (set (map fst (z_w # zs_ws))) \\<le> card {x. poly (p1 - p2) x = 0}", "show ?case"], ["proof (prove)\nusing this:\n  length (z_w # zs_ws) \\<le> card (set (map fst (z_w # zs_ws)))\n  card (set (map fst (z_w # zs_ws))) \\<le> card {x. poly (p1 - p2) x = 0}\n\ngoal (1 subgoal):\n 1. length (z_w # zs_ws) \\<le> card {x. poly (p1 - p2) x = 0}", "by simp"], ["proof (state)\nthis:\n  length (z_w # zs_ws) \\<le> card {x. poly (p1 - p2) x = 0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length zs_ws \\<le> card {x. poly (p1 - p2) x = 0}\n\ngoal (1 subgoal):\n 1. p1 - p2 \\<noteq> 0 \\<Longrightarrow> p1 = p2", "from 1 2"], ["proof (chain)\npicking this:\n  degree p1 \\<le> length zs_ws - 1 \\<and>\n  (\\<forall>x y. (x, y) \\<in> set zs_ws \\<longrightarrow> poly p1 x = y)\n  degree p2 \\<le> length zs_ws - 1 \\<and>\n  (\\<forall>x y. (x, y) \\<in> set zs_ws \\<longrightarrow> poly p2 x = y)", "have 4: \"degree (p1 - p2) \\<le> (length zs_ws)-1\""], ["proof (prove)\nusing this:\n  degree p1 \\<le> length zs_ws - 1 \\<and>\n  (\\<forall>x y. (x, y) \\<in> set zs_ws \\<longrightarrow> poly p1 x = y)\n  degree p2 \\<le> length zs_ws - 1 \\<and>\n  (\\<forall>x y. (x, y) \\<in> set zs_ws \\<longrightarrow> poly p2 x = y)\n\ngoal (1 subgoal):\n 1. degree (p1 - p2) \\<le> length zs_ws - 1", "using degree_diff_le"], ["proof (prove)\nusing this:\n  degree p1 \\<le> length zs_ws - 1 \\<and>\n  (\\<forall>x y. (x, y) \\<in> set zs_ws \\<longrightarrow> poly p1 x = y)\n  degree p2 \\<le> length zs_ws - 1 \\<and>\n  (\\<forall>x y. (x, y) \\<in> set zs_ws \\<longrightarrow> poly p2 x = y)\n  \\<lbrakk>degree ?p \\<le> ?n; degree ?q \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> degree (?p - ?q) \\<le> ?n\n\ngoal (1 subgoal):\n 1. degree (p1 - p2) \\<le> length zs_ws - 1", "by blast"], ["proof (state)\nthis:\n  degree (p1 - p2) \\<le> length zs_ws - 1\n\ngoal (1 subgoal):\n 1. p1 - p2 \\<noteq> 0 \\<Longrightarrow> p1 = p2", "have \"p1 - p2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 - p2 = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. p1 - p2 \\<noteq> 0 \\<Longrightarrow> False", "assume \"p1 - p2 \\<noteq> 0\""], ["proof (state)\nthis:\n  p1 - p2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p1 - p2 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p1 - p2 \\<noteq> 0", "have \"card {x. poly (p1-p2) x = 0} \\<le> degree (p1-p2)\""], ["proof (prove)\nusing this:\n  p1 - p2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card {x. poly (p1 - p2) x = 0} \\<le> degree (p1 - p2)", "using poly_roots_degree"], ["proof (prove)\nusing this:\n  p1 - p2 \\<noteq> 0\n  ?p \\<noteq> 0 \\<Longrightarrow>\n  card {x. poly ?p x = (0::?'a)} \\<le> degree ?p\n\ngoal (1 subgoal):\n 1. card {x. poly (p1 - p2) x = 0} \\<le> degree (p1 - p2)", "by blast"], ["proof (state)\nthis:\n  card {x. poly (p1 - p2) x = 0} \\<le> degree (p1 - p2)\n\ngoal (1 subgoal):\n 1. p1 - p2 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  card {x. poly (p1 - p2) x = 0} \\<le> degree (p1 - p2)", "have \"card {x. poly (p1-p2) x = 0} \\<le> (length zs_ws)-1\""], ["proof (prove)\nusing this:\n  card {x. poly (p1 - p2) x = 0} \\<le> degree (p1 - p2)\n\ngoal (1 subgoal):\n 1. card {x. poly (p1 - p2) x = 0} \\<le> length zs_ws - 1", "using 4"], ["proof (prove)\nusing this:\n  card {x. poly (p1 - p2) x = 0} \\<le> degree (p1 - p2)\n  degree (p1 - p2) \\<le> length zs_ws - 1\n\ngoal (1 subgoal):\n 1. card {x. poly (p1 - p2) x = 0} \\<le> length zs_ws - 1", "by auto"], ["proof (state)\nthis:\n  card {x. poly (p1 - p2) x = 0} \\<le> length zs_ws - 1\n\ngoal (1 subgoal):\n 1. p1 - p2 \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  card {x. poly (p1 - p2) x = 0} \\<le> length zs_ws - 1", "show \"False\""], ["proof (prove)\nusing this:\n  card {x. poly (p1 - p2) x = 0} \\<le> length zs_ws - 1\n\ngoal (1 subgoal):\n 1. False", "using 3 o"], ["proof (prove)\nusing this:\n  card {x. poly (p1 - p2) x = 0} \\<le> length zs_ws - 1\n  length zs_ws \\<le> card {x. poly (p1 - p2) x = 0}\n  0 < length zs_ws\n\ngoal (1 subgoal):\n 1. False", "by linarith"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p1 - p2 = 0\n\ngoal (1 subgoal):\n 1. p1 - p2 \\<noteq> 0 \\<Longrightarrow> p1 = p2", "then"], ["proof (chain)\npicking this:\n  p1 - p2 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  p1 - p2 = 0\n\ngoal (1 subgoal):\n 1. p1 = p2", "by simp"], ["proof (state)\nthis:\n  p1 = p2\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 8.2\\<close>"], ["", "corollary lagrange:\n  assumes \"length zs_ws > 0\" \"distinct (map fst zs_ws)\"\n  shows \"(\\<exists>! (p :: complex poly).\n              degree p \\<le> length zs_ws - 1 \\<and>\n              (\\<forall>x y. (x, y) \\<in> set zs_ws \\<longrightarrow> poly p x = y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!p.\n       degree p \\<le> length zs_ws - 1 \\<and>\n       (\\<forall>x y. (x, y) \\<in> set zs_ws \\<longrightarrow> poly p x = y)", "using assms lagrange_exists lagrange_unique"], ["proof (prove)\nusing this:\n  0 < length zs_ws\n  distinct (map fst zs_ws)\n  distinct (map fst ?zs_ws) \\<Longrightarrow>\n  degree (lagrange_interpolation_poly ?zs_ws) \\<le> length ?zs_ws - 1\n  distinct (map fst ?zs_ws) \\<Longrightarrow>\n  \\<forall>x y.\n     (x, y) \\<in> set ?zs_ws \\<longrightarrow>\n     poly (lagrange_interpolation_poly ?zs_ws) x = y\n  \\<lbrakk>0 < length ?zs_ws; distinct (map fst ?zs_ws);\n   degree ?p1.0 \\<le> length ?zs_ws - 1 \\<and>\n   (\\<forall>x y.\n       (x, y) \\<in> set ?zs_ws \\<longrightarrow> poly ?p1.0 x = y);\n   degree ?p2.0 \\<le> length ?zs_ws - 1 \\<and>\n   (\\<forall>x y.\n       (x, y) \\<in> set ?zs_ws \\<longrightarrow> poly ?p2.0 x = y)\\<rbrakk>\n  \\<Longrightarrow> ?p1.0 = ?p2.0\n\ngoal (1 subgoal):\n 1. \\<exists>!p.\n       degree p \\<le> length zs_ws - 1 \\<and>\n       (\\<forall>x y. (x, y) \\<in> set zs_ws \\<longrightarrow> poly p x = y)", "by blast"], ["", "lemma poly_altdef':\n assumes gr: \"k \\<ge> degree p\"  \n shows \"poly p (z::complex) = (\\<Sum>i\\<le>k. coeff p i * z ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p z = (\\<Sum>i\\<le>k. coeff p i * z ^ i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly p z = (\\<Sum>i\\<le>k. coeff p i * z ^ i)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. poly p z = (\\<Sum>i\\<le>k. coeff p i * z ^ i)", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. poly p z = (\\<Sum>i\\<le>k. coeff p i * z ^ i)", "have 1: \"poly p z = (\\<Sum>i\\<le>degree p. coeff p i * z ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p z = (\\<Sum>i\\<le>degree p. coeff p i * z ^ i)", "using poly_altdef[of p z]"], ["proof (prove)\nusing this:\n  poly p z = (\\<Sum>i\\<le>degree p. coeff p i * z ^ i)\n\ngoal (1 subgoal):\n 1. poly p z = (\\<Sum>i\\<le>degree p. coeff p i * z ^ i)", "by simp"], ["proof (state)\nthis:\n  poly p z = (\\<Sum>i\\<le>degree p. coeff p i * z ^ i)\n\ngoal (1 subgoal):\n 1. poly p z = (\\<Sum>i\\<le>k. coeff p i * z ^ i)", "have \"poly p z = (\\<Sum>i\\<le>k. coeff p i * z ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p z = (\\<Sum>i\\<le>k. coeff p i * z ^ i)", "using gr"], ["proof (prove)\nusing this:\n  degree p \\<le> k\n\ngoal (1 subgoal):\n 1. poly p z = (\\<Sum>i\\<le>k. coeff p i * z ^ i)", "proof (induction k)"], ["proof (state)\ngoal (2 subgoals):\n 1. degree p \\<le> 0 \\<Longrightarrow>\n    poly p z = (\\<Sum>i\\<le>0. coeff p i * z ^ i)\n 2. \\<And>k.\n       \\<lbrakk>degree p \\<le> k \\<Longrightarrow>\n                poly p z = (\\<Sum>i\\<le>k. coeff p i * z ^ i);\n        degree p \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> poly p z = (\\<Sum>i\\<le>Suc k. coeff p i * z ^ i)", "case 0"], ["proof (state)\nthis:\n  degree p \\<le> 0\n\ngoal (2 subgoals):\n 1. degree p \\<le> 0 \\<Longrightarrow>\n    poly p z = (\\<Sum>i\\<le>0. coeff p i * z ^ i)\n 2. \\<And>k.\n       \\<lbrakk>degree p \\<le> k \\<Longrightarrow>\n                poly p z = (\\<Sum>i\\<le>k. coeff p i * z ^ i);\n        degree p \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> poly p z = (\\<Sum>i\\<le>Suc k. coeff p i * z ^ i)", "then"], ["proof (chain)\npicking this:\n  degree p \\<le> 0", "show ?case"], ["proof (prove)\nusing this:\n  degree p \\<le> 0\n\ngoal (1 subgoal):\n 1. poly p z = (\\<Sum>i\\<le>0. coeff p i * z ^ i)", "by (simp add: poly_altdef)"], ["proof (state)\nthis:\n  poly p z = (\\<Sum>i\\<le>0. coeff p i * z ^ i)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>degree p \\<le> k \\<Longrightarrow>\n                poly p z = (\\<Sum>i\\<le>k. coeff p i * z ^ i);\n        degree p \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> poly p z = (\\<Sum>i\\<le>Suc k. coeff p i * z ^ i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>degree p \\<le> k \\<Longrightarrow>\n                poly p z = (\\<Sum>i\\<le>k. coeff p i * z ^ i);\n        degree p \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> poly p z = (\\<Sum>i\\<le>Suc k. coeff p i * z ^ i)", "case (Suc k)"], ["proof (state)\nthis:\n  degree p \\<le> k \\<Longrightarrow>\n  poly p z = (\\<Sum>i\\<le>k. coeff p i * z ^ i)\n  degree p \\<le> Suc k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>degree p \\<le> k \\<Longrightarrow>\n                poly p z = (\\<Sum>i\\<le>k. coeff p i * z ^ i);\n        degree p \\<le> Suc k\\<rbrakk>\n       \\<Longrightarrow> poly p z = (\\<Sum>i\\<le>Suc k. coeff p i * z ^ i)", "then"], ["proof (chain)\npicking this:\n  degree p \\<le> k \\<Longrightarrow>\n  poly p z = (\\<Sum>i\\<le>k. coeff p i * z ^ i)\n  degree p \\<le> Suc k", "show ?case"], ["proof (prove)\nusing this:\n  degree p \\<le> k \\<Longrightarrow>\n  poly p z = (\\<Sum>i\\<le>k. coeff p i * z ^ i)\n  degree p \\<le> Suc k\n\ngoal (1 subgoal):\n 1. poly p z = (\\<Sum>i\\<le>Suc k. coeff p i * z ^ i)", "using \"1\" le_degree not_less_eq_eq"], ["proof (prove)\nusing this:\n  degree p \\<le> k \\<Longrightarrow>\n  poly p z = (\\<Sum>i\\<le>k. coeff p i * z ^ i)\n  degree p \\<le> Suc k\n  poly p z = (\\<Sum>i\\<le>degree p. coeff p i * z ^ i)\n  coeff ?p ?n \\<noteq> (0::?'a) \\<Longrightarrow> ?n \\<le> degree ?p\n  (\\<not> ?m \\<le> ?n) = (Suc ?n \\<le> ?m)\n\ngoal (1 subgoal):\n 1. poly p z = (\\<Sum>i\\<le>Suc k. coeff p i * z ^ i)", "by fastforce"], ["proof (state)\nthis:\n  poly p z = (\\<Sum>i\\<le>Suc k. coeff p i * z ^ i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  poly p z = (\\<Sum>i\\<le>k. coeff p i * z ^ i)\n\ngoal (1 subgoal):\n 1. poly p z = (\\<Sum>i\\<le>k. coeff p i * z ^ i)", "}"], ["proof (state)\nthis:\n  poly p ?za2 = (\\<Sum>i\\<le>k. coeff p i * ?za2 ^ i)\n\ngoal (1 subgoal):\n 1. poly p z = (\\<Sum>i\\<le>k. coeff p i * z ^ i)", "then"], ["proof (chain)\npicking this:\n  poly p ?za2 = (\\<Sum>i\\<le>k. coeff p i * ?za2 ^ i)", "show ?thesis"], ["proof (prove)\nusing this:\n  poly p ?za2 = (\\<Sum>i\\<le>k. coeff p i * ?za2 ^ i)\n\ngoal (1 subgoal):\n 1. poly p z = (\\<Sum>i\\<le>k. coeff p i * z ^ i)", "using gr"], ["proof (prove)\nusing this:\n  poly p ?za2 = (\\<Sum>i\\<le>k. coeff p i * ?za2 ^ i)\n  degree p \\<le> k\n\ngoal (1 subgoal):\n 1. poly p z = (\\<Sum>i\\<le>k. coeff p i * z ^ i)", "by blast"], ["proof (state)\nthis:\n  poly p z = (\\<Sum>i\\<le>k. coeff p i * z ^ i)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Definition and uniqueness\\<close>"], ["", "definition finite_fourier_poly :: \"complex list \\<Rightarrow> complex poly\" where\n  \"finite_fourier_poly ws =\n    (let k = length ws\n      in  poly_of_list [1 / k * (\\<Sum>m<k. ws ! m * unity_root k (-n*m)). n \\<leftarrow> [0..<k]])\""], ["", "lemma degree_poly_of_list_le: \"degree (poly_of_list ws) \\<le> length ws - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (poly_of_list ws) \\<le> length ws - 1", "by (intro degree_le) (auto simp: nth_default_def)"], ["", "lemma degree_finite_fourier_poly: \"degree (finite_fourier_poly ws) \\<le> length ws - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (finite_fourier_poly ws) \\<le> length ws - 1", "unfolding finite_fourier_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     (let k = length ws\n      in poly_of_list\n          (map (\\<lambda>n.\n                   complex_of_real (1 / real k) *\n                   (\\<Sum>m<k. ws ! m * unity_root k (- int n * int m)))\n            [0..<k]))\n    \\<le> length ws - 1", "proof (subst Let_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. degree\n     (poly_of_list\n       (map (\\<lambda>n.\n                complex_of_real (1 / real (length ws)) *\n                (\\<Sum>m<length ws.\n                    ws ! m * unity_root (length ws) (- int n * int m)))\n         [0..<length ws]))\n    \\<le> length ws - 1", "let ?unrolled_list = \"\n       (map (\\<lambda>n. complex_of_real (1 / real (length ws)) *\n                  (\\<Sum>m<length ws.\n                      ws ! m *\n                      unity_root (length ws) (- int n * int m)))\n         [0..<length ws])\""], ["proof (state)\ngoal (1 subgoal):\n 1. degree\n     (poly_of_list\n       (map (\\<lambda>n.\n                complex_of_real (1 / real (length ws)) *\n                (\\<Sum>m<length ws.\n                    ws ! m * unity_root (length ws) (- int n * int m)))\n         [0..<length ws]))\n    \\<le> length ws - 1", "have \"degree (poly_of_list ?unrolled_list) \\<le> length ?unrolled_list - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree\n     (poly_of_list\n       (map (\\<lambda>n.\n                complex_of_real (1 / real (length ws)) *\n                (\\<Sum>m<length ws.\n                    ws ! m * unity_root (length ws) (- int n * int m)))\n         [0..<length ws]))\n    \\<le> length\n           (map (\\<lambda>n.\n                    complex_of_real (1 / real (length ws)) *\n                    (\\<Sum>m<length ws.\n                        ws ! m * unity_root (length ws) (- int n * int m)))\n             [0..<length ws]) -\n          1", "by (rule degree_poly_of_list_le)"], ["proof (state)\nthis:\n  degree\n   (poly_of_list\n     (map (\\<lambda>n.\n              complex_of_real (1 / real (length ws)) *\n              (\\<Sum>m<length ws.\n                  ws ! m * unity_root (length ws) (- int n * int m)))\n       [0..<length ws]))\n  \\<le> length\n         (map (\\<lambda>n.\n                  complex_of_real (1 / real (length ws)) *\n                  (\\<Sum>m<length ws.\n                      ws ! m * unity_root (length ws) (- int n * int m)))\n           [0..<length ws]) -\n        1\n\ngoal (1 subgoal):\n 1. degree\n     (poly_of_list\n       (map (\\<lambda>n.\n                complex_of_real (1 / real (length ws)) *\n                (\\<Sum>m<length ws.\n                    ws ! m * unity_root (length ws) (- int n * int m)))\n         [0..<length ws]))\n    \\<le> length ws - 1", "also"], ["proof (state)\nthis:\n  degree\n   (poly_of_list\n     (map (\\<lambda>n.\n              complex_of_real (1 / real (length ws)) *\n              (\\<Sum>m<length ws.\n                  ws ! m * unity_root (length ws) (- int n * int m)))\n       [0..<length ws]))\n  \\<le> length\n         (map (\\<lambda>n.\n                  complex_of_real (1 / real (length ws)) *\n                  (\\<Sum>m<length ws.\n                      ws ! m * unity_root (length ws) (- int n * int m)))\n           [0..<length ws]) -\n        1\n\ngoal (1 subgoal):\n 1. degree\n     (poly_of_list\n       (map (\\<lambda>n.\n                complex_of_real (1 / real (length ws)) *\n                (\\<Sum>m<length ws.\n                    ws ! m * unity_root (length ws) (- int n * int m)))\n         [0..<length ws]))\n    \\<le> length ws - 1", "have \"\\<dots> = length [0..<length ws] - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map (\\<lambda>n.\n              complex_of_real (1 / real (length ws)) *\n              (\\<Sum>m<length ws.\n                  ws ! m * unity_root (length ws) (- int n * int m)))\n       [0..<length ws]) -\n    1 =\n    length [0..<length ws] - 1", "using length_map"], ["proof (prove)\nusing this:\n  length (map ?f ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. length\n     (map (\\<lambda>n.\n              complex_of_real (1 / real (length ws)) *\n              (\\<Sum>m<length ws.\n                  ws ! m * unity_root (length ws) (- int n * int m)))\n       [0..<length ws]) -\n    1 =\n    length [0..<length ws] - 1", "by auto"], ["proof (state)\nthis:\n  length\n   (map (\\<lambda>n.\n            complex_of_real (1 / real (length ws)) *\n            (\\<Sum>m<length ws.\n                ws ! m * unity_root (length ws) (- int n * int m)))\n     [0..<length ws]) -\n  1 =\n  length [0..<length ws] - 1\n\ngoal (1 subgoal):\n 1. degree\n     (poly_of_list\n       (map (\\<lambda>n.\n                complex_of_real (1 / real (length ws)) *\n                (\\<Sum>m<length ws.\n                    ws ! m * unity_root (length ws) (- int n * int m)))\n         [0..<length ws]))\n    \\<le> length ws - 1", "also"], ["proof (state)\nthis:\n  length\n   (map (\\<lambda>n.\n            complex_of_real (1 / real (length ws)) *\n            (\\<Sum>m<length ws.\n                ws ! m * unity_root (length ws) (- int n * int m)))\n     [0..<length ws]) -\n  1 =\n  length [0..<length ws] - 1\n\ngoal (1 subgoal):\n 1. degree\n     (poly_of_list\n       (map (\\<lambda>n.\n                complex_of_real (1 / real (length ws)) *\n                (\\<Sum>m<length ws.\n                    ws ! m * unity_root (length ws) (- int n * int m)))\n         [0..<length ws]))\n    \\<le> length ws - 1", "have \"\\<dots> = length ws - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length [0..<length ws] - 1 = length ws - 1", "by auto"], ["proof (state)\nthis:\n  length [0..<length ws] - 1 = length ws - 1\n\ngoal (1 subgoal):\n 1. degree\n     (poly_of_list\n       (map (\\<lambda>n.\n                complex_of_real (1 / real (length ws)) *\n                (\\<Sum>m<length ws.\n                    ws ! m * unity_root (length ws) (- int n * int m)))\n         [0..<length ws]))\n    \\<le> length ws - 1", "finally"], ["proof (chain)\npicking this:\n  degree\n   (poly_of_list\n     (map (\\<lambda>n.\n              complex_of_real (1 / real (length ws)) *\n              (\\<Sum>m<length ws.\n                  ws ! m * unity_root (length ws) (- int n * int m)))\n       [0..<length ws]))\n  \\<le> length ws - 1", "show \"degree (poly_of_list ?unrolled_list) \\<le> length ws - 1\""], ["proof (prove)\nusing this:\n  degree\n   (poly_of_list\n     (map (\\<lambda>n.\n              complex_of_real (1 / real (length ws)) *\n              (\\<Sum>m<length ws.\n                  ws ! m * unity_root (length ws) (- int n * int m)))\n       [0..<length ws]))\n  \\<le> length ws - 1\n\ngoal (1 subgoal):\n 1. degree\n     (poly_of_list\n       (map (\\<lambda>n.\n                complex_of_real (1 / real (length ws)) *\n                (\\<Sum>m<length ws.\n                    ws ! m * unity_root (length ws) (- int n * int m)))\n         [0..<length ws]))\n    \\<le> length ws - 1", "by blast"], ["proof (state)\nthis:\n  degree\n   (poly_of_list\n     (map (\\<lambda>n.\n              complex_of_real (1 / real (length ws)) *\n              (\\<Sum>m<length ws.\n                  ws ! m * unity_root (length ws) (- int n * int m)))\n       [0..<length ws]))\n  \\<le> length ws - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coeff_finite_fourier_poly:\n  assumes \"n < length ws\"\n  defines \"k \\<equiv> length ws\"\n  shows \"coeff (finite_fourier_poly ws) n = \n         (1/k) * (\\<Sum>m < k. ws ! m * unity_root k (-n*m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (finite_fourier_poly ws) n =\n    1 / of_nat k * (\\<Sum>m<k. ws ! m * unity_root k (- int n * int m))", "using assms degree_finite_fourier_poly"], ["proof (prove)\nusing this:\n  n < length ws\n  k \\<equiv> length ws\n  degree (finite_fourier_poly ?ws) \\<le> length ?ws - 1\n\ngoal (1 subgoal):\n 1. coeff (finite_fourier_poly ws) n =\n    1 / of_nat k * (\\<Sum>m<k. ws ! m * unity_root k (- int n * int m))", "by (auto simp: Let_def nth_default_def finite_fourier_poly_def)"], ["", "lemma poly_finite_fourier_poly:\n  fixes m :: int and ws\n  defines \"k \\<equiv> length ws\"\n  assumes \"m \\<in> {0..<k}\"\n  assumes \"m < length ws\"\n  shows \"poly (finite_fourier_poly ws) (unity_root k m) = ws ! (nat m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "have \"k > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k", "using assms"], ["proof (prove)\nusing this:\n  k \\<equiv> length ws\n  m \\<in> {0..<int k}\n  m < int (length ws)\n\ngoal (1 subgoal):\n 1. 0 < k", "by auto"], ["proof (state)\nthis:\n  0 < k\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "have distr: \"\n   (\\<Sum>j<length ws. ws ! j * unity_root k (-i*j))*(unity_root k (m*i)) = \n   (\\<Sum>j<length ws. ws ! j * unity_root k (-i*j)*(unity_root k (m*i)))\"\n   for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<length ws. ws ! j * unity_root k (- i * int j)) *\n    unity_root k (m * i) =\n    (\\<Sum>j<length ws.\n        ws ! j * unity_root k (- i * int j) * unity_root k (m * i))", "using sum_distrib_right[of \"\\<lambda>j. ws ! j * unity_root k (-i*j)\" \n                            \"{..<k}\" \"(unity_root k (m*i))\"]"], ["proof (prove)\nusing this:\n  (\\<Sum>j<k. ws ! j * unity_root k (- i * int j)) * unity_root k (m * i) =\n  (\\<Sum>n<k. ws ! n * unity_root k (- i * int n) * unity_root k (m * i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<length ws. ws ! j * unity_root k (- i * int j)) *\n    unity_root k (m * i) =\n    (\\<Sum>j<length ws.\n        ws ! j * unity_root k (- i * int j) * unity_root k (m * i))", "using k_def"], ["proof (prove)\nusing this:\n  (\\<Sum>j<k. ws ! j * unity_root k (- i * int j)) * unity_root k (m * i) =\n  (\\<Sum>n<k. ws ! n * unity_root k (- i * int n) * unity_root k (m * i))\n  k \\<equiv> length ws\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<length ws. ws ! j * unity_root k (- i * int j)) *\n    unity_root k (m * i) =\n    (\\<Sum>j<length ws.\n        ws ! j * unity_root k (- i * int j) * unity_root k (m * i))", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>j<length ws. ws ! j * unity_root k (- ?i * int j)) *\n  unity_root k (m * ?i) =\n  (\\<Sum>j<length ws.\n      ws ! j * unity_root k (- ?i * int j) * unity_root k (m * ?i))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "{"], ["proof (state)\nthis:\n  (\\<Sum>j<length ws. ws ! j * unity_root k (- ?i * int j)) *\n  unity_root k (m * ?i) =\n  (\\<Sum>j<length ws.\n      ws ! j * unity_root k (- ?i * int j) * unity_root k (m * ?i))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "fix j i :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "have \"unity_root k (-i*j)*(unity_root k (m*i)) = unity_root k (-i*j+m*i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k (- int i * int j) * unity_root k (m * int i) =\n    unity_root k (- int i * int j + m * int i)", "by (simp add: unity_root_diff unity_root_uminus field_simps)"], ["proof (state)\nthis:\n  unity_root k (- int i * int j) * unity_root k (m * int i) =\n  unity_root k (- int i * int j + m * int i)\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "also"], ["proof (state)\nthis:\n  unity_root k (- int i * int j) * unity_root k (m * int i) =\n  unity_root k (- int i * int j + m * int i)\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "have \"\\<dots> = unity_root k (i*(m-j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k (- int i * int j + m * int i) =\n    unity_root k (int i * (m - int j))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  unity_root k (- int i * int j + m * int i) =\n  unity_root k (int i * (m - int j))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "finally"], ["proof (chain)\npicking this:\n  unity_root k (- int i * int j) * unity_root k (m * int i) =\n  unity_root k (int i * (m - int j))", "have \"unity_root k (-i*j)*(unity_root k (m*i)) = unity_root k (i*(m-j))\""], ["proof (prove)\nusing this:\n  unity_root k (- int i * int j) * unity_root k (m * int i) =\n  unity_root k (int i * (m - int j))\n\ngoal (1 subgoal):\n 1. unity_root k (- int i * int j) * unity_root k (m * int i) =\n    unity_root k (int i * (m - int j))", "by simp"], ["proof (state)\nthis:\n  unity_root k (- int i * int j) * unity_root k (m * int i) =\n  unity_root k (int i * (m - int j))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "then"], ["proof (chain)\npicking this:\n  unity_root k (- int i * int j) * unity_root k (m * int i) =\n  unity_root k (int i * (m - int j))", "have \"ws ! j * unity_root k (-i*j)*(unity_root k (m*i)) = \n              ws ! j * unity_root k (i*(m-j))\""], ["proof (prove)\nusing this:\n  unity_root k (- int i * int j) * unity_root k (m * int i) =\n  unity_root k (int i * (m - int j))\n\ngoal (1 subgoal):\n 1. ws ! j * unity_root k (- int i * int j) * unity_root k (m * int i) =\n    ws ! j * unity_root k (int i * (m - int j))", "by auto"], ["proof (state)\nthis:\n  ws ! j * unity_root k (- int i * int j) * unity_root k (m * int i) =\n  ws ! j * unity_root k (int i * (m - int j))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "}"], ["proof (state)\nthis:\n  ws ! ?j2 * unity_root k (- int ?i2 * int ?j2) *\n  unity_root k (m * int ?i2) =\n  ws ! ?j2 * unity_root k (int ?i2 * (m - int ?j2))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "note prod = this"], ["proof (state)\nthis:\n  ws ! ?j2 * unity_root k (- int ?i2 * int ?j2) *\n  unity_root k (m * int ?i2) =\n  ws ! ?j2 * unity_root k (int ?i2 * (m - int ?j2))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "have zeros: \n   \"(unity_root_sum k (m-j) \\<noteq> 0 \\<longleftrightarrow> m = j)\n     \" if \"j \\<ge> 0 \\<and> j < k\"  for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. (unity_root_sum k (m - int j) \\<noteq> 0) = (m = int j)", "using k_def that assms unity_root_sum_nonzero_iff[of _ \"m-j\"]"], ["proof (prove)\nusing this:\n  k \\<equiv> length ws\n  0 \\<le> j \\<and> j < k\n  k \\<equiv> length ws\n  m \\<in> {0..<int k}\n  m < int (length ws)\n  \\<lbrakk>1 \\<le> ?k; m - int j \\<in> {- int ?k<..<int ?k}\\<rbrakk>\n  \\<Longrightarrow> (unity_root_sum ?k (m - int j) \\<noteq> 0) =\n                    (m - int j = 0)\n\ngoal (1 subgoal):\n 1. (unity_root_sum k (m - int j) \\<noteq> 0) = (m = int j)", "by simp"], ["proof (state)\nthis:\n  0 \\<le> ?j \\<and> ?j < k \\<Longrightarrow>\n  (unity_root_sum k (m - int ?j) \\<noteq> 0) = (m = int ?j)\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "then"], ["proof (chain)\npicking this:\n  0 \\<le> ?j \\<and> ?j < k \\<Longrightarrow>\n  (unity_root_sum k (m - int ?j) \\<noteq> 0) = (m = int ?j)", "have sum_eq:\n    \"(\\<Sum>j\\<le>k-1. ws ! j * unity_root_sum k (m-j)) = \n          (\\<Sum>j\\<in>{nat m}.  ws ! j * unity_root_sum k (m-j))\""], ["proof (prove)\nusing this:\n  0 \\<le> ?j \\<and> ?j < k \\<Longrightarrow>\n  (unity_root_sum k (m - int ?j) \\<noteq> 0) = (m = int ?j)\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>k - 1. ws ! j * unity_root_sum k (m - int j)) =\n    (\\<Sum>j\\<in>{nat m}. ws ! j * unity_root_sum k (m - int j))", "using assms(2)"], ["proof (prove)\nusing this:\n  0 \\<le> ?j \\<and> ?j < k \\<Longrightarrow>\n  (unity_root_sum k (m - int ?j) \\<noteq> 0) = (m = int ?j)\n  m \\<in> {0..<int k}\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>k - 1. ws ! j * unity_root_sum k (m - int j)) =\n    (\\<Sum>j\\<in>{nat m}. ws ! j * unity_root_sum k (m - int j))", "by (intro sum.mono_neutral_right,auto)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>k - 1. ws ! j * unity_root_sum k (m - int j)) =\n  (\\<Sum>j\\<in>{nat m}. ws ! j * unity_root_sum k (m - int j))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "have \"poly (finite_fourier_poly ws) (unity_root k m) = \n        (\\<Sum>i\\<le>k-1. coeff (finite_fourier_poly ws) i * (unity_root k m) ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) =\n    (\\<Sum>i\\<le>k - 1.\n        coeff (finite_fourier_poly ws) i * unity_root k m ^ i)", "using degree_finite_fourier_poly[of ws] k_def\n          poly_altdef'[of \"finite_fourier_poly ws\" \"k-1\" \"unity_root k m\"]"], ["proof (prove)\nusing this:\n  degree (finite_fourier_poly ws) \\<le> length ws - 1\n  k \\<equiv> length ws\n  degree (finite_fourier_poly ws) \\<le> k - 1 \\<Longrightarrow>\n  poly (finite_fourier_poly ws) (unity_root k m) =\n  (\\<Sum>i\\<le>k - 1. coeff (finite_fourier_poly ws) i * unity_root k m ^ i)\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) =\n    (\\<Sum>i\\<le>k - 1.\n        coeff (finite_fourier_poly ws) i * unity_root k m ^ i)", "by blast"], ["proof (state)\nthis:\n  poly (finite_fourier_poly ws) (unity_root k m) =\n  (\\<Sum>i\\<le>k - 1. coeff (finite_fourier_poly ws) i * unity_root k m ^ i)\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "also"], ["proof (state)\nthis:\n  poly (finite_fourier_poly ws) (unity_root k m) =\n  (\\<Sum>i\\<le>k - 1. coeff (finite_fourier_poly ws) i * unity_root k m ^ i)\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "have \"\\<dots> = (\\<Sum>i<k. coeff (finite_fourier_poly ws) i * (unity_root k m) ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>k - 1.\n        coeff (finite_fourier_poly ws) i * unity_root k m ^ i) =\n    (\\<Sum>i<k. coeff (finite_fourier_poly ws) i * unity_root k m ^ i)", "using assms(2)"], ["proof (prove)\nusing this:\n  m \\<in> {0..<int k}\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>k - 1.\n        coeff (finite_fourier_poly ws) i * unity_root k m ^ i) =\n    (\\<Sum>i<k. coeff (finite_fourier_poly ws) i * unity_root k m ^ i)", "by (intro sum.cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>k - 1.\n      coeff (finite_fourier_poly ws) i * unity_root k m ^ i) =\n  (\\<Sum>i<k. coeff (finite_fourier_poly ws) i * unity_root k m ^ i)\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>k - 1.\n      coeff (finite_fourier_poly ws) i * unity_root k m ^ i) =\n  (\\<Sum>i<k. coeff (finite_fourier_poly ws) i * unity_root k m ^ i)\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "have \"\\<dots> = (\\<Sum>i<k. 1 / k *\n    (\\<Sum>j<k. ws ! j * unity_root k (-i*j)) * (unity_root k m) ^ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<k. coeff (finite_fourier_poly ws) i * unity_root k m ^ i) =\n    (\\<Sum>i<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>j<k. ws ! j * unity_root k (- int i * int j)) *\n        unity_root k m ^ i)", "using coeff_finite_fourier_poly[of _ ws] k_def"], ["proof (prove)\nusing this:\n  ?n < length ws \\<Longrightarrow>\n  coeff (finite_fourier_poly ws) ?n =\n  1 / of_nat (length ws) *\n  (\\<Sum>m<length ws. ws ! m * unity_root (length ws) (- int ?n * int m))\n  k \\<equiv> length ws\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<k. coeff (finite_fourier_poly ws) i * unity_root k m ^ i) =\n    (\\<Sum>i<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>j<k. ws ! j * unity_root k (- int i * int j)) *\n        unity_root k m ^ i)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<k. coeff (finite_fourier_poly ws) i * unity_root k m ^ i) =\n  (\\<Sum>i<k.\n      complex_of_real (1 / real k) *\n      (\\<Sum>j<k. ws ! j * unity_root k (- int i * int j)) *\n      unity_root k m ^ i)\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<k. coeff (finite_fourier_poly ws) i * unity_root k m ^ i) =\n  (\\<Sum>i<k.\n      complex_of_real (1 / real k) *\n      (\\<Sum>j<k. ws ! j * unity_root k (- int i * int j)) *\n      unity_root k m ^ i)\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "have \"\\<dots> = (\\<Sum>i<k. 1 / k *\n    (\\<Sum>j<k. ws ! j * unity_root k (-i*j))*(unity_root k (m*i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>j<k. ws ! j * unity_root k (- int i * int j)) *\n        unity_root k m ^ i) =\n    (\\<Sum>i<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>j<k. ws ! j * unity_root k (- int i * int j)) *\n        unity_root k (m * int i))", "using unity_root_pow"], ["proof (prove)\nusing this:\n  unity_root ?k ?n ^ ?m = unity_root ?k (?n * int ?m)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>j<k. ws ! j * unity_root k (- int i * int j)) *\n        unity_root k m ^ i) =\n    (\\<Sum>i<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>j<k. ws ! j * unity_root k (- int i * int j)) *\n        unity_root k (m * int i))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<k.\n      complex_of_real (1 / real k) *\n      (\\<Sum>j<k. ws ! j * unity_root k (- int i * int j)) *\n      unity_root k m ^ i) =\n  (\\<Sum>i<k.\n      complex_of_real (1 / real k) *\n      (\\<Sum>j<k. ws ! j * unity_root k (- int i * int j)) *\n      unity_root k (m * int i))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<k.\n      complex_of_real (1 / real k) *\n      (\\<Sum>j<k. ws ! j * unity_root k (- int i * int j)) *\n      unity_root k m ^ i) =\n  (\\<Sum>i<k.\n      complex_of_real (1 / real k) *\n      (\\<Sum>j<k. ws ! j * unity_root k (- int i * int j)) *\n      unity_root k (m * int i))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "have \"\\<dots> = (\\<Sum>i<k. 1 / k *\n    (\\<Sum>j<k. ws ! j * unity_root k (-i*j)*(unity_root k (m*i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>j<k. ws ! j * unity_root k (- int i * int j)) *\n        unity_root k (m * int i)) =\n    (\\<Sum>i<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>j<k.\n            ws ! j * unity_root k (- int i * int j) *\n            unity_root k (m * int i)))", "using distr k_def"], ["proof (prove)\nusing this:\n  (\\<Sum>j<length ws. ws ! j * unity_root k (- ?i * int j)) *\n  unity_root k (m * ?i) =\n  (\\<Sum>j<length ws.\n      ws ! j * unity_root k (- ?i * int j) * unity_root k (m * ?i))\n  k \\<equiv> length ws\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>j<k. ws ! j * unity_root k (- int i * int j)) *\n        unity_root k (m * int i)) =\n    (\\<Sum>i<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>j<k.\n            ws ! j * unity_root k (- int i * int j) *\n            unity_root k (m * int i)))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i<k.\n      complex_of_real (1 / real k) *\n      (\\<Sum>j<k. ws ! j * unity_root k (- int i * int j)) *\n      unity_root k (m * int i)) =\n  (\\<Sum>i<k.\n      complex_of_real (1 / real k) *\n      (\\<Sum>j<k.\n          ws ! j * unity_root k (- int i * int j) *\n          unity_root k (m * int i)))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<k.\n      complex_of_real (1 / real k) *\n      (\\<Sum>j<k. ws ! j * unity_root k (- int i * int j)) *\n      unity_root k (m * int i)) =\n  (\\<Sum>i<k.\n      complex_of_real (1 / real k) *\n      (\\<Sum>j<k.\n          ws ! j * unity_root k (- int i * int j) *\n          unity_root k (m * int i)))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "have \"\\<dots> = (\\<Sum>i<k. 1 / k * \n    (\\<Sum>j<k. ws ! j * unity_root k (i*(m-j))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>j<k.\n            ws ! j * unity_root k (- int i * int j) *\n            unity_root k (m * int i))) =\n    (\\<Sum>i<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>j<k. ws ! j * unity_root k (int i * (m - int j))))", "using prod"], ["proof (prove)\nusing this:\n  ws ! ?j2 * unity_root k (- int ?i2 * int ?j2) *\n  unity_root k (m * int ?i2) =\n  ws ! ?j2 * unity_root k (int ?i2 * (m - int ?j2))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>j<k.\n            ws ! j * unity_root k (- int i * int j) *\n            unity_root k (m * int i))) =\n    (\\<Sum>i<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>j<k. ws ! j * unity_root k (int i * (m - int j))))", "by presburger"], ["proof (state)\nthis:\n  (\\<Sum>i<k.\n      complex_of_real (1 / real k) *\n      (\\<Sum>j<k.\n          ws ! j * unity_root k (- int i * int j) *\n          unity_root k (m * int i))) =\n  (\\<Sum>i<k.\n      complex_of_real (1 / real k) *\n      (\\<Sum>j<k. ws ! j * unity_root k (int i * (m - int j))))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<k.\n      complex_of_real (1 / real k) *\n      (\\<Sum>j<k.\n          ws ! j * unity_root k (- int i * int j) *\n          unity_root k (m * int i))) =\n  (\\<Sum>i<k.\n      complex_of_real (1 / real k) *\n      (\\<Sum>j<k. ws ! j * unity_root k (int i * (m - int j))))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "have \"\\<dots> = 1 / k * (\\<Sum>i<k.  \n    (\\<Sum>j<k. ws ! j * unity_root k (i*(m-j))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>j<k. ws ! j * unity_root k (int i * (m - int j)))) =\n    complex_of_real (1 / real k) *\n    (\\<Sum>i<k. \\<Sum>j<k. ws ! j * unity_root k (int i * (m - int j)))", "by (simp add: sum_distrib_left)"], ["proof (state)\nthis:\n  (\\<Sum>i<k.\n      complex_of_real (1 / real k) *\n      (\\<Sum>j<k. ws ! j * unity_root k (int i * (m - int j)))) =\n  complex_of_real (1 / real k) *\n  (\\<Sum>i<k. \\<Sum>j<k. ws ! j * unity_root k (int i * (m - int j)))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<k.\n      complex_of_real (1 / real k) *\n      (\\<Sum>j<k. ws ! j * unity_root k (int i * (m - int j)))) =\n  complex_of_real (1 / real k) *\n  (\\<Sum>i<k. \\<Sum>j<k. ws ! j * unity_root k (int i * (m - int j)))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "have \"\\<dots> = 1 / k * (\\<Sum>j<k.  \n    (\\<Sum>i<k. ws ! j * unity_root k (i*(m-j))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (1 / real k) *\n    (\\<Sum>i<k. \\<Sum>j<k. ws ! j * unity_root k (int i * (m - int j))) =\n    complex_of_real (1 / real k) *\n    (\\<Sum>j<k. \\<Sum>i<k. ws ! j * unity_root k (int i * (m - int j)))", "using sum.swap"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>?A. sum (?g i) ?B) = (\\<Sum>j\\<in>?B. \\<Sum>i\\<in>?A. ?g i j)\n\ngoal (1 subgoal):\n 1. complex_of_real (1 / real k) *\n    (\\<Sum>i<k. \\<Sum>j<k. ws ! j * unity_root k (int i * (m - int j))) =\n    complex_of_real (1 / real k) *\n    (\\<Sum>j<k. \\<Sum>i<k. ws ! j * unity_root k (int i * (m - int j)))", "by fastforce"], ["proof (state)\nthis:\n  complex_of_real (1 / real k) *\n  (\\<Sum>i<k. \\<Sum>j<k. ws ! j * unity_root k (int i * (m - int j))) =\n  complex_of_real (1 / real k) *\n  (\\<Sum>j<k. \\<Sum>i<k. ws ! j * unity_root k (int i * (m - int j)))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "also"], ["proof (state)\nthis:\n  complex_of_real (1 / real k) *\n  (\\<Sum>i<k. \\<Sum>j<k. ws ! j * unity_root k (int i * (m - int j))) =\n  complex_of_real (1 / real k) *\n  (\\<Sum>j<k. \\<Sum>i<k. ws ! j * unity_root k (int i * (m - int j)))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "have \"\\<dots> = 1 / k * (\\<Sum>j<k. ws ! j * (\\<Sum>i<k. unity_root k (i*(m-j))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (1 / real k) *\n    (\\<Sum>j<k. \\<Sum>i<k. ws ! j * unity_root k (int i * (m - int j))) =\n    complex_of_real (1 / real k) *\n    (\\<Sum>j<k. ws ! j * (\\<Sum>i<k. unity_root k (int i * (m - int j))))", "by (simp add: vector_space_over_itself.scale_sum_right)"], ["proof (state)\nthis:\n  complex_of_real (1 / real k) *\n  (\\<Sum>j<k. \\<Sum>i<k. ws ! j * unity_root k (int i * (m - int j))) =\n  complex_of_real (1 / real k) *\n  (\\<Sum>j<k. ws ! j * (\\<Sum>i<k. unity_root k (int i * (m - int j))))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "also"], ["proof (state)\nthis:\n  complex_of_real (1 / real k) *\n  (\\<Sum>j<k. \\<Sum>i<k. ws ! j * unity_root k (int i * (m - int j))) =\n  complex_of_real (1 / real k) *\n  (\\<Sum>j<k. ws ! j * (\\<Sum>i<k. unity_root k (int i * (m - int j))))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "have \"\\<dots> = 1 / k * (\\<Sum>j<k. ws ! j * unity_root_sum k (m-j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (1 / real k) *\n    (\\<Sum>j<k. ws ! j * (\\<Sum>i<k. unity_root k (int i * (m - int j)))) =\n    complex_of_real (1 / real k) *\n    (\\<Sum>j<k. ws ! j * unity_root_sum k (m - int j))", "unfolding unity_root_sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (1 / real k) *\n    (\\<Sum>j<k. ws ! j * (\\<Sum>i<k. unity_root k (int i * (m - int j)))) =\n    complex_of_real (1 / real k) *\n    (\\<Sum>j<k. ws ! j * (\\<Sum>ma<k. unity_root k ((m - int j) * int ma)))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  complex_of_real (1 / real k) *\n  (\\<Sum>j<k. ws ! j * (\\<Sum>i<k. unity_root k (int i * (m - int j)))) =\n  complex_of_real (1 / real k) *\n  (\\<Sum>j<k. ws ! j * unity_root_sum k (m - int j))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "also"], ["proof (state)\nthis:\n  complex_of_real (1 / real k) *\n  (\\<Sum>j<k. ws ! j * (\\<Sum>i<k. unity_root k (int i * (m - int j)))) =\n  complex_of_real (1 / real k) *\n  (\\<Sum>j<k. ws ! j * unity_root_sum k (m - int j))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "have \"(\\<Sum>j<k. ws ! j * unity_root_sum k (m-j)) = (\\<Sum>j\\<le>k-1. ws ! j * unity_root_sum k (m-j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<k. ws ! j * unity_root_sum k (m - int j)) =\n    (\\<Sum>j\\<le>k - 1. ws ! j * unity_root_sum k (m - int j))", "using \\<open>k > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < k\n\ngoal (1 subgoal):\n 1. (\\<Sum>j<k. ws ! j * unity_root_sum k (m - int j)) =\n    (\\<Sum>j\\<le>k - 1. ws ! j * unity_root_sum k (m - int j))", "by (intro sum.cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>j<k. ws ! j * unity_root_sum k (m - int j)) =\n  (\\<Sum>j\\<le>k - 1. ws ! j * unity_root_sum k (m - int j))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "also"], ["proof (state)\nthis:\n  (\\<Sum>j<k. ws ! j * unity_root_sum k (m - int j)) =\n  (\\<Sum>j\\<le>k - 1. ws ! j * unity_root_sum k (m - int j))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "have \"\\<dots> = (\\<Sum>j\\<in>{nat m}.  ws ! j * unity_root_sum k (m-j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>k - 1. ws ! j * unity_root_sum k (m - int j)) =\n    (\\<Sum>j\\<in>{nat m}. ws ! j * unity_root_sum k (m - int j))", "using sum_eq"], ["proof (prove)\nusing this:\n  (\\<Sum>j\\<le>k - 1. ws ! j * unity_root_sum k (m - int j)) =\n  (\\<Sum>j\\<in>{nat m}. ws ! j * unity_root_sum k (m - int j))\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<le>k - 1. ws ! j * unity_root_sum k (m - int j)) =\n    (\\<Sum>j\\<in>{nat m}. ws ! j * unity_root_sum k (m - int j))", "."], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>k - 1. ws ! j * unity_root_sum k (m - int j)) =\n  (\\<Sum>j\\<in>{nat m}. ws ! j * unity_root_sum k (m - int j))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<le>k - 1. ws ! j * unity_root_sum k (m - int j)) =\n  (\\<Sum>j\\<in>{nat m}. ws ! j * unity_root_sum k (m - int j))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "have \"\\<dots> = ws ! (nat m) * k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>{nat m}. ws ! j * unity_root_sum k (m - int j)) =\n    ws ! nat m * of_nat k", "using assms(2)"], ["proof (prove)\nusing this:\n  m \\<in> {0..<int k}\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>{nat m}. ws ! j * unity_root_sum k (m - int j)) =\n    ws ! nat m * of_nat k", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{nat m}. ws ! j * unity_root_sum k (m - int j)) =\n  ws ! nat m * of_nat k\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "finally"], ["proof (chain)\npicking this:\n  poly (finite_fourier_poly ws) (unity_root k m) =\n  complex_of_real (1 / real k) * (ws ! nat m * of_nat k)", "have \"poly (finite_fourier_poly ws) (unity_root k m) = ws ! (nat m)\""], ["proof (prove)\nusing this:\n  poly (finite_fourier_poly ws) (unity_root k m) =\n  complex_of_real (1 / real k) * (ws ! nat m * of_nat k)\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "using assms(2)"], ["proof (prove)\nusing this:\n  poly (finite_fourier_poly ws) (unity_root k m) =\n  complex_of_real (1 / real k) * (ws ! nat m * of_nat k)\n  m \\<in> {0..<int k}\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "by auto"], ["proof (state)\nthis:\n  poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "then"], ["proof (chain)\npicking this:\n  poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "show ?thesis"], ["proof (prove)\nusing this:\n  poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m", "by simp"], ["proof (state)\nthis:\n  poly (finite_fourier_poly ws) (unity_root k m) = ws ! nat m\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 8.3\\<close>"], ["", "theorem finite_fourier_poly_unique:\n  assumes \"length ws > 0\"\n  defines \"k \\<equiv> length ws\"\n  assumes \"(degree p \\<le> k - 1)\"\n  assumes \"(\\<forall>m \\<le> k-1. (ws ! m) = poly p (unity_root k m))\"\n  shows \"p = finite_fourier_poly ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = finite_fourier_poly ws", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p = finite_fourier_poly ws", "let ?z = \"map (\\<lambda>m. unity_root k m) [0..<k]\""], ["proof (state)\ngoal (1 subgoal):\n 1. p = finite_fourier_poly ws", "have k: \"k > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k", "using assms"], ["proof (prove)\nusing this:\n  0 < length ws\n  k \\<equiv> length ws\n  degree p \\<le> k - 1\n  \\<forall>m\\<le>k - 1. ws ! m = poly p (unity_root k (int m))\n\ngoal (1 subgoal):\n 1. 0 < k", "by auto"], ["proof (state)\nthis:\n  0 < k\n\ngoal (1 subgoal):\n 1. p = finite_fourier_poly ws", "from k"], ["proof (chain)\npicking this:\n  0 < k", "have d1: \"distinct ?z\""], ["proof (prove)\nusing this:\n  0 < k\n\ngoal (1 subgoal):\n 1. distinct (map (unity_root k) (map int [0..<k]))", "unfolding distinct_conv_nth"], ["proof (prove)\nusing this:\n  0 < k\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (map (unity_root k) (map int [0..<k])).\n       \\<forall>j<length (map (unity_root k) (map int [0..<k])).\n          i \\<noteq> j \\<longrightarrow>\n          map (unity_root k) (map int [0..<k]) ! i \\<noteq>\n          map (unity_root k) (map int [0..<k]) ! j", "using unity_root_eqD[OF k]"], ["proof (prove)\nusing this:\n  0 < k\n  unity_root k ?i = unity_root k ?j \\<Longrightarrow>\n  ?i mod int k = ?j mod int k\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (map (unity_root k) (map int [0..<k])).\n       \\<forall>j<length (map (unity_root k) (map int [0..<k])).\n          i \\<noteq> j \\<longrightarrow>\n          map (unity_root k) (map int [0..<k]) ! i \\<noteq>\n          map (unity_root k) (map int [0..<k]) ! j", "by force"], ["proof (state)\nthis:\n  distinct (map (unity_root k) (map int [0..<k]))\n\ngoal (1 subgoal):\n 1. p = finite_fourier_poly ws", "let ?zs_ws = \"zip ?z ws\""], ["proof (state)\ngoal (1 subgoal):\n 1. p = finite_fourier_poly ws", "from d1 k_def"], ["proof (chain)\npicking this:\n  distinct (map (unity_root k) (map int [0..<k]))\n  k \\<equiv> length ws", "have d2: \"distinct (map fst ?zs_ws)\""], ["proof (prove)\nusing this:\n  distinct (map (unity_root k) (map int [0..<k]))\n  k \\<equiv> length ws\n\ngoal (1 subgoal):\n 1. distinct (map fst (zip (map (unity_root k) (map int [0..<k])) ws))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (zip (map (unity_root k) (map int [0..<k])) ws))\n\ngoal (1 subgoal):\n 1. p = finite_fourier_poly ws", "have l2: \"length ?zs_ws > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (zip (map (unity_root k) (map int [0..<k])) ws)", "using assms(1) k_def"], ["proof (prove)\nusing this:\n  0 < length ws\n  k \\<equiv> length ws\n\ngoal (1 subgoal):\n 1. 0 < length (zip (map (unity_root k) (map int [0..<k])) ws)", "by auto"], ["proof (state)\nthis:\n  0 < length (zip (map (unity_root k) (map int [0..<k])) ws)\n\ngoal (1 subgoal):\n 1. p = finite_fourier_poly ws", "have l3: \"length ?zs_ws = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (zip (map (unity_root k) (map int [0..<k])) ws) = k", "by (simp add: k_def)"], ["proof (state)\nthis:\n  length (zip (map (unity_root k) (map int [0..<k])) ws) = k\n\ngoal (1 subgoal):\n 1. p = finite_fourier_poly ws", "from degree_finite_fourier_poly"], ["proof (chain)\npicking this:\n  degree (finite_fourier_poly ?ws) \\<le> length ?ws - 1", "have degree: \"degree (finite_fourier_poly ws) \\<le> k - 1\""], ["proof (prove)\nusing this:\n  degree (finite_fourier_poly ?ws) \\<le> length ?ws - 1\n\ngoal (1 subgoal):\n 1. degree (finite_fourier_poly ws) \\<le> k - 1", "using k_def"], ["proof (prove)\nusing this:\n  degree (finite_fourier_poly ?ws) \\<le> length ?ws - 1\n  k \\<equiv> length ws\n\ngoal (1 subgoal):\n 1. degree (finite_fourier_poly ws) \\<le> k - 1", "by simp"], ["proof (state)\nthis:\n  degree (finite_fourier_poly ws) \\<le> k - 1\n\ngoal (1 subgoal):\n 1. p = finite_fourier_poly ws", "have interp: \"poly (finite_fourier_poly ws) x = y\"\n    if \"(x, y) \\<in> set ?zs_ws\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) x = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) x = y", "from that"], ["proof (chain)\npicking this:\n  (x, y) \\<in> set (zip (map (unity_root k) (map int [0..<k])) ws)", "obtain n where \"\n         x = map (unity_root k \\<circ> int) [0..<k] ! n \\<and>\n         y = ws ! n \\<and> \n         n < length ws\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> set (zip (map (unity_root k) (map int [0..<k])) ws)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        x = map (unity_root k \\<circ> int) [0..<k] ! n \\<and>\n        y = ws ! n \\<and> n < length ws \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using in_set_zip[of \"(x,y)\" \"(map (unity_root k) (map int [0..<k]))\" ws]"], ["proof (prove)\nusing this:\n  (x, y) \\<in> set (zip (map (unity_root k) (map int [0..<k])) ws)\n  ((x, y) \\<in> set (zip (map (unity_root k) (map int [0..<k])) ws)) =\n  (\\<exists>n.\n      map (unity_root k) (map int [0..<k]) ! n = fst (x, y) \\<and>\n      ws ! n = snd (x, y) \\<and>\n      n < length (map (unity_root k) (map int [0..<k])) \\<and>\n      n < length ws)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        x = map (unity_root k \\<circ> int) [0..<k] ! n \\<and>\n        y = ws ! n \\<and> n < length ws \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = map (unity_root k \\<circ> int) [0..<k] ! n \\<and>\n  y = ws ! n \\<and> n < length ws\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) x = y", "then"], ["proof (chain)\npicking this:\n  x = map (unity_root k \\<circ> int) [0..<k] ! n \\<and>\n  y = ws ! n \\<and> n < length ws", "have \"\n         x = unity_root k (int n) \\<and>\n         y = ws ! n \\<and> \n         n < length ws\""], ["proof (prove)\nusing this:\n  x = map (unity_root k \\<circ> int) [0..<k] ! n \\<and>\n  y = ws ! n \\<and> n < length ws\n\ngoal (1 subgoal):\n 1. x = unity_root k (int n) \\<and> y = ws ! n \\<and> n < length ws", "using nth_map[of n \"[0..<k]\" \"unity_root k \\<circ> int\" ] k_def"], ["proof (prove)\nusing this:\n  x = map (unity_root k \\<circ> int) [0..<k] ! n \\<and>\n  y = ws ! n \\<and> n < length ws\n  n < length [0..<k] \\<Longrightarrow>\n  map (unity_root k \\<circ> int) [0..<k] ! n =\n  (unity_root k \\<circ> int) ([0..<k] ! n)\n  k \\<equiv> length ws\n\ngoal (1 subgoal):\n 1. x = unity_root k (int n) \\<and> y = ws ! n \\<and> n < length ws", "by simp"], ["proof (state)\nthis:\n  x = unity_root k (int n) \\<and> y = ws ! n \\<and> n < length ws\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) x = y", "thus \"poly (finite_fourier_poly ws) x = y\""], ["proof (prove)\nusing this:\n  x = unity_root k (int n) \\<and> y = ws ! n \\<and> n < length ws\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly ws) x = y", "by (simp add: poly_finite_fourier_poly k_def)"], ["proof (state)\nthis:\n  poly (finite_fourier_poly ws) x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?x, ?y)\n  \\<in> set (zip (map (unity_root k) (map int [0..<k]))\n              ws) \\<Longrightarrow>\n  poly (finite_fourier_poly ws) ?x = ?y\n\ngoal (1 subgoal):\n 1. p = finite_fourier_poly ws", "have interp_p: \"poly p x = y\" if \"(x,y) \\<in> set ?zs_ws\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p x = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly p x = y", "from that"], ["proof (chain)\npicking this:\n  (x, y) \\<in> set (zip (map (unity_root k) (map int [0..<k])) ws)", "obtain n where \"\n         x = map (unity_root k \\<circ> int) [0..<k] ! n \\<and>\n         y = ws ! n \\<and> \n         n < length ws\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> set (zip (map (unity_root k) (map int [0..<k])) ws)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        x = map (unity_root k \\<circ> int) [0..<k] ! n \\<and>\n        y = ws ! n \\<and> n < length ws \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using in_set_zip[of \"(x,y)\" \"(map (unity_root k) (map int [0..<k]))\" ws]"], ["proof (prove)\nusing this:\n  (x, y) \\<in> set (zip (map (unity_root k) (map int [0..<k])) ws)\n  ((x, y) \\<in> set (zip (map (unity_root k) (map int [0..<k])) ws)) =\n  (\\<exists>n.\n      map (unity_root k) (map int [0..<k]) ! n = fst (x, y) \\<and>\n      ws ! n = snd (x, y) \\<and>\n      n < length (map (unity_root k) (map int [0..<k])) \\<and>\n      n < length ws)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        x = map (unity_root k \\<circ> int) [0..<k] ! n \\<and>\n        y = ws ! n \\<and> n < length ws \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = map (unity_root k \\<circ> int) [0..<k] ! n \\<and>\n  y = ws ! n \\<and> n < length ws\n\ngoal (1 subgoal):\n 1. poly p x = y", "then"], ["proof (chain)\npicking this:\n  x = map (unity_root k \\<circ> int) [0..<k] ! n \\<and>\n  y = ws ! n \\<and> n < length ws", "have rw: \"x = unity_root k (int n)\" \"y = ws ! n\" \"n < length ws\""], ["proof (prove)\nusing this:\n  x = map (unity_root k \\<circ> int) [0..<k] ! n \\<and>\n  y = ws ! n \\<and> n < length ws\n\ngoal (1 subgoal):\n 1. x = unity_root k (int n) &&& y = ws ! n &&& n < length ws", "using nth_map[of n \"[0..<k]\" \"unity_root k \\<circ> int\" ] k_def"], ["proof (prove)\nusing this:\n  x = map (unity_root k \\<circ> int) [0..<k] ! n \\<and>\n  y = ws ! n \\<and> n < length ws\n  n < length [0..<k] \\<Longrightarrow>\n  map (unity_root k \\<circ> int) [0..<k] ! n =\n  (unity_root k \\<circ> int) ([0..<k] ! n)\n  k \\<equiv> length ws\n\ngoal (1 subgoal):\n 1. x = unity_root k (int n) &&& y = ws ! n &&& n < length ws", "by simp+"], ["proof (state)\nthis:\n  x = unity_root k (int n)\n  y = ws ! n\n  n < length ws\n\ngoal (1 subgoal):\n 1. poly p x = y", "show \"poly p x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p x = y", "unfolding rw(1,2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p (unity_root k (int n)) = ws ! n", "using assms(4) rw(3) k_def"], ["proof (prove)\nusing this:\n  \\<forall>m\\<le>k - 1. ws ! m = poly p (unity_root k (int m))\n  n < length ws\n  k \\<equiv> length ws\n\ngoal (1 subgoal):\n 1. poly p (unity_root k (int n)) = ws ! n", "by simp"], ["proof (state)\nthis:\n  poly p x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?x, ?y)\n  \\<in> set (zip (map (unity_root k) (map int [0..<k]))\n              ws) \\<Longrightarrow>\n  poly p ?x = ?y\n\ngoal (1 subgoal):\n 1. p = finite_fourier_poly ws", "from lagrange_unique[of _ p \"finite_fourier_poly ws\"] d2 l2"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < length ?zs_ws; distinct (map fst ?zs_ws);\n   degree p \\<le> length ?zs_ws - 1 \\<and>\n   (\\<forall>x y. (x, y) \\<in> set ?zs_ws \\<longrightarrow> poly p x = y);\n   degree (finite_fourier_poly ws) \\<le> length ?zs_ws - 1 \\<and>\n   (\\<forall>x y.\n       (x, y) \\<in> set ?zs_ws \\<longrightarrow>\n       poly (finite_fourier_poly ws) x = y)\\<rbrakk>\n  \\<Longrightarrow> p = finite_fourier_poly ws\n  distinct (map fst (zip (map (unity_root k) (map int [0..<k])) ws))\n  0 < length (zip (map (unity_root k) (map int [0..<k])) ws)", "have l: \"\n    degree p \\<le> k - 1 \\<and>\n    (\\<forall>x y. (x, y) \\<in> set ?zs_ws \\<longrightarrow> poly p x = y) \\<Longrightarrow>\n    degree (finite_fourier_poly ws) \\<le> k - 1 \\<and>\n    (\\<forall>x y. (x, y) \\<in> set ?zs_ws \\<longrightarrow> poly (finite_fourier_poly ws) x = y) \\<Longrightarrow>\n    p = (finite_fourier_poly ws)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < length ?zs_ws; distinct (map fst ?zs_ws);\n   degree p \\<le> length ?zs_ws - 1 \\<and>\n   (\\<forall>x y. (x, y) \\<in> set ?zs_ws \\<longrightarrow> poly p x = y);\n   degree (finite_fourier_poly ws) \\<le> length ?zs_ws - 1 \\<and>\n   (\\<forall>x y.\n       (x, y) \\<in> set ?zs_ws \\<longrightarrow>\n       poly (finite_fourier_poly ws) x = y)\\<rbrakk>\n  \\<Longrightarrow> p = finite_fourier_poly ws\n  distinct (map fst (zip (map (unity_root k) (map int [0..<k])) ws))\n  0 < length (zip (map (unity_root k) (map int [0..<k])) ws)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree p \\<le> k - 1 \\<and>\n             (\\<forall>x y.\n                 (x, y)\n                 \\<in> set (zip (map (unity_root k) (map int [0..<k]))\n                             ws) \\<longrightarrow>\n                 poly p x = y);\n     degree (finite_fourier_poly ws) \\<le> k - 1 \\<and>\n     (\\<forall>x y.\n         (x, y)\n         \\<in> set (zip (map (unity_root k) (map int [0..<k]))\n                     ws) \\<longrightarrow>\n         poly (finite_fourier_poly ws) x = y)\\<rbrakk>\n    \\<Longrightarrow> p = finite_fourier_poly ws", "using l3"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < length ?zs_ws; distinct (map fst ?zs_ws);\n   degree p \\<le> length ?zs_ws - 1 \\<and>\n   (\\<forall>x y. (x, y) \\<in> set ?zs_ws \\<longrightarrow> poly p x = y);\n   degree (finite_fourier_poly ws) \\<le> length ?zs_ws - 1 \\<and>\n   (\\<forall>x y.\n       (x, y) \\<in> set ?zs_ws \\<longrightarrow>\n       poly (finite_fourier_poly ws) x = y)\\<rbrakk>\n  \\<Longrightarrow> p = finite_fourier_poly ws\n  distinct (map fst (zip (map (unity_root k) (map int [0..<k])) ws))\n  0 < length (zip (map (unity_root k) (map int [0..<k])) ws)\n  length (zip (map (unity_root k) (map int [0..<k])) ws) = k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>degree p \\<le> k - 1 \\<and>\n             (\\<forall>x y.\n                 (x, y)\n                 \\<in> set (zip (map (unity_root k) (map int [0..<k]))\n                             ws) \\<longrightarrow>\n                 poly p x = y);\n     degree (finite_fourier_poly ws) \\<le> k - 1 \\<and>\n     (\\<forall>x y.\n         (x, y)\n         \\<in> set (zip (map (unity_root k) (map int [0..<k]))\n                     ws) \\<longrightarrow>\n         poly (finite_fourier_poly ws) x = y)\\<rbrakk>\n    \\<Longrightarrow> p = finite_fourier_poly ws", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>degree p \\<le> k - 1 \\<and>\n           (\\<forall>x y.\n               (x, y)\n               \\<in> set (zip (map (unity_root k) (map int [0..<k]))\n                           ws) \\<longrightarrow>\n               poly p x = y);\n   degree (finite_fourier_poly ws) \\<le> k - 1 \\<and>\n   (\\<forall>x y.\n       (x, y)\n       \\<in> set (zip (map (unity_root k) (map int [0..<k]))\n                   ws) \\<longrightarrow>\n       poly (finite_fourier_poly ws) x = y)\\<rbrakk>\n  \\<Longrightarrow> p = finite_fourier_poly ws\n\ngoal (1 subgoal):\n 1. p = finite_fourier_poly ws", "from assms degree interp interp_p l3"], ["proof (chain)\npicking this:\n  0 < length ws\n  k \\<equiv> length ws\n  degree p \\<le> k - 1\n  \\<forall>m\\<le>k - 1. ws ! m = poly p (unity_root k (int m))\n  degree (finite_fourier_poly ws) \\<le> k - 1\n  (?x, ?y)\n  \\<in> set (zip (map (unity_root k) (map int [0..<k]))\n              ws) \\<Longrightarrow>\n  poly (finite_fourier_poly ws) ?x = ?y\n  (?x, ?y)\n  \\<in> set (zip (map (unity_root k) (map int [0..<k]))\n              ws) \\<Longrightarrow>\n  poly p ?x = ?y\n  length (zip (map (unity_root k) (map int [0..<k])) ws) = k", "show \"p = (finite_fourier_poly ws)\""], ["proof (prove)\nusing this:\n  0 < length ws\n  k \\<equiv> length ws\n  degree p \\<le> k - 1\n  \\<forall>m\\<le>k - 1. ws ! m = poly p (unity_root k (int m))\n  degree (finite_fourier_poly ws) \\<le> k - 1\n  (?x, ?y)\n  \\<in> set (zip (map (unity_root k) (map int [0..<k]))\n              ws) \\<Longrightarrow>\n  poly (finite_fourier_poly ws) ?x = ?y\n  (?x, ?y)\n  \\<in> set (zip (map (unity_root k) (map int [0..<k]))\n              ws) \\<Longrightarrow>\n  poly p ?x = ?y\n  length (zip (map (unity_root k) (map int [0..<k])) ws) = k\n\ngoal (1 subgoal):\n 1. p = finite_fourier_poly ws", "using l"], ["proof (prove)\nusing this:\n  0 < length ws\n  k \\<equiv> length ws\n  degree p \\<le> k - 1\n  \\<forall>m\\<le>k - 1. ws ! m = poly p (unity_root k (int m))\n  degree (finite_fourier_poly ws) \\<le> k - 1\n  (?x, ?y)\n  \\<in> set (zip (map (unity_root k) (map int [0..<k]))\n              ws) \\<Longrightarrow>\n  poly (finite_fourier_poly ws) ?x = ?y\n  (?x, ?y)\n  \\<in> set (zip (map (unity_root k) (map int [0..<k]))\n              ws) \\<Longrightarrow>\n  poly p ?x = ?y\n  length (zip (map (unity_root k) (map int [0..<k])) ws) = k\n  \\<lbrakk>degree p \\<le> k - 1 \\<and>\n           (\\<forall>x y.\n               (x, y)\n               \\<in> set (zip (map (unity_root k) (map int [0..<k]))\n                           ws) \\<longrightarrow>\n               poly p x = y);\n   degree (finite_fourier_poly ws) \\<le> k - 1 \\<and>\n   (\\<forall>x y.\n       (x, y)\n       \\<in> set (zip (map (unity_root k) (map int [0..<k]))\n                   ws) \\<longrightarrow>\n       poly (finite_fourier_poly ws) x = y)\\<rbrakk>\n  \\<Longrightarrow> p = finite_fourier_poly ws\n\ngoal (1 subgoal):\n 1. p = finite_fourier_poly ws", "by blast"], ["proof (state)\nthis:\n  p = finite_fourier_poly ws\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The following alternative formulation returns a coefficient\n\\<close>"], ["", "definition finite_fourier_poly' :: \"(nat \\<Rightarrow> complex) \\<Rightarrow> nat \\<Rightarrow> complex poly\" where\n  \"finite_fourier_poly' ws k =\n     (poly_of_list [1 / k * (\\<Sum>m<k. (ws m) * unity_root k (-n*m)). n \\<leftarrow> [0..<k]])\""], ["", "lemma finite_fourier_poly'_conv_finite_fourier_poly:\n  \"finite_fourier_poly' ws k = finite_fourier_poly [ws n. n \\<leftarrow> [0..<k]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_fourier_poly' ws k = finite_fourier_poly (map ws [0..<k])", "unfolding finite_fourier_poly_def finite_fourier_poly'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_of_list\n     (map (\\<lambda>n.\n              1 / of_nat k *\n              (\\<Sum>m<k. ws m * unity_root k (- int n * int m)))\n       [0..<k]) =\n    (let ka = length (map ws [0..<k])\n     in poly_of_list\n         (map (\\<lambda>n.\n                  complex_of_real (1 / real ka) *\n                  (\\<Sum>m<ka.\n                      map ws [0..<k] ! m * unity_root ka (- int n * int m)))\n           [0..<ka]))", "by simp"], ["", "lemma coeff_finite_fourier_poly': \n  assumes \"n < k\"\n  shows \"coeff (finite_fourier_poly' ws k) n = \n         (1/k) * (\\<Sum>m < k. (ws m) * unity_root k (-n*m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (finite_fourier_poly' ws k) n =\n    1 / of_nat k * (\\<Sum>m<k. ws m * unity_root k (- int n * int m))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. coeff (finite_fourier_poly' ws k) n =\n    1 / of_nat k * (\\<Sum>m<k. ws m * unity_root k (- int n * int m))", "let ?ws = \"[ws n. n \\<leftarrow> [0..<k]]\""], ["proof (state)\ngoal (1 subgoal):\n 1. coeff (finite_fourier_poly' ws k) n =\n    1 / of_nat k * (\\<Sum>m<k. ws m * unity_root k (- int n * int m))", "have \"coeff (finite_fourier_poly' ws k) n =\n        coeff (finite_fourier_poly ?ws) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (finite_fourier_poly' ws k) n =\n    coeff (finite_fourier_poly (map ws [0..<k])) n", "by (simp add: finite_fourier_poly'_conv_finite_fourier_poly)"], ["proof (state)\nthis:\n  coeff (finite_fourier_poly' ws k) n =\n  coeff (finite_fourier_poly (map ws [0..<k])) n\n\ngoal (1 subgoal):\n 1. coeff (finite_fourier_poly' ws k) n =\n    1 / of_nat k * (\\<Sum>m<k. ws m * unity_root k (- int n * int m))", "also"], ["proof (state)\nthis:\n  coeff (finite_fourier_poly' ws k) n =\n  coeff (finite_fourier_poly (map ws [0..<k])) n\n\ngoal (1 subgoal):\n 1. coeff (finite_fourier_poly' ws k) n =\n    1 / of_nat k * (\\<Sum>m<k. ws m * unity_root k (- int n * int m))", "have \"coeff (finite_fourier_poly ?ws) n = \n    1 / k * (\\<Sum>m<k. (?ws ! m) * unity_root k (- n*m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (finite_fourier_poly (map ws [0..<k])) n =\n    complex_of_real (1 / real k) *\n    (\\<Sum>m<k. map ws [0..<k] ! m * unity_root k (- int n * int m))", "using assms"], ["proof (prove)\nusing this:\n  n < k\n\ngoal (1 subgoal):\n 1. coeff (finite_fourier_poly (map ws [0..<k])) n =\n    complex_of_real (1 / real k) *\n    (\\<Sum>m<k. map ws [0..<k] ! m * unity_root k (- int n * int m))", "by (auto simp: coeff_finite_fourier_poly)"], ["proof (state)\nthis:\n  coeff (finite_fourier_poly (map ws [0..<k])) n =\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. map ws [0..<k] ! m * unity_root k (- int n * int m))\n\ngoal (1 subgoal):\n 1. coeff (finite_fourier_poly' ws k) n =\n    1 / of_nat k * (\\<Sum>m<k. ws m * unity_root k (- int n * int m))", "also"], ["proof (state)\nthis:\n  coeff (finite_fourier_poly (map ws [0..<k])) n =\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. map ws [0..<k] ! m * unity_root k (- int n * int m))\n\ngoal (1 subgoal):\n 1. coeff (finite_fourier_poly' ws k) n =\n    1 / of_nat k * (\\<Sum>m<k. ws m * unity_root k (- int n * int m))", "have \"\\<dots> = (1/k) * (\\<Sum>m < k. (ws m) * unity_root k (-n*m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (1 / real k) *\n    (\\<Sum>m<k. map ws [0..<k] ! m * unity_root k (- int n * int m)) =\n    complex_of_real (1 / real k) *\n    (\\<Sum>m<k. ws m * unity_root k (- int n * int m))", "using assms"], ["proof (prove)\nusing this:\n  n < k\n\ngoal (1 subgoal):\n 1. complex_of_real (1 / real k) *\n    (\\<Sum>m<k. map ws [0..<k] ! m * unity_root k (- int n * int m)) =\n    complex_of_real (1 / real k) *\n    (\\<Sum>m<k. ws m * unity_root k (- int n * int m))", "by simp"], ["proof (state)\nthis:\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. map ws [0..<k] ! m * unity_root k (- int n * int m)) =\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. ws m * unity_root k (- int n * int m))\n\ngoal (1 subgoal):\n 1. coeff (finite_fourier_poly' ws k) n =\n    1 / of_nat k * (\\<Sum>m<k. ws m * unity_root k (- int n * int m))", "finally"], ["proof (chain)\npicking this:\n  coeff (finite_fourier_poly' ws k) n =\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. ws m * unity_root k (- int n * int m))", "show ?thesis"], ["proof (prove)\nusing this:\n  coeff (finite_fourier_poly' ws k) n =\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. ws m * unity_root k (- int n * int m))\n\ngoal (1 subgoal):\n 1. coeff (finite_fourier_poly' ws k) n =\n    1 / of_nat k * (\\<Sum>m<k. ws m * unity_root k (- int n * int m))", "by simp"], ["proof (state)\nthis:\n  coeff (finite_fourier_poly' ws k) n =\n  1 / of_nat k * (\\<Sum>m<k. ws m * unity_root k (- int n * int m))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma degree_finite_fourier_poly': \"degree (finite_fourier_poly' ws k) \\<le> k - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (finite_fourier_poly' ws k) \\<le> k - 1", "using degree_finite_fourier_poly[of \"[ws n. n \\<leftarrow> [0..<k]]\"]"], ["proof (prove)\nusing this:\n  degree (finite_fourier_poly (map ws [0..<k]))\n  \\<le> length (map ws [0..<k]) - 1\n\ngoal (1 subgoal):\n 1. degree (finite_fourier_poly' ws k) \\<le> k - 1", "by (auto simp: finite_fourier_poly'_conv_finite_fourier_poly)"], ["", "lemma poly_finite_fourier_poly':\n  fixes m :: int and k\n  assumes \"m \\<in> {0..<k}\"\n  shows \"poly (finite_fourier_poly' ws k) (unity_root k m) = ws (nat m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly' ws k) (unity_root k m) = ws (nat m)", "using assms poly_finite_fourier_poly[of m \"[ws n. n \\<leftarrow> [0..<k]]\"]"], ["proof (prove)\nusing this:\n  m \\<in> {0..<int k}\n  \\<lbrakk>m \\<in> {0..<int (length (map ws [0..<k]))};\n   m < int (length (map ws [0..<k]))\\<rbrakk>\n  \\<Longrightarrow> poly (finite_fourier_poly (map ws [0..<k]))\n                     (unity_root (length (map ws [0..<k])) m) =\n                    map ws [0..<k] ! nat m\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly' ws k) (unity_root k m) = ws (nat m)", "by (auto simp: finite_fourier_poly'_conv_finite_fourier_poly poly_finite_fourier_poly)"], ["", "lemma finite_fourier_poly'_unique:\n  assumes \"k > 0\"\n  assumes \"degree p \\<le> k - 1\"\n  assumes \"\\<forall>m\\<le>k-1. ws m = poly p (unity_root k m)\"\n  shows \"p = finite_fourier_poly' ws k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = finite_fourier_poly' ws k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p = finite_fourier_poly' ws k", "let ?ws = \"[ws n. n \\<leftarrow> [0..<k]]\""], ["proof (state)\ngoal (1 subgoal):\n 1. p = finite_fourier_poly' ws k", "from finite_fourier_poly_unique"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < length ?ws; degree ?p \\<le> length ?ws - 1;\n   \\<forall>m\\<le>length ?ws - 1.\n      ?ws ! m = poly ?p (unity_root (length ?ws) (int m))\\<rbrakk>\n  \\<Longrightarrow> ?p = finite_fourier_poly ?ws", "have \"p = finite_fourier_poly ?ws\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < length ?ws; degree ?p \\<le> length ?ws - 1;\n   \\<forall>m\\<le>length ?ws - 1.\n      ?ws ! m = poly ?p (unity_root (length ?ws) (int m))\\<rbrakk>\n  \\<Longrightarrow> ?p = finite_fourier_poly ?ws\n\ngoal (1 subgoal):\n 1. p = finite_fourier_poly (map ws [0..<k])", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < length ?ws; degree ?p \\<le> length ?ws - 1;\n   \\<forall>m\\<le>length ?ws - 1.\n      ?ws ! m = poly ?p (unity_root (length ?ws) (int m))\\<rbrakk>\n  \\<Longrightarrow> ?p = finite_fourier_poly ?ws\n  0 < k\n  degree p \\<le> k - 1\n  \\<forall>m\\<le>k - 1. ws m = poly p (unity_root k (int m))\n\ngoal (1 subgoal):\n 1. p = finite_fourier_poly (map ws [0..<k])", "by simp"], ["proof (state)\nthis:\n  p = finite_fourier_poly (map ws [0..<k])\n\ngoal (1 subgoal):\n 1. p = finite_fourier_poly' ws k", "also"], ["proof (state)\nthis:\n  p = finite_fourier_poly (map ws [0..<k])\n\ngoal (1 subgoal):\n 1. p = finite_fourier_poly' ws k", "have \"\\<dots> = finite_fourier_poly' ws k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_fourier_poly (map ws [0..<k]) = finite_fourier_poly' ws k", "using finite_fourier_poly'_conv_finite_fourier_poly"], ["proof (prove)\nusing this:\n  finite_fourier_poly' ?ws ?k = finite_fourier_poly (map ?ws [0..<?k])\n\ngoal (1 subgoal):\n 1. finite_fourier_poly (map ws [0..<k]) = finite_fourier_poly' ws k", ".."], ["proof (state)\nthis:\n  finite_fourier_poly (map ws [0..<k]) = finite_fourier_poly' ws k\n\ngoal (1 subgoal):\n 1. p = finite_fourier_poly' ws k", "finally"], ["proof (chain)\npicking this:\n  p = finite_fourier_poly' ws k", "show \"p = finite_fourier_poly' ws k\""], ["proof (prove)\nusing this:\n  p = finite_fourier_poly' ws k\n\ngoal (1 subgoal):\n 1. p = finite_fourier_poly' ws k", "by blast"], ["proof (state)\nthis:\n  p = finite_fourier_poly' ws k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fourier_unity_root:\n  fixes k :: nat\n  assumes \"k > 0\" \n  shows \"poly (finite_fourier_poly' f k) (unity_root k m) = \n    (\\<Sum>n<k.1/k*(\\<Sum>m<k.(f m)*unity_root k (-n*m))*unity_root k (m*n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly' f k) (unity_root k (int m)) =\n    (\\<Sum>n<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>m<k. f m * unity_root k (- int n * int m)) *\n        unity_root k (int (m * n)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly' f k) (unity_root k (int m)) =\n    (\\<Sum>n<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>m<k. f m * unity_root k (- int n * int m)) *\n        unity_root k (int (m * n)))", "have \"poly (finite_fourier_poly' f k) (unity_root k m) = \n        (\\<Sum>n\\<le>k-1. coeff (finite_fourier_poly' f k) n *(unity_root k m)^n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly' f k) (unity_root k (int m)) =\n    (\\<Sum>n\\<le>k - 1.\n        coeff (finite_fourier_poly' f k) n * unity_root k (int m) ^ n)", "using poly_altdef'[of \"finite_fourier_poly' f k\" \"k-1\" \"unity_root k m\"]\n          degree_finite_fourier_poly'[of f k]"], ["proof (prove)\nusing this:\n  degree (finite_fourier_poly' f k) \\<le> k - 1 \\<Longrightarrow>\n  poly (finite_fourier_poly' f k) (unity_root k (int m)) =\n  (\\<Sum>i\\<le>k - 1.\n      coeff (finite_fourier_poly' f k) i * unity_root k (int m) ^ i)\n  degree (finite_fourier_poly' f k) \\<le> k - 1\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly' f k) (unity_root k (int m)) =\n    (\\<Sum>n\\<le>k - 1.\n        coeff (finite_fourier_poly' f k) n * unity_root k (int m) ^ n)", "by simp"], ["proof (state)\nthis:\n  poly (finite_fourier_poly' f k) (unity_root k (int m)) =\n  (\\<Sum>n\\<le>k - 1.\n      coeff (finite_fourier_poly' f k) n * unity_root k (int m) ^ n)\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly' f k) (unity_root k (int m)) =\n    (\\<Sum>n<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>m<k. f m * unity_root k (- int n * int m)) *\n        unity_root k (int (m * n)))", "also"], ["proof (state)\nthis:\n  poly (finite_fourier_poly' f k) (unity_root k (int m)) =\n  (\\<Sum>n\\<le>k - 1.\n      coeff (finite_fourier_poly' f k) n * unity_root k (int m) ^ n)\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly' f k) (unity_root k (int m)) =\n    (\\<Sum>n<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>m<k. f m * unity_root k (- int n * int m)) *\n        unity_root k (int (m * n)))", "have \"\\<dots> = (\\<Sum>n\\<le>k-1. coeff (finite_fourier_poly' f k) n *(unity_root k (m*n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n\\<le>k - 1.\n        coeff (finite_fourier_poly' f k) n * unity_root k (int m) ^ n) =\n    (\\<Sum>n\\<le>k - 1.\n        coeff (finite_fourier_poly' f k) n * unity_root k (int (m * n)))", "using unity_root_pow"], ["proof (prove)\nusing this:\n  unity_root ?k ?n ^ ?m = unity_root ?k (?n * int ?m)\n\ngoal (1 subgoal):\n 1. (\\<Sum>n\\<le>k - 1.\n        coeff (finite_fourier_poly' f k) n * unity_root k (int m) ^ n) =\n    (\\<Sum>n\\<le>k - 1.\n        coeff (finite_fourier_poly' f k) n * unity_root k (int (m * n)))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>n\\<le>k - 1.\n      coeff (finite_fourier_poly' f k) n * unity_root k (int m) ^ n) =\n  (\\<Sum>n\\<le>k - 1.\n      coeff (finite_fourier_poly' f k) n * unity_root k (int (m * n)))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly' f k) (unity_root k (int m)) =\n    (\\<Sum>n<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>m<k. f m * unity_root k (- int n * int m)) *\n        unity_root k (int (m * n)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>n\\<le>k - 1.\n      coeff (finite_fourier_poly' f k) n * unity_root k (int m) ^ n) =\n  (\\<Sum>n\\<le>k - 1.\n      coeff (finite_fourier_poly' f k) n * unity_root k (int (m * n)))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly' f k) (unity_root k (int m)) =\n    (\\<Sum>n<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>m<k. f m * unity_root k (- int n * int m)) *\n        unity_root k (int (m * n)))", "have \"\\<dots> = (\\<Sum>n<k. coeff (finite_fourier_poly' f k) n *(unity_root k (m*n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n\\<le>k - 1.\n        coeff (finite_fourier_poly' f k) n * unity_root k (int (m * n))) =\n    (\\<Sum>n<k.\n        coeff (finite_fourier_poly' f k) n * unity_root k (int (m * n)))", "using assms"], ["proof (prove)\nusing this:\n  0 < k\n\ngoal (1 subgoal):\n 1. (\\<Sum>n\\<le>k - 1.\n        coeff (finite_fourier_poly' f k) n * unity_root k (int (m * n))) =\n    (\\<Sum>n<k.\n        coeff (finite_fourier_poly' f k) n * unity_root k (int (m * n)))", "by (intro sum.cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>n\\<le>k - 1.\n      coeff (finite_fourier_poly' f k) n * unity_root k (int (m * n))) =\n  (\\<Sum>n<k.\n      coeff (finite_fourier_poly' f k) n * unity_root k (int (m * n)))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly' f k) (unity_root k (int m)) =\n    (\\<Sum>n<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>m<k. f m * unity_root k (- int n * int m)) *\n        unity_root k (int (m * n)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>n\\<le>k - 1.\n      coeff (finite_fourier_poly' f k) n * unity_root k (int (m * n))) =\n  (\\<Sum>n<k.\n      coeff (finite_fourier_poly' f k) n * unity_root k (int (m * n)))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly' f k) (unity_root k (int m)) =\n    (\\<Sum>n<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>m<k. f m * unity_root k (- int n * int m)) *\n        unity_root k (int (m * n)))", "have \"\\<dots> = (\\<Sum>n<k.(1/k)*(\\<Sum>m<k.(f m)*unity_root k (-n*m))*(unity_root k (m*n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n<k.\n        coeff (finite_fourier_poly' f k) n * unity_root k (int (m * n))) =\n    (\\<Sum>n<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>m<k. f m * unity_root k (- int n * int m)) *\n        unity_root k (int (m * n)))", "using coeff_finite_fourier_poly'[of _ k f]"], ["proof (prove)\nusing this:\n  ?n < k \\<Longrightarrow>\n  coeff (finite_fourier_poly' f k) ?n =\n  1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int ?n * int m))\n\ngoal (1 subgoal):\n 1. (\\<Sum>n<k.\n        coeff (finite_fourier_poly' f k) n * unity_root k (int (m * n))) =\n    (\\<Sum>n<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>m<k. f m * unity_root k (- int n * int m)) *\n        unity_root k (int (m * n)))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>n<k.\n      coeff (finite_fourier_poly' f k) n * unity_root k (int (m * n))) =\n  (\\<Sum>n<k.\n      complex_of_real (1 / real k) *\n      (\\<Sum>m<k. f m * unity_root k (- int n * int m)) *\n      unity_root k (int (m * n)))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly' f k) (unity_root k (int m)) =\n    (\\<Sum>n<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>m<k. f m * unity_root k (- int n * int m)) *\n        unity_root k (int (m * n)))", "finally"], ["proof (chain)\npicking this:\n  poly (finite_fourier_poly' f k) (unity_root k (int m)) =\n  (\\<Sum>n<k.\n      complex_of_real (1 / real k) *\n      (\\<Sum>m<k. f m * unity_root k (- int n * int m)) *\n      unity_root k (int (m * n)))", "show\n   \"poly (finite_fourier_poly' f k) (unity_root k m) = \n    (\\<Sum>n<k.1/k*(\\<Sum>m<k.(f m)*unity_root k (-n*m))*unity_root k (m*n))\""], ["proof (prove)\nusing this:\n  poly (finite_fourier_poly' f k) (unity_root k (int m)) =\n  (\\<Sum>n<k.\n      complex_of_real (1 / real k) *\n      (\\<Sum>m<k. f m * unity_root k (- int n * int m)) *\n      unity_root k (int (m * n)))\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly' f k) (unity_root k (int m)) =\n    (\\<Sum>n<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>m<k. f m * unity_root k (- int n * int m)) *\n        unity_root k (int (m * n)))", "by blast"], ["proof (state)\nthis:\n  poly (finite_fourier_poly' f k) (unity_root k (int m)) =\n  (\\<Sum>n<k.\n      complex_of_real (1 / real k) *\n      (\\<Sum>m<k. f m * unity_root k (- int n * int m)) *\n      unity_root k (int (m * n)))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Expansion of an arithmetical function\\<close>"], ["", "text \\<open>Theorem 8.4\\<close>"], ["", "theorem fourier_expansion_periodic_arithmetic:\n  assumes \"k > 0\"\n  assumes \"periodic_arithmetic f k\"\n  defines \"g \\<equiv> (\\<lambda>n. (1 / k) * (\\<Sum>m<k. f m * unity_root k (-n * m)))\"\n    shows \"periodic_arithmetic g k\" \n      and \"f m = (\\<Sum>n<k. g n * unity_root k (m * n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic g k &&&\n    f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. periodic_arithmetic g k\n 2. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. periodic_arithmetic g k\n 2. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "fix l"], ["proof (state)\ngoal (2 subgoals):\n 1. periodic_arithmetic g k\n 2. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "from unity_periodic_arithmetic mult_period"], ["proof (chain)\npicking this:\n  periodic_arithmetic (\\<lambda>x. unity_root ?k (int x)) ?k\n  periodic_arithmetic ?g ?k \\<Longrightarrow>\n  periodic_arithmetic ?g (?k * ?q)", "have period: \"periodic_arithmetic (\\<lambda>x. unity_root k x) (k*l)\""], ["proof (prove)\nusing this:\n  periodic_arithmetic (\\<lambda>x. unity_root ?k (int x)) ?k\n  periodic_arithmetic ?g ?k \\<Longrightarrow>\n  periodic_arithmetic ?g (?k * ?q)\n\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>x. unity_root k (int x)) (k * l)", "by simp"], ["proof (state)\nthis:\n  periodic_arithmetic (\\<lambda>x. unity_root k (int x)) (k * l)\n\ngoal (2 subgoals):\n 1. periodic_arithmetic g k\n 2. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "}"], ["proof (state)\nthis:\n  periodic_arithmetic (\\<lambda>x. unity_root k (int x)) (k * ?l2)\n\ngoal (2 subgoals):\n 1. periodic_arithmetic g k\n 2. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "note period = this"], ["proof (state)\nthis:\n  periodic_arithmetic (\\<lambda>x. unity_root k (int x)) (k * ?l2)\n\ngoal (2 subgoals):\n 1. periodic_arithmetic g k\n 2. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "{"], ["proof (state)\nthis:\n  periodic_arithmetic (\\<lambda>x. unity_root k (int x)) (k * ?l2)\n\ngoal (2 subgoals):\n 1. periodic_arithmetic g k\n 2. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "fix n l"], ["proof (state)\ngoal (2 subgoals):\n 1. periodic_arithmetic g k\n 2. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "have \"unity_root k (-(n+k)*l) = cnj (unity_root k ((n+k)*l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k (- int (n + k) * int l) =\n    cnj (unity_root k (int ((n + k) * l)))", "by (simp add: unity_root_uminus unity_root_diff ring_distribs unity_root_add)"], ["proof (state)\nthis:\n  unity_root k (- int (n + k) * int l) =\n  cnj (unity_root k (int ((n + k) * l)))\n\ngoal (2 subgoals):\n 1. periodic_arithmetic g k\n 2. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "also"], ["proof (state)\nthis:\n  unity_root k (- int (n + k) * int l) =\n  cnj (unity_root k (int ((n + k) * l)))\n\ngoal (2 subgoals):\n 1. periodic_arithmetic g k\n 2. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "have \"unity_root k ((n+k)*l) = unity_root k (n*l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root k (int ((n + k) * l)) = unity_root k (int (n * l))", "by (intro unity_root_cong) (auto simp: cong_def algebra_simps)"], ["proof (state)\nthis:\n  unity_root k (int ((n + k) * l)) = unity_root k (int (n * l))\n\ngoal (2 subgoals):\n 1. periodic_arithmetic g k\n 2. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "also"], ["proof (state)\nthis:\n  unity_root k (int ((n + k) * l)) = unity_root k (int (n * l))\n\ngoal (2 subgoals):\n 1. periodic_arithmetic g k\n 2. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "have \"cnj \\<dots> = unity_root k (-n*l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (unity_root k (int (n * l))) = unity_root k (- int n * int l)", "using unity_root_uminus"], ["proof (prove)\nusing this:\n  unity_root ?k (- ?m) = cnj (unity_root ?k ?m)\n\ngoal (1 subgoal):\n 1. cnj (unity_root k (int (n * l))) = unity_root k (- int n * int l)", "by simp"], ["proof (state)\nthis:\n  cnj (unity_root k (int (n * l))) = unity_root k (- int n * int l)\n\ngoal (2 subgoals):\n 1. periodic_arithmetic g k\n 2. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "finally"], ["proof (chain)\npicking this:\n  unity_root k (- int (n + k) * int l) = unity_root k (- int n * int l)", "have \"unity_root k (-(n+k)*l) = unity_root k (-n*l)\""], ["proof (prove)\nusing this:\n  unity_root k (- int (n + k) * int l) = unity_root k (- int n * int l)\n\ngoal (1 subgoal):\n 1. unity_root k (- int (n + k) * int l) = unity_root k (- int n * int l)", "by simp"], ["proof (state)\nthis:\n  unity_root k (- int (n + k) * int l) = unity_root k (- int n * int l)\n\ngoal (2 subgoals):\n 1. periodic_arithmetic g k\n 2. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "}"], ["proof (state)\nthis:\n  unity_root k (- int (?n2 + k) * int ?l2) =\n  unity_root k (- int ?n2 * int ?l2)\n\ngoal (2 subgoals):\n 1. periodic_arithmetic g k\n 2. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "note u_period = this"], ["proof (state)\nthis:\n  unity_root k (- int (?n2 + k) * int ?l2) =\n  unity_root k (- int ?n2 * int ?l2)\n\ngoal (2 subgoals):\n 1. periodic_arithmetic g k\n 2. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "show 1: \"periodic_arithmetic g k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic g k", "unfolding periodic_arithmetic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. g (n + k) = g n", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. g (n + k) = g n", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. g (n + k) = g n", "have \"g(n+k) = (1 / k) * (\\<Sum>m<k. f(m) * unity_root k (-(n+k)*m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (n + k) =\n    complex_of_real (1 / real k) *\n    (\\<Sum>m<k. f m * unity_root k (- int (n + k) * int m))", "using assms(3)"], ["proof (prove)\nusing this:\n  g \\<equiv>\n  \\<lambda>x.\n     1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int x * int m))\n\ngoal (1 subgoal):\n 1. g (n + k) =\n    complex_of_real (1 / real k) *\n    (\\<Sum>m<k. f m * unity_root k (- int (n + k) * int m))", "by fastforce"], ["proof (state)\nthis:\n  g (n + k) =\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. f m * unity_root k (- int (n + k) * int m))\n\ngoal (1 subgoal):\n 1. \\<And>n. g (n + k) = g n", "also"], ["proof (state)\nthis:\n  g (n + k) =\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. f m * unity_root k (- int (n + k) * int m))\n\ngoal (1 subgoal):\n 1. \\<And>n. g (n + k) = g n", "have \"\\<dots> = (1 / k) * (\\<Sum>m<k. f(m) * unity_root k (-n*m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (1 / real k) *\n    (\\<Sum>m<k. f m * unity_root k (- int (n + k) * int m)) =\n    complex_of_real (1 / real k) *\n    (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. complex_of_real (1 / real k) *\n    (\\<Sum>m<k. f m * unity_root k (- int (n + k) * int m)) =\n    complex_of_real (1 / real k) *\n    (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "have \"(\\<Sum>m<k. f(m) * unity_root k (-(n+k)*m)) = \n            (\\<Sum>m<k. f(m) * unity_root k (-n*m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m<k. f m * unity_root k (- int (n + k) * int m)) =\n    (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "by (intro sum.cong) (use u_period in auto)"], ["proof (state)\nthis:\n  (\\<Sum>m<k. f m * unity_root k (- int (n + k) * int m)) =\n  (\\<Sum>m<k. f m * unity_root k (- int n * int m))\n\ngoal (1 subgoal):\n 1. complex_of_real (1 / real k) *\n    (\\<Sum>m<k. f m * unity_root k (- int (n + k) * int m)) =\n    complex_of_real (1 / real k) *\n    (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>m<k. f m * unity_root k (- int (n + k) * int m)) =\n  (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>m<k. f m * unity_root k (- int (n + k) * int m)) =\n  (\\<Sum>m<k. f m * unity_root k (- int n * int m))\n\ngoal (1 subgoal):\n 1. complex_of_real (1 / real k) *\n    (\\<Sum>m<k. f m * unity_root k (- int (n + k) * int m)) =\n    complex_of_real (1 / real k) *\n    (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "by argo"], ["proof (state)\nthis:\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. f m * unity_root k (- int (n + k) * int m)) =\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. f m * unity_root k (- int n * int m))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. f m * unity_root k (- int (n + k) * int m)) =\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. f m * unity_root k (- int n * int m))\n\ngoal (1 subgoal):\n 1. \\<And>n. g (n + k) = g n", "also"], ["proof (state)\nthis:\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. f m * unity_root k (- int (n + k) * int m)) =\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. f m * unity_root k (- int n * int m))\n\ngoal (1 subgoal):\n 1. \\<And>n. g (n + k) = g n", "have \"\\<dots> = g(n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (1 / real k) *\n    (\\<Sum>m<k. f m * unity_root k (- int n * int m)) =\n    g n", "using assms(3)"], ["proof (prove)\nusing this:\n  g \\<equiv>\n  \\<lambda>x.\n     1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int x * int m))\n\ngoal (1 subgoal):\n 1. complex_of_real (1 / real k) *\n    (\\<Sum>m<k. f m * unity_root k (- int n * int m)) =\n    g n", "by fastforce"], ["proof (state)\nthis:\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. f m * unity_root k (- int n * int m)) =\n  g n\n\ngoal (1 subgoal):\n 1. \\<And>n. g (n + k) = g n", "finally"], ["proof (chain)\npicking this:\n  g (n + k) = g n", "show \"g(n+k) = g(n)\""], ["proof (prove)\nusing this:\n  g (n + k) = g n\n\ngoal (1 subgoal):\n 1. g (n + k) = g n", "by simp"], ["proof (state)\nthis:\n  g (n + k) = g n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  periodic_arithmetic g k\n\ngoal (1 subgoal):\n 1. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "show \"f(m) = (\\<Sum>n<k. g(n)* unity_root k (m * int n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "assume range: \"m \\<in> {0..<k}\""], ["proof (state)\nthis:\n  m \\<in> {0..<k}\n\ngoal (1 subgoal):\n 1. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "have \"f(m) = (\\<Sum>n<k. g(n)* unity_root k (m * int n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "have \"f m = poly (finite_fourier_poly' f k) (unity_root k m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f m = poly (finite_fourier_poly' f k) (unity_root k (int m))", "using range"], ["proof (prove)\nusing this:\n  m \\<in> {0..<k}\n\ngoal (1 subgoal):\n 1. f m = poly (finite_fourier_poly' f k) (unity_root k (int m))", "by (simp add: poly_finite_fourier_poly')"], ["proof (state)\nthis:\n  f m = poly (finite_fourier_poly' f k) (unity_root k (int m))\n\ngoal (1 subgoal):\n 1. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "also"], ["proof (state)\nthis:\n  f m = poly (finite_fourier_poly' f k) (unity_root k (int m))\n\ngoal (1 subgoal):\n 1. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "have \"\\<dots> = (\\<Sum>n<k. (1 / k) * (\\<Sum>m<k. f(m) * unity_root k (-n*m))* unity_root k (m*n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly' f k) (unity_root k (int m)) =\n    (\\<Sum>n<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>m<k. f m * unity_root k (- int n * int m)) *\n        unity_root k (int (m * n)))", "using fourier_unity_root assms(1)"], ["proof (prove)\nusing this:\n  0 < ?k \\<Longrightarrow>\n  poly (finite_fourier_poly' ?f ?k) (unity_root ?k (int ?m)) =\n  (\\<Sum>n<?k.\n      complex_of_real (1 / real ?k) *\n      (\\<Sum>m<?k. ?f m * unity_root ?k (- int n * int m)) *\n      unity_root ?k (int (?m * n)))\n  0 < k\n\ngoal (1 subgoal):\n 1. poly (finite_fourier_poly' f k) (unity_root k (int m)) =\n    (\\<Sum>n<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>m<k. f m * unity_root k (- int n * int m)) *\n        unity_root k (int (m * n)))", "by blast"], ["proof (state)\nthis:\n  poly (finite_fourier_poly' f k) (unity_root k (int m)) =\n  (\\<Sum>n<k.\n      complex_of_real (1 / real k) *\n      (\\<Sum>m<k. f m * unity_root k (- int n * int m)) *\n      unity_root k (int (m * n)))\n\ngoal (1 subgoal):\n 1. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "also"], ["proof (state)\nthis:\n  poly (finite_fourier_poly' f k) (unity_root k (int m)) =\n  (\\<Sum>n<k.\n      complex_of_real (1 / real k) *\n      (\\<Sum>m<k. f m * unity_root k (- int n * int m)) *\n      unity_root k (int (m * n)))\n\ngoal (1 subgoal):\n 1. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "have \"\\<dots> = (\\<Sum>n<k. g(n)* unity_root k (m*n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>m<k. f m * unity_root k (- int n * int m)) *\n        unity_root k (int (m * n))) =\n    (\\<Sum>n<k. g n * unity_root k (int (m * n)))", "using assms"], ["proof (prove)\nusing this:\n  0 < k\n  periodic_arithmetic f k\n  g \\<equiv>\n  \\<lambda>x.\n     1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int x * int m))\n\ngoal (1 subgoal):\n 1. (\\<Sum>n<k.\n        complex_of_real (1 / real k) *\n        (\\<Sum>m<k. f m * unity_root k (- int n * int m)) *\n        unity_root k (int (m * n))) =\n    (\\<Sum>n<k. g n * unity_root k (int (m * n)))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>n<k.\n      complex_of_real (1 / real k) *\n      (\\<Sum>m<k. f m * unity_root k (- int n * int m)) *\n      unity_root k (int (m * n))) =\n  (\\<Sum>n<k. g n * unity_root k (int (m * n)))\n\ngoal (1 subgoal):\n 1. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "finally"], ["proof (chain)\npicking this:\n  f m = (\\<Sum>n<k. g n * unity_root k (int (m * n)))", "show ?thesis"], ["proof (prove)\nusing this:\n  f m = (\\<Sum>n<k. g n * unity_root k (int (m * n)))\n\ngoal (1 subgoal):\n 1. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "by auto"], ["proof (state)\nthis:\n  f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))\n\ngoal (1 subgoal):\n 1. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "}"], ["proof (state)\nthis:\n  ?ma2 \\<in> {0..<k} \\<Longrightarrow>\n  f ?ma2 = (\\<Sum>n<k. g n * unity_root k (int ?ma2 * int n))\n\ngoal (1 subgoal):\n 1. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "note concentrated = this"], ["proof (state)\nthis:\n  ?ma2 \\<in> {0..<k} \\<Longrightarrow>\n  f ?ma2 = (\\<Sum>n<k. g n * unity_root k (int ?ma2 * int n))\n\ngoal (1 subgoal):\n 1. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "have \"periodic_arithmetic (\\<lambda>m. (\\<Sum>n<k. g(n)* unity_root k (m * int n))) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic\n     (\\<lambda>x. \\<Sum>n<k. g n * unity_root k (int x * int n)) k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. periodic_arithmetic\n     (\\<lambda>x. \\<Sum>n<k. g n * unity_root k (int x * int n)) k", "have \"periodic_arithmetic (\\<lambda>n. g(n)* unity_root k (i * int n)) k\"  for i :: int"], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>n. g n * unity_root k (i * int n)) k", "using 1 unity_periodic_arithmetic mult_periodic_arithmetic\n            unity_periodic_arithmetic_mult"], ["proof (prove)\nusing this:\n  periodic_arithmetic g k\n  periodic_arithmetic (\\<lambda>x. unity_root ?k (int x)) ?k\n  \\<lbrakk>periodic_arithmetic ?f ?k; periodic_arithmetic ?g ?k\\<rbrakk>\n  \\<Longrightarrow> periodic_arithmetic (\\<lambda>n. ?f n * ?g n) ?k\n  periodic_arithmetic (\\<lambda>n. unity_root ?k (?m * int n)) ?k\n\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>n. g n * unity_root k (i * int n)) k", "by auto"], ["proof (state)\nthis:\n  periodic_arithmetic (\\<lambda>n. g n * unity_root k (?i * int n)) k\n\ngoal (1 subgoal):\n 1. periodic_arithmetic\n     (\\<lambda>x. \\<Sum>n<k. g n * unity_root k (int x * int n)) k", "then"], ["proof (chain)\npicking this:\n  periodic_arithmetic (\\<lambda>n. g n * unity_root k (?i * int n)) k", "have p_s: \"\\<forall>i<k. periodic_arithmetic (\\<lambda>n. g(n)* unity_root k (i * int n)) k\""], ["proof (prove)\nusing this:\n  periodic_arithmetic (\\<lambda>n. g n * unity_root k (?i * int n)) k\n\ngoal (1 subgoal):\n 1. \\<forall>i<k.\n       periodic_arithmetic (\\<lambda>n. g n * unity_root k (int i * int n))\n        k", "by simp"], ["proof (state)\nthis:\n  \\<forall>i<k.\n     periodic_arithmetic (\\<lambda>n. g n * unity_root k (int i * int n)) k\n\ngoal (1 subgoal):\n 1. periodic_arithmetic\n     (\\<lambda>x. \\<Sum>n<k. g n * unity_root k (int x * int n)) k", "have \"periodic_arithmetic (\\<lambda>i. \\<Sum>n<k. g(n)* unity_root k (i * int n)) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic\n     (\\<lambda>x. \\<Sum>n<k. g n * unity_root k (int x * int n)) k", "unfolding periodic_arithmetic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       (\\<Sum>na<k. g na * unity_root k (int (n + k) * int na)) =\n       (\\<Sum>na<k. g na * unity_root k (int n * int na))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<Sum>na<k. g na * unity_root k (int (n + k) * int na)) =\n       (\\<Sum>na<k. g na * unity_root k (int n * int na))", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<Sum>na<k. g na * unity_root k (int (n + k) * int na)) =\n       (\\<Sum>na<k. g na * unity_root k (int n * int na))", "show \"(\\<Sum>na<k. g na * unity_root k (int (n + k) * int na)) =\n            (\\<Sum>na<k. g na * unity_root k (int n * int na))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>na<k. g na * unity_root k (int (n + k) * int na)) =\n    (\\<Sum>na<k. g na * unity_root k (int n * int na))", "by (intro sum.cong refl, simp add: distrib_right flip: of_nat_mult of_nat_add)\n           (insert period, unfold periodic_arithmetic_def, blast)"], ["proof (state)\nthis:\n  (\\<Sum>na<k. g na * unity_root k (int (n + k) * int na)) =\n  (\\<Sum>na<k. g na * unity_root k (int n * int na))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  periodic_arithmetic\n   (\\<lambda>x. \\<Sum>n<k. g n * unity_root k (int x * int n)) k\n\ngoal (1 subgoal):\n 1. periodic_arithmetic\n     (\\<lambda>x. \\<Sum>n<k. g n * unity_root k (int x * int n)) k", "then"], ["proof (chain)\npicking this:\n  periodic_arithmetic\n   (\\<lambda>x. \\<Sum>n<k. g n * unity_root k (int x * int n)) k", "show ?thesis"], ["proof (prove)\nusing this:\n  periodic_arithmetic\n   (\\<lambda>x. \\<Sum>n<k. g n * unity_root k (int x * int n)) k\n\ngoal (1 subgoal):\n 1. periodic_arithmetic\n     (\\<lambda>x. \\<Sum>n<k. g n * unity_root k (int x * int n)) k", "by simp"], ["proof (state)\nthis:\n  periodic_arithmetic\n   (\\<lambda>x. \\<Sum>n<k. g n * unity_root k (int x * int n)) k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  periodic_arithmetic\n   (\\<lambda>x. \\<Sum>n<k. g n * unity_root k (int x * int n)) k\n\ngoal (1 subgoal):\n 1. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "from this assms(1-2) concentrated \n       unique_periodic_arithmetic_extension[of k f \"(\\<lambda>i. \\<Sum>n<k. g(n)* unity_root k (i * int n))\"  m]"], ["proof (chain)\npicking this:\n  periodic_arithmetic\n   (\\<lambda>x. \\<Sum>n<k. g n * unity_root k (int x * int n)) k\n  0 < k\n  periodic_arithmetic f k\n  ?ma2 \\<in> {0..<k} \\<Longrightarrow>\n  f ?ma2 = (\\<Sum>n<k. g n * unity_root k (int ?ma2 * int n))\n  \\<lbrakk>0 < k;\n   \\<forall>j<k. f j = (\\<Sum>n<k. g n * unity_root k (int j * int n));\n   periodic_arithmetic f k;\n   periodic_arithmetic\n    (\\<lambda>x. \\<Sum>n<k. g n * unity_root k (int x * int n)) k\\<rbrakk>\n  \\<Longrightarrow> f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "show \"f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))\""], ["proof (prove)\nusing this:\n  periodic_arithmetic\n   (\\<lambda>x. \\<Sum>n<k. g n * unity_root k (int x * int n)) k\n  0 < k\n  periodic_arithmetic f k\n  ?ma2 \\<in> {0..<k} \\<Longrightarrow>\n  f ?ma2 = (\\<Sum>n<k. g n * unity_root k (int ?ma2 * int n))\n  \\<lbrakk>0 < k;\n   \\<forall>j<k. f j = (\\<Sum>n<k. g n * unity_root k (int j * int n));\n   periodic_arithmetic f k;\n   periodic_arithmetic\n    (\\<lambda>x. \\<Sum>n<k. g n * unity_root k (int x * int n)) k\\<rbrakk>\n  \\<Longrightarrow> f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))\n\ngoal (1 subgoal):\n 1. f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))", "by simp"], ["proof (state)\nthis:\n  f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f m = (\\<Sum>n<k. g n * unity_root k (int m * int n))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem fourier_expansion_periodic_arithmetic_unique:\n  fixes f g :: \"nat \\<Rightarrow> complex\" \n  assumes \"k > 0\"\n  assumes \"periodic_arithmetic f k\" and \"periodic_arithmetic g k\"\n  assumes \"\\<And>m. m < k \\<Longrightarrow> f m = (\\<Sum>n<k. g n * unity_root k (int (m * n)))\" \n  shows   \"g n = (1 / k) * (\\<Sum>m<k. f m * unity_root k (-n * m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "let ?p = \"poly_of_list [g(n). n \\<leftarrow> [0..<k]]\""], ["proof (state)\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "have d: \"degree ?p \\<le> k-1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (poly_of_list (map g [0..<k])) \\<le> k - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (poly_of_list (map g [0..<k])) \\<le> k - 1", "have \"degree ?p \\<le> length [g(n). n \\<leftarrow> [0..<k]] - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (poly_of_list (map g [0..<k])) \\<le> length (map g [0..<k]) - 1", "using degree_poly_of_list_le"], ["proof (prove)\nusing this:\n  degree (poly_of_list ?ws) \\<le> length ?ws - 1\n\ngoal (1 subgoal):\n 1. degree (poly_of_list (map g [0..<k])) \\<le> length (map g [0..<k]) - 1", "by blast"], ["proof (state)\nthis:\n  degree (poly_of_list (map g [0..<k])) \\<le> length (map g [0..<k]) - 1\n\ngoal (1 subgoal):\n 1. degree (poly_of_list (map g [0..<k])) \\<le> k - 1", "also"], ["proof (state)\nthis:\n  degree (poly_of_list (map g [0..<k])) \\<le> length (map g [0..<k]) - 1\n\ngoal (1 subgoal):\n 1. degree (poly_of_list (map g [0..<k])) \\<le> k - 1", "have \"\\<dots> = length [0..<k] - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map g [0..<k]) - 1 = length [0..<k] - 1", "using length_map"], ["proof (prove)\nusing this:\n  length (map ?f ?xs) = length ?xs\n\ngoal (1 subgoal):\n 1. length (map g [0..<k]) - 1 = length [0..<k] - 1", "by auto"], ["proof (state)\nthis:\n  length (map g [0..<k]) - 1 = length [0..<k] - 1\n\ngoal (1 subgoal):\n 1. degree (poly_of_list (map g [0..<k])) \\<le> k - 1", "finally"], ["proof (chain)\npicking this:\n  degree (poly_of_list (map g [0..<k])) \\<le> length [0..<k] - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  degree (poly_of_list (map g [0..<k])) \\<le> length [0..<k] - 1\n\ngoal (1 subgoal):\n 1. degree (poly_of_list (map g [0..<k])) \\<le> k - 1", "by simp"], ["proof (state)\nthis:\n  degree (poly_of_list (map g [0..<k])) \\<le> k - 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  degree (poly_of_list (map g [0..<k])) \\<le> k - 1\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "have c: \"coeff ?p i = (if i < k then g(i) else 0)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (poly_of_list (map g [0..<k])) i = (if i < k then g i else 0)", "by (simp add: nth_default_def)"], ["proof (state)\nthis:\n  coeff (poly_of_list (map g [0..<k])) ?i = (if ?i < k then g ?i else 0)\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "{"], ["proof (state)\nthis:\n  coeff (poly_of_list (map g [0..<k])) ?i = (if ?i < k then g ?i else 0)\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "have \"poly ?p z = (\\<Sum>n\\<le>k-1. coeff ?p n* z^n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (poly_of_list (map g [0..<k])) z =\n    (\\<Sum>n\\<le>k - 1. coeff (poly_of_list (map g [0..<k])) n * z ^ n)", "using poly_altdef'[of ?p \"k-1\"] d"], ["proof (prove)\nusing this:\n  degree (poly_of_list (map g [0..<k])) \\<le> k - 1 \\<Longrightarrow>\n  poly (poly_of_list (map g [0..<k])) ?z =\n  (\\<Sum>i\\<le>k - 1. coeff (poly_of_list (map g [0..<k])) i * ?z ^ i)\n  degree (poly_of_list (map g [0..<k])) \\<le> k - 1\n\ngoal (1 subgoal):\n 1. poly (poly_of_list (map g [0..<k])) z =\n    (\\<Sum>n\\<le>k - 1. coeff (poly_of_list (map g [0..<k])) n * z ^ n)", "by blast"], ["proof (state)\nthis:\n  poly (poly_of_list (map g [0..<k])) z =\n  (\\<Sum>n\\<le>k - 1. coeff (poly_of_list (map g [0..<k])) n * z ^ n)\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "also"], ["proof (state)\nthis:\n  poly (poly_of_list (map g [0..<k])) z =\n  (\\<Sum>n\\<le>k - 1. coeff (poly_of_list (map g [0..<k])) n * z ^ n)\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "have \"\\<dots> = (\\<Sum>n<k. coeff ?p n* z^n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n\\<le>k - 1. coeff (poly_of_list (map g [0..<k])) n * z ^ n) =\n    (\\<Sum>n<k. coeff (poly_of_list (map g [0..<k])) n * z ^ n)", "using \\<open>k > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < k\n\ngoal (1 subgoal):\n 1. (\\<Sum>n\\<le>k - 1. coeff (poly_of_list (map g [0..<k])) n * z ^ n) =\n    (\\<Sum>n<k. coeff (poly_of_list (map g [0..<k])) n * z ^ n)", "by (intro sum.cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>n\\<le>k - 1. coeff (poly_of_list (map g [0..<k])) n * z ^ n) =\n  (\\<Sum>n<k. coeff (poly_of_list (map g [0..<k])) n * z ^ n)\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "also"], ["proof (state)\nthis:\n  (\\<Sum>n\\<le>k - 1. coeff (poly_of_list (map g [0..<k])) n * z ^ n) =\n  (\\<Sum>n<k. coeff (poly_of_list (map g [0..<k])) n * z ^ n)\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "have \"\\<dots> = (\\<Sum>n<k. (if n < k then g(n) else 0)* z^n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n<k. coeff (poly_of_list (map g [0..<k])) n * z ^ n) =\n    (\\<Sum>n<k. (if n < k then g n else 0) * z ^ n)", "using c"], ["proof (prove)\nusing this:\n  coeff (poly_of_list (map g [0..<k])) ?i = (if ?i < k then g ?i else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>n<k. coeff (poly_of_list (map g [0..<k])) n * z ^ n) =\n    (\\<Sum>n<k. (if n < k then g n else 0) * z ^ n)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>n<k. coeff (poly_of_list (map g [0..<k])) n * z ^ n) =\n  (\\<Sum>n<k. (if n < k then g n else 0) * z ^ n)\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "also"], ["proof (state)\nthis:\n  (\\<Sum>n<k. coeff (poly_of_list (map g [0..<k])) n * z ^ n) =\n  (\\<Sum>n<k. (if n < k then g n else 0) * z ^ n)\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "have \"\\<dots> = (\\<Sum>n<k. g(n)* z^n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n<k. (if n < k then g n else 0) * z ^ n) =\n    (\\<Sum>n<k. g n * z ^ n)", "by (simp split: if_splits)"], ["proof (state)\nthis:\n  (\\<Sum>n<k. (if n < k then g n else 0) * z ^ n) = (\\<Sum>n<k. g n * z ^ n)\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "finally"], ["proof (chain)\npicking this:\n  poly (poly_of_list (map g [0..<k])) z = (\\<Sum>n<k. g n * z ^ n)", "have \"poly ?p z = (\\<Sum>n<k. g n * z ^ n)\""], ["proof (prove)\nusing this:\n  poly (poly_of_list (map g [0..<k])) z = (\\<Sum>n<k. g n * z ^ n)\n\ngoal (1 subgoal):\n 1. poly (poly_of_list (map g [0..<k])) z = (\\<Sum>n<k. g n * z ^ n)", "."], ["proof (state)\nthis:\n  poly (poly_of_list (map g [0..<k])) z = (\\<Sum>n<k. g n * z ^ n)\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "}"], ["proof (state)\nthis:\n  poly (poly_of_list (map g [0..<k])) ?z2 = (\\<Sum>n<k. g n * ?z2 ^ n)\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "note eval = this"], ["proof (state)\nthis:\n  poly (poly_of_list (map g [0..<k])) ?z2 = (\\<Sum>n<k. g n * ?z2 ^ n)\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "{"], ["proof (state)\nthis:\n  poly (poly_of_list (map g [0..<k])) ?z2 = (\\<Sum>n<k. g n * ?z2 ^ n)\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "have \"poly ?p (unity_root k i) = (\\<Sum>n<k. g(n)* (unity_root k i)^n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (poly_of_list (map g [0..<k])) (unity_root k i) =\n    (\\<Sum>n<k. g n * unity_root k i ^ n)", "using eval"], ["proof (prove)\nusing this:\n  poly (poly_of_list (map g [0..<k])) ?z2 = (\\<Sum>n<k. g n * ?z2 ^ n)\n\ngoal (1 subgoal):\n 1. poly (poly_of_list (map g [0..<k])) (unity_root k i) =\n    (\\<Sum>n<k. g n * unity_root k i ^ n)", "by blast"], ["proof (state)\nthis:\n  poly (poly_of_list (map g [0..<k])) (unity_root k i) =\n  (\\<Sum>n<k. g n * unity_root k i ^ n)\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "then"], ["proof (chain)\npicking this:\n  poly (poly_of_list (map g [0..<k])) (unity_root k i) =\n  (\\<Sum>n<k. g n * unity_root k i ^ n)", "have \"poly ?p (unity_root k i) = (\\<Sum>n<k. g(n)* (unity_root k (i*n)))\""], ["proof (prove)\nusing this:\n  poly (poly_of_list (map g [0..<k])) (unity_root k i) =\n  (\\<Sum>n<k. g n * unity_root k i ^ n)\n\ngoal (1 subgoal):\n 1. poly (poly_of_list (map g [0..<k])) (unity_root k i) =\n    (\\<Sum>n<k. g n * unity_root k (i * int n))", "using unity_root_pow"], ["proof (prove)\nusing this:\n  poly (poly_of_list (map g [0..<k])) (unity_root k i) =\n  (\\<Sum>n<k. g n * unity_root k i ^ n)\n  unity_root ?k ?n ^ ?m = unity_root ?k (?n * int ?m)\n\ngoal (1 subgoal):\n 1. poly (poly_of_list (map g [0..<k])) (unity_root k i) =\n    (\\<Sum>n<k. g n * unity_root k (i * int n))", "by auto"], ["proof (state)\nthis:\n  poly (poly_of_list (map g [0..<k])) (unity_root k i) =\n  (\\<Sum>n<k. g n * unity_root k (i * int n))\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "}"], ["proof (state)\nthis:\n  poly (poly_of_list (map g [0..<k])) (unity_root k ?i2) =\n  (\\<Sum>n<k. g n * unity_root k (?i2 * int n))\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "note interpolation = this"], ["proof (state)\nthis:\n  poly (poly_of_list (map g [0..<k])) (unity_root k ?i2) =\n  (\\<Sum>n<k. g n * unity_root k (?i2 * int n))\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "{"], ["proof (state)\nthis:\n  poly (poly_of_list (map g [0..<k])) (unity_root k ?i2) =\n  (\\<Sum>n<k. g n * unity_root k (?i2 * int n))\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "assume b: \"m \\<le> k-1\""], ["proof (state)\nthis:\n  m \\<le> k - 1\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "from d assms(1)"], ["proof (chain)\npicking this:\n  degree (poly_of_list (map g [0..<k])) \\<le> k - 1\n  0 < k", "have \"f m = (\\<Sum>n<k. g(n) * unity_root k (m*n))\""], ["proof (prove)\nusing this:\n  degree (poly_of_list (map g [0..<k])) \\<le> k - 1\n  0 < k\n\ngoal (1 subgoal):\n 1. f m = (\\<Sum>n<k. g n * unity_root k (int (m * n)))", "using assms(4) b"], ["proof (prove)\nusing this:\n  degree (poly_of_list (map g [0..<k])) \\<le> k - 1\n  0 < k\n  ?m < k \\<Longrightarrow>\n  f ?m = (\\<Sum>n<k. g n * unity_root k (int (?m * n)))\n  m \\<le> k - 1\n\ngoal (1 subgoal):\n 1. f m = (\\<Sum>n<k. g n * unity_root k (int (m * n)))", "by auto"], ["proof (state)\nthis:\n  f m = (\\<Sum>n<k. g n * unity_root k (int (m * n)))\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "also"], ["proof (state)\nthis:\n  f m = (\\<Sum>n<k. g n * unity_root k (int (m * n)))\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "have \"\\<dots> = poly ?p (unity_root k m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n<k. g n * unity_root k (int (m * n))) =\n    poly (poly_of_list (map g [0..<k])) (unity_root k (int m))", "using interpolation"], ["proof (prove)\nusing this:\n  poly (poly_of_list (map g [0..<k])) (unity_root k ?i2) =\n  (\\<Sum>n<k. g n * unity_root k (?i2 * int n))\n\ngoal (1 subgoal):\n 1. (\\<Sum>n<k. g n * unity_root k (int (m * n))) =\n    poly (poly_of_list (map g [0..<k])) (unity_root k (int m))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>n<k. g n * unity_root k (int (m * n))) =\n  poly (poly_of_list (map g [0..<k])) (unity_root k (int m))\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "finally"], ["proof (chain)\npicking this:\n  f m = poly (poly_of_list (map g [0..<k])) (unity_root k (int m))", "have \"f m = poly ?p (unity_root k m)\""], ["proof (prove)\nusing this:\n  f m = poly (poly_of_list (map g [0..<k])) (unity_root k (int m))\n\ngoal (1 subgoal):\n 1. f m = poly (poly_of_list (map g [0..<k])) (unity_root k (int m))", "by auto"], ["proof (state)\nthis:\n  f m = poly (poly_of_list (map g [0..<k])) (unity_root k (int m))\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "}"], ["proof (state)\nthis:\n  ?m2 \\<le> k - 1 \\<Longrightarrow>\n  f ?m2 = poly (poly_of_list (map g [0..<k])) (unity_root k (int ?m2))\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "from this finite_fourier_poly'_unique[of k _ f]"], ["proof (chain)\npicking this:\n  ?m2 \\<le> k - 1 \\<Longrightarrow>\n  f ?m2 = poly (poly_of_list (map g [0..<k])) (unity_root k (int ?m2))\n  \\<lbrakk>0 < k; degree ?p \\<le> k - 1;\n   \\<forall>m\\<le>k - 1. f m = poly ?p (unity_root k (int m))\\<rbrakk>\n  \\<Longrightarrow> ?p = finite_fourier_poly' f k", "have p_is_fourier: \"?p = finite_fourier_poly' f k\""], ["proof (prove)\nusing this:\n  ?m2 \\<le> k - 1 \\<Longrightarrow>\n  f ?m2 = poly (poly_of_list (map g [0..<k])) (unity_root k (int ?m2))\n  \\<lbrakk>0 < k; degree ?p \\<le> k - 1;\n   \\<forall>m\\<le>k - 1. f m = poly ?p (unity_root k (int m))\\<rbrakk>\n  \\<Longrightarrow> ?p = finite_fourier_poly' f k\n\ngoal (1 subgoal):\n 1. poly_of_list (map g [0..<k]) = finite_fourier_poly' f k", "using assms(1) d"], ["proof (prove)\nusing this:\n  ?m2 \\<le> k - 1 \\<Longrightarrow>\n  f ?m2 = poly (poly_of_list (map g [0..<k])) (unity_root k (int ?m2))\n  \\<lbrakk>0 < k; degree ?p \\<le> k - 1;\n   \\<forall>m\\<le>k - 1. f m = poly ?p (unity_root k (int m))\\<rbrakk>\n  \\<Longrightarrow> ?p = finite_fourier_poly' f k\n  0 < k\n  degree (poly_of_list (map g [0..<k])) \\<le> k - 1\n\ngoal (1 subgoal):\n 1. poly_of_list (map g [0..<k]) = finite_fourier_poly' f k", "by blast"], ["proof (state)\nthis:\n  poly_of_list (map g [0..<k]) = finite_fourier_poly' f k\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "{"], ["proof (state)\nthis:\n  poly_of_list (map g [0..<k]) = finite_fourier_poly' f k\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "assume b: \"n \\<le> k-1\""], ["proof (state)\nthis:\n  n \\<le> k - 1\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "have f_1: \"coeff ?p n = (1 / k) * (\\<Sum>m<k. f(m) * unity_root k (-n*m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (poly_of_list (map g [0..<k])) n =\n    complex_of_real (1 / real k) *\n    (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "using p_is_fourier"], ["proof (prove)\nusing this:\n  poly_of_list (map g [0..<k]) = finite_fourier_poly' f k\n\ngoal (1 subgoal):\n 1. coeff (poly_of_list (map g [0..<k])) n =\n    complex_of_real (1 / real k) *\n    (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "using assms(1) b"], ["proof (prove)\nusing this:\n  poly_of_list (map g [0..<k]) = finite_fourier_poly' f k\n  0 < k\n  n \\<le> k - 1\n\ngoal (1 subgoal):\n 1. coeff (poly_of_list (map g [0..<k])) n =\n    complex_of_real (1 / real k) *\n    (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "by (auto simp: coeff_finite_fourier_poly')"], ["proof (state)\nthis:\n  coeff (poly_of_list (map g [0..<k])) n =\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. f m * unity_root k (- int n * int m))\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "then"], ["proof (chain)\npicking this:\n  coeff (poly_of_list (map g [0..<k])) n =\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "have \"g(n) = (1 / k) * (\\<Sum>m<k. f(m) * unity_root k (-n*m))\""], ["proof (prove)\nusing this:\n  coeff (poly_of_list (map g [0..<k])) n =\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. f m * unity_root k (- int n * int m))\n\ngoal (1 subgoal):\n 1. g n =\n    complex_of_real (1 / real k) *\n    (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "using c b assms(1)"], ["proof (prove)\nusing this:\n  coeff (poly_of_list (map g [0..<k])) n =\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. f m * unity_root k (- int n * int m))\n  coeff (poly_of_list (map g [0..<k])) ?i = (if ?i < k then g ?i else 0)\n  n \\<le> k - 1\n  0 < k\n\ngoal (1 subgoal):\n 1. g n =\n    complex_of_real (1 / real k) *\n    (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>coeff (poly_of_list (map g [0..<k])) n =\n             complex_of_real (1 / real k) *\n             (\\<Sum>m<k. f m * unity_root k (- int n * int m));\n     \\<And>i.\n        coeff (poly_of_list (map g [0..<k])) i = (if i < k then g i else 0);\n     n \\<le> k - 1; 0 < k\\<rbrakk>\n    \\<Longrightarrow> g n =\n                      complex_of_real (1 / real k) *\n                      (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "have 1: \"coeff ?p n = (1 / k) * (\\<Sum>m<k. f(m) * unity_root k (-n*m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (poly_of_list (map g [0..<k])) n =\n    complex_of_real (1 / real k) *\n    (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "using f_1"], ["proof (prove)\nusing this:\n  coeff (poly_of_list (map g [0..<k])) n =\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. f m * unity_root k (- int n * int m))\n\ngoal (1 subgoal):\n 1. coeff (poly_of_list (map g [0..<k])) n =\n    complex_of_real (1 / real k) *\n    (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "by blast"], ["proof (state)\nthis:\n  coeff (poly_of_list (map g [0..<k])) n =\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. f m * unity_root k (- int n * int m))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>coeff (poly_of_list (map g [0..<k])) n =\n             complex_of_real (1 / real k) *\n             (\\<Sum>m<k. f m * unity_root k (- int n * int m));\n     \\<And>i.\n        coeff (poly_of_list (map g [0..<k])) i = (if i < k then g i else 0);\n     n \\<le> k - 1; 0 < k\\<rbrakk>\n    \\<Longrightarrow> g n =\n                      complex_of_real (1 / real k) *\n                      (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "have 2: \"coeff ?p n =  g n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff (poly_of_list (map g [0..<k])) n = g n", "using c assms(1) b"], ["proof (prove)\nusing this:\n  coeff (poly_of_list (map g [0..<k])) ?i = (if ?i < k then g ?i else 0)\n  0 < k\n  n \\<le> k - 1\n\ngoal (1 subgoal):\n 1. coeff (poly_of_list (map g [0..<k])) n = g n", "by simp"], ["proof (state)\nthis:\n  coeff (poly_of_list (map g [0..<k])) n = g n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>coeff (poly_of_list (map g [0..<k])) n =\n             complex_of_real (1 / real k) *\n             (\\<Sum>m<k. f m * unity_root k (- int n * int m));\n     \\<And>i.\n        coeff (poly_of_list (map g [0..<k])) i = (if i < k then g i else 0);\n     n \\<le> k - 1; 0 < k\\<rbrakk>\n    \\<Longrightarrow> g n =\n                      complex_of_real (1 / real k) *\n                      (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. g n =\n    complex_of_real (1 / real k) *\n    (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "using 1 2"], ["proof (prove)\nusing this:\n  coeff (poly_of_list (map g [0..<k])) n =\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. f m * unity_root k (- int n * int m))\n  coeff (poly_of_list (map g [0..<k])) n = g n\n\ngoal (1 subgoal):\n 1. g n =\n    complex_of_real (1 / real k) *\n    (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "by argo"], ["proof (state)\nthis:\n  g n =\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. f m * unity_root k (- int n * int m))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g n =\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. f m * unity_root k (- int n * int m))\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "}"], ["proof (state)\nthis:\n  ?na2 \\<le> k - 1 \\<Longrightarrow>\n  g ?na2 =\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. f m * unity_root k (- int ?na2 * int m))\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "(* now show right hand side is periodic and use unique_periodic_extension *)"], ["proof (state)\nthis:\n  ?na2 \\<le> k - 1 \\<Longrightarrow>\n  g ?na2 =\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. f m * unity_root k (- int ?na2 * int m))\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "have \"periodic_arithmetic (\\<lambda>n. (1 / k) * (\\<Sum>m<k. f(m) * unity_root k (-n*m))) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic\n     (\\<lambda>n.\n         complex_of_real (1 / real k) *\n         (\\<Sum>m<k. f m * unity_root k (- int n * int m)))\n     k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. periodic_arithmetic\n     (\\<lambda>n.\n         complex_of_real (1 / real k) *\n         (\\<Sum>m<k. f m * unity_root k (- int n * int m)))\n     k", "have \"periodic_arithmetic (\\<lambda>i. unity_root k (-int i*int m)) k\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>i. unity_root k (- int i * int m)) k", "using unity_root_periodic_arithmetic_mult_minus"], ["proof (prove)\nusing this:\n  periodic_arithmetic (\\<lambda>i. unity_root ?k (- int i * int ?m)) ?k\n\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>i. unity_root k (- int i * int m)) k", "by simp"], ["proof (state)\nthis:\n  periodic_arithmetic (\\<lambda>i. unity_root k (- int i * int ?m)) k\n\ngoal (1 subgoal):\n 1. periodic_arithmetic\n     (\\<lambda>n.\n         complex_of_real (1 / real k) *\n         (\\<Sum>m<k. f m * unity_root k (- int n * int m)))\n     k", "then"], ["proof (chain)\npicking this:\n  periodic_arithmetic (\\<lambda>i. unity_root k (- int i * int ?m)) k", "have \"periodic_arithmetic (\\<lambda>i. f(m) * unity_root k (-i*m)) k\" for m"], ["proof (prove)\nusing this:\n  periodic_arithmetic (\\<lambda>i. unity_root k (- int i * int ?m)) k\n\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>i. f m * unity_root k (- int i * int m)) k", "by (simp add: periodic_arithmetic_def)"], ["proof (state)\nthis:\n  periodic_arithmetic (\\<lambda>i. f ?m * unity_root k (- int i * int ?m)) k\n\ngoal (1 subgoal):\n 1. periodic_arithmetic\n     (\\<lambda>n.\n         complex_of_real (1 / real k) *\n         (\\<Sum>m<k. f m * unity_root k (- int n * int m)))\n     k", "then"], ["proof (chain)\npicking this:\n  periodic_arithmetic (\\<lambda>i. f ?m * unity_root k (- int i * int ?m)) k", "show \"periodic_arithmetic (\\<lambda>i. (1 / k) * (\\<Sum>m<k. f m * unity_root k (-i*m))) k\""], ["proof (prove)\nusing this:\n  periodic_arithmetic (\\<lambda>i. f ?m * unity_root k (- int i * int ?m)) k\n\ngoal (1 subgoal):\n 1. periodic_arithmetic\n     (\\<lambda>i.\n         complex_of_real (1 / real k) *\n         (\\<Sum>m<k. f m * unity_root k (- int i * int m)))\n     k", "by (intro scalar_mult_periodic_arithmetic fin_sum_periodic_arithmetic_set) auto"], ["proof (state)\nthis:\n  periodic_arithmetic\n   (\\<lambda>i.\n       complex_of_real (1 / real k) *\n       (\\<Sum>m<k. f m * unity_root k (- int i * int m)))\n   k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  periodic_arithmetic\n   (\\<lambda>n.\n       complex_of_real (1 / real k) *\n       (\\<Sum>m<k. f m * unity_root k (- int n * int m)))\n   k\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "note periodich = this"], ["proof (state)\nthis:\n  periodic_arithmetic\n   (\\<lambda>n.\n       complex_of_real (1 / real k) *\n       (\\<Sum>m<k. f m * unity_root k (- int n * int m)))\n   k\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "let ?h = \"(\\<lambda>i. (1 / k) *(\\<Sum>m<k. f m * unity_root k (-i*m)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "from unique_periodic_arithmetic_extension[of k g ?h n] \n        assms(3) assms(1) periodich"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < k;\n   \\<forall>j<k.\n      g j =\n      complex_of_real (1 / real k) *\n      (\\<Sum>m<k. f m * unity_root k (- int j * int m));\n   periodic_arithmetic g k;\n   periodic_arithmetic\n    (\\<lambda>x.\n        complex_of_real (1 / real k) *\n        (\\<Sum>m<k. f m * unity_root k (- int x * int m)))\n    k\\<rbrakk>\n  \\<Longrightarrow> g n =\n                    complex_of_real (1 / real k) *\n                    (\\<Sum>m<k. f m * unity_root k (- int n * int m))\n  periodic_arithmetic g k\n  0 < k\n  periodic_arithmetic\n   (\\<lambda>n.\n       complex_of_real (1 / real k) *\n       (\\<Sum>m<k. f m * unity_root k (- int n * int m)))\n   k", "have \"g n = (1/k) * (\\<Sum>m<k. f m * unity_root k (-n*m))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < k;\n   \\<forall>j<k.\n      g j =\n      complex_of_real (1 / real k) *\n      (\\<Sum>m<k. f m * unity_root k (- int j * int m));\n   periodic_arithmetic g k;\n   periodic_arithmetic\n    (\\<lambda>x.\n        complex_of_real (1 / real k) *\n        (\\<Sum>m<k. f m * unity_root k (- int x * int m)))\n    k\\<rbrakk>\n  \\<Longrightarrow> g n =\n                    complex_of_real (1 / real k) *\n                    (\\<Sum>m<k. f m * unity_root k (- int n * int m))\n  periodic_arithmetic g k\n  0 < k\n  periodic_arithmetic\n   (\\<lambda>n.\n       complex_of_real (1 / real k) *\n       (\\<Sum>m<k. f m * unity_root k (- int n * int m)))\n   k\n\ngoal (1 subgoal):\n 1. g n =\n    complex_of_real (1 / real k) *\n    (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "by (simp add: \\<open>\\<And>na. na \\<le> k - 1 \\<Longrightarrow> g na = complex_of_real (1 / real k) * (\\<Sum>m<k. f m * unity_root k (- int na * int m))\\<close>)"], ["proof (state)\nthis:\n  g n =\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. f m * unity_root k (- int n * int m))\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "then"], ["proof (chain)\npicking this:\n  g n =\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "show ?thesis"], ["proof (prove)\nusing this:\n  g n =\n  complex_of_real (1 / real k) *\n  (\\<Sum>m<k. f m * unity_root k (- int n * int m))\n\ngoal (1 subgoal):\n 1. g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))", "by simp"], ["proof (state)\nthis:\n  g n = 1 / of_nat k * (\\<Sum>m<k. f m * unity_root k (- int n * int m))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}