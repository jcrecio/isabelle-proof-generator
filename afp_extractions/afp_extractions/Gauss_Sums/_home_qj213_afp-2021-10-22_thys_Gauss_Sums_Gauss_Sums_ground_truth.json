{"file_name": "/home/qj213/afp-2021-10-22/thys/Gauss_Sums/Gauss_Sums.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Gauss_Sums", "problem_names": ["lemma dir_periodic_arithmetic: \"periodic_arithmetic \\<chi> n\"", "lemma gauss_sum_periodic: \n  \"periodic_arithmetic (\\<lambda>n. gauss_sum n) n\"", "lemma ramanujan_sum_conv_gauss_sum:\n  assumes \"\\<chi> = principal_dchar n\"\n  shows \"ramanujan_sum n k = gauss_sum k\"", "lemma cnj_mult_self:\n  assumes \"coprime k n\"\n  shows \"cnj (\\<chi> k) * \\<chi> k = 1\"", "theorem gauss_sum_reduction:\n  assumes \"coprime k n\" \n  shows \"gauss_sum k = cnj (\\<chi> k) * gauss_sum 1\"", "lemma gauss_sum_int_cong:\n  assumes \"[a = b] (mod int n)\"\n  shows   \"gauss_sum_int a = gauss_sum_int b\"", "lemma gauss_sum_conv_gauss_sum_int:\n  \"gauss_sum k = gauss_sum_int (int k)\"", "lemma gauss_sum_int_conv_gauss_sum:\n  \"gauss_sum_int k = gauss_sum (nat (k mod n))\"", "lemma gauss_int_periodic: \"periodic_arithmetic gauss_sum_int n\"", "theorem global_separability_condition:\n  \"(\\<forall>n>0. separable n) \\<longleftrightarrow> (\\<forall>k>0. \\<not>coprime k n \\<longrightarrow> gauss_sum k = 0)\"", "lemma of_real_moebius_mu [simp]: \"of_real (moebius_mu k) = moebius_mu k\"", "theorem gauss_sum_1_mod_square_eq_k: \n  assumes \"(\\<forall>k. k > 0 \\<longrightarrow> separable k)\" \n  shows \"norm (gauss_sum 1) ^ 2 = real n\"", "theorem gauss_sum_nonzero_noncoprime_necessary_condition:\n  assumes \"gauss_sum k \\<noteq> 0\" \"\\<not>coprime k n\" \"k > 0\"\n  defines \"d \\<equiv> n div gcd k n\"  \n  assumes \"coprime a n\" \"[a = 1] (mod d)\" \n  shows   \"d dvd n\" \"d < n\" \"\\<chi> a = 1\"", "lemma induced_modulus_dvd: \"induced_modulus d \\<Longrightarrow> d dvd n\"", "lemma induced_modulusI [intro?]:\n  \"d dvd n \\<Longrightarrow> (\\<And>a. coprime a n \\<Longrightarrow> [a = 1] (mod d) \\<Longrightarrow> \\<chi> a = 1) \\<Longrightarrow> induced_modulus d\"", "lemma induced_modulusD: \"induced_modulus d \\<Longrightarrow> coprime a n \\<Longrightarrow> [a = 1] (mod d) \\<Longrightarrow> \\<chi> a = 1\"", "lemma zero_not_ind_mod: \"\\<not>induced_modulus 0\"", "lemma div_gcd_dvd1: \"(a :: 'a :: semiring_gcd) div gcd a b dvd a\"", "lemma div_gcd_dvd2: \"(b :: 'a :: semiring_gcd) div gcd a b dvd b\"", "lemma g_non_zero_ind_mod:\n  assumes \"gauss_sum k \\<noteq> 0\" \"\\<not>coprime k n\" \"k > 0\"\n  shows  \"induced_modulus (n div gcd k n)\"", "lemma induced_modulus_modulus: \"induced_modulus n\"", "theorem one_induced_iff_principal:\n \"induced_modulus 1 \\<longleftrightarrow> \\<chi> = principal_dchar n\"", "lemma (in nonprimitive_dchar) nonprimitive: \"\\<not>primitive_dchar n \\<chi>\"", "lemma (in dcharacter) primitive_dchar_iff:\n  \"primitive_dchar n \\<chi> \\<longleftrightarrow> \\<not>(\\<exists>d<n. induced_modulus d)\"", "lemma (in residues_nat) principal_not_primitive: \n  \"\\<not>primitive_dchar n (principal_dchar n)\"", "lemma (in dcharacter) not_primitive_imp_nonprimitive:\n  assumes \"\\<not>primitive_dchar n \\<chi>\"\n  shows   \"nonprimitive_dchar n \\<chi>\"", "theorem (in dcharacter) prime_nonprincipal_is_primitive:\n  assumes \"prime n\"\n  assumes \"\\<chi> \\<noteq> principal_dchar n\" \n  shows   \"primitive_dchar n \\<chi>\"", "lemma (in dcharacter) induced_modulus_altdef1:\n  \"induced_modulus d \\<longleftrightarrow>\n     d dvd n \\<and> (\\<forall>a b. coprime a n \\<and> coprime b n \\<and> [a = b] (mod d) \\<longrightarrow> \\<chi> a = \\<chi> b)\"", "lemma induced_modulus_altdef2_lemma:\n  fixes n a d q :: nat\n  defines \"q \\<equiv> (\\<Prod> p | prime p \\<and> p dvd n \\<and> \\<not> (p dvd a). p)\"\n  defines \"m \\<equiv> a + q * d\"\n  assumes \"n > 0\" \"coprime a d\"\n  shows \"[m = a] (mod d)\" and \"coprime m n\"", "theorem (in dcharacter) induced_modulus_altdef2:\n  assumes \"d dvd n\" \"d \\<noteq> 1\" \n  defines \"\\<chi>\\<^sub>1 \\<equiv> principal_dchar n\"\n  shows \"induced_modulus d \\<longleftrightarrow> (\\<exists>\\<Phi>. dcharacter d \\<Phi> \\<and> (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k))\"", "lemma conductor_fin: \"finite {d. induced_modulus d}\"", "lemma conductor_induced: \"induced_modulus conductor\"", "lemma conductor_le_iff: \"conductor \\<le> a \\<longleftrightarrow> (\\<exists>d\\<le>a. induced_modulus d)\"", "lemma conductor_ge_iff: \"conductor \\<ge> a \\<longleftrightarrow> (\\<forall>d. induced_modulus d \\<longrightarrow> d \\<ge> a)\"", "lemma conductor_leI: \"induced_modulus d \\<Longrightarrow> conductor \\<le> d\"", "lemma conductor_geI: \"(\\<And>d. induced_modulus d \\<Longrightarrow> d \\<ge> a) \\<Longrightarrow> conductor \\<ge> a\"", "lemma conductor_dvd: \"conductor dvd n\"", "lemma conductor_le_modulus: \"conductor \\<le> n\"", "lemma conductor_gr_0: \"conductor > 0\"", "lemma conductor_eq_1_iff_principal: \"conductor = 1 \\<longleftrightarrow> \\<chi> = principal_dchar n\"", "lemma conductor_principal [simp]: \"\\<chi> = principal_dchar n \\<Longrightarrow> conductor = 1\"", "lemma nonprimitive_imp_conductor_less:\n  assumes \"\\<not>primitive_dchar n \\<chi>\"\n  shows \"conductor < n\"", "lemma (in nonprimitive_dchar) conductor_less_modulus: \"conductor < n\"", "theorem primitive_principal_form:\n  defines \"\\<chi>\\<^sub>1 \\<equiv> principal_dchar n\"\n  assumes \"\\<chi> \\<noteq> principal_dchar n\"\n  shows \"\\<exists>\\<Phi>. primitive_dchar conductor \\<Phi> \\<and> (\\<forall>n. \\<chi>(n) = \\<Phi>(n) * \\<chi>\\<^sub>1(n))\"", "lemma\n  assumes nonprincipal: \"\\<chi> \\<noteq> principal_dchar n\"\n  shows primitive_primitive_extension: \"primitive_dchar conductor primitive_extension\"\n    and principal_decomposition:       \"\\<chi> k = primitive_extension k * principal_dchar n k\"", "lemma residue_mult_group_coset:\n  fixes m n m1 m2 :: nat and f :: \"nat \\<Rightarrow> nat\" and G H\n  defines \"G \\<equiv> residue_mult_group n\"\n  defines \"H \\<equiv> residue_mult_group m\"\n  defines \"f \\<equiv> (\\<lambda>k. k mod m)\"\n  assumes \"b \\<in> (rcosets\\<^bsub>G\\<^esub> kernel G H f)\"\n  assumes \"m1 \\<in> b\" \"m2 \\<in> b\"\n  assumes \"n > 1\" \"m dvd n\"\n  shows \"m1 mod m = m2 mod m\"", "lemma residue_mult_group_kernel_partition:\n  fixes m n :: nat and f :: \"nat \\<Rightarrow> nat\" and G H\n  defines \"G \\<equiv> residue_mult_group n\"\n  defines \"H \\<equiv> residue_mult_group m\"\n  defines \"f \\<equiv> (\\<lambda>k. k mod m)\"\n  assumes \"m > 1\" \"n > 0\" \"m dvd n\" \n  shows \"partition (carrier G) (rcosets\\<^bsub>G\\<^esub> kernel G H f)\"\n        and \"card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\"\n        and \"card (kernel G H f) = totient n div totient m\"\n        and \"b \\<in>(rcosets\\<^bsub>G\\<^esub> kernel G H f) \\<Longrightarrow> b \\<noteq> {}\"\n        and \"b \\<in>(rcosets\\<^bsub>G\\<^esub> kernel G H f) \\<Longrightarrow> card (kernel G H f) = card b\"\n        and \"bij_betw (\\<lambda>b. (the_elem (f ` b))) (rcosets\\<^bsub>G\\<^esub> kernel G H f) (carrier H)\"", "lemma primitive_iff_separable_lemma:\n assumes prod: \"(\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n) \\<and> primitive_dchar d \\<Phi>\"\n assumes \\<open>d > 1\\<close> \\<open>0 < k\\<close> \\<open>d dvd k\\<close> \\<open>k > 1\\<close>\n shows \"(\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k. \\<Phi>(m) * unity_root d m) =\n        (totient k div totient d) * (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d. \\<Phi>(m) * unity_root d m)\"", "theorem (in dcharacter) primitive_iff_separable:\n  \"primitive_dchar n \\<chi> \\<longleftrightarrow> (\\<forall>k>0. separable k)\"", "theorem (in primitive_dchar) fourier_primitive:\n  includes no_vec_lambda_notation\n  fixes \\<tau> :: complex\n  defines \"\\<tau> \\<equiv> gauss_sum 1 / sqrt n\"\n  shows   \"\\<chi> m = \\<tau> / sqrt n * (\\<Sum>k=1..n. cnj (\\<chi> k) * unity_root n (-m*k))\"\n  and     \"norm \\<tau> = 1\""], "translations": [["", "lemma dir_periodic_arithmetic: \"periodic_arithmetic \\<chi> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic \\<chi> n", "unfolding periodic_arithmetic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. \\<chi> (n + n) = \\<chi> n", "by (simp add: periodic)"], ["", "definition \"gauss_sum k = (\\<Sum>m = 1..n . \\<chi>(m) * unity_root n (m*k))\""], ["", "lemma gauss_sum_periodic: \n  \"periodic_arithmetic (\\<lambda>n. gauss_sum n) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic gauss_sum n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. periodic_arithmetic gauss_sum n", "have \"periodic_arithmetic \\<chi> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic \\<chi> n", "using dir_periodic_arithmetic"], ["proof (prove)\nusing this:\n  periodic_arithmetic \\<chi> n\n\ngoal (1 subgoal):\n 1. periodic_arithmetic \\<chi> n", "by simp"], ["proof (state)\nthis:\n  periodic_arithmetic \\<chi> n\n\ngoal (1 subgoal):\n 1. periodic_arithmetic gauss_sum n", "let ?h = \"\\<lambda>m k. \\<chi>(m) * unity_root n (m*k)\""], ["proof (state)\ngoal (1 subgoal):\n 1. periodic_arithmetic gauss_sum n", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. periodic_arithmetic gauss_sum n", "fix m :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. periodic_arithmetic gauss_sum n", "have \"periodic_arithmetic (\\<lambda>k. unity_root n (m*k)) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>k. unity_root n (int (m * k))) n", "using unity_periodic_arithmetic_mult[of n m]"], ["proof (prove)\nusing this:\n  periodic_arithmetic (\\<lambda>n. unity_root n (int m * int n)) n\n\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>k. unity_root n (int (m * k))) n", "by simp"], ["proof (state)\nthis:\n  periodic_arithmetic (\\<lambda>k. unity_root n (int (m * k))) n\n\ngoal (1 subgoal):\n 1. periodic_arithmetic gauss_sum n", "have \"periodic_arithmetic (?h m) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>k. \\<chi> m * unity_root n (int (m * k)))\n     n", "using scalar_mult_periodic_arithmetic[OF \\<open>periodic_arithmetic (\\<lambda>k. unity_root n (m*k)) n\\<close>]"], ["proof (prove)\nusing this:\n  periodic_arithmetic (\\<lambda>n. ?a * unity_root n (int (m * n))) n\n\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>k. \\<chi> m * unity_root n (int (m * k)))\n     n", "by blast"], ["proof (state)\nthis:\n  periodic_arithmetic (\\<lambda>k. \\<chi> m * unity_root n (int (m * k))) n\n\ngoal (1 subgoal):\n 1. periodic_arithmetic gauss_sum n", "}"], ["proof (state)\nthis:\n  periodic_arithmetic\n   (\\<lambda>k. \\<chi> ?m2 * unity_root n (int (?m2 * k))) n\n\ngoal (1 subgoal):\n 1. periodic_arithmetic gauss_sum n", "then"], ["proof (chain)\npicking this:\n  periodic_arithmetic\n   (\\<lambda>k. \\<chi> ?m2 * unity_root n (int (?m2 * k))) n", "have per_all: \"\\<forall>m \\<in> {1..n}. periodic_arithmetic (?h m) n\""], ["proof (prove)\nusing this:\n  periodic_arithmetic\n   (\\<lambda>k. \\<chi> ?m2 * unity_root n (int (?m2 * k))) n\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>{1..n}.\n       periodic_arithmetic\n        (\\<lambda>k. \\<chi> m * unity_root n (int (m * k))) n", "by blast"], ["proof (state)\nthis:\n  \\<forall>m\\<in>{1..n}.\n     periodic_arithmetic (\\<lambda>k. \\<chi> m * unity_root n (int (m * k)))\n      n\n\ngoal (1 subgoal):\n 1. periodic_arithmetic gauss_sum n", "have \"periodic_arithmetic (\\<lambda>k. (\\<Sum>m = 1..n . \\<chi>(m) * unity_root n (m*k))) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic\n     (\\<lambda>k. \\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k))) n", "using fin_sum_periodic_arithmetic_set[OF per_all]"], ["proof (prove)\nusing this:\n  periodic_arithmetic\n   (\\<lambda>n. \\<Sum>i = 1..n. \\<chi> i * unity_root n (int (i * n))) n\n\ngoal (1 subgoal):\n 1. periodic_arithmetic\n     (\\<lambda>k. \\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k))) n", "by blast"], ["proof (state)\nthis:\n  periodic_arithmetic\n   (\\<lambda>k. \\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k))) n\n\ngoal (1 subgoal):\n 1. periodic_arithmetic gauss_sum n", "then"], ["proof (chain)\npicking this:\n  periodic_arithmetic\n   (\\<lambda>k. \\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k))) n", "show ?thesis"], ["proof (prove)\nusing this:\n  periodic_arithmetic\n   (\\<lambda>k. \\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k))) n\n\ngoal (1 subgoal):\n 1. periodic_arithmetic gauss_sum n", "unfolding gauss_sum_def"], ["proof (prove)\nusing this:\n  periodic_arithmetic\n   (\\<lambda>k. \\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k))) n\n\ngoal (1 subgoal):\n 1. periodic_arithmetic\n     (\\<lambda>n. \\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * n))) n", "by blast"], ["proof (state)\nthis:\n  periodic_arithmetic gauss_sum n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ramanujan_sum_conv_gauss_sum:\n  assumes \"\\<chi> = principal_dchar n\"\n  shows \"ramanujan_sum n k = gauss_sum k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ramanujan_sum n k = gauss_sum k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ramanujan_sum n k = gauss_sum k", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. ramanujan_sum n k = gauss_sum k", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. ramanujan_sum n k = gauss_sum k", "from assms"], ["proof (chain)\npicking this:\n  \\<chi> = principal_dchar n", "have 1: \"coprime m n \\<Longrightarrow> \\<chi>(m) = 1\" and\n         2: \"\\<not> coprime m n \\<Longrightarrow> \\<chi>(m) = 0\""], ["proof (prove)\nusing this:\n  \\<chi> = principal_dchar n\n\ngoal (1 subgoal):\n 1. (coprime m n \\<Longrightarrow> \\<chi> m = 1) &&&\n    (\\<not> coprime m n \\<Longrightarrow> \\<chi> m = 0)", "unfolding principal_dchar_def"], ["proof (prove)\nusing this:\n  \\<chi> = (\\<lambda>k. if coprime k n then 1 else 0)\n\ngoal (1 subgoal):\n 1. (coprime m n \\<Longrightarrow> \\<chi> m = 1) &&&\n    (\\<not> coprime m n \\<Longrightarrow> \\<chi> m = 0)", "by auto"], ["proof (state)\nthis:\n  coprime m n \\<Longrightarrow> \\<chi> m = 1\n  \\<not> coprime m n \\<Longrightarrow> \\<chi> m = 0\n\ngoal (1 subgoal):\n 1. ramanujan_sum n k = gauss_sum k", "}"], ["proof (state)\nthis:\n  coprime ?m2 n \\<Longrightarrow> \\<chi> ?m2 = 1\n  \\<not> coprime ?m2 n \\<Longrightarrow> \\<chi> ?m2 = 0\n\ngoal (1 subgoal):\n 1. ramanujan_sum n k = gauss_sum k", "note eq = this"], ["proof (state)\nthis:\n  coprime ?m2 n \\<Longrightarrow> \\<chi> ?m2 = 1\n  \\<not> coprime ?m2 n \\<Longrightarrow> \\<chi> ?m2 = 0\n\ngoal (1 subgoal):\n 1. ramanujan_sum n k = gauss_sum k", "have \"gauss_sum k = (\\<Sum>m = 1..n . \\<chi>(m) * unity_root n (m*k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_sum k = (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k)))", "unfolding gauss_sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k))) =\n    (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k)))", "by simp"], ["proof (state)\nthis:\n  gauss_sum k = (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k)))\n\ngoal (1 subgoal):\n 1. ramanujan_sum n k = gauss_sum k", "also"], ["proof (state)\nthis:\n  gauss_sum k = (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k)))\n\ngoal (1 subgoal):\n 1. ramanujan_sum n k = gauss_sum k", "have \"\\<dots> = (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n . \\<chi>(m) * unity_root n (m*k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k))) =\n    (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n       \\<chi> m * unity_root n (int (m * k)))", "by (rule sum.mono_neutral_right,simp,blast,simp add: eq)"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k))) =\n  (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n     \\<chi> m * unity_root n (int (m * k)))\n\ngoal (1 subgoal):\n 1. ramanujan_sum n k = gauss_sum k", "also"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k))) =\n  (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n     \\<chi> m * unity_root n (int (m * k)))\n\ngoal (1 subgoal):\n 1. ramanujan_sum n k = gauss_sum k", "have \"\\<dots> = (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n . unity_root n (m*k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n       \\<chi> m * unity_root n (int (m * k))) =\n    (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n       unity_root n (int (m * k)))", "by (simp add: eq)"], ["proof (state)\nthis:\n  (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n     \\<chi> m * unity_root n (int (m * k))) =\n  (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n. unity_root n (int (m * k)))\n\ngoal (1 subgoal):\n 1. ramanujan_sum n k = gauss_sum k", "also"], ["proof (state)\nthis:\n  (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n     \\<chi> m * unity_root n (int (m * k))) =\n  (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n. unity_root n (int (m * k)))\n\ngoal (1 subgoal):\n 1. ramanujan_sum n k = gauss_sum k", "have \"\\<dots> = ramanujan_sum n k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n       unity_root n (int (m * k))) =\n    ramanujan_sum n k", "unfolding ramanujan_sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n       unity_root n (int (m * k))) =\n    (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n       unity_root n (int (m * k)))", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n     unity_root n (int (m * k))) =\n  ramanujan_sum n k\n\ngoal (1 subgoal):\n 1. ramanujan_sum n k = gauss_sum k", "finally"], ["proof (chain)\npicking this:\n  gauss_sum k = ramanujan_sum n k", "show ?thesis"], ["proof (prove)\nusing this:\n  gauss_sum k = ramanujan_sum n k\n\ngoal (1 subgoal):\n 1. ramanujan_sum n k = gauss_sum k", ".."], ["proof (state)\nthis:\n  ramanujan_sum n k = gauss_sum k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cnj_mult_self:\n  assumes \"coprime k n\"\n  shows \"cnj (\\<chi> k) * \\<chi> k = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (\\<chi> k) * \\<chi> k = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cnj (\\<chi> k) * \\<chi> k = 1", "have \"cnj (\\<chi> k) * \\<chi> k = norm (\\<chi> k)^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (\\<chi> k) * \\<chi> k = complex_of_real ((cmod (\\<chi> k))\\<^sup>2)", "by (simp add: mult.commute complex_mult_cnj cmod_def)"], ["proof (state)\nthis:\n  cnj (\\<chi> k) * \\<chi> k = complex_of_real ((cmod (\\<chi> k))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. cnj (\\<chi> k) * \\<chi> k = 1", "also"], ["proof (state)\nthis:\n  cnj (\\<chi> k) * \\<chi> k = complex_of_real ((cmod (\\<chi> k))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. cnj (\\<chi> k) * \\<chi> k = 1", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real ((cmod (\\<chi> k))\\<^sup>2) = 1", "using norm[of k] assms"], ["proof (prove)\nusing this:\n  cmod (\\<chi> k) = (if coprime k n then 1 else 0)\n  coprime k n\n\ngoal (1 subgoal):\n 1. complex_of_real ((cmod (\\<chi> k))\\<^sup>2) = 1", "by simp"], ["proof (state)\nthis:\n  complex_of_real ((cmod (\\<chi> k))\\<^sup>2) = 1\n\ngoal (1 subgoal):\n 1. cnj (\\<chi> k) * \\<chi> k = 1", "finally"], ["proof (chain)\npicking this:\n  cnj (\\<chi> k) * \\<chi> k = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  cnj (\\<chi> k) * \\<chi> k = 1\n\ngoal (1 subgoal):\n 1. cnj (\\<chi> k) * \\<chi> k = 1", "."], ["proof (state)\nthis:\n  cnj (\\<chi> k) * \\<chi> k = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 8.9\\<close>"], ["", "theorem gauss_sum_reduction:\n  assumes \"coprime k n\" \n  shows \"gauss_sum k = cnj (\\<chi> k) * gauss_sum 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_sum k = cnj (\\<chi> k) * gauss_sum 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gauss_sum k = cnj (\\<chi> k) * gauss_sum 1", "from n"], ["proof (chain)\npicking this:\n  1 < n", "have n_pos: \"n > 0\""], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. 0 < n", "by simp"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. gauss_sum k = cnj (\\<chi> k) * gauss_sum 1", "have \"gauss_sum k = (\\<Sum>r = 1..n . \\<chi>(r) * unity_root n (r*k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_sum k = (\\<Sum>r = 1..n. \\<chi> r * unity_root n (int (r * k)))", "unfolding gauss_sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k))) =\n    (\\<Sum>r = 1..n. \\<chi> r * unity_root n (int (r * k)))", "by simp"], ["proof (state)\nthis:\n  gauss_sum k = (\\<Sum>r = 1..n. \\<chi> r * unity_root n (int (r * k)))\n\ngoal (1 subgoal):\n 1. gauss_sum k = cnj (\\<chi> k) * gauss_sum 1", "also"], ["proof (state)\nthis:\n  gauss_sum k = (\\<Sum>r = 1..n. \\<chi> r * unity_root n (int (r * k)))\n\ngoal (1 subgoal):\n 1. gauss_sum k = cnj (\\<chi> k) * gauss_sum 1", "have \"\\<dots> = (\\<Sum>r = 1..n . cnj (\\<chi>(k)) * \\<chi> k * \\<chi> r * unity_root n (r*k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r = 1..n. \\<chi> r * unity_root n (int (r * k))) =\n    (\\<Sum>r = 1..n.\n        cnj (\\<chi> k) * \\<chi> k * \\<chi> r * unity_root n (int (r * k)))", "using assms"], ["proof (prove)\nusing this:\n  coprime k n\n\ngoal (1 subgoal):\n 1. (\\<Sum>r = 1..n. \\<chi> r * unity_root n (int (r * k))) =\n    (\\<Sum>r = 1..n.\n        cnj (\\<chi> k) * \\<chi> k * \\<chi> r * unity_root n (int (r * k)))", "by (intro sum.cong) (auto simp: cnj_mult_self)"], ["proof (state)\nthis:\n  (\\<Sum>r = 1..n. \\<chi> r * unity_root n (int (r * k))) =\n  (\\<Sum>r = 1..n.\n      cnj (\\<chi> k) * \\<chi> k * \\<chi> r * unity_root n (int (r * k)))\n\ngoal (1 subgoal):\n 1. gauss_sum k = cnj (\\<chi> k) * gauss_sum 1", "also"], ["proof (state)\nthis:\n  (\\<Sum>r = 1..n. \\<chi> r * unity_root n (int (r * k))) =\n  (\\<Sum>r = 1..n.\n      cnj (\\<chi> k) * \\<chi> k * \\<chi> r * unity_root n (int (r * k)))\n\ngoal (1 subgoal):\n 1. gauss_sum k = cnj (\\<chi> k) * gauss_sum 1", "have \"\\<dots> = (\\<Sum>r = 1..n . cnj (\\<chi>(k)) * \\<chi> (k*r) * unity_root n (r*k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r = 1..n.\n        cnj (\\<chi> k) * \\<chi> k * \\<chi> r * unity_root n (int (r * k))) =\n    (\\<Sum>r = 1..n.\n        cnj (\\<chi> k) * \\<chi> (k * r) * unity_root n (int (r * k)))", "by (intro sum.cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>r = 1..n.\n      cnj (\\<chi> k) * \\<chi> k * \\<chi> r * unity_root n (int (r * k))) =\n  (\\<Sum>r = 1..n.\n      cnj (\\<chi> k) * \\<chi> (k * r) * unity_root n (int (r * k)))\n\ngoal (1 subgoal):\n 1. gauss_sum k = cnj (\\<chi> k) * gauss_sum 1", "also"], ["proof (state)\nthis:\n  (\\<Sum>r = 1..n.\n      cnj (\\<chi> k) * \\<chi> k * \\<chi> r * unity_root n (int (r * k))) =\n  (\\<Sum>r = 1..n.\n      cnj (\\<chi> k) * \\<chi> (k * r) * unity_root n (int (r * k)))\n\ngoal (1 subgoal):\n 1. gauss_sum k = cnj (\\<chi> k) * gauss_sum 1", "have \"\\<dots> = cnj (\\<chi>(k)) * (\\<Sum>r = 1..n . \\<chi> (k*r) * unity_root n (r*k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r = 1..n.\n        cnj (\\<chi> k) * \\<chi> (k * r) * unity_root n (int (r * k))) =\n    cnj (\\<chi> k) *\n    (\\<Sum>r = 1..n. \\<chi> (k * r) * unity_root n (int (r * k)))", "by (simp add: sum_distrib_left algebra_simps)"], ["proof (state)\nthis:\n  (\\<Sum>r = 1..n.\n      cnj (\\<chi> k) * \\<chi> (k * r) * unity_root n (int (r * k))) =\n  cnj (\\<chi> k) *\n  (\\<Sum>r = 1..n. \\<chi> (k * r) * unity_root n (int (r * k)))\n\ngoal (1 subgoal):\n 1. gauss_sum k = cnj (\\<chi> k) * gauss_sum 1", "also"], ["proof (state)\nthis:\n  (\\<Sum>r = 1..n.\n      cnj (\\<chi> k) * \\<chi> (k * r) * unity_root n (int (r * k))) =\n  cnj (\\<chi> k) *\n  (\\<Sum>r = 1..n. \\<chi> (k * r) * unity_root n (int (r * k)))\n\ngoal (1 subgoal):\n 1. gauss_sum k = cnj (\\<chi> k) * gauss_sum 1", "have \"\\<dots>= cnj (\\<chi>(k)) * (\\<Sum>r = 1..n . \\<chi> r * unity_root n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (\\<chi> k) *\n    (\\<Sum>r = 1..n. \\<chi> (k * r) * unity_root n (int (r * k))) =\n    cnj (\\<chi> k) * (\\<Sum>r = 1..n. \\<chi> r * unity_root n (int r))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cnj (\\<chi> k) *\n    (\\<Sum>r = 1..n. \\<chi> (k * r) * unity_root n (int (r * k))) =\n    cnj (\\<chi> k) * (\\<Sum>r = 1..n. \\<chi> r * unity_root n (int r))", "have 1: \"periodic_arithmetic (\\<lambda>r. \\<chi> r * unity_root n r) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>r. \\<chi> r * unity_root n (int r)) n", "using dir_periodic_arithmetic unity_periodic_arithmetic mult_periodic_arithmetic"], ["proof (prove)\nusing this:\n  periodic_arithmetic \\<chi> n\n  periodic_arithmetic (\\<lambda>x. unity_root ?k (int x)) ?k\n  \\<lbrakk>periodic_arithmetic ?f ?k; periodic_arithmetic ?g ?k\\<rbrakk>\n  \\<Longrightarrow> periodic_arithmetic (\\<lambda>n. ?f n * ?g n) ?k\n\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>r. \\<chi> r * unity_root n (int r)) n", "by blast"], ["proof (state)\nthis:\n  periodic_arithmetic (\\<lambda>r. \\<chi> r * unity_root n (int r)) n\n\ngoal (1 subgoal):\n 1. cnj (\\<chi> k) *\n    (\\<Sum>r = 1..n. \\<chi> (k * r) * unity_root n (int (r * k))) =\n    cnj (\\<chi> k) * (\\<Sum>r = 1..n. \\<chi> r * unity_root n (int r))", "have \"(\\<Sum>r = 1..n . \\<chi> (k*r) * unity_root n (r*k)) = \n          (\\<Sum>r = 1..n . \\<chi> (r)* unity_root n r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r = 1..n. \\<chi> (k * r) * unity_root n (int (r * k))) =\n    (\\<Sum>r = 1..n. \\<chi> r * unity_root n (int r))", "using periodic_arithmetic_remove_homothecy[OF assms(1) 1 n_pos]"], ["proof (prove)\nusing this:\n  (\\<Sum>l = 1..n. \\<chi> l * unity_root n (int l)) =\n  (\\<Sum>l = 1..n. \\<chi> (l * k) * unity_root n (int (l * k)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>r = 1..n. \\<chi> (k * r) * unity_root n (int (r * k))) =\n    (\\<Sum>r = 1..n. \\<chi> r * unity_root n (int r))", "by (simp add: algebra_simps n)"], ["proof (state)\nthis:\n  (\\<Sum>r = 1..n. \\<chi> (k * r) * unity_root n (int (r * k))) =\n  (\\<Sum>r = 1..n. \\<chi> r * unity_root n (int r))\n\ngoal (1 subgoal):\n 1. cnj (\\<chi> k) *\n    (\\<Sum>r = 1..n. \\<chi> (k * r) * unity_root n (int (r * k))) =\n    cnj (\\<chi> k) * (\\<Sum>r = 1..n. \\<chi> r * unity_root n (int r))", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>r = 1..n. \\<chi> (k * r) * unity_root n (int (r * k))) =\n  (\\<Sum>r = 1..n. \\<chi> r * unity_root n (int r))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>r = 1..n. \\<chi> (k * r) * unity_root n (int (r * k))) =\n  (\\<Sum>r = 1..n. \\<chi> r * unity_root n (int r))\n\ngoal (1 subgoal):\n 1. cnj (\\<chi> k) *\n    (\\<Sum>r = 1..n. \\<chi> (k * r) * unity_root n (int (r * k))) =\n    cnj (\\<chi> k) * (\\<Sum>r = 1..n. \\<chi> r * unity_root n (int r))", "by argo"], ["proof (state)\nthis:\n  cnj (\\<chi> k) *\n  (\\<Sum>r = 1..n. \\<chi> (k * r) * unity_root n (int (r * k))) =\n  cnj (\\<chi> k) * (\\<Sum>r = 1..n. \\<chi> r * unity_root n (int r))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cnj (\\<chi> k) *\n  (\\<Sum>r = 1..n. \\<chi> (k * r) * unity_root n (int (r * k))) =\n  cnj (\\<chi> k) * (\\<Sum>r = 1..n. \\<chi> r * unity_root n (int r))\n\ngoal (1 subgoal):\n 1. gauss_sum k = cnj (\\<chi> k) * gauss_sum 1", "also"], ["proof (state)\nthis:\n  cnj (\\<chi> k) *\n  (\\<Sum>r = 1..n. \\<chi> (k * r) * unity_root n (int (r * k))) =\n  cnj (\\<chi> k) * (\\<Sum>r = 1..n. \\<chi> r * unity_root n (int r))\n\ngoal (1 subgoal):\n 1. gauss_sum k = cnj (\\<chi> k) * gauss_sum 1", "have \"\\<dots> = cnj (\\<chi>(k)) * gauss_sum 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (\\<chi> k) * (\\<Sum>r = 1..n. \\<chi> r * unity_root n (int r)) =\n    cnj (\\<chi> k) * gauss_sum 1", "using gauss_sum_def"], ["proof (prove)\nusing this:\n  gauss_sum ?k = (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * ?k)))\n\ngoal (1 subgoal):\n 1. cnj (\\<chi> k) * (\\<Sum>r = 1..n. \\<chi> r * unity_root n (int r)) =\n    cnj (\\<chi> k) * gauss_sum 1", "by simp"], ["proof (state)\nthis:\n  cnj (\\<chi> k) * (\\<Sum>r = 1..n. \\<chi> r * unity_root n (int r)) =\n  cnj (\\<chi> k) * gauss_sum 1\n\ngoal (1 subgoal):\n 1. gauss_sum k = cnj (\\<chi> k) * gauss_sum 1", "finally"], ["proof (chain)\npicking this:\n  gauss_sum k = cnj (\\<chi> k) * gauss_sum 1", "show ?thesis"], ["proof (prove)\nusing this:\n  gauss_sum k = cnj (\\<chi> k) * gauss_sum 1\n\ngoal (1 subgoal):\n 1. gauss_sum k = cnj (\\<chi> k) * gauss_sum 1", "."], ["proof (state)\nthis:\n  gauss_sum k = cnj (\\<chi> k) * gauss_sum 1\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The following variant takes an integer argument instead.\n\\<close>"], ["", "definition \"gauss_sum_int k = (\\<Sum>m=1..n. \\<chi> m * unity_root n (int m*k))\""], ["", "sublocale gauss_sum_int: periodic_fun_simple gauss_sum_int \"int n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_fun_simple gauss_sum_int (int n)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. gauss_sum_int (x + int n) = gauss_sum_int x", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. gauss_sum_int (x + int n) = gauss_sum_int x", "show \"gauss_sum_int (k + int n) = gauss_sum_int k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_sum_int (k + int n) = gauss_sum_int k", "by (simp add: gauss_sum_int_def ring_distribs unity_root_add)"], ["proof (state)\nthis:\n  gauss_sum_int (k + int n) = gauss_sum_int k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gauss_sum_int_cong:\n  assumes \"[a = b] (mod int n)\"\n  shows   \"gauss_sum_int a = gauss_sum_int b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_sum_int a = gauss_sum_int b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gauss_sum_int a = gauss_sum_int b", "from assms"], ["proof (chain)\npicking this:\n  [a = b] (mod int n)", "obtain k where k: \"b = a + int n * k\""], ["proof (prove)\nusing this:\n  [a = b] (mod int n)\n\ngoal (1 subgoal):\n 1. (\\<And>k. b = a + int n * k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (subst (asm) cong_iff_lin) auto"], ["proof (state)\nthis:\n  b = a + int n * k\n\ngoal (1 subgoal):\n 1. gauss_sum_int a = gauss_sum_int b", "thus ?thesis"], ["proof (prove)\nusing this:\n  b = a + int n * k\n\ngoal (1 subgoal):\n 1. gauss_sum_int a = gauss_sum_int b", "using gauss_sum_int.plus_of_int[of a k]"], ["proof (prove)\nusing this:\n  b = a + int n * k\n  gauss_sum_int (a + of_int k * int n) = gauss_sum_int a\n\ngoal (1 subgoal):\n 1. gauss_sum_int a = gauss_sum_int b", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  gauss_sum_int a = gauss_sum_int b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gauss_sum_conv_gauss_sum_int:\n  \"gauss_sum k = gauss_sum_int (int k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_sum k = gauss_sum_int (int k)", "unfolding gauss_sum_def gauss_sum_int_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k))) =\n    (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int m * int k))", "by auto"], ["", "lemma gauss_sum_int_conv_gauss_sum:\n  \"gauss_sum_int k = gauss_sum (nat (k mod n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_sum_int k = gauss_sum (nat (k mod int n))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gauss_sum_int k = gauss_sum (nat (k mod int n))", "have \"gauss_sum (nat (k mod n)) = gauss_sum_int (int (nat (k mod n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_sum (nat (k mod int n)) = gauss_sum_int (int (nat (k mod int n)))", "by (simp add: gauss_sum_conv_gauss_sum_int)"], ["proof (state)\nthis:\n  gauss_sum (nat (k mod int n)) = gauss_sum_int (int (nat (k mod int n)))\n\ngoal (1 subgoal):\n 1. gauss_sum_int k = gauss_sum (nat (k mod int n))", "also"], ["proof (state)\nthis:\n  gauss_sum (nat (k mod int n)) = gauss_sum_int (int (nat (k mod int n)))\n\ngoal (1 subgoal):\n 1. gauss_sum_int k = gauss_sum (nat (k mod int n))", "have \"\\<dots> = gauss_sum_int k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_sum_int (int (nat (k mod int n))) = gauss_sum_int k", "using n"], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. gauss_sum_int (int (nat (k mod int n))) = gauss_sum_int k", "by (intro gauss_sum_int_cong) (auto simp: cong_def)"], ["proof (state)\nthis:\n  gauss_sum_int (int (nat (k mod int n))) = gauss_sum_int k\n\ngoal (1 subgoal):\n 1. gauss_sum_int k = gauss_sum (nat (k mod int n))", "finally"], ["proof (chain)\npicking this:\n  gauss_sum (nat (k mod int n)) = gauss_sum_int k", "show ?thesis"], ["proof (prove)\nusing this:\n  gauss_sum (nat (k mod int n)) = gauss_sum_int k\n\ngoal (1 subgoal):\n 1. gauss_sum_int k = gauss_sum (nat (k mod int n))", ".."], ["proof (state)\nthis:\n  gauss_sum_int k = gauss_sum (nat (k mod int n))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gauss_int_periodic: \"periodic_arithmetic gauss_sum_int n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>x. gauss_sum_int (int x)) n", "unfolding periodic_arithmetic_def gauss_sum_int_conv_gauss_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       gauss_sum (nat (int (n + n) mod int n)) =\n       gauss_sum (nat (int n mod int n))", "by simp"], ["", "proposition dcharacter_fourier_expansion:\n  \"\\<chi> m = (\\<Sum>k=1..n. 1 / n * gauss_sum_int (-k) * unity_root n (m*k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<chi> m =\n    (\\<Sum>k = 1..n.\n        complex_of_real (1 / real n) * gauss_sum_int (- int k) *\n        unity_root n (int (m * k)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<chi> m =\n    (\\<Sum>k = 1..n.\n        complex_of_real (1 / real n) * gauss_sum_int (- int k) *\n        unity_root n (int (m * k)))", "define g where \"g = (\\<lambda>x. 1 / of_nat n *\n      (\\<Sum>m<n. \\<chi> m * unity_root n (- int x * int m)))\""], ["proof (state)\nthis:\n  g =\n  (\\<lambda>x.\n      1 / of_nat n * (\\<Sum>m<n. \\<chi> m * unity_root n (- int x * int m)))\n\ngoal (1 subgoal):\n 1. \\<chi> m =\n    (\\<Sum>k = 1..n.\n        complex_of_real (1 / real n) * gauss_sum_int (- int k) *\n        unity_root n (int (m * k)))", "have per: \"periodic_arithmetic \\<chi> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic \\<chi> n", "using dir_periodic_arithmetic"], ["proof (prove)\nusing this:\n  periodic_arithmetic \\<chi> n\n\ngoal (1 subgoal):\n 1. periodic_arithmetic \\<chi> n", "by simp"], ["proof (state)\nthis:\n  periodic_arithmetic \\<chi> n\n\ngoal (1 subgoal):\n 1. \\<chi> m =\n    (\\<Sum>k = 1..n.\n        complex_of_real (1 / real n) * gauss_sum_int (- int k) *\n        unity_root n (int (m * k)))", "have \"\\<chi> m = (\\<Sum>k<n. g k * unity_root n (m * int k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<chi> m = (\\<Sum>k<n. g k * unity_root n (int m * int k))", "using fourier_expansion_periodic_arithmetic(2)[OF _ per, of m] n"], ["proof (prove)\nusing this:\n  0 < n \\<Longrightarrow>\n  \\<chi> m =\n  (\\<Sum>n<n.\n      1 / of_nat n *\n      (\\<Sum>m<n. \\<chi> m * unity_root n (- int n * int m)) *\n      unity_root n (int m * int n))\n  1 < n\n\ngoal (1 subgoal):\n 1. \\<chi> m = (\\<Sum>k<n. g k * unity_root n (int m * int k))", "by (auto simp: g_def)"], ["proof (state)\nthis:\n  \\<chi> m = (\\<Sum>k<n. g k * unity_root n (int m * int k))\n\ngoal (1 subgoal):\n 1. \\<chi> m =\n    (\\<Sum>k = 1..n.\n        complex_of_real (1 / real n) * gauss_sum_int (- int k) *\n        unity_root n (int (m * k)))", "also"], ["proof (state)\nthis:\n  \\<chi> m = (\\<Sum>k<n. g k * unity_root n (int m * int k))\n\ngoal (1 subgoal):\n 1. \\<chi> m =\n    (\\<Sum>k = 1..n.\n        complex_of_real (1 / real n) * gauss_sum_int (- int k) *\n        unity_root n (int (m * k)))", "have \"\\<dots> = (\\<Sum>k = 1..n. g k * unity_root n (m * int k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>k = 1..n. g k * unity_root n (int m * int k))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>k = 1..n. g k * unity_root n (int m * int k))", "have g_per: \"periodic_arithmetic g n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic g n", "using fourier_expansion_periodic_arithmetic(1)[OF _ per] n"], ["proof (prove)\nusing this:\n  0 < n \\<Longrightarrow>\n  periodic_arithmetic\n   (\\<lambda>x.\n       1 / of_nat n *\n       (\\<Sum>m<n. \\<chi> m * unity_root n (- int x * int m)))\n   n\n  1 < n\n\ngoal (1 subgoal):\n 1. periodic_arithmetic g n", "by (simp add: g_def)"], ["proof (state)\nthis:\n  periodic_arithmetic g n\n\ngoal (1 subgoal):\n 1. (\\<Sum>k<n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>k = 1..n. g k * unity_root n (int m * int k))", "have fact_per: \"periodic_arithmetic (\\<lambda>k. g k * unity_root n (int m * int k)) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>k. g k * unity_root n (int m * int k)) n", "using mult_periodic_arithmetic[OF g_per] unity_periodic_arithmetic_mult"], ["proof (prove)\nusing this:\n  periodic_arithmetic ?g n \\<Longrightarrow>\n  periodic_arithmetic (\\<lambda>n. g n * ?g n) n\n  periodic_arithmetic (\\<lambda>n. unity_root ?k (?m * int n)) ?k\n\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>k. g k * unity_root n (int m * int k)) n", "by auto"], ["proof (state)\nthis:\n  periodic_arithmetic (\\<lambda>k. g k * unity_root n (int m * int k)) n\n\ngoal (1 subgoal):\n 1. (\\<Sum>k<n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>k = 1..n. g k * unity_root n (int m * int k))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>k = 1..n. g k * unity_root n (int m * int k))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>k = 1..n. g k * unity_root n (int m * int k))", "have \"(\\<Sum>k<n. g k * unity_root n (int m * int k)) =\n            (\\<Sum>l = 0..n - Suc 0. g l * unity_root n (int m * int l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k<n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>l = 0..n - Suc 0. g l * unity_root n (int m * int l))", "using n"], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>k<n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>l = 0..n - Suc 0. g l * unity_root n (int m * int l))", "by (intro sum.cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>k<n. g k * unity_root n (int m * int k)) =\n  (\\<Sum>l = 0..n - Suc 0. g l * unity_root n (int m * int l))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k<n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>k = 1..n. g k * unity_root n (int m * int k))", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<n. g k * unity_root n (int m * int k)) =\n  (\\<Sum>l = 0..n - Suc 0. g l * unity_root n (int m * int l))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k<n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>k = 1..n. g k * unity_root n (int m * int k))", "have \"\\<dots> = (\\<Sum>l = Suc 0..n. g l * unity_root n (int m * int l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l = 0..n - Suc 0. g l * unity_root n (int m * int l)) =\n    (\\<Sum>l = Suc 0..n. g l * unity_root n (int m * int l))", "using periodic_arithmetic_sum_periodic_arithmetic_shift[OF fact_per, of 1] n"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < n; 0 < 1\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>l = 0..n - 1.\n                        g l * unity_root n (int m * int l)) =\n                    (\\<Sum>l = 1..1 + n - 1.\n                        g l * unity_root n (int m * int l))\n  1 < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>l = 0..n - Suc 0. g l * unity_root n (int m * int l)) =\n    (\\<Sum>l = Suc 0..n. g l * unity_root n (int m * int l))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>l = 0..n - Suc 0. g l * unity_root n (int m * int l)) =\n  (\\<Sum>l = Suc 0..n. g l * unity_root n (int m * int l))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k<n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>k = 1..n. g k * unity_root n (int m * int k))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>k<n. g k * unity_root n (int m * int k)) =\n  (\\<Sum>l = Suc 0..n. g l * unity_root n (int m * int l))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>k<n. g k * unity_root n (int m * int k)) =\n  (\\<Sum>l = Suc 0..n. g l * unity_root n (int m * int l))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k<n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>k = 1..n. g k * unity_root n (int m * int k))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>k<n. g k * unity_root n (int m * int k)) =\n  (\\<Sum>k = 1..n. g k * unity_root n (int m * int k))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>k<n. g k * unity_root n (int m * int k)) =\n  (\\<Sum>k = 1..n. g k * unity_root n (int m * int k))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>k<n. g k * unity_root n (int m * int k)) =\n  (\\<Sum>k = 1..n. g k * unity_root n (int m * int k))\n\ngoal (1 subgoal):\n 1. \\<chi> m =\n    (\\<Sum>k = 1..n.\n        complex_of_real (1 / real n) * gauss_sum_int (- int k) *\n        unity_root n (int (m * k)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>k<n. g k * unity_root n (int m * int k)) =\n  (\\<Sum>k = 1..n. g k * unity_root n (int m * int k))\n\ngoal (1 subgoal):\n 1. \\<chi> m =\n    (\\<Sum>k = 1..n.\n        complex_of_real (1 / real n) * gauss_sum_int (- int k) *\n        unity_root n (int (m * k)))", "have \"\\<dots> = (\\<Sum>k = 1..n. (1 / of_nat n) * gauss_sum_int (-k) * unity_root n (m*k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * gauss_sum_int (- int k) * unity_root n (int (m * k)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * gauss_sum_int (- int k) * unity_root n (int (m * k)))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * gauss_sum_int (- int k) * unity_root n (int (m * k)))", "fix k :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * gauss_sum_int (- int k) * unity_root n (int (m * k)))", "have shift: \"(\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) = \n        (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) =\n    (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) =\n    (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))", "have per_unit: \"periodic_arithmetic (\\<lambda>m. unity_root n (- int k * int m)) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>m. unity_root n (- int k * int m)) n", "using unity_periodic_arithmetic_mult"], ["proof (prove)\nusing this:\n  periodic_arithmetic (\\<lambda>n. unity_root ?k (?m * int n)) ?k\n\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>m. unity_root n (- int k * int m)) n", "by blast"], ["proof (state)\nthis:\n  periodic_arithmetic (\\<lambda>m. unity_root n (- int k * int m)) n\n\ngoal (1 subgoal):\n 1. (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) =\n    (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))", "then"], ["proof (chain)\npicking this:\n  periodic_arithmetic (\\<lambda>m. unity_root n (- int k * int m)) n", "have prod_per: \"periodic_arithmetic (\\<lambda>m. \\<chi> m * unity_root n (- int k * int m)) n\""], ["proof (prove)\nusing this:\n  periodic_arithmetic (\\<lambda>m. unity_root n (- int k * int m)) n\n\ngoal (1 subgoal):\n 1. periodic_arithmetic\n     (\\<lambda>m. \\<chi> m * unity_root n (- int k * int m)) n", "using per mult_periodic_arithmetic"], ["proof (prove)\nusing this:\n  periodic_arithmetic (\\<lambda>m. unity_root n (- int k * int m)) n\n  periodic_arithmetic \\<chi> n\n  \\<lbrakk>periodic_arithmetic ?f ?k; periodic_arithmetic ?g ?k\\<rbrakk>\n  \\<Longrightarrow> periodic_arithmetic (\\<lambda>n. ?f n * ?g n) ?k\n\ngoal (1 subgoal):\n 1. periodic_arithmetic\n     (\\<lambda>m. \\<chi> m * unity_root n (- int k * int m)) n", "by blast"], ["proof (state)\nthis:\n  periodic_arithmetic\n   (\\<lambda>m. \\<chi> m * unity_root n (- int k * int m)) n\n\ngoal (1 subgoal):\n 1. (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) =\n    (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) =\n    (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) =\n    (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))", "have \"(\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) =\n              (\\<Sum>l = 0..n - Suc 0. \\<chi> l * unity_root n (- int k * int l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) =\n    (\\<Sum>l = 0..n - Suc 0. \\<chi> l * unity_root n (- int k * int l))", "using n"], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) =\n    (\\<Sum>l = 0..n - Suc 0. \\<chi> l * unity_root n (- int k * int l))", "by (intro sum.cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) =\n  (\\<Sum>l = 0..n - Suc 0. \\<chi> l * unity_root n (- int k * int l))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) =\n    (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))", "also"], ["proof (state)\nthis:\n  (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) =\n  (\\<Sum>l = 0..n - Suc 0. \\<chi> l * unity_root n (- int k * int l))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) =\n    (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))", "have \"\\<dots> = (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l = 0..n - Suc 0. \\<chi> l * unity_root n (- int k * int l)) =\n    (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))", "using periodic_arithmetic_sum_periodic_arithmetic_shift[OF prod_per, of 1] n"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < n; 0 < 1\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>l = 0..n - 1.\n                        \\<chi> l * unity_root n (- int k * int l)) =\n                    (\\<Sum>l = 1..1 + n - 1.\n                        \\<chi> l * unity_root n (- int k * int l))\n  1 < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>l = 0..n - Suc 0. \\<chi> l * unity_root n (- int k * int l)) =\n    (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>l = 0..n - Suc 0. \\<chi> l * unity_root n (- int k * int l)) =\n  (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) =\n    (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) =\n  (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) =\n  (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) =\n    (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) =\n  (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) =\n  (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) =\n  (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * gauss_sum_int (- int k) * unity_root n (int (m * k)))", "have \"g k = 1 / of_nat n *\n      (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g k =\n    1 / of_nat n * (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m))", "using g_def"], ["proof (prove)\nusing this:\n  g =\n  (\\<lambda>x.\n      1 / of_nat n * (\\<Sum>m<n. \\<chi> m * unity_root n (- int x * int m)))\n\ngoal (1 subgoal):\n 1. g k =\n    1 / of_nat n * (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m))", "by auto"], ["proof (state)\nthis:\n  g k =\n  1 / of_nat n * (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * gauss_sum_int (- int k) * unity_root n (int (m * k)))", "also"], ["proof (state)\nthis:\n  g k =\n  1 / of_nat n * (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * gauss_sum_int (- int k) * unity_root n (int (m * k)))", "have \"\\<dots> = 1 / of_nat n *\n      (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / of_nat n * (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) =\n    1 / of_nat n *\n    (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))", "using shift"], ["proof (prove)\nusing this:\n  (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) =\n  (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))\n\ngoal (1 subgoal):\n 1. 1 / of_nat n * (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) =\n    1 / of_nat n *\n    (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))", "by simp"], ["proof (state)\nthis:\n  1 / of_nat n * (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) =\n  1 / of_nat n * (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * gauss_sum_int (- int k) * unity_root n (int (m * k)))", "also"], ["proof (state)\nthis:\n  1 / of_nat n * (\\<Sum>m<n. \\<chi> m * unity_root n (- int k * int m)) =\n  1 / of_nat n * (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * gauss_sum_int (- int k) * unity_root n (int (m * k)))", "have \"\\<dots> = 1 / of_nat n * gauss_sum_int (-k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / of_nat n *\n    (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m)) =\n    1 / of_nat n * gauss_sum_int (- int k)", "unfolding gauss_sum_int_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / of_nat n *\n    (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m)) =\n    1 / of_nat n *\n    (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int m * - int k))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  1 / of_nat n *\n  (\\<Sum>m = 1..n. \\<chi> m * unity_root n (- int k * int m)) =\n  1 / of_nat n * gauss_sum_int (- int k)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * gauss_sum_int (- int k) * unity_root n (int (m * k)))", "finally"], ["proof (chain)\npicking this:\n  g k = 1 / of_nat n * gauss_sum_int (- int k)", "have \"g k = 1 / of_nat n * gauss_sum_int (-k)\""], ["proof (prove)\nusing this:\n  g k = 1 / of_nat n * gauss_sum_int (- int k)\n\ngoal (1 subgoal):\n 1. g k = 1 / of_nat n * gauss_sum_int (- int k)", "by simp"], ["proof (state)\nthis:\n  g k = 1 / of_nat n * gauss_sum_int (- int k)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * gauss_sum_int (- int k) * unity_root n (int (m * k)))", "}"], ["proof (state)\nthis:\n  g ?k2 = 1 / of_nat n * gauss_sum_int (- int ?k2)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * gauss_sum_int (- int k) * unity_root n (int (m * k)))", "note g_expr = this"], ["proof (state)\nthis:\n  g ?k2 = 1 / of_nat n * gauss_sum_int (- int ?k2)\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * gauss_sum_int (- int k) * unity_root n (int (m * k)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n. g k * unity_root n (int m * int k)) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * gauss_sum_int (- int k) * unity_root n (int (m * k)))", "by (rule sum.cong, simp, simp add: g_expr)"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n. g k * unity_root n (int m * int k)) =\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * gauss_sum_int (- int k) * unity_root n (int (m * k)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n. g k * unity_root n (int m * int k)) =\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * gauss_sum_int (- int k) * unity_root n (int (m * k)))\n\ngoal (1 subgoal):\n 1. \\<chi> m =\n    (\\<Sum>k = 1..n.\n        complex_of_real (1 / real n) * gauss_sum_int (- int k) *\n        unity_root n (int (m * k)))", "finally"], ["proof (chain)\npicking this:\n  \\<chi> m =\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * gauss_sum_int (- int k) * unity_root n (int (m * k)))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<chi> m =\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * gauss_sum_int (- int k) * unity_root n (int (m * k)))\n\ngoal (1 subgoal):\n 1. \\<chi> m =\n    (\\<Sum>k = 1..n.\n        complex_of_real (1 / real n) * gauss_sum_int (- int k) *\n        unity_root n (int (m * k)))", "by auto"], ["proof (state)\nthis:\n  \\<chi> m =\n  (\\<Sum>k = 1..n.\n      complex_of_real (1 / real n) * gauss_sum_int (- int k) *\n      unity_root n (int (m * k)))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Separability\\<close>"], ["", "definition \"separable k \\<longleftrightarrow> gauss_sum k = cnj (\\<chi> k) * gauss_sum 1\""], ["", "corollary gauss_coprime_separable:\n  assumes \"coprime k n\" \n  shows   \"separable k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. separable k", "using gauss_sum_reduction[OF assms]"], ["proof (prove)\nusing this:\n  gauss_sum k = cnj (\\<chi> k) * gauss_sum 1\n\ngoal (1 subgoal):\n 1. separable k", "unfolding separable_def"], ["proof (prove)\nusing this:\n  gauss_sum k = cnj (\\<chi> k) * gauss_sum 1\n\ngoal (1 subgoal):\n 1. gauss_sum k = cnj (\\<chi> k) * gauss_sum 1", "by simp"], ["", "text \\<open>Theorem 8.10\\<close>"], ["", "theorem global_separability_condition:\n  \"(\\<forall>n>0. separable n) \\<longleftrightarrow> (\\<forall>k>0. \\<not>coprime k n \\<longrightarrow> gauss_sum k = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>n>0. separable n) =\n    (\\<forall>k>0. \\<not> coprime k n \\<longrightarrow> gauss_sum k = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>n>0. separable n) =\n    (\\<forall>k>0. \\<not> coprime k n \\<longrightarrow> gauss_sum k = 0)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>n>0. separable n) =\n    (\\<forall>k>0. \\<not> coprime k n \\<longrightarrow> gauss_sum k = 0)", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>n>0. separable n) =\n    (\\<forall>k>0. \\<not> coprime k n \\<longrightarrow> gauss_sum k = 0)", "assume \"\\<not> coprime k n\""], ["proof (state)\nthis:\n  \\<not> coprime k n\n\ngoal (1 subgoal):\n 1. (\\<forall>n>0. separable n) =\n    (\\<forall>k>0. \\<not> coprime k n \\<longrightarrow> gauss_sum k = 0)", "then"], ["proof (chain)\npicking this:\n  \\<not> coprime k n", "have \"\\<chi>(k) = 0\""], ["proof (prove)\nusing this:\n  \\<not> coprime k n\n\ngoal (1 subgoal):\n 1. \\<chi> k = 0", "by (simp add: eq_zero)"], ["proof (state)\nthis:\n  \\<chi> k = 0\n\ngoal (1 subgoal):\n 1. (\\<forall>n>0. separable n) =\n    (\\<forall>k>0. \\<not> coprime k n \\<longrightarrow> gauss_sum k = 0)", "then"], ["proof (chain)\npicking this:\n  \\<chi> k = 0", "have \"cnj (\\<chi> k) = 0\""], ["proof (prove)\nusing this:\n  \\<chi> k = 0\n\ngoal (1 subgoal):\n 1. cnj (\\<chi> k) = 0", "by blast"], ["proof (state)\nthis:\n  cnj (\\<chi> k) = 0\n\ngoal (1 subgoal):\n 1. (\\<forall>n>0. separable n) =\n    (\\<forall>k>0. \\<not> coprime k n \\<longrightarrow> gauss_sum k = 0)", "then"], ["proof (chain)\npicking this:\n  cnj (\\<chi> k) = 0", "have \"separable k \\<longleftrightarrow> gauss_sum k = 0\""], ["proof (prove)\nusing this:\n  cnj (\\<chi> k) = 0\n\ngoal (1 subgoal):\n 1. separable k = (gauss_sum k = 0)", "unfolding separable_def"], ["proof (prove)\nusing this:\n  cnj (\\<chi> k) = 0\n\ngoal (1 subgoal):\n 1. (gauss_sum k = cnj (\\<chi> k) * gauss_sum 1) = (gauss_sum k = 0)", "by auto"], ["proof (state)\nthis:\n  separable k = (gauss_sum k = 0)\n\ngoal (1 subgoal):\n 1. (\\<forall>n>0. separable n) =\n    (\\<forall>k>0. \\<not> coprime k n \\<longrightarrow> gauss_sum k = 0)", "}"], ["proof (state)\nthis:\n  \\<not> coprime ?k2 n \\<Longrightarrow> separable ?k2 = (gauss_sum ?k2 = 0)\n\ngoal (1 subgoal):\n 1. (\\<forall>n>0. separable n) =\n    (\\<forall>k>0. \\<not> coprime k n \\<longrightarrow> gauss_sum k = 0)", "note not_case = this"], ["proof (state)\nthis:\n  \\<not> coprime ?k2 n \\<Longrightarrow> separable ?k2 = (gauss_sum ?k2 = 0)\n\ngoal (1 subgoal):\n 1. (\\<forall>n>0. separable n) =\n    (\\<forall>k>0. \\<not> coprime k n \\<longrightarrow> gauss_sum k = 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>n>0. separable n) =\n    (\\<forall>k>0. \\<not> coprime k n \\<longrightarrow> gauss_sum k = 0)", "using gauss_coprime_separable not_case separable_def"], ["proof (prove)\nusing this:\n  coprime ?k n \\<Longrightarrow> separable ?k\n  \\<not> coprime ?k2 n \\<Longrightarrow> separable ?k2 = (gauss_sum ?k2 = 0)\n  separable ?k = (gauss_sum ?k = cnj (\\<chi> ?k) * gauss_sum 1)\n\ngoal (1 subgoal):\n 1. (\\<forall>n>0. separable n) =\n    (\\<forall>k>0. \\<not> coprime k n \\<longrightarrow> gauss_sum k = 0)", "by blast"], ["proof (state)\nthis:\n  (\\<forall>n>0. separable n) =\n  (\\<forall>k>0. \\<not> coprime k n \\<longrightarrow> gauss_sum k = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma of_real_moebius_mu [simp]: \"of_real (moebius_mu k) = moebius_mu k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_real (moebius_mu k) = moebius_mu k", "by (simp add: moebius_mu_def)"], ["", "corollary principal_not_totally_separable:\n  assumes \"\\<chi> = principal_dchar n\"\n  shows \"\\<not>(\\<forall>k > 0. separable k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k>0. separable k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k>0. separable k)", "have n_pos: \"n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n", "using n"], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. 0 < n", "by simp"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k>0. separable k)", "have tot_0: \"totient n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. totient n \\<noteq> 0", "by (simp add: n_pos)"], ["proof (state)\nthis:\n  totient n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k>0. separable k)", "have \"moebius_mu (n div gcd n n) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. moebius_mu (n div gcd n n) \\<noteq> (0::'a)", "by (simp add: \\<open>n > 0\\<close>)"], ["proof (state)\nthis:\n  moebius_mu (n div gcd n n) \\<noteq> (0::?'a1)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k>0. separable k)", "then"], ["proof (chain)\npicking this:\n  moebius_mu (n div gcd n n) \\<noteq> (0::?'a1)", "have moeb_0: \"\\<exists>k. moebius_mu (n div gcd k n) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  moebius_mu (n div gcd n n) \\<noteq> (0::?'a1)\n\ngoal (1 subgoal):\n 1. \\<exists>k. moebius_mu (n div gcd k n) \\<noteq> (0::'a)", "by blast"], ["proof (state)\nthis:\n  \\<exists>k. moebius_mu (n div gcd k n) \\<noteq> (0::?'a2)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k>0. separable k)", "have lem: \"gauss_sum k = totient n * moebius_mu (n div gcd k n) / totient (n div gcd k n)\"\n    if \"k > 0\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_sum k =\n    complex_of_real\n     (real_of_int (int (totient n) * moebius_mu (n div gcd k n)) /\n      real (totient (n div gcd k n)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gauss_sum k =\n    complex_of_real\n     (real_of_int (int (totient n) * moebius_mu (n div gcd k n)) /\n      real (totient (n div gcd k n)))", "have \"gauss_sum k = ramanujan_sum n k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_sum k = ramanujan_sum n k", "using ramanujan_sum_conv_gauss_sum[OF assms(1)]"], ["proof (prove)\nusing this:\n  ramanujan_sum n ?k = gauss_sum ?k\n\ngoal (1 subgoal):\n 1. gauss_sum k = ramanujan_sum n k", ".."], ["proof (state)\nthis:\n  gauss_sum k = ramanujan_sum n k\n\ngoal (1 subgoal):\n 1. gauss_sum k =\n    complex_of_real\n     (real_of_int (int (totient n) * moebius_mu (n div gcd k n)) /\n      real (totient (n div gcd k n)))", "also"], ["proof (state)\nthis:\n  gauss_sum k = ramanujan_sum n k\n\ngoal (1 subgoal):\n 1. gauss_sum k =\n    complex_of_real\n     (real_of_int (int (totient n) * moebius_mu (n div gcd k n)) /\n      real (totient (n div gcd k n)))", "have \"\\<dots> = totient n * moebius_mu (n div gcd k n) / (totient (n div gcd k n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ramanujan_sum n k =\n    complex_of_real\n     (real_of_int (int (totient n) * moebius_mu (n div gcd k n)) /\n      real (totient (n div gcd k n)))", "by (simp add: ramanujan_sum_k_n_dirichlet_expr[OF n_pos that])"], ["proof (state)\nthis:\n  ramanujan_sum n k =\n  complex_of_real\n   (real_of_int (int (totient n) * moebius_mu (n div gcd k n)) /\n    real (totient (n div gcd k n)))\n\ngoal (1 subgoal):\n 1. gauss_sum k =\n    complex_of_real\n     (real_of_int (int (totient n) * moebius_mu (n div gcd k n)) /\n      real (totient (n div gcd k n)))", "finally"], ["proof (chain)\npicking this:\n  gauss_sum k =\n  complex_of_real\n   (real_of_int (int (totient n) * moebius_mu (n div gcd k n)) /\n    real (totient (n div gcd k n)))", "show ?thesis"], ["proof (prove)\nusing this:\n  gauss_sum k =\n  complex_of_real\n   (real_of_int (int (totient n) * moebius_mu (n div gcd k n)) /\n    real (totient (n div gcd k n)))\n\ngoal (1 subgoal):\n 1. gauss_sum k =\n    complex_of_real\n     (real_of_int (int (totient n) * moebius_mu (n div gcd k n)) /\n      real (totient (n div gcd k n)))", "."], ["proof (state)\nthis:\n  gauss_sum k =\n  complex_of_real\n   (real_of_int (int (totient n) * moebius_mu (n div gcd k n)) /\n    real (totient (n div gcd k n)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?k2 \\<Longrightarrow>\n  gauss_sum ?k2 =\n  complex_of_real\n   (real_of_int (int (totient n) * moebius_mu (n div gcd ?k2 n)) /\n    real (totient (n div gcd ?k2 n)))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k>0. separable k)", "have 2: \"\\<not> coprime n n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> coprime n n", "using n"], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. \\<not> coprime n n", "by auto"], ["proof (state)\nthis:\n  \\<not> coprime n n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k>0. separable k)", "have 3: \"gauss_sum n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_sum n \\<noteq> 0", "using lem[OF n_pos] tot_0 moebius_mu_1"], ["proof (prove)\nusing this:\n  gauss_sum n =\n  complex_of_real\n   (real_of_int (int (totient n) * moebius_mu (n div gcd n n)) /\n    real (totient (n div gcd n n)))\n  totient n \\<noteq> 0\n  moebius_mu 1 = (1::?'a)\n\ngoal (1 subgoal):\n 1. gauss_sum n \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  gauss_sum n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k>0. separable k)", "from n_pos 2 3"], ["proof (chain)\npicking this:\n  0 < n\n  \\<not> coprime n n\n  gauss_sum n \\<noteq> 0", "have\n    \"\\<exists>k>0. \\<not>coprime k n \\<and> gauss_sum k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < n\n  \\<not> coprime n n\n  gauss_sum n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>k>0. \\<not> coprime k n \\<and> gauss_sum k \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  \\<exists>k>0. \\<not> coprime k n \\<and> gauss_sum k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k>0. separable k)", "then"], ["proof (chain)\npicking this:\n  \\<exists>k>0. \\<not> coprime k n \\<and> gauss_sum k \\<noteq> 0", "obtain k where \"k > 0 \\<and> \\<not> coprime k n \\<and> gauss_sum k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>k>0. \\<not> coprime k n \\<and> gauss_sum k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        0 < k \\<and>\n        \\<not> coprime k n \\<and> gauss_sum k \\<noteq> 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  0 < k \\<and> \\<not> coprime k n \\<and> gauss_sum k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k>0. separable k)", "note right_not_zero = this"], ["proof (state)\nthis:\n  0 < k \\<and> \\<not> coprime k n \\<and> gauss_sum k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k>0. separable k)", "have \"cnj (\\<chi> k) * gauss_sum 1 = 0\" if \"\\<not>coprime k n\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (\\<chi> k) * gauss_sum 1 = 0", "using that assms"], ["proof (prove)\nusing this:\n  \\<not> coprime k n\n  \\<chi> = principal_dchar n\n\ngoal (1 subgoal):\n 1. cnj (\\<chi> k) * gauss_sum 1 = 0", "by (simp add: principal_dchar_def)"], ["proof (state)\nthis:\n  \\<not> coprime ?k2 n \\<Longrightarrow> cnj (\\<chi> ?k2) * gauss_sum 1 = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k>0. separable k)", "then"], ["proof (chain)\npicking this:\n  \\<not> coprime ?k2 n \\<Longrightarrow> cnj (\\<chi> ?k2) * gauss_sum 1 = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> coprime ?k2 n \\<Longrightarrow> cnj (\\<chi> ?k2) * gauss_sum 1 = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k>0. separable k)", "unfolding separable_def"], ["proof (prove)\nusing this:\n  \\<not> coprime ?k2 n \\<Longrightarrow> cnj (\\<chi> ?k2) * gauss_sum 1 = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k>0. gauss_sum k = cnj (\\<chi> k) * gauss_sum 1)", "using right_not_zero"], ["proof (prove)\nusing this:\n  \\<not> coprime ?k2 n \\<Longrightarrow> cnj (\\<chi> ?k2) * gauss_sum 1 = 0\n  0 < k \\<and> \\<not> coprime k n \\<and> gauss_sum k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>k>0. gauss_sum k = cnj (\\<chi> k) * gauss_sum 1)", "by auto"], ["proof (state)\nthis:\n  \\<not> (\\<forall>k>0. separable k)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 8.11\\<close>"], ["", "theorem gauss_sum_1_mod_square_eq_k: \n  assumes \"(\\<forall>k. k > 0 \\<longrightarrow> separable k)\" \n  shows \"norm (gauss_sum 1) ^ 2 = real n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "have \"(norm (gauss_sum 1))^2 = gauss_sum 1 * cnj (gauss_sum 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real ((cmod (gauss_sum 1))\\<^sup>2) =\n    gauss_sum 1 * cnj (gauss_sum 1)", "using complex_norm_square"], ["proof (prove)\nusing this:\n  complex_of_real ((cmod ?z)\\<^sup>2) = ?z * cnj ?z\n\ngoal (1 subgoal):\n 1. complex_of_real ((cmod (gauss_sum 1))\\<^sup>2) =\n    gauss_sum 1 * cnj (gauss_sum 1)", "by blast"], ["proof (state)\nthis:\n  complex_of_real ((cmod (gauss_sum 1))\\<^sup>2) =\n  gauss_sum 1 * cnj (gauss_sum 1)\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "also"], ["proof (state)\nthis:\n  complex_of_real ((cmod (gauss_sum 1))\\<^sup>2) =\n  gauss_sum 1 * cnj (gauss_sum 1)\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "have \"\\<dots> = gauss_sum 1 * (\\<Sum>m = 1..n. cnj (\\<chi>(m)) * unity_root n (-m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_sum 1 * cnj (gauss_sum 1) =\n    gauss_sum 1 * (\\<Sum>m = 1..n. cnj (\\<chi> m) * unity_root n (- int m))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gauss_sum 1 * cnj (gauss_sum 1) =\n    gauss_sum 1 * (\\<Sum>m = 1..n. cnj (\\<chi> m) * unity_root n (- int m))", "have \"cnj (gauss_sum 1) = (\\<Sum>m = 1..n. cnj (\\<chi>(m)) * unity_root n (-m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (gauss_sum 1) =\n    (\\<Sum>m = 1..n. cnj (\\<chi> m) * unity_root n (- int m))", "unfolding gauss_sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * 1))) =\n    (\\<Sum>m = 1..n. cnj (\\<chi> m) * unity_root n (- int m))", "by (simp add: unity_root_uminus)"], ["proof (state)\nthis:\n  cnj (gauss_sum 1) =\n  (\\<Sum>m = 1..n. cnj (\\<chi> m) * unity_root n (- int m))\n\ngoal (1 subgoal):\n 1. gauss_sum 1 * cnj (gauss_sum 1) =\n    gauss_sum 1 * (\\<Sum>m = 1..n. cnj (\\<chi> m) * unity_root n (- int m))", "then"], ["proof (chain)\npicking this:\n  cnj (gauss_sum 1) =\n  (\\<Sum>m = 1..n. cnj (\\<chi> m) * unity_root n (- int m))", "show ?thesis"], ["proof (prove)\nusing this:\n  cnj (gauss_sum 1) =\n  (\\<Sum>m = 1..n. cnj (\\<chi> m) * unity_root n (- int m))\n\ngoal (1 subgoal):\n 1. gauss_sum 1 * cnj (gauss_sum 1) =\n    gauss_sum 1 * (\\<Sum>m = 1..n. cnj (\\<chi> m) * unity_root n (- int m))", "by argo"], ["proof (state)\nthis:\n  gauss_sum 1 * cnj (gauss_sum 1) =\n  gauss_sum 1 * (\\<Sum>m = 1..n. cnj (\\<chi> m) * unity_root n (- int m))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gauss_sum 1 * cnj (gauss_sum 1) =\n  gauss_sum 1 * (\\<Sum>m = 1..n. cnj (\\<chi> m) * unity_root n (- int m))\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "also"], ["proof (state)\nthis:\n  gauss_sum 1 * cnj (gauss_sum 1) =\n  gauss_sum 1 * (\\<Sum>m = 1..n. cnj (\\<chi> m) * unity_root n (- int m))\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "have \"\\<dots> = (\\<Sum>m = 1..n. gauss_sum 1 * cnj (\\<chi>(m)) * unity_root n (-m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_sum 1 *\n    (\\<Sum>m = 1..n. cnj (\\<chi> m) * unity_root n (- int m)) =\n    (\\<Sum>m = 1..n. gauss_sum 1 * cnj (\\<chi> m) * unity_root n (- int m))", "by (subst sum_distrib_left)(simp add: algebra_simps)"], ["proof (state)\nthis:\n  gauss_sum 1 * (\\<Sum>m = 1..n. cnj (\\<chi> m) * unity_root n (- int m)) =\n  (\\<Sum>m = 1..n. gauss_sum 1 * cnj (\\<chi> m) * unity_root n (- int m))\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "also"], ["proof (state)\nthis:\n  gauss_sum 1 * (\\<Sum>m = 1..n. cnj (\\<chi> m) * unity_root n (- int m)) =\n  (\\<Sum>m = 1..n. gauss_sum 1 * cnj (\\<chi> m) * unity_root n (- int m))\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "have \"\\<dots> = (\\<Sum>m = 1..n. gauss_sum m * unity_root n (-m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m = 1..n.\n        gauss_sum 1 * cnj (\\<chi> m) * unity_root n (- int m)) =\n    (\\<Sum>m = 1..n. gauss_sum m * unity_root n (- int m))", "proof (rule sum.cong,simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       gauss_sum 1 * cnj (\\<chi> x) * unity_root n (- int x) =\n       gauss_sum x * unity_root n (- int x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       gauss_sum 1 * cnj (\\<chi> x) * unity_root n (- int x) =\n       gauss_sum x * unity_root n (- int x)", "assume as: \"x \\<in> {1..n}\""], ["proof (state)\nthis:\n  x \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       gauss_sum 1 * cnj (\\<chi> x) * unity_root n (- int x) =\n       gauss_sum x * unity_root n (- int x)", "show \"gauss_sum 1 * cnj (\\<chi> x) * unity_root n (-x) =\n          gauss_sum x * unity_root n (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_sum 1 * cnj (\\<chi> x) * unity_root n (- int x) =\n    gauss_sum x * unity_root n (- int x)", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<forall>k>0. separable k\n\ngoal (1 subgoal):\n 1. gauss_sum 1 * cnj (\\<chi> x) * unity_root n (- int x) =\n    gauss_sum x * unity_root n (- int x)", "unfolding separable_def"], ["proof (prove)\nusing this:\n  \\<forall>k>0. gauss_sum k = cnj (\\<chi> k) * gauss_sum 1\n\ngoal (1 subgoal):\n 1. gauss_sum 1 * cnj (\\<chi> x) * unity_root n (- int x) =\n    gauss_sum x * unity_root n (- int x)", "by (rule allE[of _ x]) (use as in auto)"], ["proof (state)\nthis:\n  gauss_sum 1 * cnj (\\<chi> x) * unity_root n (- int x) =\n  gauss_sum x * unity_root n (- int x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..n. gauss_sum 1 * cnj (\\<chi> m) * unity_root n (- int m)) =\n  (\\<Sum>m = 1..n. gauss_sum m * unity_root n (- int m))\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "also"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..n. gauss_sum 1 * cnj (\\<chi> m) * unity_root n (- int m)) =\n  (\\<Sum>m = 1..n. gauss_sum m * unity_root n (- int m))\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "have \"\\<dots> = (\\<Sum>m = 1..n. (\\<Sum>r = 1..n. \\<chi> r * unity_root n (r*m) * unity_root n (-m)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m = 1..n. gauss_sum m * unity_root n (- int m)) =\n    (\\<Sum>m = 1..n.\n        \\<Sum>r = 1..n.\n           \\<chi> r * unity_root n (int (r * m)) * unity_root n (- int m))", "unfolding gauss_sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m = 1..n.\n        (\\<Sum>ma = 1..n. \\<chi> ma * unity_root n (int (ma * m))) *\n        unity_root n (- int m)) =\n    (\\<Sum>m = 1..n.\n        \\<Sum>r = 1..n.\n           \\<chi> r * unity_root n (int (r * m)) * unity_root n (- int m))", "by (rule sum.cong,simp,rule sum_distrib_right)"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..n. gauss_sum m * unity_root n (- int m)) =\n  (\\<Sum>m = 1..n.\n      \\<Sum>r = 1..n.\n         \\<chi> r * unity_root n (int (r * m)) * unity_root n (- int m))\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "also"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..n. gauss_sum m * unity_root n (- int m)) =\n  (\\<Sum>m = 1..n.\n      \\<Sum>r = 1..n.\n         \\<chi> r * unity_root n (int (r * m)) * unity_root n (- int m))\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "have \"\\<dots> = (\\<Sum>m = 1..n. (\\<Sum>r = 1..n. \\<chi> r * unity_root n (m*(r-1)) ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m = 1..n.\n        \\<Sum>r = 1..n.\n           \\<chi> r * unity_root n (int (r * m)) * unity_root n (- int m)) =\n    (\\<Sum>m = 1..n.\n        \\<Sum>r = 1..n. \\<chi> r * unity_root n (int (m * (r - 1))))", "by (intro sum.cong refl) (auto simp: unity_root_diff of_nat_diff unity_root_uminus field_simps)"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..n.\n      \\<Sum>r = 1..n.\n         \\<chi> r * unity_root n (int (r * m)) * unity_root n (- int m)) =\n  (\\<Sum>m = 1..n.\n      \\<Sum>r = 1..n. \\<chi> r * unity_root n (int (m * (r - 1))))\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "also"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..n.\n      \\<Sum>r = 1..n.\n         \\<chi> r * unity_root n (int (r * m)) * unity_root n (- int m)) =\n  (\\<Sum>m = 1..n.\n      \\<Sum>r = 1..n. \\<chi> r * unity_root n (int (m * (r - 1))))\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "have \"\\<dots> = (\\<Sum>r=1..n. (\\<Sum>m=1..n.  \\<chi>(r) *unity_root n (m*(r-1))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m = 1..n.\n        \\<Sum>r = 1..n. \\<chi> r * unity_root n (int (m * (r - 1)))) =\n    (\\<Sum>r = 1..n.\n        \\<Sum>m = 1..n. \\<chi> r * unity_root n (int (m * (r - 1))))", "by (rule sum.swap)"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..n.\n      \\<Sum>r = 1..n. \\<chi> r * unity_root n (int (m * (r - 1)))) =\n  (\\<Sum>r = 1..n.\n      \\<Sum>m = 1..n. \\<chi> r * unity_root n (int (m * (r - 1))))\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "also"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..n.\n      \\<Sum>r = 1..n. \\<chi> r * unity_root n (int (m * (r - 1)))) =\n  (\\<Sum>r = 1..n.\n      \\<Sum>m = 1..n. \\<chi> r * unity_root n (int (m * (r - 1))))\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "have \"\\<dots> = (\\<Sum>r=1..n. \\<chi>(r) *(\\<Sum>m=1..n. unity_root n (m*(r-1))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r = 1..n.\n        \\<Sum>m = 1..n. \\<chi> r * unity_root n (int (m * (r - 1)))) =\n    (\\<Sum>r = 1..n.\n        \\<chi> r * (\\<Sum>m = 1..n. unity_root n (int (m * (r - 1)))))", "by (rule sum.cong, simp, simp add: sum_distrib_left)"], ["proof (state)\nthis:\n  (\\<Sum>r = 1..n.\n      \\<Sum>m = 1..n. \\<chi> r * unity_root n (int (m * (r - 1)))) =\n  (\\<Sum>r = 1..n.\n      \\<chi> r * (\\<Sum>m = 1..n. unity_root n (int (m * (r - 1)))))\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "also"], ["proof (state)\nthis:\n  (\\<Sum>r = 1..n.\n      \\<Sum>m = 1..n. \\<chi> r * unity_root n (int (m * (r - 1)))) =\n  (\\<Sum>r = 1..n.\n      \\<chi> r * (\\<Sum>m = 1..n. unity_root n (int (m * (r - 1)))))\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "have \"\\<dots> = (\\<Sum>r=1..n. \\<chi>(r) * unity_root_sum n (r-1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r = 1..n.\n        \\<chi> r * (\\<Sum>m = 1..n. unity_root n (int (m * (r - 1))))) =\n    (\\<Sum>r = 1..n. \\<chi> r * unity_root_sum n (int (r - 1)))", "proof (intro sum.cong refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       \\<chi> x * (\\<Sum>m = 1..n. unity_root n (int (m * (x - 1)))) =\n       \\<chi> x * unity_root_sum n (int (x - 1))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       \\<chi> x * (\\<Sum>m = 1..n. unity_root n (int (m * (x - 1)))) =\n       \\<chi> x * unity_root_sum n (int (x - 1))", "assume \"x \\<in> {1..n}\""], ["proof (state)\nthis:\n  x \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       \\<chi> x * (\\<Sum>m = 1..n. unity_root n (int (m * (x - 1)))) =\n       \\<chi> x * unity_root_sum n (int (x - 1))", "then"], ["proof (chain)\npicking this:\n  x \\<in> {1..n}", "have 1: \"periodic_arithmetic (\\<lambda>m. unity_root n (int (m * (x - 1)))) n\""], ["proof (prove)\nusing this:\n  x \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>m. unity_root n (int (m * (x - 1)))) n", "using unity_periodic_arithmetic_mult[of n \"x-1\"]"], ["proof (prove)\nusing this:\n  x \\<in> {1..n}\n  periodic_arithmetic (\\<lambda>n. unity_root n (int (x - 1) * int n)) n\n\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>m. unity_root n (int (m * (x - 1)))) n", "by (simp add: mult.commute)"], ["proof (state)\nthis:\n  periodic_arithmetic (\\<lambda>m. unity_root n (int (m * (x - 1)))) n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       \\<chi> x * (\\<Sum>m = 1..n. unity_root n (int (m * (x - 1)))) =\n       \\<chi> x * unity_root_sum n (int (x - 1))", "have \"(\\<Sum>m = 1..n. unity_root n (int (m * (x - 1)))) = \n          (\\<Sum>m = 0..n-1. unity_root n (int (m * (x - 1))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m = 1..n. unity_root n (int (m * (x - 1)))) =\n    (\\<Sum>m = 0..n - 1. unity_root n (int (m * (x - 1))))", "using periodic_arithmetic_sum_periodic_arithmetic_shift[OF 1 _, of 1] n"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < n; 0 < 1\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>l = 0..n - 1. unity_root n (int (l * (x - 1)))) =\n                    (\\<Sum>l = 1..1 + n - 1.\n                        unity_root n (int (l * (x - 1))))\n  1 < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>m = 1..n. unity_root n (int (m * (x - 1)))) =\n    (\\<Sum>m = 0..n - 1. unity_root n (int (m * (x - 1))))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..n. unity_root n (int (m * (x - 1)))) =\n  (\\<Sum>m = 0..n - 1. unity_root n (int (m * (x - 1))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       \\<chi> x * (\\<Sum>m = 1..n. unity_root n (int (m * (x - 1)))) =\n       \\<chi> x * unity_root_sum n (int (x - 1))", "also"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..n. unity_root n (int (m * (x - 1)))) =\n  (\\<Sum>m = 0..n - 1. unity_root n (int (m * (x - 1))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       \\<chi> x * (\\<Sum>m = 1..n. unity_root n (int (m * (x - 1)))) =\n       \\<chi> x * unity_root_sum n (int (x - 1))", "have \"\\<dots> = unity_root_sum n (x-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m = 0..n - 1. unity_root n (int (m * (x - 1)))) =\n    unity_root_sum n (int (x - 1))", "using n"], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>m = 0..n - 1. unity_root n (int (m * (x - 1)))) =\n    unity_root_sum n (int (x - 1))", "unfolding unity_root_sum_def"], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>m = 0..n - 1. unity_root n (int (m * (x - 1)))) =\n    (\\<Sum>m<n. unity_root n (int (x - 1) * int m))", "by (intro sum.cong) (auto simp: mult_ac)"], ["proof (state)\nthis:\n  (\\<Sum>m = 0..n - 1. unity_root n (int (m * (x - 1)))) =\n  unity_root_sum n (int (x - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       \\<chi> x * (\\<Sum>m = 1..n. unity_root n (int (m * (x - 1)))) =\n       \\<chi> x * unity_root_sum n (int (x - 1))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>m = 1..n. unity_root n (int (m * (x - 1)))) =\n  unity_root_sum n (int (x - 1))", "have \"(\\<Sum>m = 1..n. unity_root n (int (m * (x - 1)))) =\n                  unity_root_sum n (int (x - 1))\""], ["proof (prove)\nusing this:\n  (\\<Sum>m = 1..n. unity_root n (int (m * (x - 1)))) =\n  unity_root_sum n (int (x - 1))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m = 1..n. unity_root n (int (m * (x - 1)))) =\n    unity_root_sum n (int (x - 1))", "."], ["proof (state)\nthis:\n  (\\<Sum>m = 1..n. unity_root n (int (m * (x - 1)))) =\n  unity_root_sum n (int (x - 1))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       \\<chi> x * (\\<Sum>m = 1..n. unity_root n (int (m * (x - 1)))) =\n       \\<chi> x * unity_root_sum n (int (x - 1))", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>m = 1..n. unity_root n (int (m * (x - 1)))) =\n  unity_root_sum n (int (x - 1))", "show \"\\<chi> x * (\\<Sum>m = 1..n. unity_root n (int (m * (x - 1)))) =\n               \\<chi> x * unity_root_sum n (int (x - 1))\""], ["proof (prove)\nusing this:\n  (\\<Sum>m = 1..n. unity_root n (int (m * (x - 1)))) =\n  unity_root_sum n (int (x - 1))\n\ngoal (1 subgoal):\n 1. \\<chi> x * (\\<Sum>m = 1..n. unity_root n (int (m * (x - 1)))) =\n    \\<chi> x * unity_root_sum n (int (x - 1))", "by argo"], ["proof (state)\nthis:\n  \\<chi> x * (\\<Sum>m = 1..n. unity_root n (int (m * (x - 1)))) =\n  \\<chi> x * unity_root_sum n (int (x - 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>r = 1..n.\n      \\<chi> r * (\\<Sum>m = 1..n. unity_root n (int (m * (r - 1))))) =\n  (\\<Sum>r = 1..n. \\<chi> r * unity_root_sum n (int (r - 1)))\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "also"], ["proof (state)\nthis:\n  (\\<Sum>r = 1..n.\n      \\<chi> r * (\\<Sum>m = 1..n. unity_root n (int (m * (r - 1))))) =\n  (\\<Sum>r = 1..n. \\<chi> r * unity_root_sum n (int (r - 1)))\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "have \"\\<dots> = (\\<Sum>r \\<in> {1}. \\<chi> r * unity_root_sum n (int (r - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r = 1..n. \\<chi> r * unity_root_sum n (int (r - 1))) =\n    (\\<Sum>r\\<in>{1}. \\<chi> r * unity_root_sum n (int (r - 1)))", "using n unity_root_sum_nonzero_iff int_ops(6)"], ["proof (prove)\nusing this:\n  1 < n\n  \\<lbrakk>1 \\<le> ?k; ?r \\<in> {- int ?k<..<int ?k}\\<rbrakk>\n  \\<Longrightarrow> (unity_root_sum ?k ?r \\<noteq> 0) = (?r = 0)\n  int (?a - ?b) = (if int ?a < int ?b then 0 else int ?a - int ?b)\n\ngoal (1 subgoal):\n 1. (\\<Sum>r = 1..n. \\<chi> r * unity_root_sum n (int (r - 1))) =\n    (\\<Sum>r\\<in>{1}. \\<chi> r * unity_root_sum n (int (r - 1)))", "by (intro sum.mono_neutral_right) auto"], ["proof (state)\nthis:\n  (\\<Sum>r = 1..n. \\<chi> r * unity_root_sum n (int (r - 1))) =\n  (\\<Sum>r\\<in>{1}. \\<chi> r * unity_root_sum n (int (r - 1)))\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "also"], ["proof (state)\nthis:\n  (\\<Sum>r = 1..n. \\<chi> r * unity_root_sum n (int (r - 1))) =\n  (\\<Sum>r\\<in>{1}. \\<chi> r * unity_root_sum n (int (r - 1)))\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "have \"\\<dots> = \\<chi> 1 * n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>{1}. \\<chi> r * unity_root_sum n (int (r - 1))) =\n    \\<chi> 1 * of_nat n", "using n"], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>r\\<in>{1}. \\<chi> r * unity_root_sum n (int (r - 1))) =\n    \\<chi> 1 * of_nat n", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>r\\<in>{1}. \\<chi> r * unity_root_sum n (int (r - 1))) =\n  \\<chi> 1 * of_nat n\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "also"], ["proof (state)\nthis:\n  (\\<Sum>r\\<in>{1}. \\<chi> r * unity_root_sum n (int (r - 1))) =\n  \\<chi> 1 * of_nat n\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "have \"\\<dots> = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<chi> 1 * of_nat n = of_nat n", "by simp"], ["proof (state)\nthis:\n  \\<chi> 1 * of_nat n = of_nat n\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "finally"], ["proof (chain)\npicking this:\n  complex_of_real ((cmod (gauss_sum 1))\\<^sup>2) = of_nat n", "show ?thesis"], ["proof (prove)\nusing this:\n  complex_of_real ((cmod (gauss_sum 1))\\<^sup>2) = of_nat n\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "using of_real_eq_iff"], ["proof (prove)\nusing this:\n  complex_of_real ((cmod (gauss_sum 1))\\<^sup>2) = of_nat n\n  (of_real ?x = of_real ?y) = (?x = ?y)\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "by fastforce"], ["proof (state)\nthis:\n  (cmod (gauss_sum 1))\\<^sup>2 = real n\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 8.12\\<close>"], ["", "theorem gauss_sum_nonzero_noncoprime_necessary_condition:\n  assumes \"gauss_sum k \\<noteq> 0\" \"\\<not>coprime k n\" \"k > 0\"\n  defines \"d \\<equiv> n div gcd k n\"  \n  assumes \"coprime a n\" \"[a = 1] (mod d)\" \n  shows   \"d dvd n\" \"d < n\" \"\\<chi> a = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d dvd n &&& d < n &&& \\<chi> a = 1", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. d dvd n\n 2. d < n\n 3. \\<chi> a = 1", "show \"d dvd n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d dvd n", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n div gcd k n dvd n", "using n"], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. n div gcd k n dvd n", "by (subst div_dvd_iff_mult) auto"], ["proof (state)\nthis:\n  d dvd n\n\ngoal (2 subgoals):\n 1. d < n\n 2. \\<chi> a = 1", "from assms(2)"], ["proof (chain)\npicking this:\n  \\<not> coprime k n", "have \"gcd k n \\<noteq> 1\""], ["proof (prove)\nusing this:\n  \\<not> coprime k n\n\ngoal (1 subgoal):\n 1. gcd k n \\<noteq> 1", "by blast"], ["proof (state)\nthis:\n  gcd k n \\<noteq> 1\n\ngoal (2 subgoals):\n 1. d < n\n 2. \\<chi> a = 1", "then"], ["proof (chain)\npicking this:\n  gcd k n \\<noteq> 1", "have \"gcd k n > 1\""], ["proof (prove)\nusing this:\n  gcd k n \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 1 < gcd k n", "using assms(3,4)"], ["proof (prove)\nusing this:\n  gcd k n \\<noteq> 1\n  0 < k\n  d \\<equiv> n div gcd k n\n\ngoal (1 subgoal):\n 1. 1 < gcd k n", "by (simp add: nat_neq_iff)"], ["proof (state)\nthis:\n  1 < gcd k n\n\ngoal (2 subgoals):\n 1. d < n\n 2. \\<chi> a = 1", "with n"], ["proof (chain)\npicking this:\n  1 < n\n  1 < gcd k n", "show \"d < n\""], ["proof (prove)\nusing this:\n  1 < n\n  1 < gcd k n\n\ngoal (1 subgoal):\n 1. d < n", "by (simp add: d_def)"], ["proof (state)\nthis:\n  d < n\n\ngoal (1 subgoal):\n 1. \\<chi> a = 1", "have \"periodic_arithmetic (\\<lambda>r. \\<chi> (r)* unity_root n (k*r)) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>r. \\<chi> r * unity_root n (int (k * r)))\n     n", "using mult_periodic_arithmetic[OF dir_periodic_arithmetic unity_periodic_arithmetic_mult]"], ["proof (prove)\nusing this:\n  periodic_arithmetic (\\<lambda>n. \\<chi> n * unity_root n (?m1 * int n)) n\n\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>r. \\<chi> r * unity_root n (int (k * r)))\n     n", "by auto"], ["proof (state)\nthis:\n  periodic_arithmetic (\\<lambda>r. \\<chi> r * unity_root n (int (k * r))) n\n\ngoal (1 subgoal):\n 1. \\<chi> a = 1", "then"], ["proof (chain)\npicking this:\n  periodic_arithmetic (\\<lambda>r. \\<chi> r * unity_root n (int (k * r))) n", "have 1: \"periodic_arithmetic (\\<lambda>r. \\<chi> (r)* unity_root n (r*k)) n\""], ["proof (prove)\nusing this:\n  periodic_arithmetic (\\<lambda>r. \\<chi> r * unity_root n (int (k * r))) n\n\ngoal (1 subgoal):\n 1. periodic_arithmetic (\\<lambda>r. \\<chi> r * unity_root n (int (r * k)))\n     n", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  periodic_arithmetic (\\<lambda>r. \\<chi> r * unity_root n (int (r * k))) n\n\ngoal (1 subgoal):\n 1. \\<chi> a = 1", "have \"gauss_sum k = (\\<Sum>m = 1..n . \\<chi>(m) * unity_root n (m*k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_sum k = (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k)))", "unfolding gauss_sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k))) =\n    (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k)))", "by blast"], ["proof (state)\nthis:\n  gauss_sum k = (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k)))\n\ngoal (1 subgoal):\n 1. \\<chi> a = 1", "also"], ["proof (state)\nthis:\n  gauss_sum k = (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k)))\n\ngoal (1 subgoal):\n 1. \\<chi> a = 1", "have \"\\<dots> = (\\<Sum>m = 1..n . \\<chi>(m*a) * unity_root n (m*a*k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k))) =\n    (\\<Sum>m = 1..n. \\<chi> (m * a) * unity_root n (int (m * a * k)))", "using periodic_arithmetic_remove_homothecy[OF assms(5) 1] n"], ["proof (prove)\nusing this:\n  0 < n \\<Longrightarrow>\n  (\\<Sum>l = 1..n. \\<chi> l * unity_root n (int (l * k))) =\n  (\\<Sum>l = 1..n. \\<chi> (l * a) * unity_root n (int (l * a * k)))\n  1 < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k))) =\n    (\\<Sum>m = 1..n. \\<chi> (m * a) * unity_root n (int (m * a * k)))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k))) =\n  (\\<Sum>m = 1..n. \\<chi> (m * a) * unity_root n (int (m * a * k)))\n\ngoal (1 subgoal):\n 1. \\<chi> a = 1", "also"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k))) =\n  (\\<Sum>m = 1..n. \\<chi> (m * a) * unity_root n (int (m * a * k)))\n\ngoal (1 subgoal):\n 1. \\<chi> a = 1", "have \"\\<dots> = (\\<Sum>m = 1..n . \\<chi>(m*a) * unity_root n (m*k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m = 1..n. \\<chi> (m * a) * unity_root n (int (m * a * k))) =\n    (\\<Sum>m = 1..n. \\<chi> (m * a) * unity_root n (int (m * k)))", "proof (intro sum.cong refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       \\<chi> (x * a) * unity_root n (int (x * a * k)) =\n       \\<chi> (x * a) * unity_root n (int (x * k))", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       \\<chi> (x * a) * unity_root n (int (x * a * k)) =\n       \\<chi> (x * a) * unity_root n (int (x * k))", "from assms(6)"], ["proof (chain)\npicking this:\n  [a = 1] (mod d)", "obtain b where \"a = 1 + b*d\""], ["proof (prove)\nusing this:\n  [a = 1] (mod d)\n\ngoal (1 subgoal):\n 1. (\\<And>b. a = 1 + b * d \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>d < n\\<close> assms(5) cong_to_1'_nat"], ["proof (prove)\nusing this:\n  [a = 1] (mod d)\n  d < n\n  coprime a n\n  [?a = 1] (mod ?n) =\n  (?a = 0 \\<and> ?n = 1 \\<or> (\\<exists>m. ?a = 1 + m * ?n))\n\ngoal (1 subgoal):\n 1. (\\<And>b. a = 1 + b * d \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a = 1 + b * d\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       \\<chi> (x * a) * unity_root n (int (x * a * k)) =\n       \\<chi> (x * a) * unity_root n (int (x * k))", "then"], ["proof (chain)\npicking this:\n  a = 1 + b * d", "have \"m*a*k = m*k+m*b*(n div gcd k n)*k\""], ["proof (prove)\nusing this:\n  a = 1 + b * d\n\ngoal (1 subgoal):\n 1. m * a * k = m * k + m * b * (n div gcd k n) * k", "by (simp add: algebra_simps d_def)"], ["proof (state)\nthis:\n  m * a * k = m * k + m * b * (n div gcd k n) * k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       \\<chi> (x * a) * unity_root n (int (x * a * k)) =\n       \\<chi> (x * a) * unity_root n (int (x * k))", "also"], ["proof (state)\nthis:\n  m * a * k = m * k + m * b * (n div gcd k n) * k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       \\<chi> (x * a) * unity_root n (int (x * a * k)) =\n       \\<chi> (x * a) * unity_root n (int (x * k))", "have \"\\<dots> = m*k+m*b*n*(k div gcd k n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m * k + m * b * (n div gcd k n) * k =\n    m * k + m * b * n * (k div gcd k n)", "by (simp add: div_mult_swap dvd_div_mult)"], ["proof (state)\nthis:\n  m * k + m * b * (n div gcd k n) * k = m * k + m * b * n * (k div gcd k n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       \\<chi> (x * a) * unity_root n (int (x * a * k)) =\n       \\<chi> (x * a) * unity_root n (int (x * k))", "also"], ["proof (state)\nthis:\n  m * k + m * b * (n div gcd k n) * k = m * k + m * b * n * (k div gcd k n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       \\<chi> (x * a) * unity_root n (int (x * a * k)) =\n       \\<chi> (x * a) * unity_root n (int (x * k))", "obtain p where \"\\<dots> = m*k+m*b*n*p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        m * k + m * b * n * (k div gcd k n) =\n        m * k + m * b * n * p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m * k + m * b * n * (k div gcd k n) = m * k + m * b * n * p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       \\<chi> (x * a) * unity_root n (int (x * a * k)) =\n       \\<chi> (x * a) * unity_root n (int (x * k))", "finally"], ["proof (chain)\npicking this:\n  m * a * k = m * k + m * b * n * p", "have \"m*a*k = m*k+m*b*p*n\""], ["proof (prove)\nusing this:\n  m * a * k = m * k + m * b * n * p\n\ngoal (1 subgoal):\n 1. m * a * k = m * k + m * b * p * n", "by simp"], ["proof (state)\nthis:\n  m * a * k = m * k + m * b * p * n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       \\<chi> (x * a) * unity_root n (int (x * a * k)) =\n       \\<chi> (x * a) * unity_root n (int (x * k))", "then"], ["proof (chain)\npicking this:\n  m * a * k = m * k + m * b * p * n", "have 1: \"m*a*k mod n= m*k mod n\""], ["proof (prove)\nusing this:\n  m * a * k = m * k + m * b * p * n\n\ngoal (1 subgoal):\n 1. m * a * k mod n = m * k mod n", "using mod_mult_self1"], ["proof (prove)\nusing this:\n  m * a * k = m * k + m * b * p * n\n  (?a + ?c * ?b) mod ?b = ?a mod ?b\n\ngoal (1 subgoal):\n 1. m * a * k mod n = m * k mod n", "by simp"], ["proof (state)\nthis:\n  m * a * k mod n = m * k mod n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       \\<chi> (x * a) * unity_root n (int (x * a * k)) =\n       \\<chi> (x * a) * unity_root n (int (x * k))", "then"], ["proof (chain)\npicking this:\n  m * a * k mod n = m * k mod n", "have \"unity_root n (m * a * k) = unity_root n (m * k)\""], ["proof (prove)\nusing this:\n  m * a * k mod n = m * k mod n\n\ngoal (1 subgoal):\n 1. unity_root n (int (m * a * k)) = unity_root n (int (m * k))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m * a * k mod n = m * k mod n \\<Longrightarrow>\n    unity_root n (int (m * a * k)) = unity_root n (int (m * k))", "have \"unity_root n (m * a * k) = unity_root n ((m * a * k) mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root n (int (m * a * k)) = unity_root n (int (m * a * k mod n))", "using unity_root_mod[of n] zmod_int"], ["proof (prove)\nusing this:\n  unity_root n (?n mod int n) = unity_root n ?n\n  int (?a mod ?b) = int ?a mod int ?b\n\ngoal (1 subgoal):\n 1. unity_root n (int (m * a * k)) = unity_root n (int (m * a * k mod n))", "by simp"], ["proof (state)\nthis:\n  unity_root n (int (m * a * k)) = unity_root n (int (m * a * k mod n))\n\ngoal (1 subgoal):\n 1. m * a * k mod n = m * k mod n \\<Longrightarrow>\n    unity_root n (int (m * a * k)) = unity_root n (int (m * k))", "also"], ["proof (state)\nthis:\n  unity_root n (int (m * a * k)) = unity_root n (int (m * a * k mod n))\n\ngoal (1 subgoal):\n 1. m * a * k mod n = m * k mod n \\<Longrightarrow>\n    unity_root n (int (m * a * k)) = unity_root n (int (m * k))", "have \"\\<dots> = unity_root n (m * k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root n (int (m * a * k mod n)) = unity_root n (int (m * k))", "using unity_root_mod[of n] zmod_int 1"], ["proof (prove)\nusing this:\n  unity_root n (?n mod int n) = unity_root n ?n\n  int (?a mod ?b) = int ?a mod int ?b\n  m * a * k mod n = m * k mod n\n\ngoal (1 subgoal):\n 1. unity_root n (int (m * a * k mod n)) = unity_root n (int (m * k))", "by presburger"], ["proof (state)\nthis:\n  unity_root n (int (m * a * k mod n)) = unity_root n (int (m * k))\n\ngoal (1 subgoal):\n 1. m * a * k mod n = m * k mod n \\<Longrightarrow>\n    unity_root n (int (m * a * k)) = unity_root n (int (m * k))", "finally"], ["proof (chain)\npicking this:\n  unity_root n (int (m * a * k)) = unity_root n (int (m * k))", "show ?thesis"], ["proof (prove)\nusing this:\n  unity_root n (int (m * a * k)) = unity_root n (int (m * k))\n\ngoal (1 subgoal):\n 1. unity_root n (int (m * a * k)) = unity_root n (int (m * k))", "by blast"], ["proof (state)\nthis:\n  unity_root n (int (m * a * k)) = unity_root n (int (m * k))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  unity_root n (int (m * a * k)) = unity_root n (int (m * k))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       \\<chi> (x * a) * unity_root n (int (x * a * k)) =\n       \\<chi> (x * a) * unity_root n (int (x * k))", "then"], ["proof (chain)\npicking this:\n  unity_root n (int (m * a * k)) = unity_root n (int (m * k))", "show \"\\<chi> (m * a) * unity_root n (int (m * a * k)) =\n               \\<chi> (m * a) * unity_root n (int (m * k))\""], ["proof (prove)\nusing this:\n  unity_root n (int (m * a * k)) = unity_root n (int (m * k))\n\ngoal (1 subgoal):\n 1. \\<chi> (m * a) * unity_root n (int (m * a * k)) =\n    \\<chi> (m * a) * unity_root n (int (m * k))", "by auto"], ["proof (state)\nthis:\n  \\<chi> (m * a) * unity_root n (int (m * a * k)) =\n  \\<chi> (m * a) * unity_root n (int (m * k))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..n. \\<chi> (m * a) * unity_root n (int (m * a * k))) =\n  (\\<Sum>m = 1..n. \\<chi> (m * a) * unity_root n (int (m * k)))\n\ngoal (1 subgoal):\n 1. \\<chi> a = 1", "also"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..n. \\<chi> (m * a) * unity_root n (int (m * a * k))) =\n  (\\<Sum>m = 1..n. \\<chi> (m * a) * unity_root n (int (m * k)))\n\ngoal (1 subgoal):\n 1. \\<chi> a = 1", "have \"\\<dots> = (\\<Sum>m = 1..n . \\<chi>(a) * (\\<chi>(m) * unity_root n (m*k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m = 1..n. \\<chi> (m * a) * unity_root n (int (m * k))) =\n    (\\<Sum>m = 1..n. \\<chi> a * (\\<chi> m * unity_root n (int (m * k))))", "by (rule sum.cong,simp,subst mult,simp)"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..n. \\<chi> (m * a) * unity_root n (int (m * k))) =\n  (\\<Sum>m = 1..n. \\<chi> a * (\\<chi> m * unity_root n (int (m * k))))\n\ngoal (1 subgoal):\n 1. \\<chi> a = 1", "also"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..n. \\<chi> (m * a) * unity_root n (int (m * k))) =\n  (\\<Sum>m = 1..n. \\<chi> a * (\\<chi> m * unity_root n (int (m * k))))\n\ngoal (1 subgoal):\n 1. \\<chi> a = 1", "have \"\\<dots> =  \\<chi>(a) * (\\<Sum>m = 1..n . \\<chi>(m) * unity_root n (m*k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m = 1..n. \\<chi> a * (\\<chi> m * unity_root n (int (m * k)))) =\n    \\<chi> a * (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k)))", "by (simp add: sum_distrib_left[symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..n. \\<chi> a * (\\<chi> m * unity_root n (int (m * k)))) =\n  \\<chi> a * (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k)))\n\ngoal (1 subgoal):\n 1. \\<chi> a = 1", "also"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..n. \\<chi> a * (\\<chi> m * unity_root n (int (m * k)))) =\n  \\<chi> a * (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k)))\n\ngoal (1 subgoal):\n 1. \\<chi> a = 1", "have \"\\<dots> = \\<chi>(a) * gauss_sum k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<chi> a * (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k))) =\n    \\<chi> a * gauss_sum k", "unfolding gauss_sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<chi> a * (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k))) =\n    \\<chi> a * (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k)))", "by blast"], ["proof (state)\nthis:\n  \\<chi> a * (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * k))) =\n  \\<chi> a * gauss_sum k\n\ngoal (1 subgoal):\n 1. \\<chi> a = 1", "finally"], ["proof (chain)\npicking this:\n  gauss_sum k = \\<chi> a * gauss_sum k", "have \"gauss_sum k = \\<chi>(a) * gauss_sum k\""], ["proof (prove)\nusing this:\n  gauss_sum k = \\<chi> a * gauss_sum k\n\ngoal (1 subgoal):\n 1. gauss_sum k = \\<chi> a * gauss_sum k", "by blast"], ["proof (state)\nthis:\n  gauss_sum k = \\<chi> a * gauss_sum k\n\ngoal (1 subgoal):\n 1. \\<chi> a = 1", "then"], ["proof (chain)\npicking this:\n  gauss_sum k = \\<chi> a * gauss_sum k", "show \"\\<chi> a = 1\""], ["proof (prove)\nusing this:\n  gauss_sum k = \\<chi> a * gauss_sum k\n\ngoal (1 subgoal):\n 1. \\<chi> a = 1", "using assms(1)"], ["proof (prove)\nusing this:\n  gauss_sum k = \\<chi> a * gauss_sum k\n  gauss_sum k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<chi> a = 1", "by simp"], ["proof (state)\nthis:\n  \\<chi> a = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Induced moduli and primitive characters\\<close>"], ["", "definition \"induced_modulus d \\<longleftrightarrow> d dvd n \\<and> (\\<forall>a. coprime a n \\<and> [a = 1] (mod d) \\<longrightarrow> \\<chi> a = 1)\""], ["", "lemma induced_modulus_dvd: \"induced_modulus d \\<Longrightarrow> d dvd n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. induced_modulus d \\<Longrightarrow> d dvd n", "unfolding induced_modulus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d dvd n \\<and>\n    (\\<forall>a.\n        coprime a n \\<and> [a = 1] (mod d) \\<longrightarrow>\n        \\<chi> a = 1) \\<Longrightarrow>\n    d dvd n", "by blast"], ["", "lemma induced_modulusI [intro?]:\n  \"d dvd n \\<Longrightarrow> (\\<And>a. coprime a n \\<Longrightarrow> [a = 1] (mod d) \\<Longrightarrow> \\<chi> a = 1) \\<Longrightarrow> induced_modulus d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d dvd n;\n     \\<And>a.\n        \\<lbrakk>coprime a n; [a = 1] (mod d)\\<rbrakk>\n        \\<Longrightarrow> \\<chi> a = 1\\<rbrakk>\n    \\<Longrightarrow> induced_modulus d", "unfolding induced_modulus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d dvd n;\n     \\<And>a.\n        \\<lbrakk>coprime a n; [a = 1] (mod d)\\<rbrakk>\n        \\<Longrightarrow> \\<chi> a = 1\\<rbrakk>\n    \\<Longrightarrow> d dvd n \\<and>\n                      (\\<forall>a.\n                          coprime a n \\<and>\n                          [a = 1] (mod d) \\<longrightarrow>\n                          \\<chi> a = 1)", "by auto"], ["", "lemma induced_modulusD: \"induced_modulus d \\<Longrightarrow> coprime a n \\<Longrightarrow> [a = 1] (mod d) \\<Longrightarrow> \\<chi> a = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>induced_modulus d; coprime a n; [a = 1] (mod d)\\<rbrakk>\n    \\<Longrightarrow> \\<chi> a = 1", "unfolding induced_modulus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d dvd n \\<and>\n             (\\<forall>a.\n                 coprime a n \\<and> [a = 1] (mod d) \\<longrightarrow>\n                 \\<chi> a = 1);\n     coprime a n; [a = 1] (mod d)\\<rbrakk>\n    \\<Longrightarrow> \\<chi> a = 1", "by blast"], ["", "lemma zero_not_ind_mod: \"\\<not>induced_modulus 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> induced_modulus 0", "unfolding induced_modulus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (0 dvd n \\<and>\n            (\\<forall>a.\n                coprime a n \\<and> [a = 1] (mod 0) \\<longrightarrow>\n                \\<chi> a = 1))", "using n"], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. \\<not> (0 dvd n \\<and>\n            (\\<forall>a.\n                coprime a n \\<and> [a = 1] (mod 0) \\<longrightarrow>\n                \\<chi> a = 1))", "by simp"], ["", "lemma div_gcd_dvd1: \"(a :: 'a :: semiring_gcd) div gcd a b dvd a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a div gcd a b dvd a", "by (metis dvd_def dvd_div_mult_self gcd_dvd1)"], ["", "lemma div_gcd_dvd2: \"(b :: 'a :: semiring_gcd) div gcd a b dvd b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b div gcd a b dvd b", "by (metis div_gcd_dvd1 gcd.commute)"], ["", "lemma g_non_zero_ind_mod:\n  assumes \"gauss_sum k \\<noteq> 0\" \"\\<not>coprime k n\" \"k > 0\"\n  shows  \"induced_modulus (n div gcd k n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. induced_modulus (n div gcd k n)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n div gcd k n dvd n\n 2. \\<And>a.\n       \\<lbrakk>coprime a n; [a = 1] (mod n div gcd k n)\\<rbrakk>\n       \\<Longrightarrow> \\<chi> a = 1", "show \"n div gcd k n dvd n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n div gcd k n dvd n", "by (metis dvd_div_mult_self dvd_triv_left gcd.commute gcd_dvd1)"], ["proof (state)\nthis:\n  n div gcd k n dvd n\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>coprime a n; [a = 1] (mod n div gcd k n)\\<rbrakk>\n       \\<Longrightarrow> \\<chi> a = 1", "fix a :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>coprime a n; [a = 1] (mod n div gcd k n)\\<rbrakk>\n       \\<Longrightarrow> \\<chi> a = 1", "assume \"coprime a n\" \"[a = 1] (mod n div gcd k n)\""], ["proof (state)\nthis:\n  coprime a n\n  [a = 1] (mod n div gcd k n)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>coprime a n; [a = 1] (mod n div gcd k n)\\<rbrakk>\n       \\<Longrightarrow> \\<chi> a = 1", "thus \"\\<chi> a = 1\""], ["proof (prove)\nusing this:\n  coprime a n\n  [a = 1] (mod n div gcd k n)\n\ngoal (1 subgoal):\n 1. \\<chi> a = 1", "using assms n gauss_sum_nonzero_noncoprime_necessary_condition(3)"], ["proof (prove)\nusing this:\n  coprime a n\n  [a = 1] (mod n div gcd k n)\n  gauss_sum k \\<noteq> 0\n  \\<not> coprime k n\n  0 < k\n  1 < n\n  \\<lbrakk>gauss_sum ?k \\<noteq> 0; \\<not> coprime ?k n; 0 < ?k;\n   coprime ?a n; [?a = 1] (mod n div gcd ?k n)\\<rbrakk>\n  \\<Longrightarrow> \\<chi> ?a = 1\n\ngoal (1 subgoal):\n 1. \\<chi> a = 1", "by auto"], ["proof (state)\nthis:\n  \\<chi> a = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma induced_modulus_modulus: \"induced_modulus n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. induced_modulus n", "unfolding induced_modulus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n dvd n \\<and>\n    (\\<forall>a.\n        coprime a n \\<and> [a = 1] (mod n) \\<longrightarrow> \\<chi> a = 1)", "proof (rule conjI,simp,safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>coprime a n; [a = 1] (mod n)\\<rbrakk>\n       \\<Longrightarrow> \\<chi> a = 1", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>coprime a n; [a = 1] (mod n)\\<rbrakk>\n       \\<Longrightarrow> \\<chi> a = 1", "assume \"[a = 1] (mod n)\""], ["proof (state)\nthis:\n  [a = 1] (mod n)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>coprime a n; [a = 1] (mod n)\\<rbrakk>\n       \\<Longrightarrow> \\<chi> a = 1", "then"], ["proof (chain)\npicking this:\n  [a = 1] (mod n)", "have \"a mod n = 1 mod n\""], ["proof (prove)\nusing this:\n  [a = 1] (mod n)\n\ngoal (1 subgoal):\n 1. a mod n = 1 mod n", "using cong_def[of a 1 n]"], ["proof (prove)\nusing this:\n  [a = 1] (mod n)\n  [a = 1] (mod n) = (a mod n = 1 mod n)\n\ngoal (1 subgoal):\n 1. a mod n = 1 mod n", "by blast"], ["proof (state)\nthis:\n  a mod n = 1 mod n\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>coprime a n; [a = 1] (mod n)\\<rbrakk>\n       \\<Longrightarrow> \\<chi> a = 1", "also"], ["proof (state)\nthis:\n  a mod n = 1 mod n\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>coprime a n; [a = 1] (mod n)\\<rbrakk>\n       \\<Longrightarrow> \\<chi> a = 1", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 mod n = 1", "using eq_zero_iff zero_eq_0"], ["proof (prove)\nusing this:\n  (\\<chi> ?x = 0) = (\\<not> coprime ?x n)\n  \\<chi> 0 = 0\n\ngoal (1 subgoal):\n 1. 1 mod n = 1", "by fastforce"], ["proof (state)\nthis:\n  1 mod n = 1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>coprime a n; [a = 1] (mod n)\\<rbrakk>\n       \\<Longrightarrow> \\<chi> a = 1", "finally"], ["proof (chain)\npicking this:\n  a mod n = 1", "have 1: \"a mod n = 1\""], ["proof (prove)\nusing this:\n  a mod n = 1\n\ngoal (1 subgoal):\n 1. a mod n = 1", "by simp"], ["proof (state)\nthis:\n  a mod n = 1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>coprime a n; [a = 1] (mod n)\\<rbrakk>\n       \\<Longrightarrow> \\<chi> a = 1", "have \"\\<chi> a = \\<chi> (a mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<chi> a = \\<chi> (a mod n)", "by simp"], ["proof (state)\nthis:\n  \\<chi> a = \\<chi> (a mod n)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>coprime a n; [a = 1] (mod n)\\<rbrakk>\n       \\<Longrightarrow> \\<chi> a = 1", "also"], ["proof (state)\nthis:\n  \\<chi> a = \\<chi> (a mod n)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>coprime a n; [a = 1] (mod n)\\<rbrakk>\n       \\<Longrightarrow> \\<chi> a = 1", "have \"\\<dots> = \\<chi> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<chi> (a mod n) = \\<chi> 1", "using cong_def 1"], ["proof (prove)\nusing this:\n  [?b = ?c] (mod ?a) = (?b mod ?a = ?c mod ?a)\n  a mod n = 1\n\ngoal (1 subgoal):\n 1. \\<chi> (a mod n) = \\<chi> 1", "by auto"], ["proof (state)\nthis:\n  \\<chi> (a mod n) = \\<chi> 1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>coprime a n; [a = 1] (mod n)\\<rbrakk>\n       \\<Longrightarrow> \\<chi> a = 1", "also"], ["proof (state)\nthis:\n  \\<chi> (a mod n) = \\<chi> 1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>coprime a n; [a = 1] (mod n)\\<rbrakk>\n       \\<Longrightarrow> \\<chi> a = 1", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<chi> 1 = 1", "by simp"], ["proof (state)\nthis:\n  \\<chi> 1 = 1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>coprime a n; [a = 1] (mod n)\\<rbrakk>\n       \\<Longrightarrow> \\<chi> a = 1", "finally"], ["proof (chain)\npicking this:\n  \\<chi> a = 1", "show \"\\<chi> a = 1\""], ["proof (prove)\nusing this:\n  \\<chi> a = 1\n\ngoal (1 subgoal):\n 1. \\<chi> a = 1", "by blast"], ["proof (state)\nthis:\n  \\<chi> a = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 8.13\\<close>"], ["", "theorem one_induced_iff_principal:\n \"induced_modulus 1 \\<longleftrightarrow> \\<chi> = principal_dchar n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. induced_modulus 1 = (\\<chi> = principal_dchar n)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. induced_modulus 1 \\<Longrightarrow> \\<chi> = principal_dchar n\n 2. \\<chi> = principal_dchar n \\<Longrightarrow> induced_modulus 1", "assume \"induced_modulus 1\""], ["proof (state)\nthis:\n  induced_modulus 1\n\ngoal (2 subgoals):\n 1. induced_modulus 1 \\<Longrightarrow> \\<chi> = principal_dchar n\n 2. \\<chi> = principal_dchar n \\<Longrightarrow> induced_modulus 1", "then"], ["proof (chain)\npicking this:\n  induced_modulus 1", "have \"(\\<forall>a. coprime a n \\<longrightarrow> \\<chi> a = 1)\""], ["proof (prove)\nusing this:\n  induced_modulus 1\n\ngoal (1 subgoal):\n 1. \\<forall>a. coprime a n \\<longrightarrow> \\<chi> a = 1", "unfolding induced_modulus_def"], ["proof (prove)\nusing this:\n  1 dvd n \\<and>\n  (\\<forall>a.\n      coprime a n \\<and> [a = 1] (mod 1) \\<longrightarrow> \\<chi> a = 1)\n\ngoal (1 subgoal):\n 1. \\<forall>a. coprime a n \\<longrightarrow> \\<chi> a = 1", "by simp"], ["proof (state)\nthis:\n  \\<forall>a. coprime a n \\<longrightarrow> \\<chi> a = 1\n\ngoal (2 subgoals):\n 1. induced_modulus 1 \\<Longrightarrow> \\<chi> = principal_dchar n\n 2. \\<chi> = principal_dchar n \\<Longrightarrow> induced_modulus 1", "then"], ["proof (chain)\npicking this:\n  \\<forall>a. coprime a n \\<longrightarrow> \\<chi> a = 1", "show \"\\<chi> = principal_dchar n\""], ["proof (prove)\nusing this:\n  \\<forall>a. coprime a n \\<longrightarrow> \\<chi> a = 1\n\ngoal (1 subgoal):\n 1. \\<chi> = principal_dchar n", "unfolding principal_dchar_def"], ["proof (prove)\nusing this:\n  \\<forall>a. coprime a n \\<longrightarrow> \\<chi> a = 1\n\ngoal (1 subgoal):\n 1. \\<chi> = (\\<lambda>k. if coprime k n then 1 else 0)", "using eq_zero"], ["proof (prove)\nusing this:\n  \\<forall>a. coprime a n \\<longrightarrow> \\<chi> a = 1\n  \\<not> coprime ?a n \\<Longrightarrow> \\<chi> ?a = 0\n\ngoal (1 subgoal):\n 1. \\<chi> = (\\<lambda>k. if coprime k n then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  \\<chi> = principal_dchar n\n\ngoal (1 subgoal):\n 1. \\<chi> = principal_dchar n \\<Longrightarrow> induced_modulus 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<chi> = principal_dchar n \\<Longrightarrow> induced_modulus 1", "assume as: \"\\<chi> = principal_dchar n\""], ["proof (state)\nthis:\n  \\<chi> = principal_dchar n\n\ngoal (1 subgoal):\n 1. \\<chi> = principal_dchar n \\<Longrightarrow> induced_modulus 1", "{"], ["proof (state)\nthis:\n  \\<chi> = principal_dchar n\n\ngoal (1 subgoal):\n 1. \\<chi> = principal_dchar n \\<Longrightarrow> induced_modulus 1", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<chi> = principal_dchar n \\<Longrightarrow> induced_modulus 1", "assume \"coprime a n\""], ["proof (state)\nthis:\n  coprime a n\n\ngoal (1 subgoal):\n 1. \\<chi> = principal_dchar n \\<Longrightarrow> induced_modulus 1", "then"], ["proof (chain)\npicking this:\n  coprime a n", "have \"\\<chi> a = 1\""], ["proof (prove)\nusing this:\n  coprime a n\n\ngoal (1 subgoal):\n 1. \\<chi> a = 1", "using principal_dchar_def as"], ["proof (prove)\nusing this:\n  coprime a n\n  principal_dchar ?n = (\\<lambda>k. if coprime k ?n then 1 else 0)\n  \\<chi> = principal_dchar n\n\ngoal (1 subgoal):\n 1. \\<chi> a = 1", "by simp"], ["proof (state)\nthis:\n  \\<chi> a = 1\n\ngoal (1 subgoal):\n 1. \\<chi> = principal_dchar n \\<Longrightarrow> induced_modulus 1", "}"], ["proof (state)\nthis:\n  coprime ?a2 n \\<Longrightarrow> \\<chi> ?a2 = 1\n\ngoal (1 subgoal):\n 1. \\<chi> = principal_dchar n \\<Longrightarrow> induced_modulus 1", "then"], ["proof (chain)\npicking this:\n  coprime ?a2 n \\<Longrightarrow> \\<chi> ?a2 = 1", "show \"induced_modulus 1\""], ["proof (prove)\nusing this:\n  coprime ?a2 n \\<Longrightarrow> \\<chi> ?a2 = 1\n\ngoal (1 subgoal):\n 1. induced_modulus 1", "unfolding induced_modulus_def"], ["proof (prove)\nusing this:\n  coprime ?a2 n \\<Longrightarrow> \\<chi> ?a2 = 1\n\ngoal (1 subgoal):\n 1. 1 dvd n \\<and>\n    (\\<forall>a.\n        coprime a n \\<and> [a = 1] (mod 1) \\<longrightarrow> \\<chi> a = 1)", "by auto"], ["proof (state)\nthis:\n  induced_modulus 1\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale primitive_dchar = dcharacter +\n  assumes no_induced_modulus: \"\\<not>(\\<exists>d<n. induced_modulus d)\""], ["", "locale nonprimitive_dchar = dcharacter +\n  assumes induced_modulus: \"\\<exists>d<n. induced_modulus d\""], ["", "lemma (in nonprimitive_dchar) nonprimitive: \"\\<not>primitive_dchar n \\<chi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> primitive_dchar n \\<chi>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. primitive_dchar n \\<chi> \\<Longrightarrow> False", "assume \"primitive_dchar n \\<chi>\""], ["proof (state)\nthis:\n  primitive_dchar n \\<chi>\n\ngoal (1 subgoal):\n 1. primitive_dchar n \\<chi> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  primitive_dchar n \\<chi>", "interpret A: primitive_dchar n \"residue_mult_group n\" \\<chi>"], ["proof (prove)\nusing this:\n  primitive_dchar n \\<chi>\n\ngoal (1 subgoal):\n 1. primitive_dchar n \\<chi> &&&\n    residue_mult_group n \\<equiv> residue_mult_group n", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. primitive_dchar n \\<chi> \\<Longrightarrow> False", "from A.no_induced_modulus induced_modulus"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>d<n. A.induced_modulus d)\n  \\<exists>d<n. A.induced_modulus d", "show False"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>d<n. A.induced_modulus d)\n  \\<exists>d<n. A.induced_modulus d\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in dcharacter) primitive_dchar_iff:\n  \"primitive_dchar n \\<chi> \\<longleftrightarrow> \\<not>(\\<exists>d<n. induced_modulus d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primitive_dchar n \\<chi> = (\\<not> (\\<exists>d<n. induced_modulus d))", "unfolding primitive_dchar_def primitive_dchar_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (dcharacter n \\<chi> \\<and> \\<not> (\\<exists>d<n. induced_modulus d)) =\n    (\\<not> (\\<exists>d<n. induced_modulus d))", "using dcharacter_axioms"], ["proof (prove)\nusing this:\n  dcharacter n \\<chi>\n\ngoal (1 subgoal):\n 1. (dcharacter n \\<chi> \\<and> \\<not> (\\<exists>d<n. induced_modulus d)) =\n    (\\<not> (\\<exists>d<n. induced_modulus d))", "by metis"], ["", "lemma (in residues_nat) principal_not_primitive: \n  \"\\<not>primitive_dchar n (principal_dchar n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> primitive_dchar n (principal_dchar n)", "unfolding principal.primitive_dchar_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<not> (\\<exists>d<n. principal.induced_modulus d)", "using principal.one_induced_iff_principal n"], ["proof (prove)\nusing this:\n  principal.induced_modulus 1 = (principal_dchar n = principal_dchar n)\n  1 < n\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (\\<exists>d<n. principal.induced_modulus d)", "by auto"], ["", "lemma (in dcharacter) not_primitive_imp_nonprimitive:\n  assumes \"\\<not>primitive_dchar n \\<chi>\"\n  shows   \"nonprimitive_dchar n \\<chi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonprimitive_dchar n \\<chi>", "using assms dcharacter_axioms"], ["proof (prove)\nusing this:\n  \\<not> primitive_dchar n \\<chi>\n  dcharacter n \\<chi>\n\ngoal (1 subgoal):\n 1. nonprimitive_dchar n \\<chi>", "unfolding nonprimitive_dchar_def primitive_dchar_def\n            primitive_dchar_axioms_def nonprimitive_dchar_axioms_def"], ["proof (prove)\nusing this:\n  \\<not> (dcharacter n \\<chi> \\<and>\n          \\<not> (\\<exists>d<n. induced_modulus d))\n  dcharacter n \\<chi>\n\ngoal (1 subgoal):\n 1. dcharacter n \\<chi> \\<and> (\\<exists>d<n. induced_modulus d)", "by auto"], ["", "text \\<open>Theorem 8.14\\<close>"], ["", "theorem (in dcharacter) prime_nonprincipal_is_primitive:\n  assumes \"prime n\"\n  assumes \"\\<chi> \\<noteq> principal_dchar n\" \n  shows   \"primitive_dchar n \\<chi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primitive_dchar n \\<chi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. primitive_dchar n \\<chi>", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. primitive_dchar n \\<chi>", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. primitive_dchar n \\<chi>", "assume \"induced_modulus m\""], ["proof (state)\nthis:\n  induced_modulus m\n\ngoal (1 subgoal):\n 1. primitive_dchar n \\<chi>", "then"], ["proof (chain)\npicking this:\n  induced_modulus m", "have \"m = n\""], ["proof (prove)\nusing this:\n  induced_modulus m\n\ngoal (1 subgoal):\n 1. m = n", "using assms prime_nat_iff induced_modulus_def\n          one_induced_iff_principal"], ["proof (prove)\nusing this:\n  induced_modulus m\n  prime n\n  \\<chi> \\<noteq> principal_dchar n\n  prime ?n =\n  (1 < ?n \\<and>\n   (\\<forall>m. m dvd ?n \\<longrightarrow> m = 1 \\<or> m = ?n))\n  induced_modulus ?d =\n  (?d dvd n \\<and>\n   (\\<forall>a.\n       coprime a n \\<and> [a = 1] (mod ?d) \\<longrightarrow> \\<chi> a = 1))\n  induced_modulus 1 = (\\<chi> = principal_dchar n)\n\ngoal (1 subgoal):\n 1. m = n", "by blast"], ["proof (state)\nthis:\n  m = n\n\ngoal (1 subgoal):\n 1. primitive_dchar n \\<chi>", "}"], ["proof (state)\nthis:\n  induced_modulus ?m2 \\<Longrightarrow> ?m2 = n\n\ngoal (1 subgoal):\n 1. primitive_dchar n \\<chi>", "then"], ["proof (chain)\npicking this:\n  induced_modulus ?m2 \\<Longrightarrow> ?m2 = n", "show ?thesis"], ["proof (prove)\nusing this:\n  induced_modulus ?m2 \\<Longrightarrow> ?m2 = n\n\ngoal (1 subgoal):\n 1. primitive_dchar n \\<chi>", "using primitive_dchar_iff"], ["proof (prove)\nusing this:\n  induced_modulus ?m2 \\<Longrightarrow> ?m2 = n\n  primitive_dchar n \\<chi> = (\\<not> (\\<exists>d<n. induced_modulus d))\n\ngoal (1 subgoal):\n 1. primitive_dchar n \\<chi>", "by blast"], ["proof (state)\nthis:\n  primitive_dchar n \\<chi>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 8.15\\<close>"], ["", "corollary (in primitive_dchar) primitive_encoding:\n  \"\\<forall>k>0. \\<not>coprime k n \\<longrightarrow> gauss_sum k = 0\" \n  \"\\<forall>k>0. separable k\"\n  \"norm (gauss_sum 1) ^ 2 = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k>0. \\<not> coprime k n \\<longrightarrow> gauss_sum k = 0 &&&\n    \\<forall>k>0. separable k &&& (cmod (gauss_sum 1))\\<^sup>2 = real n", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>0 < k; \\<not> coprime k n\\<rbrakk>\n       \\<Longrightarrow> gauss_sum k = 0\n 2. \\<And>k. 0 < k \\<Longrightarrow> separable k\n 3. (cmod (gauss_sum 1))\\<^sup>2 = real n", "show 1: \"gauss_sum k = 0\" if \"k > 0\" and \"\\<not>coprime k n\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_sum k = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. gauss_sum k \\<noteq> 0 \\<Longrightarrow> False", "assume \"gauss_sum k \\<noteq> 0\""], ["proof (state)\nthis:\n  gauss_sum k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gauss_sum k \\<noteq> 0 \\<Longrightarrow> False", "hence \"induced_modulus (n div gcd k n)\""], ["proof (prove)\nusing this:\n  gauss_sum k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. induced_modulus (n div gcd k n)", "using that"], ["proof (prove)\nusing this:\n  gauss_sum k \\<noteq> 0\n  0 < k\n  \\<not> coprime k n\n\ngoal (1 subgoal):\n 1. induced_modulus (n div gcd k n)", "by (intro g_non_zero_ind_mod) auto"], ["proof (state)\nthis:\n  induced_modulus (n div gcd k n)\n\ngoal (1 subgoal):\n 1. gauss_sum k \\<noteq> 0 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  induced_modulus (n div gcd k n)\n\ngoal (1 subgoal):\n 1. gauss_sum k \\<noteq> 0 \\<Longrightarrow> False", "have \"n div gcd k n < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n div gcd k n < n", "using n that"], ["proof (prove)\nusing this:\n  1 < n\n  0 < k\n  \\<not> coprime k n\n\ngoal (1 subgoal):\n 1. n div gcd k n < n", "by (meson coprime_iff_gcd_eq_1 div_eq_dividend_iff le_less_trans\n                linorder_neqE_nat nat_dvd_not_less principal.div_gcd_dvd2 zero_le_one)"], ["proof (state)\nthis:\n  n div gcd k n < n\n\ngoal (1 subgoal):\n 1. gauss_sum k \\<noteq> 0 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  induced_modulus (n div gcd k n)\n  n div gcd k n < n", "show False"], ["proof (prove)\nusing this:\n  induced_modulus (n div gcd k n)\n  n div gcd k n < n\n\ngoal (1 subgoal):\n 1. False", "using no_induced_modulus"], ["proof (prove)\nusing this:\n  induced_modulus (n div gcd k n)\n  n div gcd k n < n\n  \\<not> (\\<exists>d<n. induced_modulus d)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?k; \\<not> coprime ?k n\\<rbrakk>\n  \\<Longrightarrow> gauss_sum ?k = 0\n\ngoal (2 subgoals):\n 1. \\<And>k. 0 < k \\<Longrightarrow> separable k\n 2. (cmod (gauss_sum 1))\\<^sup>2 = real n", "have \"(\\<forall>n>0. separable n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n>0. separable n", "unfolding global_separability_condition"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k>0. \\<not> coprime k n \\<longrightarrow> gauss_sum k = 0", "by (auto intro!: 1)"], ["proof (state)\nthis:\n  \\<forall>n>0. separable n\n\ngoal (2 subgoals):\n 1. \\<And>k. 0 < k \\<Longrightarrow> separable k\n 2. (cmod (gauss_sum 1))\\<^sup>2 = real n", "thus \"separable n\" if \"n > 0\" for n"], ["proof (prove)\nusing this:\n  \\<forall>n>0. separable n\n\ngoal (1 subgoal):\n 1. separable n", "using that"], ["proof (prove)\nusing this:\n  \\<forall>n>0. separable n\n  0 < n\n\ngoal (1 subgoal):\n 1. separable n", "by blast"], ["proof (state)\nthis:\n  0 < ?n \\<Longrightarrow> separable ?n\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "thus \"norm (gauss_sum 1) ^ 2 = n\""], ["proof (prove)\nusing this:\n  0 < ?n \\<Longrightarrow> separable ?n\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "using gauss_sum_1_mod_square_eq_k"], ["proof (prove)\nusing this:\n  0 < ?n \\<Longrightarrow> separable ?n\n  \\<forall>k>0. separable k \\<Longrightarrow>\n  (cmod (gauss_sum 1))\\<^sup>2 = real n\n\ngoal (1 subgoal):\n 1. (cmod (gauss_sum 1))\\<^sup>2 = real n", "by blast"], ["proof (state)\nthis:\n  (cmod (gauss_sum 1))\\<^sup>2 = real n\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 8.16\\<close>"], ["", "lemma (in dcharacter) induced_modulus_altdef1:\n  \"induced_modulus d \\<longleftrightarrow>\n     d dvd n \\<and> (\\<forall>a b. coprime a n \\<and> coprime b n \\<and> [a = b] (mod d) \\<longrightarrow> \\<chi> a = \\<chi> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. induced_modulus d =\n    (d dvd n \\<and>\n     (\\<forall>a b.\n         coprime a n \\<and>\n         coprime b n \\<and> [a = b] (mod d) \\<longrightarrow>\n         \\<chi> a = \\<chi> b))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. induced_modulus d \\<Longrightarrow>\n    d dvd n \\<and>\n    (\\<forall>a b.\n        coprime a n \\<and>\n        coprime b n \\<and> [a = b] (mod d) \\<longrightarrow>\n        \\<chi> a = \\<chi> b)\n 2. d dvd n \\<and>\n    (\\<forall>a b.\n        coprime a n \\<and>\n        coprime b n \\<and> [a = b] (mod d) \\<longrightarrow>\n        \\<chi> a = \\<chi> b) \\<Longrightarrow>\n    induced_modulus d", "assume 1: \"induced_modulus d\""], ["proof (state)\nthis:\n  induced_modulus d\n\ngoal (2 subgoals):\n 1. induced_modulus d \\<Longrightarrow>\n    d dvd n \\<and>\n    (\\<forall>a b.\n        coprime a n \\<and>\n        coprime b n \\<and> [a = b] (mod d) \\<longrightarrow>\n        \\<chi> a = \\<chi> b)\n 2. d dvd n \\<and>\n    (\\<forall>a b.\n        coprime a n \\<and>\n        coprime b n \\<and> [a = b] (mod d) \\<longrightarrow>\n        \\<chi> a = \\<chi> b) \\<Longrightarrow>\n    induced_modulus d", "with n"], ["proof (chain)\npicking this:\n  1 < n\n  induced_modulus d", "have d: \"d dvd n\" \"d > 0\""], ["proof (prove)\nusing this:\n  1 < n\n  induced_modulus d\n\ngoal (1 subgoal):\n 1. d dvd n &&& 0 < d", "by (auto simp: induced_modulus_def intro: Nat.gr0I)"], ["proof (state)\nthis:\n  d dvd n\n  0 < d\n\ngoal (2 subgoals):\n 1. induced_modulus d \\<Longrightarrow>\n    d dvd n \\<and>\n    (\\<forall>a b.\n        coprime a n \\<and>\n        coprime b n \\<and> [a = b] (mod d) \\<longrightarrow>\n        \\<chi> a = \\<chi> b)\n 2. d dvd n \\<and>\n    (\\<forall>a b.\n        coprime a n \\<and>\n        coprime b n \\<and> [a = b] (mod d) \\<longrightarrow>\n        \\<chi> a = \\<chi> b) \\<Longrightarrow>\n    induced_modulus d", "show \" d dvd n \\<and> (\\<forall>a b. coprime a n \\<and> coprime b n \\<and> [a = b] (mod d) \\<longrightarrow> \\<chi>(a) = \\<chi>(b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d dvd n \\<and>\n    (\\<forall>a b.\n        coprime a n \\<and>\n        coprime b n \\<and> [a = b] (mod d) \\<longrightarrow>\n        \\<chi> a = \\<chi> b)", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. d dvd n\n 2. \\<And>a b.\n       \\<lbrakk>coprime a n; coprime b n; [a = b] (mod d)\\<rbrakk>\n       \\<Longrightarrow> \\<chi> a = \\<chi> b", "fix a b"], ["proof (state)\ngoal (2 subgoals):\n 1. d dvd n\n 2. \\<And>a b.\n       \\<lbrakk>coprime a n; coprime b n; [a = b] (mod d)\\<rbrakk>\n       \\<Longrightarrow> \\<chi> a = \\<chi> b", "assume 2: \"coprime a n\" \"coprime b n\" \"[a = b] (mod d)\""], ["proof (state)\nthis:\n  coprime a n\n  coprime b n\n  [a = b] (mod d)\n\ngoal (2 subgoals):\n 1. d dvd n\n 2. \\<And>a b.\n       \\<lbrakk>coprime a n; coprime b n; [a = b] (mod d)\\<rbrakk>\n       \\<Longrightarrow> \\<chi> a = \\<chi> b", "show \"\\<chi>(a) = \\<chi>(b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<chi> a = \\<chi> b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<chi> a = \\<chi> b", "from 2(1)"], ["proof (chain)\npicking this:\n  coprime a n", "obtain a' where eq: \"[a*a' = 1] (mod n)\""], ["proof (prove)\nusing this:\n  coprime a n\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        [a * a' = 1] (mod n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cong_solve"], ["proof (prove)\nusing this:\n  coprime a n\n  coprime ?a ?n \\<Longrightarrow> \\<exists>x. [?a * x = ?b] (mod ?n)\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        [a * a' = 1] (mod n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  [a * a' = 1] (mod n)\n\ngoal (1 subgoal):\n 1. \\<chi> a = \\<chi> b", "from this d"], ["proof (chain)\npicking this:\n  [a * a' = 1] (mod n)\n  d dvd n\n  0 < d", "have \"[a*a' = 1] (mod d)\""], ["proof (prove)\nusing this:\n  [a * a' = 1] (mod n)\n  d dvd n\n  0 < d\n\ngoal (1 subgoal):\n 1. [a * a' = 1] (mod d)", "using cong_dvd_modulus_nat"], ["proof (prove)\nusing this:\n  [a * a' = 1] (mod n)\n  d dvd n\n  0 < d\n  \\<lbrakk>[?x = ?y] (mod ?m); ?n dvd ?m\\<rbrakk>\n  \\<Longrightarrow> [?x = ?y] (mod ?n)\n\ngoal (1 subgoal):\n 1. [a * a' = 1] (mod d)", "by blast"], ["proof (state)\nthis:\n  [a * a' = 1] (mod d)\n\ngoal (1 subgoal):\n 1. \\<chi> a = \\<chi> b", "from this 1"], ["proof (chain)\npicking this:\n  [a * a' = 1] (mod d)\n  induced_modulus d", "have \"\\<chi>(a*a') = 1\""], ["proof (prove)\nusing this:\n  [a * a' = 1] (mod d)\n  induced_modulus d\n\ngoal (1 subgoal):\n 1. \\<chi> (a * a') = 1", "unfolding induced_modulus_def"], ["proof (prove)\nusing this:\n  [a * a' = 1] (mod d)\n  d dvd n \\<and>\n  (\\<forall>a.\n      coprime a n \\<and> [a = 1] (mod d) \\<longrightarrow> \\<chi> a = 1)\n\ngoal (1 subgoal):\n 1. \\<chi> (a * a') = 1", "by (meson \"2\"(2) eq cong_imp_coprime cong_sym coprime_divisors gcd_nat.refl one_dvd)"], ["proof (state)\nthis:\n  \\<chi> (a * a') = 1\n\ngoal (1 subgoal):\n 1. \\<chi> a = \\<chi> b", "then"], ["proof (chain)\npicking this:\n  \\<chi> (a * a') = 1", "have 3: \"\\<chi>(a)*\\<chi>(a') = 1\""], ["proof (prove)\nusing this:\n  \\<chi> (a * a') = 1\n\ngoal (1 subgoal):\n 1. \\<chi> a * \\<chi> a' = 1", "by simp"], ["proof (state)\nthis:\n  \\<chi> a * \\<chi> a' = 1\n\ngoal (1 subgoal):\n 1. \\<chi> a = \\<chi> b", "from 2(3)"], ["proof (chain)\npicking this:\n  [a = b] (mod d)", "have \"[a*a' = b*a'] (mod d)\""], ["proof (prove)\nusing this:\n  [a = b] (mod d)\n\ngoal (1 subgoal):\n 1. [a * a' = b * a'] (mod d)", "by (simp add: cong_scalar_right)"], ["proof (state)\nthis:\n  [a * a' = b * a'] (mod d)\n\ngoal (1 subgoal):\n 1. \\<chi> a = \\<chi> b", "moreover"], ["proof (state)\nthis:\n  [a * a' = b * a'] (mod d)\n\ngoal (1 subgoal):\n 1. \\<chi> a = \\<chi> b", "have 4: \"[b*a' = 1] (mod d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [b * a' = 1] (mod d)", "using \\<open>[a * a' = 1] (mod d)\\<close> calculation cong_sym cong_trans"], ["proof (prove)\nusing this:\n  [a * a' = 1] (mod d)\n  [a * a' = b * a'] (mod d)\n  [?b = ?c] (mod ?a) \\<Longrightarrow> [?c = ?b] (mod ?a)\n  \\<lbrakk>[?b = ?c] (mod ?a); [?c = ?d] (mod ?a)\\<rbrakk>\n  \\<Longrightarrow> [?b = ?d] (mod ?a)\n\ngoal (1 subgoal):\n 1. [b * a' = 1] (mod d)", "by blast"], ["proof (state)\nthis:\n  [b * a' = 1] (mod d)\n\ngoal (1 subgoal):\n 1. \\<chi> a = \\<chi> b", "have \"\\<chi>(b*a') = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<chi> (b * a') = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<chi> (b * a') = 1", "have \"coprime (b*a') n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (b * a') n", "using \"2\"(2) cong_imp_coprime[OF cong_sym[OF eq]]"], ["proof (prove)\nusing this:\n  coprime b n\n  coprime 1 n \\<Longrightarrow> coprime (a * a') n\n\ngoal (1 subgoal):\n 1. coprime (b * a') n", "by simp"], ["proof (state)\nthis:\n  coprime (b * a') n\n\ngoal (1 subgoal):\n 1. \\<chi> (b * a') = 1", "then"], ["proof (chain)\npicking this:\n  coprime (b * a') n", "show ?thesis"], ["proof (prove)\nusing this:\n  coprime (b * a') n\n\ngoal (1 subgoal):\n 1. \\<chi> (b * a') = 1", "using 4 induced_modulus_def 1"], ["proof (prove)\nusing this:\n  coprime (b * a') n\n  [b * a' = 1] (mod d)\n  induced_modulus ?d =\n  (?d dvd n \\<and>\n   (\\<forall>a.\n       coprime a n \\<and> [a = 1] (mod ?d) \\<longrightarrow> \\<chi> a = 1))\n  induced_modulus d\n\ngoal (1 subgoal):\n 1. \\<chi> (b * a') = 1", "by blast"], ["proof (state)\nthis:\n  \\<chi> (b * a') = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<chi> (b * a') = 1\n\ngoal (1 subgoal):\n 1. \\<chi> a = \\<chi> b", "then"], ["proof (chain)\npicking this:\n  \\<chi> (b * a') = 1", "have 4: \"\\<chi>(b)*\\<chi>(a') = 1\""], ["proof (prove)\nusing this:\n  \\<chi> (b * a') = 1\n\ngoal (1 subgoal):\n 1. \\<chi> b * \\<chi> a' = 1", "by simp"], ["proof (state)\nthis:\n  \\<chi> b * \\<chi> a' = 1\n\ngoal (1 subgoal):\n 1. \\<chi> a = \\<chi> b", "from 3 4"], ["proof (chain)\npicking this:\n  \\<chi> a * \\<chi> a' = 1\n  \\<chi> b * \\<chi> a' = 1", "show \"\\<chi>(a) = \\<chi>(b)\""], ["proof (prove)\nusing this:\n  \\<chi> a * \\<chi> a' = 1\n  \\<chi> b * \\<chi> a' = 1\n\ngoal (1 subgoal):\n 1. \\<chi> a = \\<chi> b", "using mult_cancel_left"], ["proof (prove)\nusing this:\n  \\<chi> a * \\<chi> a' = 1\n  \\<chi> b * \\<chi> a' = 1\n  (?c * ?a = ?c * ?b) = (?c = (0::?'a) \\<or> ?a = ?b)\n\ngoal (1 subgoal):\n 1. \\<chi> a = \\<chi> b", "by (cases \"\\<chi>(a') = 0\") (fastforce simp add: field_simps)+"], ["proof (state)\nthis:\n  \\<chi> a = \\<chi> b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<chi> a = \\<chi> b\n\ngoal (1 subgoal):\n 1. d dvd n", "qed fact+"], ["proof (state)\nthis:\n  d dvd n \\<and>\n  (\\<forall>a b.\n      coprime a n \\<and>\n      coprime b n \\<and> [a = b] (mod d) \\<longrightarrow>\n      \\<chi> a = \\<chi> b)\n\ngoal (1 subgoal):\n 1. d dvd n \\<and>\n    (\\<forall>a b.\n        coprime a n \\<and>\n        coprime b n \\<and> [a = b] (mod d) \\<longrightarrow>\n        \\<chi> a = \\<chi> b) \\<Longrightarrow>\n    induced_modulus d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d dvd n \\<and>\n    (\\<forall>a b.\n        coprime a n \\<and>\n        coprime b n \\<and> [a = b] (mod d) \\<longrightarrow>\n        \\<chi> a = \\<chi> b) \\<Longrightarrow>\n    induced_modulus d", "assume *: \"d dvd n \\<and> (\\<forall>a b. coprime a n \\<and> coprime b n \\<and> [a = b] (mod d) \\<longrightarrow> \\<chi> a = \\<chi> b)\""], ["proof (state)\nthis:\n  d dvd n \\<and>\n  (\\<forall>a b.\n      coprime a n \\<and>\n      coprime b n \\<and> [a = b] (mod d) \\<longrightarrow>\n      \\<chi> a = \\<chi> b)\n\ngoal (1 subgoal):\n 1. d dvd n \\<and>\n    (\\<forall>a b.\n        coprime a n \\<and>\n        coprime b n \\<and> [a = b] (mod d) \\<longrightarrow>\n        \\<chi> a = \\<chi> b) \\<Longrightarrow>\n    induced_modulus d", "then"], ["proof (chain)\npicking this:\n  d dvd n \\<and>\n  (\\<forall>a b.\n      coprime a n \\<and>\n      coprime b n \\<and> [a = b] (mod d) \\<longrightarrow>\n      \\<chi> a = \\<chi> b)", "have \"\\<forall>a . coprime a n \\<and> coprime 1 n \\<and> [a = 1] (mod d) \\<longrightarrow> \\<chi> a = \\<chi> 1\""], ["proof (prove)\nusing this:\n  d dvd n \\<and>\n  (\\<forall>a b.\n      coprime a n \\<and>\n      coprime b n \\<and> [a = b] (mod d) \\<longrightarrow>\n      \\<chi> a = \\<chi> b)\n\ngoal (1 subgoal):\n 1. \\<forall>a.\n       coprime a n \\<and>\n       coprime 1 n \\<and> [a = 1] (mod d) \\<longrightarrow>\n       \\<chi> a = \\<chi> 1", "by blast"], ["proof (state)\nthis:\n  \\<forall>a.\n     coprime a n \\<and> coprime 1 n \\<and> [a = 1] (mod d) \\<longrightarrow>\n     \\<chi> a = \\<chi> 1\n\ngoal (1 subgoal):\n 1. d dvd n \\<and>\n    (\\<forall>a b.\n        coprime a n \\<and>\n        coprime b n \\<and> [a = b] (mod d) \\<longrightarrow>\n        \\<chi> a = \\<chi> b) \\<Longrightarrow>\n    induced_modulus d", "then"], ["proof (chain)\npicking this:\n  \\<forall>a.\n     coprime a n \\<and> coprime 1 n \\<and> [a = 1] (mod d) \\<longrightarrow>\n     \\<chi> a = \\<chi> 1", "have \"\\<forall>a . coprime a n \\<and> [a = 1] (mod d) \\<longrightarrow> \\<chi> a = 1\""], ["proof (prove)\nusing this:\n  \\<forall>a.\n     coprime a n \\<and> coprime 1 n \\<and> [a = 1] (mod d) \\<longrightarrow>\n     \\<chi> a = \\<chi> 1\n\ngoal (1 subgoal):\n 1. \\<forall>a.\n       coprime a n \\<and> [a = 1] (mod d) \\<longrightarrow> \\<chi> a = 1", "using coprime_1_left"], ["proof (prove)\nusing this:\n  \\<forall>a.\n     coprime a n \\<and> coprime 1 n \\<and> [a = 1] (mod d) \\<longrightarrow>\n     \\<chi> a = \\<chi> 1\n  coprime (1::?'a) ?a\n\ngoal (1 subgoal):\n 1. \\<forall>a.\n       coprime a n \\<and> [a = 1] (mod d) \\<longrightarrow> \\<chi> a = 1", "by simp"], ["proof (state)\nthis:\n  \\<forall>a.\n     coprime a n \\<and> [a = 1] (mod d) \\<longrightarrow> \\<chi> a = 1\n\ngoal (1 subgoal):\n 1. d dvd n \\<and>\n    (\\<forall>a b.\n        coprime a n \\<and>\n        coprime b n \\<and> [a = b] (mod d) \\<longrightarrow>\n        \\<chi> a = \\<chi> b) \\<Longrightarrow>\n    induced_modulus d", "then"], ["proof (chain)\npicking this:\n  \\<forall>a.\n     coprime a n \\<and> [a = 1] (mod d) \\<longrightarrow> \\<chi> a = 1", "show \"induced_modulus d\""], ["proof (prove)\nusing this:\n  \\<forall>a.\n     coprime a n \\<and> [a = 1] (mod d) \\<longrightarrow> \\<chi> a = 1\n\ngoal (1 subgoal):\n 1. induced_modulus d", "unfolding induced_modulus_def"], ["proof (prove)\nusing this:\n  \\<forall>a.\n     coprime a n \\<and> [a = 1] (mod d) \\<longrightarrow> \\<chi> a = 1\n\ngoal (1 subgoal):\n 1. d dvd n \\<and>\n    (\\<forall>a.\n        coprime a n \\<and> [a = 1] (mod d) \\<longrightarrow> \\<chi> a = 1)", "using *"], ["proof (prove)\nusing this:\n  \\<forall>a.\n     coprime a n \\<and> [a = 1] (mod d) \\<longrightarrow> \\<chi> a = 1\n  d dvd n \\<and>\n  (\\<forall>a b.\n      coprime a n \\<and>\n      coprime b n \\<and> [a = b] (mod d) \\<longrightarrow>\n      \\<chi> a = \\<chi> b)\n\ngoal (1 subgoal):\n 1. d dvd n \\<and>\n    (\\<forall>a.\n        coprime a n \\<and> [a = 1] (mod d) \\<longrightarrow> \\<chi> a = 1)", "by blast"], ["proof (state)\nthis:\n  induced_modulus d\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Exercise 8.4\\<close>"], ["", "lemma induced_modulus_altdef2_lemma:\n  fixes n a d q :: nat\n  defines \"q \\<equiv> (\\<Prod> p | prime p \\<and> p dvd n \\<and> \\<not> (p dvd a). p)\"\n  defines \"m \\<equiv> a + q * d\"\n  assumes \"n > 0\" \"coprime a d\"\n  shows \"[m = a] (mod d)\" and \"coprime m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [m = a] (mod d) &&& coprime m n", "proof (simp add: assms(2) cong_add_lcancel_0_nat cong_mult_self_right)"], ["proof (state)\ngoal (1 subgoal):\n 1. coprime m n", "have fin: \"finite {p. prime p \\<and> p dvd n \\<and> \\<not> (p dvd a)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}", "by (simp add: assms)"], ["proof (state)\nthis:\n  finite {p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}\n\ngoal (1 subgoal):\n 1. coprime m n", "{"], ["proof (state)\nthis:\n  finite {p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}\n\ngoal (1 subgoal):\n 1. coprime m n", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. coprime m n", "assume 4: \"prime p\" \"p dvd m\" \"p dvd n\""], ["proof (state)\nthis:\n  prime p\n  p dvd m\n  p dvd n\n\ngoal (1 subgoal):\n 1. coprime m n", "have \"p = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = 1", "proof (cases \"p dvd a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p dvd a \\<Longrightarrow> p = 1\n 2. \\<not> p dvd a \\<Longrightarrow> p = 1", "case True"], ["proof (state)\nthis:\n  p dvd a\n\ngoal (2 subgoals):\n 1. p dvd a \\<Longrightarrow> p = 1\n 2. \\<not> p dvd a \\<Longrightarrow> p = 1", "from this assms 4(2)"], ["proof (chain)\npicking this:\n  p dvd a\n  q \\<equiv> \\<Prod>{p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}\n  m \\<equiv> a + q * d\n  0 < n\n  coprime a d\n  p dvd m", "have \"p dvd q*d\""], ["proof (prove)\nusing this:\n  p dvd a\n  q \\<equiv> \\<Prod>{p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}\n  m \\<equiv> a + q * d\n  0 < n\n  coprime a d\n  p dvd m\n\ngoal (1 subgoal):\n 1. p dvd q * d", "by (simp add: dvd_add_right_iff)"], ["proof (state)\nthis:\n  p dvd q * d\n\ngoal (2 subgoals):\n 1. p dvd a \\<Longrightarrow> p = 1\n 2. \\<not> p dvd a \\<Longrightarrow> p = 1", "then"], ["proof (chain)\npicking this:\n  p dvd q * d", "have a1: \"p dvd q \\<or> p dvd d\""], ["proof (prove)\nusing this:\n  p dvd q * d\n\ngoal (1 subgoal):\n 1. p dvd q \\<or> p dvd d", "using 4(1) prime_dvd_mult_iff"], ["proof (prove)\nusing this:\n  p dvd q * d\n  prime p\n  prime ?p \\<Longrightarrow> (?p dvd ?a * ?b) = (?p dvd ?a \\<or> ?p dvd ?b)\n\ngoal (1 subgoal):\n 1. p dvd q \\<or> p dvd d", "by blast"], ["proof (state)\nthis:\n  p dvd q \\<or> p dvd d\n\ngoal (2 subgoals):\n 1. p dvd a \\<Longrightarrow> p = 1\n 2. \\<not> p dvd a \\<Longrightarrow> p = 1", "have a2: \"\\<not> (p dvd q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> p dvd q", "proof (rule ccontr,simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. p dvd q \\<Longrightarrow> False", "assume \"p dvd q\""], ["proof (state)\nthis:\n  p dvd q\n\ngoal (1 subgoal):\n 1. p dvd q \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p dvd q", "have \"p dvd (\\<Prod> p | prime p \\<and> p dvd n \\<and> \\<not> (p dvd a). p)\""], ["proof (prove)\nusing this:\n  p dvd q\n\ngoal (1 subgoal):\n 1. p dvd \\<Prod>{p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}", "unfolding assms"], ["proof (prove)\nusing this:\n  p dvd \\<Prod>{p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}\n\ngoal (1 subgoal):\n 1. p dvd \\<Prod>{p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}", "by simp"], ["proof (state)\nthis:\n  p dvd \\<Prod>{p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}\n\ngoal (1 subgoal):\n 1. p dvd q \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p dvd \\<Prod>{p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}", "have \"\\<exists>x\\<in>{p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}. p dvd x\""], ["proof (prove)\nusing this:\n  p dvd \\<Prod>{p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}.\n       p dvd x", "using prime_dvd_prod_iff[OF fin 4(1)]"], ["proof (prove)\nusing this:\n  p dvd \\<Prod>{p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}\n  (p dvd prod ?f {p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}) =\n  (\\<exists>x\\<in>{p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}.\n      p dvd ?f x)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}.\n       p dvd x", "by simp"], ["proof (state)\nthis:\n  \\<exists>x\\<in>{p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}. p dvd x\n\ngoal (1 subgoal):\n 1. p dvd q \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>{p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}. p dvd x", "obtain x where c: \"p dvd x \\<and> prime x \\<and> \\<not> x dvd a\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>{p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}. p dvd x\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        p dvd x \\<and> prime x \\<and> \\<not> x dvd a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p dvd x \\<and> prime x \\<and> \\<not> x dvd a\n\ngoal (1 subgoal):\n 1. p dvd q \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p dvd x \\<and> prime x \\<and> \\<not> x dvd a", "have \"p = x\""], ["proof (prove)\nusing this:\n  p dvd x \\<and> prime x \\<and> \\<not> x dvd a\n\ngoal (1 subgoal):\n 1. p = x", "using 4(1)"], ["proof (prove)\nusing this:\n  p dvd x \\<and> prime x \\<and> \\<not> x dvd a\n  prime p\n\ngoal (1 subgoal):\n 1. p = x", "by (simp add: primes_dvd_imp_eq)"], ["proof (state)\nthis:\n  p = x\n\ngoal (1 subgoal):\n 1. p dvd q \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p = x", "show \"False\""], ["proof (prove)\nusing this:\n  p = x\n\ngoal (1 subgoal):\n 1. False", "using True c"], ["proof (prove)\nusing this:\n  p = x\n  p dvd a\n  p dvd x \\<and> prime x \\<and> \\<not> x dvd a\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> p dvd q\n\ngoal (2 subgoals):\n 1. p dvd a \\<Longrightarrow> p = 1\n 2. \\<not> p dvd a \\<Longrightarrow> p = 1", "have a3: \"\\<not> (p dvd d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> p dvd d", "using True assms \"4\"(1) coprime_def not_prime_unit"], ["proof (prove)\nusing this:\n  p dvd a\n  q \\<equiv> \\<Prod>{p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}\n  m \\<equiv> a + q * d\n  0 < n\n  coprime a d\n  prime p\n  coprime ?a ?b =\n  (\\<forall>c.\n      c dvd ?a \\<longrightarrow> c dvd ?b \\<longrightarrow> is_unit c)\n  is_unit ?x \\<Longrightarrow> \\<not> prime ?x\n\ngoal (1 subgoal):\n 1. \\<not> p dvd d", "by auto"], ["proof (state)\nthis:\n  \\<not> p dvd d\n\ngoal (2 subgoals):\n 1. p dvd a \\<Longrightarrow> p = 1\n 2. \\<not> p dvd a \\<Longrightarrow> p = 1", "from a1 a2 a3"], ["proof (chain)\npicking this:\n  p dvd q \\<or> p dvd d\n  \\<not> p dvd q\n  \\<not> p dvd d", "show ?thesis"], ["proof (prove)\nusing this:\n  p dvd q \\<or> p dvd d\n  \\<not> p dvd q\n  \\<not> p dvd d\n\ngoal (1 subgoal):\n 1. p = 1", "by simp"], ["proof (state)\nthis:\n  p = 1\n\ngoal (1 subgoal):\n 1. \\<not> p dvd a \\<Longrightarrow> p = 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> p dvd a \\<Longrightarrow> p = 1", "case False"], ["proof (state)\nthis:\n  \\<not> p dvd a\n\ngoal (1 subgoal):\n 1. \\<not> p dvd a \\<Longrightarrow> p = 1", "then"], ["proof (chain)\npicking this:\n  \\<not> p dvd a", "have \"p dvd q\""], ["proof (prove)\nusing this:\n  \\<not> p dvd a\n\ngoal (1 subgoal):\n 1. p dvd q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> p dvd a \\<Longrightarrow> p dvd q", "have in_s: \"p \\<in> {p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> {p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}", "using False 4(3) 4(1)"], ["proof (prove)\nusing this:\n  \\<not> p dvd a\n  p dvd n\n  prime p\n\ngoal (1 subgoal):\n 1. p \\<in> {p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}", "by simp"], ["proof (state)\nthis:\n  p \\<in> {p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}\n\ngoal (1 subgoal):\n 1. \\<not> p dvd a \\<Longrightarrow> p dvd q", "show \"p dvd q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p dvd q", "unfolding assms"], ["proof (prove)\ngoal (1 subgoal):\n 1. p dvd \\<Prod>{p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}", "using dvd_prodI[OF fin in_s ]"], ["proof (prove)\nusing this:\n  ?f p dvd prod ?f {p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}\n\ngoal (1 subgoal):\n 1. p dvd \\<Prod>{p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}", "by fast"], ["proof (state)\nthis:\n  p dvd q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p dvd q\n\ngoal (1 subgoal):\n 1. \\<not> p dvd a \\<Longrightarrow> p = 1", "then"], ["proof (chain)\npicking this:\n  p dvd q", "have \"p dvd q*d\""], ["proof (prove)\nusing this:\n  p dvd q\n\ngoal (1 subgoal):\n 1. p dvd q * d", "by simp"], ["proof (state)\nthis:\n  p dvd q * d\n\ngoal (1 subgoal):\n 1. \\<not> p dvd a \\<Longrightarrow> p = 1", "then"], ["proof (chain)\npicking this:\n  p dvd q * d", "have \"p dvd a\""], ["proof (prove)\nusing this:\n  p dvd q * d\n\ngoal (1 subgoal):\n 1. p dvd a", "using 4(2) assms"], ["proof (prove)\nusing this:\n  p dvd q * d\n  p dvd m\n  q \\<equiv> \\<Prod>{p. prime p \\<and> p dvd n \\<and> \\<not> p dvd a}\n  m \\<equiv> a + q * d\n  0 < n\n  coprime a d\n\ngoal (1 subgoal):\n 1. p dvd a", "by (simp add: dvd_add_left_iff)"], ["proof (state)\nthis:\n  p dvd a\n\ngoal (1 subgoal):\n 1. \\<not> p dvd a \\<Longrightarrow> p = 1", "then"], ["proof (chain)\npicking this:\n  p dvd a", "show ?thesis"], ["proof (prove)\nusing this:\n  p dvd a\n\ngoal (1 subgoal):\n 1. p = 1", "using False"], ["proof (prove)\nusing this:\n  p dvd a\n  \\<not> p dvd a\n\ngoal (1 subgoal):\n 1. p = 1", "by auto"], ["proof (state)\nthis:\n  p = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p = 1\n\ngoal (1 subgoal):\n 1. coprime m n", "}"], ["proof (state)\nthis:\n  \\<lbrakk>prime ?p2; ?p2 dvd m; ?p2 dvd n\\<rbrakk>\n  \\<Longrightarrow> ?p2 = 1\n\ngoal (1 subgoal):\n 1. coprime m n", "note lem = this"], ["proof (state)\nthis:\n  \\<lbrakk>prime ?p2; ?p2 dvd m; ?p2 dvd n\\<rbrakk>\n  \\<Longrightarrow> ?p2 = 1\n\ngoal (1 subgoal):\n 1. coprime m n", "show \"coprime m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime m n", "proof (subst coprime_iff_gcd_eq_1)"], ["proof (state)\ngoal (1 subgoal):\n 1. gcd m n = 1", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. gcd m n = 1", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. gcd m n = 1", "assume \"a dvd m\" \"a dvd n\" \"a \\<noteq> 1\""], ["proof (state)\nthis:\n  a dvd m\n  a dvd n\n  a \\<noteq> 1\n\ngoal (1 subgoal):\n 1. gcd m n = 1", "{"], ["proof (state)\nthis:\n  a dvd m\n  a dvd n\n  a \\<noteq> 1\n\ngoal (1 subgoal):\n 1. gcd m n = 1", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. gcd m n = 1", "assume \"prime p\" \"p dvd a\""], ["proof (state)\nthis:\n  prime p\n  p dvd a\n\ngoal (1 subgoal):\n 1. gcd m n = 1", "then"], ["proof (chain)\npicking this:\n  prime p\n  p dvd a", "have \"p dvd m\" \"p dvd n\""], ["proof (prove)\nusing this:\n  prime p\n  p dvd a\n\ngoal (1 subgoal):\n 1. p dvd m &&& p dvd n", "using \\<open>a dvd m\\<close> \\<open>a dvd n\\<close>"], ["proof (prove)\nusing this:\n  prime p\n  p dvd a\n  a dvd m\n  a dvd n\n\ngoal (1 subgoal):\n 1. p dvd m &&& p dvd n", "by auto"], ["proof (state)\nthis:\n  p dvd m\n  p dvd n\n\ngoal (1 subgoal):\n 1. gcd m n = 1", "from lem"], ["proof (chain)\npicking this:\n  \\<lbrakk>prime ?p2; ?p2 dvd m; ?p2 dvd n\\<rbrakk>\n  \\<Longrightarrow> ?p2 = 1", "have \"p = a\""], ["proof (prove)\nusing this:\n  \\<lbrakk>prime ?p2; ?p2 dvd m; ?p2 dvd n\\<rbrakk>\n  \\<Longrightarrow> ?p2 = 1\n\ngoal (1 subgoal):\n 1. p = a", "using not_prime_1 \\<open>prime p\\<close> \\<open>p dvd m\\<close> \\<open>p dvd n\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime ?p2; ?p2 dvd m; ?p2 dvd n\\<rbrakk>\n  \\<Longrightarrow> ?p2 = 1\n  \\<not> prime (1::?'a)\n  prime p\n  p dvd m\n  p dvd n\n\ngoal (1 subgoal):\n 1. p = a", "by blast"], ["proof (state)\nthis:\n  p = a\n\ngoal (1 subgoal):\n 1. gcd m n = 1", "}"], ["proof (state)\nthis:\n  \\<lbrakk>prime ?p2; ?p2 dvd a\\<rbrakk> \\<Longrightarrow> ?p2 = a\n\ngoal (1 subgoal):\n 1. gcd m n = 1", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>prime ?p2; ?p2 dvd a\\<rbrakk> \\<Longrightarrow> ?p2 = a", "have \"prime a\""], ["proof (prove)\nusing this:\n  \\<lbrakk>prime ?p2; ?p2 dvd a\\<rbrakk> \\<Longrightarrow> ?p2 = a\n\ngoal (1 subgoal):\n 1. prime a", "using prime_prime_factor[of a] \\<open>a \\<noteq> 1\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime ?p2; ?p2 dvd a\\<rbrakk> \\<Longrightarrow> ?p2 = a\n  prime a =\n  (a \\<noteq> 1 \\<and>\n   (\\<forall>p. prime p \\<and> p dvd a \\<longrightarrow> p = a))\n  a \\<noteq> 1\n\ngoal (1 subgoal):\n 1. prime a", "by blast"], ["proof (state)\nthis:\n  prime a\n\ngoal (1 subgoal):\n 1. gcd m n = 1", "then"], ["proof (chain)\npicking this:\n  prime a", "have \"a = 1\""], ["proof (prove)\nusing this:\n  prime a\n\ngoal (1 subgoal):\n 1. a = 1", "using lem \\<open>a dvd m\\<close> \\<open>a dvd n\\<close>"], ["proof (prove)\nusing this:\n  prime a\n  \\<lbrakk>prime ?p2; ?p2 dvd m; ?p2 dvd n\\<rbrakk>\n  \\<Longrightarrow> ?p2 = 1\n  a dvd m\n  a dvd n\n\ngoal (1 subgoal):\n 1. a = 1", "by blast"], ["proof (state)\nthis:\n  a = 1\n\ngoal (1 subgoal):\n 1. gcd m n = 1", "then"], ["proof (chain)\npicking this:\n  a = 1", "have \"False\""], ["proof (prove)\nusing this:\n  a = 1\n\ngoal (1 subgoal):\n 1. False", "using \\<open>a = 1\\<close> \\<open>a \\<noteq> 1\\<close>"], ["proof (prove)\nusing this:\n  a = 1\n  a = 1\n  a \\<noteq> 1\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. gcd m n = 1", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?aa2 dvd m; ?aa2 dvd n; ?aa2 \\<noteq> 1\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. gcd m n = 1", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?aa2 dvd m; ?aa2 dvd n; ?aa2 \\<noteq> 1\\<rbrakk>\n  \\<Longrightarrow> False", "show \"gcd m n = 1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?aa2 dvd m; ?aa2 dvd n; ?aa2 \\<noteq> 1\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. gcd m n = 1", "by blast"], ["proof (state)\nthis:\n  gcd m n = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coprime m n\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 8.17\\<close>"], ["", "text\\<open>The case \\<open>d = 1\\<close> is exactly the case described in @{thm dcharacter.one_induced_iff_principal}.\\<close>"], ["", "theorem (in dcharacter) induced_modulus_altdef2:\n  assumes \"d dvd n\" \"d \\<noteq> 1\" \n  defines \"\\<chi>\\<^sub>1 \\<equiv> principal_dchar n\"\n  shows \"induced_modulus d \\<longleftrightarrow> (\\<exists>\\<Phi>. dcharacter d \\<Phi> \\<and> (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. induced_modulus d =\n    (\\<exists>\\<Phi>.\n        dcharacter d \\<Phi> \\<and>\n        (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. induced_modulus d \\<Longrightarrow>\n    \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k)\n 2. \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k.\n           \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<Longrightarrow>\n    induced_modulus d", "from n"], ["proof (chain)\npicking this:\n  1 < n", "have n_pos: \"n > 0\""], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. 0 < n", "by simp"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. induced_modulus d \\<Longrightarrow>\n    \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k)\n 2. \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k.\n           \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<Longrightarrow>\n    induced_modulus d", "assume as_im: \"induced_modulus d\""], ["proof (state)\nthis:\n  induced_modulus d\n\ngoal (2 subgoals):\n 1. induced_modulus d \\<Longrightarrow>\n    \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k)\n 2. \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k.\n           \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<Longrightarrow>\n    induced_modulus d", "define f where\n    \"f \\<equiv> (\\<lambda>k. k + \n      (if k = 1 then\n         0\n       else (prod id {p. prime p \\<and> p dvd n \\<and> \\<not> (p dvd k)})*d)\n      )\""], ["proof (state)\nthis:\n  f \\<equiv>\n  \\<lambda>k.\n     k +\n     (if k = 1 then 0\n      else prod id {p. prime p \\<and> p dvd n \\<and> \\<not> p dvd k} * d)\n\ngoal (2 subgoals):\n 1. induced_modulus d \\<Longrightarrow>\n    \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k)\n 2. \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k.\n           \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<Longrightarrow>\n    induced_modulus d", "have [simp]: \"f (Suc 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (Suc 0) = 1", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 +\n    (if Suc 0 = 1 then 0\n     else prod id {p. prime p \\<and> p dvd n \\<and> \\<not> p dvd Suc 0} *\n          d) =\n    1", "by simp"], ["proof (state)\nthis:\n  f (Suc 0) = 1\n\ngoal (2 subgoals):\n 1. induced_modulus d \\<Longrightarrow>\n    \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k)\n 2. \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k.\n           \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<Longrightarrow>\n    induced_modulus d", "{"], ["proof (state)\nthis:\n  f (Suc 0) = 1\n\ngoal (2 subgoals):\n 1. induced_modulus d \\<Longrightarrow>\n    \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k)\n 2. \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k.\n           \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<Longrightarrow>\n    induced_modulus d", "fix k"], ["proof (state)\ngoal (2 subgoals):\n 1. induced_modulus d \\<Longrightarrow>\n    \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k)\n 2. \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k.\n           \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<Longrightarrow>\n    induced_modulus d", "assume as: \"coprime k d\""], ["proof (state)\nthis:\n  coprime k d\n\ngoal (2 subgoals):\n 1. induced_modulus d \\<Longrightarrow>\n    \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k)\n 2. \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k.\n           \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<Longrightarrow>\n    induced_modulus d", "hence \"[f k = k] (mod d)\" \"coprime (f k) n\""], ["proof (prove)\nusing this:\n  coprime k d\n\ngoal (1 subgoal):\n 1. [f k = k] (mod d) &&& coprime (f k) n", "using induced_modulus_altdef2_lemma[OF n_pos as]"], ["proof (prove)\nusing this:\n  coprime k d\n  [k +\n   \\<Prod>{p. prime p \\<and> p dvd n \\<and> \\<not> p dvd k} * d = k] (mod d)\n  coprime (k + \\<Prod>{p. prime p \\<and> p dvd n \\<and> \\<not> p dvd k} * d)\n   n\n\ngoal (1 subgoal):\n 1. [f k = k] (mod d) &&& coprime (f k) n", "by (simp_all add: f_def)"], ["proof (state)\nthis:\n  [f k = k] (mod d)\n  coprime (f k) n\n\ngoal (2 subgoals):\n 1. induced_modulus d \\<Longrightarrow>\n    \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k)\n 2. \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k.\n           \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<Longrightarrow>\n    induced_modulus d", "}"], ["proof (state)\nthis:\n  coprime ?k2 d \\<Longrightarrow> [f ?k2 = ?k2] (mod d)\n  coprime ?k2 d \\<Longrightarrow> coprime (f ?k2) n\n\ngoal (2 subgoals):\n 1. induced_modulus d \\<Longrightarrow>\n    \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k)\n 2. \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k.\n           \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<Longrightarrow>\n    induced_modulus d", "note m_prop = this"], ["proof (state)\nthis:\n  coprime ?k2 d \\<Longrightarrow> [f ?k2 = ?k2] (mod d)\n  coprime ?k2 d \\<Longrightarrow> coprime (f ?k2) n\n\ngoal (2 subgoals):\n 1. induced_modulus d \\<Longrightarrow>\n    \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k)\n 2. \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k.\n           \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<Longrightarrow>\n    induced_modulus d", "define \\<Phi> where\n   \"\\<Phi> \\<equiv> (\\<lambda>n. (if \\<not> coprime n d then 0 else \\<chi>(f n)))\""], ["proof (state)\nthis:\n  \\<Phi> \\<equiv> \\<lambda>n. if \\<not> coprime n d then 0 else \\<chi> (f n)\n\ngoal (2 subgoals):\n 1. induced_modulus d \\<Longrightarrow>\n    \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k)\n 2. \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k.\n           \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<Longrightarrow>\n    induced_modulus d", "have \\<Phi>_1: \"\\<Phi> 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> 1 = 1", "unfolding \\<Phi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<not> coprime 1 d then 0 else \\<chi> (f 1)) = 1", "by simp"], ["proof (state)\nthis:\n  \\<Phi> 1 = 1\n\ngoal (2 subgoals):\n 1. induced_modulus d \\<Longrightarrow>\n    \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k)\n 2. \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k.\n           \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<Longrightarrow>\n    induced_modulus d", "from assms(1,2) n"], ["proof (chain)\npicking this:\n  d dvd n\n  d \\<noteq> 1\n  1 < n", "have \"d > 0\""], ["proof (prove)\nusing this:\n  d dvd n\n  d \\<noteq> 1\n  1 < n\n\ngoal (1 subgoal):\n 1. 0 < d", "by (intro Nat.gr0I) auto"], ["proof (state)\nthis:\n  0 < d\n\ngoal (2 subgoals):\n 1. induced_modulus d \\<Longrightarrow>\n    \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k)\n 2. \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k.\n           \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<Longrightarrow>\n    induced_modulus d", "from induced_modulus_altdef1 assms(1) \\<open>d > 0\\<close> as_im"], ["proof (chain)\npicking this:\n  induced_modulus ?d =\n  (?d dvd n \\<and>\n   (\\<forall>a b.\n       coprime a n \\<and>\n       coprime b n \\<and> [a = b] (mod ?d) \\<longrightarrow>\n       \\<chi> a = \\<chi> b))\n  d dvd n\n  0 < d\n  induced_modulus d", "have b: \"(\\<forall>a b. coprime a n \\<and> coprime b n \\<and> \n                 [a = b] (mod d) \\<longrightarrow> \\<chi> a = \\<chi> b)\""], ["proof (prove)\nusing this:\n  induced_modulus ?d =\n  (?d dvd n \\<and>\n   (\\<forall>a b.\n       coprime a n \\<and>\n       coprime b n \\<and> [a = b] (mod ?d) \\<longrightarrow>\n       \\<chi> a = \\<chi> b))\n  d dvd n\n  0 < d\n  induced_modulus d\n\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       coprime a n \\<and>\n       coprime b n \\<and> [a = b] (mod d) \\<longrightarrow>\n       \\<chi> a = \\<chi> b", "by blast"], ["proof (state)\nthis:\n  \\<forall>a b.\n     coprime a n \\<and> coprime b n \\<and> [a = b] (mod d) \\<longrightarrow>\n     \\<chi> a = \\<chi> b\n\ngoal (2 subgoals):\n 1. induced_modulus d \\<Longrightarrow>\n    \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k)\n 2. \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k.\n           \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<Longrightarrow>\n    induced_modulus d", "have \\<Phi>_periodic:  \" \\<forall>a. \\<Phi> (a + d) = \\<Phi> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. \\<Phi> (a + d) = \\<Phi> a", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. \\<Phi> (a + d) = \\<Phi> a", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. \\<Phi> (a + d) = \\<Phi> a", "have \"gcd (a+d) d = gcd a d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (a + d) d = gcd a d", "by auto"], ["proof (state)\nthis:\n  gcd (a + d) d = gcd a d\n\ngoal (1 subgoal):\n 1. \\<And>a. \\<Phi> (a + d) = \\<Phi> a", "then"], ["proof (chain)\npicking this:\n  gcd (a + d) d = gcd a d", "have cop: \"coprime (a+d) d = coprime a d\""], ["proof (prove)\nusing this:\n  gcd (a + d) d = gcd a d\n\ngoal (1 subgoal):\n 1. coprime (a + d) d = coprime a d", "using coprime_iff_gcd_eq_1"], ["proof (prove)\nusing this:\n  gcd (a + d) d = gcd a d\n  coprime ?a ?b = (gcd ?a ?b = (1::?'a))\n\ngoal (1 subgoal):\n 1. coprime (a + d) d = coprime a d", "by presburger"], ["proof (state)\nthis:\n  coprime (a + d) d = coprime a d\n\ngoal (1 subgoal):\n 1. \\<And>a. \\<Phi> (a + d) = \\<Phi> a", "show \"\\<Phi> (a + d) = \\<Phi> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> (a + d) = \\<Phi> a", "proof (cases \"coprime a d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. coprime a d \\<Longrightarrow> \\<Phi> (a + d) = \\<Phi> a\n 2. \\<not> coprime a d \\<Longrightarrow> \\<Phi> (a + d) = \\<Phi> a", "case True"], ["proof (state)\nthis:\n  coprime a d\n\ngoal (2 subgoals):\n 1. coprime a d \\<Longrightarrow> \\<Phi> (a + d) = \\<Phi> a\n 2. \\<not> coprime a d \\<Longrightarrow> \\<Phi> (a + d) = \\<Phi> a", "from True cop"], ["proof (chain)\npicking this:\n  coprime a d\n  coprime (a + d) d = coprime a d", "have cop_ad: \"coprime (a+d) d\""], ["proof (prove)\nusing this:\n  coprime a d\n  coprime (a + d) d = coprime a d\n\ngoal (1 subgoal):\n 1. coprime (a + d) d", "by blast"], ["proof (state)\nthis:\n  coprime (a + d) d\n\ngoal (2 subgoals):\n 1. coprime a d \\<Longrightarrow> \\<Phi> (a + d) = \\<Phi> a\n 2. \\<not> coprime a d \\<Longrightarrow> \\<Phi> (a + d) = \\<Phi> a", "have p1: \"[f (a+d) = f a] (mod d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [f (a + d) = f a] (mod d)", "using m_prop(1)[of \"a+d\", OF cop_ad] \n              m_prop(1)[of \"a\",OF True]"], ["proof (prove)\nusing this:\n  [f (a + d) = a + d] (mod d)\n  [f a = a] (mod d)\n\ngoal (1 subgoal):\n 1. [f (a + d) = f a] (mod d)", "by (simp add: cong_def)"], ["proof (state)\nthis:\n  [f (a + d) = f a] (mod d)\n\ngoal (2 subgoals):\n 1. coprime a d \\<Longrightarrow> \\<Phi> (a + d) = \\<Phi> a\n 2. \\<not> coprime a d \\<Longrightarrow> \\<Phi> (a + d) = \\<Phi> a", "have p2: \"coprime (f (a+d)) n\" \"coprime (f a) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (f (a + d)) n &&& coprime (f a) n", "using m_prop(2)[of \"a+d\", OF cop_ad]\n              m_prop(2)[of \"a\", OF True]"], ["proof (prove)\nusing this:\n  coprime (f (a + d)) n\n  coprime (f a) n\n\ngoal (1 subgoal):\n 1. coprime (f (a + d)) n &&& coprime (f a) n", "by blast+"], ["proof (state)\nthis:\n  coprime (f (a + d)) n\n  coprime (f a) n\n\ngoal (2 subgoals):\n 1. coprime a d \\<Longrightarrow> \\<Phi> (a + d) = \\<Phi> a\n 2. \\<not> coprime a d \\<Longrightarrow> \\<Phi> (a + d) = \\<Phi> a", "from b p1 p2"], ["proof (chain)\npicking this:\n  \\<forall>a b.\n     coprime a n \\<and> coprime b n \\<and> [a = b] (mod d) \\<longrightarrow>\n     \\<chi> a = \\<chi> b\n  [f (a + d) = f a] (mod d)\n  coprime (f (a + d)) n\n  coprime (f a) n", "have eq: \"\\<chi> (f (a + d)) = \\<chi> (f a)\""], ["proof (prove)\nusing this:\n  \\<forall>a b.\n     coprime a n \\<and> coprime b n \\<and> [a = b] (mod d) \\<longrightarrow>\n     \\<chi> a = \\<chi> b\n  [f (a + d) = f a] (mod d)\n  coprime (f (a + d)) n\n  coprime (f a) n\n\ngoal (1 subgoal):\n 1. \\<chi> (f (a + d)) = \\<chi> (f a)", "by blast"], ["proof (state)\nthis:\n  \\<chi> (f (a + d)) = \\<chi> (f a)\n\ngoal (2 subgoals):\n 1. coprime a d \\<Longrightarrow> \\<Phi> (a + d) = \\<Phi> a\n 2. \\<not> coprime a d \\<Longrightarrow> \\<Phi> (a + d) = \\<Phi> a", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> (a + d) = \\<Phi> a", "unfolding \\<Phi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<not> coprime (a + d) d then 0 else \\<chi> (f (a + d))) =\n    (if \\<not> coprime a d then 0 else \\<chi> (f a))", "by (subst cop,simp,safe, simp add: eq)"], ["proof (state)\nthis:\n  \\<Phi> (a + d) = \\<Phi> a\n\ngoal (1 subgoal):\n 1. \\<not> coprime a d \\<Longrightarrow> \\<Phi> (a + d) = \\<Phi> a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> coprime a d \\<Longrightarrow> \\<Phi> (a + d) = \\<Phi> a", "case False"], ["proof (state)\nthis:\n  \\<not> coprime a d\n\ngoal (1 subgoal):\n 1. \\<not> coprime a d \\<Longrightarrow> \\<Phi> (a + d) = \\<Phi> a", "then"], ["proof (chain)\npicking this:\n  \\<not> coprime a d", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> coprime a d\n\ngoal (1 subgoal):\n 1. \\<Phi> (a + d) = \\<Phi> a", "unfolding \\<Phi>_def"], ["proof (prove)\nusing this:\n  \\<not> coprime a d\n\ngoal (1 subgoal):\n 1. (if \\<not> coprime (a + d) d then 0 else \\<chi> (f (a + d))) =\n    (if \\<not> coprime a d then 0 else \\<chi> (f a))", "by (subst cop,simp)"], ["proof (state)\nthis:\n  \\<Phi> (a + d) = \\<Phi> a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi> (a + d) = \\<Phi> a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>a. \\<Phi> (a + d) = \\<Phi> a\n\ngoal (2 subgoals):\n 1. induced_modulus d \\<Longrightarrow>\n    \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k)\n 2. \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k.\n           \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<Longrightarrow>\n    induced_modulus d", "have \\<Phi>_mult: \"\\<forall>a b. a \\<in> totatives d \\<longrightarrow>\n          b \\<in> totatives d \\<longrightarrow> \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       a \\<in> totatives d \\<longrightarrow>\n       b \\<in> totatives d \\<longrightarrow>\n       \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b", "proof (safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> totatives d; b \\<in> totatives d\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> totatives d; b \\<in> totatives d\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b", "assume \"a \\<in> totatives d\" \"b \\<in> totatives d\""], ["proof (state)\nthis:\n  a \\<in> totatives d\n  b \\<in> totatives d\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> totatives d; b \\<in> totatives d\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b", "consider (ab) \"coprime a d \\<and> coprime b d\" | \n             (a)  \"coprime a d \\<and> \\<not> coprime b d\" |\n             (b)  \"coprime b d \\<and> \\<not> coprime a d\" |\n             (n)  \"\\<not> coprime a d \\<and> \\<not> coprime b d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>coprime a d \\<and> coprime b d \\<Longrightarrow> thesis;\n     coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow> thesis;\n     coprime b d \\<and> \\<not> coprime a d \\<Longrightarrow> thesis;\n     \\<not> coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>coprime a d \\<and> coprime b d \\<Longrightarrow> ?thesis;\n   coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow> ?thesis;\n   coprime b d \\<and> \\<not> coprime a d \\<Longrightarrow> ?thesis;\n   \\<not> coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> totatives d; b \\<in> totatives d\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>coprime a d \\<and> coprime b d \\<Longrightarrow> ?thesis;\n   coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow> ?thesis;\n   coprime b d \\<and> \\<not> coprime a d \\<Longrightarrow> ?thesis;\n   \\<not> coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"\\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\""], ["proof (prove)\nusing this:\n  \\<lbrakk>coprime a d \\<and> coprime b d \\<Longrightarrow> ?thesis;\n   coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow> ?thesis;\n   coprime b d \\<and> \\<not> coprime a d \\<Longrightarrow> ?thesis;\n   \\<not> coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. coprime a d \\<and> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 2. coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 3. coprime b d \\<and> \\<not> coprime a d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 4. \\<not> coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b", "case ab"], ["proof (state)\nthis:\n  coprime a d \\<and> coprime b d\n\ngoal (4 subgoals):\n 1. coprime a d \\<and> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 2. coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 3. coprime b d \\<and> \\<not> coprime a d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 4. \\<not> coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b", "then"], ["proof (chain)\npicking this:\n  coprime a d \\<and> coprime b d", "have c_ab: \n        \"coprime (a*b) d\" \"coprime a d\" \"coprime b d\""], ["proof (prove)\nusing this:\n  coprime a d \\<and> coprime b d\n\ngoal (1 subgoal):\n 1. coprime (a * b) d &&& coprime a d &&& coprime b d", "by simp+"], ["proof (state)\nthis:\n  coprime (a * b) d\n  coprime a d\n  coprime b d\n\ngoal (4 subgoals):\n 1. coprime a d \\<and> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 2. coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 3. coprime b d \\<and> \\<not> coprime a d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 4. \\<not> coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b", "then"], ["proof (chain)\npicking this:\n  coprime (a * b) d\n  coprime a d\n  coprime b d", "have p1: \"[f (a * b) = a * b] (mod d)\" \"coprime (f (a * b)) n\""], ["proof (prove)\nusing this:\n  coprime (a * b) d\n  coprime a d\n  coprime b d\n\ngoal (1 subgoal):\n 1. [f (a * b) = a * b] (mod d) &&& coprime (f (a * b)) n", "using m_prop[of \"a*b\", OF c_ab(1)]"], ["proof (prove)\nusing this:\n  coprime (a * b) d\n  coprime a d\n  coprime b d\n  [f (a * b) = a * b] (mod d)\n  coprime (f (a * b)) n\n\ngoal (1 subgoal):\n 1. [f (a * b) = a * b] (mod d) &&& coprime (f (a * b)) n", "by simp+"], ["proof (state)\nthis:\n  [f (a * b) = a * b] (mod d)\n  coprime (f (a * b)) n\n\ngoal (4 subgoals):\n 1. coprime a d \\<and> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 2. coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 3. coprime b d \\<and> \\<not> coprime a d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 4. \\<not> coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b", "moreover"], ["proof (state)\nthis:\n  [f (a * b) = a * b] (mod d)\n  coprime (f (a * b)) n\n\ngoal (4 subgoals):\n 1. coprime a d \\<and> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 2. coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 3. coprime b d \\<and> \\<not> coprime a d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 4. \\<not> coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b", "have p2: \"[f a = a] (mod d)\" \"coprime (f a) n\"\n                    \"[f b = b] (mod d)\" \"coprime (f b) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([f a = a] (mod d) &&& coprime (f a) n) &&&\n    [f b = b] (mod d) &&& coprime (f b) n", "using m_prop[of \"a\",OF c_ab(2)]\n              m_prop[of \"b\",OF c_ab(3) ]"], ["proof (prove)\nusing this:\n  [f a = a] (mod d)\n  coprime (f a) n\n  [f b = b] (mod d)\n  coprime (f b) n\n\ngoal (1 subgoal):\n 1. ([f a = a] (mod d) &&& coprime (f a) n) &&&\n    [f b = b] (mod d) &&& coprime (f b) n", "by simp+"], ["proof (state)\nthis:\n  [f a = a] (mod d)\n  coprime (f a) n\n  [f b = b] (mod d)\n  coprime (f b) n\n\ngoal (4 subgoals):\n 1. coprime a d \\<and> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 2. coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 3. coprime b d \\<and> \\<not> coprime a d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 4. \\<not> coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b", "have p1s: \"[f (a * b) = (f a) * (f b)] (mod d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [f (a * b) = f a * f b] (mod d)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [f (a * b) = f a * f b] (mod d)", "have \"[f (a * b) = a * b] (mod d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [f (a * b) = a * b] (mod d)", "using p1(1)"], ["proof (prove)\nusing this:\n  [f (a * b) = a * b] (mod d)\n\ngoal (1 subgoal):\n 1. [f (a * b) = a * b] (mod d)", "by blast"], ["proof (state)\nthis:\n  [f (a * b) = a * b] (mod d)\n\ngoal (1 subgoal):\n 1. [f (a * b) = f a * f b] (mod d)", "moreover"], ["proof (state)\nthis:\n  [f (a * b) = a * b] (mod d)\n\ngoal (1 subgoal):\n 1. [f (a * b) = f a * f b] (mod d)", "have \"[a * b = f(a) * f(b)] (mod d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a * b = f a * f b] (mod d)", "using p2(1) p2(3)"], ["proof (prove)\nusing this:\n  [f a = a] (mod d)\n  [f b = b] (mod d)\n\ngoal (1 subgoal):\n 1. [a * b = f a * f b] (mod d)", "by (simp add: cong_mult cong_sym)"], ["proof (state)\nthis:\n  [a * b = f a * f b] (mod d)\n\ngoal (1 subgoal):\n 1. [f (a * b) = f a * f b] (mod d)", "ultimately"], ["proof (chain)\npicking this:\n  [f (a * b) = a * b] (mod d)\n  [a * b = f a * f b] (mod d)", "show ?thesis"], ["proof (prove)\nusing this:\n  [f (a * b) = a * b] (mod d)\n  [a * b = f a * f b] (mod d)\n\ngoal (1 subgoal):\n 1. [f (a * b) = f a * f b] (mod d)", "using cong_trans"], ["proof (prove)\nusing this:\n  [f (a * b) = a * b] (mod d)\n  [a * b = f a * f b] (mod d)\n  \\<lbrakk>[?b = ?c] (mod ?a); [?c = ?d] (mod ?a)\\<rbrakk>\n  \\<Longrightarrow> [?b = ?d] (mod ?a)\n\ngoal (1 subgoal):\n 1. [f (a * b) = f a * f b] (mod d)", "by blast"], ["proof (state)\nthis:\n  [f (a * b) = f a * f b] (mod d)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [f (a * b) = f a * f b] (mod d)\n\ngoal (4 subgoals):\n 1. coprime a d \\<and> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 2. coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 3. coprime b d \\<and> \\<not> coprime a d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 4. \\<not> coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b", "have p2s: \"coprime (f a*f b) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (f a * f b) n", "using p2(2) p2(4)"], ["proof (prove)\nusing this:\n  coprime (f a) n\n  coprime (f b) n\n\ngoal (1 subgoal):\n 1. coprime (f a * f b) n", "by simp"], ["proof (state)\nthis:\n  coprime (f a * f b) n\n\ngoal (4 subgoals):\n 1. coprime a d \\<and> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 2. coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 3. coprime b d \\<and> \\<not> coprime a d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 4. \\<not> coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b", "have \"\\<chi> (f (a * b)) = \\<chi> (f a * f b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<chi> (f (a * b)) = \\<chi> (f a * f b)", "using p1s p2s p1(2) b"], ["proof (prove)\nusing this:\n  [f (a * b) = f a * f b] (mod d)\n  coprime (f a * f b) n\n  coprime (f (a * b)) n\n  \\<forall>a b.\n     coprime a n \\<and> coprime b n \\<and> [a = b] (mod d) \\<longrightarrow>\n     \\<chi> a = \\<chi> b\n\ngoal (1 subgoal):\n 1. \\<chi> (f (a * b)) = \\<chi> (f a * f b)", "by blast"], ["proof (state)\nthis:\n  \\<chi> (f (a * b)) = \\<chi> (f a * f b)\n\ngoal (4 subgoals):\n 1. coprime a d \\<and> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 2. coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 3. coprime b d \\<and> \\<not> coprime a d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 4. \\<not> coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b", "then"], ["proof (chain)\npicking this:\n  \\<chi> (f (a * b)) = \\<chi> (f a * f b)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<chi> (f (a * b)) = \\<chi> (f a * f b)\n\ngoal (1 subgoal):\n 1. \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b", "unfolding \\<Phi>_def"], ["proof (prove)\nusing this:\n  \\<chi> (f (a * b)) = \\<chi> (f a * f b)\n\ngoal (1 subgoal):\n 1. (if \\<not> coprime (a * b) d then 0 else \\<chi> (f (a * b))) =\n    (if \\<not> coprime a d then 0 else \\<chi> (f a)) *\n    (if \\<not> coprime b d then 0 else \\<chi> (f b))", "by (simp add: c_ab)"], ["proof (state)\nthis:\n  \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n\ngoal (3 subgoals):\n 1. coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 2. coprime b d \\<and> \\<not> coprime a d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n 3. \\<not> coprime a d \\<and> \\<not> coprime b d \\<Longrightarrow>\n    \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b", "qed (simp_all add: \\<Phi>_def)"], ["proof (state)\nthis:\n  \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>a b.\n     a \\<in> totatives d \\<longrightarrow>\n     b \\<in> totatives d \\<longrightarrow>\n     \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n\ngoal (2 subgoals):\n 1. induced_modulus d \\<Longrightarrow>\n    \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k)\n 2. \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k.\n           \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<Longrightarrow>\n    induced_modulus d", "have d_gr_1: \"d > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < d", "using assms(1,2)"], ["proof (prove)\nusing this:\n  d dvd n\n  d \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 1 < d", "using \\<open>0 < d\\<close>"], ["proof (prove)\nusing this:\n  d dvd n\n  d \\<noteq> 1\n  0 < d\n\ngoal (1 subgoal):\n 1. 1 < d", "by linarith"], ["proof (state)\nthis:\n  1 < d\n\ngoal (2 subgoals):\n 1. induced_modulus d \\<Longrightarrow>\n    \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k)\n 2. \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k.\n           \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<Longrightarrow>\n    induced_modulus d", "show \"\\<exists>\\<Phi>. dcharacter d \\<Phi> \\<and> (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n)", "proof (standard,rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. dcharacter d ?\\<Phi>\n 2. \\<forall>n. \\<chi> n = ?\\<Phi> n * \\<chi>\\<^sub>1 n", "show \"dcharacter d \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dcharacter d \\<Phi>", "unfolding dcharacter_def residues_nat_def dcharacter_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < d \\<and>\n    ((\\<forall>a b.\n         a \\<in> totatives d \\<longrightarrow>\n         b \\<in> totatives d \\<longrightarrow>\n         \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b) \\<and>\n     (\\<forall>a. \\<not> coprime a d \\<longrightarrow> \\<Phi> a = 0)) \\<and>\n    (\\<forall>a. \\<Phi> (a + d) = \\<Phi> a) \\<and> \\<Phi> 1 \\<noteq> 0", "using d_gr_1 \\<Phi>_def f_def \\<Phi>_mult \\<Phi>_1 \\<Phi>_periodic"], ["proof (prove)\nusing this:\n  1 < d\n  \\<Phi> \\<equiv> \\<lambda>n. if \\<not> coprime n d then 0 else \\<chi> (f n)\n  f \\<equiv>\n  \\<lambda>k.\n     k +\n     (if k = 1 then 0\n      else prod id {p. prime p \\<and> p dvd n \\<and> \\<not> p dvd k} * d)\n  \\<forall>a b.\n     a \\<in> totatives d \\<longrightarrow>\n     b \\<in> totatives d \\<longrightarrow>\n     \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b\n  \\<Phi> 1 = 1\n  \\<forall>a. \\<Phi> (a + d) = \\<Phi> a\n\ngoal (1 subgoal):\n 1. 1 < d \\<and>\n    ((\\<forall>a b.\n         a \\<in> totatives d \\<longrightarrow>\n         b \\<in> totatives d \\<longrightarrow>\n         \\<Phi> (a * b) = \\<Phi> a * \\<Phi> b) \\<and>\n     (\\<forall>a. \\<not> coprime a d \\<longrightarrow> \\<Phi> a = 0)) \\<and>\n    (\\<forall>a. \\<Phi> (a + d) = \\<Phi> a) \\<and> \\<Phi> 1 \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  dcharacter d \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n", "show \"\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n", "show \"\\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "proof (cases \"coprime k n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. coprime k n \\<Longrightarrow> \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k\n 2. \\<not> coprime k n \\<Longrightarrow>\n    \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "case True"], ["proof (state)\nthis:\n  coprime k n\n\ngoal (2 subgoals):\n 1. coprime k n \\<Longrightarrow> \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k\n 2. \\<not> coprime k n \\<Longrightarrow>\n    \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "then"], ["proof (chain)\npicking this:\n  coprime k n", "have \"coprime k d\""], ["proof (prove)\nusing this:\n  coprime k n\n\ngoal (1 subgoal):\n 1. coprime k d", "using assms(1)"], ["proof (prove)\nusing this:\n  coprime k n\n  d dvd n\n\ngoal (1 subgoal):\n 1. coprime k d", "by auto"], ["proof (state)\nthis:\n  coprime k d\n\ngoal (2 subgoals):\n 1. coprime k n \\<Longrightarrow> \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k\n 2. \\<not> coprime k n \\<Longrightarrow>\n    \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "then"], ["proof (chain)\npicking this:\n  coprime k d", "have \"\\<Phi>(k) = \\<chi>(f k)\""], ["proof (prove)\nusing this:\n  coprime k d\n\ngoal (1 subgoal):\n 1. \\<Phi> k = \\<chi> (f k)", "using \\<Phi>_def"], ["proof (prove)\nusing this:\n  coprime k d\n  \\<Phi> \\<equiv> \\<lambda>n. if \\<not> coprime n d then 0 else \\<chi> (f n)\n\ngoal (1 subgoal):\n 1. \\<Phi> k = \\<chi> (f k)", "by simp"], ["proof (state)\nthis:\n  \\<Phi> k = \\<chi> (f k)\n\ngoal (2 subgoals):\n 1. coprime k n \\<Longrightarrow> \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k\n 2. \\<not> coprime k n \\<Longrightarrow>\n    \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "moreover"], ["proof (state)\nthis:\n  \\<Phi> k = \\<chi> (f k)\n\ngoal (2 subgoals):\n 1. coprime k n \\<Longrightarrow> \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k\n 2. \\<not> coprime k n \\<Longrightarrow>\n    \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "have \"[f k = k] (mod d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [f k = k] (mod d)", "using m_prop[OF \\<open>coprime k d\\<close>]"], ["proof (prove)\nusing this:\n  [f k = k] (mod d)\n  coprime (f k) n\n\ngoal (1 subgoal):\n 1. [f k = k] (mod d)", "by simp"], ["proof (state)\nthis:\n  [f k = k] (mod d)\n\ngoal (2 subgoals):\n 1. coprime k n \\<Longrightarrow> \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k\n 2. \\<not> coprime k n \\<Longrightarrow>\n    \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "moreover"], ["proof (state)\nthis:\n  [f k = k] (mod d)\n\ngoal (2 subgoals):\n 1. coprime k n \\<Longrightarrow> \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k\n 2. \\<not> coprime k n \\<Longrightarrow>\n    \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "have \"\\<chi>\\<^sub>1 k = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<chi>\\<^sub>1 k = 1", "using assms(3) principal_dchar_def \\<open>coprime k n\\<close>"], ["proof (prove)\nusing this:\n  \\<chi>\\<^sub>1 \\<equiv> principal_dchar n\n  principal_dchar ?n = (\\<lambda>k. if coprime k ?n then 1 else 0)\n  coprime k n\n\ngoal (1 subgoal):\n 1. \\<chi>\\<^sub>1 k = 1", "by auto"], ["proof (state)\nthis:\n  \\<chi>\\<^sub>1 k = 1\n\ngoal (2 subgoals):\n 1. coprime k n \\<Longrightarrow> \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k\n 2. \\<not> coprime k n \\<Longrightarrow>\n    \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "ultimately"], ["proof (chain)\npicking this:\n  \\<Phi> k = \\<chi> (f k)\n  [f k = k] (mod d)\n  \\<chi>\\<^sub>1 k = 1", "show \"\\<chi>(k) = \\<Phi>(k) * \\<chi>\\<^sub>1(k)\""], ["proof (prove)\nusing this:\n  \\<Phi> k = \\<chi> (f k)\n  [f k = k] (mod d)\n  \\<chi>\\<^sub>1 k = 1\n\ngoal (1 subgoal):\n 1. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Phi> k = \\<chi> (f k); [f k = k] (mod d);\n     \\<chi>\\<^sub>1 k = 1\\<rbrakk>\n    \\<Longrightarrow> \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "assume \"\\<Phi> k = \\<chi> (f k)\" \"[f k = k] (mod d)\" \"\\<chi>\\<^sub>1 k = 1\""], ["proof (state)\nthis:\n  \\<Phi> k = \\<chi> (f k)\n  [f k = k] (mod d)\n  \\<chi>\\<^sub>1 k = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Phi> k = \\<chi> (f k); [f k = k] (mod d);\n     \\<chi>\\<^sub>1 k = 1\\<rbrakk>\n    \\<Longrightarrow> \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "then"], ["proof (chain)\npicking this:\n  \\<Phi> k = \\<chi> (f k)\n  [f k = k] (mod d)\n  \\<chi>\\<^sub>1 k = 1", "have \"\\<chi> k = \\<chi> (f k)\""], ["proof (prove)\nusing this:\n  \\<Phi> k = \\<chi> (f k)\n  [f k = k] (mod d)\n  \\<chi>\\<^sub>1 k = 1\n\ngoal (1 subgoal):\n 1. \\<chi> k = \\<chi> (f k)", "using \\<open>local.induced_modulus d\\<close> induced_modulus_altdef1 assms(1) \\<open>d > 0\\<close>\n                  True \\<open>coprime k d\\<close> m_prop(2)"], ["proof (prove)\nusing this:\n  \\<Phi> k = \\<chi> (f k)\n  [f k = k] (mod d)\n  \\<chi>\\<^sub>1 k = 1\n  induced_modulus d\n  induced_modulus ?d =\n  (?d dvd n \\<and>\n   (\\<forall>a b.\n       coprime a n \\<and>\n       coprime b n \\<and> [a = b] (mod ?d) \\<longrightarrow>\n       \\<chi> a = \\<chi> b))\n  d dvd n\n  0 < d\n  coprime k n\n  coprime k d\n  coprime ?k2 d \\<Longrightarrow> coprime (f ?k2) n\n\ngoal (1 subgoal):\n 1. \\<chi> k = \\<chi> (f k)", "by auto"], ["proof (state)\nthis:\n  \\<chi> k = \\<chi> (f k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Phi> k = \\<chi> (f k); [f k = k] (mod d);\n     \\<chi>\\<^sub>1 k = 1\\<rbrakk>\n    \\<Longrightarrow> \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "also"], ["proof (state)\nthis:\n  \\<chi> k = \\<chi> (f k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Phi> k = \\<chi> (f k); [f k = k] (mod d);\n     \\<chi>\\<^sub>1 k = 1\\<rbrakk>\n    \\<Longrightarrow> \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "have \"\\<dots> = \\<Phi> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<chi> (f k) = \\<Phi> k", "by (simp add: \\<open>\\<Phi> k = \\<chi> (f k)\\<close>)"], ["proof (state)\nthis:\n  \\<chi> (f k) = \\<Phi> k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Phi> k = \\<chi> (f k); [f k = k] (mod d);\n     \\<chi>\\<^sub>1 k = 1\\<rbrakk>\n    \\<Longrightarrow> \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "also"], ["proof (state)\nthis:\n  \\<chi> (f k) = \\<Phi> k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Phi> k = \\<chi> (f k); [f k = k] (mod d);\n     \\<chi>\\<^sub>1 k = 1\\<rbrakk>\n    \\<Longrightarrow> \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "have \"\\<dots> = \\<Phi> k * \\<chi>\\<^sub>1 k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "by (simp add: \\<open>\\<chi>\\<^sub>1 k = 1\\<close>)"], ["proof (state)\nthis:\n  \\<Phi> k = \\<Phi> k * \\<chi>\\<^sub>1 k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Phi> k = \\<chi> (f k); [f k = k] (mod d);\n     \\<chi>\\<^sub>1 k = 1\\<rbrakk>\n    \\<Longrightarrow> \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "finally"], ["proof (chain)\npicking this:\n  \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k\n\ngoal (1 subgoal):\n 1. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "by simp"], ["proof (state)\nthis:\n  \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k\n\ngoal (1 subgoal):\n 1. \\<not> coprime k n \\<Longrightarrow>\n    \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> coprime k n \\<Longrightarrow>\n    \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "case False"], ["proof (state)\nthis:\n  \\<not> coprime k n\n\ngoal (1 subgoal):\n 1. \\<not> coprime k n \\<Longrightarrow>\n    \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "hence \"\\<chi> k = 0\""], ["proof (prove)\nusing this:\n  \\<not> coprime k n\n\ngoal (1 subgoal):\n 1. \\<chi> k = 0", "using eq_zero_iff"], ["proof (prove)\nusing this:\n  \\<not> coprime k n\n  (\\<chi> ?x = 0) = (\\<not> coprime ?x n)\n\ngoal (1 subgoal):\n 1. \\<chi> k = 0", "by blast"], ["proof (state)\nthis:\n  \\<chi> k = 0\n\ngoal (1 subgoal):\n 1. \\<not> coprime k n \\<Longrightarrow>\n    \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "moreover"], ["proof (state)\nthis:\n  \\<chi> k = 0\n\ngoal (1 subgoal):\n 1. \\<not> coprime k n \\<Longrightarrow>\n    \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "have \"\\<chi>\\<^sub>1 k = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<chi>\\<^sub>1 k = 0", "using False assms(3) principal_dchar_def"], ["proof (prove)\nusing this:\n  \\<not> coprime k n\n  \\<chi>\\<^sub>1 \\<equiv> principal_dchar n\n  principal_dchar ?n = (\\<lambda>k. if coprime k ?n then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<chi>\\<^sub>1 k = 0", "by simp"], ["proof (state)\nthis:\n  \\<chi>\\<^sub>1 k = 0\n\ngoal (1 subgoal):\n 1. \\<not> coprime k n \\<Longrightarrow>\n    \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "ultimately"], ["proof (chain)\npicking this:\n  \\<chi> k = 0\n  \\<chi>\\<^sub>1 k = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<chi> k = 0\n  \\<chi>\\<^sub>1 k = 0\n\ngoal (1 subgoal):\n 1. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "by simp"], ["proof (state)\nthis:\n  \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>\\<Phi>.\n     dcharacter d \\<Phi> \\<and>\n     (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k.\n           \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<Longrightarrow>\n    induced_modulus d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k.\n           \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<Longrightarrow>\n    induced_modulus d", "assume \"(\\<exists>\\<Phi>. dcharacter d \\<Phi> \\<and> (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k))\""], ["proof (state)\nthis:\n  \\<exists>\\<Phi>.\n     dcharacter d \\<Phi> \\<and>\n     (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k.\n           \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<Longrightarrow>\n    induced_modulus d", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<Phi>.\n     dcharacter d \\<Phi> \\<and>\n     (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k)", "obtain \\<Phi> where 1: \"dcharacter d \\<Phi>\" \"(\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k)\""], ["proof (prove)\nusing this:\n  \\<exists>\\<Phi>.\n     dcharacter d \\<Phi> \\<and>\n     (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Phi>.\n        \\<lbrakk>dcharacter d \\<Phi>;\n         \\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  dcharacter d \\<Phi>\n  \\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       dcharacter d \\<Phi> \\<and>\n       (\\<forall>k.\n           \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<Longrightarrow>\n    induced_modulus d", "show \"induced_modulus d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. induced_modulus d", "unfolding induced_modulus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. d dvd n \\<and>\n    (\\<forall>a.\n        coprime a n \\<and> [a = 1] (mod d) \\<longrightarrow> \\<chi> a = 1)", "proof (rule conjI,fact,safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>coprime a n; [a = 1] (mod d)\\<rbrakk>\n       \\<Longrightarrow> \\<chi> a = 1", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>coprime a n; [a = 1] (mod d)\\<rbrakk>\n       \\<Longrightarrow> \\<chi> a = 1", "assume 2: \"coprime k n\" \"[k = 1] (mod d)\""], ["proof (state)\nthis:\n  coprime k n\n  [k = 1] (mod d)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>coprime a n; [a = 1] (mod d)\\<rbrakk>\n       \\<Longrightarrow> \\<chi> a = 1", "then"], ["proof (chain)\npicking this:\n  coprime k n\n  [k = 1] (mod d)", "have \"\\<chi>\\<^sub>1 k = 1\" \"\\<Phi> k = 1\""], ["proof (prove)\nusing this:\n  coprime k n\n  [k = 1] (mod d)\n\ngoal (1 subgoal):\n 1. \\<chi>\\<^sub>1 k = 1 &&& \\<Phi> k = 1", "proof (simp add: assms(3) principal_dchar_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> k = 1", "have \"\\<Phi> k = \\<Phi> (k mod d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> k = \\<Phi> (k mod d)", "by (simp add: dcharacter.mod[OF 1(1), of k])"], ["proof (state)\nthis:\n  \\<Phi> k = \\<Phi> (k mod d)\n\ngoal (1 subgoal):\n 1. \\<Phi> k = 1", "also"], ["proof (state)\nthis:\n  \\<Phi> k = \\<Phi> (k mod d)\n\ngoal (1 subgoal):\n 1. \\<Phi> k = 1", "have \"\\<dots> = \\<Phi> (1 mod d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> (k mod d) = \\<Phi> (1 mod d)", "using cong_def[of k 1 d] 2(2)"], ["proof (prove)\nusing this:\n  [k = 1] (mod d) = (k mod d = 1 mod d)\n  [k = 1] (mod d)\n\ngoal (1 subgoal):\n 1. \\<Phi> (k mod d) = \\<Phi> (1 mod d)", "by simp"], ["proof (state)\nthis:\n  \\<Phi> (k mod d) = \\<Phi> (1 mod d)\n\ngoal (1 subgoal):\n 1. \\<Phi> k = 1", "also"], ["proof (state)\nthis:\n  \\<Phi> (k mod d) = \\<Phi> (1 mod d)\n\ngoal (1 subgoal):\n 1. \\<Phi> k = 1", "have \"\\<dots> = \\<Phi> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> (1 mod d) = \\<Phi> 1", "using assms(2) \"1\"(1) dcharacter.mod"], ["proof (prove)\nusing this:\n  d \\<noteq> 1\n  dcharacter d \\<Phi>\n  dcharacter ?n ?\\<chi> \\<Longrightarrow> ?\\<chi> (?a mod ?n) = ?\\<chi> ?a\n\ngoal (1 subgoal):\n 1. \\<Phi> (1 mod d) = \\<Phi> 1", "by blast"], ["proof (state)\nthis:\n  \\<Phi> (1 mod d) = \\<Phi> 1\n\ngoal (1 subgoal):\n 1. \\<Phi> k = 1", "also"], ["proof (state)\nthis:\n  \\<Phi> (1 mod d) = \\<Phi> 1\n\ngoal (1 subgoal):\n 1. \\<Phi> k = 1", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> 1 = 1", "using dcharacter.Suc_0[OF 1(1)]"], ["proof (prove)\nusing this:\n  \\<Phi> (Suc 0) = 1\n\ngoal (1 subgoal):\n 1. \\<Phi> 1 = 1", "by simp"], ["proof (state)\nthis:\n  \\<Phi> 1 = 1\n\ngoal (1 subgoal):\n 1. \\<Phi> k = 1", "finally"], ["proof (chain)\npicking this:\n  \\<Phi> k = 1", "show \"\\<Phi> k = 1\""], ["proof (prove)\nusing this:\n  \\<Phi> k = 1\n\ngoal (1 subgoal):\n 1. \\<Phi> k = 1", "by simp"], ["proof (state)\nthis:\n  \\<Phi> k = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<chi>\\<^sub>1 k = 1\n  \\<Phi> k = 1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>coprime a n; [a = 1] (mod d)\\<rbrakk>\n       \\<Longrightarrow> \\<chi> a = 1", "then"], ["proof (chain)\npicking this:\n  \\<chi>\\<^sub>1 k = 1\n  \\<Phi> k = 1", "show \"\\<chi> k = 1\""], ["proof (prove)\nusing this:\n  \\<chi>\\<^sub>1 k = 1\n  \\<Phi> k = 1\n\ngoal (1 subgoal):\n 1. \\<chi> k = 1", "using 1(2)"], ["proof (prove)\nusing this:\n  \\<chi>\\<^sub>1 k = 1\n  \\<Phi> k = 1\n  \\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k\n\ngoal (1 subgoal):\n 1. \\<chi> k = 1", "by simp"], ["proof (state)\nthis:\n  \\<chi> k = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  induced_modulus d\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The conductor of a character\\<close>"], ["", "context dcharacter\nbegin"], ["", "definition \"conductor = Min {d. induced_modulus d}\""], ["", "lemma conductor_fin: \"finite {d. induced_modulus d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Collect induced_modulus)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (Collect induced_modulus)", "let ?A = \"{d. induced_modulus d}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (Collect induced_modulus)", "have \"?A \\<subseteq> {d. d dvd n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect induced_modulus \\<subseteq> {d. d dvd n}", "unfolding induced_modulus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {d. d dvd n \\<and>\n        (\\<forall>a.\n            coprime a n \\<and> [a = 1] (mod d) \\<longrightarrow>\n            \\<chi> a = 1)}\n    \\<subseteq> {d. d dvd n}", "by blast"], ["proof (state)\nthis:\n  Collect induced_modulus \\<subseteq> {d. d dvd n}\n\ngoal (1 subgoal):\n 1. finite (Collect induced_modulus)", "moreover"], ["proof (state)\nthis:\n  Collect induced_modulus \\<subseteq> {d. d dvd n}\n\ngoal (1 subgoal):\n 1. finite (Collect induced_modulus)", "have \"finite {d. d dvd n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {d. d dvd n}", "using n"], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. finite {d. d dvd n}", "by simp"], ["proof (state)\nthis:\n  finite {d. d dvd n}\n\ngoal (1 subgoal):\n 1. finite (Collect induced_modulus)", "ultimately"], ["proof (chain)\npicking this:\n  Collect induced_modulus \\<subseteq> {d. d dvd n}\n  finite {d. d dvd n}", "show \"finite ?A\""], ["proof (prove)\nusing this:\n  Collect induced_modulus \\<subseteq> {d. d dvd n}\n  finite {d. d dvd n}\n\ngoal (1 subgoal):\n 1. finite (Collect induced_modulus)", "using finite_subset"], ["proof (prove)\nusing this:\n  Collect induced_modulus \\<subseteq> {d. d dvd n}\n  finite {d. d dvd n}\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite (Collect induced_modulus)", "by auto"], ["proof (state)\nthis:\n  finite (Collect induced_modulus)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma conductor_induced: \"induced_modulus conductor\""], ["proof (prove)\ngoal (1 subgoal):\n 1. induced_modulus conductor", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. induced_modulus conductor", "have \"{d. induced_modulus d} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect induced_modulus \\<noteq> {}", "using induced_modulus_modulus"], ["proof (prove)\nusing this:\n  induced_modulus n\n\ngoal (1 subgoal):\n 1. Collect induced_modulus \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  Collect induced_modulus \\<noteq> {}\n\ngoal (1 subgoal):\n 1. induced_modulus conductor", "then"], ["proof (chain)\npicking this:\n  Collect induced_modulus \\<noteq> {}", "show \"induced_modulus conductor\""], ["proof (prove)\nusing this:\n  Collect induced_modulus \\<noteq> {}\n\ngoal (1 subgoal):\n 1. induced_modulus conductor", "using Min_in[OF conductor_fin ] conductor_def"], ["proof (prove)\nusing this:\n  Collect induced_modulus \\<noteq> {}\n  Collect induced_modulus \\<noteq> {} \\<Longrightarrow>\n  Min (Collect induced_modulus) \\<in> Collect induced_modulus\n  conductor = Min (Collect induced_modulus)\n\ngoal (1 subgoal):\n 1. induced_modulus conductor", "by auto"], ["proof (state)\nthis:\n  induced_modulus conductor\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma conductor_le_iff: \"conductor \\<le> a \\<longleftrightarrow> (\\<exists>d\\<le>a. induced_modulus d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (conductor \\<le> a) = (\\<exists>d\\<le>a. induced_modulus d)", "unfolding conductor_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Min (Collect induced_modulus) \\<le> a) =\n    (\\<exists>d\\<le>a. induced_modulus d)", "using conductor_fin induced_modulus_modulus"], ["proof (prove)\nusing this:\n  finite (Collect induced_modulus)\n  induced_modulus n\n\ngoal (1 subgoal):\n 1. (Min (Collect induced_modulus) \\<le> a) =\n    (\\<exists>d\\<le>a. induced_modulus d)", "by (subst Min_le_iff) auto"], ["", "lemma conductor_ge_iff: \"conductor \\<ge> a \\<longleftrightarrow> (\\<forall>d. induced_modulus d \\<longrightarrow> d \\<ge> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<le> conductor) =\n    (\\<forall>d. induced_modulus d \\<longrightarrow> a \\<le> d)", "unfolding conductor_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<le> Min (Collect induced_modulus)) =\n    (\\<forall>d. induced_modulus d \\<longrightarrow> a \\<le> d)", "using conductor_fin induced_modulus_modulus"], ["proof (prove)\nusing this:\n  finite (Collect induced_modulus)\n  induced_modulus n\n\ngoal (1 subgoal):\n 1. (a \\<le> Min (Collect induced_modulus)) =\n    (\\<forall>d. induced_modulus d \\<longrightarrow> a \\<le> d)", "by (subst Min_ge_iff) auto"], ["", "lemma conductor_leI: \"induced_modulus d \\<Longrightarrow> conductor \\<le> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. induced_modulus d \\<Longrightarrow> conductor \\<le> d", "by (subst conductor_le_iff) auto"], ["", "lemma conductor_geI: \"(\\<And>d. induced_modulus d \\<Longrightarrow> d \\<ge> a) \\<Longrightarrow> conductor \\<ge> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        induced_modulus d \\<Longrightarrow> a \\<le> d) \\<Longrightarrow>\n    a \\<le> conductor", "by (subst conductor_ge_iff) auto"], ["", "lemma conductor_dvd: \"conductor dvd n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conductor dvd n", "using conductor_induced"], ["proof (prove)\nusing this:\n  induced_modulus conductor\n\ngoal (1 subgoal):\n 1. conductor dvd n", "unfolding induced_modulus_def"], ["proof (prove)\nusing this:\n  conductor dvd n \\<and>\n  (\\<forall>a.\n      coprime a n \\<and> [a = 1] (mod conductor) \\<longrightarrow>\n      \\<chi> a = 1)\n\ngoal (1 subgoal):\n 1. conductor dvd n", "by blast"], ["", "lemma conductor_le_modulus: \"conductor \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conductor \\<le> n", "using conductor_dvd"], ["proof (prove)\nusing this:\n  conductor dvd n\n\ngoal (1 subgoal):\n 1. conductor \\<le> n", "by (rule dvd_imp_le) (use n in auto)"], ["", "lemma conductor_gr_0: \"conductor > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < conductor", "unfolding conductor_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Min (Collect induced_modulus)", "using zero_not_ind_mod"], ["proof (prove)\nusing this:\n  \\<not> induced_modulus 0\n\ngoal (1 subgoal):\n 1. 0 < Min (Collect induced_modulus)", "using conductor_def conductor_induced neq0_conv"], ["proof (prove)\nusing this:\n  \\<not> induced_modulus 0\n  conductor = Min (Collect induced_modulus)\n  induced_modulus conductor\n  (?n \\<noteq> 0) = (0 < ?n)\n\ngoal (1 subgoal):\n 1. 0 < Min (Collect induced_modulus)", "by fastforce"], ["", "lemma conductor_eq_1_iff_principal: \"conductor = 1 \\<longleftrightarrow> \\<chi> = principal_dchar n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (conductor = 1) = (\\<chi> = principal_dchar n)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. conductor = 1 \\<Longrightarrow> \\<chi> = principal_dchar n\n 2. \\<chi> = principal_dchar n \\<Longrightarrow> conductor = 1", "assume \"conductor = 1\""], ["proof (state)\nthis:\n  conductor = 1\n\ngoal (2 subgoals):\n 1. conductor = 1 \\<Longrightarrow> \\<chi> = principal_dchar n\n 2. \\<chi> = principal_dchar n \\<Longrightarrow> conductor = 1", "then"], ["proof (chain)\npicking this:\n  conductor = 1", "have \"induced_modulus 1\""], ["proof (prove)\nusing this:\n  conductor = 1\n\ngoal (1 subgoal):\n 1. induced_modulus 1", "using conductor_induced"], ["proof (prove)\nusing this:\n  conductor = 1\n  induced_modulus conductor\n\ngoal (1 subgoal):\n 1. induced_modulus 1", "by auto"], ["proof (state)\nthis:\n  induced_modulus 1\n\ngoal (2 subgoals):\n 1. conductor = 1 \\<Longrightarrow> \\<chi> = principal_dchar n\n 2. \\<chi> = principal_dchar n \\<Longrightarrow> conductor = 1", "then"], ["proof (chain)\npicking this:\n  induced_modulus 1", "show \"\\<chi> = principal_dchar n\""], ["proof (prove)\nusing this:\n  induced_modulus 1\n\ngoal (1 subgoal):\n 1. \\<chi> = principal_dchar n", "using one_induced_iff_principal"], ["proof (prove)\nusing this:\n  induced_modulus 1\n  induced_modulus 1 = (\\<chi> = principal_dchar n)\n\ngoal (1 subgoal):\n 1. \\<chi> = principal_dchar n", "by blast"], ["proof (state)\nthis:\n  \\<chi> = principal_dchar n\n\ngoal (1 subgoal):\n 1. \\<chi> = principal_dchar n \\<Longrightarrow> conductor = 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<chi> = principal_dchar n \\<Longrightarrow> conductor = 1", "assume \"\\<chi> = principal_dchar n\""], ["proof (state)\nthis:\n  \\<chi> = principal_dchar n\n\ngoal (1 subgoal):\n 1. \\<chi> = principal_dchar n \\<Longrightarrow> conductor = 1", "then"], ["proof (chain)\npicking this:\n  \\<chi> = principal_dchar n", "have im_1: \"induced_modulus 1\""], ["proof (prove)\nusing this:\n  \\<chi> = principal_dchar n\n\ngoal (1 subgoal):\n 1. induced_modulus 1", "using one_induced_iff_principal"], ["proof (prove)\nusing this:\n  \\<chi> = principal_dchar n\n  induced_modulus 1 = (\\<chi> = principal_dchar n)\n\ngoal (1 subgoal):\n 1. induced_modulus 1", "by auto"], ["proof (state)\nthis:\n  induced_modulus 1\n\ngoal (1 subgoal):\n 1. \\<chi> = principal_dchar n \\<Longrightarrow> conductor = 1", "show \"conductor = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conductor = 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. conductor = 1", "have \"conductor \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conductor \\<le> 1", "using conductor_fin Min_le[OF conductor_fin,simplified,OF im_1]"], ["proof (prove)\nusing this:\n  finite (Collect induced_modulus)\n  Min (Collect induced_modulus) \\<le> 1\n\ngoal (1 subgoal):\n 1. conductor \\<le> 1", "by (simp add: conductor_def[symmetric])"], ["proof (state)\nthis:\n  conductor \\<le> 1\n\ngoal (1 subgoal):\n 1. conductor = 1", "then"], ["proof (chain)\npicking this:\n  conductor \\<le> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  conductor \\<le> 1\n\ngoal (1 subgoal):\n 1. conductor = 1", "using conductor_gr_0"], ["proof (prove)\nusing this:\n  conductor \\<le> 1\n  0 < conductor\n\ngoal (1 subgoal):\n 1. conductor = 1", "by auto"], ["proof (state)\nthis:\n  conductor = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  conductor = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma conductor_principal [simp]: \"\\<chi> = principal_dchar n \\<Longrightarrow> conductor = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<chi> = principal_dchar n \\<Longrightarrow> conductor = 1", "by (subst conductor_eq_1_iff_principal)"], ["", "lemma nonprimitive_imp_conductor_less:\n  assumes \"\\<not>primitive_dchar n \\<chi>\"\n  shows \"conductor < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conductor < n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. conductor < n", "obtain d where d: \"induced_modulus d\" \"d < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>induced_modulus d; d < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using primitive_dchar_iff assms"], ["proof (prove)\nusing this:\n  primitive_dchar n \\<chi> = (\\<not> (\\<exists>d<n. induced_modulus d))\n  \\<not> primitive_dchar n \\<chi>\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>induced_modulus d; d < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  induced_modulus d\n  d < n\n\ngoal (1 subgoal):\n 1. conductor < n", "from d(1)"], ["proof (chain)\npicking this:\n  induced_modulus d", "have \"conductor \\<le> d\""], ["proof (prove)\nusing this:\n  induced_modulus d\n\ngoal (1 subgoal):\n 1. conductor \\<le> d", "by (rule conductor_leI)"], ["proof (state)\nthis:\n  conductor \\<le> d\n\ngoal (1 subgoal):\n 1. conductor < n", "also"], ["proof (state)\nthis:\n  conductor \\<le> d\n\ngoal (1 subgoal):\n 1. conductor < n", "have \"\\<dots> < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d < n", "by fact"], ["proof (state)\nthis:\n  d < n\n\ngoal (1 subgoal):\n 1. conductor < n", "finally"], ["proof (chain)\npicking this:\n  conductor < n", "show ?thesis"], ["proof (prove)\nusing this:\n  conductor < n\n\ngoal (1 subgoal):\n 1. conductor < n", "."], ["proof (state)\nthis:\n  conductor < n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in nonprimitive_dchar) conductor_less_modulus: \"conductor < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conductor < n", "using nonprimitive_imp_conductor_less nonprimitive"], ["proof (prove)\nusing this:\n  \\<not> primitive_dchar n \\<chi> \\<Longrightarrow> conductor < n\n  \\<not> primitive_dchar n \\<chi>\n\ngoal (1 subgoal):\n 1. conductor < n", "by metis"], ["", "text \\<open>Theorem 8.18\\<close>"], ["", "theorem primitive_principal_form:\n  defines \"\\<chi>\\<^sub>1 \\<equiv> principal_dchar n\"\n  assumes \"\\<chi> \\<noteq> principal_dchar n\"\n  shows \"\\<exists>\\<Phi>. primitive_dchar conductor \\<Phi> \\<and> (\\<forall>n. \\<chi>(n) = \\<Phi>(n) * \\<chi>\\<^sub>1(n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       primitive_dchar conductor \\<Phi> \\<and>\n       (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       primitive_dchar conductor \\<Phi> \\<and>\n       (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n)", "(*\n    TODO: perhaps residues_nat should be relaxed to allow n = 1.\n    Then we could remove the unnecessary precondition here.\n    It makes no real difference though.\n  *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       primitive_dchar conductor \\<Phi> \\<and>\n       (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n)", "from n"], ["proof (chain)\npicking this:\n  1 < n", "have n_pos: \"n > 0\""], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. 0 < n", "by simp"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       primitive_dchar conductor \\<Phi> \\<and>\n       (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n)", "define d where \"d = conductor\""], ["proof (state)\nthis:\n  d = conductor\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       primitive_dchar conductor \\<Phi> \\<and>\n       (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n)", "have induced: \"induced_modulus d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. induced_modulus d", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. induced_modulus conductor", "using conductor_induced"], ["proof (prove)\nusing this:\n  induced_modulus conductor\n\ngoal (1 subgoal):\n 1. induced_modulus conductor", "by blast"], ["proof (state)\nthis:\n  induced_modulus d\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       primitive_dchar conductor \\<Phi> \\<and>\n       (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n)", "then"], ["proof (chain)\npicking this:\n  induced_modulus d", "have d_not_1: \"d \\<noteq> 1\""], ["proof (prove)\nusing this:\n  induced_modulus d\n\ngoal (1 subgoal):\n 1. d \\<noteq> 1", "using one_induced_iff_principal assms"], ["proof (prove)\nusing this:\n  induced_modulus d\n  induced_modulus 1 = (\\<chi> = principal_dchar n)\n  \\<chi>\\<^sub>1 \\<equiv> principal_dchar n\n  \\<chi> \\<noteq> principal_dchar n\n\ngoal (1 subgoal):\n 1. d \\<noteq> 1", "by auto"], ["proof (state)\nthis:\n  d \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       primitive_dchar conductor \\<Phi> \\<and>\n       (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n)", "hence d_gt_1: \"d > 1\""], ["proof (prove)\nusing this:\n  d \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 1 < d", "using conductor_gr_0"], ["proof (prove)\nusing this:\n  d \\<noteq> 1\n  0 < conductor\n\ngoal (1 subgoal):\n 1. 1 < d", "by (auto simp: d_def)"], ["proof (state)\nthis:\n  1 < d\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       primitive_dchar conductor \\<Phi> \\<and>\n       (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n)", "from induced"], ["proof (chain)\npicking this:\n  induced_modulus d", "obtain \\<Phi> where \\<Phi>_def: \"dcharacter d \\<Phi> \\<and> (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n)\""], ["proof (prove)\nusing this:\n  induced_modulus d\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Phi>.\n        dcharacter d \\<Phi> \\<and>\n        (\\<forall>n.\n            \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using d_not_1"], ["proof (prove)\nusing this:\n  induced_modulus d\n  d \\<noteq> 1\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Phi>.\n        dcharacter d \\<Phi> \\<and>\n        (\\<forall>n.\n            \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (subst (asm) induced_modulus_altdef2) (auto simp: d_def conductor_dvd \\<chi>\\<^sub>1_def)"], ["proof (state)\nthis:\n  dcharacter d \\<Phi> \\<and>\n  (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       primitive_dchar conductor \\<Phi> \\<and>\n       (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n)", "have phi_dchars: \"\\<Phi> \\<in> dcharacters d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> \\<in> dcharacters d", "using \\<Phi>_def dcharacters_def"], ["proof (prove)\nusing this:\n  dcharacter d \\<Phi> \\<and>\n  (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n)\n  dcharacters ?n = {\\<chi>. dcharacter ?n \\<chi>}\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<in> dcharacters d", "by auto"], ["proof (state)\nthis:\n  \\<Phi> \\<in> dcharacters d\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       primitive_dchar conductor \\<Phi> \\<and>\n       (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n)", "interpret \\<Phi>: dcharacter d \"residue_mult_group d\" \\<Phi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. dcharacter d \\<Phi> &&&\n    residue_mult_group d \\<equiv> residue_mult_group d", "using \\<Phi>_def"], ["proof (prove)\nusing this:\n  dcharacter d \\<Phi> \\<and>\n  (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n)\n\ngoal (1 subgoal):\n 1. dcharacter d \\<Phi> &&&\n    residue_mult_group d \\<equiv> residue_mult_group d", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       primitive_dchar conductor \\<Phi> \\<and>\n       (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n)", "have \\<Phi>_prim: \"primitive_dchar d \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primitive_dchar d \\<Phi>", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> primitive_dchar d \\<Phi> \\<Longrightarrow> False", "assume \"\\<not> primitive_dchar d \\<Phi>\""], ["proof (state)\nthis:\n  \\<not> primitive_dchar d \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<not> primitive_dchar d \\<Phi> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> primitive_dchar d \\<Phi>", "obtain q where \n      1: \"q dvd d \\<and> q < d \\<and> \\<Phi>.induced_modulus q\""], ["proof (prove)\nusing this:\n  \\<not> primitive_dchar d \\<Phi>\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        q dvd d \\<and>\n        q < d \\<and> \\<Phi>.induced_modulus q \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<Phi>.induced_modulus_def \\<Phi>.primitive_dchar_iff"], ["proof (prove)\nusing this:\n  \\<not> \\<not> (\\<exists>da<d.\n                    da dvd d \\<and>\n                    (\\<forall>a.\n                        coprime a d \\<and>\n                        [a = 1] (mod da) \\<longrightarrow>\n                        \\<Phi> a = 1))\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        q dvd d \\<and>\n        q < d \\<and>\n        q dvd d \\<and>\n        (\\<forall>a.\n            coprime a d \\<and> [a = 1] (mod q) \\<longrightarrow>\n            \\<Phi> a = 1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  q dvd d \\<and> q < d \\<and> \\<Phi>.induced_modulus q\n\ngoal (1 subgoal):\n 1. \\<not> primitive_dchar d \\<Phi> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  q dvd d \\<and> q < d \\<and> \\<Phi>.induced_modulus q", "have 2: \"induced_modulus q\""], ["proof (prove)\nusing this:\n  q dvd d \\<and> q < d \\<and> \\<Phi>.induced_modulus q\n\ngoal (1 subgoal):\n 1. induced_modulus q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q dvd d \\<and> q < d \\<and> \\<Phi>.induced_modulus q \\<Longrightarrow>\n    induced_modulus q", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. q dvd d \\<and> q < d \\<and> \\<Phi>.induced_modulus q \\<Longrightarrow>\n    induced_modulus q", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. q dvd d \\<and> q < d \\<and> \\<Phi>.induced_modulus q \\<Longrightarrow>\n    induced_modulus q", "assume mod_1: \"[k = 1] (mod q)\""], ["proof (state)\nthis:\n  [k = 1] (mod q)\n\ngoal (1 subgoal):\n 1. q dvd d \\<and> q < d \\<and> \\<Phi>.induced_modulus q \\<Longrightarrow>\n    induced_modulus q", "assume cop: \"coprime k n\""], ["proof (state)\nthis:\n  coprime k n\n\ngoal (1 subgoal):\n 1. q dvd d \\<and> q < d \\<and> \\<Phi>.induced_modulus q \\<Longrightarrow>\n    induced_modulus q", "have \"\\<chi>(k) = \\<Phi>(k)*\\<chi>\\<^sub>1(k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "using \\<Phi>_def"], ["proof (prove)\nusing this:\n  dcharacter d \\<Phi> \\<and>\n  (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n)\n\ngoal (1 subgoal):\n 1. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k", "by auto"], ["proof (state)\nthis:\n  \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k\n\ngoal (1 subgoal):\n 1. q dvd d \\<and> q < d \\<and> \\<Phi>.induced_modulus q \\<Longrightarrow>\n    induced_modulus q", "also"], ["proof (state)\nthis:\n  \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k\n\ngoal (1 subgoal):\n 1. q dvd d \\<and> q < d \\<and> \\<Phi>.induced_modulus q \\<Longrightarrow>\n    induced_modulus q", "have \"\\<dots> = \\<Phi>(k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> k * \\<chi>\\<^sub>1 k = \\<Phi> k", "using cop"], ["proof (prove)\nusing this:\n  coprime k n\n\ngoal (1 subgoal):\n 1. \\<Phi> k * \\<chi>\\<^sub>1 k = \\<Phi> k", "by (simp add: assms principal_dchar_def)"], ["proof (state)\nthis:\n  \\<Phi> k * \\<chi>\\<^sub>1 k = \\<Phi> k\n\ngoal (1 subgoal):\n 1. q dvd d \\<and> q < d \\<and> \\<Phi>.induced_modulus q \\<Longrightarrow>\n    induced_modulus q", "also"], ["proof (state)\nthis:\n  \\<Phi> k * \\<chi>\\<^sub>1 k = \\<Phi> k\n\ngoal (1 subgoal):\n 1. q dvd d \\<and> q < d \\<and> \\<Phi>.induced_modulus q \\<Longrightarrow>\n    induced_modulus q", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> k = 1", "using 1 mod_1 \\<Phi>.induced_modulus_def \n                \\<open>induced_modulus d\\<close> cop induced_modulus_def"], ["proof (prove)\nusing this:\n  q dvd d \\<and> q < d \\<and> \\<Phi>.induced_modulus q\n  [k = 1] (mod q)\n  \\<Phi>.induced_modulus ?d =\n  (?d dvd d \\<and>\n   (\\<forall>a.\n       coprime a d \\<and> [a = 1] (mod ?d) \\<longrightarrow> \\<Phi> a = 1))\n  induced_modulus d\n  coprime k n\n  induced_modulus ?d =\n  (?d dvd n \\<and>\n   (\\<forall>a.\n       coprime a n \\<and> [a = 1] (mod ?d) \\<longrightarrow> \\<chi> a = 1))\n\ngoal (1 subgoal):\n 1. \\<Phi> k = 1", "by auto"], ["proof (state)\nthis:\n  \\<Phi> k = 1\n\ngoal (1 subgoal):\n 1. q dvd d \\<and> q < d \\<and> \\<Phi>.induced_modulus q \\<Longrightarrow>\n    induced_modulus q", "finally"], ["proof (chain)\npicking this:\n  \\<chi> k = 1", "have \"\\<chi>(k) = 1\""], ["proof (prove)\nusing this:\n  \\<chi> k = 1\n\ngoal (1 subgoal):\n 1. \\<chi> k = 1", "by blast"], ["proof (state)\nthis:\n  \\<chi> k = 1\n\ngoal (1 subgoal):\n 1. q dvd d \\<and> q < d \\<and> \\<Phi>.induced_modulus q \\<Longrightarrow>\n    induced_modulus q", "}"], ["proof (state)\nthis:\n  \\<lbrakk>[?k2 = 1] (mod q); coprime ?k2 n\\<rbrakk>\n  \\<Longrightarrow> \\<chi> ?k2 = 1\n\ngoal (1 subgoal):\n 1. q dvd d \\<and> q < d \\<and> \\<Phi>.induced_modulus q \\<Longrightarrow>\n    induced_modulus q", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>[?k2 = 1] (mod q); coprime ?k2 n\\<rbrakk>\n  \\<Longrightarrow> \\<chi> ?k2 = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>[?k2 = 1] (mod q); coprime ?k2 n\\<rbrakk>\n  \\<Longrightarrow> \\<chi> ?k2 = 1\n\ngoal (1 subgoal):\n 1. induced_modulus q", "using induced_modulus_def \"1\" \\<open>induced_modulus d\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>[?k2 = 1] (mod q); coprime ?k2 n\\<rbrakk>\n  \\<Longrightarrow> \\<chi> ?k2 = 1\n  induced_modulus ?d =\n  (?d dvd n \\<and>\n   (\\<forall>a.\n       coprime a n \\<and> [a = 1] (mod ?d) \\<longrightarrow> \\<chi> a = 1))\n  q dvd d \\<and> q < d \\<and> \\<Phi>.induced_modulus q\n  induced_modulus d\n\ngoal (1 subgoal):\n 1. induced_modulus q", "by auto"], ["proof (state)\nthis:\n  induced_modulus q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  induced_modulus q\n\ngoal (1 subgoal):\n 1. \\<not> primitive_dchar d \\<Phi> \\<Longrightarrow> False", "from 1"], ["proof (chain)\npicking this:\n  q dvd d \\<and> q < d \\<and> \\<Phi>.induced_modulus q", "have \"q < d\""], ["proof (prove)\nusing this:\n  q dvd d \\<and> q < d \\<and> \\<Phi>.induced_modulus q\n\ngoal (1 subgoal):\n 1. q < d", "by simp"], ["proof (state)\nthis:\n  q < d\n\ngoal (1 subgoal):\n 1. \\<not> primitive_dchar d \\<Phi> \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  q < d\n\ngoal (1 subgoal):\n 1. \\<not> primitive_dchar d \\<Phi> \\<Longrightarrow> False", "have \"d \\<le> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> q", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. conductor \\<le> q", "by (intro conductor_leI) fact"], ["proof (state)\nthis:\n  d \\<le> q\n\ngoal (1 subgoal):\n 1. \\<not> primitive_dchar d \\<Phi> \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  q < d\n  d \\<le> q", "show False"], ["proof (prove)\nusing this:\n  q < d\n  d \\<le> q\n\ngoal (1 subgoal):\n 1. False", "by linarith"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  primitive_dchar d \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       primitive_dchar conductor \\<Phi> \\<and>\n       (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n)", "from \\<Phi>_def \\<Phi>_prim d_def phi_dchars"], ["proof (chain)\npicking this:\n  dcharacter d \\<Phi> \\<and>\n  (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n)\n  primitive_dchar d \\<Phi>\n  d = conductor\n  \\<Phi> \\<in> dcharacters d", "show ?thesis"], ["proof (prove)\nusing this:\n  dcharacter d \\<Phi> \\<and>\n  (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n)\n  primitive_dchar d \\<Phi>\n  d = conductor\n  \\<Phi> \\<in> dcharacters d\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       primitive_dchar conductor \\<Phi> \\<and>\n       (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n)", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<Phi>.\n     primitive_dchar conductor \\<Phi> \\<and>\n     (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition primitive_extension :: \"nat \\<Rightarrow> complex\" where\n  \"primitive_extension =\n     (SOME \\<Phi>. primitive_dchar conductor \\<Phi> \\<and> (\\<forall>k. \\<chi> k = \\<Phi> k * principal_dchar n k))\""], ["", "lemma\n  assumes nonprincipal: \"\\<chi> \\<noteq> principal_dchar n\"\n  shows primitive_primitive_extension: \"primitive_dchar conductor primitive_extension\"\n    and principal_decomposition:       \"\\<chi> k = primitive_extension k * principal_dchar n k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primitive_dchar conductor primitive_extension &&&\n    \\<chi> k = primitive_extension k * principal_dchar n k", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. primitive_dchar conductor primitive_extension\n 2. \\<chi> k = primitive_extension k * principal_dchar n k", "note * = someI_ex[OF primitive_principal_form[OF nonprincipal], folded primitive_extension_def]"], ["proof (state)\nthis:\n  primitive_dchar conductor primitive_extension \\<and>\n  (\\<forall>n. \\<chi> n = primitive_extension n * principal_dchar n n)\n\ngoal (2 subgoals):\n 1. primitive_dchar conductor primitive_extension\n 2. \\<chi> k = primitive_extension k * principal_dchar n k", "from *"], ["proof (chain)\npicking this:\n  primitive_dchar conductor primitive_extension \\<and>\n  (\\<forall>n. \\<chi> n = primitive_extension n * principal_dchar n n)", "show \"primitive_dchar conductor primitive_extension\""], ["proof (prove)\nusing this:\n  primitive_dchar conductor primitive_extension \\<and>\n  (\\<forall>n. \\<chi> n = primitive_extension n * principal_dchar n n)\n\ngoal (1 subgoal):\n 1. primitive_dchar conductor primitive_extension", "by blast"], ["proof (state)\nthis:\n  primitive_dchar conductor primitive_extension\n\ngoal (1 subgoal):\n 1. \\<chi> k = primitive_extension k * principal_dchar n k", "from *"], ["proof (chain)\npicking this:\n  primitive_dchar conductor primitive_extension \\<and>\n  (\\<forall>n. \\<chi> n = primitive_extension n * principal_dchar n n)", "show \"\\<chi> k = primitive_extension k * principal_dchar n k\""], ["proof (prove)\nusing this:\n  primitive_dchar conductor primitive_extension \\<and>\n  (\\<forall>n. \\<chi> n = primitive_extension n * principal_dchar n n)\n\ngoal (1 subgoal):\n 1. \\<chi> k = primitive_extension k * principal_dchar n k", "by blast"], ["proof (state)\nthis:\n  \\<chi> k = primitive_extension k * principal_dchar n k\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>The connection between primitivity and separability\\<close>"], ["", "lemma residue_mult_group_coset:\n  fixes m n m1 m2 :: nat and f :: \"nat \\<Rightarrow> nat\" and G H\n  defines \"G \\<equiv> residue_mult_group n\"\n  defines \"H \\<equiv> residue_mult_group m\"\n  defines \"f \\<equiv> (\\<lambda>k. k mod m)\"\n  assumes \"b \\<in> (rcosets\\<^bsub>G\\<^esub> kernel G H f)\"\n  assumes \"m1 \\<in> b\" \"m2 \\<in> b\"\n  assumes \"n > 1\" \"m dvd n\"\n  shows \"m1 mod m = m2 mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 mod m = m2 mod m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m1 mod m = m2 mod m", "have h_1: \"\\<one>\\<^bsub>H\\<^esub> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<one>\\<^bsub>H\\<^esub> = 1", "using assms(2)"], ["proof (prove)\nusing this:\n  H \\<equiv> residue_mult_group m\n\ngoal (1 subgoal):\n 1. \\<one>\\<^bsub>H\\<^esub> = 1", "unfolding residue_mult_group_def totatives_def"], ["proof (prove)\nusing this:\n  H \\<equiv>\n  \\<lparr>carrier = {k \\<in> {0<..m}. coprime k m},\n     monoid.mult = \\<lambda>x y. x * y mod m, one = 1\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<one>\\<^bsub>H\\<^esub> = 1", "by simp"], ["proof (state)\nthis:\n  \\<one>\\<^bsub>H\\<^esub> = 1\n\ngoal (1 subgoal):\n 1. m1 mod m = m2 mod m", "from assms(4)"], ["proof (chain)\npicking this:\n  b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f", "obtain a :: nat where cos_expr: \"b = (kernel G H f) #>\\<^bsub>G\\<^esub> a \\<and> a \\<in> carrier G\""], ["proof (prove)\nusing this:\n  b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        b = kernel G H f #>\\<^bsub>G\\<^esub> a \\<and>\n        a \\<in> carrier G \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using RCOSETS_def[of G \"kernel G H f\"]"], ["proof (prove)\nusing this:\n  b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f\n  rcosets\\<^bsub>G\\<^esub> kernel G H f =\n  (\\<Union>a\\<in>carrier G. {kernel G H f #>\\<^bsub>G\\<^esub> a})\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        b = kernel G H f #>\\<^bsub>G\\<^esub> a \\<and>\n        a \\<in> carrier G \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  b = kernel G H f #>\\<^bsub>G\\<^esub> a \\<and> a \\<in> carrier G\n\ngoal (1 subgoal):\n 1. m1 mod m = m2 mod m", "then"], ["proof (chain)\npicking this:\n  b = kernel G H f #>\\<^bsub>G\\<^esub> a \\<and> a \\<in> carrier G", "have cop: \"coprime a n\""], ["proof (prove)\nusing this:\n  b = kernel G H f #>\\<^bsub>G\\<^esub> a \\<and> a \\<in> carrier G\n\ngoal (1 subgoal):\n 1. coprime a n", "using assms(1)"], ["proof (prove)\nusing this:\n  b = kernel G H f #>\\<^bsub>G\\<^esub> a \\<and> a \\<in> carrier G\n  G \\<equiv> residue_mult_group n\n\ngoal (1 subgoal):\n 1. coprime a n", "unfolding residue_mult_group_def totatives_def"], ["proof (prove)\nusing this:\n  b = kernel G H f #>\\<^bsub>G\\<^esub> a \\<and> a \\<in> carrier G\n  G \\<equiv>\n  \\<lparr>carrier = {k \\<in> {0<..n}. coprime k n},\n     monoid.mult = \\<lambda>x y. x * y mod n, one = 1\\<rparr>\n\ngoal (1 subgoal):\n 1. coprime a n", "by auto"], ["proof (state)\nthis:\n  coprime a n\n\ngoal (1 subgoal):\n 1. m1 mod m = m2 mod m", "obtain a' where \"[a * a' = 1] (mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        [a * a' = 1] (mod n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cong_solve_coprime_nat[OF cop]"], ["proof (prove)\nusing this:\n  \\<exists>x. [a * x = Suc 0] (mod n)\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        [a * a' = 1] (mod n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  [a * a' = 1] (mod n)\n\ngoal (1 subgoal):\n 1. m1 mod m = m2 mod m", "then"], ["proof (chain)\npicking this:\n  [a * a' = 1] (mod n)", "have a_inv: \"(a*a') mod n = 1\""], ["proof (prove)\nusing this:\n  [a * a' = 1] (mod n)\n\ngoal (1 subgoal):\n 1. a * a' mod n = 1", "using cong_def[of \"a*a'\" 1 n] assms(7)"], ["proof (prove)\nusing this:\n  [a * a' = 1] (mod n)\n  [a * a' = 1] (mod n) = (a * a' mod n = 1 mod n)\n  1 < n\n\ngoal (1 subgoal):\n 1. a * a' mod n = 1", "by simp"], ["proof (state)\nthis:\n  a * a' mod n = 1\n\ngoal (1 subgoal):\n 1. m1 mod m = m2 mod m", "have \"m1 \\<in> (\\<Union>h\\<in>kernel G H f. {h \\<otimes>\\<^bsub>G\\<^esub> a})\"\n       \"m2 \\<in> (\\<Union>h\\<in>kernel G H f. {h \\<otimes>\\<^bsub>G\\<^esub> a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 \\<in> (\\<Union>h\\<in>kernel G H f.\n                 {h \\<otimes>\\<^bsub>G\\<^esub> a}) &&&\n    m2 \\<in> (\\<Union>h\\<in>kernel G H f. {h \\<otimes>\\<^bsub>G\\<^esub> a})", "using r_coset_def[of G \"kernel G H f\" a] cos_expr assms(5,6)"], ["proof (prove)\nusing this:\n  kernel G H f #>\\<^bsub>G\\<^esub> a =\n  (\\<Union>h\\<in>kernel G H f. {h \\<otimes>\\<^bsub>G\\<^esub> a})\n  b = kernel G H f #>\\<^bsub>G\\<^esub> a \\<and> a \\<in> carrier G\n  m1 \\<in> b\n  m2 \\<in> b\n\ngoal (1 subgoal):\n 1. m1 \\<in> (\\<Union>h\\<in>kernel G H f.\n                 {h \\<otimes>\\<^bsub>G\\<^esub> a}) &&&\n    m2 \\<in> (\\<Union>h\\<in>kernel G H f. {h \\<otimes>\\<^bsub>G\\<^esub> a})", "by blast+"], ["proof (state)\nthis:\n  m1 \\<in> (\\<Union>h\\<in>kernel G H f. {h \\<otimes>\\<^bsub>G\\<^esub> a})\n  m2 \\<in> (\\<Union>h\\<in>kernel G H f. {h \\<otimes>\\<^bsub>G\\<^esub> a})\n\ngoal (1 subgoal):\n 1. m1 mod m = m2 mod m", "then"], ["proof (chain)\npicking this:\n  m1 \\<in> (\\<Union>h\\<in>kernel G H f. {h \\<otimes>\\<^bsub>G\\<^esub> a})\n  m2 \\<in> (\\<Union>h\\<in>kernel G H f. {h \\<otimes>\\<^bsub>G\\<^esub> a})", "have \"m1 \\<in> (\\<Union>h\\<in>kernel G H f. {(h * a) mod n})\"\n            \"m2 \\<in> (\\<Union>h\\<in>kernel G H f. {(h * a) mod n})\""], ["proof (prove)\nusing this:\n  m1 \\<in> (\\<Union>h\\<in>kernel G H f. {h \\<otimes>\\<^bsub>G\\<^esub> a})\n  m2 \\<in> (\\<Union>h\\<in>kernel G H f. {h \\<otimes>\\<^bsub>G\\<^esub> a})\n\ngoal (1 subgoal):\n 1. m1 \\<in> (\\<Union>h\\<in>kernel G H f. {h * a mod n}) &&&\n    m2 \\<in> (\\<Union>h\\<in>kernel G H f. {h * a mod n})", "using assms(1)"], ["proof (prove)\nusing this:\n  m1 \\<in> (\\<Union>h\\<in>kernel G H f. {h \\<otimes>\\<^bsub>G\\<^esub> a})\n  m2 \\<in> (\\<Union>h\\<in>kernel G H f. {h \\<otimes>\\<^bsub>G\\<^esub> a})\n  G \\<equiv> residue_mult_group n\n\ngoal (1 subgoal):\n 1. m1 \\<in> (\\<Union>h\\<in>kernel G H f. {h * a mod n}) &&&\n    m2 \\<in> (\\<Union>h\\<in>kernel G H f. {h * a mod n})", "unfolding residue_mult_group_def[of n]"], ["proof (prove)\nusing this:\n  m1 \\<in> (\\<Union>h\\<in>kernel G H f. {h \\<otimes>\\<^bsub>G\\<^esub> a})\n  m2 \\<in> (\\<Union>h\\<in>kernel G H f. {h \\<otimes>\\<^bsub>G\\<^esub> a})\n  G \\<equiv>\n  \\<lparr>carrier = totatives n, monoid.mult = \\<lambda>x y. x * y mod n,\n     one = 1\\<rparr>\n\ngoal (1 subgoal):\n 1. m1 \\<in> (\\<Union>h\\<in>kernel G H f. {h * a mod n}) &&&\n    m2 \\<in> (\\<Union>h\\<in>kernel G H f. {h * a mod n})", "by auto"], ["proof (state)\nthis:\n  m1 \\<in> (\\<Union>h\\<in>kernel G H f. {h * a mod n})\n  m2 \\<in> (\\<Union>h\\<in>kernel G H f. {h * a mod n})\n\ngoal (1 subgoal):\n 1. m1 mod m = m2 mod m", "then"], ["proof (chain)\npicking this:\n  m1 \\<in> (\\<Union>h\\<in>kernel G H f. {h * a mod n})\n  m2 \\<in> (\\<Union>h\\<in>kernel G H f. {h * a mod n})", "obtain m1' m2' where \n    m_expr: \"m1 = (m1'* a) mod n \\<and> m1' \\<in> kernel G H f\" \n            \"m2 = (m2'* a) mod n \\<and> m2' \\<in> kernel G H f\""], ["proof (prove)\nusing this:\n  m1 \\<in> (\\<Union>h\\<in>kernel G H f. {h * a mod n})\n  m2 \\<in> (\\<Union>h\\<in>kernel G H f. {h * a mod n})\n\ngoal (1 subgoal):\n 1. (\\<And>m1' m2'.\n        \\<lbrakk>m1 = m1' * a mod n \\<and> m1' \\<in> kernel G H f;\n         m2 = m2' * a mod n \\<and> m2' \\<in> kernel G H f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m1 = m1' * a mod n \\<and> m1' \\<in> kernel G H f\n  m2 = m2' * a mod n \\<and> m2' \\<in> kernel G H f\n\ngoal (1 subgoal):\n 1. m1 mod m = m2 mod m", "have eq_1: \"m1 mod m = a mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 mod m = a mod m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m1 mod m = a mod m", "have \"m1 mod m = ((m1'* a) mod n) mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 mod m = m1' * a mod n mod m", "using m_expr"], ["proof (prove)\nusing this:\n  m1 = m1' * a mod n \\<and> m1' \\<in> kernel G H f\n  m2 = m2' * a mod n \\<and> m2' \\<in> kernel G H f\n\ngoal (1 subgoal):\n 1. m1 mod m = m1' * a mod n mod m", "by blast"], ["proof (state)\nthis:\n  m1 mod m = m1' * a mod n mod m\n\ngoal (1 subgoal):\n 1. m1 mod m = a mod m", "also"], ["proof (state)\nthis:\n  m1 mod m = m1' * a mod n mod m\n\ngoal (1 subgoal):\n 1. m1 mod m = a mod m", "have \"\\<dots> = (m1' * a) mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1' * a mod n mod m = m1' * a mod m", "using euclidean_semiring_cancel_class.mod_mod_cancel assms(8)"], ["proof (prove)\nusing this:\n  ?c dvd ?b \\<Longrightarrow> ?a mod ?b mod ?c = ?a mod ?c\n  m dvd n\n\ngoal (1 subgoal):\n 1. m1' * a mod n mod m = m1' * a mod m", "by blast"], ["proof (state)\nthis:\n  m1' * a mod n mod m = m1' * a mod m\n\ngoal (1 subgoal):\n 1. m1 mod m = a mod m", "also"], ["proof (state)\nthis:\n  m1' * a mod n mod m = m1' * a mod m\n\ngoal (1 subgoal):\n 1. m1 mod m = a mod m", "have \"\\<dots> = (m1' mod m) * (a mod m) mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1' * a mod m = m1' mod m * (a mod m) mod m", "by (simp add: mod_mult_eq)"], ["proof (state)\nthis:\n  m1' * a mod m = m1' mod m * (a mod m) mod m\n\ngoal (1 subgoal):\n 1. m1 mod m = a mod m", "also"], ["proof (state)\nthis:\n  m1' * a mod m = m1' mod m * (a mod m) mod m\n\ngoal (1 subgoal):\n 1. m1 mod m = a mod m", "have \"\\<dots> = (a mod m) mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1' mod m * (a mod m) mod m = a mod m mod m", "using m_expr(1) h_1"], ["proof (prove)\nusing this:\n  m1 = m1' * a mod n \\<and> m1' \\<in> kernel G H f\n  \\<one>\\<^bsub>H\\<^esub> = 1\n\ngoal (1 subgoal):\n 1. m1' mod m * (a mod m) mod m = a mod m mod m", "unfolding kernel_def assms(3)"], ["proof (prove)\nusing this:\n  m1 = m1' * a mod n \\<and>\n  m1' \\<in> {x \\<in> carrier G. x mod m = \\<one>\\<^bsub>H\\<^esub>}\n  \\<one>\\<^bsub>H\\<^esub> = 1\n\ngoal (1 subgoal):\n 1. m1' mod m * (a mod m) mod m = a mod m mod m", "by simp"], ["proof (state)\nthis:\n  m1' mod m * (a mod m) mod m = a mod m mod m\n\ngoal (1 subgoal):\n 1. m1 mod m = a mod m", "also"], ["proof (state)\nthis:\n  m1' mod m * (a mod m) mod m = a mod m mod m\n\ngoal (1 subgoal):\n 1. m1 mod m = a mod m", "have \"\\<dots> = a mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a mod m mod m = a mod m", "by auto"], ["proof (state)\nthis:\n  a mod m mod m = a mod m\n\ngoal (1 subgoal):\n 1. m1 mod m = a mod m", "finally"], ["proof (chain)\npicking this:\n  m1 mod m = a mod m", "show ?thesis"], ["proof (prove)\nusing this:\n  m1 mod m = a mod m\n\ngoal (1 subgoal):\n 1. m1 mod m = a mod m", "by simp"], ["proof (state)\nthis:\n  m1 mod m = a mod m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m1 mod m = a mod m\n\ngoal (1 subgoal):\n 1. m1 mod m = m2 mod m", "have eq_2: \"m2 mod m = a mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m2 mod m = a mod m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m2 mod m = a mod m", "have \"m2 mod m = ((m2'* a) mod n) mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m2 mod m = m2' * a mod n mod m", "using m_expr"], ["proof (prove)\nusing this:\n  m1 = m1' * a mod n \\<and> m1' \\<in> kernel G H f\n  m2 = m2' * a mod n \\<and> m2' \\<in> kernel G H f\n\ngoal (1 subgoal):\n 1. m2 mod m = m2' * a mod n mod m", "by blast"], ["proof (state)\nthis:\n  m2 mod m = m2' * a mod n mod m\n\ngoal (1 subgoal):\n 1. m2 mod m = a mod m", "also"], ["proof (state)\nthis:\n  m2 mod m = m2' * a mod n mod m\n\ngoal (1 subgoal):\n 1. m2 mod m = a mod m", "have \"\\<dots> = (m2' * a) mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m2' * a mod n mod m = m2' * a mod m", "using euclidean_semiring_cancel_class.mod_mod_cancel assms(8)"], ["proof (prove)\nusing this:\n  ?c dvd ?b \\<Longrightarrow> ?a mod ?b mod ?c = ?a mod ?c\n  m dvd n\n\ngoal (1 subgoal):\n 1. m2' * a mod n mod m = m2' * a mod m", "by blast"], ["proof (state)\nthis:\n  m2' * a mod n mod m = m2' * a mod m\n\ngoal (1 subgoal):\n 1. m2 mod m = a mod m", "also"], ["proof (state)\nthis:\n  m2' * a mod n mod m = m2' * a mod m\n\ngoal (1 subgoal):\n 1. m2 mod m = a mod m", "have \"\\<dots> = (m2' mod m) * (a mod m) mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m2' * a mod m = m2' mod m * (a mod m) mod m", "by (simp add: mod_mult_eq)"], ["proof (state)\nthis:\n  m2' * a mod m = m2' mod m * (a mod m) mod m\n\ngoal (1 subgoal):\n 1. m2 mod m = a mod m", "also"], ["proof (state)\nthis:\n  m2' * a mod m = m2' mod m * (a mod m) mod m\n\ngoal (1 subgoal):\n 1. m2 mod m = a mod m", "have \"\\<dots> = (a mod m) mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m2' mod m * (a mod m) mod m = a mod m mod m", "using m_expr(2) h_1"], ["proof (prove)\nusing this:\n  m2 = m2' * a mod n \\<and> m2' \\<in> kernel G H f\n  \\<one>\\<^bsub>H\\<^esub> = 1\n\ngoal (1 subgoal):\n 1. m2' mod m * (a mod m) mod m = a mod m mod m", "unfolding kernel_def assms(3)"], ["proof (prove)\nusing this:\n  m2 = m2' * a mod n \\<and>\n  m2' \\<in> {x \\<in> carrier G. x mod m = \\<one>\\<^bsub>H\\<^esub>}\n  \\<one>\\<^bsub>H\\<^esub> = 1\n\ngoal (1 subgoal):\n 1. m2' mod m * (a mod m) mod m = a mod m mod m", "by simp"], ["proof (state)\nthis:\n  m2' mod m * (a mod m) mod m = a mod m mod m\n\ngoal (1 subgoal):\n 1. m2 mod m = a mod m", "also"], ["proof (state)\nthis:\n  m2' mod m * (a mod m) mod m = a mod m mod m\n\ngoal (1 subgoal):\n 1. m2 mod m = a mod m", "have \"\\<dots> = a mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a mod m mod m = a mod m", "by auto"], ["proof (state)\nthis:\n  a mod m mod m = a mod m\n\ngoal (1 subgoal):\n 1. m2 mod m = a mod m", "finally"], ["proof (chain)\npicking this:\n  m2 mod m = a mod m", "show ?thesis"], ["proof (prove)\nusing this:\n  m2 mod m = a mod m\n\ngoal (1 subgoal):\n 1. m2 mod m = a mod m", "by simp"], ["proof (state)\nthis:\n  m2 mod m = a mod m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m2 mod m = a mod m\n\ngoal (1 subgoal):\n 1. m1 mod m = m2 mod m", "from eq_1 eq_2"], ["proof (chain)\npicking this:\n  m1 mod m = a mod m\n  m2 mod m = a mod m", "show ?thesis"], ["proof (prove)\nusing this:\n  m1 mod m = a mod m\n  m2 mod m = a mod m\n\ngoal (1 subgoal):\n 1. m1 mod m = m2 mod m", "by argo"], ["proof (state)\nthis:\n  m1 mod m = m2 mod m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma residue_mult_group_kernel_partition:\n  fixes m n :: nat and f :: \"nat \\<Rightarrow> nat\" and G H\n  defines \"G \\<equiv> residue_mult_group n\"\n  defines \"H \\<equiv> residue_mult_group m\"\n  defines \"f \\<equiv> (\\<lambda>k. k mod m)\"\n  assumes \"m > 1\" \"n > 0\" \"m dvd n\" \n  shows \"partition (carrier G) (rcosets\\<^bsub>G\\<^esub> kernel G H f)\"\n        and \"card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\"\n        and \"card (kernel G H f) = totient n div totient m\"\n        and \"b \\<in>(rcosets\\<^bsub>G\\<^esub> kernel G H f) \\<Longrightarrow> b \\<noteq> {}\"\n        and \"b \\<in>(rcosets\\<^bsub>G\\<^esub> kernel G H f) \\<Longrightarrow> card (kernel G H f) = card b\"\n        and \"bij_betw (\\<lambda>b. (the_elem (f ` b))) (rcosets\\<^bsub>G\\<^esub> kernel G H f) (carrier H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Congruence.partition (carrier G)\n      (rcosets\\<^bsub>G\\<^esub> kernel G H f) &&&\n     card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m &&&\n     card (kernel G H f) = totient n div totient m) &&&\n    (b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n     b \\<noteq> {}) &&&\n    (b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n     card (kernel G H f) = card b) &&&\n    bij_betw (\\<lambda>b. the_elem (f ` b))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f) (carrier H)", "proof -"], ["proof (state)\ngoal (6 subgoals):\n 1. Congruence.partition (carrier G) (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n 2. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 3. card (kernel G H f) = totient n div totient m\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 5. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b\n 6. bij_betw (\\<lambda>b. the_elem (f ` b))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f) (carrier H)", "have \"1 < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < m", "by fact"], ["proof (state)\nthis:\n  1 < m\n\ngoal (6 subgoals):\n 1. Congruence.partition (carrier G) (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n 2. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 3. card (kernel G H f) = totient n div totient m\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 5. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b\n 6. bij_betw (\\<lambda>b. the_elem (f ` b))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f) (carrier H)", "also"], ["proof (state)\nthis:\n  1 < m\n\ngoal (6 subgoals):\n 1. Congruence.partition (carrier G) (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n 2. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 3. card (kernel G H f) = totient n div totient m\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 5. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b\n 6. bij_betw (\\<lambda>b. the_elem (f ` b))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f) (carrier H)", "have \"m \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> n", "using \\<open>n > 0\\<close> \\<open>m dvd n\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n  m dvd n\n\ngoal (1 subgoal):\n 1. m \\<le> n", "by (intro dvd_imp_le) auto"], ["proof (state)\nthis:\n  m \\<le> n\n\ngoal (6 subgoals):\n 1. Congruence.partition (carrier G) (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n 2. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 3. card (kernel G H f) = totient n div totient m\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 5. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b\n 6. bij_betw (\\<lambda>b. the_elem (f ` b))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f) (carrier H)", "finally"], ["proof (chain)\npicking this:\n  1 < n", "have \"n > 1\""], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. 1 < n", "."], ["proof (state)\nthis:\n  1 < n\n\ngoal (6 subgoals):\n 1. Congruence.partition (carrier G) (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n 2. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 3. card (kernel G H f) = totient n div totient m\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 5. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b\n 6. bij_betw (\\<lambda>b. the_elem (f ` b))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f) (carrier H)", "note mn = \\<open>m > 1\\<close> \\<open>n > 1\\<close> \\<open>m dvd n\\<close> \\<open>m \\<le> n\\<close>"], ["proof (state)\nthis:\n  1 < m\n  1 < n\n  m dvd n\n  m \\<le> n\n\ngoal (6 subgoals):\n 1. Congruence.partition (carrier G) (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n 2. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 3. card (kernel G H f) = totient n div totient m\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 5. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b\n 6. bij_betw (\\<lambda>b. the_elem (f ` b))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f) (carrier H)", "interpret n: residues_nat n G"], ["proof (prove)\ngoal (1 subgoal):\n 1. residues_nat n &&& G \\<equiv> residue_mult_group n", "using mn"], ["proof (prove)\nusing this:\n  1 < m\n  1 < n\n  m dvd n\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. residues_nat n &&& G \\<equiv> residue_mult_group n", "by unfold_locales (auto simp: assms)"], ["proof (state)\ngoal (6 subgoals):\n 1. Congruence.partition (carrier G) (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n 2. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 3. card (kernel G H f) = totient n div totient m\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 5. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b\n 6. bij_betw (\\<lambda>b. the_elem (f ` b))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f) (carrier H)", "interpret m: residues_nat m H"], ["proof (prove)\ngoal (1 subgoal):\n 1. residues_nat m &&& H \\<equiv> residue_mult_group m", "using mn"], ["proof (prove)\nusing this:\n  1 < m\n  1 < n\n  m dvd n\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. residues_nat m &&& H \\<equiv> residue_mult_group m", "by unfold_locales (auto simp: assms)"], ["proof (state)\ngoal (6 subgoals):\n 1. Congruence.partition (carrier G) (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n 2. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 3. card (kernel G H f) = totient n div totient m\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 5. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b\n 6. bij_betw (\\<lambda>b. the_elem (f ` b))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f) (carrier H)", "from mn"], ["proof (chain)\npicking this:\n  1 < m\n  1 < n\n  m dvd n\n  m \\<le> n", "have subset: \"f ` carrier G \\<subseteq> carrier H\""], ["proof (prove)\nusing this:\n  1 < m\n  1 < n\n  m dvd n\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. f ` carrier G \\<subseteq> carrier H", "by (auto simp: assms(1-3) residue_mult_group_def totatives_def\n             dest: coprime_common_divisor_nat intro!: Nat.gr0I)"], ["proof (state)\nthis:\n  f ` carrier G \\<subseteq> carrier H\n\ngoal (6 subgoals):\n 1. Congruence.partition (carrier G) (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n 2. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 3. card (kernel G H f) = totient n div totient m\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 5. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b\n 6. bij_betw (\\<lambda>b. the_elem (f ` b))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f) (carrier H)", "moreover"], ["proof (state)\nthis:\n  f ` carrier G \\<subseteq> carrier H\n\ngoal (6 subgoals):\n 1. Congruence.partition (carrier G) (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n 2. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 3. card (kernel G H f) = totient n div totient m\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 5. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b\n 6. bij_betw (\\<lambda>b. the_elem (f ` b))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f) (carrier H)", "have super_set: \"carrier H \\<subseteq> f ` carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier H \\<subseteq> f ` carrier G", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> carrier H \\<Longrightarrow> x \\<in> f ` carrier G", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> carrier H \\<Longrightarrow> x \\<in> f ` carrier G", "assume \"k \\<in> carrier H\""], ["proof (state)\nthis:\n  k \\<in> carrier H\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> carrier H \\<Longrightarrow> x \\<in> f ` carrier G", "hence k: \"k > 0\" \"k \\<le> m\" \"coprime k m\""], ["proof (prove)\nusing this:\n  k \\<in> carrier H\n\ngoal (1 subgoal):\n 1. 0 < k &&& k \\<le> m &&& coprime k m", "by (auto simp: assms(2) residue_mult_group_def totatives_def)"], ["proof (state)\nthis:\n  0 < k\n  k \\<le> m\n  coprime k m\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> carrier H \\<Longrightarrow> x \\<in> f ` carrier G", "from mn \\<open>k \\<in> carrier H\\<close>"], ["proof (chain)\npicking this:\n  1 < m\n  1 < n\n  m dvd n\n  m \\<le> n\n  k \\<in> carrier H", "have \"k < m\""], ["proof (prove)\nusing this:\n  1 < m\n  1 < n\n  m dvd n\n  m \\<le> n\n  k \\<in> carrier H\n\ngoal (1 subgoal):\n 1. k < m", "by (simp add: totatives_less assms(2) residue_mult_group_def)"], ["proof (state)\nthis:\n  k < m\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> carrier H \\<Longrightarrow> x \\<in> f ` carrier G", "define P where \"P = {p \\<in> prime_factors n. \\<not>(p dvd m)}\""], ["proof (state)\nthis:\n  P = {p. p \\<in># prime_factorization n \\<and> \\<not> p dvd m}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> carrier H \\<Longrightarrow> x \\<in> f ` carrier G", "define a where \"a = \\<Prod>P\""], ["proof (state)\nthis:\n  a = \\<Prod>P\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> carrier H \\<Longrightarrow> x \\<in> f ` carrier G", "have [simp]: \"a \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0", "by (auto simp: P_def a_def intro!: Nat.gr0I)"], ["proof (state)\nthis:\n  a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> carrier H \\<Longrightarrow> x \\<in> f ` carrier G", "have [simp]: \"prime_factors a = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factors a = P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_factors a = P", "have \"prime_factors a = set_mset (sum prime_factorization P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factors a = set_mset (sum prime_factorization P)", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factors (\\<Prod>P) = set_mset (sum prime_factorization P)", "using mn"], ["proof (prove)\nusing this:\n  1 < m\n  1 < n\n  m dvd n\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. prime_factors (\\<Prod>P) = set_mset (sum prime_factorization P)", "by (subst prime_factorization_prod)\n           (auto simp: P_def prime_factors_dvd prime_gt_0_nat)"], ["proof (state)\nthis:\n  prime_factors a = set_mset (sum prime_factorization P)\n\ngoal (1 subgoal):\n 1. prime_factors a = P", "also"], ["proof (state)\nthis:\n  prime_factors a = set_mset (sum prime_factorization P)\n\ngoal (1 subgoal):\n 1. prime_factors a = P", "have \"sum prime_factorization P = (\\<Sum>p\\<in>P. {#p#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum prime_factorization P = (\\<Sum>p\\<in>P. {#p#})", "using mn"], ["proof (prove)\nusing this:\n  1 < m\n  1 < n\n  m dvd n\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. sum prime_factorization P = (\\<Sum>p\\<in>P. {#p#})", "by (intro sum.cong) (auto simp: P_def prime_factorization_prime prime_factors_dvd)"], ["proof (state)\nthis:\n  sum prime_factorization P = (\\<Sum>p\\<in>P. {#p#})\n\ngoal (1 subgoal):\n 1. prime_factors a = P", "finally"], ["proof (chain)\npicking this:\n  prime_factors a = set_mset (\\<Sum>p\\<in>P. {#p#})", "show ?thesis"], ["proof (prove)\nusing this:\n  prime_factors a = set_mset (\\<Sum>p\\<in>P. {#p#})\n\ngoal (1 subgoal):\n 1. prime_factors a = P", "by (simp add: P_def)"], ["proof (state)\nthis:\n  prime_factors a = P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prime_factors a = P\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> carrier H \\<Longrightarrow> x \\<in> f ` carrier G", "from mn"], ["proof (chain)\npicking this:\n  1 < m\n  1 < n\n  m dvd n\n  m \\<le> n", "have \"coprime m a\""], ["proof (prove)\nusing this:\n  1 < m\n  1 < n\n  m dvd n\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. coprime m a", "by (subst coprime_iff_prime_factors_disjoint) (auto simp: P_def)"], ["proof (state)\nthis:\n  coprime m a\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> carrier H \\<Longrightarrow> x \\<in> f ` carrier G", "hence \"\\<exists>x. [x = k] (mod m) \\<and> [x = 1] (mod a)\""], ["proof (prove)\nusing this:\n  coprime m a\n\ngoal (1 subgoal):\n 1. \\<exists>x. [x = k] (mod m) \\<and> [x = 1] (mod a)", "by (intro binary_chinese_remainder_nat)"], ["proof (state)\nthis:\n  \\<exists>x. [x = k] (mod m) \\<and> [x = 1] (mod a)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> carrier H \\<Longrightarrow> x \\<in> f ` carrier G", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. [x = k] (mod m) \\<and> [x = 1] (mod a)", "obtain x where x: \"[x = k] (mod m)\" \"[x = 1] (mod a)\""], ["proof (prove)\nusing this:\n  \\<exists>x. [x = k] (mod m) \\<and> [x = 1] (mod a)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>[x = k] (mod m); [x = 1] (mod a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  [x = k] (mod m)\n  [x = 1] (mod a)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> carrier H \\<Longrightarrow> x \\<in> f ` carrier G", "from x(1) mn k"], ["proof (chain)\npicking this:\n  [x = k] (mod m)\n  1 < m\n  1 < n\n  m dvd n\n  m \\<le> n\n  0 < k\n  k \\<le> m\n  coprime k m", "have [simp]: \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  [x = k] (mod m)\n  1 < m\n  1 < n\n  m dvd n\n  m \\<le> n\n  0 < k\n  k \\<le> m\n  coprime k m\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "using coprime_common_divisor[of k m]"], ["proof (prove)\nusing this:\n  [x = k] (mod m)\n  1 < m\n  1 < n\n  m dvd n\n  m \\<le> n\n  0 < k\n  k \\<le> m\n  coprime k m\n  \\<lbrakk>coprime k m; ?c dvd k; ?c dvd m\\<rbrakk>\n  \\<Longrightarrow> is_unit ?c\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "by (auto intro!: Nat.gr0I simp: cong_def)"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> carrier H \\<Longrightarrow> x \\<in> f ` carrier G", "from x(2)"], ["proof (chain)\npicking this:\n  [x = 1] (mod a)", "have \"coprime x a\""], ["proof (prove)\nusing this:\n  [x = 1] (mod a)\n\ngoal (1 subgoal):\n 1. coprime x a", "using cong_imp_coprime cong_sym"], ["proof (prove)\nusing this:\n  [x = 1] (mod a)\n  \\<lbrakk>[?a = ?b] (mod ?m); coprime ?a ?m\\<rbrakk>\n  \\<Longrightarrow> coprime ?b ?m\n  [?b = ?c] (mod ?a) \\<Longrightarrow> [?c = ?b] (mod ?a)\n\ngoal (1 subgoal):\n 1. coprime x a", "by force"], ["proof (state)\nthis:\n  coprime x a\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> carrier H \\<Longrightarrow> x \\<in> f ` carrier G", "hence \"coprime x (a * m)\""], ["proof (prove)\nusing this:\n  coprime x a\n\ngoal (1 subgoal):\n 1. coprime x (a * m)", "using k cong_imp_coprime[OF cong_sym[OF x(1)]]"], ["proof (prove)\nusing this:\n  coprime x a\n  0 < k\n  k \\<le> m\n  coprime k m\n  coprime k m \\<Longrightarrow> coprime x m\n\ngoal (1 subgoal):\n 1. coprime x (a * m)", "by auto"], ["proof (state)\nthis:\n  coprime x (a * m)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> carrier H \\<Longrightarrow> x \\<in> f ` carrier G", "also"], ["proof (state)\nthis:\n  coprime x (a * m)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> carrier H \\<Longrightarrow> x \\<in> f ` carrier G", "have \"?this \\<longleftrightarrow> coprime x n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime x (a * m) = coprime x n", "using mn"], ["proof (prove)\nusing this:\n  1 < m\n  1 < n\n  m dvd n\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. coprime x (a * m) = coprime x n", "by (intro coprime_cong_prime_factors)\n         (auto simp: prime_factors_product P_def in_prime_factors_iff)"], ["proof (state)\nthis:\n  coprime x (a * m) = coprime x n\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> carrier H \\<Longrightarrow> x \\<in> f ` carrier G", "finally"], ["proof (chain)\npicking this:\n  coprime x n", "have \"x mod n \\<in> totatives n\""], ["proof (prove)\nusing this:\n  coprime x n\n\ngoal (1 subgoal):\n 1. x mod n \\<in> totatives n", "using mn"], ["proof (prove)\nusing this:\n  coprime x n\n  1 < m\n  1 < n\n  m dvd n\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. x mod n \\<in> totatives n", "by (auto simp: totatives_def intro!: Nat.gr0I)"], ["proof (state)\nthis:\n  x mod n \\<in> totatives n\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> carrier H \\<Longrightarrow> x \\<in> f ` carrier G", "moreover"], ["proof (state)\nthis:\n  x mod n \\<in> totatives n\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> carrier H \\<Longrightarrow> x \\<in> f ` carrier G", "have \"f (x mod n) = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (x mod n) = k", "using x(1) k mn \\<open>k < m\\<close>"], ["proof (prove)\nusing this:\n  [x = k] (mod m)\n  0 < k\n  k \\<le> m\n  coprime k m\n  1 < m\n  1 < n\n  m dvd n\n  m \\<le> n\n  k < m\n\ngoal (1 subgoal):\n 1. f (x mod n) = k", "by (auto simp: assms(3) cong_def mod_mod_cancel)"], ["proof (state)\nthis:\n  f (x mod n) = k\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> carrier H \\<Longrightarrow> x \\<in> f ` carrier G", "ultimately"], ["proof (chain)\npicking this:\n  x mod n \\<in> totatives n\n  f (x mod n) = k", "show \"k \\<in> f ` carrier G\""], ["proof (prove)\nusing this:\n  x mod n \\<in> totatives n\n  f (x mod n) = k\n\ngoal (1 subgoal):\n 1. k \\<in> f ` carrier G", "by (auto simp: assms(1) residue_mult_group_def)"], ["proof (state)\nthis:\n  k \\<in> f ` carrier G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  carrier H \\<subseteq> f ` carrier G\n\ngoal (6 subgoals):\n 1. Congruence.partition (carrier G) (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n 2. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 3. card (kernel G H f) = totient n div totient m\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 5. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b\n 6. bij_betw (\\<lambda>b. the_elem (f ` b))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f) (carrier H)", "ultimately"], ["proof (chain)\npicking this:\n  f ` carrier G \\<subseteq> carrier H\n  carrier H \\<subseteq> f ` carrier G", "have image_eq: \"f ` carrier G = carrier H\""], ["proof (prove)\nusing this:\n  f ` carrier G \\<subseteq> carrier H\n  carrier H \\<subseteq> f ` carrier G\n\ngoal (1 subgoal):\n 1. f ` carrier G = carrier H", "by blast"], ["proof (state)\nthis:\n  f ` carrier G = carrier H\n\ngoal (6 subgoals):\n 1. Congruence.partition (carrier G) (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n 2. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 3. card (kernel G H f) = totient n div totient m\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 5. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b\n 6. bij_betw (\\<lambda>b. the_elem (f ` b))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f) (carrier H)", "have [simp]: \"f (k \\<otimes>\\<^bsub>G\\<^esub> l) = f k \\<otimes>\\<^bsub>H\\<^esub> f l\" if \"k \\<in> carrier G\" \"l \\<in> carrier G\" for k l"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (k \\<otimes>\\<^bsub>G\\<^esub> l) = f k \\<otimes>\\<^bsub>H\\<^esub> f l", "using that mn"], ["proof (prove)\nusing this:\n  k \\<in> carrier G\n  l \\<in> carrier G\n  1 < m\n  1 < n\n  m dvd n\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. f (k \\<otimes>\\<^bsub>G\\<^esub> l) = f k \\<otimes>\\<^bsub>H\\<^esub> f l", "by (auto simp: assms(1-3) residue_mult_group_def totatives_def\n                                 mod_mod_cancel mod_mult_eq)"], ["proof (state)\nthis:\n  \\<lbrakk>?k \\<in> carrier G; ?l \\<in> carrier G\\<rbrakk>\n  \\<Longrightarrow> f (?k \\<otimes>\\<^bsub>G\\<^esub> ?l) =\n                    f ?k \\<otimes>\\<^bsub>H\\<^esub> f ?l\n\ngoal (6 subgoals):\n 1. Congruence.partition (carrier G) (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n 2. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 3. card (kernel G H f) = totient n div totient m\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 5. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b\n 6. bij_betw (\\<lambda>b. the_elem (f ` b))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f) (carrier H)", "interpret f: group_hom G H f"], ["proof (prove)\ngoal (1 subgoal):\n 1. group_hom G H f", "using subset"], ["proof (prove)\nusing this:\n  f ` carrier G \\<subseteq> carrier H\n\ngoal (1 subgoal):\n 1. group_hom G H f", "by unfold_locales (auto simp: hom_def)"], ["proof (state)\ngoal (6 subgoals):\n 1. Congruence.partition (carrier G) (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n 2. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 3. card (kernel G H f) = totient n div totient m\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 5. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b\n 6. bij_betw (\\<lambda>b. the_elem (f ` b))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f) (carrier H)", "show \"bij_betw (\\<lambda>b. (the_elem (f ` b))) (rcosets\\<^bsub>G\\<^esub> kernel G H f) (carrier H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>b. the_elem (f ` b))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f) (carrier H)", "unfolding bij_betw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>b. the_elem (f ` b))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f) \\<and>\n    (\\<lambda>b. the_elem (f ` b)) `\n    (rcosets\\<^bsub>G\\<^esub> kernel G H f) =\n    carrier H", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>b. the_elem (f ` b))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n 2. (\\<lambda>b. the_elem (f ` b)) `\n    (rcosets\\<^bsub>G\\<^esub> kernel G H f) =\n    carrier H", "show \"inj_on (\\<lambda>b. (the_elem (f ` b))) (rcosets\\<^bsub>G\\<^esub> kernel G H f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>b. the_elem (f ` b))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f)", "using f.FactGroup_inj_on"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>X. the_elem (f ` X)) (carrier (G Mod kernel G H f))\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>b. the_elem (f ` b))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f)", "unfolding FactGroup_def"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>X. the_elem (f ` X))\n   (carrier\n     \\<lparr>carrier = rcosets\\<^bsub>G\\<^esub> kernel G H f,\n        monoid.mult = (<#>\\<^bsub>G\\<^esub>), one = kernel G H f\\<rparr>)\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>b. the_elem (f ` b))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f)", "by auto"], ["proof (state)\nthis:\n  inj_on (\\<lambda>b. the_elem (f ` b))\n   (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. the_elem (f ` b)) `\n    (rcosets\\<^bsub>G\\<^esub> kernel G H f) =\n    carrier H", "have eq: \"f ` carrier G = carrier H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` carrier G = carrier H", "using subset super_set"], ["proof (prove)\nusing this:\n  f ` carrier G \\<subseteq> carrier H\n  carrier H \\<subseteq> f ` carrier G\n\ngoal (1 subgoal):\n 1. f ` carrier G = carrier H", "by blast"], ["proof (state)\nthis:\n  f ` carrier G = carrier H\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. the_elem (f ` b)) `\n    (rcosets\\<^bsub>G\\<^esub> kernel G H f) =\n    carrier H", "show \"(\\<lambda>b. the_elem (f ` b)) ` (rcosets\\<^bsub>G\\<^esub> kernel G H f) = carrier H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>b. the_elem (f ` b)) `\n    (rcosets\\<^bsub>G\\<^esub> kernel G H f) =\n    carrier H", "using f.FactGroup_onto[OF eq]"], ["proof (prove)\nusing this:\n  (\\<lambda>X. the_elem (f ` X)) ` carrier (G Mod kernel G H f) = carrier H\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. the_elem (f ` b)) `\n    (rcosets\\<^bsub>G\\<^esub> kernel G H f) =\n    carrier H", "unfolding FactGroup_def"], ["proof (prove)\nusing this:\n  (\\<lambda>X. the_elem (f ` X)) `\n  carrier\n   \\<lparr>carrier = rcosets\\<^bsub>G\\<^esub> kernel G H f,\n      monoid.mult = (<#>\\<^bsub>G\\<^esub>), one = kernel G H f\\<rparr> =\n  carrier H\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. the_elem (f ` b)) `\n    (rcosets\\<^bsub>G\\<^esub> kernel G H f) =\n    carrier H", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>b. the_elem (f ` b)) ` (rcosets\\<^bsub>G\\<^esub> kernel G H f) =\n  carrier H\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bij_betw (\\<lambda>b. the_elem (f ` b))\n   (rcosets\\<^bsub>G\\<^esub> kernel G H f) (carrier H)\n\ngoal (5 subgoals):\n 1. Congruence.partition (carrier G) (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n 2. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 3. card (kernel G H f) = totient n div totient m\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 5. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b", "show \"partition (carrier G) (rcosets\\<^bsub>G\\<^esub> kernel G H f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Congruence.partition (carrier G) (rcosets\\<^bsub>G\\<^esub> kernel G H f)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       a \\<in> carrier G \\<Longrightarrow>\n       \\<exists>!b.\n          b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<and> a \\<in> b\n 2. \\<And>b.\n       b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n       b \\<subseteq> carrier G", "show \"\\<And>a. a \\<in> carrier G \\<Longrightarrow>\n         \\<exists>!b. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<and> a \\<in> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> carrier G \\<Longrightarrow>\n       \\<exists>!b.\n          b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<and> a \\<in> b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> carrier G \\<Longrightarrow>\n       \\<exists>!b.\n          b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<and> a \\<in> b", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> carrier G \\<Longrightarrow>\n       \\<exists>!b.\n          b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<and> a \\<in> b", "assume a_in: \"a \\<in> carrier G\""], ["proof (state)\nthis:\n  a \\<in> carrier G\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> carrier G \\<Longrightarrow>\n       \\<exists>!b.\n          b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<and> a \\<in> b", "show \"\\<exists>!b. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<and> a \\<in> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!b.\n       b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<and> a \\<in> b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!b.\n       b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<and> a \\<in> b", "(*exists*)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!b.\n       b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<and> a \\<in> b", "have \"\\<exists>b. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<and> a \\<in> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b.\n       b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<and> a \\<in> b", "using a_in n.rcosets_part_G[OF f.subgroup_kernel]"], ["proof (prove)\nusing this:\n  a \\<in> carrier G\n  \\<Union> (rcosets\\<^bsub>G\\<^esub> kernel G H f) = carrier G\n\ngoal (1 subgoal):\n 1. \\<exists>b.\n       b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<and> a \\<in> b", "by blast"], ["proof (state)\nthis:\n  \\<exists>b. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<and> a \\<in> b\n\ngoal (1 subgoal):\n 1. \\<exists>!b.\n       b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<and> a \\<in> b", "then"], ["proof (chain)\npicking this:\n  \\<exists>b. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<and> a \\<in> b", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>b. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<and> a \\<in> b\n\ngoal (1 subgoal):\n 1. \\<exists>!b.\n       b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<and> a \\<in> b", "using group.rcos_disjoint[OF n.is_group f.subgroup_kernel]"], ["proof (prove)\nusing this:\n  \\<exists>b. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<and> a \\<in> b\n  disjoint (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n\ngoal (1 subgoal):\n 1. \\<exists>!b.\n       b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<and> a \\<in> b", "by (auto simp: disjoint_def)"], ["proof (state)\nthis:\n  \\<exists>!b.\n     b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<and> a \\<in> b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!b.\n     b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<and> a \\<in> b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?a \\<in> carrier G \\<Longrightarrow>\n  \\<exists>!b.\n     b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<and> ?a \\<in> b\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n       b \\<subseteq> carrier G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n       b \\<subseteq> carrier G", "show \"\\<And>b. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow> b \\<subseteq> carrier G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n       b \\<subseteq> carrier G", "using n.rcosets_part_G f.subgroup_kernel"], ["proof (prove)\nusing this:\n  subgroup ?H G \\<Longrightarrow>\n  \\<Union> (rcosets\\<^bsub>G\\<^esub> ?H) = carrier G\n  subgroup (kernel G H f) G\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n       b \\<subseteq> carrier G", "by auto"], ["proof (state)\nthis:\n  ?b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n  ?b \\<subseteq> carrier G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Congruence.partition (carrier G) (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n\ngoal (4 subgoals):\n 1. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 2. card (kernel G H f) = totient n div totient m\n 3. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b", "(* sizes *)"], ["proof (state)\nthis:\n  Congruence.partition (carrier G) (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n\ngoal (4 subgoals):\n 1. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 2. card (kernel G H f) = totient n div totient m\n 3. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b", "have lagr: \"card (carrier G) = card (rcosets\\<^bsub>G\\<^esub> kernel G H f) * card (kernel G H f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (carrier G) =\n    card (rcosets\\<^bsub>G\\<^esub> kernel G H f) * card (kernel G H f)", "using group.lagrange_finite[OF n.is_group n.fin f.subgroup_kernel] Coset.order_def[of G]"], ["proof (prove)\nusing this:\n  card (rcosets\\<^bsub>G\\<^esub> kernel G H f) * card (kernel G H f) =\n  Coset.order G\n  Coset.order G = card (carrier G)\n\ngoal (1 subgoal):\n 1. card (carrier G) =\n    card (rcosets\\<^bsub>G\\<^esub> kernel G H f) * card (kernel G H f)", "by argo"], ["proof (state)\nthis:\n  card (carrier G) =\n  card (rcosets\\<^bsub>G\\<^esub> kernel G H f) * card (kernel G H f)\n\ngoal (4 subgoals):\n 1. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 2. card (kernel G H f) = totient n div totient m\n 3. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b", "have k_size: \"card (kernel G H f) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < card (kernel G H f)", "using f.subgroup_kernel finite_subset n.subgroupE(1) n.subgroupE(2)"], ["proof (prove)\nusing this:\n  subgroup (kernel G H f) G\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n  subgroup ?H G \\<Longrightarrow> ?H \\<subseteq> carrier G\n  subgroup ?H G \\<Longrightarrow> ?H \\<noteq> {}\n\ngoal (1 subgoal):\n 1. 0 < card (kernel G H f)", "by fastforce"], ["proof (state)\nthis:\n  0 < card (kernel G H f)\n\ngoal (4 subgoals):\n 1. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 2. card (kernel G H f) = totient n div totient m\n 3. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b", "have G_size: \"card (carrier G) = totient n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (carrier G) = totient n", "using n.order Coset.order_def[of G]"], ["proof (prove)\nusing this:\n  Coset.order G = totient n\n  Coset.order G = card (carrier G)\n\ngoal (1 subgoal):\n 1. card (carrier G) = totient n", "by simp"], ["proof (state)\nthis:\n  card (carrier G) = totient n\n\ngoal (4 subgoals):\n 1. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 2. card (kernel G H f) = totient n div totient m\n 3. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b", "have H_size: \" totient m = card (carrier H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. totient m = card (carrier H)", "using n.order Coset.order_def[of H]"], ["proof (prove)\nusing this:\n  Coset.order G = totient n\n  Coset.order H = card (carrier H)\n\ngoal (1 subgoal):\n 1. totient m = card (carrier H)", "by simp"], ["proof (state)\nthis:\n  totient m = card (carrier H)\n\ngoal (4 subgoals):\n 1. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 2. card (kernel G H f) = totient n div totient m\n 3. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b", "also"], ["proof (state)\nthis:\n  totient m = card (carrier H)\n\ngoal (4 subgoals):\n 1. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 2. card (kernel G H f) = totient n div totient m\n 3. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b", "have \"\\<dots> = card (carrier (G Mod kernel G H f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (carrier H) = card (carrier (G Mod kernel G H f))", "using f.FactGroup_iso[OF image_eq] card_image f.FactGroup_inj_on f.FactGroup_onto image_eq"], ["proof (prove)\nusing this:\n  G Mod kernel G H f \\<cong> H\n  inj_on ?f ?A \\<Longrightarrow> card (?f ` ?A) = card ?A\n  inj_on (\\<lambda>X. the_elem (f ` X)) (carrier (G Mod kernel G H f))\n  f ` carrier G = carrier H \\<Longrightarrow>\n  (\\<lambda>X. the_elem (f ` X)) ` carrier (G Mod kernel G H f) = carrier H\n  f ` carrier G = carrier H\n\ngoal (1 subgoal):\n 1. card (carrier H) = card (carrier (G Mod kernel G H f))", "by fastforce"], ["proof (state)\nthis:\n  card (carrier H) = card (carrier (G Mod kernel G H f))\n\ngoal (4 subgoals):\n 1. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 2. card (kernel G H f) = totient n div totient m\n 3. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b", "also"], ["proof (state)\nthis:\n  card (carrier H) = card (carrier (G Mod kernel G H f))\n\ngoal (4 subgoals):\n 1. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 2. card (kernel G H f) = totient n div totient m\n 3. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b", "have \"\\<dots> = card (carrier G) div card (kernel G H f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (carrier (G Mod kernel G H f)) =\n    card (carrier G) div card (kernel G H f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (carrier (G Mod kernel G H f)) =\n    card (carrier G) div card (kernel G H f)", "have \"card (carrier (G Mod kernel G H f)) = \n          card (rcosets\\<^bsub>G\\<^esub> kernel G H f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (carrier (G Mod kernel G H f)) =\n    card (rcosets\\<^bsub>G\\<^esub> kernel G H f)", "unfolding FactGroup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (carrier\n       \\<lparr>carrier = rcosets\\<^bsub>G\\<^esub> kernel G H f,\n          monoid.mult = (<#>\\<^bsub>G\\<^esub>),\n          one = kernel G H f\\<rparr>) =\n    card (rcosets\\<^bsub>G\\<^esub> kernel G H f)", "by simp"], ["proof (state)\nthis:\n  card (carrier (G Mod kernel G H f)) =\n  card (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n\ngoal (1 subgoal):\n 1. card (carrier (G Mod kernel G H f)) =\n    card (carrier G) div card (kernel G H f)", "also"], ["proof (state)\nthis:\n  card (carrier (G Mod kernel G H f)) =\n  card (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n\ngoal (1 subgoal):\n 1. card (carrier (G Mod kernel G H f)) =\n    card (carrier G) div card (kernel G H f)", "have \"\\<dots> = card (carrier G) div card (kernel G H f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) =\n    card (carrier G) div card (kernel G H f)", "by (simp add: lagr k_size)"], ["proof (state)\nthis:\n  card (rcosets\\<^bsub>G\\<^esub> kernel G H f) =\n  card (carrier G) div card (kernel G H f)\n\ngoal (1 subgoal):\n 1. card (carrier (G Mod kernel G H f)) =\n    card (carrier G) div card (kernel G H f)", "finally"], ["proof (chain)\npicking this:\n  card (carrier (G Mod kernel G H f)) =\n  card (carrier G) div card (kernel G H f)", "show ?thesis"], ["proof (prove)\nusing this:\n  card (carrier (G Mod kernel G H f)) =\n  card (carrier G) div card (kernel G H f)\n\ngoal (1 subgoal):\n 1. card (carrier (G Mod kernel G H f)) =\n    card (carrier G) div card (kernel G H f)", "by blast"], ["proof (state)\nthis:\n  card (carrier (G Mod kernel G H f)) =\n  card (carrier G) div card (kernel G H f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (carrier (G Mod kernel G H f)) =\n  card (carrier G) div card (kernel G H f)\n\ngoal (4 subgoals):\n 1. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 2. card (kernel G H f) = totient n div totient m\n 3. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b", "also"], ["proof (state)\nthis:\n  card (carrier (G Mod kernel G H f)) =\n  card (carrier G) div card (kernel G H f)\n\ngoal (4 subgoals):\n 1. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 2. card (kernel G H f) = totient n div totient m\n 3. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b", "have \"\\<dots> = totient n div card (kernel G H f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (carrier G) div card (kernel G H f) =\n    totient n div card (kernel G H f)", "using G_size"], ["proof (prove)\nusing this:\n  card (carrier G) = totient n\n\ngoal (1 subgoal):\n 1. card (carrier G) div card (kernel G H f) =\n    totient n div card (kernel G H f)", "by argo"], ["proof (state)\nthis:\n  card (carrier G) div card (kernel G H f) =\n  totient n div card (kernel G H f)\n\ngoal (4 subgoals):\n 1. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 2. card (kernel G H f) = totient n div totient m\n 3. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b", "finally"], ["proof (chain)\npicking this:\n  totient m = totient n div card (kernel G H f)", "have eq: \"totient m = totient n div card (kernel G H f)\""], ["proof (prove)\nusing this:\n  totient m = totient n div card (kernel G H f)\n\ngoal (1 subgoal):\n 1. totient m = totient n div card (kernel G H f)", "by simp"], ["proof (state)\nthis:\n  totient m = totient n div card (kernel G H f)\n\ngoal (4 subgoals):\n 1. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 2. card (kernel G H f) = totient n div totient m\n 3. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 4. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b", "show \"card (kernel G H f) = totient n div totient m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (kernel G H f) = totient n div totient m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (kernel G H f) = totient n div totient m", "have \"totient m \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. totient m \\<noteq> 0", "using totient_0_iff[of m] assms(4)"], ["proof (prove)\nusing this:\n  (totient m = 0) = (m = 0)\n  1 < m\n\ngoal (1 subgoal):\n 1. totient m \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  totient m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (kernel G H f) = totient n div totient m", "have \"card (kernel G H f) dvd totient n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (kernel G H f) dvd totient n", "using lagr \\<open>card (carrier G) = totient n\\<close>"], ["proof (prove)\nusing this:\n  card (carrier G) =\n  card (rcosets\\<^bsub>G\\<^esub> kernel G H f) * card (kernel G H f)\n  card (carrier G) = totient n\n\ngoal (1 subgoal):\n 1. card (kernel G H f) dvd totient n", "by auto"], ["proof (state)\nthis:\n  card (kernel G H f) dvd totient n\n\ngoal (1 subgoal):\n 1. card (kernel G H f) = totient n div totient m", "have \"totient m * card (kernel G H f) = totient n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. totient m * card (kernel G H f) = totient n", "unfolding eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. totient n div card (kernel G H f) * card (kernel G H f) = totient n", "using \\<open>card (kernel G H f) dvd totient n\\<close>"], ["proof (prove)\nusing this:\n  card (kernel G H f) dvd totient n\n\ngoal (1 subgoal):\n 1. totient n div card (kernel G H f) * card (kernel G H f) = totient n", "by auto"], ["proof (state)\nthis:\n  totient m * card (kernel G H f) = totient n\n\ngoal (1 subgoal):\n 1. card (kernel G H f) = totient n div totient m", "have \"totient n div totient m = totient m * card (kernel G H f) div totient m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. totient n div totient m = totient m * card (kernel G H f) div totient m", "using \\<open>totient m * card (kernel G H f) = totient n\\<close>"], ["proof (prove)\nusing this:\n  totient m * card (kernel G H f) = totient n\n\ngoal (1 subgoal):\n 1. totient n div totient m = totient m * card (kernel G H f) div totient m", "by auto"], ["proof (state)\nthis:\n  totient n div totient m = totient m * card (kernel G H f) div totient m\n\ngoal (1 subgoal):\n 1. card (kernel G H f) = totient n div totient m", "also"], ["proof (state)\nthis:\n  totient n div totient m = totient m * card (kernel G H f) div totient m\n\ngoal (1 subgoal):\n 1. card (kernel G H f) = totient n div totient m", "have \"\\<dots> = card (kernel G H f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. totient m * card (kernel G H f) div totient m = card (kernel G H f)", "using nonzero_mult_div_cancel_left[OF \\<open>totient m \\<noteq> 0\\<close>]"], ["proof (prove)\nusing this:\n  totient m * ?b div totient m = ?b\n\ngoal (1 subgoal):\n 1. totient m * card (kernel G H f) div totient m = card (kernel G H f)", "by blast"], ["proof (state)\nthis:\n  totient m * card (kernel G H f) div totient m = card (kernel G H f)\n\ngoal (1 subgoal):\n 1. card (kernel G H f) = totient n div totient m", "finally"], ["proof (chain)\npicking this:\n  totient n div totient m = card (kernel G H f)", "show ?thesis"], ["proof (prove)\nusing this:\n  totient n div totient m = card (kernel G H f)\n\ngoal (1 subgoal):\n 1. card (kernel G H f) = totient n div totient m", "by auto"], ["proof (state)\nthis:\n  card (kernel G H f) = totient n div totient m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (kernel G H f) = totient n div totient m\n\ngoal (3 subgoals):\n 1. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n 2. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 3. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b", "show \"card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m", "have H_size: \" totient m = card (carrier H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. totient m = card (carrier H)", "using n.order Coset.order_def[of H]"], ["proof (prove)\nusing this:\n  Coset.order G = totient n\n  Coset.order H = card (carrier H)\n\ngoal (1 subgoal):\n 1. totient m = card (carrier H)", "by simp"], ["proof (state)\nthis:\n  totient m = card (carrier H)\n\ngoal (1 subgoal):\n 1. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m", "also"], ["proof (state)\nthis:\n  totient m = card (carrier H)\n\ngoal (1 subgoal):\n 1. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m", "have \"\\<dots> = card (carrier (G Mod kernel G H f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (carrier H) = card (carrier (G Mod kernel G H f))", "using f.FactGroup_iso[OF image_eq] card_image f.FactGroup_inj_on f.FactGroup_onto image_eq"], ["proof (prove)\nusing this:\n  G Mod kernel G H f \\<cong> H\n  inj_on ?f ?A \\<Longrightarrow> card (?f ` ?A) = card ?A\n  inj_on (\\<lambda>X. the_elem (f ` X)) (carrier (G Mod kernel G H f))\n  f ` carrier G = carrier H \\<Longrightarrow>\n  (\\<lambda>X. the_elem (f ` X)) ` carrier (G Mod kernel G H f) = carrier H\n  f ` carrier G = carrier H\n\ngoal (1 subgoal):\n 1. card (carrier H) = card (carrier (G Mod kernel G H f))", "by fastforce"], ["proof (state)\nthis:\n  card (carrier H) = card (carrier (G Mod kernel G H f))\n\ngoal (1 subgoal):\n 1. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m", "also"], ["proof (state)\nthis:\n  card (carrier H) = card (carrier (G Mod kernel G H f))\n\ngoal (1 subgoal):\n 1. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m", "have \"card (carrier (G Mod kernel G H f)) = \n          card (rcosets\\<^bsub>G\\<^esub> kernel G H f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (carrier (G Mod kernel G H f)) =\n    card (rcosets\\<^bsub>G\\<^esub> kernel G H f)", "unfolding FactGroup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (carrier\n       \\<lparr>carrier = rcosets\\<^bsub>G\\<^esub> kernel G H f,\n          monoid.mult = (<#>\\<^bsub>G\\<^esub>),\n          one = kernel G H f\\<rparr>) =\n    card (rcosets\\<^bsub>G\\<^esub> kernel G H f)", "by simp"], ["proof (state)\nthis:\n  card (carrier (G Mod kernel G H f)) =\n  card (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n\ngoal (1 subgoal):\n 1. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m", "finally"], ["proof (chain)\npicking this:\n  totient m = card (rcosets\\<^bsub>G\\<^esub> kernel G H f)", "show \"card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\""], ["proof (prove)\nusing this:\n  totient m = card (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n\ngoal (1 subgoal):\n 1. card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m", "by argo"], ["proof (state)\nthis:\n  card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (rcosets\\<^bsub>G\\<^esub> kernel G H f) = totient m\n\ngoal (2 subgoals):\n 1. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 2. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b", "assume \"b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f\""], ["proof (state)\nthis:\n  b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f\n\ngoal (2 subgoals):\n 1. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}\n 2. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b", "then"], ["proof (chain)\npicking this:\n  b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f", "show \"b \\<noteq> {}\""], ["proof (prove)\nusing this:\n  b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f\n\ngoal (1 subgoal):\n 1. b \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}", "have \"card b = card (kernel G H f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card b = card (kernel G H f)", "using \\<open>b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f\\<close> f.subgroup_kernel n.card_rcosets_equal n.subgroupE(1)"], ["proof (prove)\nusing this:\n  b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f\n  subgroup (kernel G H f) G\n  \\<lbrakk>?R \\<in> rcosets\\<^bsub>G\\<^esub> ?H;\n   ?H \\<subseteq> carrier G\\<rbrakk>\n  \\<Longrightarrow> card ?H = card ?R\n  subgroup ?H G \\<Longrightarrow> ?H \\<subseteq> carrier G\n\ngoal (1 subgoal):\n 1. card b = card (kernel G H f)", "by auto"], ["proof (state)\nthis:\n  card b = card (kernel G H f)\n\ngoal (1 subgoal):\n 1. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  card b = card (kernel G H f)", "have \"card b > 0\""], ["proof (prove)\nusing this:\n  card b = card (kernel G H f)\n\ngoal (1 subgoal):\n 1. 0 < card b", "by (simp add: k_size)"], ["proof (state)\nthis:\n  0 < card b\n\ngoal (1 subgoal):\n 1. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    b \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  0 < card b", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < card b\n\ngoal (1 subgoal):\n 1. b \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  b \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b \\<noteq> {}\n\ngoal (1 subgoal):\n 1. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b", "assume b_cos: \"b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f\""], ["proof (state)\nthis:\n  b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f\n\ngoal (1 subgoal):\n 1. b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n    card (kernel G H f) = card b", "show \"card (kernel G H f) = card b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (kernel G H f) = card b", "using group.card_rcosets_equal[OF n.is_group b_cos] \n          f.subgroup_kernel subgroup.subset"], ["proof (prove)\nusing this:\n  kernel G H f \\<subseteq> carrier G \\<Longrightarrow>\n  card (kernel G H f) = card b\n  subgroup (kernel G H f) G\n  subgroup ?H ?G \\<Longrightarrow> ?H \\<subseteq> carrier ?G\n\ngoal (1 subgoal):\n 1. card (kernel G H f) = card b", "by blast"], ["proof (state)\nthis:\n  card (kernel G H f) = card b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma primitive_iff_separable_lemma:\n assumes prod: \"(\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n) \\<and> primitive_dchar d \\<Phi>\"\n assumes \\<open>d > 1\\<close> \\<open>0 < k\\<close> \\<open>d dvd k\\<close> \\<open>k > 1\\<close>\n shows \"(\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k. \\<Phi>(m) * unity_root d m) =\n        (totient k div totient d) * (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d. \\<Phi>(m) * unity_root d m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "from assms"], ["proof (chain)\npicking this:\n  (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n) \\<and>\n  primitive_dchar d \\<Phi>\n  1 < d\n  0 < k\n  d dvd k\n  1 < k", "interpret \\<Phi>: primitive_dchar d \"residue_mult_group d\" \\<Phi>"], ["proof (prove)\nusing this:\n  (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n) \\<and>\n  primitive_dchar d \\<Phi>\n  1 < d\n  0 < k\n  d dvd k\n  1 < k\n\ngoal (1 subgoal):\n 1. primitive_dchar d \\<Phi> &&&\n    residue_mult_group d \\<equiv> residue_mult_group d", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "define G where \"G = residue_mult_group k\""], ["proof (state)\nthis:\n  G = residue_mult_group k\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "define H where \"H = residue_mult_group d\""], ["proof (state)\nthis:\n  H = residue_mult_group d\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "define f where \"f = (\\<lambda>t. t mod d)\""], ["proof (state)\nthis:\n  f = (\\<lambda>t. t mod d)\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "from residue_mult_group_kernel_partition(2)[OF \\<open>d > 1\\<close> \\<open>0 < k\\<close> \\<open>d dvd k\\<close>]"], ["proof (chain)\npicking this:\n  card\n   (rcosets\\<^bsub>residue_mult_group k\\<^esub> kernel\n           (residue_mult_group k) (residue_mult_group d)\n           (\\<lambda>k. k mod d)) =\n  totient d", "have fin_cosets: \"finite (rcosets\\<^bsub>G\\<^esub> kernel G H f)\""], ["proof (prove)\nusing this:\n  card\n   (rcosets\\<^bsub>residue_mult_group k\\<^esub> kernel\n           (residue_mult_group k) (residue_mult_group d)\n           (\\<lambda>k. k mod d)) =\n  totient d\n\ngoal (1 subgoal):\n 1. finite (rcosets\\<^bsub>G\\<^esub> kernel G H f)", "using \\<open>1 < d\\<close> card.infinite"], ["proof (prove)\nusing this:\n  card\n   (rcosets\\<^bsub>residue_mult_group k\\<^esub> kernel\n           (residue_mult_group k) (residue_mult_group d)\n           (\\<lambda>k. k mod d)) =\n  totient d\n  1 < d\n  infinite ?A \\<Longrightarrow> card ?A = 0\n\ngoal (1 subgoal):\n 1. finite (rcosets\\<^bsub>G\\<^esub> kernel G H f)", "by (fastforce simp: G_def H_def f_def)"], ["proof (state)\nthis:\n  finite (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "have fin_G: \"finite (carrier G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (carrier G)", "unfolding G_def residue_mult_group_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (carrier\n       \\<lparr>carrier = totatives k,\n          monoid.mult = \\<lambda>x y. x * y mod k, one = 1\\<rparr>)", "by simp"], ["proof (state)\nthis:\n  finite (carrier G)\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "have eq: \"(\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k. \\<Phi>(m) * unity_root d m) =\n         (\\<Sum>m | m \\<in> carrier G . \\<Phi>(m) * unity_root d m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    (\\<Sum>m | m \\<in> carrier G. \\<Phi> m * unity_root d (int m))", "unfolding residue_mult_group_def totatives_def G_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    (\\<Sum>m | m \\<in> carrier\n                        \\<lparr>carrier = {ka \\<in> {0<..k}. coprime ka k},\n                           monoid.mult = \\<lambda>x y. x * y mod k,\n                           one = 1\\<rparr>.\n       \\<Phi> m * unity_root d (int m))", "by (rule sum.cong,auto)"], ["proof (state)\nthis:\n  (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n     \\<Phi> m * unity_root d (int m)) =\n  (\\<Sum>m | m \\<in> carrier G. \\<Phi> m * unity_root d (int m))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "also"], ["proof (state)\nthis:\n  (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n     \\<Phi> m * unity_root d (int m)) =\n  (\\<Sum>m | m \\<in> carrier G. \\<Phi> m * unity_root d (int m))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "have \"\\<dots> = sum (\\<lambda>m. \\<Phi>(m) * unity_root d m) (carrier G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> carrier G. \\<Phi> m * unity_root d (int m)) =\n    (\\<Sum>m\\<in>carrier G. \\<Phi> m * unity_root d (int m))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>m | m \\<in> carrier G. \\<Phi> m * unity_root d (int m)) =\n  (\\<Sum>m\\<in>carrier G. \\<Phi> m * unity_root d (int m))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "also"], ["proof (state)\nthis:\n  (\\<Sum>m | m \\<in> carrier G. \\<Phi> m * unity_root d (int m)) =\n  (\\<Sum>m\\<in>carrier G. \\<Phi> m * unity_root d (int m))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "have eq': \"\\<dots> = sum (sum (\\<lambda>m. \\<Phi> m * unity_root d (int m))) (rcosets\\<^bsub>G\\<^esub> kernel G H f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>carrier G. \\<Phi> m * unity_root d (int m)) =\n    sum (sum (\\<lambda>m. \\<Phi> m * unity_root d (int m)))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f)", "by (rule disjoint_sum [symmetric])\n       (use fin_G fin_cosets residue_mult_group_kernel_partition(1)[OF \\<open>d > 1\\<close> \\<open>k > 0\\<close> \\<open>d dvd k\\<close>] in\n          \\<open>auto simp: G_def H_def f_def\\<close>)"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>carrier G. \\<Phi> m * unity_root d (int m)) =\n  sum (sum (\\<lambda>m. \\<Phi> m * unity_root d (int m)))\n   (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "also"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>carrier G. \\<Phi> m * unity_root d (int m)) =\n  sum (sum (\\<lambda>m. \\<Phi> m * unity_root d (int m)))\n   (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "have \"\\<dots> =\n   (\\<Sum>b \\<in> (rcosets\\<^bsub>G\\<^esub> kernel G H f) . (\\<Sum>m \\<in> b. \\<Phi> m * unity_root d (int m)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (sum (\\<lambda>m. \\<Phi> m * unity_root d (int m)))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f) =\n    sum (sum (\\<lambda>m. \\<Phi> m * unity_root d (int m)))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f)", "by simp"], ["proof (state)\nthis:\n  sum (sum (\\<lambda>m. \\<Phi> m * unity_root d (int m)))\n   (rcosets\\<^bsub>G\\<^esub> kernel G H f) =\n  sum (sum (\\<lambda>m. \\<Phi> m * unity_root d (int m)))\n   (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n     \\<Phi> m * unity_root d (int m)) =\n  (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n     \\<Phi> m * unity_root d (int m))", "have 1: \"(\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k. \\<Phi>(m) * unity_root d m) =\n                   (\\<Sum>b \\<in> (rcosets\\<^bsub>G\\<^esub> kernel G H f) . (\\<Sum>m \\<in> b. \\<Phi> m * unity_root d (int m)))\""], ["proof (prove)\nusing this:\n  (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n     \\<Phi> m * unity_root d (int m)) =\n  (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n     \\<Phi> m * unity_root d (int m))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    sum (sum (\\<lambda>m. \\<Phi> m * unity_root d (int m)))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f)", "using eq eq'"], ["proof (prove)\nusing this:\n  (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n     \\<Phi> m * unity_root d (int m)) =\n  (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n     \\<Phi> m * unity_root d (int m))\n  (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n     \\<Phi> m * unity_root d (int m)) =\n  (\\<Sum>m | m \\<in> carrier G. \\<Phi> m * unity_root d (int m))\n  (\\<Sum>m\\<in>carrier G. \\<Phi> m * unity_root d (int m)) =\n  sum (sum (\\<lambda>m. \\<Phi> m * unity_root d (int m)))\n   (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    sum (sum (\\<lambda>m. \\<Phi> m * unity_root d (int m)))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n     \\<Phi> m * unity_root d (int m)) =\n  sum (sum (\\<lambda>m. \\<Phi> m * unity_root d (int m)))\n   (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "have eq''': \"\\<dots> =\n    (\\<Sum>b \\<in> (rcosets\\<^bsub>G\\<^esub> kernel G H f) . (totient k div totient d) * (\\<Phi> (the_elem (f ` b)) * unity_root d (int (the_elem (f ` b)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (sum (\\<lambda>m. \\<Phi> m * unity_root d (int m)))\n     (rcosets\\<^bsub>G\\<^esub> kernel G H f) =\n    (\\<Sum>b\\<in>rcosets\\<^bsub>G\\<^esub> kernel G H f.\n       of_nat (totient k div totient d) *\n       (\\<Phi> (the_elem (f ` b)) * unity_root d (int (the_elem (f ` b)))))", "proof (rule sum.cong,simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n       (\\<Sum>m\\<in>x. \\<Phi> m * unity_root d (int m)) =\n       of_nat (totient k div totient d) *\n       (\\<Phi> (the_elem (f ` x)) * unity_root d (int (the_elem (f ` x))))", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n       (\\<Sum>m\\<in>x. \\<Phi> m * unity_root d (int m)) =\n       of_nat (totient k div totient d) *\n       (\\<Phi> (the_elem (f ` x)) * unity_root d (int (the_elem (f ` x))))", "assume b_in: \"b \\<in> (rcosets\\<^bsub>G\\<^esub> kernel G H f)\""], ["proof (state)\nthis:\n  b \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n       (\\<Sum>m\\<in>x. \\<Phi> m * unity_root d (int m)) =\n       of_nat (totient k div totient d) *\n       (\\<Phi> (the_elem (f ` x)) * unity_root d (int (the_elem (f ` x))))", "note b_not_empty = residue_mult_group_kernel_partition(4)\n                         [OF \\<open>d > 1\\<close> \\<open>0 < k\\<close> \\<open>d dvd k\\<close> b_in[unfolded G_def H_def f_def]]"], ["proof (state)\nthis:\n  b \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n       (\\<Sum>m\\<in>x. \\<Phi> m * unity_root d (int m)) =\n       of_nat (totient k div totient d) *\n       (\\<Phi> (the_elem (f ` x)) * unity_root d (int (the_elem (f ` x))))", "{"], ["proof (state)\nthis:\n  b \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n       (\\<Sum>m\\<in>x. \\<Phi> m * unity_root d (int m)) =\n       of_nat (totient k div totient d) *\n       (\\<Phi> (the_elem (f ` x)) * unity_root d (int (the_elem (f ` x))))", "fix m1 m2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n       (\\<Sum>m\\<in>x. \\<Phi> m * unity_root d (int m)) =\n       of_nat (totient k div totient d) *\n       (\\<Phi> (the_elem (f ` x)) * unity_root d (int (the_elem (f ` x))))", "assume m_in: \"m1 \\<in> b\" \"m2 \\<in> b\""], ["proof (state)\nthis:\n  m1 \\<in> b\n  m2 \\<in> b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n       (\\<Sum>m\\<in>x. \\<Phi> m * unity_root d (int m)) =\n       of_nat (totient k div totient d) *\n       (\\<Phi> (the_elem (f ` x)) * unity_root d (int (the_elem (f ` x))))", "have m_mod: \"m1 mod d = m2 mod d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 mod d = m2 mod d", "using residue_mult_group_coset[OF b_in[unfolded G_def H_def f_def] m_in \\<open>k > 1\\<close> \\<open>d dvd k\\<close>]"], ["proof (prove)\nusing this:\n  m1 mod d = m2 mod d\n\ngoal (1 subgoal):\n 1. m1 mod d = m2 mod d", "by blast"], ["proof (state)\nthis:\n  m1 mod d = m2 mod d\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n       (\\<Sum>m\\<in>x. \\<Phi> m * unity_root d (int m)) =\n       of_nat (totient k div totient d) *\n       (\\<Phi> (the_elem (f ` x)) * unity_root d (int (the_elem (f ` x))))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?m1.2 \\<in> b; ?m2.2 \\<in> b\\<rbrakk>\n  \\<Longrightarrow> ?m1.2 mod d = ?m2.2 mod d\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n       (\\<Sum>m\\<in>x. \\<Phi> m * unity_root d (int m)) =\n       of_nat (totient k div totient d) *\n       (\\<Phi> (the_elem (f ` x)) * unity_root d (int (the_elem (f ` x))))", "note m_mod = this"], ["proof (state)\nthis:\n  \\<lbrakk>?m1.2 \\<in> b; ?m2.2 \\<in> b\\<rbrakk>\n  \\<Longrightarrow> ?m1.2 mod d = ?m2.2 mod d\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n       (\\<Sum>m\\<in>x. \\<Phi> m * unity_root d (int m)) =\n       of_nat (totient k div totient d) *\n       (\\<Phi> (the_elem (f ` x)) * unity_root d (int (the_elem (f ` x))))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?m1.2 \\<in> b; ?m2.2 \\<in> b\\<rbrakk>\n  \\<Longrightarrow> ?m1.2 mod d = ?m2.2 mod d\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n       (\\<Sum>m\\<in>x. \\<Phi> m * unity_root d (int m)) =\n       of_nat (totient k div totient d) *\n       (\\<Phi> (the_elem (f ` x)) * unity_root d (int (the_elem (f ` x))))", "fix m1 m2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n       (\\<Sum>m\\<in>x. \\<Phi> m * unity_root d (int m)) =\n       of_nat (totient k div totient d) *\n       (\\<Phi> (the_elem (f ` x)) * unity_root d (int (the_elem (f ` x))))", "assume m_in: \"m1 \\<in> b\" \"m2 \\<in> b\""], ["proof (state)\nthis:\n  m1 \\<in> b\n  m2 \\<in> b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n       (\\<Sum>m\\<in>x. \\<Phi> m * unity_root d (int m)) =\n       of_nat (totient k div totient d) *\n       (\\<Phi> (the_elem (f ` x)) * unity_root d (int (the_elem (f ` x))))", "have \"\\<Phi> m1 * unity_root d (int m1) = \\<Phi> m2 * unity_root d (int m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> m1 * unity_root d (int m1) = \\<Phi> m2 * unity_root d (int m2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> m1 * unity_root d (int m1) = \\<Phi> m2 * unity_root d (int m2)", "have \\<Phi>_periodic: \"periodic_arithmetic \\<Phi> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic \\<Phi> d", "using \\<Phi>.dir_periodic_arithmetic"], ["proof (prove)\nusing this:\n  periodic_arithmetic \\<Phi> d\n\ngoal (1 subgoal):\n 1. periodic_arithmetic \\<Phi> d", "by blast"], ["proof (state)\nthis:\n  periodic_arithmetic \\<Phi> d\n\ngoal (1 subgoal):\n 1. \\<Phi> m1 * unity_root d (int m1) = \\<Phi> m2 * unity_root d (int m2)", "have 1: \"\\<Phi> m1 = \\<Phi> m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> m1 = \\<Phi> m2", "using mod_periodic_arithmetic[OF \\<open>periodic_arithmetic \\<Phi> d\\<close> m_mod[OF m_in]]"], ["proof (prove)\nusing this:\n  \\<Phi> m1 = \\<Phi> m2\n\ngoal (1 subgoal):\n 1. \\<Phi> m1 = \\<Phi> m2", "by simp"], ["proof (state)\nthis:\n  \\<Phi> m1 = \\<Phi> m2\n\ngoal (1 subgoal):\n 1. \\<Phi> m1 * unity_root d (int m1) = \\<Phi> m2 * unity_root d (int m2)", "have 2: \"unity_root d m1 = unity_root d m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root d (int m1) = unity_root d (int m2)", "using m_mod[OF m_in]"], ["proof (prove)\nusing this:\n  m1 mod d = m2 mod d\n\ngoal (1 subgoal):\n 1. unity_root d (int m1) = unity_root d (int m2)", "by (intro unity_root_cong) (auto simp: cong_def simp flip: zmod_int)"], ["proof (state)\nthis:\n  unity_root d (int m1) = unity_root d (int m2)\n\ngoal (1 subgoal):\n 1. \\<Phi> m1 * unity_root d (int m1) = \\<Phi> m2 * unity_root d (int m2)", "from 1 2"], ["proof (chain)\npicking this:\n  \\<Phi> m1 = \\<Phi> m2\n  unity_root d (int m1) = unity_root d (int m2)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Phi> m1 = \\<Phi> m2\n  unity_root d (int m1) = unity_root d (int m2)\n\ngoal (1 subgoal):\n 1. \\<Phi> m1 * unity_root d (int m1) = \\<Phi> m2 * unity_root d (int m2)", "by simp"], ["proof (state)\nthis:\n  \\<Phi> m1 * unity_root d (int m1) = \\<Phi> m2 * unity_root d (int m2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi> m1 * unity_root d (int m1) = \\<Phi> m2 * unity_root d (int m2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n       (\\<Sum>m\\<in>x. \\<Phi> m * unity_root d (int m)) =\n       of_nat (totient k div totient d) *\n       (\\<Phi> (the_elem (f ` x)) * unity_root d (int (the_elem (f ` x))))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?m1.2 \\<in> b; ?m2.2 \\<in> b\\<rbrakk>\n  \\<Longrightarrow> \\<Phi> ?m1.2 * unity_root d (int ?m1.2) =\n                    \\<Phi> ?m2.2 * unity_root d (int ?m2.2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n       (\\<Sum>m\\<in>x. \\<Phi> m * unity_root d (int m)) =\n       of_nat (totient k div totient d) *\n       (\\<Phi> (the_elem (f ` x)) * unity_root d (int (the_elem (f ` x))))", "note all_eq_in_coset = this"], ["proof (state)\nthis:\n  \\<lbrakk>?m1.2 \\<in> b; ?m2.2 \\<in> b\\<rbrakk>\n  \\<Longrightarrow> \\<Phi> ?m1.2 * unity_root d (int ?m1.2) =\n                    \\<Phi> ?m2.2 * unity_root d (int ?m2.2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n       (\\<Sum>m\\<in>x. \\<Phi> m * unity_root d (int m)) =\n       of_nat (totient k div totient d) *\n       (\\<Phi> (the_elem (f ` x)) * unity_root d (int (the_elem (f ` x))))", "from all_eq_in_coset b_not_empty"], ["proof (chain)\npicking this:\n  \\<lbrakk>?m1.2 \\<in> b; ?m2.2 \\<in> b\\<rbrakk>\n  \\<Longrightarrow> \\<Phi> ?m1.2 * unity_root d (int ?m1.2) =\n                    \\<Phi> ?m2.2 * unity_root d (int ?m2.2)\n  b \\<noteq> {}", "obtain l where l_prop: \"l \\<in> b \\<and> (\\<forall>y \\<in> b. \\<Phi> y * unity_root d (int y) = \n                                \\<Phi> l * unity_root d (int l))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?m1.2 \\<in> b; ?m2.2 \\<in> b\\<rbrakk>\n  \\<Longrightarrow> \\<Phi> ?m1.2 * unity_root d (int ?m1.2) =\n                    \\<Phi> ?m2.2 * unity_root d (int ?m2.2)\n  b \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        l \\<in> b \\<and>\n        (\\<forall>y\\<in>b.\n            \\<Phi> y * unity_root d (int y) =\n            \\<Phi> l * unity_root d (int l)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  l \\<in> b \\<and>\n  (\\<forall>y\\<in>b.\n      \\<Phi> y * unity_root d (int y) = \\<Phi> l * unity_root d (int l))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n       (\\<Sum>m\\<in>x. \\<Phi> m * unity_root d (int m)) =\n       of_nat (totient k div totient d) *\n       (\\<Phi> (the_elem (f ` x)) * unity_root d (int (the_elem (f ` x))))", "have \"(\\<Sum>m \\<in> b. \\<Phi> m * unity_root d (int m)) =\n            ((totient k div totient d) * (\\<Phi> l * unity_root d (int l)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>b. \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) * (\\<Phi> l * unity_root d (int l))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>b. \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) * (\\<Phi> l * unity_root d (int l))", "have \"(\\<Sum>m \\<in> b. \\<Phi> m * unity_root d (int m)) =\n              (\\<Sum>m \\<in> b. \\<Phi> l * unity_root d (int l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>b. \\<Phi> m * unity_root d (int m)) =\n    (\\<Sum>m\\<in>b. \\<Phi> l * unity_root d (int l))", "by (rule sum.cong,simp) (use all_eq_in_coset l_prop in blast)"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>b. \\<Phi> m * unity_root d (int m)) =\n  (\\<Sum>m\\<in>b. \\<Phi> l * unity_root d (int l))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>b. \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) * (\\<Phi> l * unity_root d (int l))", "also"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>b. \\<Phi> m * unity_root d (int m)) =\n  (\\<Sum>m\\<in>b. \\<Phi> l * unity_root d (int l))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>b. \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) * (\\<Phi> l * unity_root d (int l))", "have \"\\<dots> = card b * \\<Phi> l * unity_root d (int l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>b. \\<Phi> l * unity_root d (int l)) =\n    of_nat (card b) * \\<Phi> l * unity_root d (int l)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>b. \\<Phi> l * unity_root d (int l)) =\n  of_nat (card b) * \\<Phi> l * unity_root d (int l)\n\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>b. \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) * (\\<Phi> l * unity_root d (int l))", "also"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>b. \\<Phi> l * unity_root d (int l)) =\n  of_nat (card b) * \\<Phi> l * unity_root d (int l)\n\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>b. \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) * (\\<Phi> l * unity_root d (int l))", "have \"\\<dots> = (totient k div totient d) * \\<Phi> l * unity_root d (int l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (card b) * \\<Phi> l * unity_root d (int l) =\n    of_nat (totient k div totient d) * \\<Phi> l * unity_root d (int l)", "using residue_mult_group_kernel_partition(3)[OF \\<open>d > 1\\<close> \\<open>0 < k\\<close> \\<open>d dvd k\\<close>] \n              residue_mult_group_kernel_partition(5)\n                [OF \\<open>d > 1\\<close> \\<open>0 < k\\<close> \\<open>d dvd k\\<close> b_in [unfolded G_def H_def f_def]]"], ["proof (prove)\nusing this:\n  card\n   (kernel (residue_mult_group k) (residue_mult_group d)\n     (\\<lambda>k. k mod d)) =\n  totient k div totient d\n  card\n   (kernel (residue_mult_group k) (residue_mult_group d)\n     (\\<lambda>k. k mod d)) =\n  card b\n\ngoal (1 subgoal):\n 1. of_nat (card b) * \\<Phi> l * unity_root d (int l) =\n    of_nat (totient k div totient d) * \\<Phi> l * unity_root d (int l)", "by argo"], ["proof (state)\nthis:\n  of_nat (card b) * \\<Phi> l * unity_root d (int l) =\n  of_nat (totient k div totient d) * \\<Phi> l * unity_root d (int l)\n\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>b. \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) * (\\<Phi> l * unity_root d (int l))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>m\\<in>b. \\<Phi> m * unity_root d (int m)) =\n  of_nat (totient k div totient d) * \\<Phi> l * unity_root d (int l)", "have 2:\n        \"(\\<Sum>m \\<in> b. \\<Phi> m * unity_root d (int m)) = \n         (totient k div totient d) * \\<Phi> l * unity_root d (int l)\""], ["proof (prove)\nusing this:\n  (\\<Sum>m\\<in>b. \\<Phi> m * unity_root d (int m)) =\n  of_nat (totient k div totient d) * \\<Phi> l * unity_root d (int l)\n\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>b. \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) * \\<Phi> l * unity_root d (int l)", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>b. \\<Phi> m * unity_root d (int m)) =\n  of_nat (totient k div totient d) * \\<Phi> l * unity_root d (int l)\n\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>b. \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) * (\\<Phi> l * unity_root d (int l))", "from b_not_empty 2"], ["proof (chain)\npicking this:\n  b \\<noteq> {}\n  (\\<Sum>m\\<in>b. \\<Phi> m * unity_root d (int m)) =\n  of_nat (totient k div totient d) * \\<Phi> l * unity_root d (int l)", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<noteq> {}\n  (\\<Sum>m\\<in>b. \\<Phi> m * unity_root d (int m)) =\n  of_nat (totient k div totient d) * \\<Phi> l * unity_root d (int l)\n\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>b. \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) * (\\<Phi> l * unity_root d (int l))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>b. \\<Phi> m * unity_root d (int m)) =\n  of_nat (totient k div totient d) * (\\<Phi> l * unity_root d (int l))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>b. \\<Phi> m * unity_root d (int m)) =\n  of_nat (totient k div totient d) * (\\<Phi> l * unity_root d (int l))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n       (\\<Sum>m\\<in>x. \\<Phi> m * unity_root d (int m)) =\n       of_nat (totient k div totient d) *\n       (\\<Phi> (the_elem (f ` x)) * unity_root d (int (the_elem (f ` x))))", "also"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>b. \\<Phi> m * unity_root d (int m)) =\n  of_nat (totient k div totient d) * (\\<Phi> l * unity_root d (int l))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n       (\\<Sum>m\\<in>x. \\<Phi> m * unity_root d (int m)) =\n       of_nat (totient k div totient d) *\n       (\\<Phi> (the_elem (f ` x)) * unity_root d (int (the_elem (f ` x))))", "have \"\\<dots> = ((totient k div totient d) * (\\<Phi> (the_elem (f ` b)) * unity_root d (int (the_elem (f ` b)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (totient k div totient d) * (\\<Phi> l * unity_root d (int l)) =\n    of_nat (totient k div totient d) *\n    (\\<Phi> (the_elem (f ` b)) * unity_root d (int (the_elem (f ` b))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. of_nat (totient k div totient d) * (\\<Phi> l * unity_root d (int l)) =\n    of_nat (totient k div totient d) *\n    (\\<Phi> (the_elem (f ` b)) * unity_root d (int (the_elem (f ` b))))", "have foral: \"(\\<And>y. y \\<in> b \\<Longrightarrow> f y = f l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> b \\<Longrightarrow> f y = f l", "using m_mod l_prop"], ["proof (prove)\nusing this:\n  \\<lbrakk>?m1.2 \\<in> b; ?m2.2 \\<in> b\\<rbrakk>\n  \\<Longrightarrow> ?m1.2 mod d = ?m2.2 mod d\n  l \\<in> b \\<and>\n  (\\<forall>y\\<in>b.\n      \\<Phi> y * unity_root d (int y) = \\<Phi> l * unity_root d (int l))\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> b \\<Longrightarrow> f y = f l", "unfolding f_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?m1.2 \\<in> b; ?m2.2 \\<in> b\\<rbrakk>\n  \\<Longrightarrow> ?m1.2 mod d = ?m2.2 mod d\n  l \\<in> b \\<and>\n  (\\<forall>y\\<in>b.\n      \\<Phi> y * unity_root d (int y) = \\<Phi> l * unity_root d (int l))\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> b \\<Longrightarrow> y mod d = l mod d", "by blast"], ["proof (state)\nthis:\n  ?y \\<in> b \\<Longrightarrow> f ?y = f l\n\ngoal (1 subgoal):\n 1. of_nat (totient k div totient d) * (\\<Phi> l * unity_root d (int l)) =\n    of_nat (totient k div totient d) *\n    (\\<Phi> (the_elem (f ` b)) * unity_root d (int (the_elem (f ` b))))", "have eq: \"the_elem (f ` b) = f l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_elem (f ` b) = f l", "using the_elem_image_unique[of _ f l, OF b_not_empty foral]"], ["proof (prove)\nusing this:\n  (\\<And>y. y \\<in> b \\<Longrightarrow> y \\<in> b) \\<Longrightarrow>\n  the_elem (f ` b) = f l\n\ngoal (1 subgoal):\n 1. the_elem (f ` b) = f l", "by simp"], ["proof (state)\nthis:\n  the_elem (f ` b) = f l\n\ngoal (1 subgoal):\n 1. of_nat (totient k div totient d) * (\\<Phi> l * unity_root d (int l)) =\n    of_nat (totient k div totient d) *\n    (\\<Phi> (the_elem (f ` b)) * unity_root d (int (the_elem (f ` b))))", "have per: \"periodic_arithmetic \\<Phi> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. periodic_arithmetic \\<Phi> d", "using prod \\<Phi>.dir_periodic_arithmetic"], ["proof (prove)\nusing this:\n  (\\<forall>n. \\<chi> n = \\<Phi> n * \\<chi>\\<^sub>1 n) \\<and>\n  primitive_dchar d \\<Phi>\n  periodic_arithmetic \\<Phi> d\n\ngoal (1 subgoal):\n 1. periodic_arithmetic \\<Phi> d", "by blast"], ["proof (state)\nthis:\n  periodic_arithmetic \\<Phi> d\n\ngoal (1 subgoal):\n 1. of_nat (totient k div totient d) * (\\<Phi> l * unity_root d (int l)) =\n    of_nat (totient k div totient d) *\n    (\\<Phi> (the_elem (f ` b)) * unity_root d (int (the_elem (f ` b))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (totient k div totient d) * (\\<Phi> l * unity_root d (int l)) =\n    of_nat (totient k div totient d) *\n    (\\<Phi> (the_elem (f ` b)) * unity_root d (int (the_elem (f ` b))))", "unfolding eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (totient k div totient d) * (\\<Phi> l * unity_root d (int l)) =\n    of_nat (totient k div totient d) *\n    (\\<Phi> (f l) * unity_root d (int (f l)))", "using mod_periodic_arithmetic[OF per, of \"l mod d\" l]"], ["proof (prove)\nusing this:\n  l mod d mod d = l mod d \\<Longrightarrow> \\<Phi> (l mod d) = \\<Phi> l\n\ngoal (1 subgoal):\n 1. of_nat (totient k div totient d) * (\\<Phi> l * unity_root d (int l)) =\n    of_nat (totient k div totient d) *\n    (\\<Phi> (f l) * unity_root d (int (f l)))", "by (auto simp: f_def unity_root_mod zmod_int)"], ["proof (state)\nthis:\n  of_nat (totient k div totient d) * (\\<Phi> l * unity_root d (int l)) =\n  of_nat (totient k div totient d) *\n  (\\<Phi> (the_elem (f ` b)) * unity_root d (int (the_elem (f ` b))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  of_nat (totient k div totient d) * (\\<Phi> l * unity_root d (int l)) =\n  of_nat (totient k div totient d) *\n  (\\<Phi> (the_elem (f ` b)) * unity_root d (int (the_elem (f ` b))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> rcosets\\<^bsub>G\\<^esub> kernel G H f \\<Longrightarrow>\n       (\\<Sum>m\\<in>x. \\<Phi> m * unity_root d (int m)) =\n       of_nat (totient k div totient d) *\n       (\\<Phi> (the_elem (f ` x)) * unity_root d (int (the_elem (f ` x))))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>m\\<in>b. \\<Phi> m * unity_root d (int m)) =\n  of_nat (totient k div totient d) *\n  (\\<Phi> (the_elem (f ` b)) * unity_root d (int (the_elem (f ` b))))", "show \"(\\<Sum>m \\<in> b. \\<Phi> m * unity_root d (int m)) = \n                 ((totient k div totient d) * (\\<Phi> (the_elem (f ` b)) * unity_root d (int (the_elem (f ` b)))))\""], ["proof (prove)\nusing this:\n  (\\<Sum>m\\<in>b. \\<Phi> m * unity_root d (int m)) =\n  of_nat (totient k div totient d) *\n  (\\<Phi> (the_elem (f ` b)) * unity_root d (int (the_elem (f ` b))))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>b. \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Phi> (the_elem (f ` b)) * unity_root d (int (the_elem (f ` b))))", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>b. \\<Phi> m * unity_root d (int m)) =\n  of_nat (totient k div totient d) *\n  (\\<Phi> (the_elem (f ` b)) * unity_root d (int (the_elem (f ` b))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum (sum (\\<lambda>m. \\<Phi> m * unity_root d (int m)))\n   (rcosets\\<^bsub>G\\<^esub> kernel G H f) =\n  (\\<Sum>b\\<in>rcosets\\<^bsub>G\\<^esub> kernel G H f.\n     of_nat (totient k div totient d) *\n     (\\<Phi> (the_elem (f ` b)) * unity_root d (int (the_elem (f ` b)))))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "have \"\\<dots> =\n             (\\<Sum>b \\<in> (rcosets\\<^bsub>G\\<^esub> kernel G H f) . (totient k div totient d) * (\\<Phi> (the_elem (f ` b)) * unity_root d (int (the_elem (f ` b)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>rcosets\\<^bsub>G\\<^esub> kernel G H f.\n       of_nat (totient k div totient d) *\n       (\\<Phi> (the_elem (f ` b)) *\n        unity_root d (int (the_elem (f ` b))))) =\n    (\\<Sum>b\\<in>rcosets\\<^bsub>G\\<^esub> kernel G H f.\n       of_nat (totient k div totient d) *\n       (\\<Phi> (the_elem (f ` b)) * unity_root d (int (the_elem (f ` b)))))", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>rcosets\\<^bsub>G\\<^esub> kernel G H f.\n     of_nat (totient k div totient d) *\n     (\\<Phi> (the_elem (f ` b)) * unity_root d (int (the_elem (f ` b))))) =\n  (\\<Sum>b\\<in>rcosets\\<^bsub>G\\<^esub> kernel G H f.\n     of_nat (totient k div totient d) *\n     (\\<Phi> (the_elem (f ` b)) * unity_root d (int (the_elem (f ` b)))))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "also"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>rcosets\\<^bsub>G\\<^esub> kernel G H f.\n     of_nat (totient k div totient d) *\n     (\\<Phi> (the_elem (f ` b)) * unity_root d (int (the_elem (f ` b))))) =\n  (\\<Sum>b\\<in>rcosets\\<^bsub>G\\<^esub> kernel G H f.\n     of_nat (totient k div totient d) *\n     (\\<Phi> (the_elem (f ` b)) * unity_root d (int (the_elem (f ` b)))))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "have eq'': \"\n     \\<dots> = (\\<Sum>h \\<in> carrier H . (totient k div totient d) * (\\<Phi> (h) * unity_root d (int (h))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>rcosets\\<^bsub>G\\<^esub> kernel G H f.\n       of_nat (totient k div totient d) *\n       (\\<Phi> (the_elem (f ` b)) *\n        unity_root d (int (the_elem (f ` b))))) =\n    (\\<Sum>h\\<in>carrier H.\n       of_nat (totient k div totient d) * (\\<Phi> h * unity_root d (int h)))", "unfolding H_def G_def f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>b\\<in>rcosets\\<^bsub>residue_mult_group k\\<^esub> kernel\n                        (residue_mult_group k) (residue_mult_group d)\n                        (\\<lambda>t. t mod d).\n       of_nat (totient k div totient d) *\n       (\\<Phi> (the_elem ((\\<lambda>t. t mod d) ` b)) *\n        unity_root d (int (the_elem ((\\<lambda>t. t mod d) ` b))))) =\n    (\\<Sum>h\\<in>carrier (residue_mult_group d).\n       of_nat (totient k div totient d) * (\\<Phi> h * unity_root d (int h)))", "by (rule sum.reindex_bij_betw[OF residue_mult_group_kernel_partition(6)[OF \\<open>d > 1\\<close> \\<open>0 < k\\<close> \\<open>d dvd k\\<close>]])"], ["proof (state)\nthis:\n  (\\<Sum>b\\<in>rcosets\\<^bsub>G\\<^esub> kernel G H f.\n     of_nat (totient k div totient d) *\n     (\\<Phi> (the_elem (f ` b)) * unity_root d (int (the_elem (f ` b))))) =\n  (\\<Sum>h\\<in>carrier H.\n     of_nat (totient k div totient d) * (\\<Phi> h * unity_root d (int h)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>h\\<in>carrier H.\n     of_nat (totient k div totient d) * (\\<Phi> h * unity_root d (int h))) =\n  (\\<Sum>h\\<in>carrier H.\n     of_nat (totient k div totient d) * (\\<Phi> h * unity_root d (int h)))", "have 2: \"(\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k. \\<Phi>(m) * unity_root d m) = \n                  (totient k div totient d)*(\\<Sum>h \\<in> carrier H .  (\\<Phi> (h) * unity_root d (int (h))))\""], ["proof (prove)\nusing this:\n  (\\<Sum>h\\<in>carrier H.\n     of_nat (totient k div totient d) * (\\<Phi> h * unity_root d (int h))) =\n  (\\<Sum>h\\<in>carrier H.\n     of_nat (totient k div totient d) * (\\<Phi> h * unity_root d (int h)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>h\\<in>carrier H. \\<Phi> h * unity_root d (int h))", "using 1"], ["proof (prove)\nusing this:\n  (\\<Sum>h\\<in>carrier H.\n     of_nat (totient k div totient d) * (\\<Phi> h * unity_root d (int h))) =\n  (\\<Sum>h\\<in>carrier H.\n     of_nat (totient k div totient d) * (\\<Phi> h * unity_root d (int h)))\n  (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n     \\<Phi> m * unity_root d (int m)) =\n  sum (sum (\\<lambda>m. \\<Phi> m * unity_root d (int m)))\n   (rcosets\\<^bsub>G\\<^esub> kernel G H f)\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>h\\<in>carrier H. \\<Phi> h * unity_root d (int h))", "by (simp add: eq'' eq''' sum_distrib_left)"], ["proof (state)\nthis:\n  (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n     \\<Phi> m * unity_root d (int m)) =\n  of_nat (totient k div totient d) *\n  (\\<Sum>h\\<in>carrier H. \\<Phi> h * unity_root d (int h))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "also"], ["proof (state)\nthis:\n  (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n     \\<Phi> m * unity_root d (int m)) =\n  of_nat (totient k div totient d) *\n  (\\<Sum>h\\<in>carrier H. \\<Phi> h * unity_root d (int h))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "have \"\\<dots> = (totient k div totient d)*(\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d . (\\<Phi> (m) * unity_root d (int (m))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (totient k div totient d) *\n    (\\<Sum>h\\<in>carrier H. \\<Phi> h * unity_root d (int h)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "unfolding H_def residue_mult_group_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (totient k div totient d) *\n    (\\<Sum>h\\<in>carrier\n                  \\<lparr>carrier = totatives d,\n                     monoid.mult = \\<lambda>x y. x * y mod d,\n                     one = 1\\<rparr>.\n       \\<Phi> h * unity_root d (int h)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "by (simp add: totatives_def Suc_le_eq)"], ["proof (state)\nthis:\n  of_nat (totient k div totient d) *\n  (\\<Sum>h\\<in>carrier H. \\<Phi> h * unity_root d (int h)) =\n  of_nat (totient k div totient d) *\n  (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n     \\<Phi> m * unity_root d (int m))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n     \\<Phi> m * unity_root d (int m)) =\n  of_nat (totient k div totient d) *\n  (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n     \\<Phi> m * unity_root d (int m))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n     \\<Phi> m * unity_root d (int m)) =\n  of_nat (totient k div totient d) *\n  (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n     \\<Phi> m * unity_root d (int m))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient k div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>m | m \\<in> {1..k} \\<and> coprime m k.\n     \\<Phi> m * unity_root d (int m)) =\n  of_nat (totient k div totient d) *\n  (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n     \\<Phi> m * unity_root d (int m))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 8.19\\<close>"], ["", "theorem (in dcharacter) primitive_iff_separable:\n  \"primitive_dchar n \\<chi> \\<longleftrightarrow> (\\<forall>k>0. separable k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primitive_dchar n \\<chi> = (\\<forall>k>0. separable k)", "proof (cases \"\\<chi> = principal_dchar n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<chi> = principal_dchar n \\<Longrightarrow>\n    primitive_dchar n \\<chi> = (\\<forall>k>0. separable k)\n 2. \\<chi> \\<noteq> principal_dchar n \\<Longrightarrow>\n    primitive_dchar n \\<chi> = (\\<forall>k>0. separable k)", "case True"], ["proof (state)\nthis:\n  \\<chi> = principal_dchar n\n\ngoal (2 subgoals):\n 1. \\<chi> = principal_dchar n \\<Longrightarrow>\n    primitive_dchar n \\<chi> = (\\<forall>k>0. separable k)\n 2. \\<chi> \\<noteq> principal_dchar n \\<Longrightarrow>\n    primitive_dchar n \\<chi> = (\\<forall>k>0. separable k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<chi> = principal_dchar n\n\ngoal (1 subgoal):\n 1. primitive_dchar n \\<chi> = (\\<forall>k>0. separable k)", "using principal_not_primitive principal_not_totally_separable"], ["proof (prove)\nusing this:\n  \\<chi> = principal_dchar n\n  \\<not> primitive_dchar n (principal_dchar n)\n  \\<chi> = principal_dchar n \\<Longrightarrow>\n  \\<not> (\\<forall>k>0. separable k)\n\ngoal (1 subgoal):\n 1. primitive_dchar n \\<chi> = (\\<forall>k>0. separable k)", "by auto"], ["proof (state)\nthis:\n  primitive_dchar n \\<chi> = (\\<forall>k>0. separable k)\n\ngoal (1 subgoal):\n 1. \\<chi> \\<noteq> principal_dchar n \\<Longrightarrow>\n    primitive_dchar n \\<chi> = (\\<forall>k>0. separable k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<chi> \\<noteq> principal_dchar n \\<Longrightarrow>\n    primitive_dchar n \\<chi> = (\\<forall>k>0. separable k)", "case False"], ["proof (state)\nthis:\n  \\<chi> \\<noteq> principal_dchar n\n\ngoal (1 subgoal):\n 1. \\<chi> \\<noteq> principal_dchar n \\<Longrightarrow>\n    primitive_dchar n \\<chi> = (\\<forall>k>0. separable k)", "note nonprincipal = this"], ["proof (state)\nthis:\n  \\<chi> \\<noteq> principal_dchar n\n\ngoal (1 subgoal):\n 1. \\<chi> \\<noteq> principal_dchar n \\<Longrightarrow>\n    primitive_dchar n \\<chi> = (\\<forall>k>0. separable k)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. primitive_dchar n \\<chi> = (\\<forall>k>0. separable k)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. primitive_dchar n \\<chi> \\<Longrightarrow> \\<forall>k>0. separable k\n 2. \\<forall>k>0. separable k \\<Longrightarrow> primitive_dchar n \\<chi>", "assume \"primitive_dchar n \\<chi>\""], ["proof (state)\nthis:\n  primitive_dchar n \\<chi>\n\ngoal (2 subgoals):\n 1. primitive_dchar n \\<chi> \\<Longrightarrow> \\<forall>k>0. separable k\n 2. \\<forall>k>0. separable k \\<Longrightarrow> primitive_dchar n \\<chi>", "then"], ["proof (chain)\npicking this:\n  primitive_dchar n \\<chi>", "interpret A: primitive_dchar n \"residue_mult_group n\" \\<chi>"], ["proof (prove)\nusing this:\n  primitive_dchar n \\<chi>\n\ngoal (1 subgoal):\n 1. primitive_dchar n \\<chi> &&&\n    residue_mult_group n \\<equiv> residue_mult_group n", "by auto"], ["proof (state)\ngoal (2 subgoals):\n 1. primitive_dchar n \\<chi> \\<Longrightarrow> \\<forall>k>0. A.separable k\n 2. \\<forall>k>0. A.separable k \\<Longrightarrow> primitive_dchar n \\<chi>", "show \"(\\<forall>k. k > 0 \\<longrightarrow> separable k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k>0. A.separable k", "using n A.primitive_encoding(2)"], ["proof (prove)\nusing this:\n  1 < n\n  \\<forall>k>0. A.separable k\n\ngoal (1 subgoal):\n 1. \\<forall>k>0. A.separable k", "by blast"], ["proof (state)\nthis:\n  \\<forall>k>0. A.separable k\n\ngoal (1 subgoal):\n 1. \\<forall>k>0. A.separable k \\<Longrightarrow> primitive_dchar n \\<chi>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>k>0. separable k \\<Longrightarrow> primitive_dchar n \\<chi>", "assume tot_separable: \"\\<forall>k>0. separable k\""], ["proof (state)\nthis:\n  \\<forall>k>0. separable k\n\ngoal (1 subgoal):\n 1. \\<forall>k>0. separable k \\<Longrightarrow> primitive_dchar n \\<chi>", "{"], ["proof (state)\nthis:\n  \\<forall>k>0. separable k\n\ngoal (1 subgoal):\n 1. \\<forall>k>0. separable k \\<Longrightarrow> primitive_dchar n \\<chi>", "assume as: \"\\<not> primitive_dchar n \\<chi>\""], ["proof (state)\nthis:\n  \\<not> primitive_dchar n \\<chi>\n\ngoal (1 subgoal):\n 1. \\<forall>k>0. separable k \\<Longrightarrow> primitive_dchar n \\<chi>", "have \"\\<exists>r. r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "from n"], ["proof (chain)\npicking this:\n  1 < n", "have \"n > 0\""], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. 0 < n", "by simp"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "define d where \"d = conductor\""], ["proof (state)\nthis:\n  d = conductor\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "have \"d > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < d", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < conductor", "using conductor_gr_0"], ["proof (prove)\nusing this:\n  0 < conductor\n\ngoal (1 subgoal):\n 1. 0 < conductor", "."], ["proof (state)\nthis:\n  0 < d\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  0 < d", "have \"d > 1\""], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. 1 < d", "using nonprincipal d_def conductor_eq_1_iff_principal"], ["proof (prove)\nusing this:\n  0 < d\n  \\<chi> \\<noteq> principal_dchar n\n  d = conductor\n  (conductor = 1) = (\\<chi> = principal_dchar n)\n\ngoal (1 subgoal):\n 1. 1 < d", "by auto"], ["proof (state)\nthis:\n  1 < d\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "have \"d < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d < n", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. conductor < n", "using nonprimitive_imp_conductor_less[OF as]"], ["proof (prove)\nusing this:\n  conductor < n\n\ngoal (1 subgoal):\n 1. conductor < n", "."], ["proof (state)\nthis:\n  d < n\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "have \"d dvd n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d dvd n", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. conductor dvd n", "using conductor_dvd"], ["proof (prove)\nusing this:\n  conductor dvd n\n\ngoal (1 subgoal):\n 1. conductor dvd n", "by blast"], ["proof (state)\nthis:\n  d dvd n\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "define r where \"r = n div d\""], ["proof (state)\nthis:\n  r = n div d\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "have 0: \"r \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<noteq> 0", "unfolding r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n div d \\<noteq> 0", "using \\<open>0 < n\\<close> \\<open>d dvd n\\<close> dvd_div_gt0"], ["proof (prove)\nusing this:\n  0 < n\n  d dvd n\n  \\<lbrakk>?d dvd ?n; 0 < ?n\\<rbrakk> \\<Longrightarrow> 0 < ?n div ?d\n\ngoal (1 subgoal):\n 1. n div d \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "have \"gcd r n > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < gcd r n", "unfolding r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < gcd (n div d) n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < gcd (n div d) n", "have \"n div d > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < n div d", "using \\<open>1 < n\\<close> \\<open>d < n\\<close> \\<open>d dvd n\\<close>"], ["proof (prove)\nusing this:\n  1 < n\n  d < n\n  d dvd n\n\ngoal (1 subgoal):\n 1. 1 < n div d", "by auto"], ["proof (state)\nthis:\n  1 < n div d\n\ngoal (1 subgoal):\n 1. 1 < gcd (n div d) n", "have \"n div d dvd n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n div d dvd n", "using \\<open>d dvd n\\<close>"], ["proof (prove)\nusing this:\n  d dvd n\n\ngoal (1 subgoal):\n 1. n div d dvd n", "by force"], ["proof (state)\nthis:\n  n div d dvd n\n\ngoal (1 subgoal):\n 1. 1 < gcd (n div d) n", "have \"gcd (n div d) n = n div d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (n div d) n = n div d", "using gcd_nat.absorb1[OF \\<open>n div d dvd n\\<close>]"], ["proof (prove)\nusing this:\n  gcd (n div d) n = n div d\n\ngoal (1 subgoal):\n 1. gcd (n div d) n = n div d", "by blast"], ["proof (state)\nthis:\n  gcd (n div d) n = n div d\n\ngoal (1 subgoal):\n 1. 1 < gcd (n div d) n", "then"], ["proof (chain)\npicking this:\n  gcd (n div d) n = n div d", "show \"1 < gcd (n div d) n\""], ["proof (prove)\nusing this:\n  gcd (n div d) n = n div d\n\ngoal (1 subgoal):\n 1. 1 < gcd (n div d) n", "using \\<open>n div d > 1\\<close>"], ["proof (prove)\nusing this:\n  gcd (n div d) n = n div d\n  1 < n div d\n\ngoal (1 subgoal):\n 1. 1 < gcd (n div d) n", "by argo"], ["proof (state)\nthis:\n  1 < gcd (n div d) n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 < gcd r n\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  1 < gcd r n", "have 1: \"\\<not> coprime r n\""], ["proof (prove)\nusing this:\n  1 < gcd r n\n\ngoal (1 subgoal):\n 1. \\<not> coprime r n", "by auto"], ["proof (state)\nthis:\n  \\<not> coprime r n\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "define \\<chi>\\<^sub>1 where \"\\<chi>\\<^sub>1 = principal_dchar n\""], ["proof (state)\nthis:\n  \\<chi>\\<^sub>1 = principal_dchar n\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "from primitive_principal_form[OF nonprincipal]"], ["proof (chain)\npicking this:\n  \\<exists>\\<Phi>.\n     primitive_dchar conductor \\<Phi> \\<and>\n     (\\<forall>n. \\<chi> n = \\<Phi> n * principal_dchar n n)", "obtain \\<Phi> where \n           prod: \"(\\<forall>k. \\<chi>(k) = \\<Phi>(k)*\\<chi>\\<^sub>1(k)) \\<and> primitive_dchar d \\<Phi>\""], ["proof (prove)\nusing this:\n  \\<exists>\\<Phi>.\n     primitive_dchar conductor \\<Phi> \\<and>\n     (\\<forall>n. \\<chi> n = \\<Phi> n * principal_dchar n n)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Phi>.\n        (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<and>\n        primitive_dchar d \\<Phi> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using d_def"], ["proof (prove)\nusing this:\n  \\<exists>\\<Phi>.\n     primitive_dchar conductor \\<Phi> \\<and>\n     (\\<forall>n. \\<chi> n = \\<Phi> n * principal_dchar n n)\n  d = conductor\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Phi>.\n        (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<and>\n        primitive_dchar d \\<Phi> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<chi>\\<^sub>1_def"], ["proof (prove)\nusing this:\n  \\<exists>\\<Phi>.\n     primitive_dchar conductor \\<Phi> \\<and>\n     (\\<forall>n. \\<chi> n = \\<Phi> n * principal_dchar n n)\n  d = conductor\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Phi>.\n        (\\<forall>k. \\<chi> k = \\<Phi> k * principal_dchar n k) \\<and>\n        primitive_dchar d \\<Phi> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<and>\n  primitive_dchar d \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<and>\n  primitive_dchar d \\<Phi>", "have prod1: \"(\\<forall>k. \\<chi>(k) = \\<Phi>(k)*\\<chi>\\<^sub>1(k))\" \"primitive_dchar d \\<Phi>\""], ["proof (prove)\nusing this:\n  (\\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k) \\<and>\n  primitive_dchar d \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k &&&\n    primitive_dchar d \\<Phi>", "by blast+"], ["proof (state)\nthis:\n  \\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k\n  primitive_dchar d \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  \\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k\n  primitive_dchar d \\<Phi>", "interpret \\<Phi>: primitive_dchar d \"residue_mult_group d\" \\<Phi>"], ["proof (prove)\nusing this:\n  \\<forall>k. \\<chi> k = \\<Phi> k * \\<chi>\\<^sub>1 k\n  primitive_dchar d \\<Phi>\n\ngoal (1 subgoal):\n 1. primitive_dchar d \\<Phi> &&&\n    residue_mult_group d \\<equiv> residue_mult_group d", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "have \"gauss_sum r  = (\\<Sum>m = 1..n . \\<chi>(m) * unity_root n (m*r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_sum r = (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * r)))", "unfolding gauss_sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * r))) =\n    (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * r)))", "by blast"], ["proof (state)\nthis:\n  gauss_sum r = (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * r)))\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "also"], ["proof (state)\nthis:\n  gauss_sum r = (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * r)))\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "have \"\\<dots> = (\\<Sum>m = 1..n . \\<Phi>(m)*\\<chi>\\<^sub>1(m) * unity_root n (m*r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * r))) =\n    (\\<Sum>m = 1..n.\n        \\<Phi> m * \\<chi>\\<^sub>1 m * unity_root n (int (m * r)))", "by (rule sum.cong,auto simp add: prod)"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * r))) =\n  (\\<Sum>m = 1..n. \\<Phi> m * \\<chi>\\<^sub>1 m * unity_root n (int (m * r)))\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * r))) =\n  (\\<Sum>m = 1..n. \\<Phi> m * \\<chi>\\<^sub>1 m * unity_root n (int (m * r)))\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "have \"\\<dots> = (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n. \\<Phi>(m)*\\<chi>\\<^sub>1(m) * unity_root n (m*r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m = 1..n.\n        \\<Phi> m * \\<chi>\\<^sub>1 m * unity_root n (int (m * r))) =\n    (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n       \\<Phi> m * \\<chi>\\<^sub>1 m * unity_root n (int (m * r)))", "by (intro sum.mono_neutral_right) (auto simp: \\<chi>\\<^sub>1_def principal_dchar_def)"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..n.\n      \\<Phi> m * \\<chi>\\<^sub>1 m * unity_root n (int (m * r))) =\n  (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n     \\<Phi> m * \\<chi>\\<^sub>1 m * unity_root n (int (m * r)))\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..n.\n      \\<Phi> m * \\<chi>\\<^sub>1 m * unity_root n (int (m * r))) =\n  (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n     \\<Phi> m * \\<chi>\\<^sub>1 m * unity_root n (int (m * r)))\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "have \"\\<dots> = (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n. \\<Phi>(m)*\\<chi>\\<^sub>1(m) * unity_root d m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n       \\<Phi> m * \\<chi>\\<^sub>1 m * unity_root n (int (m * r))) =\n    (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n       \\<Phi> m * \\<chi>\\<^sub>1 m * unity_root d (int m))", "proof (rule sum.cong,simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {m \\<in> {1..n}. coprime m n} \\<Longrightarrow>\n       \\<Phi> x * \\<chi>\\<^sub>1 x * unity_root n (int (x * r)) =\n       \\<Phi> x * \\<chi>\\<^sub>1 x * unity_root d (int x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {m \\<in> {1..n}. coprime m n} \\<Longrightarrow>\n       \\<Phi> x * \\<chi>\\<^sub>1 x * unity_root n (int (x * r)) =\n       \\<Phi> x * \\<chi>\\<^sub>1 x * unity_root d (int x)", "assume \"x \\<in> {m \\<in> {1..n}. coprime m n}\""], ["proof (state)\nthis:\n  x \\<in> {m \\<in> {1..n}. coprime m n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {m \\<in> {1..n}. coprime m n} \\<Longrightarrow>\n       \\<Phi> x * \\<chi>\\<^sub>1 x * unity_root n (int (x * r)) =\n       \\<Phi> x * \\<chi>\\<^sub>1 x * unity_root d (int x)", "have \"unity_root n (int (x * r)) = unity_root d (int x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root n (int (x * r)) = unity_root d (int x)", "using unity_div_num[OF \\<open>n > 0\\<close> \\<open>d > 0\\<close> \\<open>d dvd n\\<close>]"], ["proof (prove)\nusing this:\n  unity_root n (int (?x * (n div d))) = unity_root d (int ?x)\n\ngoal (1 subgoal):\n 1. unity_root n (int (x * r)) = unity_root d (int x)", "by (simp add: algebra_simps r_def)"], ["proof (state)\nthis:\n  unity_root n (int (x * r)) = unity_root d (int x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {m \\<in> {1..n}. coprime m n} \\<Longrightarrow>\n       \\<Phi> x * \\<chi>\\<^sub>1 x * unity_root n (int (x * r)) =\n       \\<Phi> x * \\<chi>\\<^sub>1 x * unity_root d (int x)", "then"], ["proof (chain)\npicking this:\n  unity_root n (int (x * r)) = unity_root d (int x)", "show \"\\<Phi> x * \\<chi>\\<^sub>1 x * unity_root n (int (x * r)) =\n                     \\<Phi> x * \\<chi>\\<^sub>1 x * unity_root d (int x)\""], ["proof (prove)\nusing this:\n  unity_root n (int (x * r)) = unity_root d (int x)\n\ngoal (1 subgoal):\n 1. \\<Phi> x * \\<chi>\\<^sub>1 x * unity_root n (int (x * r)) =\n    \\<Phi> x * \\<chi>\\<^sub>1 x * unity_root d (int x)", "by auto"], ["proof (state)\nthis:\n  \\<Phi> x * \\<chi>\\<^sub>1 x * unity_root n (int (x * r)) =\n  \\<Phi> x * \\<chi>\\<^sub>1 x * unity_root d (int x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n     \\<Phi> m * \\<chi>\\<^sub>1 m * unity_root n (int (m * r))) =\n  (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n     \\<Phi> m * \\<chi>\\<^sub>1 m * unity_root d (int m))\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n     \\<Phi> m * \\<chi>\\<^sub>1 m * unity_root n (int (m * r))) =\n  (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n     \\<Phi> m * \\<chi>\\<^sub>1 m * unity_root d (int m))\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "have \"\\<dots> = (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n. \\<Phi>(m) * unity_root d m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n       \\<Phi> m * \\<chi>\\<^sub>1 m * unity_root d (int m)) =\n    (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n       \\<Phi> m * unity_root d (int m))", "by (rule sum.cong,auto simp add: \\<chi>\\<^sub>1_def principal_dchar_def)"], ["proof (state)\nthis:\n  (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n     \\<Phi> m * \\<chi>\\<^sub>1 m * unity_root d (int m)) =\n  (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n     \\<Phi> m * unity_root d (int m))\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n     \\<Phi> m * \\<chi>\\<^sub>1 m * unity_root d (int m)) =\n  (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n     \\<Phi> m * unity_root d (int m))\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "have \"\\<dots> = (totient n div totient d) * (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d. \\<Phi>(m) * unity_root d m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient n div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "using primitive_iff_separable_lemma[OF prod \\<open>d > 1\\<close> \\<open>n > 0\\<close> \\<open>d dvd n\\<close> \\<open>n > 1\\<close>]"], ["proof (prove)\nusing this:\n  (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n     \\<Phi> m * unity_root d (int m)) =\n  of_nat (totient n div totient d) *\n  (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n     \\<Phi> m * unity_root d (int m))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient n div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n     \\<Phi> m * unity_root d (int m)) =\n  of_nat (totient n div totient d) *\n  (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n     \\<Phi> m * unity_root d (int m))\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>m | m \\<in> {1..n} \\<and> coprime m n.\n     \\<Phi> m * unity_root d (int m)) =\n  of_nat (totient n div totient d) *\n  (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n     \\<Phi> m * unity_root d (int m))\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "have \"\\<dots> = (totient n div totient d) * \\<Phi>.gauss_sum 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (totient n div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient n div totient d) * \\<Phi>.gauss_sum 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. of_nat (totient n div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient n div totient d) * \\<Phi>.gauss_sum 1", "have \"\\<Phi>.gauss_sum 1 = (\\<Sum>m = 1..d . \\<Phi> m * unity_root d (int (m )))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>.gauss_sum 1 = (\\<Sum>m = 1..d. \\<Phi> m * unity_root d (int m))", "by (simp add: \\<Phi>.gauss_sum_def)"], ["proof (state)\nthis:\n  \\<Phi>.gauss_sum 1 = (\\<Sum>m = 1..d. \\<Phi> m * unity_root d (int m))\n\ngoal (1 subgoal):\n 1. of_nat (totient n div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient n div totient d) * \\<Phi>.gauss_sum 1", "also"], ["proof (state)\nthis:\n  \\<Phi>.gauss_sum 1 = (\\<Sum>m = 1..d. \\<Phi> m * unity_root d (int m))\n\ngoal (1 subgoal):\n 1. of_nat (totient n div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient n div totient d) * \\<Phi>.gauss_sum 1", "have \"\\<dots> = (\\<Sum>m | m \\<in> {1..d} . \\<Phi> m * unity_root d (int m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m = 1..d. \\<Phi> m * unity_root d (int m)) =\n    (\\<Sum>m | m \\<in> {1..d}. \\<Phi> m * unity_root d (int m))", "by (rule sum.cong,auto)"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..d. \\<Phi> m * unity_root d (int m)) =\n  (\\<Sum>m | m \\<in> {1..d}. \\<Phi> m * unity_root d (int m))\n\ngoal (1 subgoal):\n 1. of_nat (totient n div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient n div totient d) * \\<Phi>.gauss_sum 1", "also"], ["proof (state)\nthis:\n  (\\<Sum>m = 1..d. \\<Phi> m * unity_root d (int m)) =\n  (\\<Sum>m | m \\<in> {1..d}. \\<Phi> m * unity_root d (int m))\n\ngoal (1 subgoal):\n 1. of_nat (totient n div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient n div totient d) * \\<Phi>.gauss_sum 1", "have \"\\<dots> = (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d. \\<Phi>(m) * unity_root d m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m | m \\<in> {1..d}. \\<Phi> m * unity_root d (int m)) =\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "by (rule sum.mono_neutral_right) (use \\<Phi>.eq_zero in auto)"], ["proof (state)\nthis:\n  (\\<Sum>m | m \\<in> {1..d}. \\<Phi> m * unity_root d (int m)) =\n  (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n     \\<Phi> m * unity_root d (int m))\n\ngoal (1 subgoal):\n 1. of_nat (totient n div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient n div totient d) * \\<Phi>.gauss_sum 1", "finally"], ["proof (chain)\npicking this:\n  \\<Phi>.gauss_sum 1 =\n  (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n     \\<Phi> m * unity_root d (int m))", "have \"\\<Phi>.gauss_sum 1 = (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d. \\<Phi>(m) * unity_root d m)\""], ["proof (prove)\nusing this:\n  \\<Phi>.gauss_sum 1 =\n  (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n     \\<Phi> m * unity_root d (int m))\n\ngoal (1 subgoal):\n 1. \\<Phi>.gauss_sum 1 =\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m))", "by blast"], ["proof (state)\nthis:\n  \\<Phi>.gauss_sum 1 =\n  (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n     \\<Phi> m * unity_root d (int m))\n\ngoal (1 subgoal):\n 1. of_nat (totient n div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient n div totient d) * \\<Phi>.gauss_sum 1", "then"], ["proof (chain)\npicking this:\n  \\<Phi>.gauss_sum 1 =\n  (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n     \\<Phi> m * unity_root d (int m))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Phi>.gauss_sum 1 =\n  (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n     \\<Phi> m * unity_root d (int m))\n\ngoal (1 subgoal):\n 1. of_nat (totient n div totient d) *\n    (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n       \\<Phi> m * unity_root d (int m)) =\n    of_nat (totient n div totient d) * \\<Phi>.gauss_sum 1", "by metis"], ["proof (state)\nthis:\n  of_nat (totient n div totient d) *\n  (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n     \\<Phi> m * unity_root d (int m)) =\n  of_nat (totient n div totient d) * \\<Phi>.gauss_sum 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  of_nat (totient n div totient d) *\n  (\\<Sum>m | m \\<in> {1..d} \\<and> coprime m d.\n     \\<Phi> m * unity_root d (int m)) =\n  of_nat (totient n div totient d) * \\<Phi>.gauss_sum 1\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "finally"], ["proof (chain)\npicking this:\n  gauss_sum r = of_nat (totient n div totient d) * \\<Phi>.gauss_sum 1", "have g_expr: \"gauss_sum r = (totient n div totient d) * \\<Phi>.gauss_sum 1\""], ["proof (prove)\nusing this:\n  gauss_sum r = of_nat (totient n div totient d) * \\<Phi>.gauss_sum 1\n\ngoal (1 subgoal):\n 1. gauss_sum r = of_nat (totient n div totient d) * \\<Phi>.gauss_sum 1", "by blast"], ["proof (state)\nthis:\n  gauss_sum r = of_nat (totient n div totient d) * \\<Phi>.gauss_sum 1\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "have t_non_0: \"totient n div totient d \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. totient n div totient d \\<noteq> 0", "by (simp add: \\<open>0 < n\\<close> \\<open>d dvd n\\<close> dvd_div_gt0 totient_dvd)"], ["proof (state)\nthis:\n  totient n div totient d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "have \"(norm (\\<Phi>.gauss_sum 1))\\<^sup>2 = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmod (\\<Phi>.gauss_sum 1))\\<^sup>2 = real d", "using \\<Phi>.primitive_encoding(3)"], ["proof (prove)\nusing this:\n  (cmod (\\<Phi>.gauss_sum 1))\\<^sup>2 = real d\n\ngoal (1 subgoal):\n 1. (cmod (\\<Phi>.gauss_sum 1))\\<^sup>2 = real d", "by simp"], ["proof (state)\nthis:\n  (cmod (\\<Phi>.gauss_sum 1))\\<^sup>2 = real d\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  (cmod (\\<Phi>.gauss_sum 1))\\<^sup>2 = real d", "have \"\\<Phi>.gauss_sum 1 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (cmod (\\<Phi>.gauss_sum 1))\\<^sup>2 = real d\n\ngoal (1 subgoal):\n 1. \\<Phi>.gauss_sum 1 \\<noteq> 0", "using \\<open>0 < d\\<close>"], ["proof (prove)\nusing this:\n  (cmod (\\<Phi>.gauss_sum 1))\\<^sup>2 = real d\n  0 < d\n\ngoal (1 subgoal):\n 1. \\<Phi>.gauss_sum 1 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<Phi>.gauss_sum 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  \\<Phi>.gauss_sum 1 \\<noteq> 0", "have 2: \"gauss_sum r \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<Phi>.gauss_sum 1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gauss_sum r \\<noteq> 0", "using g_expr t_non_0"], ["proof (prove)\nusing this:\n  \\<Phi>.gauss_sum 1 \\<noteq> 0\n  gauss_sum r = of_nat (totient n div totient d) * \\<Phi>.gauss_sum 1\n  totient n div totient d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gauss_sum r \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  gauss_sum r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "from 0 1 2"], ["proof (chain)\npicking this:\n  r \\<noteq> 0\n  \\<not> coprime r n\n  gauss_sum r \\<noteq> 0", "show \"\\<exists>r. r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0\""], ["proof (prove)\nusing this:\n  r \\<noteq> 0\n  \\<not> coprime r n\n  gauss_sum r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  \\<exists>r.\n     r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>r.\n     r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>k>0. separable k \\<Longrightarrow> primitive_dchar n \\<chi>", "}"], ["proof (state)\nthis:\n  \\<not> primitive_dchar n \\<chi> \\<Longrightarrow>\n  \\<exists>r.\n     r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>k>0. separable k \\<Longrightarrow> primitive_dchar n \\<chi>", "note contr = this"], ["proof (state)\nthis:\n  \\<not> primitive_dchar n \\<chi> \\<Longrightarrow>\n  \\<exists>r.\n     r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>k>0. separable k \\<Longrightarrow> primitive_dchar n \\<chi>", "show \"primitive_dchar n \\<chi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primitive_dchar n \\<chi>", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> primitive_dchar n \\<chi> \\<Longrightarrow> False", "assume \"\\<not> primitive_dchar n \\<chi>\""], ["proof (state)\nthis:\n  \\<not> primitive_dchar n \\<chi>\n\ngoal (1 subgoal):\n 1. \\<not> primitive_dchar n \\<chi> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> primitive_dchar n \\<chi>", "obtain r where 1: \"r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> primitive_dchar n \\<chi>\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        r \\<noteq> 0 \\<and>\n        \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using contr"], ["proof (prove)\nusing this:\n  \\<not> primitive_dchar n \\<chi>\n  \\<not> primitive_dchar n \\<chi> \\<Longrightarrow>\n  \\<exists>r.\n     r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        r \\<noteq> 0 \\<and>\n        \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> primitive_dchar n \\<chi> \\<Longrightarrow> False", "from global_separability_condition tot_separable"], ["proof (chain)\npicking this:\n  (\\<forall>n>0. separable n) =\n  (\\<forall>k>0. \\<not> coprime k n \\<longrightarrow> gauss_sum k = 0)\n  \\<forall>k>0. separable k", "have 2: \"(\\<forall>k>0. \\<not> coprime k n \\<longrightarrow> gauss_sum k = 0)\""], ["proof (prove)\nusing this:\n  (\\<forall>n>0. separable n) =\n  (\\<forall>k>0. \\<not> coprime k n \\<longrightarrow> gauss_sum k = 0)\n  \\<forall>k>0. separable k\n\ngoal (1 subgoal):\n 1. \\<forall>k>0. \\<not> coprime k n \\<longrightarrow> gauss_sum k = 0", "by blast"], ["proof (state)\nthis:\n  \\<forall>k>0. \\<not> coprime k n \\<longrightarrow> gauss_sum k = 0\n\ngoal (1 subgoal):\n 1. \\<not> primitive_dchar n \\<chi> \\<Longrightarrow> False", "from 1 2"], ["proof (chain)\npicking this:\n  r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0\n  \\<forall>k>0. \\<not> coprime k n \\<longrightarrow> gauss_sum k = 0", "show \"False\""], ["proof (prove)\nusing this:\n  r \\<noteq> 0 \\<and> \\<not> coprime r n \\<and> gauss_sum r \\<noteq> 0\n  \\<forall>k>0. \\<not> coprime k n \\<longrightarrow> gauss_sum k = 0\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  primitive_dchar n \\<chi>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  primitive_dchar n \\<chi> = (\\<forall>k>0. separable k)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Theorem 8.20\\<close>"], ["", "theorem (in primitive_dchar) fourier_primitive:\n  includes no_vec_lambda_notation\n  fixes \\<tau> :: complex\n  defines \"\\<tau> \\<equiv> gauss_sum 1 / sqrt n\"\n  shows   \"\\<chi> m = \\<tau> / sqrt n * (\\<Sum>k=1..n. cnj (\\<chi> k) * unity_root n (-m*k))\"\n  and     \"norm \\<tau> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<chi> m =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int m * int k)) &&&\n    cmod \\<tau> = 1", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<chi> m =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int m * int k))\n 2. cmod \\<tau> = 1", "have chi_not_principal: \"\\<chi> \\<noteq> principal_dchar n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<chi> \\<noteq> principal_dchar n", "using principal_not_totally_separable primitive_encoding(2)"], ["proof (prove)\nusing this:\n  \\<chi> = principal_dchar n \\<Longrightarrow>\n  \\<not> (\\<forall>k>0. separable k)\n  \\<forall>k>0. separable k\n\ngoal (1 subgoal):\n 1. \\<chi> \\<noteq> principal_dchar n", "by blast"], ["proof (state)\nthis:\n  \\<chi> \\<noteq> principal_dchar n\n\ngoal (2 subgoals):\n 1. \\<chi> m =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int m * int k))\n 2. cmod \\<tau> = 1", "then"], ["proof (chain)\npicking this:\n  \\<chi> \\<noteq> principal_dchar n", "have case_0: \"(\\<Sum>k=1..n. \\<chi> k) = 0\""], ["proof (prove)\nusing this:\n  \\<chi> \\<noteq> principal_dchar n\n\ngoal (1 subgoal):\n 1. sum \\<chi> {1..n} = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<chi> \\<noteq> principal_dchar n \\<Longrightarrow>\n    sum \\<chi> {1..n} = 0", "have \"sum \\<chi> {0..n-1} = sum \\<chi> {1..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum \\<chi> {0..n - 1} = sum \\<chi> {1..n}", "using periodic_arithmetic_sum_periodic_arithmetic_shift[OF dir_periodic_arithmetic, of 1] n"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < n; 0 < 1\\<rbrakk>\n  \\<Longrightarrow> sum \\<chi> {0..n - 1} = sum \\<chi> {1..1 + n - 1}\n  1 < n\n\ngoal (1 subgoal):\n 1. sum \\<chi> {0..n - 1} = sum \\<chi> {1..n}", "by auto"], ["proof (state)\nthis:\n  sum \\<chi> {0..n - 1} = sum \\<chi> {1..n}\n\ngoal (1 subgoal):\n 1. \\<chi> \\<noteq> principal_dchar n \\<Longrightarrow>\n    sum \\<chi> {1..n} = 0", "also"], ["proof (state)\nthis:\n  sum \\<chi> {0..n - 1} = sum \\<chi> {1..n}\n\ngoal (1 subgoal):\n 1. \\<chi> \\<noteq> principal_dchar n \\<Longrightarrow>\n    sum \\<chi> {1..n} = 0", "have \"{0..n-1} = {..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..n - 1} = {..<n}", "using n"], ["proof (prove)\nusing this:\n  1 < n\n\ngoal (1 subgoal):\n 1. {0..n - 1} = {..<n}", "by auto"], ["proof (state)\nthis:\n  {0..n - 1} = {..<n}\n\ngoal (1 subgoal):\n 1. \\<chi> \\<noteq> principal_dchar n \\<Longrightarrow>\n    sum \\<chi> {1..n} = 0", "finally"], ["proof (chain)\npicking this:\n  sum \\<chi> {..<n} = sum \\<chi> {1..n}", "show \"(\\<Sum>n = 1..n . \\<chi> n) = 0\""], ["proof (prove)\nusing this:\n  sum \\<chi> {..<n} = sum \\<chi> {1..n}\n\ngoal (1 subgoal):\n 1. sum \\<chi> {1..n} = 0", "using sum_dcharacter_block chi_not_principal"], ["proof (prove)\nusing this:\n  sum \\<chi> {..<n} = sum \\<chi> {1..n}\n  sum \\<chi> {..<n} =\n  (if \\<chi> = principal_dchar n then of_nat (totient n) else 0)\n  \\<chi> \\<noteq> principal_dchar n\n\ngoal (1 subgoal):\n 1. sum \\<chi> {1..n} = 0", "by simp"], ["proof (state)\nthis:\n  sum \\<chi> {1..n} = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum \\<chi> {1..n} = 0\n\ngoal (2 subgoals):\n 1. \\<chi> m =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int m * int k))\n 2. cmod \\<tau> = 1", "have \"\\<chi> m =\n    (\\<Sum>k = 1..n. 1 / of_nat n * gauss_sum_int (- int k) *\n      unity_root n (int (m * k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<chi> m =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * gauss_sum_int (- int k) * unity_root n (int (m * k)))", "using dcharacter_fourier_expansion[of m]"], ["proof (prove)\nusing this:\n  \\<chi> m =\n  (\\<Sum>k = 1..n.\n      complex_of_real (1 / real n) * gauss_sum_int (- int k) *\n      unity_root n (int (m * k)))\n\ngoal (1 subgoal):\n 1. \\<chi> m =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * gauss_sum_int (- int k) * unity_root n (int (m * k)))", "by auto"], ["proof (state)\nthis:\n  \\<chi> m =\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * gauss_sum_int (- int k) * unity_root n (int (m * k)))\n\ngoal (2 subgoals):\n 1. \\<chi> m =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int m * int k))\n 2. cmod \\<tau> = 1", "also"], ["proof (state)\nthis:\n  \\<chi> m =\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * gauss_sum_int (- int k) * unity_root n (int (m * k)))\n\ngoal (2 subgoals):\n 1. \\<chi> m =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int m * int k))\n 2. cmod \\<tau> = 1", "have \"\\<dots> = (\\<Sum>k = 1..n. 1 / of_nat n * gauss_sum (nat ((- k) mod n)) *\n      unity_root n (int (m * k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        1 / of_nat n * gauss_sum_int (- int k) *\n        unity_root n (int (m * k))) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * gauss_sum (nat (- int k mod int n)) *\n        unity_root n (int (m * k)))", "by (auto simp: gauss_sum_int_conv_gauss_sum)"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * gauss_sum_int (- int k) * unity_root n (int (m * k))) =\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * gauss_sum (nat (- int k mod int n)) *\n      unity_root n (int (m * k)))\n\ngoal (2 subgoals):\n 1. \\<chi> m =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int m * int k))\n 2. cmod \\<tau> = 1", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * gauss_sum_int (- int k) * unity_root n (int (m * k))) =\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * gauss_sum (nat (- int k mod int n)) *\n      unity_root n (int (m * k)))\n\ngoal (2 subgoals):\n 1. \\<chi> m =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int m * int k))\n 2. cmod \\<tau> = 1", "have \"\\<dots> = (\\<Sum>k = 1..n. 1 / of_nat n * cnj (\\<chi> (nat ((- k) mod n))) * gauss_sum 1 * unity_root n (int (m * k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        1 / of_nat n * gauss_sum (nat (- int k mod int n)) *\n        unity_root n (int (m * k))) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) *\n        gauss_sum 1 *\n        unity_root n (int (m * k)))", "proof (rule sum.cong,simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       1 / of_nat n * gauss_sum (nat (- int x mod int n)) *\n       unity_root n (int (m * x)) =\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (int (m * x))", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       1 / of_nat n * gauss_sum (nat (- int x mod int n)) *\n       unity_root n (int (m * x)) =\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (int (m * x))", "assume \"k \\<in> {1..n}\""], ["proof (state)\nthis:\n  k \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       1 / of_nat n * gauss_sum (nat (- int x mod int n)) *\n       unity_root n (int (m * x)) =\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (int (m * x))", "have \"gauss_sum (nat (- int k mod int n)) = \n          cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_sum (nat (- int k mod int n)) =\n    cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1", "proof (cases \"nat ((- k) mod n) > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < nat (- int k mod int n) \\<Longrightarrow>\n    gauss_sum (nat (- int k mod int n)) =\n    cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1\n 2. \\<not> 0 < nat (- int k mod int n) \\<Longrightarrow>\n    gauss_sum (nat (- int k mod int n)) =\n    cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1", "case True"], ["proof (state)\nthis:\n  0 < nat (- int k mod int n)\n\ngoal (2 subgoals):\n 1. 0 < nat (- int k mod int n) \\<Longrightarrow>\n    gauss_sum (nat (- int k mod int n)) =\n    cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1\n 2. \\<not> 0 < nat (- int k mod int n) \\<Longrightarrow>\n    gauss_sum (nat (- int k mod int n)) =\n    cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1", "then"], ["proof (chain)\npicking this:\n  0 < nat (- int k mod int n)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < nat (- int k mod int n)\n\ngoal (1 subgoal):\n 1. gauss_sum (nat (- int k mod int n)) =\n    cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1", "using mp[OF spec[OF primitive_encoding(2)] True]"], ["proof (prove)\nusing this:\n  0 < nat (- int k mod int n)\n  separable (nat (- int k mod int n))\n\ngoal (1 subgoal):\n 1. gauss_sum (nat (- int k mod int n)) =\n    cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1", "unfolding separable_def"], ["proof (prove)\nusing this:\n  0 < nat (- int k mod int n)\n  gauss_sum (nat (- int k mod int n)) =\n  cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1\n\ngoal (1 subgoal):\n 1. gauss_sum (nat (- int k mod int n)) =\n    cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1", "by auto"], ["proof (state)\nthis:\n  gauss_sum (nat (- int k mod int n)) =\n  cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1\n\ngoal (1 subgoal):\n 1. \\<not> 0 < nat (- int k mod int n) \\<Longrightarrow>\n    gauss_sum (nat (- int k mod int n)) =\n    cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < nat (- int k mod int n) \\<Longrightarrow>\n    gauss_sum (nat (- int k mod int n)) =\n    cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < nat (- int k mod int n)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < nat (- int k mod int n) \\<Longrightarrow>\n    gauss_sum (nat (- int k mod int n)) =\n    cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 < nat (- int k mod int n)", "have nat_0: \"nat ((- k) mod n) = 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 < nat (- int k mod int n)\n\ngoal (1 subgoal):\n 1. nat (- int k mod int n) = 0", "by blast"], ["proof (state)\nthis:\n  nat (- int k mod int n) = 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < nat (- int k mod int n) \\<Longrightarrow>\n    gauss_sum (nat (- int k mod int n)) =\n    cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_sum (nat (- int k mod int n)) =\n    cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gauss_sum (nat (- int k mod int n)) =\n    cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1", "have \"gauss_sum (nat (- int k mod int n)) = gauss_sum 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_sum (nat (- int k mod int n)) = gauss_sum 0", "using nat_0"], ["proof (prove)\nusing this:\n  nat (- int k mod int n) = 0\n\ngoal (1 subgoal):\n 1. gauss_sum (nat (- int k mod int n)) = gauss_sum 0", "by argo"], ["proof (state)\nthis:\n  gauss_sum (nat (- int k mod int n)) = gauss_sum 0\n\ngoal (1 subgoal):\n 1. gauss_sum (nat (- int k mod int n)) =\n    cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1", "also"], ["proof (state)\nthis:\n  gauss_sum (nat (- int k mod int n)) = gauss_sum 0\n\ngoal (1 subgoal):\n 1. gauss_sum (nat (- int k mod int n)) =\n    cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1", "have \"\\<dots> =  (\\<Sum>m = 1..n. \\<chi> m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_sum 0 = sum \\<chi> {1..n}", "unfolding gauss_sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m = 1..n. \\<chi> m * unity_root n (int (m * 0))) =\n    sum \\<chi> {1..n}", "by (rule sum.cong) auto"], ["proof (state)\nthis:\n  gauss_sum 0 = sum \\<chi> {1..n}\n\ngoal (1 subgoal):\n 1. gauss_sum (nat (- int k mod int n)) =\n    cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1", "also"], ["proof (state)\nthis:\n  gauss_sum 0 = sum \\<chi> {1..n}\n\ngoal (1 subgoal):\n 1. gauss_sum (nat (- int k mod int n)) =\n    cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum \\<chi> {1..n} = 0", "using case_0"], ["proof (prove)\nusing this:\n  sum \\<chi> {1..n} = 0\n\ngoal (1 subgoal):\n 1. sum \\<chi> {1..n} = 0", "by blast"], ["proof (state)\nthis:\n  sum \\<chi> {1..n} = 0\n\ngoal (1 subgoal):\n 1. gauss_sum (nat (- int k mod int n)) =\n    cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1", "finally"], ["proof (chain)\npicking this:\n  gauss_sum (nat (- int k mod int n)) = 0", "have 1: \"gauss_sum (nat (- int k mod int n)) = 0\""], ["proof (prove)\nusing this:\n  gauss_sum (nat (- int k mod int n)) = 0\n\ngoal (1 subgoal):\n 1. gauss_sum (nat (- int k mod int n)) = 0", "by blast"], ["proof (state)\nthis:\n  gauss_sum (nat (- int k mod int n)) = 0\n\ngoal (1 subgoal):\n 1. gauss_sum (nat (- int k mod int n)) =\n    cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1", "have 2: \"cnj (\\<chi> (nat (- int k mod int n))) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnj (\\<chi> (nat (- int k mod int n))) = 0", "using nat_0 zero_eq_0"], ["proof (prove)\nusing this:\n  nat (- int k mod int n) = 0\n  \\<chi> 0 = 0\n\ngoal (1 subgoal):\n 1. cnj (\\<chi> (nat (- int k mod int n))) = 0", "by simp"], ["proof (state)\nthis:\n  cnj (\\<chi> (nat (- int k mod int n))) = 0\n\ngoal (1 subgoal):\n 1. gauss_sum (nat (- int k mod int n)) =\n    cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_sum (nat (- int k mod int n)) =\n    cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1", "using 1 2"], ["proof (prove)\nusing this:\n  gauss_sum (nat (- int k mod int n)) = 0\n  cnj (\\<chi> (nat (- int k mod int n))) = 0\n\ngoal (1 subgoal):\n 1. gauss_sum (nat (- int k mod int n)) =\n    cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1", "by simp"], ["proof (state)\nthis:\n  gauss_sum (nat (- int k mod int n)) =\n  cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gauss_sum (nat (- int k mod int n)) =\n  cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gauss_sum (nat (- int k mod int n)) =\n  cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       1 / of_nat n * gauss_sum (nat (- int x mod int n)) *\n       unity_root n (int (m * x)) =\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (int (m * x))", "then"], ["proof (chain)\npicking this:\n  gauss_sum (nat (- int k mod int n)) =\n  cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1", "show \"1 / of_nat n * gauss_sum (nat (- int k mod int n)) * unity_root n (int (m * k)) =\n               1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1 * unity_root n (int (m * k))\""], ["proof (prove)\nusing this:\n  gauss_sum (nat (- int k mod int n)) =\n  cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1\n\ngoal (1 subgoal):\n 1. 1 / of_nat n * gauss_sum (nat (- int k mod int n)) *\n    unity_root n (int (m * k)) =\n    1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1 *\n    unity_root n (int (m * k))", "by auto"], ["proof (state)\nthis:\n  1 / of_nat n * gauss_sum (nat (- int k mod int n)) *\n  unity_root n (int (m * k)) =\n  1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1 *\n  unity_root n (int (m * k))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * gauss_sum (nat (- int k mod int n)) *\n      unity_root n (int (m * k))) =\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1 *\n      unity_root n (int (m * k)))\n\ngoal (2 subgoals):\n 1. \\<chi> m =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int m * int k))\n 2. cmod \\<tau> = 1", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * gauss_sum (nat (- int k mod int n)) *\n      unity_root n (int (m * k))) =\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1 *\n      unity_root n (int (m * k)))\n\ngoal (2 subgoals):\n 1. \\<chi> m =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int m * int k))\n 2. cmod \\<tau> = 1", "have \"\\<dots> = (\\<Sum>k = 1..n. 1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * \n                    gauss_sum 1 * unity_root n (int (m * (nat (int k mod int n)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) *\n        gauss_sum 1 *\n        unity_root n (int (m * k))) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) *\n        gauss_sum 1 *\n        unity_root n (int (m * nat (int k mod int n))))", "proof (rule sum.cong,simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (int (m * x)) =\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (int (m * nat (int x mod int n)))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (int (m * x)) =\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (int (m * nat (int x mod int n)))", "assume \"x \\<in> {1..n}\""], ["proof (state)\nthis:\n  x \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (int (m * x)) =\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (int (m * nat (int x mod int n)))", "have \"unity_root n (m * x) = unity_root n (m * x mod n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root n (int (m * x)) = unity_root n (int (m * x mod n))", "using unity_root_mod_nat[of n \"m*x\"]"], ["proof (prove)\nusing this:\n  unity_root n (int (nat (int (m * x) mod int n))) =\n  unity_root n (int (m * x))\n\ngoal (1 subgoal):\n 1. unity_root n (int (m * x)) = unity_root n (int (m * x mod n))", "by (simp add: nat_mod_as_int)"], ["proof (state)\nthis:\n  unity_root n (int (m * x)) = unity_root n (int (m * x mod n))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (int (m * x)) =\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (int (m * nat (int x mod int n)))", "also"], ["proof (state)\nthis:\n  unity_root n (int (m * x)) = unity_root n (int (m * x mod n))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (int (m * x)) =\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (int (m * nat (int x mod int n)))", "have \"\\<dots> = unity_root n (m * (x mod n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unity_root n (int (m * x mod n)) = unity_root n (int (m * (x mod n)))", "by (rule unity_root_cong)\n         (auto simp: cong_def mod_mult_right_eq simp flip: zmod_int of_nat_mult)"], ["proof (state)\nthis:\n  unity_root n (int (m * x mod n)) = unity_root n (int (m * (x mod n)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (int (m * x)) =\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (int (m * nat (int x mod int n)))", "finally"], ["proof (chain)\npicking this:\n  unity_root n (int (m * x)) = unity_root n (int (m * (x mod n)))", "have \"unity_root n (m * x) = unity_root n (m * (x mod n))\""], ["proof (prove)\nusing this:\n  unity_root n (int (m * x)) = unity_root n (int (m * (x mod n)))\n\ngoal (1 subgoal):\n 1. unity_root n (int (m * x)) = unity_root n (int (m * (x mod n)))", "by blast"], ["proof (state)\nthis:\n  unity_root n (int (m * x)) = unity_root n (int (m * (x mod n)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (int (m * x)) =\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (int (m * nat (int x mod int n)))", "then"], ["proof (chain)\npicking this:\n  unity_root n (int (m * x)) = unity_root n (int (m * (x mod n)))", "show \"1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) *\n                 gauss_sum 1 * unity_root n (int (m * x)) =\n               1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n                 unity_root n (int (m * nat (int x mod int n)))\""], ["proof (prove)\nusing this:\n  unity_root n (int (m * x)) = unity_root n (int (m * (x mod n)))\n\ngoal (1 subgoal):\n 1. 1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n    unity_root n (int (m * x)) =\n    1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n    unity_root n (int (m * nat (int x mod int n)))", "by (simp add: nat_mod_as_int)"], ["proof (state)\nthis:\n  1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n  unity_root n (int (m * x)) =\n  1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n  unity_root n (int (m * nat (int x mod int n)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1 *\n      unity_root n (int (m * k))) =\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1 *\n      unity_root n (int (m * nat (int k mod int n))))\n\ngoal (2 subgoals):\n 1. \\<chi> m =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int m * int k))\n 2. cmod \\<tau> = 1", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1 *\n      unity_root n (int (m * k))) =\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1 *\n      unity_root n (int (m * nat (int k mod int n))))\n\ngoal (2 subgoals):\n 1. \\<chi> m =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int m * int k))\n 2. cmod \\<tau> = 1", "have \"\\<dots> = (\\<Sum>k = 0..n-1. 1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 * unity_root n (- int (m * k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) *\n        gauss_sum 1 *\n        unity_root n (int (m * nat (int k mod int n)))) =\n    (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) *\n        gauss_sum 1 *\n        unity_root n (int (m * nat (int k mod int n)))) =\n    (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))", "have b: \"bij_betw (\\<lambda>k. nat((-k) mod n)) {1..n} {0..n-1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>k. nat (- int k mod int n)) {1..n} {0..n - 1}", "unfolding bij_betw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>k. nat (- int k mod int n)) {1..n} \\<and>\n    (\\<lambda>k. nat (- int k mod int n)) ` {1..n} = {0..n - 1}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>k. nat (- int k mod int n)) {1..n}\n 2. (\\<lambda>k. nat (- int k mod int n)) ` {1..n} = {0..n - 1}", "show \"inj_on (\\<lambda>k. nat (- int k mod int n)) {1..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>k. nat (- int k mod int n)) {1..n}", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{1..n}.\n       \\<forall>y\\<in>{1..n}.\n          nat (- int x mod int n) =\n          nat (- int y mod int n) \\<longrightarrow>\n          x = y", "proof (safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {1..n}; y \\<in> {1..n};\n        nat (- int x mod int n) = nat (- int y mod int n)\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {1..n}; y \\<in> {1..n};\n        nat (- int x mod int n) = nat (- int y mod int n)\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume a1: \"x \\<in> {1..n}\" \"y \\<in> {1..n}\""], ["proof (state)\nthis:\n  x \\<in> {1..n}\n  y \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {1..n}; y \\<in> {1..n};\n        nat (- int x mod int n) = nat (- int y mod int n)\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume a2: \"nat (- x mod n) = nat (- y mod n)\""], ["proof (state)\nthis:\n  nat (- int x mod int n) = nat (- int y mod int n)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {1..n}; y \\<in> {1..n};\n        nat (- int x mod int n) = nat (- int y mod int n)\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  nat (- int x mod int n) = nat (- int y mod int n)", "have \"(- x) mod n = - y mod n\""], ["proof (prove)\nusing this:\n  nat (- int x mod int n) = nat (- int y mod int n)\n\ngoal (1 subgoal):\n 1. - int x mod int n = - int y mod int n", "using n eq_nat_nat_iff"], ["proof (prove)\nusing this:\n  nat (- int x mod int n) = nat (- int y mod int n)\n  1 < n\n  \\<lbrakk>0 \\<le> ?z; 0 \\<le> ?z'\\<rbrakk>\n  \\<Longrightarrow> (nat ?z = nat ?z') = (?z = ?z')\n\ngoal (1 subgoal):\n 1. - int x mod int n = - int y mod int n", "by auto"], ["proof (state)\nthis:\n  - int x mod int n = - int y mod int n\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {1..n}; y \\<in> {1..n};\n        nat (- int x mod int n) = nat (- int y mod int n)\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  - int x mod int n = - int y mod int n", "have \"[-int x = - int y] (mod n)\""], ["proof (prove)\nusing this:\n  - int x mod int n = - int y mod int n\n\ngoal (1 subgoal):\n 1. [- int x = - int y] (mod int n)", "using cong_def"], ["proof (prove)\nusing this:\n  - int x mod int n = - int y mod int n\n  [?b = ?c] (mod ?a) = (?b mod ?a = ?c mod ?a)\n\ngoal (1 subgoal):\n 1. [- int x = - int y] (mod int n)", "by blast"], ["proof (state)\nthis:\n  [- int x = - int y] (mod int n)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {1..n}; y \\<in> {1..n};\n        nat (- int x mod int n) = nat (- int y mod int n)\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  [- int x = - int y] (mod int n)", "have \"[x = y] (mod n)\""], ["proof (prove)\nusing this:\n  [- int x = - int y] (mod int n)\n\ngoal (1 subgoal):\n 1. [x = y] (mod n)", "by (simp add: cong_int_iff cong_minus_minus_iff)"], ["proof (state)\nthis:\n  [x = y] (mod n)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {1..n}; y \\<in> {1..n};\n        nat (- int x mod int n) = nat (- int y mod int n)\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  [x = y] (mod n)", "have cong: \"x mod n = y mod n\""], ["proof (prove)\nusing this:\n  [x = y] (mod n)\n\ngoal (1 subgoal):\n 1. x mod n = y mod n", "using cong_def"], ["proof (prove)\nusing this:\n  [x = y] (mod n)\n  [?b = ?c] (mod ?a) = (?b mod ?a = ?c mod ?a)\n\ngoal (1 subgoal):\n 1. x mod n = y mod n", "by blast"], ["proof (state)\nthis:\n  x mod n = y mod n\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {1..n}; y \\<in> {1..n};\n        nat (- int x mod int n) = nat (- int y mod int n)\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  x mod n = y mod n", "show \"x = y\""], ["proof (prove)\nusing this:\n  x mod n = y mod n\n\ngoal (1 subgoal):\n 1. x = y", "proof (cases \"x = n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x mod n = y mod n; x = n\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<lbrakk>x mod n = y mod n; x \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> x = y", "case True"], ["proof (state)\nthis:\n  x = n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x mod n = y mod n; x = n\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<lbrakk>x mod n = y mod n; x \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  x = n", "show ?thesis"], ["proof (prove)\nusing this:\n  x = n\n\ngoal (1 subgoal):\n 1. x = y", "using cong a1(2)"], ["proof (prove)\nusing this:\n  x = n\n  x mod n = y mod n\n  y \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. x = y", "by auto"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x mod n = y mod n; x \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x mod n = y mod n; x \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> x = y", "case False"], ["proof (state)\nthis:\n  x \\<noteq> n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x mod n = y mod n; x \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> n", "have \"x mod n = x\""], ["proof (prove)\nusing this:\n  x \\<noteq> n\n\ngoal (1 subgoal):\n 1. x mod n = x", "using a1(1)"], ["proof (prove)\nusing this:\n  x \\<noteq> n\n  x \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. x mod n = x", "by auto"], ["proof (state)\nthis:\n  x mod n = x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x mod n = y mod n; x \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  x mod n = x", "have \"y \\<noteq> n\""], ["proof (prove)\nusing this:\n  x mod n = x\n\ngoal (1 subgoal):\n 1. y \\<noteq> n", "using a1(1) local.cong"], ["proof (prove)\nusing this:\n  x mod n = x\n  x \\<in> {1..n}\n  x mod n = y mod n\n\ngoal (1 subgoal):\n 1. y \\<noteq> n", "by fastforce"], ["proof (state)\nthis:\n  y \\<noteq> n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x mod n = y mod n; x \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  y \\<noteq> n", "have \"y mod n = y\""], ["proof (prove)\nusing this:\n  y \\<noteq> n\n\ngoal (1 subgoal):\n 1. y mod n = y", "using a1(2)"], ["proof (prove)\nusing this:\n  y \\<noteq> n\n  y \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. y mod n = y", "by auto"], ["proof (state)\nthis:\n  y mod n = y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x mod n = y mod n; x \\<noteq> n\\<rbrakk>\n    \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  y mod n = y", "show ?thesis"], ["proof (prove)\nusing this:\n  y mod n = y\n\ngoal (1 subgoal):\n 1. x = y", "using \\<open>x mod n = x\\<close> cong"], ["proof (prove)\nusing this:\n  y mod n = y\n  x mod n = x\n  x mod n = y mod n\n\ngoal (1 subgoal):\n 1. x = y", "by linarith"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (\\<lambda>k. nat (- int k mod int n)) {1..n}\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. nat (- int k mod int n)) ` {1..n} = {0..n - 1}", "show \"(\\<lambda>k. nat (- int k mod int n)) ` {1..n} = {0..n - 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. nat (- int k mod int n)) ` {1..n} = {0..n - 1}", "unfolding image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)} = {0..n - 1}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. {y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)}\n    \\<subseteq> {0..n - 1}\n 2. {0..n - 1}\n    \\<subseteq> {y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)}", "let ?A = \"{y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)}\""], ["proof (state)\ngoal (2 subgoals):\n 1. {y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)}\n    \\<subseteq> {0..n - 1}\n 2. {0..n - 1}\n    \\<subseteq> {y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)}", "let ?B = \"{0..n - 1}\""], ["proof (state)\ngoal (2 subgoals):\n 1. {y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)}\n    \\<subseteq> {0..n - 1}\n 2. {0..n - 1}\n    \\<subseteq> {y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)}", "show \"?A \\<subseteq> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)}\n    \\<subseteq> {0..n - 1}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {y. \\<exists>x\\<in>{1..n}.\n                      y = nat (- int x mod int n)} \\<Longrightarrow>\n       x \\<in> {0..n - 1}", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {y. \\<exists>x\\<in>{1..n}.\n                      y = nat (- int x mod int n)} \\<Longrightarrow>\n       x \\<in> {0..n - 1}", "assume \"y \\<in> {y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)}\""], ["proof (state)\nthis:\n  y \\<in> {y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {y. \\<exists>x\\<in>{1..n}.\n                      y = nat (- int x mod int n)} \\<Longrightarrow>\n       x \\<in> {0..n - 1}", "then"], ["proof (chain)\npicking this:\n  y \\<in> {y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)}", "obtain x where \"x\\<in>{1..n} \\<and> y = nat (- int x mod int n)\""], ["proof (prove)\nusing this:\n  y \\<in> {y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> {1..n} \\<and> y = nat (- int x mod int n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> {1..n} \\<and> y = nat (- int x mod int n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {y. \\<exists>x\\<in>{1..n}.\n                      y = nat (- int x mod int n)} \\<Longrightarrow>\n       x \\<in> {0..n - 1}", "then"], ["proof (chain)\npicking this:\n  x \\<in> {1..n} \\<and> y = nat (- int x mod int n)", "show \"y \\<in> {0..n - 1}\""], ["proof (prove)\nusing this:\n  x \\<in> {1..n} \\<and> y = nat (- int x mod int n)\n\ngoal (1 subgoal):\n 1. y \\<in> {0..n - 1}", "by (simp add: nat_le_iff of_nat_diff)"], ["proof (state)\nthis:\n  y \\<in> {0..n - 1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)}\n  \\<subseteq> {0..n - 1}\n\ngoal (1 subgoal):\n 1. {0..n - 1}\n    \\<subseteq> {y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)}", "show \"?A \\<supseteq> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..n - 1}\n    \\<subseteq> {y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..n - 1} \\<Longrightarrow>\n       x \\<in> {y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..n - 1} \\<Longrightarrow>\n       x \\<in> {y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)}", "assume 1: \"x \\<in> {0..n-1}\""], ["proof (state)\nthis:\n  x \\<in> {0..n - 1}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..n - 1} \\<Longrightarrow>\n       x \\<in> {y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)}", "then"], ["proof (chain)\npicking this:\n  x \\<in> {0..n - 1}", "have \"n - x \\<in> {1..n}\""], ["proof (prove)\nusing this:\n  x \\<in> {0..n - 1}\n\ngoal (1 subgoal):\n 1. n - x \\<in> {1..n}", "using n"], ["proof (prove)\nusing this:\n  x \\<in> {0..n - 1}\n  1 < n\n\ngoal (1 subgoal):\n 1. n - x \\<in> {1..n}", "by auto"], ["proof (state)\nthis:\n  n - x \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..n - 1} \\<Longrightarrow>\n       x \\<in> {y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)}", "have \"x = nat (- int (n-x) mod int n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = nat (- int (n - x) mod int n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = nat (- int (n - x) mod int n)", "have \"nat (- int (n-x) mod int n) = nat (int x) mod int n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (nat (- int (n - x) mod int n)) = int (nat (int x)) mod int n", "apply(simp add: int_ops(6),rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n < x \\<longrightarrow> int x mod int n = 0\n 2. \\<not> n < x \\<longrightarrow> 0 \\<le> int x mod int n", "using \\<open>n - x \\<in> {1..n}\\<close>"], ["proof (prove)\nusing this:\n  n - x \\<in> {1..n}\n\ngoal (2 subgoals):\n 1. n < x \\<longrightarrow> int x mod int n = 0\n 2. \\<not> n < x \\<longrightarrow> 0 \\<le> int x mod int n", "by force+"], ["proof (state)\nthis:\n  int (nat (- int (n - x) mod int n)) = int (nat (int x)) mod int n\n\ngoal (1 subgoal):\n 1. x = nat (- int (n - x) mod int n)", "also"], ["proof (state)\nthis:\n  int (nat (- int (n - x) mod int n)) = int (nat (int x)) mod int n\n\ngoal (1 subgoal):\n 1. x = nat (- int (n - x) mod int n)", "have \"\\<dots> = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (nat (int x)) mod int n = int x", "using 1 n"], ["proof (prove)\nusing this:\n  x \\<in> {0..n - 1}\n  1 < n\n\ngoal (1 subgoal):\n 1. int (nat (int x)) mod int n = int x", "by auto"], ["proof (state)\nthis:\n  int (nat (int x)) mod int n = int x\n\ngoal (1 subgoal):\n 1. x = nat (- int (n - x) mod int n)", "finally"], ["proof (chain)\npicking this:\n  int (nat (- int (n - x) mod int n)) = int x", "show ?thesis"], ["proof (prove)\nusing this:\n  int (nat (- int (n - x) mod int n)) = int x\n\ngoal (1 subgoal):\n 1. x = nat (- int (n - x) mod int n)", "by presburger"], ["proof (state)\nthis:\n  x = nat (- int (n - x) mod int n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = nat (- int (n - x) mod int n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {0..n - 1} \\<Longrightarrow>\n       x \\<in> {y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)}", "then"], ["proof (chain)\npicking this:\n  x = nat (- int (n - x) mod int n)", "show \"x \\<in> {y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)}\""], ["proof (prove)\nusing this:\n  x = nat (- int (n - x) mod int n)\n\ngoal (1 subgoal):\n 1. x \\<in> {y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)}", "using \\<open>n - x \\<in> {1..n}\\<close>"], ["proof (prove)\nusing this:\n  x = nat (- int (n - x) mod int n)\n  n - x \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. x \\<in> {y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)}", "by blast"], ["proof (state)\nthis:\n  x \\<in> {y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {0..n - 1}\n  \\<subseteq> {y. \\<exists>x\\<in>{1..n}. y = nat (- int x mod int n)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>k. nat (- int k mod int n)) ` {1..n} = {0..n - 1}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bij_betw (\\<lambda>k. nat (- int k mod int n)) {1..n} {0..n - 1}\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) *\n        gauss_sum 1 *\n        unity_root n (int (m * nat (int k mod int n)))) =\n    (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) *\n        gauss_sum 1 *\n        unity_root n (int (m * nat (int k mod int n)))) =\n    (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) *\n        gauss_sum 1 *\n        unity_root n (int (m * nat (int k mod int n)))) =\n    (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))", "have 1: \"(\\<Sum>k = 1..n. 1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) *\n        gauss_sum 1 * unity_root n (int (m * nat (int k mod int n)))) = \n            (\\<Sum>x = 1..n. 1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) *\n        gauss_sum 1 * unity_root n (- int (m * nat (- int x mod int n))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) *\n        gauss_sum 1 *\n        unity_root n (int (m * nat (int k mod int n)))) =\n    (\\<Sum>x = 1..n.\n        1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) *\n        gauss_sum 1 *\n        unity_root n (- int (m * nat (- int x mod int n))))", "proof (rule sum.cong,simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (int (m * nat (int x mod int n))) =\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (- int (m * nat (- int x mod int n)))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (int (m * nat (int x mod int n))) =\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (- int (m * nat (- int x mod int n)))", "have \"(int m * (int x mod int n)) mod n = (m*x) mod n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int m * (int x mod int n) mod int n = int (m * x mod n)", "by (simp add: mod_mult_right_eq zmod_int)"], ["proof (state)\nthis:\n  int m * (int x mod int n) mod int n = int (m * x mod n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (int (m * nat (int x mod int n))) =\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (- int (m * nat (- int x mod int n)))", "also"], ["proof (state)\nthis:\n  int m * (int x mod int n) mod int n = int (m * x mod n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (int (m * nat (int x mod int n))) =\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (- int (m * nat (- int x mod int n)))", "have \"\\<dots> = (- ((- int (m*x) mod n))) mod n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (m * x mod n) = - (- int (m * x) mod int n) mod int n", "by (simp add: mod_minus_eq of_nat_mod)"], ["proof (state)\nthis:\n  int (m * x mod n) = - (- int (m * x) mod int n) mod int n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (int (m * nat (int x mod int n))) =\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (- int (m * nat (- int x mod int n)))", "have \"(int m * (int x mod int n)) mod n = (- (int m * (- int x mod int n))) mod n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int m * (int x mod int n) mod int n =\n    - (int m * (- int x mod int n)) mod int n", "apply(subst mod_mult_right_eq,subst add.inverse_inverse[symmetric],subst (5) add.inverse_inverse[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (- int m) * - (- int x) mod int n =\n    - (int m * (- int x mod int n)) mod int n", "by (subst minus_mult_minus,subst mod_mult_right_eq[symmetric],auto)"], ["proof (state)\nthis:\n  int m * (int x mod int n) mod int n =\n  - (int m * (- int x mod int n)) mod int n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (int (m * nat (int x mod int n))) =\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (- int (m * nat (- int x mod int n)))", "then"], ["proof (chain)\npicking this:\n  int m * (int x mod int n) mod int n =\n  - (int m * (- int x mod int n)) mod int n", "have \"unity_root n (int m * (int x mod int n)) =\n                   unity_root n (- (int m * (- int x mod int n)))\""], ["proof (prove)\nusing this:\n  int m * (int x mod int n) mod int n =\n  - (int m * (- int x mod int n)) mod int n\n\ngoal (1 subgoal):\n 1. unity_root n (int m * (int x mod int n)) =\n    unity_root n (- (int m * (- int x mod int n)))", "using unity_root_mod[of n \"int m * (int x mod int n)\"] \n                 unity_root_mod[of n \" - (int m * (- int x mod int n))\"]"], ["proof (prove)\nusing this:\n  int m * (int x mod int n) mod int n =\n  - (int m * (- int x mod int n)) mod int n\n  unity_root n (int m * (int x mod int n) mod int n) =\n  unity_root n (int m * (int x mod int n))\n  unity_root n (- (int m * (- int x mod int n)) mod int n) =\n  unity_root n (- (int m * (- int x mod int n)))\n\ngoal (1 subgoal):\n 1. unity_root n (int m * (int x mod int n)) =\n    unity_root n (- (int m * (- int x mod int n)))", "by argo"], ["proof (state)\nthis:\n  unity_root n (int m * (int x mod int n)) =\n  unity_root n (- (int m * (- int x mod int n)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (int (m * nat (int x mod int n))) =\n       1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n       unity_root n (- int (m * nat (- int x mod int n)))", "then"], ["proof (chain)\npicking this:\n  unity_root n (int m * (int x mod int n)) =\n  unity_root n (- (int m * (- int x mod int n)))", "show \"1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) *\n         gauss_sum 1 *\n         unity_root n (int (m * nat (int x mod int n))) =\n         1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) *\n         gauss_sum 1 *\n         unity_root n (- int (m * nat (- int x mod int n)))\""], ["proof (prove)\nusing this:\n  unity_root n (int m * (int x mod int n)) =\n  unity_root n (- (int m * (- int x mod int n)))\n\ngoal (1 subgoal):\n 1. 1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n    unity_root n (int (m * nat (int x mod int n))) =\n    1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n    unity_root n (- int (m * nat (- int x mod int n)))", "by auto"], ["proof (state)\nthis:\n  1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n  unity_root n (int (m * nat (int x mod int n))) =\n  1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n  unity_root n (- int (m * nat (- int x mod int n)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1 *\n      unity_root n (int (m * nat (int k mod int n)))) =\n  (\\<Sum>x = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n      unity_root n (- int (m * nat (- int x mod int n))))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) *\n        gauss_sum 1 *\n        unity_root n (int (m * nat (int k mod int n)))) =\n    (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1 *\n      unity_root n (int (m * nat (int k mod int n)))) =\n  (\\<Sum>x = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n      unity_root n (- int (m * nat (- int x mod int n))))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) *\n        gauss_sum 1 *\n        unity_root n (int (m * nat (int k mod int n)))) =\n    (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))", "have 2: \"(\\<Sum>x = 1..n. 1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) *\n          gauss_sum 1 * unity_root n (- int (m * nat (- int x mod int n)))) =\n            (\\<Sum>md = 0..n - 1. 1 / of_nat n * cnj (\\<chi> md) * gauss_sum 1 *\n          unity_root n (- int (m * md)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x = 1..n.\n        1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) *\n        gauss_sum 1 *\n        unity_root n (- int (m * nat (- int x mod int n)))) =\n    (\\<Sum>md = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> md) * gauss_sum 1 *\n        unity_root n (- int (m * md)))", "using sum.reindex_bij_betw[OF b, of \"\\<lambda>md. 1 / of_nat n * cnj (\\<chi> md) * gauss_sum 1 * unity_root n (- int (m * md))\"]"], ["proof (prove)\nusing this:\n  (\\<Sum>x = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n      unity_root n (- int (m * nat (- int x mod int n)))) =\n  (\\<Sum>md = 0..n - 1.\n      1 / of_nat n * cnj (\\<chi> md) * gauss_sum 1 *\n      unity_root n (- int (m * md)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x = 1..n.\n        1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) *\n        gauss_sum 1 *\n        unity_root n (- int (m * nat (- int x mod int n)))) =\n    (\\<Sum>md = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> md) * gauss_sum 1 *\n        unity_root n (- int (m * md)))", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>x = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n      unity_root n (- int (m * nat (- int x mod int n)))) =\n  (\\<Sum>md = 0..n - 1.\n      1 / of_nat n * cnj (\\<chi> md) * gauss_sum 1 *\n      unity_root n (- int (m * md)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) *\n        gauss_sum 1 *\n        unity_root n (int (m * nat (int k mod int n)))) =\n    (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>x = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n      unity_root n (- int (m * nat (- int x mod int n)))) =\n  (\\<Sum>md = 0..n - 1.\n      1 / of_nat n * cnj (\\<chi> md) * gauss_sum 1 *\n      unity_root n (- int (m * md)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) *\n        gauss_sum 1 *\n        unity_root n (int (m * nat (int k mod int n)))) =\n    (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))", "have 3: \"\\<dots> = (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>md = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> md) * gauss_sum 1 *\n        unity_root n (- int (m * md))) =\n    (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>md = 0..n - 1.\n      1 / of_nat n * cnj (\\<chi> md) * gauss_sum 1 *\n      unity_root n (- int (m * md))) =\n  (\\<Sum>k = 0..n - 1.\n      1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n      unity_root n (- int (m * k)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) *\n        gauss_sum 1 *\n        unity_root n (int (m * nat (int k mod int n)))) =\n    (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1 *\n      unity_root n (int (m * nat (int k mod int n)))) =\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1 *\n      unity_root n (int (m * nat (int k mod int n))))", "have \"(\\<Sum>k = 1..n. 1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) *\n        gauss_sum 1 * unity_root n (int (m * nat (int k mod int n)))) = \n          (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))\""], ["proof (prove)\nusing this:\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1 *\n      unity_root n (int (m * nat (int k mod int n)))) =\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1 *\n      unity_root n (int (m * nat (int k mod int n))))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) *\n        gauss_sum 1 *\n        unity_root n (int (m * nat (int k mod int n)))) =\n    (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))", "using 1 2 3"], ["proof (prove)\nusing this:\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1 *\n      unity_root n (int (m * nat (int k mod int n)))) =\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1 *\n      unity_root n (int (m * nat (int k mod int n))))\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1 *\n      unity_root n (int (m * nat (int k mod int n)))) =\n  (\\<Sum>x = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n      unity_root n (- int (m * nat (- int x mod int n))))\n  (\\<Sum>x = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int x mod int n))) * gauss_sum 1 *\n      unity_root n (- int (m * nat (- int x mod int n)))) =\n  (\\<Sum>md = 0..n - 1.\n      1 / of_nat n * cnj (\\<chi> md) * gauss_sum 1 *\n      unity_root n (- int (m * md)))\n  (\\<Sum>md = 0..n - 1.\n      1 / of_nat n * cnj (\\<chi> md) * gauss_sum 1 *\n      unity_root n (- int (m * md))) =\n  (\\<Sum>k = 0..n - 1.\n      1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n      unity_root n (- int (m * k)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) *\n        gauss_sum 1 *\n        unity_root n (int (m * nat (int k mod int n)))) =\n    (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))", "by argo"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1 *\n      unity_root n (int (m * nat (int k mod int n)))) =\n  (\\<Sum>k = 0..n - 1.\n      1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n      unity_root n (- int (m * k)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) *\n        gauss_sum 1 *\n        unity_root n (int (m * nat (int k mod int n)))) =\n    (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1 *\n      unity_root n (int (m * nat (int k mod int n)))) =\n  (\\<Sum>k = 0..n - 1.\n      1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n      unity_root n (- int (m * k)))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1 *\n      unity_root n (int (m * nat (int k mod int n)))) =\n  (\\<Sum>k = 0..n - 1.\n      1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n      unity_root n (- int (m * k)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) *\n        gauss_sum 1 *\n        unity_root n (int (m * nat (int k mod int n)))) =\n    (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1 *\n      unity_root n (int (m * nat (int k mod int n)))) =\n  (\\<Sum>k = 0..n - 1.\n      1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n      unity_root n (- int (m * k)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1 *\n      unity_root n (int (m * nat (int k mod int n)))) =\n  (\\<Sum>k = 0..n - 1.\n      1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n      unity_root n (- int (m * k)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1 *\n      unity_root n (int (m * nat (int k mod int n)))) =\n  (\\<Sum>k = 0..n - 1.\n      1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n      unity_root n (- int (m * k)))\n\ngoal (2 subgoals):\n 1. \\<chi> m =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int m * int k))\n 2. cmod \\<tau> = 1", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> (nat (- int k mod int n))) * gauss_sum 1 *\n      unity_root n (int (m * nat (int k mod int n)))) =\n  (\\<Sum>k = 0..n - 1.\n      1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n      unity_root n (- int (m * k)))\n\ngoal (2 subgoals):\n 1. \\<chi> m =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int m * int k))\n 2. cmod \\<tau> = 1", "have \"\\<dots> = (\\<Sum>k = 1..n.\n         1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n         unity_root n (- int (m * k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k))) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k))) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))", "let ?f = \"(\\<lambda>k. 1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 * unity_root n (- int (m * k)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k))) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))", "have \"?f 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / of_nat n * cnj (\\<chi> 0) * gauss_sum 1 *\n    unity_root n (- int (m * 0)) =\n    0", "using zero_eq_0"], ["proof (prove)\nusing this:\n  \\<chi> 0 = 0\n\ngoal (1 subgoal):\n 1. 1 / of_nat n * cnj (\\<chi> 0) * gauss_sum 1 *\n    unity_root n (- int (m * 0)) =\n    0", "by auto"], ["proof (state)\nthis:\n  1 / of_nat n * cnj (\\<chi> 0) * gauss_sum 1 *\n  unity_root n (- int (m * 0)) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k))) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))", "have \"?f n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / of_nat n * cnj (\\<chi> n) * gauss_sum 1 *\n    unity_root n (- int (m * n)) =\n    0", "using zero_eq_0 mod_periodic_arithmetic[OF dir_periodic_arithmetic, of n 0]"], ["proof (prove)\nusing this:\n  \\<chi> 0 = 0\n  n mod n = 0 mod n \\<Longrightarrow> \\<chi> n = \\<chi> 0\n\ngoal (1 subgoal):\n 1. 1 / of_nat n * cnj (\\<chi> n) * gauss_sum 1 *\n    unity_root n (- int (m * n)) =\n    0", "by simp"], ["proof (state)\nthis:\n  1 / of_nat n * cnj (\\<chi> n) * gauss_sum 1 *\n  unity_root n (- int (m * n)) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k))) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))", "have \"(\\<Sum>n = 0..n - 1. ?f n) = (\\<Sum>n = 1..n - 1. ?f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> n) * gauss_sum 1 *\n        unity_root n (- int (m * n))) =\n    (\\<Sum>n = 1..n - 1.\n        1 / of_nat n * cnj (\\<chi> n) * gauss_sum 1 *\n        unity_root n (- int (m * n)))", "using sum_shift_lb_Suc0_0[of ?f, OF \\<open>?f 0 = 0\\<close>]"], ["proof (prove)\nusing this:\n  (\\<Sum>k = Suc 0..?k.\n      1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n      unity_root n (- int (m * k))) =\n  (\\<Sum>k = 0..?k.\n      1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n      unity_root n (- int (m * k)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>n = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> n) * gauss_sum 1 *\n        unity_root n (- int (m * n))) =\n    (\\<Sum>n = 1..n - 1.\n        1 / of_nat n * cnj (\\<chi> n) * gauss_sum 1 *\n        unity_root n (- int (m * n)))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>n = 0..n - 1.\n      1 / of_nat n * cnj (\\<chi> n) * gauss_sum 1 *\n      unity_root n (- int (m * n))) =\n  (\\<Sum>n = 1..n - 1.\n      1 / of_nat n * cnj (\\<chi> n) * gauss_sum 1 *\n      unity_root n (- int (m * n)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k))) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>n = 0..n - 1.\n      1 / of_nat n * cnj (\\<chi> n) * gauss_sum 1 *\n      unity_root n (- int (m * n))) =\n  (\\<Sum>n = 1..n - 1.\n      1 / of_nat n * cnj (\\<chi> n) * gauss_sum 1 *\n      unity_root n (- int (m * n)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k))) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))", "have \"\\<dots> = (\\<Sum>n = 1..n. ?f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n = 1..n - 1.\n        1 / of_nat n * cnj (\\<chi> n) * gauss_sum 1 *\n        unity_root n (- int (m * n))) =\n    (\\<Sum>n = 1..n.\n        1 / of_nat n * cnj (\\<chi> n) * gauss_sum 1 *\n        unity_root n (- int (m * n)))", "proof (rule sum.mono_neutral_left,simp,simp,safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> {1..n}; i \\<notin> {1..n - 1}\\<rbrakk>\n       \\<Longrightarrow> 1 / of_nat n * cnj (\\<chi> i) * gauss_sum 1 *\n                         unity_root n (- int (m * i)) =\n                         0", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> {1..n}; i \\<notin> {1..n - 1}\\<rbrakk>\n       \\<Longrightarrow> 1 / of_nat n * cnj (\\<chi> i) * gauss_sum 1 *\n                         unity_root n (- int (m * i)) =\n                         0", "assume \"i \\<in> {1..n}\" \"i \\<notin> {1..n - 1}\""], ["proof (state)\nthis:\n  i \\<in> {1..n}\n  i \\<notin> {1..n - 1}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> {1..n}; i \\<notin> {1..n - 1}\\<rbrakk>\n       \\<Longrightarrow> 1 / of_nat n * cnj (\\<chi> i) * gauss_sum 1 *\n                         unity_root n (- int (m * i)) =\n                         0", "then"], ["proof (chain)\npicking this:\n  i \\<in> {1..n}\n  i \\<notin> {1..n - 1}", "have \"i = n\""], ["proof (prove)\nusing this:\n  i \\<in> {1..n}\n  i \\<notin> {1..n - 1}\n\ngoal (1 subgoal):\n 1. i = n", "using n"], ["proof (prove)\nusing this:\n  i \\<in> {1..n}\n  i \\<notin> {1..n - 1}\n  1 < n\n\ngoal (1 subgoal):\n 1. i = n", "by auto"], ["proof (state)\nthis:\n  i = n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<in> {1..n}; i \\<notin> {1..n - 1}\\<rbrakk>\n       \\<Longrightarrow> 1 / of_nat n * cnj (\\<chi> i) * gauss_sum 1 *\n                         unity_root n (- int (m * i)) =\n                         0", "then"], ["proof (chain)\npicking this:\n  i = n", "show \"1 / of_nat n * cnj (\\<chi> i) * gauss_sum 1 * unity_root n (- int (m * i)) = 0\""], ["proof (prove)\nusing this:\n  i = n\n\ngoal (1 subgoal):\n 1. 1 / of_nat n * cnj (\\<chi> i) * gauss_sum 1 *\n    unity_root n (- int (m * i)) =\n    0", "using \\<open>?f n = 0\\<close>"], ["proof (prove)\nusing this:\n  i = n\n  1 / of_nat n * cnj (\\<chi> n) * gauss_sum 1 *\n  unity_root n (- int (m * n)) =\n  0\n\ngoal (1 subgoal):\n 1. 1 / of_nat n * cnj (\\<chi> i) * gauss_sum 1 *\n    unity_root n (- int (m * i)) =\n    0", "by blast"], ["proof (state)\nthis:\n  1 / of_nat n * cnj (\\<chi> i) * gauss_sum 1 *\n  unity_root n (- int (m * i)) =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>n = 1..n - 1.\n      1 / of_nat n * cnj (\\<chi> n) * gauss_sum 1 *\n      unity_root n (- int (m * n))) =\n  (\\<Sum>n = 1..n.\n      1 / of_nat n * cnj (\\<chi> n) * gauss_sum 1 *\n      unity_root n (- int (m * n)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k))) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>n = 0..n - 1.\n      1 / of_nat n * cnj (\\<chi> n) * gauss_sum 1 *\n      unity_root n (- int (m * n))) =\n  (\\<Sum>n = 1..n.\n      1 / of_nat n * cnj (\\<chi> n) * gauss_sum 1 *\n      unity_root n (- int (m * n)))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>n = 0..n - 1.\n      1 / of_nat n * cnj (\\<chi> n) * gauss_sum 1 *\n      unity_root n (- int (m * n))) =\n  (\\<Sum>n = 1..n.\n      1 / of_nat n * cnj (\\<chi> n) * gauss_sum 1 *\n      unity_root n (- int (m * n)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 0..n - 1.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k))) =\n    (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k)))", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..n - 1.\n      1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n      unity_root n (- int (m * k))) =\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n      unity_root n (- int (m * k)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..n - 1.\n      1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n      unity_root n (- int (m * k))) =\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n      unity_root n (- int (m * k)))\n\ngoal (2 subgoals):\n 1. \\<chi> m =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int m * int k))\n 2. cmod \\<tau> = 1", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 0..n - 1.\n      1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n      unity_root n (- int (m * k))) =\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n      unity_root n (- int (m * k)))\n\ngoal (2 subgoals):\n 1. \\<chi> m =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int m * int k))\n 2. cmod \\<tau> = 1", "have \"\\<dots> = (\\<Sum>k = 1..n. (\\<tau> / sqrt n) * cnj (\\<chi> k) * unity_root n (- int (m * k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n        unity_root n (- int (m * k))) =\n    (\\<Sum>k = 1..n.\n        \\<tau> / complex_of_real (sqrt (real n)) * cnj (\\<chi> k) *\n        unity_root n (- int (m * k)))", "proof (rule sum.cong,simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       1 / of_nat n * cnj (\\<chi> x) * gauss_sum 1 *\n       unity_root n (- int (m * x)) =\n       \\<tau> / complex_of_real (sqrt (real n)) * cnj (\\<chi> x) *\n       unity_root n (- int (m * x))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       1 / of_nat n * cnj (\\<chi> x) * gauss_sum 1 *\n       unity_root n (- int (m * x)) =\n       \\<tau> / complex_of_real (sqrt (real n)) * cnj (\\<chi> x) *\n       unity_root n (- int (m * x))", "assume \"x \\<in> {1..n}\""], ["proof (state)\nthis:\n  x \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       1 / of_nat n * cnj (\\<chi> x) * gauss_sum 1 *\n       unity_root n (- int (m * x)) =\n       \\<tau> / complex_of_real (sqrt (real n)) * cnj (\\<chi> x) *\n       unity_root n (- int (m * x))", "have \"\\<tau> / sqrt (real n) = 1 / of_nat n  * gauss_sum 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> / complex_of_real (sqrt (real n)) = 1 / of_nat n * gauss_sum 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau> / complex_of_real (sqrt (real n)) = 1 / of_nat n * gauss_sum 1", "have \"\\<tau> / sqrt (real n) = gauss_sum 1 / sqrt n / sqrt n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> / complex_of_real (sqrt (real n)) =\n    gauss_sum 1 / complex_of_real (sqrt (real n)) /\n    complex_of_real (sqrt (real n))", "using assms"], ["proof (prove)\nusing this:\n  \\<tau> \\<equiv> gauss_sum 1 / complex_of_real (sqrt (real n))\n\ngoal (1 subgoal):\n 1. \\<tau> / complex_of_real (sqrt (real n)) =\n    gauss_sum 1 / complex_of_real (sqrt (real n)) /\n    complex_of_real (sqrt (real n))", "by auto"], ["proof (state)\nthis:\n  \\<tau> / complex_of_real (sqrt (real n)) =\n  gauss_sum 1 / complex_of_real (sqrt (real n)) /\n  complex_of_real (sqrt (real n))\n\ngoal (1 subgoal):\n 1. \\<tau> / complex_of_real (sqrt (real n)) = 1 / of_nat n * gauss_sum 1", "also"], ["proof (state)\nthis:\n  \\<tau> / complex_of_real (sqrt (real n)) =\n  gauss_sum 1 / complex_of_real (sqrt (real n)) /\n  complex_of_real (sqrt (real n))\n\ngoal (1 subgoal):\n 1. \\<tau> / complex_of_real (sqrt (real n)) = 1 / of_nat n * gauss_sum 1", "have \"\\<dots> = gauss_sum 1 / (sqrt n * sqrt n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_sum 1 / complex_of_real (sqrt (real n)) /\n    complex_of_real (sqrt (real n)) =\n    gauss_sum 1 / complex_of_real (sqrt (real n) * sqrt (real n))", "by (subst divide_divide_eq_left,subst of_real_mult,blast)"], ["proof (state)\nthis:\n  gauss_sum 1 / complex_of_real (sqrt (real n)) /\n  complex_of_real (sqrt (real n)) =\n  gauss_sum 1 / complex_of_real (sqrt (real n) * sqrt (real n))\n\ngoal (1 subgoal):\n 1. \\<tau> / complex_of_real (sqrt (real n)) = 1 / of_nat n * gauss_sum 1", "also"], ["proof (state)\nthis:\n  gauss_sum 1 / complex_of_real (sqrt (real n)) /\n  complex_of_real (sqrt (real n)) =\n  gauss_sum 1 / complex_of_real (sqrt (real n) * sqrt (real n))\n\ngoal (1 subgoal):\n 1. \\<tau> / complex_of_real (sqrt (real n)) = 1 / of_nat n * gauss_sum 1", "have \"\\<dots> = gauss_sum 1 / n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gauss_sum 1 / complex_of_real (sqrt (real n) * sqrt (real n)) =\n    gauss_sum 1 / of_nat n", "using real_sqrt_mult_self"], ["proof (prove)\nusing this:\n  sqrt ?a * sqrt ?a = \\<bar>?a\\<bar>\n\ngoal (1 subgoal):\n 1. gauss_sum 1 / complex_of_real (sqrt (real n) * sqrt (real n)) =\n    gauss_sum 1 / of_nat n", "by simp"], ["proof (state)\nthis:\n  gauss_sum 1 / complex_of_real (sqrt (real n) * sqrt (real n)) =\n  gauss_sum 1 / of_nat n\n\ngoal (1 subgoal):\n 1. \\<tau> / complex_of_real (sqrt (real n)) = 1 / of_nat n * gauss_sum 1", "finally"], ["proof (chain)\npicking this:\n  \\<tau> / complex_of_real (sqrt (real n)) = gauss_sum 1 / of_nat n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<tau> / complex_of_real (sqrt (real n)) = gauss_sum 1 / of_nat n\n\ngoal (1 subgoal):\n 1. \\<tau> / complex_of_real (sqrt (real n)) = 1 / of_nat n * gauss_sum 1", "by simp"], ["proof (state)\nthis:\n  \\<tau> / complex_of_real (sqrt (real n)) = 1 / of_nat n * gauss_sum 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<tau> / complex_of_real (sqrt (real n)) = 1 / of_nat n * gauss_sum 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {1..n} \\<Longrightarrow>\n       1 / of_nat n * cnj (\\<chi> x) * gauss_sum 1 *\n       unity_root n (- int (m * x)) =\n       \\<tau> / complex_of_real (sqrt (real n)) * cnj (\\<chi> x) *\n       unity_root n (- int (m * x))", "then"], ["proof (chain)\npicking this:\n  \\<tau> / complex_of_real (sqrt (real n)) = 1 / of_nat n * gauss_sum 1", "show \n     \"1 / of_nat n * cnj (\\<chi> x) * gauss_sum 1 * unity_root n (- int (m * x)) =\n      (\\<tau> / sqrt n) * cnj (\\<chi> x) * unity_root n (- int (m * x))\""], ["proof (prove)\nusing this:\n  \\<tau> / complex_of_real (sqrt (real n)) = 1 / of_nat n * gauss_sum 1\n\ngoal (1 subgoal):\n 1. 1 / of_nat n * cnj (\\<chi> x) * gauss_sum 1 *\n    unity_root n (- int (m * x)) =\n    \\<tau> / complex_of_real (sqrt (real n)) * cnj (\\<chi> x) *\n    unity_root n (- int (m * x))", "by simp"], ["proof (state)\nthis:\n  1 / of_nat n * cnj (\\<chi> x) * gauss_sum 1 *\n  unity_root n (- int (m * x)) =\n  \\<tau> / complex_of_real (sqrt (real n)) * cnj (\\<chi> x) *\n  unity_root n (- int (m * x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n      unity_root n (- int (m * k))) =\n  (\\<Sum>k = 1..n.\n      \\<tau> / complex_of_real (sqrt (real n)) * cnj (\\<chi> k) *\n      unity_root n (- int (m * k)))\n\ngoal (2 subgoals):\n 1. \\<chi> m =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int m * int k))\n 2. cmod \\<tau> = 1", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n.\n      1 / of_nat n * cnj (\\<chi> k) * gauss_sum 1 *\n      unity_root n (- int (m * k))) =\n  (\\<Sum>k = 1..n.\n      \\<tau> / complex_of_real (sqrt (real n)) * cnj (\\<chi> k) *\n      unity_root n (- int (m * k)))\n\ngoal (2 subgoals):\n 1. \\<chi> m =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int m * int k))\n 2. cmod \\<tau> = 1", "have \"\\<dots> = \\<tau> / sqrt (real n) * \n         (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int (m * k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        \\<tau> / complex_of_real (sqrt (real n)) * cnj (\\<chi> k) *\n        unity_root n (- int (m * k))) =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int (m * k)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        \\<tau> / complex_of_real (sqrt (real n)) * cnj (\\<chi> k) *\n        unity_root n (- int (m * k))) =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int (m * k)))", "have \"(\\<Sum>k = 1..n. \\<tau> / sqrt (real n) * cnj (\\<chi> k) * unity_root n (- int (m * k))) = \n          (\\<Sum>k = 1..n. \\<tau> / sqrt (real n) * (cnj (\\<chi> k) *  unity_root n (- int (m * k))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        \\<tau> / complex_of_real (sqrt (real n)) * cnj (\\<chi> k) *\n        unity_root n (- int (m * k))) =\n    (\\<Sum>k = 1..n.\n        \\<tau> / complex_of_real (sqrt (real n)) *\n        (cnj (\\<chi> k) * unity_root n (- int (m * k))))", "by (rule sum.cong,simp, simp add: algebra_simps)"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n.\n      \\<tau> / complex_of_real (sqrt (real n)) * cnj (\\<chi> k) *\n      unity_root n (- int (m * k))) =\n  (\\<Sum>k = 1..n.\n      \\<tau> / complex_of_real (sqrt (real n)) *\n      (cnj (\\<chi> k) * unity_root n (- int (m * k))))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        \\<tau> / complex_of_real (sqrt (real n)) * cnj (\\<chi> k) *\n        unity_root n (- int (m * k))) =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int (m * k)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n.\n      \\<tau> / complex_of_real (sqrt (real n)) * cnj (\\<chi> k) *\n      unity_root n (- int (m * k))) =\n  (\\<Sum>k = 1..n.\n      \\<tau> / complex_of_real (sqrt (real n)) *\n      (cnj (\\<chi> k) * unity_root n (- int (m * k))))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        \\<tau> / complex_of_real (sqrt (real n)) * cnj (\\<chi> k) *\n        unity_root n (- int (m * k))) =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int (m * k)))", "have \"\\<dots> = \\<tau> / sqrt (real n) * (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int (m * k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        \\<tau> / complex_of_real (sqrt (real n)) *\n        (cnj (\\<chi> k) * unity_root n (- int (m * k)))) =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int (m * k)))", "by (rule sum_distrib_left[symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n.\n      \\<tau> / complex_of_real (sqrt (real n)) *\n      (cnj (\\<chi> k) * unity_root n (- int (m * k)))) =\n  \\<tau> / complex_of_real (sqrt (real n)) *\n  (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int (m * k)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        \\<tau> / complex_of_real (sqrt (real n)) * cnj (\\<chi> k) *\n        unity_root n (- int (m * k))) =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int (m * k)))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>k = 1..n.\n      \\<tau> / complex_of_real (sqrt (real n)) * cnj (\\<chi> k) *\n      unity_root n (- int (m * k))) =\n  \\<tau> / complex_of_real (sqrt (real n)) *\n  (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int (m * k)))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>k = 1..n.\n      \\<tau> / complex_of_real (sqrt (real n)) * cnj (\\<chi> k) *\n      unity_root n (- int (m * k))) =\n  \\<tau> / complex_of_real (sqrt (real n)) *\n  (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int (m * k)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>k = 1..n.\n        \\<tau> / complex_of_real (sqrt (real n)) * cnj (\\<chi> k) *\n        unity_root n (- int (m * k))) =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int (m * k)))", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n.\n      \\<tau> / complex_of_real (sqrt (real n)) * cnj (\\<chi> k) *\n      unity_root n (- int (m * k))) =\n  \\<tau> / complex_of_real (sqrt (real n)) *\n  (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int (m * k)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>k = 1..n.\n      \\<tau> / complex_of_real (sqrt (real n)) * cnj (\\<chi> k) *\n      unity_root n (- int (m * k))) =\n  \\<tau> / complex_of_real (sqrt (real n)) *\n  (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int (m * k)))\n\ngoal (2 subgoals):\n 1. \\<chi> m =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int m * int k))\n 2. cmod \\<tau> = 1", "finally"], ["proof (chain)\npicking this:\n  \\<chi> m =\n  \\<tau> / complex_of_real (sqrt (real n)) *\n  (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int (m * k)))", "show \"\\<chi> m = (\\<tau> / sqrt (real n)) *\n    (\\<Sum>k=1..n. cnj (\\<chi> k) * unity_root n (- int m * int k))\""], ["proof (prove)\nusing this:\n  \\<chi> m =\n  \\<tau> / complex_of_real (sqrt (real n)) *\n  (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int (m * k)))\n\ngoal (1 subgoal):\n 1. \\<chi> m =\n    \\<tau> / complex_of_real (sqrt (real n)) *\n    (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int m * int k))", "by simp"], ["proof (state)\nthis:\n  \\<chi> m =\n  \\<tau> / complex_of_real (sqrt (real n)) *\n  (\\<Sum>k = 1..n. cnj (\\<chi> k) * unity_root n (- int m * int k))\n\ngoal (1 subgoal):\n 1. cmod \\<tau> = 1", "have 1: \"norm (gauss_sum 1) = sqrt n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (gauss_sum 1) = sqrt (real n)", "using gauss_sum_1_mod_square_eq_k[OF primitive_encoding(2)]"], ["proof (prove)\nusing this:\n  (cmod (gauss_sum 1))\\<^sup>2 = real n\n\ngoal (1 subgoal):\n 1. cmod (gauss_sum 1) = sqrt (real n)", "by (simp add: cmod_def)"], ["proof (state)\nthis:\n  cmod (gauss_sum 1) = sqrt (real n)\n\ngoal (1 subgoal):\n 1. cmod \\<tau> = 1", "from assms"], ["proof (chain)\npicking this:\n  \\<tau> \\<equiv> gauss_sum 1 / complex_of_real (sqrt (real n))", "have 2: \"norm \\<tau> = norm (gauss_sum 1) / \\<bar>sqrt n\\<bar>\""], ["proof (prove)\nusing this:\n  \\<tau> \\<equiv> gauss_sum 1 / complex_of_real (sqrt (real n))\n\ngoal (1 subgoal):\n 1. cmod \\<tau> = cmod (gauss_sum 1) / \\<bar>sqrt (real n)\\<bar>", "by (simp add: norm_divide)"], ["proof (state)\nthis:\n  cmod \\<tau> = cmod (gauss_sum 1) / \\<bar>sqrt (real n)\\<bar>\n\ngoal (1 subgoal):\n 1. cmod \\<tau> = 1", "show \"norm \\<tau> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod \\<tau> = 1", "using 1 2 n"], ["proof (prove)\nusing this:\n  cmod (gauss_sum 1) = sqrt (real n)\n  cmod \\<tau> = cmod (gauss_sum 1) / \\<bar>sqrt (real n)\\<bar>\n  1 < n\n\ngoal (1 subgoal):\n 1. cmod \\<tau> = 1", "by simp"], ["proof (state)\nthis:\n  cmod \\<tau> = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "unbundle vec_lambda_notation"], ["", "end"]]}