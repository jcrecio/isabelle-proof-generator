{"file_name": "/home/qj213/afp-2021-10-22/thys/Deep_Learning/DL_Deep_Model_Poly.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Deep_Learning", "problem_names": ["lemma polyfun_det:\nassumes \"\\<And>x. (A x) \\<in> carrier_mat n n\"\nassumes \"\\<And>x i j. i<n \\<Longrightarrow> j<n \\<Longrightarrow> polyfun N (\\<lambda>x. (A x) $$ (i,j))\"\nshows \"polyfun N (\\<lambda>x. det (A x))\"", "lemma polyfun_extract_matrix:\nassumes \"i<m\" \"j<n\"\nshows \"polyfun {..<a + (m * n + c)} (\\<lambda>f. extract_matrix (\\<lambda>i. f (i + a)) m n $$ (i,j))\"", "lemma polyfun_mult_mat_vec:\nassumes \"\\<And>x. v x \\<in> carrier_vec n\"\nassumes \"\\<And>j. j<n \\<Longrightarrow> polyfun N (\\<lambda>x. v x $ j)\"\nassumes \"\\<And>x. A x \\<in> carrier_mat m n\"\nassumes \"\\<And>i j. i<m \\<Longrightarrow> j<n \\<Longrightarrow> polyfun N (\\<lambda>x. A x $$ (i,j))\"\nassumes \"j < m\"\nshows \"polyfun N (\\<lambda>x. ((A x) *\\<^sub>v (v x)) $ j)\"", "lemma polyfun_evaluate_net_plus_a:\nassumes \"map dim_vec inputs = input_sizes m\"\nassumes \"valid_net m\"\nassumes \"j < output_size m\"\nshows \"polyfun {..<a + count_weights s m} (\\<lambda>f. evaluate_net (insert_weights s m (\\<lambda>i. f (i + a))) inputs $ j)\"", "lemma polyfun_evaluate_net:\nassumes \"map dim_vec inputs = input_sizes m\"\nassumes \"valid_net m\"\nassumes \"j < output_size m\"\nshows \"polyfun {..<count_weights s m} (\\<lambda>f. evaluate_net (insert_weights s m f) inputs $ j)\"", "lemma polyfun_tensors_from_net:\nassumes \"valid_net m\"\nassumes \"is \\<lhd> input_sizes m\"\nassumes \"j < output_size m\"\nshows \"polyfun {..<count_weights s m} (\\<lambda>f. Tensor.lookup (tensors_from_net (insert_weights s m f) $ j) is)\"", "lemma polyfun_matricize:\nassumes \"\\<And>x. dims (T x) = ds\"\nassumes \"\\<And>is. is \\<lhd> ds \\<Longrightarrow> polyfun N (\\<lambda>x. Tensor.lookup (T x) is)\"\nassumes \"\\<And>x. dim_row (matricize I (T x)) = nr\"\nassumes \"\\<And>x. dim_col (matricize I (T x)) = nc\"\nassumes \"i < nr\"\nassumes \"j < nc\"\nshows \"polyfun N (\\<lambda>x. matricize I (T x) $$ (i,j))\"", "lemma \"(\\<not> (a::nat) < b) = (a \\<ge> b)\"", "lemma polyfun_submatrix:\nassumes \"\\<And>x. (A x) \\<in> carrier_mat m n\"\nassumes \"\\<And>x i j. i<m \\<Longrightarrow> j<n \\<Longrightarrow> polyfun N (\\<lambda>x. (A x) $$ (i,j))\"\nassumes \"i < card {i. i < m \\<and> i \\<in> I}\"\nassumes \"j < card {j. j < n \\<and> j \\<in> J}\"\nassumes \"infinite I\" \"infinite J\"\nshows \"polyfun N (\\<lambda>x. (submatrix (A x) I J) $$ (i,j))\"", "lemma polyfun_tensor_deep_model:\nassumes \"is \\<lhd> input_sizes (deep_model_l rs)\"\nshows \"polyfun {..<weight_space_dim}\n  (\\<lambda>f. Tensor.lookup (tensors_from_net (insert_weights shared_weights (deep_model_l rs) f) $ y) is)\"", "lemma input_sizes_deep_model: \"input_sizes (deep_model_l rs) = replicate (2 * N_half) (last rs)\"", "lemma polyfun_matrix_deep_model:\nassumes \"i<(last rs) ^ N_half\"\nassumes \"j<(last rs) ^ N_half\"\nshows \"polyfun {..<weight_space_dim} (\\<lambda>f. A' f $$ (i,j))\"", "lemma polyfun_submatrix_deep_model:\nassumes \"i < r ^ N_half\"\nassumes \"j < r ^ N_half\"\nshows \"polyfun {..<weight_space_dim} (\\<lambda>f. witness_submatrix f $$ (i,j))\"", "lemma polyfun_det_deep_model:\nshows \"polyfun {..<weight_space_dim} (\\<lambda>f. det (witness_submatrix f))\""], "translations": [["", "lemma polyfun_det:\nassumes \"\\<And>x. (A x) \\<in> carrier_mat n n\"\nassumes \"\\<And>x i j. i<n \\<Longrightarrow> j<n \\<Longrightarrow> polyfun N (\\<lambda>x. (A x) $$ (i,j))\"\nshows \"polyfun N (\\<lambda>x. det (A x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. det (A x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. det (A x))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. det (A x))", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. det (A x))", "assume \"p\\<in> {p. p permutes {0..<n}}\""], ["proof (state)\nthis:\n  p \\<in> {p. p permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. det (A x))", "then"], ["proof (chain)\npicking this:\n  p \\<in> {p. p permutes {0..<n}}", "have \"p permutes {0..<n}\""], ["proof (prove)\nusing this:\n  p \\<in> {p. p permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. p permutes {0..<n}", "by auto"], ["proof (state)\nthis:\n  p permutes {0..<n}\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. det (A x))", "then"], ["proof (chain)\npicking this:\n  p permutes {0..<n}", "have \"\\<And>x. x < n \\<Longrightarrow> p x < n\""], ["proof (prove)\nusing this:\n  p permutes {0..<n}\n\ngoal (1 subgoal):\n 1. \\<And>x. x < n \\<Longrightarrow> p x < n", "using permutes_in_image"], ["proof (prove)\nusing this:\n  p permutes {0..<n}\n  ?p permutes ?S \\<Longrightarrow> (?p ?x \\<in> ?S) = (?x \\<in> ?S)\n\ngoal (1 subgoal):\n 1. \\<And>x. x < n \\<Longrightarrow> p x < n", "by auto"], ["proof (state)\nthis:\n  ?x < n \\<Longrightarrow> p ?x < n\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. det (A x))", "then"], ["proof (chain)\npicking this:\n  ?x < n \\<Longrightarrow> p ?x < n", "have \"polyfun N (\\<lambda>x. \\<Prod>i = 0..<n. A x $$ (i, p i))\""], ["proof (prove)\nusing this:\n  ?x < n \\<Longrightarrow> p ?x < n\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. \\<Prod>i = 0..<n. A x $$ (i, p i))", "using polyfun_Prod[of \"{0..<n}\" N \"\\<lambda>i x. A x $$ (i, p i)\"] assms"], ["proof (prove)\nusing this:\n  ?x < n \\<Longrightarrow> p ?x < n\n  \\<lbrakk>finite {0..<n};\n   \\<And>i.\n      i \\<in> {0..<n} \\<Longrightarrow>\n      polyfun N (\\<lambda>x. A x $$ (i, p i))\\<rbrakk>\n  \\<Longrightarrow> polyfun N\n                     (\\<lambda>x. \\<Prod>i = 0..<n. A x $$ (i, p i))\n  A ?x \\<in> carrier_mat n n\n  \\<lbrakk>?i < n; ?j < n\\<rbrakk>\n  \\<Longrightarrow> polyfun N (\\<lambda>x. A x $$ (?i, ?j))\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. \\<Prod>i = 0..<n. A x $$ (i, p i))", "by simp"], ["proof (state)\nthis:\n  polyfun N (\\<lambda>x. \\<Prod>i = 0..<n. A x $$ (i, p i))\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. det (A x))", "then"], ["proof (chain)\npicking this:\n  polyfun N (\\<lambda>x. \\<Prod>i = 0..<n. A x $$ (i, p i))", "have \"polyfun N (\\<lambda>x. signof p * (\\<Prod>i = 0..<n. A x $$ (i, p i)))\""], ["proof (prove)\nusing this:\n  polyfun N (\\<lambda>x. \\<Prod>i = 0..<n. A x $$ (i, p i))\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. signof p * (\\<Prod>i = 0..<n. A x $$ (i, p i)))", "using polyfun_const polyfun_mult"], ["proof (prove)\nusing this:\n  polyfun N (\\<lambda>x. \\<Prod>i = 0..<n. A x $$ (i, p i))\n  polyfun ?N (\\<lambda>_. ?c)\n  \\<lbrakk>polyfun ?N ?f; polyfun ?N ?g\\<rbrakk>\n  \\<Longrightarrow> polyfun ?N (\\<lambda>x. ?f x * ?g x)\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. signof p * (\\<Prod>i = 0..<n. A x $$ (i, p i)))", "by blast"], ["proof (state)\nthis:\n  polyfun N (\\<lambda>x. signof p * (\\<Prod>i = 0..<n. A x $$ (i, p i)))\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. det (A x))", "}"], ["proof (state)\nthis:\n  ?p2 \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n  polyfun N (\\<lambda>x. signof ?p2 * (\\<Prod>i = 0..<n. A x $$ (i, ?p2 i)))\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. det (A x))", "moreover"], ["proof (state)\nthis:\n  ?p2 \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n  polyfun N (\\<lambda>x. signof ?p2 * (\\<Prod>i = 0..<n. A x $$ (i, ?p2 i)))\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. det (A x))", "have \"finite {i. i permutes {0..<n}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {i. i permutes {0..<n}}", "by (simp add: finite_permutations)"], ["proof (state)\nthis:\n  finite {i. i permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. det (A x))", "ultimately"], ["proof (chain)\npicking this:\n  ?p2 \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n  polyfun N (\\<lambda>x. signof ?p2 * (\\<Prod>i = 0..<n. A x $$ (i, ?p2 i)))\n  finite {i. i permutes {0..<n}}", "show ?thesis"], ["proof (prove)\nusing this:\n  ?p2 \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n  polyfun N (\\<lambda>x. signof ?p2 * (\\<Prod>i = 0..<n. A x $$ (i, ?p2 i)))\n  finite {i. i permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. det (A x))", "unfolding det_def'[OF assms(1)]"], ["proof (prove)\nusing this:\n  ?p2 \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n  polyfun N (\\<lambda>x. signof ?p2 * (\\<Prod>i = 0..<n. A x $$ (i, ?p2 i)))\n  finite {i. i permutes {0..<n}}\n\ngoal (1 subgoal):\n 1. polyfun N\n     (\\<lambda>x.\n         \\<Sum>p | p permutes {0..<n}.\n           signof p * (\\<Prod>i = 0..<n. A x $$ (i, p i)))", "using polyfun_Sum[OF \\<open>finite {i. i permutes {0..<n}}\\<close>, of N \"\\<lambda>p x. signof p * (\\<Prod>i = 0..<n. A x $$ (i, p i))\"]"], ["proof (prove)\nusing this:\n  ?p2 \\<in> {p. p permutes {0..<n}} \\<Longrightarrow>\n  polyfun N (\\<lambda>x. signof ?p2 * (\\<Prod>i = 0..<n. A x $$ (i, ?p2 i)))\n  finite {i. i permutes {0..<n}}\n  (\\<And>i.\n      i \\<in> {i. i permutes {0..<n}} \\<Longrightarrow>\n      polyfun N\n       (\\<lambda>x.\n           signof i *\n           (\\<Prod>ia = 0..<n. A x $$ (ia, i ia)))) \\<Longrightarrow>\n  polyfun N\n   (\\<lambda>x.\n       \\<Sum>i | i permutes {0..<n}.\n         signof i * (\\<Prod>ia = 0..<n. A x $$ (ia, i ia)))\n\ngoal (1 subgoal):\n 1. polyfun N\n     (\\<lambda>x.\n         \\<Sum>p | p permutes {0..<n}.\n           signof p * (\\<Prod>i = 0..<n. A x $$ (i, p i)))", "by blast"], ["proof (state)\nthis:\n  polyfun N (\\<lambda>x. det (A x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma polyfun_extract_matrix:\nassumes \"i<m\" \"j<n\"\nshows \"polyfun {..<a + (m * n + c)} (\\<lambda>f. extract_matrix (\\<lambda>i. f (i + a)) m n $$ (i,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun {..<a + (m * n + c)}\n     (\\<lambda>f. extract_matrix (\\<lambda>i. f (i + a)) m n $$ (i, j))", "unfolding index_extract_matrix[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun {..<a + (m * n + c)} (\\<lambda>f. f (i * n + j + a))", "apply (rule polyfun_single)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i * n + j + a \\<in> {..<a + (m * n + c)}", "using two_digit_le[OF assms]"], ["proof (prove)\nusing this:\n  i * n + j < m * n\n\ngoal (1 subgoal):\n 1. i * n + j + a \\<in> {..<a + (m * n + c)}", "by simp"], ["", "lemma polyfun_mult_mat_vec:\nassumes \"\\<And>x. v x \\<in> carrier_vec n\"\nassumes \"\\<And>j. j<n \\<Longrightarrow> polyfun N (\\<lambda>x. v x $ j)\"\nassumes \"\\<And>x. A x \\<in> carrier_mat m n\"\nassumes \"\\<And>i j. i<m \\<Longrightarrow> j<n \\<Longrightarrow> polyfun N (\\<lambda>x. A x $$ (i,j))\"\nassumes \"j < m\"\nshows \"polyfun N (\\<lambda>x. ((A x) *\\<^sub>v (v x)) $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. (A x *\\<^sub>v v x) $ j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. (A x *\\<^sub>v v x) $ j)", "have \"\\<And>x. j < dim_row (A x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. j < dim_row (A x)", "using \\<open>j < m\\<close> assms(3) carrier_matD(1)"], ["proof (prove)\nusing this:\n  j < m\n  A ?x \\<in> carrier_mat m n\n  ?A \\<in> carrier_mat ?nr ?nc \\<Longrightarrow> dim_row ?A = ?nr\n\ngoal (1 subgoal):\n 1. \\<And>x. j < dim_row (A x)", "by force"], ["proof (state)\nthis:\n  j < dim_row (A ?x)\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. (A x *\\<^sub>v v x) $ j)", "have \"\\<And>x. n = dim_vec (v x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. n = dim_vec (v x)", "using assms(1) carrier_vecD"], ["proof (prove)\nusing this:\n  v ?x \\<in> carrier_vec n\n  ?v \\<in> carrier_vec ?n \\<Longrightarrow> dim_vec ?v = ?n\n\ngoal (1 subgoal):\n 1. \\<And>x. n = dim_vec (v x)", "by fastforce"], ["proof (state)\nthis:\n  n = dim_vec (v ?x)\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. (A x *\\<^sub>v v x) $ j)", "{"], ["proof (state)\nthis:\n  n = dim_vec (v ?x)\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. (A x *\\<^sub>v v x) $ j)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. (A x *\\<^sub>v v x) $ j)", "assume \"i \\<in> {0..<n}\""], ["proof (state)\nthis:\n  i \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. (A x *\\<^sub>v v x) $ j)", "then"], ["proof (chain)\npicking this:\n  i \\<in> {0..<n}", "have \"i < n\""], ["proof (prove)\nusing this:\n  i \\<in> {0..<n}\n\ngoal (1 subgoal):\n 1. i < n", "by auto"], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. (A x *\\<^sub>v v x) $ j)", "{"], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. (A x *\\<^sub>v v x) $ j)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. (A x *\\<^sub>v v x) $ j)", "have \"i < dim_vec (v x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < dim_vec (v x)", "using assms(1) carrier_vecD \\<open>i<n\\<close>"], ["proof (prove)\nusing this:\n  v ?x \\<in> carrier_vec n\n  ?v \\<in> carrier_vec ?n \\<Longrightarrow> dim_vec ?v = ?n\n  i < n\n\ngoal (1 subgoal):\n 1. i < dim_vec (v x)", "by fastforce"], ["proof (state)\nthis:\n  i < dim_vec (v x)\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. (A x *\\<^sub>v v x) $ j)", "have \"j < dim_row (A x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < dim_row (A x)", "using \\<open>j < m\\<close> assms(3) carrier_matD(1)"], ["proof (prove)\nusing this:\n  j < m\n  A ?x \\<in> carrier_mat m n\n  ?A \\<in> carrier_mat ?nr ?nc \\<Longrightarrow> dim_row ?A = ?nr\n\ngoal (1 subgoal):\n 1. j < dim_row (A x)", "by force"], ["proof (state)\nthis:\n  j < dim_row (A x)\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. (A x *\\<^sub>v v x) $ j)", "have \"dim_col (A x) = dim_vec (v x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (A x) = dim_vec (v x)", "by (metis assms(1) assms(3) carrier_matD(2) carrier_vecD)"], ["proof (state)\nthis:\n  dim_col (A x) = dim_vec (v x)\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. (A x *\\<^sub>v v x) $ j)", "then"], ["proof (chain)\npicking this:\n  dim_col (A x) = dim_vec (v x)", "have \"row (A x) j $ i = A x $$ (j,i)\" \"i<n\""], ["proof (prove)\nusing this:\n  dim_col (A x) = dim_vec (v x)\n\ngoal (1 subgoal):\n 1. row (A x) j $ i = A x $$ (j, i) &&& i < n", "using \\<open>j < dim_row (A x)\\<close> \\<open>i<n\\<close>"], ["proof (prove)\nusing this:\n  dim_col (A x) = dim_vec (v x)\n  j < dim_row (A x)\n  i < n\n\ngoal (1 subgoal):\n 1. row (A x) j $ i = A x $$ (j, i) &&& i < n", "by (simp_all add: \\<open>i < dim_vec (v x)\\<close>)"], ["proof (state)\nthis:\n  row (A x) j $ i = A x $$ (j, i)\n  i < n\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. (A x *\\<^sub>v v x) $ j)", "}"], ["proof (state)\nthis:\n  row (A ?x2) j $ i = A ?x2 $$ (j, i)\n  i < n\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. (A x *\\<^sub>v v x) $ j)", "then"], ["proof (chain)\npicking this:\n  row (A ?x2) j $ i = A ?x2 $$ (j, i)\n  i < n", "have \"polyfun N (\\<lambda>x. row (A x) j $ i * v x $ i)\""], ["proof (prove)\nusing this:\n  row (A ?x2) j $ i = A ?x2 $$ (j, i)\n  i < n\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. row (A x) j $ i * v x $ i)", "using polyfun_mult assms(4)[OF \\<open>j < m\\<close>] assms(2)"], ["proof (prove)\nusing this:\n  row (A ?x2) j $ i = A ?x2 $$ (j, i)\n  i < n\n  \\<lbrakk>polyfun ?N ?f; polyfun ?N ?g\\<rbrakk>\n  \\<Longrightarrow> polyfun ?N (\\<lambda>x. ?f x * ?g x)\n  ?j < n \\<Longrightarrow> polyfun N (\\<lambda>x. A x $$ (j, ?j))\n  ?j < n \\<Longrightarrow> polyfun N (\\<lambda>x. v x $ ?j)\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. row (A x) j $ i * v x $ i)", "by fastforce"], ["proof (state)\nthis:\n  polyfun N (\\<lambda>x. row (A x) j $ i * v x $ i)\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. (A x *\\<^sub>v v x) $ j)", "}"], ["proof (state)\nthis:\n  ?i2 \\<in> {0..<n} \\<Longrightarrow>\n  polyfun N (\\<lambda>x. row (A x) j $ ?i2 * v x $ ?i2)\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. (A x *\\<^sub>v v x) $ j)", "then"], ["proof (chain)\npicking this:\n  ?i2 \\<in> {0..<n} \\<Longrightarrow>\n  polyfun N (\\<lambda>x. row (A x) j $ ?i2 * v x $ ?i2)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?i2 \\<in> {0..<n} \\<Longrightarrow>\n  polyfun N (\\<lambda>x. row (A x) j $ ?i2 * v x $ ?i2)\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. (A x *\\<^sub>v v x) $ j)", "unfolding index_mult_mat_vec[OF \\<open>\\<And>x. j < dim_row (A x)\\<close>] scalar_prod_def"], ["proof (prove)\nusing this:\n  ?i2 \\<in> {0..<n} \\<Longrightarrow>\n  polyfun N (\\<lambda>x. row (A x) j $ ?i2 * v x $ ?i2)\n\ngoal (1 subgoal):\n 1. polyfun N\n     (\\<lambda>x. \\<Sum>i = 0..<dim_vec (v x). row (A x) j $ i * v x $ i)", "using polyfun_Sum[of \"{0..<n}\" N \"\\<lambda>i x. row (A x) j $ i * v x $ i\"] finite_atLeastLessThan[of 0 n] \\<open>\\<And>x. n = dim_vec (v x)\\<close>"], ["proof (prove)\nusing this:\n  ?i2 \\<in> {0..<n} \\<Longrightarrow>\n  polyfun N (\\<lambda>x. row (A x) j $ ?i2 * v x $ ?i2)\n  \\<lbrakk>finite {0..<n};\n   \\<And>i.\n      i \\<in> {0..<n} \\<Longrightarrow>\n      polyfun N (\\<lambda>x. row (A x) j $ i * v x $ i)\\<rbrakk>\n  \\<Longrightarrow> polyfun N\n                     (\\<lambda>x.\n                         \\<Sum>i = 0..<n. row (A x) j $ i * v x $ i)\n  finite {0..<n}\n  n = dim_vec (v ?x)\n\ngoal (1 subgoal):\n 1. polyfun N\n     (\\<lambda>x. \\<Sum>i = 0..<dim_vec (v x). row (A x) j $ i * v x $ i)", "by simp"], ["proof (state)\nthis:\n  polyfun N (\\<lambda>x. (A x *\\<^sub>v v x) $ j)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* The variable a has been inserted here to make the induction work:*)"], ["", "lemma polyfun_evaluate_net_plus_a:\nassumes \"map dim_vec inputs = input_sizes m\"\nassumes \"valid_net m\"\nassumes \"j < output_size m\"\nshows \"polyfun {..<a + count_weights s m} (\\<lambda>f. evaluate_net (insert_weights s m (\\<lambda>i. f (i + a))) inputs $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun {..<a + count_weights s m}\n     (\\<lambda>f.\n         evaluate_net (insert_weights s m (\\<lambda>i. f (i + a))) inputs $\n         j)", "using assms"], ["proof (prove)\nusing this:\n  map dim_vec inputs = input_sizes m\n  valid_net m\n  j < output_size m\n\ngoal (1 subgoal):\n 1. polyfun {..<a + count_weights s m}\n     (\\<lambda>f.\n         evaluate_net (insert_weights s m (\\<lambda>i. f (i + a))) inputs $\n         j)", "proof (induction m arbitrary:inputs j a)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x inputs j a.\n       \\<lbrakk>map dim_vec inputs = input_sizes (Input x);\n        valid_net (Input x); j < output_size (Input x)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Input x)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Input x)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)\n 2. \\<And>x1a m inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m; valid_net m;\n                    j < output_size m\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m (\\<lambda>i. f (i + a))) inputs $ j);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        valid_net (Conv x1a m); j < output_size (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Conv x1a m)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Conv x1a m)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)\n 3. \\<And>m1 m2 inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m1;\n                    valid_net m1; j < output_size m1\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m1}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a))) inputs $ j);\n        \\<And>inputs j a.\n           \\<lbrakk>map dim_vec inputs = input_sizes m2; valid_net m2;\n            j < output_size m2\\<rbrakk>\n           \\<Longrightarrow> polyfun {..<a + count_weights s m2}\n                              (\\<lambda>f.\n                                  evaluate_net\n                                   (insert_weights s m2\n                                     (\\<lambda>i. f (i + a)))\n                                   inputs $\n                                  j);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        valid_net (Pool m1 m2); j < output_size (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Pool m1 m2)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Pool m1 m2)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)", "case (Input)"], ["proof (state)\nthis:\n  map dim_vec inputs = input_sizes (Input x_)\n  valid_net (Input x_)\n  j < output_size (Input x_)\n\ngoal (3 subgoals):\n 1. \\<And>x inputs j a.\n       \\<lbrakk>map dim_vec inputs = input_sizes (Input x);\n        valid_net (Input x); j < output_size (Input x)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Input x)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Input x)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)\n 2. \\<And>x1a m inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m; valid_net m;\n                    j < output_size m\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m (\\<lambda>i. f (i + a))) inputs $ j);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        valid_net (Conv x1a m); j < output_size (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Conv x1a m)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Conv x1a m)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)\n 3. \\<And>m1 m2 inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m1;\n                    valid_net m1; j < output_size m1\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m1}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a))) inputs $ j);\n        \\<And>inputs j a.\n           \\<lbrakk>map dim_vec inputs = input_sizes m2; valid_net m2;\n            j < output_size m2\\<rbrakk>\n           \\<Longrightarrow> polyfun {..<a + count_weights s m2}\n                              (\\<lambda>f.\n                                  evaluate_net\n                                   (insert_weights s m2\n                                     (\\<lambda>i. f (i + a)))\n                                   inputs $\n                                  j);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        valid_net (Pool m1 m2); j < output_size (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Pool m1 m2)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Pool m1 m2)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)", "then"], ["proof (chain)\npicking this:\n  map dim_vec inputs = input_sizes (Input x_)\n  valid_net (Input x_)\n  j < output_size (Input x_)", "show ?case"], ["proof (prove)\nusing this:\n  map dim_vec inputs = input_sizes (Input x_)\n  valid_net (Input x_)\n  j < output_size (Input x_)\n\ngoal (1 subgoal):\n 1. polyfun {..<a + count_weights s (Input x_)}\n     (\\<lambda>f.\n         evaluate_net (insert_weights s (Input x_) (\\<lambda>i. f (i + a)))\n          inputs $\n         j)", "unfolding insert_weights.simps evaluate_net.simps"], ["proof (prove)\nusing this:\n  map dim_vec inputs = input_sizes (Input x_)\n  valid_net (Input x_)\n  j < output_size (Input x_)\n\ngoal (1 subgoal):\n 1. polyfun {..<a + count_weights s (Input x_)} (\\<lambda>f. hd inputs $ j)", "using polyfun_const"], ["proof (prove)\nusing this:\n  map dim_vec inputs = input_sizes (Input x_)\n  valid_net (Input x_)\n  j < output_size (Input x_)\n  polyfun ?N (\\<lambda>_. ?c)\n\ngoal (1 subgoal):\n 1. polyfun {..<a + count_weights s (Input x_)} (\\<lambda>f. hd inputs $ j)", "by metis"], ["proof (state)\nthis:\n  polyfun {..<a + count_weights s (Input x_)}\n   (\\<lambda>f.\n       evaluate_net (insert_weights s (Input x_) (\\<lambda>i. f (i + a)))\n        inputs $\n       j)\n\ngoal (2 subgoals):\n 1. \\<And>x1a m inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m; valid_net m;\n                    j < output_size m\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m (\\<lambda>i. f (i + a))) inputs $ j);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        valid_net (Conv x1a m); j < output_size (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Conv x1a m)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Conv x1a m)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)\n 2. \\<And>m1 m2 inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m1;\n                    valid_net m1; j < output_size m1\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m1}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a))) inputs $ j);\n        \\<And>inputs j a.\n           \\<lbrakk>map dim_vec inputs = input_sizes m2; valid_net m2;\n            j < output_size m2\\<rbrakk>\n           \\<Longrightarrow> polyfun {..<a + count_weights s m2}\n                              (\\<lambda>f.\n                                  evaluate_net\n                                   (insert_weights s m2\n                                     (\\<lambda>i. f (i + a)))\n                                   inputs $\n                                  j);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        valid_net (Pool m1 m2); j < output_size (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Pool m1 m2)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Pool m1 m2)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1a m inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m; valid_net m;\n                    j < output_size m\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m (\\<lambda>i. f (i + a))) inputs $ j);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        valid_net (Conv x1a m); j < output_size (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Conv x1a m)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Conv x1a m)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)\n 2. \\<And>m1 m2 inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m1;\n                    valid_net m1; j < output_size m1\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m1}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a))) inputs $ j);\n        \\<And>inputs j a.\n           \\<lbrakk>map dim_vec inputs = input_sizes m2; valid_net m2;\n            j < output_size m2\\<rbrakk>\n           \\<Longrightarrow> polyfun {..<a + count_weights s m2}\n                              (\\<lambda>f.\n                                  evaluate_net\n                                   (insert_weights s m2\n                                     (\\<lambda>i. f (i + a)))\n                                   inputs $\n                                  j);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        valid_net (Pool m1 m2); j < output_size (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Pool m1 m2)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Pool m1 m2)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)", "case (Conv x m)"], ["proof (state)\nthis:\n  \\<lbrakk>map dim_vec ?inputs = input_sizes m; valid_net m;\n   ?j < output_size m\\<rbrakk>\n  \\<Longrightarrow> polyfun {..<?a + count_weights s m}\n                     (\\<lambda>f.\n                         evaluate_net\n                          (insert_weights s m (\\<lambda>i. f (i + ?a)))\n                          ?inputs $\n                         ?j)\n  map dim_vec inputs = input_sizes (Conv x m)\n  valid_net (Conv x m)\n  j < output_size (Conv x m)\n\ngoal (2 subgoals):\n 1. \\<And>x1a m inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m; valid_net m;\n                    j < output_size m\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m (\\<lambda>i. f (i + a))) inputs $ j);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        valid_net (Conv x1a m); j < output_size (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Conv x1a m)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Conv x1a m)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)\n 2. \\<And>m1 m2 inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m1;\n                    valid_net m1; j < output_size m1\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m1}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a))) inputs $ j);\n        \\<And>inputs j a.\n           \\<lbrakk>map dim_vec inputs = input_sizes m2; valid_net m2;\n            j < output_size m2\\<rbrakk>\n           \\<Longrightarrow> polyfun {..<a + count_weights s m2}\n                              (\\<lambda>f.\n                                  evaluate_net\n                                   (insert_weights s m2\n                                     (\\<lambda>i. f (i + a)))\n                                   inputs $\n                                  j);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        valid_net (Pool m1 m2); j < output_size (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Pool m1 m2)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Pool m1 m2)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>map dim_vec ?inputs = input_sizes m; valid_net m;\n   ?j < output_size m\\<rbrakk>\n  \\<Longrightarrow> polyfun {..<?a + count_weights s m}\n                     (\\<lambda>f.\n                         evaluate_net\n                          (insert_weights s m (\\<lambda>i. f (i + ?a)))\n                          ?inputs $\n                         ?j)\n  map dim_vec inputs = input_sizes (Conv x m)\n  valid_net (Conv x m)\n  j < output_size (Conv x m)", "obtain x1 x2 where \"x=(x1,x2)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>map dim_vec ?inputs = input_sizes m; valid_net m;\n   ?j < output_size m\\<rbrakk>\n  \\<Longrightarrow> polyfun {..<?a + count_weights s m}\n                     (\\<lambda>f.\n                         evaluate_net\n                          (insert_weights s m (\\<lambda>i. f (i + ?a)))\n                          ?inputs $\n                         ?j)\n  map dim_vec inputs = input_sizes (Conv x m)\n  valid_net (Conv x m)\n  j < output_size (Conv x m)\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2. x = (x1, x2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x = (x1, x2)\n\ngoal (2 subgoals):\n 1. \\<And>x1a m inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m; valid_net m;\n                    j < output_size m\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m (\\<lambda>i. f (i + a))) inputs $ j);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        valid_net (Conv x1a m); j < output_size (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Conv x1a m)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Conv x1a m)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)\n 2. \\<And>m1 m2 inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m1;\n                    valid_net m1; j < output_size m1\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m1}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a))) inputs $ j);\n        \\<And>inputs j a.\n           \\<lbrakk>map dim_vec inputs = input_sizes m2; valid_net m2;\n            j < output_size m2\\<rbrakk>\n           \\<Longrightarrow> polyfun {..<a + count_weights s m2}\n                              (\\<lambda>f.\n                                  evaluate_net\n                                   (insert_weights s m2\n                                     (\\<lambda>i. f (i + a)))\n                                   inputs $\n                                  j);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        valid_net (Pool m1 m2); j < output_size (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Pool m1 m2)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Pool m1 m2)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun {..<a + count_weights s (Conv x m)}\n     (\\<lambda>f.\n         evaluate_net (insert_weights s (Conv x m) (\\<lambda>i. f (i + a)))\n          inputs $\n         j)", "unfolding \\<open>x=(x1,x2)\\<close> insert_weights.simps evaluate_net.simps drop_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n     (\\<lambda>f.\n         (extract_matrix (\\<lambda>i. f (i + a)) x1 x2 *\\<^sub>v\n          evaluate_net\n           (insert_weights s m (\\<lambda>i. f (i + x1 * x2 + a))) inputs) $\n         j)", "unfolding list_of_vec_index"], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n     (\\<lambda>f.\n         (extract_matrix (\\<lambda>i. f (i + a)) x1 x2 *\\<^sub>v\n          evaluate_net\n           (insert_weights s m (\\<lambda>i. f (i + x1 * x2 + a))) inputs) $\n         j)", "proof (rule polyfun_mult_mat_vec)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>f.\n       evaluate_net (insert_weights s m (\\<lambda>i. f (i + x1 * x2 + a)))\n        inputs\n       \\<in> carrier_vec ?n\n 2. \\<And>j.\n       j < ?n \\<Longrightarrow>\n       polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n        (\\<lambda>f.\n            evaluate_net\n             (insert_weights s m (\\<lambda>i. f (i + x1 * x2 + a))) inputs $\n            j)\n 3. \\<And>f.\n       extract_matrix (\\<lambda>i. f (i + a)) x1 x2 \\<in> carrier_mat ?m ?n\n 4. \\<And>i j.\n       \\<lbrakk>i < ?m; j < ?n\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n                          (\\<lambda>f.\n                              extract_matrix (\\<lambda>i. f (i + a)) x1\n                               x2 $$\n                              (i, j))\n 5. j < ?m", "{"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>f.\n       evaluate_net (insert_weights s m (\\<lambda>i. f (i + x1 * x2 + a)))\n        inputs\n       \\<in> carrier_vec ?n\n 2. \\<And>j.\n       j < ?n \\<Longrightarrow>\n       polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n        (\\<lambda>f.\n            evaluate_net\n             (insert_weights s m (\\<lambda>i. f (i + x1 * x2 + a))) inputs $\n            j)\n 3. \\<And>f.\n       extract_matrix (\\<lambda>i. f (i + a)) x1 x2 \\<in> carrier_mat ?m ?n\n 4. \\<And>i j.\n       \\<lbrakk>i < ?m; j < ?n\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n                          (\\<lambda>f.\n                              extract_matrix (\\<lambda>i. f (i + a)) x1\n                               x2 $$\n                              (i, j))\n 5. j < ?m", "fix f"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>f.\n       evaluate_net (insert_weights s m (\\<lambda>i. f (i + x1 * x2 + a)))\n        inputs\n       \\<in> carrier_vec ?n\n 2. \\<And>j.\n       j < ?n \\<Longrightarrow>\n       polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n        (\\<lambda>f.\n            evaluate_net\n             (insert_weights s m (\\<lambda>i. f (i + x1 * x2 + a))) inputs $\n            j)\n 3. \\<And>f.\n       extract_matrix (\\<lambda>i. f (i + a)) x1 x2 \\<in> carrier_mat ?m ?n\n 4. \\<And>i j.\n       \\<lbrakk>i < ?m; j < ?n\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n                          (\\<lambda>f.\n                              extract_matrix (\\<lambda>i. f (i + a)) x1\n                               x2 $$\n                              (i, j))\n 5. j < ?m", "have 1:\"valid_net' (insert_weights s m (\\<lambda>i. f (i + x1 * x2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_net' (insert_weights s m (\\<lambda>i. f (i + x1 * x2)))", "using \\<open>valid_net (Conv x m)\\<close> valid_net.simps"], ["proof (prove)\nusing this:\n  valid_net (Conv x m)\n  valid_net ?a =\n  ((\\<exists>M. ?a = Input M) \\<or>\n   (\\<exists>m r1 r0.\n       ?a = Conv (r0, r1) m \\<and>\n       output_size m = r1 \\<and> valid_net m) \\<or>\n   (\\<exists>m1 m2.\n       ?a = Pool m1 m2 \\<and>\n       output_size m1 = output_size m2 \\<and>\n       valid_net m1 \\<and> valid_net m2))\n\ngoal (1 subgoal):\n 1. valid_net' (insert_weights s m (\\<lambda>i. f (i + x1 * x2)))", "by (metis\n        convnet.distinct(1) convnet.distinct(5) convnet.inject(2) remove_insert_weights)"], ["proof (state)\nthis:\n  valid_net' (insert_weights s m (\\<lambda>i. f (i + x1 * x2)))\n\ngoal (5 subgoals):\n 1. \\<And>f.\n       evaluate_net (insert_weights s m (\\<lambda>i. f (i + x1 * x2 + a)))\n        inputs\n       \\<in> carrier_vec ?n\n 2. \\<And>j.\n       j < ?n \\<Longrightarrow>\n       polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n        (\\<lambda>f.\n            evaluate_net\n             (insert_weights s m (\\<lambda>i. f (i + x1 * x2 + a))) inputs $\n            j)\n 3. \\<And>f.\n       extract_matrix (\\<lambda>i. f (i + a)) x1 x2 \\<in> carrier_mat ?m ?n\n 4. \\<And>i j.\n       \\<lbrakk>i < ?m; j < ?n\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n                          (\\<lambda>f.\n                              extract_matrix (\\<lambda>i. f (i + a)) x1\n                               x2 $$\n                              (i, j))\n 5. j < ?m", "have 2:\"map dim_vec inputs = input_sizes (insert_weights s m (\\<lambda>i. f (i + x1 * x2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map dim_vec inputs =\n    input_sizes (insert_weights s m (\\<lambda>i. f (i + x1 * x2)))", "using input_sizes_remove_weights remove_insert_weights"], ["proof (prove)\nusing this:\n  input_sizes ?m = input_sizes (remove_weights ?m)\n  remove_weights (insert_weights ?s ?m ?w) = ?m\n\ngoal (1 subgoal):\n 1. map dim_vec inputs =\n    input_sizes (insert_weights s m (\\<lambda>i. f (i + x1 * x2)))", "by (simp add: Conv.prems(1))"], ["proof (state)\nthis:\n  map dim_vec inputs =\n  input_sizes (insert_weights s m (\\<lambda>i. f (i + x1 * x2)))\n\ngoal (5 subgoals):\n 1. \\<And>f.\n       evaluate_net (insert_weights s m (\\<lambda>i. f (i + x1 * x2 + a)))\n        inputs\n       \\<in> carrier_vec ?n\n 2. \\<And>j.\n       j < ?n \\<Longrightarrow>\n       polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n        (\\<lambda>f.\n            evaluate_net\n             (insert_weights s m (\\<lambda>i. f (i + x1 * x2 + a))) inputs $\n            j)\n 3. \\<And>f.\n       extract_matrix (\\<lambda>i. f (i + a)) x1 x2 \\<in> carrier_mat ?m ?n\n 4. \\<And>i j.\n       \\<lbrakk>i < ?m; j < ?n\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n                          (\\<lambda>f.\n                              extract_matrix (\\<lambda>i. f (i + a)) x1\n                               x2 $$\n                              (i, j))\n 5. j < ?m", "have \"dim_vec (evaluate_net (insert_weights s m (\\<lambda>i. f (i + x1 * x2))) inputs) = output_size m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec\n     (evaluate_net (insert_weights s m (\\<lambda>i. f (i + x1 * x2)))\n       inputs) =\n    output_size m", "using output_size_correct[OF 1 2]"], ["proof (prove)\nusing this:\n  output_size' (insert_weights s m (\\<lambda>i. f (i + x1 * x2))) =\n  dim_vec\n   (evaluate_net (insert_weights s m (\\<lambda>i. f (i + x1 * x2))) inputs)\n\ngoal (1 subgoal):\n 1. dim_vec\n     (evaluate_net (insert_weights s m (\\<lambda>i. f (i + x1 * x2)))\n       inputs) =\n    output_size m", "using remove_insert_weights"], ["proof (prove)\nusing this:\n  output_size' (insert_weights s m (\\<lambda>i. f (i + x1 * x2))) =\n  dim_vec\n   (evaluate_net (insert_weights s m (\\<lambda>i. f (i + x1 * x2))) inputs)\n  remove_weights (insert_weights ?s ?m ?w) = ?m\n\ngoal (1 subgoal):\n 1. dim_vec\n     (evaluate_net (insert_weights s m (\\<lambda>i. f (i + x1 * x2)))\n       inputs) =\n    output_size m", "by auto"], ["proof (state)\nthis:\n  dim_vec\n   (evaluate_net (insert_weights s m (\\<lambda>i. f (i + x1 * x2)))\n     inputs) =\n  output_size m\n\ngoal (5 subgoals):\n 1. \\<And>f.\n       evaluate_net (insert_weights s m (\\<lambda>i. f (i + x1 * x2 + a)))\n        inputs\n       \\<in> carrier_vec ?n\n 2. \\<And>j.\n       j < ?n \\<Longrightarrow>\n       polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n        (\\<lambda>f.\n            evaluate_net\n             (insert_weights s m (\\<lambda>i. f (i + x1 * x2 + a))) inputs $\n            j)\n 3. \\<And>f.\n       extract_matrix (\\<lambda>i. f (i + a)) x1 x2 \\<in> carrier_mat ?m ?n\n 4. \\<And>i j.\n       \\<lbrakk>i < ?m; j < ?n\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n                          (\\<lambda>f.\n                              extract_matrix (\\<lambda>i. f (i + a)) x1\n                               x2 $$\n                              (i, j))\n 5. j < ?m", "then"], ["proof (chain)\npicking this:\n  dim_vec\n   (evaluate_net (insert_weights s m (\\<lambda>i. f (i + x1 * x2)))\n     inputs) =\n  output_size m", "show \"evaluate_net (insert_weights s m (\\<lambda>i. f (i + x1 * x2))) inputs \\<in> carrier_vec (output_size m)\""], ["proof (prove)\nusing this:\n  dim_vec\n   (evaluate_net (insert_weights s m (\\<lambda>i. f (i + x1 * x2)))\n     inputs) =\n  output_size m\n\ngoal (1 subgoal):\n 1. evaluate_net (insert_weights s m (\\<lambda>i. f (i + x1 * x2))) inputs\n    \\<in> carrier_vec (output_size m)", "using carrier_vec_def"], ["proof (prove)\nusing this:\n  dim_vec\n   (evaluate_net (insert_weights s m (\\<lambda>i. f (i + x1 * x2)))\n     inputs) =\n  output_size m\n  carrier_vec ?n = {v. dim_vec v = ?n}\n\ngoal (1 subgoal):\n 1. evaluate_net (insert_weights s m (\\<lambda>i. f (i + x1 * x2))) inputs\n    \\<in> carrier_vec (output_size m)", "by (metis (full_types) mem_Collect_eq)"], ["proof (state)\nthis:\n  evaluate_net (insert_weights s m (\\<lambda>i. f (i + x1 * x2))) inputs\n  \\<in> carrier_vec (output_size m)\n\ngoal (4 subgoals):\n 1. \\<And>j.\n       j < output_size m \\<Longrightarrow>\n       polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n        (\\<lambda>f.\n            evaluate_net\n             (insert_weights s m (\\<lambda>i. f (i + x1 * x2 + a))) inputs $\n            j)\n 2. \\<And>f.\n       extract_matrix (\\<lambda>i. f (i + a)) x1 x2\n       \\<in> carrier_mat ?m (output_size m)\n 3. \\<And>i j.\n       \\<lbrakk>i < ?m; j < output_size m\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n                          (\\<lambda>f.\n                              extract_matrix (\\<lambda>i. f (i + a)) x1\n                               x2 $$\n                              (i, j))\n 4. j < ?m", "}"], ["proof (state)\nthis:\n  evaluate_net (insert_weights s m (\\<lambda>i. ?f2 (i + x1 * x2))) inputs\n  \\<in> carrier_vec (output_size m)\n\ngoal (4 subgoals):\n 1. \\<And>j.\n       j < output_size m \\<Longrightarrow>\n       polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n        (\\<lambda>f.\n            evaluate_net\n             (insert_weights s m (\\<lambda>i. f (i + x1 * x2 + a))) inputs $\n            j)\n 2. \\<And>f.\n       extract_matrix (\\<lambda>i. f (i + a)) x1 x2\n       \\<in> carrier_mat ?m (output_size m)\n 3. \\<And>i j.\n       \\<lbrakk>i < ?m; j < output_size m\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n                          (\\<lambda>f.\n                              extract_matrix (\\<lambda>i. f (i + a)) x1\n                               x2 $$\n                              (i, j))\n 4. j < ?m", "have \"map dim_vec inputs = input_sizes m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map dim_vec inputs = input_sizes m", "by (simp add: Conv.prems(1))"], ["proof (state)\nthis:\n  map dim_vec inputs = input_sizes m\n\ngoal (4 subgoals):\n 1. \\<And>j.\n       j < output_size m \\<Longrightarrow>\n       polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n        (\\<lambda>f.\n            evaluate_net\n             (insert_weights s m (\\<lambda>i. f (i + x1 * x2 + a))) inputs $\n            j)\n 2. \\<And>f.\n       extract_matrix (\\<lambda>i. f (i + a)) x1 x2\n       \\<in> carrier_mat ?m (output_size m)\n 3. \\<And>i j.\n       \\<lbrakk>i < ?m; j < output_size m\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n                          (\\<lambda>f.\n                              extract_matrix (\\<lambda>i. f (i + a)) x1\n                               x2 $$\n                              (i, j))\n 4. j < ?m", "have \"valid_net m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_net m", "using Conv.prems(2) valid_net.cases"], ["proof (prove)\nusing this:\n  valid_net (Conv x m)\n  \\<lbrakk>valid_net ?a; \\<And>M. ?a = Input M \\<Longrightarrow> ?P;\n   \\<And>m r1 r0.\n      \\<lbrakk>?a = Conv (r0, r1) m; output_size m = r1;\n       valid_net m\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>m1 m2.\n      \\<lbrakk>?a = Pool m1 m2; output_size m1 = output_size m2;\n       valid_net m1; valid_net m2\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. valid_net m", "by fastforce"], ["proof (state)\nthis:\n  valid_net m\n\ngoal (4 subgoals):\n 1. \\<And>j.\n       j < output_size m \\<Longrightarrow>\n       polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n        (\\<lambda>f.\n            evaluate_net\n             (insert_weights s m (\\<lambda>i. f (i + x1 * x2 + a))) inputs $\n            j)\n 2. \\<And>f.\n       extract_matrix (\\<lambda>i. f (i + a)) x1 x2\n       \\<in> carrier_mat ?m (output_size m)\n 3. \\<And>i j.\n       \\<lbrakk>i < ?m; j < output_size m\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n                          (\\<lambda>f.\n                              extract_matrix (\\<lambda>i. f (i + a)) x1\n                               x2 $$\n                              (i, j))\n 4. j < ?m", "show \"\\<And>j. j < output_size m \\<Longrightarrow>  polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n          (\\<lambda>f. evaluate_net (insert_weights s m (\\<lambda>i. f (i + x1 * x2 + a))) inputs $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < output_size m \\<Longrightarrow>\n       polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n        (\\<lambda>f.\n            evaluate_net\n             (insert_weights s m (\\<lambda>i. f (i + x1 * x2 + a))) inputs $\n            j)", "unfolding vec_of_list_index count_weights.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < output_size m \\<Longrightarrow>\n       polyfun {..<a + (x1 * x2 + count_weights s m)}\n        (\\<lambda>f.\n            evaluate_net\n             (insert_weights s m (\\<lambda>i. f (i + x1 * x2 + a))) inputs $\n            j)", "using Conv(1)[OF \\<open>map dim_vec inputs = input_sizes m\\<close> \\<open>valid_net m\\<close>, of _ \"x1 * x2 + a\"]"], ["proof (prove)\nusing this:\n  ?j < output_size m \\<Longrightarrow>\n  polyfun {..<x1 * x2 + a + count_weights s m}\n   (\\<lambda>f.\n       evaluate_net (insert_weights s m (\\<lambda>i. f (i + (x1 * x2 + a))))\n        inputs $\n       ?j)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < output_size m \\<Longrightarrow>\n       polyfun {..<a + (x1 * x2 + count_weights s m)}\n        (\\<lambda>f.\n            evaluate_net\n             (insert_weights s m (\\<lambda>i. f (i + x1 * x2 + a))) inputs $\n            j)", "unfolding semigroup_add_class.add.assoc ab_semigroup_add_class.add.commute[of \"x1 * x2\" a]"], ["proof (prove)\nusing this:\n  ?j < output_size m \\<Longrightarrow>\n  polyfun {..<a + (x1 * x2 + count_weights s m)}\n   (\\<lambda>f.\n       evaluate_net (insert_weights s m (\\<lambda>i. f (i + (a + x1 * x2))))\n        inputs $\n       ?j)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j < output_size m \\<Longrightarrow>\n       polyfun {..<a + (x1 * x2 + count_weights s m)}\n        (\\<lambda>f.\n            evaluate_net\n             (insert_weights s m (\\<lambda>i. f (i + (a + x1 * x2))))\n             inputs $\n            j)", "by blast"], ["proof (state)\nthis:\n  ?j < output_size m \\<Longrightarrow>\n  polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n   (\\<lambda>f.\n       evaluate_net (insert_weights s m (\\<lambda>i. f (i + x1 * x2 + a)))\n        inputs $\n       ?j)\n\ngoal (3 subgoals):\n 1. \\<And>f.\n       extract_matrix (\\<lambda>i. f (i + a)) x1 x2\n       \\<in> carrier_mat ?m (output_size m)\n 2. \\<And>i j.\n       \\<lbrakk>i < ?m; j < output_size m\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n                          (\\<lambda>f.\n                              extract_matrix (\\<lambda>i. f (i + a)) x1\n                               x2 $$\n                              (i, j))\n 3. j < ?m", "have \"output_size m = x2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. output_size m = x2", "using Conv.prems(2) \\<open>x = (x1, x2)\\<close> valid_net.cases"], ["proof (prove)\nusing this:\n  valid_net (Conv x m)\n  x = (x1, x2)\n  \\<lbrakk>valid_net ?a; \\<And>M. ?a = Input M \\<Longrightarrow> ?P;\n   \\<And>m r1 r0.\n      \\<lbrakk>?a = Conv (r0, r1) m; output_size m = r1;\n       valid_net m\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>m1 m2.\n      \\<lbrakk>?a = Pool m1 m2; output_size m1 = output_size m2;\n       valid_net m1; valid_net m2\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. output_size m = x2", "by fastforce"], ["proof (state)\nthis:\n  output_size m = x2\n\ngoal (3 subgoals):\n 1. \\<And>f.\n       extract_matrix (\\<lambda>i. f (i + a)) x1 x2\n       \\<in> carrier_mat ?m (output_size m)\n 2. \\<And>i j.\n       \\<lbrakk>i < ?m; j < output_size m\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n                          (\\<lambda>f.\n                              extract_matrix (\\<lambda>i. f (i + a)) x1\n                               x2 $$\n                              (i, j))\n 3. j < ?m", "show \"\\<And>f. extract_matrix (\\<lambda>i. f (i + a)) x1 x2 \\<in> carrier_mat x1 (output_size m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       extract_matrix (\\<lambda>i. f (i + a)) x1 x2\n       \\<in> carrier_mat x1 (output_size m)", "unfolding \\<open>output_size m = x2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       extract_matrix (\\<lambda>i. f (i + a)) x1 x2 \\<in> carrier_mat x1 x2", "using dim_extract_matrix"], ["proof (prove)\nusing this:\n  dim_row (extract_matrix ?as ?m ?n) = ?m\n  dim_col (extract_matrix ?as ?m ?n) = ?n\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       extract_matrix (\\<lambda>i. f (i + a)) x1 x2 \\<in> carrier_mat x1 x2", "using carrier_matI"], ["proof (prove)\nusing this:\n  dim_row (extract_matrix ?as ?m ?n) = ?m\n  dim_col (extract_matrix ?as ?m ?n) = ?n\n  \\<lbrakk>dim_row ?A = ?nr; dim_col ?A = ?nc\\<rbrakk>\n  \\<Longrightarrow> ?A \\<in> carrier_mat ?nr ?nc\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       extract_matrix (\\<lambda>i. f (i + a)) x1 x2 \\<in> carrier_mat x1 x2", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  extract_matrix (\\<lambda>i. ?f (i + a)) x1 x2\n  \\<in> carrier_mat x1 (output_size m)\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < x1; j < output_size m\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n                          (\\<lambda>f.\n                              extract_matrix (\\<lambda>i. f (i + a)) x1\n                               x2 $$\n                              (i, j))\n 2. j < x1", "show \"\\<And>i j. i < x1 \\<Longrightarrow> j < output_size m \\<Longrightarrow> polyfun {..<a + count_weights s (Conv (x1, x2) m)} (\\<lambda>f. extract_matrix (\\<lambda>i. f (i + a)) x1 x2 $$ (i, j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < x1; j < output_size m\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n                          (\\<lambda>f.\n                              extract_matrix (\\<lambda>i. f (i + a)) x1\n                               x2 $$\n                              (i, j))", "unfolding \\<open>output_size m = x2\\<close> count_weights.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < x1; j < x2\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + (x1 * x2 + count_weights s m)}\n                          (\\<lambda>f.\n                              extract_matrix (\\<lambda>i. f (i + a)) x1\n                               x2 $$\n                              (i, j))", "using polyfun_extract_matrix[of _ x1 _ x2 a \"count_weights s m\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < x1; ?j < x2\\<rbrakk>\n  \\<Longrightarrow> polyfun {..<a + (x1 * x2 + count_weights s m)}\n                     (\\<lambda>f.\n                         extract_matrix (\\<lambda>i. f (i + a)) x1 x2 $$\n                         (?i, ?j))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < x1; j < x2\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + (x1 * x2 + count_weights s m)}\n                          (\\<lambda>f.\n                              extract_matrix (\\<lambda>i. f (i + a)) x1\n                               x2 $$\n                              (i, j))", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?i1 < x1; ?j1 < output_size m\\<rbrakk>\n  \\<Longrightarrow> polyfun {..<a + count_weights s (Conv (x1, x2) m)}\n                     (\\<lambda>f.\n                         extract_matrix (\\<lambda>i. f (i + a)) x1 x2 $$\n                         (?i1, ?j1))\n\ngoal (1 subgoal):\n 1. j < x1", "show \"j < x1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < x1", "using Conv.prems(3) \\<open>x = (x1, x2)\\<close>"], ["proof (prove)\nusing this:\n  j < output_size (Conv x m)\n  x = (x1, x2)\n\ngoal (1 subgoal):\n 1. j < x1", "by auto"], ["proof (state)\nthis:\n  j < x1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  polyfun {..<a + count_weights s (Conv x m)}\n   (\\<lambda>f.\n       evaluate_net (insert_weights s (Conv x m) (\\<lambda>i. f (i + a)))\n        inputs $\n       j)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m1;\n                    valid_net m1; j < output_size m1\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m1}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a))) inputs $ j);\n        \\<And>inputs j a.\n           \\<lbrakk>map dim_vec inputs = input_sizes m2; valid_net m2;\n            j < output_size m2\\<rbrakk>\n           \\<Longrightarrow> polyfun {..<a + count_weights s m2}\n                              (\\<lambda>f.\n                                  evaluate_net\n                                   (insert_weights s m2\n                                     (\\<lambda>i. f (i + a)))\n                                   inputs $\n                                  j);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        valid_net (Pool m1 m2); j < output_size (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Pool m1 m2)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Pool m1 m2)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m1 m2 inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m1;\n                    valid_net m1; j < output_size m1\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m1}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a))) inputs $ j);\n        \\<And>inputs j a.\n           \\<lbrakk>map dim_vec inputs = input_sizes m2; valid_net m2;\n            j < output_size m2\\<rbrakk>\n           \\<Longrightarrow> polyfun {..<a + count_weights s m2}\n                              (\\<lambda>f.\n                                  evaluate_net\n                                   (insert_weights s m2\n                                     (\\<lambda>i. f (i + a)))\n                                   inputs $\n                                  j);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        valid_net (Pool m1 m2); j < output_size (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Pool m1 m2)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Pool m1 m2)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)", "case (Pool m1 m2 inputs j a)"], ["proof (state)\nthis:\n  \\<lbrakk>map dim_vec ?inputs = input_sizes m1; valid_net m1;\n   ?j < output_size m1\\<rbrakk>\n  \\<Longrightarrow> polyfun {..<?a + count_weights s m1}\n                     (\\<lambda>f.\n                         evaluate_net\n                          (insert_weights s m1 (\\<lambda>i. f (i + ?a)))\n                          ?inputs $\n                         ?j)\n  \\<lbrakk>map dim_vec ?inputs = input_sizes m2; valid_net m2;\n   ?j < output_size m2\\<rbrakk>\n  \\<Longrightarrow> polyfun {..<?a + count_weights s m2}\n                     (\\<lambda>f.\n                         evaluate_net\n                          (insert_weights s m2 (\\<lambda>i. f (i + ?a)))\n                          ?inputs $\n                         ?j)\n  map dim_vec inputs = input_sizes (Pool m1 m2)\n  valid_net (Pool m1 m2)\n  j < output_size (Pool m1 m2)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m1;\n                    valid_net m1; j < output_size m1\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m1}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a))) inputs $ j);\n        \\<And>inputs j a.\n           \\<lbrakk>map dim_vec inputs = input_sizes m2; valid_net m2;\n            j < output_size m2\\<rbrakk>\n           \\<Longrightarrow> polyfun {..<a + count_weights s m2}\n                              (\\<lambda>f.\n                                  evaluate_net\n                                   (insert_weights s m2\n                                     (\\<lambda>i. f (i + a)))\n                                   inputs $\n                                  j);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        valid_net (Pool m1 m2); j < output_size (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Pool m1 m2)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Pool m1 m2)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)", "have A2:\"\\<And>f. map dim_vec (take (length (input_sizes (insert_weights s m1 (\\<lambda>i. f (i + a))))) inputs) = input_sizes m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       map dim_vec\n        (take\n          (length\n            (input_sizes (insert_weights s m1 (\\<lambda>i. f (i + a)))))\n          inputs) =\n       input_sizes m1", "by (metis Pool.prems(1)  append_eq_conv_conj input_sizes.simps(3) input_sizes_remove_weights remove_insert_weights take_map)"], ["proof (state)\nthis:\n  map dim_vec\n   (take\n     (length (input_sizes (insert_weights s m1 (\\<lambda>i. ?f (i + a)))))\n     inputs) =\n  input_sizes m1\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m1;\n                    valid_net m1; j < output_size m1\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m1}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a))) inputs $ j);\n        \\<And>inputs j a.\n           \\<lbrakk>map dim_vec inputs = input_sizes m2; valid_net m2;\n            j < output_size m2\\<rbrakk>\n           \\<Longrightarrow> polyfun {..<a + count_weights s m2}\n                              (\\<lambda>f.\n                                  evaluate_net\n                                   (insert_weights s m2\n                                     (\\<lambda>i. f (i + a)))\n                                   inputs $\n                                  j);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        valid_net (Pool m1 m2); j < output_size (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Pool m1 m2)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Pool m1 m2)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)", "have B2:\"\\<And>f. map dim_vec (drop (length (input_sizes (insert_weights s m1 (\\<lambda>i. f (i + a))))) inputs) = input_sizes m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       map dim_vec\n        (drop\n          (length\n            (input_sizes (insert_weights s m1 (\\<lambda>i. f (i + a)))))\n          inputs) =\n       input_sizes m2", "using Pool.prems(1) append_eq_conv_conj input_sizes.simps(3) input_sizes_remove_weights remove_insert_weights"], ["proof (prove)\nusing this:\n  map dim_vec inputs = input_sizes (Pool m1 m2)\n  (?xs @ ?ys = ?zs) =\n  (?xs = take (length ?xs) ?zs \\<and> ?ys = drop (length ?xs) ?zs)\n  input_sizes (Pool ?m1.0 ?m2.0) = input_sizes ?m1.0 @ input_sizes ?m2.0\n  input_sizes ?m = input_sizes (remove_weights ?m)\n  remove_weights (insert_weights ?s ?m ?w) = ?m\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       map dim_vec\n        (drop\n          (length\n            (input_sizes (insert_weights s m1 (\\<lambda>i. f (i + a)))))\n          inputs) =\n       input_sizes m2", "by (metis drop_map)"], ["proof (state)\nthis:\n  map dim_vec\n   (drop\n     (length (input_sizes (insert_weights s m1 (\\<lambda>i. ?f (i + a)))))\n     inputs) =\n  input_sizes m2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m1;\n                    valid_net m1; j < output_size m1\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m1}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a))) inputs $ j);\n        \\<And>inputs j a.\n           \\<lbrakk>map dim_vec inputs = input_sizes m2; valid_net m2;\n            j < output_size m2\\<rbrakk>\n           \\<Longrightarrow> polyfun {..<a + count_weights s m2}\n                              (\\<lambda>f.\n                                  evaluate_net\n                                   (insert_weights s m2\n                                     (\\<lambda>i. f (i + a)))\n                                   inputs $\n                                  j);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        valid_net (Pool m1 m2); j < output_size (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Pool m1 m2)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Pool m1 m2)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)", "have A3:\"valid_net m1\" and B3:\"valid_net m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_net m1 &&& valid_net m2", "using \\<open>valid_net (Pool m1 m2)\\<close> valid_net.simps"], ["proof (prove)\nusing this:\n  valid_net (Pool m1 m2)\n  valid_net ?a =\n  ((\\<exists>M. ?a = Input M) \\<or>\n   (\\<exists>m r1 r0.\n       ?a = Conv (r0, r1) m \\<and>\n       output_size m = r1 \\<and> valid_net m) \\<or>\n   (\\<exists>m1 m2.\n       ?a = Pool m1 m2 \\<and>\n       output_size m1 = output_size m2 \\<and>\n       valid_net m1 \\<and> valid_net m2))\n\ngoal (1 subgoal):\n 1. valid_net m1 &&& valid_net m2", "by blast+"], ["proof (state)\nthis:\n  valid_net m1\n  valid_net m2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m1;\n                    valid_net m1; j < output_size m1\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m1}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a))) inputs $ j);\n        \\<And>inputs j a.\n           \\<lbrakk>map dim_vec inputs = input_sizes m2; valid_net m2;\n            j < output_size m2\\<rbrakk>\n           \\<Longrightarrow> polyfun {..<a + count_weights s m2}\n                              (\\<lambda>f.\n                                  evaluate_net\n                                   (insert_weights s m2\n                                     (\\<lambda>i. f (i + a)))\n                                   inputs $\n                                  j);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        valid_net (Pool m1 m2); j < output_size (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Pool m1 m2)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Pool m1 m2)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)", "have \"output_size (Pool m1 m2) = output_size m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. output_size (Pool m1 m2) = output_size m2", "unfolding output_size.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. output_size m1 = output_size m2", "using \\<open>valid_net (Pool m1 m2)\\<close> \"valid_net.cases\""], ["proof (prove)\nusing this:\n  valid_net (Pool m1 m2)\n  \\<lbrakk>valid_net ?a; \\<And>M. ?a = Input M \\<Longrightarrow> ?P;\n   \\<And>m r1 r0.\n      \\<lbrakk>?a = Conv (r0, r1) m; output_size m = r1;\n       valid_net m\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>m1 m2.\n      \\<lbrakk>?a = Pool m1 m2; output_size m1 = output_size m2;\n       valid_net m1; valid_net m2\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. output_size m1 = output_size m2", "by fastforce"], ["proof (state)\nthis:\n  output_size (Pool m1 m2) = output_size m2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m1;\n                    valid_net m1; j < output_size m1\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m1}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a))) inputs $ j);\n        \\<And>inputs j a.\n           \\<lbrakk>map dim_vec inputs = input_sizes m2; valid_net m2;\n            j < output_size m2\\<rbrakk>\n           \\<Longrightarrow> polyfun {..<a + count_weights s m2}\n                              (\\<lambda>f.\n                                  evaluate_net\n                                   (insert_weights s m2\n                                     (\\<lambda>i. f (i + a)))\n                                   inputs $\n                                  j);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        valid_net (Pool m1 m2); j < output_size (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Pool m1 m2)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Pool m1 m2)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)", "then"], ["proof (chain)\npicking this:\n  output_size (Pool m1 m2) = output_size m2", "have A4:\"j < output_size m1\" and B4:\"j < output_size m2\""], ["proof (prove)\nusing this:\n  output_size (Pool m1 m2) = output_size m2\n\ngoal (1 subgoal):\n 1. j < output_size m1 &&& j < output_size m2", "using \\<open>j < output_size (Pool m1 m2)\\<close>"], ["proof (prove)\nusing this:\n  output_size (Pool m1 m2) = output_size m2\n  j < output_size (Pool m1 m2)\n\ngoal (1 subgoal):\n 1. j < output_size m1 &&& j < output_size m2", "by simp_all"], ["proof (state)\nthis:\n  j < output_size m1\n  j < output_size m2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m1;\n                    valid_net m1; j < output_size m1\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m1}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a))) inputs $ j);\n        \\<And>inputs j a.\n           \\<lbrakk>map dim_vec inputs = input_sizes m2; valid_net m2;\n            j < output_size m2\\<rbrakk>\n           \\<Longrightarrow> polyfun {..<a + count_weights s m2}\n                              (\\<lambda>f.\n                                  evaluate_net\n                                   (insert_weights s m2\n                                     (\\<lambda>i. f (i + a)))\n                                   inputs $\n                                  j);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        valid_net (Pool m1 m2); j < output_size (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Pool m1 m2)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Pool m1 m2)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)", "let ?net1 = \"\\<lambda>f. evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a)))\n    (take (length (input_sizes (insert_weights s m1 (\\<lambda>i. f (i + a))))) inputs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m1 m2 inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m1;\n                    valid_net m1; j < output_size m1\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m1}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a))) inputs $ j);\n        \\<And>inputs j a.\n           \\<lbrakk>map dim_vec inputs = input_sizes m2; valid_net m2;\n            j < output_size m2\\<rbrakk>\n           \\<Longrightarrow> polyfun {..<a + count_weights s m2}\n                              (\\<lambda>f.\n                                  evaluate_net\n                                   (insert_weights s m2\n                                     (\\<lambda>i. f (i + a)))\n                                   inputs $\n                                  j);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        valid_net (Pool m1 m2); j < output_size (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Pool m1 m2)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Pool m1 m2)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)", "let ?net2 = \"\\<lambda>f. evaluate_net (insert_weights s m2 (if s then \\<lambda>i. f (i + a) else (\\<lambda>i. f (i + count_weights s m1 + a))))\n    (drop (length (input_sizes (insert_weights s m1 (\\<lambda>i. f (i + a))))) inputs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m1 m2 inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m1;\n                    valid_net m1; j < output_size m1\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m1}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a))) inputs $ j);\n        \\<And>inputs j a.\n           \\<lbrakk>map dim_vec inputs = input_sizes m2; valid_net m2;\n            j < output_size m2\\<rbrakk>\n           \\<Longrightarrow> polyfun {..<a + count_weights s m2}\n                              (\\<lambda>f.\n                                  evaluate_net\n                                   (insert_weights s m2\n                                     (\\<lambda>i. f (i + a)))\n                                   inputs $\n                                  j);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        valid_net (Pool m1 m2); j < output_size (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Pool m1 m2)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Pool m1 m2)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)", "have length1: \"\\<And>f. output_size m1 = dim_vec (?net1 f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       output_size m1 =\n       dim_vec\n        (evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a)))\n          (take\n            (length\n              (input_sizes (insert_weights s m1 (\\<lambda>i. f (i + a)))))\n            inputs))", "by (metis A2 A3 input_sizes_remove_weights output_size_correct remove_insert_weights)"], ["proof (state)\nthis:\n  output_size m1 =\n  dim_vec\n   (evaluate_net (insert_weights s m1 (\\<lambda>i. ?f (i + a)))\n     (take\n       (length (input_sizes (insert_weights s m1 (\\<lambda>i. ?f (i + a)))))\n       inputs))\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m1;\n                    valid_net m1; j < output_size m1\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m1}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a))) inputs $ j);\n        \\<And>inputs j a.\n           \\<lbrakk>map dim_vec inputs = input_sizes m2; valid_net m2;\n            j < output_size m2\\<rbrakk>\n           \\<Longrightarrow> polyfun {..<a + count_weights s m2}\n                              (\\<lambda>f.\n                                  evaluate_net\n                                   (insert_weights s m2\n                                     (\\<lambda>i. f (i + a)))\n                                   inputs $\n                                  j);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        valid_net (Pool m1 m2); j < output_size (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Pool m1 m2)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Pool m1 m2)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)", "then"], ["proof (chain)\npicking this:\n  output_size m1 =\n  dim_vec\n   (evaluate_net (insert_weights s m1 (\\<lambda>i. ?f (i + a)))\n     (take\n       (length (input_sizes (insert_weights s m1 (\\<lambda>i. ?f (i + a)))))\n       inputs))", "have jlength1:\"\\<And>f. j < dim_vec (?net1 f)\""], ["proof (prove)\nusing this:\n  output_size m1 =\n  dim_vec\n   (evaluate_net (insert_weights s m1 (\\<lambda>i. ?f (i + a)))\n     (take\n       (length (input_sizes (insert_weights s m1 (\\<lambda>i. ?f (i + a)))))\n       inputs))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       j < dim_vec\n            (evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a)))\n              (take\n                (length\n                  (input_sizes\n                    (insert_weights s m1 (\\<lambda>i. f (i + a)))))\n                inputs))", "using A4"], ["proof (prove)\nusing this:\n  output_size m1 =\n  dim_vec\n   (evaluate_net (insert_weights s m1 (\\<lambda>i. ?f (i + a)))\n     (take\n       (length (input_sizes (insert_weights s m1 (\\<lambda>i. ?f (i + a)))))\n       inputs))\n  j < output_size m1\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       j < dim_vec\n            (evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a)))\n              (take\n                (length\n                  (input_sizes\n                    (insert_weights s m1 (\\<lambda>i. f (i + a)))))\n                inputs))", "by metis"], ["proof (state)\nthis:\n  j < dim_vec\n       (evaluate_net (insert_weights s m1 (\\<lambda>i. ?f (i + a)))\n         (take\n           (length\n             (input_sizes (insert_weights s m1 (\\<lambda>i. ?f (i + a)))))\n           inputs))\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m1;\n                    valid_net m1; j < output_size m1\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m1}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a))) inputs $ j);\n        \\<And>inputs j a.\n           \\<lbrakk>map dim_vec inputs = input_sizes m2; valid_net m2;\n            j < output_size m2\\<rbrakk>\n           \\<Longrightarrow> polyfun {..<a + count_weights s m2}\n                              (\\<lambda>f.\n                                  evaluate_net\n                                   (insert_weights s m2\n                                     (\\<lambda>i. f (i + a)))\n                                   inputs $\n                                  j);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        valid_net (Pool m1 m2); j < output_size (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Pool m1 m2)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Pool m1 m2)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)", "have length2: \"\\<And>f. output_size m2 = dim_vec (?net2 f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       output_size m2 =\n       dim_vec\n        (evaluate_net\n          (insert_weights s m2\n            (if s then \\<lambda>i. f (i + a)\n             else (\\<lambda>i. f (i + count_weights s m1 + a))))\n          (drop\n            (length\n              (input_sizes (insert_weights s m1 (\\<lambda>i. f (i + a)))))\n            inputs))", "by (metis B2 B3 input_sizes_remove_weights output_size_correct remove_insert_weights)"], ["proof (state)\nthis:\n  output_size m2 =\n  dim_vec\n   (evaluate_net\n     (insert_weights s m2\n       (if s then \\<lambda>i. ?f (i + a)\n        else (\\<lambda>i. ?f (i + count_weights s m1 + a))))\n     (drop\n       (length (input_sizes (insert_weights s m1 (\\<lambda>i. ?f (i + a)))))\n       inputs))\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m1;\n                    valid_net m1; j < output_size m1\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m1}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a))) inputs $ j);\n        \\<And>inputs j a.\n           \\<lbrakk>map dim_vec inputs = input_sizes m2; valid_net m2;\n            j < output_size m2\\<rbrakk>\n           \\<Longrightarrow> polyfun {..<a + count_weights s m2}\n                              (\\<lambda>f.\n                                  evaluate_net\n                                   (insert_weights s m2\n                                     (\\<lambda>i. f (i + a)))\n                                   inputs $\n                                  j);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        valid_net (Pool m1 m2); j < output_size (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Pool m1 m2)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Pool m1 m2)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)", "then"], ["proof (chain)\npicking this:\n  output_size m2 =\n  dim_vec\n   (evaluate_net\n     (insert_weights s m2\n       (if s then \\<lambda>i. ?f (i + a)\n        else (\\<lambda>i. ?f (i + count_weights s m1 + a))))\n     (drop\n       (length (input_sizes (insert_weights s m1 (\\<lambda>i. ?f (i + a)))))\n       inputs))", "have jlength2:\"\\<And>f. j < dim_vec (?net2 f)\""], ["proof (prove)\nusing this:\n  output_size m2 =\n  dim_vec\n   (evaluate_net\n     (insert_weights s m2\n       (if s then \\<lambda>i. ?f (i + a)\n        else (\\<lambda>i. ?f (i + count_weights s m1 + a))))\n     (drop\n       (length (input_sizes (insert_weights s m1 (\\<lambda>i. ?f (i + a)))))\n       inputs))\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       j < dim_vec\n            (evaluate_net\n              (insert_weights s m2\n                (if s then \\<lambda>i. f (i + a)\n                 else (\\<lambda>i. f (i + count_weights s m1 + a))))\n              (drop\n                (length\n                  (input_sizes\n                    (insert_weights s m1 (\\<lambda>i. f (i + a)))))\n                inputs))", "using B4"], ["proof (prove)\nusing this:\n  output_size m2 =\n  dim_vec\n   (evaluate_net\n     (insert_weights s m2\n       (if s then \\<lambda>i. ?f (i + a)\n        else (\\<lambda>i. ?f (i + count_weights s m1 + a))))\n     (drop\n       (length (input_sizes (insert_weights s m1 (\\<lambda>i. ?f (i + a)))))\n       inputs))\n  j < output_size m2\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       j < dim_vec\n            (evaluate_net\n              (insert_weights s m2\n                (if s then \\<lambda>i. f (i + a)\n                 else (\\<lambda>i. f (i + count_weights s m1 + a))))\n              (drop\n                (length\n                  (input_sizes\n                    (insert_weights s m1 (\\<lambda>i. f (i + a)))))\n                inputs))", "by metis"], ["proof (state)\nthis:\n  j < dim_vec\n       (evaluate_net\n         (insert_weights s m2\n           (if s then \\<lambda>i. ?f (i + a)\n            else (\\<lambda>i. ?f (i + count_weights s m1 + a))))\n         (drop\n           (length\n             (input_sizes (insert_weights s m1 (\\<lambda>i. ?f (i + a)))))\n           inputs))\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m1;\n                    valid_net m1; j < output_size m1\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m1}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a))) inputs $ j);\n        \\<And>inputs j a.\n           \\<lbrakk>map dim_vec inputs = input_sizes m2; valid_net m2;\n            j < output_size m2\\<rbrakk>\n           \\<Longrightarrow> polyfun {..<a + count_weights s m2}\n                              (\\<lambda>f.\n                                  evaluate_net\n                                   (insert_weights s m2\n                                     (\\<lambda>i. f (i + a)))\n                                   inputs $\n                                  j);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        valid_net (Pool m1 m2); j < output_size (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Pool m1 m2)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Pool m1 m2)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)", "have cong1:\"\\<And>xf. (\\<lambda>f. evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a)))\n        (take (length (input_sizes (insert_weights s m1 (\\<lambda>i. xf (i + a))))) inputs) $ j)\n         = (\\<lambda>f. ?net1 f $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xf.\n       (\\<lambda>f.\n           evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a)))\n            (take\n              (length\n                (input_sizes\n                  (insert_weights s m1 (\\<lambda>i. xf (i + a)))))\n              inputs) $\n           j) =\n       (\\<lambda>f.\n           evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a)))\n            (take\n              (length\n                (input_sizes (insert_weights s m1 (\\<lambda>i. f (i + a)))))\n              inputs) $\n           j)", "using input_sizes_remove_weights remove_insert_weights"], ["proof (prove)\nusing this:\n  input_sizes ?m = input_sizes (remove_weights ?m)\n  remove_weights (insert_weights ?s ?m ?w) = ?m\n\ngoal (1 subgoal):\n 1. \\<And>xf.\n       (\\<lambda>f.\n           evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a)))\n            (take\n              (length\n                (input_sizes\n                  (insert_weights s m1 (\\<lambda>i. xf (i + a)))))\n              inputs) $\n           j) =\n       (\\<lambda>f.\n           evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a)))\n            (take\n              (length\n                (input_sizes (insert_weights s m1 (\\<lambda>i. f (i + a)))))\n              inputs) $\n           j)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>f.\n      evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a)))\n       (take\n         (length\n           (input_sizes (insert_weights s m1 (\\<lambda>i. ?xf (i + a)))))\n         inputs) $\n      j) =\n  (\\<lambda>f.\n      evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a)))\n       (take\n         (length\n           (input_sizes (insert_weights s m1 (\\<lambda>i. f (i + a)))))\n         inputs) $\n      j)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m1;\n                    valid_net m1; j < output_size m1\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m1}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a))) inputs $ j);\n        \\<And>inputs j a.\n           \\<lbrakk>map dim_vec inputs = input_sizes m2; valid_net m2;\n            j < output_size m2\\<rbrakk>\n           \\<Longrightarrow> polyfun {..<a + count_weights s m2}\n                              (\\<lambda>f.\n                                  evaluate_net\n                                   (insert_weights s m2\n                                     (\\<lambda>i. f (i + a)))\n                                   inputs $\n                                  j);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        valid_net (Pool m1 m2); j < output_size (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Pool m1 m2)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Pool m1 m2)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)", "have cong2:\"\\<And>xf. (\\<lambda>f. evaluate_net (insert_weights s m2 (\\<lambda>i. f (i + (a + (if s then 0 else count_weights s m1)))))\n        (drop (length (input_sizes (insert_weights s m1 (\\<lambda>i. xf (i + a))))) inputs) $ j)\n         = (\\<lambda>f. ?net2 f $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xf.\n       (\\<lambda>f.\n           evaluate_net\n            (insert_weights s m2\n              (\\<lambda>i.\n                  f (i + (a + (if s then 0 else count_weights s m1)))))\n            (drop\n              (length\n                (input_sizes\n                  (insert_weights s m1 (\\<lambda>i. xf (i + a)))))\n              inputs) $\n           j) =\n       (\\<lambda>f.\n           evaluate_net\n            (insert_weights s m2\n              (if s then \\<lambda>i. f (i + a)\n               else (\\<lambda>i. f (i + count_weights s m1 + a))))\n            (drop\n              (length\n                (input_sizes (insert_weights s m1 (\\<lambda>i. f (i + a)))))\n              inputs) $\n           j)", "unfolding semigroup_add_class.add.assoc[symmetric] ab_semigroup_add_class.add.commute[of a \"if s then 0 else count_weights s m1\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xf.\n       (\\<lambda>f.\n           evaluate_net\n            (insert_weights s m2\n              (\\<lambda>i.\n                  f (i + (if s then 0 else count_weights s m1) + a)))\n            (drop\n              (length\n                (input_sizes\n                  (insert_weights s m1 (\\<lambda>i. xf (i + a)))))\n              inputs) $\n           j) =\n       (\\<lambda>f.\n           evaluate_net\n            (insert_weights s m2\n              (if s then \\<lambda>i. f (i + a)\n               else (\\<lambda>i. f (i + count_weights s m1 + a))))\n            (drop\n              (length\n                (input_sizes (insert_weights s m1 (\\<lambda>i. f (i + a)))))\n              inputs) $\n           j)", "using input_sizes_remove_weights remove_insert_weights"], ["proof (prove)\nusing this:\n  input_sizes ?m = input_sizes (remove_weights ?m)\n  remove_weights (insert_weights ?s ?m ?w) = ?m\n\ngoal (1 subgoal):\n 1. \\<And>xf.\n       (\\<lambda>f.\n           evaluate_net\n            (insert_weights s m2\n              (\\<lambda>i.\n                  f (i + (if s then 0 else count_weights s m1) + a)))\n            (drop\n              (length\n                (input_sizes\n                  (insert_weights s m1 (\\<lambda>i. xf (i + a)))))\n              inputs) $\n           j) =\n       (\\<lambda>f.\n           evaluate_net\n            (insert_weights s m2\n              (if s then \\<lambda>i. f (i + a)\n               else (\\<lambda>i. f (i + count_weights s m1 + a))))\n            (drop\n              (length\n                (input_sizes (insert_weights s m1 (\\<lambda>i. f (i + a)))))\n              inputs) $\n           j)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>f.\n      evaluate_net\n       (insert_weights s m2\n         (\\<lambda>i. f (i + (a + (if s then 0 else count_weights s m1)))))\n       (drop\n         (length\n           (input_sizes (insert_weights s m1 (\\<lambda>i. ?xf (i + a)))))\n         inputs) $\n      j) =\n  (\\<lambda>f.\n      evaluate_net\n       (insert_weights s m2\n         (if s then \\<lambda>i. f (i + a)\n          else (\\<lambda>i. f (i + count_weights s m1 + a))))\n       (drop\n         (length\n           (input_sizes (insert_weights s m1 (\\<lambda>i. f (i + a)))))\n         inputs) $\n      j)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 inputs j a.\n       \\<lbrakk>\\<And>inputs j a.\n                   \\<lbrakk>map dim_vec inputs = input_sizes m1;\n                    valid_net m1; j < output_size m1\\<rbrakk>\n                   \\<Longrightarrow> polyfun {..<a + count_weights s m1}\n(\\<lambda>f.\n    evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a))) inputs $ j);\n        \\<And>inputs j a.\n           \\<lbrakk>map dim_vec inputs = input_sizes m2; valid_net m2;\n            j < output_size m2\\<rbrakk>\n           \\<Longrightarrow> polyfun {..<a + count_weights s m2}\n                              (\\<lambda>f.\n                                  evaluate_net\n                                   (insert_weights s m2\n                                     (\\<lambda>i. f (i + a)))\n                                   inputs $\n                                  j);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        valid_net (Pool m1 m2); j < output_size (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<a + count_weights s (Pool m1 m2)}\n                          (\\<lambda>f.\n                              evaluate_net\n                               (insert_weights s (Pool m1 m2)\n                                 (\\<lambda>i. f (i + a)))\n                               inputs $\n                              j)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun {..<a + count_weights s (Pool m1 m2)}\n     (\\<lambda>f.\n         evaluate_net\n          (insert_weights s (Pool m1 m2) (\\<lambda>i. f (i + a))) inputs $\n         j)", "unfolding insert_weights.simps evaluate_net.simps  count_weights.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun\n     {..<a +\n         (if s then max (count_weights s m1) (count_weights s m2)\n          else count_weights s m1 + count_weights s m2)}\n     (\\<lambda>f.\n         component_mult\n          (evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a)))\n            (take\n              (length\n                (input_sizes (insert_weights s m1 (\\<lambda>i. f (i + a)))))\n              inputs))\n          (evaluate_net\n            (insert_weights s m2\n              (if s then \\<lambda>i. f (i + a)\n               else (\\<lambda>i. f (i + count_weights s m1 + a))))\n            (drop\n              (length\n                (input_sizes (insert_weights s m1 (\\<lambda>i. f (i + a)))))\n              inputs)) $\n         j)", "unfolding  index_component_mult[OF jlength1 jlength2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun\n     {..<a +\n         (if s then max (count_weights s m1) (count_weights s m2)\n          else count_weights s m1 + count_weights s m2)}\n     (\\<lambda>f.\n         evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a)))\n          (take\n            (length\n              (input_sizes (insert_weights s m1 (\\<lambda>i. f (i + a)))))\n            inputs) $\n         j *\n         evaluate_net\n          (insert_weights s m2\n            (if s then \\<lambda>i. f (i + a)\n             else (\\<lambda>i. f (i + count_weights s m1 + a))))\n          (drop\n            (length\n              (input_sizes (insert_weights s m1 (\\<lambda>i. f (i + a)))))\n            inputs) $\n         j)", "apply (rule polyfun_mult)"], ["proof (prove)\ngoal (2 subgoals):\n 1. polyfun\n     {..<a +\n         (if s then max (count_weights s m1) (count_weights s m2)\n          else count_weights s m1 + count_weights s m2)}\n     (\\<lambda>x.\n         evaluate_net (insert_weights s m1 (\\<lambda>i. x (i + a)))\n          (take\n            (length\n              (input_sizes (insert_weights s m1 (\\<lambda>i. x (i + a)))))\n            inputs) $\n         j)\n 2. polyfun\n     {..<a +\n         (if s then max (count_weights s m1) (count_weights s m2)\n          else count_weights s m1 + count_weights s m2)}\n     (\\<lambda>x.\n         evaluate_net\n          (insert_weights s m2\n            (if s then \\<lambda>i. x (i + a)\n             else (\\<lambda>i. x (i + count_weights s m1 + a))))\n          (drop\n            (length\n              (input_sizes (insert_weights s m1 (\\<lambda>i. x (i + a)))))\n            inputs) $\n         j)", "using Pool.IH(1)[OF A2 A3 A4, of a, unfolded cong1]"], ["proof (prove)\nusing this:\n  polyfun {..<a + count_weights s m1}\n   (\\<lambda>f.\n       evaluate_net (insert_weights s m1 (\\<lambda>i. f (i + a)))\n        (take\n          (length\n            (input_sizes (insert_weights s m1 (\\<lambda>i. f (i + a)))))\n          inputs) $\n       j)\n\ngoal (2 subgoals):\n 1. polyfun\n     {..<a +\n         (if s then max (count_weights s m1) (count_weights s m2)\n          else count_weights s m1 + count_weights s m2)}\n     (\\<lambda>x.\n         evaluate_net (insert_weights s m1 (\\<lambda>i. x (i + a)))\n          (take\n            (length\n              (input_sizes (insert_weights s m1 (\\<lambda>i. x (i + a)))))\n            inputs) $\n         j)\n 2. polyfun\n     {..<a +\n         (if s then max (count_weights s m1) (count_weights s m2)\n          else count_weights s m1 + count_weights s m2)}\n     (\\<lambda>x.\n         evaluate_net\n          (insert_weights s m2\n            (if s then \\<lambda>i. x (i + a)\n             else (\\<lambda>i. x (i + count_weights s m1 + a))))\n          (drop\n            (length\n              (input_sizes (insert_weights s m1 (\\<lambda>i. x (i + a)))))\n            inputs) $\n         j)", "apply (simp add:polyfun_subset[of \"{..<a + count_weights s m1}\" \"{..<a + (if s then max (count_weights s m1) (count_weights s m2) else count_weights s m1 + count_weights s m2)}\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun\n     {..<a +\n         (if s then max (count_weights s m1) (count_weights s m2)\n          else count_weights s m1 + count_weights s m2)}\n     (\\<lambda>x.\n         evaluate_net\n          (insert_weights s m2\n            (if s then \\<lambda>i. x (i + a)\n             else (\\<lambda>i. x (i + count_weights s m1 + a))))\n          (drop\n            (length\n              (input_sizes (insert_weights s m1 (\\<lambda>i. x (i + a)))))\n            inputs) $\n         j)", "using Pool.IH(2)[OF B2 B3 B4, of \"a + (if s then 0 else count_weights s m1)\", unfolded cong2 semigroup_add_class.add.assoc[of a]]"], ["proof (prove)\nusing this:\n  polyfun\n   {..<a + ((if s then 0 else count_weights s m1) + count_weights s m2)}\n   (\\<lambda>f.\n       evaluate_net\n        (insert_weights s m2\n          (if s then \\<lambda>i. f (i + a)\n           else (\\<lambda>i. f (i + count_weights s m1 + a))))\n        (drop\n          (length\n            (input_sizes (insert_weights s m1 (\\<lambda>i. f (i + a)))))\n          inputs) $\n       j)\n\ngoal (1 subgoal):\n 1. polyfun\n     {..<a +\n         (if s then max (count_weights s m1) (count_weights s m2)\n          else count_weights s m1 + count_weights s m2)}\n     (\\<lambda>x.\n         evaluate_net\n          (insert_weights s m2\n            (if s then \\<lambda>i. x (i + a)\n             else (\\<lambda>i. x (i + count_weights s m1 + a))))\n          (drop\n            (length\n              (input_sizes (insert_weights s m1 (\\<lambda>i. x (i + a)))))\n            inputs) $\n         j)", "by (simp add:polyfun_subset[of \"{..<a + ((if s then 0 else count_weights s m1) + count_weights s m2)}\" \"{..<a + (if s then max (count_weights s m1) (count_weights s m2) else count_weights s m1 + count_weights s m2)}\"])"], ["proof (state)\nthis:\n  polyfun {..<a + count_weights s (Pool m1 m2)}\n   (\\<lambda>f.\n       evaluate_net (insert_weights s (Pool m1 m2) (\\<lambda>i. f (i + a)))\n        inputs $\n       j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma polyfun_evaluate_net:\nassumes \"map dim_vec inputs = input_sizes m\"\nassumes \"valid_net m\"\nassumes \"j < output_size m\"\nshows \"polyfun {..<count_weights s m} (\\<lambda>f. evaluate_net (insert_weights s m f) inputs $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun {..<count_weights s m}\n     (\\<lambda>f. evaluate_net (insert_weights s m f) inputs $ j)", "using polyfun_evaluate_net_plus_a[where a=0, OF assms]"], ["proof (prove)\nusing this:\n  polyfun {..<0 + count_weights ?s m}\n   (\\<lambda>f.\n       evaluate_net (insert_weights ?s m (\\<lambda>i. f (i + 0))) inputs $\n       j)\n\ngoal (1 subgoal):\n 1. polyfun {..<count_weights s m}\n     (\\<lambda>f. evaluate_net (insert_weights s m f) inputs $ j)", "by simp"], ["", "lemma polyfun_tensors_from_net:\nassumes \"valid_net m\"\nassumes \"is \\<lhd> input_sizes m\"\nassumes \"j < output_size m\"\nshows \"polyfun {..<count_weights s m} (\\<lambda>f. Tensor.lookup (tensors_from_net (insert_weights s m f) $ j) is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun {..<count_weights s m}\n     (\\<lambda>f.\n         Tensor.lookup (tensors_from_net (insert_weights s m f) $ j) is)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. polyfun {..<count_weights s m}\n     (\\<lambda>f.\n         Tensor.lookup (tensors_from_net (insert_weights s m f) $ j) is)", "have 1:\"\\<And>f. valid_net' (insert_weights s m f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. valid_net' (insert_weights s m f)", "by (simp add: assms(1) remove_insert_weights)"], ["proof (state)\nthis:\n  valid_net' (insert_weights s m ?f)\n\ngoal (1 subgoal):\n 1. polyfun {..<count_weights s m}\n     (\\<lambda>f.\n         Tensor.lookup (tensors_from_net (insert_weights s m f) $ j) is)", "have input_sizes:\"\\<And>f. input_sizes (insert_weights s m f) = input_sizes m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. input_sizes (insert_weights s m f) = input_sizes m", "unfolding input_sizes_remove_weights"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       input_sizes (remove_weights (insert_weights s m f)) = input_sizes m", "by (simp add: remove_insert_weights)"], ["proof (state)\nthis:\n  input_sizes (insert_weights s m ?f) = input_sizes m\n\ngoal (1 subgoal):\n 1. polyfun {..<count_weights s m}\n     (\\<lambda>f.\n         Tensor.lookup (tensors_from_net (insert_weights s m f) $ j) is)", "have 2:\"\\<And>f. is \\<lhd> input_sizes (insert_weights s m f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. is \\<lhd> input_sizes (insert_weights s m f)", "unfolding input_sizes"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. is \\<lhd> input_sizes m", "using assms(2)"], ["proof (prove)\nusing this:\n  is \\<lhd> input_sizes m\n\ngoal (1 subgoal):\n 1. \\<And>f. is \\<lhd> input_sizes m", "by blast"], ["proof (state)\nthis:\n  is \\<lhd> input_sizes (insert_weights s m ?f)\n\ngoal (1 subgoal):\n 1. polyfun {..<count_weights s m}\n     (\\<lambda>f.\n         Tensor.lookup (tensors_from_net (insert_weights s m f) $ j) is)", "have 3:\"\\<And>f. j < output_size' (insert_weights s m f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. j < output_size' (insert_weights s m f)", "by (simp add: assms(3) remove_insert_weights)"], ["proof (state)\nthis:\n  j < output_size' (insert_weights s m ?f)\n\ngoal (1 subgoal):\n 1. polyfun {..<count_weights s m}\n     (\\<lambda>f.\n         Tensor.lookup (tensors_from_net (insert_weights s m f) $ j) is)", "have \"\\<And>f1 f2. base_input (insert_weights s m f1) is = base_input (insert_weights s m f2) is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f1 f2.\n       base_input (insert_weights s m f1) is =\n       base_input (insert_weights s m f2) is", "unfolding base_input_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f1 f2.\n       map2 unit\\<^sub>v (input_sizes (insert_weights s m f1)) is =\n       map2 unit\\<^sub>v (input_sizes (insert_weights s m f2)) is", "by (simp add: input_sizes)"], ["proof (state)\nthis:\n  base_input (insert_weights s m ?f1.0) is =\n  base_input (insert_weights s m ?f2.0) is\n\ngoal (1 subgoal):\n 1. polyfun {..<count_weights s m}\n     (\\<lambda>f.\n         Tensor.lookup (tensors_from_net (insert_weights s m f) $ j) is)", "then"], ["proof (chain)\npicking this:\n  base_input (insert_weights s m ?f1.0) is =\n  base_input (insert_weights s m ?f2.0) is", "have \"\\<And>xf. (\\<lambda>f. evaluate_net (insert_weights s m f) (base_input (insert_weights s m xf) is) $ j)\n    = (\\<lambda>f. evaluate_net (insert_weights s m f) (base_input (insert_weights s m f) is) $ j)\""], ["proof (prove)\nusing this:\n  base_input (insert_weights s m ?f1.0) is =\n  base_input (insert_weights s m ?f2.0) is\n\ngoal (1 subgoal):\n 1. \\<And>xf.\n       (\\<lambda>f.\n           evaluate_net (insert_weights s m f)\n            (base_input (insert_weights s m xf) is) $\n           j) =\n       (\\<lambda>f.\n           evaluate_net (insert_weights s m f)\n            (base_input (insert_weights s m f) is) $\n           j)", "by metis"], ["proof (state)\nthis:\n  (\\<lambda>f.\n      evaluate_net (insert_weights s m f)\n       (base_input (insert_weights s m ?xf) is) $\n      j) =\n  (\\<lambda>f.\n      evaluate_net (insert_weights s m f)\n       (base_input (insert_weights s m f) is) $\n      j)\n\ngoal (1 subgoal):\n 1. polyfun {..<count_weights s m}\n     (\\<lambda>f.\n         Tensor.lookup (tensors_from_net (insert_weights s m f) $ j) is)", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>f.\n      evaluate_net (insert_weights s m f)\n       (base_input (insert_weights s m ?xf) is) $\n      j) =\n  (\\<lambda>f.\n      evaluate_net (insert_weights s m f)\n       (base_input (insert_weights s m f) is) $\n      j)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>f.\n      evaluate_net (insert_weights s m f)\n       (base_input (insert_weights s m ?xf) is) $\n      j) =\n  (\\<lambda>f.\n      evaluate_net (insert_weights s m f)\n       (base_input (insert_weights s m f) is) $\n      j)\n\ngoal (1 subgoal):\n 1. polyfun {..<count_weights s m}\n     (\\<lambda>f.\n         Tensor.lookup (tensors_from_net (insert_weights s m f) $ j) is)", "unfolding lookup_tensors_from_net[OF 1 2 3]"], ["proof (prove)\nusing this:\n  (\\<lambda>f.\n      evaluate_net (insert_weights s m f)\n       (base_input (insert_weights s m ?xf) is) $\n      j) =\n  (\\<lambda>f.\n      evaluate_net (insert_weights s m f)\n       (base_input (insert_weights s m f) is) $\n      j)\n\ngoal (1 subgoal):\n 1. polyfun {..<count_weights s m}\n     (\\<lambda>f.\n         evaluate_net (insert_weights s m f)\n          (base_input (insert_weights s m f) is) $\n         j)", "using polyfun_evaluate_net[OF base_input_length[OF 2, unfolded input_sizes, symmetric] assms(1) assms(3), of s]"], ["proof (prove)\nusing this:\n  (\\<lambda>f.\n      evaluate_net (insert_weights s m f)\n       (base_input (insert_weights s m ?xf) is) $\n      j) =\n  (\\<lambda>f.\n      evaluate_net (insert_weights s m f)\n       (base_input (insert_weights s m f) is) $\n      j)\n  polyfun {..<count_weights s m}\n   (\\<lambda>f.\n       evaluate_net (insert_weights s m f)\n        (base_input (insert_weights s m ?f1) is) $\n       j)\n\ngoal (1 subgoal):\n 1. polyfun {..<count_weights s m}\n     (\\<lambda>f.\n         evaluate_net (insert_weights s m f)\n          (base_input (insert_weights s m f) is) $\n         j)", "by simp"], ["proof (state)\nthis:\n  polyfun {..<count_weights s m}\n   (\\<lambda>f.\n       Tensor.lookup (tensors_from_net (insert_weights s m f) $ j) is)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma polyfun_matricize:\nassumes \"\\<And>x. dims (T x) = ds\"\nassumes \"\\<And>is. is \\<lhd> ds \\<Longrightarrow> polyfun N (\\<lambda>x. Tensor.lookup (T x) is)\"\nassumes \"\\<And>x. dim_row (matricize I (T x)) = nr\"\nassumes \"\\<And>x. dim_col (matricize I (T x)) = nc\"\nassumes \"i < nr\"\nassumes \"j < nc\"\nshows \"polyfun N (\\<lambda>x. matricize I (T x) $$ (i,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. matricize I (T x) $$ (i, j))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. matricize I (T x) $$ (i, j))", "let ?weave = \"\\<lambda> x. (weave I\n    (digit_encode (nths ds I ) i)\n    (digit_encode (nths ds (-I )) j))\""], ["proof (state)\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. matricize I (T x) $$ (i, j))", "have 1:\"\\<And>x. matricize I (T x) $$ (i,j) = Tensor.lookup (T x) (?weave x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       matricize I (T x) $$ (i, j) =\n       Tensor.lookup (T x)\n        (weave I (digit_encode (nths ds I) i)\n          (digit_encode (nths ds (- I)) j))", "unfolding matricize_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mat (prod_list (nths (dims (T x)) I))\n        (prod_list (nths (dims (T x)) (- I)))\n        (\\<lambda>(r, c).\n            Tensor.lookup (T x)\n             (weave I (digit_encode (nths (dims (T x)) I) r)\n               (digit_encode (nths (dims (T x)) (- I)) c))) $$\n       (i, j) =\n       Tensor.lookup (T x)\n        (weave I (digit_encode (nths ds I) i)\n          (digit_encode (nths ds (- I)) j))", "by (metis (no_types, lifting) assms(1) assms(3) assms(4) assms(5) assms(6) case_prod_conv\n    dim_col_mat(1) dim_row_mat(1) index_mat(1) matricize_def)"], ["proof (state)\nthis:\n  matricize I (T ?x1) $$ (i, j) =\n  Tensor.lookup (T ?x1)\n   (weave I (digit_encode (nths ds I) i) (digit_encode (nths ds (- I)) j))\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. matricize I (T x) $$ (i, j))", "have \"\\<And>x. ?weave x \\<lhd> ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       weave I (digit_encode (nths ds I) i)\n        (digit_encode (nths ds (- I)) j) \\<lhd>\n       ds", "using valid_index_weave(1) assms(2) digit_encode_valid_index dim_row_mat(1) matricize_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?is1.0 \\<lhd> nths ?ds ?A; ?is2.0 \\<lhd> nths ?ds (- ?A)\\<rbrakk>\n  \\<Longrightarrow> weave ?A ?is1.0 ?is2.0 \\<lhd> ?ds\n  ?is \\<lhd> ds \\<Longrightarrow>\n  polyfun N (\\<lambda>x. Tensor.lookup (T x) ?is)\n  ?a < prod_list ?ds \\<Longrightarrow> digit_encode ?ds ?a \\<lhd> ?ds\n  dim_row (mat ?nr ?nc ?f) = ?nr\n  matricize ?rmodes ?T =\n  mat (prod_list (nths (dims ?T) ?rmodes))\n   (prod_list (nths (dims ?T) (- ?rmodes)))\n   (\\<lambda>(r, c).\n       Tensor.lookup ?T\n        (weave ?rmodes (digit_encode (nths (dims ?T) ?rmodes) r)\n          (digit_encode (nths (dims ?T) (- ?rmodes)) c)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       weave I (digit_encode (nths ds I) i)\n        (digit_encode (nths ds (- I)) j) \\<lhd>\n       ds", "using assms digit_encode_valid_index matricize_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?is1.0 \\<lhd> nths ?ds ?A; ?is2.0 \\<lhd> nths ?ds (- ?A)\\<rbrakk>\n  \\<Longrightarrow> weave ?A ?is1.0 ?is2.0 \\<lhd> ?ds\n  ?is \\<lhd> ds \\<Longrightarrow>\n  polyfun N (\\<lambda>x. Tensor.lookup (T x) ?is)\n  ?a < prod_list ?ds \\<Longrightarrow> digit_encode ?ds ?a \\<lhd> ?ds\n  dim_row (mat ?nr ?nc ?f) = ?nr\n  matricize ?rmodes ?T =\n  mat (prod_list (nths (dims ?T) ?rmodes))\n   (prod_list (nths (dims ?T) (- ?rmodes)))\n   (\\<lambda>(r, c).\n       Tensor.lookup ?T\n        (weave ?rmodes (digit_encode (nths (dims ?T) ?rmodes) r)\n          (digit_encode (nths (dims ?T) (- ?rmodes)) c)))\n  dims (T ?x) = ds\n  ?is \\<lhd> ds \\<Longrightarrow>\n  polyfun N (\\<lambda>x. Tensor.lookup (T x) ?is)\n  dim_row (matricize I (T ?x)) = nr\n  dim_col (matricize I (T ?x)) = nc\n  i < nr\n  j < nc\n  ?a < prod_list ?ds \\<Longrightarrow> digit_encode ?ds ?a \\<lhd> ?ds\n  matricize ?rmodes ?T =\n  mat (prod_list (nths (dims ?T) ?rmodes))\n   (prod_list (nths (dims ?T) (- ?rmodes)))\n   (\\<lambda>(r, c).\n       Tensor.lookup ?T\n        (weave ?rmodes (digit_encode (nths (dims ?T) ?rmodes) r)\n          (digit_encode (nths (dims ?T) (- ?rmodes)) c)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       weave I (digit_encode (nths ds I) i)\n        (digit_encode (nths ds (- I)) j) \\<lhd>\n       ds", "by (metis dim_col_mat(1))"], ["proof (state)\nthis:\n  weave I (digit_encode (nths ds I) i)\n   (digit_encode (nths ds (- I)) j) \\<lhd>\n  ds\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. matricize I (T x) $$ (i, j))", "then"], ["proof (chain)\npicking this:\n  weave I (digit_encode (nths ds I) i)\n   (digit_encode (nths ds (- I)) j) \\<lhd>\n  ds", "have \"polyfun N (\\<lambda>x. Tensor.lookup (T x) (?weave x))\""], ["proof (prove)\nusing this:\n  weave I (digit_encode (nths ds I) i)\n   (digit_encode (nths ds (- I)) j) \\<lhd>\n  ds\n\ngoal (1 subgoal):\n 1. polyfun N\n     (\\<lambda>x.\n         Tensor.lookup (T x)\n          (weave I (digit_encode (nths ds I) i)\n            (digit_encode (nths ds (- I)) j)))", "using assms(2)"], ["proof (prove)\nusing this:\n  weave I (digit_encode (nths ds I) i)\n   (digit_encode (nths ds (- I)) j) \\<lhd>\n  ds\n  ?is \\<lhd> ds \\<Longrightarrow>\n  polyfun N (\\<lambda>x. Tensor.lookup (T x) ?is)\n\ngoal (1 subgoal):\n 1. polyfun N\n     (\\<lambda>x.\n         Tensor.lookup (T x)\n          (weave I (digit_encode (nths ds I) i)\n            (digit_encode (nths ds (- I)) j)))", "by simp"], ["proof (state)\nthis:\n  polyfun N\n   (\\<lambda>x.\n       Tensor.lookup (T x)\n        (weave I (digit_encode (nths ds I) i)\n          (digit_encode (nths ds (- I)) j)))\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. matricize I (T x) $$ (i, j))", "then"], ["proof (chain)\npicking this:\n  polyfun N\n   (\\<lambda>x.\n       Tensor.lookup (T x)\n        (weave I (digit_encode (nths ds I) i)\n          (digit_encode (nths ds (- I)) j)))", "show ?thesis"], ["proof (prove)\nusing this:\n  polyfun N\n   (\\<lambda>x.\n       Tensor.lookup (T x)\n        (weave I (digit_encode (nths ds I) i)\n          (digit_encode (nths ds (- I)) j)))\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. matricize I (T x) $$ (i, j))", "unfolding 1"], ["proof (prove)\nusing this:\n  polyfun N\n   (\\<lambda>x.\n       Tensor.lookup (T x)\n        (weave I (digit_encode (nths ds I) i)\n          (digit_encode (nths ds (- I)) j)))\n\ngoal (1 subgoal):\n 1. polyfun N\n     (\\<lambda>x.\n         Tensor.lookup (T x)\n          (weave I (digit_encode (nths ds I) i)\n            (digit_encode (nths ds (- I)) j)))", "using assms(1)"], ["proof (prove)\nusing this:\n  polyfun N\n   (\\<lambda>x.\n       Tensor.lookup (T x)\n        (weave I (digit_encode (nths ds I) i)\n          (digit_encode (nths ds (- I)) j)))\n  dims (T ?x) = ds\n\ngoal (1 subgoal):\n 1. polyfun N\n     (\\<lambda>x.\n         Tensor.lookup (T x)\n          (weave I (digit_encode (nths ds I) i)\n            (digit_encode (nths ds (- I)) j)))", "by blast"], ["proof (state)\nthis:\n  polyfun N (\\<lambda>x. matricize I (T x) $$ (i, j))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \"(\\<not> (a::nat) < b) = (a \\<ge> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> a < b) = (b \\<le> a)", "by (metis not_le)"], ["", "lemma polyfun_submatrix:\nassumes \"\\<And>x. (A x) \\<in> carrier_mat m n\"\nassumes \"\\<And>x i j. i<m \\<Longrightarrow> j<n \\<Longrightarrow> polyfun N (\\<lambda>x. (A x) $$ (i,j))\"\nassumes \"i < card {i. i < m \\<and> i \\<in> I}\"\nassumes \"j < card {j. j < n \\<and> j \\<in> J}\"\nassumes \"infinite I\" \"infinite J\"\nshows \"polyfun N (\\<lambda>x. (submatrix (A x) I J) $$ (i,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. submatrix (A x) I J $$ (i, j))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. submatrix (A x) I J $$ (i, j))", "have 1:\"\\<And>x. (submatrix (A x) I J) $$ (i,j) = (A x) $$ (pick I i, pick J j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. submatrix (A x) I J $$ (i, j) = A x $$ (pick I i, pick J j)", "using submatrix_index"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < card {i. i < dim_row ?A \\<and> i \\<in> ?I};\n   ?j < card {j. j < dim_col ?A \\<and> j \\<in> ?J}\\<rbrakk>\n  \\<Longrightarrow> submatrix ?A ?I ?J $$ (?i, ?j) =\n                    ?A $$ (pick ?I ?i, pick ?J ?j)\n\ngoal (1 subgoal):\n 1. \\<And>x. submatrix (A x) I J $$ (i, j) = A x $$ (pick I i, pick J j)", "by (metis (no_types, lifting) Collect_cong assms(1) assms(3) assms(4) carrier_matD(1) carrier_matD(2))"], ["proof (state)\nthis:\n  submatrix (A ?x) I J $$ (i, j) = A ?x $$ (pick I i, pick J j)\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. submatrix (A x) I J $$ (i, j))", "have \"pick I i < m\"  \"pick J j < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pick I i < m &&& pick J j < n", "using card_le_pick_inf[OF \\<open>infinite I\\<close>] card_le_pick_inf[OF \\<open>infinite J\\<close>]\n    \\<open>i < card {i. i < m \\<and> i \\<in> I}\\<close>[unfolded set_le_in] \\<open>j < card {j. j < n \\<and> j \\<in> J}\\<close>[unfolded set_le_in] not_less"], ["proof (prove)\nusing this:\n  ?i \\<le> pick I ?n \\<Longrightarrow> card {a \\<in> I. a < ?i} \\<le> ?n\n  ?i \\<le> pick J ?n \\<Longrightarrow> card {a \\<in> J. a < ?i} \\<le> ?n\n  i < card {i \\<in> I. i < m}\n  j < card {j \\<in> J. j < n}\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. pick I i < m &&& pick J j < n", "by metis+"], ["proof (state)\nthis:\n  pick I i < m\n  pick J j < n\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. submatrix (A x) I J $$ (i, j))", "then"], ["proof (chain)\npicking this:\n  pick I i < m\n  pick J j < n", "show ?thesis"], ["proof (prove)\nusing this:\n  pick I i < m\n  pick J j < n\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. submatrix (A x) I J $$ (i, j))", "unfolding 1"], ["proof (prove)\nusing this:\n  pick I i < m\n  pick J j < n\n\ngoal (1 subgoal):\n 1. polyfun N (\\<lambda>x. A x $$ (pick I i, pick J j))", "by (simp add: assms(2))"], ["proof (state)\nthis:\n  polyfun N (\\<lambda>x. submatrix (A x) I J $$ (i, j))\n\ngoal:\nNo subgoals!", "qed"], ["", "context deep_model_correct_params_y\nbegin"], ["", "definition witness_submatrix where\n\"witness_submatrix f = submatrix (A' f) rows_with_1 rows_with_1\""], ["", "lemma polyfun_tensor_deep_model:\nassumes \"is \\<lhd> input_sizes (deep_model_l rs)\"\nshows \"polyfun {..<weight_space_dim}\n  (\\<lambda>f. Tensor.lookup (tensors_from_net (insert_weights shared_weights (deep_model_l rs) f) $ y) is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun {..<weight_space_dim}\n     (\\<lambda>f.\n         Tensor.lookup\n          (tensors_from_net\n            (insert_weights shared_weights (deep_model_l rs) f) $\n           y)\n          is)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. polyfun {..<weight_space_dim}\n     (\\<lambda>f.\n         Tensor.lookup\n          (tensors_from_net\n            (insert_weights shared_weights (deep_model_l rs) f) $\n           y)\n          is)", "have 1:\"\\<And>f. remove_weights (insert_weights shared_weights (deep_model_l rs) f) = deep_model_l rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       remove_weights (insert_weights shared_weights (deep_model_l rs) f) =\n       deep_model_l rs", "using remove_insert_weights"], ["proof (prove)\nusing this:\n  remove_weights (insert_weights ?s ?m ?w) = ?m\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       remove_weights (insert_weights shared_weights (deep_model_l rs) f) =\n       deep_model_l rs", "by metis"], ["proof (state)\nthis:\n  remove_weights (insert_weights shared_weights (deep_model_l rs) ?f1) =\n  deep_model_l rs\n\ngoal (1 subgoal):\n 1. polyfun {..<weight_space_dim}\n     (\\<lambda>f.\n         Tensor.lookup\n          (tensors_from_net\n            (insert_weights shared_weights (deep_model_l rs) f) $\n           y)\n          is)", "then"], ["proof (chain)\npicking this:\n  remove_weights (insert_weights shared_weights (deep_model_l rs) ?f1) =\n  deep_model_l rs", "have \"y < output_size ( deep_model_l rs)\""], ["proof (prove)\nusing this:\n  remove_weights (insert_weights shared_weights (deep_model_l rs) ?f1) =\n  deep_model_l rs\n\ngoal (1 subgoal):\n 1. y < output_size (deep_model_l rs)", "using valid_deep_model y_valid length_output_deep_model"], ["proof (prove)\nusing this:\n  remove_weights (insert_weights shared_weights (deep_model_l rs) ?f1) =\n  deep_model_l rs\n  valid_net (deep_model ?Y ?r ?rs)\n  y < rs ! 0\n  remove_weights ?m = deep_model_l ?rs \\<Longrightarrow>\n  dim_vec (tensors_from_net ?m) = ?rs ! 0\n\ngoal (1 subgoal):\n 1. y < output_size (deep_model_l rs)", "by force"], ["proof (state)\nthis:\n  y < output_size (deep_model_l rs)\n\ngoal (1 subgoal):\n 1. polyfun {..<weight_space_dim}\n     (\\<lambda>f.\n         Tensor.lookup\n          (tensors_from_net\n            (insert_weights shared_weights (deep_model_l rs) f) $\n           y)\n          is)", "have 0:\"{..<weight_space_dim} = set [0..<weight_space_dim]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..<weight_space_dim} = set [0..<weight_space_dim]", "by auto"], ["proof (state)\nthis:\n  {..<weight_space_dim} = set [0..<weight_space_dim]\n\ngoal (1 subgoal):\n 1. polyfun {..<weight_space_dim}\n     (\\<lambda>f.\n         Tensor.lookup\n          (tensors_from_net\n            (insert_weights shared_weights (deep_model_l rs) f) $\n           y)\n          is)", "then"], ["proof (chain)\npicking this:\n  {..<weight_space_dim} = set [0..<weight_space_dim]", "show ?thesis"], ["proof (prove)\nusing this:\n  {..<weight_space_dim} = set [0..<weight_space_dim]\n\ngoal (1 subgoal):\n 1. polyfun {..<weight_space_dim}\n     (\\<lambda>f.\n         Tensor.lookup\n          (tensors_from_net\n            (insert_weights shared_weights (deep_model_l rs) f) $\n           y)\n          is)", "unfolding weight_space_dim_def"], ["proof (prove)\nusing this:\n  {..<count_weights shared_weights (deep_model_l rs)} =\n  set [0..<count_weights shared_weights (deep_model_l rs)]\n\ngoal (1 subgoal):\n 1. polyfun {..<count_weights shared_weights (deep_model_l rs)}\n     (\\<lambda>f.\n         Tensor.lookup\n          (tensors_from_net\n            (insert_weights shared_weights (deep_model_l rs) f) $\n           y)\n          is)", "using polyfun_tensors_from_net assms(1) valid_deep_model\n    \\<open>y < output_size ( deep_model_l rs )\\<close>"], ["proof (prove)\nusing this:\n  {..<count_weights shared_weights (deep_model_l rs)} =\n  set [0..<count_weights shared_weights (deep_model_l rs)]\n  \\<lbrakk>valid_net ?m; ?is \\<lhd> input_sizes ?m;\n   ?j < output_size ?m\\<rbrakk>\n  \\<Longrightarrow> polyfun {..<count_weights ?s ?m}\n                     (\\<lambda>f.\n                         Tensor.lookup\n                          (tensors_from_net (insert_weights ?s ?m f) $ ?j)\n                          ?is)\n  is \\<lhd> input_sizes (deep_model_l rs)\n  valid_net (deep_model ?Y ?r ?rs)\n  y < output_size (deep_model_l rs)\n\ngoal (1 subgoal):\n 1. polyfun {..<count_weights shared_weights (deep_model_l rs)}\n     (\\<lambda>f.\n         Tensor.lookup\n          (tensors_from_net\n            (insert_weights shared_weights (deep_model_l rs) f) $\n           y)\n          is)", "by metis"], ["proof (state)\nthis:\n  polyfun {..<weight_space_dim}\n   (\\<lambda>f.\n       Tensor.lookup\n        (tensors_from_net\n          (insert_weights shared_weights (deep_model_l rs) f) $\n         y)\n        is)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma input_sizes_deep_model: \"input_sizes (deep_model_l rs) = replicate (2 * N_half) (last rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. input_sizes (deep_model_l rs) = replicate (2 * N_half) (last rs)", "unfolding N_half_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. input_sizes (deep_model_l rs) =\n    replicate (2 * 2 ^ (length rs - 3)) (last rs)", "using input_sizes_deep_model deep"], ["proof (prove)\nusing this:\n  2 \\<le> length ?rs \\<Longrightarrow>\n  input_sizes (deep_model_l ?rs) =\n  replicate (2 ^ (length ?rs - 2)) (last ?rs)\n  3 \\<le> length rs\n\ngoal (1 subgoal):\n 1. input_sizes (deep_model_l rs) =\n    replicate (2 * 2 ^ (length rs - 3)) (last rs)", "by (metis (no_types, lifting) Nitpick.size_list_simp(2) One_nat_def Suc_1 Suc_le_lessD diff_Suc_Suc length_tl less_imp_le_nat list.size(3) not_less_eq numeral_3_eq_3 power_eq_if)"], ["", "lemma polyfun_matrix_deep_model:\nassumes \"i<(last rs) ^ N_half\"\nassumes \"j<(last rs) ^ N_half\"\nshows \"polyfun {..<weight_space_dim} (\\<lambda>f. A' f $$ (i,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun {..<weight_space_dim} (\\<lambda>f. A' f $$ (i, j))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. polyfun {..<weight_space_dim} (\\<lambda>f. A' f $$ (i, j))", "have 0:\"y < output_size ( deep_model_l rs )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y < output_size (deep_model_l rs)", "using valid_deep_model y_valid length_output_deep_model"], ["proof (prove)\nusing this:\n  valid_net (deep_model ?Y ?r ?rs)\n  y < rs ! 0\n  remove_weights ?m = deep_model_l ?rs \\<Longrightarrow>\n  dim_vec (tensors_from_net ?m) = ?rs ! 0\n\ngoal (1 subgoal):\n 1. y < output_size (deep_model_l rs)", "by force"], ["proof (state)\nthis:\n  y < output_size (deep_model_l rs)\n\ngoal (1 subgoal):\n 1. polyfun {..<weight_space_dim} (\\<lambda>f. A' f $$ (i, j))", "have 1:\"\\<And>f. remove_weights (insert_weights shared_weights (deep_model_l rs) f) = deep_model_l rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       remove_weights (insert_weights shared_weights (deep_model_l rs) f) =\n       deep_model_l rs", "using remove_insert_weights"], ["proof (prove)\nusing this:\n  remove_weights (insert_weights ?s ?m ?w) = ?m\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       remove_weights (insert_weights shared_weights (deep_model_l rs) f) =\n       deep_model_l rs", "by metis"], ["proof (state)\nthis:\n  remove_weights (insert_weights shared_weights (deep_model_l rs) ?f1) =\n  deep_model_l rs\n\ngoal (1 subgoal):\n 1. polyfun {..<weight_space_dim} (\\<lambda>f. A' f $$ (i, j))", "have 2:\"(\\<And>f is. is \\<lhd> replicate (2 * N_half) (last rs) \\<Longrightarrow>\n         polyfun {..<weight_space_dim} (\\<lambda>x. Tensor.lookup (A x) is))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f is.\n       is \\<lhd> replicate (2 * N_half) (last rs) \\<Longrightarrow>\n       polyfun {..<weight_space_dim} (\\<lambda>x. Tensor.lookup (A x) is)", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f is.\n       is \\<lhd> replicate (2 * N_half) (last rs) \\<Longrightarrow>\n       polyfun {..<weight_space_dim}\n        (\\<lambda>x.\n            Tensor.lookup\n             (tensors_from_net\n               (insert_weights shared_weights (deep_model_l rs) x) $\n              y)\n             is)", "using polyfun_tensor_deep_model[unfolded input_sizes_deep_model] 0"], ["proof (prove)\nusing this:\n  ?is \\<lhd> replicate (2 * N_half) (last rs) \\<Longrightarrow>\n  polyfun {..<weight_space_dim}\n   (\\<lambda>f.\n       Tensor.lookup\n        (tensors_from_net\n          (insert_weights shared_weights (deep_model_l rs) f) $\n         y)\n        ?is)\n  y < output_size (deep_model_l rs)\n\ngoal (1 subgoal):\n 1. \\<And>f is.\n       is \\<lhd> replicate (2 * N_half) (last rs) \\<Longrightarrow>\n       polyfun {..<weight_space_dim}\n        (\\<lambda>x.\n            Tensor.lookup\n             (tensors_from_net\n               (insert_weights shared_weights (deep_model_l rs) x) $\n              y)\n             is)", "by blast"], ["proof (state)\nthis:\n  ?is1 \\<lhd> replicate (2 * N_half) (last rs) \\<Longrightarrow>\n  polyfun {..<weight_space_dim} (\\<lambda>x. Tensor.lookup (A x) ?is1)\n\ngoal (1 subgoal):\n 1. polyfun {..<weight_space_dim} (\\<lambda>f. A' f $$ (i, j))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun {..<weight_space_dim} (\\<lambda>f. A' f $$ (i, j))", "unfolding A'_def A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun {..<weight_space_dim}\n     (\\<lambda>f.\n         ten2mat\n          (tensors_from_net\n            (insert_weights shared_weights (deep_model_l rs) f) $\n           y) $$\n         (i, j))", "apply (rule polyfun_matricize)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>f.\n       dims\n        (tensors_from_net\n          (insert_weights shared_weights (deep_model_l rs) f) $\n         y) =\n       ?ds\n 2. \\<And>is.\n       is \\<lhd> ?ds \\<Longrightarrow>\n       polyfun {..<weight_space_dim}\n        (\\<lambda>f.\n            Tensor.lookup\n             (tensors_from_net\n               (insert_weights shared_weights (deep_model_l rs) f) $\n              y)\n             is)\n 3. \\<And>f.\n       dim_row\n        (ten2mat\n          (tensors_from_net\n            (insert_weights shared_weights (deep_model_l rs) f) $\n           y)) =\n       ?nr\n 4. \\<And>f.\n       dim_col\n        (ten2mat\n          (tensors_from_net\n            (insert_weights shared_weights (deep_model_l rs) f) $\n           y)) =\n       ?nc\n 5. i < ?nr\n 6. j < ?nc", "using dims_tensor_deep_model[OF 1] 2[unfolded A_def]"], ["proof (prove)\nusing this:\n  dims\n   (tensors_from_net (insert_weights shared_weights (deep_model_l rs) ?f2) $\n    y) =\n  replicate (2 * N_half) (last rs)\n  ?is1 \\<lhd> replicate (2 * N_half) (last rs) \\<Longrightarrow>\n  polyfun {..<weight_space_dim}\n   (\\<lambda>x.\n       Tensor.lookup\n        (tensors_from_net\n          (insert_weights shared_weights (deep_model_l rs) x) $\n         y)\n        ?is1)\n\ngoal (6 subgoals):\n 1. \\<And>f.\n       dims\n        (tensors_from_net\n          (insert_weights shared_weights (deep_model_l rs) f) $\n         y) =\n       ?ds\n 2. \\<And>is.\n       is \\<lhd> ?ds \\<Longrightarrow>\n       polyfun {..<weight_space_dim}\n        (\\<lambda>f.\n            Tensor.lookup\n             (tensors_from_net\n               (insert_weights shared_weights (deep_model_l rs) f) $\n              y)\n             is)\n 3. \\<And>f.\n       dim_row\n        (ten2mat\n          (tensors_from_net\n            (insert_weights shared_weights (deep_model_l rs) f) $\n           y)) =\n       ?nr\n 4. \\<And>f.\n       dim_col\n        (ten2mat\n          (tensors_from_net\n            (insert_weights shared_weights (deep_model_l rs) f) $\n           y)) =\n       ?nc\n 5. i < ?nr\n 6. j < ?nc", "using dims_A'_pow[unfolded A'_def A_def] \\<open>i<(last rs) ^ N_half\\<close> \\<open>j<(last rs) ^ N_half\\<close>"], ["proof (prove)\nusing this:\n  dims\n   (tensors_from_net (insert_weights shared_weights (deep_model_l rs) ?f2) $\n    y) =\n  replicate (2 * N_half) (last rs)\n  ?is1 \\<lhd> replicate (2 * N_half) (last rs) \\<Longrightarrow>\n  polyfun {..<weight_space_dim}\n   (\\<lambda>x.\n       Tensor.lookup\n        (tensors_from_net\n          (insert_weights shared_weights (deep_model_l rs) x) $\n         y)\n        ?is1)\n  dim_row\n   (ten2mat\n     (tensors_from_net\n       (insert_weights shared_weights (deep_model_l rs) ?ws) $\n      y)) =\n  last rs ^ N_half\n  dim_col\n   (ten2mat\n     (tensors_from_net\n       (insert_weights shared_weights (deep_model_l rs) ?ws) $\n      y)) =\n  last rs ^ N_half\n  i < last rs ^ N_half\n  j < last rs ^ N_half\n\ngoal (6 subgoals):\n 1. \\<And>f.\n       dims\n        (tensors_from_net\n          (insert_weights shared_weights (deep_model_l rs) f) $\n         y) =\n       ?ds\n 2. \\<And>is.\n       is \\<lhd> ?ds \\<Longrightarrow>\n       polyfun {..<weight_space_dim}\n        (\\<lambda>f.\n            Tensor.lookup\n             (tensors_from_net\n               (insert_weights shared_weights (deep_model_l rs) f) $\n              y)\n             is)\n 3. \\<And>f.\n       dim_row\n        (ten2mat\n          (tensors_from_net\n            (insert_weights shared_weights (deep_model_l rs) f) $\n           y)) =\n       ?nr\n 4. \\<And>f.\n       dim_col\n        (ten2mat\n          (tensors_from_net\n            (insert_weights shared_weights (deep_model_l rs) f) $\n           y)) =\n       ?nc\n 5. i < ?nr\n 6. j < ?nc", "by auto"], ["proof (state)\nthis:\n  polyfun {..<weight_space_dim} (\\<lambda>f. A' f $$ (i, j))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma polyfun_submatrix_deep_model:\nassumes \"i < r ^ N_half\"\nassumes \"j < r ^ N_half\"\nshows \"polyfun {..<weight_space_dim} (\\<lambda>f. witness_submatrix f $$ (i,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun {..<weight_space_dim}\n     (\\<lambda>f. witness_submatrix f $$ (i, j))", "unfolding witness_submatrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun {..<weight_space_dim}\n     (\\<lambda>f. submatrix (A' f) rows_with_1 rows_with_1 $$ (i, j))", "proof (rule polyfun_submatrix)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>f. A' f \\<in> carrier_mat ?m ?n\n 2. \\<And>f i j.\n       \\<lbrakk>i < ?m; j < ?n\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<weight_space_dim}\n                          (\\<lambda>f. A' f $$ (i, j))\n 3. i < card {i. i < ?m \\<and> i \\<in> rows_with_1}\n 4. j < card {j. j < ?n \\<and> j \\<in> rows_with_1}\n 5. infinite rows_with_1\n 6. infinite rows_with_1", "have 1:\"\\<And>f. remove_weights (insert_weights shared_weights (deep_model_l rs) f) = deep_model_l rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       remove_weights (insert_weights shared_weights (deep_model_l rs) f) =\n       deep_model_l rs", "using remove_insert_weights"], ["proof (prove)\nusing this:\n  remove_weights (insert_weights ?s ?m ?w) = ?m\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       remove_weights (insert_weights shared_weights (deep_model_l rs) f) =\n       deep_model_l rs", "by metis"], ["proof (state)\nthis:\n  remove_weights (insert_weights shared_weights (deep_model_l rs) ?f1) =\n  deep_model_l rs\n\ngoal (6 subgoals):\n 1. \\<And>f. A' f \\<in> carrier_mat ?m ?n\n 2. \\<And>f i j.\n       \\<lbrakk>i < ?m; j < ?n\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<weight_space_dim}\n                          (\\<lambda>f. A' f $$ (i, j))\n 3. i < card {i. i < ?m \\<and> i \\<in> rows_with_1}\n 4. j < card {j. j < ?n \\<and> j \\<in> rows_with_1}\n 5. infinite rows_with_1\n 6. infinite rows_with_1", "show \"\\<And>f. A' f \\<in> carrier_mat ((last rs) ^ N_half) ((last rs) ^ N_half)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. A' f \\<in> carrier_mat (last rs ^ N_half) (last rs ^ N_half)", "using \"1\" dims_A'_pow"], ["proof (prove)\nusing this:\n  remove_weights (insert_weights shared_weights (deep_model_l rs) ?f1) =\n  deep_model_l rs\n  dim_row (A' ?ws) = last rs ^ N_half\n  dim_col (A' ?ws) = last rs ^ N_half\n\ngoal (1 subgoal):\n 1. \\<And>f. A' f \\<in> carrier_mat (last rs ^ N_half) (last rs ^ N_half)", "using weight_space_dim_def"], ["proof (prove)\nusing this:\n  remove_weights (insert_weights shared_weights (deep_model_l rs) ?f1) =\n  deep_model_l rs\n  dim_row (A' ?ws) = last rs ^ N_half\n  dim_col (A' ?ws) = last rs ^ N_half\n  weight_space_dim = count_weights shared_weights (deep_model_l rs)\n\ngoal (1 subgoal):\n 1. \\<And>f. A' f \\<in> carrier_mat (last rs ^ N_half) (last rs ^ N_half)", "by auto"], ["proof (state)\nthis:\n  A' ?f1 \\<in> carrier_mat (last rs ^ N_half) (last rs ^ N_half)\n\ngoal (5 subgoals):\n 1. \\<And>f i j.\n       \\<lbrakk>i < last rs ^ N_half; j < last rs ^ N_half\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<weight_space_dim}\n                          (\\<lambda>f. A' f $$ (i, j))\n 2. i < card {i. i < last rs ^ N_half \\<and> i \\<in> rows_with_1}\n 3. j < card {j. j < last rs ^ N_half \\<and> j \\<in> rows_with_1}\n 4. infinite rows_with_1\n 5. infinite rows_with_1", "show \"\\<And>f i j. i < last rs ^ N_half \\<Longrightarrow> j < last rs ^ N_half \\<Longrightarrow>\n        polyfun {..<weight_space_dim} (\\<lambda>f. A' f $$ (i, j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f i j.\n       \\<lbrakk>i < last rs ^ N_half; j < last rs ^ N_half\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<weight_space_dim}\n                          (\\<lambda>f. A' f $$ (i, j))", "using polyfun_matrix_deep_model weight_space_dim_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < last rs ^ N_half; ?j < last rs ^ N_half\\<rbrakk>\n  \\<Longrightarrow> polyfun {..<weight_space_dim}\n                     (\\<lambda>f. A' f $$ (?i, ?j))\n  weight_space_dim = count_weights shared_weights (deep_model_l rs)\n\ngoal (1 subgoal):\n 1. \\<And>f i j.\n       \\<lbrakk>i < last rs ^ N_half; j < last rs ^ N_half\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<weight_space_dim}\n                          (\\<lambda>f. A' f $$ (i, j))", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>?i1 < last rs ^ N_half; ?j1 < last rs ^ N_half\\<rbrakk>\n  \\<Longrightarrow> polyfun {..<weight_space_dim}\n                     (\\<lambda>f. A' f $$ (?i1, ?j1))\n\ngoal (4 subgoals):\n 1. i < card {i. i < last rs ^ N_half \\<and> i \\<in> rows_with_1}\n 2. j < card {j. j < last rs ^ N_half \\<and> j \\<in> rows_with_1}\n 3. infinite rows_with_1\n 4. infinite rows_with_1", "show \"i < card {i. i < last rs ^ N_half \\<and> i \\<in> rows_with_1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < card {i. i < last rs ^ N_half \\<and> i \\<in> rows_with_1}", "using assms(1) card_rows_with_1 dims_Aw'_pow set_le_in"], ["proof (prove)\nusing this:\n  i < r ^ N_half\n  card {i \\<in> rows_with_1. i < dim_row Aw'} = r ^ N_half\n  dim_row Aw' = last rs ^ N_half\n  dim_col Aw' = last rs ^ N_half\n  {a. a < ?n \\<and> a \\<in> ?I} = {a \\<in> ?I. a < ?n}\n\ngoal (1 subgoal):\n 1. i < card {i. i < last rs ^ N_half \\<and> i \\<in> rows_with_1}", "by metis"], ["proof (state)\nthis:\n  i < card {i. i < last rs ^ N_half \\<and> i \\<in> rows_with_1}\n\ngoal (3 subgoals):\n 1. j < card {j. j < last rs ^ N_half \\<and> j \\<in> rows_with_1}\n 2. infinite rows_with_1\n 3. infinite rows_with_1", "show \"j < card {i. i < last rs ^ N_half \\<and> i \\<in> rows_with_1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < card {i. i < last rs ^ N_half \\<and> i \\<in> rows_with_1}", "using assms(2) card_rows_with_1 dims_Aw'_pow set_le_in"], ["proof (prove)\nusing this:\n  j < r ^ N_half\n  card {i \\<in> rows_with_1. i < dim_row Aw'} = r ^ N_half\n  dim_row Aw' = last rs ^ N_half\n  dim_col Aw' = last rs ^ N_half\n  {a. a < ?n \\<and> a \\<in> ?I} = {a \\<in> ?I. a < ?n}\n\ngoal (1 subgoal):\n 1. j < card {i. i < last rs ^ N_half \\<and> i \\<in> rows_with_1}", "by metis"], ["proof (state)\nthis:\n  j < card {i. i < last rs ^ N_half \\<and> i \\<in> rows_with_1}\n\ngoal (2 subgoals):\n 1. infinite rows_with_1\n 2. infinite rows_with_1", "show \"infinite rows_with_1\" \"infinite rows_with_1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite rows_with_1 &&& infinite rows_with_1", "by (simp_all add: infinite_rows_with_1)"], ["proof (state)\nthis:\n  infinite rows_with_1\n  infinite rows_with_1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma polyfun_det_deep_model:\nshows \"polyfun {..<weight_space_dim} (\\<lambda>f. det (witness_submatrix f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polyfun {..<weight_space_dim} (\\<lambda>f. det (witness_submatrix f))", "proof (rule polyfun_det)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f. witness_submatrix f \\<in> carrier_mat ?n ?n\n 2. \\<And>f i j.\n       \\<lbrakk>i < ?n; j < ?n\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<weight_space_dim}\n                          (\\<lambda>f. witness_submatrix f $$ (i, j))", "fix f"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f. witness_submatrix f \\<in> carrier_mat ?n ?n\n 2. \\<And>f i j.\n       \\<lbrakk>i < ?n; j < ?n\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<weight_space_dim}\n                          (\\<lambda>f. witness_submatrix f $$ (i, j))", "have \"remove_weights (insert_weights shared_weights (deep_model_l rs) f) = deep_model_l rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_weights (insert_weights shared_weights (deep_model_l rs) f) =\n    deep_model_l rs", "using remove_insert_weights"], ["proof (prove)\nusing this:\n  remove_weights (insert_weights ?s ?m ?w) = ?m\n\ngoal (1 subgoal):\n 1. remove_weights (insert_weights shared_weights (deep_model_l rs) f) =\n    deep_model_l rs", "by metis"], ["proof (state)\nthis:\n  remove_weights (insert_weights shared_weights (deep_model_l rs) f) =\n  deep_model_l rs\n\ngoal (2 subgoals):\n 1. \\<And>f. witness_submatrix f \\<in> carrier_mat ?n ?n\n 2. \\<And>f i j.\n       \\<lbrakk>i < ?n; j < ?n\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<weight_space_dim}\n                          (\\<lambda>f. witness_submatrix f $$ (i, j))", "show \"witness_submatrix f \\<in> carrier_mat (r ^ N_half) (r ^ N_half)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. witness_submatrix f \\<in> carrier_mat (r ^ N_half) (r ^ N_half)", "unfolding witness_submatrix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. submatrix (A' f) rows_with_1 rows_with_1\n    \\<in> carrier_mat (r ^ N_half) (r ^ N_half)", "apply (rule carrier_matI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dim_row (submatrix (A' f) rows_with_1 rows_with_1) = r ^ N_half\n 2. dim_col (submatrix (A' f) rows_with_1 rows_with_1) = r ^ N_half", "unfolding dim_submatrix[unfolded set_le_in]"], ["proof (prove)\ngoal (2 subgoals):\n 1. card {i \\<in> rows_with_1. i < dim_row (A' f)} = r ^ N_half\n 2. card {j \\<in> rows_with_1. j < dim_col (A' f)} = r ^ N_half", "unfolding dims_A'_pow[unfolded weight_space_dim_def]"], ["proof (prove)\ngoal (2 subgoals):\n 1. card {i \\<in> rows_with_1. i < last rs ^ N_half} = r ^ N_half\n 2. card {j \\<in> rows_with_1. j < last rs ^ N_half} = r ^ N_half", "using card_rows_with_1 dims_Aw'_pow"], ["proof (prove)\nusing this:\n  card {i \\<in> rows_with_1. i < dim_row Aw'} = r ^ N_half\n  dim_row Aw' = last rs ^ N_half\n  dim_col Aw' = last rs ^ N_half\n\ngoal (2 subgoals):\n 1. card {i \\<in> rows_with_1. i < last rs ^ N_half} = r ^ N_half\n 2. card {j \\<in> rows_with_1. j < last rs ^ N_half} = r ^ N_half", "by simp_all"], ["proof (state)\nthis:\n  witness_submatrix f \\<in> carrier_mat (r ^ N_half) (r ^ N_half)\n\ngoal (1 subgoal):\n 1. \\<And>f i j.\n       \\<lbrakk>i < r ^ N_half; j < r ^ N_half\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<weight_space_dim}\n                          (\\<lambda>f. witness_submatrix f $$ (i, j))", "show \"\\<And>i j. i < r ^ N_half \\<Longrightarrow> j < r ^ N_half \\<Longrightarrow> polyfun {..<weight_space_dim} (\\<lambda>f. witness_submatrix f $$ (i, j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < r ^ N_half; j < r ^ N_half\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<weight_space_dim}\n                          (\\<lambda>f. witness_submatrix f $$ (i, j))", "using polyfun_submatrix_deep_model"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < r ^ N_half; ?j < r ^ N_half\\<rbrakk>\n  \\<Longrightarrow> polyfun {..<weight_space_dim}\n                     (\\<lambda>f. witness_submatrix f $$ (?i, ?j))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < r ^ N_half; j < r ^ N_half\\<rbrakk>\n       \\<Longrightarrow> polyfun {..<weight_space_dim}\n                          (\\<lambda>f. witness_submatrix f $$ (i, j))", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?i1 < r ^ N_half; ?j1 < r ^ N_half\\<rbrakk>\n  \\<Longrightarrow> polyfun {..<weight_space_dim}\n                     (\\<lambda>f. witness_submatrix f $$ (?i1, ?j1))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}