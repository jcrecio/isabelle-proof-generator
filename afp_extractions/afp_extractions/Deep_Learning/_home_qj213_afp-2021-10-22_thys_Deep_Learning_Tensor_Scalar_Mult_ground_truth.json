{"file_name": "/home/qj213/afp-2021-10-22/thys/Deep_Learning/Tensor_Scalar_Mult.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Deep_Learning", "problem_names": ["lemma vec_smult0: \"vec_smult 0 as = vec0 (length as)\"", "lemma vec_smult_distr_right:\nshows \"vec_smult (\\<alpha> + \\<beta>) as = vec_plus (vec_smult \\<alpha> as) (vec_smult \\<beta> as)\"", "lemma vec_smult_Cons:\nshows \"vec_smult \\<alpha> (a # as) = (\\<alpha> * a) # vec_smult \\<alpha> as\"", "lemma vec_plus_Cons:\nshows \"vec_plus (a # as) (b # bs) = (a+b) # vec_plus as bs\"", "lemma vec_smult_distr_left:\nassumes \"length as = length bs\"\nshows \"vec_smult \\<alpha> (vec_plus as bs) = vec_plus (vec_smult \\<alpha> as) (vec_smult \\<alpha> bs)\"", "lemma length_vec_smult: \"length (vec_smult \\<alpha> v) = length v\"", "lemma tensor_smult0: fixes A::\"'a::ring tensor\"\nshows \"0 \\<cdot> A = tensor0 (dims A)\"", "lemma dims_smult[simp]:\"dims (\\<alpha> \\<cdot> A) = dims A\"\nand   vec_smult[simp]: \"vec  (\\<alpha> \\<cdot> A) = map ((*) \\<alpha>) (vec A)\"", "lemma tensor_smult_distr_right: \"(\\<alpha> + \\<beta>) \\<cdot> A = \\<alpha> \\<cdot> A  + \\<beta> \\<cdot> A\"", "lemma tensor_smult_distr_left: \"dims A = dims B \\<Longrightarrow> \\<alpha> \\<cdot> (A + B) = \\<alpha> \\<cdot> A  + \\<alpha> \\<cdot> B\"", "lemma smult_fixed_length_sublist:\nassumes \"length xs = l * c\" \"i<c\"\nshows \"fixed_length_sublist (vec_smult \\<alpha> xs) l i = vec_smult \\<alpha> (fixed_length_sublist xs l i)\"", "lemma smult_subtensor:\nassumes \"dims A \\<noteq> []\" \"i < hd (dims A)\"\nshows \"\\<alpha> \\<cdot> subtensor A i = subtensor (\\<alpha> \\<cdot> A) i\"", "lemma lookup_smult:\nassumes \"is \\<lhd> dims A\"\nshows \"lookup (\\<alpha> \\<cdot> A) is = \\<alpha> * lookup A is\"", "lemma tensor_smult_assoc:\nfixes A::\"'a::ring tensor\"\nshows \"\\<alpha> \\<cdot> (\\<beta> \\<cdot> A) = (\\<alpha> * \\<beta>) \\<cdot> A\""], "translations": [["", "lemma vec_smult0: \"vec_smult 0 as = vec0 (length as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_smult (0::'a) as = vec0 (length as)", "by (induction as; auto simp add:vec0_def vec_smult_def)"], ["", "lemma vec_smult_distr_right:\nshows \"vec_smult (\\<alpha> + \\<beta>) as = vec_plus (vec_smult \\<alpha> as) (vec_smult \\<beta> as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_smult (\\<alpha> + \\<beta>) as =\n    vec_plus (vec_smult \\<alpha> as) (vec_smult \\<beta> as)", "unfolding vec_smult_def vec_plus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((*) (\\<alpha> + \\<beta>)) as =\n    map2 (+) (map ((*) \\<alpha>) as) (map ((*) \\<beta>) as)", "by (induction as; simp add: distrib_right)"], ["", "lemma vec_smult_Cons:\nshows \"vec_smult \\<alpha> (a # as) = (\\<alpha> * a) # vec_smult \\<alpha> as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_smult \\<alpha> (a # as) = \\<alpha> * a # vec_smult \\<alpha> as", "by (simp add: vec_smult_def)"], ["", "lemma vec_plus_Cons:\nshows \"vec_plus (a # as) (b # bs) = (a+b) # vec_plus as bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_plus (a # as) (b # bs) = (a + b) # vec_plus as bs", "by (simp add: vec_plus_def)"], ["", "lemma vec_smult_distr_left:\nassumes \"length as = length bs\"\nshows \"vec_smult \\<alpha> (vec_plus as bs) = vec_plus (vec_smult \\<alpha> as) (vec_smult \\<alpha> bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_smult \\<alpha> (vec_plus as bs) =\n    vec_plus (vec_smult \\<alpha> as) (vec_smult \\<alpha> bs)", "using assms"], ["proof (prove)\nusing this:\n  length as = length bs\n\ngoal (1 subgoal):\n 1. vec_smult \\<alpha> (vec_plus as bs) =\n    vec_plus (vec_smult \\<alpha> as) (vec_smult \\<alpha> bs)", "proof (induction as arbitrary:bs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       length [] = length bs \\<Longrightarrow>\n       vec_smult \\<alpha> (vec_plus [] bs) =\n       vec_plus (vec_smult \\<alpha> []) (vec_smult \\<alpha> bs)\n 2. \\<And>a as bs.\n       \\<lbrakk>\\<And>bs.\n                   length as = length bs \\<Longrightarrow>\n                   vec_smult \\<alpha> (vec_plus as bs) =\n                   vec_plus (vec_smult \\<alpha> as) (vec_smult \\<alpha> bs);\n        length (a # as) = length bs\\<rbrakk>\n       \\<Longrightarrow> vec_smult \\<alpha> (vec_plus (a # as) bs) =\n                         vec_plus (vec_smult \\<alpha> (a # as))\n                          (vec_smult \\<alpha> bs)", "case Nil"], ["proof (state)\nthis:\n  length [] = length bs\n\ngoal (2 subgoals):\n 1. \\<And>bs.\n       length [] = length bs \\<Longrightarrow>\n       vec_smult \\<alpha> (vec_plus [] bs) =\n       vec_plus (vec_smult \\<alpha> []) (vec_smult \\<alpha> bs)\n 2. \\<And>a as bs.\n       \\<lbrakk>\\<And>bs.\n                   length as = length bs \\<Longrightarrow>\n                   vec_smult \\<alpha> (vec_plus as bs) =\n                   vec_plus (vec_smult \\<alpha> as) (vec_smult \\<alpha> bs);\n        length (a # as) = length bs\\<rbrakk>\n       \\<Longrightarrow> vec_smult \\<alpha> (vec_plus (a # as) bs) =\n                         vec_plus (vec_smult \\<alpha> (a # as))\n                          (vec_smult \\<alpha> bs)", "then"], ["proof (chain)\npicking this:\n  length [] = length bs", "show ?case"], ["proof (prove)\nusing this:\n  length [] = length bs\n\ngoal (1 subgoal):\n 1. vec_smult \\<alpha> (vec_plus [] bs) =\n    vec_plus (vec_smult \\<alpha> []) (vec_smult \\<alpha> bs)", "unfolding vec_smult_def vec_plus_def"], ["proof (prove)\nusing this:\n  length [] = length bs\n\ngoal (1 subgoal):\n 1. map ((*) \\<alpha>) (map2 (+) [] bs) =\n    map2 (+) (map ((*) \\<alpha>) []) (map ((*) \\<alpha>) bs)", "by simp"], ["proof (state)\nthis:\n  vec_smult \\<alpha> (vec_plus [] bs) =\n  vec_plus (vec_smult \\<alpha> []) (vec_smult \\<alpha> bs)\n\ngoal (1 subgoal):\n 1. \\<And>a as bs.\n       \\<lbrakk>\\<And>bs.\n                   length as = length bs \\<Longrightarrow>\n                   vec_smult \\<alpha> (vec_plus as bs) =\n                   vec_plus (vec_smult \\<alpha> as) (vec_smult \\<alpha> bs);\n        length (a # as) = length bs\\<rbrakk>\n       \\<Longrightarrow> vec_smult \\<alpha> (vec_plus (a # as) bs) =\n                         vec_plus (vec_smult \\<alpha> (a # as))\n                          (vec_smult \\<alpha> bs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as bs.\n       \\<lbrakk>\\<And>bs.\n                   length as = length bs \\<Longrightarrow>\n                   vec_smult \\<alpha> (vec_plus as bs) =\n                   vec_plus (vec_smult \\<alpha> as) (vec_smult \\<alpha> bs);\n        length (a # as) = length bs\\<rbrakk>\n       \\<Longrightarrow> vec_smult \\<alpha> (vec_plus (a # as) bs) =\n                         vec_plus (vec_smult \\<alpha> (a # as))\n                          (vec_smult \\<alpha> bs)", "case (Cons a as')"], ["proof (state)\nthis:\n  length as' = length ?bs \\<Longrightarrow>\n  vec_smult \\<alpha> (vec_plus as' ?bs) =\n  vec_plus (vec_smult \\<alpha> as') (vec_smult \\<alpha> ?bs)\n  length (a # as') = length bs\n\ngoal (1 subgoal):\n 1. \\<And>a as bs.\n       \\<lbrakk>\\<And>bs.\n                   length as = length bs \\<Longrightarrow>\n                   vec_smult \\<alpha> (vec_plus as bs) =\n                   vec_plus (vec_smult \\<alpha> as) (vec_smult \\<alpha> bs);\n        length (a # as) = length bs\\<rbrakk>\n       \\<Longrightarrow> vec_smult \\<alpha> (vec_plus (a # as) bs) =\n                         vec_plus (vec_smult \\<alpha> (a # as))\n                          (vec_smult \\<alpha> bs)", "then"], ["proof (chain)\npicking this:\n  length as' = length ?bs \\<Longrightarrow>\n  vec_smult \\<alpha> (vec_plus as' ?bs) =\n  vec_plus (vec_smult \\<alpha> as') (vec_smult \\<alpha> ?bs)\n  length (a # as') = length bs", "obtain b bs' where \"bs = b # bs'\""], ["proof (prove)\nusing this:\n  length as' = length ?bs \\<Longrightarrow>\n  vec_smult \\<alpha> (vec_plus as' ?bs) =\n  vec_plus (vec_smult \\<alpha> as') (vec_smult \\<alpha> ?bs)\n  length (a # as') = length bs\n\ngoal (1 subgoal):\n 1. (\\<And>b bs'. bs = b # bs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Suc_length_conv)"], ["proof (state)\nthis:\n  bs = b # bs'\n\ngoal (1 subgoal):\n 1. \\<And>a as bs.\n       \\<lbrakk>\\<And>bs.\n                   length as = length bs \\<Longrightarrow>\n                   vec_smult \\<alpha> (vec_plus as bs) =\n                   vec_plus (vec_smult \\<alpha> as) (vec_smult \\<alpha> bs);\n        length (a # as) = length bs\\<rbrakk>\n       \\<Longrightarrow> vec_smult \\<alpha> (vec_plus (a # as) bs) =\n                         vec_plus (vec_smult \\<alpha> (a # as))\n                          (vec_smult \\<alpha> bs)", "then"], ["proof (chain)\npicking this:\n  bs = b # bs'", "have 0:\"vec_smult \\<alpha> (vec_plus (a # as') bs) = (\\<alpha>*(a+b)) # vec_smult \\<alpha> (vec_plus as' bs')\""], ["proof (prove)\nusing this:\n  bs = b # bs'\n\ngoal (1 subgoal):\n 1. vec_smult \\<alpha> (vec_plus (a # as') bs) =\n    \\<alpha> * (a + b) # vec_smult \\<alpha> (vec_plus as' bs')", "unfolding vec_smult_def vec_plus_def"], ["proof (prove)\nusing this:\n  bs = b # bs'\n\ngoal (1 subgoal):\n 1. map ((*) \\<alpha>) (map2 (+) (a # as') bs) =\n    \\<alpha> * (a + b) # map ((*) \\<alpha>) (map2 (+) as' bs')", "using Cons.IH[of bs']"], ["proof (prove)\nusing this:\n  bs = b # bs'\n  length as' = length bs' \\<Longrightarrow>\n  vec_smult \\<alpha> (vec_plus as' bs') =\n  vec_plus (vec_smult \\<alpha> as') (vec_smult \\<alpha> bs')\n\ngoal (1 subgoal):\n 1. map ((*) \\<alpha>) (map2 (+) (a # as') bs) =\n    \\<alpha> * (a + b) # map ((*) \\<alpha>) (map2 (+) as' bs')", "by simp"], ["proof (state)\nthis:\n  vec_smult \\<alpha> (vec_plus (a # as') bs) =\n  \\<alpha> * (a + b) # vec_smult \\<alpha> (vec_plus as' bs')\n\ngoal (1 subgoal):\n 1. \\<And>a as bs.\n       \\<lbrakk>\\<And>bs.\n                   length as = length bs \\<Longrightarrow>\n                   vec_smult \\<alpha> (vec_plus as bs) =\n                   vec_plus (vec_smult \\<alpha> as) (vec_smult \\<alpha> bs);\n        length (a # as) = length bs\\<rbrakk>\n       \\<Longrightarrow> vec_smult \\<alpha> (vec_plus (a # as) bs) =\n                         vec_plus (vec_smult \\<alpha> (a # as))\n                          (vec_smult \\<alpha> bs)", "have \"length bs' = length as'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length bs' = length as'", "using Cons.prems \\<open>bs = b # bs'\\<close>"], ["proof (prove)\nusing this:\n  length (a # as') = length bs\n  bs = b # bs'\n\ngoal (1 subgoal):\n 1. length bs' = length as'", "by auto"], ["proof (state)\nthis:\n  length bs' = length as'\n\ngoal (1 subgoal):\n 1. \\<And>a as bs.\n       \\<lbrakk>\\<And>bs.\n                   length as = length bs \\<Longrightarrow>\n                   vec_smult \\<alpha> (vec_plus as bs) =\n                   vec_plus (vec_smult \\<alpha> as) (vec_smult \\<alpha> bs);\n        length (a # as) = length bs\\<rbrakk>\n       \\<Longrightarrow> vec_smult \\<alpha> (vec_plus (a # as) bs) =\n                         vec_plus (vec_smult \\<alpha> (a # as))\n                          (vec_smult \\<alpha> bs)", "then"], ["proof (chain)\npicking this:\n  length bs' = length as'", "show ?case"], ["proof (prove)\nusing this:\n  length bs' = length as'\n\ngoal (1 subgoal):\n 1. vec_smult \\<alpha> (vec_plus (a # as') bs) =\n    vec_plus (vec_smult \\<alpha> (a # as')) (vec_smult \\<alpha> bs)", "unfolding 0"], ["proof (prove)\nusing this:\n  length bs' = length as'\n\ngoal (1 subgoal):\n 1. \\<alpha> * (a + b) # vec_smult \\<alpha> (vec_plus as' bs') =\n    vec_plus (vec_smult \\<alpha> (a # as')) (vec_smult \\<alpha> bs)", "unfolding  \\<open>bs = b # bs'\\<close> vec_smult_Cons vec_plus_Cons"], ["proof (prove)\nusing this:\n  length bs' = length as'\n\ngoal (1 subgoal):\n 1. \\<alpha> * (a + b) # vec_smult \\<alpha> (vec_plus as' bs') =\n    (\\<alpha> * a + \\<alpha> * b) #\n    vec_plus (vec_smult \\<alpha> as') (vec_smult \\<alpha> bs')", "by (simp add: Cons.IH distrib_left)"], ["proof (state)\nthis:\n  vec_smult \\<alpha> (vec_plus (a # as') bs) =\n  vec_plus (vec_smult \\<alpha> (a # as')) (vec_smult \\<alpha> bs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_vec_smult: \"length (vec_smult \\<alpha> v) = length v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (vec_smult \\<alpha> v) = length v", "unfolding vec_smult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map ((*) \\<alpha>) v) = length v", "by simp"], ["", "definition smult::\"'a::ring \\<Rightarrow> 'a tensor \\<Rightarrow> 'a tensor\" (infixl \"\\<cdot>\" 70) where\n\"smult \\<alpha> A = (tensor_from_vec (dims A) (vec_smult \\<alpha> (vec A)))\""], ["", "lemma tensor_smult0: fixes A::\"'a::ring tensor\"\nshows \"0 \\<cdot> A = tensor0 (dims A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<cdot> A = tensor0 (dims A)", "unfolding smult_def tensor0_def vec_smult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_from_vec (dims A) (map ((*) (0::'a)) (vec A)) =\n    tensor_from_vec (dims A) (vec0 (prod_list (dims A)))", "using vec_smult0 length_vec"], ["proof (prove)\nusing this:\n  vec_smult (0::?'a) ?as = vec0 (length ?as)\n  length (vec ?A) = prod_list (dims ?A)\n\ngoal (1 subgoal):\n 1. tensor_from_vec (dims A) (map ((*) (0::'a)) (vec A)) =\n    tensor_from_vec (dims A) (vec0 (prod_list (dims A)))", "by (metis (no_types) vec_smult_def)"], ["", "lemma dims_smult[simp]:\"dims (\\<alpha> \\<cdot> A) = dims A\"\nand   vec_smult[simp]: \"vec  (\\<alpha> \\<cdot> A) = map ((*) \\<alpha>) (vec A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dims (\\<alpha> \\<cdot> A) = dims A &&&\n    vec (\\<alpha> \\<cdot> A) = map ((*) \\<alpha>) (vec A)", "unfolding smult_def vec_smult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dims (tensor_from_vec (dims A) (map ((*) \\<alpha>) (vec A))) =\n    dims A &&&\n    vec (tensor_from_vec (dims A) (map ((*) \\<alpha>) (vec A))) =\n    map ((*) \\<alpha>) (vec A)", "by (simp add: length_vec)+"], ["", "lemma tensor_smult_distr_right: \"(\\<alpha> + \\<beta>) \\<cdot> A = \\<alpha> \\<cdot> A  + \\<beta> \\<cdot> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<alpha> + \\<beta>) \\<cdot> A = \\<alpha> \\<cdot> A + \\<beta> \\<cdot> A", "unfolding plus_def plus_base_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<alpha> + \\<beta>) \\<cdot> A =\n    (if dims (\\<alpha> \\<cdot> A) = dims (\\<beta> \\<cdot> A)\n     then tensor_from_vec (dims (\\<alpha> \\<cdot> A))\n           (vec_plus (vec (\\<alpha> \\<cdot> A)) (vec (\\<beta> \\<cdot> A)))\n     else undefined)", "by (auto; metis smult_def vec_smult_def vec_smult_distr_right)"], ["", "lemma tensor_smult_distr_left: \"dims A = dims B \\<Longrightarrow> \\<alpha> \\<cdot> (A + B) = \\<alpha> \\<cdot> A  + \\<alpha> \\<cdot> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dims A = dims B \\<Longrightarrow>\n    \\<alpha> \\<cdot> (A + B) = \\<alpha> \\<cdot> A + \\<alpha> \\<cdot> B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dims A = dims B \\<Longrightarrow>\n    \\<alpha> \\<cdot> (A + B) = \\<alpha> \\<cdot> A + \\<alpha> \\<cdot> B", "assume a1: \"dims A = dims B\""], ["proof (state)\nthis:\n  dims A = dims B\n\ngoal (1 subgoal):\n 1. dims A = dims B \\<Longrightarrow>\n    \\<alpha> \\<cdot> (A + B) = \\<alpha> \\<cdot> A + \\<alpha> \\<cdot> B", "then"], ["proof (chain)\npicking this:\n  dims A = dims B", "have f2: \"length (vec_plus (vec A) (vec B)) = length (vec A)\""], ["proof (prove)\nusing this:\n  dims A = dims B\n\ngoal (1 subgoal):\n 1. length (vec_plus (vec A) (vec B)) = length (vec A)", "by (simp add: length_vec vec_plus_def)"], ["proof (state)\nthis:\n  length (vec_plus (vec A) (vec B)) = length (vec A)\n\ngoal (1 subgoal):\n 1. dims A = dims B \\<Longrightarrow>\n    \\<alpha> \\<cdot> (A + B) = \\<alpha> \\<cdot> A + \\<alpha> \\<cdot> B", "have f3: \"dims (tensor_from_vec (dims B) (vec_smult \\<alpha> (vec A))) = dims B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dims (tensor_from_vec (dims B) (vec_smult \\<alpha> (vec A))) = dims B", "using a1"], ["proof (prove)\nusing this:\n  dims A = dims B\n\ngoal (1 subgoal):\n 1. dims (tensor_from_vec (dims B) (vec_smult \\<alpha> (vec A))) = dims B", "by (simp add: length_vec vec_smult_def)"], ["proof (state)\nthis:\n  dims (tensor_from_vec (dims B) (vec_smult \\<alpha> (vec A))) = dims B\n\ngoal (1 subgoal):\n 1. dims A = dims B \\<Longrightarrow>\n    \\<alpha> \\<cdot> (A + B) = \\<alpha> \\<cdot> A + \\<alpha> \\<cdot> B", "have f4: \"vec (\\<alpha> \\<cdot> A) = vec_smult \\<alpha> (vec A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec (\\<alpha> \\<cdot> A) = vec_smult \\<alpha> (vec A)", "by (simp add: vec_smult_def)"], ["proof (state)\nthis:\n  vec (\\<alpha> \\<cdot> A) = vec_smult \\<alpha> (vec A)\n\ngoal (1 subgoal):\n 1. dims A = dims B \\<Longrightarrow>\n    \\<alpha> \\<cdot> (A + B) = \\<alpha> \\<cdot> A + \\<alpha> \\<cdot> B", "have \"length (vec_smult \\<alpha> (vec B)) = length (vec B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (vec_smult \\<alpha> (vec B)) = length (vec B)", "by (simp add: vec_smult_def)"], ["proof (state)\nthis:\n  length (vec_smult \\<alpha> (vec B)) = length (vec B)\n\ngoal (1 subgoal):\n 1. dims A = dims B \\<Longrightarrow>\n    \\<alpha> \\<cdot> (A + B) = \\<alpha> \\<cdot> A + \\<alpha> \\<cdot> B", "then"], ["proof (chain)\npicking this:\n  length (vec_smult \\<alpha> (vec B)) = length (vec B)", "show ?thesis"], ["proof (prove)\nusing this:\n  length (vec_smult \\<alpha> (vec B)) = length (vec B)\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<cdot> (A + B) = \\<alpha> \\<cdot> A + \\<alpha> \\<cdot> B", "unfolding plus_def plus_base_def"], ["proof (prove)\nusing this:\n  length (vec_smult \\<alpha> (vec B)) = length (vec B)\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<cdot>\n    (if dims A = dims B\n     then tensor_from_vec (dims A) (vec_plus (vec A) (vec B))\n     else undefined) =\n    (if dims (\\<alpha> \\<cdot> A) = dims (\\<alpha> \\<cdot> B)\n     then tensor_from_vec (dims (\\<alpha> \\<cdot> A))\n           (vec_plus (vec (\\<alpha> \\<cdot> A)) (vec (\\<alpha> \\<cdot> B)))\n     else undefined)", "using f4 f3 f2 a1"], ["proof (prove)\nusing this:\n  length (vec_smult \\<alpha> (vec B)) = length (vec B)\n  vec (\\<alpha> \\<cdot> A) = vec_smult \\<alpha> (vec A)\n  dims (tensor_from_vec (dims B) (vec_smult \\<alpha> (vec A))) = dims B\n  length (vec_plus (vec A) (vec B)) = length (vec A)\n  dims A = dims B\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<cdot>\n    (if dims A = dims B\n     then tensor_from_vec (dims A) (vec_plus (vec A) (vec B))\n     else undefined) =\n    (if dims (\\<alpha> \\<cdot> A) = dims (\\<alpha> \\<cdot> B)\n     then tensor_from_vec (dims (\\<alpha> \\<cdot> A))\n           (vec_plus (vec (\\<alpha> \\<cdot> A)) (vec (\\<alpha> \\<cdot> B)))\n     else undefined)", "by (simp add: length_vec smult_def vec_smult_distr_left)"], ["proof (state)\nthis:\n  \\<alpha> \\<cdot> (A + B) = \\<alpha> \\<cdot> A + \\<alpha> \\<cdot> B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma smult_fixed_length_sublist:\nassumes \"length xs = l * c\" \"i<c\"\nshows \"fixed_length_sublist (vec_smult \\<alpha> xs) l i = vec_smult \\<alpha> (fixed_length_sublist xs l i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fixed_length_sublist (vec_smult \\<alpha> xs) l i =\n    vec_smult \\<alpha> (fixed_length_sublist xs l i)", "unfolding fixed_length_sublist_def vec_smult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. take l (drop (l * i) (map ((*) \\<alpha>) xs)) =\n    map ((*) \\<alpha>) (take l (drop (l * i) xs))", "by (simp add: drop_map take_map)"], ["", "lemma smult_subtensor:\nassumes \"dims A \\<noteq> []\" \"i < hd (dims A)\"\nshows \"\\<alpha> \\<cdot> subtensor A i = subtensor (\\<alpha> \\<cdot> A) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<cdot> subtensor A i = subtensor (\\<alpha> \\<cdot> A) i", "proof (rule tensor_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. dims (\\<alpha> \\<cdot> subtensor A i) =\n    dims (subtensor (\\<alpha> \\<cdot> A) i)\n 2. vec (\\<alpha> \\<cdot> subtensor A i) =\n    vec (subtensor (\\<alpha> \\<cdot> A) i)", "show \"dims (\\<alpha> \\<cdot> subtensor A i) = dims (subtensor (\\<alpha> \\<cdot> A) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dims (\\<alpha> \\<cdot> subtensor A i) =\n    dims (subtensor (\\<alpha> \\<cdot> A) i)", "using dims_smult dims_subtensor assms(1) assms(2)"], ["proof (prove)\nusing this:\n  dims (?\\<alpha> \\<cdot> ?A) = dims ?A\n  \\<lbrakk>dims ?A \\<noteq> []; ?i < hd (dims ?A)\\<rbrakk>\n  \\<Longrightarrow> dims (subtensor ?A ?i) = tl (dims ?A)\n  dims A \\<noteq> []\n  i < hd (dims A)\n\ngoal (1 subgoal):\n 1. dims (\\<alpha> \\<cdot> subtensor A i) =\n    dims (subtensor (\\<alpha> \\<cdot> A) i)", "by simp"], ["proof (state)\nthis:\n  dims (\\<alpha> \\<cdot> subtensor A i) =\n  dims (subtensor (\\<alpha> \\<cdot> A) i)\n\ngoal (1 subgoal):\n 1. vec (\\<alpha> \\<cdot> subtensor A i) =\n    vec (subtensor (\\<alpha> \\<cdot> A) i)", "show \"vec (\\<alpha> \\<cdot> subtensor A i) = vec (subtensor (\\<alpha> \\<cdot> A) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec (\\<alpha> \\<cdot> subtensor A i) =\n    vec (subtensor (\\<alpha> \\<cdot> A) i)", "unfolding vec_smult"], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((*) \\<alpha>) (vec (subtensor A i)) =\n    vec (subtensor (\\<alpha> \\<cdot> A) i)", "unfolding vec_subtensor[OF \\<open>dims A \\<noteq> []\\<close> \\<open>i < hd (dims A)\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((*) \\<alpha>)\n     (fixed_length_sublist (vec A) (prod_list (tl (dims A))) i) =\n    vec (subtensor (\\<alpha> \\<cdot> A) i)", "using vec_subtensor[of \"\\<alpha> \\<cdot> A\" i]"], ["proof (prove)\nusing this:\n  \\<lbrakk>dims (\\<alpha> \\<cdot> A) \\<noteq> [];\n   i < hd (dims (\\<alpha> \\<cdot> A))\\<rbrakk>\n  \\<Longrightarrow> vec (subtensor (\\<alpha> \\<cdot> A) i) =\n                    fixed_length_sublist (vec (\\<alpha> \\<cdot> A))\n                     (prod_list (tl (dims (\\<alpha> \\<cdot> A)))) i\n\ngoal (1 subgoal):\n 1. map ((*) \\<alpha>)\n     (fixed_length_sublist (vec A) (prod_list (tl (dims A))) i) =\n    vec (subtensor (\\<alpha> \\<cdot> A) i)", "by (simp add: assms(1) assms(2) drop_map fixed_length_sublist_def take_map)"], ["proof (state)\nthis:\n  vec (\\<alpha> \\<cdot> subtensor A i) =\n  vec (subtensor (\\<alpha> \\<cdot> A) i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_smult:\nassumes \"is \\<lhd> dims A\"\nshows \"lookup (\\<alpha> \\<cdot> A) is = \\<alpha> * lookup A is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (\\<alpha> \\<cdot> A) is = \\<alpha> * lookup A is", "using assms"], ["proof (prove)\nusing this:\n  is \\<lhd> dims A\n\ngoal (1 subgoal):\n 1. lookup (\\<alpha> \\<cdot> A) is = \\<alpha> * lookup A is", "proof (induction A arbitrary:\"is\" rule:subtensor_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A is.\n       \\<lbrakk>dims A = []; is \\<lhd> dims A\\<rbrakk>\n       \\<Longrightarrow> lookup (\\<alpha> \\<cdot> A) is =\n                         \\<alpha> * lookup A is\n 2. \\<And>A is.\n       \\<lbrakk>dims A \\<noteq> [];\n        \\<And>i is.\n           \\<lbrakk>i < hd (dims A); is \\<lhd> dims (subtensor A i)\\<rbrakk>\n           \\<Longrightarrow> lookup (\\<alpha> \\<cdot> subtensor A i) is =\n                             \\<alpha> * lookup (subtensor A i) is;\n        is \\<lhd> dims A\\<rbrakk>\n       \\<Longrightarrow> lookup (\\<alpha> \\<cdot> A) is =\n                         \\<alpha> * lookup A is", "case (order_0 A \"is\")"], ["proof (state)\nthis:\n  dims A = []\n  is \\<lhd> dims A\n\ngoal (2 subgoals):\n 1. \\<And>A is.\n       \\<lbrakk>dims A = []; is \\<lhd> dims A\\<rbrakk>\n       \\<Longrightarrow> lookup (\\<alpha> \\<cdot> A) is =\n                         \\<alpha> * lookup A is\n 2. \\<And>A is.\n       \\<lbrakk>dims A \\<noteq> [];\n        \\<And>i is.\n           \\<lbrakk>i < hd (dims A); is \\<lhd> dims (subtensor A i)\\<rbrakk>\n           \\<Longrightarrow> lookup (\\<alpha> \\<cdot> subtensor A i) is =\n                             \\<alpha> * lookup (subtensor A i) is;\n        is \\<lhd> dims A\\<rbrakk>\n       \\<Longrightarrow> lookup (\\<alpha> \\<cdot> A) is =\n                         \\<alpha> * lookup A is", "then"], ["proof (chain)\npicking this:\n  dims A = []\n  is \\<lhd> dims A", "have \"length (vec A) = 1\""], ["proof (prove)\nusing this:\n  dims A = []\n  is \\<lhd> dims A\n\ngoal (1 subgoal):\n 1. length (vec A) = 1", "by (simp add: length_vec)"], ["proof (state)\nthis:\n  length (vec A) = 1\n\ngoal (2 subgoals):\n 1. \\<And>A is.\n       \\<lbrakk>dims A = []; is \\<lhd> dims A\\<rbrakk>\n       \\<Longrightarrow> lookup (\\<alpha> \\<cdot> A) is =\n                         \\<alpha> * lookup A is\n 2. \\<And>A is.\n       \\<lbrakk>dims A \\<noteq> [];\n        \\<And>i is.\n           \\<lbrakk>i < hd (dims A); is \\<lhd> dims (subtensor A i)\\<rbrakk>\n           \\<Longrightarrow> lookup (\\<alpha> \\<cdot> subtensor A i) is =\n                             \\<alpha> * lookup (subtensor A i) is;\n        is \\<lhd> dims A\\<rbrakk>\n       \\<Longrightarrow> lookup (\\<alpha> \\<cdot> A) is =\n                         \\<alpha> * lookup A is", "then"], ["proof (chain)\npicking this:\n  length (vec A) = 1", "have \"hd (vec_smult \\<alpha> (vec A)) = \\<alpha> * hd (vec A)\""], ["proof (prove)\nusing this:\n  length (vec A) = 1\n\ngoal (1 subgoal):\n 1. hd (vec_smult \\<alpha> (vec A)) = \\<alpha> * hd (vec A)", "unfolding vec_smult_def"], ["proof (prove)\nusing this:\n  length (vec A) = 1\n\ngoal (1 subgoal):\n 1. hd (map ((*) \\<alpha>) (vec A)) = \\<alpha> * hd (vec A)", "by (metis list.map_sel(1) list.size(3) zero_neq_one)"], ["proof (state)\nthis:\n  hd (vec_smult \\<alpha> (vec A)) = \\<alpha> * hd (vec A)\n\ngoal (2 subgoals):\n 1. \\<And>A is.\n       \\<lbrakk>dims A = []; is \\<lhd> dims A\\<rbrakk>\n       \\<Longrightarrow> lookup (\\<alpha> \\<cdot> A) is =\n                         \\<alpha> * lookup A is\n 2. \\<And>A is.\n       \\<lbrakk>dims A \\<noteq> [];\n        \\<And>i is.\n           \\<lbrakk>i < hd (dims A); is \\<lhd> dims (subtensor A i)\\<rbrakk>\n           \\<Longrightarrow> lookup (\\<alpha> \\<cdot> subtensor A i) is =\n                             \\<alpha> * lookup (subtensor A i) is;\n        is \\<lhd> dims A\\<rbrakk>\n       \\<Longrightarrow> lookup (\\<alpha> \\<cdot> A) is =\n                         \\<alpha> * lookup A is", "moreover"], ["proof (state)\nthis:\n  hd (vec_smult \\<alpha> (vec A)) = \\<alpha> * hd (vec A)\n\ngoal (2 subgoals):\n 1. \\<And>A is.\n       \\<lbrakk>dims A = []; is \\<lhd> dims A\\<rbrakk>\n       \\<Longrightarrow> lookup (\\<alpha> \\<cdot> A) is =\n                         \\<alpha> * lookup A is\n 2. \\<And>A is.\n       \\<lbrakk>dims A \\<noteq> [];\n        \\<And>i is.\n           \\<lbrakk>i < hd (dims A); is \\<lhd> dims (subtensor A i)\\<rbrakk>\n           \\<Longrightarrow> lookup (\\<alpha> \\<cdot> subtensor A i) is =\n                             \\<alpha> * lookup (subtensor A i) is;\n        is \\<lhd> dims A\\<rbrakk>\n       \\<Longrightarrow> lookup (\\<alpha> \\<cdot> A) is =\n                         \\<alpha> * lookup A is", "have \"is = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is = []", "using order_0"], ["proof (prove)\nusing this:\n  dims A = []\n  is \\<lhd> dims A\n\ngoal (1 subgoal):\n 1. is = []", "by auto"], ["proof (state)\nthis:\n  is = []\n\ngoal (2 subgoals):\n 1. \\<And>A is.\n       \\<lbrakk>dims A = []; is \\<lhd> dims A\\<rbrakk>\n       \\<Longrightarrow> lookup (\\<alpha> \\<cdot> A) is =\n                         \\<alpha> * lookup A is\n 2. \\<And>A is.\n       \\<lbrakk>dims A \\<noteq> [];\n        \\<And>i is.\n           \\<lbrakk>i < hd (dims A); is \\<lhd> dims (subtensor A i)\\<rbrakk>\n           \\<Longrightarrow> lookup (\\<alpha> \\<cdot> subtensor A i) is =\n                             \\<alpha> * lookup (subtensor A i) is;\n        is \\<lhd> dims A\\<rbrakk>\n       \\<Longrightarrow> lookup (\\<alpha> \\<cdot> A) is =\n                         \\<alpha> * lookup A is", "ultimately"], ["proof (chain)\npicking this:\n  hd (vec_smult \\<alpha> (vec A)) = \\<alpha> * hd (vec A)\n  is = []", "show ?case"], ["proof (prove)\nusing this:\n  hd (vec_smult \\<alpha> (vec A)) = \\<alpha> * hd (vec A)\n  is = []\n\ngoal (1 subgoal):\n 1. lookup (\\<alpha> \\<cdot> A) is = \\<alpha> * lookup A is", "unfolding smult_def"], ["proof (prove)\nusing this:\n  hd (vec_smult \\<alpha> (vec A)) = \\<alpha> * hd (vec A)\n  is = []\n\ngoal (1 subgoal):\n 1. lookup (tensor_from_vec (dims A) (vec_smult \\<alpha> (vec A))) is =\n    \\<alpha> * lookup A is", "by (auto simp add: \\<open>length (Tensor.vec A) = 1\\<close> lookup_def length_vec_smult order_0.hyps)"], ["proof (state)\nthis:\n  lookup (\\<alpha> \\<cdot> A) is = \\<alpha> * lookup A is\n\ngoal (1 subgoal):\n 1. \\<And>A is.\n       \\<lbrakk>dims A \\<noteq> [];\n        \\<And>i is.\n           \\<lbrakk>i < hd (dims A); is \\<lhd> dims (subtensor A i)\\<rbrakk>\n           \\<Longrightarrow> lookup (\\<alpha> \\<cdot> subtensor A i) is =\n                             \\<alpha> * lookup (subtensor A i) is;\n        is \\<lhd> dims A\\<rbrakk>\n       \\<Longrightarrow> lookup (\\<alpha> \\<cdot> A) is =\n                         \\<alpha> * lookup A is", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A is.\n       \\<lbrakk>dims A \\<noteq> [];\n        \\<And>i is.\n           \\<lbrakk>i < hd (dims A); is \\<lhd> dims (subtensor A i)\\<rbrakk>\n           \\<Longrightarrow> lookup (\\<alpha> \\<cdot> subtensor A i) is =\n                             \\<alpha> * lookup (subtensor A i) is;\n        is \\<lhd> dims A\\<rbrakk>\n       \\<Longrightarrow> lookup (\\<alpha> \\<cdot> A) is =\n                         \\<alpha> * lookup A is", "case (order_step A \"is\")"], ["proof (state)\nthis:\n  dims A \\<noteq> []\n  \\<lbrakk>?i < hd (dims A); ?is \\<lhd> dims (subtensor A ?i)\\<rbrakk>\n  \\<Longrightarrow> lookup (\\<alpha> \\<cdot> subtensor A ?i) ?is =\n                    \\<alpha> * lookup (subtensor A ?i) ?is\n  is \\<lhd> dims A\n\ngoal (1 subgoal):\n 1. \\<And>A is.\n       \\<lbrakk>dims A \\<noteq> [];\n        \\<And>i is.\n           \\<lbrakk>i < hd (dims A); is \\<lhd> dims (subtensor A i)\\<rbrakk>\n           \\<Longrightarrow> lookup (\\<alpha> \\<cdot> subtensor A i) is =\n                             \\<alpha> * lookup (subtensor A i) is;\n        is \\<lhd> dims A\\<rbrakk>\n       \\<Longrightarrow> lookup (\\<alpha> \\<cdot> A) is =\n                         \\<alpha> * lookup A is", "then"], ["proof (chain)\npicking this:\n  dims A \\<noteq> []\n  \\<lbrakk>?i < hd (dims A); ?is \\<lhd> dims (subtensor A ?i)\\<rbrakk>\n  \\<Longrightarrow> lookup (\\<alpha> \\<cdot> subtensor A ?i) ?is =\n                    \\<alpha> * lookup (subtensor A ?i) ?is\n  is \\<lhd> dims A", "obtain i is' where \"is = i # is'\""], ["proof (prove)\nusing this:\n  dims A \\<noteq> []\n  \\<lbrakk>?i < hd (dims A); ?is \\<lhd> dims (subtensor A ?i)\\<rbrakk>\n  \\<Longrightarrow> lookup (\\<alpha> \\<cdot> subtensor A ?i) ?is =\n                    \\<alpha> * lookup (subtensor A ?i) ?is\n  is \\<lhd> dims A\n\ngoal (1 subgoal):\n 1. (\\<And>i is'. is = i # is' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  is = i # is'\n\ngoal (1 subgoal):\n 1. \\<And>A is.\n       \\<lbrakk>dims A \\<noteq> [];\n        \\<And>i is.\n           \\<lbrakk>i < hd (dims A); is \\<lhd> dims (subtensor A i)\\<rbrakk>\n           \\<Longrightarrow> lookup (\\<alpha> \\<cdot> subtensor A i) is =\n                             \\<alpha> * lookup (subtensor A i) is;\n        is \\<lhd> dims A\\<rbrakk>\n       \\<Longrightarrow> lookup (\\<alpha> \\<cdot> A) is =\n                         \\<alpha> * lookup A is", "then"], ["proof (chain)\npicking this:\n  is = i # is'", "have \"lookup (\\<alpha> \\<cdot> subtensor A i) is' = \\<alpha> * lookup (subtensor A i) is'\""], ["proof (prove)\nusing this:\n  is = i # is'\n\ngoal (1 subgoal):\n 1. lookup (\\<alpha> \\<cdot> subtensor A i) is' =\n    \\<alpha> * lookup (subtensor A i) is'", "by (metis (no_types, lifting) dims_subtensor list.sel(1) list.sel(3) order_step.IH order_step.hyps order_step.prems valid_index_dimsE)"], ["proof (state)\nthis:\n  lookup (\\<alpha> \\<cdot> subtensor A i) is' =\n  \\<alpha> * lookup (subtensor A i) is'\n\ngoal (1 subgoal):\n 1. \\<And>A is.\n       \\<lbrakk>dims A \\<noteq> [];\n        \\<And>i is.\n           \\<lbrakk>i < hd (dims A); is \\<lhd> dims (subtensor A i)\\<rbrakk>\n           \\<Longrightarrow> lookup (\\<alpha> \\<cdot> subtensor A i) is =\n                             \\<alpha> * lookup (subtensor A i) is;\n        is \\<lhd> dims A\\<rbrakk>\n       \\<Longrightarrow> lookup (\\<alpha> \\<cdot> A) is =\n                         \\<alpha> * lookup A is", "then"], ["proof (chain)\npicking this:\n  lookup (\\<alpha> \\<cdot> subtensor A i) is' =\n  \\<alpha> * lookup (subtensor A i) is'", "show ?case"], ["proof (prove)\nusing this:\n  lookup (\\<alpha> \\<cdot> subtensor A i) is' =\n  \\<alpha> * lookup (subtensor A i) is'\n\ngoal (1 subgoal):\n 1. lookup (\\<alpha> \\<cdot> A) is = \\<alpha> * lookup A is", "using smult_subtensor \\<open>is = i # is'\\<close> dims_smult lookup_subtensor1\n    list.sel(1) order_step.hyps order_step.prems valid_index_dimsE"], ["proof (prove)\nusing this:\n  lookup (\\<alpha> \\<cdot> subtensor A i) is' =\n  \\<alpha> * lookup (subtensor A i) is'\n  \\<lbrakk>dims ?A \\<noteq> []; ?i < hd (dims ?A)\\<rbrakk>\n  \\<Longrightarrow> ?\\<alpha> \\<cdot> subtensor ?A ?i =\n                    subtensor (?\\<alpha> \\<cdot> ?A) ?i\n  is = i # is'\n  dims (?\\<alpha> \\<cdot> ?A) = dims ?A\n  ?i # ?is \\<lhd> dims ?A \\<Longrightarrow>\n  lookup (subtensor ?A ?i) ?is = lookup ?A (?i # ?is)\n  hd (?x21.0 # ?x22.0) = ?x21.0\n  dims A \\<noteq> []\n  is \\<lhd> dims A\n  \\<lbrakk>?is \\<lhd> dims ?A;\n   \\<lbrakk>?is = []; dims ?A = []\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>is ds i d.\n      \\<lbrakk>?is = i # is; dims ?A = d # ds; is \\<lhd> ds; i < d\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. lookup (\\<alpha> \\<cdot> A) is = \\<alpha> * lookup A is", "by metis"], ["proof (state)\nthis:\n  lookup (\\<alpha> \\<cdot> A) is = \\<alpha> * lookup A is\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tensor_smult_assoc:\nfixes A::\"'a::ring tensor\"\nshows \"\\<alpha> \\<cdot> (\\<beta> \\<cdot> A) = (\\<alpha> * \\<beta>) \\<cdot> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<cdot> (\\<beta> \\<cdot> A) = \\<alpha> * \\<beta> \\<cdot> A", "by (rule tensor_lookup_eqI, simp, metis lookup_smult dims_smult mult.assoc)"], ["", "end"]]}