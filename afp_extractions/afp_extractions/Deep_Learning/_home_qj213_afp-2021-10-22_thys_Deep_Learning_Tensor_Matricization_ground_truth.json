{"file_name": "/home/qj213/afp-2021-10-22/thys/Deep_Learning/Tensor_Matricization.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Deep_Learning", "problem_names": ["lemma digit_encode_decode[simp]:\nassumes \"is \\<lhd> ds\"\nshows \"digit_encode ds (digit_decode ds is) = is\"", "lemma digit_decode_encode[simp]:\nshows \"digit_decode ds (digit_encode ds a) = a mod (prod_list ds)\"", "lemma digit_decode_encode_lt[simp]:\nassumes \"a < prod_list ds\"\nshows \"digit_decode ds (digit_encode ds a) = a\"", "lemma digit_decode_lt:\nassumes \"is \\<lhd> ds\"\nshows \"digit_decode ds is < prod_list ds\"", "lemma digit_encode_valid_index:\nassumes \"a < prod_list ds\"\nshows \"digit_encode ds a \\<lhd> ds\"", "lemma length_digit_encode:\nshows \"length (digit_encode ds a) = length ds\"", "lemma digit_encode_0:\n\"prod_list ds dvd a \\<Longrightarrow> digit_encode ds a = replicate (length ds) 0\"", "lemma valid_index_weave:\nassumes \"is1 \\<lhd> (nths ds A)\"\nand     \"is2 \\<lhd> (nths ds (-A))\"\nshows \"weave A is1 is2 \\<lhd> ds\"\nand \"nths (weave A is1 is2) A = is1\"\nand \"nths (weave A is1 is2) (-A) = is2\"", "lemma dims_matricize:\n\"dim_row (matricize rmodes T) = prod_list (nths (Tensor.dims T) rmodes)\"\n\"dim_col (matricize rmodes T) = prod_list (nths (Tensor.dims T) (-rmodes))\"", "lemma dims_dematricize: \"Tensor.dims (dematricize rmodes A ds) = ds\"", "lemma valid_index_nths:\nassumes \"is \\<lhd> ds\"\nshows \"nths is A \\<lhd> nths ds A\"", "lemma dematricize_matricize:\nshows \"dematricize rmodes (matricize rmodes T) (Tensor.dims T) = T\"", "lemma matricize_dematricize:\nassumes \" dim_row A = prod_list (nths ds rmodes)\"\nand \" dim_col A = prod_list (nths ds (-rmodes))\"\nshows \"matricize rmodes (dematricize rmodes A ds) = A\"", "lemma matricize_add:\nassumes \"dims A = dims B\"\nshows \"matricize I A + matricize I B = matricize I (A+B)\"", "lemma matricize_0:\nshows \"matricize I (tensor0 ds) = 0\\<^sub>m (dim_row (matricize I (tensor0 ds))) (dim_col (matricize I (tensor0 ds)))\""], "translations": [["", "lemma digit_encode_decode[simp]:\nassumes \"is \\<lhd> ds\"\nshows \"digit_encode ds (digit_decode ds is) = is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. digit_encode ds (digit_decode ds is) = is", "using assms"], ["proof (prove)\nusing this:\n  is \\<lhd> ds\n\ngoal (1 subgoal):\n 1. digit_encode ds (digit_decode ds is) = is", "apply (induction rule:valid_index.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. digit_encode [] (digit_decode [] []) = []\n 2. \\<And>is ds i d.\n       \\<lbrakk>is \\<lhd> ds; digit_encode ds (digit_decode ds is) = is;\n        i < d\\<rbrakk>\n       \\<Longrightarrow> digit_encode (d # ds)\n                          (digit_decode (d # ds) (i # is)) =\n                         i # is", "unfolding digit_decode.simps digit_encode.simps"], ["proof (prove)\ngoal (2 subgoals):\n 1. [] = []\n 2. \\<And>is ds i d.\n       \\<lbrakk>is \\<lhd> ds; digit_encode ds (digit_decode ds is) = is;\n        i < d\\<rbrakk>\n       \\<Longrightarrow> (i + d * digit_decode ds is) mod d #\n                         digit_encode ds\n                          ((i + d * digit_decode ds is) div d) =\n                         i # is", "by simp_all"], ["", "lemma digit_decode_encode[simp]:\nshows \"digit_decode ds (digit_encode ds a) = a mod (prod_list ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. digit_decode ds (digit_encode ds a) = a mod prod_list ds", "by (induction ds arbitrary:a; simp add: Divides.mod_mult2_eq add.commute)"], ["", "lemma digit_decode_encode_lt[simp]:\nassumes \"a < prod_list ds\"\nshows \"digit_decode ds (digit_encode ds a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. digit_decode ds (digit_encode ds a) = a", "by (simp add: assms)"], ["", "lemma digit_decode_lt:\nassumes \"is \\<lhd> ds\"\nshows \"digit_decode ds is < prod_list ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. digit_decode ds is < prod_list ds", "using assms"], ["proof (prove)\nusing this:\n  is \\<lhd> ds\n\ngoal (1 subgoal):\n 1. digit_decode ds is < prod_list ds", "proof (induction rule:valid_index.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. digit_decode [] [] < prod_list []\n 2. \\<And>is ds i d.\n       \\<lbrakk>is \\<lhd> ds; digit_decode ds is < prod_list ds;\n        i < d\\<rbrakk>\n       \\<Longrightarrow> digit_decode (d # ds) (i # is) < prod_list (d # ds)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. digit_decode [] [] < prod_list []\n 2. \\<And>is ds i d.\n       \\<lbrakk>is \\<lhd> ds; digit_decode ds is < prod_list ds;\n        i < d\\<rbrakk>\n       \\<Longrightarrow> digit_decode (d # ds) (i # is) < prod_list (d # ds)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. digit_decode [] [] < prod_list []", "by simp"], ["proof (state)\nthis:\n  digit_decode [] [] < prod_list []\n\ngoal (1 subgoal):\n 1. \\<And>is ds i d.\n       \\<lbrakk>is \\<lhd> ds; digit_decode ds is < prod_list ds;\n        i < d\\<rbrakk>\n       \\<Longrightarrow> digit_decode (d # ds) (i # is) < prod_list (d # ds)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is ds i d.\n       \\<lbrakk>is \\<lhd> ds; digit_decode ds is < prod_list ds;\n        i < d\\<rbrakk>\n       \\<Longrightarrow> digit_decode (d # ds) (i # is) < prod_list (d # ds)", "case (Cons \"is\" ds i d)"], ["proof (state)\nthis:\n  is \\<lhd> ds\n  i < d\n  digit_decode ds is < prod_list ds\n\ngoal (1 subgoal):\n 1. \\<And>is ds i d.\n       \\<lbrakk>is \\<lhd> ds; digit_decode ds is < prod_list ds;\n        i < d\\<rbrakk>\n       \\<Longrightarrow> digit_decode (d # ds) (i # is) < prod_list (d # ds)", "have \"(i + d * digit_decode ds is) div (d * prod_list ds) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i + d * digit_decode ds is) div (d * prod_list ds) = 0", "using Cons.IH Cons.hyps(2) div_mult2_eq"], ["proof (prove)\nusing this:\n  digit_decode ds is < prod_list ds\n  i < d\n  ?m div (?n * ?q) = ?m div ?n div ?q\n\ngoal (1 subgoal):\n 1. (i + d * digit_decode ds is) div (d * prod_list ds) = 0", "by force"], ["proof (state)\nthis:\n  (i + d * digit_decode ds is) div (d * prod_list ds) = 0\n\ngoal (1 subgoal):\n 1. \\<And>is ds i d.\n       \\<lbrakk>is \\<lhd> ds; digit_decode ds is < prod_list ds;\n        i < d\\<rbrakk>\n       \\<Longrightarrow> digit_decode (d # ds) (i # is) < prod_list (d # ds)", "then"], ["proof (chain)\npicking this:\n  (i + d * digit_decode ds is) div (d * prod_list ds) = 0", "show ?case"], ["proof (prove)\nusing this:\n  (i + d * digit_decode ds is) div (d * prod_list ds) = 0\n\ngoal (1 subgoal):\n 1. digit_decode (d # ds) (i # is) < prod_list (d # ds)", "unfolding digit_decode.simps prod_list.Cons"], ["proof (prove)\nusing this:\n  (i + d * digit_decode ds is) div (d * prod_list ds) = 0\n\ngoal (1 subgoal):\n 1. i + d * digit_decode ds is < d * prod_list ds", "by (metis (no_types) Cons.IH Cons.hyps(2) div_eq_0_iff mult_eq_0_iff not_less0)"], ["proof (state)\nthis:\n  digit_decode (d # ds) (i # is) < prod_list (d # ds)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma digit_encode_valid_index:\nassumes \"a < prod_list ds\"\nshows \"digit_encode ds a \\<lhd> ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. digit_encode ds a \\<lhd> ds", "using assms"], ["proof (prove)\nusing this:\n  a < prod_list ds\n\ngoal (1 subgoal):\n 1. digit_encode ds a \\<lhd> ds", "proof (induction ds arbitrary:a)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. a < prod_list [] \\<Longrightarrow> digit_encode [] a \\<lhd> []\n 2. \\<And>a ds aa.\n       \\<lbrakk>\\<And>a.\n                   a < prod_list ds \\<Longrightarrow>\n                   digit_encode ds a \\<lhd> ds;\n        aa < prod_list (a # ds)\\<rbrakk>\n       \\<Longrightarrow> digit_encode (a # ds) aa \\<lhd> a # ds", "case Nil"], ["proof (state)\nthis:\n  a < prod_list []\n\ngoal (2 subgoals):\n 1. \\<And>a. a < prod_list [] \\<Longrightarrow> digit_encode [] a \\<lhd> []\n 2. \\<And>a ds aa.\n       \\<lbrakk>\\<And>a.\n                   a < prod_list ds \\<Longrightarrow>\n                   digit_encode ds a \\<lhd> ds;\n        aa < prod_list (a # ds)\\<rbrakk>\n       \\<Longrightarrow> digit_encode (a # ds) aa \\<lhd> a # ds", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. digit_encode [] a \\<lhd> []", "by (simp add: valid_index.Nil)"], ["proof (state)\nthis:\n  digit_encode [] a \\<lhd> []\n\ngoal (1 subgoal):\n 1. \\<And>a ds aa.\n       \\<lbrakk>\\<And>a.\n                   a < prod_list ds \\<Longrightarrow>\n                   digit_encode ds a \\<lhd> ds;\n        aa < prod_list (a # ds)\\<rbrakk>\n       \\<Longrightarrow> digit_encode (a # ds) aa \\<lhd> a # ds", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ds aa.\n       \\<lbrakk>\\<And>a.\n                   a < prod_list ds \\<Longrightarrow>\n                   digit_encode ds a \\<lhd> ds;\n        aa < prod_list (a # ds)\\<rbrakk>\n       \\<Longrightarrow> digit_encode (a # ds) aa \\<lhd> a # ds", "case (Cons d ds a)"], ["proof (state)\nthis:\n  ?a < prod_list ds \\<Longrightarrow> digit_encode ds ?a \\<lhd> ds\n  a < prod_list (d # ds)\n\ngoal (1 subgoal):\n 1. \\<And>a ds aa.\n       \\<lbrakk>\\<And>a.\n                   a < prod_list ds \\<Longrightarrow>\n                   digit_encode ds a \\<lhd> ds;\n        aa < prod_list (a # ds)\\<rbrakk>\n       \\<Longrightarrow> digit_encode (a # ds) aa \\<lhd> a # ds", "then"], ["proof (chain)\npicking this:\n  ?a < prod_list ds \\<Longrightarrow> digit_encode ds ?a \\<lhd> ds\n  a < prod_list (d # ds)", "have \"a < d * prod_list ds\""], ["proof (prove)\nusing this:\n  ?a < prod_list ds \\<Longrightarrow> digit_encode ds ?a \\<lhd> ds\n  a < prod_list (d # ds)\n\ngoal (1 subgoal):\n 1. a < d * prod_list ds", "by simp"], ["proof (state)\nthis:\n  a < d * prod_list ds\n\ngoal (1 subgoal):\n 1. \\<And>a ds aa.\n       \\<lbrakk>\\<And>a.\n                   a < prod_list ds \\<Longrightarrow>\n                   digit_encode ds a \\<lhd> ds;\n        aa < prod_list (a # ds)\\<rbrakk>\n       \\<Longrightarrow> digit_encode (a # ds) aa \\<lhd> a # ds", "then"], ["proof (chain)\npicking this:\n  a < d * prod_list ds", "have \"a div d < prod_list ds\""], ["proof (prove)\nusing this:\n  a < d * prod_list ds\n\ngoal (1 subgoal):\n 1. a div d < prod_list ds", "by (metis div_eq_0_iff div_mult2_eq mult_0_right not_less0)"], ["proof (state)\nthis:\n  a div d < prod_list ds\n\ngoal (1 subgoal):\n 1. \\<And>a ds aa.\n       \\<lbrakk>\\<And>a.\n                   a < prod_list ds \\<Longrightarrow>\n                   digit_encode ds a \\<lhd> ds;\n        aa < prod_list (a # ds)\\<rbrakk>\n       \\<Longrightarrow> digit_encode (a # ds) aa \\<lhd> a # ds", "then"], ["proof (chain)\npicking this:\n  a div d < prod_list ds", "have \"digit_encode ds (a div d) \\<lhd> ds\""], ["proof (prove)\nusing this:\n  a div d < prod_list ds\n\ngoal (1 subgoal):\n 1. digit_encode ds (a div d) \\<lhd> ds", "by (rule Cons)"], ["proof (state)\nthis:\n  digit_encode ds (a div d) \\<lhd> ds\n\ngoal (1 subgoal):\n 1. \\<And>a ds aa.\n       \\<lbrakk>\\<And>a.\n                   a < prod_list ds \\<Longrightarrow>\n                   digit_encode ds a \\<lhd> ds;\n        aa < prod_list (a # ds)\\<rbrakk>\n       \\<Longrightarrow> digit_encode (a # ds) aa \\<lhd> a # ds", "moreover"], ["proof (state)\nthis:\n  digit_encode ds (a div d) \\<lhd> ds\n\ngoal (1 subgoal):\n 1. \\<And>a ds aa.\n       \\<lbrakk>\\<And>a.\n                   a < prod_list ds \\<Longrightarrow>\n                   digit_encode ds a \\<lhd> ds;\n        aa < prod_list (a # ds)\\<rbrakk>\n       \\<Longrightarrow> digit_encode (a # ds) aa \\<lhd> a # ds", "have \"d > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < d", "using \\<open>a < d * prod_list ds\\<close>"], ["proof (prove)\nusing this:\n  a < d * prod_list ds\n\ngoal (1 subgoal):\n 1. 0 < d", "by (cases \"d = 0\") simp_all"], ["proof (state)\nthis:\n  0 < d\n\ngoal (1 subgoal):\n 1. \\<And>a ds aa.\n       \\<lbrakk>\\<And>a.\n                   a < prod_list ds \\<Longrightarrow>\n                   digit_encode ds a \\<lhd> ds;\n        aa < prod_list (a # ds)\\<rbrakk>\n       \\<Longrightarrow> digit_encode (a # ds) aa \\<lhd> a # ds", "then"], ["proof (chain)\npicking this:\n  0 < d", "have \"a mod d < d\""], ["proof (prove)\nusing this:\n  0 < d\n\ngoal (1 subgoal):\n 1. a mod d < d", "by simp"], ["proof (state)\nthis:\n  a mod d < d\n\ngoal (1 subgoal):\n 1. \\<And>a ds aa.\n       \\<lbrakk>\\<And>a.\n                   a < prod_list ds \\<Longrightarrow>\n                   digit_encode ds a \\<lhd> ds;\n        aa < prod_list (a # ds)\\<rbrakk>\n       \\<Longrightarrow> digit_encode (a # ds) aa \\<lhd> a # ds", "ultimately"], ["proof (chain)\npicking this:\n  digit_encode ds (a div d) \\<lhd> ds\n  a mod d < d", "show ?case"], ["proof (prove)\nusing this:\n  digit_encode ds (a div d) \\<lhd> ds\n  a mod d < d\n\ngoal (1 subgoal):\n 1. digit_encode (d # ds) a \\<lhd> d # ds", "by (simp add: valid_index.Cons)"], ["proof (state)\nthis:\n  digit_encode (d # ds) a \\<lhd> d # ds\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_digit_encode:\nshows \"length (digit_encode ds a) = length ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (digit_encode ds a) = length ds", "by (induction ds arbitrary:a; simp_all)"], ["", "lemma digit_encode_0:\n\"prod_list ds dvd a \\<Longrightarrow> digit_encode ds a = replicate (length ds) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list ds dvd a \\<Longrightarrow>\n    digit_encode ds a = replicate (length ds) 0", "proof (induction ds arbitrary:a)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       prod_list [] dvd a \\<Longrightarrow>\n       digit_encode [] a = replicate (length []) 0\n 2. \\<And>a ds aa.\n       \\<lbrakk>\\<And>a.\n                   prod_list ds dvd a \\<Longrightarrow>\n                   digit_encode ds a = replicate (length ds) 0;\n        prod_list (a # ds) dvd aa\\<rbrakk>\n       \\<Longrightarrow> digit_encode (a # ds) aa =\n                         replicate (length (a # ds)) 0", "case Nil"], ["proof (state)\nthis:\n  prod_list [] dvd a\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       prod_list [] dvd a \\<Longrightarrow>\n       digit_encode [] a = replicate (length []) 0\n 2. \\<And>a ds aa.\n       \\<lbrakk>\\<And>a.\n                   prod_list ds dvd a \\<Longrightarrow>\n                   digit_encode ds a = replicate (length ds) 0;\n        prod_list (a # ds) dvd aa\\<rbrakk>\n       \\<Longrightarrow> digit_encode (a # ds) aa =\n                         replicate (length (a # ds)) 0", "then"], ["proof (chain)\npicking this:\n  prod_list [] dvd a", "show ?case"], ["proof (prove)\nusing this:\n  prod_list [] dvd a\n\ngoal (1 subgoal):\n 1. digit_encode [] a = replicate (length []) 0", "by simp"], ["proof (state)\nthis:\n  digit_encode [] a = replicate (length []) 0\n\ngoal (1 subgoal):\n 1. \\<And>a ds aa.\n       \\<lbrakk>\\<And>a.\n                   prod_list ds dvd a \\<Longrightarrow>\n                   digit_encode ds a = replicate (length ds) 0;\n        prod_list (a # ds) dvd aa\\<rbrakk>\n       \\<Longrightarrow> digit_encode (a # ds) aa =\n                         replicate (length (a # ds)) 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ds aa.\n       \\<lbrakk>\\<And>a.\n                   prod_list ds dvd a \\<Longrightarrow>\n                   digit_encode ds a = replicate (length ds) 0;\n        prod_list (a # ds) dvd aa\\<rbrakk>\n       \\<Longrightarrow> digit_encode (a # ds) aa =\n                         replicate (length (a # ds)) 0", "case (Cons d ds a)"], ["proof (state)\nthis:\n  prod_list ds dvd ?a \\<Longrightarrow>\n  digit_encode ds ?a = replicate (length ds) 0\n  prod_list (d # ds) dvd a\n\ngoal (1 subgoal):\n 1. \\<And>a ds aa.\n       \\<lbrakk>\\<And>a.\n                   prod_list ds dvd a \\<Longrightarrow>\n                   digit_encode ds a = replicate (length ds) 0;\n        prod_list (a # ds) dvd aa\\<rbrakk>\n       \\<Longrightarrow> digit_encode (a # ds) aa =\n                         replicate (length (a # ds)) 0", "then"], ["proof (chain)\npicking this:\n  prod_list ds dvd ?a \\<Longrightarrow>\n  digit_encode ds ?a = replicate (length ds) 0\n  prod_list (d # ds) dvd a", "have \"prod_list ds dvd (a div d)\""], ["proof (prove)\nusing this:\n  prod_list ds dvd ?a \\<Longrightarrow>\n  digit_encode ds ?a = replicate (length ds) 0\n  prod_list (d # ds) dvd a\n\ngoal (1 subgoal):\n 1. prod_list ds dvd a div d", "unfolding prod_list.Cons"], ["proof (prove)\nusing this:\n  prod_list ds dvd ?a \\<Longrightarrow>\n  digit_encode ds ?a = replicate (length ds) 0\n  d * prod_list ds dvd a\n\ngoal (1 subgoal):\n 1. prod_list ds dvd a div d", "by (metis dvd_0_right dvd_div_iff_mult dvd_mult_left mult.commute split_div)"], ["proof (state)\nthis:\n  prod_list ds dvd a div d\n\ngoal (1 subgoal):\n 1. \\<And>a ds aa.\n       \\<lbrakk>\\<And>a.\n                   prod_list ds dvd a \\<Longrightarrow>\n                   digit_encode ds a = replicate (length ds) 0;\n        prod_list (a # ds) dvd aa\\<rbrakk>\n       \\<Longrightarrow> digit_encode (a # ds) aa =\n                         replicate (length (a # ds)) 0", "then"], ["proof (chain)\npicking this:\n  prod_list ds dvd a div d", "show ?case"], ["proof (prove)\nusing this:\n  prod_list ds dvd a div d\n\ngoal (1 subgoal):\n 1. digit_encode (d # ds) a = replicate (length (d # ds)) 0", "unfolding digit_encode.simps length_Cons replicate_Suc prod_list.Cons"], ["proof (prove)\nusing this:\n  prod_list ds dvd a div d\n\ngoal (1 subgoal):\n 1. a mod d # digit_encode ds (a div d) = 0 # replicate (length ds) 0", "using Cons"], ["proof (prove)\nusing this:\n  prod_list ds dvd a div d\n  prod_list ds dvd ?a \\<Longrightarrow>\n  digit_encode ds ?a = replicate (length ds) 0\n  prod_list (d # ds) dvd a\n\ngoal (1 subgoal):\n 1. a mod d # digit_encode ds (a div d) = 0 # replicate (length ds) 0", "using dvd_imp_mod_0 dvd_mult_left prod_list.Cons"], ["proof (prove)\nusing this:\n  prod_list ds dvd a div d\n  prod_list ds dvd ?a \\<Longrightarrow>\n  digit_encode ds ?a = replicate (length ds) 0\n  prod_list (d # ds) dvd a\n  ?a dvd ?b \\<Longrightarrow> ?b mod ?a = (0::?'a)\n  ?a * ?b dvd ?c \\<Longrightarrow> ?a dvd ?c\n  prod_list (?x # ?xs) = ?x * prod_list ?xs\n\ngoal (1 subgoal):\n 1. a mod d # digit_encode ds (a div d) = 0 # replicate (length ds) 0", "by force"], ["proof (state)\nthis:\n  digit_encode (d # ds) a = replicate (length (d # ds)) 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_index_weave:\nassumes \"is1 \\<lhd> (nths ds A)\"\nand     \"is2 \\<lhd> (nths ds (-A))\"\nshows \"weave A is1 is2 \\<lhd> ds\"\nand \"nths (weave A is1 is2) A = is1\"\nand \"nths (weave A is1 is2) (-A) = is2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weave A is1 is2 \\<lhd> ds &&&\n    nths (weave A is1 is2) A = is1 &&& nths (weave A is1 is2) (- A) = is2", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. weave A is1 is2 \\<lhd> ds\n 2. nths (weave A is1 is2) A = is1\n 3. nths (weave A is1 is2) (- A) = is2", "have length_ds: \"length is1 + length is2 = length ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length is1 + length is2 = length ds", "using valid_index_length[OF assms(1)] valid_index_length[OF assms(2)]\n    length_weave  weave_complementary_nthss"], ["proof (prove)\nusing this:\n  length is1 = length (nths ds A)\n  length is2 = length (nths ds (- A))\n  length (weave ?A ?xs ?ys) = length ?xs + length ?ys\n  weave ?A (nths ?xs ?A) (nths ?xs (- ?A)) = ?xs\n\ngoal (1 subgoal):\n 1. length is1 + length is2 = length ds", "by metis"], ["proof (state)\nthis:\n  length is1 + length is2 = length ds\n\ngoal (3 subgoals):\n 1. weave A is1 is2 \\<lhd> ds\n 2. nths (weave A is1 is2) A = is1\n 3. nths (weave A is1 is2) (- A) = is2", "have 1:\"length is1 = card {i \\<in> A. i < length is1 + length is2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length is1 = card {i \\<in> A. i < length is1 + length is2}", "unfolding length_ds"], ["proof (prove)\ngoal (1 subgoal):\n 1. length is1 = card {i \\<in> A. i < length ds}", "using length_nths' assms(1) valid_index_length"], ["proof (prove)\nusing this:\n  length (nths ?xs ?I) = card {i \\<in> ?I. i < length ?xs}\n  is1 \\<lhd> nths ds A\n  ?is \\<lhd> ?ds \\<Longrightarrow> length ?is = length ?ds\n\ngoal (1 subgoal):\n 1. length is1 = card {i \\<in> A. i < length ds}", "by auto"], ["proof (state)\nthis:\n  length is1 = card {i \\<in> A. i < length is1 + length is2}\n\ngoal (3 subgoals):\n 1. weave A is1 is2 \\<lhd> ds\n 2. nths (weave A is1 is2) A = is1\n 3. nths (weave A is1 is2) (- A) = is2", "have 2:\"length is2 = card {i \\<in> -A. i < length is1 + length is2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length is2 = card {i \\<in> - A. i < length is1 + length is2}", "unfolding length_ds"], ["proof (prove)\ngoal (1 subgoal):\n 1. length is2 = card {i \\<in> - A. i < length ds}", "using length_nths'[of ds \"-A\"] assms(2) valid_index_length"], ["proof (prove)\nusing this:\n  length (nths ds (- A)) = card {i \\<in> - A. i < length ds}\n  is2 \\<lhd> nths ds (- A)\n  ?is \\<lhd> ?ds \\<Longrightarrow> length ?is = length ?ds\n\ngoal (1 subgoal):\n 1. length is2 = card {i \\<in> - A. i < length ds}", "by auto"], ["proof (state)\nthis:\n  length is2 = card {i \\<in> - A. i < length is1 + length is2}\n\ngoal (3 subgoals):\n 1. weave A is1 is2 \\<lhd> ds\n 2. nths (weave A is1 is2) A = is1\n 3. nths (weave A is1 is2) (- A) = is2", "show \"nths (weave A is1 is2) A = is1\" \"nths (weave A is1 is2) (-A) = is2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths (weave A is1 is2) A = is1 &&& nths (weave A is1 is2) (- A) = is2", "using nths_weave[OF 1 2]"], ["proof (prove)\nusing this:\n  nths (weave A is1 is2) A = is1 \\<and> nths (weave A is1 is2) (- A) = is2\n\ngoal (1 subgoal):\n 1. nths (weave A is1 is2) A = is1 &&& nths (weave A is1 is2) (- A) = is2", "by blast+"], ["proof (state)\nthis:\n  nths (weave A is1 is2) A = is1\n  nths (weave A is1 is2) (- A) = is2\n\ngoal (1 subgoal):\n 1. weave A is1 is2 \\<lhd> ds", "then"], ["proof (chain)\npicking this:\n  nths (weave A is1 is2) A = is1\n  nths (weave A is1 is2) (- A) = is2", "have \"nths (weave A is1 is2) A \\<lhd> (nths ds A)\"\n       \"nths (weave A is1 is2) (-A) \\<lhd> (nths ds (-A))\""], ["proof (prove)\nusing this:\n  nths (weave A is1 is2) A = is1\n  nths (weave A is1 is2) (- A) = is2\n\ngoal (1 subgoal):\n 1. nths (weave A is1 is2) A \\<lhd> nths ds A &&&\n    nths (weave A is1 is2) (- A) \\<lhd> nths ds (- A)", "using assms"], ["proof (prove)\nusing this:\n  nths (weave A is1 is2) A = is1\n  nths (weave A is1 is2) (- A) = is2\n  is1 \\<lhd> nths ds A\n  is2 \\<lhd> nths ds (- A)\n\ngoal (1 subgoal):\n 1. nths (weave A is1 is2) A \\<lhd> nths ds A &&&\n    nths (weave A is1 is2) (- A) \\<lhd> nths ds (- A)", "by auto"], ["proof (state)\nthis:\n  nths (weave A is1 is2) A \\<lhd> nths ds A\n  nths (weave A is1 is2) (- A) \\<lhd> nths ds (- A)\n\ngoal (1 subgoal):\n 1. weave A is1 is2 \\<lhd> ds", "then"], ["proof (chain)\npicking this:\n  nths (weave A is1 is2) A \\<lhd> nths ds A\n  nths (weave A is1 is2) (- A) \\<lhd> nths ds (- A)", "show \"weave A is1 is2 \\<lhd> ds\""], ["proof (prove)\nusing this:\n  nths (weave A is1 is2) A \\<lhd> nths ds A\n  nths (weave A is1 is2) (- A) \\<lhd> nths ds (- A)\n\ngoal (1 subgoal):\n 1. weave A is1 is2 \\<lhd> ds", "using list_all2_nths valid_index_list_all2_iff"], ["proof (prove)\nusing this:\n  nths (weave A is1 is2) A \\<lhd> nths ds A\n  nths (weave A is1 is2) (- A) \\<lhd> nths ds (- A)\n  \\<lbrakk>list_all2 ?P (nths ?xs ?A) (nths ?ys ?A);\n   list_all2 ?P (nths ?xs (- ?A)) (nths ?ys (- ?A))\\<rbrakk>\n  \\<Longrightarrow> list_all2 ?P ?xs ?ys\n  (?is \\<lhd> ?ds) = list_all2 (<) ?is ?ds\n\ngoal (1 subgoal):\n 1. weave A is1 is2 \\<lhd> ds", "by blast"], ["proof (state)\nthis:\n  weave A is1 is2 \\<lhd> ds\n\ngoal:\nNo subgoals!", "qed"], ["", "definition matricize :: \"nat set \\<Rightarrow> 'a tensor \\<Rightarrow> 'a mat\" where\n\"matricize rmodes T = mat\n  (prod_list (nths (Tensor.dims T) rmodes))\n  (prod_list (nths (Tensor.dims T) (-rmodes)))\n  (\\<lambda>(r, c). Tensor.lookup T (weave rmodes\n    (digit_encode (nths (Tensor.dims T) rmodes) r)\n    (digit_encode (nths (Tensor.dims T) (-rmodes)) c)\n  ))\n\""], ["", "definition dematricize::\"nat set \\<Rightarrow> 'a mat \\<Rightarrow> nat list \\<Rightarrow> 'a tensor\" where\n\"dematricize rmodes A ds  = tensor_from_lookup ds\n  (\\<lambda>is. A $$ (digit_decode (nths ds rmodes) (nths is rmodes),\n              digit_decode (nths ds (-rmodes)) (nths is (-rmodes)))\n )\n\""], ["", "lemma dims_matricize:\n\"dim_row (matricize rmodes T) = prod_list (nths (Tensor.dims T) rmodes)\"\n\"dim_col (matricize rmodes T) = prod_list (nths (Tensor.dims T) (-rmodes))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (matricize rmodes T) = prod_list (nths (dims T) rmodes) &&&\n    dim_col (matricize rmodes T) = prod_list (nths (dims T) (- rmodes))", "unfolding matricize_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row\n     (mat (prod_list (nths (dims T) rmodes))\n       (prod_list (nths (dims T) (- rmodes)))\n       (\\<lambda>(r, c).\n           lookup T\n            (weave rmodes (digit_encode (nths (dims T) rmodes) r)\n              (digit_encode (nths (dims T) (- rmodes)) c)))) =\n    prod_list (nths (dims T) rmodes) &&&\n    dim_col\n     (mat (prod_list (nths (dims T) rmodes))\n       (prod_list (nths (dims T) (- rmodes)))\n       (\\<lambda>(r, c).\n           lookup T\n            (weave rmodes (digit_encode (nths (dims T) rmodes) r)\n              (digit_encode (nths (dims T) (- rmodes)) c)))) =\n    prod_list (nths (dims T) (- rmodes))", "using dim_row_mat"], ["proof (prove)\nusing this:\n  dim_row (mat ?nr ?nc ?f) = ?nr\n  dim_row (mat\\<^sub>r ?nr ?nc ?g) = ?nr\n\ngoal (1 subgoal):\n 1. dim_row\n     (mat (prod_list (nths (dims T) rmodes))\n       (prod_list (nths (dims T) (- rmodes)))\n       (\\<lambda>(r, c).\n           lookup T\n            (weave rmodes (digit_encode (nths (dims T) rmodes) r)\n              (digit_encode (nths (dims T) (- rmodes)) c)))) =\n    prod_list (nths (dims T) rmodes) &&&\n    dim_col\n     (mat (prod_list (nths (dims T) rmodes))\n       (prod_list (nths (dims T) (- rmodes)))\n       (\\<lambda>(r, c).\n           lookup T\n            (weave rmodes (digit_encode (nths (dims T) rmodes) r)\n              (digit_encode (nths (dims T) (- rmodes)) c)))) =\n    prod_list (nths (dims T) (- rmodes))", "by simp_all"], ["", "lemma dims_dematricize: \"Tensor.dims (dematricize rmodes A ds) = ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dims (dematricize rmodes A ds) = ds", "by (simp add: dematricize_def dims_tensor_from_lookup)"], ["", "lemma valid_index_nths:\nassumes \"is \\<lhd> ds\"\nshows \"nths is A \\<lhd> nths ds A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nths is A \\<lhd> nths ds A", "using assms"], ["proof (prove)\nusing this:\n  is \\<lhd> ds\n\ngoal (1 subgoal):\n 1. nths is A \\<lhd> nths ds A", "proof (induction arbitrary:A rule:valid_index.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A. nths [] A \\<lhd> nths [] A\n 2. \\<And>is ds i d A.\n       \\<lbrakk>is \\<lhd> ds; \\<And>A. nths is A \\<lhd> nths ds A;\n        i < d\\<rbrakk>\n       \\<Longrightarrow> nths (i # is) A \\<lhd> nths (d # ds) A", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>A. nths [] A \\<lhd> nths [] A\n 2. \\<And>is ds i d A.\n       \\<lbrakk>is \\<lhd> ds; \\<And>A. nths is A \\<lhd> nths ds A;\n        i < d\\<rbrakk>\n       \\<Longrightarrow> nths (i # is) A \\<lhd> nths (d # ds) A", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nths [] A \\<lhd> nths [] A", "using nths_nil valid_index.simps"], ["proof (prove)\nusing this:\n  nths [] ?A = []\n  (?a1.0 \\<lhd> ?a2.0) =\n  (?a1.0 = [] \\<and> ?a2.0 = [] \\<or>\n   (\\<exists>is ds i d.\n       ?a1.0 = i # is \\<and>\n       ?a2.0 = d # ds \\<and> is \\<lhd> ds \\<and> i < d))\n\ngoal (1 subgoal):\n 1. nths [] A \\<lhd> nths [] A", "by blast"], ["proof (state)\nthis:\n  nths [] A \\<lhd> nths [] A\n\ngoal (1 subgoal):\n 1. \\<And>is ds i d A.\n       \\<lbrakk>is \\<lhd> ds; \\<And>A. nths is A \\<lhd> nths ds A;\n        i < d\\<rbrakk>\n       \\<Longrightarrow> nths (i # is) A \\<lhd> nths (d # ds) A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is ds i d A.\n       \\<lbrakk>is \\<lhd> ds; \\<And>A. nths is A \\<lhd> nths ds A;\n        i < d\\<rbrakk>\n       \\<Longrightarrow> nths (i # is) A \\<lhd> nths (d # ds) A", "case (Cons \"is\" ds i d)"], ["proof (state)\nthis:\n  is \\<lhd> ds\n  i < d\n  nths is ?A \\<lhd> nths ds ?A\n\ngoal (1 subgoal):\n 1. \\<And>is ds i d A.\n       \\<lbrakk>is \\<lhd> ds; \\<And>A. nths is A \\<lhd> nths ds A;\n        i < d\\<rbrakk>\n       \\<Longrightarrow> nths (i # is) A \\<lhd> nths (d # ds) A", "then"], ["proof (chain)\npicking this:\n  is \\<lhd> ds\n  i < d\n  nths is ?A \\<lhd> nths ds ?A", "have \" nths is {j. Suc j \\<in> A} \\<lhd> nths ds {j. Suc j \\<in> A}\""], ["proof (prove)\nusing this:\n  is \\<lhd> ds\n  i < d\n  nths is ?A \\<lhd> nths ds ?A\n\ngoal (1 subgoal):\n 1. nths is {j. Suc j \\<in> A} \\<lhd> nths ds {j. Suc j \\<in> A}", "by simp"], ["proof (state)\nthis:\n  nths is {j. Suc j \\<in> A} \\<lhd> nths ds {j. Suc j \\<in> A}\n\ngoal (1 subgoal):\n 1. \\<And>is ds i d A.\n       \\<lbrakk>is \\<lhd> ds; \\<And>A. nths is A \\<lhd> nths ds A;\n        i < d\\<rbrakk>\n       \\<Longrightarrow> nths (i # is) A \\<lhd> nths (d # ds) A", "then"], ["proof (chain)\npicking this:\n  nths is {j. Suc j \\<in> A} \\<lhd> nths ds {j. Suc j \\<in> A}", "show ?case"], ["proof (prove)\nusing this:\n  nths is {j. Suc j \\<in> A} \\<lhd> nths ds {j. Suc j \\<in> A}\n\ngoal (1 subgoal):\n 1. nths (i # is) A \\<lhd> nths (d # ds) A", "unfolding nths_Cons"], ["proof (prove)\nusing this:\n  nths is {j. Suc j \\<in> A} \\<lhd> nths ds {j. Suc j \\<in> A}\n\ngoal (1 subgoal):\n 1. (if 0 \\<in> A then [i] else []) @ nths is {j. Suc j \\<in> A} \\<lhd>\n    (if 0 \\<in> A then [d] else []) @ nths ds {j. Suc j \\<in> A}", "by (cases \"0\\<in>A\"; simp_all add: Cons.hyps(2) valid_index.Cons)"], ["proof (state)\nthis:\n  nths (i # is) A \\<lhd> nths (d # ds) A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dematricize_matricize:\nshows \"dematricize rmodes (matricize rmodes T) (Tensor.dims T) = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dematricize rmodes (matricize rmodes T) (dims T) = T", "proof (rule tensor_lookup_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. dims (dematricize rmodes (matricize rmodes T) (dims T)) = dims T\n 2. \\<And>is.\n       is \\<lhd>\n       dims\n        (dematricize rmodes (matricize rmodes T) (dims T)) \\<Longrightarrow>\n       lookup (dematricize rmodes (matricize rmodes T) (dims T)) is =\n       lookup T is", "show 1:\"Tensor.dims (dematricize rmodes (matricize rmodes T) (Tensor.dims T)) = Tensor.dims T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dims (dematricize rmodes (matricize rmodes T) (dims T)) = dims T", "by (simp add: dematricize_def dims_tensor_from_lookup)"], ["proof (state)\nthis:\n  dims (dematricize rmodes (matricize rmodes T) (dims T)) = dims T\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd>\n       dims\n        (dematricize rmodes (matricize rmodes T) (dims T)) \\<Longrightarrow>\n       lookup (dematricize rmodes (matricize rmodes T) (dims T)) is =\n       lookup T is", "fix \"is\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd>\n       dims\n        (dematricize rmodes (matricize rmodes T) (dims T)) \\<Longrightarrow>\n       lookup (dematricize rmodes (matricize rmodes T) (dims T)) is =\n       lookup T is", "assume \"is \\<lhd> Tensor.dims (dematricize rmodes (matricize rmodes T) (Tensor.dims T))\""], ["proof (state)\nthis:\n  is \\<lhd> dims (dematricize rmodes (matricize rmodes T) (dims T))\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd>\n       dims\n        (dematricize rmodes (matricize rmodes T) (dims T)) \\<Longrightarrow>\n       lookup (dematricize rmodes (matricize rmodes T) (dims T)) is =\n       lookup T is", "then"], ["proof (chain)\npicking this:\n  is \\<lhd> dims (dematricize rmodes (matricize rmodes T) (dims T))", "have \"is \\<lhd> Tensor.dims T\""], ["proof (prove)\nusing this:\n  is \\<lhd> dims (dematricize rmodes (matricize rmodes T) (dims T))\n\ngoal (1 subgoal):\n 1. is \\<lhd> dims T", "using 1"], ["proof (prove)\nusing this:\n  is \\<lhd> dims (dematricize rmodes (matricize rmodes T) (dims T))\n  dims (dematricize rmodes (matricize rmodes T) (dims T)) = dims T\n\ngoal (1 subgoal):\n 1. is \\<lhd> dims T", "by auto"], ["proof (state)\nthis:\n  is \\<lhd> dims T\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd>\n       dims\n        (dematricize rmodes (matricize rmodes T) (dims T)) \\<Longrightarrow>\n       lookup (dematricize rmodes (matricize rmodes T) (dims T)) is =\n       lookup T is", "let ?rds = \"(nths (Tensor.dims T) rmodes)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd>\n       dims\n        (dematricize rmodes (matricize rmodes T) (dims T)) \\<Longrightarrow>\n       lookup (dematricize rmodes (matricize rmodes T) (dims T)) is =\n       lookup T is", "let ?cds = \"(nths (Tensor.dims T) (-rmodes))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd>\n       dims\n        (dematricize rmodes (matricize rmodes T) (dims T)) \\<Longrightarrow>\n       lookup (dematricize rmodes (matricize rmodes T) (dims T)) is =\n       lookup T is", "have decode_r: \"digit_decode ?rds (nths is rmodes) < prod_list ?rds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. digit_decode (nths (dims T) rmodes) (nths is rmodes)\n    < prod_list (nths (dims T) rmodes)", "by (simp add: \\<open>is \\<lhd> Tensor.dims T\\<close> valid_index_nths digit_decode_lt)"], ["proof (state)\nthis:\n  digit_decode (nths (dims T) rmodes) (nths is rmodes)\n  < prod_list (nths (dims T) rmodes)\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd>\n       dims\n        (dematricize rmodes (matricize rmodes T) (dims T)) \\<Longrightarrow>\n       lookup (dematricize rmodes (matricize rmodes T) (dims T)) is =\n       lookup T is", "have decode_c: \"digit_decode ?cds (nths is (-rmodes)) < prod_list ?cds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. digit_decode (nths (dims T) (- rmodes)) (nths is (- rmodes))\n    < prod_list (nths (dims T) (- rmodes))", "by (simp add: \\<open>is \\<lhd> Tensor.dims T\\<close> valid_index_nths digit_decode_lt)"], ["proof (state)\nthis:\n  digit_decode (nths (dims T) (- rmodes)) (nths is (- rmodes))\n  < prod_list (nths (dims T) (- rmodes))\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd>\n       dims\n        (dematricize rmodes (matricize rmodes T) (dims T)) \\<Longrightarrow>\n       lookup (dematricize rmodes (matricize rmodes T) (dims T)) is =\n       lookup T is", "have \"(matricize rmodes T) $$\n     (digit_decode ?rds (nths is rmodes),\n      digit_decode ?cds (nths is (- rmodes))) =\n    Tensor.lookup T is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matricize rmodes T $$\n    (digit_decode (nths (dims T) rmodes) (nths is rmodes),\n     digit_decode (nths (dims T) (- rmodes)) (nths is (- rmodes))) =\n    lookup T is", "unfolding matricize_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (prod_list (nths (dims T) rmodes))\n     (prod_list (nths (dims T) (- rmodes)))\n     (\\<lambda>(r, c).\n         lookup T\n          (weave rmodes (digit_encode (nths (dims T) rmodes) r)\n            (digit_encode (nths (dims T) (- rmodes)) c))) $$\n    (digit_decode (nths (dims T) rmodes) (nths is rmodes),\n     digit_decode (nths (dims T) (- rmodes)) (nths is (- rmodes))) =\n    lookup T is", "by (simp add: decode_r decode_c \\<open>is \\<lhd> Tensor.dims T\\<close> valid_index_nths)"], ["proof (state)\nthis:\n  matricize rmodes T $$\n  (digit_decode (nths (dims T) rmodes) (nths is rmodes),\n   digit_decode (nths (dims T) (- rmodes)) (nths is (- rmodes))) =\n  lookup T is\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd>\n       dims\n        (dematricize rmodes (matricize rmodes T) (dims T)) \\<Longrightarrow>\n       lookup (dematricize rmodes (matricize rmodes T) (dims T)) is =\n       lookup T is", "then"], ["proof (chain)\npicking this:\n  matricize rmodes T $$\n  (digit_decode (nths (dims T) rmodes) (nths is rmodes),\n   digit_decode (nths (dims T) (- rmodes)) (nths is (- rmodes))) =\n  lookup T is", "show \"Tensor.lookup (dematricize rmodes (matricize rmodes T) (Tensor.dims T)) is = Tensor.lookup T is\""], ["proof (prove)\nusing this:\n  matricize rmodes T $$\n  (digit_decode (nths (dims T) rmodes) (nths is rmodes),\n   digit_decode (nths (dims T) (- rmodes)) (nths is (- rmodes))) =\n  lookup T is\n\ngoal (1 subgoal):\n 1. lookup (dematricize rmodes (matricize rmodes T) (dims T)) is =\n    lookup T is", "by (simp add: dematricize_def dims_tensor_from_lookup lookup_tensor_from_lookup[OF \\<open>is \\<lhd> Tensor.dims T\\<close>])"], ["proof (state)\nthis:\n  lookup (dematricize rmodes (matricize rmodes T) (dims T)) is = lookup T is\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matricize_dematricize:\nassumes \" dim_row A = prod_list (nths ds rmodes)\"\nand \" dim_col A = prod_list (nths ds (-rmodes))\"\nshows \"matricize rmodes (dematricize rmodes A ds) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matricize rmodes (dematricize rmodes A ds) = A", "proof (rule eq_matI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> matricize rmodes (dematricize rmodes A ds) $$\n                         (i, j) =\n                         A $$ (i, j)\n 2. dim_row (matricize rmodes (dematricize rmodes A ds)) = dim_row A\n 3. dim_col (matricize rmodes (dematricize rmodes A ds)) = dim_col A", "show \"dim_row (matricize rmodes (dematricize rmodes A ds)) = dim_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (matricize rmodes (dematricize rmodes A ds)) = dim_row A", "unfolding assms(1) dematricize_def dims_tensor_from_lookup matricize_def dim_row_mat"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (nths ds rmodes) = prod_list (nths ds rmodes)", "by metis"], ["proof (state)\nthis:\n  dim_row (matricize rmodes (dematricize rmodes A ds)) = dim_row A\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> matricize rmodes (dematricize rmodes A ds) $$\n                         (i, j) =\n                         A $$ (i, j)\n 2. dim_col (matricize rmodes (dematricize rmodes A ds)) = dim_col A", "show \"dim_col (matricize rmodes (dematricize rmodes A ds)) = dim_col A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (matricize rmodes (dematricize rmodes A ds)) = dim_col A", "unfolding assms(2) dematricize_def dims_tensor_from_lookup matricize_def dim_col_mat"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (nths ds (- rmodes)) = prod_list (nths ds (- rmodes))", "by metis"], ["proof (state)\nthis:\n  dim_col (matricize rmodes (dematricize rmodes A ds)) = dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> matricize rmodes (dematricize rmodes A ds) $$\n                         (i, j) =\n                         A $$ (i, j)", "fix r c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> matricize rmodes (dematricize rmodes A ds) $$\n                         (i, j) =\n                         A $$ (i, j)", "assume \"r < dim_row A\" \"c < dim_col A\""], ["proof (state)\nthis:\n  r < dim_row A\n  c < dim_col A\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> matricize rmodes (dematricize rmodes A ds) $$\n                         (i, j) =\n                         A $$ (i, j)", "have valid1:\"digit_encode (nths ds rmodes) r \\<lhd> nths ds rmodes\" and\n       valid2:\"digit_encode (nths ds (- rmodes)) c \\<lhd> nths ds (- rmodes)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. digit_encode (nths ds rmodes) r \\<lhd> nths ds rmodes &&&\n    digit_encode (nths ds (- rmodes)) c \\<lhd> nths ds (- rmodes)", "using \\<open>r < dim_row A\\<close> assms(1) \\<open>c < dim_col A\\<close> assms(2) digit_encode_valid_index"], ["proof (prove)\nusing this:\n  r < dim_row A\n  dim_row A = prod_list (nths ds rmodes)\n  c < dim_col A\n  dim_col A = prod_list (nths ds (- rmodes))\n  ?a < prod_list ?ds \\<Longrightarrow> digit_encode ?ds ?a \\<lhd> ?ds\n\ngoal (1 subgoal):\n 1. digit_encode (nths ds rmodes) r \\<lhd> nths ds rmodes &&&\n    digit_encode (nths ds (- rmodes)) c \\<lhd> nths ds (- rmodes)", "by auto"], ["proof (state)\nthis:\n  digit_encode (nths ds rmodes) r \\<lhd> nths ds rmodes\n  digit_encode (nths ds (- rmodes)) c \\<lhd> nths ds (- rmodes)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> matricize rmodes (dematricize rmodes A ds) $$\n                         (i, j) =\n                         A $$ (i, j)", "have 0:\"Tensor.lookup (dematricize rmodes A ds)\n     (weave rmodes\n       (digit_encode (nths (Tensor.dims (dematricize rmodes A ds)) rmodes) r)\n       (digit_encode (nths (Tensor.dims (dematricize rmodes A ds)) (- rmodes)) c)\n     ) =  A $$ (r, c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (dematricize rmodes A ds)\n     (weave rmodes\n       (digit_encode (nths (dims (dematricize rmodes A ds)) rmodes) r)\n       (digit_encode (nths (dims (dematricize rmodes A ds)) (- rmodes))\n         c)) =\n    A $$ (r, c)", "unfolding dematricize_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup\n     (tensor_from_lookup ds\n       (\\<lambda>is.\n           A $$\n           (digit_decode (nths ds rmodes) (nths is rmodes),\n            digit_decode (nths ds (- rmodes)) (nths is (- rmodes)))))\n     (weave rmodes\n       (digit_encode\n         (nths\n           (dims\n             (tensor_from_lookup ds\n               (\\<lambda>is.\n                   A $$\n                   (digit_decode (nths ds rmodes) (nths is rmodes),\n                    digit_decode (nths ds (- rmodes))\n                     (nths is (- rmodes))))))\n           rmodes)\n         r)\n       (digit_encode\n         (nths\n           (dims\n             (tensor_from_lookup ds\n               (\\<lambda>is.\n                   A $$\n                   (digit_decode (nths ds rmodes) (nths is rmodes),\n                    digit_decode (nths ds (- rmodes))\n                     (nths is (- rmodes))))))\n           (- rmodes))\n         c)) =\n    A $$ (r, c)", "unfolding dims_tensor_from_lookup"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup\n     (tensor_from_lookup ds\n       (\\<lambda>is.\n           A $$\n           (digit_decode (nths ds rmodes) (nths is rmodes),\n            digit_decode (nths ds (- rmodes)) (nths is (- rmodes)))))\n     (weave rmodes (digit_encode (nths ds rmodes) r)\n       (digit_encode (nths ds (- rmodes)) c)) =\n    A $$ (r, c)", "unfolding lookup_tensor_from_lookup[OF valid_index_weave(1)[OF valid1 valid2]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. A $$\n    (digit_decode (nths ds rmodes)\n      (nths\n        (weave rmodes (digit_encode (nths ds rmodes) r)\n          (digit_encode (nths ds (- rmodes)) c))\n        rmodes),\n     digit_decode (nths ds (- rmodes))\n      (nths\n        (weave rmodes (digit_encode (nths ds rmodes) r)\n          (digit_encode (nths ds (- rmodes)) c))\n        (- rmodes))) =\n    A $$ (r, c)", "using digit_decode_encode_lt[OF \\<open>c < dim_col A\\<close>[unfolded assms(2)]]\n      digit_decode_encode_lt[OF \\<open>r < dim_row A\\<close>[unfolded assms(1)]]\n      valid_index_weave(2)[OF valid1 valid2] valid_index_weave(3)[OF valid1 valid2]"], ["proof (prove)\nusing this:\n  digit_decode (nths ds (- rmodes)) (digit_encode (nths ds (- rmodes)) c) =\n  c\n  digit_decode (nths ds rmodes) (digit_encode (nths ds rmodes) r) = r\n  nths\n   (weave rmodes (digit_encode (nths ds rmodes) r)\n     (digit_encode (nths ds (- rmodes)) c))\n   rmodes =\n  digit_encode (nths ds rmodes) r\n  nths\n   (weave rmodes (digit_encode (nths ds rmodes) r)\n     (digit_encode (nths ds (- rmodes)) c))\n   (- rmodes) =\n  digit_encode (nths ds (- rmodes)) c\n\ngoal (1 subgoal):\n 1. A $$\n    (digit_decode (nths ds rmodes)\n      (nths\n        (weave rmodes (digit_encode (nths ds rmodes) r)\n          (digit_encode (nths ds (- rmodes)) c))\n        rmodes),\n     digit_decode (nths ds (- rmodes))\n      (nths\n        (weave rmodes (digit_encode (nths ds rmodes) r)\n          (digit_encode (nths ds (- rmodes)) c))\n        (- rmodes))) =\n    A $$ (r, c)", "by presburger"], ["proof (state)\nthis:\n  lookup (dematricize rmodes A ds)\n   (weave rmodes\n     (digit_encode (nths (dims (dematricize rmodes A ds)) rmodes) r)\n     (digit_encode (nths (dims (dematricize rmodes A ds)) (- rmodes)) c)) =\n  A $$ (r, c)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> matricize rmodes (dematricize rmodes A ds) $$\n                         (i, j) =\n                         A $$ (i, j)", "from \\<open>r < dim_row A\\<close>"], ["proof (chain)\npicking this:\n  r < dim_row A", "have r_le: \"r < prod_list (nths (Tensor.dims (dematricize rmodes A ds)) rmodes)\""], ["proof (prove)\nusing this:\n  r < dim_row A\n\ngoal (1 subgoal):\n 1. r < prod_list (nths (dims (dematricize rmodes A ds)) rmodes)", "by (metis \\<open>dim_row (matricize rmodes (dematricize rmodes A ds)) = dim_row A\\<close> matricize_def dim_row_mat(1))"], ["proof (state)\nthis:\n  r < prod_list (nths (dims (dematricize rmodes A ds)) rmodes)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> matricize rmodes (dematricize rmodes A ds) $$\n                         (i, j) =\n                         A $$ (i, j)", "from \\<open>c < dim_col A \\<close>"], ["proof (chain)\npicking this:\n  c < dim_col A", "have c_le: \"c < prod_list (nths (Tensor.dims (dematricize rmodes A ds)) (- rmodes))\""], ["proof (prove)\nusing this:\n  c < dim_col A\n\ngoal (1 subgoal):\n 1. c < prod_list (nths (dims (dematricize rmodes A ds)) (- rmodes))", "by (metis \\<open>dim_col (matricize rmodes (dematricize rmodes A ds)) = dim_col A\\<close> matricize_def dim_col_mat(1))"], ["proof (state)\nthis:\n  c < prod_list (nths (dims (dematricize rmodes A ds)) (- rmodes))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row A; j < dim_col A\\<rbrakk>\n       \\<Longrightarrow> matricize rmodes (dematricize rmodes A ds) $$\n                         (i, j) =\n                         A $$ (i, j)", "then"], ["proof (chain)\npicking this:\n  c < prod_list (nths (dims (dematricize rmodes A ds)) (- rmodes))", "show \"(matricize rmodes (dematricize rmodes A ds)) $$ (r, c) = A $$ (r, c)\""], ["proof (prove)\nusing this:\n  c < prod_list (nths (dims (dematricize rmodes A ds)) (- rmodes))\n\ngoal (1 subgoal):\n 1. matricize rmodes (dematricize rmodes A ds) $$ (r, c) = A $$ (r, c)", "unfolding matricize_def"], ["proof (prove)\nusing this:\n  c < prod_list (nths (dims (dematricize rmodes A ds)) (- rmodes))\n\ngoal (1 subgoal):\n 1. mat (prod_list (nths (dims (dematricize rmodes A ds)) rmodes))\n     (prod_list (nths (dims (dematricize rmodes A ds)) (- rmodes)))\n     (\\<lambda>(r, c).\n         lookup (dematricize rmodes A ds)\n          (weave rmodes\n            (digit_encode (nths (dims (dematricize rmodes A ds)) rmodes) r)\n            (digit_encode (nths (dims (dematricize rmodes A ds)) (- rmodes))\n              c))) $$\n    (r, c) =\n    A $$ (r, c)", "using r_le c_le 0"], ["proof (prove)\nusing this:\n  c < prod_list (nths (dims (dematricize rmodes A ds)) (- rmodes))\n  r < prod_list (nths (dims (dematricize rmodes A ds)) rmodes)\n  c < prod_list (nths (dims (dematricize rmodes A ds)) (- rmodes))\n  lookup (dematricize rmodes A ds)\n   (weave rmodes\n     (digit_encode (nths (dims (dematricize rmodes A ds)) rmodes) r)\n     (digit_encode (nths (dims (dematricize rmodes A ds)) (- rmodes)) c)) =\n  A $$ (r, c)\n\ngoal (1 subgoal):\n 1. mat (prod_list (nths (dims (dematricize rmodes A ds)) rmodes))\n     (prod_list (nths (dims (dematricize rmodes A ds)) (- rmodes)))\n     (\\<lambda>(r, c).\n         lookup (dematricize rmodes A ds)\n          (weave rmodes\n            (digit_encode (nths (dims (dematricize rmodes A ds)) rmodes) r)\n            (digit_encode (nths (dims (dematricize rmodes A ds)) (- rmodes))\n              c))) $$\n    (r, c) =\n    A $$ (r, c)", "by simp"], ["proof (state)\nthis:\n  matricize rmodes (dematricize rmodes A ds) $$ (r, c) = A $$ (r, c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matricize_add:\nassumes \"dims A = dims B\"\nshows \"matricize I A + matricize I B = matricize I (A+B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matricize I A + matricize I B = matricize I (A + B)", "proof (rule eq_matI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (matricize I (A + B));\n        j < dim_col (matricize I (A + B))\\<rbrakk>\n       \\<Longrightarrow> (matricize I A + matricize I B) $$ (i, j) =\n                         matricize I (A + B) $$ (i, j)\n 2. dim_row (matricize I A + matricize I B) = dim_row (matricize I (A + B))\n 3. dim_col (matricize I A + matricize I B) = dim_col (matricize I (A + B))", "show \"dim_row (matricize I A + matricize I B) = dim_row (matricize I (A + B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (matricize I A + matricize I B) = dim_row (matricize I (A + B))", "by (simp add: assms dims_matricize(1))"], ["proof (state)\nthis:\n  dim_row (matricize I A + matricize I B) = dim_row (matricize I (A + B))\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (matricize I (A + B));\n        j < dim_col (matricize I (A + B))\\<rbrakk>\n       \\<Longrightarrow> (matricize I A + matricize I B) $$ (i, j) =\n                         matricize I (A + B) $$ (i, j)\n 2. dim_col (matricize I A + matricize I B) = dim_col (matricize I (A + B))", "show \"dim_col (matricize I A + matricize I B) = dim_col (matricize I (A + B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (matricize I A + matricize I B) = dim_col (matricize I (A + B))", "by (simp add: assms dims_matricize(2))"], ["proof (state)\nthis:\n  dim_col (matricize I A + matricize I B) = dim_col (matricize I (A + B))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (matricize I (A + B));\n        j < dim_col (matricize I (A + B))\\<rbrakk>\n       \\<Longrightarrow> (matricize I A + matricize I B) $$ (i, j) =\n                         matricize I (A + B) $$ (i, j)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (matricize I (A + B));\n        j < dim_col (matricize I (A + B))\\<rbrakk>\n       \\<Longrightarrow> (matricize I A + matricize I B) $$ (i, j) =\n                         matricize I (A + B) $$ (i, j)", "assume ij_le1:\"i < dim_row (matricize I (A + B))\" \"j < dim_col (matricize I (A + B))\""], ["proof (state)\nthis:\n  i < dim_row (matricize I (A + B))\n  j < dim_col (matricize I (A + B))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (matricize I (A + B));\n        j < dim_col (matricize I (A + B))\\<rbrakk>\n       \\<Longrightarrow> (matricize I A + matricize I B) $$ (i, j) =\n                         matricize I (A + B) $$ (i, j)", "then"], ["proof (chain)\npicking this:\n  i < dim_row (matricize I (A + B))\n  j < dim_col (matricize I (A + B))", "have\n    ij_le2:\"i < prod_list (nths (Tensor.dims A) I)\"  \"j < prod_list (nths (Tensor.dims A) (-I))\" and\n    ij_le3:\"i < prod_list (nths (Tensor.dims B) I)\"  \"j < prod_list (nths (Tensor.dims B) (-I))\" and\n    ij_le4:\"i < prod_list (nths (Tensor.dims (A + B)) I)\"  \"j < prod_list (nths (Tensor.dims (A + B)) (-I))\""], ["proof (prove)\nusing this:\n  i < dim_row (matricize I (A + B))\n  j < dim_col (matricize I (A + B))\n\ngoal (1 subgoal):\n 1. (i < prod_list (nths (dims A) I) &&&\n     j < prod_list (nths (dims A) (- I))) &&&\n    (i < prod_list (nths (dims B) I) &&&\n     j < prod_list (nths (dims B) (- I))) &&&\n    i < prod_list (nths (dims (A + B)) I) &&&\n    j < prod_list (nths (dims (A + B)) (- I))", "by (simp_all add: assms dims_matricize)"], ["proof (state)\nthis:\n  i < prod_list (nths (dims A) I)\n  j < prod_list (nths (dims A) (- I))\n  i < prod_list (nths (dims B) I)\n  j < prod_list (nths (dims B) (- I))\n  i < prod_list (nths (dims (A + B)) I)\n  j < prod_list (nths (dims (A + B)) (- I))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (matricize I (A + B));\n        j < dim_col (matricize I (A + B))\\<rbrakk>\n       \\<Longrightarrow> (matricize I A + matricize I B) $$ (i, j) =\n                         matricize I (A + B) $$ (i, j)", "then"], ["proof (chain)\npicking this:\n  i < prod_list (nths (dims A) I)\n  j < prod_list (nths (dims A) (- I))\n  i < prod_list (nths (dims B) I)\n  j < prod_list (nths (dims B) (- I))\n  i < prod_list (nths (dims (A + B)) I)\n  j < prod_list (nths (dims (A + B)) (- I))", "have ij_le5:\"i < dim_row (matricize I B)\" \"j < dim_col (matricize I B)\""], ["proof (prove)\nusing this:\n  i < prod_list (nths (dims A) I)\n  j < prod_list (nths (dims A) (- I))\n  i < prod_list (nths (dims B) I)\n  j < prod_list (nths (dims B) (- I))\n  i < prod_list (nths (dims (A + B)) I)\n  j < prod_list (nths (dims (A + B)) (- I))\n\ngoal (1 subgoal):\n 1. i < dim_row (matricize I B) &&& j < dim_col (matricize I B)", "by (simp_all add: assms dims_matricize)"], ["proof (state)\nthis:\n  i < dim_row (matricize I B)\n  j < dim_col (matricize I B)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row (matricize I (A + B));\n        j < dim_col (matricize I (A + B))\\<rbrakk>\n       \\<Longrightarrow> (matricize I A + matricize I B) $$ (i, j) =\n                         matricize I (A + B) $$ (i, j)", "show \"(matricize I A + matricize I B) $$ (i, j) = matricize I (A + B) $$ (i, j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (matricize I A + matricize I B) $$ (i, j) =\n    matricize I (A + B) $$ (i, j)", "unfolding index_add_mat(1)[OF ij_le5]"], ["proof (prove)\ngoal (1 subgoal):\n 1. matricize I A $$ (i, j) + matricize I B $$ (i, j) =\n    matricize I (A + B) $$ (i, j)", "unfolding matricize_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (prod_list (nths (dims A) I)) (prod_list (nths (dims A) (- I)))\n     (\\<lambda>(r, c).\n         lookup A\n          (weave I (digit_encode (nths (dims A) I) r)\n            (digit_encode (nths (dims A) (- I)) c))) $$\n    (i, j) +\n    mat (prod_list (nths (dims B) I)) (prod_list (nths (dims B) (- I)))\n     (\\<lambda>(r, c).\n         lookup B\n          (weave I (digit_encode (nths (dims B) I) r)\n            (digit_encode (nths (dims B) (- I)) c))) $$\n    (i, j) =\n    mat (prod_list (nths (dims (A + B)) I))\n     (prod_list (nths (dims (A + B)) (- I)))\n     (\\<lambda>(r, c).\n         lookup (A + B)\n          (weave I (digit_encode (nths (dims (A + B)) I) r)\n            (digit_encode (nths (dims (A + B)) (- I)) c))) $$\n    (i, j)", "unfolding index_mat[OF ij_le2] index_mat[OF ij_le3] index_mat[OF ij_le4]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (i, j) of\n     (r, c) \\<Rightarrow>\n       lookup A\n        (weave I (digit_encode (nths (dims A) I) r)\n          (digit_encode (nths (dims A) (- I)) c))) +\n    (case (i, j) of\n     (r, c) \\<Rightarrow>\n       lookup B\n        (weave I (digit_encode (nths (dims B) I) r)\n          (digit_encode (nths (dims B) (- I)) c))) =\n    (case (i, j) of\n     (r, c) \\<Rightarrow>\n       lookup (A + B)\n        (weave I (digit_encode (nths (dims (A + B)) I) r)\n          (digit_encode (nths (dims (A + B)) (- I)) c)))", "using assms digit_encode_valid_index ij_le2(1) ij_le2(2) valid_index_weave(1)"], ["proof (prove)\nusing this:\n  dims A = dims B\n  ?a < prod_list ?ds \\<Longrightarrow> digit_encode ?ds ?a \\<lhd> ?ds\n  i < prod_list (nths (dims A) I)\n  j < prod_list (nths (dims A) (- I))\n  \\<lbrakk>?is1.0 \\<lhd> nths ?ds ?A; ?is2.0 \\<lhd> nths ?ds (- ?A)\\<rbrakk>\n  \\<Longrightarrow> weave ?A ?is1.0 ?is2.0 \\<lhd> ?ds\n\ngoal (1 subgoal):\n 1. (case (i, j) of\n     (r, c) \\<Rightarrow>\n       lookup A\n        (weave I (digit_encode (nths (dims A) I) r)\n          (digit_encode (nths (dims A) (- I)) c))) +\n    (case (i, j) of\n     (r, c) \\<Rightarrow>\n       lookup B\n        (weave I (digit_encode (nths (dims B) I) r)\n          (digit_encode (nths (dims B) (- I)) c))) =\n    (case (i, j) of\n     (r, c) \\<Rightarrow>\n       lookup (A + B)\n        (weave I (digit_encode (nths (dims (A + B)) I) r)\n          (digit_encode (nths (dims (A + B)) (- I)) c)))", "by auto"], ["proof (state)\nthis:\n  (matricize I A + matricize I B) $$ (i, j) = matricize I (A + B) $$ (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matricize_0:\nshows \"matricize I (tensor0 ds) = 0\\<^sub>m (dim_row (matricize I (tensor0 ds))) (dim_col (matricize I (tensor0 ds)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matricize I (tensor0 ds) =\n    0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n     (dim_col (matricize I (tensor0 ds)))", "proof (rule eq_matI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n                       (dim_col (matricize I (tensor0 ds))));\n        j < dim_col\n             (0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n               (dim_col (matricize I (tensor0 ds))))\\<rbrakk>\n       \\<Longrightarrow> matricize I (tensor0 ds) $$ (i, j) =\n                         0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n                          (dim_col (matricize I (tensor0 ds))) $$\n                         (i, j)\n 2. dim_row (matricize I (tensor0 ds)) =\n    dim_row\n     (0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n       (dim_col (matricize I (tensor0 ds))))\n 3. dim_col (matricize I (tensor0 ds)) =\n    dim_col\n     (0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n       (dim_col (matricize I (tensor0 ds))))", "show \"dim_row (matricize I (tensor0 ds)) = dim_row (0\\<^sub>m (dim_row (matricize I (tensor0 ds))) (dim_col (matricize I (tensor0 ds))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (matricize I (tensor0 ds)) =\n    dim_row\n     (0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n       (dim_col (matricize I (tensor0 ds))))", "unfolding zero_mat_def dim_row_mat"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_row (matricize I (tensor0 ds)) = dim_row (matricize I (tensor0 ds))", "by (simp add: dims_matricize(1))"], ["proof (state)\nthis:\n  dim_row (matricize I (tensor0 ds)) =\n  dim_row\n   (0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n     (dim_col (matricize I (tensor0 ds))))\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n                       (dim_col (matricize I (tensor0 ds))));\n        j < dim_col\n             (0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n               (dim_col (matricize I (tensor0 ds))))\\<rbrakk>\n       \\<Longrightarrow> matricize I (tensor0 ds) $$ (i, j) =\n                         0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n                          (dim_col (matricize I (tensor0 ds))) $$\n                         (i, j)\n 2. dim_col (matricize I (tensor0 ds)) =\n    dim_col\n     (0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n       (dim_col (matricize I (tensor0 ds))))", "show \"dim_col (matricize I (tensor0 ds)) = dim_col (0\\<^sub>m (dim_row (matricize I (tensor0 ds))) (dim_col (matricize I (tensor0 ds))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (matricize I (tensor0 ds)) =\n    dim_col\n     (0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n       (dim_col (matricize I (tensor0 ds))))", "unfolding zero_mat_def dim_row_mat"], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_col (matricize I (tensor0 ds)) =\n    dim_col\n     (mat (dim_row (matricize I (tensor0 ds)))\n       (dim_col (matricize I (tensor0 ds))) (\\<lambda>ij. 0::'e))", "by (simp add: dims_matricize(2))"], ["proof (state)\nthis:\n  dim_col (matricize I (tensor0 ds)) =\n  dim_col\n   (0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n     (dim_col (matricize I (tensor0 ds))))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n                       (dim_col (matricize I (tensor0 ds))));\n        j < dim_col\n             (0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n               (dim_col (matricize I (tensor0 ds))))\\<rbrakk>\n       \\<Longrightarrow> matricize I (tensor0 ds) $$ (i, j) =\n                         0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n                          (dim_col (matricize I (tensor0 ds))) $$\n                         (i, j)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n                       (dim_col (matricize I (tensor0 ds))));\n        j < dim_col\n             (0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n               (dim_col (matricize I (tensor0 ds))))\\<rbrakk>\n       \\<Longrightarrow> matricize I (tensor0 ds) $$ (i, j) =\n                         0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n                          (dim_col (matricize I (tensor0 ds))) $$\n                         (i, j)", "assume ij_le1: \"i < dim_row (0\\<^sub>m (dim_row (matricize I (tensor0 ds))) (dim_col (matricize I (tensor0 ds))))\"\n                 \"j < dim_col (0\\<^sub>m (dim_row (matricize I (tensor0 ds))) (dim_col (matricize I (tensor0 ds))))\""], ["proof (state)\nthis:\n  i < dim_row\n       (0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n         (dim_col (matricize I (tensor0 ds))))\n  j < dim_col\n       (0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n         (dim_col (matricize I (tensor0 ds))))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n                       (dim_col (matricize I (tensor0 ds))));\n        j < dim_col\n             (0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n               (dim_col (matricize I (tensor0 ds))))\\<rbrakk>\n       \\<Longrightarrow> matricize I (tensor0 ds) $$ (i, j) =\n                         0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n                          (dim_col (matricize I (tensor0 ds))) $$\n                         (i, j)", "then"], ["proof (chain)\npicking this:\n  i < dim_row\n       (0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n         (dim_col (matricize I (tensor0 ds))))\n  j < dim_col\n       (0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n         (dim_col (matricize I (tensor0 ds))))", "have ij_le2:\"i < dim_row (matricize I (tensor0 ds))\" \"j < dim_col (matricize I (tensor0 ds))\""], ["proof (prove)\nusing this:\n  i < dim_row\n       (0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n         (dim_col (matricize I (tensor0 ds))))\n  j < dim_col\n       (0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n         (dim_col (matricize I (tensor0 ds))))\n\ngoal (1 subgoal):\n 1. i < dim_row (matricize I (tensor0 ds)) &&&\n    j < dim_col (matricize I (tensor0 ds))", "unfolding zero_mat_def dim_row_mat"], ["proof (prove)\nusing this:\n  i < dim_row (matricize I (tensor0 ds))\n  j < dim_col\n       (mat (dim_row (matricize I (tensor0 ds)))\n         (dim_col (matricize I (tensor0 ds))) (\\<lambda>ij. 0::'g))\n\ngoal (1 subgoal):\n 1. i < dim_row (matricize I (tensor0 ds)) &&&\n    j < dim_col (matricize I (tensor0 ds))", "by (simp_all add: dims_matricize)"], ["proof (state)\nthis:\n  i < dim_row (matricize I (tensor0 ds))\n  j < dim_col (matricize I (tensor0 ds))\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < dim_row\n                     (0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n                       (dim_col (matricize I (tensor0 ds))));\n        j < dim_col\n             (0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n               (dim_col (matricize I (tensor0 ds))))\\<rbrakk>\n       \\<Longrightarrow> matricize I (tensor0 ds) $$ (i, j) =\n                         0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n                          (dim_col (matricize I (tensor0 ds))) $$\n                         (i, j)", "show \"matricize I (tensor0 ds) $$ (i, j) = 0\\<^sub>m (dim_row (matricize I (tensor0 ds))) (dim_col (matricize I (tensor0 ds))) $$ (i, j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matricize I (tensor0 ds) $$ (i, j) =\n    0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n     (dim_col (matricize I (tensor0 ds))) $$\n    (i, j)", "unfolding zero_mat_def  index_mat[OF ij_le2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. matricize I (tensor0 ds) $$ (i, j) = (0::'j)", "unfolding matricize_def index_mat[OF ij_le2[unfolded dims_matricize]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (i, j) of\n     (r, c) \\<Rightarrow>\n       lookup (tensor0 ds)\n        (weave I (digit_encode (nths (dims (tensor0 ds)) I) r)\n          (digit_encode (nths (dims (tensor0 ds)) (- I)) c))) =\n    (0::'j)", "by (simp, metis lookup_tensor0 digit_encode_valid_index dims_matricize(1) dims_matricize(2) dims_tensor0\n    ij_le2(1) ij_le2(2) valid_index_weave(1))"], ["proof (state)\nthis:\n  matricize I (tensor0 ds) $$ (i, j) =\n  0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n   (dim_col (matricize I (tensor0 ds))) $$\n  (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}