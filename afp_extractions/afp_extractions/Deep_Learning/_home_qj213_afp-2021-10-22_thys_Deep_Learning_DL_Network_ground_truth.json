{"file_name": "/home/qj213/afp-2021-10-22/thys/Deep_Learning/DL_Network.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Deep_Learning", "problem_names": ["lemma insert_weights_cong:\nassumes \"(\\<And>i. i<count_weights s m \\<Longrightarrow> w1 i = w2 i)\"\nshows \"insert_weights s m w1 = insert_weights s m w2\"", "lemma dims_mat_tensorlist_mult:\nassumes \"T\\<in>set\\<^sub>v (mat_tensorlist_mult A Ts ds)\"\nshows \"Tensor.dims T = ds\"", "lemma output_size_correct_tensors:\nassumes \"valid_net' m\"\nshows \"output_size' m = dim_vec (tensors_from_net m)\"", "lemma output_size_correct:\nassumes \"valid_net' m\"\nand \"map dim_vec inputs = input_sizes m\"\nshows \"output_size' m = dim_vec (evaluate_net m inputs)\"", "lemma input_sizes_remove_weights: \"input_sizes m = input_sizes (remove_weights m)\"", "lemma dims_tensors_from_net:\nassumes \"T \\<in> set\\<^sub>v (tensors_from_net m)\"\nshows \"Tensor.dims T = input_sizes m\"", "lemma base_input_length:\nassumes \"is \\<lhd> input_sizes m\"\nshows \"input_sizes m = map dim_vec (base_input m is)\"", "lemma nth_mat_tensorlist_mult:\nassumes \"\\<And>A. A\\<in>set\\<^sub>v Ts \\<Longrightarrow> dims A = ds\"\nassumes \"i < dim_row A\"\nassumes \"dim_vec Ts = dim_col A\"\nshows \"mat_tensorlist_mult A Ts ds $ i = listsum ds (map (\\<lambda>j. (A $$ (i,j)) \\<cdot> Ts $ j) [0..<dim_vec Ts])\"\n  (is \"_ = listsum ds ?Ts'\")", "lemma lookup_tensors_from_net:\nassumes \"valid_net' m\"\nand \"is \\<lhd> input_sizes m\"\nand \"j < output_size' m\"\nshows \"Tensor.lookup (tensors_from_net m $ j) is = evaluate_net m (base_input m is) $ j\"", "lemma insert_extract_weights_cong_shared:\nassumes \"shared_weight_net m\"\nassumes \"\\<And>x. x < count_weights True (remove_weights m) \\<Longrightarrow> f x = extract_weights True m x\"\nshows \"m = insert_weights True (remove_weights m) f\"", "lemma insert_extract_weights_cong_unshared:\nassumes \"\\<And>x. x < count_weights False (remove_weights m) \\<Longrightarrow> f x = extract_weights False m x\"\nshows \"m = insert_weights False (remove_weights m) f\"", "lemma remove_insert_weights:\nshows \"remove_weights (insert_weights s m w) = m\"", "lemma extract_insert_weights_shared: \nassumes \"x<count_weights True m\"\nand \"balanced_net m\"\nshows \"extract_weights True (insert_weights True m w) x = w x\"", "lemma shared_weight_net_insert_weights: \"balanced_net m \\<Longrightarrow> shared_weight_net (insert_weights True m w)\"", "lemma finite_valid_index: \"finite {is. is \\<lhd> ds}\"", "lemma setsum_valid_index_split:\n\"(\\<Sum>is | is \\<lhd> ds1 @ ds2. f is) = (\\<Sum>is1 | is1 \\<lhd> ds1. (\\<Sum>is2 | is2 \\<lhd> ds2. f (is1 @ is2)))\"", "lemma prod_lessThan_split:\nfixes g :: \"nat \\<Rightarrow> real\" shows \"prod g {..<n+m} = prod g {..<n} * prod (\\<lambda>x. g (x+n)) {..<m}\"", "lemma evaluate_net_from_tensors:\nassumes \"valid_net' m\"\nand \"map dim_vec inputs = input_sizes m\"\nand \"j < output_size' m\"\nshows \"evaluate_net m inputs $ j\n  = (\\<Sum>is\\<in>{is. is \\<lhd> input_sizes m}. (\\<Prod>k<length inputs. inputs ! k $ (is!k)) * Tensor.lookup (tensors_from_net m $ j) is)\"", "lemma tensors_from_net_eqI:\nassumes \"valid_net' m1\" \"valid_net' m2\" \"input_sizes m1 = input_sizes m2\"\nassumes \"\\<And>inputs. input_sizes m1 = map dim_vec inputs \\<Longrightarrow> evaluate_net m1 inputs = evaluate_net m2 inputs\"\nshows \"tensors_from_net m1 = tensors_from_net m2\""], "translations": [["", "lemma insert_weights_cong:\nassumes \"(\\<And>i. i<count_weights s m \\<Longrightarrow> w1 i = w2 i)\"\nshows \"insert_weights s m w1 = insert_weights s m w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_weights s m w1 = insert_weights s m w2", "using assms"], ["proof (prove)\nusing this:\n  ?i < count_weights s m \\<Longrightarrow> w1 ?i = w2 ?i\n\ngoal (1 subgoal):\n 1. insert_weights s m w1 = insert_weights s m w2", "proof (induction m arbitrary: w1 w2)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x w1 w2.\n       (\\<And>i.\n           i < count_weights s (Input x) \\<Longrightarrow>\n           w1 i = w2 i) \\<Longrightarrow>\n       insert_weights s (Input x) w1 = insert_weights s (Input x) w2\n 2. \\<And>x1a m w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   (\\<And>i.\n                       i < count_weights s m \\<Longrightarrow>\n                       w1 i = w2 i) \\<Longrightarrow>\n                   insert_weights s m w1 = insert_weights s m w2;\n        \\<And>i.\n           i < count_weights s (Conv x1a m) \\<Longrightarrow>\n           w1 i = w2 i\\<rbrakk>\n       \\<Longrightarrow> insert_weights s (Conv x1a m) w1 =\n                         insert_weights s (Conv x1a m) w2\n 3. \\<And>m1 m2 w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   (\\<And>i.\n                       i < count_weights s m1 \\<Longrightarrow>\n                       w1 i = w2 i) \\<Longrightarrow>\n                   insert_weights s m1 w1 = insert_weights s m1 w2;\n        \\<And>w1 w2.\n           (\\<And>i.\n               i < count_weights s m2 \\<Longrightarrow>\n               w1 i = w2 i) \\<Longrightarrow>\n           insert_weights s m2 w1 = insert_weights s m2 w2;\n        \\<And>i.\n           i < count_weights s (Pool m1 m2) \\<Longrightarrow>\n           w1 i = w2 i\\<rbrakk>\n       \\<Longrightarrow> insert_weights s (Pool m1 m2) w1 =\n                         insert_weights s (Pool m1 m2) w2", "case Input"], ["proof (state)\nthis:\n  ?i < count_weights s (Input x_) \\<Longrightarrow> w1 ?i = w2 ?i\n\ngoal (3 subgoals):\n 1. \\<And>x w1 w2.\n       (\\<And>i.\n           i < count_weights s (Input x) \\<Longrightarrow>\n           w1 i = w2 i) \\<Longrightarrow>\n       insert_weights s (Input x) w1 = insert_weights s (Input x) w2\n 2. \\<And>x1a m w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   (\\<And>i.\n                       i < count_weights s m \\<Longrightarrow>\n                       w1 i = w2 i) \\<Longrightarrow>\n                   insert_weights s m w1 = insert_weights s m w2;\n        \\<And>i.\n           i < count_weights s (Conv x1a m) \\<Longrightarrow>\n           w1 i = w2 i\\<rbrakk>\n       \\<Longrightarrow> insert_weights s (Conv x1a m) w1 =\n                         insert_weights s (Conv x1a m) w2\n 3. \\<And>m1 m2 w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   (\\<And>i.\n                       i < count_weights s m1 \\<Longrightarrow>\n                       w1 i = w2 i) \\<Longrightarrow>\n                   insert_weights s m1 w1 = insert_weights s m1 w2;\n        \\<And>w1 w2.\n           (\\<And>i.\n               i < count_weights s m2 \\<Longrightarrow>\n               w1 i = w2 i) \\<Longrightarrow>\n           insert_weights s m2 w1 = insert_weights s m2 w2;\n        \\<And>i.\n           i < count_weights s (Pool m1 m2) \\<Longrightarrow>\n           w1 i = w2 i\\<rbrakk>\n       \\<Longrightarrow> insert_weights s (Pool m1 m2) w1 =\n                         insert_weights s (Pool m1 m2) w2", "then"], ["proof (chain)\npicking this:\n  ?i < count_weights s (Input x_) \\<Longrightarrow> w1 ?i = w2 ?i", "show ?case"], ["proof (prove)\nusing this:\n  ?i < count_weights s (Input x_) \\<Longrightarrow> w1 ?i = w2 ?i\n\ngoal (1 subgoal):\n 1. insert_weights s (Input x_) w1 = insert_weights s (Input x_) w2", "by simp"], ["proof (state)\nthis:\n  insert_weights s (Input x_) w1 = insert_weights s (Input x_) w2\n\ngoal (2 subgoals):\n 1. \\<And>x1a m w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   (\\<And>i.\n                       i < count_weights s m \\<Longrightarrow>\n                       w1 i = w2 i) \\<Longrightarrow>\n                   insert_weights s m w1 = insert_weights s m w2;\n        \\<And>i.\n           i < count_weights s (Conv x1a m) \\<Longrightarrow>\n           w1 i = w2 i\\<rbrakk>\n       \\<Longrightarrow> insert_weights s (Conv x1a m) w1 =\n                         insert_weights s (Conv x1a m) w2\n 2. \\<And>m1 m2 w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   (\\<And>i.\n                       i < count_weights s m1 \\<Longrightarrow>\n                       w1 i = w2 i) \\<Longrightarrow>\n                   insert_weights s m1 w1 = insert_weights s m1 w2;\n        \\<And>w1 w2.\n           (\\<And>i.\n               i < count_weights s m2 \\<Longrightarrow>\n               w1 i = w2 i) \\<Longrightarrow>\n           insert_weights s m2 w1 = insert_weights s m2 w2;\n        \\<And>i.\n           i < count_weights s (Pool m1 m2) \\<Longrightarrow>\n           w1 i = w2 i\\<rbrakk>\n       \\<Longrightarrow> insert_weights s (Pool m1 m2) w1 =\n                         insert_weights s (Pool m1 m2) w2", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1a m w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   (\\<And>i.\n                       i < count_weights s m \\<Longrightarrow>\n                       w1 i = w2 i) \\<Longrightarrow>\n                   insert_weights s m w1 = insert_weights s m w2;\n        \\<And>i.\n           i < count_weights s (Conv x1a m) \\<Longrightarrow>\n           w1 i = w2 i\\<rbrakk>\n       \\<Longrightarrow> insert_weights s (Conv x1a m) w1 =\n                         insert_weights s (Conv x1a m) w2\n 2. \\<And>m1 m2 w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   (\\<And>i.\n                       i < count_weights s m1 \\<Longrightarrow>\n                       w1 i = w2 i) \\<Longrightarrow>\n                   insert_weights s m1 w1 = insert_weights s m1 w2;\n        \\<And>w1 w2.\n           (\\<And>i.\n               i < count_weights s m2 \\<Longrightarrow>\n               w1 i = w2 i) \\<Longrightarrow>\n           insert_weights s m2 w1 = insert_weights s m2 w2;\n        \\<And>i.\n           i < count_weights s (Pool m1 m2) \\<Longrightarrow>\n           w1 i = w2 i\\<rbrakk>\n       \\<Longrightarrow> insert_weights s (Pool m1 m2) w1 =\n                         insert_weights s (Pool m1 m2) w2", "case (Conv r01 m)"], ["proof (state)\nthis:\n  (\\<And>i.\n      i < count_weights s m \\<Longrightarrow>\n      ?w1.0 i = ?w2.0 i) \\<Longrightarrow>\n  insert_weights s m ?w1.0 = insert_weights s m ?w2.0\n  ?i < count_weights s (Conv r01 m) \\<Longrightarrow> w1 ?i = w2 ?i\n\ngoal (2 subgoals):\n 1. \\<And>x1a m w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   (\\<And>i.\n                       i < count_weights s m \\<Longrightarrow>\n                       w1 i = w2 i) \\<Longrightarrow>\n                   insert_weights s m w1 = insert_weights s m w2;\n        \\<And>i.\n           i < count_weights s (Conv x1a m) \\<Longrightarrow>\n           w1 i = w2 i\\<rbrakk>\n       \\<Longrightarrow> insert_weights s (Conv x1a m) w1 =\n                         insert_weights s (Conv x1a m) w2\n 2. \\<And>m1 m2 w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   (\\<And>i.\n                       i < count_weights s m1 \\<Longrightarrow>\n                       w1 i = w2 i) \\<Longrightarrow>\n                   insert_weights s m1 w1 = insert_weights s m1 w2;\n        \\<And>w1 w2.\n           (\\<And>i.\n               i < count_weights s m2 \\<Longrightarrow>\n               w1 i = w2 i) \\<Longrightarrow>\n           insert_weights s m2 w1 = insert_weights s m2 w2;\n        \\<And>i.\n           i < count_weights s (Pool m1 m2) \\<Longrightarrow>\n           w1 i = w2 i\\<rbrakk>\n       \\<Longrightarrow> insert_weights s (Pool m1 m2) w1 =\n                         insert_weights s (Pool m1 m2) w2", "then"], ["proof (chain)\npicking this:\n  (\\<And>i.\n      i < count_weights s m \\<Longrightarrow>\n      ?w1.0 i = ?w2.0 i) \\<Longrightarrow>\n  insert_weights s m ?w1.0 = insert_weights s m ?w2.0\n  ?i < count_weights s (Conv r01 m) \\<Longrightarrow> w1 ?i = w2 ?i", "obtain r0 r1 where \"r01 = (r0,r1)\""], ["proof (prove)\nusing this:\n  (\\<And>i.\n      i < count_weights s m \\<Longrightarrow>\n      ?w1.0 i = ?w2.0 i) \\<Longrightarrow>\n  insert_weights s m ?w1.0 = insert_weights s m ?w2.0\n  ?i < count_weights s (Conv r01 m) \\<Longrightarrow> w1 ?i = w2 ?i\n\ngoal (1 subgoal):\n 1. (\\<And>r0 r1. r01 = (r0, r1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson surj_pair)"], ["proof (state)\nthis:\n  r01 = (r0, r1)\n\ngoal (2 subgoals):\n 1. \\<And>x1a m w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   (\\<And>i.\n                       i < count_weights s m \\<Longrightarrow>\n                       w1 i = w2 i) \\<Longrightarrow>\n                   insert_weights s m w1 = insert_weights s m w2;\n        \\<And>i.\n           i < count_weights s (Conv x1a m) \\<Longrightarrow>\n           w1 i = w2 i\\<rbrakk>\n       \\<Longrightarrow> insert_weights s (Conv x1a m) w1 =\n                         insert_weights s (Conv x1a m) w2\n 2. \\<And>m1 m2 w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   (\\<And>i.\n                       i < count_weights s m1 \\<Longrightarrow>\n                       w1 i = w2 i) \\<Longrightarrow>\n                   insert_weights s m1 w1 = insert_weights s m1 w2;\n        \\<And>w1 w2.\n           (\\<And>i.\n               i < count_weights s m2 \\<Longrightarrow>\n               w1 i = w2 i) \\<Longrightarrow>\n           insert_weights s m2 w1 = insert_weights s m2 w2;\n        \\<And>i.\n           i < count_weights s (Pool m1 m2) \\<Longrightarrow>\n           w1 i = w2 i\\<rbrakk>\n       \\<Longrightarrow> insert_weights s (Pool m1 m2) w1 =\n                         insert_weights s (Pool m1 m2) w2", "have 2:\"insert_weights s m (\\<lambda>i. w1 (i + r0 * r1)) = insert_weights s m (\\<lambda>i. w2 (i + r0 * r1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_weights s m (\\<lambda>i. w1 (i + r0 * r1)) =\n    insert_weights s m (\\<lambda>i. w2 (i + r0 * r1))", "using Conv"], ["proof (prove)\nusing this:\n  (\\<And>i.\n      i < count_weights s m \\<Longrightarrow>\n      ?w1.0 i = ?w2.0 i) \\<Longrightarrow>\n  insert_weights s m ?w1.0 = insert_weights s m ?w2.0\n  ?i < count_weights s (Conv r01 m) \\<Longrightarrow> w1 ?i = w2 ?i\n\ngoal (1 subgoal):\n 1. insert_weights s m (\\<lambda>i. w1 (i + r0 * r1)) =\n    insert_weights s m (\\<lambda>i. w2 (i + r0 * r1))", "using \\<open>r01 = (r0, r1)\\<close> add.commute add_less_cancel_right count_weights.simps(2)"], ["proof (prove)\nusing this:\n  (\\<And>i.\n      i < count_weights s m \\<Longrightarrow>\n      ?w1.0 i = ?w2.0 i) \\<Longrightarrow>\n  insert_weights s m ?w1.0 = insert_weights s m ?w2.0\n  ?i < count_weights s (Conv r01 m) \\<Longrightarrow> w1 ?i = w2 ?i\n  r01 = (r0, r1)\n  ?a + ?b = ?b + ?a\n  (?a + ?c < ?b + ?c) = (?a < ?b)\n  count_weights ?shared (Conv (?r0.0, ?r1.0) ?m) =\n  ?r0.0 * ?r1.0 + count_weights ?shared ?m\n\ngoal (1 subgoal):\n 1. insert_weights s m (\\<lambda>i. w1 (i + r0 * r1)) =\n    insert_weights s m (\\<lambda>i. w2 (i + r0 * r1))", "by fastforce"], ["proof (state)\nthis:\n  insert_weights s m (\\<lambda>i. w1 (i + r0 * r1)) =\n  insert_weights s m (\\<lambda>i. w2 (i + r0 * r1))\n\ngoal (2 subgoals):\n 1. \\<And>x1a m w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   (\\<And>i.\n                       i < count_weights s m \\<Longrightarrow>\n                       w1 i = w2 i) \\<Longrightarrow>\n                   insert_weights s m w1 = insert_weights s m w2;\n        \\<And>i.\n           i < count_weights s (Conv x1a m) \\<Longrightarrow>\n           w1 i = w2 i\\<rbrakk>\n       \\<Longrightarrow> insert_weights s (Conv x1a m) w1 =\n                         insert_weights s (Conv x1a m) w2\n 2. \\<And>m1 m2 w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   (\\<And>i.\n                       i < count_weights s m1 \\<Longrightarrow>\n                       w1 i = w2 i) \\<Longrightarrow>\n                   insert_weights s m1 w1 = insert_weights s m1 w2;\n        \\<And>w1 w2.\n           (\\<And>i.\n               i < count_weights s m2 \\<Longrightarrow>\n               w1 i = w2 i) \\<Longrightarrow>\n           insert_weights s m2 w1 = insert_weights s m2 w2;\n        \\<And>i.\n           i < count_weights s (Pool m1 m2) \\<Longrightarrow>\n           w1 i = w2 i\\<rbrakk>\n       \\<Longrightarrow> insert_weights s (Pool m1 m2) w1 =\n                         insert_weights s (Pool m1 m2) w2", "then"], ["proof (chain)\npicking this:\n  insert_weights s m (\\<lambda>i. w1 (i + r0 * r1)) =\n  insert_weights s m (\\<lambda>i. w2 (i + r0 * r1))", "show ?case"], ["proof (prove)\nusing this:\n  insert_weights s m (\\<lambda>i. w1 (i + r0 * r1)) =\n  insert_weights s m (\\<lambda>i. w2 (i + r0 * r1))\n\ngoal (1 subgoal):\n 1. insert_weights s (Conv r01 m) w1 = insert_weights s (Conv r01 m) w2", "unfolding \\<open>r01 = (r0,r1)\\<close> insert_weights.simps"], ["proof (prove)\nusing this:\n  insert_weights s m (\\<lambda>i. w1 (i + r0 * r1)) =\n  insert_weights s m (\\<lambda>i. w2 (i + r0 * r1))\n\ngoal (1 subgoal):\n 1. Conv (extract_matrix w1 r0 r1)\n     (insert_weights s m (\\<lambda>i. w1 (i + r0 * r1))) =\n    Conv (extract_matrix w2 r0 r1)\n     (insert_weights s m (\\<lambda>i. w2 (i + r0 * r1)))", "by (metis Conv.prems \\<open>r01 = (r0, r1)\\<close> count_weights.simps(2) extract_matrix_cong trans_less_add1)"], ["proof (state)\nthis:\n  insert_weights s (Conv r01 m) w1 = insert_weights s (Conv r01 m) w2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   (\\<And>i.\n                       i < count_weights s m1 \\<Longrightarrow>\n                       w1 i = w2 i) \\<Longrightarrow>\n                   insert_weights s m1 w1 = insert_weights s m1 w2;\n        \\<And>w1 w2.\n           (\\<And>i.\n               i < count_weights s m2 \\<Longrightarrow>\n               w1 i = w2 i) \\<Longrightarrow>\n           insert_weights s m2 w1 = insert_weights s m2 w2;\n        \\<And>i.\n           i < count_weights s (Pool m1 m2) \\<Longrightarrow>\n           w1 i = w2 i\\<rbrakk>\n       \\<Longrightarrow> insert_weights s (Pool m1 m2) w1 =\n                         insert_weights s (Pool m1 m2) w2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m1 m2 w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   (\\<And>i.\n                       i < count_weights s m1 \\<Longrightarrow>\n                       w1 i = w2 i) \\<Longrightarrow>\n                   insert_weights s m1 w1 = insert_weights s m1 w2;\n        \\<And>w1 w2.\n           (\\<And>i.\n               i < count_weights s m2 \\<Longrightarrow>\n               w1 i = w2 i) \\<Longrightarrow>\n           insert_weights s m2 w1 = insert_weights s m2 w2;\n        \\<And>i.\n           i < count_weights s (Pool m1 m2) \\<Longrightarrow>\n           w1 i = w2 i\\<rbrakk>\n       \\<Longrightarrow> insert_weights s (Pool m1 m2) w1 =\n                         insert_weights s (Pool m1 m2) w2", "case (Pool m1 m2)"], ["proof (state)\nthis:\n  (\\<And>i.\n      i < count_weights s m1 \\<Longrightarrow>\n      ?w1.0 i = ?w2.0 i) \\<Longrightarrow>\n  insert_weights s m1 ?w1.0 = insert_weights s m1 ?w2.0\n  (\\<And>i.\n      i < count_weights s m2 \\<Longrightarrow>\n      ?w1.0 i = ?w2.0 i) \\<Longrightarrow>\n  insert_weights s m2 ?w1.0 = insert_weights s m2 ?w2.0\n  ?i < count_weights s (Pool m1 m2) \\<Longrightarrow> w1 ?i = w2 ?i\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   (\\<And>i.\n                       i < count_weights s m1 \\<Longrightarrow>\n                       w1 i = w2 i) \\<Longrightarrow>\n                   insert_weights s m1 w1 = insert_weights s m1 w2;\n        \\<And>w1 w2.\n           (\\<And>i.\n               i < count_weights s m2 \\<Longrightarrow>\n               w1 i = w2 i) \\<Longrightarrow>\n           insert_weights s m2 w1 = insert_weights s m2 w2;\n        \\<And>i.\n           i < count_weights s (Pool m1 m2) \\<Longrightarrow>\n           w1 i = w2 i\\<rbrakk>\n       \\<Longrightarrow> insert_weights s (Pool m1 m2) w1 =\n                         insert_weights s (Pool m1 m2) w2", "have 1:\"insert_weights s m1 w1 = insert_weights s m1 w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_weights s m1 w1 = insert_weights s m1 w2", "using Pool(1)[of w1 w2] Pool(3)[unfolded count_weights.simps]"], ["proof (prove)\nusing this:\n  (\\<And>i.\n      i < count_weights s m1 \\<Longrightarrow>\n      w1 i = w2 i) \\<Longrightarrow>\n  insert_weights s m1 w1 = insert_weights s m1 w2\n  ?i < (if s then max (count_weights s m1) (count_weights s m2)\n        else count_weights s m1 + count_weights s m2) \\<Longrightarrow>\n  w1 ?i = w2 ?i\n\ngoal (1 subgoal):\n 1. insert_weights s m1 w1 = insert_weights s m1 w2", "by (cases s; auto)"], ["proof (state)\nthis:\n  insert_weights s m1 w1 = insert_weights s m1 w2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   (\\<And>i.\n                       i < count_weights s m1 \\<Longrightarrow>\n                       w1 i = w2 i) \\<Longrightarrow>\n                   insert_weights s m1 w1 = insert_weights s m1 w2;\n        \\<And>w1 w2.\n           (\\<And>i.\n               i < count_weights s m2 \\<Longrightarrow>\n               w1 i = w2 i) \\<Longrightarrow>\n           insert_weights s m2 w1 = insert_weights s m2 w2;\n        \\<And>i.\n           i < count_weights s (Pool m1 m2) \\<Longrightarrow>\n           w1 i = w2 i\\<rbrakk>\n       \\<Longrightarrow> insert_weights s (Pool m1 m2) w1 =\n                         insert_weights s (Pool m1 m2) w2", "have shared:\"s=True \\<Longrightarrow> insert_weights s m2 w1 = insert_weights s m2 w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = True \\<Longrightarrow>\n    insert_weights s m2 w1 = insert_weights s m2 w2", "using Pool(2)[of w1 w2] Pool(3)[unfolded count_weights.simps]"], ["proof (prove)\nusing this:\n  (\\<And>i.\n      i < count_weights s m2 \\<Longrightarrow>\n      w1 i = w2 i) \\<Longrightarrow>\n  insert_weights s m2 w1 = insert_weights s m2 w2\n  ?i < (if s then max (count_weights s m1) (count_weights s m2)\n        else count_weights s m1 + count_weights s m2) \\<Longrightarrow>\n  w1 ?i = w2 ?i\n\ngoal (1 subgoal):\n 1. s = True \\<Longrightarrow>\n    insert_weights s m2 w1 = insert_weights s m2 w2", "by auto"], ["proof (state)\nthis:\n  s = True \\<Longrightarrow> insert_weights s m2 w1 = insert_weights s m2 w2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   (\\<And>i.\n                       i < count_weights s m1 \\<Longrightarrow>\n                       w1 i = w2 i) \\<Longrightarrow>\n                   insert_weights s m1 w1 = insert_weights s m1 w2;\n        \\<And>w1 w2.\n           (\\<And>i.\n               i < count_weights s m2 \\<Longrightarrow>\n               w1 i = w2 i) \\<Longrightarrow>\n           insert_weights s m2 w1 = insert_weights s m2 w2;\n        \\<And>i.\n           i < count_weights s (Pool m1 m2) \\<Longrightarrow>\n           w1 i = w2 i\\<rbrakk>\n       \\<Longrightarrow> insert_weights s (Pool m1 m2) w1 =\n                         insert_weights s (Pool m1 m2) w2", "have unshared:\"s=False \\<Longrightarrow> insert_weights s m2 (\\<lambda>i. w1 (i + count_weights s m1)) = insert_weights s m2 (\\<lambda>i. w2 (i + count_weights s m1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = False \\<Longrightarrow>\n    insert_weights s m2 (\\<lambda>i. w1 (i + count_weights s m1)) =\n    insert_weights s m2 (\\<lambda>i. w2 (i + count_weights s m1))", "using Pool(2) Pool(3) count_weights.simps"], ["proof (prove)\nusing this:\n  (\\<And>i.\n      i < count_weights s m2 \\<Longrightarrow>\n      ?w1.0 i = ?w2.0 i) \\<Longrightarrow>\n  insert_weights s m2 ?w1.0 = insert_weights s m2 ?w2.0\n  ?i < count_weights s (Pool m1 m2) \\<Longrightarrow> w1 ?i = w2 ?i\n  count_weights ?shared (Input ?M) = 0\n  count_weights ?shared (Conv (?r0.0, ?r1.0) ?m) =\n  ?r0.0 * ?r1.0 + count_weights ?shared ?m\n  count_weights ?shared (Pool ?m1.0 ?m2.0) =\n  (if ?shared\n   then max (count_weights ?shared ?m1.0) (count_weights ?shared ?m2.0)\n   else count_weights ?shared ?m1.0 + count_weights ?shared ?m2.0)\n\ngoal (1 subgoal):\n 1. s = False \\<Longrightarrow>\n    insert_weights s m2 (\\<lambda>i. w1 (i + count_weights s m1)) =\n    insert_weights s m2 (\\<lambda>i. w2 (i + count_weights s m1))", "by fastforce"], ["proof (state)\nthis:\n  s = False \\<Longrightarrow>\n  insert_weights s m2 (\\<lambda>i. w1 (i + count_weights s m1)) =\n  insert_weights s m2 (\\<lambda>i. w2 (i + count_weights s m1))\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 w1 w2.\n       \\<lbrakk>\\<And>w1 w2.\n                   (\\<And>i.\n                       i < count_weights s m1 \\<Longrightarrow>\n                       w1 i = w2 i) \\<Longrightarrow>\n                   insert_weights s m1 w1 = insert_weights s m1 w2;\n        \\<And>w1 w2.\n           (\\<And>i.\n               i < count_weights s m2 \\<Longrightarrow>\n               w1 i = w2 i) \\<Longrightarrow>\n           insert_weights s m2 w1 = insert_weights s m2 w2;\n        \\<And>i.\n           i < count_weights s (Pool m1 m2) \\<Longrightarrow>\n           w1 i = w2 i\\<rbrakk>\n       \\<Longrightarrow> insert_weights s (Pool m1 m2) w1 =\n                         insert_weights s (Pool m1 m2) w2", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_weights s (Pool m1 m2) w1 = insert_weights s (Pool m1 m2) w2", "unfolding insert_weights.simps 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. Pool (insert_weights s m1 w2)\n     (insert_weights s m2\n       (if s then w1 else (\\<lambda>i. w1 (i + count_weights s m1)))) =\n    Pool (insert_weights s m1 w2)\n     (insert_weights s m2\n       (if s then w2 else (\\<lambda>i. w2 (i + count_weights s m1))))", "using unshared shared"], ["proof (prove)\nusing this:\n  s = False \\<Longrightarrow>\n  insert_weights s m2 (\\<lambda>i. w1 (i + count_weights s m1)) =\n  insert_weights s m2 (\\<lambda>i. w2 (i + count_weights s m1))\n  s = True \\<Longrightarrow> insert_weights s m2 w1 = insert_weights s m2 w2\n\ngoal (1 subgoal):\n 1. Pool (insert_weights s m1 w2)\n     (insert_weights s m2\n       (if s then w1 else (\\<lambda>i. w1 (i + count_weights s m1)))) =\n    Pool (insert_weights s m1 w2)\n     (insert_weights s m2\n       (if s then w2 else (\\<lambda>i. w2 (i + count_weights s m1))))", "by simp"], ["proof (state)\nthis:\n  insert_weights s (Pool m1 m2) w1 = insert_weights s (Pool m1 m2) w2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dims_mat_tensorlist_mult:\nassumes \"T\\<in>set\\<^sub>v (mat_tensorlist_mult A Ts ds)\"\nshows \"Tensor.dims T = ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dims T = ds", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dims T = ds", "obtain j where \"T = tensor_from_lookup ds (\\<lambda>is. (A *\\<^sub>v (map_vec (\\<lambda>T. Tensor.lookup T is) Ts)) $j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        T =\n        tensor_from_lookup ds\n         (\\<lambda>is.\n             (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) Ts) $\n             j) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using vec_setE[OF assms, unfolded mat_tensorlist_mult_def]"], ["proof (prove)\nusing this:\n  (\\<And>i.\n      \\<lbrakk>Matrix.vec (dim_row A)\n                (\\<lambda>j.\n                    tensor_from_lookup ds\n                     (\\<lambda>is.\n                         (A *\\<^sub>v\n                          map_vec (\\<lambda>T. lookup T is) Ts) $\n                         j)) $\n               i =\n               T;\n       i < dim_vec\n            (Matrix.vec (dim_row A)\n              (\\<lambda>j.\n                  tensor_from_lookup ds\n                   (\\<lambda>is.\n                       (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) Ts) $\n                       j)))\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        T =\n        tensor_from_lookup ds\n         (\\<lambda>is.\n             (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) Ts) $\n             j) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis dim_vec index_vec)"], ["proof (state)\nthis:\n  T =\n  tensor_from_lookup ds\n   (\\<lambda>is. (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) Ts) $ j)\n\ngoal (1 subgoal):\n 1. dims T = ds", "then"], ["proof (chain)\npicking this:\n  T =\n  tensor_from_lookup ds\n   (\\<lambda>is. (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) Ts) $ j)", "show ?thesis"], ["proof (prove)\nusing this:\n  T =\n  tensor_from_lookup ds\n   (\\<lambda>is. (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) Ts) $ j)\n\ngoal (1 subgoal):\n 1. dims T = ds", "by (simp add: length_tensor_vec_from_lookup tensor_from_lookup_def)"], ["proof (state)\nthis:\n  dims T = ds\n\ngoal:\nNo subgoals!", "qed"], ["", "fun tensors_from_net :: \"real mat convnet \\<Rightarrow> real tensor vec\" where\n\"tensors_from_net (Input M) = Matrix.vec M (\\<lambda>i. unit_vec M i)\" |\n\"tensors_from_net (Conv A m) = mat_tensorlist_mult A (tensors_from_net m) (input_sizes m)\" |\n\"tensors_from_net (Pool m1 m2) = component_mult (tensors_from_net m1) (tensors_from_net m2)\""], ["", "lemma output_size_correct_tensors:\nassumes \"valid_net' m\"\nshows \"output_size' m = dim_vec (tensors_from_net m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. output_size' m = dim_vec (tensors_from_net m)", "using assms"], ["proof (prove)\nusing this:\n  valid_net' m\n\ngoal (1 subgoal):\n 1. output_size' m = dim_vec (tensors_from_net m)", "proof (induction m)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       valid_net' (Input x) \\<Longrightarrow>\n       output_size' (Input x) = dim_vec (tensors_from_net (Input x))\n 2. \\<And>x1a m.\n       \\<lbrakk>valid_net' m \\<Longrightarrow>\n                output_size' m = dim_vec (tensors_from_net m);\n        valid_net' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Conv x1a m) =\n                         dim_vec (tensors_from_net (Conv x1a m))\n 3. \\<And>m1 m2.\n       \\<lbrakk>valid_net' m1 \\<Longrightarrow>\n                output_size' m1 = dim_vec (tensors_from_net m1);\n        valid_net' m2 \\<Longrightarrow>\n        output_size' m2 = dim_vec (tensors_from_net m2);\n        valid_net' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Pool m1 m2) =\n                         dim_vec (tensors_from_net (Pool m1 m2))", "case Input"], ["proof (state)\nthis:\n  valid_net' (Input x_)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       valid_net' (Input x) \\<Longrightarrow>\n       output_size' (Input x) = dim_vec (tensors_from_net (Input x))\n 2. \\<And>x1a m.\n       \\<lbrakk>valid_net' m \\<Longrightarrow>\n                output_size' m = dim_vec (tensors_from_net m);\n        valid_net' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Conv x1a m) =\n                         dim_vec (tensors_from_net (Conv x1a m))\n 3. \\<And>m1 m2.\n       \\<lbrakk>valid_net' m1 \\<Longrightarrow>\n                output_size' m1 = dim_vec (tensors_from_net m1);\n        valid_net' m2 \\<Longrightarrow>\n        output_size' m2 = dim_vec (tensors_from_net m2);\n        valid_net' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Pool m1 m2) =\n                         dim_vec (tensors_from_net (Pool m1 m2))", "then"], ["proof (chain)\npicking this:\n  valid_net' (Input x_)", "show ?case"], ["proof (prove)\nusing this:\n  valid_net' (Input x_)\n\ngoal (1 subgoal):\n 1. output_size' (Input x_) = dim_vec (tensors_from_net (Input x_))", "by simp"], ["proof (state)\nthis:\n  output_size' (Input x_) = dim_vec (tensors_from_net (Input x_))\n\ngoal (2 subgoals):\n 1. \\<And>x1a m.\n       \\<lbrakk>valid_net' m \\<Longrightarrow>\n                output_size' m = dim_vec (tensors_from_net m);\n        valid_net' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Conv x1a m) =\n                         dim_vec (tensors_from_net (Conv x1a m))\n 2. \\<And>m1 m2.\n       \\<lbrakk>valid_net' m1 \\<Longrightarrow>\n                output_size' m1 = dim_vec (tensors_from_net m1);\n        valid_net' m2 \\<Longrightarrow>\n        output_size' m2 = dim_vec (tensors_from_net m2);\n        valid_net' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Pool m1 m2) =\n                         dim_vec (tensors_from_net (Pool m1 m2))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1a m.\n       \\<lbrakk>valid_net' m \\<Longrightarrow>\n                output_size' m = dim_vec (tensors_from_net m);\n        valid_net' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Conv x1a m) =\n                         dim_vec (tensors_from_net (Conv x1a m))\n 2. \\<And>m1 m2.\n       \\<lbrakk>valid_net' m1 \\<Longrightarrow>\n                output_size' m1 = dim_vec (tensors_from_net m1);\n        valid_net' m2 \\<Longrightarrow>\n        output_size' m2 = dim_vec (tensors_from_net m2);\n        valid_net' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Pool m1 m2) =\n                         dim_vec (tensors_from_net (Pool m1 m2))", "case (Conv A m)"], ["proof (state)\nthis:\n  valid_net' m \\<Longrightarrow>\n  output_size' m = dim_vec (tensors_from_net m)\n  valid_net' (Conv A m)\n\ngoal (2 subgoals):\n 1. \\<And>x1a m.\n       \\<lbrakk>valid_net' m \\<Longrightarrow>\n                output_size' m = dim_vec (tensors_from_net m);\n        valid_net' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Conv x1a m) =\n                         dim_vec (tensors_from_net (Conv x1a m))\n 2. \\<And>m1 m2.\n       \\<lbrakk>valid_net' m1 \\<Longrightarrow>\n                output_size' m1 = dim_vec (tensors_from_net m1);\n        valid_net' m2 \\<Longrightarrow>\n        output_size' m2 = dim_vec (tensors_from_net m2);\n        valid_net' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Pool m1 m2) =\n                         dim_vec (tensors_from_net (Pool m1 m2))", "then"], ["proof (chain)\npicking this:\n  valid_net' m \\<Longrightarrow>\n  output_size' m = dim_vec (tensors_from_net m)\n  valid_net' (Conv A m)", "show ?case"], ["proof (prove)\nusing this:\n  valid_net' m \\<Longrightarrow>\n  output_size' m = dim_vec (tensors_from_net m)\n  valid_net' (Conv A m)\n\ngoal (1 subgoal):\n 1. output_size' (Conv A m) = dim_vec (tensors_from_net (Conv A m))", "unfolding remove_weights.simps output_size.simps tensors_from_net.simps"], ["proof (prove)\nusing this:\n  valid_net' m \\<Longrightarrow>\n  output_size' m = dim_vec (tensors_from_net m)\n  valid_net (Conv (dim_row A, dim_col A) (remove_weights m))\n\ngoal (1 subgoal):\n 1. dim_row A =\n    dim_vec (mat_tensorlist_mult A (tensors_from_net m) (input_sizes m))", "using mat_tensorlist_mult_def"], ["proof (prove)\nusing this:\n  valid_net' m \\<Longrightarrow>\n  output_size' m = dim_vec (tensors_from_net m)\n  valid_net (Conv (dim_row A, dim_col A) (remove_weights m))\n  mat_tensorlist_mult ?A ?Ts ?ds =\n  Matrix.vec (dim_row ?A)\n   (\\<lambda>j.\n       tensor_from_lookup ?ds\n        (\\<lambda>is.\n            (?A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) ?Ts) $ j))\n\ngoal (1 subgoal):\n 1. dim_row A =\n    dim_vec (mat_tensorlist_mult A (tensors_from_net m) (input_sizes m))", "by auto"], ["proof (state)\nthis:\n  output_size' (Conv A m) = dim_vec (tensors_from_net (Conv A m))\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2.\n       \\<lbrakk>valid_net' m1 \\<Longrightarrow>\n                output_size' m1 = dim_vec (tensors_from_net m1);\n        valid_net' m2 \\<Longrightarrow>\n        output_size' m2 = dim_vec (tensors_from_net m2);\n        valid_net' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Pool m1 m2) =\n                         dim_vec (tensors_from_net (Pool m1 m2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m1 m2.\n       \\<lbrakk>valid_net' m1 \\<Longrightarrow>\n                output_size' m1 = dim_vec (tensors_from_net m1);\n        valid_net' m2 \\<Longrightarrow>\n        output_size' m2 = dim_vec (tensors_from_net m2);\n        valid_net' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Pool m1 m2) =\n                         dim_vec (tensors_from_net (Pool m1 m2))", "case (Pool m1 m2)"], ["proof (state)\nthis:\n  valid_net' m1 \\<Longrightarrow>\n  output_size' m1 = dim_vec (tensors_from_net m1)\n  valid_net' m2 \\<Longrightarrow>\n  output_size' m2 = dim_vec (tensors_from_net m2)\n  valid_net' (Pool m1 m2)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2.\n       \\<lbrakk>valid_net' m1 \\<Longrightarrow>\n                output_size' m1 = dim_vec (tensors_from_net m1);\n        valid_net' m2 \\<Longrightarrow>\n        output_size' m2 = dim_vec (tensors_from_net m2);\n        valid_net' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Pool m1 m2) =\n                         dim_vec (tensors_from_net (Pool m1 m2))", "then"], ["proof (chain)\npicking this:\n  valid_net' m1 \\<Longrightarrow>\n  output_size' m1 = dim_vec (tensors_from_net m1)\n  valid_net' m2 \\<Longrightarrow>\n  output_size' m2 = dim_vec (tensors_from_net m2)\n  valid_net' (Pool m1 m2)", "show ?case"], ["proof (prove)\nusing this:\n  valid_net' m1 \\<Longrightarrow>\n  output_size' m1 = dim_vec (tensors_from_net m1)\n  valid_net' m2 \\<Longrightarrow>\n  output_size' m2 = dim_vec (tensors_from_net m2)\n  valid_net' (Pool m1 m2)\n\ngoal (1 subgoal):\n 1. output_size' (Pool m1 m2) = dim_vec (tensors_from_net (Pool m1 m2))", "by (metis convnet.distinct(3) convnet.distinct(5) convnet.inject(3) dim_component_mult\n    min.idem output_size.simps(3) remove_weights.simps(3) tensors_from_net.simps(3) valid_net.simps)"], ["proof (state)\nthis:\n  output_size' (Pool m1 m2) = dim_vec (tensors_from_net (Pool m1 m2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma output_size_correct:\nassumes \"valid_net' m\"\nand \"map dim_vec inputs = input_sizes m\"\nshows \"output_size' m = dim_vec (evaluate_net m inputs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. output_size' m = dim_vec (evaluate_net m inputs)", "using assms"], ["proof (prove)\nusing this:\n  valid_net' m\n  map dim_vec inputs = input_sizes m\n\ngoal (1 subgoal):\n 1. output_size' m = dim_vec (evaluate_net m inputs)", "proof (induction m arbitrary:inputs)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x inputs.\n       \\<lbrakk>valid_net' (Input x);\n        map dim_vec inputs = input_sizes (Input x)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Input x) =\n                         dim_vec (evaluate_net (Input x) inputs)\n 2. \\<And>x1a m inputs.\n       \\<lbrakk>\\<And>inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m\\<rbrakk>\n                   \\<Longrightarrow> output_size' m =\n                                     dim_vec (evaluate_net m inputs);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Conv x1a m) =\n                         dim_vec (evaluate_net (Conv x1a m) inputs)\n 3. \\<And>m1 m2 inputs.\n       \\<lbrakk>\\<And>inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1\\<rbrakk>\n                   \\<Longrightarrow> output_size' m1 =\n                                     dim_vec (evaluate_net m1 inputs);\n        \\<And>inputs.\n           \\<lbrakk>valid_net' m2;\n            map dim_vec inputs = input_sizes m2\\<rbrakk>\n           \\<Longrightarrow> output_size' m2 =\n                             dim_vec (evaluate_net m2 inputs);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Pool m1 m2) =\n                         dim_vec (evaluate_net (Pool m1 m2) inputs)", "case Input"], ["proof (state)\nthis:\n  valid_net' (Input x_)\n  map dim_vec inputs = input_sizes (Input x_)\n\ngoal (3 subgoals):\n 1. \\<And>x inputs.\n       \\<lbrakk>valid_net' (Input x);\n        map dim_vec inputs = input_sizes (Input x)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Input x) =\n                         dim_vec (evaluate_net (Input x) inputs)\n 2. \\<And>x1a m inputs.\n       \\<lbrakk>\\<And>inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m\\<rbrakk>\n                   \\<Longrightarrow> output_size' m =\n                                     dim_vec (evaluate_net m inputs);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Conv x1a m) =\n                         dim_vec (evaluate_net (Conv x1a m) inputs)\n 3. \\<And>m1 m2 inputs.\n       \\<lbrakk>\\<And>inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1\\<rbrakk>\n                   \\<Longrightarrow> output_size' m1 =\n                                     dim_vec (evaluate_net m1 inputs);\n        \\<And>inputs.\n           \\<lbrakk>valid_net' m2;\n            map dim_vec inputs = input_sizes m2\\<rbrakk>\n           \\<Longrightarrow> output_size' m2 =\n                             dim_vec (evaluate_net m2 inputs);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Pool m1 m2) =\n                         dim_vec (evaluate_net (Pool m1 m2) inputs)", "then"], ["proof (chain)\npicking this:\n  valid_net' (Input x_)\n  map dim_vec inputs = input_sizes (Input x_)", "show ?case"], ["proof (prove)\nusing this:\n  valid_net' (Input x_)\n  map dim_vec inputs = input_sizes (Input x_)\n\ngoal (1 subgoal):\n 1. output_size' (Input x_) = dim_vec (evaluate_net (Input x_) inputs)", "using length_Cons list.map_sel(1) list.sel(1) list.simps(8) list.size(3) nat.simps(3)"], ["proof (prove)\nusing this:\n  valid_net' (Input x_)\n  map dim_vec inputs = input_sizes (Input x_)\n  length (?x # ?xs) = Suc (length ?xs)\n  ?a \\<noteq> [] \\<Longrightarrow> hd (map ?f ?a) = ?f (hd ?a)\n  hd (?x21.0 # ?x22.0) = ?x21.0\n  map ?f [] = []\n  length [] = 0\n  Suc ?x2.0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. output_size' (Input x_) = dim_vec (evaluate_net (Input x_) inputs)", "by auto"], ["proof (state)\nthis:\n  output_size' (Input x_) = dim_vec (evaluate_net (Input x_) inputs)\n\ngoal (2 subgoals):\n 1. \\<And>x1a m inputs.\n       \\<lbrakk>\\<And>inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m\\<rbrakk>\n                   \\<Longrightarrow> output_size' m =\n                                     dim_vec (evaluate_net m inputs);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Conv x1a m) =\n                         dim_vec (evaluate_net (Conv x1a m) inputs)\n 2. \\<And>m1 m2 inputs.\n       \\<lbrakk>\\<And>inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1\\<rbrakk>\n                   \\<Longrightarrow> output_size' m1 =\n                                     dim_vec (evaluate_net m1 inputs);\n        \\<And>inputs.\n           \\<lbrakk>valid_net' m2;\n            map dim_vec inputs = input_sizes m2\\<rbrakk>\n           \\<Longrightarrow> output_size' m2 =\n                             dim_vec (evaluate_net m2 inputs);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Pool m1 m2) =\n                         dim_vec (evaluate_net (Pool m1 m2) inputs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1a m inputs.\n       \\<lbrakk>\\<And>inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m\\<rbrakk>\n                   \\<Longrightarrow> output_size' m =\n                                     dim_vec (evaluate_net m inputs);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Conv x1a m) =\n                         dim_vec (evaluate_net (Conv x1a m) inputs)\n 2. \\<And>m1 m2 inputs.\n       \\<lbrakk>\\<And>inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1\\<rbrakk>\n                   \\<Longrightarrow> output_size' m1 =\n                                     dim_vec (evaluate_net m1 inputs);\n        \\<And>inputs.\n           \\<lbrakk>valid_net' m2;\n            map dim_vec inputs = input_sizes m2\\<rbrakk>\n           \\<Longrightarrow> output_size' m2 =\n                             dim_vec (evaluate_net m2 inputs);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Pool m1 m2) =\n                         dim_vec (evaluate_net (Pool m1 m2) inputs)", "case (Conv A m)"], ["proof (state)\nthis:\n  \\<lbrakk>valid_net' m; map dim_vec ?inputs = input_sizes m\\<rbrakk>\n  \\<Longrightarrow> output_size' m = dim_vec (evaluate_net m ?inputs)\n  valid_net' (Conv A m)\n  map dim_vec inputs = input_sizes (Conv A m)\n\ngoal (2 subgoals):\n 1. \\<And>x1a m inputs.\n       \\<lbrakk>\\<And>inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m\\<rbrakk>\n                   \\<Longrightarrow> output_size' m =\n                                     dim_vec (evaluate_net m inputs);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Conv x1a m) =\n                         dim_vec (evaluate_net (Conv x1a m) inputs)\n 2. \\<And>m1 m2 inputs.\n       \\<lbrakk>\\<And>inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1\\<rbrakk>\n                   \\<Longrightarrow> output_size' m1 =\n                                     dim_vec (evaluate_net m1 inputs);\n        \\<And>inputs.\n           \\<lbrakk>valid_net' m2;\n            map dim_vec inputs = input_sizes m2\\<rbrakk>\n           \\<Longrightarrow> output_size' m2 =\n                             dim_vec (evaluate_net m2 inputs);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Pool m1 m2) =\n                         dim_vec (evaluate_net (Pool m1 m2) inputs)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>valid_net' m; map dim_vec ?inputs = input_sizes m\\<rbrakk>\n  \\<Longrightarrow> output_size' m = dim_vec (evaluate_net m ?inputs)\n  valid_net' (Conv A m)\n  map dim_vec inputs = input_sizes (Conv A m)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_net' m; map dim_vec ?inputs = input_sizes m\\<rbrakk>\n  \\<Longrightarrow> output_size' m = dim_vec (evaluate_net m ?inputs)\n  valid_net' (Conv A m)\n  map dim_vec inputs = input_sizes (Conv A m)\n\ngoal (1 subgoal):\n 1. output_size' (Conv A m) = dim_vec (evaluate_net (Conv A m) inputs)", "unfolding evaluate_net.simps remove_weights.simps output_size.simps dim_mult_mat_vec"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_net' m; map dim_vec ?inputs = input_sizes m\\<rbrakk>\n  \\<Longrightarrow> output_size' m = dim_vec (evaluate_net m ?inputs)\n  valid_net (Conv (dim_row A, dim_col A) (remove_weights m))\n  map dim_vec inputs = input_sizes (Conv A m)\n\ngoal (1 subgoal):\n 1. dim_row A = dim_row A", "by auto"], ["proof (state)\nthis:\n  output_size' (Conv A m) = dim_vec (evaluate_net (Conv A m) inputs)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 inputs.\n       \\<lbrakk>\\<And>inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1\\<rbrakk>\n                   \\<Longrightarrow> output_size' m1 =\n                                     dim_vec (evaluate_net m1 inputs);\n        \\<And>inputs.\n           \\<lbrakk>valid_net' m2;\n            map dim_vec inputs = input_sizes m2\\<rbrakk>\n           \\<Longrightarrow> output_size' m2 =\n                             dim_vec (evaluate_net m2 inputs);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Pool m1 m2) =\n                         dim_vec (evaluate_net (Pool m1 m2) inputs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m1 m2 inputs.\n       \\<lbrakk>\\<And>inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1\\<rbrakk>\n                   \\<Longrightarrow> output_size' m1 =\n                                     dim_vec (evaluate_net m1 inputs);\n        \\<And>inputs.\n           \\<lbrakk>valid_net' m2;\n            map dim_vec inputs = input_sizes m2\\<rbrakk>\n           \\<Longrightarrow> output_size' m2 =\n                             dim_vec (evaluate_net m2 inputs);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Pool m1 m2) =\n                         dim_vec (evaluate_net (Pool m1 m2) inputs)", "case (Pool m1 m2)"], ["proof (state)\nthis:\n  \\<lbrakk>valid_net' m1; map dim_vec ?inputs = input_sizes m1\\<rbrakk>\n  \\<Longrightarrow> output_size' m1 = dim_vec (evaluate_net m1 ?inputs)\n  \\<lbrakk>valid_net' m2; map dim_vec ?inputs = input_sizes m2\\<rbrakk>\n  \\<Longrightarrow> output_size' m2 = dim_vec (evaluate_net m2 ?inputs)\n  valid_net' (Pool m1 m2)\n  map dim_vec inputs = input_sizes (Pool m1 m2)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 inputs.\n       \\<lbrakk>\\<And>inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1\\<rbrakk>\n                   \\<Longrightarrow> output_size' m1 =\n                                     dim_vec (evaluate_net m1 inputs);\n        \\<And>inputs.\n           \\<lbrakk>valid_net' m2;\n            map dim_vec inputs = input_sizes m2\\<rbrakk>\n           \\<Longrightarrow> output_size' m2 =\n                             dim_vec (evaluate_net m2 inputs);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Pool m1 m2) =\n                         dim_vec (evaluate_net (Pool m1 m2) inputs)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>valid_net' m1; map dim_vec ?inputs = input_sizes m1\\<rbrakk>\n  \\<Longrightarrow> output_size' m1 = dim_vec (evaluate_net m1 ?inputs)\n  \\<lbrakk>valid_net' m2; map dim_vec ?inputs = input_sizes m2\\<rbrakk>\n  \\<Longrightarrow> output_size' m2 = dim_vec (evaluate_net m2 ?inputs)\n  valid_net' (Pool m1 m2)\n  map dim_vec inputs = input_sizes (Pool m1 m2)", "have \"valid_net' m1\" \"valid_net' m2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_net' m1; map dim_vec ?inputs = input_sizes m1\\<rbrakk>\n  \\<Longrightarrow> output_size' m1 = dim_vec (evaluate_net m1 ?inputs)\n  \\<lbrakk>valid_net' m2; map dim_vec ?inputs = input_sizes m2\\<rbrakk>\n  \\<Longrightarrow> output_size' m2 = dim_vec (evaluate_net m2 ?inputs)\n  valid_net' (Pool m1 m2)\n  map dim_vec inputs = input_sizes (Pool m1 m2)\n\ngoal (1 subgoal):\n 1. valid_net' m1 &&& valid_net' m2", "using convnet.distinct(3) convnet.distinct(5) convnet.inject(3) remove_weights.simps(3) valid_net.cases"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_net' m1; map dim_vec ?inputs = input_sizes m1\\<rbrakk>\n  \\<Longrightarrow> output_size' m1 = dim_vec (evaluate_net m1 ?inputs)\n  \\<lbrakk>valid_net' m2; map dim_vec ?inputs = input_sizes m2\\<rbrakk>\n  \\<Longrightarrow> output_size' m2 = dim_vec (evaluate_net m2 ?inputs)\n  valid_net' (Pool m1 m2)\n  map dim_vec inputs = input_sizes (Pool m1 m2)\n  Input ?x1.0 \\<noteq> Pool ?x31.0 ?x32.0\n  Conv ?x21.0 ?x22.0 \\<noteq> Pool ?x31.0 ?x32.0\n  (Pool ?x31.0 ?x32.0 = Pool ?y31.0 ?y32.0) =\n  (?x31.0 = ?y31.0 \\<and> ?x32.0 = ?y32.0)\n  remove_weights (Pool ?m1.0 ?m2.0) =\n  Pool (remove_weights ?m1.0) (remove_weights ?m2.0)\n  \\<lbrakk>valid_net ?a; \\<And>M. ?a = Input M \\<Longrightarrow> ?P;\n   \\<And>m r1 r0.\n      \\<lbrakk>?a = Conv (r0, r1) m; output_size m = r1;\n       valid_net m\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>m1 m2.\n      \\<lbrakk>?a = Pool m1 m2; output_size m1 = output_size m2;\n       valid_net m1; valid_net m2\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. valid_net' m1 &&& valid_net' m2", "by fastforce+"], ["proof (state)\nthis:\n  valid_net' m1\n  valid_net' m2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 inputs.\n       \\<lbrakk>\\<And>inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1\\<rbrakk>\n                   \\<Longrightarrow> output_size' m1 =\n                                     dim_vec (evaluate_net m1 inputs);\n        \\<And>inputs.\n           \\<lbrakk>valid_net' m2;\n            map dim_vec inputs = input_sizes m2\\<rbrakk>\n           \\<Longrightarrow> output_size' m2 =\n                             dim_vec (evaluate_net m2 inputs);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Pool m1 m2) =\n                         dim_vec (evaluate_net (Pool m1 m2) inputs)", "moreover"], ["proof (state)\nthis:\n  valid_net' m1\n  valid_net' m2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 inputs.\n       \\<lbrakk>\\<And>inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1\\<rbrakk>\n                   \\<Longrightarrow> output_size' m1 =\n                                     dim_vec (evaluate_net m1 inputs);\n        \\<And>inputs.\n           \\<lbrakk>valid_net' m2;\n            map dim_vec inputs = input_sizes m2\\<rbrakk>\n           \\<Longrightarrow> output_size' m2 =\n                             dim_vec (evaluate_net m2 inputs);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Pool m1 m2) =\n                         dim_vec (evaluate_net (Pool m1 m2) inputs)", "have \"map dim_vec (take (length (input_sizes m1)) inputs) = input_sizes m1\"\n       \"map dim_vec (drop (length (input_sizes m1)) inputs) = input_sizes m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map dim_vec (take (length (input_sizes m1)) inputs) = input_sizes m1 &&&\n    map dim_vec (drop (length (input_sizes m1)) inputs) = input_sizes m2", "using Pool.prems(2)"], ["proof (prove)\nusing this:\n  map dim_vec inputs = input_sizes (Pool m1 m2)\n\ngoal (1 subgoal):\n 1. map dim_vec (take (length (input_sizes m1)) inputs) = input_sizes m1 &&&\n    map dim_vec (drop (length (input_sizes m1)) inputs) = input_sizes m2", "by (metis append_eq_conv_conj drop_map input_sizes.simps(3) take_map)+"], ["proof (state)\nthis:\n  map dim_vec (take (length (input_sizes m1)) inputs) = input_sizes m1\n  map dim_vec (drop (length (input_sizes m1)) inputs) = input_sizes m2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 inputs.\n       \\<lbrakk>\\<And>inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1\\<rbrakk>\n                   \\<Longrightarrow> output_size' m1 =\n                                     dim_vec (evaluate_net m1 inputs);\n        \\<And>inputs.\n           \\<lbrakk>valid_net' m2;\n            map dim_vec inputs = input_sizes m2\\<rbrakk>\n           \\<Longrightarrow> output_size' m2 =\n                             dim_vec (evaluate_net m2 inputs);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Pool m1 m2) =\n                         dim_vec (evaluate_net (Pool m1 m2) inputs)", "ultimately"], ["proof (chain)\npicking this:\n  valid_net' m1\n  valid_net' m2\n  map dim_vec (take (length (input_sizes m1)) inputs) = input_sizes m1\n  map dim_vec (drop (length (input_sizes m1)) inputs) = input_sizes m2", "have\n    \"output_size' m1 = dim_vec (evaluate_net m1 (take (length (input_sizes m1)) inputs))\"\n    \"output_size' m2 = dim_vec (evaluate_net m2 (drop (length (input_sizes m1)) inputs))\""], ["proof (prove)\nusing this:\n  valid_net' m1\n  valid_net' m2\n  map dim_vec (take (length (input_sizes m1)) inputs) = input_sizes m1\n  map dim_vec (drop (length (input_sizes m1)) inputs) = input_sizes m2\n\ngoal (1 subgoal):\n 1. output_size' m1 =\n    dim_vec (evaluate_net m1 (take (length (input_sizes m1)) inputs)) &&&\n    output_size' m2 =\n    dim_vec (evaluate_net m2 (drop (length (input_sizes m1)) inputs))", "using Pool.IH"], ["proof (prove)\nusing this:\n  valid_net' m1\n  valid_net' m2\n  map dim_vec (take (length (input_sizes m1)) inputs) = input_sizes m1\n  map dim_vec (drop (length (input_sizes m1)) inputs) = input_sizes m2\n  \\<lbrakk>valid_net' m1; map dim_vec ?inputs = input_sizes m1\\<rbrakk>\n  \\<Longrightarrow> output_size' m1 = dim_vec (evaluate_net m1 ?inputs)\n  \\<lbrakk>valid_net' m2; map dim_vec ?inputs = input_sizes m2\\<rbrakk>\n  \\<Longrightarrow> output_size' m2 = dim_vec (evaluate_net m2 ?inputs)\n\ngoal (1 subgoal):\n 1. output_size' m1 =\n    dim_vec (evaluate_net m1 (take (length (input_sizes m1)) inputs)) &&&\n    output_size' m2 =\n    dim_vec (evaluate_net m2 (drop (length (input_sizes m1)) inputs))", "by blast+"], ["proof (state)\nthis:\n  output_size' m1 =\n  dim_vec (evaluate_net m1 (take (length (input_sizes m1)) inputs))\n  output_size' m2 =\n  dim_vec (evaluate_net m2 (drop (length (input_sizes m1)) inputs))\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 inputs.\n       \\<lbrakk>\\<And>inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1\\<rbrakk>\n                   \\<Longrightarrow> output_size' m1 =\n                                     dim_vec (evaluate_net m1 inputs);\n        \\<And>inputs.\n           \\<lbrakk>valid_net' m2;\n            map dim_vec inputs = input_sizes m2\\<rbrakk>\n           \\<Longrightarrow> output_size' m2 =\n                             dim_vec (evaluate_net m2 inputs);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> output_size' (Pool m1 m2) =\n                         dim_vec (evaluate_net (Pool m1 m2) inputs)", "then"], ["proof (chain)\npicking this:\n  output_size' m1 =\n  dim_vec (evaluate_net m1 (take (length (input_sizes m1)) inputs))\n  output_size' m2 =\n  dim_vec (evaluate_net m2 (drop (length (input_sizes m1)) inputs))", "show ?case"], ["proof (prove)\nusing this:\n  output_size' m1 =\n  dim_vec (evaluate_net m1 (take (length (input_sizes m1)) inputs))\n  output_size' m2 =\n  dim_vec (evaluate_net m2 (drop (length (input_sizes m1)) inputs))\n\ngoal (1 subgoal):\n 1. output_size' (Pool m1 m2) = dim_vec (evaluate_net (Pool m1 m2) inputs)", "unfolding evaluate_net.simps remove_weights.simps output_size.simps"], ["proof (prove)\nusing this:\n  output_size' m1 =\n  dim_vec (evaluate_net m1 (take (length (input_sizes m1)) inputs))\n  output_size' m2 =\n  dim_vec (evaluate_net m2 (drop (length (input_sizes m1)) inputs))\n\ngoal (1 subgoal):\n 1. output_size' m1 =\n    dim_vec\n     (component_mult\n       (evaluate_net m1 (take (length (input_sizes m1)) inputs))\n       (evaluate_net m2 (drop (length (input_sizes m1)) inputs)))", "by (metis Pool.prems(1) \\<open>valid_net' m1\\<close> \\<open>valid_net' m2\\<close> dim_component_mult\n     output_size.simps(3) output_size_correct_tensors remove_weights.simps(3) tensors_from_net.simps(3))"], ["proof (state)\nthis:\n  output_size' (Pool m1 m2) = dim_vec (evaluate_net (Pool m1 m2) inputs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma input_sizes_remove_weights: \"input_sizes m = input_sizes (remove_weights m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. input_sizes m = input_sizes (remove_weights m)", "by (induction m; simp)"], ["", "lemma dims_tensors_from_net:\nassumes \"T \\<in> set\\<^sub>v (tensors_from_net m)\"\nshows \"Tensor.dims T = input_sizes m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dims T = input_sizes m", "using assms"], ["proof (prove)\nusing this:\n  T \\<in> set\\<^sub>v (tensors_from_net m)\n\ngoal (1 subgoal):\n 1. dims T = input_sizes m", "proof (induction m arbitrary:T)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x T.\n       T \\<in> set\\<^sub>v (tensors_from_net (Input x)) \\<Longrightarrow>\n       dims T = input_sizes (Input x)\n 2. \\<And>x1a m T.\n       \\<lbrakk>\\<And>T.\n                   T \\<in> set\\<^sub>v\n                            (tensors_from_net m) \\<Longrightarrow>\n                   dims T = input_sizes m;\n        T \\<in> set\\<^sub>v (tensors_from_net (Conv x1a m))\\<rbrakk>\n       \\<Longrightarrow> dims T = input_sizes (Conv x1a m)\n 3. \\<And>m1 m2 T.\n       \\<lbrakk>\\<And>T.\n                   T \\<in> set\\<^sub>v\n                            (tensors_from_net m1) \\<Longrightarrow>\n                   dims T = input_sizes m1;\n        \\<And>T.\n           T \\<in> set\\<^sub>v (tensors_from_net m2) \\<Longrightarrow>\n           dims T = input_sizes m2;\n        T \\<in> set\\<^sub>v (tensors_from_net (Pool m1 m2))\\<rbrakk>\n       \\<Longrightarrow> dims T = input_sizes (Pool m1 m2)", "case (Input M)"], ["proof (state)\nthis:\n  T \\<in> set\\<^sub>v (tensors_from_net (Input M))\n\ngoal (3 subgoals):\n 1. \\<And>x T.\n       T \\<in> set\\<^sub>v (tensors_from_net (Input x)) \\<Longrightarrow>\n       dims T = input_sizes (Input x)\n 2. \\<And>x1a m T.\n       \\<lbrakk>\\<And>T.\n                   T \\<in> set\\<^sub>v\n                            (tensors_from_net m) \\<Longrightarrow>\n                   dims T = input_sizes m;\n        T \\<in> set\\<^sub>v (tensors_from_net (Conv x1a m))\\<rbrakk>\n       \\<Longrightarrow> dims T = input_sizes (Conv x1a m)\n 3. \\<And>m1 m2 T.\n       \\<lbrakk>\\<And>T.\n                   T \\<in> set\\<^sub>v\n                            (tensors_from_net m1) \\<Longrightarrow>\n                   dims T = input_sizes m1;\n        \\<And>T.\n           T \\<in> set\\<^sub>v (tensors_from_net m2) \\<Longrightarrow>\n           dims T = input_sizes m2;\n        T \\<in> set\\<^sub>v (tensors_from_net (Pool m1 m2))\\<rbrakk>\n       \\<Longrightarrow> dims T = input_sizes (Pool m1 m2)", "then"], ["proof (chain)\npicking this:\n  T \\<in> set\\<^sub>v (tensors_from_net (Input M))", "obtain j where \"T = unit_vec M j\""], ["proof (prove)\nusing this:\n  T \\<in> set\\<^sub>v (tensors_from_net (Input M))\n\ngoal (1 subgoal):\n 1. (\\<And>j. T = unit_vec M j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using vec_setE tensors_from_net.simps(1)"], ["proof (prove)\nusing this:\n  T \\<in> set\\<^sub>v (tensors_from_net (Input M))\n  \\<lbrakk>?a \\<in> set\\<^sub>v ?v;\n   \\<And>i.\n      \\<lbrakk>?v $ i = ?a; i < dim_vec ?v\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  tensors_from_net (Input ?M) = Matrix.vec ?M (unit_vec ?M)\n\ngoal (1 subgoal):\n 1. (\\<And>j. T = unit_vec M j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis dim_vec index_vec)"], ["proof (state)\nthis:\n  T = unit_vec M j\n\ngoal (3 subgoals):\n 1. \\<And>x T.\n       T \\<in> set\\<^sub>v (tensors_from_net (Input x)) \\<Longrightarrow>\n       dims T = input_sizes (Input x)\n 2. \\<And>x1a m T.\n       \\<lbrakk>\\<And>T.\n                   T \\<in> set\\<^sub>v\n                            (tensors_from_net m) \\<Longrightarrow>\n                   dims T = input_sizes m;\n        T \\<in> set\\<^sub>v (tensors_from_net (Conv x1a m))\\<rbrakk>\n       \\<Longrightarrow> dims T = input_sizes (Conv x1a m)\n 3. \\<And>m1 m2 T.\n       \\<lbrakk>\\<And>T.\n                   T \\<in> set\\<^sub>v\n                            (tensors_from_net m1) \\<Longrightarrow>\n                   dims T = input_sizes m1;\n        \\<And>T.\n           T \\<in> set\\<^sub>v (tensors_from_net m2) \\<Longrightarrow>\n           dims T = input_sizes m2;\n        T \\<in> set\\<^sub>v (tensors_from_net (Pool m1 m2))\\<rbrakk>\n       \\<Longrightarrow> dims T = input_sizes (Pool m1 m2)", "then"], ["proof (chain)\npicking this:\n  T = unit_vec M j", "show ?case"], ["proof (prove)\nusing this:\n  T = unit_vec M j\n\ngoal (1 subgoal):\n 1. dims T = input_sizes (Input M)", "by (simp add: dims_unit_vec)"], ["proof (state)\nthis:\n  dims T = input_sizes (Input M)\n\ngoal (2 subgoals):\n 1. \\<And>x1a m T.\n       \\<lbrakk>\\<And>T.\n                   T \\<in> set\\<^sub>v\n                            (tensors_from_net m) \\<Longrightarrow>\n                   dims T = input_sizes m;\n        T \\<in> set\\<^sub>v (tensors_from_net (Conv x1a m))\\<rbrakk>\n       \\<Longrightarrow> dims T = input_sizes (Conv x1a m)\n 2. \\<And>m1 m2 T.\n       \\<lbrakk>\\<And>T.\n                   T \\<in> set\\<^sub>v\n                            (tensors_from_net m1) \\<Longrightarrow>\n                   dims T = input_sizes m1;\n        \\<And>T.\n           T \\<in> set\\<^sub>v (tensors_from_net m2) \\<Longrightarrow>\n           dims T = input_sizes m2;\n        T \\<in> set\\<^sub>v (tensors_from_net (Pool m1 m2))\\<rbrakk>\n       \\<Longrightarrow> dims T = input_sizes (Pool m1 m2)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1a m T.\n       \\<lbrakk>\\<And>T.\n                   T \\<in> set\\<^sub>v\n                            (tensors_from_net m) \\<Longrightarrow>\n                   dims T = input_sizes m;\n        T \\<in> set\\<^sub>v (tensors_from_net (Conv x1a m))\\<rbrakk>\n       \\<Longrightarrow> dims T = input_sizes (Conv x1a m)\n 2. \\<And>m1 m2 T.\n       \\<lbrakk>\\<And>T.\n                   T \\<in> set\\<^sub>v\n                            (tensors_from_net m1) \\<Longrightarrow>\n                   dims T = input_sizes m1;\n        \\<And>T.\n           T \\<in> set\\<^sub>v (tensors_from_net m2) \\<Longrightarrow>\n           dims T = input_sizes m2;\n        T \\<in> set\\<^sub>v (tensors_from_net (Pool m1 m2))\\<rbrakk>\n       \\<Longrightarrow> dims T = input_sizes (Pool m1 m2)", "case (Conv A m)"], ["proof (state)\nthis:\n  ?T \\<in> set\\<^sub>v (tensors_from_net m) \\<Longrightarrow>\n  dims ?T = input_sizes m\n  T \\<in> set\\<^sub>v (tensors_from_net (Conv A m))\n\ngoal (2 subgoals):\n 1. \\<And>x1a m T.\n       \\<lbrakk>\\<And>T.\n                   T \\<in> set\\<^sub>v\n                            (tensors_from_net m) \\<Longrightarrow>\n                   dims T = input_sizes m;\n        T \\<in> set\\<^sub>v (tensors_from_net (Conv x1a m))\\<rbrakk>\n       \\<Longrightarrow> dims T = input_sizes (Conv x1a m)\n 2. \\<And>m1 m2 T.\n       \\<lbrakk>\\<And>T.\n                   T \\<in> set\\<^sub>v\n                            (tensors_from_net m1) \\<Longrightarrow>\n                   dims T = input_sizes m1;\n        \\<And>T.\n           T \\<in> set\\<^sub>v (tensors_from_net m2) \\<Longrightarrow>\n           dims T = input_sizes m2;\n        T \\<in> set\\<^sub>v (tensors_from_net (Pool m1 m2))\\<rbrakk>\n       \\<Longrightarrow> dims T = input_sizes (Pool m1 m2)", "then"], ["proof (chain)\npicking this:\n  ?T \\<in> set\\<^sub>v (tensors_from_net m) \\<Longrightarrow>\n  dims ?T = input_sizes m\n  T \\<in> set\\<^sub>v (tensors_from_net (Conv A m))", "show ?case"], ["proof (prove)\nusing this:\n  ?T \\<in> set\\<^sub>v (tensors_from_net m) \\<Longrightarrow>\n  dims ?T = input_sizes m\n  T \\<in> set\\<^sub>v (tensors_from_net (Conv A m))\n\ngoal (1 subgoal):\n 1. dims T = input_sizes (Conv A m)", "unfolding remove_weights.simps input_sizes.simps"], ["proof (prove)\nusing this:\n  ?T \\<in> set\\<^sub>v (tensors_from_net m) \\<Longrightarrow>\n  dims ?T = input_sizes m\n  T \\<in> set\\<^sub>v (tensors_from_net (Conv A m))\n\ngoal (1 subgoal):\n 1. dims T = input_sizes m", "using dims_mat_tensorlist_mult"], ["proof (prove)\nusing this:\n  ?T \\<in> set\\<^sub>v (tensors_from_net m) \\<Longrightarrow>\n  dims ?T = input_sizes m\n  T \\<in> set\\<^sub>v (tensors_from_net (Conv A m))\n  ?T \\<in> set\\<^sub>v (mat_tensorlist_mult ?A ?Ts ?ds) \\<Longrightarrow>\n  dims ?T = ?ds\n\ngoal (1 subgoal):\n 1. dims T = input_sizes m", "by (simp add: input_sizes_remove_weights)"], ["proof (state)\nthis:\n  dims T = input_sizes (Conv A m)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 T.\n       \\<lbrakk>\\<And>T.\n                   T \\<in> set\\<^sub>v\n                            (tensors_from_net m1) \\<Longrightarrow>\n                   dims T = input_sizes m1;\n        \\<And>T.\n           T \\<in> set\\<^sub>v (tensors_from_net m2) \\<Longrightarrow>\n           dims T = input_sizes m2;\n        T \\<in> set\\<^sub>v (tensors_from_net (Pool m1 m2))\\<rbrakk>\n       \\<Longrightarrow> dims T = input_sizes (Pool m1 m2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m1 m2 T.\n       \\<lbrakk>\\<And>T.\n                   T \\<in> set\\<^sub>v\n                            (tensors_from_net m1) \\<Longrightarrow>\n                   dims T = input_sizes m1;\n        \\<And>T.\n           T \\<in> set\\<^sub>v (tensors_from_net m2) \\<Longrightarrow>\n           dims T = input_sizes m2;\n        T \\<in> set\\<^sub>v (tensors_from_net (Pool m1 m2))\\<rbrakk>\n       \\<Longrightarrow> dims T = input_sizes (Pool m1 m2)", "case (Pool m1 m2 T)"], ["proof (state)\nthis:\n  ?T \\<in> set\\<^sub>v (tensors_from_net m1) \\<Longrightarrow>\n  dims ?T = input_sizes m1\n  ?T \\<in> set\\<^sub>v (tensors_from_net m2) \\<Longrightarrow>\n  dims ?T = input_sizes m2\n  T \\<in> set\\<^sub>v (tensors_from_net (Pool m1 m2))\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 T.\n       \\<lbrakk>\\<And>T.\n                   T \\<in> set\\<^sub>v\n                            (tensors_from_net m1) \\<Longrightarrow>\n                   dims T = input_sizes m1;\n        \\<And>T.\n           T \\<in> set\\<^sub>v (tensors_from_net m2) \\<Longrightarrow>\n           dims T = input_sizes m2;\n        T \\<in> set\\<^sub>v (tensors_from_net (Pool m1 m2))\\<rbrakk>\n       \\<Longrightarrow> dims T = input_sizes (Pool m1 m2)", "then"], ["proof (chain)\npicking this:\n  ?T \\<in> set\\<^sub>v (tensors_from_net m1) \\<Longrightarrow>\n  dims ?T = input_sizes m1\n  ?T \\<in> set\\<^sub>v (tensors_from_net m2) \\<Longrightarrow>\n  dims ?T = input_sizes m2\n  T \\<in> set\\<^sub>v (tensors_from_net (Pool m1 m2))", "obtain i where\n    \"component_mult (tensors_from_net m1) (tensors_from_net m2) $ i = T\"\n    \"i < dim_vec (tensors_from_net m1)\" \"i < dim_vec (tensors_from_net m2)\""], ["proof (prove)\nusing this:\n  ?T \\<in> set\\<^sub>v (tensors_from_net m1) \\<Longrightarrow>\n  dims ?T = input_sizes m1\n  ?T \\<in> set\\<^sub>v (tensors_from_net m2) \\<Longrightarrow>\n  dims ?T = input_sizes m2\n  T \\<in> set\\<^sub>v (tensors_from_net (Pool m1 m2))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>component_mult (tensors_from_net m1)\n                  (tensors_from_net m2) $\n                 i =\n                 T;\n         i < dim_vec (tensors_from_net m1);\n         i < dim_vec (tensors_from_net m2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using tensors_from_net.simps vec_setE dim_component_mult"], ["proof (prove)\nusing this:\n  ?T \\<in> set\\<^sub>v (tensors_from_net m1) \\<Longrightarrow>\n  dims ?T = input_sizes m1\n  ?T \\<in> set\\<^sub>v (tensors_from_net m2) \\<Longrightarrow>\n  dims ?T = input_sizes m2\n  T \\<in> set\\<^sub>v (tensors_from_net (Pool m1 m2))\n  tensors_from_net (Input ?M) = Matrix.vec ?M (unit_vec ?M)\n  tensors_from_net (Conv ?A ?m) =\n  mat_tensorlist_mult ?A (tensors_from_net ?m) (input_sizes ?m)\n  tensors_from_net (Pool ?m1.0 ?m2.0) =\n  component_mult (tensors_from_net ?m1.0) (tensors_from_net ?m2.0)\n  \\<lbrakk>?a \\<in> set\\<^sub>v ?v;\n   \\<And>i.\n      \\<lbrakk>?v $ i = ?a; i < dim_vec ?v\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  dim_vec (component_mult ?v ?w) = min (dim_vec ?v) (dim_vec ?w)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>component_mult (tensors_from_net m1)\n                  (tensors_from_net m2) $\n                 i =\n                 T;\n         i < dim_vec (tensors_from_net m1);\n         i < dim_vec (tensors_from_net m2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis min.strict_boundedE)"], ["proof (state)\nthis:\n  component_mult (tensors_from_net m1) (tensors_from_net m2) $ i = T\n  i < dim_vec (tensors_from_net m1)\n  i < dim_vec (tensors_from_net m2)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 T.\n       \\<lbrakk>\\<And>T.\n                   T \\<in> set\\<^sub>v\n                            (tensors_from_net m1) \\<Longrightarrow>\n                   dims T = input_sizes m1;\n        \\<And>T.\n           T \\<in> set\\<^sub>v (tensors_from_net m2) \\<Longrightarrow>\n           dims T = input_sizes m2;\n        T \\<in> set\\<^sub>v (tensors_from_net (Pool m1 m2))\\<rbrakk>\n       \\<Longrightarrow> dims T = input_sizes (Pool m1 m2)", "then"], ["proof (chain)\npicking this:\n  component_mult (tensors_from_net m1) (tensors_from_net m2) $ i = T\n  i < dim_vec (tensors_from_net m1)\n  i < dim_vec (tensors_from_net m2)", "obtain T1 T2 where \"T = T1 \\<otimes> T2\" \"T1 \\<in> set\\<^sub>v (tensors_from_net m1)\" \"T2 \\<in> set\\<^sub>v (tensors_from_net m2)\""], ["proof (prove)\nusing this:\n  component_mult (tensors_from_net m1) (tensors_from_net m2) $ i = T\n  i < dim_vec (tensors_from_net m1)\n  i < dim_vec (tensors_from_net m2)\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>T = T1 \\<otimes> T2;\n         T1 \\<in> set\\<^sub>v (tensors_from_net m1);\n         T2 \\<in> set\\<^sub>v (tensors_from_net m2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using vec_setI"], ["proof (prove)\nusing this:\n  component_mult (tensors_from_net m1) (tensors_from_net m2) $ i = T\n  i < dim_vec (tensors_from_net m1)\n  i < dim_vec (tensors_from_net m2)\n  \\<lbrakk>?v $ ?i = ?a; ?i < dim_vec ?v\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> set\\<^sub>v ?v\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        \\<lbrakk>T = T1 \\<otimes> T2;\n         T1 \\<in> set\\<^sub>v (tensors_from_net m1);\n         T2 \\<in> set\\<^sub>v (tensors_from_net m2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis index_component_mult)"], ["proof (state)\nthis:\n  T = T1 \\<otimes> T2\n  T1 \\<in> set\\<^sub>v (tensors_from_net m1)\n  T2 \\<in> set\\<^sub>v (tensors_from_net m2)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 T.\n       \\<lbrakk>\\<And>T.\n                   T \\<in> set\\<^sub>v\n                            (tensors_from_net m1) \\<Longrightarrow>\n                   dims T = input_sizes m1;\n        \\<And>T.\n           T \\<in> set\\<^sub>v (tensors_from_net m2) \\<Longrightarrow>\n           dims T = input_sizes m2;\n        T \\<in> set\\<^sub>v (tensors_from_net (Pool m1 m2))\\<rbrakk>\n       \\<Longrightarrow> dims T = input_sizes (Pool m1 m2)", "then"], ["proof (chain)\npicking this:\n  T = T1 \\<otimes> T2\n  T1 \\<in> set\\<^sub>v (tensors_from_net m1)\n  T2 \\<in> set\\<^sub>v (tensors_from_net m2)", "show ?case"], ["proof (prove)\nusing this:\n  T = T1 \\<otimes> T2\n  T1 \\<in> set\\<^sub>v (tensors_from_net m1)\n  T2 \\<in> set\\<^sub>v (tensors_from_net m2)\n\ngoal (1 subgoal):\n 1. dims T = input_sizes (Pool m1 m2)", "unfolding remove_weights.simps input_sizes.simps"], ["proof (prove)\nusing this:\n  T = T1 \\<otimes> T2\n  T1 \\<in> set\\<^sub>v (tensors_from_net m1)\n  T2 \\<in> set\\<^sub>v (tensors_from_net m2)\n\ngoal (1 subgoal):\n 1. dims T = input_sizes m1 @ input_sizes m2", "by (simp add: Pool.IH(1) Pool.IH(2))"], ["proof (state)\nthis:\n  dims T = input_sizes (Pool m1 m2)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition base_input :: \"real mat convnet \\<Rightarrow> nat list \\<Rightarrow> real vec list\" where\n\"base_input m is = (map (\\<lambda>(n, i). unit\\<^sub>v n i) (zip (input_sizes m) is))\""], ["", "lemma base_input_length:\nassumes \"is \\<lhd> input_sizes m\"\nshows \"input_sizes m = map dim_vec (base_input m is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. input_sizes m = map dim_vec (base_input m is)", "proof (rule nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (input_sizes m) = length (map dim_vec (base_input m is))\n 2. \\<And>i.\n       i < length (input_sizes m) \\<Longrightarrow>\n       input_sizes m ! i = map dim_vec (base_input m is) ! i", "have \"length (input_sizes m) = length is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (input_sizes m) = length is", "using assms valid_index_length"], ["proof (prove)\nusing this:\n  is \\<lhd> input_sizes m\n  ?is \\<lhd> ?ds \\<Longrightarrow> length ?is = length ?ds\n\ngoal (1 subgoal):\n 1. length (input_sizes m) = length is", "by auto"], ["proof (state)\nthis:\n  length (input_sizes m) = length is\n\ngoal (2 subgoals):\n 1. length (input_sizes m) = length (map dim_vec (base_input m is))\n 2. \\<And>i.\n       i < length (input_sizes m) \\<Longrightarrow>\n       input_sizes m ! i = map dim_vec (base_input m is) ! i", "then"], ["proof (chain)\npicking this:\n  length (input_sizes m) = length is", "show \"length (input_sizes m) = length (map dim_vec (base_input m is))\""], ["proof (prove)\nusing this:\n  length (input_sizes m) = length is\n\ngoal (1 subgoal):\n 1. length (input_sizes m) = length (map dim_vec (base_input m is))", "unfolding base_input_def"], ["proof (prove)\nusing this:\n  length (input_sizes m) = length is\n\ngoal (1 subgoal):\n 1. length (input_sizes m) =\n    length (map dim_vec (map2 unit\\<^sub>v (input_sizes m) is))", "by auto"], ["proof (state)\nthis:\n  length (input_sizes m) = length (map dim_vec (base_input m is))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (input_sizes m) \\<Longrightarrow>\n       input_sizes m ! i = map dim_vec (base_input m is) ! i", "{"], ["proof (state)\nthis:\n  length (input_sizes m) = length (map dim_vec (base_input m is))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (input_sizes m) \\<Longrightarrow>\n       input_sizes m ! i = map dim_vec (base_input m is) ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (input_sizes m) \\<Longrightarrow>\n       input_sizes m ! i = map dim_vec (base_input m is) ! i", "assume \"i<length (input_sizes m)\""], ["proof (state)\nthis:\n  i < length (input_sizes m)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (input_sizes m) \\<Longrightarrow>\n       input_sizes m ! i = map dim_vec (base_input m is) ! i", "then"], ["proof (chain)\npicking this:\n  i < length (input_sizes m)", "have \"map (\\<lambda>(n, i). unit\\<^sub>v n i) (zip (input_sizes m) is) ! i = unit\\<^sub>v (input_sizes m ! i) (is ! i)\""], ["proof (prove)\nusing this:\n  i < length (input_sizes m)\n\ngoal (1 subgoal):\n 1. map2 unit\\<^sub>v (input_sizes m) is ! i =\n    unit\\<^sub>v (input_sizes m ! i) (is ! i)", "using \\<open>length (input_sizes m) = length is\\<close>"], ["proof (prove)\nusing this:\n  i < length (input_sizes m)\n  length (input_sizes m) = length is\n\ngoal (1 subgoal):\n 1. map2 unit\\<^sub>v (input_sizes m) is ! i =\n    unit\\<^sub>v (input_sizes m ! i) (is ! i)", "by auto"], ["proof (state)\nthis:\n  map2 unit\\<^sub>v (input_sizes m) is ! i =\n  unit\\<^sub>v (input_sizes m ! i) (is ! i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (input_sizes m) \\<Longrightarrow>\n       input_sizes m ! i = map dim_vec (base_input m is) ! i", "then"], ["proof (chain)\npicking this:\n  map2 unit\\<^sub>v (input_sizes m) is ! i =\n  unit\\<^sub>v (input_sizes m ! i) (is ! i)", "have \"input_sizes m ! i = map dim_vec (base_input m is) ! i\""], ["proof (prove)\nusing this:\n  map2 unit\\<^sub>v (input_sizes m) is ! i =\n  unit\\<^sub>v (input_sizes m ! i) (is ! i)\n\ngoal (1 subgoal):\n 1. input_sizes m ! i = map dim_vec (base_input m is) ! i", "unfolding base_input_def"], ["proof (prove)\nusing this:\n  map2 unit\\<^sub>v (input_sizes m) is ! i =\n  unit\\<^sub>v (input_sizes m ! i) (is ! i)\n\ngoal (1 subgoal):\n 1. input_sizes m ! i =\n    map dim_vec (map2 unit\\<^sub>v (input_sizes m) is) ! i", "using index_unit_vec(3)"], ["proof (prove)\nusing this:\n  map2 unit\\<^sub>v (input_sizes m) is ! i =\n  unit\\<^sub>v (input_sizes m ! i) (is ! i)\n  dim_vec (unit\\<^sub>v ?n ?i) = ?n\n\ngoal (1 subgoal):\n 1. input_sizes m ! i =\n    map dim_vec (map2 unit\\<^sub>v (input_sizes m) is) ! i", "using \\<open>i < length (input_sizes m)\\<close> \\<open>length (input_sizes m) = length (map dim_vec (base_input m is))\\<close>\n       base_input_def assms length_map nth_map valid_index_lt"], ["proof (prove)\nusing this:\n  map2 unit\\<^sub>v (input_sizes m) is ! i =\n  unit\\<^sub>v (input_sizes m ! i) (is ! i)\n  dim_vec (unit\\<^sub>v ?n ?i) = ?n\n  i < length (input_sizes m)\n  length (input_sizes m) = length (map dim_vec (base_input m is))\n  base_input ?m ?is = map2 unit\\<^sub>v (input_sizes ?m) ?is\n  is \\<lhd> input_sizes m\n  length (map ?f ?xs) = length ?xs\n  ?n < length ?xs \\<Longrightarrow> map ?f ?xs ! ?n = ?f (?xs ! ?n)\n  \\<lbrakk>?is \\<lhd> ?ds; ?m < length ?ds\\<rbrakk>\n  \\<Longrightarrow> ?is ! ?m < ?ds ! ?m\n\ngoal (1 subgoal):\n 1. input_sizes m ! i =\n    map dim_vec (map2 unit\\<^sub>v (input_sizes m) is) ! i", "by (simp add: input_sizes_remove_weights)"], ["proof (state)\nthis:\n  input_sizes m ! i = map dim_vec (base_input m is) ! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (input_sizes m) \\<Longrightarrow>\n       input_sizes m ! i = map dim_vec (base_input m is) ! i", "}"], ["proof (state)\nthis:\n  ?i2 < length (input_sizes m) \\<Longrightarrow>\n  input_sizes m ! ?i2 = map dim_vec (base_input m is) ! ?i2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (input_sizes m) \\<Longrightarrow>\n       input_sizes m ! i = map dim_vec (base_input m is) ! i", "then"], ["proof (chain)\npicking this:\n  ?i2 < length (input_sizes m) \\<Longrightarrow>\n  input_sizes m ! ?i2 = map dim_vec (base_input m is) ! ?i2", "show \"\\<And>i. i < length (input_sizes m) \\<Longrightarrow> input_sizes m ! i = map dim_vec (base_input m is) ! i\""], ["proof (prove)\nusing this:\n  ?i2 < length (input_sizes m) \\<Longrightarrow>\n  input_sizes m ! ?i2 = map dim_vec (base_input m is) ! ?i2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (input_sizes m) \\<Longrightarrow>\n       input_sizes m ! i = map dim_vec (base_input m is) ! i", "by auto"], ["proof (state)\nthis:\n  ?i < length (input_sizes m) \\<Longrightarrow>\n  input_sizes m ! ?i = map dim_vec (base_input m is) ! ?i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nth_mat_tensorlist_mult:\nassumes \"\\<And>A. A\\<in>set\\<^sub>v Ts \\<Longrightarrow> dims A = ds\"\nassumes \"i < dim_row A\"\nassumes \"dim_vec Ts = dim_col A\"\nshows \"mat_tensorlist_mult A Ts ds $ i = listsum ds (map (\\<lambda>j. (A $$ (i,j)) \\<cdot> Ts $ j) [0..<dim_vec Ts])\"\n  (is \"_ = listsum ds ?Ts'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_tensorlist_mult A Ts ds $ i =\n    listsum ds\n     (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts])", "proof (rule tensor_lookup_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. dims (mat_tensorlist_mult A Ts ds $ i) =\n    dims\n     (listsum ds\n       (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n 2. \\<And>is.\n       is \\<lhd> dims (mat_tensorlist_mult A Ts ds $ i) \\<Longrightarrow>\n       lookup (mat_tensorlist_mult A Ts ds $ i) is =\n       lookup\n        (listsum ds\n          (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n        is", "have dims_Ts':\"\\<And>T. T\\<in>set ?Ts' \\<Longrightarrow> dims T = ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>T.\n       T \\<in> set (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j)\n                     [0..<dim_vec Ts]) \\<Longrightarrow>\n       dims T = ds", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T.\n       T \\<in> set (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j)\n                     [0..<dim_vec Ts]) \\<Longrightarrow>\n       dims T = ds", "fix T"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T.\n       T \\<in> set (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j)\n                     [0..<dim_vec Ts]) \\<Longrightarrow>\n       dims T = ds", "assume \"T\\<in>set ?Ts'\""], ["proof (state)\nthis:\n  T \\<in> set (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j)\n                [0..<dim_vec Ts])\n\ngoal (1 subgoal):\n 1. \\<And>T.\n       T \\<in> set (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j)\n                     [0..<dim_vec Ts]) \\<Longrightarrow>\n       dims T = ds", "then"], ["proof (chain)\npicking this:\n  T \\<in> set (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j)\n                [0..<dim_vec Ts])", "obtain k where \"T = ?Ts' ! k\" and \"k < length ?Ts'\" \"k < dim_vec Ts\""], ["proof (prove)\nusing this:\n  T \\<in> set (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j)\n                [0..<dim_vec Ts])\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>T =\n                 map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j)\n                  [0..<dim_vec Ts] !\n                 k;\n         k < length\n              (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j)\n                [0..<dim_vec Ts]);\n         k < dim_vec Ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using in_set_conv_nth"], ["proof (prove)\nusing this:\n  T \\<in> set (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j)\n                [0..<dim_vec Ts])\n  (?x \\<in> set ?xs) = (\\<exists>i<length ?xs. ?xs ! i = ?x)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>T =\n                 map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j)\n                  [0..<dim_vec Ts] !\n                 k;\n         k < length\n              (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j)\n                [0..<dim_vec Ts]);\n         k < dim_vec Ts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  T = map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts] ! k\n  k < length (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts])\n  k < dim_vec Ts\n\ngoal (1 subgoal):\n 1. \\<And>T.\n       T \\<in> set (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j)\n                     [0..<dim_vec Ts]) \\<Longrightarrow>\n       dims T = ds", "show \"dims T = ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dims T = ds", "unfolding \\<open>T = ?Ts' ! k\\<close>   nth_map[OF \\<open>k < length ?Ts'\\<close>[unfolded length_map]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. dims\n     (A $$ (i, [0..<dim_vec Ts] ! k) \\<cdot> Ts $ ([0..<dim_vec Ts] ! k)) =\n    ds", "using assms(1) \\<open>k < dim_vec Ts\\<close>"], ["proof (prove)\nusing this:\n  ?A \\<in> set\\<^sub>v Ts \\<Longrightarrow> dims ?A = ds\n  k < dim_vec Ts\n\ngoal (1 subgoal):\n 1. dims\n     (A $$ (i, [0..<dim_vec Ts] ! k) \\<cdot> Ts $ ([0..<dim_vec Ts] ! k)) =\n    ds", "by (simp add: \\<open>k < length (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts])\\<close> vec_setI)"], ["proof (state)\nthis:\n  dims T = ds\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?T \\<in> set (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j)\n                 [0..<dim_vec Ts]) \\<Longrightarrow>\n  dims ?T = ds\n\ngoal (2 subgoals):\n 1. dims (mat_tensorlist_mult A Ts ds $ i) =\n    dims\n     (listsum ds\n       (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n 2. \\<And>is.\n       is \\<lhd> dims (mat_tensorlist_mult A Ts ds $ i) \\<Longrightarrow>\n       lookup (mat_tensorlist_mult A Ts ds $ i) is =\n       lookup\n        (listsum ds\n          (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n        is", "then"], ["proof (chain)\npicking this:\n  ?T \\<in> set (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j)\n                 [0..<dim_vec Ts]) \\<Longrightarrow>\n  dims ?T = ds", "show dims_eq:\"dims (mat_tensorlist_mult A Ts ds $ i) = dims (Tensor_Plus.listsum ds (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\""], ["proof (prove)\nusing this:\n  ?T \\<in> set (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j)\n                 [0..<dim_vec Ts]) \\<Longrightarrow>\n  dims ?T = ds\n\ngoal (1 subgoal):\n 1. dims (mat_tensorlist_mult A Ts ds $ i) =\n    dims\n     (listsum ds\n       (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))", "using dims_mat_tensorlist_mult assms  mat_tensorlist_mult_def listsum_dims"], ["proof (prove)\nusing this:\n  ?T \\<in> set (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j)\n                 [0..<dim_vec Ts]) \\<Longrightarrow>\n  dims ?T = ds\n  ?T \\<in> set\\<^sub>v (mat_tensorlist_mult ?A ?Ts ?ds) \\<Longrightarrow>\n  dims ?T = ?ds\n  ?A \\<in> set\\<^sub>v Ts \\<Longrightarrow> dims ?A = ds\n  i < dim_row A\n  dim_vec Ts = dim_col A\n  mat_tensorlist_mult ?A ?Ts ?ds =\n  Matrix.vec (dim_row ?A)\n   (\\<lambda>j.\n       tensor_from_lookup ?ds\n        (\\<lambda>is.\n            (?A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) ?Ts) $ j))\n  (\\<And>A.\n      A \\<in> set ?As \\<Longrightarrow> dims A = ?ds) \\<Longrightarrow>\n  dims (listsum ?ds ?As) = ?ds\n\ngoal (1 subgoal):\n 1. dims (mat_tensorlist_mult A Ts ds $ i) =\n    dims\n     (listsum ds\n       (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))", "by (metis (no_types, lifting) dim_vec vec_setI)"], ["proof (state)\nthis:\n  dims (mat_tensorlist_mult A Ts ds $ i) =\n  dims\n   (listsum ds\n     (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (mat_tensorlist_mult A Ts ds $ i) \\<Longrightarrow>\n       lookup (mat_tensorlist_mult A Ts ds $ i) is =\n       lookup\n        (listsum ds\n          (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n        is", "fix \"is\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (mat_tensorlist_mult A Ts ds $ i) \\<Longrightarrow>\n       lookup (mat_tensorlist_mult A Ts ds $ i) is =\n       lookup\n        (listsum ds\n          (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n        is", "assume is_valid:\"is \\<lhd> dims (mat_tensorlist_mult A Ts ds $ i)\""], ["proof (state)\nthis:\n  is \\<lhd> dims (mat_tensorlist_mult A Ts ds $ i)\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (mat_tensorlist_mult A Ts ds $ i) \\<Longrightarrow>\n       lookup (mat_tensorlist_mult A Ts ds $ i) is =\n       lookup\n        (listsum ds\n          (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n        is", "then"], ["proof (chain)\npicking this:\n  is \\<lhd> dims (mat_tensorlist_mult A Ts ds $ i)", "have \"is \\<lhd> ds\""], ["proof (prove)\nusing this:\n  is \\<lhd> dims (mat_tensorlist_mult A Ts ds $ i)\n\ngoal (1 subgoal):\n 1. is \\<lhd> ds", "using dims_eq dims_Ts' listsum_dims"], ["proof (prove)\nusing this:\n  is \\<lhd> dims (mat_tensorlist_mult A Ts ds $ i)\n  dims (mat_tensorlist_mult A Ts ds $ i) =\n  dims\n   (listsum ds\n     (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n  ?T \\<in> set (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j)\n                 [0..<dim_vec Ts]) \\<Longrightarrow>\n  dims ?T = ds\n  (\\<And>A.\n      A \\<in> set ?As \\<Longrightarrow> dims A = ?ds) \\<Longrightarrow>\n  dims (listsum ?ds ?As) = ?ds\n\ngoal (1 subgoal):\n 1. is \\<lhd> ds", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  is \\<lhd> ds\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (mat_tensorlist_mult A Ts ds $ i) \\<Longrightarrow>\n       lookup (mat_tensorlist_mult A Ts ds $ i) is =\n       lookup\n        (listsum ds\n          (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n        is", "have summand_eq: \"\\<And>j. j \\<in> {0 ..< dim_vec Ts} \\<Longrightarrow> row A i $ j * (map_vec (\\<lambda>T. Tensor.lookup T is) Ts) $ j = lookup (A $$ (i, j) \\<cdot> Ts $ j) is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> {0..<dim_vec Ts} \\<Longrightarrow>\n       row A i $ j * map_vec (\\<lambda>T. lookup T is) Ts $ j =\n       lookup (A $$ (i, j) \\<cdot> Ts $ j) is", "using index_vec \\<open>i<dim_row A\\<close> row_def \\<open>dim_vec Ts = dim_col A\\<close>\n     \\<open>is \\<lhd> ds\\<close> assms(1) lookup_smult atLeastLessThan_iff index_map_vec(1) vec_setI"], ["proof (prove)\nusing this:\n  ?i < ?n \\<Longrightarrow> Matrix.vec ?n ?f $ ?i = ?f ?i\n  i < dim_row A\n  row ?A ?i = Matrix.vec (dim_col ?A) (\\<lambda>j. ?A $$ (?i, j))\n  dim_vec Ts = dim_col A\n  is \\<lhd> ds\n  ?A \\<in> set\\<^sub>v Ts \\<Longrightarrow> dims ?A = ds\n  ?is \\<lhd> dims ?A \\<Longrightarrow>\n  lookup (?\\<alpha> \\<cdot> ?A) ?is = ?\\<alpha> * lookup ?A ?is\n  (?i \\<in> {?l..<?u}) = (?l \\<le> ?i \\<and> ?i < ?u)\n  ?i < dim_vec ?v \\<Longrightarrow> map_vec ?f ?v $ ?i = ?f (?v $ ?i)\n  \\<lbrakk>?v $ ?i = ?a; ?i < dim_vec ?v\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> set\\<^sub>v ?v\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> {0..<dim_vec Ts} \\<Longrightarrow>\n       row A i $ j * map_vec (\\<lambda>T. lookup T is) Ts $ j =\n       lookup (A $$ (i, j) \\<cdot> Ts $ j) is", "by metis"], ["proof (state)\nthis:\n  ?j \\<in> {0..<dim_vec Ts} \\<Longrightarrow>\n  row A i $ ?j * map_vec (\\<lambda>T. lookup T is) Ts $ ?j =\n  lookup (A $$ (i, ?j) \\<cdot> Ts $ ?j) is\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (mat_tensorlist_mult A Ts ds $ i) \\<Longrightarrow>\n       lookup (mat_tensorlist_mult A Ts ds $ i) is =\n       lookup\n        (listsum ds\n          (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n        is", "have \"lookup (mat_tensorlist_mult A Ts ds $ i) is = (A *\\<^sub>v (map_vec (\\<lambda>T. Tensor.lookup T is) Ts)) $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (mat_tensorlist_mult A Ts ds $ i) is =\n    (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) Ts) $ i", "unfolding mat_tensorlist_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup\n     (Matrix.vec (dim_row A)\n       (\\<lambda>j.\n           tensor_from_lookup ds\n            (\\<lambda>is.\n                (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) Ts) $ j)) $\n      i)\n     is =\n    (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) Ts) $ i", "using lookup_tensor_from_lookup[OF \\<open>is \\<lhd> ds\\<close>]"], ["proof (prove)\nusing this:\n  lookup (tensor_from_lookup ds ?e) is = ?e is\n\ngoal (1 subgoal):\n 1. lookup\n     (Matrix.vec (dim_row A)\n       (\\<lambda>j.\n           tensor_from_lookup ds\n            (\\<lambda>is.\n                (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) Ts) $ j)) $\n      i)\n     is =\n    (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) Ts) $ i", "using \\<open>i<dim_row A\\<close>"], ["proof (prove)\nusing this:\n  lookup (tensor_from_lookup ds ?e) is = ?e is\n  i < dim_row A\n\ngoal (1 subgoal):\n 1. lookup\n     (Matrix.vec (dim_row A)\n       (\\<lambda>j.\n           tensor_from_lookup ds\n            (\\<lambda>is.\n                (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) Ts) $ j)) $\n      i)\n     is =\n    (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) Ts) $ i", "by auto"], ["proof (state)\nthis:\n  lookup (mat_tensorlist_mult A Ts ds $ i) is =\n  (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) Ts) $ i\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (mat_tensorlist_mult A Ts ds $ i) \\<Longrightarrow>\n       lookup (mat_tensorlist_mult A Ts ds $ i) is =\n       lookup\n        (listsum ds\n          (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n        is", "also"], ["proof (state)\nthis:\n  lookup (mat_tensorlist_mult A Ts ds $ i) is =\n  (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) Ts) $ i\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (mat_tensorlist_mult A Ts ds $ i) \\<Longrightarrow>\n       lookup (mat_tensorlist_mult A Ts ds $ i) is =\n       lookup\n        (listsum ds\n          (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n        is", "have \"... = row A i \\<bullet> map_vec (\\<lambda>T. Tensor.lookup T is) Ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) Ts) $ i =\n    row A i \\<bullet> map_vec (\\<lambda>T. lookup T is) Ts", "using \\<open>i<dim_row A\\<close>"], ["proof (prove)\nusing this:\n  i < dim_row A\n\ngoal (1 subgoal):\n 1. (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) Ts) $ i =\n    row A i \\<bullet> map_vec (\\<lambda>T. lookup T is) Ts", "by simp"], ["proof (state)\nthis:\n  (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) Ts) $ i =\n  row A i \\<bullet> map_vec (\\<lambda>T. lookup T is) Ts\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (mat_tensorlist_mult A Ts ds $ i) \\<Longrightarrow>\n       lookup (mat_tensorlist_mult A Ts ds $ i) is =\n       lookup\n        (listsum ds\n          (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n        is", "also"], ["proof (state)\nthis:\n  (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) Ts) $ i =\n  row A i \\<bullet> map_vec (\\<lambda>T. lookup T is) Ts\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (mat_tensorlist_mult A Ts ds $ i) \\<Longrightarrow>\n       lookup (mat_tensorlist_mult A Ts ds $ i) is =\n       lookup\n        (listsum ds\n          (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n        is", "have \"... = (\\<Sum> j \\<in> {0 ..< dim_vec Ts}. row A i $ j * (map_vec (\\<lambda>T. Tensor.lookup T is) Ts) $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row A i \\<bullet> map_vec (\\<lambda>T. lookup T is) Ts =\n    (\\<Sum>j = 0..<dim_vec Ts.\n        row A i $ j * map_vec (\\<lambda>T. lookup T is) Ts $ j)", "unfolding scalar_prod_def nth_rows[OF \\<open>i<dim_row A\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia = 0..<dim_vec (map_vec (\\<lambda>T. lookup T is) Ts).\n        row A i $ ia * map_vec (\\<lambda>T. lookup T is) Ts $ ia) =\n    (\\<Sum>j = 0..<dim_vec Ts.\n        row A i $ j * map_vec (\\<lambda>T. lookup T is) Ts $ j)", "by simp"], ["proof (state)\nthis:\n  row A i \\<bullet> map_vec (\\<lambda>T. lookup T is) Ts =\n  (\\<Sum>j = 0..<dim_vec Ts.\n      row A i $ j * map_vec (\\<lambda>T. lookup T is) Ts $ j)\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (mat_tensorlist_mult A Ts ds $ i) \\<Longrightarrow>\n       lookup (mat_tensorlist_mult A Ts ds $ i) is =\n       lookup\n        (listsum ds\n          (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n        is", "also"], ["proof (state)\nthis:\n  row A i \\<bullet> map_vec (\\<lambda>T. lookup T is) Ts =\n  (\\<Sum>j = 0..<dim_vec Ts.\n      row A i $ j * map_vec (\\<lambda>T. lookup T is) Ts $ j)\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (mat_tensorlist_mult A Ts ds $ i) \\<Longrightarrow>\n       lookup (mat_tensorlist_mult A Ts ds $ i) is =\n       lookup\n        (listsum ds\n          (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n        is", "have \"... = (\\<Sum>j\\<in>{0..<dim_vec Ts}. lookup (A $$ (i, j) \\<cdot> Ts $ j) is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<dim_vec Ts.\n        row A i $ j * map_vec (\\<lambda>T. lookup T is) Ts $ j) =\n    (\\<Sum>j = 0..<dim_vec Ts. lookup (A $$ (i, j) \\<cdot> Ts $ j) is)", "using summand_eq"], ["proof (prove)\nusing this:\n  ?j \\<in> {0..<dim_vec Ts} \\<Longrightarrow>\n  row A i $ ?j * map_vec (\\<lambda>T. lookup T is) Ts $ ?j =\n  lookup (A $$ (i, ?j) \\<cdot> Ts $ ?j) is\n\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<dim_vec Ts.\n        row A i $ j * map_vec (\\<lambda>T. lookup T is) Ts $ j) =\n    (\\<Sum>j = 0..<dim_vec Ts. lookup (A $$ (i, j) \\<cdot> Ts $ j) is)", "by force"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<dim_vec Ts.\n      row A i $ j * map_vec (\\<lambda>T. lookup T is) Ts $ j) =\n  (\\<Sum>j = 0..<dim_vec Ts. lookup (A $$ (i, j) \\<cdot> Ts $ j) is)\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (mat_tensorlist_mult A Ts ds $ i) \\<Longrightarrow>\n       lookup (mat_tensorlist_mult A Ts ds $ i) is =\n       lookup\n        (listsum ds\n          (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n        is", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<dim_vec Ts.\n      row A i $ j * map_vec (\\<lambda>T. lookup T is) Ts $ j) =\n  (\\<Sum>j = 0..<dim_vec Ts. lookup (A $$ (i, j) \\<cdot> Ts $ j) is)\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (mat_tensorlist_mult A Ts ds $ i) \\<Longrightarrow>\n       lookup (mat_tensorlist_mult A Ts ds $ i) is =\n       lookup\n        (listsum ds\n          (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n        is", "have \"... = (\\<Sum>A\\<leftarrow>?Ts'. lookup A is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<dim_vec Ts. lookup (A $$ (i, j) \\<cdot> Ts $ j) is) =\n    (\\<Sum>A\\<leftarrow>map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j)\n                         [0..<dim_vec Ts]. lookup A is)", "unfolding map_map\n    Groups_List.sum_set_upt_conv_sum_list_nat[symmetric]  atLeastLessThan_upt[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j = 0..<dim_vec Ts. lookup (A $$ (i, j) \\<cdot> Ts $ j) is) =\n    sum ((\\<lambda>A. lookup A is) \\<circ>\n         (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j))\n     {0..<dim_vec Ts}", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<dim_vec Ts. lookup (A $$ (i, j) \\<cdot> Ts $ j) is) =\n  (\\<Sum>A\\<leftarrow>map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j)\n                       [0..<dim_vec Ts]. lookup A is)\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (mat_tensorlist_mult A Ts ds $ i) \\<Longrightarrow>\n       lookup (mat_tensorlist_mult A Ts ds $ i) is =\n       lookup\n        (listsum ds\n          (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n        is", "also"], ["proof (state)\nthis:\n  (\\<Sum>j = 0..<dim_vec Ts. lookup (A $$ (i, j) \\<cdot> Ts $ j) is) =\n  (\\<Sum>A\\<leftarrow>map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j)\n                       [0..<dim_vec Ts]. lookup A is)\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (mat_tensorlist_mult A Ts ds $ i) \\<Longrightarrow>\n       lookup (mat_tensorlist_mult A Ts ds $ i) is =\n       lookup\n        (listsum ds\n          (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n        is", "have \"... = lookup (listsum ds ?Ts') is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>A\\<leftarrow>map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j)\n                         [0..<dim_vec Ts]. lookup A is) =\n    lookup\n     (listsum ds\n       (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n     is", "using lookup_listsum[OF \\<open>is \\<lhd> ds\\<close>] dims_Ts'"], ["proof (prove)\nusing this:\n  (\\<And>A. A \\<in> set ?As \\<Longrightarrow> dims A = ds) \\<Longrightarrow>\n  lookup (listsum ds ?As) is = (\\<Sum>A\\<leftarrow>?As. lookup A is)\n  ?T \\<in> set (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j)\n                 [0..<dim_vec Ts]) \\<Longrightarrow>\n  dims ?T = ds\n\ngoal (1 subgoal):\n 1. (\\<Sum>A\\<leftarrow>map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j)\n                         [0..<dim_vec Ts]. lookup A is) =\n    lookup\n     (listsum ds\n       (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n     is", "by fastforce"], ["proof (state)\nthis:\n  (\\<Sum>A\\<leftarrow>map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j)\n                       [0..<dim_vec Ts]. lookup A is) =\n  lookup\n   (listsum ds\n     (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n   is\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (mat_tensorlist_mult A Ts ds $ i) \\<Longrightarrow>\n       lookup (mat_tensorlist_mult A Ts ds $ i) is =\n       lookup\n        (listsum ds\n          (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n        is", "finally"], ["proof (chain)\npicking this:\n  lookup (mat_tensorlist_mult A Ts ds $ i) is =\n  lookup\n   (listsum ds\n     (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n   is", "show \"lookup (mat_tensorlist_mult A Ts ds $ i) is = lookup (listsum ds ?Ts') is\""], ["proof (prove)\nusing this:\n  lookup (mat_tensorlist_mult A Ts ds $ i) is =\n  lookup\n   (listsum ds\n     (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n   is\n\ngoal (1 subgoal):\n 1. lookup (mat_tensorlist_mult A Ts ds $ i) is =\n    lookup\n     (listsum ds\n       (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n     is", "by metis"], ["proof (state)\nthis:\n  lookup (mat_tensorlist_mult A Ts ds $ i) is =\n  lookup\n   (listsum ds\n     (map (\\<lambda>j. A $$ (i, j) \\<cdot> Ts $ j) [0..<dim_vec Ts]))\n   is\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_tensors_from_net:\nassumes \"valid_net' m\"\nand \"is \\<lhd> input_sizes m\"\nand \"j < output_size' m\"\nshows \"Tensor.lookup (tensors_from_net m $ j) is = evaluate_net m (base_input m is) $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (tensors_from_net m $ j) is =\n    evaluate_net m (base_input m is) $ j", "using assms"], ["proof (prove)\nusing this:\n  valid_net' m\n  is \\<lhd> input_sizes m\n  j < output_size' m\n\ngoal (1 subgoal):\n 1. lookup (tensors_from_net m $ j) is =\n    evaluate_net m (base_input m is) $ j", "proof (induction m arbitrary:j \"is\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x j is.\n       \\<lbrakk>valid_net' (Input x); is \\<lhd> input_sizes (Input x);\n        j < output_size' (Input x)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Input x) $ j) is =\n                         evaluate_net (Input x) (base_input (Input x) is) $\n                         j\n 2. \\<And>x1a m j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m; is \\<lhd> input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m $ j) is =\n                                     evaluate_net m (base_input m is) $ j;\n        valid_net' (Conv x1a m); is \\<lhd> input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Conv x1a m) $ j) is =\n                         evaluate_net (Conv x1a m)\n                          (base_input (Conv x1a m) is) $\n                         j\n 3. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "case (Input M)"], ["proof (state)\nthis:\n  valid_net' (Input M)\n  is \\<lhd> input_sizes (Input M)\n  j < output_size' (Input M)\n\ngoal (3 subgoals):\n 1. \\<And>x j is.\n       \\<lbrakk>valid_net' (Input x); is \\<lhd> input_sizes (Input x);\n        j < output_size' (Input x)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Input x) $ j) is =\n                         evaluate_net (Input x) (base_input (Input x) is) $\n                         j\n 2. \\<And>x1a m j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m; is \\<lhd> input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m $ j) is =\n                                     evaluate_net m (base_input m is) $ j;\n        valid_net' (Conv x1a m); is \\<lhd> input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Conv x1a m) $ j) is =\n                         evaluate_net (Conv x1a m)\n                          (base_input (Conv x1a m) is) $\n                         j\n 3. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "then"], ["proof (chain)\npicking this:\n  valid_net' (Input M)\n  is \\<lhd> input_sizes (Input M)\n  j < output_size' (Input M)", "have \"j < M\""], ["proof (prove)\nusing this:\n  valid_net' (Input M)\n  is \\<lhd> input_sizes (Input M)\n  j < output_size' (Input M)\n\ngoal (1 subgoal):\n 1. j < M", "using output_size.simps(1)"], ["proof (prove)\nusing this:\n  valid_net' (Input M)\n  is \\<lhd> input_sizes (Input M)\n  j < output_size' (Input M)\n  output_size (Input ?M) = ?M\n\ngoal (1 subgoal):\n 1. j < M", "using Input"], ["proof (prove)\nusing this:\n  valid_net' (Input M)\n  is \\<lhd> input_sizes (Input M)\n  j < output_size' (Input M)\n  output_size (Input ?M) = ?M\n  valid_net' (Input M)\n  is \\<lhd> input_sizes (Input M)\n  j < output_size' (Input M)\n\ngoal (1 subgoal):\n 1. j < M", "by auto"], ["proof (state)\nthis:\n  j < M\n\ngoal (3 subgoals):\n 1. \\<And>x j is.\n       \\<lbrakk>valid_net' (Input x); is \\<lhd> input_sizes (Input x);\n        j < output_size' (Input x)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Input x) $ j) is =\n                         evaluate_net (Input x) (base_input (Input x) is) $\n                         j\n 2. \\<And>x1a m j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m; is \\<lhd> input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m $ j) is =\n                                     evaluate_net m (base_input m is) $ j;\n        valid_net' (Conv x1a m); is \\<lhd> input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Conv x1a m) $ j) is =\n                         evaluate_net (Conv x1a m)\n                          (base_input (Conv x1a m) is) $\n                         j\n 3. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "then"], ["proof (chain)\npicking this:\n  j < M", "have 1:\"tensors_from_net (Input M) $ j = unit_vec M j\""], ["proof (prove)\nusing this:\n  j < M\n\ngoal (1 subgoal):\n 1. tensors_from_net (Input M) $ j = unit_vec M j", "by simp"], ["proof (state)\nthis:\n  tensors_from_net (Input M) $ j = unit_vec M j\n\ngoal (3 subgoals):\n 1. \\<And>x j is.\n       \\<lbrakk>valid_net' (Input x); is \\<lhd> input_sizes (Input x);\n        j < output_size' (Input x)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Input x) $ j) is =\n                         evaluate_net (Input x) (base_input (Input x) is) $\n                         j\n 2. \\<And>x1a m j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m; is \\<lhd> input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m $ j) is =\n                                     evaluate_net m (base_input m is) $ j;\n        valid_net' (Conv x1a m); is \\<lhd> input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Conv x1a m) $ j) is =\n                         evaluate_net (Conv x1a m)\n                          (base_input (Conv x1a m) is) $\n                         j\n 3. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "obtain i where \"is = [i]\" \"i<M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>is = [i]; i < M\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Input Suc_length_conv input_sizes.simps(1) length_0_conv list.size(3) valid_index_length"], ["proof (prove)\nusing this:\n  valid_net' (Input M)\n  is \\<lhd> input_sizes (Input M)\n  j < output_size' (Input M)\n  (Suc ?n = length ?xs) =\n  (\\<exists>y ys. ?xs = y # ys \\<and> length ys = ?n)\n  input_sizes (Input ?M) = [?M]\n  (length ?xs = 0) = (?xs = [])\n  length [] = 0\n  ?is \\<lhd> ?ds \\<Longrightarrow> length ?is = length ?ds\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>is = [i]; i < M\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is = [i]\n  i < M\n\ngoal (3 subgoals):\n 1. \\<And>x j is.\n       \\<lbrakk>valid_net' (Input x); is \\<lhd> input_sizes (Input x);\n        j < output_size' (Input x)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Input x) $ j) is =\n                         evaluate_net (Input x) (base_input (Input x) is) $\n                         j\n 2. \\<And>x1a m j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m; is \\<lhd> input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m $ j) is =\n                                     evaluate_net m (base_input m is) $ j;\n        valid_net' (Conv x1a m); is \\<lhd> input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Conv x1a m) $ j) is =\n                         evaluate_net (Conv x1a m)\n                          (base_input (Conv x1a m) is) $\n                         j\n 3. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "then"], ["proof (chain)\npicking this:\n  is = [i]\n  i < M", "have 2:\"Tensor.lookup (tensors_from_net (Input M) $ j) is = (if i=j then 1 else 0)\""], ["proof (prove)\nusing this:\n  is = [i]\n  i < M\n\ngoal (1 subgoal):\n 1. lookup (tensors_from_net (Input M) $ j) is = (if i = j then 1 else 0)", "using lookup_unit_vec 1"], ["proof (prove)\nusing this:\n  is = [i]\n  i < M\n  ?j < ?n \\<Longrightarrow>\n  lookup (unit_vec ?n ?i) [?j] = (if ?i = ?j then 1::?'a else (0::?'a))\n  tensors_from_net (Input M) $ j = unit_vec M j\n\ngoal (1 subgoal):\n 1. lookup (tensors_from_net (Input M) $ j) is = (if i = j then 1 else 0)", "by metis"], ["proof (state)\nthis:\n  lookup (tensors_from_net (Input M) $ j) is = (if i = j then 1 else 0)\n\ngoal (3 subgoals):\n 1. \\<And>x j is.\n       \\<lbrakk>valid_net' (Input x); is \\<lhd> input_sizes (Input x);\n        j < output_size' (Input x)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Input x) $ j) is =\n                         evaluate_net (Input x) (base_input (Input x) is) $\n                         j\n 2. \\<And>x1a m j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m; is \\<lhd> input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m $ j) is =\n                                     evaluate_net m (base_input m is) $ j;\n        valid_net' (Conv x1a m); is \\<lhd> input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Conv x1a m) $ j) is =\n                         evaluate_net (Conv x1a m)\n                          (base_input (Conv x1a m) is) $\n                         j\n 3. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "have \"evaluate_net (Input M) (map (\\<lambda>(n, i). unit\\<^sub>v n i) (zip (input_sizes (Input M)) is)) = unit\\<^sub>v M i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_net (Input M) (map2 unit\\<^sub>v (input_sizes (Input M)) is) =\n    unit\\<^sub>v M i", "using \\<open>is = [i]\\<close>"], ["proof (prove)\nusing this:\n  is = [i]\n\ngoal (1 subgoal):\n 1. evaluate_net (Input M) (map2 unit\\<^sub>v (input_sizes (Input M)) is) =\n    unit\\<^sub>v M i", "by auto"], ["proof (state)\nthis:\n  evaluate_net (Input M) (map2 unit\\<^sub>v (input_sizes (Input M)) is) =\n  unit\\<^sub>v M i\n\ngoal (3 subgoals):\n 1. \\<And>x j is.\n       \\<lbrakk>valid_net' (Input x); is \\<lhd> input_sizes (Input x);\n        j < output_size' (Input x)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Input x) $ j) is =\n                         evaluate_net (Input x) (base_input (Input x) is) $\n                         j\n 2. \\<And>x1a m j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m; is \\<lhd> input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m $ j) is =\n                                     evaluate_net m (base_input m is) $ j;\n        valid_net' (Conv x1a m); is \\<lhd> input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Conv x1a m) $ j) is =\n                         evaluate_net (Conv x1a m)\n                          (base_input (Conv x1a m) is) $\n                         j\n 3. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "then"], ["proof (chain)\npicking this:\n  evaluate_net (Input M) (map2 unit\\<^sub>v (input_sizes (Input M)) is) =\n  unit\\<^sub>v M i", "show ?case"], ["proof (prove)\nusing this:\n  evaluate_net (Input M) (map2 unit\\<^sub>v (input_sizes (Input M)) is) =\n  unit\\<^sub>v M i\n\ngoal (1 subgoal):\n 1. lookup (tensors_from_net (Input M) $ j) is =\n    evaluate_net (Input M) (base_input (Input M) is) $ j", "using 2 \\<open>j < M\\<close> base_input_def"], ["proof (prove)\nusing this:\n  evaluate_net (Input M) (map2 unit\\<^sub>v (input_sizes (Input M)) is) =\n  unit\\<^sub>v M i\n  lookup (tensors_from_net (Input M) $ j) is = (if i = j then 1 else 0)\n  j < M\n  base_input ?m ?is = map2 unit\\<^sub>v (input_sizes ?m) ?is\n\ngoal (1 subgoal):\n 1. lookup (tensors_from_net (Input M) $ j) is =\n    evaluate_net (Input M) (base_input (Input M) is) $ j", "by (simp add: \\<open>i < M\\<close>)"], ["proof (state)\nthis:\n  lookup (tensors_from_net (Input M) $ j) is =\n  evaluate_net (Input M) (base_input (Input M) is) $ j\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m; is \\<lhd> input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m $ j) is =\n                                     evaluate_net m (base_input m is) $ j;\n        valid_net' (Conv x1a m); is \\<lhd> input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Conv x1a m) $ j) is =\n                         evaluate_net (Conv x1a m)\n                          (base_input (Conv x1a m) is) $\n                         j\n 2. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1a m j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m; is \\<lhd> input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m $ j) is =\n                                     evaluate_net m (base_input m is) $ j;\n        valid_net' (Conv x1a m); is \\<lhd> input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Conv x1a m) $ j) is =\n                         evaluate_net (Conv x1a m)\n                          (base_input (Conv x1a m) is) $\n                         j\n 2. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "case (Conv A m j \"is\")"], ["proof (state)\nthis:\n  \\<lbrakk>valid_net' m; ?is \\<lhd> input_sizes m;\n   ?j < output_size' m\\<rbrakk>\n  \\<Longrightarrow> lookup (tensors_from_net m $ ?j) ?is =\n                    evaluate_net m (base_input m ?is) $ ?j\n  valid_net' (Conv A m)\n  is \\<lhd> input_sizes (Conv A m)\n  j < output_size' (Conv A m)\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m; is \\<lhd> input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m $ j) is =\n                                     evaluate_net m (base_input m is) $ j;\n        valid_net' (Conv x1a m); is \\<lhd> input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Conv x1a m) $ j) is =\n                         evaluate_net (Conv x1a m)\n                          (base_input (Conv x1a m) is) $\n                         j\n 2. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "have is_valid:\"is \\<lhd> input_sizes m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is \\<lhd> input_sizes m", "using Conv.prems"], ["proof (prove)\nusing this:\n  valid_net' (Conv A m)\n  is \\<lhd> input_sizes (Conv A m)\n  j < output_size' (Conv A m)\n\ngoal (1 subgoal):\n 1. is \\<lhd> input_sizes m", "by simp"], ["proof (state)\nthis:\n  is \\<lhd> input_sizes m\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m; is \\<lhd> input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m $ j) is =\n                                     evaluate_net m (base_input m is) $ j;\n        valid_net' (Conv x1a m); is \\<lhd> input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Conv x1a m) $ j) is =\n                         evaluate_net (Conv x1a m)\n                          (base_input (Conv x1a m) is) $\n                         j\n 2. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "have valid_net:\"valid_net' m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_net' m", "using Conv.prems(1)"], ["proof (prove)\nusing this:\n  valid_net' (Conv A m)\n\ngoal (1 subgoal):\n 1. valid_net' m", "unfolding remove_weights.simps"], ["proof (prove)\nusing this:\n  valid_net (Conv (dim_row A, dim_col A) (remove_weights m))\n\ngoal (1 subgoal):\n 1. valid_net' m", "using valid_net.simps convnet.distinct(1) convnet.distinct(5) convnet.inject(2)"], ["proof (prove)\nusing this:\n  valid_net (Conv (dim_row A, dim_col A) (remove_weights m))\n  valid_net ?a =\n  ((\\<exists>M. ?a = Input M) \\<or>\n   (\\<exists>m r1 r0.\n       ?a = Conv (r0, r1) m \\<and>\n       output_size m = r1 \\<and> valid_net m) \\<or>\n   (\\<exists>m1 m2.\n       ?a = Pool m1 m2 \\<and>\n       output_size m1 = output_size m2 \\<and>\n       valid_net m1 \\<and> valid_net m2))\n  Input ?x1.0 \\<noteq> Conv ?x21.0 ?x22.0\n  Conv ?x21.0 ?x22.0 \\<noteq> Pool ?x31.0 ?x32.0\n  (Conv ?x21.0 ?x22.0 = Conv ?y21.0 ?y22.0) =\n  (?x21.0 = ?y21.0 \\<and> ?x22.0 = ?y22.0)\n\ngoal (1 subgoal):\n 1. valid_net' m", "by blast"], ["proof (state)\nthis:\n  valid_net' m\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m; is \\<lhd> input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m $ j) is =\n                                     evaluate_net m (base_input m is) $ j;\n        valid_net' (Conv x1a m); is \\<lhd> input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Conv x1a m) $ j) is =\n                         evaluate_net (Conv x1a m)\n                          (base_input (Conv x1a m) is) $\n                         j\n 2. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "then"], ["proof (chain)\npicking this:\n  valid_net' m", "have length_em: \"dim_vec (evaluate_net m (base_input m is)) = output_size' m\""], ["proof (prove)\nusing this:\n  valid_net' m\n\ngoal (1 subgoal):\n 1. dim_vec (evaluate_net m (base_input m is)) = output_size' m", "using output_size_correct base_input_length is_valid"], ["proof (prove)\nusing this:\n  valid_net' m\n  \\<lbrakk>valid_net' ?m; map dim_vec ?inputs = input_sizes ?m\\<rbrakk>\n  \\<Longrightarrow> output_size' ?m = dim_vec (evaluate_net ?m ?inputs)\n  ?is \\<lhd> input_sizes ?m \\<Longrightarrow>\n  input_sizes ?m = map dim_vec (base_input ?m ?is)\n  is \\<lhd> input_sizes m\n\ngoal (1 subgoal):\n 1. dim_vec (evaluate_net m (base_input m is)) = output_size' m", "by metis"], ["proof (state)\nthis:\n  dim_vec (evaluate_net m (base_input m is)) = output_size' m\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m; is \\<lhd> input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m $ j) is =\n                                     evaluate_net m (base_input m is) $ j;\n        valid_net' (Conv x1a m); is \\<lhd> input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Conv x1a m) $ j) is =\n                         evaluate_net (Conv x1a m)\n                          (base_input (Conv x1a m) is) $\n                         j\n 2. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "have IH':\"map_vec (\\<lambda>T. Tensor.lookup T is) (tensors_from_net m) =\n                evaluate_net m (base_input m is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_vec (\\<lambda>T. lookup T is) (tensors_from_net m) =\n    evaluate_net m (base_input m is)", "proof (rule eq_vecI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < dim_vec (evaluate_net m (base_input m is)) \\<Longrightarrow>\n       map_vec (\\<lambda>T. lookup T is) (tensors_from_net m) $ i =\n       evaluate_net m (base_input m is) $ i\n 2. dim_vec (map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) =\n    dim_vec (evaluate_net m (base_input m is))", "show equal_lengths: \"dim_vec (map_vec (\\<lambda>T. lookup T is) (tensors_from_net m))\n      = dim_vec (evaluate_net m (base_input m is))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) =\n    dim_vec (evaluate_net m (base_input m is))", "using length_em"], ["proof (prove)\nusing this:\n  dim_vec (evaluate_net m (base_input m is)) = output_size' m\n\ngoal (1 subgoal):\n 1. dim_vec (map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) =\n    dim_vec (evaluate_net m (base_input m is))", "by (simp add: output_size_correct_tensors valid_net)"], ["proof (state)\nthis:\n  dim_vec (map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) =\n  dim_vec (evaluate_net m (base_input m is))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec (evaluate_net m (base_input m is)) \\<Longrightarrow>\n       map_vec (\\<lambda>T. lookup T is) (tensors_from_net m) $ i =\n       evaluate_net m (base_input m is) $ i", "show \"\\<And>i. i < dim_vec (evaluate_net m (base_input m is)) \\<Longrightarrow>\n         map_vec (\\<lambda>T. lookup T is) (tensors_from_net m) $ i = evaluate_net m (base_input m is) $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec (evaluate_net m (base_input m is)) \\<Longrightarrow>\n       map_vec (\\<lambda>T. lookup T is) (tensors_from_net m) $ i =\n       evaluate_net m (base_input m is) $ i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec (evaluate_net m (base_input m is)) \\<Longrightarrow>\n       map_vec (\\<lambda>T. lookup T is) (tensors_from_net m) $ i =\n       evaluate_net m (base_input m is) $ i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec (evaluate_net m (base_input m is)) \\<Longrightarrow>\n       map_vec (\\<lambda>T. lookup T is) (tensors_from_net m) $ i =\n       evaluate_net m (base_input m is) $ i", "assume \"i < dim_vec (evaluate_net m (base_input m is))\""], ["proof (state)\nthis:\n  i < dim_vec (evaluate_net m (base_input m is))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec (evaluate_net m (base_input m is)) \\<Longrightarrow>\n       map_vec (\\<lambda>T. lookup T is) (tensors_from_net m) $ i =\n       evaluate_net m (base_input m is) $ i", "then"], ["proof (chain)\npicking this:\n  i < dim_vec (evaluate_net m (base_input m is))", "have \"i < output_size' m\""], ["proof (prove)\nusing this:\n  i < dim_vec (evaluate_net m (base_input m is))\n\ngoal (1 subgoal):\n 1. i < output_size' m", "using equal_lengths length_em"], ["proof (prove)\nusing this:\n  i < dim_vec (evaluate_net m (base_input m is))\n  dim_vec (map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) =\n  dim_vec (evaluate_net m (base_input m is))\n  dim_vec (evaluate_net m (base_input m is)) = output_size' m\n\ngoal (1 subgoal):\n 1. i < output_size' m", "by auto"], ["proof (state)\nthis:\n  i < output_size' m\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec (evaluate_net m (base_input m is)) \\<Longrightarrow>\n       map_vec (\\<lambda>T. lookup T is) (tensors_from_net m) $ i =\n       evaluate_net m (base_input m is) $ i", "then"], ["proof (chain)\npicking this:\n  i < output_size' m", "show \"map_vec (\\<lambda>T. lookup T is) (tensors_from_net m) $ i\n        = evaluate_net m (base_input m is) $ i\""], ["proof (prove)\nusing this:\n  i < output_size' m\n\ngoal (1 subgoal):\n 1. map_vec (\\<lambda>T. lookup T is) (tensors_from_net m) $ i =\n    evaluate_net m (base_input m is) $ i", "using Conv.IH is_valid equal_lengths valid_net base_input_def length_em nth_map_upt\n        length_map nth_map"], ["proof (prove)\nusing this:\n  i < output_size' m\n  \\<lbrakk>valid_net' m; ?is \\<lhd> input_sizes m;\n   ?j < output_size' m\\<rbrakk>\n  \\<Longrightarrow> lookup (tensors_from_net m $ ?j) ?is =\n                    evaluate_net m (base_input m ?is) $ ?j\n  is \\<lhd> input_sizes m\n  dim_vec (map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) =\n  dim_vec (evaluate_net m (base_input m is))\n  valid_net' m\n  base_input ?m ?is = map2 unit\\<^sub>v (input_sizes ?m) ?is\n  dim_vec (evaluate_net m (base_input m is)) = output_size' m\n  ?i < ?n - ?m \\<Longrightarrow> map ?f [?m..<?n] ! ?i = ?f (?m + ?i)\n  length (map ?f ?xs) = length ?xs\n  ?n < length ?xs \\<Longrightarrow> map ?f ?xs ! ?n = ?f (?xs ! ?n)\n\ngoal (1 subgoal):\n 1. map_vec (\\<lambda>T. lookup T is) (tensors_from_net m) $ i =\n    evaluate_net m (base_input m is) $ i", "by auto"], ["proof (state)\nthis:\n  map_vec (\\<lambda>T. lookup T is) (tensors_from_net m) $ i =\n  evaluate_net m (base_input m is) $ i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < dim_vec (evaluate_net m (base_input m is)) \\<Longrightarrow>\n  map_vec (\\<lambda>T. lookup T is) (tensors_from_net m) $ ?i =\n  evaluate_net m (base_input m is) $ ?i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_vec (\\<lambda>T. lookup T is) (tensors_from_net m) =\n  evaluate_net m (base_input m is)\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m; is \\<lhd> input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m $ j) is =\n                                     evaluate_net m (base_input m is) $ j;\n        valid_net' (Conv x1a m); is \\<lhd> input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Conv x1a m) $ j) is =\n                         evaluate_net (Conv x1a m)\n                          (base_input (Conv x1a m) is) $\n                         j\n 2. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "have \"Tensor.lookup ((tensors_from_net (Conv A m)) $ j) is =\n    (A *\\<^sub>v (map_vec (\\<lambda>T. Tensor.lookup T is) (tensors_from_net m))) $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (tensors_from_net (Conv A m) $ j) is =\n    (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) $ j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (tensors_from_net (Conv A m) $ j) is =\n    (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) $ j", "have \"dim_vec (tensors_from_net (Conv A m)) = output_size' (Conv A m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dim_vec (tensors_from_net (Conv A m)) = output_size' (Conv A m)", "using Conv"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_net' m; ?is \\<lhd> input_sizes m;\n   ?j < output_size' m\\<rbrakk>\n  \\<Longrightarrow> lookup (tensors_from_net m $ ?j) ?is =\n                    evaluate_net m (base_input m ?is) $ ?j\n  valid_net' (Conv A m)\n  is \\<lhd> input_sizes (Conv A m)\n  j < output_size' (Conv A m)\n\ngoal (1 subgoal):\n 1. dim_vec (tensors_from_net (Conv A m)) = output_size' (Conv A m)", "by (simp add: mat_tensorlist_mult_def)"], ["proof (state)\nthis:\n  dim_vec (tensors_from_net (Conv A m)) = output_size' (Conv A m)\n\ngoal (1 subgoal):\n 1. lookup (tensors_from_net (Conv A m) $ j) is =\n    (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) $ j", "then"], ["proof (chain)\npicking this:\n  dim_vec (tensors_from_net (Conv A m)) = output_size' (Conv A m)", "have \"j<dim_vec (tensors_from_net (Conv A m))\""], ["proof (prove)\nusing this:\n  dim_vec (tensors_from_net (Conv A m)) = output_size' (Conv A m)\n\ngoal (1 subgoal):\n 1. j < dim_vec (tensors_from_net (Conv A m))", "using Conv.prems"], ["proof (prove)\nusing this:\n  dim_vec (tensors_from_net (Conv A m)) = output_size' (Conv A m)\n  valid_net' (Conv A m)\n  is \\<lhd> input_sizes (Conv A m)\n  j < output_size' (Conv A m)\n\ngoal (1 subgoal):\n 1. j < dim_vec (tensors_from_net (Conv A m))", "by auto"], ["proof (state)\nthis:\n  j < dim_vec (tensors_from_net (Conv A m))\n\ngoal (1 subgoal):\n 1. lookup (tensors_from_net (Conv A m) $ j) is =\n    (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) $ j", "then"], ["proof (chain)\npicking this:\n  j < dim_vec (tensors_from_net (Conv A m))", "have \"(tensors_from_net (Conv A m)) $ j =  tensor_from_lookup (input_sizes m)\n                (\\<lambda>is. (A *\\<^sub>v (map_vec (\\<lambda>T. Tensor.lookup T is) (tensors_from_net m))) $ j)\""], ["proof (prove)\nusing this:\n  j < dim_vec (tensors_from_net (Conv A m))\n\ngoal (1 subgoal):\n 1. tensors_from_net (Conv A m) $ j =\n    tensor_from_lookup (input_sizes m)\n     (\\<lambda>is.\n         (A *\\<^sub>v\n          map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) $\n         j)", "unfolding tensors_from_net.simps mat_tensorlist_mult_def"], ["proof (prove)\nusing this:\n  j < dim_vec\n       (Matrix.vec (dim_row A)\n         (\\<lambda>j.\n             tensor_from_lookup (input_sizes m)\n              (\\<lambda>is.\n                  (A *\\<^sub>v\n                   map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) $\n                  j)))\n\ngoal (1 subgoal):\n 1. Matrix.vec (dim_row A)\n     (\\<lambda>j.\n         tensor_from_lookup (input_sizes m)\n          (\\<lambda>is.\n              (A *\\<^sub>v\n               map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) $\n              j)) $\n    j =\n    tensor_from_lookup (input_sizes m)\n     (\\<lambda>is.\n         (A *\\<^sub>v\n          map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) $\n         j)", "by fastforce"], ["proof (state)\nthis:\n  tensors_from_net (Conv A m) $ j =\n  tensor_from_lookup (input_sizes m)\n   (\\<lambda>is.\n       (A *\\<^sub>v\n        map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) $\n       j)\n\ngoal (1 subgoal):\n 1. lookup (tensors_from_net (Conv A m) $ j) is =\n    (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) $ j", "then"], ["proof (chain)\npicking this:\n  tensors_from_net (Conv A m) $ j =\n  tensor_from_lookup (input_sizes m)\n   (\\<lambda>is.\n       (A *\\<^sub>v\n        map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) $\n       j)", "show ?thesis"], ["proof (prove)\nusing this:\n  tensors_from_net (Conv A m) $ j =\n  tensor_from_lookup (input_sizes m)\n   (\\<lambda>is.\n       (A *\\<^sub>v\n        map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) $\n       j)\n\ngoal (1 subgoal):\n 1. lookup (tensors_from_net (Conv A m) $ j) is =\n    (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) $ j", "using lookup_tensor_from_lookup[OF is_valid]"], ["proof (prove)\nusing this:\n  tensors_from_net (Conv A m) $ j =\n  tensor_from_lookup (input_sizes m)\n   (\\<lambda>is.\n       (A *\\<^sub>v\n        map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) $\n       j)\n  lookup (tensor_from_lookup (input_sizes m) ?e) is = ?e is\n\ngoal (1 subgoal):\n 1. lookup (tensors_from_net (Conv A m) $ j) is =\n    (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) $ j", "by auto"], ["proof (state)\nthis:\n  lookup (tensors_from_net (Conv A m) $ j) is =\n  (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) $ j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup (tensors_from_net (Conv A m) $ j) is =\n  (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) $ j\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m; is \\<lhd> input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m $ j) is =\n                                     evaluate_net m (base_input m is) $ j;\n        valid_net' (Conv x1a m); is \\<lhd> input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Conv x1a m) $ j) is =\n                         evaluate_net (Conv x1a m)\n                          (base_input (Conv x1a m) is) $\n                         j\n 2. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "also"], ["proof (state)\nthis:\n  lookup (tensors_from_net (Conv A m) $ j) is =\n  (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) $ j\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m; is \\<lhd> input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m $ j) is =\n                                     evaluate_net m (base_input m is) $ j;\n        valid_net' (Conv x1a m); is \\<lhd> input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Conv x1a m) $ j) is =\n                         evaluate_net (Conv x1a m)\n                          (base_input (Conv x1a m) is) $\n                         j\n 2. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "have \"(A *\\<^sub>v (map_vec (\\<lambda>T. Tensor.lookup T is) (tensors_from_net m))) $ j\n    = (A *\\<^sub>v (evaluate_net m (base_input m is))) $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) $\n    j =\n    (A *\\<^sub>v evaluate_net m (base_input m is)) $ j", "using IH'"], ["proof (prove)\nusing this:\n  map_vec (\\<lambda>T. lookup T is) (tensors_from_net m) =\n  evaluate_net m (base_input m is)\n\ngoal (1 subgoal):\n 1. (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) $\n    j =\n    (A *\\<^sub>v evaluate_net m (base_input m is)) $ j", "by auto"], ["proof (state)\nthis:\n  (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) $ j =\n  (A *\\<^sub>v evaluate_net m (base_input m is)) $ j\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m; is \\<lhd> input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m $ j) is =\n                                     evaluate_net m (base_input m is) $ j;\n        valid_net' (Conv x1a m); is \\<lhd> input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Conv x1a m) $ j) is =\n                         evaluate_net (Conv x1a m)\n                          (base_input (Conv x1a m) is) $\n                         j\n 2. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "also"], ["proof (state)\nthis:\n  (A *\\<^sub>v map_vec (\\<lambda>T. lookup T is) (tensors_from_net m)) $ j =\n  (A *\\<^sub>v evaluate_net m (base_input m is)) $ j\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m; is \\<lhd> input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m $ j) is =\n                                     evaluate_net m (base_input m is) $ j;\n        valid_net' (Conv x1a m); is \\<lhd> input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Conv x1a m) $ j) is =\n                         evaluate_net (Conv x1a m)\n                          (base_input (Conv x1a m) is) $\n                         j\n 2. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "have \"... = evaluate_net (Conv A m) (base_input (Conv A m) is) $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A *\\<^sub>v evaluate_net m (base_input m is)) $ j =\n    evaluate_net (Conv A m) (base_input (Conv A m) is) $ j", "unfolding base_input_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A *\\<^sub>v evaluate_net m (map2 unit\\<^sub>v (input_sizes m) is)) $\n    j =\n    evaluate_net (Conv A m)\n     (map2 unit\\<^sub>v (input_sizes (Conv A m)) is) $\n    j", "using evaluate_net.simps"], ["proof (prove)\nusing this:\n  evaluate_net (Input ?M) ?inputs = hd ?inputs\n  evaluate_net (Conv ?A ?m) ?inputs = ?A *\\<^sub>v evaluate_net ?m ?inputs\n  evaluate_net (Pool ?m1.0 ?m2.0) ?inputs =\n  component_mult\n   (evaluate_net ?m1.0 (take (length (input_sizes ?m1.0)) ?inputs))\n   (evaluate_net ?m2.0 (drop (length (input_sizes ?m1.0)) ?inputs))\n\ngoal (1 subgoal):\n 1. (A *\\<^sub>v evaluate_net m (map2 unit\\<^sub>v (input_sizes m) is)) $\n    j =\n    evaluate_net (Conv A m)\n     (map2 unit\\<^sub>v (input_sizes (Conv A m)) is) $\n    j", "by auto"], ["proof (state)\nthis:\n  (A *\\<^sub>v evaluate_net m (base_input m is)) $ j =\n  evaluate_net (Conv A m) (base_input (Conv A m) is) $ j\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m; is \\<lhd> input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m $ j) is =\n                                     evaluate_net m (base_input m is) $ j;\n        valid_net' (Conv x1a m); is \\<lhd> input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Conv x1a m) $ j) is =\n                         evaluate_net (Conv x1a m)\n                          (base_input (Conv x1a m) is) $\n                         j\n 2. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "finally"], ["proof (chain)\npicking this:\n  lookup (tensors_from_net (Conv A m) $ j) is =\n  evaluate_net (Conv A m) (base_input (Conv A m) is) $ j", "show ?case"], ["proof (prove)\nusing this:\n  lookup (tensors_from_net (Conv A m) $ j) is =\n  evaluate_net (Conv A m) (base_input (Conv A m) is) $ j\n\ngoal (1 subgoal):\n 1. lookup (tensors_from_net (Conv A m) $ j) is =\n    evaluate_net (Conv A m) (base_input (Conv A m) is) $ j", "by auto"], ["proof (state)\nthis:\n  lookup (tensors_from_net (Conv A m) $ j) is =\n  evaluate_net (Conv A m) (base_input (Conv A m) is) $ j\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "case (Pool m1 m2 j \"is\")"], ["proof (state)\nthis:\n  \\<lbrakk>valid_net' m1; ?is \\<lhd> input_sizes m1;\n   ?j < output_size' m1\\<rbrakk>\n  \\<Longrightarrow> lookup (tensors_from_net m1 $ ?j) ?is =\n                    evaluate_net m1 (base_input m1 ?is) $ ?j\n  \\<lbrakk>valid_net' m2; ?is \\<lhd> input_sizes m2;\n   ?j < output_size' m2\\<rbrakk>\n  \\<Longrightarrow> lookup (tensors_from_net m2 $ ?j) ?is =\n                    evaluate_net m2 (base_input m2 ?is) $ ?j\n  valid_net' (Pool m1 m2)\n  is \\<lhd> input_sizes (Pool m1 m2)\n  j < output_size' (Pool m1 m2)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "text \\<open>We split \"is\" into two parts for each subnet:\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>valid_net' m1; ?is \\<lhd> input_sizes m1;\n   ?j < output_size' m1\\<rbrakk>\n  \\<Longrightarrow> lookup (tensors_from_net m1 $ ?j) ?is =\n                    evaluate_net m1 (base_input m1 ?is) $ ?j\n  \\<lbrakk>valid_net' m2; ?is \\<lhd> input_sizes m2;\n   ?j < output_size' m2\\<rbrakk>\n  \\<Longrightarrow> lookup (tensors_from_net m2 $ ?j) ?is =\n                    evaluate_net m2 (base_input m2 ?is) $ ?j\n  valid_net' (Pool m1 m2)\n  is \\<lhd> input_sizes (Pool m1 m2)\n  j < output_size' (Pool m1 m2)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "obtain is1 is2 where is12_def:\"is = is1 @ is2\" \"is1 \\<lhd> input_sizes m1\" \"is2 \\<lhd> input_sizes m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>is1 is2.\n        \\<lbrakk>is = is1 @ is2; is1 \\<lhd> input_sizes m1;\n         is2 \\<lhd> input_sizes m2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Pool.prems(2) input_sizes.simps(3) valid_index_split)"], ["proof (state)\nthis:\n  is = is1 @ is2\n  is1 \\<lhd> input_sizes m1\n  is2 \\<lhd> input_sizes m2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "text \\<open>Apply the induction hypothesis to the subnets:\\<close>"], ["proof (state)\nthis:\n  is = is1 @ is2\n  is1 \\<lhd> input_sizes m1\n  is2 \\<lhd> input_sizes m2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "have IH:\"Tensor.lookup (tensors_from_net m1 $ j) is1\n      = evaluate_net m1 (map (\\<lambda>(x, y). unit\\<^sub>v x y) (zip (input_sizes m1) is1)) $ j\"\n      \"Tensor.lookup (tensors_from_net m2 $ j) is2\n      = evaluate_net m2 (map (\\<lambda>(x, y). unit\\<^sub>v x y) (zip (input_sizes m2) is2)) $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (tensors_from_net m1 $ j) is1 =\n    evaluate_net m1 (map2 unit\\<^sub>v (input_sizes m1) is1) $ j &&&\n    lookup (tensors_from_net m2 $ j) is2 =\n    evaluate_net m2 (map2 unit\\<^sub>v (input_sizes m2) is2) $ j", "using Pool convnet.distinct(3) convnet.distinct(5) convnet.inject(3) remove_weights.simps(3)\n    valid_net.simps  \\<open>is1 \\<lhd> input_sizes m1\\<close> \\<open>is2 \\<lhd> input_sizes m2\\<close> output_size.simps(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_net' m1; ?is \\<lhd> input_sizes m1;\n   ?j < output_size' m1\\<rbrakk>\n  \\<Longrightarrow> lookup (tensors_from_net m1 $ ?j) ?is =\n                    evaluate_net m1 (base_input m1 ?is) $ ?j\n  \\<lbrakk>valid_net' m2; ?is \\<lhd> input_sizes m2;\n   ?j < output_size' m2\\<rbrakk>\n  \\<Longrightarrow> lookup (tensors_from_net m2 $ ?j) ?is =\n                    evaluate_net m2 (base_input m2 ?is) $ ?j\n  valid_net' (Pool m1 m2)\n  is \\<lhd> input_sizes (Pool m1 m2)\n  j < output_size' (Pool m1 m2)\n  Input ?x1.0 \\<noteq> Pool ?x31.0 ?x32.0\n  Conv ?x21.0 ?x22.0 \\<noteq> Pool ?x31.0 ?x32.0\n  (Pool ?x31.0 ?x32.0 = Pool ?y31.0 ?y32.0) =\n  (?x31.0 = ?y31.0 \\<and> ?x32.0 = ?y32.0)\n  remove_weights (Pool ?m1.0 ?m2.0) =\n  Pool (remove_weights ?m1.0) (remove_weights ?m2.0)\n  valid_net ?a =\n  ((\\<exists>M. ?a = Input M) \\<or>\n   (\\<exists>m r1 r0.\n       ?a = Conv (r0, r1) m \\<and>\n       output_size m = r1 \\<and> valid_net m) \\<or>\n   (\\<exists>m1 m2.\n       ?a = Pool m1 m2 \\<and>\n       output_size m1 = output_size m2 \\<and>\n       valid_net m1 \\<and> valid_net m2))\n  is1 \\<lhd> input_sizes m1\n  is2 \\<lhd> input_sizes m2\n  output_size (Pool ?m1.0 ?m2.0) = output_size ?m1.0\n\ngoal (1 subgoal):\n 1. lookup (tensors_from_net m1 $ j) is1 =\n    evaluate_net m1 (map2 unit\\<^sub>v (input_sizes m1) is1) $ j &&&\n    lookup (tensors_from_net m2 $ j) is2 =\n    evaluate_net m2 (map2 unit\\<^sub>v (input_sizes m2) is2) $ j", "by (metis base_input_def)+"], ["proof (state)\nthis:\n  lookup (tensors_from_net m1 $ j) is1 =\n  evaluate_net m1 (map2 unit\\<^sub>v (input_sizes m1) is1) $ j\n  lookup (tensors_from_net m2 $ j) is2 =\n  evaluate_net m2 (map2 unit\\<^sub>v (input_sizes m2) is2) $ j\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "text \\<open>In the Pool layer tensor entries get multiplied:\\<close>"], ["proof (state)\nthis:\n  lookup (tensors_from_net m1 $ j) is1 =\n  evaluate_net m1 (map2 unit\\<^sub>v (input_sizes m1) is1) $ j\n  lookup (tensors_from_net m2 $ j) is2 =\n  evaluate_net m2 (map2 unit\\<^sub>v (input_sizes m2) is2) $ j\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "have lookup_prod: \"Tensor.lookup (tensors_from_net (Pool m1 m2) $ j) is\n    = Tensor.lookup (tensors_from_net m1 $ j) is1 * Tensor.lookup (tensors_from_net m2 $ j) is2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (tensors_from_net (Pool m1 m2) $ j) is =\n    lookup (tensors_from_net m1 $ j) is1 *\n    lookup (tensors_from_net m2 $ j) is2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup (tensors_from_net (Pool m1 m2) $ j) is =\n    lookup (tensors_from_net m1 $ j) is1 *\n    lookup (tensors_from_net m2 $ j) is2", "have j_small: \"j < dim_vec (tensors_from_net m1)\"  \"j < dim_vec (tensors_from_net m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < dim_vec (tensors_from_net m1) &&& j < dim_vec (tensors_from_net m2)", "by (metis Pool.prems(1) Pool.prems(3) convnet.distinct(3) convnet.inject(3) convnet.simps(9)\n      output_size.simps(3) output_size_correct_tensors remove_weights.simps(3) valid_net.cases)+"], ["proof (state)\nthis:\n  j < dim_vec (tensors_from_net m1)\n  j < dim_vec (tensors_from_net m2)\n\ngoal (1 subgoal):\n 1. lookup (tensors_from_net (Pool m1 m2) $ j) is =\n    lookup (tensors_from_net m1 $ j) is1 *\n    lookup (tensors_from_net m2 $ j) is2", "then"], ["proof (chain)\npicking this:\n  j < dim_vec (tensors_from_net m1)\n  j < dim_vec (tensors_from_net m2)", "have 0:\"tensors_from_net (Pool m1 m2) $ j = tensors_from_net m1 $ j \\<otimes> tensors_from_net m2 $ j\""], ["proof (prove)\nusing this:\n  j < dim_vec (tensors_from_net m1)\n  j < dim_vec (tensors_from_net m2)\n\ngoal (1 subgoal):\n 1. tensors_from_net (Pool m1 m2) $ j =\n    tensors_from_net m1 $ j \\<otimes> tensors_from_net m2 $ j", "unfolding tensors_from_net.simps"], ["proof (prove)\nusing this:\n  j < dim_vec (tensors_from_net m1)\n  j < dim_vec (tensors_from_net m2)\n\ngoal (1 subgoal):\n 1. component_mult (tensors_from_net m1) (tensors_from_net m2) $ j =\n    tensors_from_net m1 $ j \\<otimes> tensors_from_net m2 $ j", "using j_small index_component_mult"], ["proof (prove)\nusing this:\n  j < dim_vec (tensors_from_net m1)\n  j < dim_vec (tensors_from_net m2)\n  j < dim_vec (tensors_from_net m1)\n  j < dim_vec (tensors_from_net m2)\n  \\<lbrakk>?i < dim_vec ?v; ?i < dim_vec ?w\\<rbrakk>\n  \\<Longrightarrow> component_mult ?v ?w $ ?i = ?v $ ?i * ?w $ ?i\n\ngoal (1 subgoal):\n 1. component_mult (tensors_from_net m1) (tensors_from_net m2) $ j =\n    tensors_from_net m1 $ j \\<otimes> tensors_from_net m2 $ j", "by blast"], ["proof (state)\nthis:\n  tensors_from_net (Pool m1 m2) $ j =\n  tensors_from_net m1 $ j \\<otimes> tensors_from_net m2 $ j\n\ngoal (1 subgoal):\n 1. lookup (tensors_from_net (Pool m1 m2) $ j) is =\n    lookup (tensors_from_net m1 $ j) is1 *\n    lookup (tensors_from_net m2 $ j) is2", "have \"Tensor.dims (tensors_from_net m1 $ j) = input_sizes m1\"\n         \"Tensor.dims (tensors_from_net m2 $ j) = input_sizes m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dims (tensors_from_net m1 $ j) = input_sizes m1 &&&\n    dims (tensors_from_net m2 $ j) = input_sizes m2", "using dims_tensors_from_net j_small nth_mem"], ["proof (prove)\nusing this:\n  ?T \\<in> set\\<^sub>v (tensors_from_net ?m) \\<Longrightarrow>\n  dims ?T = input_sizes ?m\n  j < dim_vec (tensors_from_net m1)\n  j < dim_vec (tensors_from_net m2)\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. dims (tensors_from_net m1 $ j) = input_sizes m1 &&&\n    dims (tensors_from_net m2 $ j) = input_sizes m2", "by (simp_all add: vec_setI)"], ["proof (state)\nthis:\n  dims (tensors_from_net m1 $ j) = input_sizes m1\n  dims (tensors_from_net m2 $ j) = input_sizes m2\n\ngoal (1 subgoal):\n 1. lookup (tensors_from_net (Pool m1 m2) $ j) is =\n    lookup (tensors_from_net m1 $ j) is1 *\n    lookup (tensors_from_net m2 $ j) is2", "then"], ["proof (chain)\npicking this:\n  dims (tensors_from_net m1 $ j) = input_sizes m1\n  dims (tensors_from_net m2 $ j) = input_sizes m2", "have is12_valid:\n              \"is1 \\<lhd> Tensor.dims (tensors_from_net m1 $ j)\"\n              \"is2 \\<lhd> Tensor.dims (tensors_from_net m2 $ j)\""], ["proof (prove)\nusing this:\n  dims (tensors_from_net m1 $ j) = input_sizes m1\n  dims (tensors_from_net m2 $ j) = input_sizes m2\n\ngoal (1 subgoal):\n 1. is1 \\<lhd> dims (tensors_from_net m1 $ j) &&&\n    is2 \\<lhd> dims (tensors_from_net m2 $ j)", "using is12_def"], ["proof (prove)\nusing this:\n  dims (tensors_from_net m1 $ j) = input_sizes m1\n  dims (tensors_from_net m2 $ j) = input_sizes m2\n  is = is1 @ is2\n  is1 \\<lhd> input_sizes m1\n  is2 \\<lhd> input_sizes m2\n\ngoal (1 subgoal):\n 1. is1 \\<lhd> dims (tensors_from_net m1 $ j) &&&\n    is2 \\<lhd> dims (tensors_from_net m2 $ j)", "by presburger+"], ["proof (state)\nthis:\n  is1 \\<lhd> dims (tensors_from_net m1 $ j)\n  is2 \\<lhd> dims (tensors_from_net m2 $ j)\n\ngoal (1 subgoal):\n 1. lookup (tensors_from_net (Pool m1 m2) $ j) is =\n    lookup (tensors_from_net m1 $ j) is1 *\n    lookup (tensors_from_net m2 $ j) is2", "then"], ["proof (chain)\npicking this:\n  is1 \\<lhd> dims (tensors_from_net m1 $ j)\n  is2 \\<lhd> dims (tensors_from_net m2 $ j)", "show ?thesis"], ["proof (prove)\nusing this:\n  is1 \\<lhd> dims (tensors_from_net m1 $ j)\n  is2 \\<lhd> dims (tensors_from_net m2 $ j)\n\ngoal (1 subgoal):\n 1. lookup (tensors_from_net (Pool m1 m2) $ j) is =\n    lookup (tensors_from_net m1 $ j) is1 *\n    lookup (tensors_from_net m2 $ j) is2", "unfolding 0"], ["proof (prove)\nusing this:\n  is1 \\<lhd> dims (tensors_from_net m1 $ j)\n  is2 \\<lhd> dims (tensors_from_net m2 $ j)\n\ngoal (1 subgoal):\n 1. lookup (tensors_from_net m1 $ j \\<otimes> tensors_from_net m2 $ j) is =\n    lookup (tensors_from_net m1 $ j) is1 *\n    lookup (tensors_from_net m2 $ j) is2", "using lookup_tensor_prod[OF is12_valid] is12_def"], ["proof (prove)\nusing this:\n  is1 \\<lhd> dims (tensors_from_net m1 $ j)\n  is2 \\<lhd> dims (tensors_from_net m2 $ j)\n  lookup (tensors_from_net m1 $ j \\<otimes> tensors_from_net m2 $ j)\n   (is1 @ is2) =\n  lookup (tensors_from_net m1 $ j) is1 *\n  lookup (tensors_from_net m2 $ j) is2\n  is = is1 @ is2\n  is1 \\<lhd> input_sizes m1\n  is2 \\<lhd> input_sizes m2\n\ngoal (1 subgoal):\n 1. lookup (tensors_from_net m1 $ j \\<otimes> tensors_from_net m2 $ j) is =\n    lookup (tensors_from_net m1 $ j) is1 *\n    lookup (tensors_from_net m2 $ j) is2", "by auto"], ["proof (state)\nthis:\n  lookup (tensors_from_net (Pool m1 m2) $ j) is =\n  lookup (tensors_from_net m1 $ j) is1 *\n  lookup (tensors_from_net m2 $ j) is2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup (tensors_from_net (Pool m1 m2) $ j) is =\n  lookup (tensors_from_net m1 $ j) is1 *\n  lookup (tensors_from_net m2 $ j) is2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "text \\<open>Output values get multiplied in the Pool layer as well:\\<close>"], ["proof (state)\nthis:\n  lookup (tensors_from_net (Pool m1 m2) $ j) is =\n  lookup (tensors_from_net m1 $ j) is1 *\n  lookup (tensors_from_net m2 $ j) is2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "have \"evaluate_net (Pool m1 m2) (base_input (Pool m1 m2) is) $ j\n    = evaluate_net m1 (base_input m1 is1) $ j * evaluate_net m2 (base_input m2 is2) $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_net (Pool m1 m2) (base_input (Pool m1 m2) is) $ j =\n    evaluate_net m1 (base_input m1 is1) $ j *\n    evaluate_net m2 (base_input m2 is2) $ j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. evaluate_net (Pool m1 m2) (base_input (Pool m1 m2) is) $ j =\n    evaluate_net m1 (base_input m1 is1) $ j *\n    evaluate_net m2 (base_input m2 is2) $ j", "have \"valid_net' m1\" \"valid_net' m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_net' m1 &&& valid_net' m2", "using remove_weights.simps  valid_net.simps Pool.prems"], ["proof (prove)\nusing this:\n  remove_weights (Input ?M) = Input ?M\n  remove_weights (Conv ?A ?m) =\n  Conv (dim_row ?A, dim_col ?A) (remove_weights ?m)\n  remove_weights (Pool ?m1.0 ?m2.0) =\n  Pool (remove_weights ?m1.0) (remove_weights ?m2.0)\n  valid_net ?a =\n  ((\\<exists>M. ?a = Input M) \\<or>\n   (\\<exists>m r1 r0.\n       ?a = Conv (r0, r1) m \\<and>\n       output_size m = r1 \\<and> valid_net m) \\<or>\n   (\\<exists>m1 m2.\n       ?a = Pool m1 m2 \\<and>\n       output_size m1 = output_size m2 \\<and>\n       valid_net m1 \\<and> valid_net m2))\n  valid_net' (Pool m1 m2)\n  is \\<lhd> input_sizes (Pool m1 m2)\n  j < output_size' (Pool m1 m2)\n\ngoal (1 subgoal):\n 1. valid_net' m1 &&& valid_net' m2", "by (metis convnet.distinct(3) convnet.distinct(5) convnet.inject(3))+"], ["proof (state)\nthis:\n  valid_net' m1\n  valid_net' m2\n\ngoal (1 subgoal):\n 1. evaluate_net (Pool m1 m2) (base_input (Pool m1 m2) is) $ j =\n    evaluate_net m1 (base_input m1 is1) $ j *\n    evaluate_net m2 (base_input m2 is2) $ j", "have \"input_sizes m1 = map dim_vec (base_input m1 is1)\"\n         \"input_sizes m2 = map dim_vec (base_input m2 is2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. input_sizes m1 = map dim_vec (base_input m1 is1) &&&\n    input_sizes m2 = map dim_vec (base_input m2 is2)", "using base_input_def base_input_length base_input_def is12_def"], ["proof (prove)\nusing this:\n  base_input ?m ?is = map2 unit\\<^sub>v (input_sizes ?m) ?is\n  ?is \\<lhd> input_sizes ?m \\<Longrightarrow>\n  input_sizes ?m = map dim_vec (base_input ?m ?is)\n  base_input ?m ?is = map2 unit\\<^sub>v (input_sizes ?m) ?is\n  is = is1 @ is2\n  is1 \\<lhd> input_sizes m1\n  is2 \\<lhd> input_sizes m2\n\ngoal (1 subgoal):\n 1. input_sizes m1 = map dim_vec (base_input m1 is1) &&&\n    input_sizes m2 = map dim_vec (base_input m2 is2)", "by auto"], ["proof (state)\nthis:\n  input_sizes m1 = map dim_vec (base_input m1 is1)\n  input_sizes m2 = map dim_vec (base_input m2 is2)\n\ngoal (1 subgoal):\n 1. evaluate_net (Pool m1 m2) (base_input (Pool m1 m2) is) $ j =\n    evaluate_net m1 (base_input m1 is1) $ j *\n    evaluate_net m2 (base_input m2 is2) $ j", "have \"j < dim_vec (evaluate_net m1 (base_input m1 is1))\" \"j < dim_vec (evaluate_net m2 (base_input m2 is2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < dim_vec (evaluate_net m1 (base_input m1 is1)) &&&\n    j < dim_vec (evaluate_net m2 (base_input m2 is2))", "using Pool.prems \\<open>input_sizes m1 = map dim_vec (base_input m1 is1)\\<close> \\<open>valid_net' m1\\<close>\n      output_size_correct"], ["proof (prove)\nusing this:\n  valid_net' (Pool m1 m2)\n  is \\<lhd> input_sizes (Pool m1 m2)\n  j < output_size' (Pool m1 m2)\n  input_sizes m1 = map dim_vec (base_input m1 is1)\n  valid_net' m1\n  \\<lbrakk>valid_net' ?m; map dim_vec ?inputs = input_sizes ?m\\<rbrakk>\n  \\<Longrightarrow> output_size' ?m = dim_vec (evaluate_net ?m ?inputs)\n\ngoal (1 subgoal):\n 1. j < dim_vec (evaluate_net m1 (base_input m1 is1)) &&&\n    j < dim_vec (evaluate_net m2 (base_input m2 is2))", "by (auto,metis Pool.prems(1) Pool.prems(3) \\<open>input_sizes m2 = map dim_vec (base_input m2 is2)\\<close>\n      convnet.distinct(3) convnet.distinct(5) convnet.inject(3) output_size.simps(3) output_size_correct\n      remove_weights.simps(3) valid_net.cases)"], ["proof (state)\nthis:\n  j < dim_vec (evaluate_net m1 (base_input m1 is1))\n  j < dim_vec (evaluate_net m2 (base_input m2 is2))\n\ngoal (1 subgoal):\n 1. evaluate_net (Pool m1 m2) (base_input (Pool m1 m2) is) $ j =\n    evaluate_net m1 (base_input m1 is1) $ j *\n    evaluate_net m2 (base_input m2 is2) $ j", "then"], ["proof (chain)\npicking this:\n  j < dim_vec (evaluate_net m1 (base_input m1 is1))\n  j < dim_vec (evaluate_net m2 (base_input m2 is2))", "show ?thesis"], ["proof (prove)\nusing this:\n  j < dim_vec (evaluate_net m1 (base_input m1 is1))\n  j < dim_vec (evaluate_net m2 (base_input m2 is2))\n\ngoal (1 subgoal):\n 1. evaluate_net (Pool m1 m2) (base_input (Pool m1 m2) is) $ j =\n    evaluate_net m1 (base_input m1 is1) $ j *\n    evaluate_net m2 (base_input m2 is2) $ j", "unfolding evaluate_net.simps"], ["proof (prove)\nusing this:\n  j < dim_vec (evaluate_net m1 (base_input m1 is1))\n  j < dim_vec (evaluate_net m2 (base_input m2 is2))\n\ngoal (1 subgoal):\n 1. component_mult\n     (evaluate_net m1\n       (take (length (input_sizes m1)) (base_input (Pool m1 m2) is)))\n     (evaluate_net m2\n       (drop (length (input_sizes m1)) (base_input (Pool m1 m2) is))) $\n    j =\n    evaluate_net m1 (base_input m1 is1) $ j *\n    evaluate_net m2 (base_input m2 is2) $ j", "unfolding base_input_def"], ["proof (prove)\nusing this:\n  j < dim_vec (evaluate_net m1 (map2 unit\\<^sub>v (input_sizes m1) is1))\n  j < dim_vec (evaluate_net m2 (map2 unit\\<^sub>v (input_sizes m2) is2))\n\ngoal (1 subgoal):\n 1. component_mult\n     (evaluate_net m1\n       (take (length (input_sizes m1))\n         (map2 unit\\<^sub>v (input_sizes (Pool m1 m2)) is)))\n     (evaluate_net m2\n       (drop (length (input_sizes m1))\n         (map2 unit\\<^sub>v (input_sizes (Pool m1 m2)) is))) $\n    j =\n    evaluate_net m1 (map2 unit\\<^sub>v (input_sizes m1) is1) $ j *\n    evaluate_net m2 (map2 unit\\<^sub>v (input_sizes m2) is2) $ j", "using is12_def(1) is12_def(2) valid_index_length"], ["proof (prove)\nusing this:\n  j < dim_vec (evaluate_net m1 (map2 unit\\<^sub>v (input_sizes m1) is1))\n  j < dim_vec (evaluate_net m2 (map2 unit\\<^sub>v (input_sizes m2) is2))\n  is = is1 @ is2\n  is1 \\<lhd> input_sizes m1\n  ?is \\<lhd> ?ds \\<Longrightarrow> length ?is = length ?ds\n\ngoal (1 subgoal):\n 1. component_mult\n     (evaluate_net m1\n       (take (length (input_sizes m1))\n         (map2 unit\\<^sub>v (input_sizes (Pool m1 m2)) is)))\n     (evaluate_net m2\n       (drop (length (input_sizes m1))\n         (map2 unit\\<^sub>v (input_sizes (Pool m1 m2)) is))) $\n    j =\n    evaluate_net m1 (map2 unit\\<^sub>v (input_sizes m1) is1) $ j *\n    evaluate_net m2 (map2 unit\\<^sub>v (input_sizes m2) is2) $ j", "by (simp add: append_eq_conv_conj drop_map\n      drop_zip index_component_mult input_sizes_remove_weights take_map take_zip)"], ["proof (state)\nthis:\n  evaluate_net (Pool m1 m2) (base_input (Pool m1 m2) is) $ j =\n  evaluate_net m1 (base_input m1 is1) $ j *\n  evaluate_net m2 (base_input m2 is2) $ j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  evaluate_net (Pool m1 m2) (base_input (Pool m1 m2) is) $ j =\n  evaluate_net m1 (base_input m1 is1) $ j *\n  evaluate_net m2 (base_input m2 is2) $ j\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j is.\n       \\<lbrakk>\\<And>j is.\n                   \\<lbrakk>valid_net' m1; is \\<lhd> input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> lookup (tensors_from_net m1 $ j) is =\n                                     evaluate_net m1 (base_input m1 is) $ j;\n        \\<And>j is.\n           \\<lbrakk>valid_net' m2; is \\<lhd> input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> lookup (tensors_from_net m2 $ j) is =\n                             evaluate_net m2 (base_input m2 is) $ j;\n        valid_net' (Pool m1 m2); is \\<lhd> input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j) is =\n                         evaluate_net (Pool m1 m2)\n                          (base_input (Pool m1 m2) is) $\n                         j", "then"], ["proof (chain)\npicking this:\n  evaluate_net (Pool m1 m2) (base_input (Pool m1 m2) is) $ j =\n  evaluate_net m1 (base_input m1 is1) $ j *\n  evaluate_net m2 (base_input m2 is2) $ j", "show ?case"], ["proof (prove)\nusing this:\n  evaluate_net (Pool m1 m2) (base_input (Pool m1 m2) is) $ j =\n  evaluate_net m1 (base_input m1 is1) $ j *\n  evaluate_net m2 (base_input m2 is2) $ j\n\ngoal (1 subgoal):\n 1. lookup (tensors_from_net (Pool m1 m2) $ j) is =\n    evaluate_net (Pool m1 m2) (base_input (Pool m1 m2) is) $ j", "using lookup_prod IH base_input_def"], ["proof (prove)\nusing this:\n  evaluate_net (Pool m1 m2) (base_input (Pool m1 m2) is) $ j =\n  evaluate_net m1 (base_input m1 is1) $ j *\n  evaluate_net m2 (base_input m2 is2) $ j\n  lookup (tensors_from_net (Pool m1 m2) $ j) is =\n  lookup (tensors_from_net m1 $ j) is1 *\n  lookup (tensors_from_net m2 $ j) is2\n  lookup (tensors_from_net m1 $ j) is1 =\n  evaluate_net m1 (map2 unit\\<^sub>v (input_sizes m1) is1) $ j\n  lookup (tensors_from_net m2 $ j) is2 =\n  evaluate_net m2 (map2 unit\\<^sub>v (input_sizes m2) is2) $ j\n  base_input ?m ?is = map2 unit\\<^sub>v (input_sizes ?m) ?is\n\ngoal (1 subgoal):\n 1. lookup (tensors_from_net (Pool m1 m2) $ j) is =\n    evaluate_net (Pool m1 m2) (base_input (Pool m1 m2) is) $ j", "by auto"], ["proof (state)\nthis:\n  lookup (tensors_from_net (Pool m1 m2) $ j) is =\n  evaluate_net (Pool m1 m2) (base_input (Pool m1 m2) is) $ j\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec extract_weights::\"bool \\<Rightarrow> real mat convnet \\<Rightarrow> nat \\<Rightarrow> real\" where\n  extract_weights_Input: \"extract_weights shared (Input M) = (\\<lambda>x. 0)\"\n| extract_weights_Conv: \"extract_weights shared (Conv A m) = \n    (\\<lambda>x. if x < dim_row A * dim_col A then flatten_matrix A x \n         else extract_weights shared m (x - dim_row A * dim_col A))\"\n| extract_weights_Pool: \"extract_weights shared (Pool m1 m2) = \n    (\\<lambda>x. if x < count_weights shared (remove_weights m1) \n         then extract_weights shared m1 x \n         else extract_weights shared m2 (x - count_weights shared (remove_weights m1)))\""], ["", "inductive balanced_net::\"(nat \\<times> nat) convnet \\<Rightarrow> bool\" where\n  balanced_net_Input: \"balanced_net (Input M)\"\n| balanced_net_Conv: \"balanced_net m \\<Longrightarrow> balanced_net (Conv A m)\"\n| balanced_net_Pool: \"balanced_net m1 \\<Longrightarrow> balanced_net m2 \\<Longrightarrow> \n    count_weights True m1 = count_weights True m2 \\<Longrightarrow> balanced_net (Pool m1 m2)\""], ["", "inductive shared_weight_net::\"real mat convnet \\<Rightarrow> bool\" where\n  shared_weight_net_Input: \"shared_weight_net (Input M)\"\n| shared_weight_net_Conv: \"shared_weight_net m \\<Longrightarrow> shared_weight_net (Conv A m)\"\n| shared_weight_net_Pool: \"shared_weight_net m1 \\<Longrightarrow> shared_weight_net m2 \\<Longrightarrow> \n  count_weights True (remove_weights m1) = count_weights True (remove_weights m2) \\<Longrightarrow> \n  (\\<And>x. x < count_weights True (remove_weights m1) \\<Longrightarrow> extract_weights True m1 x = extract_weights True m2 x)\n   \\<Longrightarrow> shared_weight_net (Pool m1 m2)\""], ["", "lemma insert_extract_weights_cong_shared:\nassumes \"shared_weight_net m\"\nassumes \"\\<And>x. x < count_weights True (remove_weights m) \\<Longrightarrow> f x = extract_weights True m x\"\nshows \"m = insert_weights True (remove_weights m) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = insert_weights True (remove_weights m) f", "using assms"], ["proof (prove)\nusing this:\n  shared_weight_net m\n  ?x < count_weights True (remove_weights m) \\<Longrightarrow>\n  f ?x = extract_weights True m ?x\n\ngoal (1 subgoal):\n 1. m = insert_weights True (remove_weights m) f", "proof (induction m arbitrary:f)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>M f.\n       (\\<And>x.\n           x < count_weights True\n                (remove_weights (Input M)) \\<Longrightarrow>\n           f x = extract_weights True (Input M) x) \\<Longrightarrow>\n       Input M = insert_weights True (remove_weights (Input M)) f\n 2. \\<And>m A f.\n       \\<lbrakk>shared_weight_net m;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m) \\<Longrightarrow>\n               f x = extract_weights True m x) \\<Longrightarrow>\n           m = insert_weights True (remove_weights m) f;\n        \\<And>x.\n           x < count_weights True\n                (remove_weights (Conv A m)) \\<Longrightarrow>\n           f x = extract_weights True (Conv A m) x\\<rbrakk>\n       \\<Longrightarrow> Conv A m =\n                         insert_weights True (remove_weights (Conv A m)) f\n 3. \\<And>m1 m2 f.\n       \\<lbrakk>shared_weight_net m1;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m1) \\<Longrightarrow>\n               f x = extract_weights True m1 x) \\<Longrightarrow>\n           m1 = insert_weights True (remove_weights m1) f;\n        shared_weight_net m2;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m2) \\<Longrightarrow>\n               f x = extract_weights True m2 x) \\<Longrightarrow>\n           m2 = insert_weights True (remove_weights m2) f;\n        count_weights True (remove_weights m1) =\n        count_weights True (remove_weights m2);\n        \\<And>x.\n           x < count_weights True (remove_weights m1) \\<Longrightarrow>\n           extract_weights True m1 x = extract_weights True m2 x;\n        \\<And>x.\n           x < count_weights True\n                (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n           f x = extract_weights True (Pool m1 m2) x\\<rbrakk>\n       \\<Longrightarrow> Pool m1 m2 =\n                         insert_weights True (remove_weights (Pool m1 m2)) f", "case (shared_weight_net_Input M)"], ["proof (state)\nthis:\n  ?x < count_weights True (remove_weights (Input M)) \\<Longrightarrow>\n  f ?x = extract_weights True (Input M) ?x\n\ngoal (3 subgoals):\n 1. \\<And>M f.\n       (\\<And>x.\n           x < count_weights True\n                (remove_weights (Input M)) \\<Longrightarrow>\n           f x = extract_weights True (Input M) x) \\<Longrightarrow>\n       Input M = insert_weights True (remove_weights (Input M)) f\n 2. \\<And>m A f.\n       \\<lbrakk>shared_weight_net m;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m) \\<Longrightarrow>\n               f x = extract_weights True m x) \\<Longrightarrow>\n           m = insert_weights True (remove_weights m) f;\n        \\<And>x.\n           x < count_weights True\n                (remove_weights (Conv A m)) \\<Longrightarrow>\n           f x = extract_weights True (Conv A m) x\\<rbrakk>\n       \\<Longrightarrow> Conv A m =\n                         insert_weights True (remove_weights (Conv A m)) f\n 3. \\<And>m1 m2 f.\n       \\<lbrakk>shared_weight_net m1;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m1) \\<Longrightarrow>\n               f x = extract_weights True m1 x) \\<Longrightarrow>\n           m1 = insert_weights True (remove_weights m1) f;\n        shared_weight_net m2;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m2) \\<Longrightarrow>\n               f x = extract_weights True m2 x) \\<Longrightarrow>\n           m2 = insert_weights True (remove_weights m2) f;\n        count_weights True (remove_weights m1) =\n        count_weights True (remove_weights m2);\n        \\<And>x.\n           x < count_weights True (remove_weights m1) \\<Longrightarrow>\n           extract_weights True m1 x = extract_weights True m2 x;\n        \\<And>x.\n           x < count_weights True\n                (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n           f x = extract_weights True (Pool m1 m2) x\\<rbrakk>\n       \\<Longrightarrow> Pool m1 m2 =\n                         insert_weights True (remove_weights (Pool m1 m2)) f", "then"], ["proof (chain)\npicking this:\n  ?x < count_weights True (remove_weights (Input M)) \\<Longrightarrow>\n  f ?x = extract_weights True (Input M) ?x", "show ?case"], ["proof (prove)\nusing this:\n  ?x < count_weights True (remove_weights (Input M)) \\<Longrightarrow>\n  f ?x = extract_weights True (Input M) ?x\n\ngoal (1 subgoal):\n 1. Input M = insert_weights True (remove_weights (Input M)) f", "by simp"], ["proof (state)\nthis:\n  Input M = insert_weights True (remove_weights (Input M)) f\n\ngoal (2 subgoals):\n 1. \\<And>m A f.\n       \\<lbrakk>shared_weight_net m;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m) \\<Longrightarrow>\n               f x = extract_weights True m x) \\<Longrightarrow>\n           m = insert_weights True (remove_weights m) f;\n        \\<And>x.\n           x < count_weights True\n                (remove_weights (Conv A m)) \\<Longrightarrow>\n           f x = extract_weights True (Conv A m) x\\<rbrakk>\n       \\<Longrightarrow> Conv A m =\n                         insert_weights True (remove_weights (Conv A m)) f\n 2. \\<And>m1 m2 f.\n       \\<lbrakk>shared_weight_net m1;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m1) \\<Longrightarrow>\n               f x = extract_weights True m1 x) \\<Longrightarrow>\n           m1 = insert_weights True (remove_weights m1) f;\n        shared_weight_net m2;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m2) \\<Longrightarrow>\n               f x = extract_weights True m2 x) \\<Longrightarrow>\n           m2 = insert_weights True (remove_weights m2) f;\n        count_weights True (remove_weights m1) =\n        count_weights True (remove_weights m2);\n        \\<And>x.\n           x < count_weights True (remove_weights m1) \\<Longrightarrow>\n           extract_weights True m1 x = extract_weights True m2 x;\n        \\<And>x.\n           x < count_weights True\n                (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n           f x = extract_weights True (Pool m1 m2) x\\<rbrakk>\n       \\<Longrightarrow> Pool m1 m2 =\n                         insert_weights True (remove_weights (Pool m1 m2)) f", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m A f.\n       \\<lbrakk>shared_weight_net m;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m) \\<Longrightarrow>\n               f x = extract_weights True m x) \\<Longrightarrow>\n           m = insert_weights True (remove_weights m) f;\n        \\<And>x.\n           x < count_weights True\n                (remove_weights (Conv A m)) \\<Longrightarrow>\n           f x = extract_weights True (Conv A m) x\\<rbrakk>\n       \\<Longrightarrow> Conv A m =\n                         insert_weights True (remove_weights (Conv A m)) f\n 2. \\<And>m1 m2 f.\n       \\<lbrakk>shared_weight_net m1;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m1) \\<Longrightarrow>\n               f x = extract_weights True m1 x) \\<Longrightarrow>\n           m1 = insert_weights True (remove_weights m1) f;\n        shared_weight_net m2;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m2) \\<Longrightarrow>\n               f x = extract_weights True m2 x) \\<Longrightarrow>\n           m2 = insert_weights True (remove_weights m2) f;\n        count_weights True (remove_weights m1) =\n        count_weights True (remove_weights m2);\n        \\<And>x.\n           x < count_weights True (remove_weights m1) \\<Longrightarrow>\n           extract_weights True m1 x = extract_weights True m2 x;\n        \\<And>x.\n           x < count_weights True\n                (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n           f x = extract_weights True (Pool m1 m2) x\\<rbrakk>\n       \\<Longrightarrow> Pool m1 m2 =\n                         insert_weights True (remove_weights (Pool m1 m2)) f", "case (shared_weight_net_Conv m A)"], ["proof (state)\nthis:\n  shared_weight_net m\n  (\\<And>x.\n      x < count_weights True (remove_weights m) \\<Longrightarrow>\n      ?f x = extract_weights True m x) \\<Longrightarrow>\n  m = insert_weights True (remove_weights m) ?f\n  ?x < count_weights True (remove_weights (Conv A m)) \\<Longrightarrow>\n  f ?x = extract_weights True (Conv A m) ?x\n\ngoal (2 subgoals):\n 1. \\<And>m A f.\n       \\<lbrakk>shared_weight_net m;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m) \\<Longrightarrow>\n               f x = extract_weights True m x) \\<Longrightarrow>\n           m = insert_weights True (remove_weights m) f;\n        \\<And>x.\n           x < count_weights True\n                (remove_weights (Conv A m)) \\<Longrightarrow>\n           f x = extract_weights True (Conv A m) x\\<rbrakk>\n       \\<Longrightarrow> Conv A m =\n                         insert_weights True (remove_weights (Conv A m)) f\n 2. \\<And>m1 m2 f.\n       \\<lbrakk>shared_weight_net m1;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m1) \\<Longrightarrow>\n               f x = extract_weights True m1 x) \\<Longrightarrow>\n           m1 = insert_weights True (remove_weights m1) f;\n        shared_weight_net m2;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m2) \\<Longrightarrow>\n               f x = extract_weights True m2 x) \\<Longrightarrow>\n           m2 = insert_weights True (remove_weights m2) f;\n        count_weights True (remove_weights m1) =\n        count_weights True (remove_weights m2);\n        \\<And>x.\n           x < count_weights True (remove_weights m1) \\<Longrightarrow>\n           extract_weights True m1 x = extract_weights True m2 x;\n        \\<And>x.\n           x < count_weights True\n                (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n           f x = extract_weights True (Pool m1 m2) x\\<rbrakk>\n       \\<Longrightarrow> Pool m1 m2 =\n                         insert_weights True (remove_weights (Pool m1 m2)) f", "have \"extract_matrix f (dim_row A) (dim_col A) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_matrix f (dim_row A) (dim_col A) = A", "by (simp add: extract_matrix_cong extract_matrix_flatten_matrix shared_weight_net_Conv.prems)"], ["proof (state)\nthis:\n  extract_matrix f (dim_row A) (dim_col A) = A\n\ngoal (2 subgoals):\n 1. \\<And>m A f.\n       \\<lbrakk>shared_weight_net m;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m) \\<Longrightarrow>\n               f x = extract_weights True m x) \\<Longrightarrow>\n           m = insert_weights True (remove_weights m) f;\n        \\<And>x.\n           x < count_weights True\n                (remove_weights (Conv A m)) \\<Longrightarrow>\n           f x = extract_weights True (Conv A m) x\\<rbrakk>\n       \\<Longrightarrow> Conv A m =\n                         insert_weights True (remove_weights (Conv A m)) f\n 2. \\<And>m1 m2 f.\n       \\<lbrakk>shared_weight_net m1;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m1) \\<Longrightarrow>\n               f x = extract_weights True m1 x) \\<Longrightarrow>\n           m1 = insert_weights True (remove_weights m1) f;\n        shared_weight_net m2;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m2) \\<Longrightarrow>\n               f x = extract_weights True m2 x) \\<Longrightarrow>\n           m2 = insert_weights True (remove_weights m2) f;\n        count_weights True (remove_weights m1) =\n        count_weights True (remove_weights m2);\n        \\<And>x.\n           x < count_weights True (remove_weights m1) \\<Longrightarrow>\n           extract_weights True m1 x = extract_weights True m2 x;\n        \\<And>x.\n           x < count_weights True\n                (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n           f x = extract_weights True (Pool m1 m2) x\\<rbrakk>\n       \\<Longrightarrow> Pool m1 m2 =\n                         insert_weights True (remove_weights (Pool m1 m2)) f", "then"], ["proof (chain)\npicking this:\n  extract_matrix f (dim_row A) (dim_col A) = A", "show ?case"], ["proof (prove)\nusing this:\n  extract_matrix f (dim_row A) (dim_col A) = A\n\ngoal (1 subgoal):\n 1. Conv A m = insert_weights True (remove_weights (Conv A m)) f", "using shared_weight_net_Conv.IH[of \"(\\<lambda>i. f (i + dim_row A * dim_col A))\"]"], ["proof (prove)\nusing this:\n  extract_matrix f (dim_row A) (dim_col A) = A\n  (\\<And>x.\n      x < count_weights True (remove_weights m) \\<Longrightarrow>\n      f (x + dim_row A * dim_col A) =\n      extract_weights True m x) \\<Longrightarrow>\n  m =\n  insert_weights True (remove_weights m)\n   (\\<lambda>a. f (a + dim_row A * dim_col A))\n\ngoal (1 subgoal):\n 1. Conv A m = insert_weights True (remove_weights (Conv A m)) f", "using shared_weight_net_Conv.prems"], ["proof (prove)\nusing this:\n  extract_matrix f (dim_row A) (dim_col A) = A\n  (\\<And>x.\n      x < count_weights True (remove_weights m) \\<Longrightarrow>\n      f (x + dim_row A * dim_col A) =\n      extract_weights True m x) \\<Longrightarrow>\n  m =\n  insert_weights True (remove_weights m)\n   (\\<lambda>a. f (a + dim_row A * dim_col A))\n  ?x < count_weights True (remove_weights (Conv A m)) \\<Longrightarrow>\n  f ?x = extract_weights True (Conv A m) ?x\n\ngoal (1 subgoal):\n 1. Conv A m = insert_weights True (remove_weights (Conv A m)) f", "by auto"], ["proof (state)\nthis:\n  Conv A m = insert_weights True (remove_weights (Conv A m)) f\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 f.\n       \\<lbrakk>shared_weight_net m1;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m1) \\<Longrightarrow>\n               f x = extract_weights True m1 x) \\<Longrightarrow>\n           m1 = insert_weights True (remove_weights m1) f;\n        shared_weight_net m2;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m2) \\<Longrightarrow>\n               f x = extract_weights True m2 x) \\<Longrightarrow>\n           m2 = insert_weights True (remove_weights m2) f;\n        count_weights True (remove_weights m1) =\n        count_weights True (remove_weights m2);\n        \\<And>x.\n           x < count_weights True (remove_weights m1) \\<Longrightarrow>\n           extract_weights True m1 x = extract_weights True m2 x;\n        \\<And>x.\n           x < count_weights True\n                (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n           f x = extract_weights True (Pool m1 m2) x\\<rbrakk>\n       \\<Longrightarrow> Pool m1 m2 =\n                         insert_weights True (remove_weights (Pool m1 m2)) f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m1 m2 f.\n       \\<lbrakk>shared_weight_net m1;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m1) \\<Longrightarrow>\n               f x = extract_weights True m1 x) \\<Longrightarrow>\n           m1 = insert_weights True (remove_weights m1) f;\n        shared_weight_net m2;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m2) \\<Longrightarrow>\n               f x = extract_weights True m2 x) \\<Longrightarrow>\n           m2 = insert_weights True (remove_weights m2) f;\n        count_weights True (remove_weights m1) =\n        count_weights True (remove_weights m2);\n        \\<And>x.\n           x < count_weights True (remove_weights m1) \\<Longrightarrow>\n           extract_weights True m1 x = extract_weights True m2 x;\n        \\<And>x.\n           x < count_weights True\n                (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n           f x = extract_weights True (Pool m1 m2) x\\<rbrakk>\n       \\<Longrightarrow> Pool m1 m2 =\n                         insert_weights True (remove_weights (Pool m1 m2)) f", "case (shared_weight_net_Pool m1 m2)"], ["proof (state)\nthis:\n  shared_weight_net m1\n  shared_weight_net m2\n  count_weights True (remove_weights m1) =\n  count_weights True (remove_weights m2)\n  ?x < count_weights True (remove_weights m1) \\<Longrightarrow>\n  extract_weights True m1 ?x = extract_weights True m2 ?x\n  (\\<And>x.\n      x < count_weights True (remove_weights m1) \\<Longrightarrow>\n      ?f x = extract_weights True m1 x) \\<Longrightarrow>\n  m1 = insert_weights True (remove_weights m1) ?f\n  (\\<And>x.\n      x < count_weights True (remove_weights m2) \\<Longrightarrow>\n      ?f x = extract_weights True m2 x) \\<Longrightarrow>\n  m2 = insert_weights True (remove_weights m2) ?f\n  ?x < count_weights True (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n  f ?x = extract_weights True (Pool m1 m2) ?x\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 f.\n       \\<lbrakk>shared_weight_net m1;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m1) \\<Longrightarrow>\n               f x = extract_weights True m1 x) \\<Longrightarrow>\n           m1 = insert_weights True (remove_weights m1) f;\n        shared_weight_net m2;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m2) \\<Longrightarrow>\n               f x = extract_weights True m2 x) \\<Longrightarrow>\n           m2 = insert_weights True (remove_weights m2) f;\n        count_weights True (remove_weights m1) =\n        count_weights True (remove_weights m2);\n        \\<And>x.\n           x < count_weights True (remove_weights m1) \\<Longrightarrow>\n           extract_weights True m1 x = extract_weights True m2 x;\n        \\<And>x.\n           x < count_weights True\n                (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n           f x = extract_weights True (Pool m1 m2) x\\<rbrakk>\n       \\<Longrightarrow> Pool m1 m2 =\n                         insert_weights True (remove_weights (Pool m1 m2)) f", "have \"m1 = insert_weights True (remove_weights m1) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 = insert_weights True (remove_weights m1) f", "using shared_weight_net_Pool.IH(1) shared_weight_net_Pool.prems"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x < count_weights True (remove_weights m1) \\<Longrightarrow>\n      ?f x = extract_weights True m1 x) \\<Longrightarrow>\n  m1 = insert_weights True (remove_weights m1) ?f\n  ?x < count_weights True (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n  f ?x = extract_weights True (Pool m1 m2) ?x\n\ngoal (1 subgoal):\n 1. m1 = insert_weights True (remove_weights m1) f", "by auto"], ["proof (state)\nthis:\n  m1 = insert_weights True (remove_weights m1) f\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 f.\n       \\<lbrakk>shared_weight_net m1;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m1) \\<Longrightarrow>\n               f x = extract_weights True m1 x) \\<Longrightarrow>\n           m1 = insert_weights True (remove_weights m1) f;\n        shared_weight_net m2;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m2) \\<Longrightarrow>\n               f x = extract_weights True m2 x) \\<Longrightarrow>\n           m2 = insert_weights True (remove_weights m2) f;\n        count_weights True (remove_weights m1) =\n        count_weights True (remove_weights m2);\n        \\<And>x.\n           x < count_weights True (remove_weights m1) \\<Longrightarrow>\n           extract_weights True m1 x = extract_weights True m2 x;\n        \\<And>x.\n           x < count_weights True\n                (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n           f x = extract_weights True (Pool m1 m2) x\\<rbrakk>\n       \\<Longrightarrow> Pool m1 m2 =\n                         insert_weights True (remove_weights (Pool m1 m2)) f", "have \"m2 = insert_weights True (remove_weights m2) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m2 = insert_weights True (remove_weights m2) f", "using local.shared_weight_net_Pool(3) shared_weight_net_Pool.IH(2) \n    shared_weight_net_Pool.hyps(4) shared_weight_net_Pool.prems"], ["proof (prove)\nusing this:\n  count_weights True (remove_weights m1) =\n  count_weights True (remove_weights m2)\n  (\\<And>x.\n      x < count_weights True (remove_weights m2) \\<Longrightarrow>\n      ?f x = extract_weights True m2 x) \\<Longrightarrow>\n  m2 = insert_weights True (remove_weights m2) ?f\n  ?x < count_weights True (remove_weights m1) \\<Longrightarrow>\n  extract_weights True m1 ?x = extract_weights True m2 ?x\n  ?x < count_weights True (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n  f ?x = extract_weights True (Pool m1 m2) ?x\n\ngoal (1 subgoal):\n 1. m2 = insert_weights True (remove_weights m2) f", "by fastforce"], ["proof (state)\nthis:\n  m2 = insert_weights True (remove_weights m2) f\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 f.\n       \\<lbrakk>shared_weight_net m1;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m1) \\<Longrightarrow>\n               f x = extract_weights True m1 x) \\<Longrightarrow>\n           m1 = insert_weights True (remove_weights m1) f;\n        shared_weight_net m2;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights True (remove_weights m2) \\<Longrightarrow>\n               f x = extract_weights True m2 x) \\<Longrightarrow>\n           m2 = insert_weights True (remove_weights m2) f;\n        count_weights True (remove_weights m1) =\n        count_weights True (remove_weights m2);\n        \\<And>x.\n           x < count_weights True (remove_weights m1) \\<Longrightarrow>\n           extract_weights True m1 x = extract_weights True m2 x;\n        \\<And>x.\n           x < count_weights True\n                (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n           f x = extract_weights True (Pool m1 m2) x\\<rbrakk>\n       \\<Longrightarrow> Pool m1 m2 =\n                         insert_weights True (remove_weights (Pool m1 m2)) f", "then"], ["proof (chain)\npicking this:\n  m2 = insert_weights True (remove_weights m2) f", "show ?case"], ["proof (prove)\nusing this:\n  m2 = insert_weights True (remove_weights m2) f\n\ngoal (1 subgoal):\n 1. Pool m1 m2 = insert_weights True (remove_weights (Pool m1 m2)) f", "using \\<open>m1 = insert_weights True (remove_weights m1) f\\<close>"], ["proof (prove)\nusing this:\n  m2 = insert_weights True (remove_weights m2) f\n  m1 = insert_weights True (remove_weights m1) f\n\ngoal (1 subgoal):\n 1. Pool m1 m2 = insert_weights True (remove_weights (Pool m1 m2)) f", "by auto"], ["proof (state)\nthis:\n  Pool m1 m2 = insert_weights True (remove_weights (Pool m1 m2)) f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_extract_weights_cong_unshared:\nassumes \"\\<And>x. x < count_weights False (remove_weights m) \\<Longrightarrow> f x = extract_weights False m x\"\nshows \"m = insert_weights False (remove_weights m) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = insert_weights False (remove_weights m) f", "using assms"], ["proof (prove)\nusing this:\n  ?x < count_weights False (remove_weights m) \\<Longrightarrow>\n  f ?x = extract_weights False m ?x\n\ngoal (1 subgoal):\n 1. m = insert_weights False (remove_weights m) f", "proof (induction m arbitrary:f)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x f.\n       (\\<And>xa.\n           xa < count_weights False\n                 (remove_weights (Input x)) \\<Longrightarrow>\n           f xa = extract_weights False (Input x) xa) \\<Longrightarrow>\n       Input x = insert_weights False (remove_weights (Input x)) f\n 2. \\<And>x1a m f.\n       \\<lbrakk>\\<And>f.\n                   (\\<And>x.\n                       x < count_weights False\n                            (remove_weights m) \\<Longrightarrow>\n                       f x = extract_weights False m x) \\<Longrightarrow>\n                   m = insert_weights False (remove_weights m) f;\n        \\<And>x.\n           x < count_weights False\n                (remove_weights (Conv x1a m)) \\<Longrightarrow>\n           f x = extract_weights False (Conv x1a m) x\\<rbrakk>\n       \\<Longrightarrow> Conv x1a m =\n                         insert_weights False (remove_weights (Conv x1a m))\n                          f\n 3. \\<And>m1 m2 f.\n       \\<lbrakk>\\<And>f.\n                   (\\<And>x.\n                       x < count_weights False\n                            (remove_weights m1) \\<Longrightarrow>\n                       f x = extract_weights False m1 x) \\<Longrightarrow>\n                   m1 = insert_weights False (remove_weights m1) f;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights False (remove_weights m2) \\<Longrightarrow>\n               f x = extract_weights False m2 x) \\<Longrightarrow>\n           m2 = insert_weights False (remove_weights m2) f;\n        \\<And>x.\n           x < count_weights False\n                (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n           f x = extract_weights False (Pool m1 m2) x\\<rbrakk>\n       \\<Longrightarrow> Pool m1 m2 =\n                         insert_weights False (remove_weights (Pool m1 m2))\n                          f", "case (Input M)"], ["proof (state)\nthis:\n  ?x < count_weights False (remove_weights (Input M)) \\<Longrightarrow>\n  f ?x = extract_weights False (Input M) ?x\n\ngoal (3 subgoals):\n 1. \\<And>x f.\n       (\\<And>xa.\n           xa < count_weights False\n                 (remove_weights (Input x)) \\<Longrightarrow>\n           f xa = extract_weights False (Input x) xa) \\<Longrightarrow>\n       Input x = insert_weights False (remove_weights (Input x)) f\n 2. \\<And>x1a m f.\n       \\<lbrakk>\\<And>f.\n                   (\\<And>x.\n                       x < count_weights False\n                            (remove_weights m) \\<Longrightarrow>\n                       f x = extract_weights False m x) \\<Longrightarrow>\n                   m = insert_weights False (remove_weights m) f;\n        \\<And>x.\n           x < count_weights False\n                (remove_weights (Conv x1a m)) \\<Longrightarrow>\n           f x = extract_weights False (Conv x1a m) x\\<rbrakk>\n       \\<Longrightarrow> Conv x1a m =\n                         insert_weights False (remove_weights (Conv x1a m))\n                          f\n 3. \\<And>m1 m2 f.\n       \\<lbrakk>\\<And>f.\n                   (\\<And>x.\n                       x < count_weights False\n                            (remove_weights m1) \\<Longrightarrow>\n                       f x = extract_weights False m1 x) \\<Longrightarrow>\n                   m1 = insert_weights False (remove_weights m1) f;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights False (remove_weights m2) \\<Longrightarrow>\n               f x = extract_weights False m2 x) \\<Longrightarrow>\n           m2 = insert_weights False (remove_weights m2) f;\n        \\<And>x.\n           x < count_weights False\n                (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n           f x = extract_weights False (Pool m1 m2) x\\<rbrakk>\n       \\<Longrightarrow> Pool m1 m2 =\n                         insert_weights False (remove_weights (Pool m1 m2))\n                          f", "then"], ["proof (chain)\npicking this:\n  ?x < count_weights False (remove_weights (Input M)) \\<Longrightarrow>\n  f ?x = extract_weights False (Input M) ?x", "show ?case"], ["proof (prove)\nusing this:\n  ?x < count_weights False (remove_weights (Input M)) \\<Longrightarrow>\n  f ?x = extract_weights False (Input M) ?x\n\ngoal (1 subgoal):\n 1. Input M = insert_weights False (remove_weights (Input M)) f", "by simp"], ["proof (state)\nthis:\n  Input M = insert_weights False (remove_weights (Input M)) f\n\ngoal (2 subgoals):\n 1. \\<And>x1a m f.\n       \\<lbrakk>\\<And>f.\n                   (\\<And>x.\n                       x < count_weights False\n                            (remove_weights m) \\<Longrightarrow>\n                       f x = extract_weights False m x) \\<Longrightarrow>\n                   m = insert_weights False (remove_weights m) f;\n        \\<And>x.\n           x < count_weights False\n                (remove_weights (Conv x1a m)) \\<Longrightarrow>\n           f x = extract_weights False (Conv x1a m) x\\<rbrakk>\n       \\<Longrightarrow> Conv x1a m =\n                         insert_weights False (remove_weights (Conv x1a m))\n                          f\n 2. \\<And>m1 m2 f.\n       \\<lbrakk>\\<And>f.\n                   (\\<And>x.\n                       x < count_weights False\n                            (remove_weights m1) \\<Longrightarrow>\n                       f x = extract_weights False m1 x) \\<Longrightarrow>\n                   m1 = insert_weights False (remove_weights m1) f;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights False (remove_weights m2) \\<Longrightarrow>\n               f x = extract_weights False m2 x) \\<Longrightarrow>\n           m2 = insert_weights False (remove_weights m2) f;\n        \\<And>x.\n           x < count_weights False\n                (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n           f x = extract_weights False (Pool m1 m2) x\\<rbrakk>\n       \\<Longrightarrow> Pool m1 m2 =\n                         insert_weights False (remove_weights (Pool m1 m2))\n                          f", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1a m f.\n       \\<lbrakk>\\<And>f.\n                   (\\<And>x.\n                       x < count_weights False\n                            (remove_weights m) \\<Longrightarrow>\n                       f x = extract_weights False m x) \\<Longrightarrow>\n                   m = insert_weights False (remove_weights m) f;\n        \\<And>x.\n           x < count_weights False\n                (remove_weights (Conv x1a m)) \\<Longrightarrow>\n           f x = extract_weights False (Conv x1a m) x\\<rbrakk>\n       \\<Longrightarrow> Conv x1a m =\n                         insert_weights False (remove_weights (Conv x1a m))\n                          f\n 2. \\<And>m1 m2 f.\n       \\<lbrakk>\\<And>f.\n                   (\\<And>x.\n                       x < count_weights False\n                            (remove_weights m1) \\<Longrightarrow>\n                       f x = extract_weights False m1 x) \\<Longrightarrow>\n                   m1 = insert_weights False (remove_weights m1) f;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights False (remove_weights m2) \\<Longrightarrow>\n               f x = extract_weights False m2 x) \\<Longrightarrow>\n           m2 = insert_weights False (remove_weights m2) f;\n        \\<And>x.\n           x < count_weights False\n                (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n           f x = extract_weights False (Pool m1 m2) x\\<rbrakk>\n       \\<Longrightarrow> Pool m1 m2 =\n                         insert_weights False (remove_weights (Pool m1 m2))\n                          f", "case (Conv A m)"], ["proof (state)\nthis:\n  (\\<And>x.\n      x < count_weights False (remove_weights m) \\<Longrightarrow>\n      ?f x = extract_weights False m x) \\<Longrightarrow>\n  m = insert_weights False (remove_weights m) ?f\n  ?x < count_weights False (remove_weights (Conv A m)) \\<Longrightarrow>\n  f ?x = extract_weights False (Conv A m) ?x\n\ngoal (2 subgoals):\n 1. \\<And>x1a m f.\n       \\<lbrakk>\\<And>f.\n                   (\\<And>x.\n                       x < count_weights False\n                            (remove_weights m) \\<Longrightarrow>\n                       f x = extract_weights False m x) \\<Longrightarrow>\n                   m = insert_weights False (remove_weights m) f;\n        \\<And>x.\n           x < count_weights False\n                (remove_weights (Conv x1a m)) \\<Longrightarrow>\n           f x = extract_weights False (Conv x1a m) x\\<rbrakk>\n       \\<Longrightarrow> Conv x1a m =\n                         insert_weights False (remove_weights (Conv x1a m))\n                          f\n 2. \\<And>m1 m2 f.\n       \\<lbrakk>\\<And>f.\n                   (\\<And>x.\n                       x < count_weights False\n                            (remove_weights m1) \\<Longrightarrow>\n                       f x = extract_weights False m1 x) \\<Longrightarrow>\n                   m1 = insert_weights False (remove_weights m1) f;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights False (remove_weights m2) \\<Longrightarrow>\n               f x = extract_weights False m2 x) \\<Longrightarrow>\n           m2 = insert_weights False (remove_weights m2) f;\n        \\<And>x.\n           x < count_weights False\n                (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n           f x = extract_weights False (Pool m1 m2) x\\<rbrakk>\n       \\<Longrightarrow> Pool m1 m2 =\n                         insert_weights False (remove_weights (Pool m1 m2))\n                          f", "then"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      x < count_weights False (remove_weights m) \\<Longrightarrow>\n      ?f x = extract_weights False m x) \\<Longrightarrow>\n  m = insert_weights False (remove_weights m) ?f\n  ?x < count_weights False (remove_weights (Conv A m)) \\<Longrightarrow>\n  f ?x = extract_weights False (Conv A m) ?x", "have \"extract_matrix f (dim_row A) (dim_col A) = A\""], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x < count_weights False (remove_weights m) \\<Longrightarrow>\n      ?f x = extract_weights False m x) \\<Longrightarrow>\n  m = insert_weights False (remove_weights m) ?f\n  ?x < count_weights False (remove_weights (Conv A m)) \\<Longrightarrow>\n  f ?x = extract_weights False (Conv A m) ?x\n\ngoal (1 subgoal):\n 1. extract_matrix f (dim_row A) (dim_col A) = A", "by (metis count_weights.simps(2) extract_matrix_flatten_matrix_cong extract_weights_Conv remove_weights.simps(2) trans_less_add1)"], ["proof (state)\nthis:\n  extract_matrix f (dim_row A) (dim_col A) = A\n\ngoal (2 subgoals):\n 1. \\<And>x1a m f.\n       \\<lbrakk>\\<And>f.\n                   (\\<And>x.\n                       x < count_weights False\n                            (remove_weights m) \\<Longrightarrow>\n                       f x = extract_weights False m x) \\<Longrightarrow>\n                   m = insert_weights False (remove_weights m) f;\n        \\<And>x.\n           x < count_weights False\n                (remove_weights (Conv x1a m)) \\<Longrightarrow>\n           f x = extract_weights False (Conv x1a m) x\\<rbrakk>\n       \\<Longrightarrow> Conv x1a m =\n                         insert_weights False (remove_weights (Conv x1a m))\n                          f\n 2. \\<And>m1 m2 f.\n       \\<lbrakk>\\<And>f.\n                   (\\<And>x.\n                       x < count_weights False\n                            (remove_weights m1) \\<Longrightarrow>\n                       f x = extract_weights False m1 x) \\<Longrightarrow>\n                   m1 = insert_weights False (remove_weights m1) f;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights False (remove_weights m2) \\<Longrightarrow>\n               f x = extract_weights False m2 x) \\<Longrightarrow>\n           m2 = insert_weights False (remove_weights m2) f;\n        \\<And>x.\n           x < count_weights False\n                (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n           f x = extract_weights False (Pool m1 m2) x\\<rbrakk>\n       \\<Longrightarrow> Pool m1 m2 =\n                         insert_weights False (remove_weights (Pool m1 m2))\n                          f", "then"], ["proof (chain)\npicking this:\n  extract_matrix f (dim_row A) (dim_col A) = A", "show ?case"], ["proof (prove)\nusing this:\n  extract_matrix f (dim_row A) (dim_col A) = A\n\ngoal (1 subgoal):\n 1. Conv A m = insert_weights False (remove_weights (Conv A m)) f", "using Conv.IH Conv.prems"], ["proof (prove)\nusing this:\n  extract_matrix f (dim_row A) (dim_col A) = A\n  (\\<And>x.\n      x < count_weights False (remove_weights m) \\<Longrightarrow>\n      ?f x = extract_weights False m x) \\<Longrightarrow>\n  m = insert_weights False (remove_weights m) ?f\n  ?x < count_weights False (remove_weights (Conv A m)) \\<Longrightarrow>\n  f ?x = extract_weights False (Conv A m) ?x\n\ngoal (1 subgoal):\n 1. Conv A m = insert_weights False (remove_weights (Conv A m)) f", "by auto"], ["proof (state)\nthis:\n  Conv A m = insert_weights False (remove_weights (Conv A m)) f\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 f.\n       \\<lbrakk>\\<And>f.\n                   (\\<And>x.\n                       x < count_weights False\n                            (remove_weights m1) \\<Longrightarrow>\n                       f x = extract_weights False m1 x) \\<Longrightarrow>\n                   m1 = insert_weights False (remove_weights m1) f;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights False (remove_weights m2) \\<Longrightarrow>\n               f x = extract_weights False m2 x) \\<Longrightarrow>\n           m2 = insert_weights False (remove_weights m2) f;\n        \\<And>x.\n           x < count_weights False\n                (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n           f x = extract_weights False (Pool m1 m2) x\\<rbrakk>\n       \\<Longrightarrow> Pool m1 m2 =\n                         insert_weights False (remove_weights (Pool m1 m2))\n                          f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m1 m2 f.\n       \\<lbrakk>\\<And>f.\n                   (\\<And>x.\n                       x < count_weights False\n                            (remove_weights m1) \\<Longrightarrow>\n                       f x = extract_weights False m1 x) \\<Longrightarrow>\n                   m1 = insert_weights False (remove_weights m1) f;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights False (remove_weights m2) \\<Longrightarrow>\n               f x = extract_weights False m2 x) \\<Longrightarrow>\n           m2 = insert_weights False (remove_weights m2) f;\n        \\<And>x.\n           x < count_weights False\n                (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n           f x = extract_weights False (Pool m1 m2) x\\<rbrakk>\n       \\<Longrightarrow> Pool m1 m2 =\n                         insert_weights False (remove_weights (Pool m1 m2))\n                          f", "case (Pool m1 m2)"], ["proof (state)\nthis:\n  (\\<And>x.\n      x < count_weights False (remove_weights m1) \\<Longrightarrow>\n      ?f x = extract_weights False m1 x) \\<Longrightarrow>\n  m1 = insert_weights False (remove_weights m1) ?f\n  (\\<And>x.\n      x < count_weights False (remove_weights m2) \\<Longrightarrow>\n      ?f x = extract_weights False m2 x) \\<Longrightarrow>\n  m2 = insert_weights False (remove_weights m2) ?f\n  ?x < count_weights False (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n  f ?x = extract_weights False (Pool m1 m2) ?x\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 f.\n       \\<lbrakk>\\<And>f.\n                   (\\<And>x.\n                       x < count_weights False\n                            (remove_weights m1) \\<Longrightarrow>\n                       f x = extract_weights False m1 x) \\<Longrightarrow>\n                   m1 = insert_weights False (remove_weights m1) f;\n        \\<And>f.\n           (\\<And>x.\n               x < count_weights False (remove_weights m2) \\<Longrightarrow>\n               f x = extract_weights False m2 x) \\<Longrightarrow>\n           m2 = insert_weights False (remove_weights m2) f;\n        \\<And>x.\n           x < count_weights False\n                (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n           f x = extract_weights False (Pool m1 m2) x\\<rbrakk>\n       \\<Longrightarrow> Pool m1 m2 =\n                         insert_weights False (remove_weights (Pool m1 m2))\n                          f", "then"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      x < count_weights False (remove_weights m1) \\<Longrightarrow>\n      ?f x = extract_weights False m1 x) \\<Longrightarrow>\n  m1 = insert_weights False (remove_weights m1) ?f\n  (\\<And>x.\n      x < count_weights False (remove_weights m2) \\<Longrightarrow>\n      ?f x = extract_weights False m2 x) \\<Longrightarrow>\n  m2 = insert_weights False (remove_weights m2) ?f\n  ?x < count_weights False (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n  f ?x = extract_weights False (Pool m1 m2) ?x", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x < count_weights False (remove_weights m1) \\<Longrightarrow>\n      ?f x = extract_weights False m1 x) \\<Longrightarrow>\n  m1 = insert_weights False (remove_weights m1) ?f\n  (\\<And>x.\n      x < count_weights False (remove_weights m2) \\<Longrightarrow>\n      ?f x = extract_weights False m2 x) \\<Longrightarrow>\n  m2 = insert_weights False (remove_weights m2) ?f\n  ?x < count_weights False (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n  f ?x = extract_weights False (Pool m1 m2) ?x\n\ngoal (1 subgoal):\n 1. Pool m1 m2 = insert_weights False (remove_weights (Pool m1 m2)) f", "using Pool.IH(1) Pool.IH(2) Pool.prems"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x < count_weights False (remove_weights m1) \\<Longrightarrow>\n      ?f x = extract_weights False m1 x) \\<Longrightarrow>\n  m1 = insert_weights False (remove_weights m1) ?f\n  (\\<And>x.\n      x < count_weights False (remove_weights m2) \\<Longrightarrow>\n      ?f x = extract_weights False m2 x) \\<Longrightarrow>\n  m2 = insert_weights False (remove_weights m2) ?f\n  ?x < count_weights False (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n  f ?x = extract_weights False (Pool m1 m2) ?x\n  (\\<And>x.\n      x < count_weights False (remove_weights m1) \\<Longrightarrow>\n      ?f x = extract_weights False m1 x) \\<Longrightarrow>\n  m1 = insert_weights False (remove_weights m1) ?f\n  (\\<And>x.\n      x < count_weights False (remove_weights m2) \\<Longrightarrow>\n      ?f x = extract_weights False m2 x) \\<Longrightarrow>\n  m2 = insert_weights False (remove_weights m2) ?f\n  ?x < count_weights False (remove_weights (Pool m1 m2)) \\<Longrightarrow>\n  f ?x = extract_weights False (Pool m1 m2) ?x\n\ngoal (1 subgoal):\n 1. Pool m1 m2 = insert_weights False (remove_weights (Pool m1 m2)) f", "by auto"], ["proof (state)\nthis:\n  Pool m1 m2 = insert_weights False (remove_weights (Pool m1 m2)) f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma remove_insert_weights:\nshows \"remove_weights (insert_weights s m w) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_weights (insert_weights s m w) = m", "proof (induction m arbitrary:w)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x w. remove_weights (insert_weights s (Input x) w) = Input x\n 2. \\<And>x1a m w.\n       (\\<And>w.\n           remove_weights (insert_weights s m w) = m) \\<Longrightarrow>\n       remove_weights (insert_weights s (Conv x1a m) w) = Conv x1a m\n 3. \\<And>m1 m2 w.\n       \\<lbrakk>\\<And>w. remove_weights (insert_weights s m1 w) = m1;\n        \\<And>w. remove_weights (insert_weights s m2 w) = m2\\<rbrakk>\n       \\<Longrightarrow> remove_weights (insert_weights s (Pool m1 m2) w) =\n                         Pool m1 m2", "case Input"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>x w. remove_weights (insert_weights s (Input x) w) = Input x\n 2. \\<And>x1a m w.\n       (\\<And>w.\n           remove_weights (insert_weights s m w) = m) \\<Longrightarrow>\n       remove_weights (insert_weights s (Conv x1a m) w) = Conv x1a m\n 3. \\<And>m1 m2 w.\n       \\<lbrakk>\\<And>w. remove_weights (insert_weights s m1 w) = m1;\n        \\<And>w. remove_weights (insert_weights s m2 w) = m2\\<rbrakk>\n       \\<Longrightarrow> remove_weights (insert_weights s (Pool m1 m2) w) =\n                         Pool m1 m2", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. remove_weights (insert_weights s (Input x_) w) = Input x_", "by simp"], ["proof (state)\nthis:\n  remove_weights (insert_weights s (Input x_) w) = Input x_\n\ngoal (2 subgoals):\n 1. \\<And>x1a m w.\n       (\\<And>w.\n           remove_weights (insert_weights s m w) = m) \\<Longrightarrow>\n       remove_weights (insert_weights s (Conv x1a m) w) = Conv x1a m\n 2. \\<And>m1 m2 w.\n       \\<lbrakk>\\<And>w. remove_weights (insert_weights s m1 w) = m1;\n        \\<And>w. remove_weights (insert_weights s m2 w) = m2\\<rbrakk>\n       \\<Longrightarrow> remove_weights (insert_weights s (Pool m1 m2) w) =\n                         Pool m1 m2", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1a m w.\n       (\\<And>w.\n           remove_weights (insert_weights s m w) = m) \\<Longrightarrow>\n       remove_weights (insert_weights s (Conv x1a m) w) = Conv x1a m\n 2. \\<And>m1 m2 w.\n       \\<lbrakk>\\<And>w. remove_weights (insert_weights s m1 w) = m1;\n        \\<And>w. remove_weights (insert_weights s m2 w) = m2\\<rbrakk>\n       \\<Longrightarrow> remove_weights (insert_weights s (Pool m1 m2) w) =\n                         Pool m1 m2", "case (Conv r12 m)"], ["proof (state)\nthis:\n  remove_weights (insert_weights s m ?w) = m\n\ngoal (2 subgoals):\n 1. \\<And>x1a m w.\n       (\\<And>w.\n           remove_weights (insert_weights s m w) = m) \\<Longrightarrow>\n       remove_weights (insert_weights s (Conv x1a m) w) = Conv x1a m\n 2. \\<And>m1 m2 w.\n       \\<lbrakk>\\<And>w. remove_weights (insert_weights s m1 w) = m1;\n        \\<And>w. remove_weights (insert_weights s m2 w) = m2\\<rbrakk>\n       \\<Longrightarrow> remove_weights (insert_weights s (Pool m1 m2) w) =\n                         Pool m1 m2", "then"], ["proof (chain)\npicking this:\n  remove_weights (insert_weights s m ?w) = m", "obtain r1 r2 where \"r12 = (r1, r2)\""], ["proof (prove)\nusing this:\n  remove_weights (insert_weights s m ?w) = m\n\ngoal (1 subgoal):\n 1. (\\<And>r1 r2. r12 = (r1, r2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  r12 = (r1, r2)\n\ngoal (2 subgoals):\n 1. \\<And>x1a m w.\n       (\\<And>w.\n           remove_weights (insert_weights s m w) = m) \\<Longrightarrow>\n       remove_weights (insert_weights s (Conv x1a m) w) = Conv x1a m\n 2. \\<And>m1 m2 w.\n       \\<lbrakk>\\<And>w. remove_weights (insert_weights s m1 w) = m1;\n        \\<And>w. remove_weights (insert_weights s m2 w) = m2\\<rbrakk>\n       \\<Longrightarrow> remove_weights (insert_weights s (Pool m1 m2) w) =\n                         Pool m1 m2", "then"], ["proof (chain)\npicking this:\n  r12 = (r1, r2)", "have \"remove_weights (insert_weights s m w) = m\""], ["proof (prove)\nusing this:\n  r12 = (r1, r2)\n\ngoal (1 subgoal):\n 1. remove_weights (insert_weights s m w) = m", "using Conv.IH"], ["proof (prove)\nusing this:\n  r12 = (r1, r2)\n  remove_weights (insert_weights s m ?w) = m\n\ngoal (1 subgoal):\n 1. remove_weights (insert_weights s m w) = m", "by blast"], ["proof (state)\nthis:\n  remove_weights (insert_weights s m w) = m\n\ngoal (2 subgoals):\n 1. \\<And>x1a m w.\n       (\\<And>w.\n           remove_weights (insert_weights s m w) = m) \\<Longrightarrow>\n       remove_weights (insert_weights s (Conv x1a m) w) = Conv x1a m\n 2. \\<And>m1 m2 w.\n       \\<lbrakk>\\<And>w. remove_weights (insert_weights s m1 w) = m1;\n        \\<And>w. remove_weights (insert_weights s m2 w) = m2\\<rbrakk>\n       \\<Longrightarrow> remove_weights (insert_weights s (Pool m1 m2) w) =\n                         Pool m1 m2", "then"], ["proof (chain)\npicking this:\n  remove_weights (insert_weights s m w) = m", "have \"remove_weights (insert_weights s (Conv (r1,r2) m) w) = Conv (r1,r2) m\""], ["proof (prove)\nusing this:\n  remove_weights (insert_weights s m w) = m\n\ngoal (1 subgoal):\n 1. remove_weights (insert_weights s (Conv (r1, r2) m) w) = Conv (r1, r2) m", "unfolding insert_weights.simps remove_weights.simps"], ["proof (prove)\nusing this:\n  remove_weights (insert_weights s m w) = m\n\ngoal (1 subgoal):\n 1. Conv\n     (dim_row (extract_matrix w r1 r2), dim_col (extract_matrix w r1 r2))\n     (remove_weights (insert_weights s m (\\<lambda>i. w (i + r1 * r2)))) =\n    Conv (r1, r2) m", "using extract_matrix_def Conv.IH dim_extract_matrix(1)"], ["proof (prove)\nusing this:\n  remove_weights (insert_weights s m w) = m\n  extract_matrix ?a ?m ?n = mat ?m ?n (\\<lambda>(i, j). ?a (i * ?n + j))\n  remove_weights (insert_weights s m ?w) = m\n  dim_row (extract_matrix ?as ?m ?n) = ?m\n\ngoal (1 subgoal):\n 1. Conv\n     (dim_row (extract_matrix w r1 r2), dim_col (extract_matrix w r1 r2))\n     (remove_weights (insert_weights s m (\\<lambda>i. w (i + r1 * r2)))) =\n    Conv (r1, r2) m", "by (metis dim_col_mat(1) )"], ["proof (state)\nthis:\n  remove_weights (insert_weights s (Conv (r1, r2) m) w) = Conv (r1, r2) m\n\ngoal (2 subgoals):\n 1. \\<And>x1a m w.\n       (\\<And>w.\n           remove_weights (insert_weights s m w) = m) \\<Longrightarrow>\n       remove_weights (insert_weights s (Conv x1a m) w) = Conv x1a m\n 2. \\<And>m1 m2 w.\n       \\<lbrakk>\\<And>w. remove_weights (insert_weights s m1 w) = m1;\n        \\<And>w. remove_weights (insert_weights s m2 w) = m2\\<rbrakk>\n       \\<Longrightarrow> remove_weights (insert_weights s (Pool m1 m2) w) =\n                         Pool m1 m2", "then"], ["proof (chain)\npicking this:\n  remove_weights (insert_weights s (Conv (r1, r2) m) w) = Conv (r1, r2) m", "show ?case"], ["proof (prove)\nusing this:\n  remove_weights (insert_weights s (Conv (r1, r2) m) w) = Conv (r1, r2) m\n\ngoal (1 subgoal):\n 1. remove_weights (insert_weights s (Conv r12 m) w) = Conv r12 m", "using \\<open>r12 = (r1, r2)\\<close>"], ["proof (prove)\nusing this:\n  remove_weights (insert_weights s (Conv (r1, r2) m) w) = Conv (r1, r2) m\n  r12 = (r1, r2)\n\ngoal (1 subgoal):\n 1. remove_weights (insert_weights s (Conv r12 m) w) = Conv r12 m", "by blast"], ["proof (state)\nthis:\n  remove_weights (insert_weights s (Conv r12 m) w) = Conv r12 m\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 w.\n       \\<lbrakk>\\<And>w. remove_weights (insert_weights s m1 w) = m1;\n        \\<And>w. remove_weights (insert_weights s m2 w) = m2\\<rbrakk>\n       \\<Longrightarrow> remove_weights (insert_weights s (Pool m1 m2) w) =\n                         Pool m1 m2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m1 m2 w.\n       \\<lbrakk>\\<And>w. remove_weights (insert_weights s m1 w) = m1;\n        \\<And>w. remove_weights (insert_weights s m2 w) = m2\\<rbrakk>\n       \\<Longrightarrow> remove_weights (insert_weights s (Pool m1 m2) w) =\n                         Pool m1 m2", "case (Pool m1 m2 w)"], ["proof (state)\nthis:\n  remove_weights (insert_weights s m1 ?w) = m1\n  remove_weights (insert_weights s m2 ?w) = m2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 w.\n       \\<lbrakk>\\<And>w. remove_weights (insert_weights s m1 w) = m1;\n        \\<And>w. remove_weights (insert_weights s m2 w) = m2\\<rbrakk>\n       \\<Longrightarrow> remove_weights (insert_weights s (Pool m1 m2) w) =\n                         Pool m1 m2", "then"], ["proof (chain)\npicking this:\n  remove_weights (insert_weights s m1 ?w) = m1\n  remove_weights (insert_weights s m2 ?w) = m2", "show ?case"], ["proof (prove)\nusing this:\n  remove_weights (insert_weights s m1 ?w) = m1\n  remove_weights (insert_weights s m2 ?w) = m2\n\ngoal (1 subgoal):\n 1. remove_weights (insert_weights s (Pool m1 m2) w) = Pool m1 m2", "unfolding insert_weights.simps remove_weights.simps"], ["proof (prove)\nusing this:\n  remove_weights (insert_weights s m1 ?w) = m1\n  remove_weights (insert_weights s m2 ?w) = m2\n\ngoal (1 subgoal):\n 1. Pool (remove_weights (insert_weights s m1 w))\n     (remove_weights\n       (insert_weights s m2\n         (if s then w else (\\<lambda>i. w (i + count_weights s m1))))) =\n    Pool m1 m2", "using Pool.IH"], ["proof (prove)\nusing this:\n  remove_weights (insert_weights s m1 ?w) = m1\n  remove_weights (insert_weights s m2 ?w) = m2\n  remove_weights (insert_weights s m1 ?w) = m1\n  remove_weights (insert_weights s m2 ?w) = m2\n\ngoal (1 subgoal):\n 1. Pool (remove_weights (insert_weights s m1 w))\n     (remove_weights\n       (insert_weights s m2\n         (if s then w else (\\<lambda>i. w (i + count_weights s m1))))) =\n    Pool m1 m2", "by blast"], ["proof (state)\nthis:\n  remove_weights (insert_weights s (Pool m1 m2) w) = Pool m1 m2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extract_insert_weights_shared: \nassumes \"x<count_weights True m\"\nand \"balanced_net m\"\nshows \"extract_weights True (insert_weights True m w) x = w x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract_weights True (insert_weights True m w) x = w x", "using assms"], ["proof (prove)\nusing this:\n  x < count_weights True m\n  balanced_net m\n\ngoal (1 subgoal):\n 1. extract_weights True (insert_weights True m w) x = w x", "proof (induction m arbitrary:w x)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x w xa.\n       \\<lbrakk>xa < count_weights True (Input x);\n        balanced_net (Input x)\\<rbrakk>\n       \\<Longrightarrow> extract_weights True\n                          (insert_weights True (Input x) w) xa =\n                         w xa\n 2. \\<And>x1a m w x.\n       \\<lbrakk>\\<And>w x.\n                   \\<lbrakk>x < count_weights True m;\n                    balanced_net m\\<rbrakk>\n                   \\<Longrightarrow> extract_weights True\n(insert_weights True m w) x =\n                                     w x;\n        x < count_weights True (Conv x1a m);\n        balanced_net (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> extract_weights True\n                          (insert_weights True (Conv x1a m) w) x =\n                         w x\n 3. \\<And>m1 m2 w x.\n       \\<lbrakk>\\<And>w x.\n                   \\<lbrakk>x < count_weights True m1;\n                    balanced_net m1\\<rbrakk>\n                   \\<Longrightarrow> extract_weights True\n(insert_weights True m1 w) x =\n                                     w x;\n        \\<And>w x.\n           \\<lbrakk>x < count_weights True m2; balanced_net m2\\<rbrakk>\n           \\<Longrightarrow> extract_weights True (insert_weights True m2 w)\n                              x =\n                             w x;\n        x < count_weights True (Pool m1 m2);\n        balanced_net (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> extract_weights True\n                          (insert_weights True (Pool m1 m2) w) x =\n                         w x", "case (Input x)"], ["proof (state)\nthis:\n  x < count_weights True (Input xa__)\n  balanced_net (Input xa__)\n\ngoal (3 subgoals):\n 1. \\<And>x w xa.\n       \\<lbrakk>xa < count_weights True (Input x);\n        balanced_net (Input x)\\<rbrakk>\n       \\<Longrightarrow> extract_weights True\n                          (insert_weights True (Input x) w) xa =\n                         w xa\n 2. \\<And>x1a m w x.\n       \\<lbrakk>\\<And>w x.\n                   \\<lbrakk>x < count_weights True m;\n                    balanced_net m\\<rbrakk>\n                   \\<Longrightarrow> extract_weights True\n(insert_weights True m w) x =\n                                     w x;\n        x < count_weights True (Conv x1a m);\n        balanced_net (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> extract_weights True\n                          (insert_weights True (Conv x1a m) w) x =\n                         w x\n 3. \\<And>m1 m2 w x.\n       \\<lbrakk>\\<And>w x.\n                   \\<lbrakk>x < count_weights True m1;\n                    balanced_net m1\\<rbrakk>\n                   \\<Longrightarrow> extract_weights True\n(insert_weights True m1 w) x =\n                                     w x;\n        \\<And>w x.\n           \\<lbrakk>x < count_weights True m2; balanced_net m2\\<rbrakk>\n           \\<Longrightarrow> extract_weights True (insert_weights True m2 w)\n                              x =\n                             w x;\n        x < count_weights True (Pool m1 m2);\n        balanced_net (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> extract_weights True\n                          (insert_weights True (Pool m1 m2) w) x =\n                         w x", "then"], ["proof (chain)\npicking this:\n  x < count_weights True (Input xa__)\n  balanced_net (Input xa__)", "show ?case"], ["proof (prove)\nusing this:\n  x < count_weights True (Input xa__)\n  balanced_net (Input xa__)\n\ngoal (1 subgoal):\n 1. extract_weights True (insert_weights True (Input xa__) w) x = w x", "by simp"], ["proof (state)\nthis:\n  extract_weights True (insert_weights True (Input xa__) w) x = w x\n\ngoal (2 subgoals):\n 1. \\<And>x1a m w x.\n       \\<lbrakk>\\<And>w x.\n                   \\<lbrakk>x < count_weights True m;\n                    balanced_net m\\<rbrakk>\n                   \\<Longrightarrow> extract_weights True\n(insert_weights True m w) x =\n                                     w x;\n        x < count_weights True (Conv x1a m);\n        balanced_net (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> extract_weights True\n                          (insert_weights True (Conv x1a m) w) x =\n                         w x\n 2. \\<And>m1 m2 w x.\n       \\<lbrakk>\\<And>w x.\n                   \\<lbrakk>x < count_weights True m1;\n                    balanced_net m1\\<rbrakk>\n                   \\<Longrightarrow> extract_weights True\n(insert_weights True m1 w) x =\n                                     w x;\n        \\<And>w x.\n           \\<lbrakk>x < count_weights True m2; balanced_net m2\\<rbrakk>\n           \\<Longrightarrow> extract_weights True (insert_weights True m2 w)\n                              x =\n                             w x;\n        x < count_weights True (Pool m1 m2);\n        balanced_net (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> extract_weights True\n                          (insert_weights True (Pool m1 m2) w) x =\n                         w x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1a m w x.\n       \\<lbrakk>\\<And>w x.\n                   \\<lbrakk>x < count_weights True m;\n                    balanced_net m\\<rbrakk>\n                   \\<Longrightarrow> extract_weights True\n(insert_weights True m w) x =\n                                     w x;\n        x < count_weights True (Conv x1a m);\n        balanced_net (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> extract_weights True\n                          (insert_weights True (Conv x1a m) w) x =\n                         w x\n 2. \\<And>m1 m2 w x.\n       \\<lbrakk>\\<And>w x.\n                   \\<lbrakk>x < count_weights True m1;\n                    balanced_net m1\\<rbrakk>\n                   \\<Longrightarrow> extract_weights True\n(insert_weights True m1 w) x =\n                                     w x;\n        \\<And>w x.\n           \\<lbrakk>x < count_weights True m2; balanced_net m2\\<rbrakk>\n           \\<Longrightarrow> extract_weights True (insert_weights True m2 w)\n                              x =\n                             w x;\n        x < count_weights True (Pool m1 m2);\n        balanced_net (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> extract_weights True\n                          (insert_weights True (Pool m1 m2) w) x =\n                         w x", "case (Conv r01 m)"], ["proof (state)\nthis:\n  \\<lbrakk>?x < count_weights True m; balanced_net m\\<rbrakk>\n  \\<Longrightarrow> extract_weights True (insert_weights True m ?w) ?x =\n                    ?w ?x\n  x < count_weights True (Conv r01 m)\n  balanced_net (Conv r01 m)\n\ngoal (2 subgoals):\n 1. \\<And>x1a m w x.\n       \\<lbrakk>\\<And>w x.\n                   \\<lbrakk>x < count_weights True m;\n                    balanced_net m\\<rbrakk>\n                   \\<Longrightarrow> extract_weights True\n(insert_weights True m w) x =\n                                     w x;\n        x < count_weights True (Conv x1a m);\n        balanced_net (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> extract_weights True\n                          (insert_weights True (Conv x1a m) w) x =\n                         w x\n 2. \\<And>m1 m2 w x.\n       \\<lbrakk>\\<And>w x.\n                   \\<lbrakk>x < count_weights True m1;\n                    balanced_net m1\\<rbrakk>\n                   \\<Longrightarrow> extract_weights True\n(insert_weights True m1 w) x =\n                                     w x;\n        \\<And>w x.\n           \\<lbrakk>x < count_weights True m2; balanced_net m2\\<rbrakk>\n           \\<Longrightarrow> extract_weights True (insert_weights True m2 w)\n                              x =\n                             w x;\n        x < count_weights True (Pool m1 m2);\n        balanced_net (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> extract_weights True\n                          (insert_weights True (Pool m1 m2) w) x =\n                         w x", "obtain r0 r1 where \"r01 = (r0,r1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r0 r1. r01 = (r0, r1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  r01 = (r0, r1)\n\ngoal (2 subgoals):\n 1. \\<And>x1a m w x.\n       \\<lbrakk>\\<And>w x.\n                   \\<lbrakk>x < count_weights True m;\n                    balanced_net m\\<rbrakk>\n                   \\<Longrightarrow> extract_weights True\n(insert_weights True m w) x =\n                                     w x;\n        x < count_weights True (Conv x1a m);\n        balanced_net (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> extract_weights True\n                          (insert_weights True (Conv x1a m) w) x =\n                         w x\n 2. \\<And>m1 m2 w x.\n       \\<lbrakk>\\<And>w x.\n                   \\<lbrakk>x < count_weights True m1;\n                    balanced_net m1\\<rbrakk>\n                   \\<Longrightarrow> extract_weights True\n(insert_weights True m1 w) x =\n                                     w x;\n        \\<And>w x.\n           \\<lbrakk>x < count_weights True m2; balanced_net m2\\<rbrakk>\n           \\<Longrightarrow> extract_weights True (insert_weights True m2 w)\n                              x =\n                             w x;\n        x < count_weights True (Pool m1 m2);\n        balanced_net (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> extract_weights True\n                          (insert_weights True (Pool m1 m2) w) x =\n                         w x", "then"], ["proof (chain)\npicking this:\n  r01 = (r0, r1)", "show ?case"], ["proof (prove)\nusing this:\n  r01 = (r0, r1)\n\ngoal (1 subgoal):\n 1. extract_weights True (insert_weights True (Conv r01 m) w) x = w x", "unfolding \\<open>r01 = (r0,r1)\\<close> insert_weights.simps extract_weights.simps"], ["proof (prove)\nusing this:\n  (r0, r1) = (r0, r1)\n\ngoal (1 subgoal):\n 1. (if x < dim_row (extract_matrix w r0 r1) *\n            dim_col (extract_matrix w r0 r1)\n     then flatten_matrix (extract_matrix w r0 r1) x\n     else extract_weights True\n           (insert_weights True m (\\<lambda>i. w (i + r0 * r1)))\n           (x -\n            dim_row (extract_matrix w r0 r1) *\n            dim_col (extract_matrix w r0 r1))) =\n    w x", "apply (cases \"x < dim_row (extract_matrix w r0 r1) * dim_col (extract_matrix w r0 r1)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(r0, r1) = (r0, r1);\n     x < dim_row (extract_matrix w r0 r1) *\n         dim_col (extract_matrix w r0 r1)\\<rbrakk>\n    \\<Longrightarrow> (if x < dim_row (extract_matrix w r0 r1) *\n                              dim_col (extract_matrix w r0 r1)\n                       then flatten_matrix (extract_matrix w r0 r1) x\n                       else extract_weights True\n                             (insert_weights True m\n                               (\\<lambda>i. w (i + r0 * r1)))\n                             (x -\n                              dim_row (extract_matrix w r0 r1) *\n                              dim_col (extract_matrix w r0 r1))) =\n                      w x\n 2. \\<lbrakk>(r0, r1) = (r0, r1);\n     \\<not> x < dim_row (extract_matrix w r0 r1) *\n                dim_col (extract_matrix w r0 r1)\\<rbrakk>\n    \\<Longrightarrow> (if x < dim_row (extract_matrix w r0 r1) *\n                              dim_col (extract_matrix w r0 r1)\n                       then flatten_matrix (extract_matrix w r0 r1) x\n                       else extract_weights True\n                             (insert_weights True m\n                               (\\<lambda>i. w (i + r0 * r1)))\n                             (x -\n                              dim_row (extract_matrix w r0 r1) *\n                              dim_col (extract_matrix w r0 r1))) =\n                      w x", "apply (auto simp add: dim_extract_matrix(1) dim_extract_matrix(2) flatten_matrix_extract_matrix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x < r0 * r1 \\<Longrightarrow>\n    extract_weights True\n     (insert_weights True m (\\<lambda>i. w (i + r0 * r1))) (x - r0 * r1) =\n    w x", "using Conv.IH[of _ \"\\<lambda>i. w (i + r0 * r1)\"] Conv.prems(1) Conv.prems(2) \\<open>r01 = (r0, r1)\\<close> balanced_net.cases"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x < count_weights True m; balanced_net m\\<rbrakk>\n  \\<Longrightarrow> extract_weights True\n                     (insert_weights True m (\\<lambda>a. w (a + r0 * r1)))\n                     ?x =\n                    w (?x + r0 * r1)\n  x < count_weights True (Conv r01 m)\n  balanced_net (Conv r01 m)\n  r01 = (r0, r1)\n  \\<lbrakk>balanced_net ?a; \\<And>M. ?a = Input M \\<Longrightarrow> ?P;\n   \\<And>m A.\n      \\<lbrakk>?a = Conv A m; balanced_net m\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>m1 m2.\n      \\<lbrakk>?a = Pool m1 m2; balanced_net m1; balanced_net m2;\n       count_weights True m1 = count_weights True m2\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<not> x < r0 * r1 \\<Longrightarrow>\n    extract_weights True\n     (insert_weights True m (\\<lambda>i. w (i + r0 * r1))) (x - r0 * r1) =\n    w x", "by force"], ["proof (state)\nthis:\n  extract_weights True (insert_weights True (Conv r01 m) w) x = w x\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 w x.\n       \\<lbrakk>\\<And>w x.\n                   \\<lbrakk>x < count_weights True m1;\n                    balanced_net m1\\<rbrakk>\n                   \\<Longrightarrow> extract_weights True\n(insert_weights True m1 w) x =\n                                     w x;\n        \\<And>w x.\n           \\<lbrakk>x < count_weights True m2; balanced_net m2\\<rbrakk>\n           \\<Longrightarrow> extract_weights True (insert_weights True m2 w)\n                              x =\n                             w x;\n        x < count_weights True (Pool m1 m2);\n        balanced_net (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> extract_weights True\n                          (insert_weights True (Pool m1 m2) w) x =\n                         w x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m1 m2 w x.\n       \\<lbrakk>\\<And>w x.\n                   \\<lbrakk>x < count_weights True m1;\n                    balanced_net m1\\<rbrakk>\n                   \\<Longrightarrow> extract_weights True\n(insert_weights True m1 w) x =\n                                     w x;\n        \\<And>w x.\n           \\<lbrakk>x < count_weights True m2; balanced_net m2\\<rbrakk>\n           \\<Longrightarrow> extract_weights True (insert_weights True m2 w)\n                              x =\n                             w x;\n        x < count_weights True (Pool m1 m2);\n        balanced_net (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> extract_weights True\n                          (insert_weights True (Pool m1 m2) w) x =\n                         w x", "case (Pool m1 m2)"], ["proof (state)\nthis:\n  \\<lbrakk>?x < count_weights True m1; balanced_net m1\\<rbrakk>\n  \\<Longrightarrow> extract_weights True (insert_weights True m1 ?w) ?x =\n                    ?w ?x\n  \\<lbrakk>?x < count_weights True m2; balanced_net m2\\<rbrakk>\n  \\<Longrightarrow> extract_weights True (insert_weights True m2 ?w) ?x =\n                    ?w ?x\n  x < count_weights True (Pool m1 m2)\n  balanced_net (Pool m1 m2)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 w x.\n       \\<lbrakk>\\<And>w x.\n                   \\<lbrakk>x < count_weights True m1;\n                    balanced_net m1\\<rbrakk>\n                   \\<Longrightarrow> extract_weights True\n(insert_weights True m1 w) x =\n                                     w x;\n        \\<And>w x.\n           \\<lbrakk>x < count_weights True m2; balanced_net m2\\<rbrakk>\n           \\<Longrightarrow> extract_weights True (insert_weights True m2 w)\n                              x =\n                             w x;\n        x < count_weights True (Pool m1 m2);\n        balanced_net (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> extract_weights True\n                          (insert_weights True (Pool m1 m2) w) x =\n                         w x", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x < count_weights True m1; balanced_net m1\\<rbrakk>\n  \\<Longrightarrow> extract_weights True (insert_weights True m1 ?w) ?x =\n                    ?w ?x\n  \\<lbrakk>?x < count_weights True m2; balanced_net m2\\<rbrakk>\n  \\<Longrightarrow> extract_weights True (insert_weights True m2 ?w) ?x =\n                    ?w ?x\n  x < count_weights True (Pool m1 m2)\n  balanced_net (Pool m1 m2)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x < count_weights True m1; balanced_net m1\\<rbrakk>\n  \\<Longrightarrow> extract_weights True (insert_weights True m1 ?w) ?x =\n                    ?w ?x\n  \\<lbrakk>?x < count_weights True m2; balanced_net m2\\<rbrakk>\n  \\<Longrightarrow> extract_weights True (insert_weights True m2 ?w) ?x =\n                    ?w ?x\n  x < count_weights True (Pool m1 m2)\n  balanced_net (Pool m1 m2)\n\ngoal (1 subgoal):\n 1. extract_weights True (insert_weights True (Pool m1 m2) w) x = w x", "unfolding insert_weights.simps extract_weights.simps  remove_insert_weights"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x < count_weights True m1; balanced_net m1\\<rbrakk>\n  \\<Longrightarrow> extract_weights True (insert_weights True m1 ?w) ?x =\n                    ?w ?x\n  \\<lbrakk>?x < count_weights True m2; balanced_net m2\\<rbrakk>\n  \\<Longrightarrow> extract_weights True (insert_weights True m2 ?w) ?x =\n                    ?w ?x\n  x < count_weights True (Pool m1 m2)\n  balanced_net (Pool m1 m2)\n\ngoal (1 subgoal):\n 1. (if x < count_weights True m1\n     then extract_weights True (insert_weights True m1 w) x\n     else extract_weights True\n           (insert_weights True m2\n             (if True then w\n              else (\\<lambda>i. w (i + count_weights True m1))))\n           (x - count_weights True m1)) =\n    w x", "apply (cases \"x < count_weights True m1\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x w.\n                \\<lbrakk>x < count_weights True m1; balanced_net m1\\<rbrakk>\n                \\<Longrightarrow> extract_weights True\n                                   (insert_weights True m1 w) x =\n                                  w x;\n     \\<And>x w.\n        \\<lbrakk>x < count_weights True m2; balanced_net m2\\<rbrakk>\n        \\<Longrightarrow> extract_weights True (insert_weights True m2 w)\n                           x =\n                          w x;\n     x < count_weights True (Pool m1 m2); balanced_net (Pool m1 m2);\n     x < count_weights True m1\\<rbrakk>\n    \\<Longrightarrow> (if x < count_weights True m1\n                       then extract_weights True (insert_weights True m1 w)\n                             x\n                       else extract_weights True\n                             (insert_weights True m2\n                               (if True then w\n                                else (\\<lambda>i.\n   w (i + count_weights True m1))))\n                             (x - count_weights True m1)) =\n                      w x\n 2. \\<lbrakk>\\<And>x w.\n                \\<lbrakk>x < count_weights True m1; balanced_net m1\\<rbrakk>\n                \\<Longrightarrow> extract_weights True\n                                   (insert_weights True m1 w) x =\n                                  w x;\n     \\<And>x w.\n        \\<lbrakk>x < count_weights True m2; balanced_net m2\\<rbrakk>\n        \\<Longrightarrow> extract_weights True (insert_weights True m2 w)\n                           x =\n                          w x;\n     x < count_weights True (Pool m1 m2); balanced_net (Pool m1 m2);\n     \\<not> x < count_weights True m1\\<rbrakk>\n    \\<Longrightarrow> (if x < count_weights True m1\n                       then extract_weights True (insert_weights True m1 w)\n                             x\n                       else extract_weights True\n                             (insert_weights True m2\n                               (if True then w\n                                else (\\<lambda>i.\n   w (i + count_weights True m1))))\n                             (x - count_weights True m1)) =\n                      w x", "apply (metis balanced_net.simps convnet.distinct(5) convnet.inject(3) count_weights.simps(1) not_less_zero)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x w.\n                \\<lbrakk>x < count_weights True m1; balanced_net m1\\<rbrakk>\n                \\<Longrightarrow> extract_weights True\n                                   (insert_weights True m1 w) x =\n                                  w x;\n     \\<And>x w.\n        \\<lbrakk>x < count_weights True m2; balanced_net m2\\<rbrakk>\n        \\<Longrightarrow> extract_weights True (insert_weights True m2 w)\n                           x =\n                          w x;\n     x < count_weights True (Pool m1 m2); balanced_net (Pool m1 m2);\n     \\<not> x < count_weights True m1\\<rbrakk>\n    \\<Longrightarrow> (if x < count_weights True m1\n                       then extract_weights True (insert_weights True m1 w)\n                             x\n                       else extract_weights True\n                             (insert_weights True m2\n                               (if True then w\n                                else (\\<lambda>i.\n   w (i + count_weights True m1))))\n                             (x - count_weights True m1)) =\n                      w x", "by (metis (no_types, lifting) balanced_net.simps convnet.distinct(5) convnet.inject(3) count_weights.simps(1) count_weights.simps(3) less_max_iff_disj not_less_zero)"], ["proof (state)\nthis:\n  extract_weights True (insert_weights True (Pool m1 m2) w) x = w x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma shared_weight_net_insert_weights: \"balanced_net m \\<Longrightarrow> shared_weight_net (insert_weights True m w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. balanced_net m \\<Longrightarrow>\n    shared_weight_net (insert_weights True m w)", "proof (induction m arbitrary:w)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x w.\n       balanced_net (Input x) \\<Longrightarrow>\n       shared_weight_net (insert_weights True (Input x) w)\n 2. \\<And>x1a m w.\n       \\<lbrakk>\\<And>w.\n                   balanced_net m \\<Longrightarrow>\n                   shared_weight_net (insert_weights True m w);\n        balanced_net (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> shared_weight_net\n                          (insert_weights True (Conv x1a m) w)\n 3. \\<And>m1 m2 w.\n       \\<lbrakk>\\<And>w.\n                   balanced_net m1 \\<Longrightarrow>\n                   shared_weight_net (insert_weights True m1 w);\n        \\<And>w.\n           balanced_net m2 \\<Longrightarrow>\n           shared_weight_net (insert_weights True m2 w);\n        balanced_net (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> shared_weight_net\n                          (insert_weights True (Pool m1 m2) w)", "case (Input x)"], ["proof (state)\nthis:\n  balanced_net (Input x)\n\ngoal (3 subgoals):\n 1. \\<And>x w.\n       balanced_net (Input x) \\<Longrightarrow>\n       shared_weight_net (insert_weights True (Input x) w)\n 2. \\<And>x1a m w.\n       \\<lbrakk>\\<And>w.\n                   balanced_net m \\<Longrightarrow>\n                   shared_weight_net (insert_weights True m w);\n        balanced_net (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> shared_weight_net\n                          (insert_weights True (Conv x1a m) w)\n 3. \\<And>m1 m2 w.\n       \\<lbrakk>\\<And>w.\n                   balanced_net m1 \\<Longrightarrow>\n                   shared_weight_net (insert_weights True m1 w);\n        \\<And>w.\n           balanced_net m2 \\<Longrightarrow>\n           shared_weight_net (insert_weights True m2 w);\n        balanced_net (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> shared_weight_net\n                          (insert_weights True (Pool m1 m2) w)", "then"], ["proof (chain)\npicking this:\n  balanced_net (Input x)", "show ?case"], ["proof (prove)\nusing this:\n  balanced_net (Input x)\n\ngoal (1 subgoal):\n 1. shared_weight_net (insert_weights True (Input x) w)", "using insert_weights.simps balanced_net.simps shared_weight_net.simps"], ["proof (prove)\nusing this:\n  balanced_net (Input x)\n  insert_weights ?shared (Input ?M) ?w = Input ?M\n  insert_weights ?shared (Conv (?r0.0, ?r1.0) ?m) ?w =\n  Conv (extract_matrix ?w ?r0.0 ?r1.0)\n   (insert_weights ?shared ?m (\\<lambda>i. ?w (i + ?r0.0 * ?r1.0)))\n  insert_weights ?shared (Pool ?m1.0 ?m2.0) ?w =\n  Pool (insert_weights ?shared ?m1.0 ?w)\n   (insert_weights ?shared ?m2.0\n     (if ?shared then ?w\n      else (\\<lambda>i. ?w (i + count_weights ?shared ?m1.0))))\n  balanced_net ?a =\n  ((\\<exists>M. ?a = Input M) \\<or>\n   (\\<exists>m A. ?a = Conv A m \\<and> balanced_net m) \\<or>\n   (\\<exists>m1 m2.\n       ?a = Pool m1 m2 \\<and>\n       balanced_net m1 \\<and>\n       balanced_net m2 \\<and>\n       count_weights True m1 = count_weights True m2))\n  shared_weight_net ?a =\n  ((\\<exists>M. ?a = Input M) \\<or>\n   (\\<exists>m A. ?a = Conv A m \\<and> shared_weight_net m) \\<or>\n   (\\<exists>m1 m2.\n       ?a = Pool m1 m2 \\<and>\n       shared_weight_net m1 \\<and>\n       shared_weight_net m2 \\<and>\n       count_weights True (remove_weights m1) =\n       count_weights True (remove_weights m2) \\<and>\n       (\\<forall>x<count_weights True (remove_weights m1).\n           extract_weights True m1 x = extract_weights True m2 x)))\n\ngoal (1 subgoal):\n 1. shared_weight_net (insert_weights True (Input x) w)", "by metis"], ["proof (state)\nthis:\n  shared_weight_net (insert_weights True (Input x) w)\n\ngoal (2 subgoals):\n 1. \\<And>x1a m w.\n       \\<lbrakk>\\<And>w.\n                   balanced_net m \\<Longrightarrow>\n                   shared_weight_net (insert_weights True m w);\n        balanced_net (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> shared_weight_net\n                          (insert_weights True (Conv x1a m) w)\n 2. \\<And>m1 m2 w.\n       \\<lbrakk>\\<And>w.\n                   balanced_net m1 \\<Longrightarrow>\n                   shared_weight_net (insert_weights True m1 w);\n        \\<And>w.\n           balanced_net m2 \\<Longrightarrow>\n           shared_weight_net (insert_weights True m2 w);\n        balanced_net (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> shared_weight_net\n                          (insert_weights True (Pool m1 m2) w)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1a m w.\n       \\<lbrakk>\\<And>w.\n                   balanced_net m \\<Longrightarrow>\n                   shared_weight_net (insert_weights True m w);\n        balanced_net (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> shared_weight_net\n                          (insert_weights True (Conv x1a m) w)\n 2. \\<And>m1 m2 w.\n       \\<lbrakk>\\<And>w.\n                   balanced_net m1 \\<Longrightarrow>\n                   shared_weight_net (insert_weights True m1 w);\n        \\<And>w.\n           balanced_net m2 \\<Longrightarrow>\n           shared_weight_net (insert_weights True m2 w);\n        balanced_net (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> shared_weight_net\n                          (insert_weights True (Pool m1 m2) w)", "case (Conv r01 m)"], ["proof (state)\nthis:\n  balanced_net m \\<Longrightarrow>\n  shared_weight_net (insert_weights True m ?w)\n  balanced_net (Conv r01 m)\n\ngoal (2 subgoals):\n 1. \\<And>x1a m w.\n       \\<lbrakk>\\<And>w.\n                   balanced_net m \\<Longrightarrow>\n                   shared_weight_net (insert_weights True m w);\n        balanced_net (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> shared_weight_net\n                          (insert_weights True (Conv x1a m) w)\n 2. \\<And>m1 m2 w.\n       \\<lbrakk>\\<And>w.\n                   balanced_net m1 \\<Longrightarrow>\n                   shared_weight_net (insert_weights True m1 w);\n        \\<And>w.\n           balanced_net m2 \\<Longrightarrow>\n           shared_weight_net (insert_weights True m2 w);\n        balanced_net (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> shared_weight_net\n                          (insert_weights True (Pool m1 m2) w)", "then"], ["proof (chain)\npicking this:\n  balanced_net m \\<Longrightarrow>\n  shared_weight_net (insert_weights True m ?w)\n  balanced_net (Conv r01 m)", "obtain r0 r1 where \"r01 = (r0,r1)\""], ["proof (prove)\nusing this:\n  balanced_net m \\<Longrightarrow>\n  shared_weight_net (insert_weights True m ?w)\n  balanced_net (Conv r01 m)\n\ngoal (1 subgoal):\n 1. (\\<And>r0 r1. r01 = (r0, r1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  r01 = (r0, r1)\n\ngoal (2 subgoals):\n 1. \\<And>x1a m w.\n       \\<lbrakk>\\<And>w.\n                   balanced_net m \\<Longrightarrow>\n                   shared_weight_net (insert_weights True m w);\n        balanced_net (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> shared_weight_net\n                          (insert_weights True (Conv x1a m) w)\n 2. \\<And>m1 m2 w.\n       \\<lbrakk>\\<And>w.\n                   balanced_net m1 \\<Longrightarrow>\n                   shared_weight_net (insert_weights True m1 w);\n        \\<And>w.\n           balanced_net m2 \\<Longrightarrow>\n           shared_weight_net (insert_weights True m2 w);\n        balanced_net (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> shared_weight_net\n                          (insert_weights True (Pool m1 m2) w)", "then"], ["proof (chain)\npicking this:\n  r01 = (r0, r1)", "show ?case"], ["proof (prove)\nusing this:\n  r01 = (r0, r1)\n\ngoal (1 subgoal):\n 1. shared_weight_net (insert_weights True (Conv r01 m) w)", "unfolding \\<open>r01 = (r0,r1)\\<close> insert_weights.simps"], ["proof (prove)\nusing this:\n  (r0, r1) = (r0, r1)\n\ngoal (1 subgoal):\n 1. shared_weight_net\n     (Conv (extract_matrix w r0 r1)\n       (insert_weights True m (\\<lambda>i. w (i + r0 * r1))))", "by (metis Conv.IH Conv.prems balanced_net.simps convnet.distinct(1) convnet.distinct(5) convnet.inject(2) shared_weight_net_Conv)"], ["proof (state)\nthis:\n  shared_weight_net (insert_weights True (Conv r01 m) w)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 w.\n       \\<lbrakk>\\<And>w.\n                   balanced_net m1 \\<Longrightarrow>\n                   shared_weight_net (insert_weights True m1 w);\n        \\<And>w.\n           balanced_net m2 \\<Longrightarrow>\n           shared_weight_net (insert_weights True m2 w);\n        balanced_net (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> shared_weight_net\n                          (insert_weights True (Pool m1 m2) w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m1 m2 w.\n       \\<lbrakk>\\<And>w.\n                   balanced_net m1 \\<Longrightarrow>\n                   shared_weight_net (insert_weights True m1 w);\n        \\<And>w.\n           balanced_net m2 \\<Longrightarrow>\n           shared_weight_net (insert_weights True m2 w);\n        balanced_net (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> shared_weight_net\n                          (insert_weights True (Pool m1 m2) w)", "case (Pool m1 m2)"], ["proof (state)\nthis:\n  balanced_net m1 \\<Longrightarrow>\n  shared_weight_net (insert_weights True m1 ?w)\n  balanced_net m2 \\<Longrightarrow>\n  shared_weight_net (insert_weights True m2 ?w)\n  balanced_net (Pool m1 m2)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 w.\n       \\<lbrakk>\\<And>w.\n                   balanced_net m1 \\<Longrightarrow>\n                   shared_weight_net (insert_weights True m1 w);\n        \\<And>w.\n           balanced_net m2 \\<Longrightarrow>\n           shared_weight_net (insert_weights True m2 w);\n        balanced_net (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> shared_weight_net\n                          (insert_weights True (Pool m1 m2) w)", "have \"balanced_net m1\" \"balanced_net m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. balanced_net m1 &&& balanced_net m2", "using Pool.prems balanced_net.simps"], ["proof (prove)\nusing this:\n  balanced_net (Pool m1 m2)\n  balanced_net ?a =\n  ((\\<exists>M. ?a = Input M) \\<or>\n   (\\<exists>m A. ?a = Conv A m \\<and> balanced_net m) \\<or>\n   (\\<exists>m1 m2.\n       ?a = Pool m1 m2 \\<and>\n       balanced_net m1 \\<and>\n       balanced_net m2 \\<and>\n       count_weights True m1 = count_weights True m2))\n\ngoal (1 subgoal):\n 1. balanced_net m1 &&& balanced_net m2", "by blast+"], ["proof (state)\nthis:\n  balanced_net m1\n  balanced_net m2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 w.\n       \\<lbrakk>\\<And>w.\n                   balanced_net m1 \\<Longrightarrow>\n                   shared_weight_net (insert_weights True m1 w);\n        \\<And>w.\n           balanced_net m2 \\<Longrightarrow>\n           shared_weight_net (insert_weights True m2 w);\n        balanced_net (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> shared_weight_net\n                          (insert_weights True (Pool m1 m2) w)", "have \"\\<And>x. x < count_weights True m1 \\<Longrightarrow>\n         extract_weights True (insert_weights True m1 w) x = extract_weights True (insert_weights True m2 w) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < count_weights True m1 \\<Longrightarrow>\n       extract_weights True (insert_weights True m1 w) x =\n       extract_weights True (insert_weights True m2 w) x", "using extract_insert_weights_shared"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x < count_weights True ?m; balanced_net ?m\\<rbrakk>\n  \\<Longrightarrow> extract_weights True (insert_weights True ?m ?w) ?x =\n                    ?w ?x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < count_weights True m1 \\<Longrightarrow>\n       extract_weights True (insert_weights True m1 w) x =\n       extract_weights True (insert_weights True m2 w) x", "by (metis Pool.prems balanced_net.simps convnet.distinct(3) convnet.distinct(5) convnet.inject(3))"], ["proof (state)\nthis:\n  ?x < count_weights True m1 \\<Longrightarrow>\n  extract_weights True (insert_weights True m1 w) ?x =\n  extract_weights True (insert_weights True m2 w) ?x\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 w.\n       \\<lbrakk>\\<And>w.\n                   balanced_net m1 \\<Longrightarrow>\n                   shared_weight_net (insert_weights True m1 w);\n        \\<And>w.\n           balanced_net m2 \\<Longrightarrow>\n           shared_weight_net (insert_weights True m2 w);\n        balanced_net (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> shared_weight_net\n                          (insert_weights True (Pool m1 m2) w)", "then"], ["proof (chain)\npicking this:\n  ?x < count_weights True m1 \\<Longrightarrow>\n  extract_weights True (insert_weights True m1 w) ?x =\n  extract_weights True (insert_weights True m2 w) ?x", "show ?case"], ["proof (prove)\nusing this:\n  ?x < count_weights True m1 \\<Longrightarrow>\n  extract_weights True (insert_weights True m1 w) ?x =\n  extract_weights True (insert_weights True m2 w) ?x\n\ngoal (1 subgoal):\n 1. shared_weight_net (insert_weights True (Pool m1 m2) w)", "unfolding insert_weights.simps"], ["proof (prove)\nusing this:\n  ?x < count_weights True m1 \\<Longrightarrow>\n  extract_weights True (insert_weights True m1 w) ?x =\n  extract_weights True (insert_weights True m2 w) ?x\n\ngoal (1 subgoal):\n 1. shared_weight_net\n     (Pool (insert_weights True m1 w)\n       (insert_weights True m2\n         (if True then w else (\\<lambda>i. w (i + count_weights True m1)))))", "using Pool(1)[of w] Pool(2)[of w]"], ["proof (prove)\nusing this:\n  ?x < count_weights True m1 \\<Longrightarrow>\n  extract_weights True (insert_weights True m1 w) ?x =\n  extract_weights True (insert_weights True m2 w) ?x\n  balanced_net m1 \\<Longrightarrow>\n  shared_weight_net (insert_weights True m1 w)\n  balanced_net m2 \\<Longrightarrow>\n  shared_weight_net (insert_weights True m2 w)\n\ngoal (1 subgoal):\n 1. shared_weight_net\n     (Pool (insert_weights True m1 w)\n       (insert_weights True m2\n         (if True then w else (\\<lambda>i. w (i + count_weights True m1)))))", "by (metis Pool.prems balanced_net.simps convnet.distinct(3) convnet.distinct(5) convnet.inject(3) remove_insert_weights shared_weight_net_Pool)"], ["proof (state)\nthis:\n  shared_weight_net (insert_weights True (Pool m1 m2) w)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_valid_index: \"finite {is. is \\<lhd> ds}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {is. is \\<lhd> ds}", "proof (induction ds)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite {is. is \\<lhd> []}\n 2. \\<And>a ds.\n       finite {is. is \\<lhd> ds} \\<Longrightarrow>\n       finite {is. is \\<lhd> a # ds}", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. finite {is. is \\<lhd> []}\n 2. \\<And>a ds.\n       finite {is. is \\<lhd> ds} \\<Longrightarrow>\n       finite {is. is \\<lhd> a # ds}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {is. is \\<lhd> []}", "by (metis List.finite_set finite_subset length_0_conv list.set_intros(1) mem_Collect_eq subsetI valid_index_length)"], ["proof (state)\nthis:\n  finite {is. is \\<lhd> []}\n\ngoal (1 subgoal):\n 1. \\<And>a ds.\n       finite {is. is \\<lhd> ds} \\<Longrightarrow>\n       finite {is. is \\<lhd> a # ds}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ds.\n       finite {is. is \\<lhd> ds} \\<Longrightarrow>\n       finite {is. is \\<lhd> a # ds}", "case (Cons d ds)"], ["proof (state)\nthis:\n  finite {is. is \\<lhd> ds}\n\ngoal (1 subgoal):\n 1. \\<And>a ds.\n       finite {is. is \\<lhd> ds} \\<Longrightarrow>\n       finite {is. is \\<lhd> a # ds}", "have \"{is. is \\<lhd> d # ds} \\<subseteq> (\\<Union>i<d. {i # is |is. is \\<lhd> ds})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {is. is \\<lhd> d # ds}\n    \\<subseteq> (\\<Union>i<d. {i # is |is. is \\<lhd> ds})", "proof (rule subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {is. is \\<lhd> d # ds} \\<Longrightarrow>\n       x \\<in> (\\<Union>i<d. {i # is |is. is \\<lhd> ds})", "fix \"is\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {is. is \\<lhd> d # ds} \\<Longrightarrow>\n       x \\<in> (\\<Union>i<d. {i # is |is. is \\<lhd> ds})", "assume \"is \\<in> {is. is \\<lhd> d # ds}\""], ["proof (state)\nthis:\n  is \\<in> {is. is \\<lhd> d # ds}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {is. is \\<lhd> d # ds} \\<Longrightarrow>\n       x \\<in> (\\<Union>i<d. {i # is |is. is \\<lhd> ds})", "then"], ["proof (chain)\npicking this:\n  is \\<in> {is. is \\<lhd> d # ds}", "have \"is \\<lhd> d # ds\""], ["proof (prove)\nusing this:\n  is \\<in> {is. is \\<lhd> d # ds}\n\ngoal (1 subgoal):\n 1. is \\<lhd> d # ds", "by auto"], ["proof (state)\nthis:\n  is \\<lhd> d # ds\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {is. is \\<lhd> d # ds} \\<Longrightarrow>\n       x \\<in> (\\<Union>i<d. {i # is |is. is \\<lhd> ds})", "then"], ["proof (chain)\npicking this:\n  is \\<lhd> d # ds", "obtain i is' where \"is = i # is'\""], ["proof (prove)\nusing this:\n  is \\<lhd> d # ds\n\ngoal (1 subgoal):\n 1. (\\<And>i is'. is = i # is' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  is = i # is'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {is. is \\<lhd> d # ds} \\<Longrightarrow>\n       x \\<in> (\\<Union>i<d. {i # is |is. is \\<lhd> ds})", "then"], ["proof (chain)\npicking this:\n  is = i # is'", "have \"i<d\""], ["proof (prove)\nusing this:\n  is = i # is'\n\ngoal (1 subgoal):\n 1. i < d", "using \\<open>is \\<lhd> d # ds\\<close>"], ["proof (prove)\nusing this:\n  is = i # is'\n  is \\<lhd> d # ds\n\ngoal (1 subgoal):\n 1. i < d", "by blast"], ["proof (state)\nthis:\n  i < d\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {is. is \\<lhd> d # ds} \\<Longrightarrow>\n       x \\<in> (\\<Union>i<d. {i # is |is. is \\<lhd> ds})", "have \"is' \\<lhd> ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is' \\<lhd> ds", "using \\<open>is = i # is'\\<close> \\<open>is \\<lhd> d # ds\\<close>"], ["proof (prove)\nusing this:\n  is = i # is'\n  is \\<lhd> d # ds\n\ngoal (1 subgoal):\n 1. is' \\<lhd> ds", "by blast"], ["proof (state)\nthis:\n  is' \\<lhd> ds\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {is. is \\<lhd> d # ds} \\<Longrightarrow>\n       x \\<in> (\\<Union>i<d. {i # is |is. is \\<lhd> ds})", "have \"is \\<in> {i # is |is. is \\<lhd> ds}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is \\<in> {i # is |is. is \\<lhd> ds}", "by (simp add: \\<open>is = i # is'\\<close> \\<open>is' \\<lhd> ds\\<close>)"], ["proof (state)\nthis:\n  is \\<in> {i # is |is. is \\<lhd> ds}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {is. is \\<lhd> d # ds} \\<Longrightarrow>\n       x \\<in> (\\<Union>i<d. {i # is |is. is \\<lhd> ds})", "then"], ["proof (chain)\npicking this:\n  is \\<in> {i # is |is. is \\<lhd> ds}", "show \"is \\<in> (\\<Union>i<d. {i # is |is. is \\<lhd> ds})\""], ["proof (prove)\nusing this:\n  is \\<in> {i # is |is. is \\<lhd> ds}\n\ngoal (1 subgoal):\n 1. is \\<in> (\\<Union>i<d. {i # is |is. is \\<lhd> ds})", "using \\<open>i < d\\<close>"], ["proof (prove)\nusing this:\n  is \\<in> {i # is |is. is \\<lhd> ds}\n  i < d\n\ngoal (1 subgoal):\n 1. is \\<in> (\\<Union>i<d. {i # is |is. is \\<lhd> ds})", "by blast"], ["proof (state)\nthis:\n  is \\<in> (\\<Union>i<d. {i # is |is. is \\<lhd> ds})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {is. is \\<lhd> d # ds}\n  \\<subseteq> (\\<Union>i<d. {i # is |is. is \\<lhd> ds})\n\ngoal (1 subgoal):\n 1. \\<And>a ds.\n       finite {is. is \\<lhd> ds} \\<Longrightarrow>\n       finite {is. is \\<lhd> a # ds}", "moreover"], ["proof (state)\nthis:\n  {is. is \\<lhd> d # ds}\n  \\<subseteq> (\\<Union>i<d. {i # is |is. is \\<lhd> ds})\n\ngoal (1 subgoal):\n 1. \\<And>a ds.\n       finite {is. is \\<lhd> ds} \\<Longrightarrow>\n       finite {is. is \\<lhd> a # ds}", "have \"\\<And>i. finite {i # is |is. is \\<lhd> ds}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. finite {i # is |is. is \\<lhd> ds}", "by (simp add: Cons.IH)"], ["proof (state)\nthis:\n  finite {?i # is |is. is \\<lhd> ds}\n\ngoal (1 subgoal):\n 1. \\<And>a ds.\n       finite {is. is \\<lhd> ds} \\<Longrightarrow>\n       finite {is. is \\<lhd> a # ds}", "ultimately"], ["proof (chain)\npicking this:\n  {is. is \\<lhd> d # ds}\n  \\<subseteq> (\\<Union>i<d. {i # is |is. is \\<lhd> ds})\n  finite {?i # is |is. is \\<lhd> ds}", "show \"finite {is. is \\<lhd> d # ds}\""], ["proof (prove)\nusing this:\n  {is. is \\<lhd> d # ds}\n  \\<subseteq> (\\<Union>i<d. {i # is |is. is \\<lhd> ds})\n  finite {?i # is |is. is \\<lhd> ds}\n\ngoal (1 subgoal):\n 1. finite {is. is \\<lhd> d # ds}", "by (simp add: finite_subset)"], ["proof (state)\nthis:\n  finite {is. is \\<lhd> d # ds}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma setsum_valid_index_split:\n\"(\\<Sum>is | is \\<lhd> ds1 @ ds2. f is) = (\\<Sum>is1 | is1 \\<lhd> ds1. (\\<Sum>is2 | is2 \\<lhd> ds2. f (is1 @ is2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>is | is \\<lhd> ds1 @ ds2. f is) =\n    (\\<Sum>is1 | is1 \\<lhd> ds1. \\<Sum>is2 | is2 \\<lhd> ds2. f (is1 @ is2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>is | is \\<lhd> ds1 @ ds2. f is) =\n    (\\<Sum>is1 | is1 \\<lhd> ds1. \\<Sum>is2 | is2 \\<lhd> ds2. f (is1 @ is2))", "have 1:\"((\\<lambda>(is1, is2). is1 @ is2) ` ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2})) = {is. is \\<lhd> ds1 @ ds2}\" (is \"?A = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(is1, is2). is1 @ is2) `\n    ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2}) =\n    {is. is \\<lhd> ds1 @ ds2}", "proof (rule subset_antisym; rule subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>(is1, is2). is1 @ is2) `\n               ({is1. is1 \\<lhd> ds1} \\<times>\n                {is2. is2 \\<lhd> ds2}) \\<Longrightarrow>\n       x \\<in> {is. is \\<lhd> ds1 @ ds2}\n 2. \\<And>x.\n       x \\<in> {is. is \\<lhd> ds1 @ ds2} \\<Longrightarrow>\n       x \\<in> (\\<lambda>(is1, is2). is1 @ is2) `\n               ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2})", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>(is1, is2). is1 @ is2) `\n               ({is1. is1 \\<lhd> ds1} \\<times>\n                {is2. is2 \\<lhd> ds2}) \\<Longrightarrow>\n       x \\<in> {is. is \\<lhd> ds1 @ ds2}\n 2. \\<And>x.\n       x \\<in> {is. is \\<lhd> ds1 @ ds2} \\<Longrightarrow>\n       x \\<in> (\\<lambda>(is1, is2). is1 @ is2) `\n               ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2})", "assume \"x \\<in> ?A\""], ["proof (state)\nthis:\n  x \\<in> (\\<lambda>(is1, is2). is1 @ is2) `\n          ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2})\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<lambda>(is1, is2). is1 @ is2) `\n               ({is1. is1 \\<lhd> ds1} \\<times>\n                {is2. is2 \\<lhd> ds2}) \\<Longrightarrow>\n       x \\<in> {is. is \\<lhd> ds1 @ ds2}\n 2. \\<And>x.\n       x \\<in> {is. is \\<lhd> ds1 @ ds2} \\<Longrightarrow>\n       x \\<in> (\\<lambda>(is1, is2). is1 @ is2) `\n               ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2})", "then"], ["proof (chain)\npicking this:\n  x \\<in> (\\<lambda>(is1, is2). is1 @ is2) `\n          ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2})", "show \"x \\<in> ?B\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<lambda>(is1, is2). is1 @ is2) `\n          ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2})\n\ngoal (1 subgoal):\n 1. x \\<in> {is. is \\<lhd> ds1 @ ds2}", "using valid_index_append"], ["proof (prove)\nusing this:\n  x \\<in> (\\<lambda>(is1, is2). is1 @ is2) `\n          ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2})\n  \\<lbrakk>?is1.0 \\<lhd> ?ds1.0; ?is2.0 \\<lhd> ?ds2.0\\<rbrakk>\n  \\<Longrightarrow> ?is1.0 @ ?is2.0 \\<lhd> ?ds1.0 @ ?ds2.0\n\ngoal (1 subgoal):\n 1. x \\<in> {is. is \\<lhd> ds1 @ ds2}", "by auto"], ["proof (state)\nthis:\n  x \\<in> {is. is \\<lhd> ds1 @ ds2}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {is. is \\<lhd> ds1 @ ds2} \\<Longrightarrow>\n       x \\<in> (\\<lambda>(is1, is2). is1 @ is2) `\n               ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {is. is \\<lhd> ds1 @ ds2} \\<Longrightarrow>\n       x \\<in> (\\<lambda>(is1, is2). is1 @ is2) `\n               ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2})", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {is. is \\<lhd> ds1 @ ds2} \\<Longrightarrow>\n       x \\<in> (\\<lambda>(is1, is2). is1 @ is2) `\n               ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2})", "assume \"x \\<in> ?B\""], ["proof (state)\nthis:\n  x \\<in> {is. is \\<lhd> ds1 @ ds2}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {is. is \\<lhd> ds1 @ ds2} \\<Longrightarrow>\n       x \\<in> (\\<lambda>(is1, is2). is1 @ is2) `\n               ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2})", "then"], ["proof (chain)\npicking this:\n  x \\<in> {is. is \\<lhd> ds1 @ ds2}", "have \"x \\<lhd> ds1 @ ds2\""], ["proof (prove)\nusing this:\n  x \\<in> {is. is \\<lhd> ds1 @ ds2}\n\ngoal (1 subgoal):\n 1. x \\<lhd> ds1 @ ds2", "by auto"], ["proof (state)\nthis:\n  x \\<lhd> ds1 @ ds2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {is. is \\<lhd> ds1 @ ds2} \\<Longrightarrow>\n       x \\<in> (\\<lambda>(is1, is2). is1 @ is2) `\n               ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2})", "then"], ["proof (chain)\npicking this:\n  x \\<lhd> ds1 @ ds2", "obtain x1 x2 where \"x = x1 @ x2\" \"x1 \\<lhd> ds1\" \"x2 \\<lhd> ds2\""], ["proof (prove)\nusing this:\n  x \\<lhd> ds1 @ ds2\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x = x1 @ x2; x1 \\<lhd> ds1; x2 \\<lhd> ds2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis valid_index_split)"], ["proof (state)\nthis:\n  x = x1 @ x2\n  x1 \\<lhd> ds1\n  x2 \\<lhd> ds2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {is. is \\<lhd> ds1 @ ds2} \\<Longrightarrow>\n       x \\<in> (\\<lambda>(is1, is2). is1 @ is2) `\n               ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2})", "then"], ["proof (chain)\npicking this:\n  x = x1 @ x2\n  x1 \\<lhd> ds1\n  x2 \\<lhd> ds2", "have \"(x1, x2) \\<in> ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2})\""], ["proof (prove)\nusing this:\n  x = x1 @ x2\n  x1 \\<lhd> ds1\n  x2 \\<lhd> ds2\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> {is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2}", "by auto"], ["proof (state)\nthis:\n  (x1, x2) \\<in> {is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {is. is \\<lhd> ds1 @ ds2} \\<Longrightarrow>\n       x \\<in> (\\<lambda>(is1, is2). is1 @ is2) `\n               ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2})", "then"], ["proof (chain)\npicking this:\n  (x1, x2) \\<in> {is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2}", "show \"x \\<in> ?A\""], ["proof (prove)\nusing this:\n  (x1, x2) \\<in> {is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2}\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>(is1, is2). is1 @ is2) `\n            ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2})", "using imageI \\<open>x = x1 @ x2\\<close>"], ["proof (prove)\nusing this:\n  (x1, x2) \\<in> {is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2}\n  ?x \\<in> ?A \\<Longrightarrow> ?f ?x \\<in> ?f ` ?A\n  x = x1 @ x2\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<lambda>(is1, is2). is1 @ is2) `\n            ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2})", "by blast"], ["proof (state)\nthis:\n  x \\<in> (\\<lambda>(is1, is2). is1 @ is2) `\n          ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>(is1, is2). is1 @ is2) `\n  ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2}) =\n  {is. is \\<lhd> ds1 @ ds2}\n\ngoal (1 subgoal):\n 1. (\\<Sum>is | is \\<lhd> ds1 @ ds2. f is) =\n    (\\<Sum>is1 | is1 \\<lhd> ds1. \\<Sum>is2 | is2 \\<lhd> ds2. f (is1 @ is2))", "have 2:\"inj_on (\\<lambda>(is1, is2). is1 @ is2) ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(is1, is2). is1 @ is2)\n     ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2})", "by (simp add: inj_on_def valid_index_length)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>(is1, is2). is1 @ is2)\n   ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2})\n\ngoal (1 subgoal):\n 1. (\\<Sum>is | is \\<lhd> ds1 @ ds2. f is) =\n    (\\<Sum>is1 | is1 \\<lhd> ds1. \\<Sum>is2 | is2 \\<lhd> ds2. f (is1 @ is2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>is | is \\<lhd> ds1 @ ds2. f is) =\n    (\\<Sum>is1 | is1 \\<lhd> ds1. \\<Sum>is2 | is2 \\<lhd> ds2. f (is1 @ is2))", "unfolding Groups_Big.comm_monoid_add_class.sum.cartesian_product[of \"\\<lambda>is1 is2. f (is1 @ is2)\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>is | is \\<lhd> ds1 @ ds2. f is) =\n    (\\<Sum>(is1, is2)\n           \\<in>{is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2}.\n       f (is1 @ is2))", "using Groups_Big.comm_monoid_add_class.sum.reindex[OF 2, of f] 1\n     \"2\" SigmaE prod.simps(2) sum.reindex_cong"], ["proof (prove)\nusing this:\n  sum f\n   ((\\<lambda>(is1, is2). is1 @ is2) `\n    ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2})) =\n  sum (f \\<circ> (\\<lambda>(is1, is2). is1 @ is2))\n   ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2})\n  (\\<lambda>(is1, is2). is1 @ is2) `\n  ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2}) =\n  {is. is \\<lhd> ds1 @ ds2}\n  inj_on (\\<lambda>(is1, is2). is1 @ is2)\n   ({is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2})\n  \\<lbrakk>?c \\<in> Sigma ?A ?B;\n   \\<And>x y.\n      \\<lbrakk>x \\<in> ?A; y \\<in> ?B x; ?c = (x, y)\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  (case (?x1.0, ?x2.0) of (x, xa) \\<Rightarrow> ?f x xa) = ?f ?x1.0 ?x2.0\n  \\<lbrakk>inj_on ?l ?B; ?A = ?l ` ?B;\n   \\<And>x. x \\<in> ?B \\<Longrightarrow> ?g (?l x) = ?h x\\<rbrakk>\n  \\<Longrightarrow> sum ?g ?A = sum ?h ?B\n\ngoal (1 subgoal):\n 1. (\\<Sum>is | is \\<lhd> ds1 @ ds2. f is) =\n    (\\<Sum>(is1, is2)\n           \\<in>{is1. is1 \\<lhd> ds1} \\<times> {is2. is2 \\<lhd> ds2}.\n       f (is1 @ is2))", "by (simp add: split_def)"], ["proof (state)\nthis:\n  (\\<Sum>is | is \\<lhd> ds1 @ ds2. f is) =\n  (\\<Sum>is1 | is1 \\<lhd> ds1. \\<Sum>is2 | is2 \\<lhd> ds2. f (is1 @ is2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prod_lessThan_split:\nfixes g :: \"nat \\<Rightarrow> real\" shows \"prod g {..<n+m} = prod g {..<n} * prod (\\<lambda>x. g (x+n)) {..<m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod g {..<n + m} = prod g {..<n} * (\\<Prod>x<m. g (x + n))", "using Groups_Big.comm_monoid_mult_class.prod.union_inter_neutral[of \"{..<n}\" \"{n..<n+m}\" g, unfolded ivl_disj_un_one(2)[OF le_add1], OF finite_lessThan finite_atLeastLessThan]"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>{..<n} \\<inter> {n..<n + m}. g x = 1 \\<Longrightarrow>\n  prod g {..<n + m} = prod g {..<n} * prod g {n..<n + m}\n\ngoal (1 subgoal):\n 1. prod g {..<n + m} = prod g {..<n} * (\\<Prod>x<m. g (x + n))", "by (metis (no_types) add.commute add.left_neutral atLeast0LessThan empty_iff ivl_disj_int_one(2) prod.shift_bounds_nat_ivl)"], ["", "(* This is a nice lemma, but never used to prove the Fundamental Theorem of Network Capacity: *)"], ["", "lemma evaluate_net_from_tensors:\nassumes \"valid_net' m\"\nand \"map dim_vec inputs = input_sizes m\"\nand \"j < output_size' m\"\nshows \"evaluate_net m inputs $ j\n  = (\\<Sum>is\\<in>{is. is \\<lhd> input_sizes m}. (\\<Prod>k<length inputs. inputs ! k $ (is!k)) * Tensor.lookup (tensors_from_net m $ j) is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evaluate_net m inputs $ j =\n    (\\<Sum>is | is \\<lhd> input_sizes m.\n       (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n       lookup (tensors_from_net m $ j) is)", "using assms"], ["proof (prove)\nusing this:\n  valid_net' m\n  map dim_vec inputs = input_sizes m\n  j < output_size' m\n\ngoal (1 subgoal):\n 1. evaluate_net m inputs $ j =\n    (\\<Sum>is | is \\<lhd> input_sizes m.\n       (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n       lookup (tensors_from_net m $ j) is)", "proof (induction m arbitrary:j \"is\" inputs)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x j inputs.\n       \\<lbrakk>valid_net' (Input x);\n        map dim_vec inputs = input_sizes (Input x);\n        j < output_size' (Input x)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Input x) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Input x).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Input x) $ j) is)\n 2. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 3. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "case (Input M)"], ["proof (state)\nthis:\n  valid_net' (Input M)\n  map dim_vec inputs = input_sizes (Input M)\n  j < output_size' (Input M)\n\ngoal (3 subgoals):\n 1. \\<And>x j inputs.\n       \\<lbrakk>valid_net' (Input x);\n        map dim_vec inputs = input_sizes (Input x);\n        j < output_size' (Input x)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Input x) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Input x).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Input x) $ j) is)\n 2. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 3. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "then"], ["proof (chain)\npicking this:\n  valid_net' (Input M)\n  map dim_vec inputs = input_sizes (Input M)\n  j < output_size' (Input M)", "have \"length inputs = 1\" \"input_sizes (Input M) = [M]\""], ["proof (prove)\nusing this:\n  valid_net' (Input M)\n  map dim_vec inputs = input_sizes (Input M)\n  j < output_size' (Input M)\n\ngoal (1 subgoal):\n 1. length inputs = 1 &&& input_sizes (Input M) = [M]", "by auto"], ["proof (state)\nthis:\n  length inputs = 1\n  input_sizes (Input M) = [M]\n\ngoal (3 subgoals):\n 1. \\<And>x j inputs.\n       \\<lbrakk>valid_net' (Input x);\n        map dim_vec inputs = input_sizes (Input x);\n        j < output_size' (Input x)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Input x) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Input x).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Input x) $ j) is)\n 2. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 3. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "{"], ["proof (state)\nthis:\n  length inputs = 1\n  input_sizes (Input M) = [M]\n\ngoal (3 subgoals):\n 1. \\<And>x j inputs.\n       \\<lbrakk>valid_net' (Input x);\n        map dim_vec inputs = input_sizes (Input x);\n        j < output_size' (Input x)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Input x) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Input x).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Input x) $ j) is)\n 2. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 3. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "fix \"is\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x j inputs.\n       \\<lbrakk>valid_net' (Input x);\n        map dim_vec inputs = input_sizes (Input x);\n        j < output_size' (Input x)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Input x) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Input x).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Input x) $ j) is)\n 2. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 3. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "assume \"is \\<lhd> input_sizes (Input M)\""], ["proof (state)\nthis:\n  is \\<lhd> input_sizes (Input M)\n\ngoal (3 subgoals):\n 1. \\<And>x j inputs.\n       \\<lbrakk>valid_net' (Input x);\n        map dim_vec inputs = input_sizes (Input x);\n        j < output_size' (Input x)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Input x) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Input x).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Input x) $ j) is)\n 2. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 3. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "then"], ["proof (chain)\npicking this:\n  is \\<lhd> input_sizes (Input M)", "have \"length is = 1\""], ["proof (prove)\nusing this:\n  is \\<lhd> input_sizes (Input M)\n\ngoal (1 subgoal):\n 1. length is = 1", "by (simp add: valid_index_length)"], ["proof (state)\nthis:\n  length is = 1\n\ngoal (3 subgoals):\n 1. \\<And>x j inputs.\n       \\<lbrakk>valid_net' (Input x);\n        map dim_vec inputs = input_sizes (Input x);\n        j < output_size' (Input x)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Input x) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Input x).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Input x) $ j) is)\n 2. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 3. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "then"], ["proof (chain)\npicking this:\n  length is = 1", "have \"is = [hd is]\""], ["proof (prove)\nusing this:\n  length is = 1\n\ngoal (1 subgoal):\n 1. is = [hd is]", "by (metis One_nat_def length_0_conv length_Suc_conv list.sel(1))"], ["proof (state)\nthis:\n  is = [hd is]\n\ngoal (3 subgoals):\n 1. \\<And>x j inputs.\n       \\<lbrakk>valid_net' (Input x);\n        map dim_vec inputs = input_sizes (Input x);\n        j < output_size' (Input x)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Input x) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Input x).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Input x) $ j) is)\n 2. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 3. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "then"], ["proof (chain)\npicking this:\n  is = [hd is]", "have \"Tensor.lookup (tensors_from_net (Input M) $ j) is = (if hd is=j then 1 else 0)\""], ["proof (prove)\nusing this:\n  is = [hd is]\n\ngoal (1 subgoal):\n 1. lookup (tensors_from_net (Input M) $ j) is =\n    (if hd is = j then 1 else 0)", "by (metis Input.prems(3) \\<open>input_sizes (Input M) = [M]\\<close> \\<open>is \\<lhd> input_sizes (Input M)\\<close> list.distinct(1)\n      lookup_unit_vec nth_Cons_0 output_size.simps(1) remove_weights.simps(1) tensors_from_net.simps(1) valid_indexE index_vec)"], ["proof (state)\nthis:\n  lookup (tensors_from_net (Input M) $ j) is = (if hd is = j then 1 else 0)\n\ngoal (3 subgoals):\n 1. \\<And>x j inputs.\n       \\<lbrakk>valid_net' (Input x);\n        map dim_vec inputs = input_sizes (Input x);\n        j < output_size' (Input x)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Input x) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Input x).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Input x) $ j) is)\n 2. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 3. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "then"], ["proof (chain)\npicking this:\n  lookup (tensors_from_net (Input M) $ j) is = (if hd is = j then 1 else 0)", "have \"(\\<Prod>k<length inputs. inputs ! k $ (is ! k)) * lookup (tensors_from_net (Input M) $ j) is =\n               (if is=[j] then (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) else 0)\""], ["proof (prove)\nusing this:\n  lookup (tensors_from_net (Input M) $ j) is = (if hd is = j then 1 else 0)\n\ngoal (1 subgoal):\n 1. (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n    lookup (tensors_from_net (Input M) $ j) is =\n    (if is = [j] then \\<Prod>k<length inputs. inputs ! k $ (is ! k) else 0)", "using \\<open>is = [hd is]\\<close>"], ["proof (prove)\nusing this:\n  lookup (tensors_from_net (Input M) $ j) is = (if hd is = j then 1 else 0)\n  is = [hd is]\n\ngoal (1 subgoal):\n 1. (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n    lookup (tensors_from_net (Input M) $ j) is =\n    (if is = [j] then \\<Prod>k<length inputs. inputs ! k $ (is ! k) else 0)", "by auto"], ["proof (state)\nthis:\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net (Input M) $ j) is =\n  (if is = [j] then \\<Prod>k<length inputs. inputs ! k $ (is ! k) else 0)\n\ngoal (3 subgoals):\n 1. \\<And>x j inputs.\n       \\<lbrakk>valid_net' (Input x);\n        map dim_vec inputs = input_sizes (Input x);\n        j < output_size' (Input x)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Input x) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Input x).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Input x) $ j) is)\n 2. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 3. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "}"], ["proof (state)\nthis:\n  ?is3 \\<lhd> input_sizes (Input M) \\<Longrightarrow>\n  (\\<Prod>k<length inputs. inputs ! k $ (?is3 ! k)) *\n  lookup (tensors_from_net (Input M) $ j) ?is3 =\n  (if ?is3 = [j] then \\<Prod>k<length inputs. inputs ! k $ (?is3 ! k)\n   else 0)\n\ngoal (3 subgoals):\n 1. \\<And>x j inputs.\n       \\<lbrakk>valid_net' (Input x);\n        map dim_vec inputs = input_sizes (Input x);\n        j < output_size' (Input x)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Input x) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Input x).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Input x) $ j) is)\n 2. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 3. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "then"], ["proof (chain)\npicking this:\n  ?is3 \\<lhd> input_sizes (Input M) \\<Longrightarrow>\n  (\\<Prod>k<length inputs. inputs ! k $ (?is3 ! k)) *\n  lookup (tensors_from_net (Input M) $ j) ?is3 =\n  (if ?is3 = [j] then \\<Prod>k<length inputs. inputs ! k $ (?is3 ! k)\n   else 0)", "have \"(\\<Sum>is | is \\<lhd> input_sizes (Input M). (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) * lookup (tensors_from_net (Input M) $ j) is)\n   = (\\<Sum>is | is \\<lhd> input_sizes (Input M). (if is=[j] then (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) else 0))\""], ["proof (prove)\nusing this:\n  ?is3 \\<lhd> input_sizes (Input M) \\<Longrightarrow>\n  (\\<Prod>k<length inputs. inputs ! k $ (?is3 ! k)) *\n  lookup (tensors_from_net (Input M) $ j) ?is3 =\n  (if ?is3 = [j] then \\<Prod>k<length inputs. inputs ! k $ (?is3 ! k)\n   else 0)\n\ngoal (1 subgoal):\n 1. (\\<Sum>is | is \\<lhd> input_sizes (Input M).\n       (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n       lookup (tensors_from_net (Input M) $ j) is) =\n    (\\<Sum>is | is \\<lhd> input_sizes (Input M).\n       if is = [j] then \\<Prod>k<length inputs. inputs ! k $ (is ! k)\n       else 0)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>is | is \\<lhd> input_sizes (Input M).\n     (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n     lookup (tensors_from_net (Input M) $ j) is) =\n  (\\<Sum>is | is \\<lhd> input_sizes (Input M).\n     if is = [j] then \\<Prod>k<length inputs. inputs ! k $ (is ! k) else 0)\n\ngoal (3 subgoals):\n 1. \\<And>x j inputs.\n       \\<lbrakk>valid_net' (Input x);\n        map dim_vec inputs = input_sizes (Input x);\n        j < output_size' (Input x)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Input x) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Input x).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Input x) $ j) is)\n 2. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 3. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "also"], ["proof (state)\nthis:\n  (\\<Sum>is | is \\<lhd> input_sizes (Input M).\n     (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n     lookup (tensors_from_net (Input M) $ j) is) =\n  (\\<Sum>is | is \\<lhd> input_sizes (Input M).\n     if is = [j] then \\<Prod>k<length inputs. inputs ! k $ (is ! k) else 0)\n\ngoal (3 subgoals):\n 1. \\<And>x j inputs.\n       \\<lbrakk>valid_net' (Input x);\n        map dim_vec inputs = input_sizes (Input x);\n        j < output_size' (Input x)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Input x) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Input x).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Input x) $ j) is)\n 2. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 3. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have \"(\\<Sum>is | is \\<lhd> input_sizes (Input M). (if is=[j] then (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) else 0))\n   = (\\<Prod>k<length inputs. inputs ! k $ ([j] ! k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>is | is \\<lhd> input_sizes (Input M).\n       if is = [j] then \\<Prod>k<length inputs. inputs ! k $ (is ! k)\n       else 0) =\n    (\\<Prod>k<length inputs. inputs ! k $ ([j] ! k))", "unfolding sum.delta[OF finite_valid_index]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if [j] \\<in> {is. is \\<lhd> input_sizes (Input M)}\n     then \\<Prod>k<length inputs. inputs ! k $ ([j] ! k) else 0) =\n    (\\<Prod>k<length inputs. inputs ! k $ ([j] ! k))", "using Input.prems(3) valid_index.Cons valid_index.Nil"], ["proof (prove)\nusing this:\n  j < output_size' (Input M)\n  \\<lbrakk>?is \\<lhd> ?ds; ?i < ?d\\<rbrakk>\n  \\<Longrightarrow> ?i # ?is \\<lhd> ?d # ?ds\n  [] \\<lhd> []\n\ngoal (1 subgoal):\n 1. (if [j] \\<in> {is. is \\<lhd> input_sizes (Input M)}\n     then \\<Prod>k<length inputs. inputs ! k $ ([j] ! k) else 0) =\n    (\\<Prod>k<length inputs. inputs ! k $ ([j] ! k))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>is | is \\<lhd> input_sizes (Input M).\n     if is = [j] then \\<Prod>k<length inputs. inputs ! k $ (is ! k)\n     else 0) =\n  (\\<Prod>k<length inputs. inputs ! k $ ([j] ! k))\n\ngoal (3 subgoals):\n 1. \\<And>x j inputs.\n       \\<lbrakk>valid_net' (Input x);\n        map dim_vec inputs = input_sizes (Input x);\n        j < output_size' (Input x)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Input x) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Input x).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Input x) $ j) is)\n 2. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 3. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "also"], ["proof (state)\nthis:\n  (\\<Sum>is | is \\<lhd> input_sizes (Input M).\n     if is = [j] then \\<Prod>k<length inputs. inputs ! k $ (is ! k)\n     else 0) =\n  (\\<Prod>k<length inputs. inputs ! k $ ([j] ! k))\n\ngoal (3 subgoals):\n 1. \\<And>x j inputs.\n       \\<lbrakk>valid_net' (Input x);\n        map dim_vec inputs = input_sizes (Input x);\n        j < output_size' (Input x)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Input x) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Input x).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Input x) $ j) is)\n 2. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 3. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have \"... = inputs ! 0 $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>k<length inputs. inputs ! k $ ([j] ! k)) = inputs ! 0 $ j", "using \\<open>length inputs = 1\\<close>"], ["proof (prove)\nusing this:\n  length inputs = 1\n\ngoal (1 subgoal):\n 1. (\\<Prod>k<length inputs. inputs ! k $ ([j] ! k)) = inputs ! 0 $ j", "by (simp add: prod.lessThan_Suc)"], ["proof (state)\nthis:\n  (\\<Prod>k<length inputs. inputs ! k $ ([j] ! k)) = inputs ! 0 $ j\n\ngoal (3 subgoals):\n 1. \\<And>x j inputs.\n       \\<lbrakk>valid_net' (Input x);\n        map dim_vec inputs = input_sizes (Input x);\n        j < output_size' (Input x)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Input x) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Input x).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Input x) $ j) is)\n 2. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 3. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "also"], ["proof (state)\nthis:\n  (\\<Prod>k<length inputs. inputs ! k $ ([j] ! k)) = inputs ! 0 $ j\n\ngoal (3 subgoals):\n 1. \\<And>x j inputs.\n       \\<lbrakk>valid_net' (Input x);\n        map dim_vec inputs = input_sizes (Input x);\n        j < output_size' (Input x)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Input x) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Input x).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Input x) $ j) is)\n 2. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 3. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have \"... = evaluate_net (Input M) inputs $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inputs ! 0 $ j = evaluate_net (Input M) inputs $ j", "unfolding evaluate_net.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. inputs ! 0 $ j = hd inputs $ j", "by (metis \\<open>length inputs = 1\\<close> hd_conv_nth list.size(3) zero_neq_one)"], ["proof (state)\nthis:\n  inputs ! 0 $ j = evaluate_net (Input M) inputs $ j\n\ngoal (3 subgoals):\n 1. \\<And>x j inputs.\n       \\<lbrakk>valid_net' (Input x);\n        map dim_vec inputs = input_sizes (Input x);\n        j < output_size' (Input x)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Input x) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Input x).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Input x) $ j) is)\n 2. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 3. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>is | is \\<lhd> input_sizes (Input M).\n     (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n     lookup (tensors_from_net (Input M) $ j) is) =\n  evaluate_net (Input M) inputs $ j", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Sum>is | is \\<lhd> input_sizes (Input M).\n     (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n     lookup (tensors_from_net (Input M) $ j) is) =\n  evaluate_net (Input M) inputs $ j\n\ngoal (1 subgoal):\n 1. evaluate_net (Input M) inputs $ j =\n    (\\<Sum>is | is \\<lhd> input_sizes (Input M).\n       (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n       lookup (tensors_from_net (Input M) $ j) is)", "by auto"], ["proof (state)\nthis:\n  evaluate_net (Input M) inputs $ j =\n  (\\<Sum>is | is \\<lhd> input_sizes (Input M).\n     (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n     lookup (tensors_from_net (Input M) $ j) is)\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 2. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 2. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "case (Conv A m j)"], ["proof (state)\nthis:\n  \\<lbrakk>valid_net' m; map dim_vec ?inputs = input_sizes m;\n   ?j < output_size' m\\<rbrakk>\n  \\<Longrightarrow> evaluate_net m ?inputs $ ?j =\n                    (\\<Sum>is | is \\<lhd> input_sizes m.\n                       (\\<Prod>k<length ?inputs. ?inputs ! k $ (is ! k)) *\n                       lookup (tensors_from_net m $ ?j) is)\n  valid_net' (Conv A m)\n  map dim_vec inputs = input_sizes (Conv A m)\n  j < output_size' (Conv A m)\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 2. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have \"j < dim_row A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < dim_row A", "using Conv.prems(3)"], ["proof (prove)\nusing this:\n  j < output_size' (Conv A m)\n\ngoal (1 subgoal):\n 1. j < dim_row A", "by auto"], ["proof (state)\nthis:\n  j < dim_row A\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 2. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have 0:\"\\<And>is. is \\<lhd> input_sizes (Conv A m) \\<Longrightarrow>\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) * lookup (tensors_from_net (Conv A m) $ j) is =\n  (\\<Sum>i = 0..<dim_vec (tensors_from_net m). row A j $ i * ((\\<Prod>k<length inputs. inputs ! k $ (is ! k)) * lookup (tensors_from_net m $ i) is))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> input_sizes (Conv A m) \\<Longrightarrow>\n       (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n       lookup (tensors_from_net (Conv A m) $ j) is =\n       (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n           row A j $ i *\n           ((\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n            lookup (tensors_from_net m $ i) is))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> input_sizes (Conv A m) \\<Longrightarrow>\n       (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n       lookup (tensors_from_net (Conv A m) $ j) is =\n       (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n           row A j $ i *\n           ((\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n            lookup (tensors_from_net m $ i) is))", "fix \"is\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> input_sizes (Conv A m) \\<Longrightarrow>\n       (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n       lookup (tensors_from_net (Conv A m) $ j) is =\n       (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n           row A j $ i *\n           ((\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n            lookup (tensors_from_net m $ i) is))", "assume \"is \\<lhd> input_sizes (Conv A m)\""], ["proof (state)\nthis:\n  is \\<lhd> input_sizes (Conv A m)\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> input_sizes (Conv A m) \\<Longrightarrow>\n       (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n       lookup (tensors_from_net (Conv A m) $ j) is =\n       (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n           row A j $ i *\n           ((\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n            lookup (tensors_from_net m $ i) is))", "then"], ["proof (chain)\npicking this:\n  is \\<lhd> input_sizes (Conv A m)", "have \"is \\<lhd> input_sizes m\""], ["proof (prove)\nusing this:\n  is \\<lhd> input_sizes (Conv A m)\n\ngoal (1 subgoal):\n 1. is \\<lhd> input_sizes m", "by simp"], ["proof (state)\nthis:\n  is \\<lhd> input_sizes m\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> input_sizes (Conv A m) \\<Longrightarrow>\n       (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n       lookup (tensors_from_net (Conv A m) $ j) is =\n       (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n           row A j $ i *\n           ((\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n            lookup (tensors_from_net m $ i) is))", "have 0:\"lookup (tensors_from_net (Conv A m) $ j) is =\n          (\\<Sum>i = 0..<dim_vec (tensors_from_net m). row A j $ i * lookup (tensors_from_net m $ i) is)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (tensors_from_net (Conv A m) $ j) is =\n    (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n        row A j $ i * lookup (tensors_from_net m $ i) is)", "unfolding tensors_from_net.simps mat_tensorlist_mult_def index_vec[OF \\<open>j < dim_row A\\<close>]\n      lookup_tensor_from_lookup[OF \\<open>is \\<lhd> input_sizes m\\<close>] index_mult_mat_vec[OF \\<open>j < dim_row A\\<close>] scalar_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec\n                    (map_vec (\\<lambda>T. lookup T is)\n                      (tensors_from_net m)).\n        row A j $ i *\n        map_vec (\\<lambda>T. lookup T is) (tensors_from_net m) $ i) =\n    (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n        row A j $ i * lookup (tensors_from_net m $ i) is)", "using index_map_vec"], ["proof (prove)\nusing this:\n  ?i < dim_vec ?v \\<Longrightarrow> map_vec ?f ?v $ ?i = ?f (?v $ ?i)\n  dim_vec (map_vec ?f ?v) = dim_vec ?v\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec\n                    (map_vec (\\<lambda>T. lookup T is)\n                      (tensors_from_net m)).\n        row A j $ i *\n        map_vec (\\<lambda>T. lookup T is) (tensors_from_net m) $ i) =\n    (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n        row A j $ i * lookup (tensors_from_net m $ i) is)", "by auto"], ["proof (state)\nthis:\n  lookup (tensors_from_net (Conv A m) $ j) is =\n  (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n      row A j $ i * lookup (tensors_from_net m $ i) is)\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> input_sizes (Conv A m) \\<Longrightarrow>\n       (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n       lookup (tensors_from_net (Conv A m) $ j) is =\n       (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n           row A j $ i *\n           ((\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n            lookup (tensors_from_net m $ i) is))", "show \"(\\<Prod>k<length inputs. inputs ! k $ (is ! k)) * lookup (tensors_from_net (Conv A m) $ j) is\n      = (\\<Sum>i = 0..<dim_vec (tensors_from_net m). row A j $ i * ((\\<Prod>k<length inputs. inputs ! k $ (is ! k)) * lookup (tensors_from_net m $ i) is))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n    lookup (tensors_from_net (Conv A m) $ j) is =\n    (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n        row A j $ i *\n        ((\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n         lookup (tensors_from_net m $ i) is))", "unfolding 0 sum_distrib_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n = 0..<dim_vec (tensors_from_net m).\n        (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n        (row A j $ n * lookup (tensors_from_net m $ n) is)) =\n    (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n        row A j $ i *\n        ((\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n         lookup (tensors_from_net m $ i) is))", "by (simp add: semiring_normalization_rules(19))"], ["proof (state)\nthis:\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net (Conv A m) $ j) is =\n  (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n      row A j $ i *\n      ((\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n       lookup (tensors_from_net m $ i) is))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?is \\<lhd> input_sizes (Conv A m) \\<Longrightarrow>\n  (\\<Prod>k<length inputs. inputs ! k $ (?is ! k)) *\n  lookup (tensors_from_net (Conv A m) $ j) ?is =\n  (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n      row A j $ i *\n      ((\\<Prod>k<length inputs. inputs ! k $ (?is ! k)) *\n       lookup (tensors_from_net m $ i) ?is))\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 2. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have \"valid_net' m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_net' m", "by (metis Conv.prems(1) convnet.distinct(1) convnet.distinct(5) convnet.inject(2) remove_weights.simps(2) valid_net.simps)"], ["proof (state)\nthis:\n  valid_net' m\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 2. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have \"map dim_vec inputs = input_sizes m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map dim_vec inputs = input_sizes m", "by (simp add: Conv.prems(2))"], ["proof (state)\nthis:\n  map dim_vec inputs = input_sizes m\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 2. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have \"output_size' m = dim_vec (tensors_from_net m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. output_size' m = dim_vec (tensors_from_net m)", "by (simp add: \\<open>valid_net' m\\<close> output_size_correct_tensors)"], ["proof (state)\nthis:\n  output_size' m = dim_vec (tensors_from_net m)\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 2. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have 1:\"\\<And>i. i<dim_vec (tensors_from_net m) \\<Longrightarrow> (\\<Sum>is | is \\<lhd> input_sizes (Conv A m). ((\\<Prod>k<length inputs. inputs ! k $ (is ! k)) * lookup (tensors_from_net m $ i) is)) = evaluate_net m inputs $ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec (tensors_from_net m) \\<Longrightarrow>\n       (\\<Sum>is | is \\<lhd> input_sizes (Conv A m).\n          (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n          lookup (tensors_from_net m $ i) is) =\n       evaluate_net m inputs $ i", "unfolding input_sizes.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec (tensors_from_net m) \\<Longrightarrow>\n       (\\<Sum>is | is \\<lhd> input_sizes m.\n          (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n          lookup (tensors_from_net m $ i) is) =\n       evaluate_net m inputs $ i", "using Conv.IH \\<open>valid_net' m\\<close> \\<open>map dim_vec inputs = input_sizes m\\<close> \\<open>output_size' m = dim_vec (tensors_from_net m)\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_net' m; map dim_vec ?inputs = input_sizes m;\n   ?j < output_size' m\\<rbrakk>\n  \\<Longrightarrow> evaluate_net m ?inputs $ ?j =\n                    (\\<Sum>is | is \\<lhd> input_sizes m.\n                       (\\<Prod>k<length ?inputs. ?inputs ! k $ (is ! k)) *\n                       lookup (tensors_from_net m $ ?j) is)\n  valid_net' m\n  map dim_vec inputs = input_sizes m\n  output_size' m = dim_vec (tensors_from_net m)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < dim_vec (tensors_from_net m) \\<Longrightarrow>\n       (\\<Sum>is | is \\<lhd> input_sizes m.\n          (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n          lookup (tensors_from_net m $ i) is) =\n       evaluate_net m inputs $ i", "by simp"], ["proof (state)\nthis:\n  ?i < dim_vec (tensors_from_net m) \\<Longrightarrow>\n  (\\<Sum>is | is \\<lhd> input_sizes (Conv A m).\n     (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n     lookup (tensors_from_net m $ ?i) is) =\n  evaluate_net m inputs $ ?i\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 2. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have \"(\\<Sum>is | is \\<lhd> input_sizes (Conv A m). (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) * lookup (tensors_from_net (Conv A m) $ j) is)\n    = (\\<Sum>i = 0..<dim_vec (tensors_from_net m). (\\<Sum>is | is \\<lhd> input_sizes (Conv A m).  row A j $ i *  ((\\<Prod>k<length inputs. inputs ! k $ (is ! k)) * lookup (tensors_from_net m $ i) is)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>is | is \\<lhd> input_sizes (Conv A m).\n       (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n       lookup (tensors_from_net (Conv A m) $ j) is) =\n    (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n        \\<Sum>is | is \\<lhd> input_sizes (Conv A m).\n          row A j $ i *\n          ((\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n           lookup (tensors_from_net m $ i) is))", "using Groups_Big.comm_monoid_add_class.sum.swap 0"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>?A. sum (?g i) ?B) = (\\<Sum>j\\<in>?B. \\<Sum>i\\<in>?A. ?g i j)\n  ?is \\<lhd> input_sizes (Conv A m) \\<Longrightarrow>\n  (\\<Prod>k<length inputs. inputs ! k $ (?is ! k)) *\n  lookup (tensors_from_net (Conv A m) $ j) ?is =\n  (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n      row A j $ i *\n      ((\\<Prod>k<length inputs. inputs ! k $ (?is ! k)) *\n       lookup (tensors_from_net m $ i) ?is))\n\ngoal (1 subgoal):\n 1. (\\<Sum>is | is \\<lhd> input_sizes (Conv A m).\n       (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n       lookup (tensors_from_net (Conv A m) $ j) is) =\n    (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n        \\<Sum>is | is \\<lhd> input_sizes (Conv A m).\n          row A j $ i *\n          ((\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n           lookup (tensors_from_net m $ i) is))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>is | is \\<lhd> input_sizes (Conv A m).\n     (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n     lookup (tensors_from_net (Conv A m) $ j) is) =\n  (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n      \\<Sum>is | is \\<lhd> input_sizes (Conv A m).\n        row A j $ i *\n        ((\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n         lookup (tensors_from_net m $ i) is))\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 2. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "also"], ["proof (state)\nthis:\n  (\\<Sum>is | is \\<lhd> input_sizes (Conv A m).\n     (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n     lookup (tensors_from_net (Conv A m) $ j) is) =\n  (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n      \\<Sum>is | is \\<lhd> input_sizes (Conv A m).\n        row A j $ i *\n        ((\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n         lookup (tensors_from_net m $ i) is))\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 2. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have \"... = (\\<Sum>i = 0..<dim_vec (tensors_from_net m). row A j $ i * (\\<Sum>is | is \\<lhd> input_sizes (Conv A m). ((\\<Prod>k<length inputs. inputs ! k $ (is ! k)) * lookup (tensors_from_net m $ i) is)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n        \\<Sum>is | is \\<lhd> input_sizes (Conv A m).\n          row A j $ i *\n          ((\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n           lookup (tensors_from_net m $ i) is)) =\n    (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n        row A j $ i *\n        (\\<Sum>is | is \\<lhd> input_sizes (Conv A m).\n           (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n           lookup (tensors_from_net m $ i) is))", "by (simp add: sum_distrib_left)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n      \\<Sum>is | is \\<lhd> input_sizes (Conv A m).\n        row A j $ i *\n        ((\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n         lookup (tensors_from_net m $ i) is)) =\n  (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n      row A j $ i *\n      (\\<Sum>is | is \\<lhd> input_sizes (Conv A m).\n         (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n         lookup (tensors_from_net m $ i) is))\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 2. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n      \\<Sum>is | is \\<lhd> input_sizes (Conv A m).\n        row A j $ i *\n        ((\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n         lookup (tensors_from_net m $ i) is)) =\n  (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n      row A j $ i *\n      (\\<Sum>is | is \\<lhd> input_sizes (Conv A m).\n         (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n         lookup (tensors_from_net m $ i) is))\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 2. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have \"... = (\\<Sum>i = 0..<dim_vec (tensors_from_net m). row A j $ i * evaluate_net m inputs $ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n        row A j $ i *\n        (\\<Sum>is | is \\<lhd> input_sizes (Conv A m).\n           (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n           lookup (tensors_from_net m $ i) is)) =\n    (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n        row A j $ i * evaluate_net m inputs $ i)", "using 1"], ["proof (prove)\nusing this:\n  ?i < dim_vec (tensors_from_net m) \\<Longrightarrow>\n  (\\<Sum>is | is \\<lhd> input_sizes (Conv A m).\n     (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n     lookup (tensors_from_net m $ ?i) is) =\n  evaluate_net m inputs $ ?i\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n        row A j $ i *\n        (\\<Sum>is | is \\<lhd> input_sizes (Conv A m).\n           (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n           lookup (tensors_from_net m $ i) is)) =\n    (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n        row A j $ i * evaluate_net m inputs $ i)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n      row A j $ i *\n      (\\<Sum>is | is \\<lhd> input_sizes (Conv A m).\n         (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n         lookup (tensors_from_net m $ i) is)) =\n  (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n      row A j $ i * evaluate_net m inputs $ i)\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 2. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n      row A j $ i *\n      (\\<Sum>is | is \\<lhd> input_sizes (Conv A m).\n         (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n         lookup (tensors_from_net m $ i) is)) =\n  (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n      row A j $ i * evaluate_net m inputs $ i)\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 2. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have \"... = row A j \\<bullet> evaluate_net m inputs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n        row A j $ i * evaluate_net m inputs $ i) =\n    row A j \\<bullet> evaluate_net m inputs", "by (metis (full_types) \\<open>map dim_vec inputs = input_sizes m\\<close> \\<open>output_size' m = dim_vec (tensors_from_net m)\\<close>\n    \\<open>valid_net' m\\<close> output_size_correct scalar_prod_def)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n      row A j $ i * evaluate_net m inputs $ i) =\n  row A j \\<bullet> evaluate_net m inputs\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 2. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<dim_vec (tensors_from_net m).\n      row A j $ i * evaluate_net m inputs $ i) =\n  row A j \\<bullet> evaluate_net m inputs\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 2. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have \"... = (A *\\<^sub>v evaluate_net m inputs) $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row A j \\<bullet> evaluate_net m inputs =\n    (A *\\<^sub>v evaluate_net m inputs) $ j", "by (simp add: \\<open>j < dim_row A\\<close>)"], ["proof (state)\nthis:\n  row A j \\<bullet> evaluate_net m inputs =\n  (A *\\<^sub>v evaluate_net m inputs) $ j\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 2. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "also"], ["proof (state)\nthis:\n  row A j \\<bullet> evaluate_net m inputs =\n  (A *\\<^sub>v evaluate_net m inputs) $ j\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 2. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have \"... = evaluate_net (Conv A m) inputs $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A *\\<^sub>v evaluate_net m inputs) $ j =\n    evaluate_net (Conv A m) inputs $ j", "by simp"], ["proof (state)\nthis:\n  (A *\\<^sub>v evaluate_net m inputs) $ j =\n  evaluate_net (Conv A m) inputs $ j\n\ngoal (2 subgoals):\n 1. \\<And>x1a m j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m;\n                    map dim_vec inputs = input_sizes m;\n                    j < output_size' m\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m $ j) is);\n        valid_net' (Conv x1a m);\n        map dim_vec inputs = input_sizes (Conv x1a m);\n        j < output_size' (Conv x1a m)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Conv x1a m) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Conv x1a m).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Conv x1a m) $ j) is)\n 2. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>is | is \\<lhd> input_sizes (Conv A m).\n     (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n     lookup (tensors_from_net (Conv A m) $ j) is) =\n  evaluate_net (Conv A m) inputs $ j", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Sum>is | is \\<lhd> input_sizes (Conv A m).\n     (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n     lookup (tensors_from_net (Conv A m) $ j) is) =\n  evaluate_net (Conv A m) inputs $ j\n\ngoal (1 subgoal):\n 1. evaluate_net (Conv A m) inputs $ j =\n    (\\<Sum>is | is \\<lhd> input_sizes (Conv A m).\n       (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n       lookup (tensors_from_net (Conv A m) $ j) is)", "by auto"], ["proof (state)\nthis:\n  evaluate_net (Conv A m) inputs $ j =\n  (\\<Sum>is | is \\<lhd> input_sizes (Conv A m).\n     (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n     lookup (tensors_from_net (Conv A m) $ j) is)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "case (Pool m1 m2 j)"], ["proof (state)\nthis:\n  \\<lbrakk>valid_net' m1; map dim_vec ?inputs = input_sizes m1;\n   ?j < output_size' m1\\<rbrakk>\n  \\<Longrightarrow> evaluate_net m1 ?inputs $ ?j =\n                    (\\<Sum>is | is \\<lhd> input_sizes m1.\n                       (\\<Prod>k<length ?inputs. ?inputs ! k $ (is ! k)) *\n                       lookup (tensors_from_net m1 $ ?j) is)\n  \\<lbrakk>valid_net' m2; map dim_vec ?inputs = input_sizes m2;\n   ?j < output_size' m2\\<rbrakk>\n  \\<Longrightarrow> evaluate_net m2 ?inputs $ ?j =\n                    (\\<Sum>is | is \\<lhd> input_sizes m2.\n                       (\\<Prod>k<length ?inputs. ?inputs ! k $ (is ! k)) *\n                       lookup (tensors_from_net m2 $ ?j) is)\n  valid_net' (Pool m1 m2)\n  map dim_vec inputs = input_sizes (Pool m1 m2)\n  j < output_size' (Pool m1 m2)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have \"valid_net' m1\" \"valid_net' m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_net' m1 &&& valid_net' m2", "by (metis Pool.prems(1) convnet.distinct(3) convnet.inject(3) convnet.simps(9) remove_weights.simps(3) valid_net.simps)+"], ["proof (state)\nthis:\n  valid_net' m1\n  valid_net' m2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have \"j < output_size' m2\" \"j < output_size' m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < output_size' m2 &&& j < output_size' m1", "apply (metis Pool.prems(1) Pool.prems(3) convnet.distinct(3) convnet.inject(3) convnet.simps(9)\n    output_size.simps(3) remove_weights.simps(3) valid_net.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < output_size' m1", "using Pool.prems"], ["proof (prove)\nusing this:\n  valid_net' (Pool m1 m2)\n  map dim_vec inputs = input_sizes (Pool m1 m2)\n  j < output_size' (Pool m1 m2)\n\ngoal (1 subgoal):\n 1. j < output_size' m1", "by auto"], ["proof (state)\nthis:\n  j < output_size' m2\n  j < output_size' m1\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "then"], ["proof (chain)\npicking this:\n  j < output_size' m2\n  j < output_size' m1", "have \"j < dim_vec (tensors_from_net m1)\" \"j < dim_vec (tensors_from_net m2)\""], ["proof (prove)\nusing this:\n  j < output_size' m2\n  j < output_size' m1\n\ngoal (1 subgoal):\n 1. j < dim_vec (tensors_from_net m1) &&& j < dim_vec (tensors_from_net m2)", "by (simp_all add: \\<open>valid_net' m1\\<close> \\<open>valid_net' m2\\<close> output_size_correct_tensors)"], ["proof (state)\nthis:\n  j < dim_vec (tensors_from_net m1)\n  j < dim_vec (tensors_from_net m2)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "define inputs1 where \"inputs1 = take (length (input_sizes m1)) inputs\""], ["proof (state)\nthis:\n  inputs1 = take (length (input_sizes m1)) inputs\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "define inputs2 where \"inputs2 = drop (length (input_sizes m1)) inputs\""], ["proof (state)\nthis:\n  inputs2 = drop (length (input_sizes m1)) inputs\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have \"map dim_vec inputs1 = input_sizes m1\" \"map dim_vec inputs2 = input_sizes m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map dim_vec inputs1 = input_sizes m1 &&&\n    map dim_vec inputs2 = input_sizes m2", "apply (metis Pool.prems(2) append_eq_conv_conj input_sizes.simps(3) inputs1_def take_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map dim_vec inputs2 = input_sizes m2", "by (metis Pool.prems(2) append_eq_conv_conj drop_map input_sizes.simps(3) inputs2_def)"], ["proof (state)\nthis:\n  map dim_vec inputs1 = input_sizes m1\n  map dim_vec inputs2 = input_sizes m2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have \"inputs = inputs1 @ inputs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inputs = inputs1 @ inputs2", "by (simp add: inputs1_def inputs2_def)"], ["proof (state)\nthis:\n  inputs = inputs1 @ inputs2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "{"], ["proof (state)\nthis:\n  inputs = inputs1 @ inputs2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "fix is1 is2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "assume \"is1 \\<lhd> input_sizes m1\" \"is2 \\<lhd> input_sizes m2\""], ["proof (state)\nthis:\n  is1 \\<lhd> input_sizes m1\n  is2 \\<lhd> input_sizes m2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have \"length is1 = length inputs1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length is1 = length inputs1", "using \\<open>is1 \\<lhd> input_sizes m1\\<close> \\<open>map dim_vec inputs1 = input_sizes m1\\<close> valid_index_length"], ["proof (prove)\nusing this:\n  is1 \\<lhd> input_sizes m1\n  map dim_vec inputs1 = input_sizes m1\n  ?is \\<lhd> ?ds \\<Longrightarrow> length ?is = length ?ds\n\ngoal (1 subgoal):\n 1. length is1 = length inputs1", "by fastforce"], ["proof (state)\nthis:\n  length is1 = length inputs1\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have \"length is2 = length inputs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length is2 = length inputs2", "using \\<open>is2 \\<lhd> input_sizes m2\\<close> \\<open>map dim_vec inputs2 = input_sizes m2\\<close> valid_index_length"], ["proof (prove)\nusing this:\n  is2 \\<lhd> input_sizes m2\n  map dim_vec inputs2 = input_sizes m2\n  ?is \\<lhd> ?ds \\<Longrightarrow> length ?is = length ?ds\n\ngoal (1 subgoal):\n 1. length is2 = length inputs2", "by fastforce"], ["proof (state)\nthis:\n  length is2 = length inputs2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have 1:\"(\\<Prod>k<length inputs1. (inputs1 @ inputs2) ! k $ ((is1 @ is2) ! k))  = (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>k<length inputs1. (inputs1 @ inputs2) ! k $ ((is1 @ is2) ! k)) =\n    (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k))", "using \\<open>length is1 = length inputs1\\<close> \\<open>length is2 = length inputs2\\<close>\n      nth_append"], ["proof (prove)\nusing this:\n  length is1 = length inputs1\n  length is2 = length inputs2\n  (?xs @ ?ys) ! ?n =\n  (if ?n < length ?xs then ?xs ! ?n else ?ys ! (?n - length ?xs))\n\ngoal (1 subgoal):\n 1. (\\<Prod>k<length inputs1. (inputs1 @ inputs2) ! k $ ((is1 @ is2) ! k)) =\n    (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k))", "by (metis (no_types, lifting) lessThan_iff prod.cong)"], ["proof (state)\nthis:\n  (\\<Prod>k<length inputs1. (inputs1 @ inputs2) ! k $ ((is1 @ is2) ! k)) =\n  (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k))\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have 2:\"(\\<Prod>x<length inputs2. (inputs1 @ inputs2) ! (x + length inputs1) $ ((is1 @ is2) ! (x + length inputs1))) =\n      (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x<length inputs2.\n        (inputs1 @ inputs2) ! (x + length inputs1) $\n        ((is1 @ is2) ! (x + length inputs1))) =\n    (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k))", "using \\<open>length is1 = length inputs1\\<close> \\<open>length is2 = length inputs2\\<close>"], ["proof (prove)\nusing this:\n  length is1 = length inputs1\n  length is2 = length inputs2\n\ngoal (1 subgoal):\n 1. (\\<Prod>x<length inputs2.\n        (inputs1 @ inputs2) ! (x + length inputs1) $\n        ((is1 @ is2) ! (x + length inputs1))) =\n    (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k))", "by (metis (no_types, lifting) add.commute nth_append_length_plus)"], ["proof (state)\nthis:\n  (\\<Prod>x<length inputs2.\n      (inputs1 @ inputs2) ! (x + length inputs1) $\n      ((is1 @ is2) ! (x + length inputs1))) =\n  (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k))\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have \"(\\<Prod>k<length inputs. inputs ! k $ ((is1 @ is2) ! k)) = (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k)) * (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>k<length inputs. inputs ! k $ ((is1 @ is2) ! k)) =\n    (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k)) *\n    (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k))", "unfolding \\<open>inputs = inputs1 @ inputs2\\<close> length_append prod_lessThan_split"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>k<length inputs1. (inputs1 @ inputs2) ! k $ ((is1 @ is2) ! k)) *\n    (\\<Prod>x<length inputs2.\n        (inputs1 @ inputs2) ! (x + length inputs1) $\n        ((is1 @ is2) ! (x + length inputs1))) =\n    (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k)) *\n    (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k))", "using 1 2"], ["proof (prove)\nusing this:\n  (\\<Prod>k<length inputs1. (inputs1 @ inputs2) ! k $ ((is1 @ is2) ! k)) =\n  (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k))\n  (\\<Prod>x<length inputs2.\n      (inputs1 @ inputs2) ! (x + length inputs1) $\n      ((is1 @ is2) ! (x + length inputs1))) =\n  (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k))\n\ngoal (1 subgoal):\n 1. (\\<Prod>k<length inputs1. (inputs1 @ inputs2) ! k $ ((is1 @ is2) ! k)) *\n    (\\<Prod>x<length inputs2.\n        (inputs1 @ inputs2) ! (x + length inputs1) $\n        ((is1 @ is2) ! (x + length inputs1))) =\n    (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k)) *\n    (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k))", "by metis"], ["proof (state)\nthis:\n  (\\<Prod>k<length inputs. inputs ! k $ ((is1 @ is2) ! k)) =\n  (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k)) *\n  (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k))\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?is1.2 \\<lhd> input_sizes m1;\n   ?is2.2 \\<lhd> input_sizes m2\\<rbrakk>\n  \\<Longrightarrow> (\\<Prod>k<length inputs.\n                        inputs ! k $ ((?is1.2 @ ?is2.2) ! k)) =\n                    (\\<Prod>k<length inputs1. inputs1 ! k $ (?is1.2 ! k)) *\n                    (\\<Prod>k<length inputs2. inputs2 ! k $ (?is2.2 ! k))\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "note 1 = this"], ["proof (state)\nthis:\n  \\<lbrakk>?is1.2 \\<lhd> input_sizes m1;\n   ?is2.2 \\<lhd> input_sizes m2\\<rbrakk>\n  \\<Longrightarrow> (\\<Prod>k<length inputs.\n                        inputs ! k $ ((?is1.2 @ ?is2.2) ! k)) =\n                    (\\<Prod>k<length inputs1. inputs1 ! k $ (?is1.2 ! k)) *\n                    (\\<Prod>k<length inputs2. inputs2 ! k $ (?is2.2 ! k))\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?is1.2 \\<lhd> input_sizes m1;\n   ?is2.2 \\<lhd> input_sizes m2\\<rbrakk>\n  \\<Longrightarrow> (\\<Prod>k<length inputs.\n                        inputs ! k $ ((?is1.2 @ ?is2.2) ! k)) =\n                    (\\<Prod>k<length inputs1. inputs1 ! k $ (?is1.2 ! k)) *\n                    (\\<Prod>k<length inputs2. inputs2 ! k $ (?is2.2 ! k))\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "fix is1 is2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "assume \"is1 \\<lhd> input_sizes m1\" \"is2 \\<lhd> input_sizes m2\""], ["proof (state)\nthis:\n  is1 \\<lhd> input_sizes m1\n  is2 \\<lhd> input_sizes m2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "then"], ["proof (chain)\npicking this:\n  is1 \\<lhd> input_sizes m1\n  is2 \\<lhd> input_sizes m2", "have \"is1 \\<lhd> dims (tensors_from_net m1 $ j)\" \"is2 \\<lhd> dims (tensors_from_net m2 $ j)\""], ["proof (prove)\nusing this:\n  is1 \\<lhd> input_sizes m1\n  is2 \\<lhd> input_sizes m2\n\ngoal (1 subgoal):\n 1. is1 \\<lhd> dims (tensors_from_net m1 $ j) &&&\n    is2 \\<lhd> dims (tensors_from_net m2 $ j)", "using \\<open>j < dim_vec (tensors_from_net m1)\\<close>  \\<open>j < dim_vec (tensors_from_net m2)\\<close> dims_tensors_from_net vec_setI"], ["proof (prove)\nusing this:\n  is1 \\<lhd> input_sizes m1\n  is2 \\<lhd> input_sizes m2\n  j < dim_vec (tensors_from_net m1)\n  j < dim_vec (tensors_from_net m2)\n  ?T \\<in> set\\<^sub>v (tensors_from_net ?m) \\<Longrightarrow>\n  dims ?T = input_sizes ?m\n  \\<lbrakk>?v $ ?i = ?a; ?i < dim_vec ?v\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> set\\<^sub>v ?v\n\ngoal (1 subgoal):\n 1. is1 \\<lhd> dims (tensors_from_net m1 $ j) &&&\n    is2 \\<lhd> dims (tensors_from_net m2 $ j)", "by force+"], ["proof (state)\nthis:\n  is1 \\<lhd> dims (tensors_from_net m1 $ j)\n  is2 \\<lhd> dims (tensors_from_net m2 $ j)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have \"lookup (tensors_from_net (Pool m1 m2) $ j) (is1 @ is2) = lookup (tensors_from_net m1 $ j) is1 * lookup (tensors_from_net m2 $ j) is2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (tensors_from_net (Pool m1 m2) $ j) (is1 @ is2) =\n    lookup (tensors_from_net m1 $ j) is1 *\n    lookup (tensors_from_net m2 $ j) is2", "unfolding \"tensors_from_net.simps\" index_component_mult[OF \\<open>j < dim_vec (tensors_from_net m1)\\<close> \\<open>j < dim_vec (tensors_from_net m2)\\<close>]\n      lookup_tensor_prod[OF \\<open>is1 \\<lhd> dims (tensors_from_net m1 $ j)\\<close> \\<open>is2 \\<lhd> dims (tensors_from_net m2 $ j)\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (tensors_from_net m1 $ j) is1 *\n    lookup (tensors_from_net m2 $ j) is2 =\n    lookup (tensors_from_net m1 $ j) is1 *\n    lookup (tensors_from_net m2 $ j) is2", "by metis"], ["proof (state)\nthis:\n  lookup (tensors_from_net (Pool m1 m2) $ j) (is1 @ is2) =\n  lookup (tensors_from_net m1 $ j) is1 *\n  lookup (tensors_from_net m2 $ j) is2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?is1.2 \\<lhd> input_sizes m1;\n   ?is2.2 \\<lhd> input_sizes m2\\<rbrakk>\n  \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j)\n                     (?is1.2 @ ?is2.2) =\n                    lookup (tensors_from_net m1 $ j) ?is1.2 *\n                    lookup (tensors_from_net m2 $ j) ?is2.2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "note 2 = this"], ["proof (state)\nthis:\n  \\<lbrakk>?is1.2 \\<lhd> input_sizes m1;\n   ?is2.2 \\<lhd> input_sizes m2\\<rbrakk>\n  \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j)\n                     (?is1.2 @ ?is2.2) =\n                    lookup (tensors_from_net m1 $ j) ?is1.2 *\n                    lookup (tensors_from_net m2 $ j) ?is2.2\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have j_le_eval:\"j < dim_vec (evaluate_net m1 (take (length (input_sizes m1)) inputs))\"\n                 \"j < dim_vec (evaluate_net m2 (drop (length (input_sizes m1)) inputs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < dim_vec\n         (evaluate_net m1 (take (length (input_sizes m1)) inputs)) &&&\n    j < dim_vec (evaluate_net m2 (drop (length (input_sizes m1)) inputs))", "using \\<open>j < output_size' m1\\<close> \\<open>map dim_vec inputs1 = input_sizes m1\\<close> \\<open>valid_net' m1\\<close> inputs1_def output_size_correct"], ["proof (prove)\nusing this:\n  j < output_size' m1\n  map dim_vec inputs1 = input_sizes m1\n  valid_net' m1\n  inputs1 = take (length (input_sizes m1)) inputs\n  \\<lbrakk>valid_net' ?m; map dim_vec ?inputs = input_sizes ?m\\<rbrakk>\n  \\<Longrightarrow> output_size' ?m = dim_vec (evaluate_net ?m ?inputs)\n\ngoal (1 subgoal):\n 1. j < dim_vec\n         (evaluate_net m1 (take (length (input_sizes m1)) inputs)) &&&\n    j < dim_vec (evaluate_net m2 (drop (length (input_sizes m1)) inputs))", "using \\<open>j < output_size' m2\\<close> \\<open>map dim_vec inputs2 = input_sizes m2\\<close> \\<open>valid_net' m2\\<close> inputs2_def"], ["proof (prove)\nusing this:\n  j < output_size' m1\n  map dim_vec inputs1 = input_sizes m1\n  valid_net' m1\n  inputs1 = take (length (input_sizes m1)) inputs\n  \\<lbrakk>valid_net' ?m; map dim_vec ?inputs = input_sizes ?m\\<rbrakk>\n  \\<Longrightarrow> output_size' ?m = dim_vec (evaluate_net ?m ?inputs)\n  j < output_size' m2\n  map dim_vec inputs2 = input_sizes m2\n  valid_net' m2\n  inputs2 = drop (length (input_sizes m1)) inputs\n\ngoal (1 subgoal):\n 1. j < dim_vec\n         (evaluate_net m1 (take (length (input_sizes m1)) inputs)) &&&\n    j < dim_vec (evaluate_net m2 (drop (length (input_sizes m1)) inputs))", "by auto"], ["proof (state)\nthis:\n  j < dim_vec (evaluate_net m1 (take (length (input_sizes m1)) inputs))\n  j < dim_vec (evaluate_net m2 (drop (length (input_sizes m1)) inputs))\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have \"(\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2). (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) * lookup (tensors_from_net (Pool m1 m2) $ j) is)\n        = (\\<Sum>is1 | is1 \\<lhd> input_sizes m1. \\<Sum>is2 | is2 \\<lhd> input_sizes m2.\n          (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k)) * (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k)) *\n          lookup (tensors_from_net m1 $ j) is1 * lookup (tensors_from_net m2 $ j) is2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n       (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n       lookup (tensors_from_net (Pool m1 m2) $ j) is) =\n    (\\<Sum>is1 | is1 \\<lhd> input_sizes m1.\n       \\<Sum>is2 | is2 \\<lhd> input_sizes m2.\n         (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k)) *\n         (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k)) *\n         lookup (tensors_from_net m1 $ j) is1 *\n         lookup (tensors_from_net m2 $ j) is2)", "unfolding input_sizes.simps setsum_valid_index_split"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>is1 | is1 \\<lhd> input_sizes m1.\n       \\<Sum>is2 | is2 \\<lhd> input_sizes m2.\n         (\\<Prod>k<length inputs. inputs ! k $ ((is1 @ is2) ! k)) *\n         lookup (tensors_from_net (Pool m1 m2) $ j) (is1 @ is2)) =\n    (\\<Sum>is1 | is1 \\<lhd> input_sizes m1.\n       \\<Sum>is2 | is2 \\<lhd> input_sizes m2.\n         (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k)) *\n         (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k)) *\n         lookup (tensors_from_net m1 $ j) is1 *\n         lookup (tensors_from_net m2 $ j) is2)", "using 1 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?is1.2 \\<lhd> input_sizes m1;\n   ?is2.2 \\<lhd> input_sizes m2\\<rbrakk>\n  \\<Longrightarrow> (\\<Prod>k<length inputs.\n                        inputs ! k $ ((?is1.2 @ ?is2.2) ! k)) =\n                    (\\<Prod>k<length inputs1. inputs1 ! k $ (?is1.2 ! k)) *\n                    (\\<Prod>k<length inputs2. inputs2 ! k $ (?is2.2 ! k))\n  \\<lbrakk>?is1.2 \\<lhd> input_sizes m1;\n   ?is2.2 \\<lhd> input_sizes m2\\<rbrakk>\n  \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j)\n                     (?is1.2 @ ?is2.2) =\n                    lookup (tensors_from_net m1 $ j) ?is1.2 *\n                    lookup (tensors_from_net m2 $ j) ?is2.2\n\ngoal (1 subgoal):\n 1. (\\<Sum>is1 | is1 \\<lhd> input_sizes m1.\n       \\<Sum>is2 | is2 \\<lhd> input_sizes m2.\n         (\\<Prod>k<length inputs. inputs ! k $ ((is1 @ is2) ! k)) *\n         lookup (tensors_from_net (Pool m1 m2) $ j) (is1 @ is2)) =\n    (\\<Sum>is1 | is1 \\<lhd> input_sizes m1.\n       \\<Sum>is2 | is2 \\<lhd> input_sizes m2.\n         (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k)) *\n         (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k)) *\n         lookup (tensors_from_net m1 $ j) is1 *\n         lookup (tensors_from_net m2 $ j) is2)", "using mem_Collect_eq sum.cong"], ["proof (prove)\nusing this:\n  \\<lbrakk>?is1.2 \\<lhd> input_sizes m1;\n   ?is2.2 \\<lhd> input_sizes m2\\<rbrakk>\n  \\<Longrightarrow> (\\<Prod>k<length inputs.\n                        inputs ! k $ ((?is1.2 @ ?is2.2) ! k)) =\n                    (\\<Prod>k<length inputs1. inputs1 ! k $ (?is1.2 ! k)) *\n                    (\\<Prod>k<length inputs2. inputs2 ! k $ (?is2.2 ! k))\n  \\<lbrakk>?is1.2 \\<lhd> input_sizes m1;\n   ?is2.2 \\<lhd> input_sizes m2\\<rbrakk>\n  \\<Longrightarrow> lookup (tensors_from_net (Pool m1 m2) $ j)\n                     (?is1.2 @ ?is2.2) =\n                    lookup (tensors_from_net m1 $ j) ?is1.2 *\n                    lookup (tensors_from_net m2 $ j) ?is2.2\n  (?a \\<in> Collect ?P) = ?P ?a\n  \\<lbrakk>?A = ?B;\n   \\<And>x. x \\<in> ?B \\<Longrightarrow> ?g x = ?h x\\<rbrakk>\n  \\<Longrightarrow> sum ?g ?A = sum ?h ?B\n\ngoal (1 subgoal):\n 1. (\\<Sum>is1 | is1 \\<lhd> input_sizes m1.\n       \\<Sum>is2 | is2 \\<lhd> input_sizes m2.\n         (\\<Prod>k<length inputs. inputs ! k $ ((is1 @ is2) ! k)) *\n         lookup (tensors_from_net (Pool m1 m2) $ j) (is1 @ is2)) =\n    (\\<Sum>is1 | is1 \\<lhd> input_sizes m1.\n       \\<Sum>is2 | is2 \\<lhd> input_sizes m2.\n         (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k)) *\n         (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k)) *\n         lookup (tensors_from_net m1 $ j) is1 *\n         lookup (tensors_from_net m2 $ j) is2)", "by (simp add: mult.assoc)"], ["proof (state)\nthis:\n  (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n     (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n     lookup (tensors_from_net (Pool m1 m2) $ j) is) =\n  (\\<Sum>is1 | is1 \\<lhd> input_sizes m1.\n     \\<Sum>is2 | is2 \\<lhd> input_sizes m2.\n       (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k)) *\n       (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k)) *\n       lookup (tensors_from_net m1 $ j) is1 *\n       lookup (tensors_from_net m2 $ j) is2)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "also"], ["proof (state)\nthis:\n  (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n     (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n     lookup (tensors_from_net (Pool m1 m2) $ j) is) =\n  (\\<Sum>is1 | is1 \\<lhd> input_sizes m1.\n     \\<Sum>is2 | is2 \\<lhd> input_sizes m2.\n       (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k)) *\n       (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k)) *\n       lookup (tensors_from_net m1 $ j) is1 *\n       lookup (tensors_from_net m2 $ j) is2)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have \"... = (\\<Sum>is1 | is1 \\<lhd> input_sizes m1. (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k)) * lookup (tensors_from_net m1 $ j) is1) *\n                   (\\<Sum>is2 | is2 \\<lhd> input_sizes m2. (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k)) * lookup (tensors_from_net m2 $ j) is2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>is1 | is1 \\<lhd> input_sizes m1.\n       \\<Sum>is2 | is2 \\<lhd> input_sizes m2.\n         (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k)) *\n         (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k)) *\n         lookup (tensors_from_net m1 $ j) is1 *\n         lookup (tensors_from_net m2 $ j) is2) =\n    (\\<Sum>is1 | is1 \\<lhd> input_sizes m1.\n       (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k)) *\n       lookup (tensors_from_net m1 $ j) is1) *\n    (\\<Sum>is2 | is2 \\<lhd> input_sizes m2.\n       (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k)) *\n       lookup (tensors_from_net m2 $ j) is2)", "unfolding sum_product"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>is1 | is1 \\<lhd> input_sizes m1.\n       \\<Sum>is2 | is2 \\<lhd> input_sizes m2.\n         (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k)) *\n         (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k)) *\n         lookup (tensors_from_net m1 $ j) is1 *\n         lookup (tensors_from_net m2 $ j) is2) =\n    (\\<Sum>i\\<in>{is1. is1 \\<lhd> input_sizes m1}.\n       \\<Sum>j\\<in>{is2. is2 \\<lhd> input_sizes m2}.\n         (\\<Prod>k<length inputs1. inputs1 ! k $ (i ! k)) *\n         lookup (tensors_from_net m1 $ j) i *\n         ((\\<Prod>k<length inputs2. inputs2 ! k $ (j ! k)) *\n          lookup (tensors_from_net m2 $ j) j))", "by (rule sum.cong, metis, rule sum.cong, metis, simp)"], ["proof (state)\nthis:\n  (\\<Sum>is1 | is1 \\<lhd> input_sizes m1.\n     \\<Sum>is2 | is2 \\<lhd> input_sizes m2.\n       (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k)) *\n       (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k)) *\n       lookup (tensors_from_net m1 $ j) is1 *\n       lookup (tensors_from_net m2 $ j) is2) =\n  (\\<Sum>is1 | is1 \\<lhd> input_sizes m1.\n     (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k)) *\n     lookup (tensors_from_net m1 $ j) is1) *\n  (\\<Sum>is2 | is2 \\<lhd> input_sizes m2.\n     (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k)) *\n     lookup (tensors_from_net m2 $ j) is2)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "also"], ["proof (state)\nthis:\n  (\\<Sum>is1 | is1 \\<lhd> input_sizes m1.\n     \\<Sum>is2 | is2 \\<lhd> input_sizes m2.\n       (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k)) *\n       (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k)) *\n       lookup (tensors_from_net m1 $ j) is1 *\n       lookup (tensors_from_net m2 $ j) is2) =\n  (\\<Sum>is1 | is1 \\<lhd> input_sizes m1.\n     (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k)) *\n     lookup (tensors_from_net m1 $ j) is1) *\n  (\\<Sum>is2 | is2 \\<lhd> input_sizes m2.\n     (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k)) *\n     lookup (tensors_from_net m2 $ j) is2)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "have \"... = evaluate_net (Pool m1 m2) inputs $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>is1 | is1 \\<lhd> input_sizes m1.\n       (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k)) *\n       lookup (tensors_from_net m1 $ j) is1) *\n    (\\<Sum>is2 | is2 \\<lhd> input_sizes m2.\n       (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k)) *\n       lookup (tensors_from_net m2 $ j) is2) =\n    evaluate_net (Pool m1 m2) inputs $ j", "unfolding \"evaluate_net.simps\" index_component_mult[OF j_le_eval]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>is1 | is1 \\<lhd> input_sizes m1.\n       (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k)) *\n       lookup (tensors_from_net m1 $ j) is1) *\n    (\\<Sum>is2 | is2 \\<lhd> input_sizes m2.\n       (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k)) *\n       lookup (tensors_from_net m2 $ j) is2) =\n    evaluate_net m1 (take (length (input_sizes m1)) inputs) $ j *\n    evaluate_net m2 (drop (length (input_sizes m1)) inputs) $ j", "using Pool.IH(1)[OF \\<open>valid_net' m1\\<close> _ \\<open>j < output_size' m1\\<close>] Pool.IH(2)[OF \\<open>valid_net' m2\\<close> _ \\<open>j < output_size' m2\\<close>]"], ["proof (prove)\nusing this:\n  map dim_vec ?inputs = input_sizes m1 \\<Longrightarrow>\n  evaluate_net m1 ?inputs $ j =\n  (\\<Sum>is | is \\<lhd> input_sizes m1.\n     (\\<Prod>k<length ?inputs. ?inputs ! k $ (is ! k)) *\n     lookup (tensors_from_net m1 $ j) is)\n  map dim_vec ?inputs = input_sizes m2 \\<Longrightarrow>\n  evaluate_net m2 ?inputs $ j =\n  (\\<Sum>is | is \\<lhd> input_sizes m2.\n     (\\<Prod>k<length ?inputs. ?inputs ! k $ (is ! k)) *\n     lookup (tensors_from_net m2 $ j) is)\n\ngoal (1 subgoal):\n 1. (\\<Sum>is1 | is1 \\<lhd> input_sizes m1.\n       (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k)) *\n       lookup (tensors_from_net m1 $ j) is1) *\n    (\\<Sum>is2 | is2 \\<lhd> input_sizes m2.\n       (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k)) *\n       lookup (tensors_from_net m2 $ j) is2) =\n    evaluate_net m1 (take (length (input_sizes m1)) inputs) $ j *\n    evaluate_net m2 (drop (length (input_sizes m1)) inputs) $ j", "using \\<open>map dim_vec inputs1 = input_sizes m1\\<close> \\<open>map dim_vec inputs2 = input_sizes m2\\<close> inputs1_def inputs2_def"], ["proof (prove)\nusing this:\n  map dim_vec ?inputs = input_sizes m1 \\<Longrightarrow>\n  evaluate_net m1 ?inputs $ j =\n  (\\<Sum>is | is \\<lhd> input_sizes m1.\n     (\\<Prod>k<length ?inputs. ?inputs ! k $ (is ! k)) *\n     lookup (tensors_from_net m1 $ j) is)\n  map dim_vec ?inputs = input_sizes m2 \\<Longrightarrow>\n  evaluate_net m2 ?inputs $ j =\n  (\\<Sum>is | is \\<lhd> input_sizes m2.\n     (\\<Prod>k<length ?inputs. ?inputs ! k $ (is ! k)) *\n     lookup (tensors_from_net m2 $ j) is)\n  map dim_vec inputs1 = input_sizes m1\n  map dim_vec inputs2 = input_sizes m2\n  inputs1 = take (length (input_sizes m1)) inputs\n  inputs2 = drop (length (input_sizes m1)) inputs\n\ngoal (1 subgoal):\n 1. (\\<Sum>is1 | is1 \\<lhd> input_sizes m1.\n       (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k)) *\n       lookup (tensors_from_net m1 $ j) is1) *\n    (\\<Sum>is2 | is2 \\<lhd> input_sizes m2.\n       (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k)) *\n       lookup (tensors_from_net m2 $ j) is2) =\n    evaluate_net m1 (take (length (input_sizes m1)) inputs) $ j *\n    evaluate_net m2 (drop (length (input_sizes m1)) inputs) $ j", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>is1 | is1 \\<lhd> input_sizes m1.\n     (\\<Prod>k<length inputs1. inputs1 ! k $ (is1 ! k)) *\n     lookup (tensors_from_net m1 $ j) is1) *\n  (\\<Sum>is2 | is2 \\<lhd> input_sizes m2.\n     (\\<Prod>k<length inputs2. inputs2 ! k $ (is2 ! k)) *\n     lookup (tensors_from_net m2 $ j) is2) =\n  evaluate_net (Pool m1 m2) inputs $ j\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 j inputs.\n       \\<lbrakk>\\<And>j inputs.\n                   \\<lbrakk>valid_net' m1;\n                    map dim_vec inputs = input_sizes m1;\n                    j < output_size' m1\\<rbrakk>\n                   \\<Longrightarrow> evaluate_net m1 inputs $ j =\n                                     (\\<Sum>is | is \\<lhd> input_sizes m1.\n  (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n  lookup (tensors_from_net m1 $ j) is);\n        \\<And>j inputs.\n           \\<lbrakk>valid_net' m2; map dim_vec inputs = input_sizes m2;\n            j < output_size' m2\\<rbrakk>\n           \\<Longrightarrow> evaluate_net m2 inputs $ j =\n                             (\\<Sum>is | is \\<lhd> input_sizes m2.\n                                (\\<Prod>k<length inputs.\n                                    inputs ! k $ (is ! k)) *\n                                lookup (tensors_from_net m2 $ j) is);\n        valid_net' (Pool m1 m2);\n        map dim_vec inputs = input_sizes (Pool m1 m2);\n        j < output_size' (Pool m1 m2)\\<rbrakk>\n       \\<Longrightarrow> evaluate_net (Pool m1 m2) inputs $ j =\n                         (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n                            (\\<Prod>k<length inputs.\n                                inputs ! k $ (is ! k)) *\n                            lookup (tensors_from_net (Pool m1 m2) $ j) is)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n     (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n     lookup (tensors_from_net (Pool m1 m2) $ j) is) =\n  evaluate_net (Pool m1 m2) inputs $ j", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n     (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n     lookup (tensors_from_net (Pool m1 m2) $ j) is) =\n  evaluate_net (Pool m1 m2) inputs $ j\n\ngoal (1 subgoal):\n 1. evaluate_net (Pool m1 m2) inputs $ j =\n    (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n       (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n       lookup (tensors_from_net (Pool m1 m2) $ j) is)", "by metis"], ["proof (state)\nthis:\n  evaluate_net (Pool m1 m2) inputs $ j =\n  (\\<Sum>is | is \\<lhd> input_sizes (Pool m1 m2).\n     (\\<Prod>k<length inputs. inputs ! k $ (is ! k)) *\n     lookup (tensors_from_net (Pool m1 m2) $ j) is)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tensors_from_net_eqI:\nassumes \"valid_net' m1\" \"valid_net' m2\" \"input_sizes m1 = input_sizes m2\"\nassumes \"\\<And>inputs. input_sizes m1 = map dim_vec inputs \\<Longrightarrow> evaluate_net m1 inputs = evaluate_net m2 inputs\"\nshows \"tensors_from_net m1 = tensors_from_net m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensors_from_net m1 = tensors_from_net m2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tensors_from_net m1 = tensors_from_net m2", "have \"map dim_vec (map 0\\<^sub>v (input_sizes m2)) = input_sizes m2\"\n       \"map dim_vec (map 0\\<^sub>v (input_sizes m1)) = input_sizes m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map dim_vec (map 0\\<^sub>v (input_sizes m2)) = input_sizes m2 &&&\n    map dim_vec (map 0\\<^sub>v (input_sizes m1)) = input_sizes m1", "by (auto intro: nth_equalityI)"], ["proof (state)\nthis:\n  map dim_vec (map 0\\<^sub>v (input_sizes m2)) = input_sizes m2\n  map dim_vec (map 0\\<^sub>v (input_sizes m1)) = input_sizes m1\n\ngoal (1 subgoal):\n 1. tensors_from_net m1 = tensors_from_net m2", "then"], ["proof (chain)\npicking this:\n  map dim_vec (map 0\\<^sub>v (input_sizes m2)) = input_sizes m2\n  map dim_vec (map 0\\<^sub>v (input_sizes m1)) = input_sizes m1", "have \"output_size' m1 = output_size' m2\""], ["proof (prove)\nusing this:\n  map dim_vec (map 0\\<^sub>v (input_sizes m2)) = input_sizes m2\n  map dim_vec (map 0\\<^sub>v (input_sizes m1)) = input_sizes m1\n\ngoal (1 subgoal):\n 1. output_size' m1 = output_size' m2", "using\n    output_size_correct[OF \\<open>valid_net' m1\\<close> \\<open>map dim_vec (map 0\\<^sub>v (input_sizes m1)) = input_sizes m1\\<close>]\n    output_size_correct[OF \\<open>valid_net' m2\\<close> \\<open>map dim_vec (map 0\\<^sub>v (input_sizes m2)) = input_sizes m2\\<close>]\n    assms(3) assms(4)"], ["proof (prove)\nusing this:\n  map dim_vec (map 0\\<^sub>v (input_sizes m2)) = input_sizes m2\n  map dim_vec (map 0\\<^sub>v (input_sizes m1)) = input_sizes m1\n  output_size' m1 =\n  dim_vec (evaluate_net m1 (map 0\\<^sub>v (input_sizes m1)))\n  output_size' m2 =\n  dim_vec (evaluate_net m2 (map 0\\<^sub>v (input_sizes m2)))\n  input_sizes m1 = input_sizes m2\n  input_sizes m1 = map dim_vec ?inputs \\<Longrightarrow>\n  evaluate_net m1 ?inputs = evaluate_net m2 ?inputs\n\ngoal (1 subgoal):\n 1. output_size' m1 = output_size' m2", "by (metis (no_types))"], ["proof (state)\nthis:\n  output_size' m1 = output_size' m2\n\ngoal (1 subgoal):\n 1. tensors_from_net m1 = tensors_from_net m2", "have \"\\<And>is. base_input m1 is = base_input m2 is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is. base_input m1 is = base_input m2 is", "unfolding base_input_def \\<open>input_sizes m1 = input_sizes m2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is.\n       map2 unit\\<^sub>v (input_sizes m2) is =\n       map2 unit\\<^sub>v (input_sizes m2) is", "by metis"], ["proof (state)\nthis:\n  base_input m1 ?is1 = base_input m2 ?is1\n\ngoal (1 subgoal):\n 1. tensors_from_net m1 = tensors_from_net m2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensors_from_net m1 = tensors_from_net m2", "by (rule eq_vecI, rule tensor_lookup_eqI; metis\n    lookup_tensors_from_net[OF \\<open>valid_net' m1\\<close>, unfolded \\<open>\\<And>is. base_input m1 is = base_input m2 is\\<close> \\<open>output_size' m1 = output_size' m2\\<close>]\n    lookup_tensors_from_net[OF \\<open>valid_net' m2\\<close>] assms(3) base_input_length\n    assms(1) assms(2) dims_tensors_from_net output_size_correct_tensors vec_setI\n    \\<open>output_size' m1 = output_size' m2\\<close> assms(4))"], ["proof (state)\nthis:\n  tensors_from_net m1 = tensors_from_net m2\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}