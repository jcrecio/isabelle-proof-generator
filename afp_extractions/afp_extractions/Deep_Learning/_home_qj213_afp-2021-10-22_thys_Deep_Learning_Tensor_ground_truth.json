{"file_name": "/home/qj213/afp-2021-10-22/thys/Deep_Learning/Tensor.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Deep_Learning", "problem_names": ["lemma\nassumes \"length v = prod_list d\"\nshows dims_tensor[simp]: \"dims (tensor_from_vec d v) = d\"\nand   vec_tensor[simp]:  \"vec (tensor_from_vec d v) = v\"", "lemma tensor_from_vec_simp[simp]: \"tensor_from_vec (dims A) (vec A) = A\"", "lemma length_vec: \"length (vec A) = prod_list (dims A)\"", "lemma tensor_eqI[intro]:\nassumes \"dims A = dims B\" and \"vec A = vec B\"\nshows \"A=B\"", "lemma valid_index_length: \"is \\<lhd> ds \\<Longrightarrow> length is = length ds\"", "lemma valid_index_lt: \"is \\<lhd> ds \\<Longrightarrow> m<length ds \\<Longrightarrow> is!m < ds!m\"", "lemma valid_indexI:\nassumes \"length is = length ds\" and \"\\<And>m. m<length ds \\<Longrightarrow> is!m < ds!m\"\nshows \"is \\<lhd> ds\"", "lemma valid_index_append:\nassumes is1_valid:\"is1 \\<lhd> ds1\" and is2_valid:\"is2 \\<lhd> ds2\"\nshows \"is1 @ is2 \\<lhd> ds1 @ ds2\"", "lemma valid_index_list_all2_iff: \"is \\<lhd> ds \\<longleftrightarrow> list_all2 (<) is ds\"", "lemma concat_parts_leq:\nassumes \"a * d \\<le> length v\"\nshows \"concat (map (fixed_length_sublist v d) [0..<a]) = take (a*d) v\"", "lemma concat_parts_eq:\nassumes \"a * d = length v\"\nshows \"concat (map (fixed_length_sublist v d) [0..<a]) = v\"", "lemma tensor_lookup_base:\nassumes \"length v = prod_list ds\"\nand \"\\<And>is. is \\<lhd> ds \\<Longrightarrow> lookup_base ds v is = e is\"\nshows \"tensor_vec_from_lookup ds e = v\"", "lemma tensor_lookup:\nassumes \"\\<And>is. is \\<lhd> dims A \\<Longrightarrow> lookup A is = e is\"\nshows \"tensor_from_lookup (dims A) e = A\"", "lemma concat_equal_length:\nassumes \"\\<And>xs. xs\\<in>set xss \\<Longrightarrow> length xs = l\"\nshows \"length (concat xss) = length xss*l\"", "lemma concat_equal_length_map:\nassumes \"\\<And>i. i<a \\<Longrightarrow> length (f i) = d\"\nshows \"length (concat (map (\\<lambda>i. f i) [0..<a])) = a*d\"", "lemma concat_parts:\nassumes \"\\<And>xs. xs\\<in>set xss \\<Longrightarrow> length xs = d\" and \"i<length xss\"\nshows \"fixed_length_sublist (concat xss) d i = xss ! i\"", "lemma concat_parts':\nassumes \"\\<And>i. i<a \\<Longrightarrow> length (f i) = d\"\nand \"i<a\"\nshows \"fixed_length_sublist (concat (map (\\<lambda>i. f i) [0..<a])) d i = f i\"", "lemma length_tensor_vec_from_lookup:\n\"length (tensor_vec_from_lookup ds e) = prod_list ds\"", "lemma lookup_tensor_vec:\nassumes \"is\\<lhd>ds\"\nshows \"lookup_base ds (tensor_vec_from_lookup ds e) is = e is\"", "lemma lookup_tensor_from_lookup:\nassumes \"is\\<lhd>ds\"\nshows \"lookup (tensor_from_lookup ds e) is = e is\"", "lemma dims_tensor_from_lookup: \"dims (tensor_from_lookup ds e) = ds\"", "lemma tensor_lookup_cong:\nassumes \"tensor_from_lookup ds e\\<^sub>1 = tensor_from_lookup ds e\\<^sub>2\"\nand \"is\\<lhd>ds\"\nshows \"e\\<^sub>1 is = e\\<^sub>2 is\"", "lemma tensor_from_lookup_eqI:\nassumes \"\\<And>is. is\\<lhd>ds \\<Longrightarrow> e\\<^sub>1 is = e\\<^sub>2 is\"\nshows \"tensor_from_lookup ds e\\<^sub>1 = tensor_from_lookup ds e\\<^sub>2\"", "lemma tensor_lookup_eqI:\nassumes \"dims A = dims B\" and \"\\<And>is. is\\<lhd>(dims A) \\<Longrightarrow> lookup A is = lookup B is\"\nshows \"A = B\""], "translations": [["", "lemma\nassumes \"length v = prod_list d\"\nshows dims_tensor[simp]: \"dims (tensor_from_vec d v) = d\"\nand   vec_tensor[simp]:  \"vec (tensor_from_vec d v) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dims (tensor_from_vec d v) = d &&& vec (tensor_from_vec d v) = v", "by (simp add: Abs_tensor_inverse assms dims_def tensor_from_vec_def vec_def)+"], ["", "lemma tensor_from_vec_simp[simp]: \"tensor_from_vec (dims A) (vec A) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_from_vec (dims A) (vec A) = A", "by (simp add: Rep_tensor_inverse Tensor.vec_def dims_def tensor_from_vec_def)"], ["", "lemma length_vec: \"length (vec A) = prod_list (dims A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (vec A) = prod_list (dims A)", "by (metis (mono_tags, lifting) Rep_tensor Tensor.vec_def dims_def mem_Collect_eq)"], ["", "lemma tensor_eqI[intro]:\nassumes \"dims A = dims B\" and \"vec A = vec B\"\nshows \"A=B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = B", "by (metis assms tensor_from_vec_simp)"], ["", "abbreviation order::\"'a tensor \\<Rightarrow> nat\" where\n  \"order t == length (dims t)\""], ["", "inductive valid_index::\"nat list \\<Rightarrow> nat list \\<Rightarrow> bool\" (infix \"\\<lhd>\" 50) where\n  Nil: \"[] \\<lhd> []\" |\n  Cons: \"is \\<lhd> ds \\<Longrightarrow> i<d \\<Longrightarrow> i#is \\<lhd> d#ds\""], ["", "inductive_cases valid_indexE[elim]: \"is \\<lhd> ds\""], ["", "inductive_cases valid_index_dimsE[elim]: \"is \\<lhd> dims A\""], ["", "lemma valid_index_length: \"is \\<lhd> ds \\<Longrightarrow> length is = length ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is \\<lhd> ds \\<Longrightarrow> length is = length ds", "by (induction rule:valid_index.induct; auto)"], ["", "lemma valid_index_lt: \"is \\<lhd> ds \\<Longrightarrow> m<length ds \\<Longrightarrow> is!m < ds!m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is \\<lhd> ds; m < length ds\\<rbrakk>\n    \\<Longrightarrow> is ! m < ds ! m", "proof (induction arbitrary:m rule:valid_index.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m. m < length [] \\<Longrightarrow> [] ! m < [] ! m\n 2. \\<And>is ds i d m.\n       \\<lbrakk>is \\<lhd> ds;\n        \\<And>m. m < length ds \\<Longrightarrow> is ! m < ds ! m; i < d;\n        m < length (d # ds)\\<rbrakk>\n       \\<Longrightarrow> (i # is) ! m < (d # ds) ! m", "case Nil"], ["proof (state)\nthis:\n  m < length []\n\ngoal (2 subgoals):\n 1. \\<And>m. m < length [] \\<Longrightarrow> [] ! m < [] ! m\n 2. \\<And>is ds i d m.\n       \\<lbrakk>is \\<lhd> ds;\n        \\<And>m. m < length ds \\<Longrightarrow> is ! m < ds ! m; i < d;\n        m < length (d # ds)\\<rbrakk>\n       \\<Longrightarrow> (i # is) ! m < (d # ds) ! m", "then"], ["proof (chain)\npicking this:\n  m < length []", "show ?case"], ["proof (prove)\nusing this:\n  m < length []\n\ngoal (1 subgoal):\n 1. [] ! m < [] ! m", "by auto"], ["proof (state)\nthis:\n  [] ! m < [] ! m\n\ngoal (1 subgoal):\n 1. \\<And>is ds i d m.\n       \\<lbrakk>is \\<lhd> ds;\n        \\<And>m. m < length ds \\<Longrightarrow> is ! m < ds ! m; i < d;\n        m < length (d # ds)\\<rbrakk>\n       \\<Longrightarrow> (i # is) ! m < (d # ds) ! m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is ds i d m.\n       \\<lbrakk>is \\<lhd> ds;\n        \\<And>m. m < length ds \\<Longrightarrow> is ! m < ds ! m; i < d;\n        m < length (d # ds)\\<rbrakk>\n       \\<Longrightarrow> (i # is) ! m < (d # ds) ! m", "case Cons"], ["proof (state)\nthis:\n  is_ \\<lhd> ds_\n  i_ < d_\n  ?m < length ds_ \\<Longrightarrow> is_ ! ?m < ds_ ! ?m\n  m < length (d_ # ds_)\n\ngoal (1 subgoal):\n 1. \\<And>is ds i d m.\n       \\<lbrakk>is \\<lhd> ds;\n        \\<And>m. m < length ds \\<Longrightarrow> is ! m < ds ! m; i < d;\n        m < length (d # ds)\\<rbrakk>\n       \\<Longrightarrow> (i # is) ! m < (d # ds) ! m", "then"], ["proof (chain)\npicking this:\n  is_ \\<lhd> ds_\n  i_ < d_\n  ?m < length ds_ \\<Longrightarrow> is_ ! ?m < ds_ ! ?m\n  m < length (d_ # ds_)", "show ?case"], ["proof (prove)\nusing this:\n  is_ \\<lhd> ds_\n  i_ < d_\n  ?m < length ds_ \\<Longrightarrow> is_ ! ?m < ds_ ! ?m\n  m < length (d_ # ds_)\n\ngoal (1 subgoal):\n 1. (i_ # is_) ! m < (d_ # ds_) ! m", "by (metis gr0_conv_Suc length_Cons linorder_neqE_nat not_less_eq nth_Cons' nth_Cons_Suc)"], ["proof (state)\nthis:\n  (i_ # is_) ! m < (d_ # ds_) ! m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_indexI:\nassumes \"length is = length ds\" and \"\\<And>m. m<length ds \\<Longrightarrow> is!m < ds!m\"\nshows \"is \\<lhd> ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is \\<lhd> ds", "using assms"], ["proof (prove)\nusing this:\n  length is = length ds\n  ?m < length ds \\<Longrightarrow> is ! ?m < ds ! ?m\n\ngoal (1 subgoal):\n 1. is \\<lhd> ds", "proof (induction \"is\" arbitrary:ds)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ds.\n       \\<lbrakk>length [] = length ds;\n        \\<And>m. m < length ds \\<Longrightarrow> [] ! m < ds ! m\\<rbrakk>\n       \\<Longrightarrow> [] \\<lhd> ds\n 2. \\<And>a is ds.\n       \\<lbrakk>\\<And>ds.\n                   \\<lbrakk>length is = length ds;\n                    \\<And>m.\n                       m < length ds \\<Longrightarrow>\n                       is ! m < ds ! m\\<rbrakk>\n                   \\<Longrightarrow> is \\<lhd> ds;\n        length (a # is) = length ds;\n        \\<And>m.\n           m < length ds \\<Longrightarrow> (a # is) ! m < ds ! m\\<rbrakk>\n       \\<Longrightarrow> a # is \\<lhd> ds", "case Nil"], ["proof (state)\nthis:\n  length [] = length ds\n  ?m < length ds \\<Longrightarrow> [] ! ?m < ds ! ?m\n\ngoal (2 subgoals):\n 1. \\<And>ds.\n       \\<lbrakk>length [] = length ds;\n        \\<And>m. m < length ds \\<Longrightarrow> [] ! m < ds ! m\\<rbrakk>\n       \\<Longrightarrow> [] \\<lhd> ds\n 2. \\<And>a is ds.\n       \\<lbrakk>\\<And>ds.\n                   \\<lbrakk>length is = length ds;\n                    \\<And>m.\n                       m < length ds \\<Longrightarrow>\n                       is ! m < ds ! m\\<rbrakk>\n                   \\<Longrightarrow> is \\<lhd> ds;\n        length (a # is) = length ds;\n        \\<And>m.\n           m < length ds \\<Longrightarrow> (a # is) ! m < ds ! m\\<rbrakk>\n       \\<Longrightarrow> a # is \\<lhd> ds", "then"], ["proof (chain)\npicking this:\n  length [] = length ds\n  ?m < length ds \\<Longrightarrow> [] ! ?m < ds ! ?m", "show ?case"], ["proof (prove)\nusing this:\n  length [] = length ds\n  ?m < length ds \\<Longrightarrow> [] ! ?m < ds ! ?m\n\ngoal (1 subgoal):\n 1. [] \\<lhd> ds", "by (metis length_0_conv valid_index.simps)"], ["proof (state)\nthis:\n  [] \\<lhd> ds\n\ngoal (1 subgoal):\n 1. \\<And>a is ds.\n       \\<lbrakk>\\<And>ds.\n                   \\<lbrakk>length is = length ds;\n                    \\<And>m.\n                       m < length ds \\<Longrightarrow>\n                       is ! m < ds ! m\\<rbrakk>\n                   \\<Longrightarrow> is \\<lhd> ds;\n        length (a # is) = length ds;\n        \\<And>m.\n           m < length ds \\<Longrightarrow> (a # is) ! m < ds ! m\\<rbrakk>\n       \\<Longrightarrow> a # is \\<lhd> ds", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a is ds.\n       \\<lbrakk>\\<And>ds.\n                   \\<lbrakk>length is = length ds;\n                    \\<And>m.\n                       m < length ds \\<Longrightarrow>\n                       is ! m < ds ! m\\<rbrakk>\n                   \\<Longrightarrow> is \\<lhd> ds;\n        length (a # is) = length ds;\n        \\<And>m.\n           m < length ds \\<Longrightarrow> (a # is) ! m < ds ! m\\<rbrakk>\n       \\<Longrightarrow> a # is \\<lhd> ds", "case (Cons a \"is\" ds)"], ["proof (state)\nthis:\n  \\<lbrakk>length is = length ?ds;\n   \\<And>m. m < length ?ds \\<Longrightarrow> is ! m < ?ds ! m\\<rbrakk>\n  \\<Longrightarrow> is \\<lhd> ?ds\n  length (a # is) = length ds\n  ?m < length ds \\<Longrightarrow> (a # is) ! ?m < ds ! ?m\n\ngoal (1 subgoal):\n 1. \\<And>a is ds.\n       \\<lbrakk>\\<And>ds.\n                   \\<lbrakk>length is = length ds;\n                    \\<And>m.\n                       m < length ds \\<Longrightarrow>\n                       is ! m < ds ! m\\<rbrakk>\n                   \\<Longrightarrow> is \\<lhd> ds;\n        length (a # is) = length ds;\n        \\<And>m.\n           m < length ds \\<Longrightarrow> (a # is) ! m < ds ! m\\<rbrakk>\n       \\<Longrightarrow> a # is \\<lhd> ds", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length is = length ?ds;\n   \\<And>m. m < length ?ds \\<Longrightarrow> is ! m < ?ds ! m\\<rbrakk>\n  \\<Longrightarrow> is \\<lhd> ?ds\n  length (a # is) = length ds\n  ?m < length ds \\<Longrightarrow> (a # is) ! ?m < ds ! ?m", "obtain d ds' where \"ds = d # ds'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length is = length ?ds;\n   \\<And>m. m < length ?ds \\<Longrightarrow> is ! m < ?ds ! m\\<rbrakk>\n  \\<Longrightarrow> is \\<lhd> ?ds\n  length (a # is) = length ds\n  ?m < length ds \\<Longrightarrow> (a # is) ! ?m < ds ! ?m\n\ngoal (1 subgoal):\n 1. (\\<And>d ds'. ds = d # ds' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis length_Suc_conv)"], ["proof (state)\nthis:\n  ds = d # ds'\n\ngoal (1 subgoal):\n 1. \\<And>a is ds.\n       \\<lbrakk>\\<And>ds.\n                   \\<lbrakk>length is = length ds;\n                    \\<And>m.\n                       m < length ds \\<Longrightarrow>\n                       is ! m < ds ! m\\<rbrakk>\n                   \\<Longrightarrow> is \\<lhd> ds;\n        length (a # is) = length ds;\n        \\<And>m.\n           m < length ds \\<Longrightarrow> (a # is) ! m < ds ! m\\<rbrakk>\n       \\<Longrightarrow> a # is \\<lhd> ds", "then"], ["proof (chain)\npicking this:\n  ds = d # ds'", "have \"is \\<lhd> ds'\""], ["proof (prove)\nusing this:\n  ds = d # ds'\n\ngoal (1 subgoal):\n 1. is \\<lhd> ds'", "using Cons"], ["proof (prove)\nusing this:\n  ds = d # ds'\n  \\<lbrakk>length is = length ?ds;\n   \\<And>m. m < length ?ds \\<Longrightarrow> is ! m < ?ds ! m\\<rbrakk>\n  \\<Longrightarrow> is \\<lhd> ?ds\n  length (a # is) = length ds\n  ?m < length ds \\<Longrightarrow> (a # is) ! ?m < ds ! ?m\n\ngoal (1 subgoal):\n 1. is \\<lhd> ds'", "by (metis length_Cons less_irrefl linorder_neqE_nat not_less_eq nth_Cons_Suc)"], ["proof (state)\nthis:\n  is \\<lhd> ds'\n\ngoal (1 subgoal):\n 1. \\<And>a is ds.\n       \\<lbrakk>\\<And>ds.\n                   \\<lbrakk>length is = length ds;\n                    \\<And>m.\n                       m < length ds \\<Longrightarrow>\n                       is ! m < ds ! m\\<rbrakk>\n                   \\<Longrightarrow> is \\<lhd> ds;\n        length (a # is) = length ds;\n        \\<And>m.\n           m < length ds \\<Longrightarrow> (a # is) ! m < ds ! m\\<rbrakk>\n       \\<Longrightarrow> a # is \\<lhd> ds", "then"], ["proof (chain)\npicking this:\n  is \\<lhd> ds'", "show ?case"], ["proof (prove)\nusing this:\n  is \\<lhd> ds'\n\ngoal (1 subgoal):\n 1. a # is \\<lhd> ds", "using Cons.prems(2) \\<open>ds = d # ds'\\<close> valid_index.Cons"], ["proof (prove)\nusing this:\n  is \\<lhd> ds'\n  ?m < length ds \\<Longrightarrow> (a # is) ! ?m < ds ! ?m\n  ds = d # ds'\n  \\<lbrakk>?is \\<lhd> ?ds; ?i < ?d\\<rbrakk>\n  \\<Longrightarrow> ?i # ?is \\<lhd> ?d # ?ds\n\ngoal (1 subgoal):\n 1. a # is \\<lhd> ds", "by fastforce"], ["proof (state)\nthis:\n  a # is \\<lhd> ds\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_index_append:\nassumes is1_valid:\"is1 \\<lhd> ds1\" and is2_valid:\"is2 \\<lhd> ds2\"\nshows \"is1 @ is2 \\<lhd> ds1 @ ds2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is1 @ is2 \\<lhd> ds1 @ ds2", "apply (rule valid_indexI[of \"is1 @ is2\" \"ds1 @ ds2\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (is1 @ is2) = length (ds1 @ ds2)\n 2. \\<And>m.\n       m < length (ds1 @ ds2) \\<Longrightarrow>\n       (is1 @ is2) ! m < (ds1 @ ds2) ! m", "unfolding nth_append"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (is1 @ is2) = length (ds1 @ ds2)\n 2. \\<And>m.\n       m < length (ds1 @ ds2) \\<Longrightarrow>\n       (if m < length is1 then is1 ! m else is2 ! (m - length is1))\n       < (if m < length ds1 then ds1 ! m else ds2 ! (m - length ds1))", "using valid_index_lt[OF is2_valid] valid_index_lt[OF is1_valid] valid_index_length[OF is1_valid] valid_index_length[OF is2_valid] length_append"], ["proof (prove)\nusing this:\n  ?m < length ds2 \\<Longrightarrow> is2 ! ?m < ds2 ! ?m\n  ?m < length ds1 \\<Longrightarrow> is1 ! ?m < ds1 ! ?m\n  length is1 = length ds1\n  length is2 = length ds2\n  length (?xs @ ?ys) = length ?xs + length ?ys\n\ngoal (2 subgoals):\n 1. length (is1 @ is2) = length (ds1 @ ds2)\n 2. \\<And>m.\n       m < length (ds1 @ ds2) \\<Longrightarrow>\n       (if m < length is1 then is1 ! m else is2 ! (m - length is1))\n       < (if m < length ds1 then ds1 ! m else ds2 ! (m - length ds1))", "by (auto simp add: \\<open>length is1 = length ds1\\<close>)"], ["", "lemma valid_index_list_all2_iff: \"is \\<lhd> ds \\<longleftrightarrow> list_all2 (<) is ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is \\<lhd> ds) = list_all2 (<) is ds", "by (metis list_all2_conv_all_nth list_all2_nthD valid_indexI valid_index_length valid_index_lt)"], ["", "definition fixed_length_sublist::\"'a list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a list\" where\n\"fixed_length_sublist xs l i = (take l (drop (l*i) xs))\""], ["", "fun lookup_base::\"nat list \\<Rightarrow> 'a list \\<Rightarrow> nat list \\<Rightarrow> 'a\" where\n  lookup_base_Nil: \"lookup_base [] v [] = hd v\" |\n  lookup_base_Cons: \"lookup_base (d # ds) v (i # is) =\n    lookup_base ds (fixed_length_sublist v (prod_list ds) i) is\""], ["", "definition lookup::\"'a tensor \\<Rightarrow> nat list \\<Rightarrow> 'a\" where\n  \"lookup A = lookup_base (dims A) (vec A)\""], ["", "fun tensor_vec_from_lookup::\"nat list \\<Rightarrow> (nat list \\<Rightarrow> 'a) \\<Rightarrow> 'a list\" where\n  tensor_vec_from_lookup_Nil: \"tensor_vec_from_lookup [] e = [e []]\" |\n  tensor_vec_from_lookup_Cons: \"tensor_vec_from_lookup (d # ds) e = concat (map (\\<lambda>i. tensor_vec_from_lookup ds (\\<lambda>is. e (i # is))) [0..<d])\""], ["", "definition tensor_from_lookup::\"nat list \\<Rightarrow> (nat list \\<Rightarrow> 'a) \\<Rightarrow> 'a tensor\" where\n  \"tensor_from_lookup ds e = tensor_from_vec ds (tensor_vec_from_lookup ds e)\""], ["", "lemma concat_parts_leq:\nassumes \"a * d \\<le> length v\"\nshows \"concat (map (fixed_length_sublist v d) [0..<a]) = take (a*d) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (map (fixed_length_sublist v d) [0..<a]) = take (a * d) v", "using assms"], ["proof (prove)\nusing this:\n  a * d \\<le> length v\n\ngoal (1 subgoal):\n 1. concat (map (fixed_length_sublist v d) [0..<a]) = take (a * d) v", "proof (induction a)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 * d \\<le> length v \\<Longrightarrow>\n    concat (map (fixed_length_sublist v d) [0..<0]) = take (0 * d) v\n 2. \\<And>a.\n       \\<lbrakk>a * d \\<le> length v \\<Longrightarrow>\n                concat (map (fixed_length_sublist v d) [0..<a]) =\n                take (a * d) v;\n        Suc a * d \\<le> length v\\<rbrakk>\n       \\<Longrightarrow> concat\n                          (map (fixed_length_sublist v d) [0..<Suc a]) =\n                         take (Suc a * d) v", "case 0"], ["proof (state)\nthis:\n  0 * d \\<le> length v\n\ngoal (2 subgoals):\n 1. 0 * d \\<le> length v \\<Longrightarrow>\n    concat (map (fixed_length_sublist v d) [0..<0]) = take (0 * d) v\n 2. \\<And>a.\n       \\<lbrakk>a * d \\<le> length v \\<Longrightarrow>\n                concat (map (fixed_length_sublist v d) [0..<a]) =\n                take (a * d) v;\n        Suc a * d \\<le> length v\\<rbrakk>\n       \\<Longrightarrow> concat\n                          (map (fixed_length_sublist v d) [0..<Suc a]) =\n                         take (Suc a * d) v", "then"], ["proof (chain)\npicking this:\n  0 * d \\<le> length v", "show ?case"], ["proof (prove)\nusing this:\n  0 * d \\<le> length v\n\ngoal (1 subgoal):\n 1. concat (map (fixed_length_sublist v d) [0..<0]) = take (0 * d) v", "by simp"], ["proof (state)\nthis:\n  concat (map (fixed_length_sublist v d) [0..<0]) = take (0 * d) v\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a * d \\<le> length v \\<Longrightarrow>\n                concat (map (fixed_length_sublist v d) [0..<a]) =\n                take (a * d) v;\n        Suc a * d \\<le> length v\\<rbrakk>\n       \\<Longrightarrow> concat\n                          (map (fixed_length_sublist v d) [0..<Suc a]) =\n                         take (Suc a * d) v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a * d \\<le> length v \\<Longrightarrow>\n                concat (map (fixed_length_sublist v d) [0..<a]) =\n                take (a * d) v;\n        Suc a * d \\<le> length v\\<rbrakk>\n       \\<Longrightarrow> concat\n                          (map (fixed_length_sublist v d) [0..<Suc a]) =\n                         take (Suc a * d) v", "case (Suc a)"], ["proof (state)\nthis:\n  a * d \\<le> length v \\<Longrightarrow>\n  concat (map (fixed_length_sublist v d) [0..<a]) = take (a * d) v\n  Suc a * d \\<le> length v\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a * d \\<le> length v \\<Longrightarrow>\n                concat (map (fixed_length_sublist v d) [0..<a]) =\n                take (a * d) v;\n        Suc a * d \\<le> length v\\<rbrakk>\n       \\<Longrightarrow> concat\n                          (map (fixed_length_sublist v d) [0..<Suc a]) =\n                         take (Suc a * d) v", "then"], ["proof (chain)\npicking this:\n  a * d \\<le> length v \\<Longrightarrow>\n  concat (map (fixed_length_sublist v d) [0..<a]) = take (a * d) v\n  Suc a * d \\<le> length v", "have \"concat (map (fixed_length_sublist v d) [0..<a]) = take (a * d) v\""], ["proof (prove)\nusing this:\n  a * d \\<le> length v \\<Longrightarrow>\n  concat (map (fixed_length_sublist v d) [0..<a]) = take (a * d) v\n  Suc a * d \\<le> length v\n\ngoal (1 subgoal):\n 1. concat (map (fixed_length_sublist v d) [0..<a]) = take (a * d) v", "by auto"], ["proof (state)\nthis:\n  concat (map (fixed_length_sublist v d) [0..<a]) = take (a * d) v\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a * d \\<le> length v \\<Longrightarrow>\n                concat (map (fixed_length_sublist v d) [0..<a]) =\n                take (a * d) v;\n        Suc a * d \\<le> length v\\<rbrakk>\n       \\<Longrightarrow> concat\n                          (map (fixed_length_sublist v d) [0..<Suc a]) =\n                         take (Suc a * d) v", "then"], ["proof (chain)\npicking this:\n  concat (map (fixed_length_sublist v d) [0..<a]) = take (a * d) v", "have \"concat (map (fixed_length_sublist v d) [0..<Suc a]) =\n        take (a * d) v @ fixed_length_sublist v d a\""], ["proof (prove)\nusing this:\n  concat (map (fixed_length_sublist v d) [0..<a]) = take (a * d) v\n\ngoal (1 subgoal):\n 1. concat (map (fixed_length_sublist v d) [0..<Suc a]) =\n    take (a * d) v @ fixed_length_sublist v d a", "using fixed_length_sublist_def"], ["proof (prove)\nusing this:\n  concat (map (fixed_length_sublist v d) [0..<a]) = take (a * d) v\n  fixed_length_sublist ?xs ?l ?i = take ?l (drop (?l * ?i) ?xs)\n\ngoal (1 subgoal):\n 1. concat (map (fixed_length_sublist v d) [0..<Suc a]) =\n    take (a * d) v @ fixed_length_sublist v d a", "by auto"], ["proof (state)\nthis:\n  concat (map (fixed_length_sublist v d) [0..<Suc a]) =\n  take (a * d) v @ fixed_length_sublist v d a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a * d \\<le> length v \\<Longrightarrow>\n                concat (map (fixed_length_sublist v d) [0..<a]) =\n                take (a * d) v;\n        Suc a * d \\<le> length v\\<rbrakk>\n       \\<Longrightarrow> concat\n                          (map (fixed_length_sublist v d) [0..<Suc a]) =\n                         take (Suc a * d) v", "then"], ["proof (chain)\npicking this:\n  concat (map (fixed_length_sublist v d) [0..<Suc a]) =\n  take (a * d) v @ fixed_length_sublist v d a", "show ?case"], ["proof (prove)\nusing this:\n  concat (map (fixed_length_sublist v d) [0..<Suc a]) =\n  take (a * d) v @ fixed_length_sublist v d a\n\ngoal (1 subgoal):\n 1. concat (map (fixed_length_sublist v d) [0..<Suc a]) = take (Suc a * d) v", "using Suc"], ["proof (prove)\nusing this:\n  concat (map (fixed_length_sublist v d) [0..<Suc a]) =\n  take (a * d) v @ fixed_length_sublist v d a\n  a * d \\<le> length v \\<Longrightarrow>\n  concat (map (fixed_length_sublist v d) [0..<a]) = take (a * d) v\n  Suc a * d \\<le> length v\n\ngoal (1 subgoal):\n 1. concat (map (fixed_length_sublist v d) [0..<Suc a]) = take (Suc a * d) v", "by (metis add.commute mult.commute mult_Suc take_add fixed_length_sublist_def)"], ["proof (state)\nthis:\n  concat (map (fixed_length_sublist v d) [0..<Suc a]) = take (Suc a * d) v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma concat_parts_eq:\nassumes \"a * d = length v\"\nshows \"concat (map (fixed_length_sublist v d) [0..<a]) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (map (fixed_length_sublist v d) [0..<a]) = v", "by (simp add: concat_parts_leq assms)"], ["", "lemma tensor_lookup_base:\nassumes \"length v = prod_list ds\"\nand \"\\<And>is. is \\<lhd> ds \\<Longrightarrow> lookup_base ds v is = e is\"\nshows \"tensor_vec_from_lookup ds e = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_vec_from_lookup ds e = v", "using assms"], ["proof (prove)\nusing this:\n  length v = prod_list ds\n  ?is \\<lhd> ds \\<Longrightarrow> lookup_base ds v ?is = e ?is\n\ngoal (1 subgoal):\n 1. tensor_vec_from_lookup ds e = v", "proof (induction ds arbitrary:v e)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v e.\n       \\<lbrakk>length v = prod_list [];\n        \\<And>is.\n           is \\<lhd> [] \\<Longrightarrow>\n           lookup_base [] v is = e is\\<rbrakk>\n       \\<Longrightarrow> tensor_vec_from_lookup [] e = v\n 2. \\<And>a ds v e.\n       \\<lbrakk>\\<And>v e.\n                   \\<lbrakk>length v = prod_list ds;\n                    \\<And>is.\n                       is \\<lhd> ds \\<Longrightarrow>\n                       lookup_base ds v is = e is\\<rbrakk>\n                   \\<Longrightarrow> tensor_vec_from_lookup ds e = v;\n        length v = prod_list (a # ds);\n        \\<And>is.\n           is \\<lhd> a # ds \\<Longrightarrow>\n           lookup_base (a # ds) v is = e is\\<rbrakk>\n       \\<Longrightarrow> tensor_vec_from_lookup (a # ds) e = v", "case Nil"], ["proof (state)\nthis:\n  length v = prod_list []\n  ?is \\<lhd> [] \\<Longrightarrow> lookup_base [] v ?is = e ?is\n\ngoal (2 subgoals):\n 1. \\<And>v e.\n       \\<lbrakk>length v = prod_list [];\n        \\<And>is.\n           is \\<lhd> [] \\<Longrightarrow>\n           lookup_base [] v is = e is\\<rbrakk>\n       \\<Longrightarrow> tensor_vec_from_lookup [] e = v\n 2. \\<And>a ds v e.\n       \\<lbrakk>\\<And>v e.\n                   \\<lbrakk>length v = prod_list ds;\n                    \\<And>is.\n                       is \\<lhd> ds \\<Longrightarrow>\n                       lookup_base ds v is = e is\\<rbrakk>\n                   \\<Longrightarrow> tensor_vec_from_lookup ds e = v;\n        length v = prod_list (a # ds);\n        \\<And>is.\n           is \\<lhd> a # ds \\<Longrightarrow>\n           lookup_base (a # ds) v is = e is\\<rbrakk>\n       \\<Longrightarrow> tensor_vec_from_lookup (a # ds) e = v", "then"], ["proof (chain)\npicking this:\n  length v = prod_list []\n  ?is \\<lhd> [] \\<Longrightarrow> lookup_base [] v ?is = e ?is", "show ?case"], ["proof (prove)\nusing this:\n  length v = prod_list []\n  ?is \\<lhd> [] \\<Longrightarrow> lookup_base [] v ?is = e ?is\n\ngoal (1 subgoal):\n 1. tensor_vec_from_lookup [] e = v", "unfolding tensor_vec_from_lookup.simps"], ["proof (prove)\nusing this:\n  length v = prod_list []\n  ?is \\<lhd> [] \\<Longrightarrow> lookup_base [] v ?is = e ?is\n\ngoal (1 subgoal):\n 1. [e []] = v", "by (metis One_nat_def Tensor.lookup_base_Nil length_0_conv length_Suc_conv list.sel(1) prod_list.Nil valid_index.Nil)"], ["proof (state)\nthis:\n  tensor_vec_from_lookup [] e = v\n\ngoal (1 subgoal):\n 1. \\<And>a ds v e.\n       \\<lbrakk>\\<And>v e.\n                   \\<lbrakk>length v = prod_list ds;\n                    \\<And>is.\n                       is \\<lhd> ds \\<Longrightarrow>\n                       lookup_base ds v is = e is\\<rbrakk>\n                   \\<Longrightarrow> tensor_vec_from_lookup ds e = v;\n        length v = prod_list (a # ds);\n        \\<And>is.\n           is \\<lhd> a # ds \\<Longrightarrow>\n           lookup_base (a # ds) v is = e is\\<rbrakk>\n       \\<Longrightarrow> tensor_vec_from_lookup (a # ds) e = v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ds v e.\n       \\<lbrakk>\\<And>v e.\n                   \\<lbrakk>length v = prod_list ds;\n                    \\<And>is.\n                       is \\<lhd> ds \\<Longrightarrow>\n                       lookup_base ds v is = e is\\<rbrakk>\n                   \\<Longrightarrow> tensor_vec_from_lookup ds e = v;\n        length v = prod_list (a # ds);\n        \\<And>is.\n           is \\<lhd> a # ds \\<Longrightarrow>\n           lookup_base (a # ds) v is = e is\\<rbrakk>\n       \\<Longrightarrow> tensor_vec_from_lookup (a # ds) e = v", "case (Cons a ds)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?v = prod_list ds;\n   \\<And>is.\n      is \\<lhd> ds \\<Longrightarrow> lookup_base ds ?v is = ?e is\\<rbrakk>\n  \\<Longrightarrow> tensor_vec_from_lookup ds ?e = ?v\n  length v = prod_list (a # ds)\n  ?is \\<lhd> a # ds \\<Longrightarrow> lookup_base (a # ds) v ?is = e ?is\n\ngoal (1 subgoal):\n 1. \\<And>a ds v e.\n       \\<lbrakk>\\<And>v e.\n                   \\<lbrakk>length v = prod_list ds;\n                    \\<And>is.\n                       is \\<lhd> ds \\<Longrightarrow>\n                       lookup_base ds v is = e is\\<rbrakk>\n                   \\<Longrightarrow> tensor_vec_from_lookup ds e = v;\n        length v = prod_list (a # ds);\n        \\<And>is.\n           is \\<lhd> a # ds \\<Longrightarrow>\n           lookup_base (a # ds) v is = e is\\<rbrakk>\n       \\<Longrightarrow> tensor_vec_from_lookup (a # ds) e = v", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?v = prod_list ds;\n   \\<And>is.\n      is \\<lhd> ds \\<Longrightarrow> lookup_base ds ?v is = ?e is\\<rbrakk>\n  \\<Longrightarrow> tensor_vec_from_lookup ds ?e = ?v\n  length v = prod_list (a # ds)\n  ?is \\<lhd> a # ds \\<Longrightarrow> lookup_base (a # ds) v ?is = e ?is", "have \"a * prod_list ds = length v\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?v = prod_list ds;\n   \\<And>is.\n      is \\<lhd> ds \\<Longrightarrow> lookup_base ds ?v is = ?e is\\<rbrakk>\n  \\<Longrightarrow> tensor_vec_from_lookup ds ?e = ?v\n  length v = prod_list (a # ds)\n  ?is \\<lhd> a # ds \\<Longrightarrow> lookup_base (a # ds) v ?is = e ?is\n\ngoal (1 subgoal):\n 1. a * prod_list ds = length v", "by auto"], ["proof (state)\nthis:\n  a * prod_list ds = length v\n\ngoal (1 subgoal):\n 1. \\<And>a ds v e.\n       \\<lbrakk>\\<And>v e.\n                   \\<lbrakk>length v = prod_list ds;\n                    \\<And>is.\n                       is \\<lhd> ds \\<Longrightarrow>\n                       lookup_base ds v is = e is\\<rbrakk>\n                   \\<Longrightarrow> tensor_vec_from_lookup ds e = v;\n        length v = prod_list (a # ds);\n        \\<And>is.\n           is \\<lhd> a # ds \\<Longrightarrow>\n           lookup_base (a # ds) v is = e is\\<rbrakk>\n       \\<Longrightarrow> tensor_vec_from_lookup (a # ds) e = v", "{"], ["proof (state)\nthis:\n  a * prod_list ds = length v\n\ngoal (1 subgoal):\n 1. \\<And>a ds v e.\n       \\<lbrakk>\\<And>v e.\n                   \\<lbrakk>length v = prod_list ds;\n                    \\<And>is.\n                       is \\<lhd> ds \\<Longrightarrow>\n                       lookup_base ds v is = e is\\<rbrakk>\n                   \\<Longrightarrow> tensor_vec_from_lookup ds e = v;\n        length v = prod_list (a # ds);\n        \\<And>is.\n           is \\<lhd> a # ds \\<Longrightarrow>\n           lookup_base (a # ds) v is = e is\\<rbrakk>\n       \\<Longrightarrow> tensor_vec_from_lookup (a # ds) e = v", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ds v e.\n       \\<lbrakk>\\<And>v e.\n                   \\<lbrakk>length v = prod_list ds;\n                    \\<And>is.\n                       is \\<lhd> ds \\<Longrightarrow>\n                       lookup_base ds v is = e is\\<rbrakk>\n                   \\<Longrightarrow> tensor_vec_from_lookup ds e = v;\n        length v = prod_list (a # ds);\n        \\<And>is.\n           is \\<lhd> a # ds \\<Longrightarrow>\n           lookup_base (a # ds) v is = e is\\<rbrakk>\n       \\<Longrightarrow> tensor_vec_from_lookup (a # ds) e = v", "assume \"i<a\""], ["proof (state)\nthis:\n  i < a\n\ngoal (1 subgoal):\n 1. \\<And>a ds v e.\n       \\<lbrakk>\\<And>v e.\n                   \\<lbrakk>length v = prod_list ds;\n                    \\<And>is.\n                       is \\<lhd> ds \\<Longrightarrow>\n                       lookup_base ds v is = e is\\<rbrakk>\n                   \\<Longrightarrow> tensor_vec_from_lookup ds e = v;\n        length v = prod_list (a # ds);\n        \\<And>is.\n           is \\<lhd> a # ds \\<Longrightarrow>\n           lookup_base (a # ds) v is = e is\\<rbrakk>\n       \\<Longrightarrow> tensor_vec_from_lookup (a # ds) e = v", "then"], ["proof (chain)\npicking this:\n  i < a", "have \"prod_list ds * (i+1) \\<le> length v\""], ["proof (prove)\nusing this:\n  i < a\n\ngoal (1 subgoal):\n 1. prod_list ds * (i + 1) \\<le> length v", "using \\<open>a * prod_list ds = length v\\<close>"], ["proof (prove)\nusing this:\n  i < a\n  a * prod_list ds = length v\n\ngoal (1 subgoal):\n 1. prod_list ds * (i + 1) \\<le> length v", "using discrete mult.commute mult_le_mono1"], ["proof (prove)\nusing this:\n  i < a\n  a * prod_list ds = length v\n  (?a < ?b) = (?a + (1::?'a) \\<le> ?b)\n  ?a * ?b = ?b * ?a\n  ?i \\<le> ?j \\<Longrightarrow> ?i * ?k \\<le> ?j * ?k\n\ngoal (1 subgoal):\n 1. prod_list ds * (i + 1) \\<le> length v", "by metis"], ["proof (state)\nthis:\n  prod_list ds * (i + 1) \\<le> length v\n\ngoal (1 subgoal):\n 1. \\<And>a ds v e.\n       \\<lbrakk>\\<And>v e.\n                   \\<lbrakk>length v = prod_list ds;\n                    \\<And>is.\n                       is \\<lhd> ds \\<Longrightarrow>\n                       lookup_base ds v is = e is\\<rbrakk>\n                   \\<Longrightarrow> tensor_vec_from_lookup ds e = v;\n        length v = prod_list (a # ds);\n        \\<And>is.\n           is \\<lhd> a # ds \\<Longrightarrow>\n           lookup_base (a # ds) v is = e is\\<rbrakk>\n       \\<Longrightarrow> tensor_vec_from_lookup (a # ds) e = v", "have \"\\<And>is'. is' \\<lhd> ds \\<Longrightarrow> e (i # is') = lookup_base ds (fixed_length_sublist v (prod_list ds) i) is'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is'.\n       is' \\<lhd> ds \\<Longrightarrow>\n       e (i # is') =\n       lookup_base ds (fixed_length_sublist v (prod_list ds) i) is'", "using \\<open>i<a\\<close>"], ["proof (prove)\nusing this:\n  i < a\n\ngoal (1 subgoal):\n 1. \\<And>is'.\n       is' \\<lhd> ds \\<Longrightarrow>\n       e (i # is') =\n       lookup_base ds (fixed_length_sublist v (prod_list ds) i) is'", "by (metis Cons.prems(2) Tensor.lookup_base_Cons valid_index.simps)"], ["proof (state)\nthis:\n  ?is' \\<lhd> ds \\<Longrightarrow>\n  e (i # ?is') =\n  lookup_base ds (fixed_length_sublist v (prod_list ds) i) ?is'\n\ngoal (1 subgoal):\n 1. \\<And>a ds v e.\n       \\<lbrakk>\\<And>v e.\n                   \\<lbrakk>length v = prod_list ds;\n                    \\<And>is.\n                       is \\<lhd> ds \\<Longrightarrow>\n                       lookup_base ds v is = e is\\<rbrakk>\n                   \\<Longrightarrow> tensor_vec_from_lookup ds e = v;\n        length v = prod_list (a # ds);\n        \\<And>is.\n           is \\<lhd> a # ds \\<Longrightarrow>\n           lookup_base (a # ds) v is = e is\\<rbrakk>\n       \\<Longrightarrow> tensor_vec_from_lookup (a # ds) e = v", "then"], ["proof (chain)\npicking this:\n  ?is' \\<lhd> ds \\<Longrightarrow>\n  e (i # ?is') =\n  lookup_base ds (fixed_length_sublist v (prod_list ds) i) ?is'", "have \"tensor_vec_from_lookup ds (\\<lambda>is'. e (i # is')) = fixed_length_sublist v (prod_list ds) i\""], ["proof (prove)\nusing this:\n  ?is' \\<lhd> ds \\<Longrightarrow>\n  e (i # ?is') =\n  lookup_base ds (fixed_length_sublist v (prod_list ds) i) ?is'\n\ngoal (1 subgoal):\n 1. tensor_vec_from_lookup ds (\\<lambda>is'. e (i # is')) =\n    fixed_length_sublist v (prod_list ds) i", "using Cons"], ["proof (prove)\nusing this:\n  ?is' \\<lhd> ds \\<Longrightarrow>\n  e (i # ?is') =\n  lookup_base ds (fixed_length_sublist v (prod_list ds) i) ?is'\n  \\<lbrakk>length ?v = prod_list ds;\n   \\<And>is.\n      is \\<lhd> ds \\<Longrightarrow> lookup_base ds ?v is = ?e is\\<rbrakk>\n  \\<Longrightarrow> tensor_vec_from_lookup ds ?e = ?v\n  length v = prod_list (a # ds)\n  ?is \\<lhd> a # ds \\<Longrightarrow> lookup_base (a # ds) v ?is = e ?is\n\ngoal (1 subgoal):\n 1. tensor_vec_from_lookup ds (\\<lambda>is'. e (i # is')) =\n    fixed_length_sublist v (prod_list ds) i", "using \\<open>prod_list ds * (i + 1) \\<le> length v\\<close>"], ["proof (prove)\nusing this:\n  ?is' \\<lhd> ds \\<Longrightarrow>\n  e (i # ?is') =\n  lookup_base ds (fixed_length_sublist v (prod_list ds) i) ?is'\n  \\<lbrakk>length ?v = prod_list ds;\n   \\<And>is.\n      is \\<lhd> ds \\<Longrightarrow> lookup_base ds ?v is = ?e is\\<rbrakk>\n  \\<Longrightarrow> tensor_vec_from_lookup ds ?e = ?v\n  length v = prod_list (a # ds)\n  ?is \\<lhd> a # ds \\<Longrightarrow> lookup_base (a # ds) v ?is = e ?is\n  prod_list ds * (i + 1) \\<le> length v\n\ngoal (1 subgoal):\n 1. tensor_vec_from_lookup ds (\\<lambda>is'. e (i # is')) =\n    fixed_length_sublist v (prod_list ds) i", "by (simp add: Cons.IH fixed_length_sublist_def)"], ["proof (state)\nthis:\n  tensor_vec_from_lookup ds (\\<lambda>is'. e (i # is')) =\n  fixed_length_sublist v (prod_list ds) i\n\ngoal (1 subgoal):\n 1. \\<And>a ds v e.\n       \\<lbrakk>\\<And>v e.\n                   \\<lbrakk>length v = prod_list ds;\n                    \\<And>is.\n                       is \\<lhd> ds \\<Longrightarrow>\n                       lookup_base ds v is = e is\\<rbrakk>\n                   \\<Longrightarrow> tensor_vec_from_lookup ds e = v;\n        length v = prod_list (a # ds);\n        \\<And>is.\n           is \\<lhd> a # ds \\<Longrightarrow>\n           lookup_base (a # ds) v is = e is\\<rbrakk>\n       \\<Longrightarrow> tensor_vec_from_lookup (a # ds) e = v", "}"], ["proof (state)\nthis:\n  ?i2 < a \\<Longrightarrow>\n  tensor_vec_from_lookup ds (\\<lambda>is'. e (?i2 # is')) =\n  fixed_length_sublist v (prod_list ds) ?i2\n\ngoal (1 subgoal):\n 1. \\<And>a ds v e.\n       \\<lbrakk>\\<And>v e.\n                   \\<lbrakk>length v = prod_list ds;\n                    \\<And>is.\n                       is \\<lhd> ds \\<Longrightarrow>\n                       lookup_base ds v is = e is\\<rbrakk>\n                   \\<Longrightarrow> tensor_vec_from_lookup ds e = v;\n        length v = prod_list (a # ds);\n        \\<And>is.\n           is \\<lhd> a # ds \\<Longrightarrow>\n           lookup_base (a # ds) v is = e is\\<rbrakk>\n       \\<Longrightarrow> tensor_vec_from_lookup (a # ds) e = v", "then"], ["proof (chain)\npicking this:\n  ?i2 < a \\<Longrightarrow>\n  tensor_vec_from_lookup ds (\\<lambda>is'. e (?i2 # is')) =\n  fixed_length_sublist v (prod_list ds) ?i2", "show ?case"], ["proof (prove)\nusing this:\n  ?i2 < a \\<Longrightarrow>\n  tensor_vec_from_lookup ds (\\<lambda>is'. e (?i2 # is')) =\n  fixed_length_sublist v (prod_list ds) ?i2\n\ngoal (1 subgoal):\n 1. tensor_vec_from_lookup (a # ds) e = v", "unfolding tensor_vec_from_lookup_Cons lookup_base_Cons"], ["proof (prove)\nusing this:\n  ?i2 < a \\<Longrightarrow>\n  tensor_vec_from_lookup ds (\\<lambda>is'. e (?i2 # is')) =\n  fixed_length_sublist v (prod_list ds) ?i2\n\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>i. tensor_vec_from_lookup ds (\\<lambda>is. e (i # is)))\n       [0..<a]) =\n    v", "using   concat_parts_eq[OF \\<open>a * prod_list ds = length v\\<close>]\n     atLeastLessThan_iff map_eq_conv set_upt Cons"], ["proof (prove)\nusing this:\n  ?i2 < a \\<Longrightarrow>\n  tensor_vec_from_lookup ds (\\<lambda>is'. e (?i2 # is')) =\n  fixed_length_sublist v (prod_list ds) ?i2\n  concat (map (fixed_length_sublist v (prod_list ds)) [0..<a]) = v\n  (?i \\<in> {?l..<?u}) = (?l \\<le> ?i \\<and> ?i < ?u)\n  (map ?f ?xs = map ?g ?xs) = (\\<forall>x\\<in>set ?xs. ?f x = ?g x)\n  set [?i..<?j] = {?i..<?j}\n  \\<lbrakk>length ?v = prod_list ds;\n   \\<And>is.\n      is \\<lhd> ds \\<Longrightarrow> lookup_base ds ?v is = ?e is\\<rbrakk>\n  \\<Longrightarrow> tensor_vec_from_lookup ds ?e = ?v\n  length v = prod_list (a # ds)\n  ?is \\<lhd> a # ds \\<Longrightarrow> lookup_base (a # ds) v ?is = e ?is\n\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>i. tensor_vec_from_lookup ds (\\<lambda>is. e (i # is)))\n       [0..<a]) =\n    v", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  tensor_vec_from_lookup (a # ds) e = v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tensor_lookup:\nassumes \"\\<And>is. is \\<lhd> dims A \\<Longrightarrow> lookup A is = e is\"\nshows \"tensor_from_lookup (dims A) e = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_from_lookup (dims A) e = A", "using tensor_lookup_base lookup_def length_vec tensor_from_lookup_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?v = prod_list ?ds;\n   \\<And>is.\n      is \\<lhd> ?ds \\<Longrightarrow> lookup_base ?ds ?v is = ?e is\\<rbrakk>\n  \\<Longrightarrow> tensor_vec_from_lookup ?ds ?e = ?v\n  lookup ?A = lookup_base (dims ?A) (vec ?A)\n  length (vec ?A) = prod_list (dims ?A)\n  tensor_from_lookup ?ds ?e =\n  tensor_from_vec ?ds (tensor_vec_from_lookup ?ds ?e)\n\ngoal (1 subgoal):\n 1. tensor_from_lookup (dims A) e = A", "by (metis assms tensor_from_vec_simp)"], ["", "lemma concat_equal_length:\nassumes \"\\<And>xs. xs\\<in>set xss \\<Longrightarrow> length xs = l\"\nshows \"length (concat xss) = length xss*l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (concat xss) = length xss * l", "using assms"], ["proof (prove)\nusing this:\n  ?xs \\<in> set xss \\<Longrightarrow> length ?xs = l\n\ngoal (1 subgoal):\n 1. length (concat xss) = length xss * l", "by (induction xss;auto)"], ["", "lemma concat_equal_length_map:\nassumes \"\\<And>i. i<a \\<Longrightarrow> length (f i) = d\"\nshows \"length (concat (map (\\<lambda>i. f i) [0..<a])) = a*d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (concat (map f [0..<a])) = a * d", "using assms"], ["proof (prove)\nusing this:\n  ?i < a \\<Longrightarrow> length (f ?i) = d\n\ngoal (1 subgoal):\n 1. length (concat (map f [0..<a])) = a * d", "by (induction a;auto)"], ["", "lemma concat_parts:\nassumes \"\\<And>xs. xs\\<in>set xss \\<Longrightarrow> length xs = d\" and \"i<length xss\"\nshows \"fixed_length_sublist (concat xss) d i = xss ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fixed_length_sublist (concat xss) d i = xss ! i", "using assms"], ["proof (prove)\nusing this:\n  ?xs \\<in> set xss \\<Longrightarrow> length ?xs = d\n  i < length xss\n\ngoal (1 subgoal):\n 1. fixed_length_sublist (concat xss) d i = xss ! i", "proof (induction xss arbitrary:i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<And>xs. xs \\<in> set [] \\<Longrightarrow> length xs = d;\n        i < length []\\<rbrakk>\n       \\<Longrightarrow> fixed_length_sublist (concat []) d i = [] ! i\n 2. \\<And>a xss i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>xs.\n                               xs \\<in> set xss \\<Longrightarrow>\n                               length xs = d;\n                    i < length xss\\<rbrakk>\n                   \\<Longrightarrow> fixed_length_sublist (concat xss) d i =\n                                     xss ! i;\n        \\<And>xs. xs \\<in> set (a # xss) \\<Longrightarrow> length xs = d;\n        i < length (a # xss)\\<rbrakk>\n       \\<Longrightarrow> fixed_length_sublist (concat (a # xss)) d i =\n                         (a # xss) ! i", "case Nil"], ["proof (state)\nthis:\n  ?xs \\<in> set [] \\<Longrightarrow> length ?xs = d\n  i < length []\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<And>xs. xs \\<in> set [] \\<Longrightarrow> length xs = d;\n        i < length []\\<rbrakk>\n       \\<Longrightarrow> fixed_length_sublist (concat []) d i = [] ! i\n 2. \\<And>a xss i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>xs.\n                               xs \\<in> set xss \\<Longrightarrow>\n                               length xs = d;\n                    i < length xss\\<rbrakk>\n                   \\<Longrightarrow> fixed_length_sublist (concat xss) d i =\n                                     xss ! i;\n        \\<And>xs. xs \\<in> set (a # xss) \\<Longrightarrow> length xs = d;\n        i < length (a # xss)\\<rbrakk>\n       \\<Longrightarrow> fixed_length_sublist (concat (a # xss)) d i =\n                         (a # xss) ! i", "then"], ["proof (chain)\npicking this:\n  ?xs \\<in> set [] \\<Longrightarrow> length ?xs = d\n  i < length []", "show ?case"], ["proof (prove)\nusing this:\n  ?xs \\<in> set [] \\<Longrightarrow> length ?xs = d\n  i < length []\n\ngoal (1 subgoal):\n 1. fixed_length_sublist (concat []) d i = [] ! i", "by simp"], ["proof (state)\nthis:\n  fixed_length_sublist (concat []) d i = [] ! i\n\ngoal (1 subgoal):\n 1. \\<And>a xss i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>xs.\n                               xs \\<in> set xss \\<Longrightarrow>\n                               length xs = d;\n                    i < length xss\\<rbrakk>\n                   \\<Longrightarrow> fixed_length_sublist (concat xss) d i =\n                                     xss ! i;\n        \\<And>xs. xs \\<in> set (a # xss) \\<Longrightarrow> length xs = d;\n        i < length (a # xss)\\<rbrakk>\n       \\<Longrightarrow> fixed_length_sublist (concat (a # xss)) d i =\n                         (a # xss) ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xss i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>xs.\n                               xs \\<in> set xss \\<Longrightarrow>\n                               length xs = d;\n                    i < length xss\\<rbrakk>\n                   \\<Longrightarrow> fixed_length_sublist (concat xss) d i =\n                                     xss ! i;\n        \\<And>xs. xs \\<in> set (a # xss) \\<Longrightarrow> length xs = d;\n        i < length (a # xss)\\<rbrakk>\n       \\<Longrightarrow> fixed_length_sublist (concat (a # xss)) d i =\n                         (a # xss) ! i", "case (Cons xs xss)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>xs. xs \\<in> set xss \\<Longrightarrow> length xs = d;\n   ?i < length xss\\<rbrakk>\n  \\<Longrightarrow> fixed_length_sublist (concat xss) d ?i = xss ! ?i\n  ?xs \\<in> set (xs # xss) \\<Longrightarrow> length ?xs = d\n  i < length (xs # xss)\n\ngoal (1 subgoal):\n 1. \\<And>a xss i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>xs.\n                               xs \\<in> set xss \\<Longrightarrow>\n                               length xs = d;\n                    i < length xss\\<rbrakk>\n                   \\<Longrightarrow> fixed_length_sublist (concat xss) d i =\n                                     xss ! i;\n        \\<And>xs. xs \\<in> set (a # xss) \\<Longrightarrow> length xs = d;\n        i < length (a # xss)\\<rbrakk>\n       \\<Longrightarrow> fixed_length_sublist (concat (a # xss)) d i =\n                         (a # xss) ! i", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>xs. xs \\<in> set xss \\<Longrightarrow> length xs = d;\n   ?i < length xss\\<rbrakk>\n  \\<Longrightarrow> fixed_length_sublist (concat xss) d ?i = xss ! ?i\n  ?xs \\<in> set (xs # xss) \\<Longrightarrow> length ?xs = d\n  i < length (xs # xss)", "have \"length (concat xss) = length xss * d\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>xs. xs \\<in> set xss \\<Longrightarrow> length xs = d;\n   ?i < length xss\\<rbrakk>\n  \\<Longrightarrow> fixed_length_sublist (concat xss) d ?i = xss ! ?i\n  ?xs \\<in> set (xs # xss) \\<Longrightarrow> length ?xs = d\n  i < length (xs # xss)\n\ngoal (1 subgoal):\n 1. length (concat xss) = length xss * d", "by (simp add: Cons.prems(1) concat_equal_length)"], ["proof (state)\nthis:\n  length (concat xss) = length xss * d\n\ngoal (1 subgoal):\n 1. \\<And>a xss i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>\\<And>xs.\n                               xs \\<in> set xss \\<Longrightarrow>\n                               length xs = d;\n                    i < length xss\\<rbrakk>\n                   \\<Longrightarrow> fixed_length_sublist (concat xss) d i =\n                                     xss ! i;\n        \\<And>xs. xs \\<in> set (a # xss) \\<Longrightarrow> length xs = d;\n        i < length (a # xss)\\<rbrakk>\n       \\<Longrightarrow> fixed_length_sublist (concat (a # xss)) d i =\n                         (a # xss) ! i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fixed_length_sublist (concat (xs # xss)) d i = (xs # xss) ! i", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    fixed_length_sublist (concat (xs # xss)) d i = (xs # xss) ! i\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       fixed_length_sublist (concat (xs # xss)) d i = (xs # xss) ! i", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    fixed_length_sublist (concat (xs # xss)) d i = (xs # xss) ! i\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       fixed_length_sublist (concat (xs # xss)) d i = (xs # xss) ! i", "then"], ["proof (chain)\npicking this:\n  i = 0", "have \"fixed_length_sublist (concat (xs # xss)) d i = xs\""], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. fixed_length_sublist (concat (xs # xss)) d i = xs", "unfolding fixed_length_sublist_def"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. take d (drop (d * i) (concat (xs # xss))) = xs", "by (simp add: Cons.prems(1))"], ["proof (state)\nthis:\n  fixed_length_sublist (concat (xs # xss)) d i = xs\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    fixed_length_sublist (concat (xs # xss)) d i = (xs # xss) ! i\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       fixed_length_sublist (concat (xs # xss)) d i = (xs # xss) ! i", "then"], ["proof (chain)\npicking this:\n  fixed_length_sublist (concat (xs # xss)) d i = xs", "show ?thesis"], ["proof (prove)\nusing this:\n  fixed_length_sublist (concat (xs # xss)) d i = xs\n\ngoal (1 subgoal):\n 1. fixed_length_sublist (concat (xs # xss)) d i = (xs # xss) ! i", "using 0"], ["proof (prove)\nusing this:\n  fixed_length_sublist (concat (xs # xss)) d i = xs\n  i = 0\n\ngoal (1 subgoal):\n 1. fixed_length_sublist (concat (xs # xss)) d i = (xs # xss) ! i", "by auto"], ["proof (state)\nthis:\n  fixed_length_sublist (concat (xs # xss)) d i = (xs # xss) ! i\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       fixed_length_sublist (concat (xs # xss)) d i = (xs # xss) ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       fixed_length_sublist (concat (xs # xss)) d i = (xs # xss) ! i", "case (Suc i')"], ["proof (state)\nthis:\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       fixed_length_sublist (concat (xs # xss)) d i = (xs # xss) ! i", "then"], ["proof (chain)\npicking this:\n  i = Suc i'", "have \"fixed_length_sublist (concat xss) d i' = xss ! i'\""], ["proof (prove)\nusing this:\n  i = Suc i'\n\ngoal (1 subgoal):\n 1. fixed_length_sublist (concat xss) d i' = xss ! i'", "using Cons"], ["proof (prove)\nusing this:\n  i = Suc i'\n  \\<lbrakk>\\<And>xs. xs \\<in> set xss \\<Longrightarrow> length xs = d;\n   ?i < length xss\\<rbrakk>\n  \\<Longrightarrow> fixed_length_sublist (concat xss) d ?i = xss ! ?i\n  ?xs \\<in> set (xs # xss) \\<Longrightarrow> length ?xs = d\n  i < length (xs # xss)\n\ngoal (1 subgoal):\n 1. fixed_length_sublist (concat xss) d i' = xss ! i'", "by auto"], ["proof (state)\nthis:\n  fixed_length_sublist (concat xss) d i' = xss ! i'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       fixed_length_sublist (concat (xs # xss)) d i = (xs # xss) ! i", "then"], ["proof (chain)\npicking this:\n  fixed_length_sublist (concat xss) d i' = xss ! i'", "show ?thesis"], ["proof (prove)\nusing this:\n  fixed_length_sublist (concat xss) d i' = xss ! i'\n\ngoal (1 subgoal):\n 1. fixed_length_sublist (concat (xs # xss)) d i = (xs # xss) ! i", "unfolding fixed_length_sublist_def"], ["proof (prove)\nusing this:\n  take d (drop (d * i') (concat xss)) = xss ! i'\n\ngoal (1 subgoal):\n 1. take d (drop (d * i) (concat (xs # xss))) = (xs # xss) ! i", "using Suc Cons.prems(1)"], ["proof (prove)\nusing this:\n  take d (drop (d * i') (concat xss)) = xss ! i'\n  i = Suc i'\n  ?xs \\<in> set (xs # xss) \\<Longrightarrow> length ?xs = d\n\ngoal (1 subgoal):\n 1. take d (drop (d * i) (concat (xs # xss))) = (xs # xss) ! i", "by auto"], ["proof (state)\nthis:\n  fixed_length_sublist (concat (xs # xss)) d i = (xs # xss) ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fixed_length_sublist (concat (xs # xss)) d i = (xs # xss) ! i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma concat_parts':\nassumes \"\\<And>i. i<a \\<Longrightarrow> length (f i) = d\"\nand \"i<a\"\nshows \"fixed_length_sublist (concat (map (\\<lambda>i. f i) [0..<a])) d i = f i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fixed_length_sublist (concat (map f [0..<a])) d i = f i", "using assms"], ["proof (prove)\nusing this:\n  ?i < a \\<Longrightarrow> length (f ?i) = d\n  i < a\n\ngoal (1 subgoal):\n 1. fixed_length_sublist (concat (map f [0..<a])) d i = f i", "proof (induction a)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i. i < 0 \\<Longrightarrow> length (f i) = d;\n     i < 0\\<rbrakk>\n    \\<Longrightarrow> fixed_length_sublist (concat (map f [0..<0])) d i =\n                      f i\n 2. \\<And>a.\n       \\<lbrakk>\\<lbrakk>\\<And>i. i < a \\<Longrightarrow> length (f i) = d;\n                 i < a\\<rbrakk>\n                \\<Longrightarrow> fixed_length_sublist\n                                   (concat (map f [0..<a])) d i =\n                                  f i;\n        \\<And>i. i < Suc a \\<Longrightarrow> length (f i) = d;\n        i < Suc a\\<rbrakk>\n       \\<Longrightarrow> fixed_length_sublist (concat (map f [0..<Suc a])) d\n                          i =\n                         f i", "case 0"], ["proof (state)\nthis:\n  ?i < 0 \\<Longrightarrow> length (f ?i) = d\n  i < 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i. i < 0 \\<Longrightarrow> length (f i) = d;\n     i < 0\\<rbrakk>\n    \\<Longrightarrow> fixed_length_sublist (concat (map f [0..<0])) d i =\n                      f i\n 2. \\<And>a.\n       \\<lbrakk>\\<lbrakk>\\<And>i. i < a \\<Longrightarrow> length (f i) = d;\n                 i < a\\<rbrakk>\n                \\<Longrightarrow> fixed_length_sublist\n                                   (concat (map f [0..<a])) d i =\n                                  f i;\n        \\<And>i. i < Suc a \\<Longrightarrow> length (f i) = d;\n        i < Suc a\\<rbrakk>\n       \\<Longrightarrow> fixed_length_sublist (concat (map f [0..<Suc a])) d\n                          i =\n                         f i", "then"], ["proof (chain)\npicking this:\n  ?i < 0 \\<Longrightarrow> length (f ?i) = d\n  i < 0", "show ?case"], ["proof (prove)\nusing this:\n  ?i < 0 \\<Longrightarrow> length (f ?i) = d\n  i < 0\n\ngoal (1 subgoal):\n 1. fixed_length_sublist (concat (map f [0..<0])) d i = f i", "by simp"], ["proof (state)\nthis:\n  fixed_length_sublist (concat (map f [0..<0])) d i = f i\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>\\<And>i. i < a \\<Longrightarrow> length (f i) = d;\n                 i < a\\<rbrakk>\n                \\<Longrightarrow> fixed_length_sublist\n                                   (concat (map f [0..<a])) d i =\n                                  f i;\n        \\<And>i. i < Suc a \\<Longrightarrow> length (f i) = d;\n        i < Suc a\\<rbrakk>\n       \\<Longrightarrow> fixed_length_sublist (concat (map f [0..<Suc a])) d\n                          i =\n                         f i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>\\<And>i. i < a \\<Longrightarrow> length (f i) = d;\n                 i < a\\<rbrakk>\n                \\<Longrightarrow> fixed_length_sublist\n                                   (concat (map f [0..<a])) d i =\n                                  f i;\n        \\<And>i. i < Suc a \\<Longrightarrow> length (f i) = d;\n        i < Suc a\\<rbrakk>\n       \\<Longrightarrow> fixed_length_sublist (concat (map f [0..<Suc a])) d\n                          i =\n                         f i", "case (Suc a)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>i. i < a \\<Longrightarrow> length (f i) = d; i < a\\<rbrakk>\n  \\<Longrightarrow> fixed_length_sublist (concat (map f [0..<a])) d i = f i\n  ?i < Suc a \\<Longrightarrow> length (f ?i) = d\n  i < Suc a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>\\<And>i. i < a \\<Longrightarrow> length (f i) = d;\n                 i < a\\<rbrakk>\n                \\<Longrightarrow> fixed_length_sublist\n                                   (concat (map f [0..<a])) d i =\n                                  f i;\n        \\<And>i. i < Suc a \\<Longrightarrow> length (f i) = d;\n        i < Suc a\\<rbrakk>\n       \\<Longrightarrow> fixed_length_sublist (concat (map f [0..<Suc a])) d\n                          i =\n                         f i", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>i. i < a \\<Longrightarrow> length (f i) = d; i < a\\<rbrakk>\n  \\<Longrightarrow> fixed_length_sublist (concat (map f [0..<a])) d i = f i\n  ?i < Suc a \\<Longrightarrow> length (f ?i) = d\n  i < Suc a", "have \"(\\<And>i. i < a \\<Longrightarrow> length (f i) = d)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>i. i < a \\<Longrightarrow> length (f i) = d; i < a\\<rbrakk>\n  \\<Longrightarrow> fixed_length_sublist (concat (map f [0..<a])) d i = f i\n  ?i < Suc a \\<Longrightarrow> length (f ?i) = d\n  i < Suc a\n\ngoal (1 subgoal):\n 1. \\<And>i. i < a \\<Longrightarrow> length (f i) = d", "by auto"], ["proof (state)\nthis:\n  ?i < a \\<Longrightarrow> length (f ?i) = d\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>\\<And>i. i < a \\<Longrightarrow> length (f i) = d;\n                 i < a\\<rbrakk>\n                \\<Longrightarrow> fixed_length_sublist\n                                   (concat (map f [0..<a])) d i =\n                                  f i;\n        \\<And>i. i < Suc a \\<Longrightarrow> length (f i) = d;\n        i < Suc a\\<rbrakk>\n       \\<Longrightarrow> fixed_length_sublist (concat (map f [0..<Suc a])) d\n                          i =\n                         f i", "then"], ["proof (chain)\npicking this:\n  ?i < a \\<Longrightarrow> length (f ?i) = d", "have \"length (concat (map f [0..<a])) = a*d\""], ["proof (prove)\nusing this:\n  ?i < a \\<Longrightarrow> length (f ?i) = d\n\ngoal (1 subgoal):\n 1. length (concat (map f [0..<a])) = a * d", "using concat_equal_length_map"], ["proof (prove)\nusing this:\n  ?i < a \\<Longrightarrow> length (f ?i) = d\n  (\\<And>i. i < ?a \\<Longrightarrow> length (?f i) = ?d) \\<Longrightarrow>\n  length (concat (map ?f [0..<?a])) = ?a * ?d\n\ngoal (1 subgoal):\n 1. length (concat (map f [0..<a])) = a * d", "by auto"], ["proof (state)\nthis:\n  length (concat (map f [0..<a])) = a * d\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lbrakk>\\<And>i. i < a \\<Longrightarrow> length (f i) = d;\n                 i < a\\<rbrakk>\n                \\<Longrightarrow> fixed_length_sublist\n                                   (concat (map f [0..<a])) d i =\n                                  f i;\n        \\<And>i. i < Suc a \\<Longrightarrow> length (f i) = d;\n        i < Suc a\\<rbrakk>\n       \\<Longrightarrow> fixed_length_sublist (concat (map f [0..<Suc a])) d\n                          i =\n                         f i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fixed_length_sublist (concat (map f [0..<Suc a])) d i = f i", "proof (cases \"i=a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = a \\<Longrightarrow>\n    fixed_length_sublist (concat (map f [0..<Suc a])) d i = f i\n 2. i \\<noteq> a \\<Longrightarrow>\n    fixed_length_sublist (concat (map f [0..<Suc a])) d i = f i", "assume \"i=a\""], ["proof (state)\nthis:\n  i = a\n\ngoal (2 subgoals):\n 1. i = a \\<Longrightarrow>\n    fixed_length_sublist (concat (map f [0..<Suc a])) d i = f i\n 2. i \\<noteq> a \\<Longrightarrow>\n    fixed_length_sublist (concat (map f [0..<Suc a])) d i = f i", "then"], ["proof (chain)\npicking this:\n  i = a", "have \"fixed_length_sublist (concat (map f [0..<Suc a])) d i = f a\""], ["proof (prove)\nusing this:\n  i = a\n\ngoal (1 subgoal):\n 1. fixed_length_sublist (concat (map f [0..<Suc a])) d i = f a", "by (simp add: Suc.prems(1) \\<open>length (concat (map f [0..<a])) = a * d\\<close> fixed_length_sublist_def)"], ["proof (state)\nthis:\n  fixed_length_sublist (concat (map f [0..<Suc a])) d i = f a\n\ngoal (2 subgoals):\n 1. i = a \\<Longrightarrow>\n    fixed_length_sublist (concat (map f [0..<Suc a])) d i = f i\n 2. i \\<noteq> a \\<Longrightarrow>\n    fixed_length_sublist (concat (map f [0..<Suc a])) d i = f i", "then"], ["proof (chain)\npicking this:\n  fixed_length_sublist (concat (map f [0..<Suc a])) d i = f a", "show ?case"], ["proof (prove)\nusing this:\n  fixed_length_sublist (concat (map f [0..<Suc a])) d i = f a\n\ngoal (1 subgoal):\n 1. fixed_length_sublist (concat (map f [0..<Suc a])) d i = f i", "using \\<open>i=a\\<close>"], ["proof (prove)\nusing this:\n  fixed_length_sublist (concat (map f [0..<Suc a])) d i = f a\n  i = a\n\ngoal (1 subgoal):\n 1. fixed_length_sublist (concat (map f [0..<Suc a])) d i = f i", "by auto"], ["proof (state)\nthis:\n  fixed_length_sublist (concat (map f [0..<Suc a])) d i = f i\n\ngoal (1 subgoal):\n 1. i \\<noteq> a \\<Longrightarrow>\n    fixed_length_sublist (concat (map f [0..<Suc a])) d i = f i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> a \\<Longrightarrow>\n    fixed_length_sublist (concat (map f [0..<Suc a])) d i = f i", "assume \"i\\<noteq>a\""], ["proof (state)\nthis:\n  i \\<noteq> a\n\ngoal (1 subgoal):\n 1. i \\<noteq> a \\<Longrightarrow>\n    fixed_length_sublist (concat (map f [0..<Suc a])) d i = f i", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> a", "have \"fixed_length_sublist (concat (map f [0..<a])) d i = f i\"\n      \"concat (map f [0..<Suc a]) = concat (map f [0..<a]) @ f a\""], ["proof (prove)\nusing this:\n  i \\<noteq> a\n\ngoal (1 subgoal):\n 1. fixed_length_sublist (concat (map f [0..<a])) d i = f i &&&\n    concat (map f [0..<Suc a]) = concat (map f [0..<a]) @ f a", "using Suc"], ["proof (prove)\nusing this:\n  i \\<noteq> a\n  \\<lbrakk>\\<And>i. i < a \\<Longrightarrow> length (f i) = d; i < a\\<rbrakk>\n  \\<Longrightarrow> fixed_length_sublist (concat (map f [0..<a])) d i = f i\n  ?i < Suc a \\<Longrightarrow> length (f ?i) = d\n  i < Suc a\n\ngoal (1 subgoal):\n 1. fixed_length_sublist (concat (map f [0..<a])) d i = f i &&&\n    concat (map f [0..<Suc a]) = concat (map f [0..<a]) @ f a", "by auto"], ["proof (state)\nthis:\n  fixed_length_sublist (concat (map f [0..<a])) d i = f i\n  concat (map f [0..<Suc a]) = concat (map f [0..<a]) @ f a\n\ngoal (1 subgoal):\n 1. i \\<noteq> a \\<Longrightarrow>\n    fixed_length_sublist (concat (map f [0..<Suc a])) d i = f i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fixed_length_sublist (concat (map f [0..<Suc a])) d i = f i", "unfolding \\<open>concat (map f [0..<Suc a]) = concat (map f [0..<a]) @ f a\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. fixed_length_sublist (concat (map f [0..<a]) @ f a) d i = f i", "unfolding fixed_length_sublist_def drop_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. take d\n     (drop (d * i) (concat (map f [0..<a])) @\n      drop (d * i - length (concat (map f [0..<a]))) (f a)) =\n    f i", "using  \\<open>length (concat (map f [0..<a])) = a * d\\<close>  \\<open>fixed_length_sublist (concat (map f [0..<a])) d i = f i\\<close>"], ["proof (prove)\nusing this:\n  length (concat (map f [0..<a])) = a * d\n  fixed_length_sublist (concat (map f [0..<a])) d i = f i\n\ngoal (1 subgoal):\n 1. take d\n     (drop (d * i) (concat (map f [0..<a])) @\n      drop (d * i - length (concat (map f [0..<a]))) (f a)) =\n    f i", "using append_assoc append_eq_conv_conj append_take_drop_id assms(1) assms(2)  fixed_length_sublist_def"], ["proof (prove)\nusing this:\n  length (concat (map f [0..<a])) = a * d\n  fixed_length_sublist (concat (map f [0..<a])) d i = f i\n  (?xs @ ?ys) @ ?zs = ?xs @ ?ys @ ?zs\n  (?xs @ ?ys = ?zs) =\n  (?xs = take (length ?xs) ?zs \\<and> ?ys = drop (length ?xs) ?zs)\n  take ?n ?xs @ drop ?n ?xs = ?xs\n  ?i < a \\<Longrightarrow> length (f ?i) = d\n  i < a\n  fixed_length_sublist ?xs ?l ?i = take ?l (drop (?l * ?i) ?xs)\n\ngoal (1 subgoal):\n 1. take d\n     (drop (d * i) (concat (map f [0..<a])) @\n      drop (d * i - length (concat (map f [0..<a]))) (f a)) =\n    f i", "by metis"], ["proof (state)\nthis:\n  fixed_length_sublist (concat (map f [0..<Suc a])) d i = f i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fixed_length_sublist (concat (map f [0..<Suc a])) d i = f i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_tensor_vec_from_lookup:\n\"length (tensor_vec_from_lookup ds e) = prod_list ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (tensor_vec_from_lookup ds e) = prod_list ds", "by (induction ds arbitrary:e; auto simp add: concat_equal_length_map)"], ["", "lemma lookup_tensor_vec:\nassumes \"is\\<lhd>ds\"\nshows \"lookup_base ds (tensor_vec_from_lookup ds e) is = e is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_base ds (tensor_vec_from_lookup ds e) is = e is", "using assms"], ["proof (prove)\nusing this:\n  is \\<lhd> ds\n\ngoal (1 subgoal):\n 1. lookup_base ds (tensor_vec_from_lookup ds e) is = e is", "proof (induction arbitrary:e rule:valid_index.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e. lookup_base [] (tensor_vec_from_lookup [] e) [] = e []\n 2. \\<And>is ds i d e.\n       \\<lbrakk>is \\<lhd> ds;\n        \\<And>e. lookup_base ds (tensor_vec_from_lookup ds e) is = e is;\n        i < d\\<rbrakk>\n       \\<Longrightarrow> lookup_base (d # ds)\n                          (tensor_vec_from_lookup (d # ds) e) (i # is) =\n                         e (i # is)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>e. lookup_base [] (tensor_vec_from_lookup [] e) [] = e []\n 2. \\<And>is ds i d e.\n       \\<lbrakk>is \\<lhd> ds;\n        \\<And>e. lookup_base ds (tensor_vec_from_lookup ds e) is = e is;\n        i < d\\<rbrakk>\n       \\<Longrightarrow> lookup_base (d # ds)\n                          (tensor_vec_from_lookup (d # ds) e) (i # is) =\n                         e (i # is)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_base [] (tensor_vec_from_lookup [] e) [] = e []", "by simp"], ["proof (state)\nthis:\n  lookup_base [] (tensor_vec_from_lookup [] e) [] = e []\n\ngoal (1 subgoal):\n 1. \\<And>is ds i d e.\n       \\<lbrakk>is \\<lhd> ds;\n        \\<And>e. lookup_base ds (tensor_vec_from_lookup ds e) is = e is;\n        i < d\\<rbrakk>\n       \\<Longrightarrow> lookup_base (d # ds)\n                          (tensor_vec_from_lookup (d # ds) e) (i # is) =\n                         e (i # is)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is ds i d e.\n       \\<lbrakk>is \\<lhd> ds;\n        \\<And>e. lookup_base ds (tensor_vec_from_lookup ds e) is = e is;\n        i < d\\<rbrakk>\n       \\<Longrightarrow> lookup_base (d # ds)\n                          (tensor_vec_from_lookup (d # ds) e) (i # is) =\n                         e (i # is)", "case (Cons \"is\" ds i d e)"], ["proof (state)\nthis:\n  is \\<lhd> ds\n  i < d\n  lookup_base ds (tensor_vec_from_lookup ds ?e) is = ?e is\n\ngoal (1 subgoal):\n 1. \\<And>is ds i d e.\n       \\<lbrakk>is \\<lhd> ds;\n        \\<And>e. lookup_base ds (tensor_vec_from_lookup ds e) is = e is;\n        i < d\\<rbrakk>\n       \\<Longrightarrow> lookup_base (d # ds)\n                          (tensor_vec_from_lookup (d # ds) e) (i # is) =\n                         e (i # is)", "then"], ["proof (chain)\npicking this:\n  is \\<lhd> ds\n  i < d\n  lookup_base ds (tensor_vec_from_lookup ds ?e) is = ?e is", "show ?case"], ["proof (prove)\nusing this:\n  is \\<lhd> ds\n  i < d\n  lookup_base ds (tensor_vec_from_lookup ds ?e) is = ?e is\n\ngoal (1 subgoal):\n 1. lookup_base (d # ds) (tensor_vec_from_lookup (d # ds) e) (i # is) =\n    e (i # is)", "unfolding tensor_vec_from_lookup_Cons lookup_base_Cons"], ["proof (prove)\nusing this:\n  is \\<lhd> ds\n  i < d\n  lookup_base ds (tensor_vec_from_lookup ds ?e) is = ?e is\n\ngoal (1 subgoal):\n 1. lookup_base ds\n     (fixed_length_sublist\n       (concat\n         (map (\\<lambda>i.\n                  tensor_vec_from_lookup ds (\\<lambda>is. e (i # is)))\n           [0..<d]))\n       (prod_list ds) i)\n     is =\n    e (i # is)", "by (simp add: length_tensor_vec_from_lookup concat_parts'[of d \"\\<lambda>i. tensor_vec_from_lookup ds (\\<lambda>is. e (i # is))\" \"prod_list ds\" i] \\<open>i < d\\<close>)"], ["proof (state)\nthis:\n  lookup_base (d # ds) (tensor_vec_from_lookup (d # ds) e) (i # is) =\n  e (i # is)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_tensor_from_lookup:\nassumes \"is\\<lhd>ds\"\nshows \"lookup (tensor_from_lookup ds e) is = e is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (tensor_from_lookup ds e) is = e is", "unfolding lookup_def tensor_from_lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_base (dims (tensor_from_vec ds (tensor_vec_from_lookup ds e)))\n     (vec (tensor_from_vec ds (tensor_vec_from_lookup ds e))) is =\n    e is", "by (simp add: lookup_tensor_vec assms length_tensor_vec_from_lookup)"], ["", "lemma dims_tensor_from_lookup: \"dims (tensor_from_lookup ds e) = ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dims (tensor_from_lookup ds e) = ds", "unfolding tensor_from_lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dims (tensor_from_vec ds (tensor_vec_from_lookup ds e)) = ds", "by (simp add: length_tensor_vec_from_lookup)"], ["", "lemma tensor_lookup_cong:\nassumes \"tensor_from_lookup ds e\\<^sub>1 = tensor_from_lookup ds e\\<^sub>2\"\nand \"is\\<lhd>ds\"\nshows \"e\\<^sub>1 is = e\\<^sub>2 is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e\\<^sub>1 is = e\\<^sub>2 is", "using assms lookup_tensor_from_lookup"], ["proof (prove)\nusing this:\n  tensor_from_lookup ds e\\<^sub>1 = tensor_from_lookup ds e\\<^sub>2\n  is \\<lhd> ds\n  ?is \\<lhd> ?ds \\<Longrightarrow>\n  lookup (tensor_from_lookup ?ds ?e) ?is = ?e ?is\n\ngoal (1 subgoal):\n 1. e\\<^sub>1 is = e\\<^sub>2 is", "by metis"], ["", "lemma tensor_from_lookup_eqI:\nassumes \"\\<And>is. is\\<lhd>ds \\<Longrightarrow> e\\<^sub>1 is = e\\<^sub>2 is\"\nshows \"tensor_from_lookup ds e\\<^sub>1 = tensor_from_lookup ds e\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_from_lookup ds e\\<^sub>1 = tensor_from_lookup ds e\\<^sub>2", "by (metis assms lookup_tensor_vec length_tensor_vec_from_lookup tensor_lookup_base tensor_from_lookup_def)"], ["", "lemma tensor_lookup_eqI:\nassumes \"dims A = dims B\" and \"\\<And>is. is\\<lhd>(dims A) \\<Longrightarrow> lookup A is = lookup B is\"\nshows \"A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = B", "by (metis assms(1) assms(2) tensor_lookup)"], ["", "end"]]}