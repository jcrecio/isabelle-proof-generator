{"file_name": "/home/qj213/afp-2021-10-22/thys/Deep_Learning/Tensor_Product.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Deep_Learning", "problem_names": ["lemma vec_tensor_prod[simp]: \"vec (A \\<otimes> B) = concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))\" (is ?V)\n  and dims_tensor_prod[simp]: \"dims (A \\<otimes> B) = dims A @ dims B\" (is ?D)", "lemma tensorprod_subtensor_base:\n  shows \"concat (map f (concat xss)) = concat (map (\\<lambda>xs. concat (map f xs)) xss)\"", "lemma subtensor_combine_tensor_prod:\n  assumes \"\\<And>A. A\\<in>set As \\<Longrightarrow> dims A = ds\"\n  shows \"subtensor_combine ds As \\<otimes> B = subtensor_combine (ds @ dims B) (map (\\<lambda>A. A \\<otimes> B) As)\"", "lemma subtensor_tensor_prod:\n  assumes \"dims A \\<noteq> []\" and \"i < hd (dims A)\"\n  shows \"subtensor (A \\<otimes> B) i = subtensor A i \\<otimes> B\"", "lemma lookup_tensor_prod[simp]:\n  assumes is1_valid:\"is1 \\<lhd> dims A\" and is2_valid:\"is2 \\<lhd> dims B\"\n  shows \"lookup (A \\<otimes> B) (is1 @ is2) = lookup A is1 * lookup B is2\"", "lemma valid_index_split:\n  assumes \"is \\<lhd> ds1 @ ds2\"\n  obtains is1 is2 where \"is1 @ is2 = is\" \"is1 \\<lhd> ds1\" \"is2 \\<lhd> ds2\"", "lemma tensor_prod_distr_left:\nassumes \"dims A = dims B\"\nshows \"(A + B) \\<otimes> C = (A \\<otimes> C) + (B \\<otimes> C)\"", "lemma tensor_prod_distr_right:\nassumes \"dims A = dims B\"\nshows \"C \\<otimes> (A + B) = (C \\<otimes> A) + (C \\<otimes> B)\"", "lemma tensor_one_from_lookup: \"1 = tensor_from_lookup [] (\\<lambda>_. 1)\"", "lemma order_tensor_one: \"order 1 = 0\"", "lemma smult_prod_extract1:\nfixes a::\"'a::comm_ring_1\"\nshows \"a \\<cdot> (A \\<otimes> B) = (a \\<cdot> A) \\<otimes> B\"", "lemma smult_prod_extract2:\nfixes a::\"'a::comm_ring_1\"\nshows \"a \\<cdot> (A \\<otimes> B) = A \\<otimes> (a \\<cdot> B)\"", "lemma order_0_multiple_of_one:\nassumes \"order A = 0\"\nobtains a where \"A = a \\<cdot> 1\"", "lemma smult_1:\nfixes A::\"'a::ring_1 tensor\"\nshows \"A = 1 \\<cdot> A\"", "lemma tensor0_prod_right[simp]: \"A \\<otimes> tensor0 ds = tensor0 (dims A @ ds)\"", "lemma tensor0_prod_left[simp]: \"tensor0 ds \\<otimes> A = tensor0 (ds @ dims A)\"", "lemma subtensor_prod_with_vec:\nassumes \"order A = 1\" \"i < hd (dims A)\"\nshows \"subtensor (A \\<otimes> B) i = lookup A [i] \\<cdot> B\""], "translations": [["", "lemma vec_tensor_prod[simp]: \"vec (A \\<otimes> B) = concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))\" (is ?V)\n  and dims_tensor_prod[simp]: \"dims (A \\<otimes> B) = dims A @ dims B\" (is ?D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec (local.tensor_prod_otimes A B) =\n    concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A)) &&&\n    dims (local.tensor_prod_otimes A B) = dims A @ dims B", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. vec (local.tensor_prod_otimes A B) =\n    concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))\n 2. dims (local.tensor_prod_otimes A B) = dims A @ dims B", "have \"length (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))) = prod_list (dims A @ dims B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))) =\n    prod_list (dims A @ dims B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))) =\n    prod_list (dims A @ dims B)", "have \"\\<And>xs. xs \\<in> set (map (\\<lambda>a. vec_smult a (vec B)) (vec A)) \\<Longrightarrow> length xs = length (vec B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> set (map (\\<lambda>a. vec_smult a (vec B))\n                      (vec A)) \\<Longrightarrow>\n       length xs = length (vec B)", "using length_vec_smult"], ["proof (prove)\nusing this:\n  length (vec_smult ?\\<alpha> ?v) = length ?v\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       xs \\<in> set (map (\\<lambda>a. vec_smult a (vec B))\n                      (vec A)) \\<Longrightarrow>\n       length xs = length (vec B)", "by force"], ["proof (state)\nthis:\n  ?xs\n  \\<in> set (map (\\<lambda>a. vec_smult a (vec B))\n              (vec A)) \\<Longrightarrow>\n  length ?xs = length (vec B)\n\ngoal (1 subgoal):\n 1. length (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))) =\n    prod_list (dims A @ dims B)", "then"], ["proof (chain)\npicking this:\n  ?xs\n  \\<in> set (map (\\<lambda>a. vec_smult a (vec B))\n              (vec A)) \\<Longrightarrow>\n  length ?xs = length (vec B)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?xs\n  \\<in> set (map (\\<lambda>a. vec_smult a (vec B))\n              (vec A)) \\<Longrightarrow>\n  length ?xs = length (vec B)\n\ngoal (1 subgoal):\n 1. length (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))) =\n    prod_list (dims A @ dims B)", "using concat_equal_length"], ["proof (prove)\nusing this:\n  ?xs\n  \\<in> set (map (\\<lambda>a. vec_smult a (vec B))\n              (vec A)) \\<Longrightarrow>\n  length ?xs = length (vec B)\n  (\\<And>xs.\n      xs \\<in> set ?xss \\<Longrightarrow> length xs = ?l) \\<Longrightarrow>\n  length (concat ?xss) = length ?xss * ?l\n\ngoal (1 subgoal):\n 1. length (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))) =\n    prod_list (dims A @ dims B)", "by (metis length_map length_vec prod_list.append)"], ["proof (state)\nthis:\n  length (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))) =\n  prod_list (dims A @ dims B)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))) =\n  prod_list (dims A @ dims B)\n\ngoal (2 subgoals):\n 1. vec (local.tensor_prod_otimes A B) =\n    concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))\n 2. dims (local.tensor_prod_otimes A B) = dims A @ dims B", "then"], ["proof (chain)\npicking this:\n  length (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))) =\n  prod_list (dims A @ dims B)", "show ?V ?D"], ["proof (prove)\nusing this:\n  length (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))) =\n  prod_list (dims A @ dims B)\n\ngoal (1 subgoal):\n 1. vec (local.tensor_prod_otimes A B) =\n    concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A)) &&&\n    dims (local.tensor_prod_otimes A B) = dims A @ dims B", "by (simp add: tensor_prod_def)+"], ["proof (state)\nthis:\n  vec (local.tensor_prod_otimes A B) =\n  concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))\n  dims (local.tensor_prod_otimes A B) = dims A @ dims B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tensorprod_subtensor_base:\n  shows \"concat (map f (concat xss)) = concat (map (\\<lambda>xs. concat (map f xs)) xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (map f (concat xss)) =\n    concat (map (\\<lambda>xs. concat (map f xs)) xss)", "by (induction xss; auto)"], ["", "lemma subtensor_combine_tensor_prod:\n  assumes \"\\<And>A. A\\<in>set As \\<Longrightarrow> dims A = ds\"\n  shows \"subtensor_combine ds As \\<otimes> B = subtensor_combine (ds @ dims B) (map (\\<lambda>A. A \\<otimes> B) As)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.tensor_prod_otimes (subtensor_combine ds As) B =\n    subtensor_combine (ds @ dims B)\n     (map (\\<lambda>A. local.tensor_prod_otimes A B) As)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.tensor_prod_otimes (subtensor_combine ds As) B =\n    subtensor_combine (ds @ dims B)\n     (map (\\<lambda>A. local.tensor_prod_otimes A B) As)", "let ?f = \"\\<lambda>a. vec_smult a (Tensor.vec B)\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.tensor_prod_otimes (subtensor_combine ds As) B =\n    subtensor_combine (ds @ dims B)\n     (map (\\<lambda>A. local.tensor_prod_otimes A B) As)", "let ?xss = \"map Tensor.vec As\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.tensor_prod_otimes (subtensor_combine ds As) B =\n    subtensor_combine (ds @ dims B)\n     (map (\\<lambda>A. local.tensor_prod_otimes A B) As)", "have 1:\"prod_list (length As # ds) = length (concat ?xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_list (length As # ds) = length (concat (map vec As))", "by (metis assms length_vec subtensor_combine_dims subtensor_combine_vec)"], ["proof (state)\nthis:\n  prod_list (length As # ds) = length (concat (map vec As))\n\ngoal (1 subgoal):\n 1. local.tensor_prod_otimes (subtensor_combine ds As) B =\n    subtensor_combine (ds @ dims B)\n     (map (\\<lambda>A. local.tensor_prod_otimes A B) As)", "have 2:\"\\<And>A. A\\<in>set As \\<Longrightarrow> prod_list (dims A @ dims B) = length (concat (map ?f (Tensor.vec A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> set As \\<Longrightarrow>\n       prod_list (dims A @ dims B) =\n       length (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A)))", "by (metis dims_tensor_prod length_vec vec_tensor_prod)"], ["proof (state)\nthis:\n  ?A \\<in> set As \\<Longrightarrow>\n  prod_list (dims ?A @ dims B) =\n  length (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec ?A)))\n\ngoal (1 subgoal):\n 1. local.tensor_prod_otimes (subtensor_combine ds As) B =\n    subtensor_combine (ds @ dims B)\n     (map (\\<lambda>A. local.tensor_prod_otimes A B) As)", "have 3: \"length As # ds @ dims B = (length (map (\\<lambda>A. tensor_from_vec (dims A @ dims B)\n      (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A)))) As) # ds @ dims B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length As # ds @ dims B =\n    length\n     (map (\\<lambda>A.\n              tensor_from_vec (dims A @ dims B)\n               (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))))\n       As) #\n    ds @ dims B", "by simp"], ["proof (state)\nthis:\n  length As # ds @ dims B =\n  length\n   (map (\\<lambda>A.\n            tensor_from_vec (dims A @ dims B)\n             (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))))\n     As) #\n  ds @ dims B\n\ngoal (1 subgoal):\n 1. local.tensor_prod_otimes (subtensor_combine ds As) B =\n    subtensor_combine (ds @ dims B)\n     (map (\\<lambda>A. local.tensor_prod_otimes A B) As)", "have 4:\"(concat (map (\\<lambda>xs. concat (map (\\<lambda>a. vec_smult a (vec B)) xs)) (map vec As)))\n         = (concat (map vec (map (\\<lambda>A. tensor_from_vec (dims A @ dims B) (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))))  As)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>xs. concat (map (\\<lambda>a. vec_smult a (vec B)) xs))\n       (map vec As)) =\n    concat\n     (map vec\n       (map (\\<lambda>A.\n                tensor_from_vec (dims A @ dims B)\n                 (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))))\n         As))", "unfolding map_map[unfolded comp_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>x.\n              concat (map (\\<lambda>a. vec_smult a (vec B)) (vec x)))\n       As) =\n    concat\n     (map (\\<lambda>x.\n              vec (tensor_from_vec (dims x @ dims B)\n                    (concat\n                      (map (\\<lambda>a. vec_smult a (vec B)) (vec x)))))\n       As)", "using vec_tensor"], ["proof (prove)\nusing this:\n  length ?v = prod_list ?d \\<Longrightarrow>\n  vec (tensor_from_vec ?d ?v) = ?v\n\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>x.\n              concat (map (\\<lambda>a. vec_smult a (vec B)) (vec x)))\n       As) =\n    concat\n     (map (\\<lambda>x.\n              vec (tensor_from_vec (dims x @ dims B)\n                    (concat\n                      (map (\\<lambda>a. vec_smult a (vec B)) (vec x)))))\n       As)", "by (metis (no_types, lifting) \"2\" map_eq_conv)"], ["proof (state)\nthis:\n  concat\n   (map (\\<lambda>xs. concat (map (\\<lambda>a. vec_smult a (vec B)) xs))\n     (map vec As)) =\n  concat\n   (map vec\n     (map (\\<lambda>A.\n              tensor_from_vec (dims A @ dims B)\n               (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))))\n       As))\n\ngoal (1 subgoal):\n 1. local.tensor_prod_otimes (subtensor_combine ds As) B =\n    subtensor_combine (ds @ dims B)\n     (map (\\<lambda>A. local.tensor_prod_otimes A B) As)", "have \"subtensor_combine ds As \\<otimes> B = tensor_from_vec (length As # ds @ dims B) (concat (map ?f (concat (?xss))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.tensor_prod_otimes (subtensor_combine ds As) B =\n    tensor_from_vec (length As # ds @ dims B)\n     (concat (map (\\<lambda>a. vec_smult a (vec B)) (concat (map vec As))))", "unfolding subtensor_combine_def tensor_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_from_vec\n     (dims (tensor_from_vec (length As # ds) (concat (map vec As))) @\n      dims B)\n     (concat\n       (map (\\<lambda>a. vec_smult a (vec B))\n         (vec (tensor_from_vec (length As # ds) (concat (map vec As)))))) =\n    tensor_from_vec (length As # ds @ dims B)\n     (concat (map (\\<lambda>a. vec_smult a (vec B)) (concat (map vec As))))", "using 1"], ["proof (prove)\nusing this:\n  prod_list (length As # ds) = length (concat (map vec As))\n\ngoal (1 subgoal):\n 1. tensor_from_vec\n     (dims (tensor_from_vec (length As # ds) (concat (map vec As))) @\n      dims B)\n     (concat\n       (map (\\<lambda>a. vec_smult a (vec B))\n         (vec (tensor_from_vec (length As # ds) (concat (map vec As)))))) =\n    tensor_from_vec (length As # ds @ dims B)\n     (concat (map (\\<lambda>a. vec_smult a (vec B)) (concat (map vec As))))", "by auto"], ["proof (state)\nthis:\n  local.tensor_prod_otimes (subtensor_combine ds As) B =\n  tensor_from_vec (length As # ds @ dims B)\n   (concat (map (\\<lambda>a. vec_smult a (vec B)) (concat (map vec As))))\n\ngoal (1 subgoal):\n 1. local.tensor_prod_otimes (subtensor_combine ds As) B =\n    subtensor_combine (ds @ dims B)\n     (map (\\<lambda>A. local.tensor_prod_otimes A B) As)", "also"], ["proof (state)\nthis:\n  local.tensor_prod_otimes (subtensor_combine ds As) B =\n  tensor_from_vec (length As # ds @ dims B)\n   (concat (map (\\<lambda>a. vec_smult a (vec B)) (concat (map vec As))))\n\ngoal (1 subgoal):\n 1. local.tensor_prod_otimes (subtensor_combine ds As) B =\n    subtensor_combine (ds @ dims B)\n     (map (\\<lambda>A. local.tensor_prod_otimes A B) As)", "have \"... = tensor_from_vec (length As # ds @ dims B) (concat (map (\\<lambda>xs. concat (map ?f xs)) ?xss))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_from_vec (length As # ds @ dims B)\n     (concat\n       (map (\\<lambda>a. vec_smult a (vec B)) (concat (map vec As)))) =\n    tensor_from_vec (length As # ds @ dims B)\n     (concat\n       (map (\\<lambda>xs. concat (map (\\<lambda>a. vec_smult a (vec B)) xs))\n         (map vec As)))", "using tensorprod_subtensor_base[of ?f ?xss]"], ["proof (prove)\nusing this:\n  concat (map (\\<lambda>a. vec_smult a (vec B)) (concat (map vec As))) =\n  concat\n   (map (\\<lambda>xs. concat (map (\\<lambda>a. vec_smult a (vec B)) xs))\n     (map vec As))\n\ngoal (1 subgoal):\n 1. tensor_from_vec (length As # ds @ dims B)\n     (concat\n       (map (\\<lambda>a. vec_smult a (vec B)) (concat (map vec As)))) =\n    tensor_from_vec (length As # ds @ dims B)\n     (concat\n       (map (\\<lambda>xs. concat (map (\\<lambda>a. vec_smult a (vec B)) xs))\n         (map vec As)))", "by auto"], ["proof (state)\nthis:\n  tensor_from_vec (length As # ds @ dims B)\n   (concat (map (\\<lambda>a. vec_smult a (vec B)) (concat (map vec As)))) =\n  tensor_from_vec (length As # ds @ dims B)\n   (concat\n     (map (\\<lambda>xs. concat (map (\\<lambda>a. vec_smult a (vec B)) xs))\n       (map vec As)))\n\ngoal (1 subgoal):\n 1. local.tensor_prod_otimes (subtensor_combine ds As) B =\n    subtensor_combine (ds @ dims B)\n     (map (\\<lambda>A. local.tensor_prod_otimes A B) As)", "also"], ["proof (state)\nthis:\n  tensor_from_vec (length As # ds @ dims B)\n   (concat (map (\\<lambda>a. vec_smult a (vec B)) (concat (map vec As)))) =\n  tensor_from_vec (length As # ds @ dims B)\n   (concat\n     (map (\\<lambda>xs. concat (map (\\<lambda>a. vec_smult a (vec B)) xs))\n       (map vec As)))\n\ngoal (1 subgoal):\n 1. local.tensor_prod_otimes (subtensor_combine ds As) B =\n    subtensor_combine (ds @ dims B)\n     (map (\\<lambda>A. local.tensor_prod_otimes A B) As)", "have \"... =subtensor_combine (ds @ dims B) (map (\\<lambda>A. A \\<otimes> B) As)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_from_vec (length As # ds @ dims B)\n     (concat\n       (map (\\<lambda>xs. concat (map (\\<lambda>a. vec_smult a (vec B)) xs))\n         (map vec As))) =\n    subtensor_combine (ds @ dims B)\n     (map (\\<lambda>A. local.tensor_prod_otimes A B) As)", "unfolding subtensor_combine_def tensor_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_from_vec (length As # ds @ dims B)\n     (concat\n       (map (\\<lambda>xs. concat (map (\\<lambda>a. vec_smult a (vec B)) xs))\n         (map vec As))) =\n    tensor_from_vec\n     (length\n       (map (\\<lambda>A.\n                tensor_from_vec (dims A @ dims B)\n                 (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))))\n         As) #\n      ds @ dims B)\n     (concat\n       (map vec\n         (map (\\<lambda>A.\n                  tensor_from_vec (dims A @ dims B)\n                   (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))))\n           As)))", "using 3 4"], ["proof (prove)\nusing this:\n  length As # ds @ dims B =\n  length\n   (map (\\<lambda>A.\n            tensor_from_vec (dims A @ dims B)\n             (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))))\n     As) #\n  ds @ dims B\n  concat\n   (map (\\<lambda>xs. concat (map (\\<lambda>a. vec_smult a (vec B)) xs))\n     (map vec As)) =\n  concat\n   (map vec\n     (map (\\<lambda>A.\n              tensor_from_vec (dims A @ dims B)\n               (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))))\n       As))\n\ngoal (1 subgoal):\n 1. tensor_from_vec (length As # ds @ dims B)\n     (concat\n       (map (\\<lambda>xs. concat (map (\\<lambda>a. vec_smult a (vec B)) xs))\n         (map vec As))) =\n    tensor_from_vec\n     (length\n       (map (\\<lambda>A.\n                tensor_from_vec (dims A @ dims B)\n                 (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))))\n         As) #\n      ds @ dims B)\n     (concat\n       (map vec\n         (map (\\<lambda>A.\n                  tensor_from_vec (dims A @ dims B)\n                   (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))))\n           As)))", "by metis"], ["proof (state)\nthis:\n  tensor_from_vec (length As # ds @ dims B)\n   (concat\n     (map (\\<lambda>xs. concat (map (\\<lambda>a. vec_smult a (vec B)) xs))\n       (map vec As))) =\n  subtensor_combine (ds @ dims B)\n   (map (\\<lambda>A. local.tensor_prod_otimes A B) As)\n\ngoal (1 subgoal):\n 1. local.tensor_prod_otimes (subtensor_combine ds As) B =\n    subtensor_combine (ds @ dims B)\n     (map (\\<lambda>A. local.tensor_prod_otimes A B) As)", "finally"], ["proof (chain)\npicking this:\n  local.tensor_prod_otimes (subtensor_combine ds As) B =\n  subtensor_combine (ds @ dims B)\n   (map (\\<lambda>A. local.tensor_prod_otimes A B) As)", "show ?thesis"], ["proof (prove)\nusing this:\n  local.tensor_prod_otimes (subtensor_combine ds As) B =\n  subtensor_combine (ds @ dims B)\n   (map (\\<lambda>A. local.tensor_prod_otimes A B) As)\n\ngoal (1 subgoal):\n 1. local.tensor_prod_otimes (subtensor_combine ds As) B =\n    subtensor_combine (ds @ dims B)\n     (map (\\<lambda>A. local.tensor_prod_otimes A B) As)", "by metis"], ["proof (state)\nthis:\n  local.tensor_prod_otimes (subtensor_combine ds As) B =\n  subtensor_combine (ds @ dims B)\n   (map (\\<lambda>A. local.tensor_prod_otimes A B) As)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* evtl. besser ohne Induktion beweisen? Dann w?re das obige Lemma unn?tig. Vllt aber auch schwierig. *)"], ["", "lemma subtensor_tensor_prod:\n  assumes \"dims A \\<noteq> []\" and \"i < hd (dims A)\"\n  shows \"subtensor (A \\<otimes> B) i = subtensor A i \\<otimes> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subtensor (local.tensor_prod_otimes A B) i =\n    local.tensor_prod_otimes (subtensor A i) B", "using assms"], ["proof (prove)\nusing this:\n  dims A \\<noteq> []\n  i < hd (dims A)\n\ngoal (1 subgoal):\n 1. subtensor (local.tensor_prod_otimes A B) i =\n    local.tensor_prod_otimes (subtensor A i) B", "proof (induction A rule:subtensor_combine_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>dims A = []; dims A \\<noteq> []; i < hd (dims A)\\<rbrakk>\n       \\<Longrightarrow> subtensor (local.tensor_prod_otimes A B) i =\n                         local.tensor_prod_otimes (subtensor A i) B\n 2. \\<And>As ds.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> set As; dims A \\<noteq> [];\n                    i < hd (dims A)\\<rbrakk>\n                   \\<Longrightarrow> subtensor\n(local.tensor_prod_otimes A B) i =\n                                     local.tensor_prod_otimes\n(subtensor A i) B;\n        \\<And>A. A \\<in> set As \\<Longrightarrow> dims A = ds;\n        dims (subtensor_combine ds As) \\<noteq> [];\n        i < hd (dims (subtensor_combine ds As))\\<rbrakk>\n       \\<Longrightarrow> subtensor\n                          (local.tensor_prod_otimes\n                            (subtensor_combine ds As) B)\n                          i =\n                         local.tensor_prod_otimes\n                          (subtensor (subtensor_combine ds As) i) B", "case order_0"], ["proof (state)\nthis:\n  dims A_ = []\n  dims A_ \\<noteq> []\n  i < hd (dims A_)\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>dims A = []; dims A \\<noteq> []; i < hd (dims A)\\<rbrakk>\n       \\<Longrightarrow> subtensor (local.tensor_prod_otimes A B) i =\n                         local.tensor_prod_otimes (subtensor A i) B\n 2. \\<And>As ds.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> set As; dims A \\<noteq> [];\n                    i < hd (dims A)\\<rbrakk>\n                   \\<Longrightarrow> subtensor\n(local.tensor_prod_otimes A B) i =\n                                     local.tensor_prod_otimes\n(subtensor A i) B;\n        \\<And>A. A \\<in> set As \\<Longrightarrow> dims A = ds;\n        dims (subtensor_combine ds As) \\<noteq> [];\n        i < hd (dims (subtensor_combine ds As))\\<rbrakk>\n       \\<Longrightarrow> subtensor\n                          (local.tensor_prod_otimes\n                            (subtensor_combine ds As) B)\n                          i =\n                         local.tensor_prod_otimes\n                          (subtensor (subtensor_combine ds As) i) B", "then"], ["proof (chain)\npicking this:\n  dims A_ = []\n  dims A_ \\<noteq> []\n  i < hd (dims A_)", "show ?case"], ["proof (prove)\nusing this:\n  dims A_ = []\n  dims A_ \\<noteq> []\n  i < hd (dims A_)\n\ngoal (1 subgoal):\n 1. subtensor (local.tensor_prod_otimes A_ B) i =\n    local.tensor_prod_otimes (subtensor A_ i) B", "by auto"], ["proof (state)\nthis:\n  subtensor (local.tensor_prod_otimes A_ B) i =\n  local.tensor_prod_otimes (subtensor A_ i) B\n\ngoal (1 subgoal):\n 1. \\<And>As ds.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> set As; dims A \\<noteq> [];\n                    i < hd (dims A)\\<rbrakk>\n                   \\<Longrightarrow> subtensor\n(local.tensor_prod_otimes A B) i =\n                                     local.tensor_prod_otimes\n(subtensor A i) B;\n        \\<And>A. A \\<in> set As \\<Longrightarrow> dims A = ds;\n        dims (subtensor_combine ds As) \\<noteq> [];\n        i < hd (dims (subtensor_combine ds As))\\<rbrakk>\n       \\<Longrightarrow> subtensor\n                          (local.tensor_prod_otimes\n                            (subtensor_combine ds As) B)\n                          i =\n                         local.tensor_prod_otimes\n                          (subtensor (subtensor_combine ds As) i) B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>As ds.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> set As; dims A \\<noteq> [];\n                    i < hd (dims A)\\<rbrakk>\n                   \\<Longrightarrow> subtensor\n(local.tensor_prod_otimes A B) i =\n                                     local.tensor_prod_otimes\n(subtensor A i) B;\n        \\<And>A. A \\<in> set As \\<Longrightarrow> dims A = ds;\n        dims (subtensor_combine ds As) \\<noteq> [];\n        i < hd (dims (subtensor_combine ds As))\\<rbrakk>\n       \\<Longrightarrow> subtensor\n                          (local.tensor_prod_otimes\n                            (subtensor_combine ds As) B)\n                          i =\n                         local.tensor_prod_otimes\n                          (subtensor (subtensor_combine ds As) i) B", "case (order_step As ds)"], ["proof (state)\nthis:\n  \\<lbrakk>?A \\<in> set As; dims ?A \\<noteq> []; i < hd (dims ?A)\\<rbrakk>\n  \\<Longrightarrow> subtensor (local.tensor_prod_otimes ?A B) i =\n                    local.tensor_prod_otimes (subtensor ?A i) B\n  ?A \\<in> set As \\<Longrightarrow> dims ?A = ds\n  dims (subtensor_combine ds As) \\<noteq> []\n  i < hd (dims (subtensor_combine ds As))\n\ngoal (1 subgoal):\n 1. \\<And>As ds.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> set As; dims A \\<noteq> [];\n                    i < hd (dims A)\\<rbrakk>\n                   \\<Longrightarrow> subtensor\n(local.tensor_prod_otimes A B) i =\n                                     local.tensor_prod_otimes\n(subtensor A i) B;\n        \\<And>A. A \\<in> set As \\<Longrightarrow> dims A = ds;\n        dims (subtensor_combine ds As) \\<noteq> [];\n        i < hd (dims (subtensor_combine ds As))\\<rbrakk>\n       \\<Longrightarrow> subtensor\n                          (local.tensor_prod_otimes\n                            (subtensor_combine ds As) B)\n                          i =\n                         local.tensor_prod_otimes\n                          (subtensor (subtensor_combine ds As) i) B", "have 1:\"i < length (map (\\<lambda>A. A \\<otimes> B) As)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (map (\\<lambda>A. local.tensor_prod_otimes A B) As)", "using order_step"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> set As; dims ?A \\<noteq> []; i < hd (dims ?A)\\<rbrakk>\n  \\<Longrightarrow> subtensor (local.tensor_prod_otimes ?A B) i =\n                    local.tensor_prod_otimes (subtensor ?A i) B\n  ?A \\<in> set As \\<Longrightarrow> dims ?A = ds\n  dims (subtensor_combine ds As) \\<noteq> []\n  i < hd (dims (subtensor_combine ds As))\n\ngoal (1 subgoal):\n 1. i < length (map (\\<lambda>A. local.tensor_prod_otimes A B) As)", "by (simp add: order_step.hyps order_step.prems(1))"], ["proof (state)\nthis:\n  i < length (map (\\<lambda>A. local.tensor_prod_otimes A B) As)\n\ngoal (1 subgoal):\n 1. \\<And>As ds.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> set As; dims A \\<noteq> [];\n                    i < hd (dims A)\\<rbrakk>\n                   \\<Longrightarrow> subtensor\n(local.tensor_prod_otimes A B) i =\n                                     local.tensor_prod_otimes\n(subtensor A i) B;\n        \\<And>A. A \\<in> set As \\<Longrightarrow> dims A = ds;\n        dims (subtensor_combine ds As) \\<noteq> [];\n        i < hd (dims (subtensor_combine ds As))\\<rbrakk>\n       \\<Longrightarrow> subtensor\n                          (local.tensor_prod_otimes\n                            (subtensor_combine ds As) B)\n                          i =\n                         local.tensor_prod_otimes\n                          (subtensor (subtensor_combine ds As) i) B", "have 2:\"(\\<And>A. A \\<in> set (map (\\<lambda>A. A \\<otimes> B) As) \\<Longrightarrow> dims A = ds @ dims B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> set (map (\\<lambda>A. local.tensor_prod_otimes A B)\n                     As) \\<Longrightarrow>\n       dims A = ds @ dims B", "using order_step"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> set As; dims ?A \\<noteq> []; i < hd (dims ?A)\\<rbrakk>\n  \\<Longrightarrow> subtensor (local.tensor_prod_otimes ?A B) i =\n                    local.tensor_prod_otimes (subtensor ?A i) B\n  ?A \\<in> set As \\<Longrightarrow> dims ?A = ds\n  dims (subtensor_combine ds As) \\<noteq> []\n  i < hd (dims (subtensor_combine ds As))\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> set (map (\\<lambda>A. local.tensor_prod_otimes A B)\n                     As) \\<Longrightarrow>\n       dims A = ds @ dims B", "by auto"], ["proof (state)\nthis:\n  ?A \\<in> set (map (\\<lambda>A. local.tensor_prod_otimes A B)\n                 As) \\<Longrightarrow>\n  dims ?A = ds @ dims B\n\ngoal (1 subgoal):\n 1. \\<And>As ds.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> set As; dims A \\<noteq> [];\n                    i < hd (dims A)\\<rbrakk>\n                   \\<Longrightarrow> subtensor\n(local.tensor_prod_otimes A B) i =\n                                     local.tensor_prod_otimes\n(subtensor A i) B;\n        \\<And>A. A \\<in> set As \\<Longrightarrow> dims A = ds;\n        dims (subtensor_combine ds As) \\<noteq> [];\n        i < hd (dims (subtensor_combine ds As))\\<rbrakk>\n       \\<Longrightarrow> subtensor\n                          (local.tensor_prod_otimes\n                            (subtensor_combine ds As) B)\n                          i =\n                         local.tensor_prod_otimes\n                          (subtensor (subtensor_combine ds As) i) B", "have \"subtensor (subtensor_combine ds As \\<otimes> B) i = subtensor (subtensor_combine (ds @ dims B) (map (\\<lambda>A. A \\<otimes> B) As)) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subtensor (local.tensor_prod_otimes (subtensor_combine ds As) B) i =\n    subtensor\n     (subtensor_combine (ds @ dims B)\n       (map (\\<lambda>A. local.tensor_prod_otimes A B) As))\n     i", "using subtensor_combine_tensor_prod order_step"], ["proof (prove)\nusing this:\n  (\\<And>A.\n      A \\<in> set ?As \\<Longrightarrow> dims A = ?ds) \\<Longrightarrow>\n  local.tensor_prod_otimes (subtensor_combine ?ds ?As) ?B =\n  subtensor_combine (?ds @ dims ?B)\n   (map (\\<lambda>A. local.tensor_prod_otimes A ?B) ?As)\n  \\<lbrakk>?A \\<in> set As; dims ?A \\<noteq> []; i < hd (dims ?A)\\<rbrakk>\n  \\<Longrightarrow> subtensor (local.tensor_prod_otimes ?A B) i =\n                    local.tensor_prod_otimes (subtensor ?A i) B\n  ?A \\<in> set As \\<Longrightarrow> dims ?A = ds\n  dims (subtensor_combine ds As) \\<noteq> []\n  i < hd (dims (subtensor_combine ds As))\n\ngoal (1 subgoal):\n 1. subtensor (local.tensor_prod_otimes (subtensor_combine ds As) B) i =\n    subtensor\n     (subtensor_combine (ds @ dims B)\n       (map (\\<lambda>A. local.tensor_prod_otimes A B) As))\n     i", "by metis"], ["proof (state)\nthis:\n  subtensor (local.tensor_prod_otimes (subtensor_combine ds As) B) i =\n  subtensor\n   (subtensor_combine (ds @ dims B)\n     (map (\\<lambda>A. local.tensor_prod_otimes A B) As))\n   i\n\ngoal (1 subgoal):\n 1. \\<And>As ds.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> set As; dims A \\<noteq> [];\n                    i < hd (dims A)\\<rbrakk>\n                   \\<Longrightarrow> subtensor\n(local.tensor_prod_otimes A B) i =\n                                     local.tensor_prod_otimes\n(subtensor A i) B;\n        \\<And>A. A \\<in> set As \\<Longrightarrow> dims A = ds;\n        dims (subtensor_combine ds As) \\<noteq> [];\n        i < hd (dims (subtensor_combine ds As))\\<rbrakk>\n       \\<Longrightarrow> subtensor\n                          (local.tensor_prod_otimes\n                            (subtensor_combine ds As) B)\n                          i =\n                         local.tensor_prod_otimes\n                          (subtensor (subtensor_combine ds As) i) B", "also"], ["proof (state)\nthis:\n  subtensor (local.tensor_prod_otimes (subtensor_combine ds As) B) i =\n  subtensor\n   (subtensor_combine (ds @ dims B)\n     (map (\\<lambda>A. local.tensor_prod_otimes A B) As))\n   i\n\ngoal (1 subgoal):\n 1. \\<And>As ds.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> set As; dims A \\<noteq> [];\n                    i < hd (dims A)\\<rbrakk>\n                   \\<Longrightarrow> subtensor\n(local.tensor_prod_otimes A B) i =\n                                     local.tensor_prod_otimes\n(subtensor A i) B;\n        \\<And>A. A \\<in> set As \\<Longrightarrow> dims A = ds;\n        dims (subtensor_combine ds As) \\<noteq> [];\n        i < hd (dims (subtensor_combine ds As))\\<rbrakk>\n       \\<Longrightarrow> subtensor\n                          (local.tensor_prod_otimes\n                            (subtensor_combine ds As) B)\n                          i =\n                         local.tensor_prod_otimes\n                          (subtensor (subtensor_combine ds As) i) B", "have \"... = As ! i \\<otimes> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subtensor\n     (subtensor_combine (ds @ dims B)\n       (map (\\<lambda>A. local.tensor_prod_otimes A B) As))\n     i =\n    local.tensor_prod_otimes (As ! i) B", "using order_step subtensor_subtensor_combine[of \"(map (\\<lambda>A. A \\<otimes> B) As)\" \"ds @ dims B\" i] 1 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> set As; dims ?A \\<noteq> []; i < hd (dims ?A)\\<rbrakk>\n  \\<Longrightarrow> subtensor (local.tensor_prod_otimes ?A B) i =\n                    local.tensor_prod_otimes (subtensor ?A i) B\n  ?A \\<in> set As \\<Longrightarrow> dims ?A = ds\n  dims (subtensor_combine ds As) \\<noteq> []\n  i < hd (dims (subtensor_combine ds As))\n  \\<lbrakk>\\<And>A.\n              A \\<in> set (map (\\<lambda>A. local.tensor_prod_otimes A B)\n                            As) \\<Longrightarrow>\n              dims A = ds @ dims B;\n   i < length (map (\\<lambda>A. local.tensor_prod_otimes A B) As)\\<rbrakk>\n  \\<Longrightarrow> subtensor\n                     (subtensor_combine (ds @ dims B)\n                       (map (\\<lambda>A. local.tensor_prod_otimes A B) As))\n                     i =\n                    map (\\<lambda>A. local.tensor_prod_otimes A B) As ! i\n  i < length (map (\\<lambda>A. local.tensor_prod_otimes A B) As)\n  ?A \\<in> set (map (\\<lambda>A. local.tensor_prod_otimes A B)\n                 As) \\<Longrightarrow>\n  dims ?A = ds @ dims B\n\ngoal (1 subgoal):\n 1. subtensor\n     (subtensor_combine (ds @ dims B)\n       (map (\\<lambda>A. local.tensor_prod_otimes A B) As))\n     i =\n    local.tensor_prod_otimes (As ! i) B", "by auto"], ["proof (state)\nthis:\n  subtensor\n   (subtensor_combine (ds @ dims B)\n     (map (\\<lambda>A. local.tensor_prod_otimes A B) As))\n   i =\n  local.tensor_prod_otimes (As ! i) B\n\ngoal (1 subgoal):\n 1. \\<And>As ds.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> set As; dims A \\<noteq> [];\n                    i < hd (dims A)\\<rbrakk>\n                   \\<Longrightarrow> subtensor\n(local.tensor_prod_otimes A B) i =\n                                     local.tensor_prod_otimes\n(subtensor A i) B;\n        \\<And>A. A \\<in> set As \\<Longrightarrow> dims A = ds;\n        dims (subtensor_combine ds As) \\<noteq> [];\n        i < hd (dims (subtensor_combine ds As))\\<rbrakk>\n       \\<Longrightarrow> subtensor\n                          (local.tensor_prod_otimes\n                            (subtensor_combine ds As) B)\n                          i =\n                         local.tensor_prod_otimes\n                          (subtensor (subtensor_combine ds As) i) B", "also"], ["proof (state)\nthis:\n  subtensor\n   (subtensor_combine (ds @ dims B)\n     (map (\\<lambda>A. local.tensor_prod_otimes A B) As))\n   i =\n  local.tensor_prod_otimes (As ! i) B\n\ngoal (1 subgoal):\n 1. \\<And>As ds.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> set As; dims A \\<noteq> [];\n                    i < hd (dims A)\\<rbrakk>\n                   \\<Longrightarrow> subtensor\n(local.tensor_prod_otimes A B) i =\n                                     local.tensor_prod_otimes\n(subtensor A i) B;\n        \\<And>A. A \\<in> set As \\<Longrightarrow> dims A = ds;\n        dims (subtensor_combine ds As) \\<noteq> [];\n        i < hd (dims (subtensor_combine ds As))\\<rbrakk>\n       \\<Longrightarrow> subtensor\n                          (local.tensor_prod_otimes\n                            (subtensor_combine ds As) B)\n                          i =\n                         local.tensor_prod_otimes\n                          (subtensor (subtensor_combine ds As) i) B", "have \"... = subtensor (subtensor_combine ds As) i \\<otimes> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.tensor_prod_otimes (As ! i) B =\n    local.tensor_prod_otimes (subtensor (subtensor_combine ds As) i) B", "by (metis \"1\" length_map order_step.hyps subtensor_subtensor_combine)"], ["proof (state)\nthis:\n  local.tensor_prod_otimes (As ! i) B =\n  local.tensor_prod_otimes (subtensor (subtensor_combine ds As) i) B\n\ngoal (1 subgoal):\n 1. \\<And>As ds.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>A \\<in> set As; dims A \\<noteq> [];\n                    i < hd (dims A)\\<rbrakk>\n                   \\<Longrightarrow> subtensor\n(local.tensor_prod_otimes A B) i =\n                                     local.tensor_prod_otimes\n(subtensor A i) B;\n        \\<And>A. A \\<in> set As \\<Longrightarrow> dims A = ds;\n        dims (subtensor_combine ds As) \\<noteq> [];\n        i < hd (dims (subtensor_combine ds As))\\<rbrakk>\n       \\<Longrightarrow> subtensor\n                          (local.tensor_prod_otimes\n                            (subtensor_combine ds As) B)\n                          i =\n                         local.tensor_prod_otimes\n                          (subtensor (subtensor_combine ds As) i) B", "finally"], ["proof (chain)\npicking this:\n  subtensor (local.tensor_prod_otimes (subtensor_combine ds As) B) i =\n  local.tensor_prod_otimes (subtensor (subtensor_combine ds As) i) B", "show ?case"], ["proof (prove)\nusing this:\n  subtensor (local.tensor_prod_otimes (subtensor_combine ds As) B) i =\n  local.tensor_prod_otimes (subtensor (subtensor_combine ds As) i) B\n\ngoal (1 subgoal):\n 1. subtensor (local.tensor_prod_otimes (subtensor_combine ds As) B) i =\n    local.tensor_prod_otimes (subtensor (subtensor_combine ds As) i) B", "by auto"], ["proof (state)\nthis:\n  subtensor (local.tensor_prod_otimes (subtensor_combine ds As) B) i =\n  local.tensor_prod_otimes (subtensor (subtensor_combine ds As) i) B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_tensor_prod[simp]:\n  assumes is1_valid:\"is1 \\<lhd> dims A\" and is2_valid:\"is2 \\<lhd> dims B\"\n  shows \"lookup (A \\<otimes> B) (is1 @ is2) = lookup A is1 * lookup B is2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n    lookup A is1 * lookup B is2", "using assms"], ["proof (prove)\nusing this:\n  is1 \\<lhd> dims A\n  is2 \\<lhd> dims B\n\ngoal (1 subgoal):\n 1. lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n    lookup A is1 * lookup B is2", "proof (induction A arbitrary:is1 rule:subtensor_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A is1.\n       \\<lbrakk>dims A = []; is1 \\<lhd> dims A; is2 \\<lhd> dims B\\<rbrakk>\n       \\<Longrightarrow> lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n                         lookup A is1 * lookup B is2\n 2. \\<And>A is1.\n       \\<lbrakk>dims A \\<noteq> [];\n        \\<And>i is1.\n           \\<lbrakk>i < hd (dims A); is1 \\<lhd> dims (subtensor A i);\n            is2 \\<lhd> dims B\\<rbrakk>\n           \\<Longrightarrow> lookup\n                              (local.tensor_prod_otimes (subtensor A i) B)\n                              (is1 @ is2) =\n                             lookup (subtensor A i) is1 * lookup B is2;\n        is1 \\<lhd> dims A; is2 \\<lhd> dims B\\<rbrakk>\n       \\<Longrightarrow> lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n                         lookup A is1 * lookup B is2", "case (order_0 A is1)"], ["proof (state)\nthis:\n  dims A = []\n  is1 \\<lhd> dims A\n  is2 \\<lhd> dims B\n\ngoal (2 subgoals):\n 1. \\<And>A is1.\n       \\<lbrakk>dims A = []; is1 \\<lhd> dims A; is2 \\<lhd> dims B\\<rbrakk>\n       \\<Longrightarrow> lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n                         lookup A is1 * lookup B is2\n 2. \\<And>A is1.\n       \\<lbrakk>dims A \\<noteq> [];\n        \\<And>i is1.\n           \\<lbrakk>i < hd (dims A); is1 \\<lhd> dims (subtensor A i);\n            is2 \\<lhd> dims B\\<rbrakk>\n           \\<Longrightarrow> lookup\n                              (local.tensor_prod_otimes (subtensor A i) B)\n                              (is1 @ is2) =\n                             lookup (subtensor A i) is1 * lookup B is2;\n        is1 \\<lhd> dims A; is2 \\<lhd> dims B\\<rbrakk>\n       \\<Longrightarrow> lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n                         lookup A is1 * lookup B is2", "then"], ["proof (chain)\npicking this:\n  dims A = []\n  is1 \\<lhd> dims A\n  is2 \\<lhd> dims B", "obtain a where \"vec A = [a]\""], ["proof (prove)\nusing this:\n  dims A = []\n  is1 \\<lhd> dims A\n  is2 \\<lhd> dims B\n\ngoal (1 subgoal):\n 1. (\\<And>a. vec A = [a] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using Suc_length_conv Tensor.tensor_vec_from_lookup_Nil length_0_conv length_tensor_vec_from_lookup length_vec"], ["proof (prove)\nusing this:\n  dims A = []\n  is1 \\<lhd> dims A\n  is2 \\<lhd> dims B\n  (Suc ?n = length ?xs) =\n  (\\<exists>y ys. ?xs = y # ys \\<and> length ys = ?n)\n  tensor_vec_from_lookup [] ?e = [?e []]\n  (length ?xs = 0) = (?xs = [])\n  length (tensor_vec_from_lookup ?ds ?e) = prod_list ?ds\n  length (vec ?A) = prod_list (dims ?A)\n\ngoal (1 subgoal):\n 1. (\\<And>a. vec A = [a] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by metis"], ["proof (state)\nthis:\n  vec A = [a]\n\ngoal (2 subgoals):\n 1. \\<And>A is1.\n       \\<lbrakk>dims A = []; is1 \\<lhd> dims A; is2 \\<lhd> dims B\\<rbrakk>\n       \\<Longrightarrow> lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n                         lookup A is1 * lookup B is2\n 2. \\<And>A is1.\n       \\<lbrakk>dims A \\<noteq> [];\n        \\<And>i is1.\n           \\<lbrakk>i < hd (dims A); is1 \\<lhd> dims (subtensor A i);\n            is2 \\<lhd> dims B\\<rbrakk>\n           \\<Longrightarrow> lookup\n                              (local.tensor_prod_otimes (subtensor A i) B)\n                              (is1 @ is2) =\n                             lookup (subtensor A i) is1 * lookup B is2;\n        is1 \\<lhd> dims A; is2 \\<lhd> dims B\\<rbrakk>\n       \\<Longrightarrow> lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n                         lookup A is1 * lookup B is2", "then"], ["proof (chain)\npicking this:\n  vec A = [a]", "have \"A \\<otimes> B = a \\<cdot> B\""], ["proof (prove)\nusing this:\n  vec A = [a]\n\ngoal (1 subgoal):\n 1. local.tensor_prod_otimes A B = a \\<cdot> B", "unfolding tensor_prod_def smult_def"], ["proof (prove)\nusing this:\n  vec A = [a]\n\ngoal (1 subgoal):\n 1. tensor_from_vec (dims A @ dims B)\n     (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))) =\n    tensor_from_vec (dims B) (vec_smult a (vec B))", "using order_0"], ["proof (prove)\nusing this:\n  vec A = [a]\n  dims A = []\n  is1 \\<lhd> dims A\n  is2 \\<lhd> dims B\n\ngoal (1 subgoal):\n 1. tensor_from_vec (dims A @ dims B)\n     (concat (map (\\<lambda>a. vec_smult a (vec B)) (vec A))) =\n    tensor_from_vec (dims B) (vec_smult a (vec B))", "by simp"], ["proof (state)\nthis:\n  local.tensor_prod_otimes A B = a \\<cdot> B\n\ngoal (2 subgoals):\n 1. \\<And>A is1.\n       \\<lbrakk>dims A = []; is1 \\<lhd> dims A; is2 \\<lhd> dims B\\<rbrakk>\n       \\<Longrightarrow> lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n                         lookup A is1 * lookup B is2\n 2. \\<And>A is1.\n       \\<lbrakk>dims A \\<noteq> [];\n        \\<And>i is1.\n           \\<lbrakk>i < hd (dims A); is1 \\<lhd> dims (subtensor A i);\n            is2 \\<lhd> dims B\\<rbrakk>\n           \\<Longrightarrow> lookup\n                              (local.tensor_prod_otimes (subtensor A i) B)\n                              (is1 @ is2) =\n                             lookup (subtensor A i) is1 * lookup B is2;\n        is1 \\<lhd> dims A; is2 \\<lhd> dims B\\<rbrakk>\n       \\<Longrightarrow> lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n                         lookup A is1 * lookup B is2", "moreover"], ["proof (state)\nthis:\n  local.tensor_prod_otimes A B = a \\<cdot> B\n\ngoal (2 subgoals):\n 1. \\<And>A is1.\n       \\<lbrakk>dims A = []; is1 \\<lhd> dims A; is2 \\<lhd> dims B\\<rbrakk>\n       \\<Longrightarrow> lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n                         lookup A is1 * lookup B is2\n 2. \\<And>A is1.\n       \\<lbrakk>dims A \\<noteq> [];\n        \\<And>i is1.\n           \\<lbrakk>i < hd (dims A); is1 \\<lhd> dims (subtensor A i);\n            is2 \\<lhd> dims B\\<rbrakk>\n           \\<Longrightarrow> lookup\n                              (local.tensor_prod_otimes (subtensor A i) B)\n                              (is1 @ is2) =\n                             lookup (subtensor A i) is1 * lookup B is2;\n        is1 \\<lhd> dims A; is2 \\<lhd> dims B\\<rbrakk>\n       \\<Longrightarrow> lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n                         lookup A is1 * lookup B is2", "have \"lookup A [] = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup A [] = a", "by (simp add: \\<open>Tensor.vec A = [a]\\<close> lookup_def order_0.hyps)"], ["proof (state)\nthis:\n  lookup A [] = a\n\ngoal (2 subgoals):\n 1. \\<And>A is1.\n       \\<lbrakk>dims A = []; is1 \\<lhd> dims A; is2 \\<lhd> dims B\\<rbrakk>\n       \\<Longrightarrow> lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n                         lookup A is1 * lookup B is2\n 2. \\<And>A is1.\n       \\<lbrakk>dims A \\<noteq> [];\n        \\<And>i is1.\n           \\<lbrakk>i < hd (dims A); is1 \\<lhd> dims (subtensor A i);\n            is2 \\<lhd> dims B\\<rbrakk>\n           \\<Longrightarrow> lookup\n                              (local.tensor_prod_otimes (subtensor A i) B)\n                              (is1 @ is2) =\n                             lookup (subtensor A i) is1 * lookup B is2;\n        is1 \\<lhd> dims A; is2 \\<lhd> dims B\\<rbrakk>\n       \\<Longrightarrow> lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n                         lookup A is1 * lookup B is2", "ultimately"], ["proof (chain)\npicking this:\n  local.tensor_prod_otimes A B = a \\<cdot> B\n  lookup A [] = a", "have \"lookup (A \\<otimes> B) (is2) = a * lookup B is2\""], ["proof (prove)\nusing this:\n  local.tensor_prod_otimes A B = a \\<cdot> B\n  lookup A [] = a\n\ngoal (1 subgoal):\n 1. lookup (local.tensor_prod_otimes A B) is2 = a * lookup B is2", "by (simp add: lookup_smult is2_valid)"], ["proof (state)\nthis:\n  lookup (local.tensor_prod_otimes A B) is2 = a * lookup B is2\n\ngoal (2 subgoals):\n 1. \\<And>A is1.\n       \\<lbrakk>dims A = []; is1 \\<lhd> dims A; is2 \\<lhd> dims B\\<rbrakk>\n       \\<Longrightarrow> lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n                         lookup A is1 * lookup B is2\n 2. \\<And>A is1.\n       \\<lbrakk>dims A \\<noteq> [];\n        \\<And>i is1.\n           \\<lbrakk>i < hd (dims A); is1 \\<lhd> dims (subtensor A i);\n            is2 \\<lhd> dims B\\<rbrakk>\n           \\<Longrightarrow> lookup\n                              (local.tensor_prod_otimes (subtensor A i) B)\n                              (is1 @ is2) =\n                             lookup (subtensor A i) is1 * lookup B is2;\n        is1 \\<lhd> dims A; is2 \\<lhd> dims B\\<rbrakk>\n       \\<Longrightarrow> lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n                         lookup A is1 * lookup B is2", "then"], ["proof (chain)\npicking this:\n  lookup (local.tensor_prod_otimes A B) is2 = a * lookup B is2", "show ?case"], ["proof (prove)\nusing this:\n  lookup (local.tensor_prod_otimes A B) is2 = a * lookup B is2\n\ngoal (1 subgoal):\n 1. lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n    lookup A is1 * lookup B is2", "using \\<open>lookup A [] = a\\<close> null_rec(1) order_0.hyps order_0.prems(1)"], ["proof (prove)\nusing this:\n  lookup (local.tensor_prod_otimes A B) is2 = a * lookup B is2\n  lookup A [] = a\n  List.null (?x # ?xs) = False\n  dims A = []\n  is1 \\<lhd> dims A\n\ngoal (1 subgoal):\n 1. lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n    lookup A is1 * lookup B is2", "by auto"], ["proof (state)\nthis:\n  lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n  lookup A is1 * lookup B is2\n\ngoal (1 subgoal):\n 1. \\<And>A is1.\n       \\<lbrakk>dims A \\<noteq> [];\n        \\<And>i is1.\n           \\<lbrakk>i < hd (dims A); is1 \\<lhd> dims (subtensor A i);\n            is2 \\<lhd> dims B\\<rbrakk>\n           \\<Longrightarrow> lookup\n                              (local.tensor_prod_otimes (subtensor A i) B)\n                              (is1 @ is2) =\n                             lookup (subtensor A i) is1 * lookup B is2;\n        is1 \\<lhd> dims A; is2 \\<lhd> dims B\\<rbrakk>\n       \\<Longrightarrow> lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n                         lookup A is1 * lookup B is2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A is1.\n       \\<lbrakk>dims A \\<noteq> [];\n        \\<And>i is1.\n           \\<lbrakk>i < hd (dims A); is1 \\<lhd> dims (subtensor A i);\n            is2 \\<lhd> dims B\\<rbrakk>\n           \\<Longrightarrow> lookup\n                              (local.tensor_prod_otimes (subtensor A i) B)\n                              (is1 @ is2) =\n                             lookup (subtensor A i) is1 * lookup B is2;\n        is1 \\<lhd> dims A; is2 \\<lhd> dims B\\<rbrakk>\n       \\<Longrightarrow> lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n                         lookup A is1 * lookup B is2", "case (order_step A is1)"], ["proof (state)\nthis:\n  dims A \\<noteq> []\n  \\<lbrakk>?i < hd (dims A); ?is1.0 \\<lhd> dims (subtensor A ?i);\n   is2 \\<lhd> dims B\\<rbrakk>\n  \\<Longrightarrow> lookup (local.tensor_prod_otimes (subtensor A ?i) B)\n                     (?is1.0 @ is2) =\n                    lookup (subtensor A ?i) ?is1.0 * lookup B is2\n  is1 \\<lhd> dims A\n  is2 \\<lhd> dims B\n\ngoal (1 subgoal):\n 1. \\<And>A is1.\n       \\<lbrakk>dims A \\<noteq> [];\n        \\<And>i is1.\n           \\<lbrakk>i < hd (dims A); is1 \\<lhd> dims (subtensor A i);\n            is2 \\<lhd> dims B\\<rbrakk>\n           \\<Longrightarrow> lookup\n                              (local.tensor_prod_otimes (subtensor A i) B)\n                              (is1 @ is2) =\n                             lookup (subtensor A i) is1 * lookup B is2;\n        is1 \\<lhd> dims A; is2 \\<lhd> dims B\\<rbrakk>\n       \\<Longrightarrow> lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n                         lookup A is1 * lookup B is2", "then"], ["proof (chain)\npicking this:\n  dims A \\<noteq> []\n  \\<lbrakk>?i < hd (dims A); ?is1.0 \\<lhd> dims (subtensor A ?i);\n   is2 \\<lhd> dims B\\<rbrakk>\n  \\<Longrightarrow> lookup (local.tensor_prod_otimes (subtensor A ?i) B)\n                     (?is1.0 @ is2) =\n                    lookup (subtensor A ?i) ?is1.0 * lookup B is2\n  is1 \\<lhd> dims A\n  is2 \\<lhd> dims B", "obtain i is1' where \"i # is1' = is1\""], ["proof (prove)\nusing this:\n  dims A \\<noteq> []\n  \\<lbrakk>?i < hd (dims A); ?is1.0 \\<lhd> dims (subtensor A ?i);\n   is2 \\<lhd> dims B\\<rbrakk>\n  \\<Longrightarrow> lookup (local.tensor_prod_otimes (subtensor A ?i) B)\n                     (?is1.0 @ is2) =\n                    lookup (subtensor A ?i) ?is1.0 * lookup B is2\n  is1 \\<lhd> dims A\n  is2 \\<lhd> dims B\n\ngoal (1 subgoal):\n 1. (\\<And>i is1'.\n        i # is1' = is1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i # is1' = is1\n\ngoal (1 subgoal):\n 1. \\<And>A is1.\n       \\<lbrakk>dims A \\<noteq> [];\n        \\<And>i is1.\n           \\<lbrakk>i < hd (dims A); is1 \\<lhd> dims (subtensor A i);\n            is2 \\<lhd> dims B\\<rbrakk>\n           \\<Longrightarrow> lookup\n                              (local.tensor_prod_otimes (subtensor A i) B)\n                              (is1 @ is2) =\n                             lookup (subtensor A i) is1 * lookup B is2;\n        is1 \\<lhd> dims A; is2 \\<lhd> dims B\\<rbrakk>\n       \\<Longrightarrow> lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n                         lookup A is1 * lookup B is2", "have \"lookup (subtensor A i \\<otimes> B) (is1' @ is2) = lookup (subtensor A i) is1' * lookup B is2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (local.tensor_prod_otimes (subtensor A i) B) (is1' @ is2) =\n    lookup (subtensor A i) is1' * lookup B is2", "using order_step"], ["proof (prove)\nusing this:\n  dims A \\<noteq> []\n  \\<lbrakk>?i < hd (dims A); ?is1.0 \\<lhd> dims (subtensor A ?i);\n   is2 \\<lhd> dims B\\<rbrakk>\n  \\<Longrightarrow> lookup (local.tensor_prod_otimes (subtensor A ?i) B)\n                     (?is1.0 @ is2) =\n                    lookup (subtensor A ?i) ?is1.0 * lookup B is2\n  is1 \\<lhd> dims A\n  is2 \\<lhd> dims B\n\ngoal (1 subgoal):\n 1. lookup (local.tensor_prod_otimes (subtensor A i) B) (is1' @ is2) =\n    lookup (subtensor A i) is1' * lookup B is2", "by (metis \\<open>i # is1' = is1\\<close> dims_subtensor list.sel(1) list.sel(3) valid_index_dimsE)"], ["proof (state)\nthis:\n  lookup (local.tensor_prod_otimes (subtensor A i) B) (is1' @ is2) =\n  lookup (subtensor A i) is1' * lookup B is2\n\ngoal (1 subgoal):\n 1. \\<And>A is1.\n       \\<lbrakk>dims A \\<noteq> [];\n        \\<And>i is1.\n           \\<lbrakk>i < hd (dims A); is1 \\<lhd> dims (subtensor A i);\n            is2 \\<lhd> dims B\\<rbrakk>\n           \\<Longrightarrow> lookup\n                              (local.tensor_prod_otimes (subtensor A i) B)\n                              (is1 @ is2) =\n                             lookup (subtensor A i) is1 * lookup B is2;\n        is1 \\<lhd> dims A; is2 \\<lhd> dims B\\<rbrakk>\n       \\<Longrightarrow> lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n                         lookup A is1 * lookup B is2", "then"], ["proof (chain)\npicking this:\n  lookup (local.tensor_prod_otimes (subtensor A i) B) (is1' @ is2) =\n  lookup (subtensor A i) is1' * lookup B is2", "show \"lookup (A \\<otimes> B) (is1 @ is2) = lookup A is1 * lookup B is2\""], ["proof (prove)\nusing this:\n  lookup (local.tensor_prod_otimes (subtensor A i) B) (is1' @ is2) =\n  lookup (subtensor A i) is1' * lookup B is2\n\ngoal (1 subgoal):\n 1. lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n    lookup A is1 * lookup B is2", "using lookup_subtensor1[of i is1' A] lookup_subtensor1[of i \"is1' @ is2\" \"A\\<otimes>B\"] subtensor_tensor_prod[of A i B]\n      Cons_eq_appendI \\<open>i # is1' = is1\\<close> dims_tensor_prod is2_valid list.sel(1) order_step.hyps order_step.prems(1) valid_index_append valid_index_dimsE"], ["proof (prove)\nusing this:\n  lookup (local.tensor_prod_otimes (subtensor A i) B) (is1' @ is2) =\n  lookup (subtensor A i) is1' * lookup B is2\n  i # is1' \\<lhd> dims A \\<Longrightarrow>\n  lookup (subtensor A i) is1' = lookup A (i # is1')\n  i # is1' @ is2 \\<lhd>\n  dims (local.tensor_prod_otimes A B) \\<Longrightarrow>\n  lookup (subtensor (local.tensor_prod_otimes A B) i) (is1' @ is2) =\n  lookup (local.tensor_prod_otimes A B) (i # is1' @ is2)\n  \\<lbrakk>dims A \\<noteq> []; i < hd (dims A)\\<rbrakk>\n  \\<Longrightarrow> subtensor (local.tensor_prod_otimes A B) i =\n                    local.tensor_prod_otimes (subtensor A i) B\n  \\<lbrakk>?x # ?xs1.0 = ?ys; ?xs = ?xs1.0 @ ?zs\\<rbrakk>\n  \\<Longrightarrow> ?x # ?xs = ?ys @ ?zs\n  i # is1' = is1\n  dims (local.tensor_prod_otimes ?A ?B) = dims ?A @ dims ?B\n  is2 \\<lhd> dims B\n  hd (?x21.0 # ?x22.0) = ?x21.0\n  dims A \\<noteq> []\n  is1 \\<lhd> dims A\n  \\<lbrakk>?is1.0 \\<lhd> ?ds1.0; ?is2.0 \\<lhd> ?ds2.0\\<rbrakk>\n  \\<Longrightarrow> ?is1.0 @ ?is2.0 \\<lhd> ?ds1.0 @ ?ds2.0\n  \\<lbrakk>?is \\<lhd> dims ?A;\n   \\<lbrakk>?is = []; dims ?A = []\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>is ds i d.\n      \\<lbrakk>?is = i # is; dims ?A = d # ds; is \\<lhd> ds; i < d\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n    lookup A is1 * lookup B is2", "by metis"], ["proof (state)\nthis:\n  lookup (local.tensor_prod_otimes A B) (is1 @ is2) =\n  lookup A is1 * lookup B is2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_index_split:\n  assumes \"is \\<lhd> ds1 @ ds2\"\n  obtains is1 is2 where \"is1 @ is2 = is\" \"is1 \\<lhd> ds1\" \"is2 \\<lhd> ds2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>is1 is2.\n        \\<lbrakk>is1 @ is2 = is; is1 \\<lhd> ds1; is2 \\<lhd> ds2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<And>is1 is2.\n        \\<lbrakk>is1 @ is2 = is; is1 \\<lhd> ds1; is2 \\<lhd> ds2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?is1.2 @ ?is2.2 = is\n 2. (\\<And>is1 is2.\n        \\<lbrakk>is1 @ is2 = is; is1 \\<lhd> ds1; is2 \\<lhd> ds2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?is1.2 \\<lhd> ds1\n 3. (\\<And>is1 is2.\n        \\<lbrakk>is1 @ is2 = is; is1 \\<lhd> ds1; is2 \\<lhd> ds2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?is2.2 \\<lhd> ds2", "assume a: \"\\<And>is1 is2. is1 @ is2 = is \\<Longrightarrow> is1 \\<lhd> ds1 \\<Longrightarrow> is2 \\<lhd> ds2 \\<Longrightarrow> thesis\""], ["proof (state)\nthis:\n  \\<lbrakk>?is1.0 @ ?is2.0 = is; ?is1.0 \\<lhd> ds1;\n   ?is2.0 \\<lhd> ds2\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (3 subgoals):\n 1. (\\<And>is1 is2.\n        \\<lbrakk>is1 @ is2 = is; is1 \\<lhd> ds1; is2 \\<lhd> ds2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?is1.2 @ ?is2.2 = is\n 2. (\\<And>is1 is2.\n        \\<lbrakk>is1 @ is2 = is; is1 \\<lhd> ds1; is2 \\<lhd> ds2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?is1.2 \\<lhd> ds1\n 3. (\\<And>is1 is2.\n        \\<lbrakk>is1 @ is2 = is; is1 \\<lhd> ds1; is2 \\<lhd> ds2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?is2.2 \\<lhd> ds2", "have length_is:\"length is = length ds1 + length ds2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length is = length ds1 + length ds2", "using valid_index_length"], ["proof (prove)\nusing this:\n  ?is \\<lhd> ?ds \\<Longrightarrow> length ?is = length ?ds\n\ngoal (1 subgoal):\n 1. length is = length ds1 + length ds2", "using assms"], ["proof (prove)\nusing this:\n  ?is \\<lhd> ?ds \\<Longrightarrow> length ?is = length ?ds\n  is \\<lhd> ds1 @ ds2\n\ngoal (1 subgoal):\n 1. length is = length ds1 + length ds2", "by auto"], ["proof (state)\nthis:\n  length is = length ds1 + length ds2\n\ngoal (3 subgoals):\n 1. (\\<And>is1 is2.\n        \\<lbrakk>is1 @ is2 = is; is1 \\<lhd> ds1; is2 \\<lhd> ds2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?is1.2 @ ?is2.2 = is\n 2. (\\<And>is1 is2.\n        \\<lbrakk>is1 @ is2 = is; is1 \\<lhd> ds1; is2 \\<lhd> ds2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?is1.2 \\<lhd> ds1\n 3. (\\<And>is1 is2.\n        \\<lbrakk>is1 @ is2 = is; is1 \\<lhd> ds1; is2 \\<lhd> ds2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?is2.2 \\<lhd> ds2", "show \"take (length ds1) is \\<lhd> ds1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length ds1) is \\<lhd> ds1", "apply (rule valid_indexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (take (length ds1) is) = length ds1\n 2. \\<And>m.\n       m < length ds1 \\<Longrightarrow> take (length ds1) is ! m < ds1 ! m", "using valid_index_length"], ["proof (prove)\nusing this:\n  ?is \\<lhd> ?ds \\<Longrightarrow> length ?is = length ?ds\n\ngoal (2 subgoals):\n 1. length (take (length ds1) is) = length ds1\n 2. \\<And>m.\n       m < length ds1 \\<Longrightarrow> take (length ds1) is ! m < ds1 ! m", "using assms"], ["proof (prove)\nusing this:\n  ?is \\<lhd> ?ds \\<Longrightarrow> length ?is = length ?ds\n  is \\<lhd> ds1 @ ds2\n\ngoal (2 subgoals):\n 1. length (take (length ds1) is) = length ds1\n 2. \\<And>m.\n       m < length ds1 \\<Longrightarrow> take (length ds1) is ! m < ds1 ! m", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       m < length ds1 \\<Longrightarrow> take (length ds1) is ! m < ds1 ! m", "by (metis add_leD1 assms length_append not_less nth_append nth_take valid_index_lt)"], ["proof (state)\nthis:\n  take (length ds1) is \\<lhd> ds1\n\ngoal (2 subgoals):\n 1. (\\<And>is1 is2.\n        \\<lbrakk>is1 @ is2 = is; is1 \\<lhd> ds1; is2 \\<lhd> ds2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    take (length ds1) is @ ?is2.2 = is\n 2. (\\<And>is1 is2.\n        \\<lbrakk>is1 @ is2 = is; is1 \\<lhd> ds1; is2 \\<lhd> ds2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    ?is2.2 \\<lhd> ds2", "show \"drop (length ds1) is \\<lhd> ds2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop (length ds1) is \\<lhd> ds2", "apply (rule valid_indexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length (drop (length ds1) is) = length ds2\n 2. \\<And>m.\n       m < length ds2 \\<Longrightarrow> drop (length ds1) is ! m < ds2 ! m", "using valid_index_length"], ["proof (prove)\nusing this:\n  ?is \\<lhd> ?ds \\<Longrightarrow> length ?is = length ?ds\n\ngoal (2 subgoals):\n 1. length (drop (length ds1) is) = length ds2\n 2. \\<And>m.\n       m < length ds2 \\<Longrightarrow> drop (length ds1) is ! m < ds2 ! m", "using assms"], ["proof (prove)\nusing this:\n  ?is \\<lhd> ?ds \\<Longrightarrow> length ?is = length ?ds\n  is \\<lhd> ds1 @ ds2\n\ngoal (2 subgoals):\n 1. length (drop (length ds1) is) = length ds2\n 2. \\<And>m.\n       m < length ds2 \\<Longrightarrow> drop (length ds1) is ! m < ds2 ! m", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       m < length ds2 \\<Longrightarrow> drop (length ds1) is ! m < ds2 ! m", "using nth_drop[of \"length ds1\" \"is\"] valid_index_lt[OF assms(1)] nth_append[of ds1 ds2] length_is"], ["proof (prove)\nusing this:\n  length ds1 \\<le> length is \\<Longrightarrow>\n  drop (length ds1) is ! ?i = is ! (length ds1 + ?i)\n  ?m < length (ds1 @ ds2) \\<Longrightarrow> is ! ?m < (ds1 @ ds2) ! ?m\n  (ds1 @ ds2) ! ?n =\n  (if ?n < length ds1 then ds1 ! ?n else ds2 ! (?n - length ds1))\n  length is = length ds1 + length ds2\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       m < length ds2 \\<Longrightarrow> drop (length ds1) is ! m < ds2 ! m", "by (metis length_append nat_add_left_cancel_less nat_le_iff_add nth_append_length_plus)"], ["proof (state)\nthis:\n  drop (length ds1) is \\<lhd> ds2\n\ngoal (1 subgoal):\n 1. (\\<And>is1 is2.\n        \\<lbrakk>is1 @ is2 = is; is1 \\<lhd> ds1; is2 \\<lhd> ds2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    take (length ds1) is @ drop (length ds1) is = is", "show \"take (length ds1) is @ drop (length ds1) is = is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length ds1) is @ drop (length ds1) is = is", "using length_is"], ["proof (prove)\nusing this:\n  length is = length ds1 + length ds2\n\ngoal (1 subgoal):\n 1. take (length ds1) is @ drop (length ds1) is = is", "by auto"], ["proof (state)\nthis:\n  take (length ds1) is @ drop (length ds1) is = is\n\ngoal:\nNo subgoals!", "qed"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tensor, semigroup_mult_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       local.tensor_prod_otimes (local.tensor_prod_otimes a b) c =\n       local.tensor_prod_otimes a (local.tensor_prod_otimes b c)", "fix A B C::\"'a::ring tensor\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       local.tensor_prod_otimes (local.tensor_prod_otimes a b) c =\n       local.tensor_prod_otimes a (local.tensor_prod_otimes b c)", "show \"(A \\<otimes> B) \\<otimes> C = A \\<otimes> (B \\<otimes> C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.tensor_prod_otimes (local.tensor_prod_otimes A B) C =\n    local.tensor_prod_otimes A (local.tensor_prod_otimes B C)", "proof (rule tensor_lookup_eqI, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd>\n       dims\n        (local.tensor_prod_otimes (local.tensor_prod_otimes A B)\n          C) \\<Longrightarrow>\n       lookup (local.tensor_prod_otimes (local.tensor_prod_otimes A B) C)\n        is =\n       lookup (local.tensor_prod_otimes A (local.tensor_prod_otimes B C)) is", "fix \"is\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd>\n       dims\n        (local.tensor_prod_otimes (local.tensor_prod_otimes A B)\n          C) \\<Longrightarrow>\n       lookup (local.tensor_prod_otimes (local.tensor_prod_otimes A B) C)\n        is =\n       lookup (local.tensor_prod_otimes A (local.tensor_prod_otimes B C)) is", "assume \"is \\<lhd> dims ((A \\<otimes> B) \\<otimes> C)\""], ["proof (state)\nthis:\n  is \\<lhd> dims (local.tensor_prod_otimes (local.tensor_prod_otimes A B) C)\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd>\n       dims\n        (local.tensor_prod_otimes (local.tensor_prod_otimes A B)\n          C) \\<Longrightarrow>\n       lookup (local.tensor_prod_otimes (local.tensor_prod_otimes A B) C)\n        is =\n       lookup (local.tensor_prod_otimes A (local.tensor_prod_otimes B C)) is", "obtain is1 is23 where \"is1 \\<lhd> dims A\" \"is23 \\<lhd> dims (B \\<otimes> C)\" \"is1 @ is23 = is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>is1 is23.\n        \\<lbrakk>is1 \\<lhd> dims A;\n         is23 \\<lhd> dims (local.tensor_prod_otimes B C);\n         is1 @ is23 = is\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (mono_tags, lifting) \\<open>is \\<lhd> dims ((A \\<otimes> B) \\<otimes> C)\\<close> Tensor_Product.dims_tensor_prod append_assoc valid_index_split)"], ["proof (state)\nthis:\n  is1 \\<lhd> dims A\n  is23 \\<lhd> dims (local.tensor_prod_otimes B C)\n  is1 @ is23 = is\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd>\n       dims\n        (local.tensor_prod_otimes (local.tensor_prod_otimes A B)\n          C) \\<Longrightarrow>\n       lookup (local.tensor_prod_otimes (local.tensor_prod_otimes A B) C)\n        is =\n       lookup (local.tensor_prod_otimes A (local.tensor_prod_otimes B C)) is", "obtain is2 is3 where \"is2 \\<lhd> dims B\" \"is3 \\<lhd> dims C\" \"is2 @ is3 = is23\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>is2 is3.\n        \\<lbrakk>is2 \\<lhd> dims B; is3 \\<lhd> dims C;\n         is2 @ is3 = is23\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>is23 \\<lhd> dims (local.tensor_prod_otimes B C)\\<close> dims_tensor_prod valid_index_split)"], ["proof (state)\nthis:\n  is2 \\<lhd> dims B\n  is3 \\<lhd> dims C\n  is2 @ is3 = is23\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd>\n       dims\n        (local.tensor_prod_otimes (local.tensor_prod_otimes A B)\n          C) \\<Longrightarrow>\n       lookup (local.tensor_prod_otimes (local.tensor_prod_otimes A B) C)\n        is =\n       lookup (local.tensor_prod_otimes A (local.tensor_prod_otimes B C)) is", "define is12 where \"is12 = is1 @ is2\""], ["proof (state)\nthis:\n  is12 = is1 @ is2\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd>\n       dims\n        (local.tensor_prod_otimes (local.tensor_prod_otimes A B)\n          C) \\<Longrightarrow>\n       lookup (local.tensor_prod_otimes (local.tensor_prod_otimes A B) C)\n        is =\n       lookup (local.tensor_prod_otimes A (local.tensor_prod_otimes B C)) is", "have \"is12 \\<lhd> dims (A \\<otimes> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is12 \\<lhd> dims (local.tensor_prod_otimes A B)", "by (simp add: \\<open>is1 \\<lhd> dims A\\<close> \\<open>is2 \\<lhd> dims B\\<close> is12_def valid_index_append)"], ["proof (state)\nthis:\n  is12 \\<lhd> dims (local.tensor_prod_otimes A B)\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd>\n       dims\n        (local.tensor_prod_otimes (local.tensor_prod_otimes A B)\n          C) \\<Longrightarrow>\n       lookup (local.tensor_prod_otimes (local.tensor_prod_otimes A B) C)\n        is =\n       lookup (local.tensor_prod_otimes A (local.tensor_prod_otimes B C)) is", "have \"is12 @ is3 = is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is12 @ is3 = is", "by (simp add: \\<open>is1 @ is23 = is\\<close> \\<open>is2 @ is3 = is23\\<close> is12_def)"], ["proof (state)\nthis:\n  is12 @ is3 = is\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd>\n       dims\n        (local.tensor_prod_otimes (local.tensor_prod_otimes A B)\n          C) \\<Longrightarrow>\n       lookup (local.tensor_prod_otimes (local.tensor_prod_otimes A B) C)\n        is =\n       lookup (local.tensor_prod_otimes A (local.tensor_prod_otimes B C)) is", "show \"lookup ((A \\<otimes> B) \\<otimes> C) is = lookup (A \\<otimes> (B \\<otimes> C)) is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (local.tensor_prod_otimes (local.tensor_prod_otimes A B) C) is =\n    lookup (local.tensor_prod_otimes A (local.tensor_prod_otimes B C)) is", "unfolding lookup_tensor_prod[OF \\<open>is1 \\<lhd> dims A\\<close> \\<open>is23 \\<lhd> dims (B \\<otimes> C)\\<close>, unfolded \\<open>is1 @ is23 = is\\<close>]\n        lookup_tensor_prod[OF \\<open>is12 \\<lhd> dims (A \\<otimes> B)\\<close> \\<open>is3 \\<lhd> dims C\\<close>, unfolded \\<open>is12 @ is3 = is\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (local.tensor_prod_otimes A B) is12 * lookup C is3 =\n    lookup A is1 * lookup (local.tensor_prod_otimes B C) is23", "using \\<open>is1 \\<lhd> dims A\\<close> \\<open>is2 @ is3 = is23\\<close> \\<open>is2 \\<lhd> dims B\\<close> \\<open>is3 \\<lhd> dims C\\<close> is12_def mult.assoc"], ["proof (prove)\nusing this:\n  is1 \\<lhd> dims A\n  is2 @ is3 = is23\n  is2 \\<lhd> dims B\n  is3 \\<lhd> dims C\n  is12 = is1 @ is2\n  ?a * ?b * ?c = ?a * (?b * ?c)\n\ngoal (1 subgoal):\n 1. lookup (local.tensor_prod_otimes A B) is12 * lookup C is3 =\n    lookup A is1 * lookup (local.tensor_prod_otimes B C) is23", "by fastforce"], ["proof (state)\nthis:\n  lookup (local.tensor_prod_otimes (local.tensor_prod_otimes A B) C) is =\n  lookup (local.tensor_prod_otimes A (local.tensor_prod_otimes B C)) is\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.tensor_prod_otimes (local.tensor_prod_otimes A B) C =\n  local.tensor_prod_otimes A (local.tensor_prod_otimes B C)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma tensor_prod_distr_left:\nassumes \"dims A = dims B\"\nshows \"(A + B) \\<otimes> C = (A \\<otimes> C) + (B \\<otimes> C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A + B) \\<otimes> C = A \\<otimes> C + B \\<otimes> C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (A + B) \\<otimes> C = A \\<otimes> C + B \\<otimes> C", "have \"\\<And>is. is \\<lhd> dims A @ dims C \\<Longrightarrow> lookup ((A + B) \\<otimes> C) is = lookup (A \\<otimes> C + B \\<otimes> C) is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims A @ dims C \\<Longrightarrow>\n       lookup ((A + B) \\<otimes> C) is =\n       lookup (A \\<otimes> C + B \\<otimes> C) is", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims A @ dims C \\<Longrightarrow>\n       lookup ((A + B) \\<otimes> C) is =\n       lookup (A \\<otimes> C + B \\<otimes> C) is", "fix \"is\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims A @ dims C \\<Longrightarrow>\n       lookup ((A + B) \\<otimes> C) is =\n       lookup (A \\<otimes> C + B \\<otimes> C) is", "assume \"is \\<lhd> dims A @ dims C\""], ["proof (state)\nthis:\n  is \\<lhd> dims A @ dims C\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims A @ dims C \\<Longrightarrow>\n       lookup ((A + B) \\<otimes> C) is =\n       lookup (A \\<otimes> C + B \\<otimes> C) is", "obtain is1 is2 where \"is = is1 @ is2\" \"is1 \\<lhd> dims A\" \"is2 \\<lhd> dims C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>is1 is2.\n        \\<lbrakk>is = is1 @ is2; is1 \\<lhd> dims A;\n         is2 \\<lhd> dims C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using valid_index_split"], ["proof (prove)\nusing this:\n  \\<lbrakk>?is \\<lhd> ?ds1.0 @ ?ds2.0;\n   \\<And>is1 is2.\n      \\<lbrakk>is1 @ is2 = ?is; is1 \\<lhd> ?ds1.0;\n       is2 \\<lhd> ?ds2.0\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>is1 is2.\n        \\<lbrakk>is = is1 @ is2; is1 \\<lhd> dims A;\n         is2 \\<lhd> dims C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>is \\<lhd> dims A @ dims C\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?is \\<lhd> ?ds1.0 @ ?ds2.0;\n   \\<And>is1 is2.\n      \\<lbrakk>is1 @ is2 = ?is; is1 \\<lhd> ?ds1.0;\n       is2 \\<lhd> ?ds2.0\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  is \\<lhd> dims A @ dims C\n\ngoal (1 subgoal):\n 1. (\\<And>is1 is2.\n        \\<lbrakk>is = is1 @ is2; is1 \\<lhd> dims A;\n         is2 \\<lhd> dims C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  is = is1 @ is2\n  is1 \\<lhd> dims A\n  is2 \\<lhd> dims C\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims A @ dims C \\<Longrightarrow>\n       lookup ((A + B) \\<otimes> C) is =\n       lookup (A \\<otimes> C + B \\<otimes> C) is", "then"], ["proof (chain)\npicking this:\n  is = is1 @ is2\n  is1 \\<lhd> dims A\n  is2 \\<lhd> dims C", "show \"lookup ((A + B) \\<otimes> C) is = lookup ((A \\<otimes> C) + (B \\<otimes> C)) is\""], ["proof (prove)\nusing this:\n  is = is1 @ is2\n  is1 \\<lhd> dims A\n  is2 \\<lhd> dims C\n\ngoal (1 subgoal):\n 1. lookup ((A + B) \\<otimes> C) is =\n    lookup (A \\<otimes> C + B \\<otimes> C) is", "using lookup_plus\n     \\<open>is1 \\<lhd> dims A\\<close> \\<open>is2 \\<lhd> dims C\\<close> assms plus_dim1 dims_tensor_prod lookup_tensor_prod ring_class.ring_distribs(2) valid_index_append"], ["proof (prove)\nusing this:\n  is = is1 @ is2\n  is1 \\<lhd> dims A\n  is2 \\<lhd> dims C\n  \\<lbrakk>dims ?A = dims ?B; ?is \\<lhd> dims ?A\\<rbrakk>\n  \\<Longrightarrow> lookup (?A + ?B) ?is = lookup ?A ?is + lookup ?B ?is\n  is1 \\<lhd> dims A\n  is2 \\<lhd> dims C\n  dims A = dims B\n  dims ?A = dims ?B \\<Longrightarrow> dims (?A + ?B) = dims ?A\n  dims (?A \\<otimes> ?B) = dims ?A @ dims ?B\n  \\<lbrakk>?is1.0 \\<lhd> dims ?A; ?is2.0 \\<lhd> dims ?B\\<rbrakk>\n  \\<Longrightarrow> lookup (?A \\<otimes> ?B) (?is1.0 @ ?is2.0) =\n                    lookup ?A ?is1.0 * lookup ?B ?is2.0\n  (?a + ?b) * ?c = ?a * ?c + ?b * ?c\n  \\<lbrakk>?is1.0 \\<lhd> ?ds1.0; ?is2.0 \\<lhd> ?ds2.0\\<rbrakk>\n  \\<Longrightarrow> ?is1.0 @ ?is2.0 \\<lhd> ?ds1.0 @ ?ds2.0\n\ngoal (1 subgoal):\n 1. lookup ((A + B) \\<otimes> C) is =\n    lookup (A \\<otimes> C + B \\<otimes> C) is", "by fastforce"], ["proof (state)\nthis:\n  lookup ((A + B) \\<otimes> C) is =\n  lookup (A \\<otimes> C + B \\<otimes> C) is\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?is \\<lhd> dims A @ dims C \\<Longrightarrow>\n  lookup ((A + B) \\<otimes> C) ?is =\n  lookup (A \\<otimes> C + B \\<otimes> C) ?is\n\ngoal (1 subgoal):\n 1. (A + B) \\<otimes> C = A \\<otimes> C + B \\<otimes> C", "moreover"], ["proof (state)\nthis:\n  ?is \\<lhd> dims A @ dims C \\<Longrightarrow>\n  lookup ((A + B) \\<otimes> C) ?is =\n  lookup (A \\<otimes> C + B \\<otimes> C) ?is\n\ngoal (1 subgoal):\n 1. (A + B) \\<otimes> C = A \\<otimes> C + B \\<otimes> C", "have \"tensor_from_lookup (dims A @ dims C) (lookup ((A + B) \\<otimes> C)) = (A + B) \\<otimes> C\"\n       \"tensor_from_lookup (dims A @ dims C) (lookup ((A \\<otimes> C) + (B \\<otimes> C))) = (A \\<otimes> C) + (B \\<otimes> C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_from_lookup (dims A @ dims C) (lookup ((A + B) \\<otimes> C)) =\n    (A + B) \\<otimes> C &&&\n    tensor_from_lookup (dims A @ dims C)\n     (lookup (A \\<otimes> C + B \\<otimes> C)) =\n    A \\<otimes> C + B \\<otimes> C", "by (metis (no_types, lifting) assms plus_dim1 dims_tensor_prod tensor_lookup)+"], ["proof (state)\nthis:\n  tensor_from_lookup (dims A @ dims C) (lookup ((A + B) \\<otimes> C)) =\n  (A + B) \\<otimes> C\n  tensor_from_lookup (dims A @ dims C)\n   (lookup (A \\<otimes> C + B \\<otimes> C)) =\n  A \\<otimes> C + B \\<otimes> C\n\ngoal (1 subgoal):\n 1. (A + B) \\<otimes> C = A \\<otimes> C + B \\<otimes> C", "ultimately"], ["proof (chain)\npicking this:\n  ?is \\<lhd> dims A @ dims C \\<Longrightarrow>\n  lookup ((A + B) \\<otimes> C) ?is =\n  lookup (A \\<otimes> C + B \\<otimes> C) ?is\n  tensor_from_lookup (dims A @ dims C) (lookup ((A + B) \\<otimes> C)) =\n  (A + B) \\<otimes> C\n  tensor_from_lookup (dims A @ dims C)\n   (lookup (A \\<otimes> C + B \\<otimes> C)) =\n  A \\<otimes> C + B \\<otimes> C", "show ?thesis"], ["proof (prove)\nusing this:\n  ?is \\<lhd> dims A @ dims C \\<Longrightarrow>\n  lookup ((A + B) \\<otimes> C) ?is =\n  lookup (A \\<otimes> C + B \\<otimes> C) ?is\n  tensor_from_lookup (dims A @ dims C) (lookup ((A + B) \\<otimes> C)) =\n  (A + B) \\<otimes> C\n  tensor_from_lookup (dims A @ dims C)\n   (lookup (A \\<otimes> C + B \\<otimes> C)) =\n  A \\<otimes> C + B \\<otimes> C\n\ngoal (1 subgoal):\n 1. (A + B) \\<otimes> C = A \\<otimes> C + B \\<otimes> C", "using tensor_from_lookup_eqI"], ["proof (prove)\nusing this:\n  ?is \\<lhd> dims A @ dims C \\<Longrightarrow>\n  lookup ((A + B) \\<otimes> C) ?is =\n  lookup (A \\<otimes> C + B \\<otimes> C) ?is\n  tensor_from_lookup (dims A @ dims C) (lookup ((A + B) \\<otimes> C)) =\n  (A + B) \\<otimes> C\n  tensor_from_lookup (dims A @ dims C)\n   (lookup (A \\<otimes> C + B \\<otimes> C)) =\n  A \\<otimes> C + B \\<otimes> C\n  (\\<And>is.\n      is \\<lhd> ?ds \\<Longrightarrow>\n      ?e\\<^sub>1 is = ?e\\<^sub>2 is) \\<Longrightarrow>\n  tensor_from_lookup ?ds ?e\\<^sub>1 = tensor_from_lookup ?ds ?e\\<^sub>2\n\ngoal (1 subgoal):\n 1. (A + B) \\<otimes> C = A \\<otimes> C + B \\<otimes> C", "by (metis \\<open>\\<And>is. is \\<lhd> dims A @ dims C \\<Longrightarrow> lookup ((A + B) \\<otimes> C) is = lookup (A \\<otimes> C + B \\<otimes> C) is\\<close>)"], ["proof (state)\nthis:\n  (A + B) \\<otimes> C = A \\<otimes> C + B \\<otimes> C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tensor_prod_distr_right:\nassumes \"dims A = dims B\"\nshows \"C \\<otimes> (A + B) = (C \\<otimes> A) + (C \\<otimes> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<otimes> (A + B) = C \\<otimes> A + C \\<otimes> B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. C \\<otimes> (A + B) = C \\<otimes> A + C \\<otimes> B", "have \"\\<And>is. is \\<lhd> dims C @ dims A \\<Longrightarrow> lookup (C \\<otimes> (A + B)) is = lookup (C \\<otimes> A + C \\<otimes> B) is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims C @ dims A \\<Longrightarrow>\n       lookup (C \\<otimes> (A + B)) is =\n       lookup (C \\<otimes> A + C \\<otimes> B) is", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims C @ dims A \\<Longrightarrow>\n       lookup (C \\<otimes> (A + B)) is =\n       lookup (C \\<otimes> A + C \\<otimes> B) is", "fix \"is\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims C @ dims A \\<Longrightarrow>\n       lookup (C \\<otimes> (A + B)) is =\n       lookup (C \\<otimes> A + C \\<otimes> B) is", "assume \"is \\<lhd> dims C @ dims A\""], ["proof (state)\nthis:\n  is \\<lhd> dims C @ dims A\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims C @ dims A \\<Longrightarrow>\n       lookup (C \\<otimes> (A + B)) is =\n       lookup (C \\<otimes> A + C \\<otimes> B) is", "obtain is1 is2 where \"is = is1 @ is2\" \"is1 \\<lhd> dims C\" \"is2 \\<lhd> dims A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>is1 is2.\n        \\<lbrakk>is = is1 @ is2; is1 \\<lhd> dims C;\n         is2 \\<lhd> dims A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using valid_index_split"], ["proof (prove)\nusing this:\n  \\<lbrakk>?is \\<lhd> ?ds1.0 @ ?ds2.0;\n   \\<And>is1 is2.\n      \\<lbrakk>is1 @ is2 = ?is; is1 \\<lhd> ?ds1.0;\n       is2 \\<lhd> ?ds2.0\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>is1 is2.\n        \\<lbrakk>is = is1 @ is2; is1 \\<lhd> dims C;\n         is2 \\<lhd> dims A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>is \\<lhd> dims C @ dims A\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?is \\<lhd> ?ds1.0 @ ?ds2.0;\n   \\<And>is1 is2.\n      \\<lbrakk>is1 @ is2 = ?is; is1 \\<lhd> ?ds1.0;\n       is2 \\<lhd> ?ds2.0\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  is \\<lhd> dims C @ dims A\n\ngoal (1 subgoal):\n 1. (\\<And>is1 is2.\n        \\<lbrakk>is = is1 @ is2; is1 \\<lhd> dims C;\n         is2 \\<lhd> dims A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  is = is1 @ is2\n  is1 \\<lhd> dims C\n  is2 \\<lhd> dims A\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims C @ dims A \\<Longrightarrow>\n       lookup (C \\<otimes> (A + B)) is =\n       lookup (C \\<otimes> A + C \\<otimes> B) is", "then"], ["proof (chain)\npicking this:\n  is = is1 @ is2\n  is1 \\<lhd> dims C\n  is2 \\<lhd> dims A", "show \"lookup (C \\<otimes> (A + B)) is = lookup ((C \\<otimes> A) + (C \\<otimes> B)) is\""], ["proof (prove)\nusing this:\n  is = is1 @ is2\n  is1 \\<lhd> dims C\n  is2 \\<lhd> dims A\n\ngoal (1 subgoal):\n 1. lookup (C \\<otimes> (A + B)) is =\n    lookup (C \\<otimes> A + C \\<otimes> B) is", "using lookup_plus"], ["proof (prove)\nusing this:\n  is = is1 @ is2\n  is1 \\<lhd> dims C\n  is2 \\<lhd> dims A\n  \\<lbrakk>dims ?A = dims ?B; ?is \\<lhd> dims ?A\\<rbrakk>\n  \\<Longrightarrow> lookup (?A + ?B) ?is = lookup ?A ?is + lookup ?B ?is\n\ngoal (1 subgoal):\n 1. lookup (C \\<otimes> (A + B)) is =\n    lookup (C \\<otimes> A + C \\<otimes> B) is", "using \\<open>is2 \\<lhd> dims A\\<close> \\<open>is1 \\<lhd> dims C\\<close> assms plus_dim1 dims_tensor_prod lookup_tensor_prod ring_class.ring_distribs(1) valid_index_append"], ["proof (prove)\nusing this:\n  is = is1 @ is2\n  is1 \\<lhd> dims C\n  is2 \\<lhd> dims A\n  \\<lbrakk>dims ?A = dims ?B; ?is \\<lhd> dims ?A\\<rbrakk>\n  \\<Longrightarrow> lookup (?A + ?B) ?is = lookup ?A ?is + lookup ?B ?is\n  is2 \\<lhd> dims A\n  is1 \\<lhd> dims C\n  dims A = dims B\n  dims ?A = dims ?B \\<Longrightarrow> dims (?A + ?B) = dims ?A\n  dims (?A \\<otimes> ?B) = dims ?A @ dims ?B\n  \\<lbrakk>?is1.0 \\<lhd> dims ?A; ?is2.0 \\<lhd> dims ?B\\<rbrakk>\n  \\<Longrightarrow> lookup (?A \\<otimes> ?B) (?is1.0 @ ?is2.0) =\n                    lookup ?A ?is1.0 * lookup ?B ?is2.0\n  ?a * (?b + ?c) = ?a * ?b + ?a * ?c\n  \\<lbrakk>?is1.0 \\<lhd> ?ds1.0; ?is2.0 \\<lhd> ?ds2.0\\<rbrakk>\n  \\<Longrightarrow> ?is1.0 @ ?is2.0 \\<lhd> ?ds1.0 @ ?ds2.0\n\ngoal (1 subgoal):\n 1. lookup (C \\<otimes> (A + B)) is =\n    lookup (C \\<otimes> A + C \\<otimes> B) is", "by fastforce"], ["proof (state)\nthis:\n  lookup (C \\<otimes> (A + B)) is =\n  lookup (C \\<otimes> A + C \\<otimes> B) is\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?is \\<lhd> dims C @ dims A \\<Longrightarrow>\n  lookup (C \\<otimes> (A + B)) ?is =\n  lookup (C \\<otimes> A + C \\<otimes> B) ?is\n\ngoal (1 subgoal):\n 1. C \\<otimes> (A + B) = C \\<otimes> A + C \\<otimes> B", "moreover"], ["proof (state)\nthis:\n  ?is \\<lhd> dims C @ dims A \\<Longrightarrow>\n  lookup (C \\<otimes> (A + B)) ?is =\n  lookup (C \\<otimes> A + C \\<otimes> B) ?is\n\ngoal (1 subgoal):\n 1. C \\<otimes> (A + B) = C \\<otimes> A + C \\<otimes> B", "have \"tensor_from_lookup (dims C @ dims A) (lookup (C \\<otimes> (A + B))) = C \\<otimes> (A + B)\"\n       \"tensor_from_lookup (dims C @ dims A) (lookup ((C \\<otimes> A) + (C \\<otimes> B))) = (C \\<otimes> A) + (C \\<otimes> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_from_lookup (dims C @ dims A) (lookup (C \\<otimes> (A + B))) =\n    C \\<otimes> (A + B) &&&\n    tensor_from_lookup (dims C @ dims A)\n     (lookup (C \\<otimes> A + C \\<otimes> B)) =\n    C \\<otimes> A + C \\<otimes> B", "by (metis (no_types, lifting) assms plus_dim1 dims_tensor_prod tensor_lookup)+"], ["proof (state)\nthis:\n  tensor_from_lookup (dims C @ dims A) (lookup (C \\<otimes> (A + B))) =\n  C \\<otimes> (A + B)\n  tensor_from_lookup (dims C @ dims A)\n   (lookup (C \\<otimes> A + C \\<otimes> B)) =\n  C \\<otimes> A + C \\<otimes> B\n\ngoal (1 subgoal):\n 1. C \\<otimes> (A + B) = C \\<otimes> A + C \\<otimes> B", "ultimately"], ["proof (chain)\npicking this:\n  ?is \\<lhd> dims C @ dims A \\<Longrightarrow>\n  lookup (C \\<otimes> (A + B)) ?is =\n  lookup (C \\<otimes> A + C \\<otimes> B) ?is\n  tensor_from_lookup (dims C @ dims A) (lookup (C \\<otimes> (A + B))) =\n  C \\<otimes> (A + B)\n  tensor_from_lookup (dims C @ dims A)\n   (lookup (C \\<otimes> A + C \\<otimes> B)) =\n  C \\<otimes> A + C \\<otimes> B", "show ?thesis"], ["proof (prove)\nusing this:\n  ?is \\<lhd> dims C @ dims A \\<Longrightarrow>\n  lookup (C \\<otimes> (A + B)) ?is =\n  lookup (C \\<otimes> A + C \\<otimes> B) ?is\n  tensor_from_lookup (dims C @ dims A) (lookup (C \\<otimes> (A + B))) =\n  C \\<otimes> (A + B)\n  tensor_from_lookup (dims C @ dims A)\n   (lookup (C \\<otimes> A + C \\<otimes> B)) =\n  C \\<otimes> A + C \\<otimes> B\n\ngoal (1 subgoal):\n 1. C \\<otimes> (A + B) = C \\<otimes> A + C \\<otimes> B", "using tensor_from_lookup_eqI"], ["proof (prove)\nusing this:\n  ?is \\<lhd> dims C @ dims A \\<Longrightarrow>\n  lookup (C \\<otimes> (A + B)) ?is =\n  lookup (C \\<otimes> A + C \\<otimes> B) ?is\n  tensor_from_lookup (dims C @ dims A) (lookup (C \\<otimes> (A + B))) =\n  C \\<otimes> (A + B)\n  tensor_from_lookup (dims C @ dims A)\n   (lookup (C \\<otimes> A + C \\<otimes> B)) =\n  C \\<otimes> A + C \\<otimes> B\n  (\\<And>is.\n      is \\<lhd> ?ds \\<Longrightarrow>\n      ?e\\<^sub>1 is = ?e\\<^sub>2 is) \\<Longrightarrow>\n  tensor_from_lookup ?ds ?e\\<^sub>1 = tensor_from_lookup ?ds ?e\\<^sub>2\n\ngoal (1 subgoal):\n 1. C \\<otimes> (A + B) = C \\<otimes> A + C \\<otimes> B", "by (metis \\<open>\\<And>is. is \\<lhd> dims C @ dims A \\<Longrightarrow> lookup (C \\<otimes> (A + B)) is = lookup (C \\<otimes> A + C \\<otimes> B) is\\<close>)"], ["proof (state)\nthis:\n  C \\<otimes> (A + B) = C \\<otimes> A + C \\<otimes> B\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation tensor :: (ring_1) monoid_mult\nbegin"], ["", "definition tensor_one_def:\"1 = tensor_from_vec [] [1]\""], ["", "lemma tensor_one_from_lookup: \"1 = tensor_from_lookup [] (\\<lambda>_. 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = tensor_from_lookup [] (\\<lambda>_. 1::'a)", "unfolding tensor_one_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_from_vec [] [1::'a] = tensor_from_lookup [] (\\<lambda>_. 1::'a)", "by (rule tensor_eqI; simp_all add: tensor_from_lookup_def )"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a tensor, monoid_mult_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. 1 \\<otimes> a = a\n 2. \\<And>a. a \\<otimes> 1 = a", "fix A::\"'a::ring_1 tensor\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. 1 \\<otimes> a = a\n 2. \\<And>a. a \\<otimes> 1 = a", "show \"A * 1 = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<otimes> 1 = A", "unfolding tensor_one_from_lookup"], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<otimes> tensor_from_lookup [] (\\<lambda>_. 1::'a) = A", "by (rule tensor_lookup_eqI;metis lookup_tensor_prod[of _ \"A\" \"[]\" \"tensor_from_lookup [] (\\<lambda>_. 1)\"]\n          lookup_tensor_from_lookup valid_index.Nil append_Nil2 dims_tensor dims_tensor_prod\n          length_tensor_vec_from_lookup mult.right_neutral tensor_from_lookup_def)"], ["proof (state)\nthis:\n  A \\<otimes> 1 = A\n\ngoal (1 subgoal):\n 1. \\<And>a. 1 \\<otimes> a = a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. 1 \\<otimes> a = a", "fix A::\"'a::ring_1 tensor\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. 1 \\<otimes> a = a", "show \"1 * A = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<otimes> A = A", "unfolding tensor_one_from_lookup"], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor_from_lookup [] (\\<lambda>_. 1::'a) \\<otimes> A = A", "by (rule tensor_lookup_eqI; metis lookup_tensor_prod[of \"[]\" \"tensor_from_lookup [] (\\<lambda>_. 1)\" _ \"A\"]\n          lookup_tensor_from_lookup valid_index.Nil List.append.append_Nil dims_tensor dims_tensor_prod\n          length_tensor_vec_from_lookup mult.left_neutral tensor_from_lookup_def)"], ["proof (state)\nthis:\n  1 \\<otimes> A = A\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma order_tensor_one: \"order 1 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order 1 = 0", "unfolding tensor_one_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. order (tensor_from_vec [] [1::'a]) = 0", "by simp"], ["", "lemma smult_prod_extract1:\nfixes a::\"'a::comm_ring_1\"\nshows \"a \\<cdot> (A \\<otimes> B) = (a \\<cdot> A) \\<otimes> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<cdot> (A \\<otimes> B) = a \\<cdot> A \\<otimes> B", "proof (rule tensor_lookup_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. dims (a \\<cdot> (A \\<otimes> B)) = dims (a \\<cdot> A \\<otimes> B)\n 2. \\<And>is.\n       is \\<lhd> dims (a \\<cdot> (A \\<otimes> B)) \\<Longrightarrow>\n       lookup (a \\<cdot> (A \\<otimes> B)) is =\n       lookup (a \\<cdot> A \\<otimes> B) is", "show \"dims (a \\<cdot> (A \\<otimes> B)) = dims ((a \\<cdot> A) \\<otimes> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dims (a \\<cdot> (A \\<otimes> B)) = dims (a \\<cdot> A \\<otimes> B)", "by simp"], ["proof (state)\nthis:\n  dims (a \\<cdot> (A \\<otimes> B)) = dims (a \\<cdot> A \\<otimes> B)\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (a \\<cdot> (A \\<otimes> B)) \\<Longrightarrow>\n       lookup (a \\<cdot> (A \\<otimes> B)) is =\n       lookup (a \\<cdot> A \\<otimes> B) is", "fix \"is\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (a \\<cdot> (A \\<otimes> B)) \\<Longrightarrow>\n       lookup (a \\<cdot> (A \\<otimes> B)) is =\n       lookup (a \\<cdot> A \\<otimes> B) is", "assume \"is \\<lhd> dims (a \\<cdot> (A \\<otimes> B))\""], ["proof (state)\nthis:\n  is \\<lhd> dims (a \\<cdot> (A \\<otimes> B))\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (a \\<cdot> (A \\<otimes> B)) \\<Longrightarrow>\n       lookup (a \\<cdot> (A \\<otimes> B)) is =\n       lookup (a \\<cdot> A \\<otimes> B) is", "then"], ["proof (chain)\npicking this:\n  is \\<lhd> dims (a \\<cdot> (A \\<otimes> B))", "have \"is \\<lhd> dims (A \\<otimes> B)\""], ["proof (prove)\nusing this:\n  is \\<lhd> dims (a \\<cdot> (A \\<otimes> B))\n\ngoal (1 subgoal):\n 1. is \\<lhd> dims (A \\<otimes> B)", "by auto"], ["proof (state)\nthis:\n  is \\<lhd> dims (A \\<otimes> B)\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (a \\<cdot> (A \\<otimes> B)) \\<Longrightarrow>\n       lookup (a \\<cdot> (A \\<otimes> B)) is =\n       lookup (a \\<cdot> A \\<otimes> B) is", "then"], ["proof (chain)\npicking this:\n  is \\<lhd> dims (A \\<otimes> B)", "obtain is1 is2 where \"is1 \\<lhd> dims A\" \"is2 \\<lhd> dims B\" \"is = is1 @ is2\""], ["proof (prove)\nusing this:\n  is \\<lhd> dims (A \\<otimes> B)\n\ngoal (1 subgoal):\n 1. (\\<And>is1 is2.\n        \\<lbrakk>is1 \\<lhd> dims A; is2 \\<lhd> dims B;\n         is = is1 @ is2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis dims_tensor_prod valid_index_split)"], ["proof (state)\nthis:\n  is1 \\<lhd> dims A\n  is2 \\<lhd> dims B\n  is = is1 @ is2\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (a \\<cdot> (A \\<otimes> B)) \\<Longrightarrow>\n       lookup (a \\<cdot> (A \\<otimes> B)) is =\n       lookup (a \\<cdot> A \\<otimes> B) is", "then"], ["proof (chain)\npicking this:\n  is1 \\<lhd> dims A\n  is2 \\<lhd> dims B\n  is = is1 @ is2", "have \"is1 \\<lhd> dims (a \\<cdot> A)\""], ["proof (prove)\nusing this:\n  is1 \\<lhd> dims A\n  is2 \\<lhd> dims B\n  is = is1 @ is2\n\ngoal (1 subgoal):\n 1. is1 \\<lhd> dims (a \\<cdot> A)", "by auto"], ["proof (state)\nthis:\n  is1 \\<lhd> dims (a \\<cdot> A)\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (a \\<cdot> (A \\<otimes> B)) \\<Longrightarrow>\n       lookup (a \\<cdot> (A \\<otimes> B)) is =\n       lookup (a \\<cdot> A \\<otimes> B) is", "show \"lookup (a \\<cdot> (A \\<otimes> B)) is = lookup (a \\<cdot> A \\<otimes> B) is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (a \\<cdot> (A \\<otimes> B)) is =\n    lookup (a \\<cdot> A \\<otimes> B) is", "using lookup_tensor_prod[OF \\<open>is1 \\<lhd> dims A\\<close> \\<open>is2 \\<lhd> dims B\\<close>] lookup_tensor_prod[OF \\<open>is1 \\<lhd> dims (a \\<cdot> A)\\<close> \\<open>is2 \\<lhd> dims B\\<close>]\n        lookup_smult[OF \\<open>is \\<lhd> dims (A \\<otimes> B)\\<close>] lookup_smult[OF \\<open>is1 \\<lhd> dims A\\<close>] \\<open>is = is1 @ is2\\<close>"], ["proof (prove)\nusing this:\n  lookup (A \\<otimes> B) (is1 @ is2) = lookup A is1 * lookup B is2\n  lookup (a \\<cdot> A \\<otimes> B) (is1 @ is2) =\n  lookup (a \\<cdot> A) is1 * lookup B is2\n  lookup (?\\<alpha> \\<cdot> (A \\<otimes> B)) is =\n  ?\\<alpha> * lookup (A \\<otimes> B) is\n  lookup (?\\<alpha> \\<cdot> A) is1 = ?\\<alpha> * lookup A is1\n  is = is1 @ is2\n\ngoal (1 subgoal):\n 1. lookup (a \\<cdot> (A \\<otimes> B)) is =\n    lookup (a \\<cdot> A \\<otimes> B) is", "by simp"], ["proof (state)\nthis:\n  lookup (a \\<cdot> (A \\<otimes> B)) is =\n  lookup (a \\<cdot> A \\<otimes> B) is\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma smult_prod_extract2:\nfixes a::\"'a::comm_ring_1\"\nshows \"a \\<cdot> (A \\<otimes> B) = A \\<otimes> (a \\<cdot> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<cdot> (A \\<otimes> B) = A \\<otimes> (a \\<cdot> B)", "proof (rule tensor_lookup_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. dims (a \\<cdot> (A \\<otimes> B)) = dims (A \\<otimes> (a \\<cdot> B))\n 2. \\<And>is.\n       is \\<lhd> dims (a \\<cdot> (A \\<otimes> B)) \\<Longrightarrow>\n       lookup (a \\<cdot> (A \\<otimes> B)) is =\n       lookup (A \\<otimes> (a \\<cdot> B)) is", "show \"dims (a \\<cdot> (A \\<otimes> B)) = dims (A \\<otimes> (a \\<cdot> B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dims (a \\<cdot> (A \\<otimes> B)) = dims (A \\<otimes> (a \\<cdot> B))", "by simp"], ["proof (state)\nthis:\n  dims (a \\<cdot> (A \\<otimes> B)) = dims (A \\<otimes> (a \\<cdot> B))\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (a \\<cdot> (A \\<otimes> B)) \\<Longrightarrow>\n       lookup (a \\<cdot> (A \\<otimes> B)) is =\n       lookup (A \\<otimes> (a \\<cdot> B)) is", "fix \"is\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (a \\<cdot> (A \\<otimes> B)) \\<Longrightarrow>\n       lookup (a \\<cdot> (A \\<otimes> B)) is =\n       lookup (A \\<otimes> (a \\<cdot> B)) is", "assume \"is \\<lhd> dims (a \\<cdot> (A \\<otimes> B))\""], ["proof (state)\nthis:\n  is \\<lhd> dims (a \\<cdot> (A \\<otimes> B))\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (a \\<cdot> (A \\<otimes> B)) \\<Longrightarrow>\n       lookup (a \\<cdot> (A \\<otimes> B)) is =\n       lookup (A \\<otimes> (a \\<cdot> B)) is", "then"], ["proof (chain)\npicking this:\n  is \\<lhd> dims (a \\<cdot> (A \\<otimes> B))", "have \"is \\<lhd> dims (A \\<otimes> B)\""], ["proof (prove)\nusing this:\n  is \\<lhd> dims (a \\<cdot> (A \\<otimes> B))\n\ngoal (1 subgoal):\n 1. is \\<lhd> dims (A \\<otimes> B)", "by auto"], ["proof (state)\nthis:\n  is \\<lhd> dims (A \\<otimes> B)\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (a \\<cdot> (A \\<otimes> B)) \\<Longrightarrow>\n       lookup (a \\<cdot> (A \\<otimes> B)) is =\n       lookup (A \\<otimes> (a \\<cdot> B)) is", "then"], ["proof (chain)\npicking this:\n  is \\<lhd> dims (A \\<otimes> B)", "obtain is1 is2 where \"is1 \\<lhd> dims A\" \"is2 \\<lhd> dims B\" \"is = is1 @ is2\""], ["proof (prove)\nusing this:\n  is \\<lhd> dims (A \\<otimes> B)\n\ngoal (1 subgoal):\n 1. (\\<And>is1 is2.\n        \\<lbrakk>is1 \\<lhd> dims A; is2 \\<lhd> dims B;\n         is = is1 @ is2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis dims_tensor_prod valid_index_split)"], ["proof (state)\nthis:\n  is1 \\<lhd> dims A\n  is2 \\<lhd> dims B\n  is = is1 @ is2\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (a \\<cdot> (A \\<otimes> B)) \\<Longrightarrow>\n       lookup (a \\<cdot> (A \\<otimes> B)) is =\n       lookup (A \\<otimes> (a \\<cdot> B)) is", "then"], ["proof (chain)\npicking this:\n  is1 \\<lhd> dims A\n  is2 \\<lhd> dims B\n  is = is1 @ is2", "have \"is2 \\<lhd> dims (a \\<cdot> B)\""], ["proof (prove)\nusing this:\n  is1 \\<lhd> dims A\n  is2 \\<lhd> dims B\n  is = is1 @ is2\n\ngoal (1 subgoal):\n 1. is2 \\<lhd> dims (a \\<cdot> B)", "by auto"], ["proof (state)\nthis:\n  is2 \\<lhd> dims (a \\<cdot> B)\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (a \\<cdot> (A \\<otimes> B)) \\<Longrightarrow>\n       lookup (a \\<cdot> (A \\<otimes> B)) is =\n       lookup (A \\<otimes> (a \\<cdot> B)) is", "show \"lookup (a \\<cdot> (A \\<otimes> B)) is = lookup (A \\<otimes> (a \\<cdot> B)) is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (a \\<cdot> (A \\<otimes> B)) is =\n    lookup (A \\<otimes> (a \\<cdot> B)) is", "using lookup_tensor_prod[OF \\<open>is1 \\<lhd> dims A\\<close> \\<open>is2 \\<lhd> dims B\\<close>] lookup_tensor_prod[OF \\<open>is1 \\<lhd> dims A\\<close> \\<open>is2 \\<lhd> dims (a \\<cdot> B)\\<close>]\n        lookup_smult[OF \\<open>is \\<lhd> dims (A \\<otimes> B)\\<close>] lookup_smult[OF \\<open>is2 \\<lhd> dims B\\<close>] \\<open>is = is1 @ is2\\<close>"], ["proof (prove)\nusing this:\n  lookup (A \\<otimes> B) (is1 @ is2) = lookup A is1 * lookup B is2\n  lookup (A \\<otimes> (a \\<cdot> B)) (is1 @ is2) =\n  lookup A is1 * lookup (a \\<cdot> B) is2\n  lookup (?\\<alpha> \\<cdot> (A \\<otimes> B)) is =\n  ?\\<alpha> * lookup (A \\<otimes> B) is\n  lookup (?\\<alpha> \\<cdot> B) is2 = ?\\<alpha> * lookup B is2\n  is = is1 @ is2\n\ngoal (1 subgoal):\n 1. lookup (a \\<cdot> (A \\<otimes> B)) is =\n    lookup (A \\<otimes> (a \\<cdot> B)) is", "by simp"], ["proof (state)\nthis:\n  lookup (a \\<cdot> (A \\<otimes> B)) is =\n  lookup (A \\<otimes> (a \\<cdot> B)) is\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma order_0_multiple_of_one:\nassumes \"order A = 0\"\nobtains a where \"A = a \\<cdot> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a. A = a \\<cdot> 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>a. A = a \\<cdot> 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    A = ?a2 \\<cdot> 1", "assume \"(\\<And>a. A = a \\<cdot> 1 \\<Longrightarrow> thesis)\""], ["proof (state)\nthis:\n  A = ?a \\<cdot> 1 \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>a. A = a \\<cdot> 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    A = ?a2 \\<cdot> 1", "have \"length (vec A) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (vec A) = 1", "using assms"], ["proof (prove)\nusing this:\n  order A = 0\n\ngoal (1 subgoal):\n 1. length (vec A) = 1", "by (simp add:length_vec)"], ["proof (state)\nthis:\n  length (vec A) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>a. A = a \\<cdot> 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    A = ?a2 \\<cdot> 1", "then"], ["proof (chain)\npicking this:\n  length (vec A) = 1", "obtain a where \"vec A = [a]\""], ["proof (prove)\nusing this:\n  length (vec A) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>a. vec A = [a] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (metis One_nat_def Suc_length_conv length_0_conv)"], ["proof (state)\nthis:\n  vec A = [a]\n\ngoal (1 subgoal):\n 1. (\\<And>a. A = a \\<cdot> 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    A = ?a2 \\<cdot> 1", "moreover"], ["proof (state)\nthis:\n  vec A = [a]\n\ngoal (1 subgoal):\n 1. (\\<And>a. A = a \\<cdot> 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    A = ?a2 \\<cdot> 1", "have \"vec (a \\<cdot> 1) = [a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec (a \\<cdot> 1) = [a]", "unfolding smult_def tensor_one_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec (tensor_from_vec (dims (tensor_from_vec [] [1::'a]))\n          (vec_smult a (vec (tensor_from_vec [] [1::'a])))) =\n    [a]", "by (simp add: vec_smult_def)"], ["proof (state)\nthis:\n  vec (a \\<cdot> 1) = [a]\n\ngoal (1 subgoal):\n 1. (\\<And>a. A = a \\<cdot> 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    A = ?a2 \\<cdot> 1", "ultimately"], ["proof (chain)\npicking this:\n  vec A = [a]\n  vec (a \\<cdot> 1) = [a]", "have \"A = a \\<cdot> 1\""], ["proof (prove)\nusing this:\n  vec A = [a]\n  vec (a \\<cdot> 1) = [a]\n\ngoal (1 subgoal):\n 1. A = a \\<cdot> 1", "using tensor_eqI"], ["proof (prove)\nusing this:\n  vec A = [a]\n  vec (a \\<cdot> 1) = [a]\n  \\<lbrakk>dims ?A = dims ?B; vec ?A = vec ?B\\<rbrakk>\n  \\<Longrightarrow> ?A = ?B\n\ngoal (1 subgoal):\n 1. A = a \\<cdot> 1", "by (metis assms dims_smult length_0_conv order_tensor_one)"], ["proof (state)\nthis:\n  A = a \\<cdot> 1\n\ngoal (1 subgoal):\n 1. (\\<And>a. A = a \\<cdot> 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    A = ?a2 \\<cdot> 1", "then"], ["proof (chain)\npicking this:\n  A = a \\<cdot> 1", "show \"A = hd (vec A) \\<cdot> 1\""], ["proof (prove)\nusing this:\n  A = a \\<cdot> 1\n\ngoal (1 subgoal):\n 1. A = hd (vec A) \\<cdot> 1", "using \\<open>vec A = [a]\\<close>"], ["proof (prove)\nusing this:\n  A = a \\<cdot> 1\n  vec A = [a]\n\ngoal (1 subgoal):\n 1. A = hd (vec A) \\<cdot> 1", "by auto"], ["proof (state)\nthis:\n  A = hd (vec A) \\<cdot> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma smult_1:\nfixes A::\"'a::ring_1 tensor\"\nshows \"A = 1 \\<cdot> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = (1::'a) \\<cdot> A", "unfolding smult_def tensor_one_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A = tensor_from_vec (dims A) (vec_smult (1::'a) (vec A))", "apply (rule tensor_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dims A = dims (tensor_from_vec (dims A) (vec_smult (1::'a) (vec A)))\n 2. vec A = vec (tensor_from_vec (dims A) (vec_smult (1::'a) (vec A)))", "apply (simp add: length_vec length_vec_smult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec A = vec (tensor_from_vec (dims A) (vec_smult (1::'a) (vec A)))", "by (metis dims_tensor length_vec length_vec_smult lookup_smult mult.left_neutral smult_def tensor_lookup_eqI)"], ["", "lemma tensor0_prod_right[simp]: \"A \\<otimes> tensor0 ds = tensor0 (dims A @ ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<otimes> tensor0 ds = tensor0 (dims A @ ds)", "proof (rule tensor_lookup_eqI,simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (A \\<otimes> tensor0 ds) \\<Longrightarrow>\n       lookup (A \\<otimes> tensor0 ds) is =\n       lookup (tensor0 (dims A @ ds)) is", "fix \"is\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (A \\<otimes> tensor0 ds) \\<Longrightarrow>\n       lookup (A \\<otimes> tensor0 ds) is =\n       lookup (tensor0 (dims A @ ds)) is", "assume \"is \\<lhd> dims (A \\<otimes> tensor0 ds)\""], ["proof (state)\nthis:\n  is \\<lhd> dims (A \\<otimes> tensor0 ds)\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (A \\<otimes> tensor0 ds) \\<Longrightarrow>\n       lookup (A \\<otimes> tensor0 ds) is =\n       lookup (tensor0 (dims A @ ds)) is", "then"], ["proof (chain)\npicking this:\n  is \\<lhd> dims (A \\<otimes> tensor0 ds)", "obtain is1 is2 where \"is1 \\<lhd> dims A\" \"is2 \\<lhd> dims (tensor0 ds)\" \"is = is1 @ is2\""], ["proof (prove)\nusing this:\n  is \\<lhd> dims (A \\<otimes> tensor0 ds)\n\ngoal (1 subgoal):\n 1. (\\<And>is1 is2.\n        \\<lbrakk>is1 \\<lhd> dims A; is2 \\<lhd> dims (tensor0 ds);\n         is = is1 @ is2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis dims_tensor0 dims_tensor_prod valid_index_split)"], ["proof (state)\nthis:\n  is1 \\<lhd> dims A\n  is2 \\<lhd> dims (tensor0 ds)\n  is = is1 @ is2\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (A \\<otimes> tensor0 ds) \\<Longrightarrow>\n       lookup (A \\<otimes> tensor0 ds) is =\n       lookup (tensor0 (dims A @ ds)) is", "then"], ["proof (chain)\npicking this:\n  is1 \\<lhd> dims A\n  is2 \\<lhd> dims (tensor0 ds)\n  is = is1 @ is2", "show \"lookup (A \\<otimes> tensor0 ds) is = lookup (tensor0 (dims A @ ds)) is\""], ["proof (prove)\nusing this:\n  is1 \\<lhd> dims A\n  is2 \\<lhd> dims (tensor0 ds)\n  is = is1 @ is2\n\ngoal (1 subgoal):\n 1. lookup (A \\<otimes> tensor0 ds) is = lookup (tensor0 (dims A @ ds)) is", "by (metis (no_types, lifting) \\<open>is \\<lhd> dims (A \\<otimes> tensor0 ds)\\<close> dims_tensor0 dims_tensor_prod lookup_tensor0 lookup_tensor_prod mult_zero_right)"], ["proof (state)\nthis:\n  lookup (A \\<otimes> tensor0 ds) is = lookup (tensor0 (dims A @ ds)) is\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tensor0_prod_left[simp]: \"tensor0 ds \\<otimes> A = tensor0 (ds @ dims A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tensor0 ds \\<otimes> A = tensor0 (ds @ dims A)", "proof (rule tensor_lookup_eqI,simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (tensor0 ds \\<otimes> A) \\<Longrightarrow>\n       lookup (tensor0 ds \\<otimes> A) is =\n       lookup (tensor0 (ds @ dims A)) is", "fix \"is\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (tensor0 ds \\<otimes> A) \\<Longrightarrow>\n       lookup (tensor0 ds \\<otimes> A) is =\n       lookup (tensor0 (ds @ dims A)) is", "assume \"is \\<lhd> dims (tensor0 ds \\<otimes> A)\""], ["proof (state)\nthis:\n  is \\<lhd> dims (tensor0 ds \\<otimes> A)\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (tensor0 ds \\<otimes> A) \\<Longrightarrow>\n       lookup (tensor0 ds \\<otimes> A) is =\n       lookup (tensor0 (ds @ dims A)) is", "then"], ["proof (chain)\npicking this:\n  is \\<lhd> dims (tensor0 ds \\<otimes> A)", "obtain is1 is2 where \"is1 \\<lhd> dims (tensor0 ds)\" \"is2 \\<lhd> dims A\" \"is = is1 @ is2\""], ["proof (prove)\nusing this:\n  is \\<lhd> dims (tensor0 ds \\<otimes> A)\n\ngoal (1 subgoal):\n 1. (\\<And>is1 is2.\n        \\<lbrakk>is1 \\<lhd> dims (tensor0 ds); is2 \\<lhd> dims A;\n         is = is1 @ is2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis dims_tensor0 dims_tensor_prod valid_index_split)"], ["proof (state)\nthis:\n  is1 \\<lhd> dims (tensor0 ds)\n  is2 \\<lhd> dims A\n  is = is1 @ is2\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (tensor0 ds \\<otimes> A) \\<Longrightarrow>\n       lookup (tensor0 ds \\<otimes> A) is =\n       lookup (tensor0 (ds @ dims A)) is", "then"], ["proof (chain)\npicking this:\n  is1 \\<lhd> dims (tensor0 ds)\n  is2 \\<lhd> dims A\n  is = is1 @ is2", "show \"lookup (tensor0 ds \\<otimes> A) is = lookup (tensor0 (ds @ dims A)) is\""], ["proof (prove)\nusing this:\n  is1 \\<lhd> dims (tensor0 ds)\n  is2 \\<lhd> dims A\n  is = is1 @ is2\n\ngoal (1 subgoal):\n 1. lookup (tensor0 ds \\<otimes> A) is = lookup (tensor0 (ds @ dims A)) is", "by (metis (no_types, lifting) \\<open>is \\<lhd> dims (tensor0 ds \\<otimes> A)\\<close> dims_tensor0 dims_tensor_prod lookup_tensor0 lookup_tensor_prod mult_zero_left)"], ["proof (state)\nthis:\n  lookup (tensor0 ds \\<otimes> A) is = lookup (tensor0 (ds @ dims A)) is\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subtensor_prod_with_vec:\nassumes \"order A = 1\" \"i < hd (dims A)\"\nshows \"subtensor (A \\<otimes> B) i = lookup A [i] \\<cdot> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subtensor (A \\<otimes> B) i = lookup A [i] \\<cdot> B", "proof (rule tensor_lookup_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. dims (subtensor (A \\<otimes> B) i) = dims (lookup A [i] \\<cdot> B)\n 2. \\<And>is.\n       is \\<lhd> dims (subtensor (A \\<otimes> B) i) \\<Longrightarrow>\n       lookup (subtensor (A \\<otimes> B) i) is =\n       lookup (lookup A [i] \\<cdot> B) is", "have \"dims (A \\<otimes> B) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dims (A \\<otimes> B) \\<noteq> []", "using assms(1)"], ["proof (prove)\nusing this:\n  order A = 1\n\ngoal (1 subgoal):\n 1. dims (A \\<otimes> B) \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  dims (A \\<otimes> B) \\<noteq> []\n\ngoal (2 subgoals):\n 1. dims (subtensor (A \\<otimes> B) i) = dims (lookup A [i] \\<cdot> B)\n 2. \\<And>is.\n       is \\<lhd> dims (subtensor (A \\<otimes> B) i) \\<Longrightarrow>\n       lookup (subtensor (A \\<otimes> B) i) is =\n       lookup (lookup A [i] \\<cdot> B) is", "have \"hd (dims A) =  hd (dims (A \\<otimes> B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (dims A) = hd (dims (A \\<otimes> B))", "by (metis One_nat_def Suc_length_conv append_Cons assms(1) dims_tensor_prod list.sel(1))"], ["proof (state)\nthis:\n  hd (dims A) = hd (dims (A \\<otimes> B))\n\ngoal (2 subgoals):\n 1. dims (subtensor (A \\<otimes> B) i) = dims (lookup A [i] \\<cdot> B)\n 2. \\<And>is.\n       is \\<lhd> dims (subtensor (A \\<otimes> B) i) \\<Longrightarrow>\n       lookup (subtensor (A \\<otimes> B) i) is =\n       lookup (lookup A [i] \\<cdot> B) is", "show \"dims (subtensor (A \\<otimes> B) i) = dims (lookup A [i] \\<cdot> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dims (subtensor (A \\<otimes> B) i) = dims (lookup A [i] \\<cdot> B)", "unfolding dims_smult dims_subtensor[OF \\<open>dims (A \\<otimes> B) \\<noteq> []\\<close> \\<open>i < hd (dims A)\\<close>[unfolded \\<open>hd (dims A) =  hd (dims (A \\<otimes> B))\\<close>] ]"], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (dims (A \\<otimes> B)) = dims B", "by (metis One_nat_def Suc_length_conv append.simps(2) append_self_conv2 assms(1) dims_tensor_prod length_0_conv list.sel(3))"], ["proof (state)\nthis:\n  dims (subtensor (A \\<otimes> B) i) = dims (lookup A [i] \\<cdot> B)\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (subtensor (A \\<otimes> B) i) \\<Longrightarrow>\n       lookup (subtensor (A \\<otimes> B) i) is =\n       lookup (lookup A [i] \\<cdot> B) is", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (subtensor (A \\<otimes> B) i) \\<Longrightarrow>\n       lookup (subtensor (A \\<otimes> B) i) is =\n       lookup (lookup A [i] \\<cdot> B) is", "fix \"is\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (subtensor (A \\<otimes> B) i) \\<Longrightarrow>\n       lookup (subtensor (A \\<otimes> B) i) is =\n       lookup (lookup A [i] \\<cdot> B) is", "assume \"is \\<lhd> dims (subtensor (A \\<otimes> B) i)\""], ["proof (state)\nthis:\n  is \\<lhd> dims (subtensor (A \\<otimes> B) i)\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (subtensor (A \\<otimes> B) i) \\<Longrightarrow>\n       lookup (subtensor (A \\<otimes> B) i) is =\n       lookup (lookup A [i] \\<cdot> B) is", "have \"dims (A \\<otimes> B) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dims (A \\<otimes> B) \\<noteq> []", "using assms(1)"], ["proof (prove)\nusing this:\n  order A = 1\n\ngoal (1 subgoal):\n 1. dims (A \\<otimes> B) \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  dims (A \\<otimes> B) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (subtensor (A \\<otimes> B) i) \\<Longrightarrow>\n       lookup (subtensor (A \\<otimes> B) i) is =\n       lookup (lookup A [i] \\<cdot> B) is", "have \"hd (dims A) =  hd (dims (A \\<otimes> B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (dims A) = hd (dims (A \\<otimes> B))", "by (metis One_nat_def Suc_length_conv append_Cons assms(1) dims_tensor_prod list.sel(1))"], ["proof (state)\nthis:\n  hd (dims A) = hd (dims (A \\<otimes> B))\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (subtensor (A \\<otimes> B) i) \\<Longrightarrow>\n       lookup (subtensor (A \\<otimes> B) i) is =\n       lookup (lookup A [i] \\<cdot> B) is", "then"], ["proof (chain)\npicking this:\n  hd (dims A) = hd (dims (A \\<otimes> B))", "have \"is \\<lhd> dims B\""], ["proof (prove)\nusing this:\n  hd (dims A) = hd (dims (A \\<otimes> B))\n\ngoal (1 subgoal):\n 1. is \\<lhd> dims B", "using \\<open>is \\<lhd> dims (subtensor (A \\<otimes> B) i)\\<close>[unfolded dims_subtensor[OF \\<open>dims (A \\<otimes> B) \\<noteq> []\\<close> \\<open>i < hd (dims A)\\<close>[unfolded \\<open>hd (dims A) =  hd (dims (A \\<otimes> B))\\<close>] ]]"], ["proof (prove)\nusing this:\n  hd (dims A) = hd (dims (A \\<otimes> B))\n  is \\<lhd> tl (dims (A \\<otimes> B))\n\ngoal (1 subgoal):\n 1. is \\<lhd> dims B", "by (metis One_nat_def Suc_length_conv append_self_conv2 assms(1) dims_tensor_prod length_0_conv list.sel(3) list.simps(3) tl_append2)"], ["proof (state)\nthis:\n  is \\<lhd> dims B\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (subtensor (A \\<otimes> B) i) \\<Longrightarrow>\n       lookup (subtensor (A \\<otimes> B) i) is =\n       lookup (lookup A [i] \\<cdot> B) is", "have \"[i] \\<lhd> dims A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [i] \\<lhd> dims A", "using assms"], ["proof (prove)\nusing this:\n  order A = 1\n  i < hd (dims A)\n\ngoal (1 subgoal):\n 1. [i] \\<lhd> dims A", "by (metis One_nat_def Suc_length_conv length_0_conv list.sel(1) valid_index.Nil valid_index.simps)"], ["proof (state)\nthis:\n  [i] \\<lhd> dims A\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (subtensor (A \\<otimes> B) i) \\<Longrightarrow>\n       lookup (subtensor (A \\<otimes> B) i) is =\n       lookup (lookup A [i] \\<cdot> B) is", "then"], ["proof (chain)\npicking this:\n  [i] \\<lhd> dims A", "have \"i # is \\<lhd> dims (A \\<otimes> B)\""], ["proof (prove)\nusing this:\n  [i] \\<lhd> dims A\n\ngoal (1 subgoal):\n 1. i # is \\<lhd> dims (A \\<otimes> B)", "using \\<open>is \\<lhd> dims (subtensor (A \\<otimes> B) i)\\<close> dims_subtensor valid_index.Cons"], ["proof (prove)\nusing this:\n  [i] \\<lhd> dims A\n  is \\<lhd> dims (subtensor (A \\<otimes> B) i)\n  \\<lbrakk>dims ?A \\<noteq> []; ?i < hd (dims ?A)\\<rbrakk>\n  \\<Longrightarrow> dims (subtensor ?A ?i) = tl (dims ?A)\n  \\<lbrakk>?is \\<lhd> ?ds; ?i < ?d\\<rbrakk>\n  \\<Longrightarrow> ?i # ?is \\<lhd> ?d # ?ds\n\ngoal (1 subgoal):\n 1. i # is \\<lhd> dims (A \\<otimes> B)", "by auto"], ["proof (state)\nthis:\n  i # is \\<lhd> dims (A \\<otimes> B)\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims (subtensor (A \\<otimes> B) i) \\<Longrightarrow>\n       lookup (subtensor (A \\<otimes> B) i) is =\n       lookup (lookup A [i] \\<cdot> B) is", "then"], ["proof (chain)\npicking this:\n  i # is \\<lhd> dims (A \\<otimes> B)", "show \"lookup (subtensor (A \\<otimes> B) i) is = lookup (lookup A [i] \\<cdot> B) is\""], ["proof (prove)\nusing this:\n  i # is \\<lhd> dims (A \\<otimes> B)\n\ngoal (1 subgoal):\n 1. lookup (subtensor (A \\<otimes> B) i) is =\n    lookup (lookup A [i] \\<cdot> B) is", "unfolding lookup_subtensor1[OF \\<open>i # is \\<lhd> dims (A \\<otimes> B)\\<close>]"], ["proof (prove)\nusing this:\n  i # is \\<lhd> dims (A \\<otimes> B)\n\ngoal (1 subgoal):\n 1. lookup (A \\<otimes> B) (i # is) = lookup (lookup A [i] \\<cdot> B) is", "using lookup_tensor_prod[OF \\<open>[i] \\<lhd> dims A\\<close> \\<open>is \\<lhd> dims B\\<close>] lookup_smult\n    \\<open>is \\<lhd> dims B\\<close>"], ["proof (prove)\nusing this:\n  i # is \\<lhd> dims (A \\<otimes> B)\n  lookup (A \\<otimes> B) ([i] @ is) = lookup A [i] * lookup B is\n  ?is \\<lhd> dims ?A \\<Longrightarrow>\n  lookup (?\\<alpha> \\<cdot> ?A) ?is = ?\\<alpha> * lookup ?A ?is\n  is \\<lhd> dims B\n\ngoal (1 subgoal):\n 1. lookup (A \\<otimes> B) (i # is) = lookup (lookup A [i] \\<cdot> B) is", "using append_Cons"], ["proof (prove)\nusing this:\n  i # is \\<lhd> dims (A \\<otimes> B)\n  lookup (A \\<otimes> B) ([i] @ is) = lookup A [i] * lookup B is\n  ?is \\<lhd> dims ?A \\<Longrightarrow>\n  lookup (?\\<alpha> \\<cdot> ?A) ?is = ?\\<alpha> * lookup ?A ?is\n  is \\<lhd> dims B\n  (?x # ?xs) @ ?ys = ?x # ?xs @ ?ys\n\ngoal (1 subgoal):\n 1. lookup (A \\<otimes> B) (i # is) = lookup (lookup A [i] \\<cdot> B) is", "by fastforce"], ["proof (state)\nthis:\n  lookup (subtensor (A \\<otimes> B) i) is =\n  lookup (lookup A [i] \\<cdot> B) is\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}