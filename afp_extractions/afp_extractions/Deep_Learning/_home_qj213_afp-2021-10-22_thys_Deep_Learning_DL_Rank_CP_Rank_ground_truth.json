{"file_name": "/home/qj213/afp-2021-10-22/thys/Deep_Learning/DL_Rank_CP_Rank.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Deep_Learning", "problem_names": ["lemma lookup_order1_prod:\nassumes \"\\<And>B. B\\<in>set Bs \\<Longrightarrow> Tensor.order B = 1\"\nassumes \"is \\<lhd> dims (prod_list Bs)\"\nshows \"lookup (prod_list Bs) is = prod_list (map (\\<lambda>(i,B). lookup B [i]) (zip is Bs))\"", "lemma matricize_cprank_max1:\nfixes A::\"'a::field tensor\"\nassumes \"cprank_max1 A\"\nshows \"mrank (matricize I A) \\<le> 1\"", "lemma matrix_rank_le_cprank_max:\nfixes A :: \"('a::field) tensor\"\nassumes \"cprank_max r A\"\nshows \"mrank (matricize I A) \\<le> r\"", "lemma matrix_rank_le_cp_rank:\nfixes A :: \"('a::field) tensor\"\nshows \"mrank (matricize I A) \\<le> cprank A\""], "translations": [["", "lemma lookup_order1_prod:\nassumes \"\\<And>B. B\\<in>set Bs \\<Longrightarrow> Tensor.order B = 1\"\nassumes \"is \\<lhd> dims (prod_list Bs)\"\nshows \"lookup (prod_list Bs) is = prod_list (map (\\<lambda>(i,B). lookup B [i]) (zip is Bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (prod_list Bs) is =\n    prod_list (map2 (\\<lambda>i B. lookup B [i]) is Bs)", "using assms"], ["proof (prove)\nusing this:\n  ?B \\<in> set Bs \\<Longrightarrow> Tensor.order ?B = 1\n  is \\<lhd> dims (prod_list Bs)\n\ngoal (1 subgoal):\n 1. lookup (prod_list Bs) is =\n    prod_list (map2 (\\<lambda>i B. lookup B [i]) is Bs)", "proof (induction Bs arbitrary:\"is\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>is.\n       \\<lbrakk>\\<And>B.\n                   B \\<in> set [] \\<Longrightarrow> Tensor.order B = 1;\n        is \\<lhd> dims (prod_list [])\\<rbrakk>\n       \\<Longrightarrow> lookup (prod_list []) is =\n                         prod_list (map2 (\\<lambda>i B. lookup B [i]) is [])\n 2. \\<And>a Bs is.\n       \\<lbrakk>\\<And>is.\n                   \\<lbrakk>\\<And>B.\n                               B \\<in> set Bs \\<Longrightarrow>\n                               Tensor.order B = 1;\n                    is \\<lhd> dims (prod_list Bs)\\<rbrakk>\n                   \\<Longrightarrow> lookup (prod_list Bs) is =\n                                     prod_list\n(map2 (\\<lambda>i B. lookup B [i]) is Bs);\n        \\<And>B. B \\<in> set (a # Bs) \\<Longrightarrow> Tensor.order B = 1;\n        is \\<lhd> dims (prod_list (a # Bs))\\<rbrakk>\n       \\<Longrightarrow> lookup (prod_list (a # Bs)) is =\n                         prod_list\n                          (map2 (\\<lambda>i B. lookup B [i]) is (a # Bs))", "case Nil"], ["proof (state)\nthis:\n  ?B \\<in> set [] \\<Longrightarrow> Tensor.order ?B = 1\n  is \\<lhd> dims (prod_list [])\n\ngoal (2 subgoals):\n 1. \\<And>is.\n       \\<lbrakk>\\<And>B.\n                   B \\<in> set [] \\<Longrightarrow> Tensor.order B = 1;\n        is \\<lhd> dims (prod_list [])\\<rbrakk>\n       \\<Longrightarrow> lookup (prod_list []) is =\n                         prod_list (map2 (\\<lambda>i B. lookup B [i]) is [])\n 2. \\<And>a Bs is.\n       \\<lbrakk>\\<And>is.\n                   \\<lbrakk>\\<And>B.\n                               B \\<in> set Bs \\<Longrightarrow>\n                               Tensor.order B = 1;\n                    is \\<lhd> dims (prod_list Bs)\\<rbrakk>\n                   \\<Longrightarrow> lookup (prod_list Bs) is =\n                                     prod_list\n(map2 (\\<lambda>i B. lookup B [i]) is Bs);\n        \\<And>B. B \\<in> set (a # Bs) \\<Longrightarrow> Tensor.order B = 1;\n        is \\<lhd> dims (prod_list (a # Bs))\\<rbrakk>\n       \\<Longrightarrow> lookup (prod_list (a # Bs)) is =\n                         prod_list\n                          (map2 (\\<lambda>i B. lookup B [i]) is (a # Bs))", "then"], ["proof (chain)\npicking this:\n  ?B \\<in> set [] \\<Longrightarrow> Tensor.order ?B = 1\n  is \\<lhd> dims (prod_list [])", "show ?case"], ["proof (prove)\nusing this:\n  ?B \\<in> set [] \\<Longrightarrow> Tensor.order ?B = 1\n  is \\<lhd> dims (prod_list [])\n\ngoal (1 subgoal):\n 1. lookup (prod_list []) is =\n    prod_list (map2 (\\<lambda>i B. lookup B [i]) is [])", "unfolding \"prod_list.Nil\""], ["proof (prove)\nusing this:\n  ?B \\<in> set [] \\<Longrightarrow> Tensor.order ?B = 1\n  is \\<lhd> dims 1\n\ngoal (1 subgoal):\n 1. lookup 1 is = prod_list (map2 (\\<lambda>i B. lookup B [i]) is [])", "unfolding zip.simps tensor_one_def"], ["proof (prove)\nusing this:\n  ?B \\<in> set [] \\<Longrightarrow> Tensor.order ?B = 1\n  is \\<lhd> dims (tensor_from_vec [] [1::'a])\n\ngoal (1 subgoal):\n 1. lookup (tensor_from_vec [] [1::'a]) is =\n    (\\<Prod>a\\<leftarrow>[]. case a of (i, B) \\<Rightarrow> lookup B [i])", "by (metis (no_types, lifting) dims_tensor_from_lookup length_greater_0_conv length_map prod_list.Nil\n    lookup_tensor_from_lookup tensor_one_def tensor_one_from_lookup)"], ["proof (state)\nthis:\n  lookup (prod_list []) is =\n  prod_list (map2 (\\<lambda>i B. lookup B [i]) is [])\n\ngoal (1 subgoal):\n 1. \\<And>a Bs is.\n       \\<lbrakk>\\<And>is.\n                   \\<lbrakk>\\<And>B.\n                               B \\<in> set Bs \\<Longrightarrow>\n                               Tensor.order B = 1;\n                    is \\<lhd> dims (prod_list Bs)\\<rbrakk>\n                   \\<Longrightarrow> lookup (prod_list Bs) is =\n                                     prod_list\n(map2 (\\<lambda>i B. lookup B [i]) is Bs);\n        \\<And>B. B \\<in> set (a # Bs) \\<Longrightarrow> Tensor.order B = 1;\n        is \\<lhd> dims (prod_list (a # Bs))\\<rbrakk>\n       \\<Longrightarrow> lookup (prod_list (a # Bs)) is =\n                         prod_list\n                          (map2 (\\<lambda>i B. lookup B [i]) is (a # Bs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Bs is.\n       \\<lbrakk>\\<And>is.\n                   \\<lbrakk>\\<And>B.\n                               B \\<in> set Bs \\<Longrightarrow>\n                               Tensor.order B = 1;\n                    is \\<lhd> dims (prod_list Bs)\\<rbrakk>\n                   \\<Longrightarrow> lookup (prod_list Bs) is =\n                                     prod_list\n(map2 (\\<lambda>i B. lookup B [i]) is Bs);\n        \\<And>B. B \\<in> set (a # Bs) \\<Longrightarrow> Tensor.order B = 1;\n        is \\<lhd> dims (prod_list (a # Bs))\\<rbrakk>\n       \\<Longrightarrow> lookup (prod_list (a # Bs)) is =\n                         prod_list\n                          (map2 (\\<lambda>i B. lookup B [i]) is (a # Bs))", "case (Cons B Bs \"is'\")"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>B. B \\<in> set Bs \\<Longrightarrow> Tensor.order B = 1;\n   ?is \\<lhd> dims (prod_list Bs)\\<rbrakk>\n  \\<Longrightarrow> lookup (prod_list Bs) ?is =\n                    prod_list (map2 (\\<lambda>i B. lookup B [i]) ?is Bs)\n  ?B \\<in> set (B # Bs) \\<Longrightarrow> Tensor.order ?B = 1\n  is' \\<lhd> dims (prod_list (B # Bs))\n\ngoal (1 subgoal):\n 1. \\<And>a Bs is.\n       \\<lbrakk>\\<And>is.\n                   \\<lbrakk>\\<And>B.\n                               B \\<in> set Bs \\<Longrightarrow>\n                               Tensor.order B = 1;\n                    is \\<lhd> dims (prod_list Bs)\\<rbrakk>\n                   \\<Longrightarrow> lookup (prod_list Bs) is =\n                                     prod_list\n(map2 (\\<lambda>i B. lookup B [i]) is Bs);\n        \\<And>B. B \\<in> set (a # Bs) \\<Longrightarrow> Tensor.order B = 1;\n        is \\<lhd> dims (prod_list (a # Bs))\\<rbrakk>\n       \\<Longrightarrow> lookup (prod_list (a # Bs)) is =\n                         prod_list\n                          (map2 (\\<lambda>i B. lookup B [i]) is (a # Bs))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>B. B \\<in> set Bs \\<Longrightarrow> Tensor.order B = 1;\n   ?is \\<lhd> dims (prod_list Bs)\\<rbrakk>\n  \\<Longrightarrow> lookup (prod_list Bs) ?is =\n                    prod_list (map2 (\\<lambda>i B. lookup B [i]) ?is Bs)\n  ?B \\<in> set (B # Bs) \\<Longrightarrow> Tensor.order ?B = 1\n  is' \\<lhd> dims (prod_list (B # Bs))", "obtain i \"is\" where \"is' = i # is\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>B. B \\<in> set Bs \\<Longrightarrow> Tensor.order B = 1;\n   ?is \\<lhd> dims (prod_list Bs)\\<rbrakk>\n  \\<Longrightarrow> lookup (prod_list Bs) ?is =\n                    prod_list (map2 (\\<lambda>i B. lookup B [i]) ?is Bs)\n  ?B \\<in> set (B # Bs) \\<Longrightarrow> Tensor.order ?B = 1\n  is' \\<lhd> dims (prod_list (B # Bs))\n\ngoal (1 subgoal):\n 1. (\\<And>i is. is' = i # is \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis append_is_Nil_conv dims_tensor_prod length_0_conv list.set_intros(1) prod_list.Cons valid_index.simps zero_neq_one)"], ["proof (state)\nthis:\n  is' = i # is\n\ngoal (1 subgoal):\n 1. \\<And>a Bs is.\n       \\<lbrakk>\\<And>is.\n                   \\<lbrakk>\\<And>B.\n                               B \\<in> set Bs \\<Longrightarrow>\n                               Tensor.order B = 1;\n                    is \\<lhd> dims (prod_list Bs)\\<rbrakk>\n                   \\<Longrightarrow> lookup (prod_list Bs) is =\n                                     prod_list\n(map2 (\\<lambda>i B. lookup B [i]) is Bs);\n        \\<And>B. B \\<in> set (a # Bs) \\<Longrightarrow> Tensor.order B = 1;\n        is \\<lhd> dims (prod_list (a # Bs))\\<rbrakk>\n       \\<Longrightarrow> lookup (prod_list (a # Bs)) is =\n                         prod_list\n                          (map2 (\\<lambda>i B. lookup B [i]) is (a # Bs))", "have \"Tensor.order B = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Tensor.order B = 1", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>B. B \\<in> set Bs \\<Longrightarrow> Tensor.order B = 1;\n   ?is \\<lhd> dims (prod_list Bs)\\<rbrakk>\n  \\<Longrightarrow> lookup (prod_list Bs) ?is =\n                    prod_list (map2 (\\<lambda>i B. lookup B [i]) ?is Bs)\n  ?B \\<in> set (B # Bs) \\<Longrightarrow> Tensor.order ?B = 1\n  is' \\<lhd> dims (prod_list (B # Bs))\n\ngoal (1 subgoal):\n 1. Tensor.order B = 1", "by auto"], ["proof (state)\nthis:\n  Tensor.order B = 1\n\ngoal (1 subgoal):\n 1. \\<And>a Bs is.\n       \\<lbrakk>\\<And>is.\n                   \\<lbrakk>\\<And>B.\n                               B \\<in> set Bs \\<Longrightarrow>\n                               Tensor.order B = 1;\n                    is \\<lhd> dims (prod_list Bs)\\<rbrakk>\n                   \\<Longrightarrow> lookup (prod_list Bs) is =\n                                     prod_list\n(map2 (\\<lambda>i B. lookup B [i]) is Bs);\n        \\<And>B. B \\<in> set (a # Bs) \\<Longrightarrow> Tensor.order B = 1;\n        is \\<lhd> dims (prod_list (a # Bs))\\<rbrakk>\n       \\<Longrightarrow> lookup (prod_list (a # Bs)) is =\n                         prod_list\n                          (map2 (\\<lambda>i B. lookup B [i]) is (a # Bs))", "then"], ["proof (chain)\npicking this:\n  Tensor.order B = 1", "have valid1:\"[i] \\<lhd> dims B\""], ["proof (prove)\nusing this:\n  Tensor.order B = 1\n\ngoal (1 subgoal):\n 1. [i] \\<lhd> dims B", "using \\<open>is' \\<lhd> dims (prod_list (B # Bs))\\<close>[unfolded prod_list.Cons dims_tensor_prod \\<open>is' = i # is\\<close>]"], ["proof (prove)\nusing this:\n  Tensor.order B = 1\n  i # is \\<lhd> dims B @ dims (prod_list Bs)\n\ngoal (1 subgoal):\n 1. [i] \\<lhd> dims B", "by (metis One_nat_def Suc_length_conv hd_append2 length_0_conv list.sel(1) list.simps(3) valid_index.Nil valid_index.simps)"], ["proof (state)\nthis:\n  [i] \\<lhd> dims B\n\ngoal (1 subgoal):\n 1. \\<And>a Bs is.\n       \\<lbrakk>\\<And>is.\n                   \\<lbrakk>\\<And>B.\n                               B \\<in> set Bs \\<Longrightarrow>\n                               Tensor.order B = 1;\n                    is \\<lhd> dims (prod_list Bs)\\<rbrakk>\n                   \\<Longrightarrow> lookup (prod_list Bs) is =\n                                     prod_list\n(map2 (\\<lambda>i B. lookup B [i]) is Bs);\n        \\<And>B. B \\<in> set (a # Bs) \\<Longrightarrow> Tensor.order B = 1;\n        is \\<lhd> dims (prod_list (a # Bs))\\<rbrakk>\n       \\<Longrightarrow> lookup (prod_list (a # Bs)) is =\n                         prod_list\n                          (map2 (\\<lambda>i B. lookup B [i]) is (a # Bs))", "have valid2:\"is \\<lhd> dims (prod_list Bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is \\<lhd> dims (prod_list Bs)", "using \\<open>is' \\<lhd> dims (prod_list (B # Bs))\\<close>[unfolded prod_list.Cons dims_tensor_prod \\<open>is' = i # is\\<close>] \\<open>Tensor.order B = 1\\<close>"], ["proof (prove)\nusing this:\n  i # is \\<lhd> dims B @ dims (prod_list Bs)\n  Tensor.order B = 1\n\ngoal (1 subgoal):\n 1. is \\<lhd> dims (prod_list Bs)", "by (metis One_nat_def Suc_length_conv append_eq_Cons_conv length_0_conv list.sel(3) list.simps(3) self_append_conv2 valid_indexE)"], ["proof (state)\nthis:\n  is \\<lhd> dims (prod_list Bs)\n\ngoal (1 subgoal):\n 1. \\<And>a Bs is.\n       \\<lbrakk>\\<And>is.\n                   \\<lbrakk>\\<And>B.\n                               B \\<in> set Bs \\<Longrightarrow>\n                               Tensor.order B = 1;\n                    is \\<lhd> dims (prod_list Bs)\\<rbrakk>\n                   \\<Longrightarrow> lookup (prod_list Bs) is =\n                                     prod_list\n(map2 (\\<lambda>i B. lookup B [i]) is Bs);\n        \\<And>B. B \\<in> set (a # Bs) \\<Longrightarrow> Tensor.order B = 1;\n        is \\<lhd> dims (prod_list (a # Bs))\\<rbrakk>\n       \\<Longrightarrow> lookup (prod_list (a # Bs)) is =\n                         prod_list\n                          (map2 (\\<lambda>i B. lookup B [i]) is (a # Bs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (prod_list (B # Bs)) is' =\n    prod_list (map2 (\\<lambda>i B. lookup B [i]) is' (B # Bs))", "unfolding \\<open>is' = i # is\\<close> List.zip_Cons_Cons List.list.map(2) prod_list.Cons\n    lookup_tensor_prod[OF valid1 valid2, simplified]"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup B [i] * lookup (prod_list Bs) is =\n    (case (i, B) of (i, B) \\<Rightarrow> lookup B [i]) *\n    prod_list (map2 (\\<lambda>i B. lookup B [i]) is Bs)", "by (simp add: Cons.IH Cons.prems(1) valid2)"], ["proof (state)\nthis:\n  lookup (prod_list (B # Bs)) is' =\n  prod_list (map2 (\\<lambda>i B. lookup B [i]) is' (B # Bs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matricize_cprank_max1:\nfixes A::\"'a::field tensor\"\nassumes \"cprank_max1 A\"\nshows \"mrank (matricize I A) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mrank (matricize I A) \\<le> 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mrank (matricize I A) \\<le> 1", "obtain Bs a where \"\\<And>B. B \\<in> set Bs \\<Longrightarrow> Tensor.order B = 1\" \"a \\<cdot> prod_list Bs = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Bs a.\n        \\<lbrakk>\\<And>B.\n                    B \\<in> set Bs \\<Longrightarrow> Tensor.order B = 1;\n         a \\<cdot> prod_list Bs = A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cprank_max1_prod_listE assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>cprank_max1 ?A;\n   \\<And>Bs a.\n      \\<lbrakk>\\<And>B. B \\<in> set Bs \\<Longrightarrow> Tensor.order B = 1;\n       a \\<cdot> prod_list Bs = ?A\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  cprank_max1 A\n\ngoal (1 subgoal):\n 1. (\\<And>Bs a.\n        \\<lbrakk>\\<And>B.\n                    B \\<in> set Bs \\<Longrightarrow> Tensor.order B = 1;\n         a \\<cdot> prod_list Bs = A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  ?B \\<in> set Bs \\<Longrightarrow> Tensor.order ?B = 1\n  a \\<cdot> prod_list Bs = A\n\ngoal (1 subgoal):\n 1. mrank (matricize I A) \\<le> 1", "define row_factor\n    where \"row_factor ris = a * prod_list (map (\\<lambda>(i,B). lookup B [i]) (zip ris (nths Bs I)))\"\n    for ris"], ["proof (state)\nthis:\n  row_factor ?ris =\n  a * prod_list (map2 (\\<lambda>i B. lookup B [i]) ?ris (nths Bs I))\n\ngoal (1 subgoal):\n 1. mrank (matricize I A) \\<le> 1", "define col_factor\n    where \"col_factor cis = prod_list (map (\\<lambda>(i,B). lookup B [i]) (zip cis (nths Bs (-I))))\"\n    for cis"], ["proof (state)\nthis:\n  col_factor ?cis =\n  prod_list (map2 (\\<lambda>i B. lookup B [i]) ?cis (nths Bs (- I)))\n\ngoal (1 subgoal):\n 1. mrank (matricize I A) \\<le> 1", "have \"\\<And>is. is \\<lhd> dims A \\<Longrightarrow> lookup A is = row_factor (nths is I) * col_factor (nths is (-I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims A \\<Longrightarrow>\n       lookup A is = row_factor (nths is I) * col_factor (nths is (- I))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims A \\<Longrightarrow>\n       lookup A is = row_factor (nths is I) * col_factor (nths is (- I))", "fix \"is\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims A \\<Longrightarrow>\n       lookup A is = row_factor (nths is I) * col_factor (nths is (- I))", "assume \"is \\<lhd> dims A\""], ["proof (state)\nthis:\n  is \\<lhd> dims A\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims A \\<Longrightarrow>\n       lookup A is = row_factor (nths is I) * col_factor (nths is (- I))", "then"], ["proof (chain)\npicking this:\n  is \\<lhd> dims A", "have \"lookup A is = a * (prod_list (map (\\<lambda>(i,B). lookup B [i]) (zip is Bs)))\""], ["proof (prove)\nusing this:\n  is \\<lhd> dims A\n\ngoal (1 subgoal):\n 1. lookup A is = a * prod_list (map2 (\\<lambda>i B. lookup B [i]) is Bs)", "using lookup_order1_prod[OF \\<open>\\<And>B. B \\<in> set Bs \\<Longrightarrow> Tensor.order B = 1\\<close>] lookup_smult"], ["proof (prove)\nusing this:\n  is \\<lhd> dims A\n  \\<lbrakk>\\<And>B. B \\<in> set ?Bs \\<Longrightarrow> B \\<in> set Bs;\n   ?is \\<lhd> dims (prod_list ?Bs)\\<rbrakk>\n  \\<Longrightarrow> lookup (prod_list ?Bs) ?is =\n                    prod_list (map2 (\\<lambda>i B. lookup B [i]) ?is ?Bs)\n  ?is \\<lhd> dims ?A \\<Longrightarrow>\n  lookup (?\\<alpha> \\<cdot> ?A) ?is = ?\\<alpha> * lookup ?A ?is\n\ngoal (1 subgoal):\n 1. lookup A is = a * prod_list (map2 (\\<lambda>i B. lookup B [i]) is Bs)", "using \\<open>a \\<cdot> prod_list Bs = A\\<close> dims_smult"], ["proof (prove)\nusing this:\n  is \\<lhd> dims A\n  \\<lbrakk>\\<And>B. B \\<in> set ?Bs \\<Longrightarrow> B \\<in> set Bs;\n   ?is \\<lhd> dims (prod_list ?Bs)\\<rbrakk>\n  \\<Longrightarrow> lookup (prod_list ?Bs) ?is =\n                    prod_list (map2 (\\<lambda>i B. lookup B [i]) ?is ?Bs)\n  ?is \\<lhd> dims ?A \\<Longrightarrow>\n  lookup (?\\<alpha> \\<cdot> ?A) ?is = ?\\<alpha> * lookup ?A ?is\n  a \\<cdot> prod_list Bs = A\n  dims (?\\<alpha> \\<cdot> ?A) = dims ?A\n\ngoal (1 subgoal):\n 1. lookup A is = a * prod_list (map2 (\\<lambda>i B. lookup B [i]) is Bs)", "by fastforce"], ["proof (state)\nthis:\n  lookup A is = a * prod_list (map2 (\\<lambda>i B. lookup B [i]) is Bs)\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims A \\<Longrightarrow>\n       lookup A is = row_factor (nths is I) * col_factor (nths is (- I))", "also"], ["proof (state)\nthis:\n  lookup A is = a * prod_list (map2 (\\<lambda>i B. lookup B [i]) is Bs)\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims A \\<Longrightarrow>\n       lookup A is = row_factor (nths is I) * col_factor (nths is (- I))", "have \"... = a * (prod_list (map (\\<lambda>(i,B). lookup B [i]) (nths (zip is Bs) I))) *\n                         (prod_list (map (\\<lambda>(i,B). lookup B [i]) (nths (zip is Bs) (-I))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * prod_list (map2 (\\<lambda>i B. lookup B [i]) is Bs) =\n    a * (\\<Prod>(i, B)\\<leftarrow>nths (zip is Bs) I. lookup B [i]) *\n    (\\<Prod>(i, B)\\<leftarrow>nths (zip is Bs) (- I). lookup B [i])", "using prod_list_complementary_nthss"], ["proof (prove)\nusing this:\n  prod_list (map ?f ?xs) =\n  prod_list (map ?f (nths ?xs ?A)) * prod_list (map ?f (nths ?xs (- ?A)))\n\ngoal (1 subgoal):\n 1. a * prod_list (map2 (\\<lambda>i B. lookup B [i]) is Bs) =\n    a * (\\<Prod>(i, B)\\<leftarrow>nths (zip is Bs) I. lookup B [i]) *\n    (\\<Prod>(i, B)\\<leftarrow>nths (zip is Bs) (- I). lookup B [i])", "by auto"], ["proof (state)\nthis:\n  a * prod_list (map2 (\\<lambda>i B. lookup B [i]) is Bs) =\n  a * (\\<Prod>(i, B)\\<leftarrow>nths (zip is Bs) I. lookup B [i]) *\n  (\\<Prod>(i, B)\\<leftarrow>nths (zip is Bs) (- I). lookup B [i])\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims A \\<Longrightarrow>\n       lookup A is = row_factor (nths is I) * col_factor (nths is (- I))", "also"], ["proof (state)\nthis:\n  a * prod_list (map2 (\\<lambda>i B. lookup B [i]) is Bs) =\n  a * (\\<Prod>(i, B)\\<leftarrow>nths (zip is Bs) I. lookup B [i]) *\n  (\\<Prod>(i, B)\\<leftarrow>nths (zip is Bs) (- I). lookup B [i])\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims A \\<Longrightarrow>\n       lookup A is = row_factor (nths is I) * col_factor (nths is (- I))", "have \"... = row_factor (nths is I) * col_factor (nths is (-I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * (\\<Prod>(i, B)\\<leftarrow>nths (zip is Bs) I. lookup B [i]) *\n    (\\<Prod>(i, B)\\<leftarrow>nths (zip is Bs) (- I). lookup B [i]) =\n    row_factor (nths is I) * col_factor (nths is (- I))", "using nths_zip row_factor_def col_factor_def"], ["proof (prove)\nusing this:\n  nths (zip ?xs ?ys) ?I = zip (nths ?xs ?I) (nths ?ys ?I)\n  row_factor ?ris =\n  a * prod_list (map2 (\\<lambda>i B. lookup B [i]) ?ris (nths Bs I))\n  col_factor ?cis =\n  prod_list (map2 (\\<lambda>i B. lookup B [i]) ?cis (nths Bs (- I)))\n\ngoal (1 subgoal):\n 1. a * (\\<Prod>(i, B)\\<leftarrow>nths (zip is Bs) I. lookup B [i]) *\n    (\\<Prod>(i, B)\\<leftarrow>nths (zip is Bs) (- I). lookup B [i]) =\n    row_factor (nths is I) * col_factor (nths is (- I))", "by metis"], ["proof (state)\nthis:\n  a * (\\<Prod>(i, B)\\<leftarrow>nths (zip is Bs) I. lookup B [i]) *\n  (\\<Prod>(i, B)\\<leftarrow>nths (zip is Bs) (- I). lookup B [i]) =\n  row_factor (nths is I) * col_factor (nths is (- I))\n\ngoal (1 subgoal):\n 1. \\<And>is.\n       is \\<lhd> dims A \\<Longrightarrow>\n       lookup A is = row_factor (nths is I) * col_factor (nths is (- I))", "finally"], ["proof (chain)\npicking this:\n  lookup A is = row_factor (nths is I) * col_factor (nths is (- I))", "show \"lookup A is = row_factor (nths is I) * col_factor (nths is (-I))\""], ["proof (prove)\nusing this:\n  lookup A is = row_factor (nths is I) * col_factor (nths is (- I))\n\ngoal (1 subgoal):\n 1. lookup A is = row_factor (nths is I) * col_factor (nths is (- I))", "."], ["proof (state)\nthis:\n  lookup A is = row_factor (nths is I) * col_factor (nths is (- I))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?is \\<lhd> dims A \\<Longrightarrow>\n  lookup A ?is = row_factor (nths ?is I) * col_factor (nths ?is (- I))\n\ngoal (1 subgoal):\n 1. mrank (matricize I A) \\<le> 1", "define row_factor'\n    where \"row_factor' r = row_factor (digit_encode (nths (Tensor.dims A) I) r)\" for r"], ["proof (state)\nthis:\n  row_factor' ?r = row_factor (digit_encode (nths (dims A) I) ?r)\n\ngoal (1 subgoal):\n 1. mrank (matricize I A) \\<le> 1", "define col_factor'\n    where \"col_factor' c = col_factor (digit_encode (nths (Tensor.dims A) (-I)) c)\" for c"], ["proof (state)\nthis:\n  col_factor' ?c = col_factor (digit_encode (nths (dims A) (- I)) ?c)\n\ngoal (1 subgoal):\n 1. mrank (matricize I A) \\<le> 1", "have \"\\<And>r c. r<dim_row (matricize I A) \\<Longrightarrow> c<dim_col (matricize I A) \\<Longrightarrow> matricize I A $$ (r,c) = row_factor' r * col_factor' c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r c.\n       \\<lbrakk>r < dim_row (matricize I A);\n        c < dim_col (matricize I A)\\<rbrakk>\n       \\<Longrightarrow> matricize I A $$ (r, c) =\n                         row_factor' r * col_factor' c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r c.\n       \\<lbrakk>r < dim_row (matricize I A);\n        c < dim_col (matricize I A)\\<rbrakk>\n       \\<Longrightarrow> matricize I A $$ (r, c) =\n                         row_factor' r * col_factor' c", "fix r c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r c.\n       \\<lbrakk>r < dim_row (matricize I A);\n        c < dim_col (matricize I A)\\<rbrakk>\n       \\<Longrightarrow> matricize I A $$ (r, c) =\n                         row_factor' r * col_factor' c", "assume \"r<dim_row (matricize I A)\" \"c<dim_col (matricize I A)\""], ["proof (state)\nthis:\n  r < dim_row (matricize I A)\n  c < dim_col (matricize I A)\n\ngoal (1 subgoal):\n 1. \\<And>r c.\n       \\<lbrakk>r < dim_row (matricize I A);\n        c < dim_col (matricize I A)\\<rbrakk>\n       \\<Longrightarrow> matricize I A $$ (r, c) =\n                         row_factor' r * col_factor' c", "then"], ["proof (chain)\npicking this:\n  r < dim_row (matricize I A)\n  c < dim_col (matricize I A)", "have \"matricize I A $$ (r,c) = Tensor.lookup A (weave I\n      (digit_encode (nths (Tensor.dims A) I) r)\n      (digit_encode (nths (Tensor.dims A) (-I)) c)\n    )\""], ["proof (prove)\nusing this:\n  r < dim_row (matricize I A)\n  c < dim_col (matricize I A)\n\ngoal (1 subgoal):\n 1. matricize I A $$ (r, c) =\n    lookup A\n     (weave I (digit_encode (nths (dims A) I) r)\n       (digit_encode (nths (dims A) (- I)) c))", "unfolding dims_matricize"], ["proof (prove)\nusing this:\n  r < prod_list (nths (dims A) I)\n  c < prod_list (nths (dims A) (- I))\n\ngoal (1 subgoal):\n 1. matricize I A $$ (r, c) =\n    lookup A\n     (weave I (digit_encode (nths (dims A) I) r)\n       (digit_encode (nths (dims A) (- I)) c))", "unfolding matricize_def"], ["proof (prove)\nusing this:\n  r < prod_list (nths (dims A) I)\n  c < prod_list (nths (dims A) (- I))\n\ngoal (1 subgoal):\n 1. mat (prod_list (nths (dims A) I)) (prod_list (nths (dims A) (- I)))\n     (\\<lambda>(r, c).\n         lookup A\n          (weave I (digit_encode (nths (dims A) I) r)\n            (digit_encode (nths (dims A) (- I)) c))) $$\n    (r, c) =\n    lookup A\n     (weave I (digit_encode (nths (dims A) I) r)\n       (digit_encode (nths (dims A) (- I)) c))", "by simp"], ["proof (state)\nthis:\n  matricize I A $$ (r, c) =\n  lookup A\n   (weave I (digit_encode (nths (dims A) I) r)\n     (digit_encode (nths (dims A) (- I)) c))\n\ngoal (1 subgoal):\n 1. \\<And>r c.\n       \\<lbrakk>r < dim_row (matricize I A);\n        c < dim_col (matricize I A)\\<rbrakk>\n       \\<Longrightarrow> matricize I A $$ (r, c) =\n                         row_factor' r * col_factor' c", "also"], ["proof (state)\nthis:\n  matricize I A $$ (r, c) =\n  lookup A\n   (weave I (digit_encode (nths (dims A) I) r)\n     (digit_encode (nths (dims A) (- I)) c))\n\ngoal (1 subgoal):\n 1. \\<And>r c.\n       \\<lbrakk>r < dim_row (matricize I A);\n        c < dim_col (matricize I A)\\<rbrakk>\n       \\<Longrightarrow> matricize I A $$ (r, c) =\n                         row_factor' r * col_factor' c", "have \"... = row_factor' r * col_factor' c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup A\n     (weave I (digit_encode (nths (dims A) I) r)\n       (digit_encode (nths (dims A) (- I)) c)) =\n    row_factor' r * col_factor' c", "using  \\<open>\\<And>is. is \\<lhd> dims A \\<Longrightarrow> lookup A is = row_factor (nths is I) * col_factor (nths is (- I))\\<close>\n      valid_index_weave[OF\n      digit_encode_valid_index[OF \\<open>r < dim_row (matricize I A)\\<close>[unfolded dims_matricize]]\n      digit_encode_valid_index[OF \\<open>c < dim_col (matricize I A)\\<close>[unfolded dims_matricize]]]\n      valid_index_weave(2) valid_index_weave(3) row_factor'_def col_factor'_def"], ["proof (prove)\nusing this:\n  ?is \\<lhd> dims A \\<Longrightarrow>\n  lookup A ?is = row_factor (nths ?is I) * col_factor (nths ?is (- I))\n  weave I (digit_encode (nths (dims A) I) r)\n   (digit_encode (nths (dims A) (- I)) c) \\<lhd>\n  dims A\n  nths\n   (weave I (digit_encode (nths (dims A) I) r)\n     (digit_encode (nths (dims A) (- I)) c))\n   I =\n  digit_encode (nths (dims A) I) r\n  nths\n   (weave I (digit_encode (nths (dims A) I) r)\n     (digit_encode (nths (dims A) (- I)) c))\n   (- I) =\n  digit_encode (nths (dims A) (- I)) c\n  \\<lbrakk>?is1.0 \\<lhd> nths ?ds ?A; ?is2.0 \\<lhd> nths ?ds (- ?A)\\<rbrakk>\n  \\<Longrightarrow> nths (weave ?A ?is1.0 ?is2.0) ?A = ?is1.0\n  \\<lbrakk>?is1.0 \\<lhd> nths ?ds ?A; ?is2.0 \\<lhd> nths ?ds (- ?A)\\<rbrakk>\n  \\<Longrightarrow> nths (weave ?A ?is1.0 ?is2.0) (- ?A) = ?is2.0\n  row_factor' ?r = row_factor (digit_encode (nths (dims A) I) ?r)\n  col_factor' ?c = col_factor (digit_encode (nths (dims A) (- I)) ?c)\n\ngoal (1 subgoal):\n 1. lookup A\n     (weave I (digit_encode (nths (dims A) I) r)\n       (digit_encode (nths (dims A) (- I)) c)) =\n    row_factor' r * col_factor' c", "by metis"], ["proof (state)\nthis:\n  lookup A\n   (weave I (digit_encode (nths (dims A) I) r)\n     (digit_encode (nths (dims A) (- I)) c)) =\n  row_factor' r * col_factor' c\n\ngoal (1 subgoal):\n 1. \\<And>r c.\n       \\<lbrakk>r < dim_row (matricize I A);\n        c < dim_col (matricize I A)\\<rbrakk>\n       \\<Longrightarrow> matricize I A $$ (r, c) =\n                         row_factor' r * col_factor' c", "finally"], ["proof (chain)\npicking this:\n  matricize I A $$ (r, c) = row_factor' r * col_factor' c", "show \"matricize I A $$ (r,c) = row_factor' r * col_factor' c\""], ["proof (prove)\nusing this:\n  matricize I A $$ (r, c) = row_factor' r * col_factor' c\n\ngoal (1 subgoal):\n 1. matricize I A $$ (r, c) = row_factor' r * col_factor' c", "."], ["proof (state)\nthis:\n  matricize I A $$ (r, c) = row_factor' r * col_factor' c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?r < dim_row (matricize I A);\n   ?c < dim_col (matricize I A)\\<rbrakk>\n  \\<Longrightarrow> matricize I A $$ (?r, ?c) =\n                    row_factor' ?r * col_factor' ?c\n\ngoal (1 subgoal):\n 1. mrank (matricize I A) \\<le> 1", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?r < dim_row (matricize I A);\n   ?c < dim_col (matricize I A)\\<rbrakk>\n  \\<Longrightarrow> matricize I A $$ (?r, ?c) =\n                    row_factor' ?r * col_factor' ?c", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?r < dim_row (matricize I A);\n   ?c < dim_col (matricize I A)\\<rbrakk>\n  \\<Longrightarrow> matricize I A $$ (?r, ?c) =\n                    row_factor' ?r * col_factor' ?c\n\ngoal (1 subgoal):\n 1. mrank (matricize I A) \\<le> 1", "using vec_space.rank_le_1_product_entries[of \"matricize I A\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?r < dim_row (matricize I A);\n   ?c < dim_col (matricize I A)\\<rbrakk>\n  \\<Longrightarrow> matricize I A $$ (?r, ?c) =\n                    row_factor' ?r * col_factor' ?c\n  \\<lbrakk>matricize I A \\<in> carrier_mat ?n ?nc;\n   \\<And>r c.\n      \\<lbrakk>r < dim_row (matricize I A);\n       c < dim_col (matricize I A)\\<rbrakk>\n      \\<Longrightarrow> matricize I A $$ (r, c) = ?f r * ?g c\\<rbrakk>\n  \\<Longrightarrow> vec_space.rank ?n (matricize I A) \\<le> 1\n\ngoal (1 subgoal):\n 1. mrank (matricize I A) \\<le> 1", "by blast"], ["proof (state)\nthis:\n  mrank (matricize I A) \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_rank_le_cprank_max:\nfixes A :: \"('a::field) tensor\"\nassumes \"cprank_max r A\"\nshows \"mrank (matricize I A) \\<le> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mrank (matricize I A) \\<le> r", "using assms"], ["proof (prove)\nusing this:\n  cprank_max r A\n\ngoal (1 subgoal):\n 1. mrank (matricize I A) \\<le> r", "proof (induction rule:cprank_max.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ds. mrank (matricize I (tensor0 ds)) \\<le> 0\n 2. \\<And>A B j.\n       \\<lbrakk>dims A = dims B; cprank_max1 A; cprank_max j B;\n        mrank (matricize I B) \\<le> j\\<rbrakk>\n       \\<Longrightarrow> mrank (matricize I (A + B)) \\<le> Suc j", "fix ds :: \"nat list\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ds. mrank (matricize I (tensor0 ds)) \\<le> 0\n 2. \\<And>A B j.\n       \\<lbrakk>dims A = dims B; cprank_max1 A; cprank_max j B;\n        mrank (matricize I B) \\<le> j\\<rbrakk>\n       \\<Longrightarrow> mrank (matricize I (A + B)) \\<le> Suc j", "have \"matricize I (tensor0 ds) = 0\\<^sub>m (dim_row (matricize I (tensor0 ds))) (dim_col (matricize I (tensor0 ds)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matricize I (tensor0 ds) =\n    0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n     (dim_col (matricize I (tensor0 ds)))", "using matricize_0"], ["proof (prove)\nusing this:\n  matricize ?I (tensor0 ?ds) =\n  0\\<^sub>m (dim_row (matricize ?I (tensor0 ?ds)))\n   (dim_col (matricize ?I (tensor0 ?ds)))\n\ngoal (1 subgoal):\n 1. matricize I (tensor0 ds) =\n    0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n     (dim_col (matricize I (tensor0 ds)))", "by auto"], ["proof (state)\nthis:\n  matricize I (tensor0 ds) =\n  0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n   (dim_col (matricize I (tensor0 ds)))\n\ngoal (2 subgoals):\n 1. \\<And>ds. mrank (matricize I (tensor0 ds)) \\<le> 0\n 2. \\<And>A B j.\n       \\<lbrakk>dims A = dims B; cprank_max1 A; cprank_max j B;\n        mrank (matricize I B) \\<le> j\\<rbrakk>\n       \\<Longrightarrow> mrank (matricize I (A + B)) \\<le> Suc j", "then"], ["proof (chain)\npicking this:\n  matricize I (tensor0 ds) =\n  0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n   (dim_col (matricize I (tensor0 ds)))", "show \"mrank (matricize I (tensor0 ds)) \\<le> 0\""], ["proof (prove)\nusing this:\n  matricize I (tensor0 ds) =\n  0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n   (dim_col (matricize I (tensor0 ds)))\n\ngoal (1 subgoal):\n 1. mrank (matricize I (tensor0 ds)) \\<le> 0", "using eq_imp_le vec_space.rank_0I"], ["proof (prove)\nusing this:\n  matricize I (tensor0 ds) =\n  0\\<^sub>m (dim_row (matricize I (tensor0 ds)))\n   (dim_col (matricize I (tensor0 ds)))\n  ?m = ?n \\<Longrightarrow> ?m \\<le> ?n\n  vec_space.rank ?n (0\\<^sub>m ?n ?nc) = 0\n\ngoal (1 subgoal):\n 1. mrank (matricize I (tensor0 ds)) \\<le> 0", "by metis"], ["proof (state)\nthis:\n  mrank (matricize I (tensor0 ds)) \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<And>A B j.\n       \\<lbrakk>dims A = dims B; cprank_max1 A; cprank_max j B;\n        mrank (matricize I B) \\<le> j\\<rbrakk>\n       \\<Longrightarrow> mrank (matricize I (A + B)) \\<le> Suc j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B j.\n       \\<lbrakk>dims A = dims B; cprank_max1 A; cprank_max j B;\n        mrank (matricize I B) \\<le> j\\<rbrakk>\n       \\<Longrightarrow> mrank (matricize I (A + B)) \\<le> Suc j", "fix A B::\"'a tensor\" and j::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A B j.\n       \\<lbrakk>dims A = dims B; cprank_max1 A; cprank_max j B;\n        mrank (matricize I B) \\<le> j\\<rbrakk>\n       \\<Longrightarrow> mrank (matricize I (A + B)) \\<le> Suc j", "assume \"dims A = dims B\""], ["proof (state)\nthis:\n  dims A = dims B\n\ngoal (1 subgoal):\n 1. \\<And>A B j.\n       \\<lbrakk>dims A = dims B; cprank_max1 A; cprank_max j B;\n        mrank (matricize I B) \\<le> j\\<rbrakk>\n       \\<Longrightarrow> mrank (matricize I (A + B)) \\<le> Suc j", "assume \"cprank_max1 A\""], ["proof (state)\nthis:\n  cprank_max1 A\n\ngoal (1 subgoal):\n 1. \\<And>A B j.\n       \\<lbrakk>dims A = dims B; cprank_max1 A; cprank_max j B;\n        mrank (matricize I B) \\<le> j\\<rbrakk>\n       \\<Longrightarrow> mrank (matricize I (A + B)) \\<le> Suc j", "assume \"mrank (matricize I B) \\<le> j\""], ["proof (state)\nthis:\n  mrank (matricize I B) \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>A B j.\n       \\<lbrakk>dims A = dims B; cprank_max1 A; cprank_max j B;\n        mrank (matricize I B) \\<le> j\\<rbrakk>\n       \\<Longrightarrow> mrank (matricize I (A + B)) \\<le> Suc j", "have \"mrank (matricize I A) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mrank (matricize I A) \\<le> 1", "using \\<open>cprank_max1 A\\<close> matricize_cprank_max1"], ["proof (prove)\nusing this:\n  cprank_max1 A\n  cprank_max1 ?A \\<Longrightarrow> mrank (matricize ?I ?A) \\<le> 1\n\ngoal (1 subgoal):\n 1. mrank (matricize I A) \\<le> 1", "by auto"], ["proof (state)\nthis:\n  mrank (matricize I A) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>A B j.\n       \\<lbrakk>dims A = dims B; cprank_max1 A; cprank_max j B;\n        mrank (matricize I B) \\<le> j\\<rbrakk>\n       \\<Longrightarrow> mrank (matricize I (A + B)) \\<le> Suc j", "have \"mrank (matricize I (A + B)) \\<le> mrank (matricize I A) + mrank (matricize I B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mrank (matricize I (A + B))\n    \\<le> mrank (matricize I A) + mrank (matricize I B)", "using matricize_add vec_space.rank_subadditive dims_matricize\n    carrier_matI index_add_mat(2) \\<open>dims A = dims B\\<close>"], ["proof (prove)\nusing this:\n  dims ?A = dims ?B \\<Longrightarrow>\n  matricize ?I ?A + matricize ?I ?B = matricize ?I (?A + ?B)\n  \\<lbrakk>?A \\<in> carrier_mat ?n ?nc; ?B \\<in> carrier_mat ?n ?nc\\<rbrakk>\n  \\<Longrightarrow> vec_space.rank ?n (?A + ?B)\n                    \\<le> vec_space.rank ?n ?A + vec_space.rank ?n ?B\n  dim_row (matricize ?rmodes ?T) = prod_list (nths (dims ?T) ?rmodes)\n  dim_col (matricize ?rmodes ?T) = prod_list (nths (dims ?T) (- ?rmodes))\n  \\<lbrakk>dim_row ?A = ?nr; dim_col ?A = ?nc\\<rbrakk>\n  \\<Longrightarrow> ?A \\<in> carrier_mat ?nr ?nc\n  dim_row (?A + ?B) = dim_row ?B\n  dims A = dims B\n\ngoal (1 subgoal):\n 1. mrank (matricize I (A + B))\n    \\<le> mrank (matricize I A) + mrank (matricize I B)", "by metis"], ["proof (state)\nthis:\n  mrank (matricize I (A + B))\n  \\<le> mrank (matricize I A) + mrank (matricize I B)\n\ngoal (1 subgoal):\n 1. \\<And>A B j.\n       \\<lbrakk>dims A = dims B; cprank_max1 A; cprank_max j B;\n        mrank (matricize I B) \\<le> j\\<rbrakk>\n       \\<Longrightarrow> mrank (matricize I (A + B)) \\<le> Suc j", "then"], ["proof (chain)\npicking this:\n  mrank (matricize I (A + B))\n  \\<le> mrank (matricize I A) + mrank (matricize I B)", "show \"mrank (matricize I (A + B)) \\<le> Suc j\""], ["proof (prove)\nusing this:\n  mrank (matricize I (A + B))\n  \\<le> mrank (matricize I A) + mrank (matricize I B)\n\ngoal (1 subgoal):\n 1. mrank (matricize I (A + B)) \\<le> Suc j", "using \\<open>mrank (matricize I A) \\<le> 1\\<close> \\<open>mrank (matricize I B) \\<le> j\\<close>"], ["proof (prove)\nusing this:\n  mrank (matricize I (A + B))\n  \\<le> mrank (matricize I A) + mrank (matricize I B)\n  mrank (matricize I A) \\<le> 1\n  mrank (matricize I B) \\<le> j\n\ngoal (1 subgoal):\n 1. mrank (matricize I (A + B)) \\<le> Suc j", "by linarith"], ["proof (state)\nthis:\n  mrank (matricize I (A + B)) \\<le> Suc j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_rank_le_cp_rank:\nfixes A :: \"('a::field) tensor\"\nshows \"mrank (matricize I A) \\<le> cprank A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mrank (matricize I A) \\<le> cprank A", "using matrix_rank_le_cprank_max"], ["proof (prove)\nusing this:\n  cprank_max ?r ?A \\<Longrightarrow> mrank (matricize ?I ?A) \\<le> ?r\n\ngoal (1 subgoal):\n 1. mrank (matricize I A) \\<le> cprank A", "using cprank_max_cprank"], ["proof (prove)\nusing this:\n  cprank_max ?r ?A \\<Longrightarrow> mrank (matricize ?I ?A) \\<le> ?r\n  cprank_max (cprank ?A) ?A\n\ngoal (1 subgoal):\n 1. mrank (matricize I A) \\<le> cprank A", "by auto"], ["", "end"]]}